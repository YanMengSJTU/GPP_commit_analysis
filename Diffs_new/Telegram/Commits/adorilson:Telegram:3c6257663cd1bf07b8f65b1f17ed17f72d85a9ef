diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/Animator10.java b/TMessagesProj/src/main/java/org/telegram/messenger/Animation/Animator10.java
deleted file mode 100644
index 6defed840..000000000
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/Animator10.java
+++ /dev/null
@@ -1,191 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.telegram.messenger.Animation;
-
-import android.view.animation.Interpolator;
-
-import java.util.ArrayList;
-
-public abstract class Animator10 implements Cloneable {
-
-    ArrayList<AnimatorListener> mListeners = null;
-    ArrayList<AnimatorPauseListener> mPauseListeners = null;
-    boolean mPaused = false;
-
-    public abstract long getStartDelay();
-
-    public abstract void setStartDelay(long startDelay);
-
-    public abstract Animator10 setDuration(long duration);
-
-    public abstract long getDuration();
-
-    public abstract void setInterpolator(Interpolator value);
-
-    public abstract boolean isRunning();
-
-    public void start() {
-
-    }
-
-    public void cancel() {
-
-    }
-
-    public void end() {
-
-    }
-
-    @SuppressWarnings("unchecked")
-    public void pause() {
-        if (isStarted() && !mPaused) {
-            mPaused = true;
-            if (mPauseListeners != null) {
-                ArrayList<AnimatorPauseListener> tmpListeners = (ArrayList<AnimatorPauseListener>) mPauseListeners.clone();
-                int numListeners = tmpListeners.size();
-                for (AnimatorPauseListener tmpListener : tmpListeners) {
-                    tmpListener.onAnimationPause(this);
-                }
-            }
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    public void resume() {
-        if (mPaused) {
-            mPaused = false;
-            if (mPauseListeners != null) {
-                ArrayList<AnimatorPauseListener> tmpListeners = (ArrayList<AnimatorPauseListener>) mPauseListeners.clone();
-                int numListeners = tmpListeners.size();
-                for (AnimatorPauseListener tmpListener : tmpListeners) {
-                    tmpListener.onAnimationResume(this);
-                }
-            }
-        }
-    }
-
-    public boolean isPaused() {
-        return mPaused;
-    }
-
-    public boolean isStarted() {
-        return isRunning();
-    }
-
-    public Interpolator getInterpolator() {
-        return null;
-    }
-
-    public void addListener(AnimatorListener listener) {
-        if (mListeners == null) {
-            mListeners = new ArrayList<AnimatorListener>();
-        }
-        mListeners.add(listener);
-    }
-
-    public void removeListener(AnimatorListener listener) {
-        if (mListeners == null) {
-            return;
-        }
-        mListeners.remove(listener);
-        if (mListeners.size() == 0) {
-            mListeners = null;
-        }
-    }
-
-    public ArrayList<AnimatorListener> getListeners() {
-        return mListeners;
-    }
-
-    public void addPauseListener(AnimatorPauseListener listener) {
-        if (mPauseListeners == null) {
-            mPauseListeners = new ArrayList<AnimatorPauseListener>();
-        }
-        mPauseListeners.add(listener);
-    }
-
-    public void removePauseListener(AnimatorPauseListener listener) {
-        if (mPauseListeners == null) {
-            return;
-        }
-        mPauseListeners.remove(listener);
-        if (mPauseListeners.size() == 0) {
-            mPauseListeners = null;
-        }
-    }
-
-    public void removeAllListeners() {
-        if (mListeners != null) {
-            mListeners.clear();
-            mListeners = null;
-        }
-        if (mPauseListeners != null) {
-            mPauseListeners.clear();
-            mPauseListeners = null;
-        }
-    }
-
-    @Override
-    public Animator10 clone() {
-        try {
-            final Animator10 anim = (Animator10) super.clone();
-            if (mListeners != null) {
-                ArrayList<AnimatorListener> oldListeners = mListeners;
-                anim.mListeners = new ArrayList<AnimatorListener>();
-                int numListeners = oldListeners.size();
-                for (AnimatorListener oldListener : oldListeners) {
-                    anim.mListeners.add(oldListener);
-                }
-            }
-            if (mPauseListeners != null) {
-                ArrayList<AnimatorPauseListener> oldListeners = mPauseListeners;
-                anim.mPauseListeners = new ArrayList<AnimatorPauseListener>();
-                int numListeners = oldListeners.size();
-                for (AnimatorPauseListener oldListener : oldListeners) {
-                    anim.mPauseListeners.add(oldListener);
-                }
-            }
-            return anim;
-        } catch (CloneNotSupportedException e) {
-            throw new AssertionError();
-        }
-    }
-
-    public void setupStartValues() {
-
-    }
-
-    public void setupEndValues() {
-
-    }
-
-    public void setTarget(Object target) {
-
-    }
-
-    public interface AnimatorListener {
-        void onAnimationStart(Animator10 animation);
-        void onAnimationEnd(Animator10 animation);
-        void onAnimationCancel(Animator10 animation);
-        void onAnimationRepeat(Animator10 animation);
-    }
-
-    public interface AnimatorPauseListener {
-        void onAnimationPause(Animator10 animation);
-        void onAnimationResume(Animator10 animation);
-    }
-}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/AnimatorListenerAdapter10.java b/TMessagesProj/src/main/java/org/telegram/messenger/Animation/AnimatorListenerAdapter10.java
deleted file mode 100644
index f5aefe9a8..000000000
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/AnimatorListenerAdapter10.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.telegram.messenger.Animation;
-
-public abstract class AnimatorListenerAdapter10 implements Animator10.AnimatorListener, Animator10.AnimatorPauseListener {
-
-    @Override
-    public void onAnimationCancel(Animator10 animation) {
-
-    }
-
-    @Override
-    public void onAnimationEnd(Animator10 animation) {
-
-    }
-
-    @Override
-    public void onAnimationRepeat(Animator10 animation) {
-
-    }
-
-    @Override
-    public void onAnimationStart(Animator10 animation) {
-
-    }
-
-    @Override
-    public void onAnimationPause(Animator10 animation) {
-
-    }
-
-    @Override
-    public void onAnimationResume(Animator10 animation) {
-
-    }
-}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/AnimatorSet10.java b/TMessagesProj/src/main/java/org/telegram/messenger/Animation/AnimatorSet10.java
deleted file mode 100644
index 2f749f2f0..000000000
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/AnimatorSet10.java
+++ /dev/null
@@ -1,705 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.telegram.messenger.Animation;
-
-import android.view.animation.Interpolator;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
-
-public final class AnimatorSet10 extends Animator10 {
-
-    private ArrayList<Animator10> mPlayingSet = new ArrayList<>();
-    private HashMap<Animator10, Node> mNodeMap = new HashMap<>();
-    private ArrayList<Node> mNodes = new ArrayList<>();
-    private ArrayList<Node> mSortedNodes = new ArrayList<>();
-    private boolean mNeedsSort = true;
-    private AnimatorSetListener mSetListener = null;
-    boolean mTerminated = false;
-    private boolean mStarted = false;
-    private long mStartDelay = 0;
-    private ValueAnimator mDelayAnim = null;
-    private long mDuration = -1;
-    private Interpolator mInterpolator = null;
-
-    public void playTogether(Animator10... items) {
-        if (items != null) {
-            mNeedsSort = true;
-            Builder builder = play(items[0]);
-            for (int i = 1; i < items.length; ++i) {
-                builder.with(items[i]);
-            }
-        }
-    }
-
-    public void playTogether(Collection<Animator10> items) {
-        if (items != null && items.size() > 0) {
-            mNeedsSort = true;
-            Builder builder = null;
-            for (Animator10 anim : items) {
-                if (builder == null) {
-                    builder = play(anim);
-                } else {
-                    builder.with(anim);
-                }
-            }
-        }
-    }
-
-    public void playSequentially(Animator10... items) {
-        if (items != null) {
-            mNeedsSort = true;
-            if (items.length == 1) {
-                play(items[0]);
-            } else {
-                for (int i = 0; i < items.length - 1; ++i) {
-                    play(items[i]).before(items[i+1]);
-                }
-            }
-        }
-    }
-
-    public void playSequentially(List<Animator10> items) {
-        if (items != null && items.size() > 0) {
-            mNeedsSort = true;
-            if (items.size() == 1) {
-                play(items.get(0));
-            } else {
-                for (int i = 0; i < items.size() - 1; ++i) {
-                    play(items.get(i)).before(items.get(i+1));
-                }
-            }
-        }
-    }
-
-    public ArrayList<Animator10> getChildAnimations() {
-        ArrayList<Animator10> childList = new ArrayList<>();
-        for (Node node : mNodes) {
-            childList.add(node.animation);
-        }
-        return childList;
-    }
-
-    @Override
-    public void setTarget(Object target) {
-        for (Node node : mNodes) {
-            Animator10 animation = node.animation;
-            if (animation instanceof AnimatorSet10) {
-                animation.setTarget(target);
-            } else if (animation instanceof ObjectAnimator10) {
-                animation.setTarget(target);
-            }
-        }
-    }
-
-    @Override
-    public void setInterpolator(Interpolator interpolator) {
-        mInterpolator = interpolator;
-    }
-
-    @Override
-    public Interpolator getInterpolator() {
-        return mInterpolator;
-    }
-
-    public Builder play(Animator10 anim) {
-        if (anim != null) {
-            mNeedsSort = true;
-            return new Builder(anim);
-        }
-        return null;
-    }
-
-    @SuppressWarnings("unchecked")
-    @Override
-    public void cancel() {
-        mTerminated = true;
-        if (isStarted()) {
-            ArrayList<AnimatorListener> tmpListeners = null;
-            if (mListeners != null) {
-                tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
-                for (AnimatorListener listener : tmpListeners) {
-                    listener.onAnimationCancel(this);
-                }
-            }
-            if (mDelayAnim != null && mDelayAnim.isRunning()) {
-                mDelayAnim.cancel();
-            } else  if (mSortedNodes.size() > 0) {
-                for (Node node : mSortedNodes) {
-                    node.animation.cancel();
-                }
-            }
-            if (tmpListeners != null) {
-                for (AnimatorListener listener : tmpListeners) {
-                    listener.onAnimationEnd(this);
-                }
-            }
-            mStarted = false;
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    @Override
-    public void end() {
-        mTerminated = true;
-        if (isStarted()) {
-            if (mSortedNodes.size() != mNodes.size()) {
-                // hasn't been started yet - sort the nodes now, then end them
-                sortNodes();
-                for (Node node : mSortedNodes) {
-                    if (mSetListener == null) {
-                        mSetListener = new AnimatorSetListener(this);
-                    }
-                    node.animation.addListener(mSetListener);
-                }
-            }
-            if (mDelayAnim != null) {
-                mDelayAnim.cancel();
-            }
-            if (mSortedNodes.size() > 0) {
-                for (Node node : mSortedNodes) {
-                    node.animation.end();
-                }
-            }
-            if (mListeners != null) {
-                ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
-                for (AnimatorListener listener : tmpListeners) {
-                    listener.onAnimationEnd(this);
-                }
-            }
-            mStarted = false;
-        }
-    }
-
-    @Override
-    public boolean isRunning() {
-        for (Node node : mNodes) {
-            if (node.animation.isRunning()) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    @Override
-    public boolean isStarted() {
-        return mStarted;
-    }
-
-    @Override
-    public long getStartDelay() {
-        return mStartDelay;
-    }
-
-    @Override
-    public void setStartDelay(long startDelay) {
-        mStartDelay = startDelay;
-    }
-
-    @Override
-    public long getDuration() {
-        return mDuration;
-    }
-
-    @Override
-    public AnimatorSet10 setDuration(long duration) {
-        if (duration < 0) {
-            throw new IllegalArgumentException("duration must be a value of zero or greater");
-        }
-        mDuration = duration;
-        return this;
-    }
-
-    @Override
-    public void setupStartValues() {
-        for (Node node : mNodes) {
-            node.animation.setupStartValues();
-        }
-    }
-
-    @Override
-    public void setupEndValues() {
-        for (Node node : mNodes) {
-            node.animation.setupEndValues();
-        }
-    }
-
-    @Override
-    public void pause() {
-        boolean previouslyPaused = mPaused;
-        super.pause();
-        if (!previouslyPaused && mPaused) {
-            if (mDelayAnim != null) {
-                mDelayAnim.pause();
-            } else {
-                for (Node node : mNodes) {
-                    node.animation.pause();
-                }
-            }
-        }
-    }
-
-    @Override
-    public void resume() {
-        boolean previouslyPaused = mPaused;
-        super.resume();
-        if (previouslyPaused && !mPaused) {
-            if (mDelayAnim != null) {
-                mDelayAnim.resume();
-            } else {
-                for (Node node : mNodes) {
-                    node.animation.resume();
-                }
-            }
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    @Override
-    public void start() {
-        mTerminated = false;
-        mStarted = true;
-        mPaused = false;
-
-        if (mDuration >= 0) {
-            for (Node node : mNodes) {
-                node.animation.setDuration(mDuration);
-            }
-        }
-        if (mInterpolator != null) {
-            for (Node node : mNodes) {
-                node.animation.setInterpolator(mInterpolator);
-            }
-        }
-
-        sortNodes();
-
-        int numSortedNodes = mSortedNodes.size();
-        for (Node node : mSortedNodes) {
-            ArrayList<AnimatorListener> oldListeners = node.animation.getListeners();
-            if (oldListeners != null && oldListeners.size() > 0) {
-                final ArrayList<AnimatorListener> clonedListeners = new
-                        ArrayList<>(oldListeners);
-
-                for (AnimatorListener listener : clonedListeners) {
-                    if (listener instanceof DependencyListener ||
-                            listener instanceof AnimatorSetListener) {
-                        node.animation.removeListener(listener);
-                    }
-                }
-            }
-        }
-
-        final ArrayList<Node> nodesToStart = new ArrayList<>();
-        for (Node node : mSortedNodes) {
-            if (mSetListener == null) {
-                mSetListener = new AnimatorSetListener(this);
-            }
-            if (node.dependencies == null || node.dependencies.size() == 0) {
-                nodesToStart.add(node);
-            } else {
-                int numDependencies = node.dependencies.size();
-                for (int j = 0; j < numDependencies; ++j) {
-                    Dependency dependency = node.dependencies.get(j);
-                    dependency.node.animation.addListener(
-                            new DependencyListener(this, node, dependency.rule));
-                }
-                node.tmpDependencies = (ArrayList<Dependency>) node.dependencies.clone();
-            }
-            node.animation.addListener(mSetListener);
-        }
-
-        if (mStartDelay <= 0) {
-            for (Node node : nodesToStart) {
-                node.animation.start();
-                mPlayingSet.add(node.animation);
-            }
-        } else {
-            mDelayAnim = ValueAnimator.ofFloat(0f, 1f);
-            mDelayAnim.setDuration(mStartDelay);
-            mDelayAnim.addListener(new AnimatorListenerAdapter10() {
-                boolean canceled = false;
-                public void onAnimationCancel(Animator10 anim) {
-                    canceled = true;
-                }
-                public void onAnimationEnd(Animator10 anim) {
-                    if (!canceled) {
-                        int numNodes = nodesToStart.size();
-                        for (Node node : nodesToStart) {
-                            node.animation.start();
-                            mPlayingSet.add(node.animation);
-                        }
-                    }
-                    mDelayAnim = null;
-                }
-            });
-            mDelayAnim.start();
-        }
-        if (mListeners != null) {
-            ArrayList<AnimatorListener> tmpListeners =
-                    (ArrayList<AnimatorListener>) mListeners.clone();
-            int numListeners = tmpListeners.size();
-            for (AnimatorListener tmpListener : tmpListeners) {
-                tmpListener.onAnimationStart(this);
-            }
-        }
-        if (mNodes.size() == 0 && mStartDelay == 0) {
-            mStarted = false;
-            if (mListeners != null) {
-                ArrayList<AnimatorListener> tmpListeners =
-                        (ArrayList<AnimatorListener>) mListeners.clone();
-                int numListeners = tmpListeners.size();
-                for (AnimatorListener tmpListener : tmpListeners) {
-                    tmpListener.onAnimationEnd(this);
-                }
-            }
-        }
-    }
-
-    @Override
-    public AnimatorSet10 clone() {
-        final AnimatorSet10 anim = (AnimatorSet10) super.clone();
-
-        anim.mNeedsSort = true;
-        anim.mTerminated = false;
-        anim.mStarted = false;
-        anim.mPlayingSet = new ArrayList<>();
-        anim.mNodeMap = new HashMap<>();
-        anim.mNodes = new ArrayList<>();
-        anim.mSortedNodes = new ArrayList<>();
-
-        HashMap<Node, Node> nodeCloneMap = new HashMap<>();
-        for (Node node : mNodes) {
-            Node nodeClone = node.clone();
-            nodeCloneMap.put(node, nodeClone);
-            anim.mNodes.add(nodeClone);
-            anim.mNodeMap.put(nodeClone.animation, nodeClone);
-            nodeClone.dependencies = null;
-            nodeClone.tmpDependencies = null;
-            nodeClone.nodeDependents = null;
-            nodeClone.nodeDependencies = null;
-            ArrayList<AnimatorListener> cloneListeners = nodeClone.animation.getListeners();
-            if (cloneListeners != null) {
-                ArrayList<AnimatorListener> listenersToRemove = null;
-                for (AnimatorListener listener : cloneListeners) {
-                    if (listener instanceof AnimatorSetListener) {
-                        if (listenersToRemove == null) {
-                            listenersToRemove = new ArrayList<>();
-                        }
-                        listenersToRemove.add(listener);
-                    }
-                }
-                if (listenersToRemove != null) {
-                    for (AnimatorListener listener : listenersToRemove) {
-                        cloneListeners.remove(listener);
-                    }
-                }
-            }
-        }
-        for (Node node : mNodes) {
-            Node nodeClone = nodeCloneMap.get(node);
-            if (node.dependencies != null) {
-                for (Dependency dependency : node.dependencies) {
-                    Node clonedDependencyNode = nodeCloneMap.get(dependency.node);
-                    Dependency cloneDependency = new Dependency(clonedDependencyNode, dependency.rule);
-                    nodeClone.addDependency(cloneDependency);
-                }
-            }
-        }
-        return anim;
-    }
-
-    private static class DependencyListener implements AnimatorListener {
-
-        private AnimatorSet10 mAnimatorSet;
-        private Node mNode;
-        private int mRule;
-
-        public DependencyListener(AnimatorSet10 animatorSet, Node node, int rule) {
-            this.mAnimatorSet = animatorSet;
-            this.mNode = node;
-            this.mRule = rule;
-        }
-
-        public void onAnimationCancel(Animator10 animation) {
-
-        }
-
-        public void onAnimationEnd(Animator10 animation) {
-            if (mRule == Dependency.AFTER) {
-                startIfReady(animation);
-            }
-        }
-
-        public void onAnimationRepeat(Animator10 animation) {
-
-        }
-
-        public void onAnimationStart(Animator10 animation) {
-            if (mRule == Dependency.WITH) {
-                startIfReady(animation);
-            }
-        }
-
-        private void startIfReady(Animator10 dependencyAnimation) {
-            if (mAnimatorSet.mTerminated) {
-                return;
-            }
-            Dependency dependencyToRemove = null;
-            int numDependencies = mNode.tmpDependencies.size();
-            for (int i = 0; i < numDependencies; ++i) {
-                Dependency dependency = mNode.tmpDependencies.get(i);
-                if (dependency.rule == mRule && dependency.node.animation == dependencyAnimation) {
-                    dependencyToRemove = dependency;
-                    dependencyAnimation.removeListener(this);
-                    break;
-                }
-            }
-            mNode.tmpDependencies.remove(dependencyToRemove);
-            if (mNode.tmpDependencies.size() == 0) {
-                mNode.animation.start();
-                mAnimatorSet.mPlayingSet.add(mNode.animation);
-            }
-        }
-    }
-
-    private class AnimatorSetListener implements AnimatorListener {
-
-        private AnimatorSet10 mAnimatorSet;
-
-        AnimatorSetListener(AnimatorSet10 animatorSet) {
-            mAnimatorSet = animatorSet;
-        }
-
-        public void onAnimationCancel(Animator10 animation) {
-            if (!mTerminated) {
-                if (mPlayingSet.size() == 0) {
-                    if (mListeners != null) {
-                        int numListeners = mListeners.size();
-                        for (AnimatorListener mListener : mListeners) {
-                            mListener.onAnimationCancel(mAnimatorSet);
-                        }
-                    }
-                }
-            }
-        }
-
-        @SuppressWarnings("unchecked")
-        public void onAnimationEnd(Animator10 animation) {
-            animation.removeListener(this);
-            mPlayingSet.remove(animation);
-            Node animNode = mAnimatorSet.mNodeMap.get(animation);
-            animNode.done = true;
-            if (!mTerminated) {
-                ArrayList<Node> sortedNodes = mAnimatorSet.mSortedNodes;
-                boolean allDone = true;
-                int numSortedNodes = sortedNodes.size();
-                for (Node sortedNode : sortedNodes) {
-                    if (!sortedNode.done) {
-                        allDone = false;
-                        break;
-                    }
-                }
-                if (allDone) {
-                    if (mListeners != null) {
-                        ArrayList<AnimatorListener> tmpListeners =
-                                (ArrayList<AnimatorListener>) mListeners.clone();
-                        int numListeners = tmpListeners.size();
-                        for (AnimatorListener tmpListener : tmpListeners) {
-                            tmpListener.onAnimationEnd(mAnimatorSet);
-                        }
-                    }
-                    mAnimatorSet.mStarted = false;
-                    mAnimatorSet.mPaused = false;
-                }
-            }
-        }
-
-        public void onAnimationRepeat(Animator10 animation) {
-
-        }
-
-        public void onAnimationStart(Animator10 animation) {
-
-        }
-    }
-
-    private void sortNodes() {
-        if (mNeedsSort) {
-            mSortedNodes.clear();
-            ArrayList<Node> roots = new ArrayList<>();
-            int numNodes = mNodes.size();
-            for (Node node : mNodes) {
-                if (node.dependencies == null || node.dependencies.size() == 0) {
-                    roots.add(node);
-                }
-            }
-            ArrayList<Node> tmpRoots = new ArrayList<>();
-            while (roots.size() > 0) {
-                int numRoots = roots.size();
-                for (Node root : roots) {
-                    mSortedNodes.add(root);
-                    if (root.nodeDependents != null) {
-                        int numDependents = root.nodeDependents.size();
-                        for (int j = 0; j < numDependents; ++j) {
-                            Node node = root.nodeDependents.get(j);
-                            node.nodeDependencies.remove(root);
-                            if (node.nodeDependencies.size() == 0) {
-                                tmpRoots.add(node);
-                            }
-                        }
-                    }
-                }
-                roots.clear();
-                roots.addAll(tmpRoots);
-                tmpRoots.clear();
-            }
-            mNeedsSort = false;
-            if (mSortedNodes.size() != mNodes.size()) {
-                throw new IllegalStateException("Circular dependencies cannot exist in AnimatorSet");
-            }
-        } else {
-            int numNodes = mNodes.size();
-            for (Node node : mNodes) {
-                if (node.dependencies != null && node.dependencies.size() > 0) {
-                    int numDependencies = node.dependencies.size();
-                    for (int j = 0; j < numDependencies; ++j) {
-                        Dependency dependency = node.dependencies.get(j);
-                        if (node.nodeDependencies == null) {
-                            node.nodeDependencies = new ArrayList<>();
-                        }
-                        if (!node.nodeDependencies.contains(dependency.node)) {
-                            node.nodeDependencies.add(dependency.node);
-                        }
-                    }
-                }
-                node.done = false;
-            }
-        }
-    }
-
-    private static class Dependency {
-        static final int WITH = 0;
-        static final int AFTER = 1;
-        public Node node;
-        public int rule;
-
-        public Dependency(Node node, int rule) {
-            this.node = node;
-            this.rule = rule;
-        }
-    }
-
-    private static class Node implements Cloneable {
-        public Animator10 animation;
-        public ArrayList<Dependency> dependencies = null;
-        public ArrayList<Dependency> tmpDependencies = null;
-        public ArrayList<Node> nodeDependencies = null;
-        public ArrayList<Node> nodeDependents = null;
-        public boolean done = false;
-
-        public Node(Animator10 animation) {
-            this.animation = animation;
-        }
-
-        public void addDependency(Dependency dependency) {
-            if (dependencies == null) {
-                dependencies = new ArrayList<>();
-                nodeDependencies = new ArrayList<>();
-            }
-            dependencies.add(dependency);
-            if (!nodeDependencies.contains(dependency.node)) {
-                nodeDependencies.add(dependency.node);
-            }
-            Node dependencyNode = dependency.node;
-            if (dependencyNode.nodeDependents == null) {
-                dependencyNode.nodeDependents = new ArrayList<>();
-            }
-            dependencyNode.nodeDependents.add(this);
-        }
-
-        @Override
-        public Node clone() {
-            try {
-                Node node = (Node) super.clone();
-                node.animation = animation.clone();
-                return node;
-            } catch (CloneNotSupportedException e) {
-               throw new AssertionError();
-            }
-        }
-    }
-
-    public class Builder {
-
-        private Node mCurrentNode;
-
-        Builder(Animator10 anim) {
-            mCurrentNode = mNodeMap.get(anim);
-            if (mCurrentNode == null) {
-                mCurrentNode = new Node(anim);
-                mNodeMap.put(anim, mCurrentNode);
-                mNodes.add(mCurrentNode);
-            }
-        }
-
-        public Builder with(Animator10 anim) {
-            Node node = mNodeMap.get(anim);
-            if (node == null) {
-                node = new Node(anim);
-                mNodeMap.put(anim, node);
-                mNodes.add(node);
-            }
-            Dependency dependency = new Dependency(mCurrentNode, Dependency.WITH);
-            node.addDependency(dependency);
-            return this;
-        }
-
-        public Builder before(Animator10 anim) {
-            Node node = mNodeMap.get(anim);
-            if (node == null) {
-                node = new Node(anim);
-                mNodeMap.put(anim, node);
-                mNodes.add(node);
-            }
-            Dependency dependency = new Dependency(mCurrentNode, Dependency.AFTER);
-            node.addDependency(dependency);
-            return this;
-        }
-
-        public Builder after(Animator10 anim) {
-            Node node = mNodeMap.get(anim);
-            if (node == null) {
-                node = new Node(anim);
-                mNodeMap.put(anim, node);
-                mNodes.add(node);
-            }
-            Dependency dependency = new Dependency(node, Dependency.AFTER);
-            mCurrentNode.addDependency(dependency);
-            return this;
-        }
-
-        public Builder after(long delay) {
-            ValueAnimator anim = ValueAnimator.ofFloat(0f, 1f);
-            anim.setDuration(delay);
-            after(anim);
-            return this;
-        }
-    }
-}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/FloatEvaluator.java b/TMessagesProj/src/main/java/org/telegram/messenger/Animation/FloatEvaluator.java
deleted file mode 100644
index 31d289390..000000000
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/FloatEvaluator.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.telegram.messenger.Animation;
-
-public class FloatEvaluator implements TypeEvaluator<Number> {
-    public Float evaluate(float fraction, Number startValue, Number endValue) {
-        float startFloat = startValue.floatValue();
-        return startFloat + fraction * (endValue.floatValue() - startFloat);
-    }
-}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/FloatKeyframeSet.java b/TMessagesProj/src/main/java/org/telegram/messenger/Animation/FloatKeyframeSet.java
deleted file mode 100644
index e7865e05c..000000000
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/FloatKeyframeSet.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.telegram.messenger.Animation;
-
-import android.view.animation.Interpolator;
-
-import org.telegram.messenger.Animation.Keyframe.FloatKeyframe;
-
-import java.util.ArrayList;
-
-class FloatKeyframeSet extends KeyframeSet {
-    private float firstValue;
-    private float lastValue;
-    private float deltaValue;
-    private boolean firstTime = true;
-
-    public FloatKeyframeSet(FloatKeyframe... keyframes) {
-        super(keyframes);
-    }
-
-    @Override
-    public Object getValue(float fraction) {
-        return getFloatValue(fraction);
-    }
-
-    @Override
-    public FloatKeyframeSet clone() {
-        ArrayList<Keyframe> keyframes = mKeyframes;
-        int numKeyframes = mKeyframes.size();
-        FloatKeyframe[] newKeyframes = new FloatKeyframe[numKeyframes];
-        for (int i = 0; i < numKeyframes; ++i) {
-            newKeyframes[i] = (FloatKeyframe) keyframes.get(i).clone();
-        }
-        return new FloatKeyframeSet(newKeyframes);
-    }
-
-    @SuppressWarnings("unchecked")
-    public float getFloatValue(float fraction) {
-        if (mNumKeyframes == 2) {
-            if (firstTime) {
-                firstTime = false;
-                firstValue = ((FloatKeyframe) mKeyframes.get(0)).getFloatValue();
-                lastValue = ((FloatKeyframe) mKeyframes.get(1)).getFloatValue();
-                deltaValue = lastValue - firstValue;
-            }
-            if (mInterpolator != null) {
-                fraction = mInterpolator.getInterpolation(fraction);
-            }
-            if (mEvaluator == null) {
-                return firstValue + fraction * deltaValue;
-            } else {
-                return ((Number)mEvaluator.evaluate(fraction, firstValue, lastValue)).floatValue();
-            }
-        }
-        if (fraction <= 0f) {
-            final FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(0);
-            final FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(1);
-            float prevValue = prevKeyframe.getFloatValue();
-            float nextValue = nextKeyframe.getFloatValue();
-            float prevFraction = prevKeyframe.getFraction();
-            float nextFraction = nextKeyframe.getFraction();
-            final Interpolator interpolator = nextKeyframe.getInterpolator();
-            if (interpolator != null) {
-                fraction = interpolator.getInterpolation(fraction);
-            }
-            float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
-            return mEvaluator == null ? prevValue + intervalFraction * (nextValue - prevValue) : ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).floatValue();
-        } else if (fraction >= 1f) {
-            final FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(mNumKeyframes - 2);
-            final FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(mNumKeyframes - 1);
-            float prevValue = prevKeyframe.getFloatValue();
-            float nextValue = nextKeyframe.getFloatValue();
-            float prevFraction = prevKeyframe.getFraction();
-            float nextFraction = nextKeyframe.getFraction();
-            final Interpolator interpolator = nextKeyframe.getInterpolator();
-            if (interpolator != null) {
-                fraction = interpolator.getInterpolation(fraction);
-            }
-            float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
-            return mEvaluator == null ? prevValue + intervalFraction * (nextValue - prevValue) : ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).floatValue();
-        }
-        FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(0);
-        for (int i = 1; i < mNumKeyframes; ++i) {
-            FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(i);
-            if (fraction < nextKeyframe.getFraction()) {
-                final Interpolator interpolator = nextKeyframe.getInterpolator();
-                if (interpolator != null) {
-                    fraction = interpolator.getInterpolation(fraction);
-                }
-                float intervalFraction = (fraction - prevKeyframe.getFraction()) /
-                    (nextKeyframe.getFraction() - prevKeyframe.getFraction());
-                float prevValue = prevKeyframe.getFloatValue();
-                float nextValue = nextKeyframe.getFloatValue();
-                return mEvaluator == null ? prevValue + intervalFraction * (nextValue - prevValue) : ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).floatValue();
-            }
-            prevKeyframe = nextKeyframe;
-        }
-        return ((Number)mKeyframes.get(mNumKeyframes - 1).getValue()).floatValue();
-    }
-}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/FloatProperty10.java b/TMessagesProj/src/main/java/org/telegram/messenger/Animation/FloatProperty10.java
deleted file mode 100755
index 1a3b6d798..000000000
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/FloatProperty10.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.telegram.messenger.Animation;
-
-public abstract class FloatProperty10<T> extends Property<T, Float> {
-
-    public FloatProperty10(String name) {
-        super(Float.class, name);
-    }
-
-    public abstract void setValue(T object, float value);
-
-    @Override
-    final public void set(T object, Float value) {
-        setValue(object, value.floatValue());
-    }
-}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/IntEvaluator.java b/TMessagesProj/src/main/java/org/telegram/messenger/Animation/IntEvaluator.java
deleted file mode 100644
index 2b43e0773..000000000
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/IntEvaluator.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.telegram.messenger.Animation;
-
-public class IntEvaluator implements TypeEvaluator<Integer> {
-    public Integer evaluate(float fraction, Integer startValue, Integer endValue) {
-        int startInt = startValue;
-        return (int)(startInt + fraction * (endValue - startInt));
-    }
-}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/IntKeyframeSet.java b/TMessagesProj/src/main/java/org/telegram/messenger/Animation/IntKeyframeSet.java
deleted file mode 100644
index 2224f2126..000000000
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/IntKeyframeSet.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.telegram.messenger.Animation;
-
-import android.view.animation.Interpolator;
-
-import org.telegram.messenger.Animation.Keyframe.IntKeyframe;
-
-import java.util.ArrayList;
-
-class IntKeyframeSet extends KeyframeSet {
-    private int firstValue;
-    private int lastValue;
-    private int deltaValue;
-    private boolean firstTime = true;
-
-    public IntKeyframeSet(IntKeyframe... keyframes) {
-        super(keyframes);
-    }
-
-    @Override
-    public Object getValue(float fraction) {
-        return getIntValue(fraction);
-    }
-
-    @Override
-    public IntKeyframeSet clone() {
-        ArrayList<Keyframe> keyframes = mKeyframes;
-        int numKeyframes = mKeyframes.size();
-        IntKeyframe[] newKeyframes = new IntKeyframe[numKeyframes];
-        for (int i = 0; i < numKeyframes; ++i) {
-            newKeyframes[i] = (IntKeyframe) keyframes.get(i).clone();
-        }
-        return new IntKeyframeSet(newKeyframes);
-    }
-
-    @SuppressWarnings("unchecked")
-    public int getIntValue(float fraction) {
-        if (mNumKeyframes == 2) {
-            if (firstTime) {
-                firstTime = false;
-                firstValue = ((IntKeyframe) mKeyframes.get(0)).getIntValue();
-                lastValue = ((IntKeyframe) mKeyframes.get(1)).getIntValue();
-                deltaValue = lastValue - firstValue;
-            }
-            if (mInterpolator != null) {
-                fraction = mInterpolator.getInterpolation(fraction);
-            }
-            if (mEvaluator == null) {
-                return firstValue + (int)(fraction * deltaValue);
-            } else {
-                return ((Number)mEvaluator.evaluate(fraction, firstValue, lastValue)).intValue();
-            }
-        }
-        if (fraction <= 0f) {
-            final IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(0);
-            final IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(1);
-            int prevValue = prevKeyframe.getIntValue();
-            int nextValue = nextKeyframe.getIntValue();
-            float prevFraction = prevKeyframe.getFraction();
-            float nextFraction = nextKeyframe.getFraction();
-            final Interpolator interpolator = nextKeyframe.getInterpolator();
-            if (interpolator != null) {
-                fraction = interpolator.getInterpolation(fraction);
-            }
-            float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
-            return mEvaluator == null ? prevValue + (int)(intervalFraction * (nextValue - prevValue)) : ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();
-        } else if (fraction >= 1f) {
-            final IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(mNumKeyframes - 2);
-            final IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(mNumKeyframes - 1);
-            int prevValue = prevKeyframe.getIntValue();
-            int nextValue = nextKeyframe.getIntValue();
-            float prevFraction = prevKeyframe.getFraction();
-            float nextFraction = nextKeyframe.getFraction();
-            final Interpolator interpolator = nextKeyframe.getInterpolator();
-            if (interpolator != null) {
-                fraction = interpolator.getInterpolation(fraction);
-            }
-            float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
-            return mEvaluator == null ? prevValue + (int)(intervalFraction * (nextValue - prevValue)) : ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();
-        }
-        IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(0);
-        for (int i = 1; i < mNumKeyframes; ++i) {
-            IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(i);
-            if (fraction < nextKeyframe.getFraction()) {
-                final Interpolator interpolator = nextKeyframe.getInterpolator();
-                if (interpolator != null) {
-                    fraction = interpolator.getInterpolation(fraction);
-                }
-                float intervalFraction = (fraction - prevKeyframe.getFraction()) / (nextKeyframe.getFraction() - prevKeyframe.getFraction());
-                int prevValue = prevKeyframe.getIntValue();
-                int nextValue = nextKeyframe.getIntValue();
-                return mEvaluator == null ? prevValue + (int)(intervalFraction * (nextValue - prevValue)) : ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();
-            }
-            prevKeyframe = nextKeyframe;
-        }
-        return ((Number)mKeyframes.get(mNumKeyframes - 1).getValue()).intValue();
-    }
-}
-
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/IntProperty.java b/TMessagesProj/src/main/java/org/telegram/messenger/Animation/IntProperty.java
deleted file mode 100755
index 175704cf4..000000000
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/IntProperty.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.telegram.messenger.Animation;
-
-public abstract class IntProperty<T> extends Property<T, Integer> {
-
-    public IntProperty(String name) {
-        super(Integer.class, name);
-    }
-
-    public abstract void setValue(T object, int value);
-
-    @Override
-    final public void set(T object, Integer value) {
-        setValue(object, value.intValue());
-    }
-}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/Keyframe.java b/TMessagesProj/src/main/java/org/telegram/messenger/Animation/Keyframe.java
deleted file mode 100644
index b65ddaf44..000000000
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/Keyframe.java
+++ /dev/null
@@ -1,187 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.telegram.messenger.Animation;
-
-import android.view.animation.Interpolator;
-
-public abstract class Keyframe implements Cloneable {
-
-    float mFraction;
-    Class mValueType;
-    private Interpolator mInterpolator = null;
-    boolean mHasValue = false;
-
-    public static Keyframe ofInt(float fraction, int value) {
-        return new IntKeyframe(fraction, value);
-    }
-
-    public static Keyframe ofInt(float fraction) {
-        return new IntKeyframe(fraction);
-    }
-
-    public static Keyframe ofFloat(float fraction, float value) {
-        return new FloatKeyframe(fraction, value);
-    }
-
-    public static Keyframe ofFloat(float fraction) {
-        return new FloatKeyframe(fraction);
-    }
-
-    public static Keyframe ofObject(float fraction, Object value) {
-        return new ObjectKeyframe(fraction, value);
-    }
-
-    public static Keyframe ofObject(float fraction) {
-        return new ObjectKeyframe(fraction, null);
-    }
-
-    public boolean hasValue() {
-        return mHasValue;
-    }
-
-    public abstract Object getValue();
-    public abstract void setValue(Object value);
-
-    public float getFraction() {
-        return mFraction;
-    }
-
-    public void setFraction(float fraction) {
-        mFraction = fraction;
-    }
-
-    public Interpolator getInterpolator() {
-        return mInterpolator;
-    }
-
-    public void setInterpolator(Interpolator interpolator) {
-        mInterpolator = interpolator;
-    }
-
-    public Class getType() {
-        return mValueType;
-    }
-
-    @Override
-    public abstract Keyframe clone();
-
-    static class ObjectKeyframe extends Keyframe {
-
-        Object mValue;
-
-        ObjectKeyframe(float fraction, Object value) {
-            mFraction = fraction;
-            mValue = value;
-            mHasValue = (value != null);
-            mValueType = mHasValue ? value.getClass() : Object.class;
-        }
-
-        public Object getValue() {
-            return mValue;
-        }
-
-        public void setValue(Object value) {
-            mValue = value;
-            mHasValue = (value != null);
-        }
-
-        @Override
-        public ObjectKeyframe clone() {
-            ObjectKeyframe kfClone = new ObjectKeyframe(getFraction(), mHasValue ? mValue : null);
-            kfClone.setInterpolator(getInterpolator());
-            return kfClone;
-        }
-    }
-
-    static class IntKeyframe extends Keyframe {
-
-        int mValue;
-
-        IntKeyframe(float fraction, int value) {
-            mFraction = fraction;
-            mValue = value;
-            mValueType = int.class;
-            mHasValue = true;
-        }
-
-        IntKeyframe(float fraction) {
-            mFraction = fraction;
-            mValueType = int.class;
-        }
-
-        public int getIntValue() {
-            return mValue;
-        }
-
-        public Object getValue() {
-            return mValue;
-        }
-
-        public void setValue(Object value) {
-            if (value != null && value.getClass() == Integer.class) {
-                mValue = (Integer) value;
-                mHasValue = true;
-            }
-        }
-
-        @Override
-        public IntKeyframe clone() {
-            IntKeyframe kfClone = mHasValue ? new IntKeyframe(getFraction(), mValue) : new IntKeyframe(getFraction());
-            kfClone.setInterpolator(getInterpolator());
-            return kfClone;
-        }
-    }
-
-    static class FloatKeyframe extends Keyframe {
-
-        float mValue;
-
-        FloatKeyframe(float fraction, float value) {
-            mFraction = fraction;
-            mValue = value;
-            mValueType = float.class;
-            mHasValue = true;
-        }
-
-        FloatKeyframe(float fraction) {
-            mFraction = fraction;
-            mValueType = float.class;
-        }
-
-        public float getFloatValue() {
-            return mValue;
-        }
-
-        public Object getValue() {
-            return mValue;
-        }
-
-        public void setValue(Object value) {
-            if (value != null && value.getClass() == Float.class) {
-                mValue = (Float) value;
-                mHasValue = true;
-            }
-        }
-
-        @Override
-        public FloatKeyframe clone() {
-            FloatKeyframe kfClone = mHasValue ? new FloatKeyframe(getFraction(), mValue) : new FloatKeyframe(getFraction());
-            kfClone.setInterpolator(getInterpolator());
-            return kfClone;
-        }
-    }
-}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/KeyframeSet.java b/TMessagesProj/src/main/java/org/telegram/messenger/Animation/KeyframeSet.java
deleted file mode 100644
index 2e86dc876..000000000
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/KeyframeSet.java
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.telegram.messenger.Animation;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import android.util.Log;
-import android.view.animation.Interpolator;
-
-import org.telegram.messenger.Animation.Keyframe.IntKeyframe;
-import org.telegram.messenger.Animation.Keyframe.FloatKeyframe;
-import org.telegram.messenger.Animation.Keyframe.ObjectKeyframe;
-
-class KeyframeSet {
-
-    int mNumKeyframes;
-
-    Keyframe mFirstKeyframe;
-    Keyframe mLastKeyframe;
-    Interpolator mInterpolator;
-    ArrayList<Keyframe> mKeyframes;
-    TypeEvaluator mEvaluator;
-
-    public KeyframeSet(Keyframe... keyframes) {
-        mNumKeyframes = keyframes.length;
-        mKeyframes = new ArrayList<Keyframe>();
-        mKeyframes.addAll(Arrays.asList(keyframes));
-        mFirstKeyframe = mKeyframes.get(0);
-        mLastKeyframe = mKeyframes.get(mNumKeyframes - 1);
-        mInterpolator = mLastKeyframe.getInterpolator();
-    }
-
-    public static KeyframeSet ofInt(int... values) {
-        int numKeyframes = values.length;
-        IntKeyframe keyframes[] = new IntKeyframe[Math.max(numKeyframes,2)];
-        if (numKeyframes == 1) {
-            keyframes[0] = (IntKeyframe) Keyframe.ofInt(0f);
-            keyframes[1] = (IntKeyframe) Keyframe.ofInt(1f, values[0]);
-        } else {
-            keyframes[0] = (IntKeyframe) Keyframe.ofInt(0f, values[0]);
-            for (int i = 1; i < numKeyframes; ++i) {
-                keyframes[i] = (IntKeyframe) Keyframe.ofInt((float) i / (numKeyframes - 1), values[i]);
-            }
-        }
-        return new IntKeyframeSet(keyframes);
-    }
-
-    public static KeyframeSet ofFloat(float... values) {
-        boolean badValue = false;
-        int numKeyframes = values.length;
-        FloatKeyframe keyframes[] = new FloatKeyframe[Math.max(numKeyframes,2)];
-        if (numKeyframes == 1) {
-            keyframes[0] = (FloatKeyframe) Keyframe.ofFloat(0f);
-            keyframes[1] = (FloatKeyframe) Keyframe.ofFloat(1f, values[0]);
-            if (Float.isNaN(values[0])) {
-                badValue = true;
-            }
-        } else {
-            keyframes[0] = (FloatKeyframe) Keyframe.ofFloat(0f, values[0]);
-            for (int i = 1; i < numKeyframes; ++i) {
-                keyframes[i] = (FloatKeyframe) Keyframe.ofFloat((float) i / (numKeyframes - 1), values[i]);
-                if (Float.isNaN(values[i])) {
-                    badValue = true;
-                }
-            }
-        }
-        if (badValue) {
-            Log.w("Animator", "Bad value (NaN) in float animator");
-        }
-        return new FloatKeyframeSet(keyframes);
-    }
-
-    public static KeyframeSet ofKeyframe(Keyframe... keyframes) {
-        int numKeyframes = keyframes.length;
-        boolean hasFloat = false;
-        boolean hasInt = false;
-        boolean hasOther = false;
-        for (Keyframe keyframe : keyframes) {
-            if (keyframe instanceof FloatKeyframe) {
-                hasFloat = true;
-            } else if (keyframe instanceof IntKeyframe) {
-                hasInt = true;
-            } else {
-                hasOther = true;
-            }
-        }
-        if (hasFloat && !hasInt && !hasOther) {
-            FloatKeyframe floatKeyframes[] = new FloatKeyframe[numKeyframes];
-            for (int i = 0; i < numKeyframes; ++i) {
-                floatKeyframes[i] = (FloatKeyframe) keyframes[i];
-            }
-            return new FloatKeyframeSet(floatKeyframes);
-        } else if (hasInt && !hasFloat && !hasOther) {
-            IntKeyframe intKeyframes[] = new IntKeyframe[numKeyframes];
-            for (int i = 0; i < numKeyframes; ++i) {
-                intKeyframes[i] = (IntKeyframe) keyframes[i];
-            }
-            return new IntKeyframeSet(intKeyframes);
-        } else {
-            return new KeyframeSet(keyframes);
-        }
-    }
-
-    public static KeyframeSet ofObject(Object... values) {
-        int numKeyframes = values.length;
-        ObjectKeyframe keyframes[] = new ObjectKeyframe[Math.max(numKeyframes,2)];
-        if (numKeyframes == 1) {
-            keyframes[0] = (ObjectKeyframe) Keyframe.ofObject(0f);
-            keyframes[1] = (ObjectKeyframe) Keyframe.ofObject(1f, values[0]);
-        } else {
-            keyframes[0] = (ObjectKeyframe) Keyframe.ofObject(0f, values[0]);
-            for (int i = 1; i < numKeyframes; ++i) {
-                keyframes[i] = (ObjectKeyframe) Keyframe.ofObject((float) i / (numKeyframes - 1), values[i]);
-            }
-        }
-        return new KeyframeSet(keyframes);
-    }
-
-    public void setEvaluator(TypeEvaluator evaluator) {
-        mEvaluator = evaluator;
-    }
-
-    @Override
-    public KeyframeSet clone() {
-        ArrayList<Keyframe> keyframes = mKeyframes;
-        int numKeyframes = mKeyframes.size();
-        Keyframe[] newKeyframes = new Keyframe[numKeyframes];
-        for (int i = 0; i < numKeyframes; ++i) {
-            newKeyframes[i] = keyframes.get(i).clone();
-        }
-        return new KeyframeSet(newKeyframes);
-    }
-
-    @SuppressWarnings("unchecked")
-    public Object getValue(float fraction) {
-        if (mNumKeyframes == 2) {
-            if (mInterpolator != null) {
-                fraction = mInterpolator.getInterpolation(fraction);
-            }
-            return mEvaluator.evaluate(fraction, mFirstKeyframe.getValue(), mLastKeyframe.getValue());
-        }
-        if (fraction <= 0f) {
-            final Keyframe nextKeyframe = mKeyframes.get(1);
-            final Interpolator interpolator = nextKeyframe.getInterpolator();
-            if (interpolator != null) {
-                fraction = interpolator.getInterpolation(fraction);
-            }
-            final float prevFraction = mFirstKeyframe.getFraction();
-            float intervalFraction = (fraction - prevFraction) / (nextKeyframe.getFraction() - prevFraction);
-            return mEvaluator.evaluate(intervalFraction, mFirstKeyframe.getValue(), nextKeyframe.getValue());
-        } else if (fraction >= 1f) {
-            final Keyframe prevKeyframe = mKeyframes.get(mNumKeyframes - 2);
-            final Interpolator interpolator = mLastKeyframe.getInterpolator();
-            if (interpolator != null) {
-                fraction = interpolator.getInterpolation(fraction);
-            }
-            final float prevFraction = prevKeyframe.getFraction();
-            float intervalFraction = (fraction - prevFraction) / (mLastKeyframe.getFraction() - prevFraction);
-            return mEvaluator.evaluate(intervalFraction, prevKeyframe.getValue(), mLastKeyframe.getValue());
-        }
-        Keyframe prevKeyframe = mFirstKeyframe;
-        for (int i = 1; i < mNumKeyframes; ++i) {
-            Keyframe nextKeyframe = mKeyframes.get(i);
-            if (fraction < nextKeyframe.getFraction()) {
-                final Interpolator interpolator = nextKeyframe.getInterpolator();
-                if (interpolator != null) {
-                    fraction = interpolator.getInterpolation(fraction);
-                }
-                final float prevFraction = prevKeyframe.getFraction();
-                float intervalFraction = (fraction - prevFraction) / (nextKeyframe.getFraction() - prevFraction);
-                return mEvaluator.evaluate(intervalFraction, prevKeyframe.getValue(), nextKeyframe.getValue());
-            }
-            prevKeyframe = nextKeyframe;
-        }
-        return mLastKeyframe.getValue();
-    }
-
-    @Override
-    public String toString() {
-        String returnVal = " ";
-        for (int i = 0; i < mNumKeyframes; ++i) {
-            returnVal += mKeyframes.get(i).getValue() + "  ";
-        }
-        return returnVal;
-    }
-}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/NoSuchPropertyException.java b/TMessagesProj/src/main/java/org/telegram/messenger/Animation/NoSuchPropertyException.java
deleted file mode 100755
index 114660287..000000000
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/NoSuchPropertyException.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.telegram.messenger.Animation;
-
-public class NoSuchPropertyException extends RuntimeException {
-
-    public NoSuchPropertyException(String s) {
-        super(s);
-    }
-
-}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/ObjectAnimator10.java b/TMessagesProj/src/main/java/org/telegram/messenger/Animation/ObjectAnimator10.java
deleted file mode 100644
index fef5f1851..000000000
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/ObjectAnimator10.java
+++ /dev/null
@@ -1,488 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.telegram.messenger.Animation;
-
-import android.view.View;
-
-import java.util.HashMap;
-
-public final class ObjectAnimator10 extends ValueAnimator {
-
-    private static final HashMap<String, Property> PROXY_PROPERTIES = new HashMap<String, Property>();
-
-    static {
-        Property<View, Float> ALPHA = new FloatProperty10<View>("alpha") {
-            @Override
-            public void setValue(View object, float value) {
-                View10.wrap(object).setAlpha(value);
-            }
-
-            @Override
-            public Float get(View object) {
-                return View10.wrap(object).getAlpha();
-            }
-        };
-
-        Property<View, Float> PIVOT_X = new FloatProperty10<View>("pivotX") {
-            @Override
-            public void setValue(View object, float value) {
-                View10.wrap(object).setPivotX(value);
-            }
-
-            @Override
-            public Float get(View object) {
-                return View10.wrap(object).getPivotX();
-            }
-        };
-
-        Property<View, Float> PIVOT_Y = new FloatProperty10<View>("pivotY") {
-            @Override
-            public void setValue(View object, float value) {
-                View10.wrap(object).setPivotY(value);
-            }
-
-            @Override
-            public Float get(View object) {
-                return View10.wrap(object).getPivotY();
-            }
-        };
-
-        Property<View, Float> TRANSLATION_X = new FloatProperty10<View>("translationX") {
-            @Override
-            public void setValue(View object, float value) {
-                View10.wrap(object).setTranslationX(value);
-            }
-
-            @Override
-            public Float get(View object) {
-                return View10.wrap(object).getTranslationX();
-            }
-        };
-
-        Property<View, Float> TRANSLATION_Y = new FloatProperty10<View>("translationY") {
-            @Override
-            public void setValue(View object, float value) {
-                View10.wrap(object).setTranslationY(value);
-            }
-
-            @Override
-            public Float get(View object) {
-                return View10.wrap(object).getTranslationY();
-            }
-        };
-
-        Property<View, Float> ROTATION = new FloatProperty10<View>("rotation") {
-            @Override
-            public void setValue(View object, float value) {
-                View10.wrap(object).setRotation(value);
-            }
-
-            @Override
-            public Float get(View object) {
-                return View10.wrap(object).getRotation();
-            }
-        };
-
-        Property<View, Float> ROTATION_X = new FloatProperty10<View>("rotationX") {
-            @Override
-            public void setValue(View object, float value) {
-                View10.wrap(object).setRotationX(value);
-            }
-
-            @Override
-            public Float get(View object) {
-                return View10.wrap(object).getRotationX();
-            }
-        };
-
-        Property<View, Float> ROTATION_Y = new FloatProperty10<View>("rotationY") {
-            @Override
-            public void setValue(View object, float value) {
-                View10.wrap(object).setRotationY(value);
-            }
-
-            @Override
-            public Float get(View object) {
-                return View10.wrap(object).getRotationY();
-            }
-        };
-
-        Property<View, Float> SCALE_X = new FloatProperty10<View>("scaleX") {
-            @Override
-            public void setValue(View object, float value) {
-                View10.wrap(object).setScaleX(value);
-            }
-
-            @Override
-            public Float get(View object) {
-                return View10.wrap(object).getScaleX();
-            }
-        };
-
-        Property<View, Float> SCALE_Y = new FloatProperty10<View>("scaleY") {
-            @Override
-            public void setValue(View object, float value) {
-                View10.wrap(object).setScaleY(value);
-            }
-
-            @Override
-            public Float get(View object) {
-                return View10.wrap(object).getScaleY();
-            }
-        };
-
-        Property<View, Integer> SCROLL_X = new IntProperty<View>("scrollX") {
-            @Override
-            public void setValue(View object, int value) {
-                View10.wrap(object).setScrollX(value);
-            }
-
-            @Override
-            public Integer get(View object) {
-                return View10.wrap(object).getScrollX();
-            }
-        };
-
-        Property<View, Integer> SCROLL_Y = new IntProperty<View>("scrollY") {
-            @Override
-            public void setValue(View object, int value) {
-                View10.wrap(object).setScrollY(value);
-            }
-
-            @Override
-            public Integer get(View object) {
-                return View10.wrap(object).getScrollY();
-            }
-        };
-
-        Property<View, Float> X = new FloatProperty10<View>("x") {
-            @Override
-            public void setValue(View object, float value) {
-                View10.wrap(object).setX(value);
-            }
-
-            @Override
-            public Float get(View object) {
-                return View10.wrap(object).getX();
-            }
-        };
-
-        Property<View, Float> Y = new FloatProperty10<View>("y") {
-            @Override
-            public void setValue(View object, float value) {
-                View10.wrap(object).setY(value);
-            }
-
-            @Override
-            public Float get(View object) {
-                return View10.wrap(object).getY();
-            }
-        };
-
-        PROXY_PROPERTIES.put("alpha", ALPHA);
-        PROXY_PROPERTIES.put("pivotX", PIVOT_X);
-        PROXY_PROPERTIES.put("pivotY", PIVOT_Y);
-        PROXY_PROPERTIES.put("translationX", TRANSLATION_X);
-        PROXY_PROPERTIES.put("translationY", TRANSLATION_Y);
-        PROXY_PROPERTIES.put("rotation", ROTATION);
-        PROXY_PROPERTIES.put("rotationX", ROTATION_X);
-        PROXY_PROPERTIES.put("rotationY", ROTATION_Y);
-        PROXY_PROPERTIES.put("scaleX", SCALE_X);
-        PROXY_PROPERTIES.put("scaleY", SCALE_Y);
-        PROXY_PROPERTIES.put("scrollX", SCROLL_X);
-        PROXY_PROPERTIES.put("scrollY", SCROLL_Y);
-        PROXY_PROPERTIES.put("x", X);
-        PROXY_PROPERTIES.put("y", Y);
-    }
-
-    private Object mTarget;
-    private String mPropertyName;
-    private Property mProperty;
-    private boolean mAutoCancel = false;
-
-    public void setPropertyName(String propertyName) {
-        if (mValues != null) {
-            PropertyValuesHolder valuesHolder = mValues[0];
-            String oldName = valuesHolder.getPropertyName();
-            valuesHolder.setPropertyName(propertyName);
-            mValuesMap.remove(oldName);
-            mValuesMap.put(propertyName, valuesHolder);
-        }
-        mPropertyName = propertyName;
-        mInitialized = false;
-    }
-
-    public void setProperty(Property property) {
-        if (mValues != null) {
-            PropertyValuesHolder valuesHolder = mValues[0];
-            String oldName = valuesHolder.getPropertyName();
-            valuesHolder.setProperty(property);
-            mValuesMap.remove(oldName);
-            mValuesMap.put(mPropertyName, valuesHolder);
-        }
-        if (mProperty != null) {
-            mPropertyName = property.getName();
-        }
-        mProperty = property;
-        mInitialized = false;
-    }
-
-    public String getPropertyName() {
-        String propertyName = null;
-        if (mPropertyName != null) {
-            propertyName = mPropertyName;
-        } else if (mProperty != null) {
-            propertyName = mProperty.getName();
-        } else if (mValues != null && mValues.length > 0) {
-            for (int i = 0; i < mValues.length; ++i) {
-                if (i == 0) {
-                    propertyName = "";
-                } else {
-                    propertyName += ",";
-                }
-                propertyName += mValues[i].getPropertyName();
-            }
-        }
-        return propertyName;
-    }
-
-    public ObjectAnimator10() {
-
-    }
-
-    private ObjectAnimator10(Object target, String propertyName) {
-        mTarget = target;
-        setPropertyName(propertyName);
-    }
-
-    private <T> ObjectAnimator10(T target, Property<T, ?> property) {
-        mTarget = target;
-        setProperty(property);
-    }
-
-    public static ObjectAnimator10 ofInt(Object target, String propertyName, int... values) {
-        ObjectAnimator10 anim = new ObjectAnimator10(target, propertyName);
-        anim.setIntValues(values);
-        return anim;
-    }
-
-    public static <T> ObjectAnimator10 ofInt(T target, Property<T, Integer> property, int... values) {
-        ObjectAnimator10 anim = new ObjectAnimator10(target, property);
-        anim.setIntValues(values);
-        return anim;
-    }
-
-    public static ObjectAnimator10 ofFloat(Object target, String propertyName, float... values) {
-        ObjectAnimator10 anim = new ObjectAnimator10(target, propertyName);
-        anim.setFloatValues(values);
-        return anim;
-    }
-
-    public static <T> ObjectAnimator10 ofFloat(T target, Property<T, Float> property, float... values) {
-        ObjectAnimator10 anim = new ObjectAnimator10(target, property);
-        anim.setFloatValues(values);
-        return anim;
-    }
-
-    public static ObjectAnimator10 ofObject(Object target, String propertyName, TypeEvaluator evaluator, Object... values) {
-        ObjectAnimator10 anim = new ObjectAnimator10(target, propertyName);
-        anim.setObjectValues(values);
-        anim.setEvaluator(evaluator);
-        return anim;
-    }
-
-    public static <T, V> ObjectAnimator10 ofObject(T target, Property<T, V> property, TypeEvaluator<V> evaluator, V... values) {
-        ObjectAnimator10 anim = new ObjectAnimator10(target, property);
-        anim.setObjectValues(values);
-        anim.setEvaluator(evaluator);
-        return anim;
-    }
-
-    public static ObjectAnimator10 ofPropertyValuesHolder(Object target, PropertyValuesHolder... values) {
-        ObjectAnimator10 anim = new ObjectAnimator10();
-        anim.mTarget = target;
-        anim.setValues(values);
-        return anim;
-    }
-
-    @SuppressWarnings("unchecked")
-    @Override
-    public void setIntValues(int... values) {
-        if (mValues == null || mValues.length == 0) {
-            if (mProperty != null) {
-                setValues(PropertyValuesHolder.ofInt(mProperty, values));
-            } else {
-                setValues(PropertyValuesHolder.ofInt(mPropertyName, values));
-            }
-        } else {
-            super.setIntValues(values);
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    @Override
-    public void setFloatValues(float... values) {
-        if (mValues == null || mValues.length == 0) {
-            if (mProperty != null) {
-                setValues(PropertyValuesHolder.ofFloat(mProperty, values));
-            } else {
-                setValues(PropertyValuesHolder.ofFloat(mPropertyName, values));
-            }
-        } else {
-            super.setFloatValues(values);
-        }
-    }
-
-    @Override
-    public void setObjectValues(Object... values) {
-        if (mValues == null || mValues.length == 0) {
-            if (mProperty != null) {
-                setValues(PropertyValuesHolder.ofObject(mProperty, null, values));
-            } else {
-                setValues(PropertyValuesHolder.ofObject(mPropertyName, null, values));
-            }
-        } else {
-            super.setObjectValues(values);
-        }
-    }
-
-    public void setAutoCancel(boolean cancel) {
-        mAutoCancel = cancel;
-    }
-
-    private boolean hasSameTargetAndProperties(Animator10 anim) {
-        if (anim instanceof ObjectAnimator10) {
-            PropertyValuesHolder[] theirValues = ((ObjectAnimator10) anim).getValues();
-            if (((ObjectAnimator10) anim).getTarget() == mTarget &&
-                    mValues.length == theirValues.length) {
-                for (int i = 0; i < mValues.length; ++i) {
-                    PropertyValuesHolder pvhMine = mValues[i];
-                    PropertyValuesHolder pvhTheirs = theirValues[i];
-                    if (pvhMine.getPropertyName() == null ||
-                            !pvhMine.getPropertyName().equals(pvhTheirs.getPropertyName())) {
-                        return false;
-                    }
-                }
-                return true;
-            }
-        }
-        return false;
-    }
-
-    @Override
-    public void start() {
-        AnimationHandler handler = sAnimationHandler.get();
-        if (handler != null) {
-            int numAnims = handler.mAnimations.size();
-            for (int i = numAnims - 1; i >= 0; i--) {
-                if (handler.mAnimations.get(i) instanceof ObjectAnimator10) {
-                    ObjectAnimator10 anim = (ObjectAnimator10) handler.mAnimations.get(i);
-                    if (anim.mAutoCancel && hasSameTargetAndProperties(anim)) {
-                        anim.cancel();
-                    }
-                }
-            }
-            numAnims = handler.mPendingAnimations.size();
-            for (int i = numAnims - 1; i >= 0; i--) {
-                if (handler.mPendingAnimations.get(i) instanceof ObjectAnimator10) {
-                    ObjectAnimator10 anim = (ObjectAnimator10) handler.mPendingAnimations.get(i);
-                    if (anim.mAutoCancel && hasSameTargetAndProperties(anim)) {
-                        anim.cancel();
-                    }
-                }
-            }
-            numAnims = handler.mDelayedAnims.size();
-            for (int i = numAnims - 1; i >= 0; i--) {
-                if (handler.mDelayedAnims.get(i) instanceof ObjectAnimator10) {
-                    ObjectAnimator10 anim = (ObjectAnimator10) handler.mDelayedAnims.get(i);
-                    if (anim.mAutoCancel && hasSameTargetAndProperties(anim)) {
-                        anim.cancel();
-                    }
-                }
-            }
-        }
-        super.start();
-    }
-
-    @Override
-    void initAnimation() {
-        if (!mInitialized) {
-            if ((mProperty == null) && (mTarget instanceof View) && PROXY_PROPERTIES.containsKey(mPropertyName)) {
-                setProperty(PROXY_PROPERTIES.get(mPropertyName));
-            }
-            int numValues = mValues.length;
-            for (PropertyValuesHolder mValue : mValues) {
-                mValue.setupSetterAndGetter(mTarget);
-            }
-            super.initAnimation();
-        }
-    }
-
-    @Override
-    public ObjectAnimator10 setDuration(long duration) {
-        super.setDuration(duration);
-        return this;
-    }
-
-    public Object getTarget() {
-        return mTarget;
-    }
-
-    @Override
-    public void setTarget(Object target) {
-        if (mTarget != target) {
-            final Object oldTarget = mTarget;
-            mTarget = target;
-            if (oldTarget != null && target != null && oldTarget.getClass() == target.getClass()) {
-                return;
-            }
-            mInitialized = false;
-        }
-    }
-
-    @Override
-    public void setupStartValues() {
-        initAnimation();
-        int numValues = mValues.length;
-        for (PropertyValuesHolder mValue : mValues) {
-            mValue.setupStartValue(mTarget);
-        }
-    }
-
-    @Override
-    public void setupEndValues() {
-        initAnimation();
-        int numValues = mValues.length;
-        for (PropertyValuesHolder mValue : mValues) {
-            mValue.setupEndValue(mTarget);
-        }
-    }
-
-    @Override
-    void animateValue(float fraction) {
-        super.animateValue(fraction);
-        int numValues = mValues.length;
-        for (PropertyValuesHolder mValue : mValues) {
-            mValue.setAnimatedValue(mTarget);
-        }
-    }
-
-    @Override
-    public ObjectAnimator10 clone() {
-        return (ObjectAnimator10) super.clone();
-    }
-}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/Property.java b/TMessagesProj/src/main/java/org/telegram/messenger/Animation/Property.java
deleted file mode 100755
index 98983e162..000000000
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/Property.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.telegram.messenger.Animation;
-
-public abstract class Property<T, V> {
-
-    private final String mName;
-    private final Class<V> mType;
-
-    public static <T, V> Property<T, V> of(Class<T> hostType, Class<V> valueType, String name) {
-        return new ReflectiveProperty<T, V>(hostType, valueType, name);
-    }
-
-    public Property(Class<V> type, String name) {
-        mName = name;
-        mType = type;
-    }
-
-    public boolean isReadOnly() {
-        return false;
-    }
-
-    public void set(T object, V value) {
-        throw new UnsupportedOperationException("Property " + getName() +" is read-only");
-    }
-
-    public abstract V get(T object);
-
-    public String getName() {
-        return mName;
-    }
-
-    public Class<V> getType() {
-        return mType;
-    }
-}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/PropertyValuesHolder.java b/TMessagesProj/src/main/java/org/telegram/messenger/Animation/PropertyValuesHolder.java
deleted file mode 100644
index c4ab83b4c..000000000
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/PropertyValuesHolder.java
+++ /dev/null
@@ -1,545 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.telegram.messenger.Animation;
-
-import java.lang.reflect.Method;
-import java.util.HashMap;
-import java.util.concurrent.locks.ReentrantReadWriteLock;
-
-public class PropertyValuesHolder implements Cloneable {
-
-    String mPropertyName;
-    protected Property mProperty;
-    Method mSetter = null;
-    private Method mGetter = null;
-    Class mValueType;
-    KeyframeSet mKeyframeSet = null;
-
-    private static final TypeEvaluator sIntEvaluator = new IntEvaluator();
-    private static final TypeEvaluator sFloatEvaluator = new FloatEvaluator();
-
-    private static Class[] FLOAT_VARIANTS = {float.class, Float.class, double.class, int.class, Double.class, Integer.class};
-    private static Class[] INTEGER_VARIANTS = {int.class, Integer.class, float.class, double.class, Float.class, Double.class};
-    private static Class[] DOUBLE_VARIANTS = {double.class, Double.class, float.class, int.class, Float.class, Integer.class};
-
-    private static final HashMap<Class, HashMap<String, Method>> sSetterPropertyMap = new HashMap<Class, HashMap<String, Method>>();
-    private static final HashMap<Class, HashMap<String, Method>> sGetterPropertyMap = new HashMap<Class, HashMap<String, Method>>();
-
-    final ReentrantReadWriteLock mPropertyMapLock = new ReentrantReadWriteLock();
-    final Object[] mTmpValueArray = new Object[1];
-
-    private TypeEvaluator mEvaluator;
-
-    private Object mAnimatedValue;
-
-    private PropertyValuesHolder(String propertyName) {
-        mPropertyName = propertyName;
-    }
-
-    private PropertyValuesHolder(Property property) {
-        mProperty = property;
-        if (property != null) {
-            mPropertyName = property.getName();
-        }
-    }
-
-    public static PropertyValuesHolder ofInt(String propertyName, int... values) {
-        return new IntPropertyValuesHolder(propertyName, values);
-    }
-
-    public static PropertyValuesHolder ofInt(Property<?, Integer> property, int... values) {
-        return new IntPropertyValuesHolder(property, values);
-    }
-
-    public static PropertyValuesHolder ofFloat(String propertyName, float... values) {
-        return new FloatPropertyValuesHolder(propertyName, values);
-    }
-
-    public static PropertyValuesHolder ofFloat(Property<?, Float> property, float... values) {
-        return new FloatPropertyValuesHolder(property, values);
-    }
-
-    public static PropertyValuesHolder ofObject(String propertyName, TypeEvaluator evaluator,
-                                                Object... values) {
-        PropertyValuesHolder pvh = new PropertyValuesHolder(propertyName);
-        pvh.setObjectValues(values);
-        pvh.setEvaluator(evaluator);
-        return pvh;
-    }
-
-    public static <V> PropertyValuesHolder ofObject(Property property,
-                                                    TypeEvaluator<V> evaluator, V... values) {
-        PropertyValuesHolder pvh = new PropertyValuesHolder(property);
-        pvh.setObjectValues(values);
-        pvh.setEvaluator(evaluator);
-        return pvh;
-    }
-
-    public static PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values) {
-        KeyframeSet keyframeSet = KeyframeSet.ofKeyframe(values);
-        if (keyframeSet instanceof IntKeyframeSet) {
-            return new IntPropertyValuesHolder(propertyName, (IntKeyframeSet) keyframeSet);
-        } else if (keyframeSet instanceof FloatKeyframeSet) {
-            return new FloatPropertyValuesHolder(propertyName, (FloatKeyframeSet) keyframeSet);
-        } else {
-            PropertyValuesHolder pvh = new PropertyValuesHolder(propertyName);
-            pvh.mKeyframeSet = keyframeSet;
-            pvh.mValueType = values[0].getType();
-            return pvh;
-        }
-    }
-
-    public static PropertyValuesHolder ofKeyframe(Property property, Keyframe... values) {
-        KeyframeSet keyframeSet = KeyframeSet.ofKeyframe(values);
-        if (keyframeSet instanceof IntKeyframeSet) {
-            return new IntPropertyValuesHolder(property, (IntKeyframeSet) keyframeSet);
-        } else if (keyframeSet instanceof FloatKeyframeSet) {
-            return new FloatPropertyValuesHolder(property, (FloatKeyframeSet) keyframeSet);
-        } else {
-            PropertyValuesHolder pvh = new PropertyValuesHolder(property);
-            pvh.mKeyframeSet = keyframeSet;
-            pvh.mValueType = values[0].getType();
-            return pvh;
-        }
-    }
-
-    public void setIntValues(int... values) {
-        mValueType = int.class;
-        mKeyframeSet = KeyframeSet.ofInt(values);
-    }
-
-    public void setFloatValues(float... values) {
-        mValueType = float.class;
-        mKeyframeSet = KeyframeSet.ofFloat(values);
-    }
-
-    public void setKeyframes(Keyframe... values) {
-        int numKeyframes = values.length;
-        Keyframe keyframes[] = new Keyframe[Math.max(numKeyframes, 2)];
-        mValueType = values[0].getType();
-        System.arraycopy(values, 0, keyframes, 0, numKeyframes);
-        mKeyframeSet = new KeyframeSet(keyframes);
-    }
-
-    public void setObjectValues(Object... values) {
-        mValueType = values[0].getClass();
-        mKeyframeSet = KeyframeSet.ofObject(values);
-    }
-
-    @SuppressWarnings("unchecked")
-    private Method getPropertyFunction(Class targetClass, String prefix, Class valueType) {
-        Method returnVal = null;
-        String methodName = getMethodName(prefix, mPropertyName);
-        Class args[] = null;
-        if (valueType == null) {
-            try {
-                returnVal = targetClass.getMethod(methodName);
-            } catch (Throwable e) {
-                try {
-                    returnVal = targetClass.getDeclaredMethod(methodName);
-                    returnVal.setAccessible(true);
-                } catch (Throwable e2) {
-                    e2.printStackTrace();
-                }
-            }
-        } else {
-            args = new Class[1];
-            Class typeVariants[];
-            if (mValueType.equals(Float.class)) {
-                typeVariants = FLOAT_VARIANTS;
-            } else if (mValueType.equals(Integer.class)) {
-                typeVariants = INTEGER_VARIANTS;
-            } else if (mValueType.equals(Double.class)) {
-                typeVariants = DOUBLE_VARIANTS;
-            } else {
-                typeVariants = new Class[1];
-                typeVariants[0] = mValueType;
-            }
-            for (Class typeVariant : typeVariants) {
-                args[0] = typeVariant;
-                try {
-                    returnVal = targetClass.getMethod(methodName, args);
-                    mValueType = typeVariant;
-                    return returnVal;
-                } catch (Throwable e) {
-                    try {
-                        returnVal = targetClass.getDeclaredMethod(methodName, args);
-                        returnVal.setAccessible(true);
-                        mValueType = typeVariant;
-                        return returnVal;
-                    } catch (Throwable e2) {
-                        // Swallow the error and keep trying other variants
-                    }
-                }
-            }
-        }
-
-        return returnVal;
-    }
-
-    private Method setupSetterOrGetter(Class targetClass, HashMap<Class, HashMap<String, Method>> propertyMapMap, String prefix, Class valueType) {
-        Method setterOrGetter = null;
-        try {
-            mPropertyMapLock.writeLock().lock();
-            HashMap<String, Method> propertyMap = propertyMapMap.get(targetClass);
-            if (propertyMap != null) {
-                setterOrGetter = propertyMap.get(mPropertyName);
-            }
-            if (setterOrGetter == null) {
-                setterOrGetter = getPropertyFunction(targetClass, prefix, valueType);
-                if (propertyMap == null) {
-                    propertyMap = new HashMap<String, Method>();
-                    propertyMapMap.put(targetClass, propertyMap);
-                }
-                propertyMap.put(mPropertyName, setterOrGetter);
-            }
-        } finally {
-            mPropertyMapLock.writeLock().unlock();
-        }
-        return setterOrGetter;
-    }
-
-    void setupSetter(Class targetClass) {
-        mSetter = setupSetterOrGetter(targetClass, sSetterPropertyMap, "set", mValueType);
-    }
-
-    private void setupGetter(Class targetClass) {
-        mGetter = setupSetterOrGetter(targetClass, sGetterPropertyMap, "get", null);
-    }
-
-    @SuppressWarnings("unchecked")
-    void setupSetterAndGetter(Object target) {
-        if (mProperty != null) {
-            try {
-                Object testValue = mProperty.get(target);
-                for (Keyframe kf : mKeyframeSet.mKeyframes) {
-                    if (!kf.hasValue()) {
-                        kf.setValue(mProperty.get(target));
-                    }
-                }
-                return;
-            } catch (Throwable e) {
-                mProperty = null;
-            }
-        }
-        Class targetClass = target.getClass();
-        if (mSetter == null) {
-            setupSetter(targetClass);
-        }
-        for (Keyframe kf : mKeyframeSet.mKeyframes) {
-            if (!kf.hasValue()) {
-                if (mGetter == null) {
-                    setupGetter(targetClass);
-                    if (mGetter == null) {
-                        return;
-                    }
-                }
-                try {
-                    kf.setValue(mGetter.invoke(target));
-                } catch (Throwable e) {
-                    e.printStackTrace();
-                }
-            }
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    private void setupValue(Object target, Keyframe kf) {
-        if (mProperty != null) {
-            kf.setValue(mProperty.get(target));
-        }
-        try {
-            if (mGetter == null) {
-                Class targetClass = target.getClass();
-                setupGetter(targetClass);
-                if (mGetter == null) {
-                    return;
-                }
-            }
-            kf.setValue(mGetter.invoke(target));
-        } catch (Throwable e) {
-            e.printStackTrace();
-        }
-    }
-
-    void setupStartValue(Object target) {
-        setupValue(target, mKeyframeSet.mKeyframes.get(0));
-    }
-
-    void setupEndValue(Object target) {
-        setupValue(target, mKeyframeSet.mKeyframes.get(mKeyframeSet.mKeyframes.size() - 1));
-    }
-
-    @Override
-    public PropertyValuesHolder clone() {
-        try {
-            PropertyValuesHolder newPVH = (PropertyValuesHolder) super.clone();
-            newPVH.mPropertyName = mPropertyName;
-            newPVH.mProperty = mProperty;
-            newPVH.mKeyframeSet = mKeyframeSet.clone();
-            newPVH.mEvaluator = mEvaluator;
-            return newPVH;
-        } catch (CloneNotSupportedException e) {
-            return null;
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    void setAnimatedValue(Object target) {
-        if (mProperty != null) {
-            mProperty.set(target, getAnimatedValue());
-        }
-        if (mSetter != null) {
-            try {
-                mTmpValueArray[0] = getAnimatedValue();
-                mSetter.invoke(target, mTmpValueArray);
-            } catch (Throwable e) {
-                e.printStackTrace();
-            }
-        }
-    }
-
-    void init() {
-        if (mEvaluator == null) {
-            mEvaluator = (mValueType == Integer.class) ? sIntEvaluator : (mValueType == Float.class) ? sFloatEvaluator : null;
-        }
-        if (mEvaluator != null) {
-            mKeyframeSet.setEvaluator(mEvaluator);
-        }
-    }
-
-    public void setEvaluator(TypeEvaluator evaluator) {
-        mEvaluator = evaluator;
-        mKeyframeSet.setEvaluator(evaluator);
-    }
-
-    void calculateValue(float fraction) {
-        mAnimatedValue = mKeyframeSet.getValue(fraction);
-    }
-
-    public void setPropertyName(String propertyName) {
-        mPropertyName = propertyName;
-    }
-
-    public void setProperty(Property property) {
-        mProperty = property;
-    }
-
-    public String getPropertyName() {
-        return mPropertyName;
-    }
-
-    Object getAnimatedValue() {
-        return mAnimatedValue;
-    }
-
-    @Override
-    public String toString() {
-        return mPropertyName + ": " + mKeyframeSet.toString();
-    }
-
-    static String getMethodName(String prefix, String propertyName) {
-        if (propertyName == null || propertyName.length() == 0) {
-            return prefix;
-        }
-        char firstLetter = Character.toUpperCase(propertyName.charAt(0));
-        String theRest = propertyName.substring(1);
-        return prefix + firstLetter + theRest;
-    }
-
-    static class IntPropertyValuesHolder extends PropertyValuesHolder {
-        private static final HashMap<Class, HashMap<String, Integer>> sJNISetterPropertyMap = new HashMap<Class, HashMap<String, Integer>>();
-        private IntProperty mIntProperty;
-
-        IntKeyframeSet mIntKeyframeSet;
-        int mIntAnimatedValue;
-
-        public IntPropertyValuesHolder(String propertyName, IntKeyframeSet keyframeSet) {
-            super(propertyName);
-            mValueType = int.class;
-            mKeyframeSet = keyframeSet;
-            mIntKeyframeSet = (IntKeyframeSet) mKeyframeSet;
-        }
-
-        public IntPropertyValuesHolder(Property property, IntKeyframeSet keyframeSet) {
-            super(property);
-            mValueType = int.class;
-            mKeyframeSet = keyframeSet;
-            mIntKeyframeSet = (IntKeyframeSet) mKeyframeSet;
-            if (property instanceof IntProperty) {
-                mIntProperty = (IntProperty) mProperty;
-            }
-        }
-
-        public IntPropertyValuesHolder(String propertyName, int... values) {
-            super(propertyName);
-            setIntValues(values);
-        }
-
-        public IntPropertyValuesHolder(Property property, int... values) {
-            super(property);
-            setIntValues(values);
-            if (property instanceof IntProperty) {
-                mIntProperty = (IntProperty) mProperty;
-            }
-        }
-
-        @Override
-        public void setIntValues(int... values) {
-            super.setIntValues(values);
-            mIntKeyframeSet = (IntKeyframeSet) mKeyframeSet;
-        }
-
-        @Override
-        void calculateValue(float fraction) {
-            mIntAnimatedValue = mIntKeyframeSet.getIntValue(fraction);
-        }
-
-        @Override
-        Object getAnimatedValue() {
-            return mIntAnimatedValue;
-        }
-
-        @Override
-        public IntPropertyValuesHolder clone() {
-            IntPropertyValuesHolder newPVH = (IntPropertyValuesHolder) super.clone();
-            newPVH.mIntKeyframeSet = (IntKeyframeSet) newPVH.mKeyframeSet;
-            return newPVH;
-        }
-
-        @SuppressWarnings("unchecked")
-        @Override
-        void setAnimatedValue(Object target) {
-            if (mIntProperty != null) {
-                mIntProperty.setValue(target, mIntAnimatedValue);
-                return;
-            }
-            if (mProperty != null) {
-                mProperty.set(target, mIntAnimatedValue);
-                return;
-            }
-            if (mSetter != null) {
-                try {
-                    mTmpValueArray[0] = mIntAnimatedValue;
-                    mSetter.invoke(target, mTmpValueArray);
-                } catch (Throwable e) {
-                    e.printStackTrace();
-                }
-            }
-        }
-
-        @Override
-        void setupSetter(Class targetClass) {
-            if (mProperty != null) {
-                return;
-            }
-
-            super.setupSetter(targetClass);
-        }
-    }
-
-    static class FloatPropertyValuesHolder extends PropertyValuesHolder {
-
-        private static final HashMap<Class, HashMap<String, Integer>> sJNISetterPropertyMap = new HashMap<Class, HashMap<String, Integer>>();
-        private FloatProperty10 mFloatProperty;
-
-        FloatKeyframeSet mFloatKeyframeSet;
-        float mFloatAnimatedValue;
-
-        public FloatPropertyValuesHolder(String propertyName, FloatKeyframeSet keyframeSet) {
-            super(propertyName);
-            mValueType = float.class;
-            mKeyframeSet = keyframeSet;
-            mFloatKeyframeSet = (FloatKeyframeSet) mKeyframeSet;
-        }
-
-        public FloatPropertyValuesHolder(Property property, FloatKeyframeSet keyframeSet) {
-            super(property);
-            mValueType = float.class;
-            mKeyframeSet = keyframeSet;
-            mFloatKeyframeSet = (FloatKeyframeSet) mKeyframeSet;
-            if (property instanceof FloatProperty10) {
-                mFloatProperty = (FloatProperty10) mProperty;
-            }
-        }
-
-        public FloatPropertyValuesHolder(String propertyName, float... values) {
-            super(propertyName);
-            setFloatValues(values);
-        }
-
-        public FloatPropertyValuesHolder(Property property, float... values) {
-            super(property);
-            setFloatValues(values);
-            if (property instanceof FloatProperty10) {
-                mFloatProperty = (FloatProperty10) mProperty;
-            }
-        }
-
-        @Override
-        public void setFloatValues(float... values) {
-            super.setFloatValues(values);
-            mFloatKeyframeSet = (FloatKeyframeSet) mKeyframeSet;
-        }
-
-        @Override
-        void calculateValue(float fraction) {
-            mFloatAnimatedValue = mFloatKeyframeSet.getFloatValue(fraction);
-        }
-
-        @Override
-        Object getAnimatedValue() {
-            return mFloatAnimatedValue;
-        }
-
-        @Override
-        public FloatPropertyValuesHolder clone() {
-            FloatPropertyValuesHolder newPVH = (FloatPropertyValuesHolder) super.clone();
-            newPVH.mFloatKeyframeSet = (FloatKeyframeSet) newPVH.mKeyframeSet;
-            return newPVH;
-        }
-
-        @SuppressWarnings("unchecked")
-        @Override
-        void setAnimatedValue(Object target) {
-            if (mFloatProperty != null) {
-                mFloatProperty.setValue(target, mFloatAnimatedValue);
-                return;
-            }
-            if (mProperty != null) {
-                mProperty.set(target, mFloatAnimatedValue);
-                return;
-            }
-            if (mSetter != null) {
-                try {
-                    mTmpValueArray[0] = mFloatAnimatedValue;
-                    mSetter.invoke(target, mTmpValueArray);
-                } catch (Throwable e) {
-                    e.printStackTrace();
-                }
-            }
-        }
-
-        @Override
-        void setupSetter(Class targetClass) {
-            if (mProperty != null) {
-                return;
-            }
-            super.setupSetter(targetClass);
-        }
-    }
-}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/ReflectiveProperty.java b/TMessagesProj/src/main/java/org/telegram/messenger/Animation/ReflectiveProperty.java
deleted file mode 100755
index 47b65aac9..000000000
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/ReflectiveProperty.java
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.telegram.messenger.Animation;
-
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-
-/**
- * Internal class to automatically generate a Property for a given class/name pair, given the
- * specification of {@link Property#of(java.lang.Class, java.lang.Class, java.lang.String)}
- */
-class ReflectiveProperty<T, V> extends Property<T, V> {
-
-    private static final String PREFIX_GET = "get";
-    private static final String PREFIX_IS = "is";
-    private static final String PREFIX_SET = "set";
-    private Method mSetter;
-    private Method mGetter;
-    private Field mField;
-
-    /**
-     * For given property name 'name', look for getName/isName method or 'name' field.
-     * Also look for setName method (optional - could be readonly). Failing method getters and
-     * field results in throwing NoSuchPropertyException.
-     *
-     * @param propertyHolder The class on which the methods or field are found
-     * @param name The name of the property, where this name is capitalized and appended to
-     * "get" and "is to search for the appropriate methods. If the get/is methods are not found,
-     * the constructor will search for a field with that exact name.
-     */
-    public ReflectiveProperty(Class<T> propertyHolder, Class<V> valueType, String name) {
-         // TODO: cache reflection info for each new class/name pair
-        super(valueType, name);
-        char firstLetter = Character.toUpperCase(name.charAt(0));
-        String theRest = name.substring(1);
-        String capitalizedName = firstLetter + theRest;
-        String getterName = PREFIX_GET + capitalizedName;
-        try {
-            mGetter = propertyHolder.getMethod(getterName, (Class<?>[]) null);
-        } catch (NoSuchMethodException e) {
-            try {
-                /* The native implementation uses JNI to do reflection, which allows access to private methods.
-                 * getDeclaredMethod(..) does not find superclass methods, so it's implemented as a fallback.
-                 */
-                mGetter = propertyHolder.getDeclaredMethod(getterName, (Class<?>[]) null);
-                mGetter.setAccessible(true);
-            } catch (NoSuchMethodException e2) {
-                // getName() not available - try isName() instead
-                getterName = PREFIX_IS + capitalizedName;
-                try {
-                    mGetter = propertyHolder.getMethod(getterName, (Class<?>[]) null);
-                } catch (NoSuchMethodException e3) {
-                    try {
-                        /* The native implementation uses JNI to do reflection, which allows access to private methods.
-                         * getDeclaredMethod(..) does not find superclass methods, so it's implemented as a fallback.
-                         */
-                        mGetter = propertyHolder.getDeclaredMethod(getterName, (Class<?>[]) null);
-                        mGetter.setAccessible(true);
-                    } catch (NoSuchMethodException e4) {
-                        // Try public field instead
-                        try {
-                            mField = propertyHolder.getField(name);
-                            Class fieldType = mField.getType();
-                            if (!typesMatch(valueType, fieldType)) {
-                                throw new NoSuchPropertyException("Underlying type (" + fieldType + ") " +
-                                        "does not match Property type (" + valueType + ")");
-                            }
-                            return;
-                        } catch (NoSuchFieldException e5) {
-                            // no way to access property - throw appropriate exception
-                            throw new NoSuchPropertyException("No accessor method or field found for"
-                                    + " property with name " + name);
-                        }
-                    }
-                }
-            }
-        }
-        Class getterType = mGetter.getReturnType();
-        // Check to make sure our getter type matches our valueType
-        if (!typesMatch(valueType, getterType)) {
-            throw new NoSuchPropertyException("Underlying type (" + getterType + ") " +
-                    "does not match Property type (" + valueType + ")");
-        }
-        String setterName = PREFIX_SET + capitalizedName;
-        try {
-            // mSetter = propertyHolder.getMethod(setterName, getterType);
-            // The native implementation uses JNI to do reflection, which allows access to private methods.
-            mSetter = propertyHolder.getDeclaredMethod(setterName, getterType);
-            mSetter.setAccessible(true);
-        } catch (NoSuchMethodException ignored) {
-            // Okay to not have a setter - just a readonly property
-        }
-    }
-
-    /**
-     * Utility method to check whether the type of the underlying field/method on the target
-     * object matches the type of the Property. The extra checks for primitive types are because
-     * generics will force the Property type to be a class, whereas the type of the underlying
-     * method/field will probably be a primitive type instead. Accept float as matching Float,
-     * etc.
-     */
-    private boolean typesMatch(Class<V> valueType, Class getterType) {
-        if (getterType != valueType) {
-            if (getterType.isPrimitive()) {
-                return (getterType == float.class && valueType == Float.class) ||
-                        (getterType == int.class && valueType == Integer.class) ||
-                        (getterType == boolean.class && valueType == Boolean.class) ||
-                        (getterType == long.class && valueType == Long.class) ||
-                        (getterType == double.class && valueType == Double.class) ||
-                        (getterType == short.class && valueType == Short.class) ||
-                        (getterType == byte.class && valueType == Byte.class) ||
-                        (getterType == char.class && valueType == Character.class);
-            }
-            return false;
-        }
-        return true;
-    }
-
-    @Override
-    public void set(T object, V value) {
-        if (mSetter != null) {
-            try {
-                mSetter.invoke(object, value);
-            } catch (IllegalAccessException e) {
-                throw new AssertionError();
-            } catch (InvocationTargetException e) {
-                throw new RuntimeException(e.getCause());
-            }
-        } else if (mField != null) {
-            try {
-                mField.set(object, value);
-            } catch (IllegalAccessException e) {
-                throw new AssertionError();
-            }
-        } else {
-            throw new UnsupportedOperationException("Property " + getName() +" is read-only");
-        }
-    }
-
-    @Override
-    public V get(T object) {
-        if (mGetter != null) {
-            try {
-                return (V) mGetter.invoke(object, (Object[])null);
-            } catch (IllegalAccessException e) {
-                throw new AssertionError();
-            } catch (InvocationTargetException e) {
-                throw new RuntimeException(e.getCause());
-            }
-        } else if (mField != null) {
-            try {
-                return (V) mField.get(object);
-            } catch (IllegalAccessException e) {
-                throw new AssertionError();
-            }
-        }
-        // Should not get here: there should always be a non-null getter or field
-        throw new AssertionError();
-    }
-
-    /**
-     * Returns false if there is no setter or public field underlying this Property.
-     */
-    @Override
-    public boolean isReadOnly() {
-        return (mSetter == null && mField == null);
-    }
-}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/TypeEvaluator.java b/TMessagesProj/src/main/java/org/telegram/messenger/Animation/TypeEvaluator.java
deleted file mode 100644
index 305f8ad8d..000000000
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/TypeEvaluator.java
+++ /dev/null
@@ -1,21 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.telegram.messenger.Animation;
-
-public interface TypeEvaluator<T> {
-    T evaluate(float fraction, T startValue, T endValue);
-}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/ValueAnimator.java b/TMessagesProj/src/main/java/org/telegram/messenger/Animation/ValueAnimator.java
deleted file mode 100644
index ec4648883..000000000
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/ValueAnimator.java
+++ /dev/null
@@ -1,675 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.telegram.messenger.Animation;
-
-import android.os.Looper;
-import android.util.AndroidRuntimeException;
-import android.view.animation.AccelerateDecelerateInterpolator;
-import android.view.animation.AnimationUtils;
-import android.view.animation.Interpolator;
-import android.view.animation.LinearInterpolator;
-
-import org.telegram.messenger.AndroidUtilities;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-
-public class ValueAnimator extends Animator10 {
-
-    private static float sDurationScale = 1.0f;
-    static final int STOPPED    = 0;
-    static final int RUNNING    = 1;
-    static final int SEEKED     = 2;
-
-    long mStartTime;
-    long mSeekTime = -1;
-    private long mPauseTime;
-    private boolean mResumed = false;
-    protected static ThreadLocal<AnimationHandler> sAnimationHandler = new ThreadLocal<AnimationHandler>();
-    private static final Interpolator sDefaultInterpolator = new AccelerateDecelerateInterpolator();
-    private boolean mPlayingBackwards = false;
-    private int mCurrentIteration = 0;
-    private float mCurrentFraction = 0f;
-    private boolean mStartedDelay = false;
-    private long mDelayStartTime;
-    int mPlayingState = STOPPED;
-    private boolean mRunning = false;
-    private boolean mStarted = false;
-    private boolean mStartListenersCalled = false;
-    boolean mInitialized = false;
-
-    private long mDuration = (long)(300 * sDurationScale);
-    private long mUnscaledDuration = 300;
-    private long mStartDelay = 0;
-    private long mUnscaledStartDelay = 0;
-    private int mRepeatCount = 0;
-    private int mRepeatMode = RESTART;
-    private Interpolator mInterpolator = sDefaultInterpolator;
-    private ArrayList<AnimatorUpdateListener> mUpdateListeners = null;
-    PropertyValuesHolder[] mValues;
-    HashMap<String, PropertyValuesHolder> mValuesMap;
-
-    public static final int RESTART = 1;
-    public static final int REVERSE = 2;
-    public static final int INFINITE = -1;
-
-    public static void setDurationScale(float durationScale) {
-        sDurationScale = durationScale;
-    }
-
-    public static float getDurationScale() {
-        return sDurationScale;
-    }
-
-    public ValueAnimator() {
-
-    }
-
-    public static ValueAnimator ofInt(int... values) {
-        ValueAnimator anim = new ValueAnimator();
-        anim.setIntValues(values);
-        return anim;
-    }
-
-    public static ValueAnimator ofFloat(float... values) {
-        ValueAnimator anim = new ValueAnimator();
-        anim.setFloatValues(values);
-        return anim;
-    }
-
-    public static ValueAnimator ofPropertyValuesHolder(PropertyValuesHolder... values) {
-        ValueAnimator anim = new ValueAnimator();
-        anim.setValues(values);
-        return anim;
-    }
-
-    public static ValueAnimator ofObject(TypeEvaluator evaluator, Object... values) {
-        ValueAnimator anim = new ValueAnimator();
-        anim.setObjectValues(values);
-        anim.setEvaluator(evaluator);
-        return anim;
-    }
-
-    public void setIntValues(int... values) {
-        if (values == null || values.length == 0) {
-            return;
-        }
-        if (mValues == null || mValues.length == 0) {
-            setValues(PropertyValuesHolder.ofInt("", values));
-        } else {
-            PropertyValuesHolder valuesHolder = mValues[0];
-            valuesHolder.setIntValues(values);
-        }
-        mInitialized = false;
-    }
-
-    public void setFloatValues(float... values) {
-        if (values == null || values.length == 0) {
-            return;
-        }
-        if (mValues == null || mValues.length == 0) {
-            setValues(PropertyValuesHolder.ofFloat("", values));
-        } else {
-            PropertyValuesHolder valuesHolder = mValues[0];
-            valuesHolder.setFloatValues(values);
-        }
-        mInitialized = false;
-    }
-
-    public void setObjectValues(Object... values) {
-        if (values == null || values.length == 0) {
-            return;
-        }
-        if (mValues == null || mValues.length == 0) {
-            setValues(PropertyValuesHolder.ofObject("", null, values));
-        } else {
-            PropertyValuesHolder valuesHolder = mValues[0];
-            valuesHolder.setObjectValues(values);
-        }
-        mInitialized = false;
-    }
-
-    public void setValues(PropertyValuesHolder... values) {
-        int numValues = values.length;
-        mValues = values;
-        mValuesMap = new HashMap<String, PropertyValuesHolder>(numValues);
-        for (PropertyValuesHolder valuesHolder : values) {
-            mValuesMap.put(valuesHolder.getPropertyName(), valuesHolder);
-        }
-        mInitialized = false;
-    }
-
-    public PropertyValuesHolder[] getValues() {
-        return mValues;
-    }
-
-    void initAnimation() {
-        if (!mInitialized) {
-            int numValues = mValues.length;
-            for (PropertyValuesHolder mValue : mValues) {
-                mValue.init();
-            }
-            mInitialized = true;
-        }
-    }
-
-    public ValueAnimator setDuration(long duration) {
-        if (duration < 0) {
-            throw new IllegalArgumentException("Animators cannot have negative duration: " + duration);
-        }
-        mUnscaledDuration = duration;
-        mDuration = (long)(duration * sDurationScale);
-        return this;
-    }
-
-    public long getDuration() {
-        return mUnscaledDuration;
-    }
-
-    public void setCurrentPlayTime(long playTime) {
-        initAnimation();
-        long currentTime = AnimationUtils.currentAnimationTimeMillis();
-        if (mPlayingState != RUNNING) {
-            mSeekTime = playTime;
-            mPlayingState = SEEKED;
-        }
-        mStartTime = currentTime - playTime;
-        doAnimationFrame(currentTime);
-    }
-
-    public long getCurrentPlayTime() {
-        if (!mInitialized || mPlayingState == STOPPED) {
-            return 0;
-        }
-        return AnimationUtils.currentAnimationTimeMillis() - mStartTime;
-    }
-
-    @SuppressWarnings("unchecked")
-    protected static class AnimationHandler implements Runnable {
-
-        protected final ArrayList<ValueAnimator> mAnimations = new ArrayList<ValueAnimator>();
-        private final ArrayList<ValueAnimator> mTmpAnimations = new ArrayList<ValueAnimator>();
-        protected final ArrayList<ValueAnimator> mPendingAnimations = new ArrayList<ValueAnimator>();
-        protected final ArrayList<ValueAnimator> mDelayedAnims = new ArrayList<ValueAnimator>();
-        private final ArrayList<ValueAnimator> mEndingAnims = new ArrayList<ValueAnimator>();
-        private final ArrayList<ValueAnimator> mReadyAnims = new ArrayList<ValueAnimator>();
-
-        private boolean mAnimationScheduled;
-
-        public void start() {
-            scheduleAnimation();
-        }
-
-        private void doAnimationFrame(long frameTime) {
-            while (mPendingAnimations.size() > 0) {
-                ArrayList<ValueAnimator> pendingCopy = (ArrayList<ValueAnimator>) mPendingAnimations.clone();
-                mPendingAnimations.clear();
-                int count = pendingCopy.size();
-                for (ValueAnimator anim : pendingCopy) {
-                    if (anim.mStartDelay == 0) {
-                        anim.startAnimation(this);
-                    } else {
-                        mDelayedAnims.add(anim);
-                    }
-                }
-            }
-
-            int numDelayedAnims = mDelayedAnims.size();
-            for (ValueAnimator anim : mDelayedAnims) {
-                if (anim.delayedAnimationFrame(frameTime)) {
-                    mReadyAnims.add(anim);
-                }
-            }
-            int numReadyAnims = mReadyAnims.size();
-            if (numReadyAnims > 0) {
-                for (ValueAnimator anim : mReadyAnims) {
-                    anim.startAnimation(this);
-                    anim.mRunning = true;
-                    mDelayedAnims.remove(anim);
-                }
-                mReadyAnims.clear();
-            }
-
-            int numAnims = mAnimations.size();
-            for (ValueAnimator mAnimation : mAnimations) {
-                mTmpAnimations.add(mAnimation);
-            }
-            for (int i = 0; i < numAnims; ++i) {
-                ValueAnimator anim = mTmpAnimations.get(i);
-                if (mAnimations.contains(anim) && anim.doAnimationFrame(frameTime)) {
-                    mEndingAnims.add(anim);
-                }
-            }
-            mTmpAnimations.clear();
-            if (mEndingAnims.size() > 0) {
-                for (ValueAnimator mEndingAnim : mEndingAnims) {
-                    mEndingAnim.endAnimation(this);
-                }
-                mEndingAnims.clear();
-            }
-
-            if (!mAnimations.isEmpty() || !mDelayedAnims.isEmpty()) {
-                scheduleAnimation();
-            }
-        }
-
-        @Override
-        public void run() {
-            mAnimationScheduled = false;
-            doAnimationFrame(System.nanoTime() / 1000000);
-        }
-
-        private void scheduleAnimation() {
-            if (!mAnimationScheduled) {
-                AndroidUtilities.runOnUIThread(this);
-                mAnimationScheduled = true;
-            }
-        }
-    }
-
-    public long getStartDelay() {
-        return mUnscaledStartDelay;
-    }
-
-    public void setStartDelay(long startDelay) {
-        this.mStartDelay = (long)(startDelay * sDurationScale);
-        mUnscaledStartDelay = startDelay;
-    }
-
-    public Object getAnimatedValue() {
-        if (mValues != null && mValues.length > 0) {
-            return mValues[0].getAnimatedValue();
-        }
-        return null;
-    }
-
-    public Object getAnimatedValue(String propertyName) {
-        PropertyValuesHolder valuesHolder = mValuesMap.get(propertyName);
-        if (valuesHolder != null) {
-            return valuesHolder.getAnimatedValue();
-        } else {
-            return null;
-        }
-    }
-
-    public void setRepeatCount(int value) {
-        mRepeatCount = value;
-    }
-
-    public int getRepeatCount() {
-        return mRepeatCount;
-    }
-
-    public void setRepeatMode(int value) {
-        mRepeatMode = value;
-    }
-
-    public int getRepeatMode() {
-        return mRepeatMode;
-    }
-
-    public void addUpdateListener(AnimatorUpdateListener listener) {
-        if (mUpdateListeners == null) {
-            mUpdateListeners = new ArrayList<AnimatorUpdateListener>();
-        }
-        mUpdateListeners.add(listener);
-    }
-
-    public void removeAllUpdateListeners() {
-        if (mUpdateListeners == null) {
-            return;
-        }
-        mUpdateListeners.clear();
-        mUpdateListeners = null;
-    }
-
-    public void removeUpdateListener(AnimatorUpdateListener listener) {
-        if (mUpdateListeners == null) {
-            return;
-        }
-        mUpdateListeners.remove(listener);
-        if (mUpdateListeners.size() == 0) {
-            mUpdateListeners = null;
-        }
-    }
-
-    @Override
-    public void setInterpolator(Interpolator value) {
-        if (value != null) {
-            mInterpolator = value;
-        } else {
-            mInterpolator = new LinearInterpolator();
-        }
-    }
-
-    @Override
-    public Interpolator getInterpolator() {
-        return mInterpolator;
-    }
-
-    public void setEvaluator(TypeEvaluator value) {
-        if (value != null && mValues != null && mValues.length > 0) {
-            mValues[0].setEvaluator(value);
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    private void notifyStartListeners() {
-        if (mListeners != null && !mStartListenersCalled) {
-            ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
-            int numListeners = tmpListeners.size();
-            for (AnimatorListener tmpListener : tmpListeners) {
-                tmpListener.onAnimationStart(this);
-            }
-        }
-        mStartListenersCalled = true;
-    }
-
-    private void start(boolean playBackwards) {
-        if (Looper.myLooper() == null) {
-            throw new AndroidRuntimeException("Animators may only be run on Looper threads");
-        }
-        mPlayingBackwards = playBackwards;
-        mCurrentIteration = 0;
-        mPlayingState = STOPPED;
-        mStarted = true;
-        mStartedDelay = false;
-        mPaused = false;
-        AnimationHandler animationHandler = getOrCreateAnimationHandler();
-        animationHandler.mPendingAnimations.add(this);
-        if (mStartDelay == 0) {
-            setCurrentPlayTime(0);
-            mPlayingState = STOPPED;
-            mRunning = true;
-            notifyStartListeners();
-        }
-        animationHandler.start();
-    }
-
-    @Override
-    public void start() {
-        start(false);
-    }
-
-    @SuppressWarnings("unchecked")
-    @Override
-    public void cancel() {
-        AnimationHandler handler = getOrCreateAnimationHandler();
-        if (mPlayingState != STOPPED || handler.mPendingAnimations.contains(this) || handler.mDelayedAnims.contains(this)) {
-            if ((mStarted || mRunning) && mListeners != null) {
-                if (!mRunning) {
-                    notifyStartListeners();
-                }
-                ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
-                for (AnimatorListener listener : tmpListeners) {
-                    listener.onAnimationCancel(this);
-                }
-            }
-            endAnimation(handler);
-        }
-    }
-
-    @Override
-    public void end() {
-        AnimationHandler handler = getOrCreateAnimationHandler();
-        if (!handler.mAnimations.contains(this) && !handler.mPendingAnimations.contains(this)) {
-            mStartedDelay = false;
-            startAnimation(handler);
-            mStarted = true;
-        } else if (!mInitialized) {
-            initAnimation();
-        }
-        animateValue(mPlayingBackwards ? 0f : 1f);
-        endAnimation(handler);
-    }
-
-    @Override
-    public void resume() {
-        if (mPaused) {
-            mResumed = true;
-        }
-        super.resume();
-    }
-
-    @Override
-    public void pause() {
-        boolean previouslyPaused = mPaused;
-        super.pause();
-        if (!previouslyPaused && mPaused) {
-            mPauseTime = -1;
-            mResumed = false;
-        }
-    }
-
-    @Override
-    public boolean isRunning() {
-        return (mPlayingState == RUNNING || mRunning);
-    }
-
-    @Override
-    public boolean isStarted() {
-        return mStarted;
-    }
-
-    public void reverse() {
-        mPlayingBackwards = !mPlayingBackwards;
-        if (mPlayingState == RUNNING) {
-            long currentTime = AnimationUtils.currentAnimationTimeMillis();
-            long currentPlayTime = currentTime - mStartTime;
-            long timeLeft = mDuration - currentPlayTime;
-            mStartTime = currentTime - timeLeft;
-        } else if (mStarted) {
-            end();
-        } else {
-            start(true);
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    private void endAnimation(AnimationHandler handler) {
-        handler.mAnimations.remove(this);
-        handler.mPendingAnimations.remove(this);
-        handler.mDelayedAnims.remove(this);
-        mPlayingState = STOPPED;
-        mPaused = false;
-        if ((mStarted || mRunning) && mListeners != null) {
-            if (!mRunning) {
-                notifyStartListeners();
-             }
-            ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
-            int numListeners = tmpListeners.size();
-            for (AnimatorListener tmpListener : tmpListeners) {
-                tmpListener.onAnimationEnd(this);
-            }
-        }
-        mRunning = false;
-        mStarted = false;
-        mStartListenersCalled = false;
-        mPlayingBackwards = false;
-    }
-
-    private void startAnimation(AnimationHandler handler) {
-        initAnimation();
-        handler.mAnimations.add(this);
-        if (mStartDelay > 0 && mListeners != null) {
-            notifyStartListeners();
-        }
-    }
-
-    private boolean delayedAnimationFrame(long currentTime) {
-        if (!mStartedDelay) {
-            mStartedDelay = true;
-            mDelayStartTime = currentTime;
-        } else {
-            if (mPaused) {
-                if (mPauseTime < 0) {
-                    mPauseTime = currentTime;
-                }
-                return false;
-            } else if (mResumed) {
-                mResumed = false;
-                if (mPauseTime > 0) {
-                    mDelayStartTime += (currentTime - mPauseTime);
-                }
-            }
-            long deltaTime = currentTime - mDelayStartTime;
-            if (deltaTime > mStartDelay) {
-                mStartTime = currentTime - (deltaTime - mStartDelay);
-                mPlayingState = RUNNING;
-                return true;
-            }
-        }
-        return false;
-    }
-
-    boolean animationFrame(long currentTime) {
-        boolean done = false;
-        switch (mPlayingState) {
-        case RUNNING:
-        case SEEKED:
-            float fraction = mDuration > 0 ? (float)(currentTime - mStartTime) / mDuration : 1f;
-            if (fraction >= 1f) {
-                if (mCurrentIteration < mRepeatCount || mRepeatCount == INFINITE) {
-                    if (mListeners != null) {
-                        int numListeners = mListeners.size();
-                        for (AnimatorListener mListener : mListeners) {
-                            mListener.onAnimationRepeat(this);
-                        }
-                    }
-                    if (mRepeatMode == REVERSE) {
-                        mPlayingBackwards = !mPlayingBackwards;
-                    }
-                    mCurrentIteration += (int)fraction;
-                    fraction = fraction % 1f;
-                    mStartTime += mDuration;
-                } else {
-                    done = true;
-                    fraction = Math.min(fraction, 1.0f);
-                }
-            }
-            if (mPlayingBackwards) {
-                fraction = 1f - fraction;
-            }
-            animateValue(fraction);
-            break;
-        }
-
-        return done;
-    }
-
-    final boolean doAnimationFrame(long frameTime) {
-        if (mPlayingState == STOPPED) {
-            mPlayingState = RUNNING;
-            if (mSeekTime < 0) {
-                mStartTime = frameTime;
-            } else {
-                mStartTime = frameTime - mSeekTime;
-                mSeekTime = -1;
-            }
-        }
-        if (mPaused) {
-            if (mPauseTime < 0) {
-                mPauseTime = frameTime;
-            }
-            return false;
-        } else if (mResumed) {
-            mResumed = false;
-            if (mPauseTime > 0) {
-                mStartTime += (frameTime - mPauseTime);
-            }
-        }
-        final long currentTime = Math.max(frameTime, mStartTime);
-        return animationFrame(currentTime);
-    }
-
-    public float getAnimatedFraction() {
-        return mCurrentFraction;
-    }
-
-    void animateValue(float fraction) {
-        fraction = mInterpolator.getInterpolation(fraction);
-        mCurrentFraction = fraction;
-        int numValues = mValues.length;
-        for (PropertyValuesHolder mValue : mValues) {
-            mValue.calculateValue(fraction);
-        }
-        if (mUpdateListeners != null) {
-            int numListeners = mUpdateListeners.size();
-            for (AnimatorUpdateListener mUpdateListener : mUpdateListeners) {
-                mUpdateListener.onAnimationUpdate(this);
-            }
-        }
-    }
-
-    @Override
-    public ValueAnimator clone() {
-        final ValueAnimator anim = (ValueAnimator) super.clone();
-        if (mUpdateListeners != null) {
-            ArrayList<AnimatorUpdateListener> oldListeners = mUpdateListeners;
-            anim.mUpdateListeners = new ArrayList<AnimatorUpdateListener>();
-            int numListeners = oldListeners.size();
-            for (AnimatorUpdateListener oldListener : oldListeners) {
-                anim.mUpdateListeners.add(oldListener);
-            }
-        }
-        anim.mSeekTime = -1;
-        anim.mPlayingBackwards = false;
-        anim.mCurrentIteration = 0;
-        anim.mInitialized = false;
-        anim.mPlayingState = STOPPED;
-        anim.mStartedDelay = false;
-        PropertyValuesHolder[] oldValues = mValues;
-        if (oldValues != null) {
-            int numValues = oldValues.length;
-            anim.mValues = new PropertyValuesHolder[numValues];
-            anim.mValuesMap = new HashMap<String, PropertyValuesHolder>(numValues);
-            for (int i = 0; i < numValues; ++i) {
-                PropertyValuesHolder newValuesHolder = oldValues[i].clone();
-                anim.mValues[i] = newValuesHolder;
-                anim.mValuesMap.put(newValuesHolder.getPropertyName(), newValuesHolder);
-            }
-        }
-        return anim;
-    }
-
-    public interface AnimatorUpdateListener {
-        void onAnimationUpdate(ValueAnimator animation);
-    }
-
-    public static int getCurrentAnimationsCount() {
-        AnimationHandler handler = sAnimationHandler.get();
-        return handler != null ? handler.mAnimations.size() : 0;
-    }
-
-    public static void clearAllAnimations() {
-        AnimationHandler handler = sAnimationHandler.get();
-        if (handler != null) {
-            handler.mAnimations.clear();
-            handler.mPendingAnimations.clear();
-            handler.mDelayedAnims.clear();
-        }
-    }
-
-    private static AnimationHandler getOrCreateAnimationHandler() {
-        AnimationHandler handler = sAnimationHandler.get();
-        if (handler == null) {
-            handler = new AnimationHandler();
-            sAnimationHandler.set(handler);
-        }
-        return handler;
-    }
-}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/View10.java b/TMessagesProj/src/main/java/org/telegram/messenger/Animation/View10.java
deleted file mode 100644
index 540b61a95..000000000
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Animation/View10.java
+++ /dev/null
@@ -1,349 +0,0 @@
-/*
- Copyright 2012 Jake Wharton
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-   http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
- */
-
-package org.telegram.messenger.Animation;
-
-import android.graphics.Camera;
-import android.graphics.Matrix;
-import android.graphics.RectF;
-import android.os.Build;
-import android.view.View;
-import android.view.animation.Animation;
-import android.view.animation.Transformation;
-
-import java.lang.ref.WeakReference;
-import java.util.WeakHashMap;
-
-public class View10 extends Animation {
-
-    public static boolean NEED_PROXY = Build.VERSION.SDK_INT < 11;
-
-    private static final WeakHashMap<View, View10> PROXIES = new WeakHashMap<>();
-
-    public static View10 wrap(View view) {
-        View10 proxy = PROXIES.get(view);
-        Animation animation = view.getAnimation();
-        if (proxy == null || proxy != animation && animation != null) {
-            proxy = new View10(view);
-            PROXIES.put(view, proxy);
-        } else if (animation == null) {
-            view.setAnimation(proxy);
-        }
-        return proxy;
-    }
-
-    private final WeakReference<View> mView;
-    private final Camera mCamera = new Camera();
-    private boolean mHasPivot;
-
-    private float mAlpha = 1;
-    private float mPivotX;
-    private float mPivotY;
-    private float mRotationX;
-    private float mRotationY;
-    private float mRotationZ;
-    private float mScaleX = 1;
-    private float mScaleY = 1;
-    private float mTranslationX;
-    private float mTranslationY;
-
-    private final RectF mBefore = new RectF();
-    private final RectF mAfter = new RectF();
-    private final Matrix mTempMatrix = new Matrix();
-
-    private View10(View view) {
-        setDuration(0);
-        setFillAfter(true);
-        view.setAnimation(this);
-        mView = new WeakReference<>(view);
-    }
-
-    public float getAlpha() {
-        return mAlpha;
-    }
-
-    public void setAlpha(float alpha) {
-        if (mAlpha != alpha) {
-            mAlpha = alpha;
-            View view = mView.get();
-            if (view != null) {
-                view.invalidate();
-            }
-        }
-    }
-
-    public float getPivotX() {
-        return mPivotX;
-    }
-
-    public void setPivotX(float pivotX) {
-        if (!mHasPivot || mPivotX != pivotX) {
-            prepareForUpdate();
-            mHasPivot = true;
-            mPivotX = pivotX;
-            invalidateAfterUpdate();
-        }
-    }
-
-    public float getPivotY() {
-        return mPivotY;
-    }
-
-    public void setPivotY(float pivotY) {
-        if (!mHasPivot || mPivotY != pivotY) {
-            prepareForUpdate();
-            mHasPivot = true;
-            mPivotY = pivotY;
-            invalidateAfterUpdate();
-        }
-    }
-
-    public float getRotation() {
-        return mRotationZ;
-    }
-
-    public void setRotation(float rotation) {
-        if (mRotationZ != rotation) {
-            prepareForUpdate();
-            mRotationZ = rotation;
-            invalidateAfterUpdate();
-        }
-    }
-
-    public float getRotationX() {
-        return mRotationX;
-    }
-
-    public void setRotationX(float rotationX) {
-        if (mRotationX != rotationX) {
-            prepareForUpdate();
-            mRotationX = rotationX;
-            invalidateAfterUpdate();
-        }
-    }
-
-    public float getRotationY() {
-        return mRotationY;
-    }
-
-    public void setRotationY(float rotationY) {
-        if (mRotationY != rotationY) {
-            prepareForUpdate();
-            mRotationY = rotationY;
-            invalidateAfterUpdate();
-        }
-    }
-
-    public float getScaleX() {
-        return mScaleX;
-    }
-
-    public void setScaleX(float scaleX) {
-        if (mScaleX != scaleX) {
-            prepareForUpdate();
-            mScaleX = scaleX;
-            invalidateAfterUpdate();
-        }
-    }
-
-    public float getScaleY() {
-        return mScaleY;
-    }
-
-    public void setScaleY(float scaleY) {
-        if (mScaleY != scaleY) {
-            prepareForUpdate();
-            mScaleY = scaleY;
-            invalidateAfterUpdate();
-        }
-    }
-
-    public int getScrollX() {
-        View view = mView.get();
-        if (view == null) {
-            return 0;
-        }
-        return view.getScrollX();
-    }
-
-    public void setScrollX(int value) {
-        View view = mView.get();
-        if (view != null) {
-            view.scrollTo(value, view.getScrollY());
-        }
-    }
-
-    public int getScrollY() {
-        View view = mView.get();
-        if (view == null) {
-            return 0;
-        }
-        return view.getScrollY();
-    }
-
-    public void setScrollY(int value) {
-        View view = mView.get();
-        if (view != null) {
-            view.scrollTo(view.getScrollX(), value);
-        }
-    }
-
-    public float getTranslationX() {
-        return mTranslationX;
-    }
-
-    public void setTranslationX(float translationX) {
-        if (mTranslationX != translationX) {
-            prepareForUpdate();
-            mTranslationX = translationX;
-            invalidateAfterUpdate();
-        }
-    }
-
-    public float getTranslationY() {
-        return mTranslationY;
-    }
-
-    public void setTranslationY(float translationY) {
-        if (mTranslationY != translationY) {
-            prepareForUpdate();
-            mTranslationY = translationY;
-            invalidateAfterUpdate();
-        }
-    }
-
-    public float getX() {
-        View view = mView.get();
-        if (view == null) {
-            return 0;
-        }
-        return view.getLeft() + mTranslationX;
-    }
-
-    public void setX(float x) {
-        View view = mView.get();
-        if (view != null) {
-            setTranslationX(x - view.getLeft());
-        }
-    }
-
-    public float getY() {
-        View view = mView.get();
-        if (view == null) {
-            return 0;
-        }
-        return view.getTop() + mTranslationY;
-    }
-
-    public void setY(float y) {
-        View view = mView.get();
-        if (view != null) {
-            setTranslationY(y - view.getTop());
-        }
-    }
-
-    private void prepareForUpdate() {
-        View view = mView.get();
-        if (view != null) {
-            computeRect(mBefore, view);
-        }
-    }
-
-    private void invalidateAfterUpdate() {
-        View view = mView.get();
-        if (view == null || view.getParent() == null) {
-            return;
-        }
-
-        final RectF after = mAfter;
-        computeRect(after, view);
-        after.union(mBefore);
-
-        ((View) view.getParent()).invalidate(
-                (int) Math.floor(after.left),
-                (int) Math.floor(after.top),
-                (int) Math.ceil(after.right),
-                (int) Math.ceil(after.bottom));
-    }
-
-    private void computeRect(final RectF r, View view) {
-        final float w = view.getWidth();
-        final float h = view.getHeight();
-
-        r.set(0, 0, w, h);
-
-        final Matrix m = mTempMatrix;
-        m.reset();
-        transformMatrix(m, view);
-        mTempMatrix.mapRect(r);
-
-        r.offset(view.getLeft(), view.getTop());
-
-        if (r.right < r.left) {
-            final float f = r.right;
-            r.right = r.left;
-            r.left = f;
-        }
-        if (r.bottom < r.top) {
-            final float f = r.top;
-            r.top = r.bottom;
-            r.bottom = f;
-        }
-    }
-
-    private void transformMatrix(Matrix m, View view) {
-        final float w = view.getWidth();
-        final float h = view.getHeight();
-        final boolean hasPivot = mHasPivot;
-        final float pX = hasPivot ? mPivotX : w / 2f;
-        final float pY = hasPivot ? mPivotY : h / 2f;
-
-        final float rX = mRotationX;
-        final float rY = mRotationY;
-        final float rZ = mRotationZ;
-        if ((rX != 0) || (rY != 0) || (rZ != 0)) {
-            final Camera camera = mCamera;
-            camera.save();
-            camera.rotateX(rX);
-            camera.rotateY(rY);
-            camera.rotateZ(-rZ);
-            camera.getMatrix(m);
-            camera.restore();
-            m.preTranslate(-pX, -pY);
-            m.postTranslate(pX, pY);
-        }
-
-        final float sX = mScaleX;
-        final float sY = mScaleY;
-        if ((sX != 1.0f) || (sY != 1.0f)) {
-            m.postScale(sX, sY);
-            final float sPX = -(pX / w) * ((sX * w) - w);
-            final float sPY = -(pY / h) * ((sY * h) - h);
-            m.postTranslate(sPX, sPY);
-        }
-
-        m.postTranslate(mTranslationX, mTranslationY);
-    }
-
-    @Override
-    protected void applyTransformation(float interpolatedTime, Transformation t) {
-        View view = mView.get();
-        if (view != null) {
-            t.setAlpha(mAlpha);
-            transformMatrix(t.getMatrix(), view);
-        }
-    }
-}
