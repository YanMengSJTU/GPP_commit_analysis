diff --git a/TMessagesProj/jni/image.c b/TMessagesProj/jni/image.c
index 6f1c3b251..03750dcfa 100644
--- a/TMessagesProj/jni/image.c
+++ b/TMessagesProj/jni/image.c
@@ -6,13 +6,18 @@
 #include <android/bitmap.h>
 #include <libwebp/webp/decode.h>
 #include <libwebp/webp/encode.h>
-
+#include<string.h>
 #include "utils.h"
 #include "image.h"
-extern  JBLOCKARRAY get_mem_buffer(jvirt_barray_ptr jbc );
-extern JDIMENSION get_rows_in_mem(jvirt_barray_ptr jbc );
-extern JDIMENSION  get_blocksperrow(jvirt_barray_ptr jbc );
-extern jvirt_barray_ptr  get_next(jvirt_barray_ptr jbc );
+
+extern JBLOCKARRAY get_mem_buffer(jvirt_barray_ptr jbc);
+
+extern JDIMENSION get_rows_in_mem(jvirt_barray_ptr jbc);
+
+extern JDIMENSION get_blocksperrow(jvirt_barray_ptr jbc);
+
+extern jvirt_barray_ptr get_next(jvirt_barray_ptr jbc);
+
 jclass jclass_NullPointerException;
 jclass jclass_RuntimeException;
 
@@ -37,20 +42,24 @@ jclass createGlobarRef(JNIEnv *env, jclass class) {
 }
 
 jint imageOnJNILoad(JavaVM *vm, void *reserved, JNIEnv *env) {
-    jclass_NullPointerException = createGlobarRef(env, (*env)->FindClass(env, "java/lang/NullPointerException"));
+    jclass_NullPointerException = createGlobarRef(env, (*env)->FindClass(env,
+                                                                         "java/lang/NullPointerException"));
     if (jclass_NullPointerException == 0) {
         return -1;
     }
-    jclass_RuntimeException = createGlobarRef(env, (*env)->FindClass(env, "java/lang/RuntimeException"));
+    jclass_RuntimeException = createGlobarRef(env,
+                                              (*env)->FindClass(env, "java/lang/RuntimeException"));
     if (jclass_RuntimeException == 0) {
         return -1;
     }
-    
-    jclass_Options = createGlobarRef(env, (*env)->FindClass(env, "android/graphics/BitmapFactory$Options"));
+
+    jclass_Options = createGlobarRef(env, (*env)->FindClass(env,
+                                                            "android/graphics/BitmapFactory$Options"));
     if (jclass_Options == 0) {
         return -1;
     }
-    jclass_Options_inJustDecodeBounds = (*env)->GetFieldID(env, jclass_Options, "inJustDecodeBounds", "Z");
+    jclass_Options_inJustDecodeBounds = (*env)->GetFieldID(env, jclass_Options,
+                                                           "inJustDecodeBounds", "Z");
     if (jclass_Options_inJustDecodeBounds == 0) {
         return -1;
     }
@@ -62,67 +71,70 @@ jint imageOnJNILoad(JavaVM *vm, void *reserved, JNIEnv *env) {
     if (jclass_Options_outWidth == 0) {
         return -1;
     }
-    
+
     jclass_Bitmap = createGlobarRef(env, (*env)->FindClass(env, "android/graphics/Bitmap"));
     if (jclass_Bitmap == 0) {
         return -1;
     }
-    jclass_Bitmap_createBitmap = (*env)->GetStaticMethodID(env, jclass_Bitmap, "createBitmap", "(IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;");
+    jclass_Bitmap_createBitmap = (*env)->GetStaticMethodID(env, jclass_Bitmap, "createBitmap",
+                                                           "(IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;");
     if (jclass_Bitmap_createBitmap == 0) {
         return -1;
     }
-    
+
     jclass_Config = createGlobarRef(env, (*env)->FindClass(env, "android/graphics/Bitmap$Config"));
     if (jclass_Config == 0) {
         return -1;
     }
-    jclass_Config_ARGB_8888 = (*env)->GetStaticFieldID(env, jclass_Config, "ARGB_8888", "Landroid/graphics/Bitmap$Config;");
+    jclass_Config_ARGB_8888 = (*env)->GetStaticFieldID(env, jclass_Config, "ARGB_8888",
+                                                       "Landroid/graphics/Bitmap$Config;");
     if (jclass_Config_ARGB_8888 == 0) {
         return -1;
     }
-    
+
     return JNI_VERSION_1_6;
 }
 
-static inline uint64_t get_colors (const uint8_t *p) {
-    return p[0] + (p[1] << 16) + ((uint64_t)p[2] << 32);
+static inline uint64_t get_colors(const uint8_t *p) {
+    return p[0] + (p[1] << 16) + ((uint64_t) p[2] << 32);
 }
 
-static void fastBlurMore(int imageWidth, int imageHeight, int imageStride, void *pixels, int radius) {
-    uint8_t *pix = (uint8_t *)pixels;
+static void fastBlurMore(int imageWidth, int imageHeight, int imageStride, void *pixels,
+                         int radius) {
+    uint8_t *pix = (uint8_t *) pixels;
     const int w = imageWidth;
     const int h = imageHeight;
     const int stride = imageStride;
     const int r1 = radius + 1;
     const int div = radius * 2 + 1;
-    
+
     if (radius > 15 || div >= w || div >= h || w * h > 128 * 128 || imageStride > imageWidth * 4) {
         return;
     }
-    
+
     uint64_t *rgb = malloc(imageWidth * imageHeight * sizeof(uint64_t));
     if (rgb == NULL) {
         return;
     }
-    
+
     int x, y, i;
-    
+
     int yw = 0;
     const int we = w - r1;
     for (y = 0; y < h; y++) {
-        uint64_t cur = get_colors (&pix[yw]);
+        uint64_t cur = get_colors(&pix[yw]);
         uint64_t rgballsum = -radius * cur;
         uint64_t rgbsum = cur * ((r1 * (r1 + 1)) >> 1);
-        
+
         for (i = 1; i <= radius; i++) {
-            uint64_t cur = get_colors (&pix[yw + i * 4]);
+            uint64_t cur = get_colors(&pix[yw + i * 4]);
             rgbsum += cur * (r1 - i);
             rgballsum += cur;
         }
-        
+
         x = 0;
-        
-    #define update(start, middle, end) \
+
+#define update(start, middle, end) \
             rgb[y * w + x] = (rgbsum >> 6) & 0x00FF00FF00FF00FF; \
             rgballsum += get_colors (&pix[yw + (start) * 4]) - 2 * get_colors (&pix[yw + (middle) * 4]) + get_colors (&pix[yw + (end) * 4]); \
             rgbsum += rgballsum; \
@@ -137,11 +149,11 @@ static void fastBlurMore(int imageWidth, int imageHeight, int imageStride, void
         while (x < w) {
             update (x - r1, x, w - 1);
         }
-    #undef update
-        
+#undef update
+
         yw += stride;
     }
-    
+
     const int he = h - r1;
     for (x = 0; x < w; x++) {
         uint64_t rgballsum = -radius * rgb[x];
@@ -150,11 +162,11 @@ static void fastBlurMore(int imageWidth, int imageHeight, int imageStride, void
             rgbsum += rgb[i * w + x] * (r1 - i);
             rgballsum += rgb[i * w + x];
         }
-        
+
         y = 0;
         int yi = x * 4;
-        
-    #define update(start, middle, end) \
+
+#define update(start, middle, end) \
             int64_t res = rgbsum >> 6; \
             pix[yi] = res; \
             pix[yi + 1] = res >> 16; \
@@ -163,7 +175,7 @@ static void fastBlurMore(int imageWidth, int imageHeight, int imageStride, void
             rgbsum += rgballsum; \
             y++; \
             yi += stride;
-        
+
         while (y < r1) {
             update (0, y, y + r1);
         }
@@ -173,12 +185,12 @@ static void fastBlurMore(int imageWidth, int imageHeight, int imageStride, void
         while (y < h) {
             update (y - r1, y, h - 1);
         }
-    #undef update
+#undef update
     }
 }
 
 static void fastBlur(int imageWidth, int imageHeight, int imageStride, void *pixels, int radius) {
-    uint8_t *pix = (uint8_t *)pixels;
+    uint8_t *pix = (uint8_t *) pixels;
     const int w = imageWidth;
     const int h = imageHeight;
     const int stride = imageStride;
@@ -196,34 +208,34 @@ static void fastBlur(int imageWidth, int imageHeight, int imageStride, void *pix
     } else {
         return;
     }
-    
+
     if (radius > 15 || div >= w || div >= h || w * h > 128 * 128 || imageStride > imageWidth * 4) {
         return;
     }
-    
+
     uint64_t *rgb = malloc(imageWidth * imageHeight * sizeof(uint64_t));
     if (rgb == NULL) {
         return;
     }
-    
+
     int x, y, i;
-    
+
     int yw = 0;
     const int we = w - r1;
     for (y = 0; y < h; y++) {
-        uint64_t cur = get_colors (&pix[yw]);
+        uint64_t cur = get_colors(&pix[yw]);
         uint64_t rgballsum = -radius * cur;
         uint64_t rgbsum = cur * ((r1 * (r1 + 1)) >> 1);
-        
+
         for (i = 1; i <= radius; i++) {
-            uint64_t cur = get_colors (&pix[yw + i * 4]);
+            uint64_t cur = get_colors(&pix[yw + i * 4]);
             rgbsum += cur * (r1 - i);
             rgballsum += cur;
         }
-        
+
         x = 0;
-        
-        #define update(start, middle, end)  \
+
+#define update(start, middle, end)  \
                 rgb[y * w + x] = (rgbsum >> shift) & 0x00FF00FF00FF00FFLL; \
                 rgballsum += get_colors (&pix[yw + (start) * 4]) - 2 * get_colors (&pix[yw + (middle) * 4]) + get_colors (&pix[yw + (end) * 4]); \
                 rgbsum += rgballsum;        \
@@ -238,12 +250,12 @@ static void fastBlur(int imageWidth, int imageHeight, int imageStride, void *pix
         while (x < w) {
             update (x - r1, x, w - 1);
         }
-        
-        #undef update
-        
+
+#undef update
+
         yw += stride;
     }
-    
+
     const int he = h - r1;
     for (x = 0; x < w; x++) {
         uint64_t rgballsum = -radius * rgb[x];
@@ -252,11 +264,11 @@ static void fastBlur(int imageWidth, int imageHeight, int imageStride, void *pix
             rgbsum += rgb[i * w + x] * (r1 - i);
             rgballsum += rgb[i * w + x];
         }
-        
+
         y = 0;
         int yi = x * 4;
-        
-        #define update(start, middle, end)  \
+
+#define update(start, middle, end)  \
                 int64_t res = rgbsum >> shift;   \
                 pix[yi] = res;              \
                 pix[yi + 1] = res >> 16;    \
@@ -265,7 +277,7 @@ static void fastBlur(int imageWidth, int imageHeight, int imageStride, void *pix
                 rgbsum += rgballsum;        \
                 y++;                        \
                 yi += stride;
-        
+
         while (y < r1) {
             update (0, y, y + r1);
         }
@@ -275,9 +287,9 @@ static void fastBlur(int imageWidth, int imageHeight, int imageStride, void *pix
         while (y < h) {
             update (y - r1, y, h - 1);
         }
-        #undef update
+#undef update
     }
-    
+
     free(rgb);
 }
 
@@ -287,27 +299,34 @@ typedef struct my_error_mgr {
 } *my_error_ptr;
 
 
-METHODDEF(void) my_error_exit(j_common_ptr cinfo) {
-    my_error_ptr myerr = (my_error_ptr) cinfo->err;
-    (*cinfo->err->output_message) (cinfo);
-    longjmp(myerr->setjmp_buffer, 1);
+METHODDEF(void)
+
+my_error_exit(j_common_ptr
+cinfo) {
+my_error_ptr myerr = (my_error_ptr) cinfo->err;
+(*cinfo->err->output_message) (cinfo);
+longjmp(myerr
+->setjmp_buffer, 1);
 }
 
-JNIEXPORT void Java_org_telegram_messenger_Utilities_blurBitmap(JNIEnv *env, jclass class, jobject bitmap, int radius, int unpin) {
+JNIEXPORT void Java_org_telegram_messenger_Utilities_blurBitmap(JNIEnv *env, jclass class,
+                                                                jobject bitmap, int radius,
+                                                                int unpin) {
     if (!bitmap) {
         return;
     }
-    
+
     AndroidBitmapInfo info;
-    
+
     if (AndroidBitmap_getInfo(env, bitmap, &info) < 0) {
         return;
     }
-    
-    if (info.format != ANDROID_BITMAP_FORMAT_RGBA_8888 || !info.width || !info.height || !info.stride) {
+
+    if (info.format != ANDROID_BITMAP_FORMAT_RGBA_8888 || !info.width || !info.height ||
+        !info.stride) {
         return;
     }
-    
+
     void *pixels = 0;
     if (AndroidBitmap_lockPixels(env, bitmap, &pixels) < 0) {
         return;
@@ -322,45 +341,49 @@ JNIEXPORT void Java_org_telegram_messenger_Utilities_blurBitmap(JNIEnv *env, jcl
     }
 }
 
-JNIEXPORT void Java_org_telegram_messenger_Utilities_calcCDT(JNIEnv *env, jclass class, jobject hsvBuffer, int width, int height, jobject buffer) {
+JNIEXPORT void Java_org_telegram_messenger_Utilities_calcCDT(JNIEnv *env, jclass class,
+                                                             jobject hsvBuffer, int width,
+                                                             int height, jobject buffer) {
     float imageWidth = width;
     float imageHeight = height;
     float _clipLimit = 1.25f;
 
     uint32_t totalSegments = PGPhotoEnhanceSegments * PGPhotoEnhanceSegments;
-    uint32_t tileArea = (uint32_t)(floorf(imageWidth / PGPhotoEnhanceSegments) * floorf(imageHeight / PGPhotoEnhanceSegments));
-    uint32_t clipLimit = (uint32_t)max(1, _clipLimit * tileArea / (float) PGPhotoEnhanceHistogramBins);
+    uint32_t tileArea = (uint32_t) (floorf(imageWidth / PGPhotoEnhanceSegments) *
+                                    floorf(imageHeight / PGPhotoEnhanceSegments));
+    uint32_t clipLimit = (uint32_t) max(1, _clipLimit * tileArea /
+                                           (float) PGPhotoEnhanceHistogramBins);
     float scale = 255.0f / (float) tileArea;
 
 
     unsigned char *bytes = (*env)->GetDirectBufferAddress(env, hsvBuffer);
-   // LOGI("calccdt %d",bytes);
+    // LOGI("calccdt %d",bytes);
     uint32_t **hist = calloc(totalSegments, sizeof(uint32_t *));
     uint32_t **cdfs = calloc(totalSegments, sizeof(uint32_t *));
     uint32_t *cdfsMin = calloc(totalSegments, sizeof(uint32_t));
     uint32_t *cdfsMax = calloc(totalSegments, sizeof(uint32_t));
-    
+
     for (uint32_t a = 0; a < totalSegments; a++) {
         hist[a] = calloc(PGPhotoEnhanceHistogramBins, sizeof(uint32_t));
         cdfs[a] = calloc(PGPhotoEnhanceHistogramBins, sizeof(uint32_t));
     }
-    
+
     float xMul = PGPhotoEnhanceSegments / imageWidth;
     float yMul = PGPhotoEnhanceSegments / imageHeight;
-    
+
     for (uint32_t y = 0; y < imageHeight; y++) {
         uint32_t yOffset = y * width * 4;
         for (uint32_t x = 0; x < imageWidth; x++) {
             uint32_t index = x * 4 + yOffset;
-            
-            uint32_t tx = (uint32_t)(x * xMul);
-            uint32_t ty = (uint32_t)(y * yMul);
+
+            uint32_t tx = (uint32_t) (x * xMul);
+            uint32_t ty = (uint32_t) (y * yMul);
             uint32_t t = ty * PGPhotoEnhanceSegments + tx;
-            
+
             hist[t][bytes[index + 2]]++;
         }
     }
-    
+
     for (uint32_t i = 0; i < totalSegments; i++) {
         if (clipLimit > 0) {
             uint32_t clipped = 0;
@@ -370,48 +393,48 @@ JNIEXPORT void Java_org_telegram_messenger_Utilities_calcCDT(JNIEnv *env, jclass
                     hist[i][j] = clipLimit;
                 }
             }
-            
+
             uint32_t redistBatch = clipped / PGPhotoEnhanceHistogramBins;
             uint32_t residual = clipped - redistBatch * PGPhotoEnhanceHistogramBins;
-            
+
             for (uint32_t j = 0; j < PGPhotoEnhanceHistogramBins; ++j) {
                 hist[i][j] += redistBatch;
             }
-            
+
             for (uint32_t j = 0; j < residual; ++j) {
                 hist[i][j]++;
             }
         }
         memcpy(cdfs[i], hist[i], PGPhotoEnhanceHistogramBins * sizeof(uint32_t));
-        
+
         uint32_t hMin = PGPhotoEnhanceHistogramBins - 1;
         for (uint32_t j = 0; j < hMin; ++j) {
             if (cdfs[j] != 0) {
                 hMin = j;
             }
         }
-        
+
         uint32_t cdf = 0;
         for (uint32_t j = hMin; j < PGPhotoEnhanceHistogramBins; ++j) {
             cdf += cdfs[i][j];
             cdfs[i][j] = (uint8_t) min(255, cdf * scale);
         }
-        
+
         cdfsMin[i] = cdfs[i][hMin];
         cdfsMax[i] = cdfs[i][PGPhotoEnhanceHistogramBins - 1];
     }
-    
+
     uint32_t resultSize = 4 * PGPhotoEnhanceHistogramBins * totalSegments;
     uint32_t resultBytesPerRow = 4 * PGPhotoEnhanceHistogramBins;
-    
+
     unsigned char *result = (*env)->GetDirectBufferAddress(env, buffer);
     for (uint32_t tile = 0; tile < totalSegments; tile++) {
         uint32_t yOffset = tile * resultBytesPerRow;
         for (uint32_t i = 0; i < PGPhotoEnhanceHistogramBins; i++) {
             uint32_t index = i * 4 + yOffset;
-            result[index] = (uint8_t)cdfs[tile][i];
-            result[index + 1] = (uint8_t)cdfsMin[tile];
-            result[index + 2] = (uint8_t)cdfsMax[tile];
+            result[index] = (uint8_t) cdfs[tile][i];
+            result[index + 1] = (uint8_t) cdfsMin[tile];
+            result[index + 2] = (uint8_t) cdfsMax[tile];
             result[index + 3] = 255;
         }
     }
@@ -426,114 +449,124 @@ JNIEXPORT void Java_org_telegram_messenger_Utilities_calcCDT(JNIEnv *env, jclass
     free(cdfsMin);
 }
 
-JNIEXPORT int Java_org_telegram_messenger_Utilities_pinBitmap(JNIEnv *env, jclass class, jobject bitmap) {
+JNIEXPORT int Java_org_telegram_messenger_Utilities_pinBitmap(JNIEnv *env, jclass class,
+                                                              jobject bitmap) {
 //    if(bitmap==null)
 //        return;
     unsigned char *pixels;
     return AndroidBitmap_lockPixels(env, bitmap, &pixels) >= 0 ? 1 : 0;
 }
 
-JNIEXPORT void Java_org_telegram_messenger_Utilities_loadBitmap(JNIEnv *env, jclass class, jstring path, jobject bitmap, int scale, int width, int height, int stride) {
-    
+JNIEXPORT void Java_org_telegram_messenger_Utilities_loadBitmap(JNIEnv *env, jclass class,
+                                                                jstring path, jobject bitmap,
+                                                                int scale, int width, int height,
+                                                                int stride) {
+
     AndroidBitmapInfo info;
     int i;
 
     if ((i = AndroidBitmap_getInfo(env, bitmap, &info)) >= 0) {
         char *fileName = (*env)->GetStringUTFChars(env, path, NULL);
         FILE *infile;
-        
+
         if ((infile = fopen(fileName, "rb"))) {
             struct my_error_mgr jerr;
             struct jpeg_decompress_struct cinfo;
 
             cinfo.err = jpeg_std_error(&jerr.pub);
             jerr.pub.error_exit = my_error_exit;
-            
+
             if (!setjmp(jerr.setjmp_buffer)) {
                 jpeg_create_decompress(&cinfo);
                 jpeg_stdio_src(&cinfo, infile);
-                
+
                 jpeg_read_header(&cinfo, TRUE);
-                
+
                 cinfo.scale_denom = scale;
                 cinfo.scale_num = 1;
-                
+
                 jpeg_start_decompress(&cinfo);
                 int row_stride = cinfo.output_width * cinfo.output_components;
-                JSAMPARRAY buffer = (*cinfo.mem->alloc_sarray) ((j_common_ptr) &cinfo, JPOOL_IMAGE, row_stride, 1);
+                JSAMPARRAY buffer = (*cinfo.mem->alloc_sarray)((j_common_ptr) & cinfo, JPOOL_IMAGE,
+                                                               row_stride, 1);
 
                 unsigned char *pixels;
                 if ((i = AndroidBitmap_lockPixels(env, bitmap, &pixels)) >= 0) {
                     int rowCount = min(cinfo.output_height, height);
                     int colCount = min(cinfo.output_width, width);
-                    
+
                     while (cinfo.output_scanline < rowCount) {
                         jpeg_read_scanlines(&cinfo, buffer, 1);
-                        
+
                         //if (info.format == ANDROID_BITMAP_FORMAT_RGBA_8888) {
-                            if (cinfo.out_color_space == JCS_GRAYSCALE) {
-                                for (i = 0; i < colCount; i++) {
-                                    float alpha = buffer[0][i] / 255.0f;
-                                    pixels[i * 4] *= alpha;
-                                    pixels[i * 4 + 1] *= alpha;
-                                    pixels[i * 4 + 2] *= alpha;
-                                    pixels[i * 4 + 3] = buffer[0][i];
-                                }
-                            } else {
-                                int c = 0;
-                                for (i = 0; i < colCount; i++) {
-                                    pixels[i * 4] = buffer[0][i * 3];
-                                    pixels[i * 4 + 1] = buffer[0][i * 3 + 1];
-                                    pixels[i * 4 + 2] = buffer[0][i * 3 + 2];
-                                    pixels[i * 4 + 3] = 255;
-                                    c += 4;
-                                }
+                        if (cinfo.out_color_space == JCS_GRAYSCALE) {
+                            for (i = 0; i < colCount; i++) {
+                                float alpha = buffer[0][i] / 255.0f;
+                                pixels[i * 4] *= alpha;
+                                pixels[i * 4 + 1] *= alpha;
+                                pixels[i * 4 + 2] *= alpha;
+                                pixels[i * 4 + 3] = buffer[0][i];
+                            }
+                        } else {
+                            int c = 0;
+                            for (i = 0; i < colCount; i++) {
+                                pixels[i * 4] = buffer[0][i * 3];
+                                pixels[i * 4 + 1] = buffer[0][i * 3 + 1];
+                                pixels[i * 4 + 2] = buffer[0][i * 3 + 2];
+                                pixels[i * 4 + 3] = 255;
+                                c += 4;
                             }
+                        }
                         //} else if (info.format == ANDROID_BITMAP_FORMAT_RGB_565) {
-                            
+
                         //}
-                        
+
                         pixels += stride;
                     }
-                    
+
                     AndroidBitmap_unlockPixels(env, bitmap);
                 } else {
                     throwException(env, "AndroidBitmap_lockPixels() failed ! error=%d", i);
                 }
-                
+
                 jpeg_finish_decompress(&cinfo);
             } else {
                 throwException(env, "the JPEG code has signaled an error");
             }
-            
+
             jpeg_destroy_decompress(&cinfo);
             fclose(infile);
         } else {
             throwException(env, "can't open %s", fileName);
         }
-        
+
         (*env)->ReleaseStringUTFChars(env, path, fileName);
     } else {
         throwException(env, "AndroidBitmap_getInfo() failed ! error=%d", i);
     }
 }
+
 int rowOffset;
 int blockOffset;
 /**
  * 嵌入消息长度的最大比特表示.
  * todo 消息长度可以从传入的bytebuffer得到.
  */
-static const int MSG_SIZE=4;
-JNIEXPORT int Java_org_telegram_messenger_Utilities_lsbEmbed(JNIEnv *env,jclass  class,
-                                                              jobject buffer, jstring key,
-                                                              jstring input, jstring output,int len) {
+static const int MSG_SIZE = 4;
+static char STEGO_MARK[] = "1234567890abcdef";
+static const MARK_LEN = 16;
+
+JNIEXPORT int Java_org_telegram_messenger_Utilities_lsbEmbed(JNIEnv *env, jclass class,
+                                                             jobject buffer, jstring key,
+                                                             jstring input, jstring output,
+                                                             int len) {
 
     unsigned char *bytes = (*env)->GetDirectBufferAddress(env, buffer);
-    LOGI("bytes %s",bytes);
+//    LOGI("bytes %s", bytes);
 //    int dataLen = len * 8;
     struct jpeg_decompress_struct srcinfo;
     struct jpeg_compress_struct dstinfo;
-    static  jvirt_barray_ptr *coef_arrays;
+    static jvirt_barray_ptr *coef_arrays;
     struct jpeg_error_mgr jsrcerr, jdsterr;
 //    struct stat ifstats;
     FILE *input_file;
@@ -542,12 +575,12 @@ JNIEXPORT int Java_org_telegram_messenger_Utilities_lsbEmbed(JNIEnv *env,jclass
     char *outfileName = (*env)->GetStringUTFChars(env, output, NULL);
     input_file = fopen(infileName, "rb");
     if (input_file == NULL) {
-        throwException(env,"Can't open input file");
+        throwException(env, "Can't open input file");
         return (-1);
     }
     output_file = fopen(outfileName, "wb");
     if (output_file == NULL) {
-        throwException(env,"Can't open output file");
+        throwException(env, "Can't open output file");
         return (-1);
     }
 
@@ -558,15 +591,22 @@ JNIEXPORT int Java_org_telegram_messenger_Utilities_lsbEmbed(JNIEnv *env,jclass
     jpeg_stdio_src(&srcinfo, input_file);
     jpeg_read_header(&srcinfo, TRUE);
     coef_arrays = jpeg_read_coefficients(&srcinfo);
-    rowOffset=0;
-    blockOffset=0;
-    int dataLen=len;
-    LOGI("size of int %d %d",dataLen,sizeof(dataLen));
-    if(writeLsb(coef_arrays,(char*)&dataLen,MSG_SIZE)!=MSG_SIZE){
+    rowOffset = 0;
+    blockOffset = 0;
+    int dataLen = len;
+    //write mark: this mark is used to differentiate stego image and non stego image
+    if (writeLsb(coef_arrays, STEGO_MARK, MARK_LEN) != MARK_LEN) {
+        LOGE("write mark error");
+        return -1;
+    }
+    //write length
+//    LOGI("size of int %d %d",dataLen,sizeof(dataLen));
+    if (writeLsb(coef_arrays, (char *) &dataLen, MSG_SIZE) != MSG_SIZE) {
         LOGE("write length error");
         return -1;
     }
-    if(writeLsb(coef_arrays,bytes,len)!=len){
+    //write data;
+    if (writeLsb(coef_arrays, bytes, len) != len) {
         LOGE("write msg error");
         return -1;
     }
@@ -588,77 +628,119 @@ JNIEXPORT int Java_org_telegram_messenger_Utilities_lsbEmbed(JNIEnv *env,jclass
  * buffer：写消息的buffer.
  * len:读取消息的最大长度
  *  分配的内存是否需要手动释放
+ *  return: -2:表示这张图片不是隐写的图片.
  */
 JNIEXPORT jobject Java_org_telegram_messenger_Utilities_lsbExtract(JNIEnv *env, jclass class,
-                                                              jstring key, jstring input) {
+                                                                   jstring key, jstring input) {
     struct jpeg_decompress_struct srcinfo;
-    static  jvirt_barray_ptr *coef_arrays;
+    static jvirt_barray_ptr *coef_arrays;
     struct jpeg_error_mgr jsrcerr, jdsterr;
-//    struct stat ifstats;
     FILE *input_file;
     char *infileName = (*env)->GetStringUTFChars(env, input, NULL);
     input_file = fopen(infileName, "rb");
     if (input_file == NULL) {
-        throwException(env,"Can't open input file");
-        return (-1);
+        throwException(env, "Can't open input file");
     }
-
     srcinfo.err = jpeg_std_error(&jsrcerr);
     jpeg_create_decompress(&srcinfo);
     jpeg_stdio_src(&srcinfo, input_file);
     jpeg_read_header(&srcinfo, TRUE);
     coef_arrays = jpeg_read_coefficients(&srcinfo);
-    rowOffset=0;
-    blockOffset=0;
-    int dataLen;
-    int ret=readLsb(coef_arrays,&dataLen,MSG_SIZE);
-    if(ret!=MSG_SIZE||dataLen<0){
-        return -1;
+    rowOffset = 0;
+    blockOffset = 0;
+    int dataLen, ret;
+    char extractMark[17];
+    extractMark[16] = 0;
+    if (readLsb(coef_arrays, extractMark, MARK_LEN) != MARK_LEN) {
+        return 0;
+    }
+    ret = readLsb(coef_arrays, &dataLen, MSG_SIZE);
+    if (ret != MSG_SIZE || dataLen < 0) {
+        return 0;
     }
-    LOGI("extract dataLen %d",dataLen);
-    char *data=(char*)malloc(dataLen+1);
-    *(data+dataLen)=0;
-    if(readLsb(coef_arrays,data,dataLen)<dataLen){
+//    LOGI("extract dataLen %d", dataLen);
+    char *data = (char *) malloc(dataLen + 1);
+    *(data + dataLen) = 0;
+    if (readLsb(coef_arrays, data, dataLen) < dataLen) {
         free(data);
-        return -1;
+        return 0;
     }
     jpeg_finish_decompress(&srcinfo);
     jpeg_destroy_decompress(&srcinfo);
     fclose(input_file);
 
-    jobject retO=(*env)->NewDirectByteBuffer( env,data,dataLen);
-    LOGI("extract %s",data);
+    jobject retO = (*env)->NewDirectByteBuffer(env, data, dataLen);
+//    LOGI("extract %s",data);
     return retO;
 }
+/**
+ * 这样的话，isStego里面提取了一次洗漱，extract里面提取了一次，会影响效率.
+ */
+JNIEXPORT jboolean Java_org_telegram_messenger_Utilities_isStego(JNIEnv *env, jclass class,
+                                                                 jstring key, jstring input) {
+    struct jpeg_decompress_struct srcinfo;
+    static jvirt_barray_ptr *coef_arrays;
+    struct jpeg_error_mgr jsrcerr, jdsterr;
+//    struct stat ifstats;
+    FILE *input_file;
+    char *infileName = (*env)->GetStringUTFChars(env, input, NULL);
+    input_file = fopen(infileName, "rb");
+    if (input_file == NULL) {
+        throwException(env, "Can't open input file");
+//        return (-1);
+    }
+    srcinfo.err = jpeg_std_error(&jsrcerr);
+    jpeg_create_decompress(&srcinfo);
+    jpeg_stdio_src(&srcinfo, input_file);
+    jpeg_read_header(&srcinfo, TRUE);
+    coef_arrays = jpeg_read_coefficients(&srcinfo);
+    rowOffset = 0;
+    blockOffset = 0;
+    int dataLen;
+    char extractMark[17];
+    extractMark[16] = 0;
+    jboolean ret = JNI_TRUE;
+    if (readLsb(coef_arrays, extractMark, MARK_LEN) != MARK_LEN) {
+        ret = JNI_FALSE;
+    }
+//    LOGI("read mark : %s",extractMark);
+    if (strcmp(STEGO_MARK, extractMark) != 0) {
+        ret = JNI_FALSE;
+    }
+    jpeg_finish_decompress(&srcinfo);
+    jpeg_destroy_decompress(&srcinfo);
+    fclose(input_file);
+    return ret;
+}
 
 /**
  * 返回实际写入的字节数
  *
  */
-int writeLsb( jvirt_barray_ptr* coef_arrays,char* data,int count){
-    char *dataEnd=data+count;
-    LOGI("data: %d end %d",data,dataEnd);
-    jvirt_barray_ptr temp_src_coef_arrays= *coef_arrays;
+int writeLsb(jvirt_barray_ptr *coef_arrays, const char *data, int count) {
+    char *dataEnd = data + count;
+//    LOGI("data: %d end %d", data, dataEnd);
+    jvirt_barray_ptr temp_src_coef_arrays = *coef_arrays;
     //indicate 写入到了字节中的哪一个比特.
-    int bitCount=0;
-    int ibeg=rowOffset;
-    int jbeg=blockOffset;
-    int i,j;
-    while (temp_src_coef_arrays ) {
+    int bitCount = 0;
+    int ibeg = rowOffset;
+    int jbeg = blockOffset;
+    int i, j;
+    while (temp_src_coef_arrays) {
 //        JBLOCKARRAY jbarray = (temp_src_coef_arrays)->mem_buffer;
-        JBLOCKARRAY jbarray=get_mem_buffer(temp_src_coef_arrays);
+        JBLOCKARRAY jbarray = get_mem_buffer(temp_src_coef_arrays);
         JBLOCKROW jbrow = NULL;
-        for ( i = ibeg; ( data<dataEnd) && i < get_rows_in_mem(temp_src_coef_arrays); i++) {
+        for (i = ibeg; (data < dataEnd) && i < get_rows_in_mem(temp_src_coef_arrays); i++) {
             jbrow = *(jbarray);
-            for ( j = jbeg; ( data<dataEnd) && j < get_blocksperrow(temp_src_coef_arrays); j++) {
+            for (j = jbeg; (data < dataEnd) && j < get_blocksperrow(temp_src_coef_arrays); j++) {
                 //跳过了直流分量和0系数.
-                for (int k = 1; ( data<dataEnd) && k < 64; k++) {
+                for (int k = 1; (data < dataEnd) && k < 64; k++) {
                     if (((*(jbrow + j))[k] != 0) && ((*(jbrow + j))[k] != 1)) {
-                      int   move = bitCount % 8;
-                        if ( bitCount&&(bitCount%8) == 0) {
+                        int move = bitCount % 8;
+                        if (bitCount && (bitCount % 8) == 0) {
                             data++;
                         }
-                        char bits = ((*data) >> (7-move)) & 0x01;
+                        char bits = ((*data) >> (7 - move)) & 0x01;
                         (*(jbrow + j))[k] = ((((*(jbrow + j))[k]) >> 1) << 1) | bits;
 
                         bitCount++;
@@ -667,121 +749,132 @@ int writeLsb( jvirt_barray_ptr* coef_arrays,char* data,int count){
                 }
             }
             jbarray++;
-            jbeg=0;
+            jbeg = 0;
         }
-        ibeg=0;
-        if(data>=dataEnd)
+        ibeg = 0;
+        if (data >= dataEnd)
             break;
         temp_src_coef_arrays = get_next(temp_src_coef_arrays);
     }
-    rowOffset=i;
-    blockOffset=j;
-    *coef_arrays=temp_src_coef_arrays;
-    LOGI("bitcount %d",bitCount);
-    return ((bitCount-1)/8);
+    rowOffset = i;
+    blockOffset = j;
+    *coef_arrays = temp_src_coef_arrays;
+//    LOGI("bitcount %d", bitCount);
+    return ((bitCount - 1) / 8);
 }
+
 /**
  * 返回实际读出的字节数
  *data:写数据的缓冲区.
  */
-int readLsb( jvirt_barray_ptr* coef_arrays,char* data,int count){
-    char *dataEnd=data+count;
-    jvirt_barray_ptr temp_src_coef_arrays= *coef_arrays;
+int readLsb(jvirt_barray_ptr *coef_arrays, char *data, int count) {
+    char *dataEnd = data + count;
+    jvirt_barray_ptr temp_src_coef_arrays = *coef_arrays;
     //indicate 写入到了字节中的哪一个比特.
-    int bitCount=0;
-    int ibeg=rowOffset;
-    int jbeg=blockOffset;
-    int i,j;
+    int bitCount = 0;
+    int ibeg = rowOffset;
+    int jbeg = blockOffset;
+    int i, j;
     while (temp_src_coef_arrays) {
 //        JBLOCKARRAY jbarray = (temp_src_coef_arrays)->mem_buffer;
-        JBLOCKARRAY jbarray=get_mem_buffer(temp_src_coef_arrays);
+        JBLOCKARRAY jbarray = get_mem_buffer(temp_src_coef_arrays);
         JBLOCKROW jbrow = NULL;
-        for ( i = ibeg; ( data<dataEnd) && i < get_rows_in_mem(temp_src_coef_arrays); i++) {
+        for (i = ibeg; (data < dataEnd) && i < get_rows_in_mem(temp_src_coef_arrays); i++) {
             jbrow = *(jbarray);
-            for ( j = jbeg; ( data<dataEnd) && j < get_blocksperrow(temp_src_coef_arrays); j++) {
+            for (j = jbeg; (data < dataEnd) && j < get_blocksperrow(temp_src_coef_arrays); j++) {
                 //跳过了直流分量和0系数.
-                for (int k = 1; ( data<dataEnd) && k < 64; k++) {
+                for (int k = 1; (data < dataEnd) && k < 64; k++) {
                     if (((*(jbrow + j))[k] != 0) && ((*(jbrow + j))[k] != 1)) {
                         int move = bitCount % 8;
-                        char bits = ((*(jbrow + j))[k])& 0x01;
+                        char bits = ((*(jbrow + j))[k]) & 0x01;
                         if (bitCount && move == 0) {
                             data++;
                         }
-                        *data=(*data)<<1;
-                        *data=(*data)|bits;
+                        *data = (*data) << 1;
+                        *data = (*data) | bits;
 
                         bitCount++;
                     }
                 }
             }
             jbarray++;
-            jbeg=0;
+            jbeg = 0;
         }
-        ibeg=0;
-        if(data>=dataEnd)
+        ibeg = 0;
+        if (data >= dataEnd)
             break;
         temp_src_coef_arrays = get_next(temp_src_coef_arrays);
     }
-    rowOffset=i;
-    blockOffset=j;
-    *coef_arrays=temp_src_coef_arrays;
-    return ((bitCount-1)/8);
+    rowOffset = i;
+    blockOffset = j;
+    *coef_arrays = temp_src_coef_arrays;
+    return ((bitCount - 1) / 8);
 }
-JNIEXPORT jobject Java_org_telegram_messenger_Utilities_loadWebpImage(JNIEnv *env, jclass class, jobject buffer, int len, jobject options) {
+
+JNIEXPORT jobject Java_org_telegram_messenger_Utilities_loadWebpImage(JNIEnv *env, jclass class,
+                                                                      jobject buffer, int len,
+                                                                      jobject options) {
     if (!buffer) {
         (*env)->ThrowNew(env, jclass_NullPointerException, "Input buffer can not be null");
         return 0;
     }
-    
+
     jbyte *inputBuffer = (*env)->GetDirectBufferAddress(env, buffer);
-    
+
     int bitmapWidth = 0;
     int bitmapHeight = 0;
-    if (!WebPGetInfo((uint8_t*)inputBuffer, len, &bitmapWidth, &bitmapHeight)) {
+    if (!WebPGetInfo((uint8_t *) inputBuffer, len, &bitmapWidth, &bitmapHeight)) {
         (*env)->ThrowNew(env, jclass_RuntimeException, "Invalid WebP format");
         return 0;
     }
-    
-    if (options && (*env)->GetBooleanField(env, options, jclass_Options_inJustDecodeBounds) == JNI_TRUE) {
+
+    if (options &&
+        (*env)->GetBooleanField(env, options, jclass_Options_inJustDecodeBounds) == JNI_TRUE) {
         (*env)->SetIntField(env, options, jclass_Options_outWidth, bitmapWidth);
         (*env)->SetIntField(env, options, jclass_Options_outHeight, bitmapHeight);
         return 0;
     }
 
-    jobject value__ARGB_8888 = (*env)->GetStaticObjectField(env, jclass_Config, jclass_Config_ARGB_8888);
-    jobject outputBitmap = (*env)->CallStaticObjectMethod(env, jclass_Bitmap, jclass_Bitmap_createBitmap, (jint)bitmapWidth, (jint)bitmapHeight, value__ARGB_8888);
+    jobject value__ARGB_8888 = (*env)->GetStaticObjectField(env, jclass_Config,
+                                                            jclass_Config_ARGB_8888);
+    jobject outputBitmap = (*env)->CallStaticObjectMethod(env, jclass_Bitmap,
+                                                          jclass_Bitmap_createBitmap,
+                                                          (jint) bitmapWidth, (jint) bitmapHeight,
+                                                          value__ARGB_8888);
     if (!outputBitmap) {
         (*env)->ThrowNew(env, jclass_RuntimeException, "Failed to allocate Bitmap");
         return 0;
     }
     outputBitmap = (*env)->NewLocalRef(env, outputBitmap);
-    
+
     AndroidBitmapInfo bitmapInfo;
     if (AndroidBitmap_getInfo(env, outputBitmap, &bitmapInfo) != ANDROID_BITMAP_RESUT_SUCCESS) {
         (*env)->DeleteLocalRef(env, outputBitmap);
         (*env)->ThrowNew(env, jclass_RuntimeException, "Failed to get Bitmap information");
         return 0;
     }
-    
+
     void *bitmapPixels = 0;
-    if (AndroidBitmap_lockPixels(env, outputBitmap, &bitmapPixels) != ANDROID_BITMAP_RESUT_SUCCESS) {
+    if (AndroidBitmap_lockPixels(env, outputBitmap, &bitmapPixels) !=
+        ANDROID_BITMAP_RESUT_SUCCESS) {
         (*env)->DeleteLocalRef(env, outputBitmap);
         (*env)->ThrowNew(env, jclass_RuntimeException, "Failed to lock Bitmap pixels");
         return 0;
     }
-    
-    if (!WebPDecodeRGBAInto((uint8_t*)inputBuffer, len, (uint8_t*)bitmapPixels, bitmapInfo.height * bitmapInfo.stride, bitmapInfo.stride)) {
+
+    if (!WebPDecodeRGBAInto((uint8_t *) inputBuffer, len, (uint8_t *) bitmapPixels,
+                            bitmapInfo.height * bitmapInfo.stride, bitmapInfo.stride)) {
         AndroidBitmap_unlockPixels(env, outputBitmap);
         (*env)->DeleteLocalRef(env, outputBitmap);
         (*env)->ThrowNew(env, jclass_RuntimeException, "Failed to decode webp image");
         return 0;
     }
-    
+
     if (AndroidBitmap_unlockPixels(env, outputBitmap) != ANDROID_BITMAP_RESUT_SUCCESS) {
         (*env)->DeleteLocalRef(env, outputBitmap);
         (*env)->ThrowNew(env, jclass_RuntimeException, "Failed to unlock Bitmap pixels");
         return 0;
     }
-    
+
     return outputBitmap;
 }
diff --git a/TMessagesProj/jni/utils.c b/TMessagesProj/jni/utils.c
index 1321a8213..e5f7981ff 100644
--- a/TMessagesProj/jni/utils.c
+++ b/TMessagesProj/jni/utils.c
@@ -12,3 +12,12 @@ void throwException(JNIEnv *env, char *format, ...) {
     va_end(argptr);
     (*env)->ThrowNew(env, exClass, dest);
 }
+/**
+ * create a new Integer object
+ */
+jobject newInteger(JNIEnv* env, jint value)
+{
+    jclass cls = (*env)-> FindClass(env, "java/lang/Integer");
+    jmethodID methodID = (*env)-> GetMethodID(env, cls, "<init>", "(I)V");
+    return (*env)->NewObject(env,cls, methodID, value);
+}
diff --git a/TMessagesProj/jni/utils.h b/TMessagesProj/jni/utils.h
index f17ae9025..cd02a9db5 100644
--- a/TMessagesProj/jni/utils.h
+++ b/TMessagesProj/jni/utils.h
@@ -25,5 +25,5 @@
 #endif
 
 void throwException(JNIEnv *env, char *format, ...);
-
+jobject newInteger(JNIEnv* env, jint value);
 #endif
diff --git a/TMessagesProj/libs/armeabi-v7a/libtmessages.8.so b/TMessagesProj/libs/armeabi-v7a/libtmessages.8.so
index f8a221eb6..301836b9d 100755
Binary files a/TMessagesProj/libs/armeabi-v7a/libtmessages.8.so and b/TMessagesProj/libs/armeabi-v7a/libtmessages.8.so differ
diff --git a/TMessagesProj/libs/armeabi/libtmessages.8.so b/TMessagesProj/libs/armeabi/libtmessages.8.so
index 4a09261ca..9be5d1d50 100755
Binary files a/TMessagesProj/libs/armeabi/libtmessages.8.so and b/TMessagesProj/libs/armeabi/libtmessages.8.so differ
diff --git a/TMessagesProj/libs/x86/libtmessages.8.so b/TMessagesProj/libs/x86/libtmessages.8.so
index f6386f538..a6d49e650 100755
Binary files a/TMessagesProj/libs/x86/libtmessages.8.so and b/TMessagesProj/libs/x86/libtmessages.8.so differ
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Utilities.java b/TMessagesProj/src/main/java/org/telegram/messenger/Utilities.java
index cdb67bcd5..92db496a6 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Utilities.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/Utilities.java
@@ -89,7 +89,7 @@
             }
         }
     }
-
+    public native static boolean isStego(String key,String input);
     public native static ByteBuffer lsbExtract(String key,String input);
     public native static int lsbEmbed(ByteBuffer buffer,String key,String input,String output,int len);
     public native static long doPQNative(long _what);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java
index a377db071..d70c5ac79 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java
@@ -46,6 +46,8 @@
 import android.widget.TextView;
 import android.widget.Toast;
 
+import net.hockeyapp.android.utils.Util;
+
 import org.telegram.android.AndroidUtilities;
 import org.telegram.PhoneFormat.PhoneFormat;
 import org.telegram.android.Emoji;
@@ -600,7 +602,7 @@ public void onItemClick(final int id) {
                     fragment.setDelegate(new PhotoAlbumPickerActivity.PhotoAlbumPickerActivityDelegate() {
                         @Override
                         public void didSelectPhotos(ArrayList<String> photos, ArrayList<String> captions, ArrayList<MediaController.SearchImage> webPhotos) {
-                           //发送图片的地方. photos 路径  dialog_id 不明 captions size 是1 但是element是null.
+                            //发送图片的地方. photos 路径  dialog_id 不明 captions size 是1 但是element是null.
                             SendMessagesHelper.prepareSendingPhotos(photos, null, dialog_id, replyingMessageObject, captions);
                             SendMessagesHelper.prepareSendingPhotosSearch(webPhotos, dialog_id, replyingMessageObject);
                             showReplyPanel(false, null, null, null, false, true);
@@ -769,23 +771,30 @@ public void onClick(DialogInterface dialogInterface, int i) {
                         return;  //// TODO: 2015/10/2 0002
 
                     }
-                    final boolean isChat = (int) dialog_id < 0 && (int) (dialog_id >> 32) != 1;
+                    final boolean isChat = (int) dialog_id < 0 && (
+                            int) (dialog_id >> 32) != 1;
                     AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
                     builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
                     if (id == clear_history) {
-                        String inputPath="/storage/emulated/0/DCIM/Camera/xifan.jpg";
-                        String outputPath="/storage/emulated/0/DCIM/Camera/stego.jpg";
-                        Random random=new Random();
-                        byte[] msg=new byte[5*1024];
-                        random.nextBytes(msg);
-//                        String msg="hello";
-                        ByteBuffer bb=ByteBuffer.allocateDirect(msg.length);
-                        bb.put(msg);
-                        Utilities.lsbEmbed(bb, new String("fads"), inputPath, outputPath, bb.capacity());
-                          ByteBuffer ret=Utilities.lsbExtract("", outputPath);
-                        byte[] extract=new byte[ret.capacity()];
-                        ret.get(extract);
-                        System.out.println("result " + Arrays.equals(extract,msg));
+                        builder.setMessage(LocaleController.getString("AreYouSureClearHistory", R.string.AreYouSureClearHistory));
+//                        String inputPath="/mnt/sdcard/DCIM/Camera/cover.jpg";
+//                        String outputPath="/mnt/sdcard/DCIM/Camera/stego.jpg";
+//                        Random random=new Random();
+//                        byte[] msg=new byte[5];
+//                        random.nextBytes(msg);
+////                        String msg="hello";
+//                        ByteBuffer bb=ByteBuffer.allocateDirect(msg.length);
+//                        bb.put(msg);
+//
+//                        Utilities.lsbEmbed(bb, "", inputPath, outputPath, bb.capacity());
+//                        if(Utilities.isStego("",outputPath)){
+//                         ByteBuffer ret=Utilities.lsbExtract("", outputPath);
+//                        byte[] extract=new byte[ret.capacity()];
+//                        ret.get(extract);
+//                        System.out.println("result " + Arrays.equals(extract,msg));}
+//                        else{
+//                            System.out.println("is not stego");
+//                        }
                     } else {
                         if (isChat) {
                             builder.setMessage(LocaleController.getString("AreYouSureDeleteAndExit", R.string.AreYouSureDeleteAndExit));
@@ -1600,7 +1609,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
         chatActivityEnterView.setId(id_chat_compose_panel);
         contentView.addView(chatActivityEnterView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT | Gravity.BOTTOM));
         chatActivityEnterView.setDelegate(new ChatActivityEnterView.ChatActivityEnterViewDelegate() {
-//            @Override
+            //            @Override
 //            public void onStegoMsgSend(String path){
 //                SendMessagesHelper.prepareSendingPhoto(path, null, dialog_id, replyingMessageObject, null);
 //            }
