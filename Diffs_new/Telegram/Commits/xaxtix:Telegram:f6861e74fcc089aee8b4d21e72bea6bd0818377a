diff --git a/TMessagesProj/afat/release/TMessagesProj-afat-release.apk b/TMessagesProj/afat/release/TMessagesProj-afat-release.apk
new file mode 100644
index 000000000..55674d57d
Binary files /dev/null and b/TMessagesProj/afat/release/TMessagesProj-afat-release.apk differ
diff --git a/TMessagesProj/arm64/release/TMessagesProj-arm64-release.apk b/TMessagesProj/arm64/release/TMessagesProj-arm64-release.apk
new file mode 100644
index 000000000..3fc407ca8
Binary files /dev/null and b/TMessagesProj/arm64/release/TMessagesProj-arm64-release.apk differ
diff --git a/TMessagesProj/jni/Android.mk b/TMessagesProj/jni/Android.mk
index d01178934..3e9775cb8 100755
--- a/TMessagesProj/jni/Android.mk
+++ b/TMessagesProj/jni/Android.mk
@@ -81,6 +81,22 @@ include $(PREBUILT_STATIC_LIBRARY)
 
 include $(CLEAR_VARS)
 
+LOCAL_MODULE    := x264
+
+ifeq ($(TARGET_ARCH_ABI),armeabi-v7a)
+    LOCAL_SRC_FILES := ./ffmpeg/armv7-a/libx264.a
+else ifeq ($(TARGET_ARCH_ABI),arm64-v8a)
+    LOCAL_SRC_FILES := ./ffmpeg/arm64/libx264.a
+else ifeq ($(TARGET_ARCH_ABI),x86)
+    LOCAL_SRC_FILES := ./ffmpeg/i686/libx264.a
+else ifeq ($(TARGET_ARCH_ABI),x86_64)
+    LOCAL_SRC_FILES := ./ffmpeg/x86_64/libx264.a
+endif
+
+include $(PREBUILT_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
 LOCAL_MODULE    := crypto
 
 ifeq ($(TARGET_ARCH_ABI),armeabi-v7a)
@@ -353,7 +369,7 @@ LOCAL_CFLAGS 	+= -Drestrict='' -D__EMX__ -DOPUS_BUILD -DFIXED_POINT -DUSE_ALLOCA
 LOCAL_CFLAGS 	+= -DANDROID_NDK -DDISABLE_IMPORTGL -fno-strict-aliasing -fprefetch-loop-arrays -DAVOID_TABLES -DANDROID_TILE_BASED_DECODE -DANDROID_ARMV6_IDCT -ffast-math -D__STDC_CONSTANT_MACROS
 LOCAL_CPPFLAGS 	:= -DBSD=1 -ffast-math -Os -funroll-loops -std=c++14
 LOCAL_LDLIBS 	:= -ljnigraphics -llog -lz -lEGL -lGLESv2 -landroid
-LOCAL_STATIC_LIBRARIES := webp sqlite lz4 rlottie tgnet swscale avformat avcodec avresample avutil voip flac
+LOCAL_STATIC_LIBRARIES := webp sqlite lz4 rlottie tgnet swscale avformat avcodec avresample avutil voip flac x264
 
 LOCAL_SRC_FILES     := \
 ./opus/src/opus.c \
@@ -632,7 +648,8 @@ LOCAL_SRC_FILES     += \
 ./exoplayer/ffmpeg_jni.cc \
 ./fast-edge.cpp \
 ./genann.c \
-./secureid_ocr.cpp
+./secureid_ocr.cpp \
+./video-compress.c
 
 include $(BUILD_SHARED_LIBRARY)
 
diff --git a/TMessagesProj/jni/ffmpeg/arm64/libavcodec.a b/TMessagesProj/jni/ffmpeg/arm64/libavcodec.a
index c70f0b413..67e37feac 100644
Binary files a/TMessagesProj/jni/ffmpeg/arm64/libavcodec.a and b/TMessagesProj/jni/ffmpeg/arm64/libavcodec.a differ
diff --git a/TMessagesProj/jni/ffmpeg/arm64/libavformat.a b/TMessagesProj/jni/ffmpeg/arm64/libavformat.a
index bdcf3088d..45d5412f6 100644
Binary files a/TMessagesProj/jni/ffmpeg/arm64/libavformat.a and b/TMessagesProj/jni/ffmpeg/arm64/libavformat.a differ
diff --git a/TMessagesProj/jni/ffmpeg/arm64/libavresample.a b/TMessagesProj/jni/ffmpeg/arm64/libavresample.a
index beb952491..6092867ab 100644
Binary files a/TMessagesProj/jni/ffmpeg/arm64/libavresample.a and b/TMessagesProj/jni/ffmpeg/arm64/libavresample.a differ
diff --git a/TMessagesProj/jni/ffmpeg/arm64/libavutil.a b/TMessagesProj/jni/ffmpeg/arm64/libavutil.a
index b02dc9bd8..7a57556f4 100644
Binary files a/TMessagesProj/jni/ffmpeg/arm64/libavutil.a and b/TMessagesProj/jni/ffmpeg/arm64/libavutil.a differ
diff --git a/TMessagesProj/jni/ffmpeg/arm64/libswscale.a b/TMessagesProj/jni/ffmpeg/arm64/libswscale.a
index 59f17885f..f5e578ef9 100644
Binary files a/TMessagesProj/jni/ffmpeg/arm64/libswscale.a and b/TMessagesProj/jni/ffmpeg/arm64/libswscale.a differ
diff --git a/TMessagesProj/jni/ffmpeg/armv7-a/libavcodec.a b/TMessagesProj/jni/ffmpeg/armv7-a/libavcodec.a
index decd1f45d..fdfb956a7 100644
Binary files a/TMessagesProj/jni/ffmpeg/armv7-a/libavcodec.a and b/TMessagesProj/jni/ffmpeg/armv7-a/libavcodec.a differ
diff --git a/TMessagesProj/jni/ffmpeg/armv7-a/libavformat.a b/TMessagesProj/jni/ffmpeg/armv7-a/libavformat.a
index 0f1e870f8..04b452fb9 100644
Binary files a/TMessagesProj/jni/ffmpeg/armv7-a/libavformat.a and b/TMessagesProj/jni/ffmpeg/armv7-a/libavformat.a differ
diff --git a/TMessagesProj/jni/ffmpeg/armv7-a/libavresample.a b/TMessagesProj/jni/ffmpeg/armv7-a/libavresample.a
index 82940c810..b102d9106 100644
Binary files a/TMessagesProj/jni/ffmpeg/armv7-a/libavresample.a and b/TMessagesProj/jni/ffmpeg/armv7-a/libavresample.a differ
diff --git a/TMessagesProj/jni/ffmpeg/armv7-a/libavutil.a b/TMessagesProj/jni/ffmpeg/armv7-a/libavutil.a
index 3a2367eae..a25a197cc 100644
Binary files a/TMessagesProj/jni/ffmpeg/armv7-a/libavutil.a and b/TMessagesProj/jni/ffmpeg/armv7-a/libavutil.a differ
diff --git a/TMessagesProj/jni/ffmpeg/armv7-a/libswscale.a b/TMessagesProj/jni/ffmpeg/armv7-a/libswscale.a
index 957ac45d2..cff404ed9 100644
Binary files a/TMessagesProj/jni/ffmpeg/armv7-a/libswscale.a and b/TMessagesProj/jni/ffmpeg/armv7-a/libswscale.a differ
diff --git a/TMessagesProj/jni/ffmpeg/build_ffmpeg_android.sh b/TMessagesProj/jni/ffmpeg/build_ffmpeg_android.sh
index 4fe8ee199..9fb22661e 100755
--- a/TMessagesProj/jni/ffmpeg/build_ffmpeg_android.sh
+++ b/TMessagesProj/jni/ffmpeg/build_ffmpeg_android.sh
@@ -1,12 +1,46 @@
 #!/bin/bash
 
+#recomended use ndk r12b
+NDK=/path-to-NDK
+
+ROOT_DIR=$PWD
+
 function build_one {
 
 echo "Cleaning..."
 rm config.h
 make clean
 
-echo "Configuring..."
+echo "========== Building x264 for $ARCH =========="
+
+cd $ROOT_DIR/x264
+
+./configure \
+--cc=$CC \
+--prefix=$PREFIX \
+--enable-static \
+--enable-shared \
+--enable-pic \
+--enable-strip \
+--disable-asm \
+--disable-cli \
+--disable-opencl \
+--disable-avs \
+--disable-swscale \
+--disable-lavf \
+--disable-ffms \
+--disable-gpac \
+--disable-interlaced \
+--chroma-format=420 \
+--host=$X264_ARCH-linux \
+--extra-cflags="-D_ANDROID_SYS_ -fno-tree-vectorize -funsafe-math-optimizations $BUILD_EXTRA_CFLAGS" \
+--extra-ldflags="-Wl,-rpath-link=${PLATFORM}/usr/lib -L${PLATFORM}/usr/lib" \
+--cross-prefix=$CROSS_PREFIX \
+--sysroot=$PLATFORM
+
+make install && cd -
+
+echo "========== Building ffmpeg for $ARCH =========="
 
 ./configure \
 --cc=$CC \
@@ -24,12 +58,13 @@ echo "Configuring..."
 --enable-inline-asm \
 --cross-prefix=$CROSS_PREFIX \
 --sysroot=$PLATFORM \
---extra-cflags="-Wl,-Bsymbolic -Os -DCONFIG_LINUX_PERF=0 -DANDROID $OPTIMIZE_CFLAGS -fPIE -pie --static -fPIC" \
---extra-ldflags="-Wl,-Bsymbolic -Wl,-rpath-link=$PLATFORM/usr/lib -L$PLATFORM/usr/lib -nostdlib -lc -lm -ldl -fPIC" \
+--extra-cflags="-I$PREFIX/include -Wl,-Bsymbolic -Os -DCONFIG_LINUX_PERF=0 -DANDROID $OPTIMIZE_CFLAGS -fPIE -pie --static -fPIC" \
+--extra-ldflags="-L$PREFIX/lib -lx264 -Wl,-Bsymbolic,-rpath-link=$PLATFORM/usr/lib -L$PLATFORM/usr/lib -nostdlib -lc -lm -lz -ldl -fPIC" \
 --extra-libs="-lgcc" \
 \
 --enable-version3 \
 --enable-gpl \
+--enable-libx264 \
 \
 --disable-doc \
 --disable-avx \
@@ -43,19 +78,26 @@ echo "Configuring..."
 --disable-debug \
 --disable-programs \
 --disable-network \
+--disable-swresample \
 \
 --enable-runtime-cpudetect \
 --enable-pthreads \
 --enable-avresample \
 --enable-protocol=file \
+\
+--enable-decoder=gif \
 --enable-decoder=h264 \
 --enable-decoder=mpeg4 \
 --enable-decoder=gif \
---enable-decoder=alac \
+\
+--enable-encoder=libx264 \
+--enable-encoder=h264 \
+\
+--enable-muxer=mp4 \
 --enable-demuxer=mov \
 --enable-demuxer=gif \
+--enable-demuxer=matroska \
 --enable-hwaccels \
---enable-runtime-cpudetect \
 $ADDITIONAL_CONFIGURE_FLAG
 
 #echo "continue?"
@@ -64,7 +106,71 @@ make -j8 install
 
 }
 
-NDK=/path-to-NDK
+download_and_unpack_package()
+{
+    TARBALL=$1.tar.gz
+    URL=$3
+    if [[ ! -f ${TARBALL} ]]; then
+        echo "Download package $URL/$TARBALL ..."
+        wget ${URL}/${TARBALL}
+
+        if [[ ! $? -eq 0 ]]; then
+            TARBALL=$1.tar.bz2
+            if [[ ! -f $TARBALL ]]; then
+                wget ${URL}/${TARBALL} || exit 1
+            fi
+        fi
+
+        if [[ -d $1 ]]; then
+            rm -rf $1
+        fi
+    fi
+
+    if [[ -f ${TARBALL} ]] && [[ ! -d $2 ]]; then
+        echo "Unpack package $TARBALL ..."
+        tar -xzvf $TARBALL
+        if [[ -f $2 ]]; then
+            rm $2
+        fi
+        ln -s $1 $2
+    fi
+}
+
+rm_package()
+{
+    echo "Removing package $1..."
+
+    TARBALL=$1.tar.gz
+    if [[ -f ${TARBALL} ]]; then
+        rm -rf ${TARBALL}
+    fi
+
+    TARBALL=$1.tar.bz2
+    if [ -f $TARBALL ]; then
+        rm -rf $TARBALL
+    fi
+
+    if [ -L $1 ]; then
+        echo "Removing package symlink $1..."
+        rm -rf $1
+    fi
+
+    if [ -L $2 ]; then
+        echo "Removing package version symlink $2..."
+        rm -rf $2
+    fi
+
+    if [ -d $1 ]; then
+        echo "Removing package source $1..."
+        rm -rf $1
+    fi
+}
+
+X264_LIB_NAME=x264
+X264_LIB_VERSION="snapshot-20170101-2245-stable"
+X264_LIB_URL=https://download.videolan.org/pub/videolan/x264/snapshots/
+
+download_and_unpack_package $X264_LIB_NAME-$X264_LIB_VERSION $X264_LIB_NAME $X264_LIB_URL
 
 #x86_64
 PREBUILT=$NDK/toolchains/x86_64-4.9/prebuilt/darwin-x86_64
@@ -77,7 +183,8 @@ CC=$PREBUILT/bin/x86_64-linux-android-gcc
 CROSS_PREFIX=$PREBUILT/bin/x86_64-linux-android-
 ARCH=x86_64
 CPU=x86_64
-PREFIX=./android/$CPU
+X264_ARCH=x86_64
+PREFIX=$ROOT_DIR/android/$CPU
 ADDITIONAL_CONFIGURE_FLAG="--disable-mmx --disable-inline-asm"
 build_one
 
@@ -91,9 +198,10 @@ GCCLIB=$PREBUILT/lib/gcc/aarch64-linux-android/4.9/libgcc.a
 CC=$PREBUILT/bin/aarch64-linux-android-gcc
 CROSS_PREFIX=$PREBUILT/bin/aarch64-linux-android-
 ARCH=arm64
+X264_ARCH=arm
 CPU=arm64-v8a
 OPTIMIZE_CFLAGS=
-PREFIX=./android/$CPU
+PREFIX=$ROOT_DIR/android/$CPU
 ADDITIONAL_CONFIGURE_FLAG="--enable-neon --enable-optimizations"
 build_one
 
@@ -107,9 +215,10 @@ GCCLIB=$PREBUILT/lib/gcc/arm-linux-androideabi/4.9/libgcc.a
 CC=$PREBUILT/bin/arm-linux-androideabi-gcc
 CROSS_PREFIX=$PREBUILT/bin/arm-linux-androideabi-
 ARCH=arm
+X264_ARCH=armv7-a
 CPU=armv7-a
 OPTIMIZE_CFLAGS="-marm -march=$CPU"
-PREFIX=./android/$CPU
+PREFIX=$ROOT_DIR/android/$CPU
 ADDITIONAL_CONFIGURE_FLAG=--enable-neon
 build_one
 #
@@ -124,9 +233,11 @@ CC=$PREBUILT/bin/i686-linux-android-gcc
 CROSS_PREFIX=$PREBUILT/bin/i686-linux-android-
 ARCH=x86
 CPU=i686
+X264_ARCH=i686
 OPTIMIZE_CFLAGS="-march=$CPU"
-PREFIX=./android/$CPU
+PREFIX=$ROOT_DIR/android/$CPU
 ADDITIONAL_CONFIGURE_FLAG="--disable-mmx --disable-yasm"
 build_one
 
+rm_package $X264_LIB_NAME-$X264_LIB_VERSION $X264_LIB_NAME
 
diff --git a/TMessagesProj/jni/ffmpeg/i686/libavcodec.a b/TMessagesProj/jni/ffmpeg/i686/libavcodec.a
index ebe9e35f9..bc315c3c2 100644
Binary files a/TMessagesProj/jni/ffmpeg/i686/libavcodec.a and b/TMessagesProj/jni/ffmpeg/i686/libavcodec.a differ
diff --git a/TMessagesProj/jni/ffmpeg/i686/libavformat.a b/TMessagesProj/jni/ffmpeg/i686/libavformat.a
index ff11db278..25b53511d 100644
Binary files a/TMessagesProj/jni/ffmpeg/i686/libavformat.a and b/TMessagesProj/jni/ffmpeg/i686/libavformat.a differ
diff --git a/TMessagesProj/jni/ffmpeg/i686/libavresample.a b/TMessagesProj/jni/ffmpeg/i686/libavresample.a
index dc8326607..be4c3e39d 100644
Binary files a/TMessagesProj/jni/ffmpeg/i686/libavresample.a and b/TMessagesProj/jni/ffmpeg/i686/libavresample.a differ
diff --git a/TMessagesProj/jni/ffmpeg/i686/libavutil.a b/TMessagesProj/jni/ffmpeg/i686/libavutil.a
index 401b5a72e..54fc9c7be 100644
Binary files a/TMessagesProj/jni/ffmpeg/i686/libavutil.a and b/TMessagesProj/jni/ffmpeg/i686/libavutil.a differ
diff --git a/TMessagesProj/jni/ffmpeg/i686/libswscale.a b/TMessagesProj/jni/ffmpeg/i686/libswscale.a
index dfddfc133..016f35878 100644
Binary files a/TMessagesProj/jni/ffmpeg/i686/libswscale.a and b/TMessagesProj/jni/ffmpeg/i686/libswscale.a differ
diff --git a/TMessagesProj/jni/ffmpeg/include/x264.h b/TMessagesProj/jni/ffmpeg/include/x264.h
new file mode 100644
index 000000000..2b59b92a0
--- /dev/null
+++ b/TMessagesProj/jni/ffmpeg/include/x264.h
@@ -0,0 +1,961 @@
+/*****************************************************************************
+ * x264.h: x264 public header
+ *****************************************************************************
+ * Copyright (C) 2003-2016 x264 project
+ *
+ * Authors: Laurent Aimar <fenrir@via.ecp.fr>
+ *          Loren Merritt <lorenm@u.washington.edu>
+ *          Fiona Glaser <fiona@x264.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111, USA.
+ *
+ * This program is also available under a commercial proprietary license.
+ * For more information, contact us at licensing@x264.com.
+ *****************************************************************************/
+
+#ifndef X264_X264_H
+#define X264_X264_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if !defined(_STDINT_H) && !defined(_STDINT_H_) && !defined(_STDINT_H_INCLUDED) && !defined(_STDINT) &&\
+    !defined(_SYS_STDINT_H_) && !defined(_INTTYPES_H) && !defined(_INTTYPES_H_) && !defined(_INTTYPES)
+# ifdef _MSC_VER
+#  pragma message("You must include stdint.h or inttypes.h before x264.h")
+# else
+#  warning You must include stdint.h or inttypes.h before x264.h
+# endif
+#endif
+
+#include <stdarg.h>
+
+#include "x264_config.h"
+
+#define X264_BUILD 148
+
+/* Application developers planning to link against a shared library version of
+ * libx264 from a Microsoft Visual Studio or similar development environment
+ * will need to define X264_API_IMPORTS before including this header.
+ * This clause does not apply to MinGW, similar development environments, or non
+ * Windows platforms. */
+#ifdef X264_API_IMPORTS
+#define X264_API __declspec(dllimport)
+#else
+#define X264_API
+#endif
+
+/* x264_t:
+ *      opaque handler for encoder */
+typedef struct x264_t x264_t;
+
+/****************************************************************************
+ * NAL structure and functions
+ ****************************************************************************/
+
+enum nal_unit_type_e
+{
+    NAL_UNKNOWN     = 0,
+    NAL_SLICE       = 1,
+    NAL_SLICE_DPA   = 2,
+    NAL_SLICE_DPB   = 3,
+    NAL_SLICE_DPC   = 4,
+    NAL_SLICE_IDR   = 5,    /* ref_idc != 0 */
+    NAL_SEI         = 6,    /* ref_idc == 0 */
+    NAL_SPS         = 7,
+    NAL_PPS         = 8,
+    NAL_AUD         = 9,
+    NAL_FILLER      = 12,
+    /* ref_idc == 0 for 6,9,10,11,12 */
+};
+enum nal_priority_e
+{
+    NAL_PRIORITY_DISPOSABLE = 0,
+    NAL_PRIORITY_LOW        = 1,
+    NAL_PRIORITY_HIGH       = 2,
+    NAL_PRIORITY_HIGHEST    = 3,
+};
+
+/* The data within the payload is already NAL-encapsulated; the ref_idc and type
+ * are merely in the struct for easy access by the calling application.
+ * All data returned in an x264_nal_t, including the data in p_payload, is no longer
+ * valid after the next call to x264_encoder_encode.  Thus it must be used or copied
+ * before calling x264_encoder_encode or x264_encoder_headers again. */
+typedef struct x264_nal_t
+{
+    int i_ref_idc;  /* nal_priority_e */
+    int i_type;     /* nal_unit_type_e */
+    int b_long_startcode;
+    int i_first_mb; /* If this NAL is a slice, the index of the first MB in the slice. */
+    int i_last_mb;  /* If this NAL is a slice, the index of the last MB in the slice. */
+
+    /* Size of payload (including any padding) in bytes. */
+    int     i_payload;
+    /* If param->b_annexb is set, Annex-B bytestream with startcode.
+     * Otherwise, startcode is replaced with a 4-byte size.
+     * This size is the size used in mp4/similar muxing; it is equal to i_payload-4 */
+    uint8_t *p_payload;
+
+    /* Size of padding in bytes. */
+    int i_padding;
+} x264_nal_t;
+
+/****************************************************************************
+ * Encoder parameters
+ ****************************************************************************/
+/* CPU flags */
+
+/* x86 */
+#define X264_CPU_CMOV            0x0000001
+#define X264_CPU_MMX             0x0000002
+#define X264_CPU_MMX2            0x0000004  /* MMX2 aka MMXEXT aka ISSE */
+#define X264_CPU_MMXEXT          X264_CPU_MMX2
+#define X264_CPU_SSE             0x0000008
+#define X264_CPU_SSE2            0x0000010
+#define X264_CPU_SSE3            0x0000020
+#define X264_CPU_SSSE3           0x0000040
+#define X264_CPU_SSE4            0x0000080  /* SSE4.1 */
+#define X264_CPU_SSE42           0x0000100  /* SSE4.2 */
+#define X264_CPU_LZCNT           0x0000200  /* Phenom support for "leading zero count" instruction. */
+#define X264_CPU_AVX             0x0000400  /* AVX support: requires OS support even if YMM registers aren't used. */
+#define X264_CPU_XOP             0x0000800  /* AMD XOP */
+#define X264_CPU_FMA4            0x0001000  /* AMD FMA4 */
+#define X264_CPU_FMA3            0x0002000  /* FMA3 */
+#define X264_CPU_AVX2            0x0004000  /* AVX2 */
+#define X264_CPU_BMI1            0x0008000  /* BMI1 */
+#define X264_CPU_BMI2            0x0010000  /* BMI2 */
+/* x86 modifiers */
+#define X264_CPU_CACHELINE_32    0x0020000  /* avoid memory loads that span the border between two cachelines */
+#define X264_CPU_CACHELINE_64    0x0040000  /* 32/64 is the size of a cacheline in bytes */
+#define X264_CPU_SSE2_IS_SLOW    0x0080000  /* avoid most SSE2 functions on Athlon64 */
+#define X264_CPU_SSE2_IS_FAST    0x0100000  /* a few functions are only faster on Core2 and Phenom */
+#define X264_CPU_SLOW_SHUFFLE    0x0200000  /* The Conroe has a slow shuffle unit (relative to overall SSE performance) */
+#define X264_CPU_STACK_MOD4      0x0400000  /* if stack is only mod4 and not mod16 */
+#define X264_CPU_SLOW_CTZ        0x0800000  /* BSR/BSF x86 instructions are really slow on some CPUs */
+#define X264_CPU_SLOW_ATOM       0x1000000  /* The Atom is terrible: slow SSE unaligned loads, slow
+                                             * SIMD multiplies, slow SIMD variable shifts, slow pshufb,
+                                             * cacheline split penalties -- gather everything here that
+                                             * isn't shared by other CPUs to avoid making half a dozen
+                                             * new SLOW flags. */
+#define X264_CPU_SLOW_PSHUFB     0x2000000  /* such as on the Intel Atom */
+#define X264_CPU_SLOW_PALIGNR    0x4000000  /* such as on the AMD Bobcat */
+
+/* PowerPC */
+#define X264_CPU_ALTIVEC         0x0000001
+
+/* ARM and AArch64 */
+#define X264_CPU_ARMV6           0x0000001
+#define X264_CPU_NEON            0x0000002  /* ARM NEON */
+#define X264_CPU_FAST_NEON_MRC   0x0000004  /* Transfer from NEON to ARM register is fast (Cortex-A9) */
+#define X264_CPU_ARMV8           0x0000008
+
+/* MIPS */
+#define X264_CPU_MSA             0x0000001  /* MIPS MSA */
+
+/* Analyse flags */
+#define X264_ANALYSE_I4x4       0x0001  /* Analyse i4x4 */
+#define X264_ANALYSE_I8x8       0x0002  /* Analyse i8x8 (requires 8x8 transform) */
+#define X264_ANALYSE_PSUB16x16  0x0010  /* Analyse p16x8, p8x16 and p8x8 */
+#define X264_ANALYSE_PSUB8x8    0x0020  /* Analyse p8x4, p4x8, p4x4 */
+#define X264_ANALYSE_BSUB16x16  0x0100  /* Analyse b16x8, b8x16 and b8x8 */
+#define X264_DIRECT_PRED_NONE        0
+#define X264_DIRECT_PRED_SPATIAL     1
+#define X264_DIRECT_PRED_TEMPORAL    2
+#define X264_DIRECT_PRED_AUTO        3
+#define X264_ME_DIA                  0
+#define X264_ME_HEX                  1
+#define X264_ME_UMH                  2
+#define X264_ME_ESA                  3
+#define X264_ME_TESA                 4
+#define X264_CQM_FLAT                0
+#define X264_CQM_JVT                 1
+#define X264_CQM_CUSTOM              2
+#define X264_RC_CQP                  0
+#define X264_RC_CRF                  1
+#define X264_RC_ABR                  2
+#define X264_QP_AUTO                 0
+#define X264_AQ_NONE                 0
+#define X264_AQ_VARIANCE             1
+#define X264_AQ_AUTOVARIANCE         2
+#define X264_AQ_AUTOVARIANCE_BIASED  3
+#define X264_B_ADAPT_NONE            0
+#define X264_B_ADAPT_FAST            1
+#define X264_B_ADAPT_TRELLIS         2
+#define X264_WEIGHTP_NONE            0
+#define X264_WEIGHTP_SIMPLE          1
+#define X264_WEIGHTP_SMART           2
+#define X264_B_PYRAMID_NONE          0
+#define X264_B_PYRAMID_STRICT        1
+#define X264_B_PYRAMID_NORMAL        2
+#define X264_KEYINT_MIN_AUTO         0
+#define X264_KEYINT_MAX_INFINITE     (1<<30)
+
+static const char * const x264_direct_pred_names[] = { "none", "spatial", "temporal", "auto", 0 };
+static const char * const x264_motion_est_names[] = { "dia", "hex", "umh", "esa", "tesa", 0 };
+static const char * const x264_b_pyramid_names[] = { "none", "strict", "normal", 0 };
+static const char * const x264_overscan_names[] = { "undef", "show", "crop", 0 };
+static const char * const x264_vidformat_names[] = { "component", "pal", "ntsc", "secam", "mac", "undef", 0 };
+static const char * const x264_fullrange_names[] = { "off", "on", 0 };
+static const char * const x264_colorprim_names[] = { "", "bt709", "undef", "", "bt470m", "bt470bg", "smpte170m", "smpte240m", "film", "bt2020", "smpte428",
+                                                     "smpte431", "smpte432", 0 };
+static const char * const x264_transfer_names[] = { "", "bt709", "undef", "", "bt470m", "bt470bg", "smpte170m", "smpte240m", "linear", "log100", "log316",
+                                                    "iec61966-2-4", "bt1361e", "iec61966-2-1", "bt2020-10", "bt2020-12", "smpte2084", "smpte428", 0 };
+static const char * const x264_colmatrix_names[] = { "GBR", "bt709", "undef", "", "fcc", "bt470bg", "smpte170m", "smpte240m", "YCgCo", "bt2020nc", "bt2020c",
+                                                     "smpte2085", 0 };
+static const char * const x264_nal_hrd_names[] = { "none", "vbr", "cbr", 0 };
+
+/* Colorspace type */
+#define X264_CSP_MASK           0x00ff  /* */
+#define X264_CSP_NONE           0x0000  /* Invalid mode     */
+#define X264_CSP_I420           0x0001  /* yuv 4:2:0 planar */
+#define X264_CSP_YV12           0x0002  /* yvu 4:2:0 planar */
+#define X264_CSP_NV12           0x0003  /* yuv 4:2:0, with one y plane and one packed u+v */
+#define X264_CSP_NV21           0x0004  /* yuv 4:2:0, with one y plane and one packed v+u */
+#define X264_CSP_I422           0x0005  /* yuv 4:2:2 planar */
+#define X264_CSP_YV16           0x0006  /* yvu 4:2:2 planar */
+#define X264_CSP_NV16           0x0007  /* yuv 4:2:2, with one y plane and one packed u+v */
+#define X264_CSP_V210           0x0008  /* 10-bit yuv 4:2:2 packed in 32 */
+#define X264_CSP_I444           0x0009  /* yuv 4:4:4 planar */
+#define X264_CSP_YV24           0x000a  /* yvu 4:4:4 planar */
+#define X264_CSP_BGR            0x000b  /* packed bgr 24bits   */
+#define X264_CSP_BGRA           0x000c  /* packed bgr 32bits   */
+#define X264_CSP_RGB            0x000d  /* packed rgb 24bits   */
+#define X264_CSP_MAX            0x000e  /* end of list */
+#define X264_CSP_VFLIP          0x1000  /* the csp is vertically flipped */
+#define X264_CSP_HIGH_DEPTH     0x2000  /* the csp has a depth of 16 bits per pixel component */
+
+/* Slice type */
+#define X264_TYPE_AUTO          0x0000  /* Let x264 choose the right type */
+#define X264_TYPE_IDR           0x0001
+#define X264_TYPE_I             0x0002
+#define X264_TYPE_P             0x0003
+#define X264_TYPE_BREF          0x0004  /* Non-disposable B-frame */
+#define X264_TYPE_B             0x0005
+#define X264_TYPE_KEYFRAME      0x0006  /* IDR or I depending on b_open_gop option */
+#define IS_X264_TYPE_I(x) ((x)==X264_TYPE_I || (x)==X264_TYPE_IDR || (x)==X264_TYPE_KEYFRAME)
+#define IS_X264_TYPE_B(x) ((x)==X264_TYPE_B || (x)==X264_TYPE_BREF)
+
+/* Log level */
+#define X264_LOG_NONE          (-1)
+#define X264_LOG_ERROR          0
+#define X264_LOG_WARNING        1
+#define X264_LOG_INFO           2
+#define X264_LOG_DEBUG          3
+
+/* Threading */
+#define X264_THREADS_AUTO 0 /* Automatically select optimal number of threads */
+#define X264_SYNC_LOOKAHEAD_AUTO (-1) /* Automatically select optimal lookahead thread buffer size */
+
+/* HRD */
+#define X264_NAL_HRD_NONE            0
+#define X264_NAL_HRD_VBR             1
+#define X264_NAL_HRD_CBR             2
+
+/* Zones: override ratecontrol or other options for specific sections of the video.
+ * See x264_encoder_reconfig() for which options can be changed.
+ * If zones overlap, whichever comes later in the list takes precedence. */
+typedef struct x264_zone_t
+{
+    int i_start, i_end; /* range of frame numbers */
+    int b_force_qp; /* whether to use qp vs bitrate factor */
+    int i_qp;
+    float f_bitrate_factor;
+    struct x264_param_t *param;
+} x264_zone_t;
+
+typedef struct x264_param_t
+{
+    /* CPU flags */
+    unsigned int cpu;
+    int         i_threads;           /* encode multiple frames in parallel */
+    int         i_lookahead_threads; /* multiple threads for lookahead analysis */
+    int         b_sliced_threads;  /* Whether to use slice-based threading. */
+    int         b_deterministic; /* whether to allow non-deterministic optimizations when threaded */
+    int         b_cpu_independent; /* force canonical behavior rather than cpu-dependent optimal algorithms */
+    int         i_sync_lookahead; /* threaded lookahead buffer */
+
+    /* Video Properties */
+    int         i_width;
+    int         i_height;
+    int         i_csp;         /* CSP of encoded bitstream */
+    int         i_level_idc;
+    int         i_frame_total; /* number of frames to encode if known, else 0 */
+
+    /* NAL HRD
+     * Uses Buffering and Picture Timing SEIs to signal HRD
+     * The HRD in H.264 was not designed with VFR in mind.
+     * It is therefore not recommendeded to use NAL HRD with VFR.
+     * Furthermore, reconfiguring the VBV (via x264_encoder_reconfig)
+     * will currently generate invalid HRD. */
+    int         i_nal_hrd;
+
+    struct
+    {
+        /* they will be reduced to be 0 < x <= 65535 and prime */
+        int         i_sar_height;
+        int         i_sar_width;
+
+        int         i_overscan;    /* 0=undef, 1=no overscan, 2=overscan */
+
+        /* see h264 annex E for the values of the following */
+        int         i_vidformat;
+        int         b_fullrange;
+        int         i_colorprim;
+        int         i_transfer;
+        int         i_colmatrix;
+        int         i_chroma_loc;    /* both top & bottom */
+    } vui;
+
+    /* Bitstream parameters */
+    int         i_frame_reference;  /* Maximum number of reference frames */
+    int         i_dpb_size;         /* Force a DPB size larger than that implied by B-frames and reference frames.
+                                     * Useful in combination with interactive error resilience. */
+    int         i_keyint_max;       /* Force an IDR keyframe at this interval */
+    int         i_keyint_min;       /* Scenecuts closer together than this are coded as I, not IDR. */
+    int         i_scenecut_threshold; /* how aggressively to insert extra I frames */
+    int         b_intra_refresh;    /* Whether or not to use periodic intra refresh instead of IDR frames. */
+
+    int         i_bframe;   /* how many b-frame between 2 references pictures */
+    int         i_bframe_adaptive;
+    int         i_bframe_bias;
+    int         i_bframe_pyramid;   /* Keep some B-frames as references: 0=off, 1=strict hierarchical, 2=normal */
+    int         b_open_gop;
+    int         b_bluray_compat;
+    int         i_avcintra_class;
+
+    int         b_deblocking_filter;
+    int         i_deblocking_filter_alphac0;    /* [-6, 6] -6 light filter, 6 strong */
+    int         i_deblocking_filter_beta;       /* [-6, 6]  idem */
+
+    int         b_cabac;
+    int         i_cabac_init_idc;
+
+    int         b_interlaced;
+    int         b_constrained_intra;
+
+    int         i_cqm_preset;
+    char        *psz_cqm_file;      /* filename (in UTF-8) of CQM file, JM format */
+    uint8_t     cqm_4iy[16];        /* used only if i_cqm_preset == X264_CQM_CUSTOM */
+    uint8_t     cqm_4py[16];
+    uint8_t     cqm_4ic[16];
+    uint8_t     cqm_4pc[16];
+    uint8_t     cqm_8iy[64];
+    uint8_t     cqm_8py[64];
+    uint8_t     cqm_8ic[64];
+    uint8_t     cqm_8pc[64];
+
+    /* Log */
+    void        (*pf_log)( void *, int i_level, const char *psz, va_list );
+    void        *p_log_private;
+    int         i_log_level;
+    int         b_full_recon;   /* fully reconstruct frames, even when not necessary for encoding.  Implied by psz_dump_yuv */
+    char        *psz_dump_yuv;  /* filename (in UTF-8) for reconstructed frames */
+
+    /* Encoder analyser parameters */
+    struct
+    {
+        unsigned int intra;     /* intra partitions */
+        unsigned int inter;     /* inter partitions */
+
+        int          b_transform_8x8;
+        int          i_weighted_pred; /* weighting for P-frames */
+        int          b_weighted_bipred; /* implicit weighting for B-frames */
+        int          i_direct_mv_pred; /* spatial vs temporal mv prediction */
+        int          i_chroma_qp_offset;
+
+        int          i_me_method; /* motion estimation algorithm to use (X264_ME_*) */
+        int          i_me_range; /* integer pixel motion estimation search range (from predicted mv) */
+        int          i_mv_range; /* maximum length of a mv (in pixels). -1 = auto, based on level */
+        int          i_mv_range_thread; /* minimum space between threads. -1 = auto, based on number of threads. */
+        int          i_subpel_refine; /* subpixel motion estimation quality */
+        int          b_chroma_me; /* chroma ME for subpel and mode decision in P-frames */
+        int          b_mixed_references; /* allow each mb partition to have its own reference number */
+        int          i_trellis;  /* trellis RD quantization */
+        int          b_fast_pskip; /* early SKIP detection on P-frames */
+        int          b_dct_decimate; /* transform coefficient thresholding on P-frames */
+        int          i_noise_reduction; /* adaptive pseudo-deadzone */
+        float        f_psy_rd; /* Psy RD strength */
+        float        f_psy_trellis; /* Psy trellis strength */
+        int          b_psy; /* Toggle all psy optimizations */
+
+        int          b_mb_info;            /* Use input mb_info data in x264_picture_t */
+        int          b_mb_info_update; /* Update the values in mb_info according to the results of encoding. */
+
+        /* the deadzone size that will be used in luma quantization */
+        int          i_luma_deadzone[2]; /* {inter, intra} */
+
+        int          b_psnr;    /* compute and print PSNR stats */
+        int          b_ssim;    /* compute and print SSIM stats */
+    } analyse;
+
+    /* Rate control parameters */
+    struct
+    {
+        int         i_rc_method;    /* X264_RC_* */
+
+        int         i_qp_constant;  /* 0 to (51 + 6*(x264_bit_depth-8)). 0=lossless */
+        int         i_qp_min;       /* min allowed QP value */
+        int         i_qp_max;       /* max allowed QP value */
+        int         i_qp_step;      /* max QP step between frames */
+
+        int         i_bitrate;
+        float       f_rf_constant;  /* 1pass VBR, nominal QP */
+        float       f_rf_constant_max;  /* In CRF mode, maximum CRF as caused by VBV */
+        float       f_rate_tolerance;
+        int         i_vbv_max_bitrate;
+        int         i_vbv_buffer_size;
+        float       f_vbv_buffer_init; /* <=1: fraction of buffer_size. >1: kbit */
+        float       f_ip_factor;
+        float       f_pb_factor;
+
+        /* VBV filler: force CBR VBV and use filler bytes to ensure hard-CBR.
+         * Implied by NAL-HRD CBR. */
+        int         b_filler;
+
+        int         i_aq_mode;      /* psy adaptive QP. (X264_AQ_*) */
+        float       f_aq_strength;
+        int         b_mb_tree;      /* Macroblock-tree ratecontrol. */
+        int         i_lookahead;
+
+        /* 2pass */
+        int         b_stat_write;   /* Enable stat writing in psz_stat_out */
+        char        *psz_stat_out;  /* output filename (in UTF-8) of the 2pass stats file */
+        int         b_stat_read;    /* Read stat from psz_stat_in and use it */
+        char        *psz_stat_in;   /* input filename (in UTF-8) of the 2pass stats file */
+
+        /* 2pass params (same as ffmpeg ones) */
+        float       f_qcompress;    /* 0.0 => cbr, 1.0 => constant qp */
+        float       f_qblur;        /* temporally blur quants */
+        float       f_complexity_blur; /* temporally blur complexity */
+        x264_zone_t *zones;         /* ratecontrol overrides */
+        int         i_zones;        /* number of zone_t's */
+        char        *psz_zones;     /* alternate method of specifying zones */
+    } rc;
+
+    /* Cropping Rectangle parameters: added to those implicitly defined by
+       non-mod16 video resolutions. */
+    struct
+    {
+        unsigned int i_left;
+        unsigned int i_top;
+        unsigned int i_right;
+        unsigned int i_bottom;
+    } crop_rect;
+
+    /* frame packing arrangement flag */
+    int i_frame_packing;
+
+    /* Muxing parameters */
+    int b_aud;                  /* generate access unit delimiters */
+    int b_repeat_headers;       /* put SPS/PPS before each keyframe */
+    int b_annexb;               /* if set, place start codes (4 bytes) before NAL units,
+                                 * otherwise place size (4 bytes) before NAL units. */
+    int i_sps_id;               /* SPS and PPS id number */
+    int b_vfr_input;            /* VFR input.  If 1, use timebase and timestamps for ratecontrol purposes.
+                                 * If 0, use fps only. */
+    int b_pulldown;             /* use explicity set timebase for CFR */
+    uint32_t i_fps_num;
+    uint32_t i_fps_den;
+    uint32_t i_timebase_num;    /* Timebase numerator */
+    uint32_t i_timebase_den;    /* Timebase denominator */
+
+    int b_tff;
+
+    /* Pulldown:
+     * The correct pic_struct must be passed with each input frame.
+     * The input timebase should be the timebase corresponding to the output framerate. This should be constant.
+     * e.g. for 3:2 pulldown timebase should be 1001/30000
+     * The PTS passed with each frame must be the PTS of the frame after pulldown is applied.
+     * Frame doubling and tripling require b_vfr_input set to zero (see H.264 Table D-1)
+     *
+     * Pulldown changes are not clearly defined in H.264. Therefore, it is the calling app's responsibility to manage this.
+     */
+
+    int b_pic_struct;
+
+    /* Fake Interlaced.
+     *
+     * Used only when b_interlaced=0. Setting this flag makes it possible to flag the stream as PAFF interlaced yet
+     * encode all frames progessively. It is useful for encoding 25p and 30p Blu-Ray streams.
+     */
+
+    int b_fake_interlaced;
+
+    /* Don't optimize header parameters based on video content, e.g. ensure that splitting an input video, compressing
+     * each part, and stitching them back together will result in identical SPS/PPS. This is necessary for stitching
+     * with container formats that don't allow multiple SPS/PPS. */
+    int b_stitchable;
+
+    int b_opencl;            /* use OpenCL when available */
+    int i_opencl_device;     /* specify count of GPU devices to skip, for CLI users */
+    void *opencl_device_id;  /* pass explicit cl_device_id as void*, for API users */
+    char *psz_clbin_file;    /* filename (in UTF-8) of the compiled OpenCL kernel cache file */
+
+    /* Slicing parameters */
+    int i_slice_max_size;    /* Max size per slice in bytes; includes estimated NAL overhead. */
+    int i_slice_max_mbs;     /* Max number of MBs per slice; overrides i_slice_count. */
+    int i_slice_min_mbs;     /* Min number of MBs per slice */
+    int i_slice_count;       /* Number of slices per frame: forces rectangular slices. */
+    int i_slice_count_max;   /* Absolute cap on slices per frame; stops applying slice-max-size
+                              * and slice-max-mbs if this is reached. */
+
+    /* Optional callback for freeing this x264_param_t when it is done being used.
+     * Only used when the x264_param_t sits in memory for an indefinite period of time,
+     * i.e. when an x264_param_t is passed to x264_t in an x264_picture_t or in zones.
+     * Not used when x264_encoder_reconfig is called directly. */
+    void (*param_free)( void* );
+
+    /* Optional low-level callback for low-latency encoding.  Called for each output NAL unit
+     * immediately after the NAL unit is finished encoding.  This allows the calling application
+     * to begin processing video data (e.g. by sending packets over a network) before the frame
+     * is done encoding.
+     *
+     * This callback MUST do the following in order to work correctly:
+     * 1) Have available an output buffer of at least size nal->i_payload*3/2 + 5 + 64.
+     * 2) Call x264_nal_encode( h, dst, nal ), where dst is the output buffer.
+     * After these steps, the content of nal is valid and can be used in the same way as if
+     * the NAL unit were output by x264_encoder_encode.
+     *
+     * This does not need to be synchronous with the encoding process: the data pointed to
+     * by nal (both before and after x264_nal_encode) will remain valid until the next
+     * x264_encoder_encode call.  The callback must be re-entrant.
+     *
+     * This callback does not work with frame-based threads; threads must be disabled
+     * or sliced-threads enabled.  This callback also does not work as one would expect
+     * with HRD -- since the buffering period SEI cannot be calculated until the frame
+     * is finished encoding, it will not be sent via this callback.
+     *
+     * Note also that the NALs are not necessarily returned in order when sliced threads is
+     * enabled.  Accordingly, the variable i_first_mb and i_last_mb are available in
+     * x264_nal_t to help the calling application reorder the slices if necessary.
+     *
+     * When this callback is enabled, x264_encoder_encode does not return valid NALs;
+     * the calling application is expected to acquire all output NALs through the callback.
+     *
+     * It is generally sensible to combine this callback with a use of slice-max-mbs or
+     * slice-max-size.
+     *
+     * The opaque pointer is the opaque pointer from the input frame associated with this
+     * NAL unit. This helps distinguish between nalu_process calls from different sources,
+     * e.g. if doing multiple encodes in one process.
+     */
+    void (*nalu_process) ( x264_t *h, x264_nal_t *nal, void *opaque );
+} x264_param_t;
+
+void x264_nal_encode( x264_t *h, uint8_t *dst, x264_nal_t *nal );
+
+/****************************************************************************
+ * H.264 level restriction information
+ ****************************************************************************/
+
+typedef struct x264_level_t
+{
+    int level_idc;
+    int mbps;        /* max macroblock processing rate (macroblocks/sec) */
+    int frame_size;  /* max frame size (macroblocks) */
+    int dpb;         /* max decoded picture buffer (mbs) */
+    int bitrate;     /* max bitrate (kbit/sec) */
+    int cpb;         /* max vbv buffer (kbit) */
+    int mv_range;    /* max vertical mv component range (pixels) */
+    int mvs_per_2mb; /* max mvs per 2 consecutive mbs. */
+    int slice_rate;  /* ?? */
+    int mincr;       /* min compression ratio */
+    int bipred8x8;   /* limit bipred to >=8x8 */
+    int direct8x8;   /* limit b_direct to >=8x8 */
+    int frame_only;  /* forbid interlacing */
+} x264_level_t;
+
+/* all of the levels defined in the standard, terminated by .level_idc=0 */
+X264_API extern const x264_level_t x264_levels[];
+
+/****************************************************************************
+ * Basic parameter handling functions
+ ****************************************************************************/
+
+/* x264_param_default:
+ *      fill x264_param_t with default values and do CPU detection */
+void    x264_param_default( x264_param_t * );
+
+/* x264_param_parse:
+ *  set one parameter by name.
+ *  returns 0 on success, or returns one of the following errors.
+ *  note: BAD_VALUE occurs only if it can't even parse the value,
+ *  numerical range is not checked until x264_encoder_open() or
+ *  x264_encoder_reconfig().
+ *  value=NULL means "true" for boolean options, but is a BAD_VALUE for non-booleans. */
+#define X264_PARAM_BAD_NAME  (-1)
+#define X264_PARAM_BAD_VALUE (-2)
+int x264_param_parse( x264_param_t *, const char *name, const char *value );
+
+/****************************************************************************
+ * Advanced parameter handling functions
+ ****************************************************************************/
+
+/* These functions expose the full power of x264's preset-tune-profile system for
+ * easy adjustment of large numbers of internal parameters.
+ *
+ * In order to replicate x264CLI's option handling, these functions MUST be called
+ * in the following order:
+ * 1) x264_param_default_preset
+ * 2) Custom user options (via param_parse or directly assigned variables)
+ * 3) x264_param_apply_fastfirstpass
+ * 4) x264_param_apply_profile
+ *
+ * Additionally, x264CLI does not apply step 3 if the preset chosen is "placebo"
+ * or --slow-firstpass is set. */
+
+/* x264_param_default_preset:
+ *      The same as x264_param_default, but also use the passed preset and tune
+ *      to modify the default settings.
+ *      (either can be NULL, which implies no preset or no tune, respectively)
+ *
+ *      Currently available presets are, ordered from fastest to slowest: */
+static const char * const x264_preset_names[] = { "ultrafast", "superfast", "veryfast", "faster", "fast", "medium", "slow", "slower", "veryslow", "placebo", 0 };
+
+/*      The presets can also be indexed numerically, as in:
+ *      x264_param_default_preset( &param, "3", ... )
+ *      with ultrafast mapping to "0" and placebo mapping to "9".  This mapping may
+ *      of course change if new presets are added in between, but will always be
+ *      ordered from fastest to slowest.
+ *
+ *      Warning: the speed of these presets scales dramatically.  Ultrafast is a full
+ *      100 times faster than placebo!
+ *
+ *      Currently available tunings are: */
+static const char * const x264_tune_names[] = { "film", "animation", "grain", "stillimage", "psnr", "ssim", "fastdecode", "zerolatency", 0 };
+
+/*      Multiple tunings can be used if separated by a delimiter in ",./-+",
+ *      however multiple psy tunings cannot be used.
+ *      film, animation, grain, stillimage, psnr, and ssim are psy tunings.
+ *
+ *      returns 0 on success, negative on failure (e.g. invalid preset/tune name). */
+int     x264_param_default_preset( x264_param_t *, const char *preset, const char *tune );
+
+/* x264_param_apply_fastfirstpass:
+ *      If first-pass mode is set (rc.b_stat_read == 0, rc.b_stat_write == 1),
+ *      modify the encoder settings to disable options generally not useful on
+ *      the first pass. */
+void    x264_param_apply_fastfirstpass( x264_param_t * );
+
+/* x264_param_apply_profile:
+ *      Applies the restrictions of the given profile.
+ *      Currently available profiles are, from most to least restrictive: */
+static const char * const x264_profile_names[] = { "baseline", "main", "high", "high10", "high422", "high444", 0 };
+
+/*      (can be NULL, in which case the function will do nothing)
+ *
+ *      Does NOT guarantee that the given profile will be used: if the restrictions
+ *      of "High" are applied to settings that are already Baseline-compatible, the
+ *      stream will remain baseline.  In short, it does not increase settings, only
+ *      decrease them.
+ *
+ *      returns 0 on success, negative on failure (e.g. invalid profile name). */
+int     x264_param_apply_profile( x264_param_t *, const char *profile );
+
+/****************************************************************************
+ * Picture structures and functions
+ ****************************************************************************/
+
+/* x264_bit_depth:
+ *      Specifies the number of bits per pixel that x264 uses. This is also the
+ *      bit depth that x264 encodes in. If this value is > 8, x264 will read
+ *      two bytes of input data for each pixel sample, and expect the upper
+ *      (16-x264_bit_depth) bits to be zero.
+ *      Note: The flag X264_CSP_HIGH_DEPTH must be used to specify the
+ *      colorspace depth as well. */
+X264_API extern const int x264_bit_depth;
+
+/* x264_chroma_format:
+ *      Specifies the chroma formats that x264 supports encoding. When this
+ *      value is non-zero, then it represents a X264_CSP_* that is the only
+ *      chroma format that x264 supports encoding. If the value is 0 then
+ *      there are no restrictions. */
+X264_API extern const int x264_chroma_format;
+
+enum pic_struct_e
+{
+    PIC_STRUCT_AUTO              = 0, // automatically decide (default)
+    PIC_STRUCT_PROGRESSIVE       = 1, // progressive frame
+    // "TOP" and "BOTTOM" are not supported in x264 (PAFF only)
+    PIC_STRUCT_TOP_BOTTOM        = 4, // top field followed by bottom
+    PIC_STRUCT_BOTTOM_TOP        = 5, // bottom field followed by top
+    PIC_STRUCT_TOP_BOTTOM_TOP    = 6, // top field, bottom field, top field repeated
+    PIC_STRUCT_BOTTOM_TOP_BOTTOM = 7, // bottom field, top field, bottom field repeated
+    PIC_STRUCT_DOUBLE            = 8, // double frame
+    PIC_STRUCT_TRIPLE            = 9, // triple frame
+};
+
+typedef struct x264_hrd_t
+{
+    double cpb_initial_arrival_time;
+    double cpb_final_arrival_time;
+    double cpb_removal_time;
+
+    double dpb_output_time;
+} x264_hrd_t;
+
+/* Arbitrary user SEI:
+ * Payload size is in bytes and the payload pointer must be valid.
+ * Payload types and syntax can be found in Annex D of the H.264 Specification.
+ * SEI payload alignment bits as described in Annex D must be included at the
+ * end of the payload if needed.
+ * The payload should not be NAL-encapsulated.
+ * Payloads are written first in order of input, apart from in the case when HRD
+ * is enabled where payloads are written after the Buffering Period SEI. */
+
+typedef struct x264_sei_payload_t
+{
+    int payload_size;
+    int payload_type;
+    uint8_t *payload;
+} x264_sei_payload_t;
+
+typedef struct x264_sei_t
+{
+    int num_payloads;
+    x264_sei_payload_t *payloads;
+    /* In: optional callback to free each payload AND x264_sei_payload_t when used. */
+    void (*sei_free)( void* );
+} x264_sei_t;
+
+typedef struct x264_image_t
+{
+    int     i_csp;       /* Colorspace */
+    int     i_plane;     /* Number of image planes */
+    int     i_stride[4]; /* Strides for each plane */
+    uint8_t *plane[4];   /* Pointers to each plane */
+} x264_image_t;
+
+typedef struct x264_image_properties_t
+{
+    /* All arrays of data here are ordered as follows:
+     * each array contains one offset per macroblock, in raster scan order.  In interlaced
+     * mode, top-field MBs and bottom-field MBs are interleaved at the row level.
+     * Macroblocks are 16x16 blocks of pixels (with respect to the luma plane).  For the
+     * purposes of calculating the number of macroblocks, width and height are rounded up to
+     * the nearest 16.  If in interlaced mode, height is rounded up to the nearest 32 instead. */
+
+    /* In: an array of quantizer offsets to be applied to this image during encoding.
+     *     These are added on top of the decisions made by x264.
+     *     Offsets can be fractional; they are added before QPs are rounded to integer.
+     *     Adaptive quantization must be enabled to use this feature.  Behavior if quant
+     *     offsets differ between encoding passes is undefined. */
+    float *quant_offsets;
+    /* In: optional callback to free quant_offsets when used.
+     *     Useful if one wants to use a different quant_offset array for each frame. */
+    void (*quant_offsets_free)( void* );
+
+    /* In: optional array of flags for each macroblock.
+     *     Allows specifying additional information for the encoder such as which macroblocks
+     *     remain unchanged.  Usable flags are listed below.
+     *     x264_param_t.analyse.b_mb_info must be set to use this, since x264 needs to track
+     *     extra data internally to make full use of this information.
+     *
+     * Out: if b_mb_info_update is set, x264 will update this array as a result of encoding.
+     *
+     *      For "MBINFO_CONSTANT", it will remove this flag on any macroblock whose decoded
+     *      pixels have changed.  This can be useful for e.g. noting which areas of the
+     *      frame need to actually be blitted. Note: this intentionally ignores the effects
+     *      of deblocking for the current frame, which should be fine unless one needs exact
+     *      pixel-perfect accuracy.
+     *
+     *      Results for MBINFO_CONSTANT are currently only set for P-frames, and are not
+     *      guaranteed to enumerate all blocks which haven't changed.  (There may be false
+     *      negatives, but no false positives.)
+     */
+    uint8_t *mb_info;
+    /* In: optional callback to free mb_info when used. */
+    void (*mb_info_free)( void* );
+
+    /* The macroblock is constant and remains unchanged from the previous frame. */
+    #define X264_MBINFO_CONSTANT   (1<<0)
+    /* More flags may be added in the future. */
+
+    /* Out: SSIM of the the frame luma (if x264_param_t.b_ssim is set) */
+    double f_ssim;
+    /* Out: Average PSNR of the frame (if x264_param_t.b_psnr is set) */
+    double f_psnr_avg;
+    /* Out: PSNR of Y, U, and V (if x264_param_t.b_psnr is set) */
+    double f_psnr[3];
+
+    /* Out: Average effective CRF of the encoded frame */
+    double f_crf_avg;
+} x264_image_properties_t;
+
+typedef struct x264_picture_t
+{
+    /* In: force picture type (if not auto)
+     *     If x264 encoding parameters are violated in the forcing of picture types,
+     *     x264 will correct the input picture type and log a warning.
+     * Out: type of the picture encoded */
+    int     i_type;
+    /* In: force quantizer for != X264_QP_AUTO */
+    int     i_qpplus1;
+    /* In: pic_struct, for pulldown/doubling/etc...used only if b_pic_struct=1.
+     *     use pic_struct_e for pic_struct inputs
+     * Out: pic_struct element associated with frame */
+    int     i_pic_struct;
+    /* Out: whether this frame is a keyframe.  Important when using modes that result in
+     * SEI recovery points being used instead of IDR frames. */
+    int     b_keyframe;
+    /* In: user pts, Out: pts of encoded picture (user)*/
+    int64_t i_pts;
+    /* Out: frame dts. When the pts of the first frame is close to zero,
+     *      initial frames may have a negative dts which must be dealt with by any muxer */
+    int64_t i_dts;
+    /* In: custom encoding parameters to be set from this frame forwards
+           (in coded order, not display order). If NULL, continue using
+           parameters from the previous frame.  Some parameters, such as
+           aspect ratio, can only be changed per-GOP due to the limitations
+           of H.264 itself; in this case, the caller must force an IDR frame
+           if it needs the changed parameter to apply immediately. */
+    x264_param_t *param;
+    /* In: raw image data */
+    /* Out: reconstructed image data.  x264 may skip part of the reconstruction process,
+            e.g. deblocking, in frames where it isn't necessary.  To force complete
+            reconstruction, at a small speed cost, set b_full_recon. */
+    x264_image_t img;
+    /* In: optional information to modify encoder decisions for this frame
+     * Out: information about the encoded frame */
+    x264_image_properties_t prop;
+    /* Out: HRD timing information. Output only when i_nal_hrd is set. */
+    x264_hrd_t hrd_timing;
+    /* In: arbitrary user SEI (e.g subtitles, AFDs) */
+    x264_sei_t extra_sei;
+    /* private user data. copied from input to output frames. */
+    void *opaque;
+} x264_picture_t;
+
+/* x264_picture_init:
+ *  initialize an x264_picture_t.  Needs to be done if the calling application
+ *  allocates its own x264_picture_t as opposed to using x264_picture_alloc. */
+void x264_picture_init( x264_picture_t *pic );
+
+/* x264_picture_alloc:
+ *  alloc data for a picture. You must call x264_picture_clean on it.
+ *  returns 0 on success, or -1 on malloc failure or invalid colorspace. */
+int x264_picture_alloc( x264_picture_t *pic, int i_csp, int i_width, int i_height );
+
+/* x264_picture_clean:
+ *  free associated resource for a x264_picture_t allocated with
+ *  x264_picture_alloc ONLY */
+void x264_picture_clean( x264_picture_t *pic );
+
+/****************************************************************************
+ * Encoder functions
+ ****************************************************************************/
+
+/* Force a link error in the case of linking against an incompatible API version.
+ * Glue #defines exist to force correct macro expansion; the final output of the macro
+ * is x264_encoder_open_##X264_BUILD (for purposes of dlopen). */
+#define x264_encoder_glue1(x,y) x##y
+#define x264_encoder_glue2(x,y) x264_encoder_glue1(x,y)
+#define x264_encoder_open x264_encoder_glue2(x264_encoder_open_,X264_BUILD)
+
+/* x264_encoder_open:
+ *      create a new encoder handler, all parameters from x264_param_t are copied */
+x264_t *x264_encoder_open( x264_param_t * );
+
+/* x264_encoder_reconfig:
+ *      various parameters from x264_param_t are copied.
+ *      this takes effect immediately, on whichever frame is encoded next;
+ *      due to delay, this may not be the next frame passed to encoder_encode.
+ *      if the change should apply to some particular frame, use x264_picture_t->param instead.
+ *      returns 0 on success, negative on parameter validation error.
+ *      not all parameters can be changed; see the actual function for a detailed breakdown.
+ *
+ *      since not all parameters can be changed, moving from preset to preset may not always
+ *      fully copy all relevant parameters, but should still work usably in practice. however,
+ *      more so than for other presets, many of the speed shortcuts used in ultrafast cannot be
+ *      switched out of; using reconfig to switch between ultrafast and other presets is not
+ *      recommended without a more fine-grained breakdown of parameters to take this into account. */
+int     x264_encoder_reconfig( x264_t *, x264_param_t * );
+/* x264_encoder_parameters:
+ *      copies the current internal set of parameters to the pointer provided
+ *      by the caller.  useful when the calling application needs to know
+ *      how x264_encoder_open has changed the parameters, or the current state
+ *      of the encoder after multiple x264_encoder_reconfig calls.
+ *      note that the data accessible through pointers in the returned param struct
+ *      (e.g. filenames) should not be modified by the calling application. */
+void    x264_encoder_parameters( x264_t *, x264_param_t * );
+/* x264_encoder_headers:
+ *      return the SPS and PPS that will be used for the whole stream.
+ *      *pi_nal is the number of NAL units outputted in pp_nal.
+ *      returns the number of bytes in the returned NALs.
+ *      returns negative on error.
+ *      the payloads of all output NALs are guaranteed to be sequential in memory. */
+int     x264_encoder_headers( x264_t *, x264_nal_t **pp_nal, int *pi_nal );
+/* x264_encoder_encode:
+ *      encode one picture.
+ *      *pi_nal is the number of NAL units outputted in pp_nal.
+ *      returns the number of bytes in the returned NALs.
+ *      returns negative on error and zero if no NAL units returned.
+ *      the payloads of all output NALs are guaranteed to be sequential in memory. */
+int     x264_encoder_encode( x264_t *, x264_nal_t **pp_nal, int *pi_nal, x264_picture_t *pic_in, x264_picture_t *pic_out );
+/* x264_encoder_close:
+ *      close an encoder handler */
+void    x264_encoder_close  ( x264_t * );
+/* x264_encoder_delayed_frames:
+ *      return the number of currently delayed (buffered) frames
+ *      this should be used at the end of the stream, to know when you have all the encoded frames. */
+int     x264_encoder_delayed_frames( x264_t * );
+/* x264_encoder_maximum_delayed_frames( x264_t *h ):
+ *      return the maximum number of delayed (buffered) frames that can occur with the current
+ *      parameters. */
+int     x264_encoder_maximum_delayed_frames( x264_t *h );
+/* x264_encoder_intra_refresh:
+ *      If an intra refresh is not in progress, begin one with the next P-frame.
+ *      If an intra refresh is in progress, begin one as soon as the current one finishes.
+ *      Requires that b_intra_refresh be set.
+ *
+ *      Useful for interactive streaming where the client can tell the server that packet loss has
+ *      occurred.  In this case, keyint can be set to an extremely high value so that intra refreshes
+ *      only occur when calling x264_encoder_intra_refresh.
+ *
+ *      In multi-pass encoding, if x264_encoder_intra_refresh is called differently in each pass,
+ *      behavior is undefined.
+ *
+ *      Should not be called during an x264_encoder_encode. */
+void    x264_encoder_intra_refresh( x264_t * );
+/* x264_encoder_invalidate_reference:
+ *      An interactive error resilience tool, designed for use in a low-latency one-encoder-few-clients
+ *      system.  When the client has packet loss or otherwise incorrectly decodes a frame, the encoder
+ *      can be told with this command to "forget" the frame and all frames that depend on it, referencing
+ *      only frames that occurred before the loss.  This will force a keyframe if no frames are left to
+ *      reference after the aforementioned "forgetting".
+ *
+ *      It is strongly recommended to use a large i_dpb_size in this case, which allows the encoder to
+ *      keep around extra, older frames to fall back on in case more recent frames are all invalidated.
+ *      Unlike increasing i_frame_reference, this does not increase the number of frames used for motion
+ *      estimation and thus has no speed impact.  It is also recommended to set a very large keyframe
+ *      interval, so that keyframes are not used except as necessary for error recovery.
+ *
+ *      x264_encoder_invalidate_reference is not currently compatible with the use of B-frames or intra
+ *      refresh.
+ *
+ *      In multi-pass encoding, if x264_encoder_invalidate_reference is called differently in each pass,
+ *      behavior is undefined.
+ *
+ *      Should not be called during an x264_encoder_encode, but multiple calls can be made simultaneously.
+ *
+ *      Returns 0 on success, negative on failure. */
+int x264_encoder_invalidate_reference( x264_t *, int64_t pts );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/TMessagesProj/jni/ffmpeg/include/x264_config.h b/TMessagesProj/jni/ffmpeg/include/x264_config.h
new file mode 100644
index 000000000..94ca522ef
--- /dev/null
+++ b/TMessagesProj/jni/ffmpeg/include/x264_config.h
@@ -0,0 +1,6 @@
+#define X264_BIT_DEPTH     8
+#define X264_GPL           1
+#define X264_INTERLACED    0
+#define X264_CHROMA_FORMAT X264_CSP_I420
+#define X264_VERSION ""
+#define X264_POINTVER "0.148.x"
diff --git a/TMessagesProj/jni/ffmpeg/x86_64/libavcodec.a b/TMessagesProj/jni/ffmpeg/x86_64/libavcodec.a
index b7a8e733f..5557e0343 100644
Binary files a/TMessagesProj/jni/ffmpeg/x86_64/libavcodec.a and b/TMessagesProj/jni/ffmpeg/x86_64/libavcodec.a differ
diff --git a/TMessagesProj/jni/ffmpeg/x86_64/libavformat.a b/TMessagesProj/jni/ffmpeg/x86_64/libavformat.a
index 211ea97d5..8c41344e9 100644
Binary files a/TMessagesProj/jni/ffmpeg/x86_64/libavformat.a and b/TMessagesProj/jni/ffmpeg/x86_64/libavformat.a differ
diff --git a/TMessagesProj/jni/ffmpeg/x86_64/libavresample.a b/TMessagesProj/jni/ffmpeg/x86_64/libavresample.a
index 00f258687..606bc8756 100644
Binary files a/TMessagesProj/jni/ffmpeg/x86_64/libavresample.a and b/TMessagesProj/jni/ffmpeg/x86_64/libavresample.a differ
diff --git a/TMessagesProj/jni/ffmpeg/x86_64/libavutil.a b/TMessagesProj/jni/ffmpeg/x86_64/libavutil.a
index 4f29a7591..d14eedca7 100644
Binary files a/TMessagesProj/jni/ffmpeg/x86_64/libavutil.a and b/TMessagesProj/jni/ffmpeg/x86_64/libavutil.a differ
diff --git a/TMessagesProj/jni/ffmpeg/x86_64/libswscale.a b/TMessagesProj/jni/ffmpeg/x86_64/libswscale.a
index 27f57efe3..45dbb7989 100644
Binary files a/TMessagesProj/jni/ffmpeg/x86_64/libswscale.a and b/TMessagesProj/jni/ffmpeg/x86_64/libswscale.a differ
diff --git a/TMessagesProj/jni/video-compress.c b/TMessagesProj/jni/video-compress.c
new file mode 100644
index 000000000..79ea92f65
--- /dev/null
+++ b/TMessagesProj/jni/video-compress.c
@@ -0,0 +1,634 @@
+#include <libavformat/avformat.h>
+#include <libavcodec/avcodec.h>
+#include <libswscale/swscale.h>
+#include "c_utils.h"
+#include <jni.h>
+#include <malloc.h>
+
+typedef struct StreamContext {
+    AVCodecContext *dec_ctx;
+    AVCodecContext *enc_ctx;
+    int64_t pts_start_from;
+    int streamIndex;
+} StreamContext;
+
+typedef struct VideoConfig {
+    int height;
+    int width;
+    int bitrate;
+    int frame_rate;
+    float start_time;
+    float end_time;
+};
+
+typedef struct Context {
+    struct StreamContext audio_stream_context;
+    struct VideoConfig videoConfig;
+
+    AVFormatContext *ifmt_ctx;
+    AVFormatContext *ofmt_ctx;
+    AVFrame *video_frame;
+    AVCodecContext *video_enc_ctx;
+
+    int videoStreamIndex;
+    int audioStreamIndex;
+    double_t pts_scale;
+};
+
+int open_input_file(const char *filename, struct Context *context) {
+    int ret;
+    unsigned int i;
+
+    context->ifmt_ctx = NULL;
+    if ((ret = avformat_open_input(&context->ifmt_ctx, filename, NULL, NULL)) < 0) {
+        LOGE("Cannot open input file\n");
+        return ret;
+    }
+
+    if ((ret = avformat_find_stream_info(context->ifmt_ctx, NULL)) < 0) {
+        LOGE("Cannot find stream information\n");
+        return ret;
+    }
+
+
+    for (i = 0; i < context->ifmt_ctx->nb_streams; i++) {
+        AVStream *stream = context->ifmt_ctx->streams[i];
+        if (stream->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
+            context->audioStreamIndex = i;
+            context->audio_stream_context.streamIndex = context->audioStreamIndex;
+            if (stream->codecpar->codec_id != AV_CODEC_ID_AAC) {
+                AVCodec *dec = avcodec_find_decoder(stream->codecpar->codec_id);
+                AVCodecContext *codec_ctx;
+                if (!dec) {
+                    LOGE("Failed to find decoder for stream #%u\n", i);
+                    return AVERROR_DECODER_NOT_FOUND;
+                }
+                codec_ctx = avcodec_alloc_context3(dec);
+                if (!codec_ctx) {
+                    LOGE("Failed to allocate the decoder context for stream #%u\n", i);
+                    return AVERROR(ENOMEM);
+                }
+                ret = avcodec_parameters_to_context(codec_ctx, stream->codecpar);
+                if (ret < 0) {
+                    LOGE("Failed to copy decoder parameters to input decoder context "
+                         "for stream #%u\n", i);
+                    return ret;
+                }
+
+                AVDictionary *opt = NULL;
+                if (codec_ctx->codec_id == AV_CODEC_ID_H264) {
+                    av_dict_set(&opt, "preset", "superfast", 0);
+                }
+                ret = avcodec_open2(codec_ctx, dec, &opt);
+                av_dict_free(&opt);
+                if (ret < 0) {
+                    LOGE("Failed to open decoder for stream #%u\n", i);
+                    return ret;
+                }
+
+                context->audio_stream_context.dec_ctx = codec_ctx;
+            } else {
+                context->audio_stream_context.dec_ctx = NULL;
+                context->audio_stream_context.enc_ctx = NULL;
+            }
+        }
+
+        if (stream->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {
+            context->videoStreamIndex = i;
+        }
+    }
+    return 0;
+}
+
+int open_output_file(const char *filename, struct Context *context) {
+    AVStream *in_stream;
+    AVCodecContext *dec_ctx, *enc_ctx;
+    AVCodec *encoder;
+    int ret;
+    unsigned int i;
+
+    context->ofmt_ctx = NULL;
+    avformat_alloc_output_context2(&context->ofmt_ctx, NULL, NULL, filename);
+
+
+    for (i = 0; i < context->ifmt_ctx->nb_streams; i++) {
+        in_stream = context->ifmt_ctx->streams[i];
+        if (context->audioStreamIndex == i) {
+            AVStream *out_stream = avformat_new_stream(context->ofmt_ctx, NULL);
+            if (context->audio_stream_context.dec_ctx == NULL) {
+                ret = avcodec_parameters_copy(out_stream->codecpar, in_stream->codecpar);
+                if (ret < 0) {
+                    av_log(NULL, AV_LOG_ERROR, "Copying parameters for stream #%u failed\n", i);
+                    return ret;
+                }
+                out_stream->time_base = in_stream->time_base;
+            } else {
+                encoder = avcodec_find_encoder(AV_CODEC_ID_AAC);
+                if (!encoder) {
+                    LOGE("Necessary encoder not found aac\n");
+                    return AVERROR_INVALIDDATA;
+                }
+                enc_ctx = avcodec_alloc_context3(encoder);
+                if (!enc_ctx) {
+                    LOGE("Failed to allocate the encoder context\n");
+                    return AVERROR(ENOMEM);
+                }
+
+                enc_ctx->sample_rate = dec_ctx->sample_rate;
+                enc_ctx->channel_layout = dec_ctx->channel_layout;
+                enc_ctx->channels = av_get_channel_layout_nb_channels(enc_ctx->channel_layout);
+                enc_ctx->sample_fmt = encoder->sample_fmts[0];
+                enc_ctx->time_base = (AVRational) {1, enc_ctx->sample_rate};
+                enc_ctx->flags |= AV_CODEC_FLAG_GLOBAL_HEADER;
+
+                ret = avcodec_open2(enc_ctx, encoder, NULL);
+
+                if (ret < 0) {
+                    LOGE("Cannot open audio encoder %s\n", av_err2str(ret));
+                    return ret;
+                }
+                if (ret < 0) {
+                    LOGE("Failed to copy encoder parameters to output stream #%u\n", i);
+                    return ret;
+                }
+
+                context->audio_stream_context.enc_ctx = enc_ctx;
+            }
+        }
+
+        if (context->videoStreamIndex == i) {
+            encoder = avcodec_find_encoder(AV_CODEC_ID_H264);
+            if (!encoder) {
+                LOGE("Necessary encoder not found %d\n");
+                return AVERROR_INVALIDDATA;
+            }
+            context->video_enc_ctx = avcodec_alloc_context3(encoder);
+
+            context->video_enc_ctx->height = context->videoConfig.height;
+            context->video_enc_ctx->width = context->videoConfig.width;
+            context->video_enc_ctx->pix_fmt = AV_PIX_FMT_YUV420P;
+
+            context->pts_scale =
+                    context->videoConfig.frame_rate /
+                    av_q2d(context->ifmt_ctx->streams[i]->avg_frame_rate);
+            context->video_enc_ctx->time_base = (AVRational) {
+                    1,
+                    context->videoConfig.frame_rate
+            };
+            context->video_enc_ctx->bit_rate = context->videoConfig.bitrate;
+
+            context->video_enc_ctx->flags |= AV_CODEC_FLAG_GLOBAL_HEADER;
+            context->video_frame = av_frame_alloc();
+            context->video_frame->format = AV_PIX_FMT_YUV420P;
+            context->video_frame->width = context->video_enc_ctx->width;
+            context->video_frame->height = context->video_enc_ctx->height;
+            av_frame_get_buffer(context->video_frame, 1);
+
+            AVDictionary *opt = NULL;
+            av_dict_set(&opt, "preset", "superfast", 0);
+            avcodec_open2(context->video_enc_ctx, encoder, &opt);
+            av_dict_free(&opt);
+
+
+            AVStream *out_stream = avformat_new_stream(context->ofmt_ctx, NULL);
+            ret = avcodec_parameters_from_context(out_stream->codecpar, context->video_enc_ctx);
+            if (ret < 0) {
+                av_log(NULL, AV_LOG_ERROR,
+                       "Failed to copy encoder parameters to output stream #%u\n", i);
+                return ret;
+            }
+
+            out_stream->time_base = context->video_enc_ctx->time_base;
+        }
+    }
+
+    if (!(context->ofmt_ctx->oformat->flags & AVFMT_NOFILE)) {
+        ret = avio_open(&context->ofmt_ctx->pb, filename, AVIO_FLAG_WRITE);
+        if (ret < 0) {
+            av_log(NULL, AV_LOG_ERROR, "Could not open output file '%s'", filename);
+            return ret;
+        }
+    }
+
+    avformat_write_header(context->ofmt_ctx, NULL);
+
+    return 0;
+}
+
+int encode_write_frame(AVFrame *frame, struct Context *context, StreamContext *streamContext,
+                       int *got_frame) {
+    int ret;
+    int got_frame_local;
+    AVPacket enc_pkt;
+    int (*enc_func)(AVCodecContext *, AVPacket *, const AVFrame *, int *) =
+    (streamContext->enc_ctx->codec_type == AVMEDIA_TYPE_VIDEO) ? avcodec_encode_video2
+                                                               : avcodec_encode_audio2;
+
+    if (!got_frame) got_frame = &got_frame_local;
+
+    enc_pkt.data = NULL;
+    enc_pkt.size = 0;
+    av_init_packet(&enc_pkt);
+    ret = enc_func(streamContext->enc_ctx, &enc_pkt,
+                   frame, got_frame);
+    av_frame_free(&frame);
+    if (ret < 0)
+        return ret;
+    if (!(*got_frame))
+        return 0;
+
+
+    enc_pkt.stream_index = streamContext->streamIndex;
+
+    av_packet_rescale_ts(&enc_pkt,
+                         streamContext->enc_ctx->time_base,
+                         context->ifmt_ctx->streams[context->audioStreamIndex]->time_base);
+
+    if (context->videoConfig.start_time > 0) {
+        enc_pkt.pts -= streamContext->pts_start_from;
+        if (enc_pkt.pts < 0) {
+            streamContext->pts_start_from += enc_pkt.pts;
+            enc_pkt.pts = 0;
+        }
+        enc_pkt.dts -= streamContext->pts_start_from;
+    }
+
+    ret = av_interleaved_write_frame(context->ofmt_ctx, &enc_pkt);
+    av_packet_unref(&enc_pkt);
+    return ret;
+}
+
+int
+process_encode_write_frame(AVFrame *frame, struct Context *context, StreamContext *streamContext) {
+    int ret;
+
+    if (ret < 0) {
+        if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)
+            av_frame_free(&frame);
+    }
+
+    ret = encode_write_frame(frame, context, streamContext, NULL);
+    av_frame_free(&frame);
+    return ret;
+}
+
+int flush_encoder(struct Context *context, StreamContext *streamContext) {
+    int ret;
+    int got_frame;
+    if (!(streamContext->enc_ctx->codec->capabilities & AV_CODEC_CAP_DELAY))
+        return 0;
+
+    while (1) {
+        ret = encode_write_frame(NULL, context, streamContext, &got_frame);
+        if (ret < 0)
+            break;
+        if (!got_frame)
+            return 0;
+    }
+    return ret;
+}
+
+
+int compress_video(const char *src_in, const char *src_out, struct Context *context, JNIEnv *env,
+                   jobject convertorObject) {
+
+    jclass jclass_FfmpegVideoConvertor = (*env)->GetObjectClass(env, convertorObject);
+    jmethodID checkConversionCanceled = (*env)->GetMethodID(env, jclass_FfmpegVideoConvertor,
+                                                            "checkConversionCanceled", "()Z");
+
+    jmethodID updateProgress = (*env)->GetMethodID(env, jclass_FfmpegVideoConvertor,
+                                                   "updateProgress", "(F)V");
+
+
+    jmethodID pullDecoder = (*env)->GetMethodID(env, jclass_FfmpegVideoConvertor,
+                                                "pullDecoder", "()Ljava/nio/ByteBuffer;");
+
+
+    int ret;
+    AVPacket packet = {.data = NULL, .size = 0};
+    AVFrame *frame = NULL;
+
+    int stream_index;
+    int got_frame;
+
+    context->audioStreamIndex = -1;
+    context->videoStreamIndex = -1;
+
+    if ((ret = open_input_file(src_in, context) < 0))
+        goto end;
+
+    if ((ret = open_output_file(src_out, context)) < 0)
+        goto end;
+
+    if (context->videoConfig.start_time > 0) {
+        context->audio_stream_context.pts_start_from = -1;
+        av_seek_frame(context->ifmt_ctx, -1,
+                      (int64_t) (context->videoConfig.start_time * AV_TIME_BASE),
+                      AVSEEK_FLAG_BACKWARD);
+    }
+
+
+//    float duration_sec;
+//    float pts2sec = (float) av_q2d(context->video_enc_ctx->time_base);
+//
+//    if (context->videoConfig.end_time > 0) {
+//        duration_sec = context->videoConfig.end_time - context->videoConfig.start_time;
+//    } else {
+//        duration_sec = (float) (av_q2d(context->ifmt_ctx->streams[0]->time_base) *
+//                                context->ifmt_ctx->streams[0]->duration) - context->videoConfig.start_time;
+//    }
+
+
+    /* read audio stream packets */
+    int video_stream_end = 0;
+    int audio_stream_end = 0;
+    int decoded_frame_count = 0;
+    int encoded_frame_count = 0;
+
+    int64_t last_pts = -1;
+
+    int cycle_count = 0;
+    while (1) {
+        if (cycle_count % 20 == 0) {
+            if ((*env)->CallBooleanMethod(env, convertorObject, checkConversionCanceled)) {
+                ret = -1;
+                break;
+            }
+        }
+        cycle_count++;
+        if ((context->videoStreamIndex < 0 || video_stream_end) &&
+            (context->audioStreamIndex < 0 || audio_stream_end))
+            break;
+
+        while (context->videoStreamIndex >= 0 && !video_stream_end) {
+            jobject decoded_data = (*env)->CallObjectMethod(env, convertorObject, pullDecoder);
+            if (decoded_data != NULL) {
+                uint8_t *dataBuf = (uint8_t *) (*env)->GetDirectBufferAddress(env, decoded_data);
+                jlong dataBufSize = (*env)->GetDirectBufferCapacity(env, decoded_data);
+
+                if (dataBufSize == 3 && dataBuf[0] == 0x00 && dataBuf[1] == 0x00 &&
+                    dataBuf[2] == 0x08) {
+                    video_stream_end = 1;
+                    break;
+                }
+
+                AVPacket enc_pkt;
+                av_init_packet(&enc_pkt);
+                enc_pkt.data = NULL;
+                enc_pkt.size = 0;
+                enc_pkt.stream_index = context->videoStreamIndex;
+                context->video_frame->pts = (int64_t) (decoded_frame_count * context->pts_scale);
+                decoded_frame_count++;
+                if (context->video_frame->pts <= last_pts) {
+                    break;
+                }
+
+                last_pts = context->video_frame->pts;
+
+
+                int y_count = 0;
+                int c_count = 0;
+
+                for (int y = 0; y < context->video_frame->height; y++) {
+                    int k = y * context->video_frame->width;
+                    for (int x = 0; x < context->video_frame->width; x++) {
+
+                        context->video_frame->data[0][y_count] = dataBuf[(k + x) * 4];
+                        y_count++;
+
+
+                        if (y % 2 == 0 && x % 2 == 0) {
+                            context->video_frame->data[1][c_count] = dataBuf[(k + x) * 4 + 1];
+                            context->video_frame->data[2][c_count] = dataBuf[(k + x) * 4 + 2];
+                            c_count++;
+                        }
+                    }
+                }
+
+
+                avcodec_encode_video2(context->video_enc_ctx, &enc_pkt, context->video_frame,
+                                      &got_frame);
+
+                if (got_frame) {
+                    encoded_frame_count++;
+                    if (encoded_frame_count % 20 == 0) {
+                        // float progress =(enc_pkt.pts * pts2sec - context->videoConfig.start_time) /duration_sec;
+                        (*env)->CallVoidMethod(env, convertorObject, updateProgress, 0.0);
+                    }
+
+                    av_packet_rescale_ts(&enc_pkt,
+                                         context->video_enc_ctx->time_base,
+                                         context->ofmt_ctx->streams[context->videoStreamIndex]->time_base);
+                    enc_pkt.stream_index = context->videoStreamIndex;
+
+                    av_interleaved_write_frame(context->ofmt_ctx, &enc_pkt);
+                }
+
+                av_packet_unref(&enc_pkt);
+            }
+            break;
+        }
+
+        if (context->audioStreamIndex < 0 || audio_stream_end) continue;
+        if ((ret = av_read_frame(context->ifmt_ctx, &packet)) < 0) {
+            if (ret == AVERROR_EOF) ret = 0;
+            audio_stream_end = 1;
+            continue;
+        }
+
+        stream_index = packet.stream_index;
+
+        if (stream_index == context->audioStreamIndex) {
+            if (context->audio_stream_context.enc_ctx == NULL) {
+                double if_time_s = av_q2d(context->ifmt_ctx->streams[stream_index]->time_base);
+                if (context->videoConfig.start_time > 0 &&
+                    if_time_s * packet.pts <
+                    context->videoConfig.start_time) {
+                    continue;
+                }
+
+                if (context->videoConfig.end_time > 0 &&
+                    if_time_s * packet.pts >
+                    context->videoConfig.end_time) {
+                    audio_stream_end = 1;
+                    continue;
+                }
+
+
+                if (context->videoConfig.start_time > 0) {
+                    if (context->audio_stream_context.pts_start_from == -1) {
+                        context->audio_stream_context.pts_start_from = av_rescale_q_rnd(
+                                packet.pts,
+                                context->ifmt_ctx->streams[stream_index]->time_base,
+                                context->ifmt_ctx->streams[stream_index]->time_base,
+                                AV_ROUND_NEAR_INF |
+                                AV_ROUND_PASS_MINMAX);
+                    }
+                }
+
+                av_packet_rescale_ts(&packet,
+                                     context->ifmt_ctx->streams[stream_index]->time_base,
+                                     context->ifmt_ctx->streams[stream_index]->time_base);
+
+                if (context->videoConfig.start_time > 0) {
+                    packet.pts -= context->audio_stream_context.pts_start_from;
+                    if (packet.pts < 0) {
+                        context->audio_stream_context.pts_start_from += packet.pts;
+                        packet.pts = 0;
+                    }
+                    packet.dts -= context->audio_stream_context.pts_start_from;
+                }
+                av_interleaved_write_frame(context->ofmt_ctx, &packet);
+                continue;
+            } else {
+                frame = av_frame_alloc();
+                if (!frame) {
+                    ret = AVERROR(ENOMEM);
+                    break;
+                }
+                av_packet_rescale_ts(&packet,
+                                     context->ifmt_ctx->streams[stream_index]->time_base,
+                                     context->audio_stream_context.dec_ctx->time_base);
+
+
+                ret = avcodec_decode_audio4(context->audio_stream_context.dec_ctx, frame,
+                                            &got_frame, &packet);
+                if (ret < 0) {
+                    av_frame_free(&frame);
+                    LOGE("Decoding failed\n");
+                    break;
+                }
+
+                if (got_frame) {
+                    double decoder_time_s = av_q2d(
+                            context->audio_stream_context.dec_ctx->time_base);
+
+                    if (context->videoConfig.start_time > 0 &&
+                        decoder_time_s * packet.pts <
+                        context->videoConfig.start_time) {
+                        continue;
+                    }
+                    if (context->videoConfig.end_time > 0 &&
+                        decoder_time_s * packet.pts >
+                        context->videoConfig.end_time) {
+                        audio_stream_end = 1;
+                        continue;
+                    }
+
+                    if (context->videoConfig.start_time > 0) {
+                        if (context->audio_stream_context.pts_start_from == -1) {
+                            context->audio_stream_context.pts_start_from = av_rescale_q_rnd(
+                                    packet.pts,
+                                    context->audio_stream_context.dec_ctx->time_base,
+                                    context->ifmt_ctx->streams[stream_index]->time_base,
+                                    AV_ROUND_NEAR_INF |
+                                    AV_ROUND_PASS_MINMAX);
+                        }
+                    }
+
+                    ret = process_encode_write_frame(frame, context,
+                                                     &context->audio_stream_context);
+                    av_frame_free(&frame);
+                    if (ret < 0)
+                        goto end;
+                }
+            }
+        }
+
+        av_packet_unref(&packet);
+    }
+
+    if (context->audio_stream_context.enc_ctx != NULL) {
+        ret = flush_encoder(context, &context->audio_stream_context);
+        if (ret < 0) {
+            LOGE("Flushing encoder failed\n");
+            goto end;
+        }
+    }
+
+    got_frame = 1;
+    while (got_frame) {
+        AVPacket enc_pkt;
+        av_init_packet(&enc_pkt);
+        enc_pkt.data = NULL;
+        enc_pkt.size = 0;
+        enc_pkt.stream_index = context->videoStreamIndex;
+        avcodec_encode_video2(context->video_enc_ctx, &enc_pkt, NULL, &got_frame);
+
+        if (got_frame) {
+            encoded_frame_count++;
+            if (encoded_frame_count % 20 == 0) {
+                //     float progress =(enc_pkt.pts * pts2sec - context->videoConfig.start_time) / duration_sec;
+                (*env)->CallVoidMethod(env, convertorObject, updateProgress, 0.0);
+            }
+
+            av_packet_rescale_ts(&enc_pkt,
+                                 context->video_enc_ctx->time_base,
+                                 context->ofmt_ctx->streams[context->videoStreamIndex]->time_base);
+
+            av_interleaved_write_frame(context->ofmt_ctx, &enc_pkt);
+        }
+
+        av_packet_unref(&enc_pkt);
+    }
+
+
+    av_write_trailer(context->ofmt_ctx);
+    end:
+
+    av_frame_free(&frame);
+    av_frame_free(&context->video_frame);
+    av_packet_unref(&packet);
+
+    if (context->audioStreamIndex >= 0 && context->audio_stream_context.dec_ctx != NULL) {
+        avcodec_free_context(&context->audio_stream_context.enc_ctx);
+        avcodec_free_context(&context->audio_stream_context.dec_ctx);
+    }
+
+    if (context->videoStreamIndex >= 0) {
+        avcodec_free_context(&context->video_enc_ctx);
+    }
+
+    avformat_free_context(context->ofmt_ctx);
+    avformat_close_input(&context->ifmt_ctx);
+
+
+    if (ret < 0) LOGE("Error occurred: %s\n", av_err2str(ret));
+    return ret;
+}
+
+JNIEXPORT jint
+Java_org_telegram_messenger_Utilities_compressVideo(JNIEnv *env, jclass class,
+                                                    jobject convertor,
+                                                    jstring src_path, jstring out_path,
+                                                    jint width, jint height,
+                                                    jint frame_rate, jint bitrate,
+                                                    jfloat startTime, jfloat endTime) {
+
+    struct Context *context = malloc(sizeof(struct Context));
+
+    context->ifmt_ctx = NULL;
+    context->video_frame = NULL;
+    context->video_enc_ctx = NULL;
+    context->audio_stream_context.dec_ctx = NULL;
+    context->audio_stream_context.enc_ctx = NULL;
+
+    context->videoConfig.bitrate = bitrate;
+    context->videoConfig.frame_rate = frame_rate;
+    context->videoConfig.width = width;
+    context->videoConfig.height = height;
+    context->videoConfig.start_time = (float) startTime;
+    context->videoConfig.end_time = (float) endTime;
+
+    if (context->videoConfig.start_time < 0) context->videoConfig.start_time = 0;
+
+    int r = compress_video(
+            (*env)->GetStringUTFChars(env, src_path, 0),
+            (*env)->GetStringUTFChars(env, out_path, 0),
+            context,
+            env, convertor);
+
+    realloc(context, sizeof(struct Context));
+    return r;
+}
+
diff --git a/TMessagesProj/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java b/TMessagesProj/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
index 7e8ecfddc..a4c86214c 100755
--- a/TMessagesProj/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
+++ b/TMessagesProj/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
@@ -30,7 +30,7 @@
   public static final String BASE_TYPE_TEXT = "text";
   public static final String BASE_TYPE_APPLICATION = "application";
 
-  public static final String VIDEO_MP4 = BASE_TYPE_VIDEO + "/mp4";
+  public static final String VIDEO_MP4 = BASE_TYPE_VIDEO + "/mp4muxer";
   public static final String VIDEO_WEBM = BASE_TYPE_VIDEO + "/webm";
   public static final String VIDEO_H263 = BASE_TYPE_VIDEO + "/3gpp";
   public static final String VIDEO_H264 = BASE_TYPE_VIDEO + "/avc";
@@ -43,7 +43,7 @@
   public static final String VIDEO_VC1 = BASE_TYPE_VIDEO + "/wvc1";
   public static final String VIDEO_UNKNOWN = BASE_TYPE_VIDEO + "/x-unknown";
 
-  public static final String AUDIO_MP4 = BASE_TYPE_AUDIO + "/mp4";
+  public static final String AUDIO_MP4 = BASE_TYPE_AUDIO + "/mp4muxer";
   public static final String AUDIO_AAC = BASE_TYPE_AUDIO + "/mp4a-latm";
   public static final String AUDIO_WEBM = BASE_TYPE_AUDIO + "/webm";
   public static final String AUDIO_MPEG = BASE_TYPE_AUDIO + "/mpeg";
@@ -71,7 +71,7 @@
   public static final String TEXT_VTT = BASE_TYPE_TEXT + "/vtt";
   public static final String TEXT_SSA = BASE_TYPE_TEXT + "/x-ssa";
 
-  public static final String APPLICATION_MP4 = BASE_TYPE_APPLICATION + "/mp4";
+  public static final String APPLICATION_MP4 = BASE_TYPE_APPLICATION + "/mp4muxer";
   public static final String APPLICATION_WEBM = BASE_TYPE_APPLICATION + "/webm";
   public static final String APPLICATION_MPD = BASE_TYPE_APPLICATION + "/dash+xml";
   public static final String APPLICATION_M3U8 = BASE_TYPE_APPLICATION + "/x-mpegURL";
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/AudioTranscoder.java b/TMessagesProj/src/main/java/org/telegram/messenger/AudioTranscoder.java
index b56594ea6..e6d5e8ee8 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/AudioTranscoder.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/AudioTranscoder.java
@@ -102,11 +102,12 @@ public boolean step(MP4Builder muxer, int audioTrackIndex) throws Exception {
 
             extractorDone = !extractor.advance();
             if (extractorDone) {
+                decoderInputBufferIndex = decoder.dequeueInputBuffer(TIMEOUT_USEC);
                 decoder.queueInputBuffer(
                         decoderInputBufferIndex,
                         0,
                         0,
-                        0,
+                        0L,
                         MediaCodec.BUFFER_FLAG_END_OF_STREAM);
             }
             break;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/FileLoader.java b/TMessagesProj/src/main/java/org/telegram/messenger/FileLoader.java
index b9acfae16..7319ed2bf 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/FileLoader.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/FileLoader.java
@@ -195,7 +195,7 @@ public void cancelUploadFile(final String location, final boolean enc) {
         });
     }
 
-    public void checkUploadNewDataAvailable(final String location, final boolean encrypted, final long newAvailableSize, final long finalSize) {
+    public void  checkUploadNewDataAvailable(final String location, final boolean encrypted, final long newAvailableSize, final long finalSize) {
         fileLoaderQueue.postRunnable(() -> {
             FileUploadOperation operation;
             if (encrypted) {
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/ImageLoader.java b/TMessagesProj/src/main/java/org/telegram/messenger/ImageLoader.java
index 8d5c214a3..71865b525 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/ImageLoader.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/ImageLoader.java
@@ -663,7 +663,7 @@ public void run() {
                     originalBitmap = ThumbnailUtils.createVideoThumbnail(originalPath.toString(), info.big ? MediaStore.Video.Thumbnails.FULL_SCREEN_KIND : MediaStore.Video.Thumbnails.MINI_KIND);
                 } else if (mediaType == FileLoader.MEDIA_DIR_DOCUMENT) {
                     String path = originalPath.toString().toLowerCase();
-                    if (path.endsWith("mp4")) {
+                    if (path.endsWith("mp4muxer")) {
                         originalBitmap = ThumbnailUtils.createVideoThumbnail(originalPath.toString(), info.big ? MediaStore.Video.Thumbnails.FULL_SCREEN_KIND : MediaStore.Video.Thumbnails.MINI_KIND);
                     } else if (path.endsWith(".jpg") || path.endsWith(".jpeg") || path.endsWith(".png") || path.endsWith(".gif")) {
                         originalBitmap = ImageLoader.loadBitmap(path, null, size, size, false);
@@ -2242,7 +2242,7 @@ private void createLoadOperationForImageReceiver(final ImageReceiver imageReceiv
                             String location = imageLocation.path;
                             if (!location.startsWith("vthumb") && !location.startsWith("thumb")) {
                                 String trueExt = getHttpUrlExtension(location, "jpg");
-                                if (trueExt.equals("mp4") || trueExt.equals("gif")) {
+                                if (trueExt.equals("mp4muxer") || trueExt.equals("gif")) {
                                     img.animatedFile = true;
                                 }
                             }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/MediaController.java b/TMessagesProj/src/main/java/org/telegram/messenger/MediaController.java
index 7a2d9187a..dc9cc9cf6 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/MediaController.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/MediaController.java
@@ -55,10 +55,13 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ui.AspectRatioFrameLayout;
+import com.google.android.exoplayer2.util.Log;
 
 import org.telegram.messenger.audioinfo.AudioInfo;
+import org.telegram.messenger.video.FfmpegVideoConvertor;
 import org.telegram.messenger.video.InputSurface;
 import org.telegram.messenger.video.MP4Builder;
+import org.telegram.messenger.video.MediaCodecVideoConvertor;
 import org.telegram.messenger.video.Mp4Movie;
 import org.telegram.messenger.video.OutputSurface;
 import org.telegram.messenger.voip.VoIPService;
@@ -76,6 +79,7 @@
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
+import java.io.IOException;
 import java.io.InputStream;
 import java.net.URLEncoder;
 import java.nio.ByteBuffer;
@@ -88,6 +92,8 @@
 import java.util.Timer;
 import java.util.TimerTask;
 
+import static android.media.MediaFormat.MIMETYPE_AUDIO_AAC;
+
 public class MediaController implements AudioManager.OnAudioFocusChangeListener, NotificationCenter.NotificationCenterDelegate, SensorEventListener {
 
     private native int startRecord(String path);
@@ -297,13 +303,8 @@ public String getPathToAttach() {
     }
 
     public final static String VIDEO_MIME_TYPE = "video/avc";
-    public final static String AUDIO_MIME_TYPE = "audio/mp4a-latm";
-    private final static int PROCESSOR_TYPE_OTHER = 0;
-    private final static int PROCESSOR_TYPE_QCOM = 1;
-    private final static int PROCESSOR_TYPE_INTEL = 2;
-    private final static int PROCESSOR_TYPE_MTK = 3;
-    private final static int PROCESSOR_TYPE_SEC = 4;
-    private final static int PROCESSOR_TYPE_TI = 5;
+    public final static String AUIDO_MIME_TYPE = "audio/mp4a-latm";
+
     private final Object videoConvertSync = new Object();
 
     private SensorManager sensorManager;
@@ -346,13 +347,8 @@ public String getPathToAttach() {
     private static final int AUDIO_NO_FOCUS_CAN_DUCK = 1;
     private static final int AUDIO_FOCUSED = 2;
 
-    private static final int MEDIACODEC_TIMEOUT_DEFAULT = 2500;
-    private static final int MEDIACODEC_TIMEOUT_INCREASED = 22000;
-
     private ArrayList<MessageObject> videoConvertQueue = new ArrayList<>();
     private final Object videoQueueSync = new Object();
-    private boolean cancelCurrentVideoConversion = false;
-    private boolean videoConvertFirstWrite = true;
     private HashMap<String, MessageObject> generatingWaveform = new HashMap<>();
 
     private boolean voiceMessagesPlaylistUnread;
@@ -569,7 +565,6 @@ public void onChange(boolean selfChange) {
     }
 
 
-
     private class GalleryObserverExternal extends ContentObserver {
         public GalleryObserverExternal() {
             super(null);
@@ -2249,7 +2244,6 @@ public void onSurfaceTextureUpdated(SurfaceTexture surfaceTexture) {
         }
 
 
-
         checkAudioFocus(messageObject);
         setPlayerVolume();
 
@@ -3450,18 +3444,14 @@ public boolean scheduleVideoConvert(MessageObject messageObject, boolean isEmpty
     }
 
     public void cancelVideoConvert(MessageObject messageObject) {
-        if (messageObject == null) {
-            synchronized (videoConvertSync) {
-                cancelCurrentVideoConversion = true;
-            }
-        } else {
+        if (messageObject != null) {
             if (!videoConvertQueue.isEmpty()) {
                 for (int a = 0; a < videoConvertQueue.size(); a++) {
                     MessageObject object = videoConvertQueue.get(a);
                     if (object.getId() == messageObject.getId() && object.currentAccount == messageObject.currentAccount) {
                         if (a == 0) {
                             synchronized (videoConvertSync) {
-                                cancelCurrentVideoConversion = true;
+                                messageObject.videoEditedInfo.canceled = true;
                             }
                         } else {
                             videoConvertQueue.remove(a);
@@ -3475,10 +3465,10 @@ public void cancelVideoConvert(MessageObject messageObject) {
 
     private boolean startVideoConvertFromQueue() {
         if (!videoConvertQueue.isEmpty()) {
+            MessageObject messageObject = videoConvertQueue.get(0);
             synchronized (videoConvertSync) {
-                cancelCurrentVideoConversion = false;
+                messageObject.videoEditedInfo.canceled = false;
             }
-            MessageObject messageObject = videoConvertQueue.get(0);
             Intent intent = new Intent(ApplicationLoader.applicationContext, VideoEncodingService.class);
             intent.putExtra("path", messageObject.messageOwner.attachPath);
             intent.putExtra("currentAccount", messageObject.currentAccount);
@@ -3560,7 +3550,7 @@ public static int selectColorFormat(MediaCodecInfo codecInfo, String mimeType) {
         return lastColorFormat;
     }
 
-    private int findTrack(MediaExtractor extractor, boolean audio) {
+    public static int findTrack(MediaExtractor extractor, boolean audio) {
         int numTracks = extractor.getTrackCount();
         for (int i = 0; i < numTracks; i++) {
             MediaFormat format = extractor.getTrackFormat(i);
@@ -3579,14 +3569,14 @@ private int findTrack(MediaExtractor extractor, boolean audio) {
     }
 
     private void didWriteData(final MessageObject messageObject, final File file, final boolean last, long availableSize, final boolean error) {
-        final boolean firstWrite = videoConvertFirstWrite;
+        final boolean firstWrite = messageObject.videoEditedInfo.videoConvertFirstWrite;
         if (firstWrite) {
-            videoConvertFirstWrite = false;
+            messageObject.videoEditedInfo.videoConvertFirstWrite = false;
         }
         AndroidUtilities.runOnUIThread(() -> {
             if (error || last) {
                 synchronized (videoConvertSync) {
-                    cancelCurrentVideoConversion = false;
+                    messageObject.videoEditedInfo.canceled = false;
                 }
                 videoConvertQueue.remove(messageObject);
                 startVideoConvertFromQueue();
@@ -3602,124 +3592,6 @@ private void didWriteData(final MessageObject messageObject, final File file, fi
         });
     }
 
-    private long readAndWriteTracks(final MessageObject messageObject, MediaExtractor extractor, MP4Builder mediaMuxer, MediaCodec.BufferInfo info, long start, long end, File file, boolean needAudio) throws Exception {
-        int videoTrackIndex = findTrack(extractor, false);
-        int audioTrackIndex = needAudio ? findTrack(extractor, true) : -1;
-        int muxerVideoTrackIndex = -1;
-        int muxerAudioTrackIndex = -1;
-        boolean inputDone = false;
-        int maxBufferSize = 0;
-        if (videoTrackIndex >= 0) {
-            extractor.selectTrack(videoTrackIndex);
-            MediaFormat trackFormat = extractor.getTrackFormat(videoTrackIndex);
-            muxerVideoTrackIndex = mediaMuxer.addTrack(trackFormat, false);
-            maxBufferSize = trackFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE);
-            if (start > 0) {
-                extractor.seekTo(start, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
-            } else {
-                extractor.seekTo(0, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
-            }
-        }
-        if (audioTrackIndex >= 0) {
-            extractor.selectTrack(audioTrackIndex);
-            MediaFormat trackFormat = extractor.getTrackFormat(audioTrackIndex);
-            muxerAudioTrackIndex = mediaMuxer.addTrack(trackFormat, true);
-            maxBufferSize = Math.max(trackFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE), maxBufferSize);
-            if (start > 0) {
-                extractor.seekTo(start, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
-            } else {
-                extractor.seekTo(0, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
-            }
-        }
-        ByteBuffer buffer = ByteBuffer.allocateDirect(maxBufferSize);
-        if (audioTrackIndex >= 0 || videoTrackIndex >= 0) {
-            long startTime = -1;
-            checkConversionCanceled();
-            while (!inputDone) {
-                checkConversionCanceled();
-                boolean eof = false;
-                int muxerTrackIndex;
-                info.size = extractor.readSampleData(buffer, 0);
-                int index = extractor.getSampleTrackIndex();
-                if (index == videoTrackIndex) {
-                    muxerTrackIndex = muxerVideoTrackIndex;
-                } else if (index == audioTrackIndex) {
-                    muxerTrackIndex = muxerAudioTrackIndex;
-                } else {
-                    muxerTrackIndex = -1;
-                }
-                if (muxerTrackIndex != -1) {
-                    if (Build.VERSION.SDK_INT < 21) {
-                        buffer.position(0);
-                        buffer.limit(info.size);
-                    }
-                    if (index != audioTrackIndex) {
-                        byte[] array = buffer.array();
-                        if (array != null) {
-                            int offset = buffer.arrayOffset();
-                            int len = offset + buffer.limit();
-                            int writeStart = -1;
-                            for (int a = offset; a <= len - 4; a++) {
-                                if (array[a] == 0 && array[a + 1] == 0 && array[a + 2] == 0 && array[a + 3] == 1 || a == len - 4) {
-                                    if (writeStart != -1) {
-                                        int l = a - writeStart - (a != len - 4 ? 4 : 0);
-                                        array[writeStart] = (byte) (l >> 24);
-                                        array[writeStart + 1] = (byte) (l >> 16);
-                                        array[writeStart + 2] = (byte) (l >> 8);
-                                        array[writeStart + 3] = (byte) l;
-                                        writeStart = a;
-                                    } else {
-                                        writeStart = a;
-                                    }
-                                }
-                            }
-                        }
-                    }
-                    if (info.size >= 0) {
-                        info.presentationTimeUs = extractor.getSampleTime();
-                    } else {
-                        info.size = 0;
-                        eof = true;
-                    }
-
-                    if (info.size > 0 && !eof) {
-                        if (index == videoTrackIndex && start > 0 && startTime == -1) {
-                            startTime = info.presentationTimeUs;
-                        }
-                        if (end < 0 || info.presentationTimeUs < end) {
-                            info.offset = 0;
-                            info.flags = extractor.getSampleFlags();
-                            long availableSize = mediaMuxer.writeSampleData(muxerTrackIndex, buffer, info, false);
-                            if (availableSize != 0) {
-                                didWriteData(messageObject, file, false, availableSize, false);
-                            }
-                        } else {
-                            eof = true;
-                        }
-                    }
-                    if (!eof) {
-                        extractor.advance();
-                    }
-                } else if (index == -1) {
-                    eof = true;
-                } else {
-                    extractor.advance();
-                }
-                if (eof) {
-                    inputDone = true;
-                }
-            }
-            if (videoTrackIndex >= 0) {
-                extractor.unselectTrack(videoTrackIndex);
-            }
-            if (audioTrackIndex >= 0) {
-                extractor.unselectTrack(audioTrackIndex);
-            }
-            return startTime;
-        }
-        return -1;
-    }
-
     private static class VideoConvertRunnable implements Runnable {
 
         private MessageObject messageObject;
@@ -3747,18 +3619,8 @@ public static void runConversion(final MessageObject obj) {
         }
     }
 
-    private void checkConversionCanceled() {
-        boolean cancelConversion;
-        synchronized (videoConvertSync) {
-            cancelConversion = cancelCurrentVideoConversion;
-        }
-        if (cancelConversion) {
-            throw new RuntimeException("canceled conversion");
-        }
-    }
-
     private boolean convertVideo(MessageObject messageObject) {
-        return convertVideo(messageObject, MEDIACODEC_TIMEOUT_DEFAULT);
+        return convertVideo(messageObject, 2500);
     }
 
     private boolean convertVideo(final MessageObject messageObject, int timoutUsec) {
@@ -3775,581 +3637,152 @@ private boolean convertVideo(final MessageObject messageObject, int timoutUsec)
         int originalHeight = messageObject.videoEditedInfo.originalHeight;
         int framerate = messageObject.videoEditedInfo.framerate;
         int bitrate = messageObject.videoEditedInfo.bitrate;
+
+
         int rotateRender = 0;
         boolean isSecret = ((int) messageObject.getDialogId()) == 0;
-        File cacheFile = new File(messageObject.messageOwner.attachPath);
+        final File cacheFile = new File(messageObject.messageOwner.attachPath);
         if (videoPath == null) {
             videoPath = "";
         }
 
+        long duration;
+        if (startTime > 0 && endTime > 0) {
+            duration = endTime - startTime;
+        } else if (endTime > 0) {
+            duration = endTime;
+        } else if (startTime > 0) {
+            duration = messageObject.videoEditedInfo.originalDuration - startTime;
+        } else {
+            duration = messageObject.videoEditedInfo.originalDuration;
+        }
+
+
         if (framerate == 0) {
             framerate = 25;
         } else if (framerate > 59) {
             framerate = 59;
         }
 
-        if(bitrate <= 0) bitrate = 921600;
+        if (bitrate <= 0) bitrate = 921600;
 
-        if (Build.VERSION.SDK_INT < 18 && resultHeight > resultWidth && resultWidth != originalWidth && resultHeight != originalHeight) {
+        if (rotationValue == 90) {
             int temp = resultHeight;
             resultHeight = resultWidth;
             resultWidth = temp;
-            rotationValue = 90;
+            rotationValue = 0;
             rotateRender = 270;
-        } else if (Build.VERSION.SDK_INT > 20) {
-            if (rotationValue == 90) {
-                int temp = resultHeight;
-                resultHeight = resultWidth;
-                resultWidth = temp;
-                rotationValue = 0;
-                rotateRender = 270;
-            } else if (rotationValue == 180) {
-                rotateRender = 180;
-                rotationValue = 0;
-            } else if (rotationValue == 270) {
-                int temp = resultHeight;
-                resultHeight = resultWidth;
-                resultWidth = temp;
-                rotationValue = 0;
-                rotateRender = 90;
-            }
-        }
-
-        SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("videoconvert", Activity.MODE_PRIVATE);
-        File inputFile = new File(videoPath);
-
-        if (messageObject.getId() != 0 && timoutUsec == MEDIACODEC_TIMEOUT_DEFAULT) {
-            boolean isPreviousOk = preferences.getBoolean("isPreviousOk", true);
-            preferences.edit().putBoolean("isPreviousOk", false).commit();
-            if (!inputFile.canRead() || !isPreviousOk) {
-                didWriteData(messageObject, cacheFile, true, 0, true);
-                preferences.edit().putBoolean("isPreviousOk", true).commit();
-                return false;
-            }
+        } else if (rotationValue == 180) {
+            rotateRender = 180;
+            rotationValue = 0;
+        } else if (rotationValue == 270) {
+            int temp = resultHeight;
+            resultHeight = resultWidth;
+            resultWidth = temp;
+            rotationValue = 0;
+            rotateRender = 90;
         }
 
-        videoConvertFirstWrite = true;
-        boolean error = false;
-
-        long time = System.currentTimeMillis();
-
-        if (resultWidth != 0 && resultHeight != 0) {
-            MP4Builder mediaMuxer = null;
-            MediaExtractor extractor = null;
+        boolean needCompress = resultWidth != originalWidth || resultHeight != originalHeight || rotateRender != 0
+                || messageObject.videoEditedInfo.roundVideo || Build.VERSION.SDK_INT >= 18 && startTime != -1;
 
-            boolean repeatWithIncreasedTimeout = false;
 
-            try {
-                MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();
-                Mp4Movie movie = new Mp4Movie();
-                movie.setCacheFile(cacheFile);
-                movie.setRotation(rotationValue);
-                movie.setSize(resultWidth, resultHeight);
-                mediaMuxer = new MP4Builder().createMovie(movie, isSecret);
-                extractor = new MediaExtractor();
-                extractor.setDataSource(videoPath);
-
-                checkConversionCanceled();
-
-                if (resultWidth != originalWidth || resultHeight != originalHeight || rotateRender != 0 || messageObject.videoEditedInfo.roundVideo || Build.VERSION.SDK_INT >= 18 && startTime != -1) {
-                    int videoIndex = findTrack(extractor, false);
-                    int audioIndex = bitrate != -1 ? findTrack(extractor, true) : -1;
-
-                    AudioTranscoder audioTranscoder = null;
-                    ByteBuffer audioBuffer = null;
-                    boolean copyAudioBuffer = true;
-
-                    if (videoIndex >= 0) {
-                        MediaCodec decoder = null;
-                        MediaCodec encoder = null;
-                        InputSurface inputSurface = null;
-                        OutputSurface outputSurface = null;
-
-                        try {
-                            long videoTime = -1;
-                            boolean outputDone = false;
-                            boolean inputDone = false;
-                            boolean decoderDone = false;
-                            int swapUV = 0;
-                            int videoTrackIndex = -5;
-                            int audioTrackIndex = -5;
-
-                            int colorFormat;
-                            int processorType = PROCESSOR_TYPE_OTHER;
-                            String manufacturer = Build.MANUFACTURER.toLowerCase();
-                            if (Build.VERSION.SDK_INT < 18) {
-                                MediaCodecInfo codecInfo = selectCodec(VIDEO_MIME_TYPE);
-                                colorFormat = selectColorFormat(codecInfo, VIDEO_MIME_TYPE);
-                                if (colorFormat == 0) {
-                                    throw new RuntimeException("no supported color format");
-                                }
-                                String codecName = codecInfo.getName();
-                                if (codecName.contains("OMX.qcom.")) {
-                                    processorType = PROCESSOR_TYPE_QCOM;
-                                    if (Build.VERSION.SDK_INT == 16) {
-                                        if (manufacturer.equals("lge") || manufacturer.equals("nokia")) {
-                                            swapUV = 1;
-                                        }
-                                    }
-                                } else if (codecName.contains("OMX.Intel.")) {
-                                    processorType = PROCESSOR_TYPE_INTEL;
-                                } else if (codecName.equals("OMX.MTK.VIDEO.ENCODER.AVC")) {
-                                    processorType = PROCESSOR_TYPE_MTK;
-                                } else if (codecName.equals("OMX.SEC.AVC.Encoder")) {
-                                    processorType = PROCESSOR_TYPE_SEC;
-                                    swapUV = 1;
-                                } else if (codecName.equals("OMX.TI.DUCATI1.VIDEO.H264E")) {
-                                    processorType = PROCESSOR_TYPE_TI;
-                                }
-                                if (BuildVars.LOGS_ENABLED) {
-                                    FileLog.d("codec = " + codecInfo.getName() + " manufacturer = " + manufacturer + "device = " + Build.MODEL);
-                                }
-                            } else {
-                                colorFormat = MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface;
-                            }
-                            if (BuildVars.LOGS_ENABLED) {
-                                FileLog.d("colorFormat = " + colorFormat);
-                            }
-
-                            int resultHeightAligned = resultHeight;
-                            int padding = 0;
-                            int bufferSize = resultWidth * resultHeight * 3 / 2;
-                            if (processorType == PROCESSOR_TYPE_OTHER) {
-                                if (resultHeight % 16 != 0) {
-                                    resultHeightAligned += (16 - (resultHeight % 16));
-                                    padding = resultWidth * (resultHeightAligned - resultHeight);
-                                    bufferSize += padding * 5 / 4;
-                                }
-                            } else if (processorType == PROCESSOR_TYPE_QCOM) {
-                                if (!manufacturer.toLowerCase().equals("lge")) {
-                                    int uvoffset = (resultWidth * resultHeight + 2047) & ~2047;
-                                    padding = uvoffset - (resultWidth * resultHeight);
-                                    bufferSize += padding;
-                                }
-                            } else if (processorType == PROCESSOR_TYPE_TI) {
-                                //resultHeightAligned = 368;
-                                //bufferSize = resultWidth * resultHeightAligned * 3 / 2;
-                                //resultHeightAligned += (16 - (resultHeight % 16));
-                                //padding = resultWidth * (resultHeightAligned - resultHeight);
-                                //bufferSize += padding * 5 / 4;
-                            } else if (processorType == PROCESSOR_TYPE_MTK) {
-                                if (manufacturer.equals("baidu")) {
-                                    resultHeightAligned += (16 - (resultHeight % 16));
-                                    padding = resultWidth * (resultHeightAligned - resultHeight);
-                                    bufferSize += padding * 5 / 4;
-                                }
-                            }
-
-                            extractor.selectTrack(videoIndex);
-                            MediaFormat videoFormat = extractor.getTrackFormat(videoIndex);
-
-                            if (startTime > 0) {
-                                extractor.seekTo(startTime, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
-                            } else {
-                                extractor.seekTo(0, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
-                            }
-
-                            MediaFormat outputFormat = MediaFormat.createVideoFormat(VIDEO_MIME_TYPE, resultWidth, resultHeight);
-                            outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, colorFormat);
-                            outputFormat.setInteger(MediaFormat.KEY_BIT_RATE, bitrate);
-                            outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE, framerate);
-                            outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 2);
-
-                            if (Build.VERSION.SDK_INT >= 23) {
-                                int profile;
-                                int level;
-
-                                if (Math.min(resultHeight, resultWidth) >= 1080) {
-                                    profile = MediaCodecInfo.CodecProfileLevel.AVCProfileHigh;
-                                    level = MediaCodecInfo.CodecProfileLevel.AVCLevel41;
-                                } else if (Math.min(resultHeight, resultWidth) >= 720) {
-                                    profile = MediaCodecInfo.CodecProfileLevel.AVCProfileHigh;
-                                    level = MediaCodecInfo.CodecProfileLevel.AVCLevel4;
-                                } else if (Math.min(resultHeight, resultWidth) >= 480) {
-                                    profile = MediaCodecInfo.CodecProfileLevel.AVCProfileBaseline;
-                                    level = MediaCodecInfo.CodecProfileLevel.AVCLevel31;
-                                } else {
-                                    profile = MediaCodecInfo.CodecProfileLevel.AVCProfileBaseline;
-                                    level = MediaCodecInfo.CodecProfileLevel.AVCLevel3;
-                                }
-
-                                MediaCodecInfo.CodecCapabilities capabilities = MediaCodecInfo.CodecCapabilities.createFromProfileLevel(VIDEO_MIME_TYPE, profile, level);
-
-                                if(capabilities == null && profile == MediaCodecInfo.CodecProfileLevel.AVCProfileHigh){
-                                    profile = MediaCodecInfo.CodecProfileLevel.AVCProfileBaseline;
-                                    capabilities = MediaCodecInfo.CodecCapabilities.createFromProfileLevel(VIDEO_MIME_TYPE, profile, level);
-                                }
-                                if (capabilities.getEncoderCapabilities() != null) {
-                                    outputFormat.setInteger(MediaFormat.KEY_PROFILE, profile);
-                                    outputFormat.setInteger(MediaFormat.KEY_LEVEL, level);
-
-                                    int maxBitrate = capabilities.getVideoCapabilities().getBitrateRange().getUpper();
-                                    if (bitrate > maxBitrate) {
-                                        bitrate = maxBitrate;
-                                        outputFormat.setInteger(MediaFormat.KEY_BIT_RATE, bitrate);
-                                    }
-
-                                    int maxFramerate = capabilities.getVideoCapabilities().getSupportedFrameRates().getUpper();
-                                    if (framerate > maxFramerate) {
-                                        framerate = maxFramerate;
-                                        outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE, framerate);
-                                    }
-                                }
-                            } else {
-                                if (Math.min(resultHeight, resultWidth) <= 480) {
-                                    if(bitrate < 921600)
-                                    bitrate = 921600;
-                                    outputFormat.setInteger(MediaFormat.KEY_BIT_RATE, bitrate);
-                                }
-                            }
-
-                            if (Build.VERSION.SDK_INT < 18) {
-                                outputFormat.setInteger("stride", resultWidth + 32);
-                                outputFormat.setInteger("slice-height", resultHeight);
-                            }
-
-                            encoder = MediaCodec.createEncoderByType(VIDEO_MIME_TYPE);
-                            encoder.configure(outputFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);
-                            if (Build.VERSION.SDK_INT >= 18) {
-                                inputSurface = new InputSurface(encoder.createInputSurface());
-                                inputSurface.makeCurrent();
-                            }
-                            encoder.start();
-
-                            decoder = MediaCodec.createDecoderByType(videoFormat.getString(MediaFormat.KEY_MIME));
-                            if (Build.VERSION.SDK_INT >= 18) {
-                                outputSurface = new OutputSurface();
-                            } else {
-                                outputSurface = new OutputSurface(resultWidth, resultHeight, rotateRender);
-                            }
-                            decoder.configure(videoFormat, outputSurface.getSurface(), null, 0);
-                            decoder.start();
-
-                            ByteBuffer[] decoderInputBuffers = null;
-                            ByteBuffer[] encoderOutputBuffers = null;
-                            ByteBuffer[] encoderInputBuffers = null;
-                            if (Build.VERSION.SDK_INT < 21) {
-                                decoderInputBuffers = decoder.getInputBuffers();
-                                encoderOutputBuffers = encoder.getOutputBuffers();
-                                if (Build.VERSION.SDK_INT < 18) {
-                                    encoderInputBuffers = encoder.getInputBuffers();
-                                }
-                            }
+        SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("videoconvert", Activity.MODE_PRIVATE);
 
-                            if (audioIndex >= 0) {
-                                MediaFormat audioFormat = extractor.getTrackFormat(audioIndex);
-                                copyAudioBuffer = audioFormat.getString(MediaFormat.KEY_MIME).equals(AUDIO_MIME_TYPE);
-                                audioTrackIndex = mediaMuxer.addTrack(audioFormat, true);
+        long time = System.currentTimeMillis();
 
-                                if(copyAudioBuffer) {
-                                    extractor.selectTrack(audioIndex);
-                                    int maxBufferSize = audioFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE);
-                                    audioBuffer = ByteBuffer.allocateDirect(maxBufferSize);
-                                } else {
+        VideoConvertorListener callback = new VideoConvertorListener() {
+            @Override
+            public boolean checkConversionCanceled() {
+                return messageObject.videoEditedInfo.canceled;
+            }
 
-                                    MediaExtractor audioExtractor = new MediaExtractor();
-                                    audioExtractor.setDataSource(videoPath);
-                                    audioExtractor.selectTrack(audioIndex);
+            long lastLength = 0;
+            @Override
+            public void updateProgress(float progress) {
+                if (messageObject.videoEditedInfo.canceled) return;
+                long availableSize = cacheFile.length();
+                if(availableSize > lastLength) {
+                    lastLength = availableSize;
+                    Log.d("kek","ffmpeg " + availableSize);
+                    MediaController.this.didWriteData(messageObject, cacheFile, false, availableSize, false);
+                }
+            }
 
-                                    if (startTime > 0) {
-                                        audioExtractor.seekTo(startTime, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
-                                    } else {
-                                        audioExtractor.seekTo(0, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
-                                    }
+            @Override
+            public void didWriteData(long availableSize) {
+                if (messageObject.videoEditedInfo.canceled) return;
+                Log.d("kek","mediacodec " + availableSize);
+                MediaController.this.didWriteData(messageObject, cacheFile, false, availableSize, false);
+            }
+        };
 
-                                    audioTranscoder = new AudioTranscoder(audioFormat, audioExtractor, audioIndex);
-                                    audioTranscoder.startTime = startTime;
-                                    audioTranscoder.endTime = endTime;
-                                }
-                            }
-                            boolean audioEncoderDone = false;
+        messageObject.videoEditedInfo.videoConvertFirstWrite = true;
+        boolean error = false;
+        boolean mediacodec = true;
 
-                            checkConversionCanceled();
+        MediaExtractor extractor = new MediaExtractor();
 
-                            while (!outputDone || (!copyAudioBuffer && !audioEncoderDone)) {
-                                checkConversionCanceled();
+        boolean copyAudioStream = true;
 
-                                if(!copyAudioBuffer && audioTranscoder != null){
-                                    audioEncoderDone = audioTranscoder.step(mediaMuxer,audioTrackIndex);
-                                }
+        try {
+            extractor.setDataSource(videoPath);
+            int audioTrackIndex = findTrack(extractor, true);
+            if(audioTrackIndex < 0){
+                copyAudioStream = true;
+            } else {
+                copyAudioStream = extractor.getTrackFormat(audioTrackIndex)
+                        .getString(MediaFormat.KEY_MIME).equals(MIMETYPE_AUDIO_AAC);
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
 
-                                if (!inputDone) {
-                                    boolean eof = false;
-                                    int index = extractor.getSampleTrackIndex();
-                                    if (index == videoIndex) {
-                                        int inputBufIndex = decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);
-                                        if (inputBufIndex >= 0) {
-                                            ByteBuffer inputBuf;
-                                            if (Build.VERSION.SDK_INT < 21) {
-                                                inputBuf = decoderInputBuffers[inputBufIndex];
-                                            } else {
-                                                inputBuf = decoder.getInputBuffer(inputBufIndex);
-                                            }
-                                            int chunkSize = extractor.readSampleData(inputBuf, 0);
-                                            if (chunkSize < 0) {
-                                                decoder.queueInputBuffer(inputBufIndex, 0, 0, 0L, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
-                                                inputDone = true;
-                                            } else {
-                                                decoder.queueInputBuffer(inputBufIndex, 0, chunkSize, extractor.getSampleTime(), 0);
-                                                extractor.advance();
-                                            }
-                                        }
-                                    } else if (copyAudioBuffer && audioIndex != -1 && index == audioIndex) {
-                                        info.size = extractor.readSampleData(audioBuffer, 0);
-                                        if (Build.VERSION.SDK_INT < 21) {
-                                            audioBuffer.position(0);
-                                            audioBuffer.limit(info.size);
-                                        }
-                                        if (info.size >= 0) {
-                                            info.presentationTimeUs = extractor.getSampleTime();
-                                            extractor.advance();
-                                        } else {
-                                            info.size = 0;
-                                            inputDone = true;
-                                        }
-                                        if (info.size > 0 && (endTime < 0 || info.presentationTimeUs < endTime)) {
-                                            info.offset = 0;
-                                            info.flags = extractor.getSampleFlags();
-                                            long availableSize = mediaMuxer.writeSampleData(audioTrackIndex, audioBuffer, info, false);
-                                            if (availableSize != 0) {
-                                                didWriteData(messageObject, cacheFile, false, availableSize, false);
-                                            }
-                                        }
-                                    } else if (index == -1) {
-                                        eof = true;
-                                    }
-                                    if (eof) {
-                                        int inputBufIndex = decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);
-                                        if (inputBufIndex >= 0) {
-                                            decoder.queueInputBuffer(inputBufIndex, 0, 0, 0L, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
-                                            inputDone = true;
-                                        }
-                                    }
-                                }
+        extractor.release();
 
-                                boolean decoderOutputAvailable = !decoderDone;
-                                boolean encoderOutputAvailable = true;
-                                while (decoderOutputAvailable || encoderOutputAvailable) {
-                                    checkConversionCanceled();
-                                    int encoderStatus = encoder.dequeueOutputBuffer(info, timoutUsec);
-                                    if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {
-                                        encoderOutputAvailable = false;
-                                    } else if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
-                                        if (Build.VERSION.SDK_INT < 21) {
-                                            encoderOutputBuffers = encoder.getOutputBuffers();
-                                        }
-                                    } else if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
-                                        MediaFormat newFormat = encoder.getOutputFormat();
-                                        if (videoTrackIndex == -5) {
-                                            videoTrackIndex = mediaMuxer.addTrack(newFormat, false);
-                                        }
-                                    } else if (encoderStatus < 0) {
-                                        throw new RuntimeException("unexpected result from encoder.dequeueOutputBuffer: " + encoderStatus);
-                                    } else {
-                                        ByteBuffer encodedData;
-                                        if (Build.VERSION.SDK_INT < 21) {
-                                            encodedData = encoderOutputBuffers[encoderStatus];
-                                        } else {
-                                            encodedData = encoder.getOutputBuffer(encoderStatus);
-                                        }
-                                        if (encodedData == null) {
-                                            throw new RuntimeException("encoderOutputBuffer " + encoderStatus + " was null");
-                                        }
-                                        if (info.size > 1) {
-                                            if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {
-                                                long availableSize = mediaMuxer.writeSampleData(videoTrackIndex, encodedData, info, true);
-                                                if (availableSize != 0) {
-                                                    didWriteData(messageObject, cacheFile, false, availableSize, false);
-                                                }
-                                            } else if (videoTrackIndex == -5) {
-                                                byte[] csd = new byte[info.size];
-                                                encodedData.limit(info.offset + info.size);
-                                                encodedData.position(info.offset);
-                                                encodedData.get(csd);
-                                                ByteBuffer sps = null;
-                                                ByteBuffer pps = null;
-                                                for (int a = info.size - 1; a >= 0; a--) {
-                                                    if (a > 3) {
-                                                        if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {
-                                                            sps = ByteBuffer.allocate(a - 3);
-                                                            pps = ByteBuffer.allocate(info.size - (a - 3));
-                                                            sps.put(csd, 0, a - 3).position(0);
-                                                            pps.put(csd, a - 3, info.size - (a - 3)).position(0);
-                                                            break;
-                                                        }
-                                                    } else {
-                                                        break;
-                                                    }
-                                                }
-
-                                                MediaFormat newFormat = MediaFormat.createVideoFormat(VIDEO_MIME_TYPE, resultWidth, resultHeight);
-                                                if (sps != null && pps != null) {
-                                                    newFormat.setByteBuffer("csd-0", sps);
-                                                    newFormat.setByteBuffer("csd-1", pps);
-                                                }
-                                                videoTrackIndex = mediaMuxer.addTrack(newFormat, false);
-                                            }
-                                        }
-                                        outputDone = (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;
-                                        encoder.releaseOutputBuffer(encoderStatus, false);
-                                    }
-                                    if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {
-                                        continue;
-                                    }
+        if(needCompress && duration < 25_000000 && !isSecret && copyAudioStream) {
+            try {
+                mediacodec = false;
+                FfmpegVideoConvertor convertor = new FfmpegVideoConvertor();
+                error = convertor.convertVideo(videoPath, cacheFile.getAbsolutePath(),
+                        rotationValue,
+                        resultWidth, resultHeight,
+                        framerate, bitrate,
+                        startTime, endTime,
+                        callback
+                );
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        } else {
+            MediaCodecVideoConvertor videoConvertor = new MediaCodecVideoConvertor();
+            error = videoConvertor.convertVideo(videoPath, cacheFile,
+                    rotationValue, isSecret,
+                    resultWidth, resultHeight,
+                    framerate, bitrate,
+                    startTime, endTime,
+                    needCompress, callback);
+        }
 
-                                    if (!decoderDone) {
-                                        int decoderStatus = decoder.dequeueOutputBuffer(info, MEDIACODEC_TIMEOUT_DEFAULT);
-                                        if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {
-                                            decoderOutputAvailable = false;
-                                        } else if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
-
-                                        } else if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
-                                            MediaFormat newFormat = decoder.getOutputFormat();
-                                            if (BuildVars.LOGS_ENABLED) {
-                                                FileLog.d("newFormat = " + newFormat);
-                                            }
-                                        } else if (decoderStatus < 0) {
-                                            throw new RuntimeException("unexpected result from decoder.dequeueOutputBuffer: " + decoderStatus);
-                                        } else {
-                                            boolean doRender;
-                                            if (Build.VERSION.SDK_INT >= 18) {
-                                                doRender = info.size != 0;
-                                            } else {
-                                                doRender = info.size != 0 || info.presentationTimeUs != 0;
-                                            }
-                                            if (endTime > 0 && info.presentationTimeUs >= endTime) {
-                                                inputDone = true;
-                                                decoderDone = true;
-                                                doRender = false;
-                                                info.flags |= MediaCodec.BUFFER_FLAG_END_OF_STREAM;
-                                            }
-                                            if (startTime > 0 && videoTime == -1) {
-                                                if (info.presentationTimeUs < startTime) {
-                                                    doRender = false;
-                                                    if (BuildVars.LOGS_ENABLED) {
-                                                        FileLog.d("drop frame startTime = " + startTime + " present time = " + info.presentationTimeUs);
-                                                    }
-                                                } else {
-                                                    videoTime = info.presentationTimeUs;
-                                                }
-                                            }
-                                            decoder.releaseOutputBuffer(decoderStatus, doRender);
-                                            if (doRender) {
-                                                boolean errorWait = false;
-                                                try {
-                                                    outputSurface.awaitNewImage();
-                                                } catch (Exception e) {
-                                                    errorWait = true;
-                                                    FileLog.e(e);
-                                                }
-                                                if (!errorWait) {
-                                                    if (Build.VERSION.SDK_INT >= 18) {
-                                                        outputSurface.drawImage(false);
-                                                        inputSurface.setPresentationTime(info.presentationTimeUs * 1000);
-                                                        inputSurface.swapBuffers();
-                                                    } else {
-                                                        int inputBufIndex = encoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);
-                                                        if (inputBufIndex >= 0) {
-                                                            outputSurface.drawImage(true);
-                                                            ByteBuffer rgbBuf = outputSurface.getFrame();
-                                                            ByteBuffer yuvBuf = encoderInputBuffers[inputBufIndex];
-                                                            yuvBuf.clear();
-                                                            Utilities.convertVideoFrame(rgbBuf, yuvBuf, colorFormat, resultWidth, resultHeight, padding, swapUV);
-                                                            encoder.queueInputBuffer(inputBufIndex, 0, bufferSize, info.presentationTimeUs, 0);
-                                                        } else {
-                                                            if (BuildVars.LOGS_ENABLED) {
-                                                                FileLog.d("input buffer not available");
-                                                            }
-                                                        }
-                                                    }
-                                                }
-                                            }
-                                            if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
-                                                decoderOutputAvailable = false;
-                                                if (BuildVars.LOGS_ENABLED) {
-                                                    FileLog.d("decoder stream end");
-                                                }
-                                                if (Build.VERSION.SDK_INT >= 18) {
-                                                    encoder.signalEndOfInputStream();
-                                                } else {
-                                                    int inputBufIndex = encoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);
-                                                    if (inputBufIndex >= 0) {
-                                                        encoder.queueInputBuffer(inputBufIndex, 0, 1, info.presentationTimeUs, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
-                                                    }
-                                                }
-                                            }
-                                        }
-                                    }
-                                }
-                            }
-                        } catch (Exception e) {
-                            // in some case encoder.dequeueOutputBuffer return IllegalStateException
-                            // stable reproduced on xiaomi
-                            // fix it by increasing timeout
-                            if (e instanceof IllegalStateException && timoutUsec != MEDIACODEC_TIMEOUT_INCREASED) {
-                                repeatWithIncreasedTimeout = true;
-                            }
-                            FileLog.e("bitrate: " + bitrate + " framerate: " + framerate + " size: " + resultHeight + "x" + resultWidth);
-                            FileLog.e(e);
-                            e.printStackTrace();
-                            error = true;
-                        }
 
-                        extractor.unselectTrack(videoIndex);
+        boolean canceled = messageObject.videoEditedInfo.canceled;
+        if (!canceled) {
+            synchronized (videoConvertSync) {
+                canceled = messageObject.videoEditedInfo.canceled;
+            }
+        }
 
-                        if (outputSurface != null) {
-                            outputSurface.release();
-                        }
-                        if (inputSurface != null) {
-                            inputSurface.release();
-                        }
-                        if (decoder != null) {
-                            decoder.stop();
-                            decoder.release();
-                        }
-                        if (encoder != null) {
-                            encoder.stop();
-                            encoder.release();
-                        }
+        int p = Math.min(resultHeight, resultWidth);
 
-                        if(audioTranscoder != null) audioTranscoder.release();
-                        checkConversionCanceled();
-                    }
-                } else {
-                    readAndWriteTracks(messageObject, extractor, mediaMuxer, info, startTime, endTime, cacheFile, bitrate != -1);
-                }
-            } catch (Exception e) {
-                error = true;
-                FileLog.e("bitrate: " + bitrate + " framerate: " + framerate + " size: " + resultHeight + "x" + resultWidth);
-                FileLog.e(e);
-            } finally {
-                if (extractor != null) {
-                    extractor.release();
-                }
-                if (mediaMuxer != null) {
-                    try {
-                        mediaMuxer.finishMovie();
-                    } catch (Exception e) {
-                        FileLog.e(e);
-                    }
-                }
-                if (BuildVars.LOGS_ENABLED) {
-                    FileLog.d("time = " + (System.currentTimeMillis() - time));
-                }
-            }
+        Log.d("kek", "mediacodec " + mediacodec +
+                " " + p + "p " +
+                " bitrate: " + bitrate +
+                " convert time: " + ((System.currentTimeMillis() - time) / 1000f) + "s " +
+                " file size= " + (cacheFile.length() / (1024 * 1024)) + "mb");
 
-            if (repeatWithIncreasedTimeout) {
-                preferences.edit().putBoolean("isPreviousOk", false).commit();
-                return convertVideo(messageObject, MEDIACODEC_TIMEOUT_INCREASED);
-            }
+        preferences.edit().putBoolean("isPreviousOk", true).apply();
+        didWriteData(messageObject, cacheFile, true, cacheFile.length(), error || canceled);
 
-        } else {
-            preferences.edit().putBoolean("isPreviousOk", true).commit();
-            didWriteData(messageObject, cacheFile, true, 0, true);
-            return false;
-        }
-        preferences.edit().putBoolean("isPreviousOk", true).commit();
-        didWriteData(messageObject, cacheFile, true, 0, error);
         return true;
     }
 
@@ -4390,4 +3823,10 @@ public static int makeVideoBitrate(int originalHeight, int originalWidth, int or
     private static int getVideoBitrateWithFactor(float f) {
         return (int) (f * 2000f * 1000f * 1.13f);
     }
+
+    public interface VideoConvertorListener {
+        boolean checkConversionCanceled();
+        void updateProgress(float progress);
+        void didWriteData(long availableSize);
+    }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/SendMessagesHelper.java b/TMessagesProj/src/main/java/org/telegram/messenger/SendMessagesHelper.java
index b46df127c..c57b2183c 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/SendMessagesHelper.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/SendMessagesHelper.java
@@ -2927,7 +2927,7 @@ private void sendMessage(String message, String caption, TLRPC.MessageMedia loca
                                 newMsg.ttl = uploadedMedia.ttl_seconds = ttl;
                                 uploadedMedia.flags |= 2;
                             }
-                            if (!TextUtils.isEmpty(path) && path.toLowerCase().endsWith("mp4") && (params == null || params.containsKey("forceDocument"))) {
+                            if (!TextUtils.isEmpty(path) && path.toLowerCase().endsWith("mp4muxer") && (params == null || params.containsKey("forceDocument"))) {
                                 uploadedMedia.nosound_video = true;
                             }
                             uploadedMedia.mime_type = document.mime_type;
@@ -5094,7 +5094,7 @@ public static void prepareSendingBotContextResult(AccountInstance accountInstanc
                             switch (result.type) {
                                 case "gif": {
                                     fileName.file_name = "animation.gif";
-                                    if (finalPath.endsWith("mp4")) {
+                                    if (finalPath.endsWith("mp4muxer")) {
                                         document.mime_type = "video/mp4";
                                         document.attributes.add(new TLRPC.TL_documentAttributeAnimated());
                                     } else {
@@ -5103,7 +5103,7 @@ public static void prepareSendingBotContextResult(AccountInstance accountInstanc
                                     try {
                                         int side = isEncrypted ? 90 : 320;
                                         Bitmap bitmap;
-                                        if (finalPath.endsWith("mp4")) {
+                                        if (finalPath.endsWith("mp4muxer")) {
                                             bitmap = ThumbnailUtils.createVideoThumbnail(finalPath, MediaStore.Video.Thumbnails.MINI_KIND);
                                         } else {
                                             bitmap = ImageLoader.loadBitmap(finalPath, null, side, side, true);
@@ -5624,7 +5624,7 @@ public static void prepareSendingMedia(AccountInstance accountInstance, final Ar
                             document.attributes.add(fileName);
                             document.size = info.searchImage.size;
                             document.dc_id = 0;
-                            if (cacheFile.toString().endsWith("mp4")) {
+                            if (cacheFile.toString().endsWith("mp4muxer")) {
                                 document.mime_type = "video/mp4";
                                 document.attributes.add(new TLRPC.TL_documentAttributeAnimated());
                             } else {
@@ -5646,7 +5646,7 @@ public static void prepareSendingMedia(AccountInstance accountInstance, final Ar
                                 try {
                                     int side = isEncrypted || info.ttl != 0 ? 90 : 320;
                                     Bitmap bitmap;
-                                    if (thumbFile.getAbsolutePath().endsWith("mp4")) {
+                                    if (thumbFile.getAbsolutePath().endsWith("mp4muxer")) {
                                         bitmap = ThumbnailUtils.createVideoThumbnail(thumbFile.getAbsolutePath(), MediaStore.Video.Thumbnails.MINI_KIND);
                                     } else {
                                         bitmap = ImageLoader.loadBitmap(thumbFile.getAbsolutePath(), null, side, side, true);
@@ -5770,7 +5770,7 @@ public static void prepareSendingMedia(AccountInstance accountInstance, final Ar
                             videoEditedInfo = info.videoEditedInfo != null ? info.videoEditedInfo : createCompressionSettings(info.path);
                         }
 
-                        if (!forceDocument && (videoEditedInfo != null || info.path.endsWith("mp4"))) {
+                        if (!forceDocument && (videoEditedInfo != null || info.path.endsWith("mp4muxer"))) {
                             String path = info.path;
                             String originalPath = info.path;
                             File temp = new File(originalPath);
@@ -6104,6 +6104,7 @@ private static void fillVideoAttribute(String videoPath, TLRPC.TL_documentAttrib
             String duration = mediaMetadataRetriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION);
             if (duration != null) {
                 attributeVideo.duration = (int) Math.ceil(Long.parseLong(duration) / 1000.0f);
+                videoEditedInfo.originalDuration = attributeVideo.duration;
             }
             if (Build.VERSION.SDK_INT >= 17) {
                 String rotation = mediaMetadataRetriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_VIDEO_ROTATION);
@@ -6316,7 +6317,7 @@ public static void prepareSendingVideo(AccountInstance accountInstance, final St
             Bitmap thumb = null;
             String thumbKey = null;
 
-            if (videoEditedInfo != null || videoPath.endsWith("mp4") || isRound) {
+            if (videoEditedInfo != null || videoPath.endsWith("mp4muxer") || isRound) {
                 String path = videoPath;
                 String originalPath = videoPath;
                 File temp = new File(originalPath);
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Utilities.java b/TMessagesProj/src/main/java/org/telegram/messenger/Utilities.java
index f3326f40c..e53a2b9ad 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Utilities.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/Utilities.java
@@ -14,6 +14,8 @@
 import android.graphics.Paint;
 import android.graphics.Rect;
 
+import org.telegram.messenger.video.FfmpegVideoConvertor;
+
 import java.io.File;
 import java.io.FileInputStream;
 import java.math.BigInteger;
@@ -65,6 +67,7 @@
     public native static void clearDir(String path, int docType, long time);
     private native static int pbkdf2(byte[] password, byte[] salt, byte[] dst, int iterations);
     public static native void stackBlurBitmap(Bitmap bitmap, int radius);
+    public static native int compressVideo(FfmpegVideoConvertor controller, String scrIn, String srcOut, int width, int height, int framerate, int bitrate, float startTime, float endTime);
 
     public static Bitmap blurWallpaper(Bitmap src) {
         if (src == null) {
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/VideoEditedInfo.java b/TMessagesProj/src/main/java/org/telegram/messenger/VideoEditedInfo.java
index 7e35486ac..e3136707e 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/VideoEditedInfo.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/VideoEditedInfo.java
@@ -34,6 +34,10 @@
     public byte[] key;
     public byte[] iv;
 
+    public boolean canceled;
+    public boolean videoConvertFirstWrite;
+    public long originalDuration;
+
     public String getString() {
         return String.format(Locale.US, "-1_%d_%d_%d_%d_%d_%d_%d_%d_%d_%s", startTime, endTime, rotationValue, originalWidth, originalHeight, bitrate, resultWidth, resultHeight, framerate, originalPath);
     }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/video/FfmpegVideoConvertor.java b/TMessagesProj/src/main/java/org/telegram/messenger/video/FfmpegVideoConvertor.java
new file mode 100644
index 000000000..df60bdb5b
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/video/FfmpegVideoConvertor.java
@@ -0,0 +1,172 @@
+package org.telegram.messenger.video;
+
+import android.media.MediaCodec;
+import android.media.MediaExtractor;
+import android.media.MediaFormat;
+import android.os.Build;
+
+import org.telegram.messenger.MediaController;
+import org.telegram.messenger.Utilities;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+import static org.telegram.messenger.MediaController.findTrack;
+
+public class FfmpegVideoConvertor {
+
+    private final ByteBuffer endOfStream;
+
+    private MediaCodec decoder;
+    private OutputSurface outputSurface;
+    private MediaExtractor extractor;
+
+    private long endTime;
+    private long startTime;
+    private int videoTrackIndex;
+    private boolean inputDone;
+    private boolean outputDone;
+
+    private MediaController.VideoConvertorListener callback;
+    private MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();
+
+    public FfmpegVideoConvertor() {
+        endOfStream = ByteBuffer.allocateDirect(3);
+        endOfStream.put(0, (byte) 0x00);
+        endOfStream.put(1, (byte) 0x00);
+        endOfStream.put(2, (byte) 0x08);
+    }
+
+    public boolean convertVideo(String videoPath, String outPath,
+                                int rotate,
+                                int resultWidth, int resultHeight,
+                                int framerate, int bitrate,
+                                long startTime, long endTime,
+                                MediaController.VideoConvertorListener callback) throws IOException {
+
+        this.callback = callback;
+        this.endTime = endTime;
+        this.startTime = startTime;
+
+        inputDone = false;
+        outputDone = false;
+
+        extractor = new MediaExtractor();
+        extractor.setDataSource(videoPath);
+        videoTrackIndex = findTrack(extractor, false);
+        extractor.selectTrack(videoTrackIndex);
+        MediaFormat videoFormat = extractor.getTrackFormat(videoTrackIndex);
+
+        decoder = MediaCodec.createDecoderByType(videoFormat.getString(MediaFormat.KEY_MIME));
+        outputSurface = new OutputSurface(resultWidth, resultHeight, rotate,true);
+
+        decoder.configure(videoFormat, outputSurface.getSurface(), null, 0);
+        decoder.start();
+
+        if (startTime > 0) {
+            extractor.seekTo(startTime, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
+        } else {
+            extractor.seekTo(0, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
+        }
+
+        int rez = Utilities.compressVideo(this,
+                videoPath, outPath,
+                resultWidth, resultHeight,
+                framerate, bitrate,
+                startTime / 1000_000f, endTime / 1000_000f
+        );
+
+        decoder.stop();
+        decoder.release();
+        extractor.release();
+
+        return rez < 0;
+    }
+
+
+    public ByteBuffer pullDecoder() {
+        ByteBuffer rgbBuf = null;
+        if (inputDone && outputDone) return endOfStream;
+
+        if (!inputDone) {
+            int trackIndex;
+            while (true) {
+                trackIndex = extractor.getSampleTrackIndex();
+                if (trackIndex < 0) {
+                    inputDone = true;
+                    break;
+                }
+                if (trackIndex == videoTrackIndex) {
+                    break;
+                }
+                extractor.advance();
+            }
+
+            if (trackIndex == videoTrackIndex) {
+                int inputBufIndex = decoder.dequeueInputBuffer(0);
+                if (endTime > 0 && extractor.getSampleTime() > endTime) {
+                    inputDone = true;
+                } else {
+                    if (inputBufIndex >= 0) {
+                        ByteBuffer inputBuf;
+                        if (Build.VERSION.SDK_INT < 21) {
+                            inputBuf = decoder.getInputBuffers()[inputBufIndex];
+                        } else {
+                            inputBuf = decoder.getInputBuffer(inputBufIndex);
+                        }
+                        int chunkSize = extractor.readSampleData(inputBuf, 0);
+
+                        if (chunkSize < 0) {
+                            decoder.queueInputBuffer(inputBufIndex, 0, 0, 0L, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
+                            inputDone = true;
+                        } else {
+                            decoder.queueInputBuffer(inputBufIndex, 0, chunkSize, extractor.getSampleTime(), 0);
+                            extractor.advance();
+                        }
+                    }
+                }
+            }
+        }
+
+        if (!outputDone) {
+            int decoderStatus = decoder.dequeueOutputBuffer(info, 2500);
+            if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {
+                if (inputDone) {
+                    outputDone = true;
+                    return endOfStream;
+                }
+            } else if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
+
+            } else if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
+
+            } else if (decoderStatus < 0) {
+                throw new RuntimeException("unexpected result from decoder.dequeueOutputBuffer: " + decoderStatus);
+            } else {
+                if (info.size > 0) {
+                    boolean doRender = info.presentationTimeUs > startTime;
+                    decoder.releaseOutputBuffer(decoderStatus, doRender);
+                    if(doRender) {
+                        try {
+                            outputSurface.awaitNewImage();
+                            outputSurface.drawImage(false);
+                            rgbBuf = outputSurface.getFrame();
+                        } catch (Exception e) {
+
+                        }
+                    }
+                }
+            }
+        }
+        return rgbBuf;
+    }
+
+    public boolean checkConversionCanceled() {
+        if(callback != null) return callback.checkConversionCanceled();
+        return false;
+    }
+
+    public void updateProgress(float progress){
+        if(callback != null) callback.updateProgress(progress);
+    }
+
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/video/MediaCodecVideoConvertor.java b/TMessagesProj/src/main/java/org/telegram/messenger/video/MediaCodecVideoConvertor.java
new file mode 100644
index 000000000..056ffab2e
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/video/MediaCodecVideoConvertor.java
@@ -0,0 +1,674 @@
+package org.telegram.messenger.video;
+
+import android.media.MediaCodec;
+import android.media.MediaCodecInfo;
+import android.media.MediaExtractor;
+import android.media.MediaFormat;
+import android.os.Build;
+
+import com.google.android.exoplayer2.util.Log;
+
+import org.telegram.messenger.AudioTranscoder;
+import org.telegram.messenger.BuildVars;
+import org.telegram.messenger.FileLog;
+import org.telegram.messenger.MediaController;
+import org.telegram.messenger.Utilities;
+
+import java.io.File;
+import java.nio.ByteBuffer;
+
+public class MediaCodecVideoConvertor {
+
+    MP4Builder mediaMuxer;
+    MediaExtractor extractor;
+
+    MediaController.VideoConvertorListener callback;
+
+    private final static int PROCESSOR_TYPE_OTHER = 0;
+    private final static int PROCESSOR_TYPE_QCOM = 1;
+    private final static int PROCESSOR_TYPE_INTEL = 2;
+    private final static int PROCESSOR_TYPE_MTK = 3;
+    private final static int PROCESSOR_TYPE_SEC = 4;
+    private final static int PROCESSOR_TYPE_TI = 5;
+
+    private static final int MEDIACODEC_TIMEOUT_DEFAULT = 2500;
+    private static final int MEDIACODEC_TIMEOUT_INCREASED = 22000;
+
+    public boolean convertVideo(String videoPath, File cacheFile,
+                                int rotationValue, boolean isSecret,
+                                int resultWidth, int resultHeight,
+                                int framerate, int bitrate,
+                                long startTime, long endTime,
+                                boolean needCompress,
+                                MediaController.VideoConvertorListener callback){
+        this.callback = callback;
+        boolean error = false;
+
+        try {
+            MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();
+            Mp4Movie movie = new Mp4Movie();
+            movie.setCacheFile(cacheFile);
+            movie.setRotation(rotationValue);
+            movie.setSize(resultWidth, resultHeight);
+            mediaMuxer = new MP4Builder().createMovie(movie, isSecret);
+            extractor = new MediaExtractor();
+            extractor.setDataSource(videoPath);
+
+
+
+            checkConversionCanceled();
+
+            if (needCompress) {
+                int videoIndex = MediaController.findTrack(extractor, false);
+                int audioIndex = bitrate != -1 ? MediaController.findTrack(extractor, true) : -1;
+
+                AudioTranscoder audioTranscoder = null;
+                ByteBuffer audioBuffer = null;
+                boolean copyAudioBuffer = true;
+
+                if (videoIndex >= 0) {
+                    MediaCodec decoder = null;
+                    MediaCodec encoder = null;
+                    InputSurface inputSurface = null;
+                    OutputSurface outputSurface = null;
+
+                    try {
+                        long videoTime = -1;
+                        boolean outputDone = false;
+                        boolean inputDone = false;
+                        boolean decoderDone = false;
+                        int swapUV = 0;
+                        int videoTrackIndex = -5;
+                        int audioTrackIndex = -5;
+
+                        int colorFormat;
+                        int processorType = PROCESSOR_TYPE_OTHER;
+                        String manufacturer = Build.MANUFACTURER.toLowerCase();
+                        if (Build.VERSION.SDK_INT < 18) {
+                            MediaCodecInfo codecInfo = MediaController.selectCodec(MediaController.VIDEO_MIME_TYPE);
+                            colorFormat = MediaController.selectColorFormat(codecInfo, MediaController.VIDEO_MIME_TYPE);
+                            if (colorFormat == 0) {
+                                throw new RuntimeException("no supported color format");
+                            }
+                            String codecName = codecInfo.getName();
+                            if (codecName.contains("OMX.qcom.")) {
+                                processorType = PROCESSOR_TYPE_QCOM;
+                                if (Build.VERSION.SDK_INT == 16) {
+                                    if (manufacturer.equals("lge") || manufacturer.equals("nokia")) {
+                                        swapUV = 1;
+                                    }
+                                }
+                            } else if (codecName.contains("OMX.Intel.")) {
+                                processorType = PROCESSOR_TYPE_INTEL;
+                            } else if (codecName.equals("OMX.MTK.VIDEO.ENCODER.AVC")) {
+                                processorType = PROCESSOR_TYPE_MTK;
+                            } else if (codecName.equals("OMX.SEC.AVC.Encoder")) {
+                                processorType = PROCESSOR_TYPE_SEC;
+                                swapUV = 1;
+                            } else if (codecName.equals("OMX.TI.DUCATI1.VIDEO.H264E")) {
+                                processorType = PROCESSOR_TYPE_TI;
+                            }
+                            if (BuildVars.LOGS_ENABLED) {
+                                FileLog.d("codec = " + codecInfo.getName() + " manufacturer = " + manufacturer + "device = " + Build.MODEL);
+                            }
+                        } else {
+                            colorFormat = MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface;
+                        }
+                        if (BuildVars.LOGS_ENABLED) {
+                            FileLog.d("colorFormat = " + colorFormat);
+                        }
+
+                        int resultHeightAligned = resultHeight;
+                        int padding = 0;
+                        int bufferSize = resultWidth * resultHeight * 3 / 2;
+                        if (processorType == PROCESSOR_TYPE_OTHER) {
+                            if (resultHeight % 16 != 0) {
+                                resultHeightAligned += (16 - (resultHeight % 16));
+                                padding = resultWidth * (resultHeightAligned - resultHeight);
+                                bufferSize += padding * 5 / 4;
+                            }
+                        } else if (processorType == PROCESSOR_TYPE_QCOM) {
+                            if (!manufacturer.toLowerCase().equals("lge")) {
+                                int uvoffset = (resultWidth * resultHeight + 2047) & ~2047;
+                                padding = uvoffset - (resultWidth * resultHeight);
+                                bufferSize += padding;
+                            }
+                        } else if (processorType == PROCESSOR_TYPE_TI) {
+                            //resultHeightAligned = 368;
+                            //bufferSize = resultWidth * resultHeightAligned * 3 / 2;
+                            //resultHeightAligned += (16 - (resultHeight % 16));
+                            //padding = resultWidth * (resultHeightAligned - resultHeight);
+                            //bufferSize += padding * 5 / 4;
+                        } else if (processorType == PROCESSOR_TYPE_MTK) {
+                            if (manufacturer.equals("baidu")) {
+                                resultHeightAligned += (16 - (resultHeight % 16));
+                                padding = resultWidth * (resultHeightAligned - resultHeight);
+                                bufferSize += padding * 5 / 4;
+                            }
+                        }
+
+                        extractor.selectTrack(videoIndex);
+                        MediaFormat videoFormat = extractor.getTrackFormat(videoIndex);
+
+                        if (startTime > 0) {
+                            extractor.seekTo(startTime, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
+                        } else {
+                            extractor.seekTo(0, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
+                        }
+
+                        MediaFormat outputFormat = MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE, resultWidth, resultHeight);
+                        outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, colorFormat);
+                        outputFormat.setInteger(MediaFormat.KEY_BIT_RATE, bitrate);
+                        outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE, framerate);
+                        outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 2);
+
+                        if (Build.VERSION.SDK_INT >= 23) {
+                            int profile;
+                            int level;
+
+                            if (Math.min(resultHeight, resultWidth) >= 1080) {
+                                profile = MediaCodecInfo.CodecProfileLevel.AVCProfileHigh;
+                                level = MediaCodecInfo.CodecProfileLevel.AVCLevel41;
+                            } else if (Math.min(resultHeight, resultWidth) >= 720) {
+                                profile = MediaCodecInfo.CodecProfileLevel.AVCProfileHigh;
+                                level = MediaCodecInfo.CodecProfileLevel.AVCLevel4;
+                            } else if (Math.min(resultHeight, resultWidth) >= 480) {
+                                profile = MediaCodecInfo.CodecProfileLevel.AVCProfileBaseline;
+                                level = MediaCodecInfo.CodecProfileLevel.AVCLevel31;
+                            } else {
+                                profile = MediaCodecInfo.CodecProfileLevel.AVCProfileBaseline;
+                                level = MediaCodecInfo.CodecProfileLevel.AVCLevel3;
+                            }
+
+                            MediaCodecInfo.CodecCapabilities capabilities = MediaCodecInfo.CodecCapabilities.createFromProfileLevel(MediaController.VIDEO_MIME_TYPE, profile, level);
+
+                            if (capabilities == null && profile == MediaCodecInfo.CodecProfileLevel.AVCProfileHigh) {
+                                profile = MediaCodecInfo.CodecProfileLevel.AVCProfileBaseline;
+                                capabilities = MediaCodecInfo.CodecCapabilities.createFromProfileLevel(MediaController.VIDEO_MIME_TYPE, profile, level);
+                            }
+                            if (capabilities.getEncoderCapabilities() != null) {
+                                outputFormat.setInteger(MediaFormat.KEY_PROFILE, profile);
+                                outputFormat.setInteger(MediaFormat.KEY_LEVEL, level);
+
+                                int maxBitrate = capabilities.getVideoCapabilities().getBitrateRange().getUpper();
+                                if (bitrate > maxBitrate) {
+                                    bitrate = maxBitrate;
+                                    outputFormat.setInteger(MediaFormat.KEY_BIT_RATE, bitrate);
+                                }
+
+                                int maxFramerate = capabilities.getVideoCapabilities().getSupportedFrameRates().getUpper();
+                                if (framerate > maxFramerate) {
+                                    framerate = maxFramerate;
+                                    outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE, framerate);
+                                }
+                            }
+                        } else {
+                            if (Math.min(resultHeight, resultWidth) <= 480) {
+                                if (bitrate > 921600) bitrate = 921600;
+                                outputFormat.setInteger(MediaFormat.KEY_BIT_RATE, bitrate);
+                            }
+                        }
+
+                        if (Build.VERSION.SDK_INT < 18) {
+                            outputFormat.setInteger("stride", resultWidth + 32);
+                            outputFormat.setInteger("slice-height", resultHeight);
+                        }
+
+                        encoder = MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);
+                        encoder.configure(outputFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);
+                        if (Build.VERSION.SDK_INT >= 18) {
+                            inputSurface = new InputSurface(encoder.createInputSurface());
+                            inputSurface.makeCurrent();
+                        }
+                        encoder.start();
+
+                        decoder = MediaCodec.createDecoderByType(videoFormat.getString(MediaFormat.KEY_MIME));
+                        if (Build.VERSION.SDK_INT >= 18) {
+                            outputSurface = new OutputSurface();
+                        } else {
+                            outputSurface = new OutputSurface(resultWidth, resultHeight, rotationValue,false);
+                        }
+                        decoder.configure(videoFormat, outputSurface.getSurface(), null, 0);
+                        decoder.start();
+
+                        ByteBuffer[] decoderInputBuffers = null;
+                        ByteBuffer[] encoderOutputBuffers = null;
+                        ByteBuffer[] encoderInputBuffers = null;
+                        if (Build.VERSION.SDK_INT < 21) {
+                            decoderInputBuffers = decoder.getInputBuffers();
+                            encoderOutputBuffers = encoder.getOutputBuffers();
+                            if (Build.VERSION.SDK_INT < 18) {
+                                encoderInputBuffers = encoder.getInputBuffers();
+                            }
+                        }
+
+                        if (audioIndex >= 0) {
+                            MediaFormat audioFormat = extractor.getTrackFormat(audioIndex);
+                            copyAudioBuffer = audioFormat.getString(MediaFormat.KEY_MIME).equals(MediaController.AUIDO_MIME_TYPE);
+                            audioTrackIndex = mediaMuxer.addTrack(audioFormat, true);
+
+                            if (copyAudioBuffer) {
+                                extractor.selectTrack(audioIndex);
+                                int maxBufferSize = audioFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE);
+                                audioBuffer = ByteBuffer.allocateDirect(maxBufferSize);
+                            } else {
+
+                                MediaExtractor audioExtractor = new MediaExtractor();
+                                audioExtractor.setDataSource(videoPath);
+                                audioExtractor.selectTrack(audioIndex);
+
+                                if (startTime > 0) {
+                                    audioExtractor.seekTo(startTime, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
+                                } else {
+                                    audioExtractor.seekTo(0, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
+                                }
+
+                                audioTranscoder = new AudioTranscoder(audioFormat, audioExtractor, audioIndex);
+                                audioTranscoder.startTime = startTime;
+                                audioTranscoder.endTime = endTime;
+                            }
+                        }
+                        boolean audioEncoderDone = false;
+
+                        checkConversionCanceled();
+
+                        while (!outputDone || (!copyAudioBuffer && !audioEncoderDone)) {
+                            checkConversionCanceled();
+
+                            if (!copyAudioBuffer && audioTranscoder != null) {
+                                audioEncoderDone = audioTranscoder.step(mediaMuxer, audioTrackIndex);
+                            }
+
+                            if (!inputDone) {
+                                boolean eof = false;
+                                int index = extractor.getSampleTrackIndex();
+                                if (index == videoIndex) {
+                                    int inputBufIndex = decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);
+                                    if (inputBufIndex >= 0) {
+                                        ByteBuffer inputBuf;
+                                        if (Build.VERSION.SDK_INT < 21) {
+                                            inputBuf = decoderInputBuffers[inputBufIndex];
+                                        } else {
+                                            inputBuf = decoder.getInputBuffer(inputBufIndex);
+                                        }
+                                        int chunkSize = extractor.readSampleData(inputBuf, 0);
+                                        if (chunkSize < 0) {
+                                            decoder.queueInputBuffer(inputBufIndex, 0, 0, 0L, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
+                                            inputDone = true;
+                                        } else {
+                                            decoder.queueInputBuffer(inputBufIndex, 0, chunkSize, extractor.getSampleTime(), 0);
+                                            extractor.advance();
+                                        }
+                                    }
+                                } else if (copyAudioBuffer && audioIndex != -1 && index == audioIndex) {
+                                    info.size = extractor.readSampleData(audioBuffer, 0);
+                                    if (Build.VERSION.SDK_INT < 21) {
+                                        audioBuffer.position(0);
+                                        audioBuffer.limit(info.size);
+                                    }
+                                    if (info.size >= 0) {
+                                        info.presentationTimeUs = extractor.getSampleTime();
+                                        extractor.advance();
+                                    } else {
+                                        info.size = 0;
+                                        inputDone = true;
+                                    }
+                                    if (info.size > 0 && (endTime < 0 || info.presentationTimeUs < endTime)) {
+                                        info.offset = 0;
+                                        info.flags = extractor.getSampleFlags();
+                                        long availableSize = mediaMuxer.writeSampleData(audioTrackIndex, audioBuffer, info, false);
+                                        if (availableSize != 0) {
+                                            if(callback != null) callback.didWriteData(availableSize);
+                                        }
+                                    }
+                                } else if (index == -1) {
+                                    eof = true;
+                                }
+                                if (eof) {
+                                    int inputBufIndex = decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);
+                                    if (inputBufIndex >= 0) {
+                                        decoder.queueInputBuffer(inputBufIndex, 0, 0, 0L, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
+                                        inputDone = true;
+                                    }
+                                }
+                            }
+
+                            boolean decoderOutputAvailable = !decoderDone;
+                            boolean encoderOutputAvailable = true;
+                            while (decoderOutputAvailable || encoderOutputAvailable) {
+                                checkConversionCanceled();
+                                int encoderStatus = encoder.dequeueOutputBuffer(info, 2500);
+                                if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {
+                                    encoderOutputAvailable = false;
+                                } else if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
+                                    if (Build.VERSION.SDK_INT < 21) {
+                                        encoderOutputBuffers = encoder.getOutputBuffers();
+                                    }
+                                } else if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
+                                    MediaFormat newFormat = encoder.getOutputFormat();
+                                    if (videoTrackIndex == -5) {
+                                        videoTrackIndex = mediaMuxer.addTrack(newFormat, false);
+                                    }
+                                } else if (encoderStatus < 0) {
+                                    throw new RuntimeException("unexpected result from encoder.dequeueOutputBuffer: " + encoderStatus);
+                                } else {
+                                    ByteBuffer encodedData;
+                                    if (Build.VERSION.SDK_INT < 21) {
+                                        encodedData = encoderOutputBuffers[encoderStatus];
+                                    } else {
+                                        encodedData = encoder.getOutputBuffer(encoderStatus);
+                                    }
+                                    if (encodedData == null) {
+                                        throw new RuntimeException("encoderOutputBuffer " + encoderStatus + " was null");
+                                    }
+                                    if (info.size > 1) {
+                                        if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {
+                                            long availableSize = mediaMuxer.writeSampleData(videoTrackIndex, encodedData, info, true);
+                                            if (availableSize != 0) {
+                                                if(callback != null) callback.didWriteData(availableSize);
+                                            }
+                                        } else if (videoTrackIndex == -5) {
+                                            byte[] csd = new byte[info.size];
+                                            encodedData.limit(info.offset + info.size);
+                                            encodedData.position(info.offset);
+                                            encodedData.get(csd);
+                                            ByteBuffer sps = null;
+                                            ByteBuffer pps = null;
+                                            for (int a = info.size - 1; a >= 0; a--) {
+                                                if (a > 3) {
+                                                    if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {
+                                                        sps = ByteBuffer.allocate(a - 3);
+                                                        pps = ByteBuffer.allocate(info.size - (a - 3));
+                                                        sps.put(csd, 0, a - 3).position(0);
+                                                        pps.put(csd, a - 3, info.size - (a - 3)).position(0);
+                                                        break;
+                                                    }
+                                                } else {
+                                                    break;
+                                                }
+                                            }
+
+                                            MediaFormat newFormat = MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE, resultWidth, resultHeight);
+                                            if (sps != null && pps != null) {
+                                                newFormat.setByteBuffer("csd-0", sps);
+                                                newFormat.setByteBuffer("csd-1", pps);
+                                            }
+                                            videoTrackIndex = mediaMuxer.addTrack(newFormat, false);
+                                        }
+                                    }
+                                    outputDone = (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;
+                                    encoder.releaseOutputBuffer(encoderStatus, false);
+                                }
+                                if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {
+                                    continue;
+                                }
+
+                                if (!decoderDone) {
+                                    int decoderStatus = decoder.dequeueOutputBuffer(info, MEDIACODEC_TIMEOUT_DEFAULT);
+                                    if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {
+                                        decoderOutputAvailable = false;
+                                    } else if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
+
+                                    } else if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
+                                        MediaFormat newFormat = decoder.getOutputFormat();
+                                        if (BuildVars.LOGS_ENABLED) {
+                                            FileLog.d("newFormat = " + newFormat);
+                                        }
+                                    } else if (decoderStatus < 0) {
+                                        throw new RuntimeException("unexpected result from decoder.dequeueOutputBuffer: " + decoderStatus);
+                                    } else {
+                                        boolean doRender;
+                                        if (Build.VERSION.SDK_INT >= 18) {
+                                            doRender = info.size != 0;
+                                        } else {
+                                            doRender = info.size != 0 || info.presentationTimeUs != 0;
+                                        }
+                                        if (endTime > 0 && info.presentationTimeUs >= endTime) {
+                                            inputDone = true;
+                                            decoderDone = true;
+                                            doRender = false;
+                                            info.flags |= MediaCodec.BUFFER_FLAG_END_OF_STREAM;
+                                        }
+                                        if (startTime > 0 && videoTime == -1) {
+                                            if (info.presentationTimeUs < startTime) {
+                                                doRender = false;
+                                                if (BuildVars.LOGS_ENABLED) {
+                                                    FileLog.d("drop frame startTime = " + startTime + " present time = " + info.presentationTimeUs);
+                                                }
+                                            } else {
+                                                videoTime = info.presentationTimeUs;
+                                            }
+                                        }
+                                        decoder.releaseOutputBuffer(decoderStatus, doRender);
+                                        if (doRender) {
+                                            boolean errorWait = false;
+                                            try {
+                                                outputSurface.awaitNewImage();
+                                            } catch (Exception e) {
+                                                errorWait = true;
+                                                FileLog.e(e);
+                                            }
+                                            if (!errorWait) {
+                                                if (Build.VERSION.SDK_INT >= 18) {
+                                                    outputSurface.drawImage(false);
+                                                    inputSurface.setPresentationTime(info.presentationTimeUs * 1000);
+                                                    inputSurface.swapBuffers();
+                                                } else {
+                                                    int inputBufIndex = encoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);
+                                                    if (inputBufIndex >= 0) {
+                                                        outputSurface.drawImage(true);
+                                                        ByteBuffer rgbBuf = outputSurface.getFrame();
+                                                        ByteBuffer yuvBuf = encoderInputBuffers[inputBufIndex];
+                                                        yuvBuf.clear();
+                                                        Utilities.convertVideoFrame(rgbBuf, yuvBuf, colorFormat, resultWidth, resultHeight, padding, swapUV);
+                                                        encoder.queueInputBuffer(inputBufIndex, 0, bufferSize, info.presentationTimeUs, 0);
+                                                    } else {
+                                                        if (BuildVars.LOGS_ENABLED) {
+                                                            FileLog.d("input buffer not available");
+                                                        }
+                                                    }
+                                                }
+                                            }
+                                        }
+                                        if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
+                                            decoderOutputAvailable = false;
+                                            if (BuildVars.LOGS_ENABLED) {
+                                                FileLog.d("decoder stream end");
+                                            }
+                                            if (Build.VERSION.SDK_INT >= 18) {
+                                                encoder.signalEndOfInputStream();
+                                            } else {
+                                                int inputBufIndex = encoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);
+                                                if (inputBufIndex >= 0) {
+                                                    encoder.queueInputBuffer(inputBufIndex, 0, 1, info.presentationTimeUs, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    } catch (Exception e) {
+                        // in some case encoder.dequeueOutputBuffer return IllegalStateException
+                        // stable reproduced on xiaomi
+                        // fix it by increasing timeout
+//                        if (e instanceof IllegalStateException && timoutUsec != MEDIACODEC_TIMEOUT_INCREASED) {
+//                            repeatWithIncreasedTimeout = true;
+//                        }
+                        e.printStackTrace();
+                        FileLog.e("bitrate: " + bitrate + " framerate: " + framerate + " size: " + resultHeight + "x" + resultWidth);
+                        FileLog.e(e);
+                        e.printStackTrace();
+                        error = true;
+                    }
+
+                    extractor.unselectTrack(videoIndex);
+
+                    if (outputSurface != null) {
+                        outputSurface.release();
+                    }
+                    if (inputSurface != null) {
+                        inputSurface.release();
+                    }
+                    if (decoder != null) {
+                        decoder.stop();
+                        decoder.release();
+                    }
+                    if (encoder != null) {
+                        encoder.stop();
+                        encoder.release();
+                    }
+
+                    if (audioTranscoder != null) audioTranscoder.release();
+                    checkConversionCanceled();
+                }
+            } else {
+                readAndWriteTracks(extractor, mediaMuxer, info, startTime, endTime, cacheFile, bitrate != -1);
+            }
+        } catch (Exception e) {
+            error = true;
+            e.printStackTrace();
+            FileLog.e("bitrate: " + bitrate + " framerate: " + framerate + " size: " + resultHeight + "x" + resultWidth);
+            FileLog.e(e);
+        } finally {
+            if (extractor != null) {
+                extractor.release();
+            }
+            if (mediaMuxer != null) {
+                try {
+                    mediaMuxer.finishMovie();
+                } catch (Exception e) {
+                    FileLog.e(e);
+                }
+            }
+            if (BuildVars.LOGS_ENABLED) {
+               // FileLog.d("time = " + (System.currentTimeMillis() - time));
+            }
+        }
+
+        return error;
+    }
+
+    private long readAndWriteTracks(MediaExtractor extractor, MP4Builder mediaMuxer,
+                                    MediaCodec.BufferInfo info, long start, long end, File file, boolean needAudio) throws Exception {
+        int videoTrackIndex = MediaController.findTrack(extractor, false);
+        int audioTrackIndex = needAudio ? MediaController.findTrack(extractor, true) : -1;
+        int muxerVideoTrackIndex = -1;
+        int muxerAudioTrackIndex = -1;
+        boolean inputDone = false;
+        int maxBufferSize = 0;
+        if (videoTrackIndex >= 0) {
+            extractor.selectTrack(videoTrackIndex);
+            MediaFormat trackFormat = extractor.getTrackFormat(videoTrackIndex);
+            muxerVideoTrackIndex = mediaMuxer.addTrack(trackFormat, false);
+            maxBufferSize = trackFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE);
+            if (start > 0) {
+                extractor.seekTo(start, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
+            } else {
+                extractor.seekTo(0, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
+            }
+        }
+        if (audioTrackIndex >= 0) {
+            extractor.selectTrack(audioTrackIndex);
+            MediaFormat trackFormat = extractor.getTrackFormat(audioTrackIndex);
+            muxerAudioTrackIndex = mediaMuxer.addTrack(trackFormat, true);
+            maxBufferSize = Math.max(trackFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE), maxBufferSize);
+            if (start > 0) {
+                extractor.seekTo(start, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
+            } else {
+                extractor.seekTo(0, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
+            }
+        }
+        ByteBuffer buffer = ByteBuffer.allocateDirect(maxBufferSize);
+        if (audioTrackIndex >= 0 || videoTrackIndex >= 0) {
+            long startTime = -1;
+            checkConversionCanceled();
+            while (!inputDone) {
+                checkConversionCanceled();
+                boolean eof = false;
+                int muxerTrackIndex;
+                info.size = extractor.readSampleData(buffer, 0);
+                int index = extractor.getSampleTrackIndex();
+                if (index == videoTrackIndex) {
+                    muxerTrackIndex = muxerVideoTrackIndex;
+                } else if (index == audioTrackIndex) {
+                    muxerTrackIndex = muxerAudioTrackIndex;
+                } else {
+                    muxerTrackIndex = -1;
+                }
+                if (muxerTrackIndex != -1) {
+                    if (Build.VERSION.SDK_INT < 21) {
+                        buffer.position(0);
+                        buffer.limit(info.size);
+                    }
+                    if (index != audioTrackIndex) {
+                        byte[] array = buffer.array();
+                        if (array != null) {
+                            int offset = buffer.arrayOffset();
+                            int len = offset + buffer.limit();
+                            int writeStart = -1;
+                            for (int a = offset; a <= len - 4; a++) {
+                                if (array[a] == 0 && array[a + 1] == 0 && array[a + 2] == 0 && array[a + 3] == 1 || a == len - 4) {
+                                    if (writeStart != -1) {
+                                        int l = a - writeStart - (a != len - 4 ? 4 : 0);
+                                        array[writeStart] = (byte) (l >> 24);
+                                        array[writeStart + 1] = (byte) (l >> 16);
+                                        array[writeStart + 2] = (byte) (l >> 8);
+                                        array[writeStart + 3] = (byte) l;
+                                        writeStart = a;
+                                    } else {
+                                        writeStart = a;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                    if (info.size >= 0) {
+                        info.presentationTimeUs = extractor.getSampleTime();
+                    } else {
+                        info.size = 0;
+                        eof = true;
+                    }
+
+                    if (info.size > 0 && !eof) {
+                        if (index == videoTrackIndex && start > 0 && startTime == -1) {
+                            startTime = info.presentationTimeUs;
+                        }
+                        if (end < 0 || info.presentationTimeUs < end) {
+                            info.offset = 0;
+                            info.flags = extractor.getSampleFlags();
+                            long availableSize = mediaMuxer.writeSampleData(muxerTrackIndex, buffer, info, false);
+                            if (availableSize != 0) {
+                                if(callback != null) callback.didWriteData(availableSize);
+                            }
+                        } else {
+                            eof = true;
+                        }
+                    }
+                    if (!eof) {
+                        extractor.advance();
+                    }
+                } else if (index == -1) {
+                    eof = true;
+                } else {
+                    extractor.advance();
+                }
+                if (eof) {
+                    inputDone = true;
+                }
+            }
+            if (videoTrackIndex >= 0) {
+                extractor.unselectTrack(videoTrackIndex);
+            }
+            if (audioTrackIndex >= 0) {
+                extractor.unselectTrack(audioTrackIndex);
+            }
+            return startTime;
+        }
+        return -1;
+    }
+
+    private void checkConversionCanceled() {
+        if(callback != null && callback.checkConversionCanceled())  throw new RuntimeException("canceled conversion");
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/video/OutputSurface.java b/TMessagesProj/src/main/java/org/telegram/messenger/video/OutputSurface.java
index 3a2fa7a8c..7a428f8f8 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/video/OutputSurface.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/video/OutputSurface.java
@@ -42,12 +42,12 @@
     private final Object mFrameSyncObject = new Object();
     private boolean mFrameAvailable;
     private TextureRenderer mTextureRender;
-    private int mWidth;
-    private int mHeight;
+    public int mWidth;
+    public int mHeight;
     private int rotateRender = 0;
     private ByteBuffer mPixelBuf;
 
-    public OutputSurface(int width, int height, int rotate) {
+    public OutputSurface(int width, int height, int rotate, boolean useYuv) {
         if (width <= 0 || height <= 0) {
             throw new IllegalArgumentException();
         }
@@ -58,15 +58,15 @@ public OutputSurface(int width, int height, int rotate) {
         mPixelBuf.order(ByteOrder.LITTLE_ENDIAN);
         eglSetup(width, height);
         makeCurrent();
-        setup();
+        setup(useYuv);
     }
 
     public OutputSurface() {
-        setup();
+        setup(false);
     }
 
-    private void setup() {
-        mTextureRender = new TextureRenderer(rotateRender);
+    private void setup(boolean yuv) {
+        mTextureRender = new TextureRenderer(rotateRender, yuv);
         mTextureRender.surfaceCreated();
         mSurfaceTexture = new SurfaceTexture(mTextureRender.getTextureId());
         mSurfaceTexture.setOnFrameAvailableListener(this);
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/video/TextureRenderer.java b/TMessagesProj/src/main/java/org/telegram/messenger/video/TextureRenderer.java
index 3f093d8c7..0e0d23c47 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/video/TextureRenderer.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/video/TextureRenderer.java
@@ -53,6 +53,31 @@
             "  gl_FragColor = texture2D(sTexture, vTextureCoord);\n" +
             "}\n";
 
+    private static final String FRAGMENT_SHADER_YUV =
+            "#extension GL_OES_EGL_image_external : require\n" +
+                    "precision highp float;\n" +
+                    "varying vec2 vTextureCoord;\n" +
+                    "uniform samplerExternalOES sTexture;\n" +
+                    "const float RGB2YUV_SHIFT = 32768.0;\n" +
+                    "const float BY =  (0.114 * 219.0 / 255.0 * RGB2YUV_SHIFT);\n" +
+                    "const float BV = -(0.081 * 224.0 / 255.0 * RGB2YUV_SHIFT);\n" +
+                    "const float BU =  (0.500 * 224.0 / 255.0 * RGB2YUV_SHIFT);\n" +
+                    "const float GY =  (0.587 * 219.0 / 255.0 * RGB2YUV_SHIFT);\n" +
+                    "const float GV = -(0.419 * 224.0 / 255.0 * RGB2YUV_SHIFT);\n" +
+                    "const float GU = -(0.331 * 224.0 / 255.0 * RGB2YUV_SHIFT);\n" +
+                    "const float RY =  (0.299 * 219.0 / 255.0 * RGB2YUV_SHIFT);\n" +
+                    "const float RV =  (0.500 * 224.0 / 255.0 * RGB2YUV_SHIFT);\n" +
+                    "const float RU = -(0.169 * 224.0 / 255.0 * RGB2YUV_SHIFT);\n" +
+                    "void main() {\n" +
+                    "vec4 rgb = texture2D(sTexture, vTextureCoord);\n" +
+                    "vec4 yuv = vec4(0.0);\n" +
+
+                    "yuv.x = ((RY * rgb.x + GY * rgb.y + BY * rgb.z + 2120.282) / RGB2YUV_SHIFT);\n" +
+                    "yuv.y = ((RU * rgb.x + GU * rgb.y + BU * rgb.z + 16512.5019) / RGB2YUV_SHIFT);\n" +
+                    "yuv.z = ((RV * rgb.x + GV * rgb.y + BV * rgb.z + 16512.5019) / RGB2YUV_SHIFT);" +
+                    "gl_FragColor = yuv;\n" +
+                    "}\n";
+
     private float[] mMVPMatrix = new float[16];
     private float[] mSTMatrix = new float[16];
     private int mTextureID = -12345;
@@ -63,8 +88,14 @@
     private int maTextureHandle;
 
     private int rotationAngle;
+    private boolean yuv;
 
     public TextureRenderer(int rotation) {
+        this(rotation, false);
+    }
+
+    public TextureRenderer(int rotation, boolean useYuv) {
+        this.yuv = useYuv;
         rotationAngle = rotation;
         float[] mTriangleVerticesData = {
                 -1.0f, -1.0f, 0, 0.f, 0.f,
@@ -113,7 +144,7 @@ public void drawFrame(SurfaceTexture st, boolean invert) {
     }
 
     public void surfaceCreated() {
-        mProgram = createProgram(VERTEX_SHADER, FRAGMENT_SHADER);
+        mProgram = createProgram(VERTEX_SHADER, yuv ? FRAGMENT_SHADER_YUV : FRAGMENT_SHADER);
         if (mProgram == 0) {
             throw new RuntimeException("failed creating program");
         }
@@ -149,9 +180,18 @@ public void surfaceCreated() {
         checkGlError("glTexParameter");
 
         Matrix.setIdentityM(mMVPMatrix, 0);
+
         if (rotationAngle != 0) {
             Matrix.rotateM(mMVPMatrix, 0, rotationAngle, 0, 0, 1);
         }
+
+        if(yuv) {
+            if (rotationAngle == 180) {
+                Matrix.rotateM(mMVPMatrix, 0, 180, 0, 1, 0);
+            } else {
+                Matrix.rotateM(mMVPMatrix, 0, 180, 1, 0, 0);
+            }
+        }
     }
 
     private int loadShader(int shaderType, String source) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java b/TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java
index 0669c0aa1..af692db78 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java
@@ -2749,15 +2749,19 @@ public boolean onTouch(View v, MotionEvent event) {
         compressItem.setBackgroundDrawable(Theme.createSelectorDrawable(Theme.ACTION_BAR_WHITE_SELECTOR_COLOR));
         SharedPreferences preferences = MessagesController.getGlobalMainSettings();
         selectedCompression = preferences.getInt("compress_video2", 1);
+        int compressIconWidth;
         if (selectedCompression <= 0) {
             compressItem.setImageResource(R.drawable.video_quality1);
+            compressIconWidth = 48;
         } else if (selectedCompression == 2) {
             compressItem.setImageResource(R.drawable.video_quality2);
+            compressIconWidth = 64;
         } else {
             selectedCompression = compressionsCount - 1;
             compressItem.setImageResource(R.drawable.video_quality3);
+            compressIconWidth = 64;
         }
-        itemsLayout.addView(compressItem, LayoutHelper.createLinear(70, 48));
+        itemsLayout.addView(compressItem, LayoutHelper.createLinear(compressIconWidth, 48));
         compressItem.setOnClickListener(v -> {
             if (captionEditText.getTag() != null) {
                 return;
@@ -6380,7 +6384,7 @@ private void checkProgress(int a, boolean animated) {
                     if (botInlineResult.document != null) {
                         f = FileLoader.getPathToAttach(botInlineResult.document);
                     } else if (botInlineResult.content instanceof TLRPC.TL_webDocument) {
-                        f = new File(FileLoader.getDirectory(FileLoader.MEDIA_DIR_CACHE), Utilities.MD5(botInlineResult.content.url) + "." + ImageLoader.getHttpUrlExtension(botInlineResult.content.url, "mp4"));
+                        f = new File(FileLoader.getDirectory(FileLoader.MEDIA_DIR_CACHE), Utilities.MD5(botInlineResult.content.url) + "." + ImageLoader.getHttpUrlExtension(botInlineResult.content.url, "mp4muxer"));
                     }
                     isVideo = true;
                 } else if (botInlineResult.document != null) {
@@ -6771,7 +6775,8 @@ public boolean openPhotoForSelect(final ArrayList<Object> photos, final int inde
             }
             pickerViewSendButton.setLayoutParams(layoutParams2);
         }
-        return openPhoto(null, null, null, null, null, photos, index, provider, chatActivity, 0, 0, true);
+        long dialogId = chatActivity != null ? chatActivity.getDialogId() : 0;
+        return openPhoto(null, null, null, null, null, photos, index, provider, chatActivity, dialogId, 0, true);
     }
 
     private boolean checkAnimation() {
@@ -8297,7 +8302,7 @@ private void onActionClick(boolean download) {
                     file = null;
                 }
             } else if (currentBotInlineResult.content instanceof TLRPC.TL_webDocument) {
-                file = new File(FileLoader.getDirectory(FileLoader.MEDIA_DIR_CACHE), Utilities.MD5(currentBotInlineResult.content.url) + "." + ImageLoader.getHttpUrlExtension(currentBotInlineResult.content.url, "mp4"));
+                file = new File(FileLoader.getDirectory(FileLoader.MEDIA_DIR_CACHE), Utilities.MD5(currentBotInlineResult.content.url) + "." + ImageLoader.getHttpUrlExtension(currentBotInlineResult.content.url, "mp4muxer"));
                 if (!file.exists()) {
                     file = null;
                 }
@@ -8323,7 +8328,7 @@ private void onActionClick(boolean download) {
                         }
                     } else if (currentBotInlineResult.content instanceof TLRPC.TL_webDocument) {
                         if (!ImageLoader.getInstance().isLoadingHttpFile(currentBotInlineResult.content.url)) {
-                            ImageLoader.getInstance().loadHttpFile(currentBotInlineResult.content.url, "mp4", currentAccount);
+                            ImageLoader.getInstance().loadHttpFile(currentBotInlineResult.content.url, "mp4muxer", currentAccount);
                         } else {
                             ImageLoader.getInstance().cancelLoadHttpFile(currentBotInlineResult.content.url);
                         }
@@ -8553,10 +8558,6 @@ public boolean onDoubleTapEvent(MotionEvent e) {
         private int sideSide;
         private int lineSize;
 
-        private boolean moving;
-        private boolean startMoving;
-        private float startX;
-
         private String lowQualityDescription;
         private String hightQualityDescription;
 
@@ -8578,17 +8579,10 @@ public QualityChooseView(Context context) {
         public boolean onTouchEvent(MotionEvent event) {
             float x = event.getX();
             if (event.getAction() == MotionEvent.ACTION_DOWN) {
+                startMovingQuality = selectedCompression;
                 getParent().requestDisallowInterceptTouchEvent(true);
-                for (int a = 0; a < compressionsCount; a++) {
-                    int cx = sideSide + (lineSize + gapSize * 2 + circleSize) * a + circleSize / 2;
-                    if (x > cx - AndroidUtilities.dp(15) && x < cx + AndroidUtilities.dp(15)) {
-                        startMoving = a == selectedCompression;
-                        startX = x;
-                        startMovingQuality = selectedCompression;
-                        break;
-                    }
-                }
-            } else if (event.getAction() == MotionEvent.ACTION_MOVE) {
+            }
+            if (event.getAction() == MotionEvent.ACTION_DOWN || event.getAction() == MotionEvent.ACTION_MOVE) {
 
                 for (int a = 0; a < compressionsCount; a++) {
                     int cx = sideSide + (lineSize + gapSize * 2 + circleSize) * a + circleSize / 2;
@@ -8604,12 +8598,9 @@ public boolean onTouchEvent(MotionEvent event) {
                 }
 
             } else if (event.getAction() == MotionEvent.ACTION_UP || event.getAction() == MotionEvent.ACTION_CANCEL) {
-
                 if (selectedCompression != startMovingQuality) {
                     requestVideoPreview(1);
                 }
-
-                startMoving = false;
                 moving = false;
             }
             return true;
@@ -8715,13 +8706,19 @@ private void updateVideoInfo() {
             return;
         }
 
+        int compressIconWidth = 64;
         if (selectedCompression < 2) {
             compressItem.setImageResource(R.drawable.video_quality1);
+            compressIconWidth = 48;
         } else if (selectedCompression == 2) {
             compressItem.setImageResource(R.drawable.video_quality2);
+            compressIconWidth = 64;
         } else if (selectedCompression == 3) {
             compressItem.setImageResource(R.drawable.video_quality3);
+            compressIconWidth = 64;
         }
+        compressItem.getLayoutParams().width = AndroidUtilities.dp(compressIconWidth);
+        compressItem.requestLayout();
         String[] compressionStrings = {"360", "480", "720", "1080"};
         compressItem.setContentDescription(LocaleController.getString("AccDescrVideoQuality", R.string.AccDescrVideoQuality) + ", " + compressionStrings[Math.max(0, selectedCompression)]);
 
@@ -8790,6 +8787,7 @@ private void requestVideoPreview(int request) {
                     message.message = "";
                     message.media = new TLRPC.TL_messageMediaEmpty();
                     message.action = new TLRPC.TL_messageActionEmpty();
+                    message.dialog_id = currentDialogId;
                     videoPreviewMessageObject = new MessageObject(UserConfig.selectedAccount, message, false);
                     videoPreviewMessageObject.messageOwner.attachPath = new File(FileLoader.getDirectory(FileLoader.MEDIA_DIR_CACHE), "video_preview.mp4").getAbsolutePath();
                     videoPreviewMessageObject.videoEditedInfo = new VideoEditedInfo();
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/video_quality1.png b/TMessagesProj/src/main/res/drawable-hdpi/video_quality1.png
index 8cdd6664d..2c84840a6 100644
Binary files a/TMessagesProj/src/main/res/drawable-hdpi/video_quality1.png and b/TMessagesProj/src/main/res/drawable-hdpi/video_quality1.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/video_quality2.png b/TMessagesProj/src/main/res/drawable-hdpi/video_quality2.png
index d43eb70fb..60326c09c 100644
Binary files a/TMessagesProj/src/main/res/drawable-hdpi/video_quality2.png and b/TMessagesProj/src/main/res/drawable-hdpi/video_quality2.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/video_quality1.png b/TMessagesProj/src/main/res/drawable-mdpi/video_quality1.png
index 247a2f1bb..f3c028baa 100644
Binary files a/TMessagesProj/src/main/res/drawable-mdpi/video_quality1.png and b/TMessagesProj/src/main/res/drawable-mdpi/video_quality1.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/video_quality2.png b/TMessagesProj/src/main/res/drawable-mdpi/video_quality2.png
index 81dcbca13..5a221e41d 100644
Binary files a/TMessagesProj/src/main/res/drawable-mdpi/video_quality2.png and b/TMessagesProj/src/main/res/drawable-mdpi/video_quality2.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/video_quality3.png b/TMessagesProj/src/main/res/drawable-mdpi/video_quality3.png
index eacfd14c0..73dd84808 100644
Binary files a/TMessagesProj/src/main/res/drawable-mdpi/video_quality3.png and b/TMessagesProj/src/main/res/drawable-mdpi/video_quality3.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/video_quality1.png b/TMessagesProj/src/main/res/drawable-xhdpi/video_quality1.png
index 09728acfd..e06ec23ae 100644
Binary files a/TMessagesProj/src/main/res/drawable-xhdpi/video_quality1.png and b/TMessagesProj/src/main/res/drawable-xhdpi/video_quality1.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/video_quality2.png b/TMessagesProj/src/main/res/drawable-xhdpi/video_quality2.png
index 9a8d0b2cf..aa92c4fab 100644
Binary files a/TMessagesProj/src/main/res/drawable-xhdpi/video_quality2.png and b/TMessagesProj/src/main/res/drawable-xhdpi/video_quality2.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/video_quality1.png b/TMessagesProj/src/main/res/drawable-xxhdpi/video_quality1.png
index 03c781552..347d36f78 100644
Binary files a/TMessagesProj/src/main/res/drawable-xxhdpi/video_quality1.png and b/TMessagesProj/src/main/res/drawable-xxhdpi/video_quality1.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/video_quality2.png b/TMessagesProj/src/main/res/drawable-xxhdpi/video_quality2.png
index 2524e5429..6596e8a65 100644
Binary files a/TMessagesProj/src/main/res/drawable-xxhdpi/video_quality2.png and b/TMessagesProj/src/main/res/drawable-xxhdpi/video_quality2.png differ
