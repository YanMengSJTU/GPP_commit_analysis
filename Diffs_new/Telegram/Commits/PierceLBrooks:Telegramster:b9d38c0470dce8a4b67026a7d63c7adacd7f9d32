diff --git a/Telegram/sfml/src/main/assets/sansation.ttf b/Telegram/sfml/src/main/assets/sansation.ttf
new file mode 100644
index 000000000..d85fbc81d
Binary files /dev/null and b/Telegram/sfml/src/main/assets/sansation.ttf differ
diff --git a/Trunk/include/DrawableStack.hpp b/Trunk/include/DrawableStack.hpp
new file mode 100644
index 000000000..6747d9250
--- /dev/null
+++ b/Trunk/include/DrawableStack.hpp
@@ -0,0 +1,80 @@
+#ifndef DRAWABLE_STACK_HPP
+#define DRAWABLE_STACK_HPP
+
+#include <map>
+#include <vector>
+#include <SFML/Graphics/RenderTarget.hpp>
+#include <SFML/Graphics/Drawable.hpp>
+
+class DrawableStack : public sf::Drawable
+{
+public:
+    DrawableStack() :
+		sf::Drawable()
+    {
+        
+    }
+    void addDrawable(sf::Drawable* drawable, unsigned int depth)
+    {
+        std::map<unsigned int, std::vector<sf::Drawable*> >::iterator iter = drawables.find(depth);
+        if (iter == drawables.end())
+        {
+            drawables[depth] = std::vector<sf::Drawable*>();
+            iter = drawables.find(depth);
+        }
+        iter->second.push_back(drawable);
+    }
+    bool removeDrawable(sf::Drawable* drawable, unsigned int depth)
+    {
+        std::map<unsigned int, std::vector<sf::Drawable*> >::iterator iter = drawables.find(depth);
+        if (iter != drawables.end())
+        {
+            for (unsigned int i = 0; i != iter->second.size(); ++i)
+            {
+                if (iter->second[i] == drawable)
+                {
+                    iter->second.erase(iter->second.begin()+i);
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+    bool removeDrawable(sf::Drawable* drawable)
+    {
+        for (std::map<unsigned int, std::vector<sf::Drawable*> >::iterator iter = drawables.begin(); iter != drawables.end(); ++iter)
+        {
+            if (removeDrawable(drawable,iter->first))
+            {
+                return true;
+            }
+        }
+        return false;
+    }
+	void removeDrawables()
+	{
+        for (std::map<unsigned int, std::vector<sf::Drawable*> >::const_iterator iter = drawables.begin(); iter != drawables.end(); ++iter)
+        {
+            for (std::vector<sf::Drawable*>::const_iterator iter2 = iter->second.begin(); iter2 != iter->second.end(); ++iter2)
+            {
+                delete *iter2;
+            }
+        }
+		drawables.clear();
+	}
+protected:
+    void draw(sf::RenderTarget& renderTarget, sf::RenderStates renderStates) const
+    {
+        for (std::map<unsigned int, std::vector<sf::Drawable*> >::const_iterator iter = drawables.begin(); iter != drawables.end(); ++iter)
+        {
+            for (std::vector<sf::Drawable*>::const_iterator iter2 = iter->second.begin(); iter2 != iter->second.end(); ++iter2)
+            {
+                renderTarget.draw(**iter2,renderStates);
+            }
+        }
+    }
+private:
+    std::map<unsigned int, std::vector<sf::Drawable*>> drawables;
+};
+
+#endif
diff --git a/Trunk/include/MainState.hpp b/Trunk/include/MainState.hpp
new file mode 100644
index 000000000..04578909b
--- /dev/null
+++ b/Trunk/include/MainState.hpp
@@ -0,0 +1,49 @@
+#ifndef MAIN_STATE_HPP
+#define MAIN_STATE_HPP
+
+#include <vector>
+#include "State.hpp"
+
+namespace sfml
+{
+	class MainState : public State
+	{
+		public:
+			MainState();
+			void enter();
+			void exit();
+			void update();
+
+			sf::Color colorConvert(sf::Vector3f color);
+			void drawLine(sf::Vector2f point1, sf::Vector2f point2);
+			void draw(sf::Vector2f point);
+			bool drawing, brushMode;
+			float deltaTime;
+			int brushSize, brushSizeMax, drawMode, gray, scale;
+			sf::Color brushColor;
+			sf::Image* pictureImg;
+			sf::Image* brushImg;
+			sf::Texture* pictureTex;
+			sf::Texture* brushTex;
+			sf::Sprite* pictureSpr;
+			sf::Sprite* brushSpr;
+			sf::Clock clock;
+			sf::Vector2f mouse, mousePrev, mouseReal, window, windowRatio, cursor;
+			sf::RectangleShape* back;
+			sf::RectangleShape* colorSelect;
+			sf::RectangleShape* colorUnit;
+			sf::RectangleShape* brushSizeSliderBack;
+			sf::RectangleShape* brushSizeSlider;
+			sf::RenderTexture* paletteColorTex;
+			sf::RenderTexture* paletteGrayTex;
+			sf::RectangleShape* paletteColorOutline;
+			sf::RectangleShape* paletteGrayOutline;
+			sf::Sprite* paletteColorSpr;
+			sf::Sprite* paletteGraySpr;
+			sf::Text* colorSelectTxt;
+			sf::Text* brushSizeSliderTxt;
+			sf::Font* font;
+	};
+}
+
+#endif
diff --git a/Trunk/include/State.hpp b/Trunk/include/State.hpp
new file mode 100644
index 000000000..2abd89b14
--- /dev/null
+++ b/Trunk/include/State.hpp
@@ -0,0 +1,26 @@
+#ifndef STATE_HPP
+#define STATE_HPP
+
+#include <vector>
+#include <string>
+#include <SFML/Graphics.hpp>
+#include "DrawableStack.hpp"
+
+namespace sfml
+{
+    class State
+    {
+        public:
+            State();
+
+            virtual void enter() = 0;
+
+            virtual void exit() = 0;
+
+            virtual void update() = 0;
+
+            DrawableStack* drawableStack;
+    };
+}
+
+#endif // STATE_HPP
diff --git a/Trunk/src/CMakeLists.txt b/Trunk/src/CMakeLists.txt
index 10739f973..b8d7a8b5b 100644
--- a/Trunk/src/CMakeLists.txt
+++ b/Trunk/src/CMakeLists.txt
@@ -27,6 +27,11 @@ set(PROJECT_FILES
 	${INC}/native-lib.hpp
 	${SRC}/Log.cpp
 	${INC}/Log.hpp
+	${SRC}/MainState.cpp
+	${INC}/MainState.hpp
+	${SRC}/State.cpp
+	${INC}/State.hpp
+	${INC}/DrawableStack.hpp
 )
 
 message(${LIBRARIES})
diff --git a/Trunk/src/MainState.cpp b/Trunk/src/MainState.cpp
new file mode 100644
index 000000000..7e0a0e29c
--- /dev/null
+++ b/Trunk/src/MainState.cpp
@@ -0,0 +1,426 @@
+#include <MainState.hpp>
+#include <iostream>
+#include <cstdlib>
+#include <cmath>
+
+#define PI 4.0f*atan(1.0f)
+
+sfml::MainState::MainState() :
+	State()
+{
+	
+}
+
+void sfml::MainState::enter()
+{
+	drawableStack = new DrawableStack();
+    drawMode = 0;
+    scale = 3;
+    deltaTime = 0;
+    gray = 0;
+    mouse.x = 0;
+    mouse.y = 0;
+    mousePrev.x = 0;
+    mousePrev.y = 0;
+    mouseReal.x = 0;
+    mouseReal.y = 0;
+    brushSize = 0;
+    brushSizeMax = 25;
+    drawing = false;
+    brushMode = false;
+    brushColor = sf::Color::Black;
+    font = new sf::Font();
+    font->loadFromFile("sansation.ttf");
+    pictureImg = new sf::Image();
+    pictureImg->create((window.x/scale)*.75f,window.y/scale,sf::Color::White);
+    pictureTex = new sf::Texture();
+    pictureTex->loadFromImage(*pictureImg);
+    pictureSpr = new sf::Sprite(*pictureTex);
+    pictureSpr->setScale(scale,scale);
+    brushImg = new sf::Image();
+    brushImg->create(brushSizeMax*2, brushSizeMax*2, sf::Color::Transparent);
+    brushImg->setPixel(brushSizeMax,brushSizeMax,sf::Color(128,128,128,128));
+    brushTex = new sf::Texture();
+    brushTex->loadFromImage(*brushImg);
+    brushSpr = new sf::Sprite(*brushTex);
+    brushSpr->setScale(scale,scale);
+    brushSpr->setOrigin(brushSizeMax, brushSizeMax);
+    back = new sf::RectangleShape();
+    back->setSize(sf::Vector2f(window.x*.25f,window.y));
+    back->setPosition(window.x-(window.x*.25f),0);
+    back->setFillColor(sf::Color(128,128,128));
+    colorSelect = new sf::RectangleShape();
+    colorSelect->setSize(sf::Vector2f(256,32));
+    colorSelect->setFillColor(sf::Color::Black);
+    colorSelect->setPosition(window.x-(window.x*.25f)+32,window.y/16);
+    colorSelect->setOutlineColor(sf::Color::Black);
+    colorSelect->setOutlineThickness(2);
+    paletteColorOutline = new sf::RectangleShape();
+    paletteColorOutline->setSize(sf::Vector2f(256,32));
+    paletteColorOutline->setFillColor(sf::Color::Black);
+    paletteColorOutline->setPosition(window.x-(window.x*.25f)+32,(window.y/16)*2);
+    paletteColorOutline->setOutlineColor(sf::Color::Black);
+    paletteColorOutline->setOutlineThickness(2);
+    paletteGrayOutline = new sf::RectangleShape();
+    paletteGrayOutline->setSize(sf::Vector2f(256,32));
+    paletteGrayOutline->setFillColor(sf::Color::Black);
+    paletteGrayOutline->setPosition(window.x-(window.x*.25f)+32,(window.y/16)*3);
+    paletteGrayOutline->setOutlineColor(sf::Color::Black);
+    paletteGrayOutline->setOutlineThickness(2);
+    paletteColorTex = new sf::RenderTexture();
+    paletteColorTex->create(256,32);
+    paletteColorTex->setActive();
+    paletteGrayTex = new sf::RenderTexture();
+    paletteGrayTex->create(256,32);
+    paletteGrayTex->setActive();
+    for (int i = 0; i < 255; i++)
+    {
+        colorUnit = new sf::RectangleShape();
+        colorUnit->setFillColor(colorConvert(sf::Vector3f(((float)i/255.0f)*359.0f,1,1)));
+        colorUnit->setSize(sf::Vector2f(1,32));
+        colorUnit->setPosition(i,0);
+        paletteColorTex->draw(*colorUnit);
+        colorUnit = new sf::RectangleShape();
+        colorUnit->setFillColor(sf::Color(i,i,i));
+        colorUnit->setSize(sf::Vector2f(1,32));
+        colorUnit->setPosition(i,0);
+        paletteGrayTex->draw(*colorUnit);
+    }
+    paletteColorTex->setActive(false);
+    paletteColorSpr = new sf::Sprite(paletteColorTex->getTexture());
+    paletteColorSpr->setPosition(window.x-(window.x*.25f)+32,(window.y/16)*2);
+    paletteGrayTex->setActive(false);
+    paletteGraySpr = new sf::Sprite(paletteGrayTex->getTexture());
+    paletteGraySpr->setPosition(window.x-(window.x*.25f)+32,(window.y/16)*3);
+    brushSizeSliderBack = new sf::RectangleShape();
+    brushSizeSliderBack->setSize(sf::Vector2f(256,32));
+    brushSizeSliderBack->setFillColor(sf::Color::White);
+    brushSizeSliderBack->setPosition(window.x-(window.x*.25f)+32,(window.y/16)*4);
+    brushSizeSliderBack->setOutlineColor(sf::Color::Black);
+    brushSizeSliderBack->setOutlineThickness(2);
+    brushSizeSlider = new sf::RectangleShape();
+    brushSizeSlider->setSize(sf::Vector2f(8,32));
+    brushSizeSlider->setFillColor(sf::Color::Black);
+    brushSizeSlider->setPosition(window.x-(window.x*.25f)+32,(window.y/16)*4);
+    colorSelectTxt = new sf::Text(sf::String("Brush Color"), *font, 20);
+    colorSelectTxt->setPosition(colorSelect->getPosition().x+128,colorSelect->getPosition().y+4);
+    colorSelectTxt->setFillColor(sf::Color::White);
+    colorSelectTxt->setOrigin(colorSelectTxt->getGlobalBounds().width/2,0);
+    colorSelectTxt->setStyle(sf::Text::Bold);
+    brushSizeSliderTxt = new sf::Text(sf::String("Brush Size"), *font, 20);
+    brushSizeSliderTxt->setPosition(brushSizeSliderBack->getPosition().x+128,brushSizeSliderBack->getPosition().y+4);
+    brushSizeSliderTxt->setFillColor(sf::Color(128,128,128));
+    brushSizeSliderTxt->setOrigin(brushSizeSliderTxt->getGlobalBounds().width/2,0);
+    brushSizeSliderTxt->setStyle(sf::Text::Bold);
+    drawableStack->addDrawable(brushSpr, 2);
+    drawableStack->addDrawable(pictureSpr, 1);
+    drawableStack->addDrawable(back, 3);
+    drawableStack->addDrawable(colorSelect, 4);
+    drawableStack->addDrawable(paletteColorSpr, 5);
+    drawableStack->addDrawable(paletteGraySpr, 5);
+    drawableStack->addDrawable(brushSizeSlider, 6);
+    drawableStack->addDrawable(brushSizeSliderBack, 4);
+    drawableStack->addDrawable(paletteColorOutline, 4);
+    drawableStack->addDrawable(paletteGrayOutline, 4);
+    drawableStack->addDrawable(colorSelectTxt, 4);
+    drawableStack->addDrawable(brushSizeSliderTxt, 5);
+}
+
+void sfml::MainState::exit()
+{
+	drawableStack->removeDrawables();
+	delete drawableStack;
+	drawableStack = nullptr;
+}
+
+void sfml::MainState::update()
+{
+    deltaTime = clock.restart().asSeconds();
+    windowRatio.x = 1.0f;
+    windowRatio.y = 1.0f;
+    mouse.x = (cursor.x/scale)*windowRatio.x;
+    mouse.y = (cursor.y/scale)*windowRatio.y;
+    mouseReal.x = cursor.x*windowRatio.x;
+    mouseReal.y = cursor.y*windowRatio.y;
+    if (brushSize < 0)
+    {
+        brushSize = brushSizeMax;
+    }
+    if (brushSize > brushSizeMax)
+    {
+        brushSize = 0;
+    }
+    if (sf::Mouse::isButtonPressed(sf::Mouse::Right))
+    {
+        if ((mouse.x >= 0) && (mouse.y >= 0) && (mouse.x < pictureImg->getSize().x) && (mouse.y < pictureImg->getSize().y))
+        {
+            colorSelect->setFillColor(pictureImg->getPixel(mouse.x, mouse.y));
+            brushColor = colorSelect->getFillColor();
+        }
+        else
+        {
+            brushColor = colorSelect->getFillColor();
+        }
+    }
+    else
+    {
+        brushColor = colorSelect->getFillColor();
+    }
+    if (drawing)
+    {
+        if ((mouse.x >= 0) && (mouse.y >= 0) && (mouse.x < pictureImg->getSize().x) && (mouse.y < pictureImg->getSize().y))
+        {
+            if (drawing)
+            {
+                drawLine(mousePrev, mouse);
+            }
+            draw(mouse);
+            pictureTex->loadFromImage(*pictureImg);
+            drawing = true;
+        }
+        if (!drawing)
+        {
+            if ((paletteColorSpr->getPosition().x-32 <= mouseReal.x) &&
+                (paletteColorSpr->getPosition().y <= mouseReal.y) &&
+                (paletteColorSpr->getPosition().x+(window.x*.25f)+32 >= mouseReal.x) &&
+                (paletteColorSpr->getPosition().y+32 >= mouseReal.y))
+            {
+                brushColor = colorConvert(sf::Vector3f((std::min(255.0f,std::max(0.0f,(mouseReal.x-(window.x-(window.x*.25f)+32))))/255.0f)*359.0f,1,1));
+                colorSelect->setFillColor(brushColor);
+            }
+            if ((paletteGraySpr->getPosition().x-32 <= mouseReal.x) &&
+                (paletteGraySpr->getPosition().y <= mouseReal.y) &&
+                (paletteGraySpr->getPosition().x+(window.x*.25f)+32 >= mouseReal.x) &&
+                (paletteGraySpr->getPosition().y+32 >= mouseReal.y))
+            {
+                gray = std::min(255.0f,std::max(0.0f,mouseReal.x-(window.x-(window.x*.25f)+32)));
+                brushColor = sf::Color(gray,gray,gray);
+                colorSelect->setFillColor(brushColor);
+            }
+            if ((brushSizeSliderBack->getPosition().x-32 <= mouseReal.x) &&
+                (brushSizeSliderBack->getPosition().y <= mouseReal.y) &&
+                (brushSizeSliderBack->getPosition().x+(window.x*.25f)+32 >= mouseReal.x) &&
+                (brushSizeSliderBack->getPosition().y+32 >= mouseReal.y))
+            {
+                brushSizeSlider->setPosition(std::min(window.x-(window.x*.25f)+280,std::max(window.x-(window.x*.25f)+32,mouseReal.x)), brushSizeSlider->getPosition().y);
+                brushSize = std::min(brushSizeMax,std::max(0,(int)(brushSizeMax*((mouseReal.x-(window.x-(window.x*.25f)+32))/256))));
+                brushImg->create(brushSizeMax*2, brushSizeMax*2, sf::Color::Transparent);
+                if (brushSize == 0)
+                {
+                    brushImg->setPixel(brushSizeMax,brushSizeMax,sf::Color(128,128,128,128));
+                }
+                else
+                {
+                    for (int i = -brushSize; i <= brushSize; i++)
+                    {
+                        for (int ii = -brushSize; ii <= brushSize; ii++)
+                        {
+                            if ((i*i)+(ii*ii) <= brushSize*brushSize)
+                            {
+                                if ((brushSizeMax+i >= 0) && (brushSizeMax+ii >= 0) && (brushSizeMax+i < brushImg->getSize().x) && (brushSizeMax+ii < brushImg->getSize().y))
+                                {
+                                    brushImg->setPixel(brushSizeMax+i,brushSizeMax+ii,sf::Color(128,128,128,128));
+                                }
+                            }
+                        }
+                    }
+                }
+                brushTex->loadFromImage(*brushImg);
+                brushSpr->setOrigin(brushSizeMax, brushSizeMax);
+            }
+        }
+    }
+    else
+    {
+        drawing = false;
+    }
+    mousePrev = mouse;
+    if ((mouse.x >= 0) && (mouse.y >= 0) && (mouse.x < pictureImg->getSize().x) && (mouse.y < pictureImg->getSize().y))
+    {
+        brushSpr->setPosition(mouseReal);
+    }
+    else
+    {
+        brushSpr->setPosition(-100*scale, -100*scale);
+    }
+    if ((colorSelect->getFillColor().r == colorSelect->getFillColor().g) &&
+        (colorSelect->getFillColor().r == colorSelect->getFillColor().b) &&
+        (colorSelect->getFillColor().g == colorSelect->getFillColor().b))
+    {
+        gray = (1-((colorSelect->getFillColor().r+128)/255))*255;
+        colorSelectTxt->setFillColor(sf::Color(gray,gray,gray));
+    }
+    else
+    {
+        colorSelectTxt->setFillColor(sf::Color::Black);
+    }
+}
+
+void sfml::MainState::drawLine(sf::Vector2f point1, sf::Vector2f point2)
+{
+    sf::Vector2i point;
+    int dx, dy, dx1, dy1, px, py, xe, ye;
+    dx = point2.x-point1.x;
+    dy = point2.y-point1.y;
+    dx1 = fabs(dx);
+    dy1 = fabs(dy);
+    px = 2*dy1-dx1;
+    py = 2*dx1-dy1;
+    if (dy1 <= dx1)
+    {
+        if (dx >= 0)
+        {
+            point.x = point1.x;
+            point.y = point1.y;
+            xe = point2.x;
+        }
+        else
+        {
+            point.x = point2.x;
+            point.y = point2.y;
+            xe = point1.x;
+        }
+        draw(sf::Vector2f(point.x, point.y));
+        for (int i = 0; point.x < xe; i++)
+        {
+            point.x = point.x+1;
+            if(px < 0)
+            {
+                px = px+(2*dy1);
+            }
+            else
+            {
+                if (((dx < 0) && (dy < 0)) || ((dx > 0) && (dy>0)))
+                {
+                    point.y = point.y+1;
+                }
+                else
+                {
+                    point.y = point.y-1;
+                }
+                px = px+(2*(dy1-dx1));
+            }
+            draw(sf::Vector2f(point.x, point.y));
+        }
+    }
+    else
+    {
+        if (dy >= 0)
+        {
+            point.x = point1.x;
+            point.y = point1.y;
+            ye = point2.y;
+        }
+        else
+        {
+            point.x = point2.x;
+            point.y = point2.y;
+            ye = point1.y;
+        }
+        draw(sf::Vector2f(point.x, point.y));
+        for(int i = 0; point.y < ye; i++)
+        {
+            point.y = point.y+1;
+            if (py <= 0)
+            {
+                py = py+(2*dx1);
+            }
+            else
+            {
+                if (((dx < 0) && (dy < 0)) || ((dx > 0) && (dy > 0)))
+                {
+                    point.x = point.x+1;
+                }
+                else
+                {
+                    point.x = point.x-1;
+                }
+                py = py+(2*(dx1-dy1));
+            }
+            draw(sf::Vector2f(point.x, point.y));
+        }
+    }
+}
+
+void sfml::MainState::draw(sf::Vector2f point)
+{
+    if (brushSize == 0)
+    {
+        if ((point.x >= 0) && (point.y >= 0) && (point.x < pictureImg->getSize().x) && (point.y < pictureImg->getSize().y))
+        {
+            pictureImg->setPixel(point.x,point.y,brushColor);
+        }
+    }
+    else
+    {
+        for (int i = -brushSize; i <= brushSize; i++)
+        {
+            for (int ii = -brushSize; ii <= brushSize; ii++)
+            {
+                if ((i*i)+(ii*ii) <= brushSize*brushSize)
+                {
+                    if ((point.x+i >= 0) && (point.y+ii >= 0) && (point.x+i < pictureImg->getSize().x) && (point.y+ii < pictureImg->getSize().y))
+                    {
+                        pictureImg->setPixel(point.x+i,point.y+ii,brushColor);
+                    }
+                }
+            }
+        }
+    }
+}
+
+sf::Color sfml::MainState::colorConvert(sf::Vector3f color)
+{
+	int i = 0;
+	float f = 0, p = 0, q = 0, t = 0;
+	sf::Color colorNew;
+	if (color.y == 0)
+    {
+		colorNew.r = color.z;
+		colorNew.g = color.z;
+		colorNew.b = color.z;
+    }
+    else
+    {
+        color.x /= 60;
+        i = floor(color.x);
+        f = color.x-i;
+        p = color.z*(1.0f-color.y);
+        q = color.z*(1.0f-(color.y*f));
+        t = color.z*(1.0f-(color.y*(1.0f-f)));
+        switch (i)
+        {
+        case 0:
+            colorNew.r = color.z*255;
+            colorNew.g = t*255;
+            colorNew.b = p*255;
+            break;
+        case 1:
+            colorNew.r = q*255;
+            colorNew.g = color.z*255;
+            colorNew.b = p*255;
+            break;
+        case 2:
+            colorNew.r = p*255;
+            colorNew.g = color.z*255;
+            colorNew.b = t*255;
+            break;
+        case 3:
+            colorNew.r = p*255;
+            colorNew.g = q*255;
+            colorNew.b = color.z*255;
+            break;
+        case 4:
+            colorNew.r = t*255;
+            colorNew.g = p*255;
+            colorNew.b = color.z*255;
+            break;
+        case 5:
+            colorNew.r = color.z*255;
+            colorNew.g = p*255;
+            colorNew.b = q*255;
+            break;
+        }
+    }
+    return colorNew;
+}
diff --git a/Trunk/src/State.cpp b/Trunk/src/State.cpp
new file mode 100644
index 000000000..59e16a180
--- /dev/null
+++ b/Trunk/src/State.cpp
@@ -0,0 +1,7 @@
+
+#include <State.hpp>
+
+sfml::State::State()
+{
+	
+}
diff --git a/Trunk/src/main.cpp b/Trunk/src/main.cpp
index e37d7da07..2b3ec54d2 100644
--- a/Trunk/src/main.cpp
+++ b/Trunk/src/main.cpp
@@ -1,4 +1,6 @@
 #include "native-lib.hpp"
+#include "MainState.hpp"
+#include <SFML/System/Vector2.hpp>
 
 int main(int argc, char *argv[])
 {
@@ -28,6 +30,11 @@ int main(int argc, char *argv[])
     // so we'll have to track that. You can do minor background
     // work, but keep battery life in mind.
     bool active = true;
+	
+	sf::Vector2i cursor;
+	sfml::MainState* mainState = new sfml::MainState();
+	mainState->window = sf::Vector2f(window.getSize());
+	mainState->enter();
 
     while (window.isOpen())
     {
@@ -64,21 +71,39 @@ int main(int argc, char *argv[])
                     active = true;
                     break;
                 case sf::Event::TouchBegan:
+					mainState->drawing = true;
                     if (event.touch.finger == 0)
                     {
                         vibrate(sf::milliseconds(10));
                     }
-                    break;
+					cursor.x = event.touch.x;
+					cursor.y = event.touch.y;
+					break;
+                case sf::Event::TouchMoved:
+					cursor.x = event.touch.x;
+					cursor.y = event.touch.y;
+					break;
+				case sf::Event::TouchEnded:
+					mainState->drawing = false;
+					cursor.x = event.touch.x;
+					cursor.y = event.touch.y;
+					break;
             }
         }
 
         if (active) {
+			mainState->cursor = sf::Vector2f(cursor);
+			mainState->update();
             window.clear(background);
+            window.draw(*(mainState->drawableStack));
             window.display();
         } else {
             sf::sleep(sf::milliseconds(100));
         }
     }
+	
+	mainState->exit();
+	delete mainState;
 
     // Detach thread again
     vm->DetachCurrentThread();
