diff --git a/TMessagesProj/build.gradle b/TMessagesProj/build.gradle
index 368114b52..e7913055d 100644
--- a/TMessagesProj/build.gradle
+++ b/TMessagesProj/build.gradle
@@ -119,7 +119,7 @@ android {
         }
     }
 
-    defaultConfig.versionCode = 1358
+    defaultConfig.versionCode = 1000
 
     sourceSets.debug {
         manifest.srcFile 'config/debug/AndroidManifest.xml'
@@ -268,7 +268,7 @@ android {
     defaultConfig {
         minSdkVersion rootProject.minSdkVersion
         targetSdkVersion rootProject.targetSdkVersion
-        versionName "4.9.1"
+        versionName "1.0.0"
 
         vectorDrawables.generatedDensities = ['mdpi', 'hdpi', 'xhdpi', 'xxhdpi']
 
diff --git a/TMessagesProj/src/main/AndroidManifest.xml b/TMessagesProj/src/main/AndroidManifest.xml
index 3254df97a..2c808cba3 100644
--- a/TMessagesProj/src/main/AndroidManifest.xml
+++ b/TMessagesProj/src/main/AndroidManifest.xml
@@ -278,6 +278,8 @@
                 android:taskAffinity="${applicationId}.voip_feedback"
                 android:theme="@style/Theme.TMessages.TransparentWithAlerts"/>
 
+        <activity android:name="org.telegram.ui.SplashActivity"/>
+
         <receiver
                 android:name="org.telegram.messenger.AutoMessageHeardReceiver"
                 android:exported="false">
@@ -515,8 +517,10 @@
         <meta-data android:name="com.urbanairship.autopilot"
                    android:value="com.urbanairship.Autopilot"/>
 
-        <activity android:name="org.telegram.ui.SplashActivity">
-        </activity>
+        <meta-data
+                android:name="firebase_crashlytics_collection_enabled"
+                android:value="false" />
+
     </application>
 
 </manifest>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/io/bettergram/service/CryptoDataService.java b/TMessagesProj/src/main/java/io/bettergram/service/CryptoDataService.java
index 556e23aa3..482e0b0bb 100644
--- a/TMessagesProj/src/main/java/io/bettergram/service/CryptoDataService.java
+++ b/TMessagesProj/src/main/java/io/bettergram/service/CryptoDataService.java
@@ -48,6 +48,7 @@ public CryptoDataService() {
 
     @Override
     public void onDestroy() {
+        mTimer.cancel();
         super.onDestroy();
     }
 
@@ -57,7 +58,11 @@ protected void onHandleIntent(@Nullable Intent intent) {
             mTimer.cancel();
         else
             mTimer = new Timer();   //recreate new
-        mTimer.scheduleAtFixedRate(new TimeDisplay(intent), 0, notify);   //Schedule task
+        try {
+            mTimer.scheduleAtFixedRate(new TimeDisplay(intent), 0, notify);   //Schedule task
+        } catch (IllegalStateException e) {
+            e.printStackTrace();
+        }
     }
 
     private List<CryptoCurrencyInfo> addIcons(List<CryptoCurrencyInfo> list, List<CryptoCurrency> currencies) {
@@ -74,11 +79,11 @@ protected void onHandleIntent(@Nullable Intent intent) {
         return list;
     }
 
-    interface Predicate<T> {
+    public interface Predicate<T> {
         boolean contains(T item);
     }
 
-    static class CollectionUtil {
+    public static class CollectionUtil {
 
         public static <T> T find(final Collection<T> collection, final Predicate<T> predicate) {
             for (T item : collection) {
diff --git a/TMessagesProj/src/main/java/io/bettergram/ui/adapters/CryptoAdapter.java b/TMessagesProj/src/main/java/io/bettergram/ui/adapters/CryptoAdapter.java
index e4e2bc02f..e864791bc 100644
--- a/TMessagesProj/src/main/java/io/bettergram/ui/adapters/CryptoAdapter.java
+++ b/TMessagesProj/src/main/java/io/bettergram/ui/adapters/CryptoAdapter.java
@@ -11,6 +11,8 @@
 import android.os.Bundle;
 import android.support.annotation.NonNull;
 import android.support.v4.content.ContextCompat;
+import android.support.v4.view.PagerAdapter;
+import android.support.v4.view.ViewPager;
 import android.text.SpannableStringBuilder;
 import android.text.TextUtils;
 import android.text.style.ForegroundColorSpan;
@@ -35,9 +37,11 @@
 import org.telegram.messenger.support.widget.RecyclerView;
 import org.telegram.ui.ActionBar.Theme;
 import org.telegram.ui.Components.LayoutHelper;
+import org.telegram.ui.Components.TabStrip.SlidingTabLayout;
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
 
 import static android.text.TextUtils.isEmpty;
@@ -94,17 +98,12 @@ public void setCrypto(String crypto) {
 
         MainViewHolder(@NonNull View itemView) {
             super(itemView);
-            //imageCrypto = itemView.findViewById(R.id.imageCrypto);
             imageCrypto = itemView.findViewWithTag("imageCrypto");
-            //textCryptoName = itemView.findViewById(R.id.textCryptoName);
             textCryptoName = itemView.findViewWithTag("textCryptoName");
-            //textCryptoPrice = itemView.findViewById(R.id.textCryptoPrice);
             textCryptoPrice = itemView.findViewWithTag("textCryptoPrice");
-            //textDayDelta = itemView.findViewById(R.id.textDayDelta);
             textDayDelta = itemView.findViewWithTag("textDayDelta");
 
             Activity activity = (Activity) itemView.getContext();
-            //ShineButton star = itemView.findViewById(R.id.star);
             star = itemView.findViewWithTag("star");
             if (star.activity == null) {
                 star.init(activity);
@@ -121,6 +120,16 @@ public void onCheckedChanged(View view, boolean checked) {
                     break;
                 }
             }
+            backup.clear();
+            backup.addAll(data);
+            favorites.clear();
+            favorites.addAll(data);
+            for (Iterator<CryptoCurrencyInfo> iterator = favorites.iterator(); iterator.hasNext(); ) {
+                CryptoCurrencyInfo value = iterator.next();
+                if (!value.favorite) {
+                    iterator.remove();
+                }
+            }
         }
     }
 
@@ -136,6 +145,12 @@ public void onCheckedChanged(View view, boolean checked) {
         }
     }
 
+    class TabsViewHolder extends RecyclerView.ViewHolder {
+        public TabsViewHolder(View itemView) {
+            super(itemView);
+        }
+    }
+
     class LabelViewHolder extends RecyclerView.ViewHolder {
         public LabelViewHolder(View itemView) {
             super(itemView);
@@ -145,11 +160,10 @@ public LabelViewHolder(View itemView) {
     private CryptoCurrencyInfoResponse cryptoData;
 
     private List<CryptoCurrencyInfo> data = new ArrayList<>();
+    private List<CryptoCurrencyInfo> backup = new ArrayList<>();
+    private List<CryptoCurrencyInfo> favorites = new ArrayList<>();
 
     public CryptoAdapter() {
-        for (int i = 0; i < 100; i++) {
-            data.add(new CryptoCurrencyInfo());
-        }
     }
 
     public void setCryptoData(CryptoCurrencyInfoResponse cryptoData) {
@@ -159,15 +173,26 @@ public void setCryptoData(CryptoCurrencyInfoResponse cryptoData) {
                 data.clear();
                 data.addAll(cryptoData.data.favorites);
                 data.addAll(cryptoData.data.list);
+                backup.clear();
+                backup.addAll(data);
+                favorites.clear();
+                favorites.addAll(data);
+                for (Iterator<CryptoCurrencyInfo> iterator = favorites.iterator(); iterator.hasNext(); ) {
+                    CryptoCurrencyInfo value = iterator.next();
+                    if (!value.favorite) {
+                        iterator.remove();
+                    }
+                }
             }
         }
     }
 
     @Override
     public int getItemViewType(int position) {
-        return position == 0 ? 0 : position == 1 ? 1 : 2;
+        return position == 0 ? 0 : position == 1 ? 1 : position == 2 ? 2 : 3;
     }
 
+
     @NonNull
     @Override
     public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
@@ -175,10 +200,36 @@ public int getItemViewType(int position) {
         LayoutInflater inflater = LayoutInflater.from(context);
         switch (viewType) {
             case 0:
-                return new HeaderViewHolder(inflater.inflate(R.layout.header_crypto, parent, false));
+                View header = inflater.inflate(R.layout.header_crypto, parent, false);
+                return new HeaderViewHolder(header);
             case 1:
-                return new LabelViewHolder(inflater.inflate(R.layout.item_crypto_top, parent, false));
+                SlidingTabLayout tabLayout = new SlidingTabLayout(context);
+                tabLayout.setAdapter(new TabsPagerAdapter());
+                tabLayout.setDividerColors(context.getResources().getColor(android.R.color.transparent));
+                tabLayout.setSelectedIndicatorColors(context.getResources().getColor(R.color.actionBarDefault));
+                tabLayout.setOnPageChangeListener(new ViewPager.SimpleOnPageChangeListener() {
+                    @Override
+                    public void onPageSelected(int position) {
+                        super.onPageSelected(position);
+                        switch (position) {
+                            case 0:
+                                data.clear();
+                                data.addAll(backup);
+                                notifyDataSetChanged();
+                                break;
+                            case 1:
+                                data.clear();
+                                data.addAll(favorites);
+                                notifyDataSetChanged();
+                                break;
+                        }
+                    }
+                });
+                tabLayout.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
+                return new TabsViewHolder(tabLayout);
             case 2:
+                return new LabelViewHolder(inflater.inflate(R.layout.item_crypto_top, parent, false));
+            case 3:
                 LinearLayout content = new LinearLayout(context);
                 content.setOrientation(LinearLayout.HORIZONTAL);
                 content.setWeightSum(1);
@@ -249,7 +300,7 @@ public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int positi
         } else if (holder instanceof LabelViewHolder) {
 
         } else if (holder instanceof MainViewHolder) {
-            int realPosition = position - 2;
+            int realPosition = position - 3;
             CryptoCurrencyInfo info = data.get(realPosition);
 
             MainViewHolder main = (MainViewHolder) holder;
@@ -284,7 +335,7 @@ public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int positi
 
     @Override
     public int getItemCount() {
-        return data.size() + 2;
+        return data.size() + 3;
     }
 
     /**
@@ -326,4 +377,34 @@ public void registerReceiver(Activity activity) {
     public void unregisterReceiver(Activity activity) {
         activity.unregisterReceiver(receiver);
     }
+
+    class TabsPagerAdapter extends PagerAdapter {
+
+        final String[] ITEMS = {"All", "Favorites"};
+
+        /**
+         * @return the number of pages to display
+         */
+        @Override
+        public int getCount() {
+            return ITEMS.length;
+        }
+
+        @Override
+        public boolean isViewFromObject(View view, Object o) {
+            return o == view;
+        }
+
+
+        @Override
+        public CharSequence getPageTitle(int position) {
+            return ITEMS[position];
+        }
+
+        @Override
+        public void destroyItem(ViewGroup container, int position, Object object) {
+            container.removeView((View) object);
+        }
+
+    }
 }
diff --git a/TMessagesProj/src/main/java/io/bettergram/ui/adapters/YouTubePlayerAdapter.java b/TMessagesProj/src/main/java/io/bettergram/ui/adapters/YouTubePlayerAdapter.java
index 8ef00c001..aa2c6d3a2 100644
--- a/TMessagesProj/src/main/java/io/bettergram/ui/adapters/YouTubePlayerAdapter.java
+++ b/TMessagesProj/src/main/java/io/bettergram/ui/adapters/YouTubePlayerAdapter.java
@@ -98,7 +98,7 @@ public void run() {
                 .load(url)
                 .resize(width, height)
                 .centerCrop()
-                .placeholder(R.color.grey70)
+                .placeholder(R.drawable.photoview_placeholder)
                 .into(imageView);
     };
 
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java b/TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java
index 72c757d90..6d75e0c3d 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java
@@ -9,6 +9,7 @@
 package org.telegram.messenger;
 
 import android.annotation.SuppressLint;
+import android.app.Activity;
 import android.app.AlarmManager;
 import android.app.Application;
 import android.app.PendingIntent;
@@ -22,6 +23,7 @@
 import com.google.android.gms.common.ConnectionResult;
 import com.google.android.gms.common.GooglePlayServicesUtil;
 import com.google.firebase.iid.FirebaseInstanceId;
+import io.bettergram.service.CryptoDataService;
 import io.fabric.sdk.android.Fabric;
 import org.telegram.tgnet.ConnectionsManager;
 import org.telegram.tgnet.TLRPC;
@@ -29,6 +31,8 @@
 
 import java.io.File;
 
+import static io.bettergram.service.CryptoDataService.EXTRA_LIMIT;
+
 public class ApplicationLoader extends Application {
 
     @SuppressLint("StaticFieldLeak")
@@ -124,7 +128,11 @@ public static void postInitApplication() {
     public void onCreate() {
         super.onCreate();
 
-        Fabric.with(this, Crashlytics.getInstance());
+        final Fabric fabric = new Fabric.Builder(this)
+                .kits(new Crashlytics())
+                .debuggable(true)  // Enables Crashlytics debugger
+                .build();
+        Fabric.with(fabric);
 
         applicationContext = getApplicationContext();
         NativeLoader.initNativeLibs(ApplicationLoader.applicationContext);
@@ -208,4 +216,10 @@ private boolean checkPlayServices() {
         }
         return true;
     }
+
+    public static void warmupCryptos(Activity activity) {
+        Intent intent = new Intent(activity, CryptoDataService.class);
+        intent.putExtra(EXTRA_LIMIT, 100);
+        activity.startService(intent);
+    }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/TabStrip/SlidingTabLayout.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/TabStrip/SlidingTabLayout.java
new file mode 100644
index 000000000..55656d17c
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/TabStrip/SlidingTabLayout.java
@@ -0,0 +1,328 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.ui.Components.TabStrip;
+
+import android.content.Context;
+import android.graphics.Typeface;
+import android.os.Build;
+import android.support.v4.view.PagerAdapter;
+import android.support.v4.view.ViewPager;
+import android.util.AttributeSet;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.view.LayoutInflater;
+import android.view.MotionEvent;
+import android.view.View;
+import android.widget.HorizontalScrollView;
+import android.widget.TextView;
+
+/**
+ * To be used with ViewPager to provide a tab indicator component which give constant feedback as to
+ * the user's scroll progress.
+ * <p>
+ * To use the component, simply add it to your view hierarchy. Then in your
+ * {@link android.app.Activity} or {@link android.app.Fragment} call
+ * {@link #setViewPager(ViewPager)} providing it the ViewPager this layout is being used for.
+ * <p>
+ * The colors can be customized in two ways. The first and simplest is to provide an array of colors
+ * via {@link #setSelectedIndicatorColors(int...)} and {@link #setDividerColors(int...)}. The
+ * alternative is via the {@link TabColorizer} interface which provides you complete control over
+ * which color is used for any individual position.
+ * <p>
+ * The views used as tabs can be customized by calling {@link #setCustomTabView(int, int)},
+ * providing the layout ID of your custom layout.
+ */
+public class SlidingTabLayout extends HorizontalScrollView {
+
+    /**
+     * Allows complete control over the colors drawn in the tab layout. Set with
+     * {@link #setCustomTabColorizer(TabColorizer)}.
+     */
+    public interface TabColorizer {
+
+        /**
+         * @return return the color of the indicator used when {@code position} is selected.
+         */
+        int getIndicatorColor(int position);
+
+        /**
+         * @return return the color of the divider drawn to the right of {@code position}.
+         */
+        int getDividerColor(int position);
+
+    }
+
+    private static final int TITLE_OFFSET_DIPS = 24;
+    private static final int TAB_VIEW_PADDING_DIPS = 16;
+    private static final int TAB_VIEW_TEXT_SIZE_SP = 14;
+
+    private int mTitleOffset;
+
+    private int mTabViewLayoutId;
+    private int mTabViewTextViewId;
+
+    private ViewPager mViewPager;
+    private ViewPager.OnPageChangeListener mViewPagerPageChangeListener;
+
+    private final SlidingTabStrip mTabStrip;
+
+    public SlidingTabLayout(Context context) {
+        this(context, null);
+    }
+
+    public SlidingTabLayout(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public SlidingTabLayout(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+
+        // Disable the Scroll Bar
+        setHorizontalScrollBarEnabled(false);
+        // Make sure that the Tab Strips fills this View
+        setFillViewport(true);
+
+        mTitleOffset = (int) (TITLE_OFFSET_DIPS * getResources().getDisplayMetrics().density);
+
+        mTabStrip = new SlidingTabStrip(context);
+        addView(mTabStrip, LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
+    }
+
+    /**
+     * Set the custom {@link TabColorizer} to be used.
+     * <p>
+     * If you only require simple custmisation then you can use
+     * {@link #setSelectedIndicatorColors(int...)} and {@link #setDividerColors(int...)} to achieve
+     * similar effects.
+     */
+    public void setCustomTabColorizer(TabColorizer tabColorizer) {
+        mTabStrip.setCustomTabColorizer(tabColorizer);
+    }
+
+    /**
+     * Sets the colors to be used for indicating the selected tab. These colors are treated as a
+     * circular array. Providing one color will mean that all tabs are indicated with the same color.
+     */
+    public void setSelectedIndicatorColors(int... colors) {
+        mTabStrip.setSelectedIndicatorColors(colors);
+    }
+
+    /**
+     * Sets the colors to be used for tab dividers. These colors are treated as a circular array.
+     * Providing one color will mean that all tabs are indicated with the same color.
+     */
+    public void setDividerColors(int... colors) {
+        mTabStrip.setDividerColors(colors);
+    }
+
+    /**
+     * Set the {@link ViewPager.OnPageChangeListener}. When using {@link SlidingTabLayout} you are
+     * required to set any {@link ViewPager.OnPageChangeListener} through this method. This is so
+     * that the layout can update it's scroll position correctly.
+     *
+     * @see ViewPager#setOnPageChangeListener(ViewPager.OnPageChangeListener)
+     */
+    public void setOnPageChangeListener(ViewPager.OnPageChangeListener listener) {
+        mViewPagerPageChangeListener = listener;
+    }
+
+    /**
+     * Set the custom layout to be inflated for the tab views.
+     *
+     * @param layoutResId Layout id to be inflated
+     * @param textViewId  id of the {@link TextView} in the inflated view
+     */
+    public void setCustomTabView(int layoutResId, int textViewId) {
+        mTabViewLayoutId = layoutResId;
+        mTabViewTextViewId = textViewId;
+    }
+
+    /**
+     * Sets the associated view pager. Note that the assumption here is that the pager content
+     * (number of tabs and tab titles) does not change after this call has been made.
+     */
+    public void setAdapter(PagerAdapter adapter) {
+        mTabStrip.removeAllViews();
+
+        //mViewPager = viewPager;
+        mViewPager = new ViewPager(getContext()) {
+            @Override
+            public boolean onInterceptTouchEvent(MotionEvent ev) {
+                if (getParent() != null) {
+                    getParent().requestDisallowInterceptTouchEvent(true);
+                }
+                return super.onInterceptTouchEvent(ev);
+            }
+        };
+        mViewPager.setAdapter(adapter);
+        if (mViewPager != null) {
+            mViewPager.setOnPageChangeListener(new InternalViewPagerListener());
+            populateTabStrip();
+        }
+    }
+
+    /**
+     * Create a default view to be used for tabs. This is called if a custom tab view is not set via
+     * {@link #setCustomTabView(int, int)}.
+     */
+    protected TextView createDefaultTabView(Context context) {
+        TextView textView = new TextView(context);
+        textView.setGravity(Gravity.CENTER);
+        textView.setTextSize(TypedValue.COMPLEX_UNIT_SP, TAB_VIEW_TEXT_SIZE_SP);
+        textView.setTypeface(Typeface.DEFAULT_BOLD);
+        textView.setAllCaps(false);
+        textView.setTypeface(textView.getTypeface(), Typeface.BOLD);
+        textView.setTextColor(getResources().getColor(android.R.color.black));
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
+            // If we're running on Honeycomb or newer, then we can use the Theme's
+            // selectableItemBackground to ensure that the View has a pressed state
+            TypedValue outValue = new TypedValue();
+            getContext().getTheme().resolveAttribute(android.R.attr.selectableItemBackground,
+                    outValue, true);
+            textView.setBackgroundResource(outValue.resourceId);
+        }
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
+            // If we're running on ICS or newer, enable all-caps to match the Action Bar tab style
+            //textView.setAllCaps(true);
+        }
+
+        int padding = (int) (TAB_VIEW_PADDING_DIPS * getResources().getDisplayMetrics().density);
+        textView.setPadding(padding, padding, padding, padding);
+
+        return textView;
+    }
+
+    private void populateTabStrip() {
+        final PagerAdapter adapter = mViewPager.getAdapter();
+        final View.OnClickListener tabClickListener = new TabClickListener();
+
+        for (int i = 0; i < adapter.getCount(); i++) {
+            View tabView = null;
+            TextView tabTitleView = null;
+
+            if (mTabViewLayoutId != 0) {
+                // If there is a custom tab view layout id set, try and inflate it
+                tabView = LayoutInflater.from(getContext()).inflate(mTabViewLayoutId, mTabStrip,
+                        false);
+                tabTitleView = (TextView) tabView.findViewById(mTabViewTextViewId);
+            }
+
+            if (tabView == null) {
+                tabView = createDefaultTabView(getContext());
+            }
+
+            if (tabTitleView == null && TextView.class.isInstance(tabView)) {
+                tabTitleView = (TextView) tabView;
+            }
+
+            tabTitleView.setText(adapter.getPageTitle(i));
+            tabView.setOnClickListener(tabClickListener);
+
+            mTabStrip.addView(tabView);
+        }
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+
+        if (mViewPager != null) {
+            scrollToTab(mViewPager.getCurrentItem(), 0);
+        }
+    }
+
+    private void scrollToTab(int tabIndex, int positionOffset) {
+        final int tabStripChildCount = mTabStrip.getChildCount();
+        if (tabStripChildCount == 0 || tabIndex < 0 || tabIndex >= tabStripChildCount) {
+            return;
+        }
+
+        View selectedChild = mTabStrip.getChildAt(tabIndex);
+        if (selectedChild != null) {
+            int targetScrollX = selectedChild.getLeft() + positionOffset;
+
+            if (tabIndex > 0 || positionOffset > 0) {
+                // If we're not at the first child and are mid-scroll, make sure we obey the offset
+                targetScrollX -= mTitleOffset;
+            }
+
+            scrollTo(targetScrollX, 0);
+        }
+    }
+
+    private class InternalViewPagerListener implements ViewPager.OnPageChangeListener {
+        private int mScrollState;
+
+        @Override
+        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
+            int tabStripChildCount = mTabStrip.getChildCount();
+            if ((tabStripChildCount == 0) || (position < 0) || (position >= tabStripChildCount)) {
+                return;
+            }
+
+            mTabStrip.onViewPagerPageChanged(position, positionOffset);
+
+            View selectedTitle = mTabStrip.getChildAt(position);
+            int extraOffset = (selectedTitle != null)
+                    ? (int) (positionOffset * selectedTitle.getWidth())
+                    : 0;
+            scrollToTab(position, extraOffset);
+
+            if (mViewPagerPageChangeListener != null) {
+                mViewPagerPageChangeListener.onPageScrolled(position, positionOffset,
+                        positionOffsetPixels);
+            }
+        }
+
+        @Override
+        public void onPageScrollStateChanged(int state) {
+            mScrollState = state;
+
+            if (mViewPagerPageChangeListener != null) {
+                mViewPagerPageChangeListener.onPageScrollStateChanged(state);
+            }
+        }
+
+        @Override
+        public void onPageSelected(int position) {
+            if (mScrollState == ViewPager.SCROLL_STATE_IDLE) {
+                mTabStrip.onViewPagerPageChanged(position, 0f);
+                scrollToTab(position, 0);
+            }
+
+            if (mViewPagerPageChangeListener != null) {
+                mViewPagerPageChangeListener.onPageSelected(position);
+            }
+        }
+
+    }
+
+    private class TabClickListener implements View.OnClickListener {
+        @Override
+        public void onClick(View v) {
+            for (int i = 0; i < mTabStrip.getChildCount(); i++) {
+                if (v == mTabStrip.getChildAt(i)) {
+                    mViewPager.setCurrentItem(i);
+                    return;
+                }
+            }
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/TabStrip/SlidingTabStrip.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/TabStrip/SlidingTabStrip.java
new file mode 100644
index 000000000..9d1594749
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/TabStrip/SlidingTabStrip.java
@@ -0,0 +1,206 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.telegram.ui.Components.TabStrip;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.util.AttributeSet;
+import android.util.TypedValue;
+import android.view.View;
+import android.widget.LinearLayout;
+
+public class SlidingTabStrip extends LinearLayout {
+
+    private static final int DEFAULT_BOTTOM_BORDER_THICKNESS_DIPS = 1;
+    private static final byte DEFAULT_BOTTOM_BORDER_COLOR_ALPHA = 0x26;
+    private static final int SELECTED_INDICATOR_THICKNESS_DIPS = 8;
+    private static final int DEFAULT_SELECTED_INDICATOR_COLOR = 0xFF33B5E5;
+
+    private static final int DEFAULT_DIVIDER_THICKNESS_DIPS = 1;
+    private static final byte DEFAULT_DIVIDER_COLOR_ALPHA = 0x20;
+    private static final float DEFAULT_DIVIDER_HEIGHT = 0.5f;
+
+    private final int mBottomBorderThickness;
+    private final Paint mBottomBorderPaint;
+
+    private final int mSelectedIndicatorThickness;
+    private final Paint mSelectedIndicatorPaint;
+
+    private final int mDefaultBottomBorderColor;
+
+    private final Paint mDividerPaint;
+    private final float mDividerHeight;
+
+    private int mSelectedPosition;
+    private float mSelectionOffset;
+
+    private SlidingTabLayout.TabColorizer mCustomTabColorizer;
+    private final SimpleTabColorizer mDefaultTabColorizer;
+
+    SlidingTabStrip(Context context) {
+        this(context, null);
+    }
+
+    SlidingTabStrip(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        setWillNotDraw(false);
+
+        final float density = getResources().getDisplayMetrics().density;
+
+        TypedValue outValue = new TypedValue();
+        context.getTheme().resolveAttribute(android.R.attr.colorForeground, outValue, true);
+        final int themeForegroundColor = outValue.data;
+
+        mDefaultBottomBorderColor = setColorAlpha(themeForegroundColor,
+                DEFAULT_BOTTOM_BORDER_COLOR_ALPHA);
+
+        mDefaultTabColorizer = new SimpleTabColorizer();
+        mDefaultTabColorizer.setIndicatorColors(DEFAULT_SELECTED_INDICATOR_COLOR);
+        mDefaultTabColorizer.setDividerColors(setColorAlpha(themeForegroundColor,
+                DEFAULT_DIVIDER_COLOR_ALPHA));
+
+        mBottomBorderThickness = (int) (DEFAULT_BOTTOM_BORDER_THICKNESS_DIPS * density);
+        mBottomBorderPaint = new Paint();
+        mBottomBorderPaint.setColor(mDefaultBottomBorderColor);
+
+        mSelectedIndicatorThickness = (int) (SELECTED_INDICATOR_THICKNESS_DIPS * density);
+        mSelectedIndicatorPaint = new Paint();
+
+        mDividerHeight = DEFAULT_DIVIDER_HEIGHT;
+        mDividerPaint = new Paint();
+        mDividerPaint.setStrokeWidth((int) (DEFAULT_DIVIDER_THICKNESS_DIPS * density));
+    }
+
+    void setCustomTabColorizer(SlidingTabLayout.TabColorizer customTabColorizer) {
+        mCustomTabColorizer = customTabColorizer;
+        invalidate();
+    }
+
+    void setSelectedIndicatorColors(int... colors) {
+        // Make sure that the custom colorizer is removed
+        mCustomTabColorizer = null;
+        mDefaultTabColorizer.setIndicatorColors(colors);
+        invalidate();
+    }
+
+    void setDividerColors(int... colors) {
+        // Make sure that the custom colorizer is removed
+        mCustomTabColorizer = null;
+        mDefaultTabColorizer.setDividerColors(colors);
+        invalidate();
+    }
+
+    void onViewPagerPageChanged(int position, float positionOffset) {
+        mSelectedPosition = position;
+        mSelectionOffset = positionOffset;
+        invalidate();
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        final int height = getHeight();
+        final int childCount = getChildCount();
+        final int dividerHeightPx = (int) (Math.min(Math.max(0f, mDividerHeight), 1f) * height);
+        final SlidingTabLayout.TabColorizer tabColorizer = mCustomTabColorizer != null
+                ? mCustomTabColorizer
+                : mDefaultTabColorizer;
+
+        // Thick colored underline below the current selection
+        if (childCount > 0) {
+            View selectedTitle = getChildAt(mSelectedPosition);
+            int left = selectedTitle.getLeft();
+            int right = selectedTitle.getRight();
+            int color = tabColorizer.getIndicatorColor(mSelectedPosition);
+
+            if (mSelectionOffset > 0f && mSelectedPosition < (getChildCount() - 1)) {
+                int nextColor = tabColorizer.getIndicatorColor(mSelectedPosition + 1);
+                if (color != nextColor) {
+                    color = blendColors(nextColor, color, mSelectionOffset);
+                }
+
+                // Draw the selection partway between the tabs
+                View nextTitle = getChildAt(mSelectedPosition + 1);
+                left = (int) (mSelectionOffset * nextTitle.getLeft() +
+                        (1.0f - mSelectionOffset) * left);
+                right = (int) (mSelectionOffset * nextTitle.getRight() +
+                        (1.0f - mSelectionOffset) * right);
+            }
+
+            mSelectedIndicatorPaint.setColor(color);
+
+            canvas.drawRect(left, height - mSelectedIndicatorThickness, right,
+                    height, mSelectedIndicatorPaint);
+        }
+
+        // Thin underline along the entire bottom edge
+        canvas.drawRect(0, height - mBottomBorderThickness, getWidth(), height, mBottomBorderPaint);
+
+        // Vertical separators between the titles
+        int separatorTop = (height - dividerHeightPx) / 2;
+        for (int i = 0; i < childCount - 1; i++) {
+            View child = getChildAt(i);
+            mDividerPaint.setColor(tabColorizer.getDividerColor(i));
+            canvas.drawLine(child.getRight(), separatorTop, child.getRight(),
+                    separatorTop + dividerHeightPx, mDividerPaint);
+        }
+    }
+
+    /**
+     * Set the alpha value of the {@code color} to be the given {@code alpha} value.
+     */
+    private static int setColorAlpha(int color, byte alpha) {
+        return Color.argb(alpha, Color.red(color), Color.green(color), Color.blue(color));
+    }
+
+    /**
+     * Blend {@code color1} and {@code color2} using the given ratio.
+     *
+     * @param ratio of which to blend. 1.0 will return {@code color1}, 0.5 will give an even blend,
+     *              0.0 will return {@code color2}.
+     */
+    private static int blendColors(int color1, int color2, float ratio) {
+        final float inverseRation = 1f - ratio;
+        float r = (Color.red(color1) * ratio) + (Color.red(color2) * inverseRation);
+        float g = (Color.green(color1) * ratio) + (Color.green(color2) * inverseRation);
+        float b = (Color.blue(color1) * ratio) + (Color.blue(color2) * inverseRation);
+        return Color.rgb((int) r, (int) g, (int) b);
+    }
+
+    private static class SimpleTabColorizer implements SlidingTabLayout.TabColorizer {
+        private int[] mIndicatorColors;
+        private int[] mDividerColors;
+
+        @Override
+        public final int getIndicatorColor(int position) {
+            return mIndicatorColors[position % mIndicatorColors.length];
+        }
+
+        @Override
+        public final int getDividerColor(int position) {
+            return mDividerColors[position % mDividerColors.length];
+        }
+
+        void setIndicatorColors(int... colors) {
+            mIndicatorColors = colors;
+        }
+
+        void setDividerColors(int... colors) {
+            mDividerColors = colors;
+        }
+    }
+}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/LaunchActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/LaunchActivity.java
index a525e5f52..eae5031fb 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/LaunchActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/LaunchActivity.java
@@ -106,6 +106,7 @@
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         ApplicationLoader.postInitApplication();
+        ApplicationLoader.warmupCryptos(this);
         AndroidUtilities.checkDisplaySize(this, getResources().getConfiguration());
         currentAccount = UserConfig.selectedAccount;
         if (!UserConfig.getInstance(currentAccount).isClientActivated()) {
diff --git a/TMessagesProj/src/main/res/layout/header_crypto.xml b/TMessagesProj/src/main/res/layout/header_crypto.xml
index e0fc1f20a..faf66a84a 100644
--- a/TMessagesProj/src/main/res/layout/header_crypto.xml
+++ b/TMessagesProj/src/main/res/layout/header_crypto.xml
@@ -11,42 +11,34 @@
         app:cardCornerRadius="4dp"
         app:cardUseCompatPadding="true"
         android:elevation="2dp">
-
     <LinearLayout
-            android:orientation="vertical"
+            android:layout_marginTop="16dp"
+            android:layout_marginBottom="16dp"
             android:layout_width="match_parent"
-            android:layout_height="wrap_content">
-
-        <LinearLayout
-                android:layout_marginTop="16dp"
-                android:layout_marginBottom="16dp"
-                android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:orientation="horizontal">
+        <TextView
+                android:id="@+id/textCap"
+                android:layout_width="0dp"
                 android:layout_height="wrap_content"
-                android:orientation="horizontal">
-            <TextView
-                    android:id="@+id/textCap"
-                    android:layout_width="0dp"
-                    android:layout_height="wrap_content"
-                    android:layout_weight="1"
-                    android:gravity="center"
-                    android:textSize="18sp"/>
-
-            <TextView
-                    android:id="@+id/textDom"
-                    android:layout_width="0dp"
-                    android:layout_height="wrap_content"
-                    android:layout_weight="1"
-                    android:gravity="center"
-                    android:textSize="18sp"/>
+                android:layout_weight="1"
+                android:gravity="center"
+                android:textSize="18sp"/>
 
-            <TextView
-                    android:id="@+id/textVol"
-                    android:layout_width="0dp"
-                    android:layout_height="wrap_content"
-                    android:layout_weight="1"
-                    android:gravity="center"
-                    android:textSize="18sp"/>
-        </LinearLayout>
+        <TextView
+                android:id="@+id/textDom"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:gravity="center"
+                android:textSize="18sp"/>
 
+        <TextView
+                android:id="@+id/textVol"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:gravity="center"
+                android:textSize="18sp"/>
     </LinearLayout>
 </org.telegram.ui.Components.CardView.CardView>
\ No newline at end of file
