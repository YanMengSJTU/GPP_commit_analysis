diff --git a/TMessagesProj/build.gradle b/TMessagesProj/build.gradle
index bebc4be90..9e72dca29 100644
--- a/TMessagesProj/build.gradle
+++ b/TMessagesProj/build.gradle
@@ -5,13 +5,17 @@ repositories {
 }
 
 dependencies {
-    compile 'com.android.support:support-v4:23.2.1'
-    compile "com.google.android.gms:play-services-gcm:8.4.0"
-    compile "com.google.android.gms:play-services-maps:8.4.0"
-    compile 'net.hockeyapp.android:HockeySDK:3.6.+'
-    compile 'com.googlecode.mp4parser:isoparser:1.0.+'
+
     compile files('libs/org.eclipse.paho.android.service-1.0.2.jar')
     compile files('libs/org.eclipse.paho.client.mqttv3-1.0.2.jar')
+    compile files('libs/eventbus-2.4.0.jar')
+    compile files('libs/android-priority-jobqueue-1.3.1.jar')
+
+   compile 'com.android.support:support-v4:23.2.1'
+   compile "com.google.android.gms:play-services-gcm:8.4.0"
+   compile "com.google.android.gms:play-services-maps:8.4.0"
+   compile 'net.hockeyapp.android:HockeySDK:3.6.+'
+   compile 'com.googlecode.mp4parser:isoparser:1.0.+'
 }
 
 android {
@@ -123,4 +127,13 @@ android {
         javaMaxHeapSize "4g"
     }
 
+
+    packagingOptions {
+        exclude 'META-INF/LICENSE.txt'
+        exclude 'META-INF/NOTICE.txt'
+        exclude 'META-INF/ECLIPSE_.SF'
+        exclude 'META-INF/ECLIPSE_.RSA'
+    }
+
+
 }
diff --git a/TMessagesProj/libs/android-priority-jobqueue-1.3.1.jar b/TMessagesProj/libs/android-priority-jobqueue-1.3.1.jar
new file mode 100644
index 000000000..c56fba0e1
Binary files /dev/null and b/TMessagesProj/libs/android-priority-jobqueue-1.3.1.jar differ
diff --git a/TMessagesProj/libs/armeabi-v7a/libtmessages.20.so b/TMessagesProj/libs/armeabi-v7a/libtmessages.20.so
new file mode 100644
index 000000000..228a397e2
Binary files /dev/null and b/TMessagesProj/libs/armeabi-v7a/libtmessages.20.so differ
diff --git a/TMessagesProj/libs/armeabi/libtmessages.20.so b/TMessagesProj/libs/armeabi/libtmessages.20.so
new file mode 100644
index 000000000..fca44aab6
Binary files /dev/null and b/TMessagesProj/libs/armeabi/libtmessages.20.so differ
diff --git a/TMessagesProj/libs/eventbus-2.4.0.jar b/TMessagesProj/libs/eventbus-2.4.0.jar
new file mode 100644
index 000000000..fd5ae2633
Binary files /dev/null and b/TMessagesProj/libs/eventbus-2.4.0.jar differ
diff --git a/TMessagesProj/libs/x86/libtmessages.20.so b/TMessagesProj/libs/x86/libtmessages.20.so
new file mode 100644
index 000000000..98e954fdf
Binary files /dev/null and b/TMessagesProj/libs/x86/libtmessages.20.so differ
diff --git a/TMessagesProj/proguard-rules.pro b/TMessagesProj/proguard-rules.pro
index cc87272f6..8b018a479 100644
--- a/TMessagesProj/proguard-rules.pro
+++ b/TMessagesProj/proguard-rules.pro
@@ -5,4 +5,8 @@
 }
 -dontwarn com.google.android.gms.**
 -dontwarn com.google.common.cache.**
--dontwarn com.google.common.primitives.**
\ No newline at end of file
+-dontwarn com.google.common.primitives.**
+
+-keep class org.eclipse.paho.android.** { *; }
+-keep class org.eclipse.paho.client.** { *; }
+-keep class org.eclipse.paho.** { *; }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java b/TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java
index 944477f0d..25e239b03 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java
@@ -26,10 +26,12 @@
 import android.os.Handler;
 import android.os.PowerManager;
 import android.util.Base64;
+import android.util.Log;
 
 import com.google.android.gms.common.ConnectionResult;
 import com.google.android.gms.common.GooglePlayServicesUtil;
 
+import org.telegram.messenger.mqtt.MQTTService;
 import org.telegram.tgnet.ConnectionsManager;
 import org.telegram.tgnet.SerializedData;
 import org.telegram.tgnet.TLRPC;
@@ -40,6 +42,12 @@
 import java.util.ArrayList;
 import java.util.Locale;
 
+//reza_ak
+import com.path.android.jobqueue.JobManager;
+
+
+
+
 public class ApplicationLoader extends Application {
 
     private static Drawable cachedWallpaper;
@@ -47,12 +55,16 @@
     private static boolean isCustomTheme;
     private static final Object sync = new Object();
 
+
     public static volatile Context applicationContext;
     public static volatile Handler applicationHandler;
     private static volatile boolean applicationInited = false;
 
     public static volatile boolean isScreenOn = false;
     public static volatile boolean mainInterfacePaused = true;
+//reza_ak
+    private static JobManager jobManager;
+    private static ApplicationLoader instance;
 
     public static boolean isCustomTheme() {
         return isCustomTheme;
@@ -259,6 +271,9 @@ public static void postInitApplication() {
     @Override
     public void onCreate() {
         super.onCreate();
+        //reza_ak
+        configureJobManager();
+
 
         if (Build.VERSION.SDK_INT < 11) {
             java.lang.System.setProperty("java.net.preferIPv4Stack", "true");
@@ -276,6 +291,10 @@ public void onCreate() {
         applicationHandler = new Handler(applicationContext.getMainLooper());
 
         startPushService();
+
+        //reza_ak
+        Intent backgroundService = new Intent(this, MQTTService.class);
+        startService(backgroundService);
     }
 
     public static void startPushService() {
@@ -350,4 +369,54 @@ private boolean checkPlayServices() {
         }
         return true;*/
     }
+    //reza_ak
+    private void configureJobManager() {
+      /*Configuration configuration = new Configuration.Builder(this)
+                .customLogger(new CustomLogger() {
+                    private static final String TAG = "JOBS";
+
+                    @Override
+                    public boolean isDebugEnabled() {
+                        return true;
+                    }
+
+                    @Override
+                    public void d(String text, Object... args) {
+                        Log.d(TAG, String.format(text, args));
+                    }
+
+                    @Override
+                    public void e(Throwable t, String text, Object... args) {
+                        Log.e(TAG, String.format(text, args), t);
+                    }
+
+                    @Override
+                    public void e(String text, Object... args) {
+                        Log.e(TAG, String.format(text, args));
+                    }
+                }).minConsumerCount(5)// always keep at least five consumer
+                // alive
+                .maxConsumerCount(10)// up to 10 consumers at a time
+                .loadFactor(3)// 3 jobs per consumer
+                .consumerKeepAlive(120)// wait 2 minute
+                .build();*/
+        jobManager = new JobManager(this);
+    }
+
+    public JobManager getJobManager() {
+        return jobManager;
+    }
+
+    public ApplicationLoader() {
+        super();
+        instance = this;
+    }
+
+    public static ApplicationLoader getInstance() {
+        if (instance == null)
+            throw new IllegalStateException();
+
+        return instance;
+    }
+
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/SendMessagesHelper.java b/TMessagesProj/src/main/java/org/telegram/messenger/SendMessagesHelper.java
index ece09d9aa..db8c16b0a 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/SendMessagesHelper.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/SendMessagesHelper.java
@@ -23,8 +23,14 @@
 import android.webkit.MimeTypeMap;
 import android.widget.Toast;
 
+import com.path.android.jobqueue.JobManager;
+
+import org.json.JSONObject;
 import org.telegram.messenger.audioinfo.AudioInfo;
 import org.telegram.messenger.query.StickersQuery;
+import org.telegram.messenger.shamChat.MessageContentTypeProvider;
+import org.telegram.messenger.shamChat.PublishToTopicJob;
+import org.telegram.messenger.shamChat.Utils;
 import org.telegram.tgnet.ConnectionsManager;
 import org.telegram.tgnet.QuickAckDelegate;
 import org.telegram.tgnet.RequestDelegate;
@@ -45,6 +51,8 @@
     private HashMap<String, ArrayList<DelayedMessage>> delayedMessages = new HashMap<>();
     private HashMap<Integer, MessageObject> unsentMessages = new HashMap<>();
     private HashMap<Integer, TLRPC.Message> sendingMessages = new HashMap<>();
+//reza_ak
+    private JobManager jobManager;
 
     protected class DelayedMessage {
         public TLObject sendRequest;
@@ -84,6 +92,9 @@ public SendMessagesHelper() {
         NotificationCenter.getInstance().addObserver(this, NotificationCenter.httpFileDidLoaded);
         NotificationCenter.getInstance().addObserver(this, NotificationCenter.FileDidLoaded);
         NotificationCenter.getInstance().addObserver(this, NotificationCenter.FileDidFailedLoad);
+
+        //reza_ak
+        jobManager = ApplicationLoader.getInstance().getJobManager();
     }
 
     public void cleanUp() {
@@ -1257,6 +1268,36 @@ private void sendMessage(String message, TLRPC.MessageMedia location, TLRPC.TL_p
                             reqSend.no_webpage = true;
                         }
                         performSendMessageRequest(reqSend, newMsgObj.messageOwner, null);
+                        JSONObject jsonMessageObject = new JSONObject();
+                        String packetId = null;
+                        String timestamp = Utils.getTimeStamp();
+
+                        try {
+                            jsonMessageObject.put("packet_type", "message");
+                            jsonMessageObject.put("to", "98729");
+                            jsonMessageObject.put("from", "+989122335645");
+                            jsonMessageObject.put("from_userid","6");
+                            jsonMessageObject.put("messageBody", newMsg.message);
+                            jsonMessageObject.put("messageType", MessageContentTypeProvider.MessageContentType.TEXT.ordinal());
+                            jsonMessageObject.put("messageTypeDesc", "");
+                            jsonMessageObject.put("timestamp", timestamp);
+                            jsonMessageObject.put("groupAlias", "aa");
+                            jsonMessageObject.put("isForward", false);
+                            jsonMessageObject.put( "channeltitle", "");
+                            jsonMessageObject.put("channelhashcode", "");
+                            jsonMessageObject.put("orginalpachetid", "");
+
+                            //jsonMessageObject.put("groupOwnerId",groupOwnerId);
+                            jsonMessageObject.put("isGroupChat", 1);
+                            jsonMessageObject.put("channel_view", "1");
+                            packetId = Utils.makePacketId("6");
+                            jsonMessageObject.put("packetId", packetId);
+
+                        } catch (Exception e) {
+                            // TODO Auto-generated catch block
+                            e.printStackTrace();
+                        }
+                        jobManager.addJobInBackground(new PublishToTopicJob(jsonMessageObject.toString(), "groups/" + "s6:98729"));
                     }
                 } else {
                     TLRPC.TL_decryptedMessage reqSend;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/mqtt/ActionListener.java b/TMessagesProj/src/main/java/org/telegram/messenger/mqtt/ActionListener.java
index 2e5528a7c..f7e22b84a 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/mqtt/ActionListener.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/mqtt/ActionListener.java
@@ -12,23 +12,23 @@
  */
 package org.telegram.messenger.mqtt;
 
-import org.greenrobot.eventbus.EventBus;
+
 import org.telegram.messenger.R;
 import org.telegram.messenger.mqtt.Connection.ConnectionStatus;
 
 
 import org.eclipse.paho.client.mqttv3.IMqttActionListener;
 import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.telegram.messenger.shamChat.NewGroupMessageSentFailedEvent;
+import org.telegram.messenger.shamChat.NewGroupMessageSentSuccessEvent;
 
 import android.content.Context;
 import android.widget.Toast;
 
+import de.greenrobot.event.EventBus;
+
+
 
-/**
- * This Class handles receiving information from the
- * {@link MqttAndroidClient} and updating the {@link Connection} associated with 
- * the action
- */
 public class ActionListener implements IMqttActionListener {
 
   /**
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/mqtt/MQTTService.java b/TMessagesProj/src/main/java/org/telegram/messenger/mqtt/MQTTService.java
index 9c68cfe3f..b74aac9e7 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/mqtt/MQTTService.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/mqtt/MQTTService.java
@@ -28,22 +28,31 @@
 import android.util.Log;
 import android.widget.Toast;
 
-import org.greenrobot.eventbus.EventBus;
+import org.telegram.messenger.ApplicationLoader;
+import org.telegram.messenger.R;
 import org.telegram.messenger.mqtt.Connection.ConnectionStatus;
 import com.path.android.jobqueue.JobManager;
-import com.shamchat.adapters.MyMessageType;
-import com.shamchat.androidclient.chat.extension.MessageContentTypeProvider.MessageContentType;
-import com.shamchat.events.ChannelOnLeaveEvent;
-import com.shamchat.events.CloseGroupActivityEvent;
-import com.shamchat.events.FileUploadingProgressEvent;
-import com.shamchat.events.NewMessageEvent;
-import com.shamchat.events.UpdateGroupMembersList;
-import com.shamchat.jobs.DeleteChatMessageDBLoadJob;
-import com.shamchat.jobs.PublishToTopicJob;
-import com.shamchat.jobs.RoomRestoreJob;
-import com.shamchat.jobs.SubscribeToAllTopicsJob;
-import com.shamchat.jobs.SubscribeToEventsJob;
-import com.shamchat.jobs.SyncContactsJob;
+
+import org.telegram.messenger.shamChat.ChatMessage;
+
+import org.telegram.messenger.shamChat.Constant;
+import org.telegram.messenger.shamChat.FriendGroup;
+import org.telegram.messenger.shamChat.FriendGroupMember;
+import org.telegram.messenger.shamChat.MessageThread;
+import org.telegram.messenger.shamChat.MyMessageType;
+import org.telegram.messenger.shamChat.MessageContentTypeProvider.MessageContentType;
+import org.telegram.messenger.shamChat.ChannelOnLeaveEvent;
+import org.telegram.messenger.shamChat.CloseGroupActivityEvent;
+import org.telegram.messenger.shamChat.FileUploadingProgressEvent;
+import org.telegram.messenger.shamChat.NewMessageEvent;
+import org.telegram.messenger.shamChat.RokhPref;
+import org.telegram.messenger.shamChat.UpdateGroupMembersList;
+import org.telegram.messenger.shamChat.DeleteChatMessageDBLoadJob;
+import org.telegram.messenger.shamChat.PublishToTopicJob;
+import org.telegram.messenger.shamChat.RoomRestoreJob;
+import org.telegram.messenger.shamChat.SubscribeToAllTopicsJob;
+import org.telegram.messenger.shamChat.SubscribeToEventsJob;
+//import org.telegram.messenger.shamChat.SyncContactsJob;
 
 import org.eclipse.paho.android.service.MqttAndroidClient;
 import org.eclipse.paho.client.mqttv3.IMqttActionListener;
@@ -59,6 +68,9 @@
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
+import org.telegram.messenger.shamChat.User;
+import org.telegram.messenger.shamChat.Utils;
+
 
 import java.beans.PropertyChangeEvent;
 import java.beans.PropertyChangeListener;
@@ -72,6 +84,8 @@
 import java.util.Hashtable;
 import java.util.Map;
 
+import de.greenrobot.event.EventBus;
+
 public class MQTTService extends Service
 {
 
@@ -93,7 +107,7 @@
     // constants used to tell the Activity UI the connection status
     public static final String MQTT_STATUS_INTENT = "com.rokhgroup.mqtt.STATUS";
     public static final String MQTT_STATUS_MSG    = "com.rokhgroup.mqtt.STATUS_MSG";
-
+String userIdPub="6";
     // constant used internally to schedule the next ping event
     public static final String MQTT_PING_ACTION = "com.rokhgroup.mqtt.PING";
 
@@ -280,12 +294,15 @@ public void onCreate()
         //String clientId = "testshamchat1";
 
         brokerHostName = Constant.MqttTcpHost;
-        mqttClientId = SHAMChatApplication.getConfig().getUserId();
+        //reza_ak
+        mqttClientId ="6";
+                //SHAMChatApplication.getConfig().getUserId();
         brokerPortNumber = Integer.valueOf(Constant.MqttTcpPort);
 
-        Session	= new RokhPref(SHAMChatApplication.getInstance().getApplicationContext());
+        //Session	= new RokhPref(getApplicationContext());
 
-        jobManager = SHAMChatApplication.getInstance().getJobManager();
+        jobManager =  ApplicationLoader.getInstance().getJobManager();
+        //ApplicationLoader.getJobManager();
 
         // register to be notified whenever the user changes their preferences
         //  relating to background data use - so that we can respect the current
@@ -705,7 +722,8 @@ private void defineConnectionToBroker(String brokerHostName)
             // create a client handle
             //clientHandle		= uri + mqttClientId;
             clientHandle		= "user"+mqttClientId;
-            Session.setClientHandle(clientHandle);
+            //reza_ak
+            //Session.setClientHandle(clientHandle);
 		
 		/*if (Connections.getInstance(this).getConnection(clientHandle) != null)
 		{
@@ -814,7 +832,8 @@ public void onSuccess(IMqttToken arg0) {
 
                         if (DEBUG) notifyUser2("broker - success");
 
-                        boolean getTopics	= Session.getFirstRun();
+                        //reza_ak
+                       /* boolean getTopics	= Session.getFirstRun();
 
                         if(!getTopics){
 
@@ -827,7 +846,7 @@ public void onSuccess(IMqttToken arg0) {
                         else {
                             //Subscribe to all group topics
                             jobManager.addJobInBackground(new SubscribeToAllTopicsJob());
-                        }
+                        }*/
 
                         //Subscribe to events topic
                         jobManager.addJobInBackground(new SubscribeToEventsJob());
@@ -862,12 +881,12 @@ public void onFailure(IMqttToken arg0, Throwable arg1) {
 
                             if (((MqttPersistenceException) arg1).getReasonCode() == 32200) {
                                 //if it is "Persistence already in use" error
-                                Notify.toast(SHAMChatApplication.getMyApplicationContext(), "P fail", Toast.LENGTH_SHORT);
+                                NotifySimple.toast(getApplicationContext(), "P fail", Toast.LENGTH_SHORT);
 							   
 							    
 							    
 							    /*try {
-							    	SHAMChatApplication.getMyApplicationContext().deleteDatabase(Persistence.DATABASE_NAME);
+							    	getApplicationContext().deleteDatabase(Persistence.DATABASE_NAME);
 						            SQLiteDatabase db = openOrCreateDatabase(Persistence.DATABASE_NAME, MODE_PRIVATE, null);
 				                    db.execSQL(Persistence.SQL_CREATE_ENTRIES);
 				                    db.close();
@@ -1207,7 +1226,9 @@ public void onReceive(Context context, Intent intent)
                 //https://www.eclipse.org/paho/files/javadoc/org/eclipse/paho/client/mqttv3/internal/ClientComms.html#checkForActivity%28%29
 
                 if (DEBUG) notifyUser2("ping to server");
-                String userId	= SHAMChatApplication.getConfig().getUserId();
+                //reza_ak
+                String userId	= "6";
+                        //SHAMChatApplication.getConfig().getUserId();
                 String topic = "events/"+userId;
                 String pingMessage = "ping";
                 int qos = 1;
@@ -1411,7 +1432,8 @@ public void onEventBackgroundThread(NewMessageEvent event) {
         if ((event.getConsumed() == false) && !(jsonMessageString == null))
         {
 
-            Notify.notifcation(getApplicationContext(), jsonMessageString);
+            NotifySimple.toast(getApplicationContext(), jsonMessageString,Toast.LENGTH_SHORT);
+
         }
 
     }
@@ -1428,7 +1450,8 @@ public void onEventBackgroundThread(FileUploadingProgressEvent event) {
 
         if (event.getUploadedPercentage() == 100 && isGroup) {
 
-            Cursor cursor = null;
+            //reza_ak
+           /*  Cursor cursor = null;
 
             cursor = getContentResolver().query(
                     ChatProviderNew.CONTENT_URI_CHAT,
@@ -1436,15 +1459,14 @@ public void onEventBackgroundThread(FileUploadingProgressEvent event) {
                     ChatMessage.THREAD_ID + "=? AND " + ChatMessage.PACKET_ID +"=?" ,
                     new String[] { event.getThreadId(), event.getPacketId() },null);
 
-
-            chatProvider = new ChatProviderNew();
+ chatProvider = new ChatProviderNew();
 
 
             if (chatProvider != null && cursor.getCount() > 0) {
                 while (cursor.moveToNext()) {
                     final ChatMessage message = chatProvider.getChatMessageByCursor(cursor);
 
-                    ContentResolver mContentResolver = SHAMChatApplication.getMyApplicationContext().getContentResolver();
+                    ContentResolver mContentResolver = getApplicationContext().getContentResolver();
 
                     if (message.getThreadId().equals(event.getThreadId())) {
 
@@ -1456,7 +1478,7 @@ public void onEventBackgroundThread(FileUploadingProgressEvent event) {
                         try {
 
                             Cursor cursorMe = mContentResolver.query(UserProvider.CONTENT_URI_USER,
-                                    null, UserConstants.USER_ID + "=?",
+                                    null, UserProvider.UserConstants.USER_ID + "=?",
                                     new String[] { SHAMChatApplication.getConfig().getUserId() },
                                     null);
 
@@ -1527,7 +1549,7 @@ public void onEventBackgroundThread(FileUploadingProgressEvent event) {
                 }
             }
 
-            cursor.close();
+            cursor.close();*/
 
         }
 
@@ -1602,7 +1624,9 @@ public MqttCallbackHandler(Context context, String clientHandle)
         {
             this.context = context;
             this.clientHandle = clientHandle;
-            CURRENT_USER_ID	= SHAMChatApplication.getConfig().getUserId();
+            //reza_ak
+            CURRENT_USER_ID	= "6";
+                    //SHAMChatApplication.getConfig().getUserId();
         }
 
         /**
@@ -1824,8 +1848,8 @@ public void messageArrived(String topic, MqttMessage message) throws Exception {
                             values.put(FriendGroup.DB_DESCRIPTION, description);
                             values.put(FriendGroup.DB_LINK_NAME, name);
                         }
-
-                        SHAMChatApplication.getInstance().getContentResolver().update(UserProvider.CONTENT_URI_GROUP, values, FriendGroup.DB_ID + "=?", new String[]{hashcode});
+//reza_ak
+                      //  getApplicationContext().getContentResolver().update(UserProvider.CONTENT_URI_GROUP, values, FriendGroup.DB_ID + "=?", new String[]{hashcode});
 
                         EventBus.getDefault().postSticky(new NewMessageEvent());
 
@@ -1862,14 +1886,15 @@ else if (packetType.equals("unknown")) {
                 }else { //if this is a group message
 
                     if (packetType.equals("message")){
-
+//reza_ak
                         //if it is my own packet just ignore it
+                        /*
                         if (Utils.isMyOwnPacket(jsonMessageString)) return;
 
                         //notify the user
                         int messageContentType = Utils.detectMessageContentType(jsonMessageString);
 
-                        addChatMessageToDB(MyMessageType.INCOMING_MSG.ordinal(), MessageStatusType.QUEUED.ordinal(), messageContentType, jsonMessageString);
+                        addChatMessageToDB(MyMessageType.INCOMING_MSG.ordinal(), ChatMessage.MessageStatusType.QUEUED.ordinal(), messageContentType, jsonMessageString);
 
                         //here we can do something specific for each type of message like notification or other things
                         if (messageContentType == MessageContentType.TEXT.ordinal()) {}
@@ -1879,6 +1904,7 @@ else if (messageContentType == MessageContentType.STICKER.ordinal()) {}
                         else if (messageContentType == MessageContentType.LOCATION.ordinal()) {}
                         else if (messageContentType == MessageContentType.VOICE_RECORD.ordinal()) {}
                         else if (messageContentType == MessageContentType.MESSAGE_WITH_IMOTICONS.ordinal()) {}
+                        */
 
                     }
                     //if user x is invited to group
@@ -1967,7 +1993,7 @@ public boolean addChatMessageToDB(int direction, int messageStatus, int messageC
 
             boolean isExistingMessage = false;
 
-            ContentResolver mContentResolver = SHAMChatApplication.getInstance().getContentResolver();
+            ContentResolver mContentResolver = getApplicationContext().getContentResolver();
 
 
             //mast - sample message to handle sent message and insert to db
@@ -2019,8 +2045,9 @@ public boolean addChatMessageToDB(int direction, int messageStatus, int messageC
 
 
             String groupId = to;
-
-            String threadOwner = SHAMChatApplication.getConfig().getUserId();
+//reza_ak
+            String threadOwner = "6";
+                    //SHAMChatApplication.getConfig().getUserId();
 
             //String threadId = threadId;
             //String groupId = null;
@@ -2040,8 +2067,8 @@ public boolean addChatMessageToDB(int direction, int messageStatus, int messageC
 
                 Cursor chatCursor = null;
 
-
-                try {
+//reza_ak
+              /*  try {
                     //check to see if current message exists previously - ic_search using packetId of message
 
                     chatCursor = mContentResolver.query(
@@ -2111,16 +2138,16 @@ else if(groupId.startsWith("s")) {
 
                             String fromGroup = groupId;
 
-     								/*String userId = fromGroup.substring(
+     								*//*String userId = fromGroup.substring(
      										fromGroup.indexOf("/") + 1,
      										fromGroup.indexOf("-"));
 
      								String username = getUsernameToDisplayForGroup(
-     										userId, fromGroup);*/
+     										userId, fromGroup);*//*
                             String userId = from;
                             //mast - will change later - currently it is phonenumber
 
-                            String username = getContactNameFromPhone(SHAMChatApplication.getMyApplicationContext(),from);
+                            String username = getContactNameFromPhone(getApplicationContext(),from);
 
                             // This is the actual sender, from value is
                             // the room name not the individual who sent it
@@ -2205,7 +2232,7 @@ else if ( singleChat==true) {
 
                             }
 
-                        } else { //Group chat out going message*/
+                        } else { //Group chat out going message*//*
 
                             System.out
                                     .println("processMessage addChatMessageToDB Single chat, both directions, Group chat outgoing");
@@ -2280,7 +2307,7 @@ else if ( singleChat==true) {
 
                 } finally {
                     chatCursor.close();
-                }
+                }*/
             }
 
             return isExistingMessage;
@@ -2299,14 +2326,15 @@ private void doSubscribe(String clienthandle, String topic) {
 
             //find our own User object
             User me;
-            ContentResolver mContentResolver = SHAMChatApplication.getMyApplicationContext().getContentResolver();
-
-            Cursor cursor = mContentResolver.query(UserProvider.CONTENT_URI_USER, null, UserConstants.USER_ID + "=?", new String[]{SHAMChatApplication.getConfig().getUserId()}, null);
+            ContentResolver mContentResolver = getApplicationContext().getContentResolver();
+            //reza_ak
+/*
+            Cursor cursor = mContentResolver.query(UserProvider.CONTENT_URI_USER, null, UserProvider.UserConstants.USER_ID + "=?", new String[]{userIdPub}, null);
             cursor.moveToFirst();
             me = UserProvider.userFromCursor(cursor);
-            cursor.close();
+            cursor.close();*/
 
-            String clientId = me.getUserId();
+            String clientId = "6";
 
             String[] actionArgs = new String[1];
 
@@ -2317,7 +2345,7 @@ private void doSubscribe(String clienthandle, String topic) {
                 actionArgs[0] = "groups/" + topic;
             }
 
-            final ActionListener callback = new ActionListener(SHAMChatApplication.getMyApplicationContext(),
+            final ActionListener callback = new ActionListener(getApplicationContext(),
                     ActionListener.Action.SUBSCRIBE, clientHandle, actionArgs);
 
             try {
@@ -2397,25 +2425,25 @@ public void processInvitation(String jsonString) {
                     linkName =  topic.getString("name");
                 }
 
-                RokhPref	Session	= new RokhPref(SHAMChatApplication.getInstance().getApplicationContext());
+                RokhPref	Session	= new RokhPref(getApplicationContext());
                 String clientHandle	= Session.getClientHandle();
 
-                ContentResolver mContentResolver = SHAMChatApplication.getInstance().getApplicationContext().getContentResolver();
-                String userId = SHAMChatApplication.getConfig().getUserId();
-
+                ContentResolver mContentResolver = getApplicationContext().getContentResolver();
+                String userId = userIdPub;
 
-                Cursor groupCursor = mContentResolver.query( UserProvider.CONTENT_URI_GROUP, new String[] { FriendGroup.DB_ID }, FriendGroup.CHAT_ROOM_NAME + "=?", new String[] { hashcode }, null);
+//reza_ak
+               // Cursor groupCursor = mContentResolver.query( UserProvider.CONTENT_URI_GROUP, new String[] { FriendGroup.DB_ID }, FriendGroup.CHAT_ROOM_NAME + "=?", new String[] { hashcode }, null);
 
                 boolean isUpdate = false;
-
-                if (groupCursor.getCount() > 0) {
+//reza_ak
+            /*    if (groupCursor.getCount() > 0) {
                     isUpdate = true;
-                }
+                }*/
 
                 String groupName = title;	// Group Alias
                 String ownerID = ownerId;
-
-                groupCursor.close();
+//reza_ak
+                //groupCursor.close();
 
                 System.out.println(" invitation group name " + groupName);
 
@@ -2459,19 +2487,20 @@ public void processInvitation(String jsonString) {
                 vals.put(MessageThread.THREAD_ID, thread.getThreadId());
                 vals.put(MessageThread.FRIEND_ID, thread.getFriendId());
                 vals.put(MessageThread.READ_STATUS, 0);
-                vals.put(MessageThread.LAST_UPDATED_DATETIME,Utils.formatDate(new Date().getTime(), "yyyy/MM/dd HH:mm:ss"));
+                //reza_ak
+                //vals.put(MessageThread.LAST_UPDATED_DATETIME,Utils.formatDate(new Date().getTime(), "yyyy/MM/dd HH:mm:ss"));
                 vals.put(MessageThread.IS_GROUP_CHAT, 1);
                 vals.put(MessageThread.THREAD_OWNER, thread.getThreadOwner());
-
-                if (!isUpdate) {
+//reza_ak
+               /* if (!isUpdate) {
 
 
                     mContentResolver.insert(UserProvider.CONTENT_URI_GROUP, values);
 
                     if(hashcode.startsWith("ch")) {
-                        vals.put(MessageThread.LAST_MESSAGE, SHAMChatApplication.getInstance().getString(R.string.new_channel_invited));
+                        vals.put(MessageThread.LAST_MESSAGE, "new_channel_invited");
                     } else if(hashcode.startsWith("g")){
-                        vals.put(MessageThread.LAST_MESSAGE, SHAMChatApplication.getInstance().getString(R.string.new_group_invited));
+                        vals.put(MessageThread.LAST_MESSAGE, "new_group_invited");
                     }
                     else {
                         vals.put(MessageThread.LAST_MESSAGE, "");
@@ -2487,7 +2516,7 @@ public void processInvitation(String jsonString) {
 
                     mContentResolver.update(UserProvider.CONTENT_URI_GROUP, values, FriendGroup.DB_ID + "=?", new String[] { group.getId() });
                     mContentResolver.update(ChatProviderNew.CONTENT_URI_THREAD, vals, MessageThread.THREAD_ID + "=?", new String[] { thread.getThreadId() });
-                }
+                }*/
                 //
                 // requestAndUpdateParticpants(group,list);
 
@@ -2501,10 +2530,11 @@ public void processInvitation(String jsonString) {
                 adminCv.put(FriendGroupMember.DB_GROUP, admin.getGroupID());
                 adminCv.put(FriendGroupMember.DB_FRIEND_IS_ADMIN, 1);
                 adminCv.put(FriendGroupMember.PHONE_NUMBER, admin.getPhoneNumber());
-
+//reza_ak
+                /*
                 if (mContentResolver.update(UserProvider.CONTENT_URI_GROUP_MEMBER, adminCv, FriendGroupMember.DB_GROUP + "=? AND " + FriendGroupMember.DB_FRIEND + "=?", new String[] { admin.getGroupID(), ownerID }) == 0) {
                     mContentResolver.insert(UserProvider.CONTENT_URI_GROUP_MEMBER, adminCv);
-                }
+                }*/
                 //if this is a group we save list of group members
                 if (!isChannel) {
                     if (users.length() > 0) {
@@ -2531,10 +2561,11 @@ public void processInvitation(String jsonString) {
                                 groupMember.put(FriendGroupMember.DB_FRIEND_IS_ADMIN, 1);
                             }
                             groupMember.put(FriendGroupMember.DB_FRIEND_DID_JOIN, 1);
-
+//reza_ak
+/*
                             if (mContentResolver.update(UserProvider.CONTENT_URI_GROUP_MEMBER, groupMember, FriendGroupMember.DB_GROUP + "=? AND " + FriendGroupMember.DB_FRIEND + "=?", new String[]{members.getGroupID(), memberId}) == 0) {
                                 mContentResolver.insert(UserProvider.CONTENT_URI_GROUP_MEMBER, groupMember);
-                            }
+                            }*/
 
                         }
 
@@ -2561,7 +2592,7 @@ public void processInvitation(String jsonString) {
         private boolean saveOrUpdateThread(String threadId, String receivedJsonMessage, int messageContentType, String friendId, int direction) {
 
 
-            ContentResolver mContentResolver = SHAMChatApplication.getInstance()
+            ContentResolver mContentResolver = getApplicationContext()
                     .getContentResolver();
             // Pars Json String
 
@@ -2598,7 +2629,8 @@ private boolean saveOrUpdateThread(String threadId, String receivedJsonMessage,
             // End Pars
 
             Cursor threadCursor = null;
-            try {
+            //reza_ak
+           /* try {
                 threadCursor = mContentResolver.query(
                         ChatProviderNew.CONTENT_URI_THREAD,
                         new String[] { MessageThread.THREAD_ID },
@@ -2620,8 +2652,8 @@ private boolean saveOrUpdateThread(String threadId, String receivedJsonMessage,
                 if (messageContentType != MessageContentType.GROUP_INFO.ordinal()) {
 
                     System.out.println("processMessage addChatMessageToDB saveOrUpdateThread NOT group info");
-
-                    switch (Utils.readMessageContentType(messageType)) {
+//reza_ak
+                  *//*  switch (Utils.readMessageContentType(messageType)) {
                         case TEXT:
                             int limit;
                             if (messageBody.length()>70) limit = 70;
@@ -2632,31 +2664,31 @@ private boolean saveOrUpdateThread(String threadId, String receivedJsonMessage,
 
                         case IMAGE:
 
-                            lastMessage =  SHAMChatApplication.getInstance().getApplicationContext().getResources().getString(R.string.received_image);
+                            lastMessage = "received_image";
                             break;
 
                         case VIDEO:
-                            lastMessage = SHAMChatApplication.getInstance().getApplicationContext().getResources().getString(R.string.received_video);
+                            lastMessage = "received_video";
                             break;
 
                         case STICKER:
-                            lastMessage = SHAMChatApplication.getInstance().getApplicationContext().getResources().getString(R.string.received_sticker);
+                            lastMessage = "received_sticker";
                             break;
 
 
                         case LOCATION:
-                            lastMessage = SHAMChatApplication.getInstance().getApplicationContext().getResources().getString(R.string.received_location);
+                            lastMessage = "received_location";
                             break;
 
                         case VOICE_RECORD:
-                            lastMessage = SHAMChatApplication.getInstance().getApplicationContext().getResources().getString(R.string.received_voice);
+                            lastMessage = "received_voice";
                             break;
 
                         default:
                             System.out.println("processMessage addChatMessageToDB saveOrUpdateThread DEFAULT"+ lastMessage);
                             break;
 
-                    }
+                    }*//*
 
                 }
 
@@ -2670,7 +2702,7 @@ private boolean saveOrUpdateThread(String threadId, String receivedJsonMessage,
                     values.put(MessageThread.READ_STATUS, isRead ? 1 : 0);
                     values.put(MessageThread.LAST_UPDATED_DATETIME,Utils.formatDate(new Date().getTime(),"yyyy/MM/dd HH:mm:ss"));
                     values.put(MessageThread.LAST_MESSAGE_DIRECTION, direction);
-                    values.put(MessageThread.THREAD_OWNER, SHAMChatApplication.getConfig().getUserId());
+                    values.put(MessageThread.THREAD_OWNER, userIdPub);
                     values.put(MessageThread.IS_GROUP_CHAT,isGroupChat);
                     mContentResolver.update(ChatProviderNew.CONTENT_URI_THREAD, values, MessageThread.THREAD_ID + "=?", new String[] { threadId });
                 } else {
@@ -2685,8 +2717,7 @@ private boolean saveOrUpdateThread(String threadId, String receivedJsonMessage,
                     values.put(MessageThread.LAST_MESSAGE_CONTENT_TYPE,messageContentType);
                     values.put(MessageThread.LAST_UPDATED_DATETIME, Utils.formatDate(new Date().getTime(), "yyyy/MM/dd HH:mm:ss"));
                     values.put(MessageThread.IS_GROUP_CHAT, isGroupChat);
-                    values.put(MessageThread.THREAD_OWNER, SHAMChatApplication
-                            .getConfig().getUserId());
+                    values.put(MessageThread.THREAD_OWNER, userIdPub);
                     values.put(MessageThread.LAST_MESSAGE_DIRECTION, direction);
 
                     mContentResolver.insert(ChatProviderNew.CONTENT_URI_THREAD,
@@ -2695,7 +2726,7 @@ private boolean saveOrUpdateThread(String threadId, String receivedJsonMessage,
 
             } finally {
                 threadCursor.close();
-            }
+            }*/
             return true;
         }
 
@@ -2710,7 +2741,7 @@ private boolean addInviteMessageToGroup (String jsonMessageString)
             // Conference service
             // g18261_20150618235025@conference.rabtcdn.com/+987735065830
 
-            ContentResolver mContentResolver = SHAMChatApplication.getMyApplicationContext().getContentResolver();
+            ContentResolver mContentResolver = getApplicationContext().getContentResolver();
 
             JSONObject MessageObject = null;
             JSONObject topicObject = null;
@@ -2755,7 +2786,7 @@ private boolean addInviteMessageToGroup (String jsonMessageString)
             String threadId = null;
 
             roomname = hashcode;
-            threadId = SHAMChatApplication.getConfig().getUserId() + "-" + roomname;
+            threadId = userIdPub + "-" + roomname;
 
             String userId=null;
 
@@ -2781,20 +2812,21 @@ private boolean addInviteMessageToGroup (String jsonMessageString)
 
                 userId = String.valueOf(newMemberUserId) ;
 
-
-                Cursor cursor = mContentResolver.query(
+////reza_ak
+               /* Cursor cursor = mContentResolver.query(
                         UserProvider.CONTENT_URI_GROUP_MEMBER,
                         new String[] { FriendGroupMember.DB_ID },
                         FriendGroupMember.DB_FRIEND + "=? AND "
                                 + FriendGroupMember.DB_GROUP + "=?"
-                        , new String[] { userId, roomname}, null);
+                        , new String[] { userId, roomname}, null);*/
 
                 //if invited user doesn't exists previously then insert it to database
-                if (cursor.getCount() == 0) {
+                //reza_ak
+              /*  if (cursor.getCount() == 0) {
 
                     //insert new users to list of group members
                     FriendGroupMember newUser = new FriendGroupMember(roomname, userId);
-                    newUser.assignUniqueId(SHAMChatApplication.getConfig().getUserId());
+                    newUser.assignUniqueId(userIdPub);
 
                     ContentValues vals = new ContentValues();
                     vals.put(FriendGroupMember.DB_ID, newUser.getId());
@@ -2804,7 +2836,9 @@ private boolean addInviteMessageToGroup (String jsonMessageString)
                     vals.put(FriendGroupMember.DB_FRIEND_DID_JOIN, "1");
 
                     //first try to update and if not exists then insert new record to friend group members table
-                    if (mContentResolver.update(
+
+                    //reza_ak
+                    *//*   if (mContentResolver.update(
                             UserProvider.CONTENT_URI_GROUP_MEMBER, vals,
                             FriendGroupMember.DB_GROUP + "=? AND "
                                     + FriendGroupMember.DB_FRIEND + "=?",
@@ -2812,12 +2846,11 @@ private boolean addInviteMessageToGroup (String jsonMessageString)
                         mContentResolver
                                 .insert(UserProvider.CONTENT_URI_GROUP_MEMBER,
                                         vals);
-                    }
+                    }*//*
 
 
                     //mast - username is phone number of new user
-                    String message = getContactNameFromPhone(SHAMChatApplication.getMyApplicationContext(),newMemberPhone) + " " + SHAMChatApplication.getInstance().getApplicationContext().getResources()
-                            .getString(R.string.has_joined_the_room);
+                    String message = "has_joined_the_room";
 
                     //update the chat thread
                     ContentValues values = new ContentValues();
@@ -2831,17 +2864,17 @@ private boolean addInviteMessageToGroup (String jsonMessageString)
                     values.put(MessageThread.LAST_MESSAGE_DIRECTION,
                             MyMessageType.INCOMING_MSG.ordinal());
 
-
-                    mContentResolver.update(
+//reza_ak
+                  *//*  mContentResolver.update(
                             ChatProviderNew.CONTENT_URI_THREAD, values,
                             MessageThread.THREAD_ID + "=?",
-                            new String[] { threadId });
+                            new String[] { threadId });*//*
 
                     ContentValues chatmessageVals = new ContentValues();
 
                     //add the group info message that user x was invited to room
                     chatmessageVals.put(ChatMessage.MESSAGE_RECIPIENT,
-                            SHAMChatApplication.getConfig().getUserId());
+                            userIdPub);
                     chatmessageVals.put(ChatMessage.MESSAGE_TYPE,
                             MyMessageType.INCOMING_MSG.ordinal());
                     chatmessageVals.put(ChatMessage.PACKET_ID,packetId);
@@ -2851,7 +2884,7 @@ private boolean addInviteMessageToGroup (String jsonMessageString)
                     chatmessageVals.put(ChatMessage.MESSAGE_CONTENT_TYPE,
                             MessageContentType.GROUP_INFO.ordinal());
                     chatmessageVals.put(ChatMessage.MESSAGE_STATUS,
-                            MessageStatusType.SEEN.ordinal());
+                            ChatMessage.MessageStatusType.SEEN.ordinal());
                     chatmessageVals.put(ChatMessage.FILE_SIZE, 0);
 
                     chatmessageVals.put(ChatMessage.GROUP_ID, roomname);
@@ -2865,8 +2898,8 @@ private boolean addInviteMessageToGroup (String jsonMessageString)
 
 
 
-
-                    if (mContentResolver.update(
+//reza_ak
+                   *//* if (mContentResolver.update(
                             ChatProviderNew.CONTENT_URI_CHAT,
                             chatmessageVals, ChatMessage.PACKET_ID + "=?",
                             new String[] { packetId }) == 0) {
@@ -2874,7 +2907,7 @@ private boolean addInviteMessageToGroup (String jsonMessageString)
                                 ChatProviderNew.CONTENT_URI_CHAT,
                                 chatmessageVals);
 
-                    }
+                    }*//*
 
                 }
                 //if user already was invited and exists in database
@@ -2882,7 +2915,7 @@ private boolean addInviteMessageToGroup (String jsonMessageString)
                     //what to do ? nothing is not required
                 }
 
-                cursor.close();
+                cursor.close();*/
             }
 
 
@@ -2931,7 +2964,7 @@ private void DeleteChannelPost(String jsonMessageString) {
 
         private boolean addLeftRoomToGroup (String jsonMessageString){
 
-            ContentResolver mContentResolver = SHAMChatApplication.getMyApplicationContext().getContentResolver();
+            ContentResolver mContentResolver = getApplicationContext().getContentResolver();
 
             JSONObject MessageObject = null;
             JSONObject topicObject = null;
@@ -2953,6 +2986,7 @@ private boolean addLeftRoomToGroup (String jsonMessageString){
                 leftMemberUserId = actorObject.getInt("user_id");
 
                 //Mast - TODO - the packetId should come from python script
+
                 packetId = Utils.makePacketId(String.valueOf(leftMemberUserId));
                 MessageObject.put("packet_id", packetId);
                 jsonMessageString = MessageObject.toString();
@@ -2965,18 +2999,22 @@ private boolean addLeftRoomToGroup (String jsonMessageString){
             String groupId = hashcode;
             String userId = String.valueOf(leftMemberUserId);
 
-            String threadId = SHAMChatApplication.getConfig().getUserId() + "-" + groupId;
+            String threadId = userIdPub + "-" + groupId;
 
             //delete user from table of friend group members
-            mContentResolver.delete(UserProvider.CONTENT_URI_GROUP_MEMBER, FriendGroupMember.DB_GROUP + "=? AND "+ FriendGroupMember.DB_FRIEND + "=?", new String[] {groupId, userId });
+            //reza_ak
+            //mContentResolver.delete(UserProvider.CONTENT_URI_GROUP_MEMBER, FriendGroupMember.DB_GROUP + "=? AND "+ FriendGroupMember.DB_FRIEND + "=?", new String[] {groupId, userId });
             String displayMessage="";
             if(!groupId.substring(0,2).equals("ch")) {
-                displayMessage = getContactNameFromPhone(SHAMChatApplication.getMyApplicationContext(), leftMemberPhone) + " " + SHAMChatApplication.getInstance().getApplicationContext().getResources().getString(R.string.left_the_chat);
+                displayMessage = getContactNameFromPhone(getApplicationContext(), leftMemberPhone) + " " +"left_the_chat";
 
                 //update the chat thread table to show message user x left the room
                 ContentValues cvs = new ContentValues();
                 cvs.put(MessageThread.LAST_MESSAGE, displayMessage);
-                mContentResolver.update(ChatProviderNew.CONTENT_URI_THREAD, cvs, MessageThread.THREAD_ID + "=?", new String[]{threadId});
+
+                //reza_ak
+                /*    mContentResolver.update(ChatProviderNew.CONTENT_URI_THREAD, cvs, MessageThread.THREAD_ID + "=?", new String[]{threadId});
+            */
             }
             Log.w("leftuserid", String.valueOf(leftMemberUserId));
             Log.w("currentuserid", CURRENT_USER_ID);
@@ -2985,7 +3023,7 @@ private boolean addLeftRoomToGroup (String jsonMessageString){
             if(String.valueOf(leftMemberUserId).equals(CURRENT_USER_ID)){
 
                 //Mast - unsubscribe from the group we left
-                RokhPref Session			= new RokhPref(SHAMChatApplication.getInstance().getApplicationContext());
+                RokhPref Session			= new RokhPref(getApplicationContext());
                 clientHandle	= Session.getClientHandle();
 
                 String topic = null;
@@ -2999,7 +3037,7 @@ private boolean addLeftRoomToGroup (String jsonMessageString){
 
                 try {
 
-                    mqttClient.unsubscribe(topic, SHAMChatApplication.getInstance().getApplicationContext(), null);
+                    mqttClient.unsubscribe(topic, getApplicationContext(), null);
                 }
                 catch (MqttSecurityException e) {
                     Log.e(this.getClass().getCanonicalName(), "Failed to unsubscribe to" + topic + " the client with the handle " + clientHandle, e);
@@ -3007,8 +3045,9 @@ private boolean addLeftRoomToGroup (String jsonMessageString){
                 catch (MqttException e) {
                     Log.e(this.getClass().getCanonicalName(), "Failed to unsubscribe to" + topic + " the client with the handle " + clientHandle, e);
                 }
-
-                mContentResolver.delete(ChatProviderNew.CONTENT_URI_THREAD, MessageThread.THREAD_ID + "=?", new String[] { threadId });
+//reza_ak
+         /*       mContentResolver.delete(ChatProviderNew.CONTENT_URI_THREAD, MessageThread.THREAD_ID + "=?", new String[] { threadId });
+         */
             }
 
 
@@ -3017,7 +3056,7 @@ private boolean addLeftRoomToGroup (String jsonMessageString){
                 ContentValues chatmessageVals = new ContentValues();
                 //add the group info message that user x left the room to chat messages inside group screen
                 chatmessageVals.put(ChatMessage.MESSAGE_RECIPIENT,
-                        SHAMChatApplication.getConfig().getUserId());
+                        userIdPub);
                 chatmessageVals.put(ChatMessage.MESSAGE_TYPE,
                         MyMessageType.INCOMING_MSG.ordinal());
                 chatmessageVals.put(ChatMessage.PACKET_ID, packetId);
@@ -3027,7 +3066,7 @@ private boolean addLeftRoomToGroup (String jsonMessageString){
                 chatmessageVals.put(ChatMessage.MESSAGE_CONTENT_TYPE,
                         MessageContentType.GROUP_INFO.ordinal());
                 chatmessageVals.put(ChatMessage.MESSAGE_STATUS,
-                        MessageStatusType.SEEN.ordinal());
+                        ChatMessage.MessageStatusType.SEEN.ordinal());
                 chatmessageVals.put(ChatMessage.FILE_SIZE, 0);
 
                 chatmessageVals.put(ChatMessage.GROUP_ID, groupId);
@@ -3035,15 +3074,15 @@ private boolean addLeftRoomToGroup (String jsonMessageString){
                 chatmessageVals.put(ChatMessage.MESSAGE_SENDER,
                         groupId);
                 chatmessageVals.put(ChatMessage.TEXT_MESSAGE, displayMessage);
-
-                if (mContentResolver.update(
+//reza_ak
+              /*  if (mContentResolver.update(
                         ChatProviderNew.CONTENT_URI_CHAT,
                         chatmessageVals, ChatMessage.PACKET_ID + "=?",
                         new String[]{packetId}) == 0) {
                     mContentResolver.insert(
                             ChatProviderNew.CONTENT_URI_CHAT,
                             chatmessageVals);
-                }
+                }*/
 
 
                 //send newMessage event so Chat thread fragment and also chatInitialorGroupActivity update the UI
@@ -3105,7 +3144,7 @@ private boolean  KickFromChannel (String jsonMessageString, Boolean kickAll) {
                     kickedMemberUserId = targetObject.getInt("user_id");
                 }
 
-                String threadId = SHAMChatApplication.getConfig().getUserId() + "-" + groupId;
+                String threadId = userIdPub+ "-" + groupId;
 
                 isChannel = hashcode.indexOf("ch") != -1;
                 if (isChannel) {
@@ -3113,35 +3152,33 @@ private boolean  KickFromChannel (String jsonMessageString, Boolean kickAll) {
                     //if we ourself were kicked from room
                     // delete the chat thread and unsubscribe from group
                     if(String.valueOf(kickedMemberUserId).equals(CURRENT_USER_ID) || kickAll) {
-
-                        SHAMChatApplication
-                                .getMyApplicationContext()
+//reza_ak
+                    /*  getApplicationContext()
                                 .getContentResolver()
                                 .delete(ChatProviderNew.CONTENT_URI_CHAT,
                                         ChatMessage.THREAD_ID + "=?",
                                         new String[]{threadId});
 
-                        SHAMChatApplication
-                                .getMyApplicationContext()
+                     getApplicationContext()
                                 .getContentResolver()
                                 .delete(ChatProviderNew.CONTENT_URI_THREAD,
                                         MessageThread.THREAD_ID + "=?",
-                                        new String[]{threadId});
+                                        new String[]{threadId});*/
 
+/*reza_ak
 
-                        SHAMChatApplication
-                                .getMyApplicationContext()
+                        getApplicationContext()
                                 .getContentResolver()
                                 .delete(UserProvider.CONTENT_URI_GROUP,
                                         "did_join_room=? OR friend_group_id=?",
                                         new String[]{groupId, groupId});
 
-                        SHAMChatApplication
-                                .getMyApplicationContext()
+                      getApplicationContext()
                                 .getContentResolver()
                                 .delete(UserProvider.CONTENT_URI_GROUP_MEMBER,
                                         "friend_group_id=? OR friend_id=?",
                                         new String[]{groupId, groupId});
+*/
 
 
                         String topic = null;
@@ -3155,7 +3192,7 @@ private boolean  KickFromChannel (String jsonMessageString, Boolean kickAll) {
 
 
                         try {
-                            mqttClient.unsubscribe(topic, SHAMChatApplication.getInstance().getApplicationContext(), null);
+                            mqttClient.unsubscribe(topic, getApplicationContext(), null);
 
 
                         } catch (MqttSecurityException e) {
@@ -3186,7 +3223,7 @@ private boolean addKickedFromRoomToGroup (String jsonMessageString){
             //update UI of group members listview
             //smackableImp --> line 2988
 
-            ContentResolver mContentResolver = SHAMChatApplication.getMyApplicationContext().getContentResolver();
+            ContentResolver mContentResolver = getApplicationContext().getContentResolver();
 
             JSONObject MessageObject = null;
             JSONObject topicObject = null;
@@ -3226,26 +3263,29 @@ private boolean addKickedFromRoomToGroup (String jsonMessageString){
             String groupId = hashcode;
             String userId = String.valueOf(kickedMemberUserId);
 
-            String threadId = SHAMChatApplication.getConfig().getUserId() + "-" + groupId;
+            String threadId = userIdPub + "-" + groupId;
 
             //delete user from table of friend group members
+            /*reza_ak
             mContentResolver.delete(UserProvider.CONTENT_URI_GROUP_MEMBER, FriendGroupMember.DB_GROUP + "=? AND "+ FriendGroupMember.DB_FRIEND + "=?", new String[] {groupId, userId });
 
-
-            String displayMessage = getContactNameFromPhone(SHAMChatApplication.getMyApplicationContext(),kickedMemberPhone) + " "+SHAMChatApplication.getInstance().getApplicationContext().getResources().getString(R.string.kicked_from_chat);
+*/
+            String displayMessage = getContactNameFromPhone(getApplicationContext(),kickedMemberPhone) + " "+"kicked_from_chat";
 
             //update the chat thread table to show message user x left the room
             ContentValues cvs = new ContentValues();
             cvs.put(MessageThread.LAST_MESSAGE, displayMessage);
-            mContentResolver.update(ChatProviderNew.CONTENT_URI_THREAD, cvs, MessageThread.THREAD_ID + "=?", new String[] { threadId });
 
+  //reza_ak
+          /*  mContentResolver.update(ChatProviderNew.CONTENT_URI_THREAD, cvs, MessageThread.THREAD_ID + "=?", new String[] { threadId });
+*/
 
             //if we ourself left the room  delete the chat thread and unsubscribe from group
             if(String.valueOf(kickedMemberUserId).equals(CURRENT_USER_ID)){
 
-                displayMessage = context.getString(R.string.you_were_kicked_from_room);
+                displayMessage = "you_were_kicked_from_room";
                 //Mast - unsubscribe from the group we are kicked from
-                RokhPref Session			= new RokhPref(SHAMChatApplication.getInstance().getApplicationContext());
+                RokhPref Session			= new RokhPref(getApplicationContext());
                 clientHandle	= Session.getClientHandle();
                 String topic = null;
 
@@ -3259,7 +3299,7 @@ private boolean addKickedFromRoomToGroup (String jsonMessageString){
 
 
                 try {
-                    mqttClient.unsubscribe(topic, SHAMChatApplication.getInstance().getApplicationContext(), null);
+                    mqttClient.unsubscribe(topic, getApplicationContext(), null);
 
 
                 }
@@ -3270,15 +3310,16 @@ private boolean addKickedFromRoomToGroup (String jsonMessageString){
                     Log.e(this.getClass().getCanonicalName(), "Failed to unsubscribe to" + topic + " the client with the handle " + clientHandle, e);
                 }
 
-                mContentResolver.delete(ChatProviderNew.CONTENT_URI_THREAD, MessageThread.THREAD_ID + "=?", new String[] { threadId });
-
+  //reza_ak
+                /*mContentResolver.delete(ChatProviderNew.CONTENT_URI_THREAD, MessageThread.THREAD_ID + "=?", new String[] { threadId });
+*/
 
             }
 
             ContentValues chatmessageVals = new ContentValues();
             //add the group info message that user x left the room to chat messages inside group screen
             chatmessageVals.put(ChatMessage.MESSAGE_RECIPIENT,
-                    SHAMChatApplication.getConfig().getUserId());
+                    userIdPub);
             chatmessageVals.put(ChatMessage.MESSAGE_TYPE,
                     MyMessageType.INCOMING_MSG.ordinal());
             chatmessageVals.put(ChatMessage.PACKET_ID,packetId);
@@ -3288,7 +3329,7 @@ private boolean addKickedFromRoomToGroup (String jsonMessageString){
             chatmessageVals.put(ChatMessage.MESSAGE_CONTENT_TYPE,
                     MessageContentType.GROUP_INFO.ordinal());
             chatmessageVals.put(ChatMessage.MESSAGE_STATUS,
-                    MessageStatusType.SEEN.ordinal());
+                    ChatMessage.MessageStatusType.SEEN.ordinal());
             chatmessageVals.put(ChatMessage.FILE_SIZE, 0);
 
             chatmessageVals.put(ChatMessage.GROUP_ID, groupId);
@@ -3296,15 +3337,15 @@ private boolean addKickedFromRoomToGroup (String jsonMessageString){
             chatmessageVals.put(ChatMessage.MESSAGE_SENDER,
                     groupId);
             chatmessageVals.put(ChatMessage.TEXT_MESSAGE, displayMessage);
-
-            if (mContentResolver.update(
+//reza_ak
+          /*  if (mContentResolver.update(
                     ChatProviderNew.CONTENT_URI_CHAT,
                     chatmessageVals, ChatMessage.PACKET_ID + "=?",
                     new String[] { packetId }) == 0) {
                 mContentResolver.insert(
                         ChatProviderNew.CONTENT_URI_CHAT,
                         chatmessageVals);
-            }
+            }*/
 
             //send newMessage event so Chat thread fragment and also chatInitialorGroupActivity update the UI
             //send a new message event so the ChatThreadFragment updates itself
@@ -3327,15 +3368,16 @@ private boolean addKickedFromRoomToGroup (String jsonMessageString){
 
             if (isChannel) {
 
-                SHAMChatApplication
-                        .getMyApplicationContext()
+                //reza_ak
+                /*
+
+                getApplicationContext()
                         .getContentResolver()
                         .delete(ChatProviderNew.CONTENT_URI_CHAT,
                                 ChatMessage.THREAD_ID + "=?",
                                 new String[]{threadId});
 
-                SHAMChatApplication
-                        .getMyApplicationContext()
+                getApplicationContext()
                         .getContentResolver()
                         .delete(ChatProviderNew.CONTENT_URI_THREAD,
                                 MessageThread.THREAD_ID + "=?",
@@ -3343,20 +3385,18 @@ private boolean addKickedFromRoomToGroup (String jsonMessageString){
 
 
 
-                SHAMChatApplication
-                        .getMyApplicationContext()
+                getApplicationContext()
                         .getContentResolver()
                         .delete(UserProvider.CONTENT_URI_GROUP,
                                 "did_join_room=? OR friend_group_id=?",
                                 new String[]{groupId, groupId});
 
-                SHAMChatApplication
-                        .getMyApplicationContext()
+                getApplicationContext()
                         .getContentResolver()
                         .delete(UserProvider.CONTENT_URI_GROUP_MEMBER,
                                 "friend_group_id=? OR friend_id=?",
                                 new String[]{groupId,groupId});
-
+*/
 
                 EventBus.getDefault().postSticky(new NewMessageEvent());
                 EventBus.getDefault().postSticky(new CloseGroupActivityEvent(threadId, groupId));
@@ -3384,7 +3424,7 @@ public void onEventMainThread(ChannelOnLeaveEvent event) {
                 }
 
                 try {
-                    mqttClient.unsubscribe(topic, SHAMChatApplication.getInstance().getApplicationContext(), null);
+                    mqttClient.unsubscribe(topic, getApplicationContext(), null);
 
 
                 } catch (MqttSecurityException e) {
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/ChannelOnLeaveEvent.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/ChannelOnLeaveEvent.java
new file mode 100644
index 000000000..0bf89c18f
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/ChannelOnLeaveEvent.java
@@ -0,0 +1,12 @@
+package org.telegram.messenger.shamChat;
+
+/**
+ * Created by msa on 27/03/2016.
+ */
+public class ChannelOnLeaveEvent {
+   public  String groupId ;
+
+     public ChannelOnLeaveEvent(String groupId) {
+        this.groupId = groupId ;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/ChatMessage.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/ChatMessage.java
new file mode 100644
index 000000000..e3df663b5
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/ChatMessage.java
@@ -0,0 +1,550 @@
+package org.telegram.messenger.shamChat;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.Log;
+
+
+
+public class ChatMessage implements Parcelable {
+
+	public static final String THREAD_ID = "thread_id";
+	public static final String MESSAGE_SENDER = "message_sender";
+	public static final String MESSAGE_RECIPIENT = "message_recipient";
+	public static  final  String CHANNEL_ID = "channel_id"  ;
+	public static final String MESSAGE_CONTENT_TYPE = "message_content_type";
+	public static final String TEXT_MESSAGE = "text_message";
+	public static final String BLOB_MESSAGE = "blob_message";
+	public static final String MESSAGE_DATETIME = "message_datetime";
+	public static final String LAST_UPDATED_DATE_TIME = "message_last_updated_datetime";
+	public static final String DELIVERED_DATETIME = "delivered_datetime";
+
+	public static final String CHANNEL_VIEW = "channel_view"; //// very important add
+
+
+	public static final String MESSAGE_STATUS = "message_status";
+	public static final String MESSAGE_TYPE = "message_type";
+
+	public static final String PACKET_ID = "packet_id";
+
+	public static final String DESCRIPTION = "description";
+
+	public static final String LONGITUDE = "longitude";
+	public static final String LATITUDE = "latitude";
+
+	public static final String SENDERS_MOBILE_NO = "senders_mobile_number";
+
+	public static final String FILE_SIZE = "file_size";
+	public static final String UPLOADED_PERCENTAGE = "uploaded_percentage";
+
+	public static final String FILE_URL = "file_url";
+
+	public static final String UPLOADED_FILE_URL = "uploaded_file_url";
+
+	public static final String GROUP_ID = "group_id";
+
+	public  static  final  String ISFORWARD =  "isforward" ;
+	public  static  final  String CHANNELTITLE =  "channeltitle" ;
+	public  static  final  String CHANNELHASHCODE =  "channelhashcode" ;
+	public  static  final  String ORGINALPACKETID =  "orgianlpacketid" ;
+
+
+
+
+	private int messageId;
+	private String threadId;
+
+	private String sender;
+	private String recipient;
+
+	private MessageContentTypeProvider.MessageContentType messageContentType;
+	private String textMessage;
+	private byte[] blobMessage;
+
+	private String messageDateTime;
+
+	private String lastUpdatedDateTime;
+
+	private String deliveredDateTime;
+
+	private boolean offlineSent;
+	private MyMessageType incomingMessage;
+
+	private boolean sentSeen;
+
+	private String packetId;
+
+	private String description;
+
+	private double longitude;
+	private double latitude;
+
+	private  String ViewChnnel = "0" ;
+
+	private String sendersMobileNumber;
+
+	private long fileSize;
+	private int uploadedPercentage;
+
+	private MessageStatusType messageStatus;
+
+	private String fileUrl;
+
+	private String uploadedFileUrl;
+
+	private User user;
+
+	private boolean isForward  ;
+	private  String ChannelTile , ChannelHashcode , OrginalPacketId ;
+
+
+	public  void setIsforward(boolean isForward) {this.isForward  =  isForward;}
+	public  void setChanneltitle(String ChannelTile) {this.ChannelTile = ChannelTile ;}
+	public  void setChannelHashcode (String ChannelHashcode) {this.ChannelHashcode = ChannelHashcode ;}
+	public void setOrginalPacketId (String OrginalPacketId) {this.OrginalPacketId = OrginalPacketId ;}
+	public boolean getIsforward () {return  this.isForward ; }
+	public  String getChanneltitle () {return  this.ChannelTile ; } ;
+	public  String getChannelhashcode () {return  this.ChannelHashcode ; }
+	public  String getOrginalpacketid () {return  this.OrginalPacketId ;}
+
+	@Override
+	public void writeToParcel(Parcel dest, int flags) {
+		dest.writeInt(messageId);
+		dest.writeString(threadId);
+
+		dest.writeString(sender);
+		dest.writeString(recipient);
+
+		dest.writeInt(messageContentType.getType());
+		dest.writeString(textMessage);
+		dest.writeInt(blobMessage.length);
+		dest.writeByteArray(blobMessage);
+
+		dest.writeLong(Utils.getDateFromStringDate(messageDateTime).getTime());
+		dest.writeLong(Utils.getDateFromStringDate(deliveredDateTime).getTime());
+
+		dest.writeInt(offlineSent ? 1 : 0);
+		dest.writeInt(incomingMessage.ordinal());
+
+		dest.writeInt(sentSeen ? 1 : 0);
+
+		dest.writeString(packetId);
+
+		dest.writeString(description);
+
+		dest.writeString(sendersMobileNumber);
+		dest.writeLong(fileSize);
+		dest.writeInt(uploadedPercentage);
+
+	}
+
+	public ChatMessage(Parcel in) {
+
+		setMessageId(in.readInt());
+		setThreadId(in.readString());
+
+		setSender(in.readString());
+		setRecipient(in.readString());
+//reza_ak
+		//setMessageContentType(readMessageContentType(in.readInt()));
+		setTextMessage(in.readString());
+		byte[] temp = new byte[in.readInt()];
+		in.readByteArray(temp);
+		setBlobMessage(temp);
+
+		setMessageDateTime(Utils.formatDate(in.readLong(),
+				"yyyy/MM/dd HH:mm:ss"));
+		setDeliveredDateTime(Utils.formatDate(in.readLong(),
+				"yyyy/MM/dd HH:mm:ss"));
+		setOfflineSent(in.readInt() == 1 ? true : false);
+		setIncomingMessage(readMessageType(in.readInt()));
+
+		setSentSeen(in.readInt() == 1 ? true : false);
+
+		setPacketId(in.readString());
+		setDescription(in.readString());
+
+		setSendersMobileNumber(in.readString());
+
+		setFileSize(in.readLong());
+		setUploadedPercentage(in.readInt());
+	}
+
+	private MyMessageType readMessageType(int type) {
+		MyMessageType messageType = MyMessageType.HEADER_MSG;
+		switch (type) {
+			case 0:
+				messageType = MyMessageType.OUTGOING_MSG;
+				break;
+			case 1:
+				messageType = MyMessageType.INCOMING_MSG;
+				break;
+
+		}
+		return messageType;
+	}
+//reza_ak
+/*	private MessageContentType readMessageContentType(int type) {
+		MessageContentType messageContentType = MessageContentType.TEXT;
+		switch (type) {
+			case 1:
+				messageContentType = MessageContentType.IMAGE;
+				break;
+			case 2:
+				messageContentType = MessageContentType.STICKER;
+				break;
+			case 3:
+				messageContentType = MessageContentType.VOICE_RECORD;
+				break;
+			case 4:
+				messageContentType = MessageContentType.FAVORITE;
+				break;
+			case 5:
+				messageContentType = MessageContentType.MESSAGE_WITH_IMOTICONS;
+				break;
+			case 6:
+				messageContentType = MessageContentType.LOCATION;
+				break;
+			case 7:
+				messageContentType = MessageContentType.INCOMING_CALL;
+				break;
+			case 8:
+				messageContentType = MessageContentType.OUTGOING_CALL;
+				break;
+			case 9:
+				messageContentType = MessageContentType.VIDEO;
+				break;
+			case 11:
+				messageContentType = MessageContentType.GROUP_INFO;
+				break;
+
+		}
+
+		return messageContentType;
+	}*/
+
+	public static final Creator<ChatMessage> CREATOR = new Creator<ChatMessage>() {
+		public ChatMessage createFromParcel(Parcel in) {
+			return new ChatMessage(in);
+		}
+
+		public ChatMessage[] newArray(int size) {
+			return new ChatMessage[size];
+		}
+	};
+//reza_ak
+	/*public ChatMessage(int messageId, String threadId,
+
+
+					   MessageContentType messageContentType, String textMessage,
+					   byte[] blobMessage, String messageDateTime,
+					   String deliverdDateTime, MyMessageType messageType,
+					   String packetId, String sender, String recipient,
+					   String description, double longitude, double latitude,
+					   String sendersMobileNumber, long fileSize, int uploadedPercentage,
+					   String fileUrl, MessageStatusType messageStatus,
+					   String lastUpdatedDateTime, String uploadedFileUrl , String ViewChnnel , boolean isForwarded , String ChannelTitle , String ChannelHashcode , String OrginalPacketId ) {
+
+		this.ViewChnnel  = ViewChnnel ;
+
+
+		setIsforward(isForwarded) ;
+
+		Log.d("isForwardedisForwarded" , isForwarded + " ss")  ;
+
+
+
+
+		if (isForwarded) {
+			setChanneltitle(ChannelTitle);
+			setChannelHashcode(ChannelHashcode);
+			setOrginalPacketId(OrginalPacketId);
+		}
+
+
+
+
+		setMessageId(messageId);
+		setThreadId(threadId);
+		setMessageContentType(messageContentType);
+		setTextMessage(textMessage);
+		setBlobMessage(blobMessage);
+
+		setMessageDateTime(messageDateTime);
+		setDeliveredDateTime(deliverdDateTime);
+
+		setOfflineSent(offlineSent);
+		setIncomingMessage(messageType);
+
+		setSentSeen(sentSeen);
+
+		setPacketId(packetId);
+		setSender(sender);
+		setRecipient(recipient);
+
+		setDescription(description);
+
+		setLongitude(longitude);
+		setLatitude(latitude);
+
+		setSendersMobileNumber(sendersMobileNumber);
+		setFileSize(fileSize);
+		setUploadedPercentage(uploadedPercentage);
+
+		setFileUrl(fileUrl);
+
+		setMessageStatus(messageStatus);
+
+		setLastUpdatedDateTime(lastUpdatedDateTime);
+
+		setUploadedFileUrl(uploadedFileUrl);
+	}*/
+
+	public ChatMessage() {
+
+	}
+
+	public enum MessageStatusType {
+		QUEUED(0), SENDING(1), SENT(2), DELIVERED(3) , SEEN(4), FAILED(5);
+
+		private int type ;
+
+		MessageStatusType(int type) {
+			this.setType(type);
+		}
+
+		public int getType() {
+			return type;
+		}
+
+		private void setType(int type) {
+			this.type = type;
+		}
+
+
+	}
+
+	public int getMessageId() {
+		return messageId;
+	}
+
+	public void setMessageId(int messageId) {
+		this.messageId = messageId;
+	}
+
+	public String getDeliveredDateTime() {
+		return deliveredDateTime;
+	}
+
+	public void setDeliveredDateTime(String deliveredDateTime) {
+		this.deliveredDateTime = deliveredDateTime;
+	}
+
+	/***
+	 * get message received time or sent time
+	 *
+	 * @return
+	 */
+	public String getMessageDateTime() {
+		return messageDateTime;
+	}
+
+	public void setMessageDateTime(String message_date) {
+		this.messageDateTime = message_date;
+	}
+
+	public byte[] getBlobMessage() {
+		return blobMessage;
+	}
+
+	/**
+	 * set message content(like images, sound files, stickers),
+	 *
+	 * @warning: message MessageType is directly effect on this
+	 * @param blobMessage
+	 */
+	public void setBlobMessage(byte[] blobMessage) {
+		this.blobMessage = blobMessage;
+	}
+
+	public MessageContentTypeProvider.MessageContentType getMessageContentType() {
+		return messageContentType;
+	}
+
+	public void setMessageContentType(MessageContentTypeProvider.MessageContentType messageContentType) {
+		this.messageContentType = messageContentType;
+	}
+
+	public String getThreadId() {
+		return threadId;
+	}
+
+	public void setThreadId(String threadId) {
+		this.threadId = threadId;
+	}
+
+	public String getTextMessage() {
+		return textMessage;
+	}
+
+	public void setTextMessage(String textMessage) {
+		this.textMessage = textMessage;
+	}
+
+	@Override
+	public int describeContents() {
+		return 0;
+	}
+
+	public boolean isOfflineSent() {
+		return offlineSent;
+	}
+
+	/***
+	 * message sent when
+	 *
+	 * @param offlineSent
+	 */
+	public void setOfflineSent(boolean offlineSent) {
+		this.offlineSent = offlineSent;
+	}
+
+	public MyMessageType getMessageType() {
+		return incomingMessage;
+	}
+
+	public void setIncomingMessage(MyMessageType messageType) {
+		this.incomingMessage = messageType;
+	}
+
+	public String getPacketId() {
+		return packetId;
+	}
+
+	public void setPacketId(String packetId) {
+		this.packetId = packetId;
+	}
+
+	public boolean isSentSeen() {
+		return sentSeen;
+	}
+
+	public void setSentSeen(boolean sentSeen) {
+		this.sentSeen = sentSeen;
+	}
+
+	public String getSender() {
+		return sender;
+	}
+
+	public void setSender(String sender) {
+		this.sender = sender;
+	}
+
+	public String getRecipient() {
+		return recipient;
+	}
+
+	public void setRecipient(String recipient) {
+		this.recipient = recipient;
+	}
+
+	public String getDescription() {
+		return description;
+	}
+
+	/***
+	 * you can set a description to a message
+	 *
+	 * @param description
+	 */
+	public void setDescription(String description) {
+		this.description = description;
+	}
+
+	public double getLongitude() {
+		return longitude;
+	}
+
+	public void setLongitude(double longitude) {
+		this.longitude = longitude;
+	}
+
+	public double getLatitude() {
+		return latitude;
+	}
+
+	public void setLatitude(double latitude) {
+		this.latitude = latitude;
+	}
+
+	public String getSendersMobileNumber() {
+		return sendersMobileNumber;
+	}
+
+	public void setSendersMobileNumber(String sendersMobileNumber) {
+		this.sendersMobileNumber = sendersMobileNumber;
+	}
+
+	public long getFileSize() {
+		return fileSize;
+	}
+
+	public void setFileSize(long fileSize) {
+		this.fileSize = fileSize;
+	}
+
+	public int getUploadedPercentage() {
+		return uploadedPercentage;
+	}
+
+	public void setUploadedPercentage(int uploadedPercentage) {
+		this.uploadedPercentage = uploadedPercentage;
+	}
+
+	public String getFileUrl() {
+		return fileUrl;
+	}
+
+	public void setFileUrl(String fileUrl) {
+		this.fileUrl = fileUrl;
+	}
+
+	public MessageStatusType getMessageStatus() {
+		return messageStatus;
+	}
+
+	public void setMessageStatus(MessageStatusType messageStatus) {
+		this.messageStatus = messageStatus;
+	}
+
+	public String getLastUpdatedDateTime() {
+		return lastUpdatedDateTime;
+	}
+
+	public void setLastUpdatedDateTime(String lastUpdatedDateTime) {
+		this.lastUpdatedDateTime = lastUpdatedDateTime;
+	}
+
+	public String getUploadedFileUrl() {
+		return uploadedFileUrl;
+	}
+
+	public void setUploadedFileUrl(String uploadedFileUrl) {
+		this.uploadedFileUrl = uploadedFileUrl;
+	}
+
+	public User getUser() {
+		return user;
+	}
+
+	public void setUser(User user) {
+		this.user = user;
+	}
+
+
+	public String getChannelView () {
+		return  this.ViewChnnel ;
+	}
+
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/ChatProviderNew.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/ChatProviderNew.java
new file mode 100644
index 000000000..b0b92f719
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/ChatProviderNew.java
@@ -0,0 +1,1870 @@
+/*
+package org.telegram.messenger.shamChat;
+
+import android.content.ContentProvider;
+import android.content.ContentResolver;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.UriMatcher;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.database.sqlite.SQLiteQueryBuilder;
+import android.net.Uri;
+import android.provider.BaseColumns;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.shamchat.adapters.EndlessScrollListener;
+import com.shamchat.androidclient.SHAMChatApplication;
+import com.shamchat.androidclient.chat.extension.MessageContentTypeProvider.MessageContentType;
+import com.shamchat.androidclient.data.RosterProvider.RosterConstants;
+import com.shamchat.androidclient.data.UserProvider.UserConstants;
+import com.shamchat.models.ChatMessage;
+import com.shamchat.models.ChatMessage.MessageStatusType;
+import com.shamchat.models.Message;
+import com.shamchat.models.MessageThread;
+import com.shamchat.models.User;
+import com.shamchat.utils.Utils;
+import com.squareup.okhttp.CacheControl;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+public class ChatProviderNew extends ContentProvider {
+
+	public static final String AUTHORITY = "org.zamin.androidclient.provider.Messages";
+	public static final String TABLE_NAME_CHATS = "chat_message";
+	public static final String TABLE_NAME_THREADS = "message_thread";
+	private static final String TABLE_NAME_FAVORITE = "favorite";
+	private static final String TABLE_NAME_FILE = "file_tb";
+
+	public static final Uri CONTENT_URI_CHAT = Uri.parse("content://"
+			+ AUTHORITY + "/" + TABLE_NAME_CHATS);
+
+	public static final Uri CONTENT_URI_THREAD = Uri.parse("content://"
+			+ AUTHORITY + "/" + TABLE_NAME_THREADS);
+
+	public static final Uri CONTENT_URI_FILE = Uri.parse("content://"
+			+ AUTHORITY + "/" + TABLE_NAME_FILE);
+
+
+
+
+
+
+
+
+
+	private static final UriMatcher URI_MATCHER = new UriMatcher(
+			UriMatcher.NO_MATCH);
+
+	private static final int MESSAGES = 1;
+	private static final int MESSAGE_ID = 2;
+	private static final int THREADS = 3;
+	private static final int THREAD_ID = 4;
+	private static final int FILES = 5;
+	private static final int FILE_ID = 6;
+
+	static {
+		URI_MATCHER.addURI(AUTHORITY, "chat_message", MESSAGES);
+		URI_MATCHER.addURI(AUTHORITY, "chat_message/#", MESSAGE_ID);
+		URI_MATCHER.addURI(AUTHORITY, "message_thread", THREADS);
+		URI_MATCHER.addURI(AUTHORITY, "message_thread/#", THREAD_ID);
+		URI_MATCHER.addURI(AUTHORITY, "file_tb", FILES);
+		URI_MATCHER.addURI(AUTHORITY, "file_tb/#", FILE_ID);
+
+
+	}
+
+	private static final String TAG = "zamin.ChatProviderNew";
+
+
+	private SQLiteOpenHelper mOpenHelper;
+
+
+	public ChatProviderNew() {
+	}
+
+
+
+	@Override
+	public int delete(Uri url, String where, String[] whereArgs) {
+		SQLiteDatabase db = mOpenHelper.getWritableDatabase();
+		int count;
+		String segment = null;
+		switch (URI_MATCHER.match(url)) {
+
+			case MESSAGES:
+				count = db.delete(TABLE_NAME_CHATS, where, whereArgs);
+				break;
+			case MESSAGE_ID:
+				segment = url.getPathSegments().get(1);
+
+				if (TextUtils.isEmpty(where)) {
+					where = "_id=" + segment;
+				} else {
+					where = "_id=" + segment + " AND (" + where + ")";
+				}
+
+				count = db.delete(TABLE_NAME_CHATS, where, whereArgs);
+				break;
+
+			case THREADS:
+				count = db.delete(TABLE_NAME_THREADS, where, whereArgs);
+				break;
+			case THREAD_ID:
+				segment = url.getPathSegments().get(1);
+
+				if (TextUtils.isEmpty(where)) {
+					where = "_id=" + segment;
+				} else {
+					where = "_id=" + segment + " AND (" + where + ")";
+				}
+
+				count = db.delete(TABLE_NAME_THREADS, where, whereArgs);
+				break;
+			case FILES :
+				count = db.delete(TABLE_NAME_FILE, where, whereArgs);
+				break;
+			case FILE_ID :
+				segment = url.getPathSegments().get(1);
+
+				if (TextUtils.isEmpty(where)) {
+					where = "_id=" + segment;
+				} else {
+					where = "_id=" + segment + " AND (" + where + ")";
+				}
+				count = db.delete(TABLE_NAME_FILE, where, whereArgs);
+
+				break;
+
+			default:
+				throw new IllegalArgumentException("Cannot delete from URL: " + url);
+		}
+
+		getContext().getContentResolver().notifyChange(url, null);
+		return count;
+	}
+
+	@Override
+	public String getType(Uri url) {
+		int match = URI_MATCHER.match(url);
+		switch (match) {
+			case MESSAGES:
+				return MessageConstants.CONTENT_CHAT_TYPE;
+			case MESSAGE_ID:
+				return MessageConstants.CONTENT_CHAT_ITEM_TYPE;
+			case THREADS:
+				return ThreadConstants.CONTENT_THREAD_TYPE;
+			case THREAD_ID:
+				return ThreadConstants.CONTENT_THREAD_ITEM_TYPE;
+			case FILES:
+				return FilesConstants.CONTENT_FILE_ITEM_TYPE;
+			case FILE_ID:
+				return FilesConstants.CONTENT_FILE_ITEM_TYPE;
+
+			default:
+				throw new IllegalArgumentException("Unknown URL");
+		}
+	}
+
+	@Override
+	public Uri insert(Uri url, ContentValues initialValues) {
+
+		ContentValues values = (initialValues != null) ? new ContentValues(
+				initialValues) : new ContentValues();
+
+		SQLiteDatabase db = mOpenHelper.getWritableDatabase();
+
+		long rowId = -1;
+
+		Uri noteUri = null;
+
+		switch (URI_MATCHER.match(url)) {
+
+			case MESSAGES:
+
+				for (String colName : MessageConstants.getRequiredColumns()) {
+					if (values.containsKey(colName) == false) {
+						throw new IllegalArgumentException("Missing column: "
+								+ colName);
+					}
+				}
+
+				rowId = db.insert(TABLE_NAME_CHATS, "", values);
+
+				if (rowId < 0) {
+					throw new SQLException(
+							"Failed to insert row into TABLE_NAME_CHATS" + url);
+				}
+
+				if (rowId > 0) {
+					Log.d(TAG, "Message successfully entered at " + rowId);
+				}
+
+				noteUri = ContentUris.withAppendedId(CONTENT_URI_CHAT, rowId);
+				getContext().getContentResolver().notifyChange(noteUri, null);
+				break;
+
+			case THREADS:
+
+				for (String colName : ThreadConstants.getRequiredColumns()) {
+					if (values.containsKey(colName) == false) {
+						throw new IllegalArgumentException("Missing column: "
+								+ colName);
+					}
+				}
+
+				rowId = db.insert(TABLE_NAME_THREADS, "", values);
+
+				if (rowId < 0) {
+					throw new SQLException(
+							"Failed to insert row into TABLE_NAME_THREADS" + url);
+				}
+
+				if (rowId > 0) {
+					Log.d(TAG, "Thread successfully entered at " + rowId);
+				}
+
+				noteUri = ContentUris.withAppendedId(CONTENT_URI_THREAD, rowId);
+				getContext().getContentResolver().notifyChange(noteUri, null);
+				break;
+
+
+			case  FILES :
+
+				for (String colName : FilesConstants.getRequiredColumns()) {
+					if (values.containsKey(colName) == false) {
+						throw new IllegalArgumentException("Missing column: "
+								+ colName);
+					}
+				}
+
+				rowId = db.insert(TABLE_NAME_FILE , "", values);
+
+				if (rowId < 0) {
+					throw new SQLException(
+							"Failed to insert row into TABLE_NAME_THREADS" + url);
+				}
+
+				if (rowId > 0) {
+					Log.d(TAG, "Thread successfully entered at " + rowId);
+				}
+
+				noteUri = ContentUris.withAppendedId(CONTENT_URI_FILE, rowId);
+				getContext().getContentResolver().notifyChange(noteUri, null);
+				break;
+
+			default:
+				throw new IllegalArgumentException("Cannot insert from URL: " + url);
+		}
+
+		return noteUri;
+	}
+
+	@Override
+	public boolean onCreate() {
+		mOpenHelper = new ChatDatabaseHelper(getContext());
+		return true;
+	}
+
+	@Override
+	public Cursor query(Uri url, String[] projectionIn, String selection,
+						String[] selectionArgs, String sortOrder) {
+
+		SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder();
+		int match = URI_MATCHER.match(url);
+
+		switch (match) {
+			case MESSAGES:
+				qBuilder.setTables(TABLE_NAME_CHATS);
+				break;
+			case MESSAGE_ID:
+				qBuilder.setTables(TABLE_NAME_CHATS);
+				qBuilder.appendWhere("_id=");
+				qBuilder.appendWhere(url.getPathSegments().get(1));
+				break;
+			case THREADS:
+				qBuilder.setTables(TABLE_NAME_THREADS);
+				break;
+			case THREAD_ID:
+				qBuilder.setTables(TABLE_NAME_THREADS);
+				qBuilder.appendWhere("_id=");
+				qBuilder.appendWhere(url.getPathSegments().get(1));
+				break;
+
+			case FILES:
+				qBuilder.setTables(TABLE_NAME_FILE);
+				break;
+			case FILE_ID:
+				qBuilder.setTables(TABLE_NAME_FILE);
+				qBuilder.appendWhere("_id=");
+				qBuilder.appendWhere(url.getPathSegments().get(1));
+				break;
+
+			default:
+				throw new IllegalArgumentException("Unknown URL " + url);
+		}
+
+		String orderBy;
+		if (TextUtils.isEmpty(sortOrder)) {
+			orderBy = MessageConstants.DEFAULT_SORT_ORDER;
+		} else {
+			orderBy = sortOrder;
+		}
+
+		SQLiteDatabase db = mOpenHelper.getReadableDatabase();
+		Cursor ret = qBuilder.query(db, projectionIn, selection, selectionArgs,
+				null, null, orderBy);
+
+		if (ret == null) {
+			infoLog("ChatProvider.query: failed");
+		} else {
+			ret.setNotificationUri(getContext().getContentResolver(), url);
+		}
+
+		return ret;
+	}
+
+	@Override
+	public int update(Uri url, ContentValues values, String where,
+					  String[] whereArgs) {
+		int count;
+		long rowId = 0;
+		String segment = null;
+		int match = URI_MATCHER.match(url);
+		SQLiteDatabase db = mOpenHelper.getWritableDatabase();
+
+		switch (match) {
+			case MESSAGES:
+				count = db.update(TABLE_NAME_CHATS, values, where, whereArgs);
+
+				if (count > 0) {
+					Log.d(TAG, "Message successfully updated " + count);
+				}
+
+				break;
+			case MESSAGE_ID:
+				segment = url.getPathSegments().get(1);
+				rowId = Long.parseLong(segment);
+				count = db.update(TABLE_NAME_CHATS, values, "_id=" + rowId, null);
+
+				Uri messageUri = ContentUris
+						.withAppendedId(CONTENT_URI_CHAT, rowId);
+				getContext().getContentResolver().notifyChange(messageUri, null);
+				getContext().getContentResolver().notifyChange(url, null);
+
+				return count;
+
+			case THREADS:
+				count = db.update(TABLE_NAME_THREADS, values, where, whereArgs);
+
+				if (count > 0) {
+					Log.d(TAG, "Thread successfully updated " + count);
+				}
+
+				break;
+			case THREAD_ID:
+				segment = url.getPathSegments().get(1);
+				rowId = Long.parseLong(segment);
+				count = db.update(TABLE_NAME_THREADS, values, where, whereArgs);
+
+				Uri noteUri = ContentUris.withAppendedId(CONTENT_URI_THREAD, rowId);
+				getContext().getContentResolver().notifyChange(noteUri, null);
+				getContext().getContentResolver().notifyChange(url, null);
+
+				return count;
+
+			case FILES:
+				count = db.update(TABLE_NAME_FILE , values, where, whereArgs);
+
+				if (count > 0) {
+					Log.d(TAG, "Thread successfully updated " + count);
+				}
+
+				break;
+
+			case FILE_ID:
+				segment = url.getPathSegments().get(1);
+				rowId = Long.parseLong(segment);
+				count = db.update(TABLE_NAME_FILE, values, where, whereArgs);
+
+				Uri noteUria = ContentUris.withAppendedId(CONTENT_URI_FILE, rowId);
+				getContext().getContentResolver().notifyChange(noteUria, null);
+				getContext().getContentResolver().notifyChange(url, null);
+				return count;
+
+			default:
+				throw new UnsupportedOperationException("Cannot update URL: " + url);
+		}
+
+		infoLog("*** notifyChange() rowId: " + rowId + " url " + url);
+
+		getContext().getContentResolver().notifyChange(url, null);
+		return count;
+
+	}
+
+	private static void infoLog(String data) {
+	}
+
+	public static class ChatDatabaseHelper extends SQLiteOpenHelper {
+
+		private static final String DATABASE_NAME = "chat.db";
+		private static final String USER_DATABASE_NAME = "user.db";
+		private static final int DATABASE_VERSION = 10 ;
+		private String CHAT_DATABASE_PATH;
+		private String USER_DATABASE_PATH;
+
+		public ChatDatabaseHelper(Context context) {
+			super(context, DATABASE_NAME, null, DATABASE_VERSION);
+			CHAT_DATABASE_PATH = context.getDatabasePath(DATABASE_NAME).toString();
+			USER_DATABASE_PATH = context.getDatabasePath(USER_DATABASE_NAME).toString();
+		}
+
+		@Override
+		public void onCreate(SQLiteDatabase db) {
+
+			String CREATE_TABLE_CHAT_MESSAGE = "CREATE TABLE IF NOT EXISTS "
+					+ TABLE_NAME_CHATS + " (" + MessageConstants._ID
+					+ " INTEGER PRIMARY KEY AUTOINCREMENT,"
+					+ ChatMessage.THREAD_ID + " TEXT , "
+					+ ChatMessage.MESSAGE_SENDER + " TEXT, "
+					+ ChatMessage.MESSAGE_RECIPIENT + " TEXT, "
+					+ ChatMessage.MESSAGE_CONTENT_TYPE + " INTEGER , "
+					+ ChatMessage.TEXT_MESSAGE + " TEXT , "
+					+ ChatMessage.BLOB_MESSAGE + " BLOB , "
+					+ ChatMessage.MESSAGE_DATETIME
+					+ " DATETIME DEFAULT (datetime('now','localtime')), "
+					+ ChatMessage.DELIVERED_DATETIME + " DATETIME, "
+					+ ChatMessage.MESSAGE_STATUS
+					+ " INTEGER NOT NULL DEFAULT 0, "
+					+ ChatMessage.MESSAGE_TYPE
+					+ " INTEGER NOT NULL  DEFAULT 0, "
+					+ ChatMessage.SENDERS_MOBILE_NO + " TEXT , "
+					+ ChatMessage.PACKET_ID + " TEXT, "
+					+ ChatMessage.DESCRIPTION + " TEXT, "
+					+ ChatMessage.LONGITUDE + " DOUBLE, "
+					+ ChatMessage.FILE_SIZE + " INTEGER NOT NULL DEFAULT 0, "
+					+ ChatMessage.FILE_URL + " TEXT , "
+					+ ChatMessage.UPLOADED_PERCENTAGE
+					+ " INTEGER NOT NULL DEFAULT 0, "
+					+ ChatMessage.LAST_UPDATED_DATE_TIME
+					+ " DATETIME DEFAULT (datetime('now','localtime')), "
+					+ ChatMessage.UPLOADED_FILE_URL + " TEXT , "
+					+ ChatMessage.GROUP_ID + " TEXT , " + ChatMessage.LATITUDE + " DOUBLE , "
+					+ ChatMessage.CHANNEL_VIEW + " TEXT NOT NULL DEFAULT '0' , "
+					+ ChatMessage.CHANNEL_ID + " INTEGER NOT NULL DEFAULT 0  , "
+					+ ChatMessage.ISFORWARD + " INTEGER NOT NULL DEFAULT 0  ,"
+					+ ChatMessage.CHANNELTITLE + " TEXT NOT NULL DEFAULT '0' ,  "
+					+ ChatMessage.CHANNELHASHCODE + " TEXT NOT NULL DEFAULT '0' , "
+					+ ChatMessage.ORGINALPACKETID + " TEXT NOT NULL DEFAULT '0' "
+					+ ")";
+
+
+
+			db.execSQL(CREATE_TABLE_CHAT_MESSAGE);
+
+			String CREATE_TABLE_CHAT_THREAD = "CREATE TABLE IF NOT EXISTS "
+					+ TABLE_NAME_THREADS + " (" + MessageConstants._ID
+					+ " INTEGER PRIMARY KEY AUTOINCREMENT,"
+					+ MessageThread.THREAD_ID + " TEXT NOT NULL , "
+					+ MessageThread.LAST_UPDATED_DATETIME
+					+ " DATETIME NOT NULL , " + MessageThread.THREAD_STATUS
+					+ " INTEGER NOT NULL  DEFAULT 1, "
+					+ MessageThread.IS_GROUP_CHAT
+					+ " INTEGER NOT NULL  DEFAULT 0, "
+					+ MessageThread.READ_STATUS
+					+ " INTEGER NOT NULL  DEFAULT 0, "
+					+ MessageThread.THREAD_OWNER + " TEXT NOT NULL, "
+					+ MessageThread.LAST_MESSAGE + " TEXT NOT NULL, "
+					+ MessageThread.LAST_MESSAGE_CONTENT_TYPE
+					+ " INTEGER NOT NULL  DEFAULT 0 , "
+					+ MessageThread.LAST_MESSAGE_DIRECTION
+					+ " INTEGER NOT NULL , " + MessageThread.FRIEND_ID
+					+ " TEXT NOT NULL" + ")";
+
+			db.execSQL(CREATE_TABLE_CHAT_THREAD);
+
+			String CREATE_TABLE_FAVORITE = "CREATE TABLE "
+					+ TABLE_NAME_FAVORITE + " (" + Message.DB_MESSAGE_ID
+					+ " TEXT PRIMARY KEY NOT NULL, " + Message.DB_MESSAGE_TYPE
+					+ " INTEGER, " + Message.DB_CONTENT + " TEXT, "
+					+ Message.DB_DELETED + " INTEGER NOT NULL DEFAULT 0 , "
+					+ Message.DB_USER_ID + " TEXT, " + Message.DB_TIME
+					+ " INTEGER" + ");";
+
+			db.execSQL(CREATE_TABLE_FAVORITE);
+
+
+
+
+            String PACKET_ID1 = "packet_id";
+            String FILE_URL = "file_url";
+
+			String CREATE_TABLE_FILE = "CREATE TABLE IF NOT EXISTS "
+					+ TABLE_NAME_FILE + " (" + MessageConstants._ID
+					+ " INTEGER PRIMARY KEY AUTOINCREMENT,"
+					+ PACKET_ID1 + " TEXT NOT NULL , "
+					+ FILE_URL + " TEXT NOT NULL  " + ")";
+
+
+
+			db.execSQL(CREATE_TABLE_FILE);
+
+
+
+		}
+
+		@Override
+		public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+			infoLog("onUpgrade: from " + oldVersion + " to " + newVersion);
+			switch (oldVersion) {
+				case 5:
+
+					db.execSQL("ALTER TABLE " + TABLE_NAME_CHATS + " ADD " + ChatMessage.CHANNEL_VIEW + " TEXT NOT NULL DEFAULT '0' ");
+					db.execSQL("ALTER TABLE " + TABLE_NAME_CHATS + " ADD " + ChatMessage.CHANNEL_ID + " INTEGER NOT NULL DEFAULT 0 ");
+
+				case 6 :
+					db.execSQL("ALTER TABLE " + TABLE_NAME_CHATS + " ADD " + ChatMessage.ISFORWARD + " INTEGER NOT NULL DEFAULT 0 ");
+					db.execSQL("ALTER TABLE " + TABLE_NAME_CHATS + " ADD " + ChatMessage.CHANNELTITLE + " TEXT NOT NULL DEFAULT '0' ");
+					db.execSQL("ALTER TABLE " + TABLE_NAME_CHATS + " ADD " + ChatMessage.CHANNELHASHCODE + " TEXT NOT NULL DEFAULT '0' ");
+					db.execSQL("ALTER TABLE " + TABLE_NAME_CHATS + " ADD " + ChatMessage.ORGINALPACKETID + " TEXT NOT NULL DEFAULT '0' ");
+
+				case 9 :
+
+                   String PACKET_ID1 = "packet_id";
+                    String FILE_URL = "file_url";
+
+					String CREATE_TABLE_FILE = "CREATE TABLE IF NOT EXISTS "
+							+ TABLE_NAME_FILE + " (" + MessageConstants._ID
+							+ " INTEGER PRIMARY KEY AUTOINCREMENT,"
+							+ PACKET_ID1 + " TEXT NOT NULL , "
+							+ FILE_URL + " TEXT NOT NULL  " + ")";
+
+
+					db.execSQL(CREATE_TABLE_FILE);
+
+					break;
+				// case 3:
+				// db.execSQL("UPDATE " + TABLE_NAME + " SET READ=1");
+				// case 4:
+				// db.execSQL("ALTER TABLE " + TABLE_NAME + " ADD " +
+				// ChatConstants.PACKET_ID + " TEXT");
+				// break;
+				// default:
+				// db.execSQL("DROP TABLE IF EXISTS " + TABLE_NAME);
+				// onCreate(db);
+			}
+		}
+
+	}
+
+	public static final class MessageConstants implements BaseColumns {
+
+		private MessageConstants() {
+		}
+
+		public static final String CONTENT_CHAT_TYPE = "vnd.android.cursor.dir/vnd.zamin.message";
+		public static final String CONTENT_CHAT_ITEM_TYPE = "vnd.android.cursor.item/vnd.zamin.message";
+
+		public static final String DEFAULT_SORT_ORDER = "_id ASC"; // sort by
+		// auto-id
+
+		public static ArrayList<String> getRequiredColumns() {
+			ArrayList<String> tmpList = new ArrayList<String>();
+			tmpList.add(ChatMessage.PACKET_ID);
+			tmpList.add(ChatMessage.MESSAGE_SENDER);
+			tmpList.add(ChatMessage.MESSAGE_RECIPIENT);
+			tmpList.add(ChatMessage.THREAD_ID);
+			return tmpList;
+		}
+	}
+
+
+	public static final class FilesConstants implements BaseColumns {
+
+		private FilesConstants() {
+		}
+
+		public static final String CONTENT_FILE_TYPE = "vnd.android.cursor.dir/vnd.zamin.files";
+		public static final String CONTENT_FILE_ITEM_TYPE = "vnd.android.cursor.item/vnd.zamin.fils";
+
+		public static final String DEFAULT_SORT_ORDER = "_id ASC"; // sort by
+		// auto-id
+
+		public static ArrayList<String> getRequiredColumns() {
+			ArrayList<String> tmpList = new ArrayList<String>();
+			tmpList.add("packet_id");
+			tmpList.add("file_url");
+			return tmpList;
+		}
+	}
+
+
+	public static final class ThreadConstants implements BaseColumns {
+
+		private ThreadConstants() {
+		}
+
+		public static final String CONTENT_THREAD_TYPE = "vnd.android.cursor.dir/vnd.zamin.thread";
+		public static final String CONTENT_THREAD_ITEM_TYPE = "vnd.android.cursor.item/vnd.zamin.thread";
+
+		public static ArrayList<String> getRequiredColumns() {
+			ArrayList<String> tmpList = new ArrayList<String>();
+			tmpList.add(MessageThread.THREAD_ID);
+			tmpList.add(MessageThread.FRIEND_ID);
+			return tmpList;
+		}
+
+	}
+
+	public List<ChatMessage> getAllMessagesByThreadIdAsList(String threadId,
+															String currentLoadedIndex) {
+
+
+		String orderBy = "" ;
+		if (threadId.indexOf("-ch") != -1 ) {
+			Log.d("tegg" , "true") ;
+			orderBy = ChatMessage.MESSAGE_DATETIME ;
+		}else {
+			orderBy = "_id";
+		}
+
+		List<ChatMessage> listMsg = new ArrayList<ChatMessage>();
+
+		Cursor cursor = SHAMChatApplication
+				.getMyApplicationContext()
+				.getContentResolver()
+				.query(ChatProviderNew.CONTENT_URI_CHAT,
+						null,
+						ChatMessage.THREAD_ID + "=?",
+						new String[] { threadId },
+						MessageConstants._ID + " DESC LIMIT "
+								+ currentLoadedIndex + " ");
+
+		if (cursor != null && cursor.getCount() > 0) {
+			while (cursor.moveToNext()) {
+
+				listMsg.add(getChatMessageByCursor(cursor));
+
+			}
+		}
+
+		cursor.close();
+
+		Collections.reverse(listMsg);
+		return listMsg;
+
+	}
+
+	public ChatMessage getChatMessageByCursor(Cursor cursor) {
+		int messageId = cursor.getInt(cursor.getColumnIndex(MessageConstants._ID));
+
+		String ChannelView = cursor.getString(cursor.getColumnIndex(ChatMessage.CHANNEL_VIEW)) ;
+		Log.d("isForwardedisForwarded" , cursor.getInt(cursor.getColumnIndex(ChatMessage.ISFORWARD)) + "" ) ;
+
+		boolean isForward = cursor.getInt(cursor.getColumnIndex(ChatMessage.ISFORWARD)) == 1  ;
+		String ChannelTitle = cursor.getString(cursor.getColumnIndex(ChatMessage.CHANNELTITLE)) ;
+		String ChannelHashcode = cursor.getString(cursor.getColumnIndex(ChatMessage.CHANNELHASHCODE)) ;
+		String orginalPacketId = cursor.getString(cursor.getColumnIndex(ChatMessage.ORGINALPACKETID)) ;
+
+
+		MessageContentType messageContentType = readMessageContentType(cursor
+				.getInt(cursor.getColumnIndex(ChatMessage.MESSAGE_CONTENT_TYPE)));
+		String textMessage = cursor.getString(cursor
+				.getColumnIndex(ChatMessage.TEXT_MESSAGE));
+
+		byte[] blobMessage = cursor.getBlob(cursor
+				.getColumnIndex(ChatMessage.BLOB_MESSAGE));
+
+		String messageDateTime = cursor.getString(cursor
+				.getColumnIndex(ChatMessage.MESSAGE_DATETIME));
+
+		int messageStatus = cursor.getInt(cursor
+				.getColumnIndex(ChatMessage.MESSAGE_STATUS));
+
+		String deliverdDateTime = cursor.getString(cursor
+				.getColumnIndex(ChatMessage.DELIVERED_DATETIME));
+
+		int messageType = cursor.getInt(cursor.getColumnIndex(ChatMessage.MESSAGE_TYPE));
+		String packetId = cursor.getString(cursor.getColumnIndex(ChatMessage.PACKET_ID));
+
+		String sender = cursor.getString(cursor
+				.getColumnIndex(ChatMessage.MESSAGE_SENDER));
+		String recipient = cursor.getString(cursor
+				.getColumnIndex(ChatMessage.MESSAGE_RECIPIENT));
+
+		String description = cursor.getString(cursor
+				.getColumnIndex(ChatMessage.DESCRIPTION));
+
+		double longitude = cursor.getDouble(cursor
+				.getColumnIndex(ChatMessage.LONGITUDE));
+		double latitude = cursor.getDouble(cursor
+				.getColumnIndex(ChatMessage.LATITUDE));
+		String sendersMobileNumber = cursor.getString(cursor
+				.getColumnIndex(ChatMessage.SENDERS_MOBILE_NO));
+
+		long fileSize = cursor.getLong(cursor
+				.getColumnIndex(ChatMessage.FILE_SIZE));
+
+		int uploadedPercentage = cursor.getInt(cursor
+				.getColumnIndex(ChatMessage.UPLOADED_PERCENTAGE));
+
+		String fileUrl = cursor.getString(cursor
+				.getColumnIndex(ChatMessage.FILE_URL));
+
+		String threadId = cursor.getString(cursor
+				.getColumnIndex(ChatMessage.THREAD_ID));
+
+		String lastUpdatedDateTime = cursor.getString(cursor
+				.getColumnIndex(ChatMessage.LAST_UPDATED_DATE_TIME));
+
+		String uploadedFileUrl = cursor.getString(cursor
+				.getColumnIndex(ChatMessage.UPLOADED_FILE_URL));
+
+		*/
+/**
+		 * Get the user
+		 *//*
+
+
+		String tmpUserId = sender;
+
+		System.out.println("INCOMING SENDER "+sender);
+
+		if (sender.startsWith("g") || sender.startsWith("ch")|| sender.substring( sender.indexOf("-")+1).startsWith("s")) {
+
+			switch (messageContentType) {
+				case FAVORITE:
+					System.out.println("INCOMING CPN FAVORITE " +textMessage);
+					break;
+				case IMAGE:
+					System.out.println("INCOMING CPN IMAGE  " +textMessage);
+					break;
+				case INCOMING_CALL:
+					System.out.println("INCOMING CPN CALL  " +textMessage);
+
+					break;
+				case LOCATION:
+					System.out.println("INCOMING CPN LOCATION  " +textMessage);
+
+					break;
+				case OUTGOING_CALL:
+					System.out.println("INCOMING CPN OUTGOING_CALL " +textMessage);
+					break;
+				case STICKER:
+					System.out.println("INCOMING CPN STICKER " +textMessage);
+
+					String data[] = textMessage.split("-");
+
+					tmpUserId = data[1];
+
+					break;
+				case TEXT:
+					System.out.println("INCOMING CPN TEXT " +textMessage);
+					break;
+				case VOICE_RECORD:
+					System.out.println("INCOMING CPN VOICE_RECORD " +textMessage);
+					break;
+				case VIDEO:
+					System.out.println("INCOMING CPN VIDEO " +textMessage);
+					break;
+
+				case GROUP_INFO:
+					System.out.println("INCOMING CPN GROUP_INFO " +textMessage);
+					break;
+				default:
+					System.out.println("INCOMING CPN DEFAULT " +textMessage);
+					break;
+			}
+
+		} else {
+			tmpUserId = sender;
+		}
+		ContentResolver contentResolver = SHAMChatApplication
+				.getMyApplicationContext().getContentResolver();
+
+		Cursor friendCursor = contentResolver.query(
+				UserProvider.CONTENT_URI_USER, null, UserConstants.USER_ID
+						+ "=?", new String[] { tmpUserId }, null);
+
+		User user = null;
+		if (friendCursor != null && friendCursor.getCount() > 0) {
+			friendCursor.moveToFirst();
+
+			System.out.println("INCOMING CPN USER FOUND "+tmpUserId);
+			user = new User();
+
+			String userId = friendCursor.getString(friendCursor
+					.getColumnIndex(UserConstants.USER_ID));
+			user.setUserId(userId);
+
+			String username = friendCursor.getString(friendCursor
+					.getColumnIndex(UserConstants.USERNAME));
+			user.setUsername(username);
+
+			String friendMobileNo = friendCursor.getString(friendCursor
+					.getColumnIndex(UserConstants.MOBILE_NO));
+
+			user.setMobileNo(friendMobileNo);
+
+			String profileImageUrl = friendCursor.getString(friendCursor
+					.getColumnIndex(UserConstants.PROFILE_IMAGE_URL));
+			user.setprofileImageUrl(profileImageUrl);
+		} else {
+
+			System.out.println("INCOMING CPN USER NOT FOUND "+tmpUserId);
+		}
+		friendCursor.close();
+
+		ChatMessage c = new ChatMessage(messageId, threadId,
+				messageContentType, textMessage, blobMessage, messageDateTime,
+				deliverdDateTime, readMessageType(messageType), packetId,
+				sender, recipient, description, longitude, latitude,
+				sendersMobileNumber, fileSize, uploadedPercentage, fileUrl,
+				readMessageStatus(messageStatus), lastUpdatedDateTime,
+				uploadedFileUrl ,  ChannelView,isForward,ChannelTitle,ChannelHashcode,orginalPacketId);
+
+		c.setUser(user);
+
+		return c;
+	}
+
+	private MyMessageType readMessageType(int type) {
+		MyMessageType messageType = MyMessageType.HEADER_MSG;
+		switch (type) {
+			case 0:
+				messageType = MyMessageType.OUTGOING_MSG;
+				break;
+			case 1:
+				messageType = MyMessageType.INCOMING_MSG;
+				break;
+
+		}
+		return messageType;
+	}
+
+
+	public static MessageStatusType readMessageStatus(int type) {
+
+		MessageStatusType messageType = MessageStatusType.QUEUED;
+
+		switch (type) {
+			case 1:
+				messageType = MessageStatusType.SENDING;
+				break;
+			case 2:
+				messageType = MessageStatusType.SENT;
+				break;
+			case 3:
+				messageType = MessageStatusType.DELIVERED;
+				break;
+			case 4:
+				messageType = MessageStatusType.SEEN;
+				break;
+			case 5:
+				messageType = MessageStatusType.FAILED;
+				break;
+
+		}
+
+		return messageType;
+	}
+
+	public static MessageContentType readMessageContentType(int type) {
+		MessageContentType messageType = MessageContentType.TEXT;
+		switch (type) {
+			case 1:
+				messageType = MessageContentType.IMAGE;
+				break;
+			case 2:
+				messageType = MessageContentType.STICKER;
+				break;
+			case 3:
+				messageType = MessageContentType.VOICE_RECORD;
+				break;
+			case 4:
+				messageType = MessageContentType.FAVORITE;
+				break;
+			case 5:
+				messageType = MessageContentType.MESSAGE_WITH_IMOTICONS;
+				break;
+			case 6:
+				messageType = MessageContentType.LOCATION;
+				break;
+			case 7:
+				messageType = MessageContentType.INCOMING_CALL;
+				break;
+			case 8:
+				messageType = MessageContentType.OUTGOING_CALL;
+				break;
+			case 9:
+				messageType = MessageContentType.VIDEO;
+				break;
+			case 10:
+				messageType = MessageContentType.MISSED_CALL;
+				break;
+			case 11:
+				messageType = MessageContentType.GROUP_INFO;
+				break;
+		}
+
+		return messageType;
+	}
+
+
+	*/
+/**
+	 * This loads n rows before the specified packetId row
+	 * @param packetId
+	 * @param threadId
+	 * @param limit
+	 * @return
+	 *//*
+
+	public ArrayList<ChatMessage> loadDataSet(String packetId, String threadId,int appendDirection, int limit) {
+		return loadDataSet( packetId, threadId, appendDirection, limit, "Desc", false);
+	}
+	*/
+/**
+	 * This loads n rows before the specified packetId row
+	 * @param packetId
+	 * @param threadId
+	 * @param limit
+	 * @return
+	 *//*
+
+	public ArrayList<ChatMessage> loadDataSet(String packetId, String threadId,int appendDirection, int limit, String descAsc, boolean forceReverse) {
+
+		User me = getUser(SHAMChatApplication.getConfig().getUserId());
+
+		ArrayList<ChatMessage> listMsg = new ArrayList<ChatMessage>();
+
+		if (me != null) {
+
+			int _id = 0;
+
+			ChatDatabaseHelper databaseHelper = new ChatDatabaseHelper(SHAMChatApplication.getMyApplicationContext());
+			SQLiteDatabase db = databaseHelper.getReadableDatabase();
+
+			//get _id of message from database
+			String[] tableColumns = new String[] {"_id"};
+			String orderBy = null  ;
+
+			Log.d("tegg" , "trues") ;
+			if (threadId.indexOf("-ch") != -1 ) {
+				Log.d("tegg" , "true") ;
+				orderBy = ChatMessage.MESSAGE_DATETIME ;
+			}else {
+				orderBy = "_id";
+			}
+
+			Cursor cursor = db.query(TABLE_NAME_CHATS, tableColumns,
+					ChatMessage.PACKET_ID + "=? OR _id=?",
+
+					new String[] { packetId, packetId }, null, null, orderBy);
+
+			if (cursor != null && cursor.getCount() > 0) {
+				cursor.moveToFirst();
+				_id = cursor.getInt(cursor.getColumnIndex(MessageConstants._ID));
+			}
+
+
+			String[] selectionArgs = new String[] {
+					threadId,
+					String.valueOf(_id)
+			};
+
+			String operator = (appendDirection == EndlessScrollListener.SCROLL_DIRECTION_UP) ? "<" : ">";
+
+			Log.i("scrolldown", "loading from packet number to bottom: "+ String.valueOf(_id));
+
+			String queryString = "SELECT * FROM (select * from "+TABLE_NAME_CHATS+" where thread_id=?) alias_name WHERE _id "+operator+" ? ORDER BY "+orderBy+" "+descAsc+" limit 0,"+limit;
+			cursor = db.rawQuery(queryString, selectionArgs);
+			if (cursor.moveToFirst()) {
+				do {
+					ChatMessage chatMessage = getChatMessageByCursor(cursor);
+
+
+					String sender = chatMessage.getSender();
+					System.out.println("chat message sender "+ chatMessage.getSender());
+
+					if (me.getUserId().equals(sender)) {
+						chatMessage.setUser(me);
+					} else {
+
+						if (!sender.startsWith("g") && !sender.startsWith("ch")|| !sender.substring( sender.indexOf("-")+1).startsWith("s")) {
+							chatMessage.setUser(getUser(chatMessage.getSender()));
+						}
+					}
+					listMsg.add(chatMessage);
+				} while (cursor.moveToNext());
+
+
+			}
+
+
+			cursor.close();
+			db.close();
+		}
+
+		if (forceReverse) {
+			Collections.reverse(listMsg);
+		}
+
+		return listMsg;
+	}
+
+
+	public ArrayList<ChatMessage> ChannelDataLoad (String firstItemAdded , String ThreadId) {
+		Cursor cursor = null ;
+		ChatDatabaseHelper databaseHelper = new ChatDatabaseHelper(SHAMChatApplication.getMyApplicationContext());
+		SQLiteDatabase db = databaseHelper.getReadableDatabase();
+
+		User me = getUser(SHAMChatApplication.getConfig().getUserId());
+		ArrayList<ChatMessage> listMsg = new ArrayList<ChatMessage>();
+
+		String queryString = "SELECT * FROM  "+TABLE_NAME_CHATS+" WHERE thread_id=? AND _id >= ? ORDER BY "+ChatMessage.MESSAGE_DATETIME+" DESC " ;
+
+		String[] selectionArgs = new String[] {
+				ThreadId,
+				String.valueOf(firstItemAdded)
+		};
+
+		cursor = db.rawQuery(queryString, selectionArgs);
+		if (cursor.moveToFirst()) {
+			do {
+				ChatMessage chatMessage = getChatMessageByCursor(cursor);
+
+
+				String sender = chatMessage.getSender();
+				System.out.println("chat message sender "+ chatMessage.getSender());
+
+				if (me.getUserId().equals(sender)) {
+					chatMessage.setUser(me);
+				} else {
+
+					if (!sender.startsWith("g") && !sender.startsWith("ch")|| !sender.substring( sender.indexOf("-")+1).startsWith("s")) {
+						chatMessage.setUser(getUser(chatMessage.getSender()));
+					}
+				}
+				listMsg.add(chatMessage);
+			} while (cursor.moveToNext());
+
+
+		}
+
+
+		return  listMsg ;
+	}
+
+	*/
+/**
+	 * This checks if this packetId is the last record of database
+	 * according to top or bottom direction
+	 * * @param packetId
+	 * @param threadId
+	 * @param direction
+	 * @return
+	 *//*
+
+	public boolean isLastRecord(String packetId,String threadId,int direction) {
+		String orderBy = "" ;
+		if (threadId.indexOf("-ch") != -1 ) {
+			Log.d("tegg" , "true") ;
+			orderBy = ChatMessage.MESSAGE_DATETIME ;
+		}else {
+			orderBy = "_id";
+		}
+
+		ChatDatabaseHelper databaseHelper = new ChatDatabaseHelper(SHAMChatApplication.getMyApplicationContext());
+		SQLiteDatabase db = databaseHelper.getReadableDatabase();
+
+
+		String[] selectionArgs = new String[] {threadId};
+		String operator = (direction == EndlessScrollListener.SCROLL_DIRECTION_UP) ? "min" : "max";
+
+		int lastMessageId=0;
+		String lastMessagepacketId=null;
+		//String queryString = "SELECT * FROM (select * from "+TABLE_NAME_CHATS+" where thread_id=?) alias_name WHERE _id "+operator+" ? ORDER BY _id DESC limit 0,"+limit;
+		String queryLastRow = "select "+operator+"(_id),_id,packet_id from "+TABLE_NAME_CHATS+" where thread_id=?";
+
+		Cursor cursor = db.rawQuery(queryLastRow, selectionArgs);
+		if (cursor.moveToFirst()) {
+			do {
+				lastMessageId = cursor.getInt(cursor.getColumnIndex(MessageConstants._ID));
+				lastMessagepacketId = cursor.getString(cursor.getColumnIndex(ChatMessage.PACKET_ID));
+			} while (cursor.moveToNext());
+		}
+
+		cursor.close();
+		db.close();
+
+		if (lastMessagepacketId.equals(packetId)) return true;
+		else return false;
+	}
+
+
+	*/
+/**
+	 * This checks if this packetId is the last record of database
+	 * according to top or bottom direction
+	 * * @param packetId
+	 * @param threadId
+	 * @param direction
+	 * @return
+	 *//*
+
+	public boolean previousToLastRecord(String packetId,String threadId,int direction) {
+
+		ChatDatabaseHelper databaseHelper = new ChatDatabaseHelper(SHAMChatApplication.getMyApplicationContext());
+		SQLiteDatabase db = databaseHelper.getReadableDatabase();
+
+		String orderBy = "" ;
+		if (threadId.indexOf("-ch") != -1 ) {
+			Log.d("tegg" , "true") ;
+			orderBy = ChatMessage.MESSAGE_DATETIME ;
+		}else {
+			orderBy = "_id";
+		}
+
+
+		String[] selectionArgs = new String[] {threadId};
+		String operator = (direction == EndlessScrollListener.SCROLL_DIRECTION_UP) ? "Asc" : "Desc";
+
+		int beforeLastMessageId=0;
+		String beforeLastMessagepacketId=null;
+		//String queryString = "SELECT * FROM (select * from "+TABLE_NAME_CHATS+" where thread_id=?) alias_name WHERE _id "+operator+" ? ORDER BY _id DESC limit 0,"+limit;
+		String queryLastRow = "select _id,packet_id from "+TABLE_NAME_CHATS+" where thread_id=?  ORDER BY "+orderBy+" "+operator+" limit 1,1";
+
+		Cursor cursor = db.rawQuery(queryLastRow, selectionArgs);
+
+		if (cursor.moveToFirst()) {
+			beforeLastMessageId = cursor.getInt(cursor.getColumnIndex(MessageConstants._ID));
+			beforeLastMessagepacketId = cursor.getString(cursor.getColumnIndex(ChatMessage.PACKET_ID));
+		}
+
+		cursor.close();
+		db.close();
+
+		if (beforeLastMessagepacketId.equals(packetId)) return true;
+		else return false;
+	}
+
+	*/
+/**
+	 * returns the last message of a threadId
+	 * @param threadId
+	 * @return
+	 *//*
+
+	public ChatMessage getLastMessageFromDB(String threadId) {
+
+		String orderBy = "" ;
+		if (threadId.indexOf("-ch") != -1 ) {
+
+			orderBy = ChatMessage.MESSAGE_DATETIME ;
+		}else {
+
+		}
+
+		orderBy = "_id";
+
+		ChatDatabaseHelper databaseHelper = new ChatDatabaseHelper(SHAMChatApplication.getMyApplicationContext());
+		SQLiteDatabase db = databaseHelper.getReadableDatabase();
+
+
+		String[] selectionArgs = new String[] {threadId};
+
+		String queryLastRow = "SELECT * FROM "+TABLE_NAME_CHATS+" WHERE thread_id=? ORDER BY "+orderBy+" DESC LIMIT 1";
+
+		Cursor cursor = db.rawQuery(queryLastRow, selectionArgs);
+		ChatMessage c = null;
+
+		if (cursor.moveToFirst()) {
+			c = getChatMessageByCursor(cursor);
+		}
+
+		cursor.close();
+		db.close();
+
+		return c;
+	}
+
+	*/
+/**
+	 * returns the message object from a packetId
+	 * @param packetId
+	 * @return
+	 *//*
+
+	public ChatMessage getMessageFromDB(String packetId) {
+
+		User me = getUser(SHAMChatApplication.getConfig().getUserId());
+
+		Cursor cursor = SHAMChatApplication.getMyApplicationContext().getContentResolver()
+				.query(ChatProviderNew.CONTENT_URI_CHAT, null,
+						ChatMessage.PACKET_ID + "=? OR _id=?",
+						new String[] { packetId, packetId }, null);
+
+		ChatMessage chatMessage = null;
+
+		if (cursor != null && cursor.getCount() > 0) {
+			cursor.moveToFirst();
+
+			chatMessage = getChatMessageByCursor(cursor);
+
+			String sender = chatMessage.getSender();
+			System.out.println("chat message sender "+ chatMessage.getSender());
+
+			if (me.getUserId().equals(sender)) {
+				chatMessage.setUser(me);
+			} else {
+
+				if (!sender.startsWith("g") && !sender.startsWith("ch") || !sender.substring( sender.indexOf("-")+1).startsWith("s")) {
+					chatMessage.setUser(getUser(chatMessage.getSender()));
+				}
+			}
+
+
+		}
+
+		cursor.close();
+
+		return chatMessage;
+	}
+
+
+	*/
+/**
+	 * This sets last N messages of a thread as unread
+	 * used this for debugging
+	 * @param threadId
+	 * @param limit
+	 * @return
+	 *//*
+
+	public ArrayList<ChatMessage> setAsUnread(String threadId, int limit) {
+
+		String orderBy = "" ;
+		if (threadId.indexOf("-ch") != -1 ) {
+			Log.d("tegg" , "true") ;
+			orderBy = ChatMessage.MESSAGE_DATETIME ;
+		}else {
+			orderBy = "_id";
+		}
+
+		User me = getUser(SHAMChatApplication.getConfig().getUserId());
+
+		ArrayList<ChatMessage> listMsg = new ArrayList<ChatMessage>();
+
+		if (me != null) {
+
+			ChatDatabaseHelper databaseHelper = new ChatDatabaseHelper(SHAMChatApplication.getMyApplicationContext());
+			SQLiteDatabase db = databaseHelper.getReadableDatabase();
+
+			String[] selectionArgs = new String[] {threadId, String.valueOf(MyMessageType.INCOMING_MSG.ordinal())};
+
+
+			String queryString = "SELECT * FROM "+TABLE_NAME_CHATS+" WHERE thread_id=? AND message_type =? ORDER BY "+orderBy+" DESC LIMIT 0,"+ limit;
+			Cursor cursor = db.rawQuery(queryString, selectionArgs);
+			if (cursor.moveToFirst()) {
+				do {
+					ChatMessage chatMessage = getChatMessageByCursor(cursor);
+					ContentValues cv = new ContentValues();
+					cv.put("message_status",MessageStatusType.QUEUED.ordinal());
+					db.update(TABLE_NAME_CHATS, cv, "_id=?", new String[] {String.valueOf(chatMessage.getMessageId())});
+
+				} while (cursor.moveToNext());
+
+
+			}
+
+
+			cursor.close();
+			db.close();
+		}
+
+		return listMsg;
+	}
+
+
+	*/
+/**
+	 * returns the first unread message of a thread from db
+	 * @param threadId
+	 * @return
+	 *//*
+
+	public ChatMessage getFirtUnreadMessageFromDB(String threadId) {
+
+		String orderBy = "" ;
+		if (threadId.indexOf("-ch") != -1 ) {
+			Log.d("tegg" , "true") ;
+			orderBy = ChatMessage.MESSAGE_DATETIME ;
+		}else {
+			orderBy = "_id";
+		}
+
+		ChatMessage chatMessage = null;
+
+		User me = getUser(SHAMChatApplication.getConfig().getUserId());
+
+		Cursor unreadMessagesCursor = SHAMChatApplication.getMyApplicationContext().getContentResolver()
+				.query(ChatProviderNew.CONTENT_URI_CHAT,null,
+						ChatMessage.MESSAGE_STATUS + "=? AND "
+								+ ChatMessage.MESSAGE_TYPE + "=? AND "
+								+ ChatMessage.THREAD_ID + "=?",
+						new String[] {
+								MessageStatusType.QUEUED.ordinal() + "",
+								MyMessageType.INCOMING_MSG.ordinal() + "",
+								threadId }, null);
+
+		if (unreadMessagesCursor != null && unreadMessagesCursor.getCount() > 0) {
+			unreadMessagesCursor.moveToFirst();
+
+			chatMessage = getChatMessageByCursor(unreadMessagesCursor);
+
+			String sender = chatMessage.getSender();
+			System.out.println("chat message sender "+ chatMessage.getSender());
+
+			if (me.getUserId().equals(sender)) {
+				chatMessage.setUser(me);
+			} else {
+
+				if (!sender.startsWith("g") && !sender.startsWith("ch") || !sender.substring( sender.indexOf("-")+1).startsWith("s")) {
+					chatMessage.setUser(getUser(chatMessage.getSender()));
+				}
+			}
+
+
+		}
+
+		unreadMessagesCursor.close();
+
+		return chatMessage;
+	}
+
+
+	*/
+/**
+	 * returns the unread messages count of a thread
+	 * @param threadId
+	 * @return
+	 *//*
+
+	public int getUnreadMessagesCount(String threadId) {
+
+		String orderBy = "" ;
+		if (threadId.indexOf("-ch") != -1 ) {
+			Log.d("tegg" , "true") ;
+			orderBy = ChatMessage.MESSAGE_DATETIME ;
+		}else {
+			orderBy = "_id";
+		}
+
+		Cursor unreadMessagesCursor = SHAMChatApplication.getMyApplicationContext().getContentResolver()
+				.query(ChatProviderNew.CONTENT_URI_CHAT,
+						new String[] { ChatMessage.PACKET_ID },
+						ChatMessage.MESSAGE_STATUS + "=? AND "
+								+ ChatMessage.MESSAGE_TYPE + "=? AND "
+								+ ChatMessage.THREAD_ID + "=?",
+						new String[] {
+								MessageStatusType.QUEUED.ordinal() + "",
+								MyMessageType.INCOMING_MSG.ordinal() + "",
+								threadId }, null);
+		unreadMessagesCursor.close();
+
+		int count = unreadMessagesCursor.getCount();
+
+
+		unreadMessagesCursor.close();
+
+		return count;
+	}
+
+	*/
+/**
+	 * Gets a user object from a user id
+	 * @param userId
+	 * @return
+	 *//*
+
+	private User getUser(String userId) {
+
+		ContentResolver contentResolver = SHAMChatApplication
+				.getMyApplicationContext().getContentResolver();
+
+		Cursor friendCursor = null;
+		Cursor rosterCursor = null;
+		User user = null;
+		try {
+
+			friendCursor = contentResolver.query(UserProvider.CONTENT_URI_USER,
+					null, UserConstants.USER_ID + "=?",
+					new String[] { userId }, null);
+			friendCursor.moveToFirst();
+
+			String friendJID = Utils.createXmppUserIdByUserId(userId);
+
+			rosterCursor = contentResolver.query(RosterProvider.CONTENT_URI,
+					null, RosterConstants.JID + "=?",
+					new String[] { friendJID }, null);
+
+			if (friendCursor.getCount()>= 1) {
+
+				user = new User();
+				int blockCount = 0;
+
+				user.setUserId(userId);
+
+				String username = friendCursor.getString(friendCursor
+						.getColumnIndex(UserConstants.USERNAME));
+				user.setUsername(username);
+
+				*/
+/*String status = friendCursor.getString(friendCursor
+						.getColumnIndex(UserConstants.MY_STATUS));
+				user.setMyStatus(status);*//*
+
+
+				String friendMobileNo = friendCursor.getString(friendCursor
+						.getColumnIndex(UserConstants.MOBILE_NO));
+
+				user.setMobileNo(friendMobileNo);
+
+				*/
+/*String profileImageUrl = friendCursor.getString(friendCursor
+						.getColumnIndex(UserConstants.PROFILE_IMAGE_URL));
+				user.setprofileImageUrl(profileImageUrl);
+
+				if (rosterCursor != null && rosterCursor.getCount() > 0) {
+					rosterCursor.moveToFirst();
+					if (rosterCursor != null) {
+						blockCount = rosterCursor.getCount();
+					}
+
+					int blockStatus = rosterCursor.getInt(rosterCursor
+							.getColumnIndex(RosterConstants.USER_STATUS));
+					System.out.println("User blck status " + blockStatus);
+					if (blockStatus == 1) {
+						user.setBlocked(true);
+					} else {
+						user.setBlocked(false);
+					}
+
+					user.setStatusMode(rosterCursor.getInt(rosterCursor
+							.getColumnIndex(RosterConstants.STATUS_MODE)));
+
+					String statusMessage = rosterCursor.getString(rosterCursor
+							.getColumnIndex(RosterConstants.STATUS_MESSAGE));
+
+					user.setMyStatus(statusMessage);
+
+				}
+
+				int userType = friendCursor.getInt(friendCursor
+						.getColumnIndex(UserConstants.USER_TYPE));
+
+				if (userType == 2) {
+					user.setIsInChat(BooleanStatus.TRUE);
+				} else {
+					user.setIsInChat(BooleanStatus.FALSE);
+				}
+
+				String gender = friendCursor.getString(friendCursor
+						.getColumnIndex(UserConstants.GENDER));
+				user.setGender(gender);
+
+				String cityOrRegion = friendCursor.getString(friendCursor
+						.getColumnIndex(UserConstants.CITY_OR_REGION));
+				user.setCityOrRegion(cityOrRegion);*//*
+
+
+				String chatId = friendCursor.getString(friendCursor
+						.getColumnIndex(UserConstants.CHAT_ID));
+				user.setChatId(chatId);
+			}
+
+		} finally {
+			friendCursor.close();
+			rosterCursor.close();
+		}
+		return user;
+	}
+
+
+	public ArrayList<Message> getFavorites(String userId) {
+		ArrayList<Message> favorites = new ArrayList<Message>();
+
+		ChatDatabaseHelper databaseHelper = new ChatDatabaseHelper(
+				SHAMChatApplication.getMyApplicationContext());
+		SQLiteDatabase db = databaseHelper.getWritableDatabase();
+
+		Cursor cursor = db.query(TABLE_NAME_FAVORITE, null, Message.DB_USER_ID
+				+ "=? AND " + Message.DB_DELETED + "=?", new String[] { userId,
+				"0" }, null, null, Message.DB_TIME + " DESC");
+		if (cursor.moveToFirst()) {
+			do {
+				favorites.add(favoriteToCursor(cursor));
+			} while (cursor.moveToNext());
+		}
+
+		cursor.close();
+		db.close();
+		return favorites;
+	}
+
+	public Message favoriteToCursor(Cursor cursor) {
+		Message message = new Message();
+		message.setMessageId(cursor.getString(cursor
+				.getColumnIndex(Message.DB_MESSAGE_ID)));
+		int type = cursor
+				.getInt(cursor.getColumnIndex(Message.DB_MESSAGE_TYPE));
+		message.setType(type);
+		message.setMessageContent(cursor.getString(cursor
+				.getColumnIndex(Message.DB_CONTENT)));
+		message.setTime(cursor.getLong(cursor.getColumnIndex(Message.DB_TIME)));
+		message.setUserId(cursor.getString(cursor
+				.getColumnIndex(Message.DB_USER_ID)));
+		return message;
+	}
+
+	public void insertFavorite(Message message) {
+		// SQLiteDatabase database = getWritableDatabase();
+		ChatDatabaseHelper databaseHelper = new ChatDatabaseHelper(
+				SHAMChatApplication.getMyApplicationContext());
+		SQLiteDatabase db = databaseHelper.getWritableDatabase();
+
+		ContentValues values = new ContentValues();
+		values.put(Message.DB_MESSAGE_ID, message.getMessageId());
+		values.put(Message.DB_MESSAGE_TYPE, message.getType().getValue());
+		values.put(Message.DB_CONTENT, message.getMessageContent());
+		values.put(Message.DB_TIME, message.getTime());
+		values.put(Message.DB_USER_ID, message.getUserId());
+
+		long row = db.insert(TABLE_NAME_FAVORITE, null, values);
+
+		if (row == -1) {
+			Log.e(TAG, "Error inserting Message(" + message + ")");
+		}
+
+		Log.v(TAG, "Inserted new Message with id '" + message.getMessageId()
+				+ "' at rowid " + row);
+
+		db.close();
+	}
+
+	public void updateFavorite(Message message) {
+
+		ChatDatabaseHelper databaseHelper = new ChatDatabaseHelper(
+				SHAMChatApplication.getMyApplicationContext());
+		SQLiteDatabase db = databaseHelper.getWritableDatabase();
+
+		ContentValues values = new ContentValues();
+		values.put(Message.DB_MESSAGE_ID, message.getMessageId());
+		values.put(Message.DB_MESSAGE_TYPE, message.getType().getValue());
+		values.put(Message.DB_CONTENT, message.getMessageContent());
+		values.put(Message.DB_TIME, message.getTime());
+		values.put(Message.DB_USER_ID, message.getUserId());
+
+		long row = db.update(TABLE_NAME_FAVORITE, values, Message.DB_MESSAGE_ID
+				+ "=?", new String[] { message.getMessageId() });
+
+		if (row < 1) {
+			Log.e(TAG, "Error updating Message(" + message + ")");
+		}
+
+		db.close();
+	}
+
+	public boolean removeFavorite(String messageId) {
+
+		ChatDatabaseHelper databaseHelper = new ChatDatabaseHelper(
+				SHAMChatApplication.getMyApplicationContext());
+		SQLiteDatabase db = databaseHelper.getWritableDatabase();
+
+		int rows = 0;
+
+		try {
+
+			ContentValues values = new ContentValues();
+			values.put(Message.DB_DELETED, 1);
+			rows = db.update(TABLE_NAME_FAVORITE, values, Message.DB_MESSAGE_ID
+					+ " = ?", new String[] { messageId });
+
+		} catch (Exception e) {
+			Log.w(TAG, "Couldn't remove message with id '" + messageId
+					+ "' (not found)");
+			e.printStackTrace();
+		} finally {
+			db.close();
+		}
+
+		return rows >= 0;
+	}
+
+	*/
+/**
+	 * Returns the favorite message or null
+	 *
+	 * @param messageId
+	 * @return
+	 *//*
+
+	public Message getFavorite(String messageId) {
+		ChatDatabaseHelper databaseHelper = new ChatDatabaseHelper(
+				SHAMChatApplication.getMyApplicationContext());
+		SQLiteDatabase db = databaseHelper.getWritableDatabase();
+
+		Cursor cursor = db.query(TABLE_NAME_FAVORITE, null,
+				Message.DB_MESSAGE_ID + "=?", new String[] { messageId }, null,
+				null, null);
+
+		Message message = null;
+
+		if (cursor.moveToFirst()) {
+			message = favoriteToCursor(cursor);
+		}
+
+		cursor.close();
+		db.close();
+
+		return message;
+	}
+
+	*/
+/**
+	 *
+	 * @return
+	 *//*
+
+	public String geLasttFavoriteMessageId() {
+		ChatDatabaseHelper databaseHelper = new ChatDatabaseHelper(
+				SHAMChatApplication.getMyApplicationContext());
+		SQLiteDatabase db = databaseHelper.getWritableDatabase();
+
+		String messageId = null;
+		Cursor cursor = db.query(TABLE_NAME_FAVORITE,
+				new String[] { Message.DB_MESSAGE_ID }, null, null, null, null,
+				Message.DB_MESSAGE_ID + " DESC", "1");
+
+		if (cursor.moveToFirst()) {
+			messageId = cursor.getString(cursor
+					.getColumnIndex(Message.DB_MESSAGE_ID));
+		}
+
+		cursor.close();
+		db.close();
+		return messageId;
+	}
+
+	*/
+/**
+	 * returns all the chat message threads with its unread count, username, etc
+	 * sroted by Date desc
+	 * @return
+	 *//*
+
+	public List<MessageThread> getChatThreadsSorted() throws IOException, JSONException {
+
+		ChatDatabaseHelper databaseHelper = new ChatDatabaseHelper(SHAMChatApplication.getMyApplicationContext());
+		SQLiteDatabase db = databaseHelper.getReadableDatabase();
+
+		String CHAT_DATABASE_PATH = databaseHelper.CHAT_DATABASE_PATH;
+		String USER_DATABASE_PATH = databaseHelper.USER_DATABASE_PATH;
+
+
+		List<MessageThread> messageThreads = new ArrayList<MessageThread>();
+
+		String queryLastRow = "SELECT  friend_group_name as username,\n" +
+				"(SELECT COUNT(*) FROM chat_message WHERE chat_message.thread_id = message_thread.thread_id AND chat_message.message_status=0 AND chat_message.message_type=1) AS count,\n" +
+				"friend_id, thread_id, is_group_chat, last_message, last_message_direction, last_updated_datetime, last_message_content_type\n" +
+				"FROM message_thread\n" +
+				" INNER JOIN user.friend_group\n" +
+				"      ON message_thread.friend_id = user.friend_group.friend_group_id\n" +
+				"UNION ALL\n" +
+				"SELECT  name,\n" +
+				"(SELECT COUNT(*) FROM chat_message WHERE chat_message.thread_id = message_thread.thread_id AND chat_message.message_status=0 AND chat_message.message_type=1) AS count,\n" +
+				"friend_id, thread_id, is_group_chat, last_message, last_message_direction, last_updated_datetime, last_message_content_type\n" +
+				"FROM message_thread\n" +
+				" INNER JOIN (SELECT * \n" +
+				"             FROM user.user \n" +
+				"             GROUP BY userId \n" +
+				"             ORDER BY userId ) O ON friend_id = userId\n" +
+				"ORDER BY last_updated_datetime DESC\n";
+
+		db.execSQL("ATTACH DATABASE '" + USER_DATABASE_PATH + "' AS user");
+
+		Cursor cursor = db.rawQuery(queryLastRow, null);
+		if (cursor.moveToFirst()) {
+			do {
+				MessageThread messageThread = new MessageThread();
+				messageThread.setThreadOwner(SHAMChatApplication.getConfig()
+						.getUserId());
+				messageThread.setFriendId(cursor.getString(cursor.getColumnIndex("friend_id")));
+				messageThread.setThreadId(cursor.getString(cursor.getColumnIndex("thread_id")));
+				messageThread.setGroupChat(cursor.getInt(cursor.getColumnIndex("is_group_chat"))==1);
+				messageThread.setLastMessage(cursor.getString(cursor.getColumnIndex("last_message")));
+				messageThread.setLastMessageDirection(cursor.getInt(cursor.getColumnIndex("last_message_direction")));
+				messageThread.setLastUpdatedDate(Utils.getDateFromStringDate(cursor.getString(cursor.getColumnIndex("last_updated_datetime")), "yyyy/MM/dd hh:mm"));
+				messageThread.setLastMessageMedium(cursor.getInt(cursor.getColumnIndex("last_message_content_type")));
+				messageThread.setUsername(cursor.getString(cursor.getColumnIndex("username")));
+				messageThread.setMessageCount(cursor.getInt(cursor.getColumnIndex("count")));
+
+
+				String imageLocation="";
+		if (cursor.getString(cursor.getColumnIndex("friend_id")).startsWith("g") || cursor.getString(cursor.getColumnIndex("friend_id")).substring( cursor.getString(cursor.getColumnIndex("friend_id")).indexOf("-")+1).startsWith("s"))
+		{*/
+/*
+			OkHttpClient client = new OkHttpClient();
+
+
+			client.setConnectTimeout(60, TimeUnit.SECONDS); // connect timeout
+			client.setReadTimeout(60, TimeUnit.SECONDS);
+
+			// socket timeout
+			Request request = new Request.Builder()
+					.url("http://social.rabtcdn.com/groups/api/v1/avatar/with/topic_hashcode/" + cursor.getString(cursor.getColumnIndex("friend_id")) + "/")
+					.cacheControl(new CacheControl.Builder().noCache().build())
+					.build();
+
+			Response responses = null;
+			try {
+				responses = client.newCall(request).execute();
+
+
+
+			} catch (IOException e) {
+				e.printStackTrace();
+			}
+
+			if (responses.isSuccessful()) {
+				String jsonData = responses.body().string();
+				JSONObject Jobject = new JSONObject(jsonData);
+				imageLocation = Jobject.getString("avatar");
+			}
+			//JSONArray Jarray = Jobject.getJSONArray("objects");
+
+				*//*
+*/
+/*	for (int i = 0; i < Jarray.length(); i++) {
+						JSONObject object     = Jarray.getJSONObject(i);
+					}*//*
+*/
+/*
+*//*
+
+		}
+		else if(cursor.getString(cursor.getColumnIndex("friend_id")).startsWith("ch"))
+		{*/
+/*
+			OkHttpClient client = new OkHttpClient();
+
+
+			client.setConnectTimeout(60, TimeUnit.SECONDS); // connect timeout
+			client.setReadTimeout(60, TimeUnit.SECONDS);
+
+			// socket timeout
+			Request request = new Request.Builder()
+					.url("http://social.rabtcdn.com/groups/api/v1/avatar/with/channel_hashcode/" + cursor.getString(cursor.getColumnIndex("friend_id")) + "/")
+					.cacheControl(new CacheControl.Builder().noCache().build())
+					.build();
+
+			Response responses = null;
+			try {
+				responses = client.newCall(request).execute();
+
+
+
+			} catch (IOException e) {
+				e.printStackTrace();
+			}
+
+			if (responses.isSuccessful()) {
+				String jsonData = responses.body().string();
+				JSONObject Jobject = new JSONObject(jsonData);
+				imageLocation = Jobject.getString("avatar");
+			}
+			//JSONArray Jarray = Jobject.getJSONArray("objects");
+
+				*//*
+*/
+/*	for (int i = 0; i < Jarray.length(); i++) {
+						JSONObject object     = Jarray.getJSONObject(i);
+					}*//*
+*/
+/*
+*//*
+
+		}
+		else
+		{		OkHttpClient client = new OkHttpClient();
+
+
+			client.setConnectTimeout(60, TimeUnit.SECONDS); // connect timeout
+			client.setReadTimeout(60, TimeUnit.SECONDS);
+
+			// socket timeout
+			Request request = new Request.Builder()
+					.url("http://social.rabtcdn.com/groups/api/v1/avatar/with/userid/" + cursor.getString(cursor.getColumnIndex("friend_id")) + "/")
+					.cacheControl(new CacheControl.Builder().noCache().build())
+					.build();
+
+			Response responses = null;
+			try {
+				responses = client.newCall(request).execute();
+
+
+
+			} catch (IOException e) {
+				e.printStackTrace();
+			}
+
+			if (responses.isSuccessful()) {
+				String jsonData = responses.body().string();
+				JSONObject Jobject = new JSONObject(jsonData);
+				imageLocation = Jobject.getString("avatar");
+			}
+			//JSONArray Jarray = Jobject.getJSONArray("objects");
+
+				*/
+/*	for (int i = 0; i < Jarray.length(); i++) {
+						JSONObject object     = Jarray.getJSONObject(i);
+					}*//*
+
+
+		}
+
+
+
+
+
+				messageThread.setFriendProfileImageUrl("http://social.rabtcdn.com"+imageLocation);
+				messageThreads.add(messageThread);
+			} while (cursor.moveToNext());
+		}
+
+
+		cursor.close();
+		db.close();
+
+		return messageThreads;
+
+	}
+
+}
+*/
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/CloseGroupActivityEvent.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/CloseGroupActivityEvent.java
new file mode 100644
index 000000000..34696adfe
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/CloseGroupActivityEvent.java
@@ -0,0 +1,26 @@
+package org.telegram.messenger.shamChat;
+
+public class CloseGroupActivityEvent {
+
+	private String threadId;
+	private String groupId;
+
+	public CloseGroupActivityEvent(String threadId, String groupId){
+		this.threadId = threadId;
+		this.groupId = groupId;
+	}
+	public String getGroupId() {
+		return groupId;
+	}
+	public void setGroupId(String groupId) {
+		this.groupId = groupId;
+	}
+	public String getThreadId() {
+		return threadId;
+	}
+	public void setThreadId(String threadId) {
+		this.threadId = threadId;
+	}
+
+}
+
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/Constant.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/Constant.java
new file mode 100644
index 000000000..53f420637
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/Constant.java
@@ -0,0 +1,79 @@
+package org.telegram.messenger.shamChat;
+
+public class Constant {
+
+	private Constant(){}
+	
+	public static final String AppTOKEN					= "e622c330c77a17c8426e638d7a85da6c2ec9f455";
+	
+	public static final String Domain					= "http://social.rabtcdn.com";
+	public static final String Media					= Domain+"/media/";
+	public static final String UserProfile				= Domain+"/pin/api/profile/profile/?token=";
+	public static final String UserProfileByName		= Domain+"/pin/api/profile/profile/?user__username=";
+	public static final String Follow					= Domain+"/pin/d/follow/";
+	public static final String Posts					= Domain+"/pin/api/post/";
+	public static final String Stream					= Domain+"/pin/api/friends_post/";
+	public static final String Hasgtag					= Domain+"/pin/api/hashtag/";
+	public static final String NewPost					= Domain+"/pin/d_send/";
+	public static final String NewPostVideo				= Domain+"/pin/d/video/upload/?token=";
+	public static final String Like						= Domain+"/pin/d_like2/?token=";
+	public static final String PostDetails				= Domain+"/pin/api/post/";
+	public static final String PostDelete				= Domain+"/pin/d/post/delete/";
+	public static final String PostUpdate				= Domain+"/pin/d/post/update/";
+	public static final String PostReport				= Domain+"/pin/d_post_report/?token=";
+	public static final String Comments					= Domain+"/pin/api/com/comments/?object_pk=";
+	public static final String PostComment				= Domain+"/pin/d_post_comment/?token=";
+	public static final String PostSearch				= Domain+"/pin/api/search/posts/?offset=0&q=";
+	public static final String UserSearch				= Domain+"/pin/api/search/?q=";
+	public static final String PostLikers				= Domain+"/pin/api/like/likes/?post_id=";
+	public static final String UserFollowers			= Domain+"/pin/api/follower/";
+	public static final String UserFollowing			= Domain+"/pin/api/following/";
+	
+	public static final String Register					= Domain+"/api/user/register/";
+	public static final String Login					= Domain+"/api/user/login/";
+	public static final String UserAvailability			= Domain+"/api/v4/user/check/username/";
+	
+	public static final String ProfileUpdate			= Domain+"/profile/d_change/?token=";
+	
+	public static final String NotificationCount		= Domain+"/pin/api/notif/count/?token=";
+	public static final String Notifications			= Domain+"/pin/api/notif/notify/?api_key=";
+	
+	public static final String UserExistVerify			= Domain+"/api/v4/user/salam/is/user/registered/";
+	public static final String UpdateJaberID			= Domain+"/api/v4/user/salam/change/profile/jid/?token=";
+
+	public static final String MqttTcpPort				= "1883";
+//	public static final String MqttTcpHost				= "iot.eclipse.org";
+	public static final String MqttTcpHost				= "sp.rabtcdn.com";
+	
+	public static final String MqttTopicCreation		= Domain+"/groups/api/v1/topics/create/";
+	public static final String MqttTopicsList			= Domain+"/groups/api/v1/topics/user/";
+	public static final String MqttDeleteTopic			= Domain+"/groups/api/v1/topics/delete/";
+	public static final String MqttKickFromTopic		= Domain+"/groups/api/v1/topics/kick/";
+	public static final String MqttInviteToTopic		= Domain+"/groups/api/v1/topics/invite/";
+	public static final String MqttLeftFromTopic		= Domain+"/groups/api/v1/topics/left/";
+
+	public static final String MqttChannelCreation		= Domain+"/groups/api/v1/channels/create/";
+	public static final String MqttUpdateInfo			= Domain+"/groups/api/v1/channels/update/info/";
+	public static final String MqttUserChannels			= Domain+"/groups/api/v1/channels/user/channels/";
+	public static final String MqttChannelDetails		= Domain+"/groups/api/v1/channels/details/";
+	public static final String MqttChannelDelete		= Domain+"/groups/api/v1/channels/delete/";
+	public static final String MqttChannelLeft			= Domain+"/groups/api/v1/channels/left/";
+	public static final String MqttChannelInvite		= Domain+"/groups/api/v1/channels/invite/";
+	public static final String MqttChannelKick			= Domain+"/groups/api/v1/channels/kick/";
+	public static final String MqttChannelGetPosts		= Domain+"/groups/api/v1/channels/posts/";
+	public static final String MqttChannelSendPost		= Domain+"/groups/api/v1/channels/post/send/";
+	public static final String MqttChannelDeletePost	= Domain+"/groups/api/v1/channels/post/delete/";
+	public static final String SyncContacts				= Domain+"/groups/api/v1/contact/sync/";
+	public static final String RegisterPhoneNumber		= Domain+"/groups/api/v1/auth/register/phone/";
+	public static final String RegisterPhoneVerify		= Domain+"/groups/api/v1/auth/register/verify/";
+	public static final String RegisterWhitPhone		= Domain+"/groups/api/v1/auth/register/user/with/phone/";
+	public static final String RegisterPhoneResend		= Domain+"/groups/api/v1/auth/resend/verify/";
+	public static final String RenameTopic		= Domain+"/groups/api/v1/topics/change/name/";
+	public static final String DeleteTopic		= Domain+"/groups/api/v1/topics/delete/";
+
+
+
+
+
+
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/DeleteChatMessageDBLoadJob.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/DeleteChatMessageDBLoadJob.java
new file mode 100644
index 000000000..920d7dbd3
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/DeleteChatMessageDBLoadJob.java
@@ -0,0 +1,152 @@
+package org.telegram.messenger.shamChat;
+
+import com.path.android.jobqueue.Job;
+import com.path.android.jobqueue.Params;
+
+
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import de.greenrobot.event.EventBus;
+
+public class DeleteChatMessageDBLoadJob extends Job {
+
+	/**
+	 * 
+	 */
+	private static final long serialVersionUID = 1L;
+
+	private static final AtomicInteger jobCounter = new AtomicInteger(0);
+	private final int id;
+
+	public static final int PRIORITY = 100;
+
+	private String packetId;
+	private String actorId;
+	private String ChannelId;
+
+	public DeleteChatMessageDBLoadJob(String packetId) {
+
+		super(new Params(PRIORITY));
+		id = jobCounter.incrementAndGet();
+		this.packetId = packetId;
+
+	}
+
+	public DeleteChatMessageDBLoadJob(String packetId,String actorId,String ChannelId) {
+
+		super(new Params(PRIORITY).persist().requireNetwork());
+		id = jobCounter.incrementAndGet();
+		this.packetId = packetId;
+		this.actorId = actorId;
+		this.ChannelId = ChannelId;
+
+	}
+	@Override
+	public void onAdded() {
+		// Job has been saved to disk.
+		// This is a good place to dispatch a UI event to indicate the job will
+		// eventually run.
+		// In this example, it would be good to update the UI with the newly
+		// posted tweet.
+	}
+
+	@Override
+	protected void onCancel() {
+		// Job has exceeded retry attempts or shouldReRunOnThrowable() has
+		// returned false.
+
+	}
+
+	@Override
+	public void onRun() throws Throwable {
+		if (id != jobCounter.get()) {
+			// looks like other fetch jobs has been added after me. no reason to
+			// keep fetching
+			// many times, cancel me, let the other one fetch tweets.
+			return;
+		}
+//reza_ak
+	/*	try {
+
+			SHAMChatApplication
+					.getMyApplicationContext()
+					.getContentResolver()
+					.delete(ChatProviderNew.CONTENT_URI_CHAT,
+							ChatMessage.PACKET_ID + "=?",
+							new String[] { packetId });
+
+			EventBus.getDefault().post(new MessageDeletedEvent(packetId));
+
+
+
+if(ChannelId.startsWith("ch")) {
+
+	final String URL = Constant.MqttChannelDeletePost + ChannelId + "/";
+	//mast - send request to server to leave the room
+	OkHttpClient client = new OkHttpClient();
+
+	client.setConnectTimeout(60, TimeUnit.SECONDS); // connect timeout
+	client.setReadTimeout(60, TimeUnit.SECONDS);    // socket timeout
+
+	RequestBody formBody = new FormEncodingBuilder()
+			.add("packet_id" ,packetId )
+			.add("actor_id", actorId)
+			.build();
+
+	Request request = new Request.Builder()
+			.url(URL)
+		    .post(formBody)
+			.build();
+
+	Response response = client.newCall(request).execute();
+	// check if request was successful
+	if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+
+	*//*
+
+	final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
+
+	JSONObject jsContent = new JSONObject();
+	jsContent.put("post_id", new JSONArray().put(packetId));
+	jsContent.put("actor_id", new JSONArray().put(actorId));
+
+
+	RequestBody formBody = RequestBody.create(JSON, jsContent.toString());
+
+
+	Request request = new Request.Builder()
+			.url(URL)
+			.post(formBody)
+			.build();*//*
+
+
+
+
+
+
+			EventBus.getDefault().post(new MessageDeletedEvent(packetId));
+}
+
+		} catch (Exception e) {
+
+			System.out.println("DisableStickerPackDBLoadJob " + e);
+		}*/
+
+	}
+
+	@Override
+	protected boolean shouldReRunOnThrowable(Throwable throwable) {
+
+		// An error occurred in onRun.
+		// Return value determines whether this job should retry running (true)
+		// or abort (false).
+
+		return false;
+	}
+
+
+
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/FileUploadingProgressEvent.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/FileUploadingProgressEvent.java
new file mode 100644
index 000000000..61db22eb6
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/FileUploadingProgressEvent.java
@@ -0,0 +1,31 @@
+package org.telegram.messenger.shamChat;
+
+
+public class FileUploadingProgressEvent {
+
+	private String threadId;
+	private String packetId;
+	private int uploadedPercentage;
+
+	
+	public String getPacketId() {
+		return packetId;
+	}
+	public void setPacketId(String packetId) {
+		this.packetId = packetId;
+	}
+	public String getThreadId() {
+		return threadId;
+	}
+	public void setThreadId(String threadId) {
+		this.threadId = threadId;
+	}
+	public int getUploadedPercentage() {
+		return uploadedPercentage;
+	}
+	public void setUploadedPercentage(int uploadedPercentage) {
+		this.uploadedPercentage = uploadedPercentage;
+	}
+
+}
+
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/FriendGroup.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/FriendGroup.java
new file mode 100644
index 000000000..2c643e04a
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/FriendGroup.java
@@ -0,0 +1,135 @@
+package org.telegram.messenger.shamChat;
+
+import android.content.Context;
+import android.database.Cursor;
+
+
+
+import java.util.Date;
+
+public class FriendGroup {
+	public static String DB_ID = "friend_group_id";
+	public static String DB_NAME = "friend_group_name";
+	public static String DB_RECORD_OWNER = "record_owner_id";
+	public static String CHAT_ROOM_NAME = "chat_room_name";
+	public static String DID_JOIN_ROOM = "did_join_room";
+	public static String DID_LEAVE = "did_leave";
+	public static String IS_MUTE = "is_mute";
+	public static String DB_DESCRIPTION = "friend_group_description";
+	public static String DB_LINK_NAME = "friend_group_link_name";
+	public static String CHANNEL_LOGO = "logo" ;
+
+	private String id;
+	private String name;
+	private String recordOwnerId;
+	private String chatRoomName;
+	private String dbRecordId;
+
+	private String groupDescription;
+	private String groupLinkName;
+
+	public FriendGroup(String name, String ownerId) {
+		setName(name);
+		setRecordOwnerId(ownerId);
+	}
+
+	public FriendGroup() {
+	}
+
+	public String getId() {
+		return id;
+	}
+
+	public FriendGroup setId(String id) {
+		this.id = id;
+		return this;
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	public FriendGroup setName(String name) {
+		this.name = name;
+		return this;
+	}
+
+	public String getRecordOwnerId() {
+		return recordOwnerId;
+	}
+
+	public FriendGroup setRecordOwnerId(String recordOwnerId) {
+		this.recordOwnerId = recordOwnerId;
+		return this;
+	}
+
+	public FriendGroup assignUniqueId() {
+//		setId("G" + DatabaseTest.getUniqueId());
+		setId("g" + recordOwnerId + "_" + Utils.formatDate(new Date().getTime(),"yyyyMMddHHmmss"));
+		return this;
+	}
+
+	@Override
+	public String toString() {
+		return "Id:" + getId() + " Name:" + getName() + " Owner:" + getRecordOwnerId();
+	}
+//reza_ak
+	/*public static String getNextAvailableGroupName(Context context) {
+		int i;
+
+		Cursor cursor = context.getContentResolver().query(UserProvider.CONTENT_URI_GROUP, new String [] {FriendGroup.DB_ID}, null, null, null);
+
+		i=cursor.getCount()+1;
+
+		cursor.close();
+
+		return "Group " + i;
+	}*/
+//reza_ak
+	/*public static String getNextAvailableChannelName(Context context) {
+		int i;
+
+		Cursor cursor = context.getContentResolver().query(UserProvider.CONTENT_URI_GROUP, new String [] {FriendGroup.DB_ID}, null, null, null);
+
+		i=cursor.getCount()+1;
+
+		cursor.close();
+
+		return "Channel " + i;
+	}*/
+
+
+	public String getChatRoomName() {
+		return chatRoomName;
+	}
+
+	public void setChatRoomName(String chatRoomName) {
+		this.chatRoomName = chatRoomName;
+	}
+
+
+
+
+
+	public String getGroupDescription() {
+		return groupDescription;
+	}
+	public void setGroupDescription(String groupDescription) {
+		this.groupDescription = groupDescription;
+	}
+
+	public String getGroupLinkName() {
+		return groupLinkName;
+	}
+	public void setGroupLinkName(String groupLinkName) {
+		this.groupLinkName = groupLinkName;
+	}
+
+	public String getDbRecordId() {
+		return dbRecordId;
+	}
+
+	public void setDbRecordId(String dbRecordId) {
+		this.dbRecordId = dbRecordId;
+	}
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/FriendGroupMember.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/FriendGroupMember.java
new file mode 100644
index 000000000..1a989c9e4
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/FriendGroupMember.java
@@ -0,0 +1,99 @@
+package org.telegram.messenger.shamChat;
+
+import java.util.Date;
+
+public class FriendGroupMember {
+	public static String DB_ID = "friend_group_member_id";
+	public static String DB_GROUP = "friend_group_id";
+	public static String DB_FRIEND = "friend_id";
+	public static String DB_FRIEND_DID_JOIN = "friend_did_join";
+	public static String DB_FRIEND_IS_ADMIN = "friend_is_admin";
+	public static String PHONE_NUMBER = "phone_number";
+
+	private String id;
+	private String groupID;
+	private String friendId;
+	private String phoneNumber;	
+	private boolean isAdmin;
+	private boolean didJoin;
+	private User user;
+	
+	public FriendGroupMember(String groupId, String friendId) {
+		setGroupID(groupId);
+		setFriendId(friendId);
+	}
+
+	public FriendGroupMember() {
+	}
+
+	public String getId() {
+		return id;
+	}
+
+	public FriendGroupMember setId(String id) {
+		this.id = id;
+		return this;
+	}
+
+	public String getGroupID() {
+		return groupID;
+	}
+
+	public FriendGroupMember setGroupID(String groupID) {
+		this.groupID = groupID;
+		return this;
+	}
+
+	public String getFriendId() {
+		return friendId;
+	}
+
+	public FriendGroupMember setFriendId(String friendId) {
+		this.friendId = friendId;
+		return this;
+	}
+
+	public FriendGroupMember assignUniqueId(String ownerId) {
+		id = "M" + ownerId + "_" + new Date().getTime();
+		return this;
+	}
+
+	@Override
+	public String toString() {
+		return "Id:" + getId() + " GroupId:" + getGroupID() + " FriendId:" + getFriendId();
+	}
+
+	public boolean isAdmin() {
+		return isAdmin;
+	}
+
+	public void setAdmin(boolean isAdmin) {
+		this.isAdmin = isAdmin;
+	}
+
+	public boolean isDidJoin() {
+		return didJoin;
+	}
+
+	public void setDidJoin(boolean didJoin) {
+		this.didJoin = didJoin;
+	}
+
+	public User getUser() {
+		return user;
+	}
+
+	public void setUser(User user) {
+		this.user = user;
+	}
+	
+	public String getPhoneNumber() {
+		return phoneNumber;
+	}
+
+	public FriendGroupMember setPhoneNumber(String phoneNumber) {
+		this.phoneNumber = phoneNumber;
+		return this;
+	}
+	
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/MessageContentTypeProvider.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/MessageContentTypeProvider.java
new file mode 100644
index 000000000..31c0ec740
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/MessageContentTypeProvider.java
@@ -0,0 +1,25 @@
+package org.telegram.messenger.shamChat;
+
+public class MessageContentTypeProvider {
+
+	public enum MessageContentType {
+		  TEXT(0), IMAGE(1) , STICKER(2), VOICE_RECORD(3), FAVORITE(4), MESSAGE_WITH_IMOTICONS(5), LOCATION(6), INCOMING_CALL(
+		    7), OUTGOING_CALL(8) , VIDEO(9) ,MISSED_CALL(10), GROUP_INFO(11);
+
+		  private int type;
+
+		  MessageContentType(int type) {
+		   this.setType(type);
+		  }
+
+		  public int getType() {
+		   return type;
+		  }
+
+		  private void setType(int type) {
+		   this.type = type;
+		  }
+
+		 }
+
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/MessageThread.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/MessageThread.java
new file mode 100644
index 000000000..c95070b4a
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/MessageThread.java
@@ -0,0 +1,188 @@
+package org.telegram.messenger.shamChat;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import java.util.Date;
+
+public class MessageThread{
+	public static final String TABLE_NAME = "chat_thread";
+	public static final String THREAD_ID = "thread_id";
+	public static final String FRIEND_ID = "friend_id";
+	public static final String THREAD_OWNER = "thread_owner";
+	public static final String LAST_UPDATED_DATETIME = "last_updated_datetime";
+	public static final String THREAD_STATUS = "thread_status";
+	public static final String IS_GROUP_CHAT = "is_group_chat";
+	public static final String READ_STATUS = "read_status";
+	public static final String LAST_MESSAGE = "last_message";
+	public static final String LAST_MESSAGE_CONTENT_TYPE = "last_message_content_type";
+	public static final String LAST_MESSAGE_DIRECTION = "last_message_direction";
+	
+	private String threadId;
+	private Date lastUpdateTime;
+	private boolean threadStatus;
+	private boolean isGroupChat;
+	private String threadOwner;
+	private String friendId;
+
+	private  String logo = "http://google.com" ;
+	private String lastMessage;
+	private int lastMessageDirection;
+	private Date lastUpdatedDate;
+	private int lastMessageMedium;
+	
+	private String username;
+	
+	
+	private int messageCount;
+	private String friendProfileImageUrl;
+
+	public MessageThread() {
+	}
+
+	public MessageThread(String threadId, Date lastUpdateTime, boolean threadStatus, boolean isGroupChat,String threadOwner,String friendId) {
+		this.threadId = threadId;
+		this.lastUpdateTime = lastUpdateTime;
+		this.threadStatus = threadStatus;
+		this.isGroupChat = isGroupChat;
+		this.threadOwner = threadOwner;
+		this.friendId = friendId;
+	}
+
+	public MessageThread(Parcel in) {
+		this.setThreadId(in.readString());
+		this.setLastUpdateTime(new Date(in.readLong()));
+		this.setThreadStatus(in.readInt() == 1 ? true : false);
+		this.setGroupChat(in.readInt() == 1 ? true : false);
+		this.setThreadOwner(in.readString());
+		this.setFriendId(in.readString());
+
+	}
+
+
+	public Date getLastUpdateTime() {
+		return lastUpdateTime;
+	}
+
+	public void setLastUpdateTime(Date lastUpdateTime) {
+		this.lastUpdateTime = lastUpdateTime;
+	}
+
+	/**
+	 * thread id will also be this one because chat thread is unique to each user
+	 * @return
+	 */
+	public String getThreadId() {
+		return threadOwner + "-" + friendId;
+	}
+
+	public void setThreadId(String threadId) {
+		this.threadId = threadId;
+	}
+
+	public boolean isThreadActive() {
+		return threadStatus;
+	}
+
+	public void setThreadStatus(boolean threadStatus) {
+		this.threadStatus = threadStatus;
+	}
+
+	public boolean isGroupChat() {
+		return isGroupChat;
+	}
+
+	public void setGroupChat(boolean isGroupChat) {
+		this.isGroupChat = isGroupChat;
+	}
+
+	public static final Parcelable.Creator<MessageThread> CREATOR = new Parcelable.Creator<MessageThread>() {
+		public MessageThread createFromParcel(Parcel in) {
+			return new MessageThread(in);
+		}
+
+		public MessageThread[] newArray(int size) {
+			return new MessageThread[size];
+		}
+	};
+
+	public String getThreadOwner() {
+		return threadOwner;
+	}
+
+	public void setThreadOwner(String thread_owner) {
+		this.threadOwner = thread_owner;
+	}
+
+	public String getFriendId() {
+		return friendId;
+	}
+
+	public void setFriendId(String friendId) {
+		this.friendId = friendId;
+	}
+
+	public String getLastMessage() {
+		return lastMessage;
+	}
+
+	public void setLastMessage(String lastMessage) {
+		this.lastMessage = lastMessage;
+	}
+
+	public  void setLogo (String logo) {this.logo = logo ;}
+
+	public  String getLogo () {return  logo ; }
+
+	public int getLastMessageDirection() {
+		return lastMessageDirection;
+	}
+
+	public void setLastMessageDirection(int lastMessageDirection) {
+		this.lastMessageDirection = lastMessageDirection;
+	}
+
+	public Date getLastUpdatedDate() {
+		return lastUpdatedDate;
+	}
+
+	public void setLastUpdatedDate(Date lastUpdatedDate) {
+		this.lastUpdatedDate = lastUpdatedDate;
+	}
+
+	public int getLastMessageMedium() {
+		return lastMessageMedium;
+	}
+
+	public void setLastMessageMedium(int lastMessageMedium) {
+		this.lastMessageMedium = lastMessageMedium;
+	}
+
+	public String getUsername() {
+		return username;
+	}
+
+	public void setUsername(String username) {
+		this.username = username;
+	}
+
+	public int getMessageCount() {
+		return messageCount;
+	}
+
+	public void setMessageCount(int messageCount) {
+		this.messageCount = messageCount;
+	}
+
+	public String getFriendProfileImageUrl() {
+		return friendProfileImageUrl;
+	}
+
+	public void setFriendProfileImageUrl(String friendProfileImageUrl) {
+		this.friendProfileImageUrl = friendProfileImageUrl;
+	}
+
+	
+	
+
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/MyMessageType.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/MyMessageType.java
new file mode 100644
index 000000000..d3c6fb15e
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/MyMessageType.java
@@ -0,0 +1,5 @@
+package org.telegram.messenger.shamChat;
+
+public enum MyMessageType {
+	OUTGOING_MSG,INCOMING_MSG, HEADER_MSG,ADD_OR_BLOCK_FRIEND
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/NewGroupMessageSentFailedEvent.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/NewGroupMessageSentFailedEvent.java
new file mode 100644
index 000000000..71ada1402
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/NewGroupMessageSentFailedEvent.java
@@ -0,0 +1,108 @@
+package org.telegram.messenger.shamChat;
+
+
+import org.telegram.messenger.shamChat.MessageContentTypeProvider.MessageContentType;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+public class NewGroupMessageSentFailedEvent {
+	
+	private String jsonMessageString;
+
+	public String threadId = null;
+	
+	public JSONObject SampleMsg = null;
+	public  String packetId = null;	
+	public  String from = null;	
+	public String to=null;	
+	public String messageTypeDesc = null;
+	int messageType = 0;
+	String messageBody = null;
+	String latitude=null;
+	String longitude=null;
+	//String groupOwnerId = null;
+	int isGroupChat = 0; 
+	
+	public NewGroupMessageSentFailedEvent(String jsonMessage)
+	{
+			
+		this.jsonMessageString = jsonMessage;
+			try {
+				SampleMsg = new JSONObject(jsonMessageString);
+				packetId = SampleMsg.getString("packetId");
+				from = SampleMsg.getString("from");					
+				to = SampleMsg.getString("to");	
+				messageTypeDesc = SampleMsg.getString("messageTypeDesc");
+				messageType = SampleMsg.getInt("messageType");
+				
+				if (messageType == MessageContentType.LOCATION.ordinal())
+				{
+					latitude = SampleMsg.getString("latitude");
+					longitude = SampleMsg.getString("longitude");					
+				}
+				
+				messageBody = SampleMsg.getString("messageBody");
+			//groupOwnerId = SampleMsg.getString("groupOwnerId");					
+			isGroupChat = SampleMsg.getInt("isGroupChat");					
+			//reza_ak
+			String threadOwner = "6";
+			threadId = threadOwner + "-" + to; 
+				
+			} catch (JSONException e1) {
+				// TODO Auto-generated catch block
+				e1.printStackTrace();
+			}
+		
+		
+	}
+
+	public String getThreadId() {
+		return threadId;
+	}
+	
+	public void setThreadId(String threadId) {
+		this.threadId = threadId;
+	}
+	
+	public String getPacketId() {
+		return packetId;
+	}
+
+	public String getFrom() {
+		return from;
+	}
+
+	public String getTo() {
+		return to;
+	}
+	
+	public String getHashCode() {
+		return to;
+	}
+
+	public String getMssageTypeDesc() {
+		return messageTypeDesc;
+	}
+
+	public int getMessageType() {
+		return messageType;
+	}
+
+	public String getMessageBody() {
+		return messageBody;
+	}
+
+	public String getLatitude() {
+		return latitude;
+	}
+
+	public String getLongitude() {
+		return longitude;
+	}
+	
+	public String getJsonMessageString(){
+		return jsonMessageString;	
+	}
+
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/NewGroupMessageSentSuccessEvent.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/NewGroupMessageSentSuccessEvent.java
new file mode 100644
index 000000000..58ea60a6c
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/NewGroupMessageSentSuccessEvent.java
@@ -0,0 +1,121 @@
+package org.telegram.messenger.shamChat;
+
+
+import org.telegram.messenger.shamChat.MessageContentTypeProvider.MessageContentType;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+public class NewGroupMessageSentSuccessEvent {
+	
+	private String jsonMessageString;
+
+	public String threadId = null;
+	
+	public JSONObject SampleMsg = null;
+	public  String packetId = null;	
+	public  String from = null;	
+	public String to=null;	
+	public String messageTypeDesc = null;
+	int messageType = 0;
+	String messageBody = null;
+	String latitude=null;
+	String timestamp=null;	
+	String longitude=null;
+	String packetType=null;	
+	//String groupOwnerId = null;
+	int isGroupChat = 0; 
+	
+	public NewGroupMessageSentSuccessEvent(String jsonMessage)
+	{
+			
+		this.jsonMessageString = jsonMessage;
+			try {
+				SampleMsg = new JSONObject(jsonMessageString);
+				packetId = SampleMsg.getString("packetId");
+				packetType = SampleMsg.getString("packet_type");					
+				from = SampleMsg.getString("from");					
+				to = SampleMsg.getString("to");	
+				messageTypeDesc = SampleMsg.getString("messageTypeDesc");
+				timestamp = SampleMsg.getString("timestamp");
+				messageType = SampleMsg.getInt("messageType");
+				
+				if (messageType ==  MessageContentType.LOCATION.ordinal())
+				{
+					latitude = SampleMsg.getString("latitude");
+					longitude = SampleMsg.getString("longitude");					
+				}
+				
+				messageBody = SampleMsg.getString("messageBody");
+			//groupOwnerId = SampleMsg.getString("groupOwnerId");					
+			isGroupChat = SampleMsg.getInt("isGroupChat");					
+			//reza_ak
+			String threadOwner = "6";
+			threadId = threadOwner + "-" + to; 
+				
+			} catch (JSONException e1) {
+				// TODO Auto-generated catch block
+				e1.printStackTrace();
+			}
+		
+		
+	}
+
+	public String getThreadId() {
+		return threadId;
+	}
+	
+	public void setThreadId(String threadId) {
+		this.threadId = threadId;
+	}
+	
+	public String getPacketId() {
+		return packetId;
+	}
+
+	public String getFrom() {
+		return from;
+	}
+
+	public String getTo() {
+		return to;
+	}
+	
+	public String getHashCode() {
+		return to;
+	}
+
+	public String getMssageTypeDesc() {
+		return messageTypeDesc;
+	}
+
+	public String getTimeStamp() {
+		return timestamp;
+	}
+	
+	public int getMessageType() {
+		return messageType;
+	}
+
+	public String getMessageBody() {
+		return messageBody;
+	}
+
+	public String getLatitude() {
+		return latitude;
+	}
+
+	public String getLongitude() {
+		return longitude;
+	}
+
+	public String getJsonMessageString(){
+		return jsonMessageString;	
+	}
+	
+	public String getPacketType(){
+		return packetType;	
+	}
+	
+
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/NewMessageEvent.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/NewMessageEvent.java
new file mode 100644
index 000000000..83b537dc7
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/NewMessageEvent.java
@@ -0,0 +1,52 @@
+package org.telegram.messenger.shamChat;
+
+public class NewMessageEvent {
+	
+	private String threadId;
+	private int direction;
+	private String jsonMessageString;
+	private String packetId=null;
+	public boolean consumed = false; 
+	
+	public String getThreadId() {
+		return threadId;
+	}
+
+	public void setThreadId(String threadId) {
+		this.threadId = threadId;
+	}
+
+	public int getDirection() {
+		return direction;
+	}
+
+	public void setDirection(int direction) {
+		this.direction = direction;
+	}
+
+	public String getPacketId() {
+		return packetId;
+	}
+
+	public void setPacketId(String packetId) {
+		this.packetId = packetId;
+	}
+	
+	public String getJsonMessageString() {
+		return jsonMessageString;
+	}
+
+	public void setJsonMessageString(String jsonMessageString) {
+		this.jsonMessageString = jsonMessageString;
+	}
+	
+	public boolean getConsumed() {
+		return consumed;
+	}
+
+	public void setConsumed(boolean consumed) {
+		this.consumed = consumed;
+	}
+	
+
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/PublishToTopicJob.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/PublishToTopicJob.java
new file mode 100644
index 000000000..06a54138d
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/PublishToTopicJob.java
@@ -0,0 +1,778 @@
+package org.telegram.messenger.shamChat;
+
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.net.ConnectivityManager;
+import android.net.Uri;
+import android.widget.Toast;
+
+import com.path.android.jobqueue.Job;
+import com.path.android.jobqueue.JobManager;
+import com.path.android.jobqueue.Params;
+
+
+import org.eclipse.paho.android.service.MqttAndroidClient;
+import org.eclipse.paho.client.mqttv3.IMqttActionListener;
+import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.telegram.messenger.ApplicationLoader;
+import org.telegram.messenger.R;
+import org.telegram.messenger.mqtt.Connections;
+import org.telegram.messenger.mqtt.NotifySimple;
+
+import java.util.Date;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import de.greenrobot.event.EventBus;
+
+public class PublishToTopicJob extends Job {
+
+	private static final long serialVersionUID = 1L;
+
+	public static final int PRIORITY = 1000;
+
+	boolean DEBUG = false;
+
+	boolean isRetry = false;
+	private static final AtomicInteger jobCounter = new AtomicInteger(0);
+	private final int id;
+
+	private String jsonMessageString;
+	private String topicName;
+
+	public String threadId = null;
+
+
+	public  String packetId = null;
+	public  String from = null;
+	public String to=null;
+	public String messageTypeDesc = null;
+	int messageType = 0;
+	String messageBody = null;
+	String latitude=null;
+	String timestamp=null;
+	String longitude=null;
+	String packetType=null;
+	//String groupOwnerId = null;
+	int isGroupChat = 0;
+
+
+
+	public PublishToTopicJob(String jsonMessageString, String topicName) {
+		super(new Params(PRIORITY).persist().requireNetwork());
+		id = jobCounter.incrementAndGet();
+
+		initClass(jsonMessageString, topicName);
+
+	}
+
+	public PublishToTopicJob(String jsonMessageString, String topicName, boolean isRetry) {
+		super(new Params(PRIORITY).persist().requireNetwork());
+		id = jobCounter.incrementAndGet();
+
+		this.isRetry = isRetry;
+
+		initClass(jsonMessageString, topicName);
+
+	}
+
+	public void initClass(String jsonMessageString, String topicName) {
+
+
+		this.jsonMessageString = jsonMessageString;
+		this.topicName = topicName;
+
+		JSONObject SampleMsg = null;
+		try {
+			SampleMsg = new JSONObject(jsonMessageString);
+			packetId = SampleMsg.getString("packetId");
+			packetType = SampleMsg.getString("packet_type");
+			from = SampleMsg.getString("from");
+			to = SampleMsg.getString("to");
+			messageTypeDesc = SampleMsg.getString("messageTypeDesc");
+			timestamp = SampleMsg.getString("timestamp");
+			messageType = SampleMsg.getInt("messageType");
+
+			if (messageType == MessageContentTypeProvider.MessageContentType.LOCATION.ordinal())
+			{
+				latitude = SampleMsg.getString("latitude");
+				longitude = SampleMsg.getString("longitude");
+			}
+
+			messageBody = SampleMsg.getString("messageBody");
+			//groupOwnerId = SampleMsg.getString("groupOwnerId");
+			isGroupChat = SampleMsg.getInt("isGroupChat");
+
+			String threadOwner = "6";
+			threadId = threadOwner + "-" + to;
+
+		} catch (JSONException e1) {
+			// TODO Auto-generated catch block
+			e1.printStackTrace();
+		}
+	}
+	@Override
+	public void onAdded() {
+		// Job has been saved to disk.
+		// This is a good place to dispatch a UI event to indicate the job will
+		// eventually run.
+		// In this example, it would be good to update the UI with the newly
+		// posted tweet.
+
+		//if this is text message or sticker add it to database first
+		//if this is not a retry operation we add message to database
+		if (isRetry== false)
+		{
+			if (messageType == MessageContentTypeProvider.MessageContentType.TEXT.ordinal() || messageType == MessageContentTypeProvider.MessageContentType.STICKER.ordinal())
+				addChatMessageToDB(MyMessageType.OUTGOING_MSG.ordinal(), ChatMessage.MessageStatusType.SENDING.ordinal(), MessageContentTypeProvider.MessageContentType.TEXT.ordinal(), jsonMessageString);
+		}
+
+	}
+
+	@Override
+	protected void onCancel() {
+		// Job has exceeded retry attempts or shouldReRunOnThrowable() has
+		// returned false.
+
+	}
+
+	@Override
+	public void onRun() throws Throwable {
+		// Job logic goes here.
+
+		/*if (id != jobCounter.get()) {
+			// looks like other fetch jobs has been added after me. no reason to
+			// keep fetching
+			// many times, cancel me, let the other one fetch tweets.
+			return;
+		}*/
+
+		RokhPref Session;
+		String clientHandle = null;
+//reza_ak
+		//Session = new RokhPref(SHAMChatApplication.getInstance().getApplicationContext());
+		clientHandle = "user6";
+
+		int qos = 1;
+		boolean retained = false;
+
+		String[] args = new String[2];
+		args[0] = jsonMessageString;
+		args[1] = topicName + ";qos:" + qos + ";retained:" + retained;
+
+
+		JSONObject jss = new JSONObject(jsonMessageString);
+//reza_ak
+		/*try {
+			if (jss.getInt(IncomingChannelMsg.ISFORWARDED) == 0 || jss.getInt(IncomingChannelMsg.ISFORWARDED) == 1) {
+			}
+		} catch (JSONException e) {
+
+
+
+			try {
+				if (!threadId.substring(threadId.indexOf("-") + 1).startsWith("s")) {
+					boolean bb = jss.getBoolean(IncomingChannelMsg.ISFORWARDED);
+					jss.remove(IncomingChannelMsg.ISFORWARDED);
+					jss.put(IncomingChannelMsg.ISFORWARDED, bb ? 1 : 0);
+					jsonMessageString = jss.toString();
+				}
+			}catch (Exception e12)
+			{}
+
+		}
+*/
+		MqttAndroidClient client = Connections.getInstance(ApplicationLoader.applicationContext).getConnection(clientHandle).getClient();
+		
+		client.publish(topicName, jsonMessageString.getBytes(), qos, retained, null, new IMqttActionListener() {
+
+			@Override
+			public void onSuccess(IMqttToken arg0) {
+				// if publishes to topic successfully
+
+				final String jsonMessage = jsonMessageString;
+				if (messageType == MessageContentTypeProvider.MessageContentType.TEXT.ordinal() || messageType == MessageContentTypeProvider.MessageContentType.STICKER.ordinal())
+				{
+					//MAST - if message is published to mqtt - we update it to delivered status
+					//MAST - TODO - for single chat later we can improve this to make it as "Sent" status and in the MQTTService check its real delivery and then change to delivered
+					//reza_ak
+					// /updateMessageStatus(packetId, MessageStatusType.DELIVERED);
+				}
+				else {
+
+					//MAST - TODO - if it is image/video/voice/sticker
+					//Update status of message in chat message table to delivered
+					//refresh UI
+					//updateMessageStatus(packetId, MessageStatusType.DELIVERED);
+				}
+
+			}
+
+			@Override
+			public void onFailure(IMqttToken arg0, Throwable arg1) {
+				// if some error happens and doesn't send to topic
+
+				//if it is a blob message
+				if (messageType == MessageContentTypeProvider.MessageContentType.IMAGE.ordinal() || messageType == MessageContentTypeProvider.MessageContentType.VIDEO.ordinal() ||
+						messageType == MessageContentTypeProvider.MessageContentType.LOCATION.ordinal() || messageType== MessageContentTypeProvider.MessageContentType.VOICE_RECORD.ordinal()	)
+				{
+					//updateMessageStatus(packetId, ChatMessage.MessageStatusType.FAILED);
+				}
+				else {
+					//MAST - TODO - for text messages
+					//Should change message status to failed
+					//Add a retry button to its UI
+					//try sending it again
+					//updateMessageStatus(packetId, MessageStatusType.FAILED);
+
+				}
+
+
+
+				String actionTaken = "publish_message_failed";
+				/*if (DEBUG)
+					NotifySimple.notifcation(ApplicationLoader.applicationContext, actionTaken, Toast.LENGTH_SHORT);
+*/
+				//mast - this is too much just for testing
+			    /*if (isOnline())
+			    {
+					Intent backgroundService = new Intent(ApplicationLoader.applicationContext, MQTTService.class);
+					ApplicationLoader.applicationContext.stopService(backgroundService);
+					ApplicationLoader.applicationContext.startService(backgroundService);
+			    }*/
+
+			}
+		});
+
+		client.close();
+
+	}
+
+	private boolean isOnline()
+	{
+		ConnectivityManager cm = (ConnectivityManager)ApplicationLoader.applicationContext.getSystemService(ApplicationLoader.applicationContext.CONNECTIVITY_SERVICE);
+		if(cm.getActiveNetworkInfo() != null &&
+				cm.getActiveNetworkInfo().isAvailable() &&
+				cm.getActiveNetworkInfo().isConnected())
+		{
+			return true;
+		}
+
+		return false;
+	}
+
+	/**
+	 *
+	 * @param direction  put 0 for outgoing message, 1 for incoming message OR
+	 * 				  MyMessageType.INCOMING_MSG.ordinal(), MyMessageType.OUTGOING_MSG.ordinal()
+	 * @param messageStatus queued = 0, sending = 1, sent = 2, delivered = 3, seen =4, failed = 5
+	 * @param messageContentType  text = 0, image = 1, sticker = 2, voice record = 3, favorite = 4,
+	 *  						  MESSAGE_WITH_IMOTICONS = 5, LOCATION = 6, INCOMING_CALL = 7, OUTGOING_CALL = 8, VIDEO = 9, GROUP_INFO = 10
+	 //* @param message
+	 * @return
+	 */
+
+	public boolean addChatMessageToDB(int direction, int messageStatus, int messageContentType,
+									  final String jsonMessageString) {
+
+		boolean isExistingMessage = false;
+
+		ContentResolver mContentResolver = ApplicationLoader.applicationContext.getContentResolver();
+
+		//mast - sample message to handle sent message and insert to db
+		//String jsonSampleMsg = "{\"to\": \"/groups/testgroup\",\"from\": \"wizgoonId\",\"messageBody\": \"hello everyone!\",\"messageType\": 1,\"timestamp\": \"2014-03-07T00:00:00.000Z\",\"groupAlias\": \"Good friends group\"\"packetId\": \"userId_timestamp\"}";
+		JSONObject SampleMsg=null;
+		String packetId = null;
+		String from = null;
+		int fromUserId = 0;
+		String to=null;
+		String messageTypeDesc = null;
+		int messageType = 0;
+		String messageBody = null;
+		String timestamp = null;
+		//String groupOwnerId = null;
+		int isGroupChat = 0;
+
+
+		try {
+			SampleMsg = new JSONObject(jsonMessageString);
+			packetId = SampleMsg.getString("packetId");
+			from = SampleMsg.getString("from");
+			fromUserId = SampleMsg.getInt("from_userid");
+			to = SampleMsg.getString("to");
+			messageTypeDesc = SampleMsg.getString("messageTypeDesc");
+			messageType = SampleMsg.getInt("messageType");
+			messageBody = SampleMsg.getString("messageBody");
+			//groupOwnerId = SampleMsg.getString("groupOwnerId");
+			isGroupChat = SampleMsg.getInt("isGroupChat");
+
+			timestamp = SampleMsg.getString("timestamp");
+
+
+
+		} catch (JSONException e1) {
+			// TODO Auto-generated catch block
+			e1.printStackTrace();
+		}
+
+//reza_ak
+		String threadOwner = "6";
+
+		//String threadId = threadId;
+		//String groupId = null;
+		String friendId = null;
+
+		// Out going message
+		//threadId = message.getThread();
+		//groupId = to;
+		friendId = to;
+
+
+		//mast - just for now to focus on adding just chat message - later we will update thread table too
+
+		boolean threadSaveOrUpdateSuccess = saveOrUpdateThread(threadId, jsonMessageString, messageType, friendId, direction);
+//
+		if (threadSaveOrUpdateSuccess) {
+
+			Cursor chatCursor = null;
+//reza_ak
+/*
+			try {
+				//check to see if current message exists previously - ic_search using packetId of message
+
+				chatCursor = mContentResolver.query(
+						ChatProviderNew.CONTENT_URI_CHAT,
+						new String[] { MessageConstants._ID },
+						ChatMessage.PACKET_ID + "=?",
+						new String[] { packetId }, null);
+
+				if (chatCursor != null && chatCursor.getCount() > 0) {
+
+					isExistingMessage = true;
+				}
+
+				// If this is a totally new message
+				if (!isExistingMessage) {
+
+					ContentValues values = new ContentValues();
+
+					values.put(ChatMessage.MESSAGE_RECIPIENT, to);
+					//mast - put 0 for outgoing , 1 for incoming message
+					values.put(ChatMessage.MESSAGE_TYPE, direction);
+					values.put(ChatMessage.PACKET_ID, packetId);
+					values.put(ChatMessage.THREAD_ID, threadId);
+
+					values.put(ChatMessage.DESCRIPTION, messageTypeDesc);
+					values.put(ChatMessage.MESSAGE_CONTENT_TYPE, messageType);
+					values.put(ChatMessage.MESSAGE_STATUS, messageStatus);
+
+					values.put(ChatMessage.MESSAGE_DATETIME, timestamp);
+					values.put(ChatMessage.LAST_UPDATED_DATE_TIME, timestamp);
+
+					if (isGroupChat == 1) {
+						values.put(ChatMessage.GROUP_ID, to);
+					}
+
+					//mast - this is for incoming message
+								*//*LocationDetails locDetails = (LocationDetails) message
+										.getExtension(LocationDetails.NAMESPACE);
+
+								if (locDetails != null) {
+									values.put(ChatMessage.LATITUDE,
+											locDetails.getLatitude());
+									values.put(ChatMessage.LONGITUDE,
+											locDetails.getLongitude());
+								}*//*
+
+								*//*if (message.getType() == Message.Type.groupchat
+										&& direction == MyMessageType.INCOMING_MSG
+												.ordinal()) { // We
+									// handle
+									// Group messages slightly different compared to
+									// single chat
+									// We add "ABC says: " text in to certain messages
+									// group chat
+									// Then we need to manage the friends in the group
+
+									System.out
+											.println("processMessage addChatMessageToDB message.getType() == Message.Type.groupchat && direction == MyMessageType.INCOMING_MSG.ordinal()");
+									String fromGroup = message.getFrom();
+
+									String userId = fromGroup.substring(
+											fromGroup.indexOf("/") + 1,
+											fromGroup.indexOf("-"));
+
+									String username = getUsernameToDisplayForGroup(
+											userId, fromGroup);
+
+									// This is the actual sender, from value is
+									// the room name not the individual who sent it
+									values.put(ChatMessage.MESSAGE_SENDER, userId);
+
+									if (messageContentType.getMessageContentType() != MessageContentType.GROUP_INFO) {
+										// Group, incoming, not group info
+										System.out
+												.println("processMessage addChatMessageToDB messageContentType.getMessageContentType() != MessageContentType.GROUP_INFO");
+
+										String formattedMessage = null;
+										if (messageContentType.getMessageContentType() == MessageContentType.TEXT) {
+											System.out
+													.println("processMessage addChatMessageToDB messageContentType.getMessageContentType() == MessageContentType.TEXT");
+
+											formattedMessage = username
+													+ " "
+													+ R.string.says
+													+ " \n" + message.getBody();
+										} else {
+											System.out
+													.println("processMessage addChatMessageToDB messageContentType.getMessageContentType() != MessageContentType.TEXT");
+
+											formattedMessage = username
+													+ " "
+													+ R.string.sent;
+
+											String body = message.getBody();
+											values.put(ChatMessage.UPLOADED_FILE_URL,
+													body);
+
+											if (body != null
+													&& body.contains("http://")) {
+												try {
+													URL u = new URL(body);
+													int size = Utils.getFileSize(u);
+
+													values.put(ChatMessage.FILE_SIZE,
+															size);
+
+												} catch (Exception e) {
+													e.printStackTrace();
+												}
+											}
+
+										}
+										values.put(ChatMessage.TEXT_MESSAGE,
+												formattedMessage);
+
+									} else { //
+
+									}
+
+								} else { //Group chat out going message*//*
+
+					System.out
+							.println("processMessage addChatMessageToDB Single chat, both directions, Group chat outgoing");
+					values.put(ChatMessage.MESSAGE_SENDER, from);
+					values.put(ChatMessage.TEXT_MESSAGE, messageBody);
+
+					if (threadId.indexOf("-ch") != -1) {
+						values.put(ChatMessage.CHANNEL_ID  , "1");
+						values.put(ChatMessage.CHANNEL_VIEW  , "1");
+					}
+
+
+
+					try {
+
+
+						if 	(SampleMsg.getBoolean(IncomingChannelMsg.ISFORWARDED)) {
+							values.put(ChatMessage.ISFORWARD , true ? 1 : 0);
+							values.put(ChatMessage.CHANNELTITLE , SampleMsg.getString(IncomingChannelMsg.CHANNELTITLE));
+							values.put(ChatMessage.CHANNELHASHCODE , SampleMsg.getString(IncomingChannelMsg.CHANNELHASHCODE));
+							values.put(ChatMessage.ORGINALPACKETID , SampleMsg.getString(IncomingChannelMsg.ORGINALPACKETID));
+						}
+
+
+					} catch (JSONException e) {
+						e.printStackTrace();
+					}
+
+
+					//}
+
+
+					Uri uri = mContentResolver.insert(
+							ChatProviderNew.CONTENT_URI_CHAT, values);
+
+					Cursor c = null;
+					int dbId = 0;
+					try {
+						c = mContentResolver.query(uri, null, null, null,
+								null);
+
+						c.moveToFirst();
+
+						dbId = c.getInt(c.getColumnIndex("_id"));
+
+					} finally {
+						if (c != null) {
+							c.close();
+						}
+					}
+
+
+					NewMessageEvent newMessageEvent = new NewMessageEvent();
+					newMessageEvent.setThreadId(threadId);
+					newMessageEvent.setJsonMessageString(jsonMessageString);
+					if (direction == MyMessageType.OUTGOING_MSG.ordinal()) {
+
+						newMessageEvent.setDirection(MyMessageType.OUTGOING_MSG.ordinal());
+					} *//*else {
+
+									newMessageEvent
+											.setDirection(MyMessageType.INCOMING_MSG
+													.ordinal());
+								}*//*
+
+					EventBus.getDefault().postSticky(newMessageEvent);
+
+
+
+				} else {
+					//if this message exists previously we add code required below (if required)
+				}
+
+			} finally {
+				chatCursor.close();
+			}*/
+		}
+
+		return isExistingMessage;
+
+	}
+
+	private boolean saveOrUpdateThread(String threadId, String receivedJsonMessage, int messageContentType, String friendId, int direction) {
+
+		System.out.println("processMessage addChatMessageToDB saveOrUpdateThread");
+
+		ContentResolver mContentResolver = ApplicationLoader.applicationContext.getContentResolver();
+
+		// Pars Json String
+
+		JSONObject SampleMsg=null;
+		String packetId = null;
+		String from = null;
+		int fromUserId = 0;
+		String to=null;
+		String messageTypeDesc = null;
+		int messageType = 0;
+		String messageBody = null;
+		//String groupOwnerId = null;
+		int isGroupChat = 0;
+
+
+		try {
+			SampleMsg		= new JSONObject(receivedJsonMessage);
+			packetId		= SampleMsg.getString("packetId");
+			from			= SampleMsg.getString("from");
+			fromUserId		= SampleMsg.getInt("from_userid");
+			to				= SampleMsg.getString("to");
+			messageTypeDesc	= SampleMsg.getString("messageTypeDesc");
+			messageType		= SampleMsg.getInt("messageType");
+			messageBody		= SampleMsg.getString("messageBody");
+			//groupOwnerId	= SampleMsg.getString("groupOwnerId");
+			isGroupChat		= SampleMsg.getInt("isGroupChat");
+
+		} catch (JSONException e1) {
+			// TODO Auto-generated catch block
+			e1.printStackTrace();
+		}
+
+		// End Pars
+		//reza_ak
+/*
+		Cursor threadCursor = null;
+		try {
+			threadCursor = mContentResolver.query(
+					ChatProviderNew.CONTENT_URI_THREAD,
+					new String[] { MessageThread.THREAD_ID },
+					MessageThread.THREAD_ID + "=?", new String[] { threadId },
+					null);
+
+			boolean isExistingThread = false;
+			if (threadCursor != null && threadCursor.getCount() > 0) {
+
+				System.out
+						.println("processMessage addChatMessageToDB saveOrUpdateThread isExisting thread");
+				isExistingThread = true;
+
+			}
+
+			String lastMessage = messageBody;
+			boolean isRead = false;
+
+
+			if (messageContentType != MessageContentType.GROUP_INFO.ordinal()) {
+
+				System.out.println("processMessage addChatMessageToDB saveOrUpdateThread NOT group info");
+
+				switch (Utils.readMessageContentType(messageType)) {
+					case TEXT:
+
+						int limit;
+						if (messageBody.length()>70) limit = 70;
+						else limit = messageBody.length();
+
+						lastMessage =  SHAMChatApplication.getInstance().getApplicationContext().getResources().getString(R.string.sent)+" "+
+								messageBody.substring(0,limit);
+						break;
+
+					case IMAGE:
+
+						lastMessage =  SHAMChatApplication.getInstance().getApplicationContext().getResources().getString(R.string.sent_image);
+						break;
+
+					case VIDEO:
+						lastMessage = SHAMChatApplication.getInstance().getApplicationContext().getResources().getString(R.string.sent_video);
+						break;
+
+					case STICKER:
+						lastMessage = SHAMChatApplication.getInstance().getApplicationContext().getResources().getString(R.string.sent_sticker);
+						break;
+
+
+					case LOCATION:
+						lastMessage = SHAMChatApplication.getInstance().getApplicationContext().getResources().getString(R.string.sent_location);
+						break;
+
+					case VOICE_RECORD:
+						lastMessage = SHAMChatApplication.getInstance().getApplicationContext().getResources().getString(R.string.sent_voice);
+						break;
+
+					default:
+						System.out.println("processMessage addChatMessageToDB saveOrUpdateThread DEFAULT"+ lastMessage);
+						break;
+
+				}
+
+			}
+
+
+
+			if (isExistingThread) {
+
+				ContentValues values = new ContentValues();
+				values.put(MessageThread.LAST_MESSAGE, lastMessage.trim());
+				values.put(MessageThread.LAST_MESSAGE_CONTENT_TYPE,messageContentType);
+				values.put(MessageThread.READ_STATUS, isRead ? 1 : 0);
+				values.put(MessageThread.LAST_UPDATED_DATETIME,Utils.formatDate(new Date().getTime(),"yyyy/MM/dd HH:mm:ss"));
+				values.put(MessageThread.LAST_MESSAGE_DIRECTION, direction);
+				values.put(MessageThread.THREAD_OWNER, SHAMChatApplication.getConfig().getUserId());
+				values.put(MessageThread.IS_GROUP_CHAT,isGroupChat);
+				mContentResolver.update(ChatProviderNew.CONTENT_URI_THREAD, values, MessageThread.THREAD_ID + "=?", new String[] { threadId });
+			} else {
+				System.out.println("processMessage addChatMessageToDB saveOrUpdateThread new thread " + lastMessage);
+				ContentValues values = new ContentValues();
+				values.put(MessageThread.THREAD_ID, threadId);
+				values.put(MessageThread.FRIEND_ID, friendId);
+				values.put(MessageThread.READ_STATUS, isRead ? 1 : 0);
+				values.put(MessageThread.LAST_MESSAGE, lastMessage.trim());
+				values.put(MessageThread.LAST_MESSAGE_CONTENT_TYPE,messageContentType);
+				values.put(MessageThread.LAST_UPDATED_DATETIME, Utils.formatDate(new Date().getTime(), "yyyy/MM/dd HH:mm:ss"));
+				values.put(MessageThread.IS_GROUP_CHAT, isGroupChat);
+				values.put(MessageThread.THREAD_OWNER, SHAMChatApplication.getConfig().getUserId());
+				values.put(MessageThread.LAST_MESSAGE_DIRECTION, direction);
+
+				try {
+					if 	(SampleMsg.getBoolean(IncomingChannelMsg.ISFORWARDED)) {
+						values.put(ChatMessage.ISFORWARD , true);
+						values.put(ChatMessage.CHANNELTITLE , SampleMsg.getString(IncomingChannelMsg.CHANNELTITLE));
+						values.put(ChatMessage.CHANNELHASHCODE , SampleMsg.getString(IncomingChannelMsg.CHANNELHASHCODE));
+						values.put(ChatMessage.ORGINALPACKETID , SampleMsg.getString(IncomingChannelMsg.ORGINALPACKETID));
+					}
+
+				} catch (JSONException e) {
+					e.printStackTrace();
+				}
+
+
+
+				mContentResolver.insert(ChatProviderNew.CONTENT_URI_THREAD, values);
+			}
+
+		} finally {
+			threadCursor.close();
+		}*/
+		return true;
+	}
+
+
+	/**
+	 * Updates the BLOB message status to x and updates UI too
+	 * @param packetId
+	 */
+
+	private void updateMessageStatus(final String packetId, ChatMessage.MessageStatusType messageStatusType ) {
+
+		ContentResolver mContentResolver = ApplicationLoader.applicationContext.getContentResolver();
+//reza_ak
+	/*	Cursor cursor = null;
+		try {
+			ContentValues cv = new ContentValues();
+			cv.put(ChatMessage.MESSAGE_STATUS, messageStatusType.ordinal());
+			cv.put(ChatMessage.LAST_UPDATED_DATE_TIME, Utils.formatDate(
+					new Date().getTime(), "yyyy/MM/dd HH:mm:ss"));
+
+			cursor = mContentResolver
+					.query(ChatProviderNew.CONTENT_URI_CHAT, new String[] {
+									MessageConstants._ID, ChatMessage.THREAD_ID },
+							ChatMessage.PACKET_ID + "=?",
+							new String[] { packetId }, null);
+			if (cursor.getCount() > 0) {
+				cursor.moveToFirst();
+
+				String columnID = Integer.toString(cursor.getInt(cursor
+						.getColumnIndex(MessageConstants._ID)));
+
+				String threadId = cursor.getString(cursor
+						.getColumnIndex(ChatMessage.THREAD_ID));
+				Uri rowuri = Uri.parse("content://" + ChatProviderNew.AUTHORITY
+						+ "/" + ChatProviderNew.TABLE_NAME_CHATS + "/"
+						+ columnID);
+
+				mContentResolver.update(rowuri, cv, MessageConstants._ID
+								+ " = ? AND " + ChatMessage.MESSAGE_STATUS + " != "
+								+ MessageStatusType.SEEN.ordinal() + " AND "
+								+ ChatMessage.MESSAGE_TYPE + " = "
+								+ MyMessageType.OUTGOING_MSG.ordinal(),
+						new String[] { columnID });
+
+				//Update the UI to Delivered
+				JobManager jobManager;
+				jobManager = SHAMChatApplication.getInstance().getJobManager();
+				jobManager.addJobInBackground(new MessageStateChangedJob(threadId, packetId, messageStatusType.getType()));
+
+
+			}
+
+
+		} finally {
+			cursor.close();
+		}*/
+
+	}
+
+
+	@Override
+	protected int getRetryLimit() {
+		// mast - just try to send to topic 1 time
+		return 1;
+	}
+
+
+	@Override
+	protected boolean shouldReRunOnThrowable(Throwable throwable) {
+
+		// An error occurred in onRun.
+		// Return value determines whether this job should retry running (true)
+		// or abort (false).
+		System.out.println("Publish to topic run again");
+
+		return true;
+	}
+
+
+
+
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/RokhPref.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/RokhPref.java
new file mode 100644
index 000000000..7db2bb959
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/RokhPref.java
@@ -0,0 +1,98 @@
+package org.telegram.messenger.shamChat;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.content.SharedPreferences.Editor;
+
+import java.util.HashMap;
+
+public class RokhPref {
+
+	SharedPreferences								pref;
+	Editor											editor;
+	Context											_context;
+	
+	int Private_Mode								= 0;
+		
+	private static final String PREF_NAME			= "RokhgroupPref";
+	private static final String IS_LOGIN			= "IsLoggedin";
+	public static final String KEY_USERTOKEN		= "token";
+	public static final String KEY_USERID			= "userId";
+	public static final String KEY_USERNAME			= "username";
+	public static final String KEY_CLIENTHANDLE 	= "clientHandle";
+    public static final String KEY_IS_FIRST_RUN		= "isFirstRun";
+    public static final String KEY_IS_UNREAD_MSG	= "isUnreadMsg";
+    
+	public RokhPref(Context context){
+		this._context	= context;
+		pref		= _context.getSharedPreferences(PREF_NAME, Private_Mode);
+		editor		= pref.edit();
+	}
+	
+	public void CreateUser(String token, String userid){
+		editor.putBoolean(IS_LOGIN, true);
+		editor.putString(KEY_USERTOKEN, token);
+		editor.putString(KEY_USERID, userid);
+		editor.commit();
+	}
+	
+	public HashMap<String, String> GetUserData(){
+		
+		HashMap<String, String> UserInfo	= new HashMap<String, String>();
+		
+		UserInfo.put(KEY_USERTOKEN, pref.getString(KEY_USERTOKEN, null));
+		UserInfo.put(KEY_USERID, pref.getString(KEY_USERID, null));
+		
+		return UserInfo;
+		
+	}
+	
+	public String getUSERID(){
+		return pref.getString(KEY_USERID, null);
+	}
+	
+	public String getUSERTOKEN(){
+		return pref.getString(KEY_USERTOKEN, null);
+		
+	}
+	
+	public boolean isLoggedIn(){
+		return pref.getBoolean(IS_LOGIN, false);
+	}
+
+	public void setUsername(String username){
+		editor.putString(KEY_USERNAME, username);
+		editor.commit();
+	}
+	
+	public String getUsername(){
+		return pref.getString(KEY_USERNAME, null);
+	}
+	
+	public void setClientHandle(String clientHandle){
+		editor.putString(KEY_CLIENTHANDLE, clientHandle);
+		editor.commit();
+	}
+	
+	public String getClientHandle(){
+		return pref.getString(KEY_CLIENTHANDLE, null);
+	}
+    
+    public void setFirstRun(boolean firstRun){
+        editor.putBoolean(KEY_IS_FIRST_RUN, firstRun);
+        editor.commit();
+    }
+    
+    public boolean getFirstRun(){
+        return pref.getBoolean(KEY_IS_FIRST_RUN, false);
+    }
+    
+    public void setUnreadMsg(boolean unreadmsg){
+        editor.putBoolean(KEY_IS_UNREAD_MSG, unreadmsg);
+        editor.commit();
+    }
+    
+    public boolean getIsUnreadMsg(){
+        return pref.getBoolean(KEY_IS_UNREAD_MSG, false);
+    }
+;}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/RoomRestoreJob.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/RoomRestoreJob.java
new file mode 100644
index 000000000..32afbe03b
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/RoomRestoreJob.java
@@ -0,0 +1,348 @@
+package org.telegram.messenger.shamChat;
+
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.database.Cursor;
+
+import com.path.android.jobqueue.Job;
+import com.path.android.jobqueue.Params;
+
+
+import org.eclipse.paho.android.service.MqttAndroidClient;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
+import java.util.Date;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import de.greenrobot.event.EventBus;
+
+public class RoomRestoreJob extends Job {
+
+    private static final long serialVersionUID = 1L;
+
+    public static final int PRIORITY = 1000;
+
+    private static final AtomicInteger jobCounter = new AtomicInteger(0);
+    private final int id;
+//reza_ak
+    final String  userId					= "6";
+
+    String[] allTopics;
+    int [] qosArray;
+
+
+    MqttAndroidClient mqttClient;
+
+    public RoomRestoreJob() {
+        super(new Params(PRIORITY).persist().requireNetwork());
+
+        id = jobCounter.incrementAndGet();
+    }
+
+    @Override
+    public void onAdded() {
+        // Job has been saved to disk.
+        // This is a good place to dispatch a UI event to indicate the job will
+        // eventually run.
+        // In this example, it would be good to update the UI with the newly
+        // posted tweet.
+    }
+
+    @Override
+    protected void onCancel() {
+        // Job has exceeded retry attempts or shouldReRunOnThrowable() has
+        // returned false.
+
+    }
+
+    @Override
+    public void onRun() throws Throwable {
+        // Job logic goes here.
+
+		/*if (id != jobCounter.get()) {
+			// looks like other fetch jobs has been added after me. no reason to
+			// keep fetching
+			// many times, cancel me, let the other one fetch tweets.
+			return;
+		}*/
+//reza_ak
+   //     User userObject 		= new UserProvider().getCurrentUserForMyProfile();
+
+//reza_ak
+        //RokhPref Session = new RokhPref(getApplicationContext());
+
+     //   final String clientHandle				= Session.getClientHandle();
+
+
+        final String	URL						= Constant.MqttTopicsList+userId+"/";
+
+//reza_ak
+/*
+        //mast - send request to server to restore the rooms
+        OkHttpClient client = new OkHttpClient();
+
+        client.setConnectTimeout(60, TimeUnit.SECONDS); // connect timeout
+        client.setReadTimeout(60, TimeUnit.SECONDS);    // socket timeout
+
+        Request request = new Request.Builder()
+                .url(URL)
+                .build();
+
+        Response response = client.newCall(request).execute();
+        // check if request was successful
+        if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+        String stringResponse = response.body().string();
+        response.body().close();
+
+        System.out.println(stringResponse);
+        JSONObject jsonResponse = new JSONObject(stringResponse);
+        String status = jsonResponse.getString("status");
+
+        // check if API processed the room restore request successfully
+        if(status.equals("200")){
+
+            //Parsing JSONObject
+            JSONArray	groupsJSONArray	= jsonResponse.getJSONArray("objects");
+            JSONArray	channelsJSONArray	= jsonResponse.getJSONArray("channels");
+            JSONArray	allTopicsArray	= concatJSONArray(groupsJSONArray, channelsJSONArray);
+
+            if(allTopicsArray.length() > 0){
+
+                addTopicsToDB(allTopicsArray);
+
+                final ActionListener callback = new ActionListener(SHAMChatApplication.getInstance().getApplicationContext(), ActionListener.Action.SUBSCRIBE, clientHandle, allTopics);
+
+                mqttClient = Connections.getInstance(
+                        SHAMChatApplication.getInstance().getApplicationContext()).getConnection(clientHandle).getClient();
+                mqttClient.subscribe(allTopics, qosArray, null, callback);
+
+
+
+            }
+
+        } else {
+            throw new IOException("Unexpected reponse code " + status);
+        }*/
+
+
+    }
+
+    @Override
+    protected boolean shouldReRunOnThrowable(Throwable throwable) {
+
+        // An error occurred in onRun.
+        // Return value determines whether this job should retry running (true)
+        // or abort (false).
+        System.out.println("Room Restore Job run again");
+
+        return true;
+    }
+
+    private JSONArray concatJSONArray(JSONArray... arrs)
+            throws JSONException {
+        JSONArray result = new JSONArray();
+        for (JSONArray arr : arrs) {
+            for (int i = 0; i < arr.length(); i++) {
+                result.put(arr.get(i));
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Add a JSON array of topics (groups/channels) to database
+     * @param allTopicsArray
+     * @return
+     */
+    protected boolean addTopicsToDB(JSONArray allTopicsArray) {
+//reza_ak
+     //   final ContentResolver mContentResolver	= SHAMChatApplication.getInstance().getApplicationContext().getContentResolver();
+
+        if(allTopicsArray.length() > 0){
+
+            allTopics = new String[allTopicsArray.length()];
+            qosArray  = new int[allTopicsArray.length()];
+
+
+            try {
+
+                for (int i = 0; i < allTopicsArray.length(); i++) {
+
+                    JSONObject allTopicsList = allTopicsArray.getJSONObject(i);
+                    String groupAlias = allTopicsList.getString("title");
+                    String subscibtionpath = allTopicsList.getString("sub_path");
+                    String groupMemberCnt = String.valueOf(allTopicsList.getInt("cnt_members"));
+                    String groupHashCode = allTopicsList.getString("hashcode");
+                    allTopics[i] = allTopicsList.getString("hashcode");
+                    qosArray[i] = 1;
+                    JSONObject groupAdmin = allTopicsList.getJSONObject("admin");
+                    String groupAdminID = groupAdmin.getString("user_id");
+                    String groupAdminPhone = groupAdmin.getString("phone");
+
+                    String description="";
+                    String linkName="";
+
+                    Boolean isChannel = false;
+                    if (groupHashCode.startsWith("ch")) {
+                        isChannel = true;
+                    }
+
+                    if (isChannel) {
+                        description = allTopicsList.getString("description");
+                        linkName =  allTopicsList.getString("name");
+                    }
+//reza_ak
+                 /*  Cursor groupCursor = mContentResolver.query(UserProvider.CONTENT_URI_GROUP, new String[]{FriendGroup.DB_ID}, FriendGroup.CHAT_ROOM_NAME + "=?", new String[]{groupHashCode}, null);
+                    boolean isUpdate = false;
+
+                    if (groupCursor.getCount() > 0) {
+                        isUpdate = true;
+                    }
+                    groupCursor.close();
+*/
+                    final FriendGroup group = new FriendGroup();
+                    group.setId(groupHashCode);
+                    group.setName(groupAlias);
+                    group.setRecordOwnerId(groupAdminID);
+                    group.setChatRoomName(groupHashCode);
+
+                    if (isChannel) {
+                        group.setGroupDescription(description);
+                        group.setGroupLinkName(linkName);
+                    }
+
+                    ContentValues values = new ContentValues();
+                    values.put(FriendGroup.DB_ID, groupHashCode);
+                    values.put(FriendGroup.DB_NAME, groupAlias);
+                    values.put(FriendGroup.DB_RECORD_OWNER, groupAdminID);
+                    values.put(FriendGroup.CHAT_ROOM_NAME, groupHashCode);
+
+                    if (allTopicsList.has("logo")) {
+                        if (!allTopicsList.getString("logo").equals("")) {
+                            values.put(FriendGroup.CHANNEL_LOGO,   allTopicsList.getString("logo"));
+
+
+                        }
+                    }
+
+                    MessageThread thread = new MessageThread();
+                    thread.setFriendId(groupHashCode);
+                    thread.setGroupChat(true);
+                    thread.setThreadOwner(userId);
+
+                    ContentValues vals = new ContentValues();
+                    vals.put(MessageThread.THREAD_ID, thread.getThreadId());
+                    vals.put(MessageThread.FRIEND_ID, thread.getFriendId());
+                    vals.put(MessageThread.READ_STATUS, 0);
+                    vals.put(MessageThread.LAST_UPDATED_DATETIME, Utils.formatDate(new Date().getTime(), "yyyy/MM/dd HH:mm:ss"));
+                    vals.put(MessageThread.IS_GROUP_CHAT, 1);
+                    vals.put(MessageThread.THREAD_OWNER, thread.getThreadOwner());
+
+                    //reza_ak
+                   /* if (!isUpdate) {
+
+                        mContentResolver.insert(UserProvider.CONTENT_URI_GROUP, values);
+
+                        if (groupHashCode.startsWith("ch"))
+                        {vals.put(MessageThread.LAST_MESSAGE, SHAMChatApplication.getInstance().getString(R.string.new_channel_invited));}
+                        else if (groupHashCode.startsWith("g"))
+                        { vals.put(MessageThread.LAST_MESSAGE, SHAMChatApplication.getInstance().getString(R.string.new_group_invited));}
+                        else
+                        {vals.put(MessageThread.LAST_MESSAGE, "");}
+
+                        vals.put(MessageThread.LAST_MESSAGE_DIRECTION, MyMessageType.INCOMING_MSG.ordinal());
+                        vals.put(MessageThread.LAST_MESSAGE_CONTENT_TYPE, 0);
+                        mContentResolver.insert(ChatProviderNew.CONTENT_URI_THREAD, vals);
+
+                    } else {
+
+                        mContentResolver.update(UserProvider.CONTENT_URI_GROUP, values, FriendGroup.DB_ID + "=?", new String[]{group.getId()});
+                        mContentResolver.update(ChatProviderNew.CONTENT_URI_THREAD, vals, MessageThread.THREAD_ID + "=?", new String[]{thread.getThreadId()});
+                    }*/
+
+                    // add admin as member
+                    FriendGroupMember admin = new FriendGroupMember(group.getId(), groupAdminID);
+                    admin.assignUniqueId(userId);
+
+                    ContentValues adminCv = new ContentValues();
+                    adminCv.put(FriendGroupMember.DB_ID, admin.getId());
+                    adminCv.put(FriendGroupMember.DB_FRIEND, admin.getFriendId());
+                    adminCv.put(FriendGroupMember.DB_GROUP, admin.getGroupID());
+                    adminCv.put(FriendGroupMember.DB_FRIEND_IS_ADMIN, 1);
+                    adminCv.put(FriendGroupMember.PHONE_NUMBER, admin.getPhoneNumber());
+//reza_ak
+                 /*   if (mContentResolver.update(UserProvider.CONTENT_URI_GROUP_MEMBER, adminCv, FriendGroupMember.DB_GROUP + "=? AND " + FriendGroupMember.DB_FRIEND + "=?", new String[]{admin.getGroupID(), groupAdminID}) == 0) {
+                        mContentResolver.insert(UserProvider.CONTENT_URI_GROUP_MEMBER, adminCv);
+                    }*/
+
+                    //we add users just for groups
+                    if (!isChannel) {
+                         try {
+
+
+                        JSONArray users = allTopicsList.getJSONArray("users");
+
+                        if (users.length() > 0) {
+
+
+                            for (int j = 0; j < users.length(); j++) {
+
+                                JSONObject member = users.getJSONObject(j);
+
+                                String memberId = member.getString("user_id");
+                                String memberPhone = member.getString("phone");
+                                boolean memberisAdmin = member.getBoolean("is_admin");
+
+                                //add members
+                                FriendGroupMember members = new FriendGroupMember(group.getId(), memberId);
+
+                                members.assignUniqueId(userId);
+
+                                ContentValues groupMembers = new ContentValues();
+                                groupMembers.put(FriendGroupMember.DB_ID, members.getId());
+                                groupMembers.put(FriendGroupMember.DB_FRIEND, members.getFriendId());
+                                groupMembers.put(FriendGroupMember.DB_GROUP, members.getGroupID());
+                                groupMembers.put(FriendGroupMember.PHONE_NUMBER, memberPhone);
+
+                                if (memberisAdmin) {
+                                    groupMembers.put(FriendGroupMember.DB_FRIEND_IS_ADMIN, 1);
+                                }
+
+                                groupMembers.put(FriendGroupMember.DB_FRIEND_DID_JOIN, 1);
+//reza_ak
+                             /*   if (mContentResolver.update(UserProvider.CONTENT_URI_GROUP_MEMBER, groupMembers, FriendGroupMember.DB_GROUP + "=? AND " + FriendGroupMember.DB_FRIEND + "=?", new String[]{members.getGroupID(), memberId}) == 0) {
+                                    mContentResolver.insert(UserProvider.CONTENT_URI_GROUP_MEMBER, groupMembers);
+                                }*/
+
+                            }
+
+                        }
+                    }catch (Exception e)
+                         {}
+
+
+                    }
+
+
+                    //send a new message event so the ChatThreadFragment updates itself
+                    NewMessageEvent newMessageEvent = new NewMessageEvent();
+                    newMessageEvent.setThreadId(thread.getThreadId());
+
+                    newMessageEvent.setDirection(MyMessageType.INCOMING_MSG.ordinal());
+                    EventBus.getDefault().postSticky(newMessageEvent);
+
+                }
+            } catch (Exception e) {
+                return false;
+            }
+
+        }
+        return true;
+    }
+
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/SubscribeToAllTopicsJob.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/SubscribeToAllTopicsJob.java
new file mode 100644
index 000000000..4ac2b4d62
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/SubscribeToAllTopicsJob.java
@@ -0,0 +1,161 @@
+package org.telegram.messenger.shamChat;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.database.Cursor;
+import android.util.Log;
+
+import com.path.android.jobqueue.Job;
+import com.path.android.jobqueue.Params;
+
+
+import org.eclipse.paho.android.service.MqttAndroidClient;
+import org.eclipse.paho.client.mqttv3.IMqttActionListener;
+import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.telegram.messenger.ApplicationLoader;
+import org.telegram.messenger.R;
+import org.telegram.messenger.mqtt.Connection;
+import org.telegram.messenger.mqtt.Connections;
+
+import java.io.IOException;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class SubscribeToAllTopicsJob extends Job {
+
+	private static final long serialVersionUID = 1L;
+
+	public static final int PRIORITY = 1000;
+
+	private static final AtomicInteger jobCounter = new AtomicInteger(0);
+	private final int id;
+	private boolean isError = false;
+	String[] allTopics;
+	
+	public SubscribeToAllTopicsJob() {
+		super(new Params(PRIORITY).persist().requireNetwork());
+		 
+		id = jobCounter.incrementAndGet();
+	}
+
+	@Override
+	public void onAdded() {
+		// Job has been saved to disk.
+		// This is a good place to dispatch a UI event to indicate the job will
+		// eventually run.
+		// In this example, it would be good to update the UI with the newly
+		// posted tweet.
+	}
+
+	@Override
+	protected void onCancel() {
+		// Job has exceeded retry attempts or shouldReRunOnThrowable() has
+		// returned false.
+
+	}
+
+	@Override
+	public void onRun() throws Throwable {
+		// Job logic goes here.
+
+		if (id != jobCounter.get()) {
+			// looks like other fetch jobs has been added after me. no reason to
+			// keep fetching
+			// many times, cancel me, let the other one fetch tweets.
+			return;
+		}
+		/*reza_ak
+
+		MqttAndroidClient mqttClient;		
+		ContentResolver mContentResolver = ApplicationLoader.applicationContext.getContentResolver();
+			
+		RokhPref Session = new RokhPref(ApplicationLoader.applicationContext.getApplicationContext());
+		final String clientHandle = Session.getClientHandle();
+		
+		final Context context = ApplicationLoader.applicationContext.getApplicationContext();
+		//reza_ak
+		Cursor cursor		= mContentResolver.query( UserProvider.CONTENT_URI_GROUP, null, null, null, null);
+		int	groupCount		= cursor.getCount();
+
+		
+		allTopics	= new String[groupCount];
+		isError = false;
+		int [] qosArray = new int[groupCount];
+		int i	= 0;
+		if (groupCount >0)
+		 {
+			while (cursor.moveToNext()) {
+				String hashcode	= cursor.getString(cursor.getColumnIndex(FriendGroup.CHAT_ROOM_NAME));
+				String groupAlias	= cursor.getString(cursor.getColumnIndex(FriendGroup.DB_NAME));
+
+				if (hashcode==null) hashcode = "nothing";
+                    //if this is a group
+					if (hashcode.startsWith("ch")) {
+						Log.e("Subscribe", "channels/" + hashcode + "  channelAlias:" + groupAlias);
+						allTopics[i] = "channels/" + hashcode;
+						qosArray[i] = 1;
+                    //if this is a channel
+					} else {
+
+						Log.e("Subscribe", "groups/" + hashcode + "  groupAlias:" + groupAlias);
+						allTopics[i] = "groups/" + hashcode;
+						qosArray[i] = 1;
+					}
+					i++;
+	
+			}
+			cursor.close();
+			
+			//final ActionListener callback = new ActionListener(context, ActionListener.Action.SUBSCRIBE, clientHandle, allTopics);
+
+			
+			mqttClient = Connections.getInstance(ApplicationLoader.applicationContext.getApplicationContext()).getConnection(clientHandle).getClient();
+			
+		    
+			mqttClient.subscribe(allTopics, qosArray, null,  new IMqttActionListener() {
+				
+				@Override
+				public void onSuccess(IMqttToken arg0) {
+					// TODO Auto-generated method stub
+				    Connection c = Connections.getInstance(context).getConnection(clientHandle);
+				    String actionTaken = context.getString(R.string.toast_sub_success,
+				        (Object[]) allTopics);
+				    c.addAction(actionTaken);
+				    
+				    //Notify.toast(context, actionTaken, Toast.LENGTH_SHORT);
+				    //Notify.toast(context, "successG", Toast.LENGTH_SHORT);
+				}
+				
+				@Override
+				public void onFailure(IMqttToken arg0, Throwable arg1) {
+					
+				    Connection c = Connections.getInstance(context).getConnection(clientHandle);
+				    String action = context.getString(R.string.toast_sub_failed,
+				        (Object[]) allTopics);
+				    c.addAction(action);
+				    
+				    //Notify.toast(context, action, Toast.LENGTH_SHORT);
+				    //Notify.toast(context, "failG", Toast.LENGTH_SHORT);
+				    isError = true;
+				}	
+		
+			});
+
+			if (isError) throw new IOException("Unexpected code");
+		 }*/
+	}
+
+
+	@Override
+	protected boolean shouldReRunOnThrowable(Throwable throwable) {
+
+		// An error occurred in onRun.
+		// Return value determines whether this job should retry running (true)
+		// or abort (false).
+		Log.e("Subscribe", "to all topics failed: "+ throwable.getCause());	
+		System.out.println("subscribe to events topic failed - retry");
+
+		return true;
+	}
+
+
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/SubscribeToEventsJob.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/SubscribeToEventsJob.java
new file mode 100644
index 000000000..eabe4fc7b
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/SubscribeToEventsJob.java
@@ -0,0 +1,127 @@
+package org.telegram.messenger.shamChat;
+
+import android.content.Context;
+
+import com.path.android.jobqueue.Job;
+import com.path.android.jobqueue.Params;
+
+
+import org.eclipse.paho.android.service.MqttAndroidClient;
+import org.eclipse.paho.client.mqttv3.IMqttActionListener;
+import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.telegram.messenger.ApplicationLoader;
+import org.telegram.messenger.R;
+import org.telegram.messenger.mqtt.Connection;
+import org.telegram.messenger.mqtt.Connections;
+
+import java.io.IOException;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class SubscribeToEventsJob extends Job {
+
+	private static final long serialVersionUID = 1L;
+
+	public static final int PRIORITY = 1000;
+
+	private static final AtomicInteger jobCounter = new AtomicInteger(0);
+	private final int id;
+
+
+	String[] topics;
+	boolean isError = false;
+	
+	public SubscribeToEventsJob() {
+		super(new Params(PRIORITY).persist().requireNetwork());
+		 
+		id = jobCounter.incrementAndGet();
+
+	}
+
+	@Override
+	public void onAdded() {
+		// Job has been saved to disk.
+		// This is a good place to dispatch a UI event to indicate the job will
+		// eventually run.
+		// In this example, it would be good to update the UI with the newly
+		// posted tweet.
+	}
+
+	@Override
+	protected void onCancel() {
+		// Job has exceeded retry attempts or shouldReRunOnThrowable() has
+		// returned false.
+
+	}
+
+	@Override
+	public void onRun() throws Throwable {
+		// Job logic goes here.
+
+		if (id != jobCounter.get()) {
+			// looks like other fetch jobs has been added after me. no reason to
+			// keep fetching
+			// many times, cancel me, let the other one fetch tweets.
+			return;
+		}
+			
+		MqttAndroidClient mqttClient;		
+		RokhPref Session = new RokhPref(ApplicationLoader.applicationContext.getApplicationContext());
+		final String clientHandle = Session.getClientHandle();
+		//reza_ak
+		String userId	= "6";
+		//phoneNumber = phoneNumber.startsWith("+") ? phoneNumber.substring(1) : phoneNumber;
+		String topic = "events/"+userId;
+		final Context context = ApplicationLoader.applicationContext.getApplicationContext();
+		
+		topics = new String[1];
+	    topics[0] = topic;
+	     
+		mqttClient = Connections.getInstance(
+				ApplicationLoader.applicationContext.getApplicationContext()).getConnection(clientHandle).getClient();
+		mqttClient.subscribe(topic, 1, null,   new IMqttActionListener() {
+			
+			@Override
+			public void onSuccess(IMqttToken arg0) {
+				// TODO Auto-generated method stub
+			    Connection c = Connections.getInstance(context).getConnection(clientHandle);
+			    String actionTaken = context.getString(R.string.toast_sub_success,
+			        (Object[]) topics);
+			    c.addAction(actionTaken);
+			    
+			    //Notify.toast(context, actionTaken, Toast.LENGTH_SHORT);
+			    //Notify.toast(context, "success", Toast.LENGTH_SHORT);
+			}
+			
+			@Override
+			public void onFailure(IMqttToken arg0, Throwable arg1) {
+				
+			    Connection c = Connections.getInstance(context).getConnection(clientHandle);
+			    String action = context.getString(R.string.toast_sub_failed,
+			        (Object[]) topics);
+			    c.addAction(action);
+			    
+			    //Notify.toast(context, action, Toast.LENGTH_SHORT);
+			    //Notify.toast(context, "fail", Toast.LENGTH_SHORT);
+			    isError = true;
+			}	
+	
+		});
+		
+		if (isError) throw new IOException("Unexpected code");
+		
+		
+	}
+
+	@Override
+	protected boolean shouldReRunOnThrowable(Throwable throwable) {
+
+		// An error occurred in onRun.
+		// Return value determines whether this job should retry running (true)
+		// or abort (false).
+		System.out.println("********subscribe to events topic failed - retry******8");
+	
+		return true;
+	}
+
+
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/SyncContactsJob.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/SyncContactsJob.java
new file mode 100644
index 000000000..778b8099f
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/SyncContactsJob.java
@@ -0,0 +1,391 @@
+/*
+package org.telegram.messenger.shamChat;
+
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.SharedPreferences;
+import android.content.SharedPreferences.Editor;
+import android.database.Cursor;
+import android.os.Looper;
+import android.preference.PreferenceManager;
+import android.provider.BaseColumns;
+import android.provider.ContactsContract;
+import android.provider.ContactsContract.CommonDataKinds.Phone;
+import android.widget.Toast;
+
+import com.path.android.jobqueue.Job;
+import com.path.android.jobqueue.Params;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import de.greenrobot.event.EventBus;
+
+public class SyncContactsJob extends Job {
+
+	private static final long serialVersionUID = 1L;
+
+	public static final int PRIORITY = 9000;
+
+	private static final AtomicInteger jobCounter = new AtomicInteger(0);
+	private final int id;
+
+	public SyncContactsJob(long delay) {
+		super(new Params(PRIORITY).delayInMs(delay).persist().requireNetwork());
+		id = jobCounter.incrementAndGet();
+
+	}
+
+	@Override
+	public void onAdded() {
+		// Job has been saved to disk.
+		// This is a good place to dispatch a UI event to indicate the job will
+		// eventually run.
+		// In this example, it would be good to update the UI with the newly
+		// posted tweet.
+	}
+
+	@Override
+	protected void onCancel() {
+		// Job has exceeded retry attempts or shouldReRunOnThrowable() has
+		// returned false.
+		
+		showToast("خطایی در بروزرسانی مخاطبین رخ داد لطفا مجدد سعی نمایید.");
+
+		EventBus.getDefault().postSticky(new SyncContactsCompletedEvent());		
+
+	}
+
+	@Override
+	protected int getRetryLimit() {
+		// TODO Auto-generated method stub
+		return 2;
+	}
+	@Override
+	public void onRun() throws Throwable {
+		// Job logic goes here.
+
+		if (id != jobCounter.get()) {
+			// looks like other fetch jobs has been added after me. no reason to
+			// keep fetching
+			// many times, cancel me, let the other one fetch tweets.
+			return;
+		}
+
+			List<User> phoneContacts = new ArrayList<User>();
+			String result = null;
+
+
+			PhoneContacts contacts = getPhoneContacts();
+
+			if (contacts == null) {
+				return;
+			}
+			phoneContacts.addAll(contacts.getNewlyAddedContacts());
+
+			JSONObject jObject = new JSONObject();
+
+			jObject.put("phone_numbers", contacts.getContactsJson());
+
+			String value = jObject.toString();
+			System.out.println("value" + value);
+			String value2=SHAMChatApplication.getConfig().getUserId();
+			//String URL = SHAMChatApplication.getMyApplicationContext().getResources().getString(R.string.homeBaseURL) + "getFreindsForPhoneNumbers.htm";
+		String URL= Constant.SyncContacts;
+
+		//mast - send request to server for syncing contacts
+			  OkHttpClient client = new OkHttpClient();
+			  
+			   client.setConnectTimeout(180, TimeUnit.SECONDS); // connect timeout
+			   client.setReadTimeout(180, TimeUnit.SECONDS);    // socket timeout
+			   
+			    RequestBody formBody = new FormEncodingBuilder()
+			        .add("contact", value)
+					.add("user_id", value2)
+			        .build();
+			    Request request = new Request.Builder()
+			        .url(URL)
+			        .post(formBody)
+			        .build();
+			  
+			    Response response = client.newCall(request).execute();
+				// check if request was successful
+			    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+			    
+			result = response.body().string();
+			response.body().close();
+			
+			if (result != null) {
+
+				JSONObject serverResponse = new JSONObject(result);
+				String status = serverResponse.getString("status");
+
+				if (status.equals("200")) {
+					//JSONObject webData = serverResponse.getJSONObject("objects");
+					markCurrentAppUsers(serverResponse.getJSONArray("objects"),phoneContacts);
+
+					SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(SHAMChatApplication.getMyApplicationContext());
+					preferences.edit().putBoolean(PreferenceConstants.INITIAL_LOGIN, false);
+					preferences.edit().apply();
+
+				}
+
+			}
+			
+			showToast("بروز رسانی مخاطبین با موفقیت انجام شد ");	
+
+		EventBus.getDefault().postSticky(new SyncContactsCompletedEvent());
+
+	}
+	
+	private void showToast(final String message) {
+        try {
+            new Thread() {
+                @Override
+                public void run() {
+                    Looper.prepare();
+                    Toast.makeText(SHAMChatApplication.getMyApplicationContext(), message , Toast.LENGTH_LONG).show();
+                    Looper.loop();
+                }
+            }.start();
+        } catch (Exception e) {
+            // TODO: handle exception
+            e.printStackTrace();
+        }
+  		
+	}
+
+	@Override
+	protected boolean shouldReRunOnThrowable(Throwable throwable) {
+
+		// An error occurred in onRun.
+		// Return value determines whether this job should retry running (true)
+		// or abort (false).
+		System.out.println("Sync Contacts should retry? tries 2 times ");
+		
+		return true;
+	}
+
+	private PhoneContacts getPhoneContacts() throws JSONException {
+		 User me;
+		 ContentResolver mContentResolver;
+		mContentResolver = SHAMChatApplication .getMyApplicationContext().getContentResolver();
+		Cursor cursor = mContentResolver.query(UserProvider.CONTENT_URI_USER,
+				null, UserConstants.USER_ID + "=?",
+				new String[] { SHAMChatApplication.getConfig().getUserId() },
+				null);
+		if (cursor != null) {
+			cursor.moveToFirst();
+		}
+		me = UserProvider.userFromCursor(cursor);
+
+		String mo=	me.getMobileNo().substring((me.getMobileNo().length()-10));
+		List<User> newlyAddedContacts = new ArrayList<User>();
+		List<String> contactListOnyNumbers = new ArrayList<String>();
+		JSONArray contactsJson = new JSONArray();
+		ContentResolver cr = SHAMChatApplication.getMyApplicationContext()
+				.getContentResolver();
+
+		Cursor cur = cr.query(ContactsContract.Contacts.CONTENT_URI, null,
+				null, null, BaseColumns._ID + " ASC");
+		SharedPreferences preferences = PreferenceManager
+				.getDefaultSharedPreferences(SHAMChatApplication
+						.getMyApplicationContext());
+		Editor editor = preferences.edit();
+		editor.putInt(PreferenceConstants.CONTACT_LAST_COUNT, cur.getCount());
+		editor.apply();
+
+		PhoneContacts contacts = null;
+		if (cur.getCount() > 0) {
+			while (cur.moveToNext()) {
+				User user = new User();
+
+				String id = cur.getString(cur.getColumnIndex(BaseColumns._ID));
+
+				String name = cur
+						.getString(cur
+								.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME));
+
+				user.setUsername(name);
+				if (Integer
+						.parseInt(cur.getString(cur
+								.getColumnIndex(ContactsContract.Contacts.HAS_PHONE_NUMBER))) > 0) {
+					Cursor phonesCursor = cr.query(
+							Phone.CONTENT_URI,
+							null,
+							Phone.CONTACT_ID
+									+ " = ?", new String[] { id }, null);
+
+					while (phonesCursor.moveToNext()) {
+						String contactNumber = phonesCursor
+								.getString(phonesCursor
+										.getColumnIndex(Phone.NUMBER));
+
+						Cursor cursor2 =  SHAMChatApplication.getMyApplicationContext().getContentResolver().query(UserProvider.CONTENT_URI_USER, null, UserConstants.MOBILE_NO+" LIKE ? AND "+UserConstants.USER_ID+"!=?  AND "+UserConstants.USER_TYPE+"=?" , new String [] {"%"+contactNumber+"%",SHAMChatApplication.getConfig().getUserId(),"2"}, null);
+
+
+						if (contactNumber != null && !contactNumber.replace(" ", "").endsWith(mo)&&cursor2.getCount()==0) {
+							contactNumber = contactNumber.replace(" ", "")
+									.trim();
+						} else {
+							continue;
+						}
+
+						String phoneNumber = contactNumber.replaceAll("[^0-9]",
+								"");
+
+						if (phoneNumber != null && phoneNumber.length() > 0) {
+							user.setMobileNo(phoneNumber);
+
+							user.setUserId(PreferenceConstants.CONTACT_IDENTIFIER
+									+ id);
+							contactListOnyNumbers.add(phoneNumber);
+
+							newlyAddedContacts.add(user);
+
+							contactsJson.put(phoneNumber);
+						} else {
+							System.out.println("Not a valid Number"
+									+ contactNumber);
+						}
+					}
+
+					phonesCursor.close();
+				}
+
+			}
+
+			cur.moveToLast();
+		}
+
+		long lastId = cur.getLong(cur.getColumnIndex(BaseColumns._ID));
+		cur.close();
+
+		if (newlyAddedContacts != null && newlyAddedContacts.size() > 0) {
+			contacts = new PhoneContacts(newlyAddedContacts, contactsJson,
+					contactListOnyNumbers, lastId);
+		}
+		return contacts;
+	}
+
+
+
+	private boolean markCurrentAppUsers(final JSONArray contactsInAppJSONArray,
+			final List<User> phoneContacts) {
+
+		System.out.println("contactsInAppJSONArray " + contactsInAppJSONArray);
+		if (contactsInAppJSONArray != null
+				&& contactsInAppJSONArray.length() > 0) {
+			ContentResolver cr = SHAMChatApplication.getMyApplicationContext()
+					.getContentResolver();
+			for (int i = 0; i < contactsInAppJSONArray.length(); i++) {
+				try {
+					JSONObject contact = contactsInAppJSONArray
+							.getJSONObject(i);
+					for (User user : phoneContacts) {
+
+						String mobileNo = user.getMobileNo();
+
+						if (mobileNo.contains(" "))
+							mobileNo = mobileNo.replace(" ", "");
+
+						if (mobileNo.length() < 9) {
+							continue;
+						}
+
+						if (contact != null
+								&& contact.has("phone")
+								&& contact.getString("phone").length() > 9
+								&& contact.getString("phone").substring(
+												contact.getString("phone")
+														.length() - 9)
+										.contains(mobileNo.substring(mobileNo
+														.length() - 9))) {
+
+							String userId = contact.getString("user_id");
+
+							ContentValues values = new ContentValues();
+							values.put(UserConstants.USER_ID,userId);
+							//values.put(UserConstants.CHAT_ID,contact.getString("chatId"));
+							values.put(UserConstants.MOBILE_NO, mobileNo);
+							values.put(UserConstants.USERNAME,user.getUsername());
+							//values.put(UserConstants.EMAIL,contact.getString("email"));
+							//values.put(UserConstants.CITY_OR_REGION,contact.getString("region"));
+							//values.put(UserConstants.GENDER,contact.getString("gender"));
+							values.put(UserConstants.PROFILE_IMAGE_URL,contact.getString("avatar"));
+
+						//	values.put(UserConstants.MY_STATUS,contact.getString("myStatus"));
+							values.put(UserConstants.USER_TYPE, 2);
+
+							int result = cr.update(UserProvider.CONTENT_URI_USER, values,
+									UserConstants.USER_ID + "=?",
+									new String[] { user.getUserId() });
+							if (result == 0) {
+								cr.insert(UserProvider.CONTENT_URI_USER, values);
+							} else {
+								System.out.println("SynContacts result "+result+" "+mobileNo);
+							}
+							
+							
+							
+							String userJabberId = Utils
+									.createXmppUserIdByUserId(userId);
+
+							
+							
+							// add fake roster entry
+
+							final ContentValues rosterValues = new ContentValues();
+
+							rosterValues.put(RosterConstants.JID, userJabberId);
+
+							rosterValues
+									.put(RosterConstants.ALIAS,
+											user.getUsername()
+													+ PreferenceConstants.ROSTER_ITEM_SPLITTER
+													+ mobileNo);
+
+							rosterValues.put(RosterConstants.STATUS_MODE,
+									StatusMode.offline.ordinal());
+
+							rosterValues
+									.put(RosterConstants.STATUS_MESSAGE, "");
+							rosterValues.put(RosterConstants.GROUP, "");
+							rosterValues.put(RosterConstants.SHOW_IN_CHAT, 1);
+
+							if (cr.update(RosterProvider.CONTENT_URI,
+									rosterValues, RosterConstants.JID + "=?",
+									new String[] { userJabberId }) == 0) {
+								cr.insert(RosterProvider.CONTENT_URI,
+										rosterValues);
+							}
+
+							// VCard card=new VCard();
+							// card.load(SmackableImp.getXmppConnection(),
+							// userJabberId);
+
+							break;
+						}
+
+					}
+				}
+
+				catch (Exception e) {
+					e.printStackTrace();
+				}
+			}
+
+		}
+
+		return true;
+	}
+
+}
+*/
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/UpdateGroupMembersList.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/UpdateGroupMembersList.java
new file mode 100644
index 000000000..5744b9228
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/UpdateGroupMembersList.java
@@ -0,0 +1,26 @@
+package org.telegram.messenger.shamChat;
+
+public class UpdateGroupMembersList {
+
+	private String threadId;
+	private String groupId;
+
+	public UpdateGroupMembersList(String threadId, String groupId){
+		this.threadId = threadId;
+		this.groupId = groupId;
+	}
+	public String getGroupId() {
+		return groupId;
+	}
+	public void setGroupId(String groupId) {
+		this.groupId = groupId;
+	}
+	public String getThreadId() {
+		return threadId;
+	}
+	public void setThreadId(String threadId) {
+		this.threadId = threadId;
+	}	
+
+}
+
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/User.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/User.java
new file mode 100644
index 000000000..536d0e9e4
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/User.java
@@ -0,0 +1,480 @@
+package org.telegram.messenger.shamChat;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.Base64;
+
+
+
+import org.json.JSONObject;
+
+import java.text.Collator;
+
+
+public class User implements Comparable<User>, Parcelable {
+
+	private String userId;
+	private String username;
+	private String chatId;
+	private String mobileNo;
+	private String email;
+	private String gender;
+	private String profileImage;
+	private int onlineStatus;
+	private String myStatus;
+	private String newMessageAlert;
+	private String inAppAlert;
+	private String emailVerificationStatus;
+	private String tmpUserId;
+	private String cityOrRegion;
+	private String coverPhoto;
+	private String jabberdResource;
+	private BooleanStatus findMeByPhoneNo;
+	private BooleanStatus findMeByShamId;
+	private Boolean isMentionChecked = false;
+	private String profileImageUrl;
+	private BooleanStatus isInChat;
+	private String dbRowId;
+
+	private String NULL = "null";
+	private boolean isBlocked;
+
+	// Not saved on db, temporal values:
+	public boolean takenFromPhoneContacts = false;
+	public boolean shamMyContactUser = false;
+	// for checkbox views
+	public boolean checked;
+	
+	private int statusMode;
+	
+	private boolean isVCardDownloaded;
+	private boolean isAddedToRoster;
+
+
+	public User() {
+
+	}
+
+	public User(JSONObject userJsonObject) throws Exception {
+		//reza_ak
+		/*
+
+		if (userJsonObject.has(UserConstants.USER_ID)) {
+			this.userId = "" + userJsonObject.getInt(UserConstants.USER_ID);
+		}
+		if (userJsonObject.has(UserConstants.USERNAME)) {
+
+			this.username = !userJsonObject.getString(UserConstants.USERNAME).equals(NULL) ? userJsonObject.getString(UserConstants.USERNAME) : "";
+		}
+		if (userJsonObject.has(UserConstants.CHAT_ID)) {
+
+			this.chatId = !userJsonObject.getString(UserConstants.CHAT_ID).equals(NULL) ? userJsonObject.getString(UserConstants.CHAT_ID) : "";
+		}
+		if (userJsonObject.has(UserConstants.MOBILE_NO)) {
+			this.mobileNo = !userJsonObject.getString(UserConstants.MOBILE_NO).equals(NULL) ? userJsonObject.getString(UserConstants.MOBILE_NO)
+					: "";
+
+		}
+		if (userJsonObject.has(UserConstants.EMAIL)) {
+
+			this.email = !userJsonObject.getString(UserConstants.EMAIL).equals(NULL) ? userJsonObject.getString(UserConstants.EMAIL) : "";
+		}
+		if (userJsonObject.has("profileImageUrl")) {
+			this.profileImage = "";
+			this.profileImageUrl = !userJsonObject.getString("profileImageUrl").equals(NULL) ? userJsonObject
+					.getString("profileImageUrl") : "";
+			Thread imageDownloader = new Thread() {
+				@Override
+				public void run() {
+					if (profileImageUrl != null && profileImageUrl.length() > 0
+							&& !profileImageUrl.equalsIgnoreCase("exception")
+							&& !profileImageUrl.equalsIgnoreCase("null")) {
+						byte[] blobMessage = new Utils().downloadImageFromUrl(profileImageUrl);
+						if (blobMessage != null)
+							profileImage = Base64.encodeToString(blobMessage, Base64.DEFAULT);
+					}
+					super.run();
+				}
+			};
+			imageDownloader.start();
+			imageDownloader.join();
+
+		}
+		if (userJsonObject.has(UserConstants.TEMP_USER_ID)) {
+			this.tmpUserId = !userJsonObject.getString(UserConstants.TEMP_USER_ID).equals(NULL) ? userJsonObject
+					.getString(UserConstants.TEMP_USER_ID) : "";
+
+		}
+		if (userJsonObject.has(UserConstants.IN_APP_ALERT)) {
+			this.inAppAlert = !userJsonObject.getString(UserConstants.IN_APP_ALERT).equals(NULL) ? userJsonObject
+					.getString(UserConstants.IN_APP_ALERT) : "";
+
+		}
+		if (userJsonObject.has(UserConstants.EMAIL_VERIFICATION_STATUS)) {
+
+			this.emailVerificationStatus = !userJsonObject.getString(UserConstants.EMAIL_VERIFICATION_STATUS).equals(NULL) ? userJsonObject
+					.getString(UserConstants.EMAIL_VERIFICATION_STATUS) : "";
+		}
+		if (userJsonObject.has(UserConstants.NEW_MESSAGE_ALERT)) {
+
+			this.newMessageAlert = !userJsonObject.getString(UserConstants.NEW_MESSAGE_ALERT).equals(NULL) ? userJsonObject
+					.getString(UserConstants.NEW_MESSAGE_ALERT) : "";
+		}
+		if (userJsonObject.has(UserConstants.GENDER)) {
+
+			this.gender = !userJsonObject.getString(UserConstants.GENDER).equals(NULL) ? userJsonObject.getString(UserConstants.GENDER) : "";
+		}
+//		if (userJsonObject.has(UserConstants.ONLINE_STATUS)) {
+//
+//			this.onlineStatus = !userJsonObject.getString(UserConstants.ONLINE_STATUS).equals(NULL) ? userJsonObject
+//					.getString(UserConstants.ONLINE_STATUS) : "Offline";
+//		}
+		if (userJsonObject.has(UserConstants.MY_STATUS)) {
+
+			this.myStatus = !userJsonObject.getString(UserConstants.MY_STATUS).equals(NULL) ? userJsonObject.getString(UserConstants.MY_STATUS)
+					: "";
+			System.out.println("User status in user class "+this.myStatus);
+		}
+
+		if (userJsonObject.has(UserConstants.CITY_OR_REGION)) {
+
+			this.cityOrRegion = !userJsonObject.getString(UserConstants.CITY_OR_REGION).equals(NULL) ? userJsonObject
+					.getString(UserConstants.CITY_OR_REGION) : "";
+		}
+		
+		this.isInChat= BooleanStatus.TRUE;*/
+
+	}
+
+	public String getUserId() {
+		return userId;
+	}
+
+	public User setUserId(String userId) {
+		this.userId = userId;
+
+		return this;
+	}
+
+	public String getChatId() {
+		return chatId;
+	}
+
+	public User setChatId(String chatId) {
+		this.chatId = chatId;
+
+		return this;
+	}
+
+	public String getUsername() {
+		return username;
+	}
+
+	public User setUsername(String username) {
+		this.username = username;
+
+		return this;
+	}
+
+	public String getGender() {
+		return gender;
+	}
+
+	public User setGender(String gender) {
+		this.gender = gender;
+
+		return this;
+	}
+
+	public String getProfileImage() {
+		return profileImage;
+	}
+
+	public User setProfileImage(String profileImage) {
+		this.profileImage = profileImage;
+
+		return this;
+	}
+
+
+	public int getOnlineStatus() {
+		return onlineStatus;
+	}
+
+	public void setOnlineStatus(int onlineStatus) {
+		this.onlineStatus = onlineStatus;
+
+	}
+
+	public String getMyStatus() {
+		return myStatus;
+	}
+
+	public void setMyStatus(String status) {
+		this.myStatus = status;
+	}
+
+	public String getMobileNo() {
+		return mobileNo;
+	}
+
+	public User setMobileNo(String mobileNo) {
+		this.mobileNo = mobileNo;
+
+		return this;
+	}
+
+	public String getEmail() {
+		return email;
+	}
+
+	public void setEmail(String email) {
+		this.email = email;
+	}
+
+	public String getNewMessageAlert() {
+		return newMessageAlert;
+	}
+
+	public void setNewMessageAlert(String newMessageAlert) {
+		this.newMessageAlert = newMessageAlert;
+	}
+
+	public String getInAppAlert() {
+		return inAppAlert;
+	}
+
+	public void setInAppAlert(String inAppAlert) {
+		this.inAppAlert = inAppAlert;
+	}
+
+	public String getEmailVerificationStatus() {
+		return emailVerificationStatus;
+	}
+
+	public void setEmailVerificationStatus(String emailVerificationStatus) {
+		this.emailVerificationStatus = emailVerificationStatus;
+	}
+
+	public String getTmpUserId() {
+		return tmpUserId;
+	}
+
+	public void setTmpUserId(String tmpUserId) {
+		this.tmpUserId = tmpUserId;
+	}
+
+	
+
+	@Override
+	public boolean equals(Object o) {
+		if (o == null)
+			return false;
+
+		if (this == o)
+			return true;
+
+		if (!(o instanceof User))
+			return false;
+
+		User other = (User) o;
+
+		if (getUserId().length() == 0 && other.getUserId().length() == 0)
+			return false;
+
+		return other.getUserId().equals(getUserId());
+	}
+	
+	public enum BooleanStatus {
+		FALSE(0), TRUE(1);
+		private int status;
+
+		BooleanStatus(int status) {
+			this.setStatus(status);
+		}
+
+		public int getStatus() {
+			return status;
+		}
+
+		private void setStatus(int status) {
+			this.status = status;
+		}
+	}
+
+	@Override
+	public int compareTo(User another) {
+		return Collator.getInstance().compare(username.toUpperCase(), another.username.toUpperCase());
+	}
+
+	@Override
+	public String toString() {
+		return "Id:" + getUserId() + " Name:" + getUsername();
+	}
+
+	public String getCityOrRegion() {
+		return cityOrRegion;
+	}
+
+	public void setCityOrRegion(String cityOrRegion) {
+		this.cityOrRegion = cityOrRegion;
+	}
+
+	public String getCoverPhoto() {
+		return coverPhoto;
+	}
+
+	public void setCoverPhoto(String coverPhoto) {
+		this.coverPhoto = coverPhoto;
+	}
+
+	public Boolean getIsMentionChecked() {
+		return isMentionChecked;
+	}
+
+	public void setIsMentionChecked(Boolean isMentionChecked) {
+		this.isMentionChecked = isMentionChecked;
+	}
+
+	public String getJabberdResource() {
+		return jabberdResource;
+	}
+
+	public void setJabberdResource(String jabberdResource) {
+		this.jabberdResource = jabberdResource;
+	}
+
+	public BooleanStatus getFindMeByPhoneNoStatus() {
+		return findMeByPhoneNo;
+	}
+
+	public void setFindMeByPhoneNoStatus(BooleanStatus findMeByPhoneNo) {
+		this.findMeByPhoneNo = findMeByPhoneNo;
+	}
+
+	public BooleanStatus getFindMeByShamIdStatus() {
+		return findMeByShamId;
+	}
+
+	public void setFindMeByShamIdStatus(BooleanStatus findMeByShamId) {
+		this.findMeByShamId = findMeByShamId;
+	}
+
+	public String getprofileImageUrl() {
+		return profileImageUrl;
+	}
+
+	public void setprofileImageUrl(String profileImageUrl) {
+		this.profileImageUrl = profileImageUrl;
+	}
+
+	public BooleanStatus getIsInChat() {
+		return isInChat;
+	}
+
+	public void setIsInChat(BooleanStatus isInChat) {
+		this.isInChat = isInChat;
+	}
+
+	public String getDbRowId() {
+		return dbRowId;
+	}
+
+	public void setDbRowId(String dbRowId) {
+		this.dbRowId = dbRowId;
+	}
+	
+	private User(Parcel in) {
+		userId = in.readString();
+		username = in.readString();
+		chatId = in.readString();
+		mobileNo = in.readString();
+		email = in.readString();
+		gender = in.readString();
+		profileImage = in.readString();
+		onlineStatus = in.readInt();
+		myStatus = in.readString();
+		newMessageAlert = in.readString();
+		inAppAlert = in.readString();
+		emailVerificationStatus = in.readString();
+		tmpUserId = in.readString();
+		cityOrRegion = in.readString();
+		coverPhoto = in.readString();
+		jabberdResource = in.readString();
+		profileImageUrl = in.readString();
+	}
+
+	@Override
+	public int describeContents() {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+	
+	public static final Creator<User> CREATOR = new Creator<User>() {
+		@Override
+		public User createFromParcel(Parcel in) {
+			return new User(in);
+		}
+
+		@Override
+		public User[] newArray(int size) {
+			return new User[size];
+		}
+	};
+
+	@Override
+	public void writeToParcel(Parcel out, int flags) {
+		out.writeString(userId);
+		out.writeString(username);
+		out.writeString(chatId);
+		out.writeString(mobileNo);
+		out.writeString(email);
+		out.writeString(gender);
+		out.writeString(profileImage);
+		out.writeInt(onlineStatus);
+		out.writeString(myStatus);
+		out.writeString(newMessageAlert);
+		out.writeString(inAppAlert);
+		out.writeString(emailVerificationStatus);
+		out.writeString(tmpUserId);
+		out.writeString(cityOrRegion);
+		out.writeString(coverPhoto);
+		out.writeString(jabberdResource);
+		out.writeString(profileImageUrl);
+		
+	}
+
+	public boolean isBlocked() {
+		return isBlocked;
+	}
+
+	public void setBlocked(boolean isBlocked) {
+		this.isBlocked = isBlocked;
+	}
+
+	public int getStatusMode() {
+		return statusMode;
+	}
+
+	public void setStatusMode(int statusMode) {
+		this.statusMode = statusMode;
+	}
+
+	public boolean isVCardDownloaded() {
+		return isVCardDownloaded;
+	}
+
+	public void setVCardDownloaded(boolean isVCardDownloaded) {
+		this.isVCardDownloaded = isVCardDownloaded;
+	}
+
+	public boolean isAddedToRoster() {
+		return isAddedToRoster;
+	}
+
+	public void setAddedToRoster(boolean isAddedToRoster) {
+		this.isAddedToRoster = isAddedToRoster;
+	}
+
+
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/UserProvider.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/UserProvider.java
new file mode 100644
index 000000000..6a281e71f
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/UserProvider.java
@@ -0,0 +1,1314 @@
+/*
+package org.telegram.messenger.shamChat;
+
+import android.content.ContentProvider;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.UriMatcher;
+import android.database.Cursor;
+import android.database.MatrixCursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.database.sqlite.SQLiteQueryBuilder;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.net.Uri;
+import android.os.Environment;
+import android.provider.BaseColumns;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.shamchat.activity.R;
+import com.shamchat.androidclient.SHAMChatApplication;
+import com.shamchat.androidclient.util.PreferenceConstants;
+import com.shamchat.androidclient.util.PreferenceConstants.AllowDeniedStatus;
+import com.shamchat.androidclient.util.PreferenceConstants.EnableDisableStatus;
+import com.shamchat.androidclient.util.PreferenceConstants.FeatureAlertStatus;
+import com.shamchat.models.FriendGroup;
+import com.shamchat.models.FriendGroupMember;
+import com.shamchat.models.User;
+import com.shamchat.models.User.BooleanStatus;
+import com.shamchat.models.UserNotification;
+import com.shamchat.utils.Utils;
+
+import org.json.JSONObject;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.ArrayList;
+import java.util.List;
+
+import cz.msebera.android.httpclient.HttpResponse;
+import cz.msebera.android.httpclient.NameValuePair;
+import cz.msebera.android.httpclient.client.entity.UrlEncodedFormEntity;
+import cz.msebera.android.httpclient.client.methods.HttpPost;
+import cz.msebera.android.httpclient.conn.ClientConnectionManager;
+import cz.msebera.android.httpclient.conn.scheme.*;
+import cz.msebera.android.httpclient.conn.ssl.SSLSocketFactory;
+import cz.msebera.android.httpclient.impl.client.DefaultHttpClient;
+import cz.msebera.android.httpclient.impl.conn.*;
+import cz.msebera.android.httpclient.impl.conn.tsccm.*;
+import cz.msebera.android.httpclient.message.BasicNameValuePair;
+import cz.msebera.android.httpclient.params.BasicHttpParams;
+
+
+public class UserProvider extends ContentProvider {
+
+	public static final String AUTHORITY = "org.zamin.androidclient.provider.Users";
+	public static final String TABLE_NAME_USER = "user";
+	public static final String TABLE_NAME_FRIEND_GROUP = "friend_group";
+	public static final String TABLE_NAME_FRIEND_GROUP_MEMBER = "friend_group_member";
+	public static final String TABLE_NAME_USER_NOTIFICATION = "user_notification";
+
+	public static final Uri CONTENT_URI_USER = Uri.parse("content://" + AUTHORITY
+			+ "/" + TABLE_NAME_USER);
+	public static final Uri CONTENT_URI_GROUP = Uri.parse("content://" + AUTHORITY
+			+ "/" + TABLE_NAME_FRIEND_GROUP);
+	public static final Uri CONTENT_URI_GROUP_MEMBER = Uri.parse("content://" + AUTHORITY
+			+ "/" + TABLE_NAME_FRIEND_GROUP_MEMBER);
+	public static final Uri CONTENT_URI_NOTIFICATION = Uri.parse("content://" + AUTHORITY
+			+ "/" + TABLE_NAME_USER_NOTIFICATION);
+
+	private static final UriMatcher URI_MATCHER = new UriMatcher(
+			UriMatcher.NO_MATCH);
+
+	private static final int ALL_USERS = 1;
+	private static final int USER_ID = 2;
+	private static final int GROUPS = 3;
+	private static final int GROUP_ID = 4;
+	private static final int GROUP_MEMBERS = 5;
+	private static final int GROUP_MEMBER_ID = 6;
+	private static final int NOTIFICATION = 7;
+
+	static {
+		URI_MATCHER.addURI(AUTHORITY, "user", ALL_USERS);
+		URI_MATCHER.addURI(AUTHORITY, "user/#", USER_ID);
+		URI_MATCHER.addURI(AUTHORITY, "friend_group", GROUPS);
+		URI_MATCHER.addURI(AUTHORITY, "friend_group/#", GROUP_ID);
+		URI_MATCHER.addURI(AUTHORITY, "friend_group_member", GROUP_MEMBERS);
+		URI_MATCHER.addURI(AUTHORITY, "friend_group_member/#", GROUP_MEMBER_ID);
+		URI_MATCHER.addURI(AUTHORITY, "user_notification", NOTIFICATION);
+	}
+
+	private static final String TAG = "zamin.UserProvider";
+
+	private SQLiteOpenHelper mOpenHelper;
+
+	public UserProvider() {
+
+	}
+
+	@Override
+	public int delete(Uri url, String where, String[] whereArgs) {
+		SQLiteDatabase db = mOpenHelper.getWritableDatabase();
+		int count;
+		switch (URI_MATCHER.match(url)) {
+
+			case ALL_USERS:
+				count = db.delete(TABLE_NAME_USER, where, whereArgs);
+				break;
+			case USER_ID:
+				String segment = url.getPathSegments().get(1);
+
+				if (TextUtils.isEmpty(where)) {
+					where = "_id=" + segment;
+				} else {
+					where = "_id=" + segment + " AND (" + where + ")";
+				}
+
+				count = db.delete(TABLE_NAME_USER, where, whereArgs);
+				break;
+
+			case GROUPS:
+				count = db.delete(TABLE_NAME_FRIEND_GROUP, where, whereArgs);
+				break;
+
+			case GROUP_ID:
+				segment = url.getPathSegments().get(1);
+
+				if (TextUtils.isEmpty(where)) {
+					where = "_id=" + segment;
+				} else {
+					where = "_id=" + segment + " AND (" + where + ")";
+				}
+
+				count = db.delete(TABLE_NAME_FRIEND_GROUP, where, whereArgs);
+				break;
+
+			case GROUP_MEMBERS:
+				count = db.delete(TABLE_NAME_FRIEND_GROUP_MEMBER, where, whereArgs);
+				break;
+
+			case GROUP_MEMBER_ID:
+				segment = url.getPathSegments().get(1);
+
+				if (TextUtils.isEmpty(where)) {
+					where = "_id=" + segment;
+				} else {
+					where = "_id=" + segment + " AND (" + where + ")";
+				}
+
+				count = db.delete(TABLE_NAME_FRIEND_GROUP_MEMBER, where, whereArgs);
+				break;
+
+			case NOTIFICATION:
+				count = db.delete(TABLE_NAME_USER_NOTIFICATION, where, whereArgs);
+				break;
+
+			default:
+				throw new IllegalArgumentException("Cannot delete from URL: " + url);
+		}
+
+		getContext().getContentResolver().notifyChange(url, null);
+		return count;
+	}
+
+	@Override
+	public String getType(Uri url) {
+		int match = URI_MATCHER.match(url);
+		switch (match) {
+			case ALL_USERS:
+				return UserConstants.CONTENT_TYPE;
+			case USER_ID:
+				return UserConstants.CONTENT_ITEM_TYPE;
+			case GROUPS:
+				return GroupConstants.CONTENT_GROUP_TYPE;
+			case GROUP_ID:
+				return GroupConstants.CONTENT_GROUP_ITEM_TYPE;
+			case GROUP_MEMBERS:
+				return GroupMemberConstants.CONTENT_GROUP_MEMBER_TYPE;
+			case GROUP_MEMBER_ID:
+				return GroupMemberConstants.CONTENT_GROUP_MEMBER_ITEM_TYPE;
+			case NOTIFICATION:
+				return NotificationConstants.CONTENT_NOTIFICATION_TYPE;
+			default:
+				throw new IllegalArgumentException("Unknown URL");
+		}
+	}
+
+	@Override
+	public Uri insert(Uri url, ContentValues initialValues) {
+
+		if (URI_MATCHER.match(url) != ALL_USERS && URI_MATCHER.match(url) != GROUPS && URI_MATCHER.match(url) != GROUP_MEMBERS && URI_MATCHER.match(url) != NOTIFICATION) {
+			throw new IllegalArgumentException("Cannot insert into URL: " + url);
+		}
+
+		long rowId=-1;
+		Uri noteUri=null;
+
+		SQLiteDatabase db = mOpenHelper.getWritableDatabase();
+
+		ContentValues values = (initialValues != null) ? new ContentValues(
+				initialValues) : new ContentValues();
+
+		switch (URI_MATCHER.match(url)) {
+
+			case ALL_USERS:
+
+				for (String colName : UserConstants.getRequiredColumns()) {
+					if (values.containsKey(colName) == false) {
+						throw new IllegalArgumentException("Missing column: "
+								+ colName);
+					}
+				}
+
+				rowId = db.insert(TABLE_NAME_USER, "", values);
+
+				if (rowId < 0) {
+					throw new SQLException("Failed to insert row into " + url);
+				}
+
+				noteUri = ContentUris.withAppendedId(CONTENT_URI_USER, rowId);
+				getContext().getContentResolver().notifyChange(noteUri, null);
+				break;
+
+			case GROUPS:
+				for (String colName : GroupConstants.getRequiredColumns()) {
+					if (values.containsKey(colName) == false) {
+						throw new IllegalArgumentException("Missing column: " + colName);
+					}
+				}
+
+				rowId = db.insert(TABLE_NAME_FRIEND_GROUP, "", values);
+
+				if (rowId < 0) {
+					throw new SQLException("Failed to insert row into Group" + url);
+				}
+
+				if (rowId > 0) {
+					Log.d(TAG, "Group successfully entered at "+rowId);
+				}
+
+
+				noteUri = ContentUris.withAppendedId(CONTENT_URI_GROUP, rowId);
+				getContext().getContentResolver().notifyChange(noteUri, null);
+				break;
+
+			case GROUP_MEMBERS:
+				//TODO
+				for (String colName : GroupMemberConstants.getRequiredColumns()) {
+					if (values.containsKey(colName) == false) {
+						throw new IllegalArgumentException("Missing column: " + colName);
+					}
+				}
+
+				rowId = db.insert(TABLE_NAME_FRIEND_GROUP_MEMBER, "", values);
+
+				if (rowId < 0) {
+					throw new SQLException("Failed to insert row into group_members" + url);
+				}
+
+				if (rowId > 0) {
+					Log.d(TAG, "Group Members successfully entered at "+rowId);
+				}
+
+				noteUri = ContentUris.withAppendedId(CONTENT_URI_GROUP_MEMBER, rowId);
+				getContext().getContentResolver().notifyChange(noteUri, null);
+				break;
+
+			case NOTIFICATION:
+				//TODO
+				for (String colName : NotificationConstants.getRequiredColumns()) {
+					if (values.containsKey(colName) == false) {
+						throw new IllegalArgumentException("Missing column: " + colName);
+					}
+				}
+
+				rowId = db.insert(TABLE_NAME_USER_NOTIFICATION, "", values);
+
+				if (rowId < 0) {
+					throw new SQLException("Failed to insert row into group_members" + url);
+				}
+
+				if (rowId > 0) {
+					Log.d(TAG, "Group Members successfully entered at "+rowId);
+				}
+
+				noteUri = ContentUris.withAppendedId(CONTENT_URI_NOTIFICATION, rowId);
+				getContext().getContentResolver().notifyChange(noteUri, null);
+				break;
+
+			default:
+				throw new IllegalArgumentException("Cannot insert from URL: " + url);
+		}
+
+
+		return noteUri;
+	}
+
+	@Override
+	public boolean onCreate() {
+		mOpenHelper = new UserDatabaseHelper(getContext());
+		return true;
+	}
+
+	@Override
+	public int bulkInsert(Uri uri, ContentValues[] values) {
+
+		if (URI_MATCHER.match(uri) != ALL_USERS && URI_MATCHER.match(uri) != GROUPS && URI_MATCHER.match(uri) != GROUP_MEMBERS && URI_MATCHER.match(uri) != NOTIFICATION) {
+			throw new IllegalArgumentException("Cannot insert into URL: " + uri);
+		}
+
+		int rowId=0;
+
+		SQLiteDatabase db = mOpenHelper.getWritableDatabase();
+
+		switch (URI_MATCHER.match(uri)) {
+			case ALL_USERS:
+
+				db.beginTransaction();
+
+				for (ContentValues i:values) {
+
+					rowId = rowId + (int) db.insert(TABLE_NAME_USER, "", i);
+				}
+
+				db.setTransactionSuccessful();
+				db.endTransaction();
+
+				getContext().getContentResolver().notifyChange(CONTENT_URI_USER, null);
+				break;
+			case GROUPS:
+
+				db.beginTransaction();
+
+				for (ContentValues i:values) {
+
+					rowId = rowId + (int) db.insert(TABLE_NAME_FRIEND_GROUP, "", i);
+				}
+
+				db.setTransactionSuccessful();
+				db.endTransaction();
+
+				getContext().getContentResolver().notifyChange(CONTENT_URI_GROUP, null);
+				break;
+			case GROUP_MEMBERS:
+
+				db.beginTransaction();
+
+				for (ContentValues i:values) {
+
+					rowId = rowId + (int) db.insert(TABLE_NAME_FRIEND_GROUP_MEMBER, "", i);
+				}
+
+				db.setTransactionSuccessful();
+				db.endTransaction();
+
+				getContext().getContentResolver().notifyChange(CONTENT_URI_GROUP_MEMBER, null);
+				break;
+			case NOTIFICATION:
+
+				db.beginTransaction();
+
+				for (ContentValues i:values) {
+
+					rowId = rowId + (int) db.insert(TABLE_NAME_USER_NOTIFICATION, "", i);
+				}
+
+				db.setTransactionSuccessful();
+				db.endTransaction();
+
+				getContext().getContentResolver().notifyChange(CONTENT_URI_NOTIFICATION, null);
+				break;
+
+		}
+
+		return rowId;
+	}
+
+	@Override
+	public Cursor query(Uri url, String[] projectionIn, String selection,
+						String[] selectionArgs, String sortOrder) {
+
+		SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder();
+		int match = URI_MATCHER.match(url);
+
+		boolean isDistinct=false;
+
+		switch (match) {
+			case ALL_USERS:
+				qBuilder.setTables(TABLE_NAME_USER);
+				isDistinct=true;
+				break;
+			case USER_ID:
+				qBuilder.setTables(TABLE_NAME_USER);
+				qBuilder.appendWhere(UserConstants.USER_ID+"=");
+				qBuilder.appendWhere(url.getPathSegments().get(1));
+				break;
+			case GROUPS:
+				qBuilder.setTables(TABLE_NAME_FRIEND_GROUP);
+				break;
+			case GROUP_ID:
+				qBuilder.setTables(TABLE_NAME_FRIEND_GROUP);
+				qBuilder.appendWhere("_id=");
+				qBuilder.appendWhere(url.getPathSegments().get(1));
+				break;
+			case GROUP_MEMBERS:
+				qBuilder.setTables(TABLE_NAME_FRIEND_GROUP_MEMBER);
+				break;
+			case GROUP_MEMBER_ID:
+				qBuilder.setTables(TABLE_NAME_FRIEND_GROUP_MEMBER);
+				qBuilder.appendWhere("_id=");
+				qBuilder.appendWhere(url.getPathSegments().get(1));
+				break;
+			case NOTIFICATION:
+				qBuilder.setTables(TABLE_NAME_USER_NOTIFICATION);
+				break;
+			default:
+
+				throw new IllegalArgumentException("Unknown URL " + url);
+		}
+
+		String orderBy;
+		if (TextUtils.isEmpty(sortOrder)) {
+			orderBy = UserConstants.DEFAULT_SORT_ORDER;
+		} else {
+			orderBy = sortOrder;
+		}
+
+		SQLiteDatabase db = mOpenHelper.getReadableDatabase();
+
+		Cursor ret = null;
+
+
+		if(isDistinct)
+		{
+			try {
+				ret = db.query(isDistinct, TABLE_NAME_USER, projectionIn, selection, selectionArgs, UserConstants.USERNAME, null, UserConstants.USERNAME+" COLLATE NOCASE ASC", null);
+			} catch (Exception e) {
+				ret = null;
+			}
+		}
+
+		else
+		{
+			try {
+				ret = qBuilder.query(db, projectionIn, selection, selectionArgs, null, null, orderBy);
+			} catch (Exception e) {
+				ret = null;
+			}
+		}
+
+		if (ret == null) {
+			infoLog("UserProvider.query: failed");
+		} else {
+			ret.setNotificationUri(getContext().getContentResolver(), url);
+		}
+
+		return ret;
+	}
+
+	@Override
+	public int update(Uri url, ContentValues values, String where,
+					  String[] whereArgs) {
+		int count;
+		long rowId = 0;
+		int match = URI_MATCHER.match(url);
+		SQLiteDatabase db = mOpenHelper.getWritableDatabase();
+
+		switch (match) {
+			case ALL_USERS:
+				count = db.update(TABLE_NAME_USER, values, where, whereArgs);
+				break;
+			case USER_ID:
+				String segment = url.getPathSegments().get(1);
+				rowId = Long.parseLong(segment);
+				count = db.update(TABLE_NAME_USER, values, UserConstants.USER_ID+"=" + rowId, null);
+
+				if (count > 0) {
+					Log.d(TAG, "User successfully updated "+rowId);
+				}
+
+				break;
+			case GROUPS:
+				count = db.update(TABLE_NAME_FRIEND_GROUP, values, where, whereArgs);
+
+				if (count > 0) {
+					Log.d(TAG, "Message successfully updated "+count);
+				}
+
+				break;
+			case GROUP_ID:
+				segment = url.getPathSegments().get(1);
+				rowId = Long.parseLong(segment);
+				count = db.update(TABLE_NAME_FRIEND_GROUP, values, "_id=" + rowId, null);
+				break;
+			case GROUP_MEMBERS:
+				count = db.update(TABLE_NAME_FRIEND_GROUP_MEMBER, values, where, whereArgs);
+
+				if (count > 0) {
+					Log.d(TAG, "Thread successfully updated "+count);
+				}
+
+				break;
+			case GROUP_MEMBER_ID:
+				segment = url.getPathSegments().get(1);
+				rowId = Long.parseLong(segment);
+				count = db.update(TABLE_NAME_FRIEND_GROUP_MEMBER, values, where, whereArgs);
+
+				break;
+
+			case NOTIFICATION:
+				count = db.update(TABLE_NAME_USER_NOTIFICATION, values, where, whereArgs);
+
+				if (count > 0) {
+					Log.d(TAG, "Message successfully updated "+count);
+				}
+
+				break;
+			default:
+				throw new UnsupportedOperationException("Cannot update URL: " + url);
+		}
+
+		infoLog("*** notifyChange() rowId: " + rowId + " url " + url);
+
+		getContext().getContentResolver().notifyChange(url, null);
+		return count;
+
+		//return 1;
+	}
+
+	private static void infoLog(String data) {
+
+	}
+
+	public static class UserDatabaseHelper extends SQLiteOpenHelper {
+
+		private static final String DATABASE_NAME = "user.db";
+		private static final int DATABASE_VERSION = 11;
+
+		public UserDatabaseHelper(Context context) {
+			super(context, DATABASE_NAME, null, DATABASE_VERSION);
+		}
+
+		@Override
+		public void onCreate(SQLiteDatabase db) {
+
+
+
+			String sql="CREATE TABLE IF NOT EXISTS "
+					+ UserProvider.TABLE_NAME_USER + " ( " + UserConstants._ID
+					+ " INTEGER PRIMARY KEY AUTOINCREMENT," + UserConstants.USER_ID
+					+ " TEXT NOT NULL," + UserConstants.CHAT_ID + " TEXT," + UserConstants.USERNAME
+					+ " TEXT," + UserConstants.GENDER + " TEXT," + UserConstants.PROFILE_IAMGE + " TEXT,"
+					+ UserConstants.ONLINE_STATUS + " TEXT  NOT NULL DEFAULT Offline,"
+					+ UserConstants.EMAIL + " TEXT," + UserConstants.EMAIL_VERIFICATION_STATUS + " TEXT,"
+					+ UserConstants.IN_APP_ALERT + " TEXT," + UserConstants.MY_STATUS + " TEXT, "
+					+ UserConstants.MOBILE_NO + " TEXT, " + UserConstants.CITY_OR_REGION + " TEXT, "
+					+ UserConstants.TEMP_USER_ID + " TEXT," + UserConstants.NEW_MESSAGE_ALERT + " TEXT, "
+					+ UserConstants.COVER_PHOTO_BYTE + " BLOB, " + UserConstants.JABBERD_RESOURCE
+					+ " TEXT, "
+					+ UserConstants.FIND_BY_PHONE_NO
+					+ " INTEGER NOT NULL DEFAULT 1,"
+					+ UserConstants.IS_ADDED_TO_ROSTER
+					+ " INTEGER NOT NULL DEFAULT 1,"
+					+ UserConstants.IS_VCARD_DOWNLOADED
+					+ " INTEGER NOT NULL DEFAULT 1,"
+					+ UserConstants.PROFILE_IMAGE_URL
+					+ " TEXT, "
+					+ UserConstants.USER_TYPE
+					+ " INTEGER NOT NULL DEFAULT 1, "
+					+ UserConstants.FIND_BY_SHAM_ID
+					+ " INTEGER NOT NULL DEFAULT 1);";
+
+			db.execSQL(sql);
+
+			String CREATE_TABLE_FRIEND_GROUP = "CREATE TABLE IF NOT EXISTS "
+					+ TABLE_NAME_FRIEND_GROUP + " (" + GroupConstants._ID
+					+ " INTEGER PRIMARY KEY AUTOINCREMENT,"+ FriendGroup.DB_ID
+					+ " TEXT ," + FriendGroup.DB_NAME + " TEXT , "
+					+ FriendGroup.CHAT_ROOM_NAME + " TEXT , "
+					+ FriendGroup.DID_JOIN_ROOM + " INTEGER NOT NULL DEFAULT 0 , "
+					+ FriendGroup.DID_LEAVE + " INTEGER NOT NULL DEFAULT 0 , "
+					+ FriendGroup.DB_RECORD_OWNER + " TEXT , "
+					+ FriendGroup.DB_DESCRIPTION + " TEXT , "
+					+ FriendGroup.DB_LINK_NAME + " TEXT  ,"
+					+ FriendGroup.CHANNEL_LOGO + " TEXT , "
+					+ FriendGroup.IS_MUTE + " INTEGER NOT NULL DEFAULT 0  "
+					+ ");";
+
+			//Log.d("CREATE_TABLE_FRIEND_GROUP" , CREATE_TABLE_FRIEND_GROUP) ;
+
+			db.execSQL(CREATE_TABLE_FRIEND_GROUP);
+
+			String CREATE_TABLE_FRIEND_GROUP_MEMBER = "CREATE TABLE IF NOT EXISTS "
+					+ TABLE_NAME_FRIEND_GROUP_MEMBER
+					+ " ("
+					+ GroupMemberConstants._ID
+					+ " INTEGER PRIMARY KEY AUTOINCREMENT,"
+					+ FriendGroupMember.DB_ID
+					+ " TEXT ,"
+					+ FriendGroupMember.DB_GROUP
+					+ " TEXT," + FriendGroupMember.DB_FRIEND + " TEXT , "
+					+ FriendGroupMember.DB_FRIEND_DID_JOIN + " INTEGER NOT NULL DEFAULT 0,"
+					+ FriendGroupMember.DB_FRIEND_IS_ADMIN + " INTEGER NOT NULL DEFAULT 0, "
+					+ FriendGroupMember.PHONE_NUMBER + " TEXT"
+					+");";
+
+			db.execSQL(CREATE_TABLE_FRIEND_GROUP_MEMBER);
+
+			String CREATE_TABLE_USER_NOTIFICATION = "CREATE TABLE "
+					+ TABLE_NAME_USER_NOTIFICATION
+					+ " ("+
+					NotificationConstants._ID
+					+ " INTEGER PRIMARY KEY AUTOINCREMENT,"
+					+ UserNotification.USER_ID
+					+ " TEXT NOT NULL  UNIQUE , "
+					+ UserNotification.MESSAGE_ALERT_STATUS
+					+ " INTEGER NOT NULL  DEFAULT 1, "
+					+ UserNotification.SOUND_ALERT_STATUS
+					+ " INTEGER NOT NULL  DEFAULT 1, "
+					+ UserNotification.VIBRATE_STATUS
+					+ " INTEGER NOT NULL  DEFAULT 0, "
+					+ UserNotification.NOTIFICATION_SOUND
+					+ " TEXT, "
+					+ UserNotification.NOTIFICATION_TIMING_START
+					+ " TEXT NOT NULL DEFAULT '0', "
+					+ UserNotification.NOTIFICATION_TIMING_END
+					+ " TEXT NOT NULL DEFAULT '0', "
+					+ UserNotification.OTHER_FEATURE_ALERT_STATUS
+					+ " INTEGER NOT NULL  DEFAULT 1, "
+					+ UserNotification.MOVEMENT_UPDATE_STATUS
+					+ " INTEGER NOT NULL  DEFAULT 1" + ")";
+
+			db.execSQL(CREATE_TABLE_USER_NOTIFICATION);
+
+		}
+
+		@Override
+		public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+			infoLog("onUpgrade: from " + oldVersion + " to " + newVersion);
+			switch (oldVersion) {
+				case 5:
+					db.execSQL("ALTER TABLE " + TABLE_NAME_FRIEND_GROUP_MEMBER + " ADD " + FriendGroupMember.DB_FRIEND_DID_JOIN + " INTEGER NOT NULL DEFAULT 0 ");
+					db.execSQL("ALTER TABLE " + TABLE_NAME_FRIEND_GROUP_MEMBER + " ADD " + FriendGroupMember.DB_FRIEND_IS_ADMIN + " INTEGER NOT NULL DEFAULT 0 ");
+					db.execSQL("ALTER TABLE " + TABLE_NAME_FRIEND_GROUP_MEMBER + " ADD " + FriendGroupMember.PHONE_NUMBER + " TEXT ");
+
+				case 6:
+					try {
+						db.execSQL("ALTER TABLE " + TABLE_NAME_FRIEND_GROUP_MEMBER + " ADD " + FriendGroupMember.PHONE_NUMBER + " TEXT ");
+					} catch (Exception e) {}
+
+				case 7:
+					try {
+						db.execSQL("ALTER TABLE " + TABLE_NAME_FRIEND_GROUP_MEMBER + " ADD " + FriendGroupMember.PHONE_NUMBER + " TEXT ");
+					} catch (Exception e) {
+
+					}
+
+				case 8:
+					try {
+						db.execSQL("ALTER TABLE " + TABLE_NAME_FRIEND_GROUP + " ADD " + FriendGroup.DB_DESCRIPTION + " TEXT ");
+						db.execSQL("ALTER TABLE " + TABLE_NAME_FRIEND_GROUP + " ADD " + FriendGroup.DB_LINK_NAME + " TEXT ");
+					} catch (Exception e) {
+
+					}
+
+				case 9:
+					try {
+						db.execSQL("ALTER TABLE " + TABLE_NAME_FRIEND_GROUP + " ADD " + FriendGroup.CHANNEL_LOGO + " TEXT ");
+					} catch (Exception e) {}
+
+				case 10 :
+					try {
+						db.execSQL("ALTER TABLE " + TABLE_NAME_FRIEND_GROUP + " ADD " + FriendGroup.IS_MUTE + " INTEGER NOT NULL DEFAULT 0 ");
+						//db.execSQL("ALTER TABLE " + TABLE_NAME_FRIEND_GROUP + " ADD " + "is_mute" + " INTEGER NOT NULL DEFAULT 0 ");
+					}
+					catch (Exception e) {}
+				break;
+
+//			case 6:
+//				db.execSQL("UPDATE " + TABLE_NAME + " SET READ=1");
+//			default:
+//				db.execSQL("DROP TABLE IF EXISTS " + TABLE_NAME);
+//				onCreate(db);
+			}
+
+
+		}
+
+		public ArrayList<Cursor> getData(String Query){
+			//get writable database
+			SQLiteDatabase sqlDB = this.getWritableDatabase();
+			String[] columns = new String[] { "mesage" };
+			//an array list of cursor to save two cursors one has results from the query
+			//other cursor stores error message if any errors are triggered
+			ArrayList<Cursor> alc = new ArrayList<Cursor>(2);
+			MatrixCursor Cursor2= new MatrixCursor(columns);
+			alc.add(null);
+			alc.add(null);
+
+
+			try{
+				String maxQuery = Query ;
+				//execute the query results will be save in Cursor c
+				Cursor c = sqlDB.rawQuery(maxQuery, null);
+
+
+				//add value to cursor2
+				Cursor2.addRow(new Object[] { "Success" });
+
+				alc.set(1,Cursor2);
+				if (null != c && c.getCount() > 0) {
+
+
+					alc.set(0,c);
+					c.moveToFirst();
+
+					return alc ;
+				}
+				return alc;
+			} catch(SQLException sqlEx){
+				Log.d("printing exception", sqlEx.getMessage());
+				//if any exceptions are triggered save the error message to cursor an return the arraylist
+				Cursor2.addRow(new Object[] { ""+sqlEx.getMessage() });
+				alc.set(1,Cursor2);
+				return alc;
+			} catch(Exception ex){
+
+				Log.d("printing exception", ex.getMessage());
+
+				//if any exceptions are triggered save the error message to cursor an return the arraylist
+				Cursor2.addRow(new Object[] { ""+ex.getMessage() });
+				alc.set(1,Cursor2);
+				return alc;
+			}
+
+
+		}
+	}
+
+	public static final class UserConstants implements BaseColumns {
+
+		private UserConstants() {
+		}
+
+		public static final String CONTENT_TYPE = "vnd.android.cursor.dir/vnd.zamin.user";
+		public static final String CONTENT_ITEM_TYPE = "vnd.android.cursor.item/vnd.zamin.user";
+		public static final String DEFAULT_SORT_ORDER = "_id ASC"; // sort by auto-id
+
+		public final static String USER_ID = "userId";
+		public final static String USERNAME = "name";
+		public final static String CHAT_ID = "chatId";
+		public final static String MOBILE_NO = "mobileNo";
+		public final static String EMAIL = "email";
+		public final static String PROFILE_IAMGE = "profileImageBytes";
+		public final static String TEMP_USER_ID = "tempUserId";
+		public final static String IN_APP_ALERT = "inAppAlert";
+		public final static String EMAIL_VERIFICATION_STATUS = "emailVerificationStatus";
+		public final static String NEW_MESSAGE_ALERT = "newMessageAlert";
+		public final static String ONLINE_STATUS = "onlineStatus";
+		public final static String MY_STATUS = "myStatus";
+		public final static String GENDER = "gender";
+		public final static String CITY_OR_REGION = "region";
+		public final static String COVER_PHOTO_BYTE = "cover_photo_byte";
+		public final static String JABBERD_RESOURCE = "jabberd_resource";
+		public final static String FIND_BY_PHONE_NO = "find_me_by_mobile_no";
+		public final static String FIND_BY_SHAM_ID = "find_me_by_chat_id";
+		public final static String PROFILE_IMAGE_URL = "profileimage_url";
+		public final static String USER_TYPE = "user_type";
+		public final static String IS_ADDED_TO_ROSTER = "is_added_to_roster";
+		public final static String IS_VCARD_DOWNLOADED = "is_vcard_downloaded";
+		//0 normal contact 1 in chat 2 in chat and contacts
+
+
+		public static ArrayList<String> getRequiredColumns() {
+			ArrayList<String> tmpList = new ArrayList<String>();
+			tmpList.add(USER_ID);
+			return tmpList;
+		}
+
+	}
+
+	public static final class GroupConstants implements BaseColumns {
+
+		private GroupConstants() {
+		}
+
+		public static final String CONTENT_GROUP_TYPE = "vnd.android.cursor.dir/vnd.zamin.groups";
+		public static final String CONTENT_GROUP_ITEM_TYPE = "vnd.android.cursor.item/vnd.zamin.groups";
+
+		public static final String DEFAULT_SORT_ORDER = "_id ASC"; // sort by auto-id
+
+		public static ArrayList<String> getRequiredColumns() {
+			ArrayList<String> tmpList = new ArrayList<String>();;
+			tmpList.add(FriendGroup.DB_RECORD_OWNER);
+			return tmpList;
+		}
+	}
+
+	public static final class GroupMemberConstants implements BaseColumns {
+
+		private GroupMemberConstants() {
+		}
+
+		public static final String CONTENT_GROUP_MEMBER_TYPE = "vnd.android.cursor.dir/vnd.zamin.groupmember";
+		public static final String CONTENT_GROUP_MEMBER_ITEM_TYPE = "vnd.android.cursor.item/vnd.zamin.groupmember";
+
+		public static final String DEFAULT_SORT_ORDER = "_id ASC"; // sort by auto-id
+
+		public static ArrayList<String> getRequiredColumns() {
+			ArrayList<String> tmpList = new ArrayList<String>();;
+			tmpList.add(FriendGroupMember.DB_GROUP);
+			return tmpList;
+		}
+	}
+
+	public static final class NotificationConstants implements BaseColumns {
+
+		private NotificationConstants() {
+		}
+
+		public static final String CONTENT_NOTIFICATION_TYPE = "vnd.android.cursor.dir/vnd.zamin.notification";
+
+		public static final String DEFAULT_SORT_ORDER = "_id ASC"; // sort by auto-id
+
+		public static ArrayList<String> getRequiredColumns() {
+			ArrayList<String> tmpList = new ArrayList<String>();;
+			tmpList.add(UserNotification.USER_ID);
+			return tmpList;
+		}
+	}
+
+	public Bitmap getProfileImageByUserId(String userId)
+	{
+		Bitmap bitmap=null;
+
+		Cursor cursor=SHAMChatApplication.getMyApplicationContext().getContentResolver().query(UserProvider.CONTENT_URI_USER, new String [] {UserConstants.PROFILE_IAMGE}, UserConstants.USER_ID+"=?", new String [] {userId}, null);
+
+		cursor.moveToFirst();
+
+		try {
+
+			File file = new File(
+					Environment.getExternalStorageDirectory()
+							+ PreferenceConstants.THUMBNAIL_DIRECTORY+"/"+userId+".jpg");
+
+			if(file.exists())
+			{
+				bitmap=BitmapFactory.decodeFile(file.getAbsolutePath());
+				//System.gc();
+			}
+
+		} catch (Exception e) {
+			System.out.println("getProfileImageByUserId "+e);;
+		} finally {
+			cursor.close();
+		}
+
+		return bitmap;
+
+	}
+
+	public Bitmap getMyProfileImage()
+	{
+		Cursor cursor=SHAMChatApplication.getMyApplicationContext().getContentResolver().query(UserProvider.CONTENT_URI_USER, new String [] {UserConstants.PROFILE_IAMGE}, UserConstants.USER_ID+"=?", new String [] {SHAMChatApplication.getConfig().getUserId()}, null);
+
+		cursor.moveToFirst();
+
+		Bitmap bitmap=null;
+
+		try {
+
+			bitmap = Utils.base64ToBitmap(cursor.getString(cursor.getColumnIndex(UserConstants.PROFILE_IAMGE)));
+
+			if(bitmap==null)
+			{
+				bitmap=getProfileImageByUserId(SHAMChatApplication.getConfig().getUserId());
+			}
+
+		} catch (Exception e) {
+			cursor.close();
+			return bitmap;
+		}
+
+		cursor.close();
+
+		return bitmap;
+
+	}
+
+	public static User userFromCursor(Cursor cursor) {
+		//cursor.moveToFirst();
+		User user = null;
+		if (cursor != null && cursor.getCount() > 0) {
+			user = new User();
+			user.setUserId(cursor.getString(cursor.getColumnIndex(UserConstants.USER_ID)));
+			user.setUsername(cursor.getString(cursor
+					.getColumnIndex(UserConstants.USERNAME)));
+			user.setChatId(cursor.getString(cursor.getColumnIndex(UserConstants.CHAT_ID)));
+			user.setMobileNo(cursor.getString(cursor
+					.getColumnIndex(UserConstants.MOBILE_NO)));
+			user.setEmail(cursor.getString(cursor.getColumnIndex(UserConstants.EMAIL)));
+			user.setGender(cursor.getString(cursor.getColumnIndex(UserConstants.GENDER)));
+			user.setEmailVerificationStatus(cursor.getString(cursor
+					.getColumnIndex(UserConstants.EMAIL_VERIFICATION_STATUS)));
+			user.setCityOrRegion(cursor.getString(cursor
+					.getColumnIndex(UserConstants.CITY_OR_REGION)));
+			user.setCoverPhoto(cursor.getString(cursor
+					.getColumnIndex(UserConstants.COVER_PHOTO_BYTE)));
+			user.setprofileImageUrl(cursor.getString(cursor
+					.getColumnIndex(UserConstants.PROFILE_IMAGE_URL)));
+
+			user.setDbRowId(String.valueOf(cursor.getInt(cursor.getColumnIndex(UserConstants._ID))));
+
+		}
+		return user;
+	}
+
+	public static List<User> usersFromCursor(Cursor cursor) {
+		List<User> list = new ArrayList<User>();
+
+		if (cursor != null && cursor.getCount() > 0) {
+			while (cursor.moveToNext()) {
+				User user = userFromCursor(cursor);
+				list.add(user);
+			}
+		}
+
+		return list;
+	}
+
+	public static ArrayList<User> usersFromCursorArray(Cursor cursor){
+
+		ArrayList<User> array    = new ArrayList<User>();
+
+		if (cursor != null && cursor.getCount() > 0) {
+			while (cursor.moveToNext()) {
+				User user = userFromCursor(cursor);
+				array.add(user);
+			}
+		}
+
+		return array;
+	}
+
+
+	public Cursor getUsersInGroup(String groupId, boolean negative) {
+
+		UserDatabaseHelper databaseHelper=new UserDatabaseHelper(SHAMChatApplication.getMyApplicationContext());
+		SQLiteDatabase database = databaseHelper.getWritableDatabase();
+
+		Cursor query=database.query(true, UserProvider.TABLE_NAME_USER, null, UserConstants.USER_ID + (negative ? " NOT " : " ") + "IN (SELECT "
+				+ FriendGroupMember.DB_FRIEND + " FROM "
+				+ TABLE_NAME_FRIEND_GROUP_MEMBER + " WHERE "
+				+ FriendGroupMember.DB_GROUP + "=?)", new String[] { groupId }, UserConstants.USERNAME, null, UserConstants.USERNAME + " ASC", null);
+
+		return query;
+	}
+
+
+	public static FriendGroup groupFromCursor(Cursor cursor) {
+		FriendGroup group = new FriendGroup();
+		cursor.moveToFirst();
+		group.setId(cursor.getString(cursor.getColumnIndex(FriendGroup.DB_ID)));
+		group.setName(cursor.getString(cursor
+				.getColumnIndex(FriendGroup.DB_NAME)));
+		group.setRecordOwnerId(cursor.getString(cursor
+				.getColumnIndex(FriendGroup.DB_RECORD_OWNER)));
+		group.setChatRoomName(cursor.getString(cursor
+				.getColumnIndex(FriendGroup.CHAT_ROOM_NAME)));
+		group.setDbRecordId(String.valueOf(cursor.getInt(cursor.getColumnIndex(GroupConstants._ID))));
+
+		cursor.close();
+
+		return group;
+	}
+
+	public void updateUser(User user) {
+
+		ContentValues values = new ContentValues();
+
+		values.put(UserConstants.USERNAME, user.getUsername());
+		values.put(UserConstants.CHAT_ID, user.getChatId());
+		values.put(UserConstants.MOBILE_NO, user.getMobileNo());
+		values.put(UserConstants.EMAIL, user.getEmail());
+		values.put(UserConstants.GENDER, user.getGender());
+		values.put(UserConstants.PROFILE_IAMGE, user.getProfileImage());
+		values.put(UserConstants.MY_STATUS, user.getMyStatus());
+		values.put(UserConstants.NEW_MESSAGE_ALERT, user.getNewMessageAlert());
+		values.put(UserConstants.IN_APP_ALERT, user.getInAppAlert());
+		values.put(UserConstants.EMAIL_VERIFICATION_STATUS,
+				user.getEmailVerificationStatus());
+		values.put(UserConstants.TEMP_USER_ID, user.getTmpUserId());
+		values.put(UserConstants.CITY_OR_REGION, user.getCityOrRegion());
+		values.put(UserConstants.JABBERD_RESOURCE, user.getJabberdResource());
+		values.put(UserConstants.PROFILE_IMAGE_URL, user.getprofileImageUrl());
+		if (user.getFindMeByPhoneNoStatus() != null
+				&& user.getFindMeByShamIdStatus() != null) {
+			values.put(UserConstants.FIND_BY_PHONE_NO, user.getFindMeByPhoneNoStatus()
+					.getStatus());
+			values.put(UserConstants.FIND_BY_SHAM_ID, user.getFindMeByShamIdStatus()
+					.getStatus());
+		}
+
+		SHAMChatApplication.getMyApplicationContext().getContentResolver().update(Uri.parse(CONTENT_URI_USER.toString()+"/"+user.getUserId()), values, null, null);
+
+	}
+
+	public User getCurrentUser() {
+
+		Cursor cursor=SHAMChatApplication.getMyApplicationContext().getContentResolver().query(Uri.parse(CONTENT_URI_USER.toString()+"/"+SHAMChatApplication.getConfig().getUserId()), null, null, null,null);
+		cursor.moveToFirst();
+
+		User user = null;
+		if (cursor != null && cursor.getCount() > 0) {
+			user = new User();
+			user.setUserId(cursor.getString(cursor.getColumnIndex(UserConstants.USER_ID)));
+			user.setUsername(cursor.getString(cursor
+					.getColumnIndex(UserConstants.USERNAME)));
+			user.setChatId(cursor.getString(cursor.getColumnIndex(UserConstants.CHAT_ID)));
+			user.setMobileNo(cursor.getString(cursor
+					.getColumnIndex(UserConstants.MOBILE_NO)));
+			user.setEmail(cursor.getString(cursor.getColumnIndex(UserConstants.EMAIL)));
+			user.setGender(cursor.getString(cursor.getColumnIndex(UserConstants.GENDER)));
+			user.setProfileImage(cursor.getString(cursor
+					.getColumnIndex(UserConstants.PROFILE_IAMGE)));
+			user.setMyStatus(cursor.getString(cursor
+					.getColumnIndex(UserConstants.MY_STATUS)));
+			user.setNewMessageAlert(cursor.getString(cursor
+					.getColumnIndex(UserConstants.NEW_MESSAGE_ALERT)));
+			user.setInAppAlert(cursor.getString(cursor
+					.getColumnIndex(UserConstants.IN_APP_ALERT)));
+			user.setEmailVerificationStatus(cursor.getString(cursor
+					.getColumnIndex(UserConstants.EMAIL_VERIFICATION_STATUS)));
+			user.setTmpUserId(cursor.getString(cursor
+					.getColumnIndex(UserConstants.TEMP_USER_ID)));
+			user.setCityOrRegion(cursor.getString(cursor
+					.getColumnIndex(UserConstants.CITY_OR_REGION)));
+			user.setCoverPhoto(cursor.getString(cursor
+					.getColumnIndex(UserConstants.COVER_PHOTO_BYTE)));
+			user.setJabberdResource(cursor.getString(cursor
+					.getColumnIndex(UserConstants.JABBERD_RESOURCE)));
+			user.setprofileImageUrl(cursor.getString(cursor
+					.getColumnIndex(UserConstants.PROFILE_IMAGE_URL)));
+
+			BooleanStatus bool = BooleanStatus.FALSE;
+			switch (cursor.getInt(cursor.getColumnIndex(UserConstants.FIND_BY_PHONE_NO))) {
+				case 0:
+					bool = BooleanStatus.FALSE;
+					break;
+				case 1:
+					bool = BooleanStatus.TRUE;
+					break;
+			}
+
+			user.setFindMeByPhoneNoStatus(bool);
+
+			BooleanStatus bool2 = BooleanStatus.FALSE;
+			switch (cursor.getInt(cursor.getColumnIndex(UserConstants.FIND_BY_SHAM_ID))) {
+				case 0:
+					bool2 = BooleanStatus.FALSE;
+					break;
+				case 1:
+					bool2 = BooleanStatus.TRUE;
+					break;
+			}
+
+			user.setFindMeByShamIdStatus(bool2);
+
+		}
+		return user;
+	}
+
+	*/
+/**
+	 * getCurrentUserForMyProfile gets the user object of the current user, just a db call
+	 * @return
+	 *//*
+
+	public User getCurrentUserForMyProfile() {
+
+		Cursor cursor=SHAMChatApplication.getMyApplicationContext().getContentResolver().query(Uri.parse(CONTENT_URI_USER.toString()+"/"+SHAMChatApplication.getConfig().getUserId()), null, null, null,null);
+		cursor.moveToFirst();
+
+		User user = null;
+		if (cursor != null && cursor.getCount() > 0) {
+			user = new User();
+			user.setUserId(cursor.getString(cursor.getColumnIndex(UserConstants.USER_ID)));
+			user.setUsername(cursor.getString(cursor
+					.getColumnIndex(UserConstants.USERNAME)));
+			user.setChatId(cursor.getString(cursor.getColumnIndex(UserConstants.CHAT_ID)));
+			user.setMobileNo(cursor.getString(cursor
+					.getColumnIndex(UserConstants.MOBILE_NO)));
+			user.setGender(cursor.getString(cursor.getColumnIndex(UserConstants.GENDER)));
+			user.setProfileImage(cursor.getString(cursor
+					.getColumnIndex(UserConstants.PROFILE_IAMGE)));
+			user.setMyStatus(cursor.getString(cursor
+					.getColumnIndex(UserConstants.MY_STATUS)));
+			user.setCityOrRegion(cursor.getString(cursor
+					.getColumnIndex(UserConstants.CITY_OR_REGION)));
+			user.setprofileImageUrl(cursor.getString(cursor
+					.getColumnIndex(UserConstants.PROFILE_IMAGE_URL)));
+
+		}
+
+		cursor.close();
+		return user;
+	}
+
+	public static enum UserNotificationUpdateType {
+		NOTIFICATION_SOUND, NOTIFICATION_TIMING_START, NOTIFICATION_TIMING_END, MESSAGE_ALERT_STATUS, MOVEMENT_UPDATE_STATUS, OTHER_FEATURE_ALERT_STATUS, SOUND_ALERT_STATUS, VIBRATE_STATUS
+	}
+
+	public void updateNotification(String userId,
+								   UserNotificationUpdateType updateType, Object value) {
+
+		ContentValues values = new ContentValues();
+		switch (updateType) {
+			case NOTIFICATION_SOUND:
+				values.put(UserNotification.NOTIFICATION_SOUND, (String) value);
+				break;
+			case NOTIFICATION_TIMING_START:
+				values.put(UserNotification.NOTIFICATION_TIMING_START,
+						(String) value);
+				break;
+			case NOTIFICATION_TIMING_END:
+				values.put(UserNotification.NOTIFICATION_TIMING_END, (String) value);
+				break;
+			case MESSAGE_ALERT_STATUS:
+				values.put(UserNotification.MESSAGE_ALERT_STATUS,
+						((AllowDeniedStatus) value).getStatus());
+				break;
+			case MOVEMENT_UPDATE_STATUS:
+				values.put(UserNotification.MOVEMENT_UPDATE_STATUS,
+						((EnableDisableStatus) value).getStatus());
+				break;
+			case OTHER_FEATURE_ALERT_STATUS:
+				values.put(UserNotification.OTHER_FEATURE_ALERT_STATUS,
+						((FeatureAlertStatus) value).getStatus());
+				break;
+			case SOUND_ALERT_STATUS:
+				values.put(UserNotification.SOUND_ALERT_STATUS,
+						((EnableDisableStatus) value).getStatus());
+				break;
+			case VIBRATE_STATUS:
+				values.put(UserNotification.VIBRATE_STATUS,
+						((EnableDisableStatus) value).getStatus());
+				break;
+		}
+
+		SHAMChatApplication.getMyApplicationContext().getContentResolver().update(CONTENT_URI_NOTIFICATION, values, UserNotification.USER_ID+"=?", new String [] {userId});
+	}
+
+	public static UserNotification userNotificationFromCursor(Cursor cursor) {
+		UserNotification userNotification = new UserNotification();
+
+		try {
+
+			userNotification.setUserNotificationId(cursor.getInt(cursor.getColumnIndex(NotificationConstants._ID)));
+			userNotification.setUserId(cursor.getString(cursor.getColumnIndex(UserNotification.USER_ID)));
+			userNotification
+					.setMessageAlertStatus((cursor.getInt(cursor.getColumnIndex(UserNotification.MESSAGE_ALERT_STATUS)) == 1 ? AllowDeniedStatus.ALLOW
+							: AllowDeniedStatus.DENIED));
+			userNotification
+					.setSoundAlertStatus((cursor.getInt(cursor.getColumnIndex(UserNotification.SOUND_ALERT_STATUS)) == 1 ? EnableDisableStatus.ENABLE
+							: EnableDisableStatus.DISABLE));
+			userNotification
+					.setVibrateStatus(cursor.getInt(cursor.getColumnIndex(UserNotification.VIBRATE_STATUS)) == 1 ? EnableDisableStatus.ENABLE
+							: EnableDisableStatus.DISABLE);
+			userNotification.setNotificationSound(cursor.getString(cursor.getColumnIndex(UserNotification.NOTIFICATION_SOUND)));
+			userNotification.setNotificationTimingStart(cursor.getString(cursor.getColumnIndex(UserNotification.NOTIFICATION_TIMING_START)));
+			userNotification.setNotificationTimingEnd(cursor.getString(cursor.getColumnIndex(UserNotification.NOTIFICATION_TIMING_END)));
+			FeatureAlertStatus fStatus = FeatureAlertStatus.DISABLE;
+
+			switch (cursor.getInt(8)) {
+				case 1:
+					fStatus = FeatureAlertStatus.ENABLE;
+					break;
+				case 2:
+					fStatus = FeatureAlertStatus.NIGHT_MODE;
+					break;
+				default:
+					fStatus = FeatureAlertStatus.DISABLE;
+			}
+			userNotification.setOtherFeatureAlertStatus(fStatus);
+			userNotification
+					.setMovementUpdateStatus(cursor.getInt(cursor.getColumnIndex(UserNotification.MOVEMENT_UPDATE_STATUS)) == 1 ? EnableDisableStatus.ENABLE
+							: EnableDisableStatus.DISABLE);
+
+		} catch (Exception e) {
+
+			if(SHAMChatApplication.getConfig().getUserId()!=null)
+			{
+				ContentValues vals = new ContentValues();
+				vals.put(UserNotification.USER_ID, SHAMChatApplication.getConfig().getUserId());
+				SHAMChatApplication.getInstance().getContentResolver()
+						.insert(UserProvider.CONTENT_URI_NOTIFICATION,
+								vals);
+			}
+
+			userNotificationFromCursor(cursor);
+
+		}
+
+		return userNotification;
+	}
+
+	public Cursor getGroupMemberCursor(String groupId) {
+
+		UserDatabaseHelper databaseHelper=new UserDatabaseHelper(SHAMChatApplication.getMyApplicationContext());
+		SQLiteDatabase database = databaseHelper.getWritableDatabase();
+
+		Cursor cursor=database.query(true, TABLE_NAME_FRIEND_GROUP_MEMBER, null, FriendGroupMember.DB_GROUP+"=?", new String [] {groupId}, FriendGroupMember.DB_FRIEND, null, FriendGroupMember.DB_FRIEND, null);
+
+		return cursor;
+	}
+
+	public User getUserDetailsFromServer(String userId)
+	{
+		User user =null;
+
+		try {
+
+			BasicHttpParams params = new BasicHttpParams();
+
+			SchemeRegistry schemeRegistry = new SchemeRegistry();
+			schemeRegistry.register(new Scheme("http", PlainSocketFactory
+					.getSocketFactory(), 80));
+			final SSLSocketFactory sslSocketFactory = SSLSocketFactory
+					.getSocketFactory();
+			schemeRegistry.register(new Scheme("https", sslSocketFactory, 443));
+			ClientConnectionManager cm = new ThreadSafeClientConnManager(params,
+					schemeRegistry);
+
+			DefaultHttpClient httpclient = new DefaultHttpClient(cm, params);
+
+			Context context = SHAMChatApplication
+					.getMyApplicationContext();
+
+			HttpPost httpPost = new HttpPost(context
+					.getApplicationContext().getResources()
+					.getString(R.string.homeBaseURL)
+					+ "getMyDetails.htm");
+
+			List<NameValuePair> data = new ArrayList<NameValuePair>();
+
+			data.add(new BasicNameValuePair("userId", userId));
+
+			httpPost.setEntity(new UrlEncodedFormEntity(data));
+
+			HttpResponse httpResponse = httpclient.execute(httpPost);
+
+			InputStream inputStream = httpResponse.getEntity().getContent();
+
+			BufferedReader bufferreader = new BufferedReader(new InputStreamReader(inputStream));
+
+			StringBuilder responseStr = new StringBuilder();
+			String responseLineStr = null;
+
+			while ((responseLineStr = bufferreader.readLine()) != null) {
+				responseStr.append(responseLineStr);
+
+			}
+
+			bufferreader.close();
+			inputStream.close();
+
+			String result = responseStr.toString().trim();
+
+
+			if (result != null) {
+
+				JSONObject serverResponse = new JSONObject(result);
+				String status = serverResponse.getString("status");
+
+				if(status.equalsIgnoreCase("success"))
+				{
+					JSONObject userJsonObject = serverResponse.getJSONObject("data");
+
+					user = new User(userJsonObject);
+
+					ContentValues values = new ContentValues();
+					values.put(UserConstants.USERNAME, user.getUsername());
+					values.put(UserConstants.CHAT_ID, user.getChatId());
+					values.put(UserConstants.USER_ID, user.getUserId());
+					values.put(UserConstants.MOBILE_NO, user.getMobileNo());
+					values.put(UserConstants.EMAIL, user.getEmail());
+					values.put(UserConstants.GENDER, user.getGender());
+					values.put(UserConstants.PROFILE_IAMGE, Utils.decodeImage(user.getProfileImage()));
+					values.put(UserConstants.MY_STATUS, user.getMyStatus());
+					values.put(UserConstants.CITY_OR_REGION, user.getCityOrRegion());
+					values.put(UserConstants.PROFILE_IMAGE_URL, user.getprofileImageUrl());
+
+					if(context.getContentResolver().update(UserProvider.CONTENT_URI_USER, values, UserConstants.USER_ID+"=?", new String [] {user.getUserId()})==0)
+					{
+						context.getContentResolver().insert(UserProvider.CONTENT_URI_USER, values);
+					}
+				}
+			}
+
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+
+		return user;
+	}
+
+
+}
+*/
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/Utils.java b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/Utils.java
new file mode 100644
index 000000000..aaa4475f6
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/shamChat/Utils.java
@@ -0,0 +1,1881 @@
+package org.telegram.messenger.shamChat;
+
+import android.annotation.TargetApi;
+import android.content.ContentUris;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.database.Cursor;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.BitmapFactory;
+import android.graphics.Color;
+import android.graphics.Matrix;
+import android.graphics.drawable.Drawable;
+import android.media.ExifInterface;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Environment;
+import android.provider.ContactsContract.PhoneLookup;
+import android.provider.DocumentsContract;
+import android.provider.MediaStore;
+import android.support.v4.content.CursorLoader;
+import android.text.TextUtils;
+import android.util.Base64;
+import android.util.Log;
+import android.view.inputmethod.InputMethodManager;
+import android.webkit.MimeTypeMap;
+import android.widget.EditText;
+import android.widget.Toast;
+
+import com.google.android.gms.common.ConnectionResult;
+import com.google.android.gms.common.GooglePlayServicesUtil;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.BufferedInputStream;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.net.URLConnection;
+import java.text.DecimalFormat;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Random;
+import java.util.TimeZone;
+import java.util.concurrent.TimeUnit;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+@TargetApi(Build.VERSION_CODES.GINGERBREAD)
+public class Utils {
+/*
+	public static void CopyStream(InputStream is, OutputStream os)
+	{
+		final int buffer_size=1024;
+		try
+		{
+
+			byte[] bytes=new byte[buffer_size];
+			for(;;)
+			{
+				//Read byte from input stream
+
+				int count=is.read(bytes, 0, buffer_size);
+				if(count==-1)
+					break;
+
+				//Write byte from output stream
+				os.write(bytes, 0, count);
+			}
+		}
+		catch(Exception ex){}
+	}
+
+	public Utils() {
+
+	}
+
+	public static boolean isInternetAvailable(Context context) {
+		ConnectivityManager connectivityManager = (ConnectivityManager) context
+				.getSystemService(Context.CONNECTIVITY_SERVICE);
+		NetworkInfo activeNetInfo = connectivityManager.getActiveNetworkInfo();
+		boolean status = false;
+
+		if (activeNetInfo != null) {
+			status = true;
+		}
+
+		return status;
+	}
+
+	public static boolean isWifiConnected() {
+		ConnectivityManager connManager = (ConnectivityManager) SHAMChatApplication
+				.getMyApplicationContext().getSystemService(
+						Context.CONNECTIVITY_SERVICE);
+		NetworkInfo mWifi = connManager
+				.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
+
+		if (mWifi.isConnected()) {
+			return true;
+		} else {
+			return false;
+		}
+	}
+	
+	public static boolean isGPRSWIFIConnected(Context context){
+	    ConnectivityManager connectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+	    NetworkInfo wifiInfo = connectivityManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
+	    NetworkInfo mobileInfo = connectivityManager.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
+
+	    if ((wifiInfo != null && wifiInfo.isConnected()) || (mobileInfo != null && mobileInfo.isConnected())) {
+	            return true;
+	    }else{
+	            return false;
+	    }
+	}	
+	
+
+	public static String convertToEnglishDigits(String value) {
+		String newValue = value.replace("١", "1").replace("١", "1")
+				.replace("٢", "2").replace("٤", "4").replace("٥", "5")
+				.replace("٦", "6").replace("٧", "7").replace("٨", "8")
+				.replace("٩", "9").replace("٠", "0").replace("٣", "3")
+				.replace("۱", "1").replace("۲", "2").replace("۳", "3")
+				.replace("۴", "4").replace("۵", "5").replace("۶", "6")
+				.replace("۷", "7").replace("۸", "8").replace("۹", "9")
+				.replace("۰", "0");
+
+		return newValue;
+	}
+
+	public static Bitmap scaleDownImageSize(Bitmap bm, int width, int height,
+			int orientation) {
+		Bitmap photo = bm;
+		photo = Bitmap.createScaledBitmap(photo, width, height, false);
+		photo = rotateImage(photo, orientation);
+		ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+		photo.compress(CompressFormat.JPEG, 100, bytes);
+
+		File f = new File(Environment.getExternalStorageDirectory()
+				+ "/salam/profileimage" + File.separator
+				+ "Imagename.jpg");
+		FileOutputStream fo;
+		try {
+			f.createNewFile();
+			fo = new FileOutputStream(f);
+			fo.write(bytes.toByteArray());
+			fo.close();
+		} catch (FileNotFoundException e) {
+			e.printStackTrace();
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+
+		return photo;
+	}
+
+	public static Bitmap rotateImage(Bitmap b, int degrees) {
+		if (degrees != 0 && b != null) {
+			Matrix m = new Matrix();
+
+			m.setRotate(degrees, (float) b.getWidth() / 2,
+					(float) b.getHeight() / 2);
+			try {
+				Bitmap b2 = Bitmap.createBitmap(b, 0, 0, b.getWidth(),
+						b.getHeight(), m, true);
+				if (b != b2) {
+					b.recycle();
+					b = b2;
+				}
+			} catch (OutOfMemoryError ex) {
+				throw ex;
+			}
+		}
+		return b;
+	}
+
+	public static int getExifRotation(String imgPath) {
+		try {
+			ExifInterface exif = new ExifInterface(imgPath);
+			String rotationAmount = exif
+					.getAttribute(ExifInterface.TAG_ORIENTATION);
+			if (!TextUtils.isEmpty(rotationAmount)) {
+				int rotationParam = Integer.parseInt(rotationAmount);
+				switch (rotationParam) {
+				case ExifInterface.ORIENTATION_NORMAL:
+					return 0;
+				case ExifInterface.ORIENTATION_ROTATE_90:
+					return 90;
+				case ExifInterface.ORIENTATION_ROTATE_180:
+					return 180;
+				case ExifInterface.ORIENTATION_ROTATE_270:
+					return 270;
+				default:
+					return 0;
+				}
+			} else {
+				return 0;
+			}
+		} catch (Exception ex) {
+			return 0;
+		}
+	}
+
+	public static boolean existCameraApp(PackageManager manager) {
+		Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
+		return takePictureIntent.resolveActivity(manager) != null;
+	}
+
+	public static boolean isCameraAvailable(PackageManager manager) {
+		return manager.hasSystemFeature(PackageManager.FEATURE_CAMERA);
+	}
+
+	public static File createImageFile(Context context) throws IOException {
+		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyyMMdd_HHmmss", Locale.US);
+        dateFormat.setTimeZone(TimeZone.getDefault());
+        String timeStamp = dateFormat.format(new Date());
+
+		//String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
+
+		String imageFileName = "JPEG_" + timeStamp + "_";
+
+		File storageDir = context
+				.getExternalFilesDir(Environment.DIRECTORY_PICTURES);
+		File image = File.createTempFile(imageFileName, ".jpg", storageDir);
+		return image;
+	}
+
+	public static Bitmap scaleDownImageSizeProfile(Bitmap bm, int width,
+			int height, int quality) {
+		Bitmap photo = bm;
+		// trycatch
+		try {
+			photo = Bitmap.createScaledBitmap(photo, width, height, false);
+			ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+			photo.compress(CompressFormat.JPEG, quality, bytes);
+		} catch (Exception e) {
+			;
+		}
+
+		return photo;
+	}
+
+	public static String encodeImage(Bitmap bitmap) {
+		// trycatch
+		try {
+			ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+			bitmap.compress(CompressFormat.PNG, 80, byteArrayOutputStream);
+			return encodeImage(byteArrayOutputStream.toByteArray());
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+		return null;
+
+	}
+
+	private static String encodeImage(byte[] data) {
+		return Base64.encodeToString(data, Base64.DEFAULT);
+	}
+
+
+	public static boolean isValidEmail(EditText email) {
+		boolean status = false;
+		if (email != null) {
+			String expression = "^[\\w\\.-]+@([\\w\\-]+\\.)+[A-Z]{2,4}$";
+			CharSequence inputString = email.getText();
+			Pattern pattern = Pattern.compile(expression,
+					Pattern.CASE_INSENSITIVE);
+			Matcher matcher = pattern.matcher(inputString);
+			status = matcher.matches();
+			if (!status) {
+				email.setHint("Invalid Email");
+				email.setHintTextColor(Color.RED);
+			}
+		}
+		return status;
+	}
+
+	public static void showKeyboard(EditText editText, Context context) {
+		InputMethodManager imm = (InputMethodManager) context
+				.getSystemService(Context.INPUT_METHOD_SERVICE);
+		imm.showSoftInput(editText, InputMethodManager.SHOW_IMPLICIT);
+	}
+
+	public static String readableFileSize(long size) {
+		if (size <= 0)
+			return "0";
+		final String[] units = new String[] { "B", "KB", "MB", "GB", "TB" };
+		int digitGroups = (int) (Math.log10(size) / Math.log10(1024));
+		return new DecimalFormat("#,##0.#").format(size
+				/ Math.pow(1024, digitGroups))
+				+ " " + units[digitGroups];
+	}
+
+
+	public static Bitmap fixOrientation(Bitmap mBitmap) {
+		if (mBitmap.getWidth() > mBitmap.getHeight()) {
+			Matrix matrix = new Matrix();
+			matrix.postRotate(90);
+			mBitmap = Bitmap.createBitmap(mBitmap, 0, 0, mBitmap.getWidth(),
+					mBitmap.getHeight(), matrix, true);
+		}
+		return mBitmap;
+	}
+
+
+	public static String createXmppUserIdByUserId(String userId) {
+		if (userId != null && !userId.contains("@")) {
+			userId = userId + "@" + PreferenceConstants.XMPP_SERVER;
+		}
+		return userId;
+	}
+
+
+
+	public static String getUserIdFromXmppUserId(String xmppUserId) {
+
+		try {
+			xmppUserId = xmppUserId.substring(0, xmppUserId.indexOf("@"));
+
+		} catch (Exception e) {
+			xmppUserId = null;
+		}
+
+		return xmppUserId;
+	}
+
+	public static Bitmap base64ToBitmap(String base64) {
+		ByteArrayInputStream bais = null;
+		Bitmap image = null;
+		if (base64 != null) {
+			bais = new ByteArrayInputStream(decodeImage(base64));
+			image = BitmapFactory.decodeStream(bais);
+		}
+
+		return image;
+	}
+
+	public static byte[] decodeImage(String base64) {
+		return Base64.decode(base64, Base64.DEFAULT);
+	}
+
+	public byte[] downloadImageFromUrl(String profileUrl) {
+		File downloadedFile = null;
+		int count = 0;
+		File noMedia = null;
+		byte[] blobMessage = null;
+		try {
+			if (profileUrl == null || profileUrl.equalsIgnoreCase("exception"))
+				return null;
+
+			String strUrl = profileUrl;
+			URL url = new URL(strUrl);
+
+			File folder = new File(Environment.getExternalStorageDirectory()
+					+ "/salam/profileimage");
+			if (!folder.exists()) {
+				folder.mkdirs();
+				noMedia = new File(folder.getAbsolutePath() + "/" + ".nomedia");
+			}
+			downloadedFile = new File(folder.getAbsolutePath() + "/"
+					+ strUrl.substring(strUrl.lastIndexOf("/") + 1));
+
+			if (!downloadedFile.exists()) {
+				URLConnection conection = url.openConnection();
+				conection.connect();
+				// getting file length
+				// with 8k buffer
+				InputStream input = new BufferedInputStream(url.openStream(),
+						8192);
+
+				// Output stream to write file
+				OutputStream output = new FileOutputStream(downloadedFile);
+
+				byte data[] = new byte[1024];
+
+				while ((count = input.read(data)) != -1) {
+					// writing data to file
+					output.write(data, 0, count);
+				}
+
+				// flushing output
+				output.flush();
+
+				// closing streams
+				output.close();
+				input.close();
+			} else {
+				// file has been already
+				// downloaded
+				System.out.println("This file has been already downloaded "
+						+ downloadedFile.getName());
+			}
+			blobMessage = getBytesFromFilePath(downloadedFile);
+
+		} catch (Exception ex) {
+			ex.printStackTrace();
+		}
+
+		return blobMessage;
+	}
+
+	public byte[] getBytesFromFilePath(File filePath) {
+		FileInputStream fileInputStream = null;
+		byte[] bFile = new byte[(int) filePath.length()];
+
+		try {
+			System.out.println("Converting to byte[]");
+
+			// convert file into array of bytes
+			fileInputStream = new FileInputStream(filePath);
+			fileInputStream.read(bFile);
+			fileInputStream.close();
+
+			System.out.println("Done");
+		} catch (Exception e) {
+			System.out.println("error converting to byte[] " + e.getMessage());
+		}
+		return bFile;
+	}
+
+	public Bitmap scaleDownImageSize(Bitmap bm, int width, int height) {
+		Bitmap photo = bm;
+		photo = Bitmap.createScaledBitmap(photo, width, height, false);
+		ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+		photo.compress(CompressFormat.JPEG, 100, bytes);
+
+		File f = new File(Environment.getExternalStorageDirectory()
+				+ "/salam/profileimage" + File.separator
+				+ "Imagename.jpg");
+		FileOutputStream fo;
+		try {
+			f.createNewFile();
+			fo = new FileOutputStream(f);
+			fo.write(bytes.toByteArray());
+			fo.close();
+		} catch (FileNotFoundException e) {
+			e.printStackTrace();
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+
+		return photo;
+	}
+
+	public static boolean isEditTextEmpty(EditText etText) {
+		if (etText.getText().toString().trim().length() > 0) {
+			return false;
+		} else {
+			return true;
+		}
+	}
+
+	public static void hideKeyboard(EditText editText, Context context) {
+		InputMethodManager imm = (InputMethodManager) context
+				.getSystemService(Context.INPUT_METHOD_SERVICE);
+		imm.hideSoftInputFromWindow(editText.getWindowToken(), 0);
+	}
+
+	public static ContactDetails getConactExists(Context context, String number) {
+		// / number is the phone number
+		ContactDetails details = new ContactDetails();
+		details.isExist = false;
+		details.displayName = "";
+
+		Uri lookupUri = Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,
+				Uri.encode(number));
+		String[] mPhoneNumberProjection = { PhoneLookup._ID,
+				PhoneLookup.NUMBER, PhoneLookup.DISPLAY_NAME };
+		Cursor cur = context.getContentResolver().query(lookupUri,
+				mPhoneNumberProjection, null, null, null);
+		try {
+			if (cur.moveToFirst()) {
+				details.isExist = true;
+				details.displayName = cur.getString(cur
+						.getColumnIndex(PhoneLookup.DISPLAY_NAME));
+			}
+		} finally {
+			if (cur != null) {
+				cur.close();
+			}
+		}
+		return details;
+	}
+
+	public static class ContactDetails {
+		public boolean isExist;
+		public String displayName;
+
+		public ContactDetails() {
+
+		}
+
+		public ContactDetails(boolean isExist, String displayName) {
+			this.isExist = isExist;
+			this.displayName = displayName;
+		}
+	}
+
+	public static Bitmap decodeSampledBitmapFromResource(String path,
+			int reqWidth, int reqHeight) {
+
+		// First decode with inJustDecodeBounds=true to check dimensions
+		final BitmapFactory.Options options = new BitmapFactory.Options();
+		options.inJustDecodeBounds = true;
+		BitmapFactory.decodeFile(path, options);
+
+		// Calculate inSampleSize
+		options.inSampleSize = calculateInSampleSize(options, reqWidth,
+				reqHeight);
+
+		// Decode bitmap with inSampleSize set
+		options.inJustDecodeBounds = false;
+		return BitmapFactory.decodeFile(path, options);
+	}
+
+	public static boolean contactExists(Context context, String number) {
+		// / number is the phone number
+		Uri lookupUri = Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,
+				Uri.encode(number));
+		String[] mPhoneNumberProjection = { PhoneLookup._ID,
+				PhoneLookup.NUMBER, PhoneLookup.DISPLAY_NAME };
+		Cursor cur = context.getContentResolver().query(lookupUri,
+				mPhoneNumberProjection, null, null, null);
+		try {
+			if (cur.moveToFirst()) {
+				return true;
+			}
+		} finally {
+			if (cur != null)
+				cur.close();
+		}
+		return false;
+	}
+
+	public static int calculateInSampleSize(BitmapFactory.Options options,
+			int reqWidth, int reqHeight) {
+		// Raw height and width of image
+		final int height = options.outHeight;
+		final int width = options.outWidth;
+		int inSampleSize = 1;
+
+		if (height > reqHeight || width > reqWidth) {
+
+			final int halfHeight = height / 2;
+			final int halfWidth = width / 2;
+
+			// Calculate the largest inSampleSize value that is a power of 2 and
+			// keeps both
+			// height and width larger than the requested height and width.
+			while ((halfHeight / inSampleSize) > reqHeight
+					&& (halfWidth / inSampleSize) > reqWidth) {
+				inSampleSize *= 2;
+			}
+		}
+
+		return inSampleSize;
+	}
+
+	public static boolean checkPlayServices(Context context) {
+		int status = GooglePlayServicesUtil
+				.isGooglePlayServicesAvailable(context);
+		if (status != ConnectionResult.SUCCESS) {
+			if (GooglePlayServicesUtil.isUserRecoverableError(status)) {
+				Toast.makeText(context, R.string.googleplay_not_found,
+						Toast.LENGTH_SHORT).show();
+				try {
+					ProgressBarLoadingDialog.getInstance().dismiss();
+				} catch (Exception e) {
+					e.printStackTrace();
+				}
+
+			} else {
+				Toast.makeText(context, R.string.device_not_supported,
+						Toast.LENGTH_LONG).show();
+				try {
+					ProgressBarLoadingDialog.getInstance().dismiss();
+				} catch (Exception e) {
+					e.printStackTrace();
+				}
+			}
+			return false;
+		}
+		return true;
+	}
+
+	public static Map<String, Long> getDurationBreakdownArray(long millis) {
+		String[] units = { "Days", "Hours", "Minutes", "Seconds" };
+		Long[] values = new Long[units.length];
+		Map<String, Long> jo = new HashMap<String, Long>();
+		boolean startPrinting = false;
+		if (millis <= 0) {
+			for (int i = 0; i < units.length; i++) {
+
+				try {
+					jo.put(units[i], 0L);
+				} catch (Exception e) {
+					e.printStackTrace();
+				}
+
+			}
+		} else {
+
+			values[0] = TimeUnit.MILLISECONDS.toDays(millis);
+			millis -= TimeUnit.DAYS.toMillis(values[0]);
+			values[1] = TimeUnit.MILLISECONDS.toHours(millis);
+			millis -= TimeUnit.HOURS.toMillis(values[1]);
+			values[2] = TimeUnit.MILLISECONDS.toMinutes(millis);
+			millis -= TimeUnit.MINUTES.toMillis(values[2]);
+			values[3] = TimeUnit.MILLISECONDS.toSeconds(millis);
+
+			for (int i = 0; i < units.length; i++) {
+				if (!startPrinting && values[i] != 0)
+					startPrinting = true;
+				if (startPrinting) {
+					try {
+						jo.put(units[i], values[i]);
+					} catch (Exception e) {
+						e.printStackTrace();
+					}
+				}
+			}
+		}
+
+		return jo;
+	}
+
+	public static String createXmppRoomIDByUserId(String room) {
+		if (room != null && !room.contains("@")) {
+			room = room + "@" + PreferenceConstants.CONFERENCE_SERVICE;
+		}
+		return room;
+	}
+
+	public static File createFileFromBase64(Context context,String base64ImageData) {
+		FileOutputStream fos = null;
+		File file = null;
+		try {
+
+			if (base64ImageData != null) {
+				file = new File(Environment.getExternalStorageDirectory()+ File.separator + "temp_asasjakska32jaac.png");
+				if (!file.exists()) {
+					file.createNewFile();
+				}
+				fos = new FileOutputStream(file);
+				byte[] decodedString = Base64.decode(
+						base64ImageData, Base64.DEFAULT);
+				fos.write(decodedString);
+				fos.flush();
+				fos.close();
+
+			}
+
+		} catch (Exception e) {
+			System.out.println("Error creating file, Utils");
+		} finally {
+			if (fos != null) {
+				fos = null;
+			}
+		}
+		return file;
+
+	}
+
+
+
+
+
+	public static String getThumbnailsVideo() {
+		String videoImageFolder = null;
+
+		try {
+			videoImageFolder = Environment.getExternalStorageDirectory()+ "/salam/thumbnailsVideo";
+
+
+
+			File profileImageFolder = null;
+
+			try {
+				profileImageFolder = new File(videoImageFolder);
+				if (!profileImageFolder.exists()) {
+					profileImageFolder.mkdirs();
+
+				*//*	File noMedia = new File(profileImageFolder.getAbsolutePath()
+							+ "/" + ".nomedia");
+
+					noMedia.createNewFile();*//*
+
+				}
+			} catch (Exception e) {
+				e.printStackTrace();
+				System.out.println("XXX e1 " + e);
+			}
+
+
+
+
+
+
+
+
+		} catch (Exception e) {
+			e.printStackTrace();
+			System.out.println("XXX e1 " + e);
+		}
+		return videoImageFolder;
+	}
+
+
+
+	public static File getProfileImageFolder() {
+		File profileImageFolder = null;
+
+		try {
+			profileImageFolder = new File(
+					Environment.getExternalStorageDirectory()
+							+ "/salam/thumbnails");
+			if (!profileImageFolder.exists()) {
+				profileImageFolder.mkdirs();
+
+				File noMedia = new File(profileImageFolder.getAbsolutePath()
+						+ "/" + ".nomedia");
+
+				noMedia.createNewFile();
+
+			}
+		} catch (IOException e) {
+			e.printStackTrace();
+			System.out.println("XXX e1 " + e);
+		}
+		return profileImageFolder;
+	}
+
+	public static File getChatMultimediaFolder() {
+		File profileImageFolder = null;
+
+		try {
+			profileImageFolder = new File(
+					Environment.getExternalStorageDirectory()
+							+ "/salam/multimedia");
+			if (!profileImageFolder.exists()) {
+				profileImageFolder.mkdirs();
+
+				File noMedia = new File(profileImageFolder.getAbsolutePath()
+						+ "/" + ".nomedia");
+
+				noMedia.createNewFile();
+
+			}
+		} catch (IOException e) {
+			e.printStackTrace();
+			System.out.println("Multimedia e1 " + e);
+		}
+		return profileImageFolder;
+	}
+
+	public static int compareDatesWithoutTime(Calendar c1, Calendar c2) {
+		if (c1.get(Calendar.YEAR) != c2.get(Calendar.YEAR))
+			return c1.get(Calendar.YEAR) - c2.get(Calendar.YEAR);
+		if (c1.get(Calendar.MONTH) != c2.get(Calendar.MONTH))
+			return c1.get(Calendar.MONTH) - c2.get(Calendar.MONTH);
+		return c1.get(Calendar.DAY_OF_MONTH) - c2.get(Calendar.DAY_OF_MONTH);
+	}
+
+	public static void handleProfileImage(final Context context,
+			final String userId, final String url) {
+
+		if (userId != null && url != null && url.contains("http://")) {
+
+			Target target = new Target() {
+				@Override
+				public void onBitmapLoaded(final Bitmap bitmap,
+						Picasso.LoadedFrom from) {
+					System.out.println("Bit map loaded");
+					SHAMChatApplication.USER_IMAGES.put(userId, bitmap);
+				}
+
+				@Override
+				public void onBitmapFailed(Drawable errorDrawable) {
+				}
+
+				@Override
+				public void onPrepareLoad(Drawable placeHolderDrawable) {
+					if (placeHolderDrawable != null) {
+
+					}
+				}
+			};
+
+			Picasso.with(context).load(url).into(target);
+		}
+
+	}
+
+	public static MessageStatusType getMessageStatusType(int status) {
+
+		MessageStatusType messageStatusType = null;
+
+		switch (status) {
+
+		case 0:
+			messageStatusType = MessageStatusType.QUEUED;
+			break;
+		case 1:
+			messageStatusType = MessageStatusType.SENDING;
+			break;
+		case 2:
+			messageStatusType = MessageStatusType.SENT;
+			break;
+		case 3:
+			messageStatusType = MessageStatusType.DELIVERED;
+			break;
+		case 4:
+			messageStatusType = MessageStatusType.SEEN;
+			break;
+		case 5:
+			messageStatusType = MessageStatusType.FAILED;
+			break;
+		}
+
+		return messageStatusType;
+	}
+
+	public static int getFileSize(URL url) {
+	    HttpURLConnection conn = null;
+	    try {
+	        conn = (HttpURLConnection) url.openConnection();
+	        conn.setRequestMethod("HEAD");
+	        conn.getInputStream();
+	        return conn.getContentLength();
+	    } catch (IOException e) {
+	        return -1;
+	    } finally {
+	        conn.disconnect();
+	    }
+	}
+
+
+	*//**
+	 * generate a random packet id
+	 * @return
+	 *//*
+	 *
+	 */
+
+
+
+		public static String makePacketId(String userId) {
+			Long tsLong = System.currentTimeMillis()/1000;
+			String ts = tsLong.toString();
+			Random r = new Random();
+			int i1 = r.nextInt(80000 - 60000) + 60000;
+
+			String packetId = "packet-"+ userId + "-" + ts +i1;
+			return packetId;
+
+	}
+
+
+		  public static String detectPacketType(String jsonMessageString) {
+
+				JSONObject SampleMsg=null;
+				String packetType=null;
+				try {
+						SampleMsg = new JSONObject(jsonMessageString);
+						packetType = SampleMsg.getString("packet_type");
+
+
+					} catch (JSONException e1) {
+						// TODO Auto-generated catch block
+						if (jsonMessageString.equalsIgnoreCase("ping")) packetType="ping";
+						else packetType ="unknown";
+
+						e1.printStackTrace();
+					}
+
+				return packetType;
+		  }
+/*
+		  *//**
+		   * Detects packet type based on json string received
+		   *//*
+		  public static int detectMessageContentType(String jsonMessageString) {
+
+				JSONObject SampleMsg=null;
+				int messageType = -1;
+				try {
+						SampleMsg = new JSONObject(jsonMessageString);
+						messageType = SampleMsg.getInt("messageType");
+
+					} catch (JSONException e1) {
+						// TODO Auto-generated catch block
+						e1.printStackTrace();
+					}
+
+				return messageType;
+		  }
+
+		  *//**
+		   * gets packet id from json message
+		   *//*
+		  public static String getPacketId(String jsonMessageString) {
+
+				JSONObject SampleMsg=null;
+				String packetId = null;
+				try {
+						SampleMsg = new JSONObject(jsonMessageString);
+
+						if (SampleMsg.has("packetId"))
+							packetId = SampleMsg.getString("packetId");
+						else if (SampleMsg.has("packet_id"))
+							packetId = SampleMsg.getString("packet_id");
+
+					} catch (JSONException e1) {
+						// TODO Auto-generated catch block
+						e1.printStackTrace();
+					}
+
+				return packetId;
+		  }
+
+
+	  public static MessageContentType readMessageContentType(int type) {
+			MessageContentType messageType = MessageContentType.TEXT;
+			switch (type) {
+			case 1:
+				messageType = MessageContentType.IMAGE;
+				break;
+			case 2:
+				messageType = MessageContentType.STICKER;
+				break;
+			case 3:
+				messageType = MessageContentType.VOICE_RECORD;
+				break;
+			case 4:
+				messageType = MessageContentType.FAVORITE;
+				break;
+			case 5:
+				messageType = MessageContentType.MESSAGE_WITH_IMOTICONS;
+				break;
+			case 6:
+				messageType = MessageContentType.LOCATION;
+				break;
+			case 7:
+				messageType = MessageContentType.INCOMING_CALL;
+				break;
+			case 8:
+				messageType = MessageContentType.OUTGOING_CALL;
+				break;
+			case 9:
+				messageType = MessageContentType.VIDEO;
+				break;
+			case 11 :
+				messageType = MessageContentType.GROUP_INFO;
+				break;
+
+			}
+
+			return messageType;
+		}
+
+	  *//**
+	   * Detects packet type based on json string received
+	   *//*
+	  public static boolean isMyOwnPacket(String jsonMessageString) {
+
+			JSONObject SampleMsg=null;
+			int fromUserId = -1;
+			try {
+					SampleMsg = new JSONObject(jsonMessageString);
+					fromUserId = SampleMsg.getInt("from_userid");
+
+				} catch (JSONException e1) {
+					// TODO Auto-generated catch block
+					e1.printStackTrace();
+				}
+
+			int myUserId = Integer.parseInt(SHAMChatApplication.getConfig().getUserId());
+
+			if (myUserId == fromUserId) return true;
+			else return false;
+	  }
+
+	*//*
+	 *  url = file path or whatever suitable URL you want.
+	 *//*
+	  public static String getMimeType(String url) {
+	      String type = null;
+	      String extension = MimeTypeMap.getFileExtensionFromUrl(url);
+	      if (extension != null) {
+	          type = MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension);
+	      }
+	      return type;
+	  }
+
+	  public static File getErrorsFolder() {
+		  File folder = new File(Environment.getExternalStorageDirectory()+"/salam_errors");
+		  return folder;
+	  }
+
+	 *//**
+	  * Get Uri of a image path starting with content://
+	  * @param context
+	  * @param uri
+	  * @return
+	  *//*
+	  @TargetApi(Build.VERSION_CODES.KITKAT)
+	  public static String getFilePathImage(Context context, Uri uri)
+	  {
+	      int currentApiVersion;
+	      try
+	      {
+	           currentApiVersion = Build.VERSION.SDK_INT;
+	      }
+	      catch(NumberFormatException e)
+	      {
+	          //API 3 will crash if SDK_INT is called
+	          currentApiVersion = 3;
+	      }
+	      if (currentApiVersion >= Build.VERSION_CODES.KITKAT)
+	      {
+	          String filePath = "";
+	          String wholeID = DocumentsContract.getDocumentId(uri);
+
+	          // Split at colon, use second item in the array
+	          String id = wholeID.split(":")[1];
+
+	          String[] column = {MediaStore.Images.Media.DATA};
+
+	          // where id is equal to
+	          String sel = MediaStore.Images.Media._ID + "=?";
+
+	          Cursor cursor = context.getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
+	                  column, sel, new String[]{id}, null);
+
+	          int columnIndex = cursor.getColumnIndex(column[0]);
+
+	          if (cursor.moveToFirst())
+	          {
+	              filePath = cursor.getString(columnIndex);
+	          }
+	          cursor.close();
+	          return filePath;
+	      }
+	      else if (currentApiVersion <= Build.VERSION_CODES.HONEYCOMB_MR2 && currentApiVersion >= Build.VERSION_CODES.HONEYCOMB)
+
+	      {
+	          String[] proj = {MediaStore.Images.Media.DATA};
+	          String result = null;
+
+	          CursorLoader cursorLoader = new CursorLoader(
+	                  context,
+	                  uri, proj, null, null, null);
+	          Cursor cursor = cursorLoader.loadInBackground();
+
+	          if (cursor != null)
+	          {
+	              int column_index =
+	                      cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);
+	              cursor.moveToFirst();
+	              result = cursor.getString(column_index);
+	          }
+	          return result;
+	      }
+	      else
+	      {
+
+	          String[] proj = {MediaStore.Images.Media.DATA};
+	          Cursor cursor = context.getContentResolver().query(uri, proj, null, null, null);
+	          int column_index
+	                  = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);
+	          cursor.moveToFirst();
+	          return cursor.getString(column_index);
+	      }
+	  }	
+	  
+	  *//**
+	   * Converts a packetId to its safe file name equivalent
+	   * @param packetId
+	   * @return
+	   *//*
+	  public static String packetIdToFileName(String packetId)
+	  {
+		  //packetId = packet-6-4332345334   --> for group chat
+		  // packetId = 6iIXK-53  --> for single chat
+		  int count = StringUtils.countMatches(packetId, "-");
+		  String fileName = packetId;
+		  //if this is a group packet id we omit user id from it (it has two - characters)
+		  if (count >=2) fileName= packetId.substring(packetId.indexOf('-')+1);
+		  
+		  fileName = fileName.replace('-','_');
+		  fileName =  fileName.replaceAll("[^a-zA-Z0-9_\\-\\.]", "_");
+		  
+		return fileName;
+		  
+	  }
+	  *//**
+	   * Checks if a file exists or not
+	   * @param filePath
+	   * @return
+	   *//*
+	  public static boolean fileExists (String filePath)
+	  {
+		  if (filePath==null) return false;
+		  
+		  File file = new File(filePath);
+		  if(file.exists())      
+		   return true;
+		  else		  
+		   return false;  
+	  }
+	  
+		*//*
+		 * Efficiently Load Image from file path    
+		 *//*
+	public static Bitmap decodeSampledBitmapFromFile(String path,
+		            int reqWidth, int reqHeight) { // BEST QUALITY MATCH
+
+		    	Bitmap bm = null;
+		    try {
+		    	
+
+		        // First decode with inJustDecodeBounds=true to check dimensions
+		        final BitmapFactory.Options options = new BitmapFactory.Options();
+		        options.inJustDecodeBounds = true;
+		        BitmapFactory.decodeFile(path, options);
+
+		        // Calculate inSampleSize
+		            // Raw height and width of image
+		            final int height = options.outHeight;
+		            final int width = options.outWidth;
+		            //options.inPreferredConfig = Bitmap.Config.ARGB_8888;
+		            
+		            int inSampleSize = 1;
+
+		            if (height > reqHeight) {
+		                inSampleSize = Math.round((float)height / (float)reqHeight);
+		            }
+
+		            int expectedWidth = width / inSampleSize;
+
+		            if (expectedWidth > reqWidth) {
+		                //if(Math.round((float)width / (float)reqWidth) > inSampleSize) // If bigger SampSize..
+		                inSampleSize = Math.round((float)width / (float)reqWidth);
+		            }
+
+
+		        options.inSampleSize = inSampleSize;
+
+		        // Decode bitmap with inSampleSize set
+		        options.inJustDecodeBounds = false;
+		        
+		        bm = BitmapFactory.decodeFile(path, options);
+		        
+		    } catch (Exception e) {
+		 	   e.printStackTrace();
+			   Toast.makeText(SHAMChatApplication.getMyApplicationContext(), e.toString(), Toast.LENGTH_LONG).show();
+			  }
+		    
+		        return bm;
+		      }
+	  
+	
+	*//**
+	 * returns current image file local file path or null if nothing exists
+	 * @return
+	 *//*
+	public static String getImageLocalFilePath(String packetId)
+	{
+		Cursor cursor = SHAMChatApplication.getMyApplicationContext().getContentResolver()
+				.query(
+		ChatProviderNew.CONTENT_URI_CHAT, null,
+		ChatMessage.PACKET_ID + "=?", new String[] { packetId },
+		null);
+
+		String fileUrl = null;
+		if (cursor != null) {
+
+			cursor.moveToFirst();
+		 	fileUrl = cursor.getString(cursor.getColumnIndex(ChatMessage.FILE_URL));
+		}
+
+        if (cursor != null) {
+            cursor.close();
+        }
+
+        return fileUrl;
+	}
+
+
+	*//**
+	 * Stack Blur v1.0 from
+	 * http://www.quasimondo.com/StackBlurForCanvas/StackBlurDemo.html
+	 * Java Author: Mario Klingemann <mario at quasimondo.com>
+	 * http://incubator.quasimondo.com
+	 *
+	 * created Feburary 29, 2004
+	 * Android port : Yahel Bouaziz <yahel at kayenko.com>
+	 * http://www.kayenko.com
+	 * ported april 5th, 2012
+	 *
+	 * This is a compromise between Gaussian Blur and Box blur
+	 * It creates much better looking blurs than Box Blur, but is
+	 * 7x faster than my Gaussian Blur implementation.
+	 *
+	 * I called it Stack Blur because this describes best how this
+	 * filter works internally: it creates a kind of moving stack
+	 * of colors whilst scanning through the image. Thereby it
+	 * just has to add one new block of color to the right side
+	 * of the stack and remove the leftmost color. The remaining
+	 * colors on the topmost layer of the stack are either added on
+	 * or reduced by one, depending on if they are on the right or
+	 * on the left side of the stack.
+	 *  
+	 * If you are using this algorithm in your code please add
+	 * the following line:
+	 * Stack Blur Algorithm by Mario Klingemann <mario@quasimondo.com>
+	 *//*
+
+	public static Bitmap fastblur(Bitmap sentBitmap, float scale, int radius) {
+
+	    int width = Math.round(sentBitmap.getWidth() * scale);
+	    int height = Math.round(sentBitmap.getHeight() * scale);
+	    sentBitmap = Bitmap.createScaledBitmap(sentBitmap, width, height, false);
+
+	    Bitmap bitmap = sentBitmap.copy(sentBitmap.getConfig(), true);
+
+	    if (radius < 1) {
+	        return (null);
+	    }
+
+	    int w = bitmap.getWidth();
+	    int h = bitmap.getHeight();
+
+	    int[] pix = new int[w * h];
+	    Log.e("pix", w + " " + h + " " + pix.length);
+	    bitmap.getPixels(pix, 0, w, 0, 0, w, h);
+
+	    int wm = w - 1;
+	    int hm = h - 1;
+	    int wh = w * h;
+	    int div = radius + radius + 1;
+
+	    int r[] = new int[wh];
+	    int g[] = new int[wh];
+	    int b[] = new int[wh];
+	    int rsum, gsum, bsum, x, y, i, p, yp, yi, yw;
+	    int vmin[] = new int[Math.max(w, h)];
+
+	    int divsum = (div + 1) >> 1;
+	    divsum *= divsum;
+	    int dv[] = new int[256 * divsum];
+	    for (i = 0; i < 256 * divsum; i++) {
+	        dv[i] = (i / divsum);
+	    }
+
+	    yw = yi = 0;
+
+	    int[][] stack = new int[div][3];
+	    int stackpointer;
+	    int stackstart;
+	    int[] sir;
+	    int rbs;
+	    int r1 = radius + 1;
+	    int routsum, goutsum, boutsum;
+	    int rinsum, ginsum, binsum;
+
+	    for (y = 0; y < h; y++) {
+	        rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0;
+	        for (i = -radius; i <= radius; i++) {
+	            p = pix[yi + Math.min(wm, Math.max(i, 0))];
+	            sir = stack[i + radius];
+	            sir[0] = (p & 0xff0000) >> 16;
+	            sir[1] = (p & 0x00ff00) >> 8;
+	            sir[2] = (p & 0x0000ff);
+	            rbs = r1 - Math.abs(i);
+	            rsum += sir[0] * rbs;
+	            gsum += sir[1] * rbs;
+	            bsum += sir[2] * rbs;
+	            if (i > 0) {
+	                rinsum += sir[0];
+	                ginsum += sir[1];
+	                binsum += sir[2];
+	            } else {
+	                routsum += sir[0];
+	                goutsum += sir[1];
+	                boutsum += sir[2];
+	            }
+	        }
+	        stackpointer = radius;
+
+	        for (x = 0; x < w; x++) {
+
+	            r[yi] = dv[rsum];
+	            g[yi] = dv[gsum];
+	            b[yi] = dv[bsum];
+
+	            rsum -= routsum;
+	            gsum -= goutsum;
+	            bsum -= boutsum;
+
+	            stackstart = stackpointer - radius + div;
+	            sir = stack[stackstart % div];
+
+	            routsum -= sir[0];
+	            goutsum -= sir[1];
+	            boutsum -= sir[2];
+
+	            if (y == 0) {
+	                vmin[x] = Math.min(x + radius + 1, wm);
+	            }
+	            p = pix[yw + vmin[x]];
+
+	            sir[0] = (p & 0xff0000) >> 16;
+	            sir[1] = (p & 0x00ff00) >> 8;
+	            sir[2] = (p & 0x0000ff);
+
+	            rinsum += sir[0];
+	            ginsum += sir[1];
+	            binsum += sir[2];
+
+	            rsum += rinsum;
+	            gsum += ginsum;
+	            bsum += binsum;
+
+	            stackpointer = (stackpointer + 1) % div;
+	            sir = stack[(stackpointer) % div];
+
+	            routsum += sir[0];
+	            goutsum += sir[1];
+	            boutsum += sir[2];
+
+	            rinsum -= sir[0];
+	            ginsum -= sir[1];
+	            binsum -= sir[2];
+
+	            yi++;
+	        }
+	        yw += w;
+	    }
+	    for (x = 0; x < w; x++) {
+	        rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0;
+	        yp = -radius * w;
+	        for (i = -radius; i <= radius; i++) {
+	            yi = Math.max(0, yp) + x;
+
+	            sir = stack[i + radius];
+
+	            sir[0] = r[yi];
+	            sir[1] = g[yi];
+	            sir[2] = b[yi];
+
+	            rbs = r1 - Math.abs(i);
+
+	            rsum += r[yi] * rbs;
+	            gsum += g[yi] * rbs;
+	            bsum += b[yi] * rbs;
+
+	            if (i > 0) {
+	                rinsum += sir[0];
+	                ginsum += sir[1];
+	                binsum += sir[2];
+	            } else {
+	                routsum += sir[0];
+	                goutsum += sir[1];
+	                boutsum += sir[2];
+	            }
+
+	            if (i < hm) {
+	                yp += w;
+	            }
+	        }
+	        yi = x;
+	        stackpointer = radius;
+	        for (y = 0; y < h; y++) {
+	            // Preserve alpha channel: ( 0xff000000 & pix[yi] )
+	            pix[yi] = ( 0xff000000 & pix[yi] ) | ( dv[rsum] << 16 ) | ( dv[gsum] << 8 ) | dv[bsum];
+
+	            rsum -= routsum;
+	            gsum -= goutsum;
+	            bsum -= boutsum;
+
+	            stackstart = stackpointer - radius + div;
+	            sir = stack[stackstart % div];
+
+	            routsum -= sir[0];
+	            goutsum -= sir[1];
+	            boutsum -= sir[2];
+
+	            if (x == 0) {
+	                vmin[y] = Math.min(y + r1, hm) * w;
+	            }
+	            p = x + vmin[y];
+
+	            sir[0] = r[p];
+	            sir[1] = g[p];
+	            sir[2] = b[p];
+
+	            rinsum += sir[0];
+	            ginsum += sir[1];
+	            binsum += sir[2];
+
+	            rsum += rinsum;
+	            gsum += ginsum;
+	            bsum += binsum;
+
+	            stackpointer = (stackpointer + 1) % div;
+	            sir = stack[stackpointer];
+
+	            routsum += sir[0];
+	            goutsum += sir[1];
+	            boutsum += sir[2];
+
+	            rinsum -= sir[0];
+	            ginsum -= sir[1];
+	            binsum -= sir[2];
+
+	            yi += w;
+	        }
+	    }
+
+	    Log.e("pix", w + " " + h + " " + pix.length);
+	    bitmap.setPixels(pix, 0, w, 0, 0, w, h);
+
+	    return (bitmap);
+	}
+
+	public static boolean isUsernameValid(String username) {
+		boolean isValid = false;
+
+		String expression = "^[a-z0-9_-]{3,15}$";
+		CharSequence inputStr =  username;
+
+		Pattern pattern = Pattern.compile(expression, Pattern.CASE_INSENSITIVE);
+		Matcher matcher = pattern.matcher(inputStr);
+		if (matcher.matches()) {
+			isValid = true;
+		}
+		return isValid;
+	}
+
+
+
+
+    *//**
+     * This is used to save in database for last update time and so
+     *
+     * @param yourDate  in GMT/UTC time or unix epoch
+     * @param format
+     * @return
+     *//*
+     * */
+    public static String formatDate(long yourDate, String format) {
+        SimpleDateFormat dateFormat = new SimpleDateFormat(format, Locale.US);
+        dateFormat.setTimeZone(TimeZone.getTimeZone("UTC"));
+
+        Date date = new Date(yourDate);
+        String dobStr = dateFormat.format(date);
+        return dobStr;
+    }
+/*
+    *//**
+     * This formats and converts date from epoch unix timestamp to local time of user (which is set in settings-> date time)
+     * @param timestamp
+     * @param format
+     * @return
+     *//*
+    public static String formatDateToLocal(long timestamp, String format) {
+
+        SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US);
+        formatter.setTimeZone(TimeZone.getDefault());
+
+        String dateTime = formatter.format(new Date(timestamp));
+
+        dateTime = UTCToLocalDateConvert(dateTime, format);
+       return dateTime;
+
+    }
+
+    *//**
+     * Converts a string like 2011-06-23T15:11:32 from UTC to android local time
+     * @param OurDate
+     * @return
+     *//*
+    public static String UTCToLocalDateConvert(String OurDate, String fromat)
+    {
+
+        SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US);
+        formatter.setTimeZone(TimeZone.getTimeZone("UTC"));
+        Date value = null;
+        String dt = "";
+        try {
+            value = formatter.parse(OurDate);
+
+        SimpleDateFormat dateFormatter = new SimpleDateFormat(fromat);
+        dateFormatter.setTimeZone(TimeZone.getDefault());
+        dt = dateFormatter.format(value);
+
+        } catch (ParseException e) {
+            e.printStackTrace();
+        }
+
+        return dt;
+    }
+
+    *//**
+     * returns datetime - sqllite compatible - GMT/UTC time
+     * @return
+     *//*
+     * */
+    public static String getTimeStamp() {
+        SimpleDateFormat simpleDateFormat =  new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US);
+        simpleDateFormat.setTimeZone(TimeZone.getTimeZone("UTC"));
+
+        Date date = new Date();
+
+        Calendar c = new GregorianCalendar();
+        c.setTime(date);
+
+        //mast - backend has a bug which sends back the time 15 minutes added to it
+        //so we add 15 minutes to time to keep listview ordering of channel/group correctly
+
+        c.add(Calendar.MINUTE, 5);
+        //c.add(Calendar.HOUR, 1);
+        //c.add(Calendar.HOUR, 1);
+        //c.set(Calendar.MINUTE, 0);
+        //c.set(Calendar.SECOND, 0);
+        date = c.getTime();
+
+        return simpleDateFormat.format(date);
+    }
+/*
+    public static String getTimeInReadableFormat(Context context, long time) {
+        long timeDiff = System.currentTimeMillis() - time;
+
+        if (timeDiff < 1000 * 60 * 60 * 24) {
+            return context.getResources().getString(R.string.today);
+        } else if (timeDiff < 1000 * 60 * 60 * 24 * 2) {
+            return context.getResources().getString(R.string.yesterday);
+        }
+
+        SimpleDateFormat dateFormat = new SimpleDateFormat("d MMM kk.mm", Locale.US);
+        dateFormat.setTimeZone(TimeZone.getDefault());
+
+        return dateFormat.format(new Date(time));
+    }
+
+    *//**
+     * Gets a UTC datetime and converts it to user local time
+     * @param dateInString
+     //* @param format
+     * @return
+     *//*
+    public static String formatStringDate(String dateInString, String format) {
+        Date formatedDate = null;
+         SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
+        formatter.setTimeZone(TimeZone.getTimeZone("UTC"));
+
+        try {
+
+            formatedDate = formatter.parse(dateInString);
+
+        } catch (ParseException e) {
+            e.printStackTrace();
+        }
+        Date date = new Date(formatedDate.getTime());
+        String dobStr = formatter.format(date);
+
+        dobStr = UTCToLocalDateConvert(dobStr,format);
+
+        return dobStr;
+    }
+
+	public static String UTCToLocalDateConvertSingleChat(String OurDate, String fromat)
+	{
+
+		SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US);
+		//formatter.setTimeZone(TimeZone.getTimeZone("UTC"));
+		Date value = null;
+		String dt = "";
+		try {
+			value = formatter.parse(OurDate);
+
+			SimpleDateFormat dateFormatter = new SimpleDateFormat(fromat);
+			dateFormatter.setTimeZone(TimeZone.getDefault());
+			dt = dateFormatter.format(value);
+
+		} catch (ParseException e) {
+			e.printStackTrace();
+		}
+
+		return dt;
+	}
+	public static String formatStringDateSingleChat(String dateInString, String format) {
+		Date formatedDate = null;
+		SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss",Locale.US);
+		//formatter.setTimeZone(TimeZone.getTimeZone("UTC"));
+
+		try {
+
+			formatedDate = formatter.parse(dateInString);
+
+		} catch (ParseException e) {
+			e.printStackTrace();
+		}
+		Date date = new Date(formatedDate.getTime());
+		String dobStr = formatter.format(date);
+
+		dobStr = UTCToLocalDateConvertSingleChat(dobStr,format);
+
+		return dobStr;
+	}
+
+
+*/
+	public static Date getDateFromStringDate(String dateInString) {
+        Date formatedDate = null;
+        SimpleDateFormat formatter = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss", Locale.US);
+        //formatter.setTimeZone(TimeZone.getTimeZone("UTC"));
+
+        try {
+
+            formatedDate = formatter.parse(dateInString);
+            // System.out.println(formatedDate);
+            // System.out.println(formatter.format(formatedDate));
+
+        } catch (ParseException e) {
+            e.printStackTrace();
+        }
+
+        return formatedDate;
+    }
+/*
+    public static Date getDateFromStringDate(String dateInString, String existingFormat) {
+        Date formatedDate = null;
+        SimpleDateFormat formatter = new SimpleDateFormat(existingFormat, Locale.US);
+        //formatter.setTimeZone(TimeZone.getTimeZone("UTC"));
+
+        try {
+
+            formatedDate = formatter.parse(dateInString);
+            // System.out.println(formatedDate);
+            // System.out.println(formatter.format(formatedDate));
+
+        } catch (ParseException e) {
+            e.printStackTrace();
+        }
+
+        return formatedDate;
+    }
+
+	*//**
+	 * Returns the good width size to use in chats in pixels
+	 * @param ctx
+	 * @return
+	 *//*
+
+	public static String b="";
+	public static  String getImagePorofile(final String userId)
+	{
+		Thread thread = new Thread() {
+			@Override
+			public void run() {
+				try {
+					OkHttpClient client = new OkHttpClient();
+
+
+					client.setConnectTimeout(60, TimeUnit.SECONDS); // connect timeout
+					client.setReadTimeout(60, TimeUnit.SECONDS);    // socket timeout
+					Request request = new Request.Builder()
+							.url("http://social.rabtcdn.com/groups/api/v1/avatar/with/userid/"+userId+"/")
+							.cacheControl(new CacheControl.Builder().noCache().build())
+							.build();
+
+					Response responses=null;
+					try {
+						responses = client.newCall(request).execute();
+
+					} catch (IOException e) {
+						e.printStackTrace();
+					}
+					String jsonData = responses.body().string();
+					JSONObject Jobject = new JSONObject(jsonData);
+					String z= Jobject.getString("avatar");
+					b=z;
+					//JSONArray Jarray = Jobject.getJSONArray("objects");
+
+				*//*	for (int i = 0; i < Jarray.length(); i++) {
+						JSONObject object     = Jarray.getJSONObject(i);
+					}*//*
+				}
+				catch (Exception e)
+				{
+
+					Log.e("getImagePorofile", "getImagePorofile: ",e );
+				}
+
+			}
+		};
+
+		thread.start();
+
+		return b;
+	}
+
+	public  static int getDisplayWidth(Context ctx)
+	{
+
+		int displayWidth = (int) com.rokhgroup.utils.Utils.getWidthInPx(ctx);
+		return displayWidth;
+	}
+	public static int getFittingImageWidthPx(Context ctx) {
+		int imageWidthInPx = 0;
+		//get device width in pixels
+		int displayWidth = (int) com.rokhgroup.utils.Utils.getWidthInPx(ctx);
+
+		if (displayWidth>=1000)
+			imageWidthInPx = 900;
+		else if (displayWidth>=900)
+			imageWidthInPx = 800;
+		else if (displayWidth>=800)
+			imageWidthInPx = 700;
+		else if (displayWidth>=700)
+			imageWidthInPx = 600;
+		else if (displayWidth>=650)
+			imageWidthInPx = 550;
+		else if (displayWidth>=550)
+			imageWidthInPx = 450;
+		else if (displayWidth>=450)
+			imageWidthInPx = 350;
+		else if (displayWidth>=350)
+			imageWidthInPx = 300;
+		else if (displayWidth>=250)
+			imageWidthInPx = 220;
+				else
+			imageWidthInPx = 240;
+
+		return imageWidthInPx;
+	}
+
+
+	public static int stikersize(Context ctx) {
+		int imageWidthInPx = 0;
+		//get device width in pixels
+		int displayWidth = (int) com.rokhgroup.utils.Utils.getWidthInPx(ctx);
+
+		if (displayWidth>=1000)
+			imageWidthInPx = 512;
+		else if (displayWidth>=900)
+			imageWidthInPx = 450;
+		else if (displayWidth>=800)
+			imageWidthInPx = 400;
+		else if (displayWidth>=700)
+			imageWidthInPx = 350;
+		else if (displayWidth>=650)
+			imageWidthInPx = 300;
+		else if (displayWidth>=550)
+			imageWidthInPx = 300;
+		else if (displayWidth>=450)
+			imageWidthInPx = 300;
+		else if (displayWidth>=350)
+			imageWidthInPx = 200;
+		else if (displayWidth>=250)
+			imageWidthInPx = 150;
+		else
+			imageWidthInPx = 150;
+
+		return imageWidthInPx;
+	}
+
+
+
+	*//**
+	 * Get file path from URI
+	 *
+	 * @param context context of Activity
+	 * @param uri     uri of file
+	 * @return path of given URI
+	 *//*
+	public static String getPath(final Context context, final Uri uri) {
+		final boolean isKitKat = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
+		// DocumentProvider
+		if (isKitKat && DocumentsContract.isDocumentUri(context, uri)) {
+			// ExternalStorageProvider
+			if (isExternalStorageDocument(uri)) {
+				final String docId = DocumentsContract.getDocumentId(uri);
+				final String[] split = docId.split(":");
+				final String type = split[0];
+				if ("primary".equalsIgnoreCase(type)) {
+					return Environment.getExternalStorageDirectory() + "/" + split[1];
+				}
+			}
+			// DownloadsProvider
+			else if (isDownloadsDocument(uri)) {
+				final String id = DocumentsContract.getDocumentId(uri);
+				final Uri contentUri = ContentUris.withAppendedId(Uri.parse("content://downloads/public_downloads"), Long.valueOf(id));
+				return getDataColumn(context, contentUri, null, null);
+			}
+			// MediaProvider
+			else if (isMediaDocument(uri)) {
+				final String docId = DocumentsContract.getDocumentId(uri);
+				final String[] split = docId.split(":");
+				final String type = split[0];
+				Uri contentUri = null;
+				if ("image".equals(type)) {
+					contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
+				} else if ("video".equals(type)) {
+					contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;
+				} else if ("audio".equals(type)) {
+					contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;
+				}
+				final String selection = "_id=?";
+				final String[] selectionArgs = new String[]{split[1]};
+				return getDataColumn(context, contentUri, selection, selectionArgs);
+			}
+		}
+		// MediaStore (and general)
+		else if ("content".equalsIgnoreCase(uri.getScheme())) {
+			// Return the remote address
+			if (isGooglePhotosUri(uri))
+				return uri.getLastPathSegment();
+			return getDataColumn(context, uri, null, null);
+		}
+		// File
+		else if ("file".equalsIgnoreCase(uri.getScheme())) {
+			return uri.getPath();
+		}
+		return null;
+	}
+
+	public static String getDataColumn(Context context, Uri uri, String selection, String[] selectionArgs) {
+		Cursor cursor = null;
+		final String column = "_data";
+		final String[] projection = {column};
+		try {
+			cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs, null);
+			if (cursor != null && cursor.moveToFirst()) {
+				final int index = cursor.getColumnIndexOrThrow(column);
+				return cursor.getString(index);
+			}
+		} finally {
+			if (cursor != null)
+				cursor.close();
+		}
+		return null;
+	}
+
+	public static boolean isExternalStorageDocument(Uri uri) {
+		return "com.android.externalstorage.documents".equals(uri.getAuthority());
+	}
+
+	public static boolean isDownloadsDocument(Uri uri) {
+		return "com.android.providers.downloads.documents".equals(uri.getAuthority());
+	}
+
+	public static boolean isMediaDocument(Uri uri) {
+		return "com.android.providers.media.documents".equals(uri.getAuthority());
+	}
+
+	public static boolean isGooglePhotosUri(Uri uri) {
+		return "com.google.android.apps.photos.content".equals(uri.getAuthority());
+	}*/
+
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/ChatActivityEnterView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/ChatActivityEnterView.java
index 299508c7c..6a966fad3 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/ChatActivityEnterView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/ChatActivityEnterView.java
@@ -1311,6 +1311,7 @@ public boolean processSendingText(String text) {
             for (int a = 0; a < count; a++) {
                 String mess = text.substring(a * 4096, Math.min((a + 1) * 4096, text.length()));
                 SendMessagesHelper.getInstance().sendMessage(mess, dialog_id, replyingMessageObject, messageWebPage, messageWebPageSearch, asAdmin(), null, null);
+
             }
             return true;
         }
