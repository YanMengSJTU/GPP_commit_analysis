diff --git a/TMessagesProj/src/main/java/org/telegram/android/MessagesStorage.java b/TMessagesProj/src/main/java/org/telegram/android/MessagesStorage.java
index 9661cc6e8..f5e2d735e 100644
--- a/TMessagesProj/src/main/java/org/telegram/android/MessagesStorage.java
+++ b/TMessagesProj/src/main/java/org/telegram/android/MessagesStorage.java
@@ -35,6 +35,7 @@
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.concurrent.Semaphore;
@@ -1200,81 +1201,86 @@ public void searchDialogs(final Integer token, final String query, final boolean
         storageQueue.postRunnable(new Runnable() {
             @Override
             public void run() {
+                final int resultLimit = 3;
                 try {
                     ArrayList<TLRPC.User> encUsers = new ArrayList<TLRPC.User>();
-                    String q = query.trim().toLowerCase();
-                    if (q.length() == 0) {
+                    if (query.trim().length() == 0) {
                         NotificationCenter.getInstance().postNotificationName(NotificationCenter.reloadSearchResults, token, new ArrayList<TLObject>(), new ArrayList<CharSequence>(), new ArrayList<CharSequence>());
                         return;
                     }
                     ArrayList<TLObject> resultArray = new ArrayList<TLObject>();
                     ArrayList<CharSequence> resultArrayNames = new ArrayList<CharSequence>();
+                    NameQuery nameQuery = new NameQuery(query);
 
-                    SQLiteCursor cursor = database.queryFinalized("SELECT u.data, u.status, u.name FROM users as u INNER JOIN contacts as c ON u.uid = c.uid");
-                    while (cursor.next()) {
-                        String name = cursor.stringValue(2);
-                        if (name.startsWith(q) || name.contains(" " + q)) {
-                            ByteBufferDesc data = buffersStorage.getFreeBuffer(cursor.byteArrayLength(0));
-                            if (data != null && cursor.byteBufferValue(0, data.buffer) != 0) {
-                                TLRPC.User user = (TLRPC.User)TLClassStore.Instance().TLdeserialize(data, data.readInt32());
-                                if (user.id != UserConfig.getClientUserId()) {
+                    SQLiteCursor cursor = database.queryFinalized("SELECT u.data, u.status FROM users as u INNER JOIN contacts as c ON u.uid = c.uid");
+                    for (int i = 0; cursor.next() && i < resultLimit;) {
+                        ByteBufferDesc data = buffersStorage.getFreeBuffer(cursor.byteArrayLength(0));
+                        if (data != null && cursor.byteBufferValue(0, data.buffer) != 0) {
+                            TLRPC.User user = (TLRPC.User) TLClassStore.Instance().TLdeserialize(data, data.readInt32());
+                            if (user.id != UserConfig.getClientUserId()) {
+                                String name = ContactsController.formatName(user.first_name, user.last_name);
+                                List<NameQuery.Range> matched = nameQuery.match(name);
+                                if (!matched.isEmpty()) {
                                     if (user.status != null) {
                                         user.status.expires = cursor.intValue(1);
                                     }
-                                    resultArrayNames.add(Utilities.generateSearchName(user.first_name, user.last_name, q));
+                                    resultArrayNames.add(Utilities.generateSearchName(name, matched));
                                     resultArray.add(user);
+                                    ++i;
                                 }
                             }
-                            buffersStorage.reuseFreeBuffer(data);
                         }
+                        buffersStorage.reuseFreeBuffer(data);
                     }
                     cursor.dispose();
 
                     if (needEncrypted) {
-                        cursor = database.queryFinalized("SELECT q.data, q.name, q.user, q.g, q.authkey, q.ttl, u.data, u.status FROM enc_chats as q INNER JOIN dialogs as d ON (q.uid << 32) = d.did INNER JOIN users as u ON q.user = u.uid");
-                        while (cursor.next()) {
-                            String name = cursor.stringValue(1);
-                            if (name.startsWith(q) || name.contains(" " + q)) {
-                                ByteBufferDesc data = buffersStorage.getFreeBuffer(cursor.byteArrayLength(0));
-                                ByteBufferDesc data2 = buffersStorage.getFreeBuffer(cursor.byteArrayLength(6));
-                                if (data != null && cursor.byteBufferValue(0, data.buffer) != 0 && cursor.byteBufferValue(6, data2.buffer) != 0) {
+                        cursor = database.queryFinalized("SELECT q.data, q.user, q.g, q.authkey, q.ttl, u.data, u.status FROM enc_chats as q INNER JOIN dialogs as d ON (q.uid << 32) = d.did INNER JOIN users as u ON q.user = u.uid");
+                        for (int i = 0; cursor.next() && i < resultLimit;) {
+                            ByteBufferDesc data = buffersStorage.getFreeBuffer(cursor.byteArrayLength(0));
+                            ByteBufferDesc data2 = buffersStorage.getFreeBuffer(cursor.byteArrayLength(5));
+                            if (data != null && cursor.byteBufferValue(0, data.buffer) != 0 && cursor.byteBufferValue(5, data2.buffer) != 0) {
+                                TLRPC.User user = (TLRPC.User)TLClassStore.Instance().TLdeserialize(data2, data2.readInt32());
+                                if (user.status != null) {
+                                    user.status.expires = cursor.intValue(6);
+                                }
+                                String name = ContactsController.formatName(user.first_name, user.last_name);
+                                List<NameQuery.Range> matched = nameQuery.match(name);
+                                if (!matched.isEmpty()) {
                                     TLRPC.EncryptedChat chat = (TLRPC.EncryptedChat) TLClassStore.Instance().TLdeserialize(data, data.readInt32());
-                                    chat.user_id = cursor.intValue(2);
-                                    chat.a_or_b = cursor.byteArrayValue(3);
-                                    chat.auth_key = cursor.byteArrayValue(4);
-                                    chat.ttl = cursor.intValue(5);
+                                    chat.user_id = cursor.intValue(1);
+                                    chat.a_or_b = cursor.byteArrayValue(2);
+                                    chat.auth_key = cursor.byteArrayValue(3);
+                                    chat.ttl = cursor.intValue(4);
 
-                                    TLRPC.User user = (TLRPC.User)TLClassStore.Instance().TLdeserialize(data2, data2.readInt32());
-                                    if (user.status != null) {
-                                        user.status.expires = cursor.intValue(7);
-                                    }
-                                    resultArrayNames.add(Html.fromHtml("<font color=\"#00a60e\">" + ContactsController.formatName(user.first_name, user.last_name) + "</font>"));
+                                    resultArrayNames.add(Utilities.generateSearchName(name, matched, "#00a60e"));
                                     resultArray.add(chat);
                                     encUsers.add(user);
+                                    ++i;
                                 }
-                                buffersStorage.reuseFreeBuffer(data);
-                                buffersStorage.reuseFreeBuffer(data2);
                             }
+                            buffersStorage.reuseFreeBuffer(data);
+                            buffersStorage.reuseFreeBuffer(data2);
                         }
                         cursor.dispose();
                     }
 
-                    cursor = database.queryFinalized("SELECT data, name FROM chats");
-                    while (cursor.next()) {
-                        String name = cursor.stringValue(1);
-                        String[] args = name.split(" ");
-                        if (name.startsWith(q) || name.contains(" " + q)) {
-                            ByteBufferDesc data = buffersStorage.getFreeBuffer(cursor.byteArrayLength(0));
-                            if (data != null && cursor.byteBufferValue(0, data.buffer) != 0) {
-                                TLRPC.Chat chat = (TLRPC.Chat) TLClassStore.Instance().TLdeserialize(data, data.readInt32());
-                                if (!needEncrypted && chat.id < 0) {
-                                    continue;
-                                }
-                                resultArrayNames.add(Utilities.generateSearchName(chat.title, null, q));
+                    cursor = database.queryFinalized("SELECT data FROM chats");
+                    for (int i = 0; cursor.next() && i < resultLimit;) {
+                        ByteBufferDesc data = buffersStorage.getFreeBuffer(cursor.byteArrayLength(0));
+                        if (data != null && cursor.byteBufferValue(0, data.buffer) != 0) {
+                            TLRPC.Chat chat = (TLRPC.Chat) TLClassStore.Instance().TLdeserialize(data, data.readInt32());
+                            if (!needEncrypted && chat.id < 0) {
+                                continue;
+                            }
+                            List<NameQuery.Range> matched = nameQuery.match(chat.title);
+                            if (!matched.isEmpty()) {
+                                resultArrayNames.add(Utilities.generateSearchName(chat.title, matched));
                                 resultArray.add(chat);
+                                ++i;
                             }
-                            buffersStorage.reuseFreeBuffer(data);
                         }
+                        buffersStorage.reuseFreeBuffer(data);
                     }
                     cursor.dispose();
 
diff --git a/TMessagesProj/src/main/java/org/telegram/android/NameQuery.java b/TMessagesProj/src/main/java/org/telegram/android/NameQuery.java
new file mode 100644
index 000000000..d9e26add2
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/NameQuery.java
@@ -0,0 +1,192 @@
+/*
+ * This is the source code of Telegram for Android v. 1.3.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2014.
+ */
+
+package org.telegram.android;
+
+import android.text.TextUtils;
+import org.telegram.messenger.Utilities;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.HashSet;
+
+public class NameQuery {
+    private static final ArrayList<Range> NO_RANGES = new ArrayList<Range>();
+    private final List<String> queryList = new ArrayList<String>();
+
+    public NameQuery(String name) {
+        if (!TextUtils.isEmpty(name)) {
+            String[] names = name.split(" ");
+            if (names.length < 5) {
+                HashSet<String> set = new HashSet<String>();
+                for (String part : names) {
+                    part = normalize(part);
+                    if (part.length() != 0) {
+                        set.add(part);
+                    }
+                }
+                queryList.addAll(set);
+            } else {
+                queryList.add(normalize(name));
+            }
+        }
+    }
+
+    private static String normalize(String str) {
+        int length = str.length();
+        StringBuilder sb = new StringBuilder(length);
+        for (int i = 0; i < length; ++i) {
+            char ch = str.charAt(i);
+            if (Character.isLetterOrDigit(ch))
+                sb.append(Character.toLowerCase(ch));
+        }
+        return sb.toString();
+    }
+
+    public List<Range> match(String str) {
+        if (!TextUtils.isEmpty(str) && !queryList.isEmpty()) {
+            NameMatcher nameMatcher = new NameMatcher(this, str);
+            if (nameMatcher.match())
+                return nameMatcher.getRanges();
+        }
+        return NO_RANGES;
+    }
+
+    public final class Range {
+        private int begin;
+        private int end;
+
+        public Range(int begin, int end) {
+            this.setBegin(begin);
+            this.setEnd(end);
+        }
+
+        public int getBegin() {
+            return begin;
+        }
+
+        private void setBegin(int begin) {
+            this.begin = begin;
+        }
+
+        public int getEnd() {
+            return end;
+        }
+
+        private void setEnd(int end) {
+            this.end = end;
+        }
+
+        @Override
+        public String toString() {
+            return "Range{begin=" + getBegin() + ",end=" + getEnd() + '}';
+        }
+    }
+
+    private final class NameMatcher {
+        private final NameQuery nameQuery;
+        private final String source;
+        private final int sourceLength;
+        private String target;
+        private Range lastRange;
+        private final List<Range> rangeList = new ArrayList<Range>();
+
+        public NameMatcher(NameQuery nameQuery, String source) {
+            this.nameQuery = nameQuery;
+            this.source = source;
+            this.sourceLength = source.length();
+        }
+
+        public final List<Range> getRanges() {
+            return rangeList;
+        }
+
+        public void addRange(final Range range) {
+            for (int i = 0; i < rangeList.size(); ++i) {
+                final Range current = rangeList.get(i);
+                int ax = range.getBegin(), ay = range.getEnd();
+                int bx = current.getBegin(), by = current.getEnd();
+                if (ax >= bx && ay <= by)
+                    return;
+                if (ay < bx) {
+                    rangeList.add(i, range);
+                    return;
+                }
+                if (ax <= by) {
+                    if (ay > by) {
+                        current.setEnd(ay);
+                        if (rangeList.size() > ++i && rangeList.get(i).getBegin() == ay) {
+                            current.setEnd(rangeList.get(i).getEnd());
+                            rangeList.remove(i);
+                        }
+                        return;
+                    }
+                    if (ax < bx) {
+                        current.setBegin(ax);
+                        return;
+                    }
+                }
+            }
+            rangeList.add(range);
+        }
+
+        public boolean match() {
+            boolean[] resultMap = new boolean[nameQuery.queryList.size()];
+            for (int i = 0; i < resultMap.length; ++i) {
+                target = nameQuery.queryList.get(i);
+                while (next()) {
+                    addRange(lastRange);
+                    resultMap[i] = true;
+                }
+            }
+            for (boolean b : resultMap) {
+                if (!b)
+                    return false;
+            }
+            return true;
+        }
+
+        public boolean next() {
+            return next(lastRange == null ? 0 : lastRange.getEnd());
+        }
+
+        public boolean next(int offset) {
+            lastRange = null;
+            for (int begin = offset; begin < sourceLength; ++begin) {
+                int targetPos = 0;
+                do {
+                    if (isEqual(Character.toLowerCase(source.charAt(begin)), target.charAt(0)))
+                        targetPos = 1;
+                } while (targetPos == 0 && ++begin < sourceLength);
+
+                int end = begin + 1;
+                for (; targetPos < target.length() && end < sourceLength; ++end) {
+                    char ch = source.charAt(end);
+                    if (!Character.isLetterOrDigit(ch))
+                        continue;
+                    if (!isEqual(Character.toLowerCase(ch), target.charAt(targetPos)))
+                        break;
+                    ++targetPos;
+                }
+
+                if (targetPos == target.length()) {
+                    lastRange = new Range(begin, end);
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        public boolean isEqual(char a, char b) {
+            if (Utilities.isKoreanCharacter(a) && Utilities.isKoreanChosung(b)) {
+                return Utilities.extractKoreanChosung(a) == b;
+            }
+            return a == b;
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Utilities.java b/TMessagesProj/src/main/java/org/telegram/messenger/Utilities.java
index 02815f5ca..3be19cb1f 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Utilities.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/Utilities.java
@@ -29,6 +29,7 @@
 import net.hockeyapp.android.UpdateManager;
 
 import org.telegram.android.LocaleController;
+import org.telegram.android.NameQuery;
 import org.telegram.ui.ApplicationLoader;
 
 import java.io.ByteArrayInputStream;
@@ -50,6 +51,9 @@
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Date;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import java.util.zip.GZIPInputStream;
@@ -73,6 +77,9 @@
     public static volatile DispatchQueue photoBookQueue = new DispatchQueue("photoBookQueue");
 
     final protected static char[] hexArray = "0123456789ABCDEF".toCharArray();
+    private static Set<Character.UnicodeBlock> CJK_UNICODE_BLOCK = null;
+    private static final char[] KOREAN_CHOSUNG_MAP = { 0x3131, 0x3132, 0x3134, 0x3137, 0x3138, 0x3139, 0x3141, 0x3142,
+            0x3143, 0x3145, 0x3146, 0x3147, 0x3148, 0x3149, 0x314a, 0x314b, 0x314c, 0x314d, 0x314e };
 
     public static ProgressDialog progressDialog;
 
@@ -640,46 +647,21 @@ public static File generatePicturePath() {
         return null;
     }
 
-    public static CharSequence generateSearchName(String name, String name2, String q) {
-        if (name == null && name2 == null) {
-            return "";
-        }
-        SpannableStringBuilder builder = new SpannableStringBuilder();
-        String wholeString = name;
-        if (wholeString == null || wholeString.length() == 0) {
-            wholeString = name2;
-        } else if (name2 != null && name2.length() != 0) {
-            wholeString += " " + name2;
-        }
-        wholeString = wholeString.trim();
-        String lower = " " + wholeString.toLowerCase();
-
-        int index = -1;
-        int lastIndex = 0;
-        while ((index = lower.indexOf(" " + q, lastIndex)) != -1) {
-            int idx = index - (index == 0 ? 0 : 1);
-            int end = q.length() + (index == 0 ? 0 : 1) + idx;
-
-            if (lastIndex != 0 && lastIndex != idx + 1) {
-                builder.append(wholeString.substring(lastIndex, idx));
-            } else if (lastIndex == 0 && idx != 0) {
-                builder.append(wholeString.substring(0, idx));
-            }
-
-            String query = wholeString.substring(idx, end);
-            if (query.startsWith(" ")) {
-                builder.append(" ");
-            }
-            query.trim();
-            builder.append(Html.fromHtml("<font color=\"#357aa8\">" + query + "</font>"));
-
-            lastIndex = end;
-        }
-
-        if (lastIndex != -1 && lastIndex != wholeString.length()) {
-            builder.append(wholeString.substring(lastIndex, wholeString.length()));
-        }
+    public static CharSequence generateSearchName(String str, List<NameQuery.Range> ranges) {
+        return generateSearchName(str, ranges, null);
+    }
 
+    public static CharSequence generateSearchName(String str, List<NameQuery.Range> ranges, String color) {
+        int start = 0;
+        SpannableStringBuilder builder = new SpannableStringBuilder();
+        if (color == null || color.length() != 7)
+            color = "#357aa8";
+        for (NameQuery.Range range : ranges) {
+            builder.append(str.substring(start, range.getBegin()));
+            builder.append(Html.fromHtml("<font color=\"" + color + "\">" + str.substring(range.getBegin(), range.getEnd()) + "</font>"));
+            start = range.getEnd();
+        }
+        builder.append(str.substring(start));
         return builder;
     }
 
@@ -743,4 +725,47 @@ public static void checkForUpdates(Activity context) {
             UpdateManager.register(context, BuildVars.HOCKEY_APP_HASH);
         }
     }
+
+    private static void buildCJKUnicodeBlock() {
+        CJK_UNICODE_BLOCK = new HashSet<Character.UnicodeBlock>() {{
+            add(Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS);
+            add(Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A);
+            add(Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B);
+            add(Character.UnicodeBlock.CJK_RADICALS_SUPPLEMENT);
+            add(Character.UnicodeBlock.KANGXI_RADICALS);
+            add(Character.UnicodeBlock.IDEOGRAPHIC_DESCRIPTION_CHARACTERS);
+            add(Character.UnicodeBlock.CJK_SYMBOLS_AND_PUNCTUATION);
+            add(Character.UnicodeBlock.ENCLOSED_CJK_LETTERS_AND_MONTHS);
+            add(Character.UnicodeBlock.CJK_COMPATIBILITY);
+            add(Character.UnicodeBlock.CJK_COMPATIBILITY_IDEOGRAPHS);
+            add(Character.UnicodeBlock.CJK_COMPATIBILITY_IDEOGRAPHS);
+            add(Character.UnicodeBlock.CJK_COMPATIBILITY_FORMS);
+            add(Character.UnicodeBlock.CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT);
+            add(Character.UnicodeBlock.HANGUL_SYLLABLES);
+            add(Character.UnicodeBlock.HANGUL_JAMO);
+            add(Character.UnicodeBlock.HANGUL_COMPATIBILITY_JAMO);
+            add(Character.UnicodeBlock.KATAKANA);
+            add(Character.UnicodeBlock.KATAKANA_PHONETIC_EXTENSIONS);
+            add(Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS);
+            add(Character.UnicodeBlock.HIRAGANA);
+        }};
+    }
+
+    public static boolean isCJKCharacter(int ch) {
+        if (CJK_UNICODE_BLOCK == null)
+            buildCJKUnicodeBlock();
+        return CJK_UNICODE_BLOCK.contains(Character.UnicodeBlock.of(ch));
+    }
+
+    public static boolean isKoreanCharacter(char ch) {
+        return (ch >= 0xac00 && ch <= 0xd7a3)|| (ch >= 0x3131 && ch <= 0x314e);
+    }
+
+    public static boolean isKoreanChosung(char ch) {
+        return (ch >= 0x3131 && ch <= 0x314e);
+    }
+
+    public static char extractKoreanChosung(char ch) {
+        return (ch >= 0xac00 && ch <= 0xd7a3) ? KOREAN_CHOSUNG_MAP[(ch - 0xac00) / 588] : 0;
+    }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/ContactsActivitySearchAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/ContactsActivitySearchAdapter.java
index c6fc1baf0..6bdacde82 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/ContactsActivitySearchAdapter.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/ContactsActivitySearchAdapter.java
@@ -13,6 +13,7 @@
 import android.view.ViewGroup;
 
 import org.telegram.android.AndroidUtilities;
+import org.telegram.android.NameQuery;
 import org.telegram.messenger.TLRPC;
 import org.telegram.android.ContactsController;
 import org.telegram.messenger.FileLog;
@@ -23,6 +24,7 @@
 
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Timer;
 import java.util.TimerTask;
 
@@ -76,23 +78,23 @@ public void run() {
                 Utilities.searchQueue.postRunnable(new Runnable() {
                     @Override
                     public void run() {
-                        String q = query.trim().toLowerCase();
-                        if (q.length() == 0) {
+                        if (query.trim().length() == 0) {
                             updateSearchResults(new ArrayList<TLRPC.User>(), new ArrayList<CharSequence>());
                             return;
                         }
-                        long time = System.currentTimeMillis();
                         ArrayList<TLRPC.User> resultArray = new ArrayList<TLRPC.User>();
                         ArrayList<CharSequence> resultArrayNames = new ArrayList<CharSequence>();
 
+                        NameQuery nameQuery = new NameQuery(query);
                         for (TLRPC.TL_contact contact : contactsCopy) {
                             TLRPC.User user = MessagesController.getInstance().getUser(contact.user_id);
-                            String name = ContactsController.formatName(user.first_name, user.last_name).toLowerCase();
-                            if (name.startsWith(q) || name.contains(" " + q)) {
+                            String name = ContactsController.formatName(user.first_name, user.last_name);
+                            List<NameQuery.Range> matched = nameQuery.match(name);
+                            if (!matched.isEmpty()) {
                                 if (user.id == UserConfig.getClientUserId()) {
                                     continue;
                                 }
-                                resultArrayNames.add(Utilities.generateSearchName(user.first_name, user.last_name, q));
+                                resultArrayNames.add(Utilities.generateSearchName(name, matched));
                                 resultArray.add(user);
                             }
                         }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/GroupCreateActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/GroupCreateActivity.java
index 52395ca14..066ef9642 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/GroupCreateActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/GroupCreateActivity.java
@@ -36,6 +36,7 @@
 import org.telegram.android.AndroidUtilities;
 import org.telegram.PhoneFormat.PhoneFormat;
 import org.telegram.android.LocaleController;
+import org.telegram.android.NameQuery;
 import org.telegram.messenger.TLRPC;
 import org.telegram.messenger.ConnectionsManager;
 import org.telegram.android.ContactsController;
@@ -54,6 +55,7 @@
 
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Timer;
 import java.util.TimerTask;
 
@@ -410,22 +412,23 @@ public void run() {
                 Utilities.searchQueue.postRunnable(new Runnable() {
                     @Override
                     public void run() {
-                        if (query.length() == 0) {
+                        if (query.trim().length() == 0) {
                             updateSearchResults(new ArrayList<TLRPC.User>(), new ArrayList<CharSequence>());
                             return;
                         }
-                        long time = System.currentTimeMillis();
                         ArrayList<TLRPC.User> resultArray = new ArrayList<TLRPC.User>();
                         ArrayList<CharSequence> resultArrayNames = new ArrayList<CharSequence>();
-                        String q = query.toLowerCase();
 
+                        NameQuery nameQuery = new NameQuery(query);
                         for (TLRPC.TL_contact contact : contactsCopy) {
                             TLRPC.User user = MessagesController.getInstance().getUser(contact.user_id);
-                            if (user.first_name.toLowerCase().startsWith(q) || user.last_name.toLowerCase().startsWith(q)) {
+                            String name = ContactsController.formatName(user.first_name, user.last_name);
+                            List<NameQuery.Range> matched = nameQuery.match(name);
+                            if (!matched.isEmpty()) {
                                 if (user.id == UserConfig.getClientUserId()) {
                                     continue;
                                 }
-                                resultArrayNames.add(Utilities.generateSearchName(user.first_name, user.last_name, q));
+                                resultArrayNames.add(Utilities.generateSearchName(name, matched));
                                 resultArray.add(user);
                             }
                         }
