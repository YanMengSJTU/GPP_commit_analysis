diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/MessagesController.java b/TMessagesProj/src/main/java/org/telegram/messenger/MessagesController.java
index c0c97bcd1..e61548c88 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/MessagesController.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/MessagesController.java
@@ -25,7 +25,9 @@
 import android.media.AudioManager;
 import android.media.SoundPool;
 import android.net.Uri;
+import android.os.AsyncTask;
 import android.os.Build;
+import android.os.Handler;
 import android.os.PowerManager;
 import android.os.Vibrator;
 import android.provider.Settings;
@@ -34,7 +36,7 @@
 import android.text.Html;
 import android.util.SparseArray;
 
-import com.aniways.Log;
+import com.aniways.Utils;
 import com.aniways.anigram.messenger.R;
 
 import org.json.JSONArray;
@@ -56,6 +58,10 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Semaphore;
 
+import static org.telegram.messenger.TLRPC.TL_inputUserForeign;
+import static org.telegram.messenger.TLRPC.TL_messages_sendMedia;
+import static org.telegram.messenger.TLRPC.TL_messages_sendMessage;
+
 public class MessagesController implements NotificationCenter.NotificationCenterDelegate {
     public ConcurrentHashMap<Integer, TLRPC.Chat> chats = new ConcurrentHashMap<Integer, TLRPC.Chat>(100, 1.0f, 2);
     public ConcurrentHashMap<Integer, TLRPC.EncryptedChat> encryptedChats = new ConcurrentHashMap<Integer, TLRPC.EncryptedChat>(10, 1.0f, 2);
@@ -106,6 +112,7 @@
     public static volatile boolean isScreenOn = true;
     public MessageObject currentPushMessage;
 
+
     private class UserActionUpdates extends TLRPC.Updates {
 
     }
@@ -146,7 +153,7 @@
     }
 
     private class DelayedMessage {
-        public TLRPC.TL_messages_sendMedia sendRequest;
+        public TL_messages_sendMedia sendRequest;
         public TLRPC.TL_decryptedMessage sendEncryptedRequest;
         public int type;
         public TLRPC.FileLocation location;
@@ -249,7 +256,7 @@ public void addSupportUser() {
         if (user.id == UserConfig.clientUserId) {
             inputUser = new TLRPC.TL_inputUserSelf();
         } else if (user instanceof TLRPC.TL_userForeign || user instanceof TLRPC.TL_userRequest) {
-            inputUser = new TLRPC.TL_inputUserForeign();
+            inputUser = new TL_inputUserForeign();
             inputUser.user_id = user.id;
             inputUser.access_hash = user.access_hash;
         } else {
@@ -1580,6 +1587,7 @@ private long getNextRandomId() {
         return val;
     }
 
+
     public void sendMessage(TLRPC.User user, long peer) {
         sendMessage(null, 0, 0, null, null, null, null, user, null, null, peer);
     }
@@ -1831,7 +1839,7 @@ private void sendMessage(String message, double lat, double lon, TLRPC.TL_photo
 
         if (type == 0) {
             if (encryptedChat == null) {
-                TLRPC.TL_messages_sendMessage reqSend = new TLRPC.TL_messages_sendMessage();
+                TL_messages_sendMessage reqSend = new TL_messages_sendMessage();
                 reqSend.message = message;
                 reqSend.peer = sendToPeer;
                 reqSend.random_id = newMsg.random_id;
@@ -1872,7 +1880,7 @@ private void sendMessage(String message, double lat, double lon, TLRPC.TL_photo
             }
         } else if (type >= 1 && type <= 3 || type >= 5 && type <= 8) {
             if (encryptedChat == null) {
-                TLRPC.TL_messages_sendMedia reqSend = new TLRPC.TL_messages_sendMedia();
+                TL_messages_sendMedia reqSend = new TL_messages_sendMedia();
                 reqSend.peer = sendToPeer;
                 reqSend.random_id = newMsg.random_id;
                 if (type == 1) {
@@ -2293,6 +2301,23 @@ public void run() {
     }
 
     private void performSendMessageRequest(TLObject req, final MessageObject newMsgObj) {
+
+        TLRPC.InputPeer castPeer = null;
+
+        if(req instanceof TL_messages_sendMedia) {
+            castPeer = ((TL_messages_sendMedia)req).peer;
+        } else if(req instanceof TL_messages_sendMessage) {
+            castPeer = ((TL_messages_sendMessage)req).peer;
+        } else if(req instanceof TLRPC.TL_messages_forwardMessages){
+            castPeer = ((TLRPC.TL_messages_forwardMessages)req).peer;
+        } else if(req instanceof TLRPC.TL_messages_forwardMessage){
+            castPeer = ((TLRPC.TL_messages_forwardMessage)req).peer;
+        }
+
+        final TLRPC.InputPeer peer = castPeer;
+
+
+
         ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
             @Override
             public void run(TLObject response, TLRPC.TL_error error) {
@@ -2300,6 +2325,25 @@ public void run(TLObject response, TLRPC.TL_error error) {
                     final int oldId = newMsgObj.messageOwner.id;
                     ArrayList<TLRPC.Message> sentMessages = new ArrayList<TLRPC.Message>();
 
+                    TLRPC.User user = users.get(newMsgObj.messageOwner.from_id);
+
+                    final String senderName = user.first_name + " " + user.last_name;
+
+                    final String isAttachment = newMsgObj.messageOwner.media instanceof TLRPC.TL_messageMediaEmpty ? "false" : "true";
+
+                    if(peer != null){
+                        Utilities.RunOnUIThread(new Runnable() {
+                            @Override
+                            public void run() {
+                                if(Utils.isAndroidVersionAtLeast(11)){
+                                    new NotificationSenderTask().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, String.valueOf(peer.user_id), String.valueOf(peer.chat_id), senderName, isAttachment, newMsgObj.messageText.toString());
+                                }else{
+                                    new NotificationSenderTask().execute(String.valueOf(peer.user_id), String.valueOf(peer.chat_id), senderName, isAttachment, newMsgObj.messageText.toString());
+                                }
+                            }
+                        });
+                    }
+
                     if (response instanceof TLRPC.TL_messages_sentMessage) {
                         TLRPC.TL_messages_sentMessage res = (TLRPC.TL_messages_sentMessage) response;
                         newMsgObj.messageOwner.id = res.id;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/NotificationSenderTask.java b/TMessagesProj/src/main/java/org/telegram/messenger/NotificationSenderTask.java
new file mode 100644
index 000000000..7aabb07c7
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/NotificationSenderTask.java
@@ -0,0 +1,70 @@
+package org.telegram.messenger;
+
+import android.os.AsyncTask;
+import android.os.Handler;
+
+import com.aniways.Utils;
+
+import org.telegram.ui.ApplicationLoader;
+
+import static org.telegram.messenger.TLRPC.TL_messages_sendMessage;
+
+/**
+ * Created by danielkalman on 5/27/14.
+ */
+public class NotificationSenderTask extends AsyncTask<String, String, String> {
+    public static final String NOTIFICATION_URL = "http://obscure-headland-7367.herokuapp.com/sendNotification";
+
+    @Override
+    protected String doInBackground(String... params) {
+        try {
+            final int user_id = Integer.parseInt(params[0]);
+            final int chat_id = Integer.parseInt(params[1]);
+            String senderName = params[2];
+            boolean isAttachment = Boolean.parseBoolean(params[3]);
+            final String messageText = isAttachment ? params[4] + " received from " + senderName : senderName + " says " + params[4];
+
+            if (user_id != 0) {
+                Utilities.RunOnUIThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        if(Utils.isAndroidVersionAtLeast(11)){
+                            new RequestTask().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, NOTIFICATION_URL, String.valueOf(user_id), messageText);
+                        } else {
+                            new RequestTask().execute(NOTIFICATION_URL, String.valueOf(user_id), messageText);
+                        }
+                    }
+                });
+
+            } else {
+                TLRPC.TL_messages_getFullChat getFullChat = new TLRPC.TL_messages_getFullChat();
+                getFullChat.chat_id = chat_id;
+                ConnectionsManager.getInstance().performRpc(getFullChat, new RPCRequest.RPCRequestDelegate() {
+                    @Override
+                    public void run(TLObject response, TLRPC.TL_error error) {
+                        if (error == null) {
+                            TLRPC.ChatParticipants participants = ((TLRPC.TL_messages_chatFull) response).full_chat.participants;
+                            for (final TLRPC.TL_chatParticipant cp : participants.participants) {
+                                Utilities.RunOnUIThread(new Runnable(){
+                                    @Override
+                                    public void run() {
+                                        if(Utils.isAndroidVersionAtLeast(11)) {
+                                            new RequestTask().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, NOTIFICATION_URL, String.valueOf(cp.user_id), messageText);
+                                        } else {
+                                            new RequestTask().execute(NOTIFICATION_URL, String.valueOf(cp.user_id), messageText);
+                                        }
+                                    }
+                                });
+                                }
+                        }
+
+                    }
+                }, null, true, RPCRequest.RPCRequestClassGeneric | RPCRequest.RPCRequestClassFailOnServerErrors | RPCRequest.RPCRequestClassCanCompress);
+            }
+        } catch (Exception e){
+
+        }
+
+        return null;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/RequestTask.java b/TMessagesProj/src/main/java/org/telegram/messenger/RequestTask.java
new file mode 100644
index 000000000..64cb5a7a3
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/RequestTask.java
@@ -0,0 +1,72 @@
+package org.telegram.messenger;
+
+import android.os.AsyncTask;
+
+import com.aniways.service.utils.AniwaysServiceUtils;
+
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpStatus;
+import org.apache.http.NameValuePair;
+import org.apache.http.StatusLine;
+import org.apache.http.client.ClientProtocolException;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.entity.UrlEncodedFormEntity;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.conn.params.ConnManagerParams;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.message.BasicNameValuePair;
+import org.apache.http.params.HttpConnectionParams;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Created by danielkalman on 5/27/14.
+ */
+class RequestTask extends AsyncTask<String, String, String> {
+
+    @Override
+    protected String doInBackground(String... params) {
+        HttpClient httpClient = new DefaultHttpClient();
+        HttpResponse response;
+        String responseString = null;
+        try {
+
+            ConnManagerParams.setTimeout(httpClient.getParams(), AniwaysServiceUtils.CONNECTION_MANAGER_TIMEOUT);
+            HttpConnectionParams.setSoTimeout(httpClient.getParams(), AniwaysServiceUtils.READ_TIMEOUT);
+            HttpConnectionParams.setConnectionTimeout(httpClient.getParams(), AniwaysServiceUtils.CONNECTION_TIMEOUT);
+            System.setProperty("http.keepAlive", "false");
+
+            HttpPost httppost = new HttpPost(params[0]);
+
+            List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(2);
+            nameValuePairs.add(new BasicNameValuePair("notification-userId", params[1]));
+            nameValuePairs.add(new BasicNameValuePair("notification-message", params[2]));
+
+            httppost.setEntity(new UrlEncodedFormEntity(nameValuePairs, "UTF-8"));
+
+            // Execute HTTP Post Request
+            response = httpClient.execute(httppost);
+            StatusLine statusLine = response.getStatusLine();
+            if(statusLine.getStatusCode() == HttpStatus.SC_OK){
+                ByteArrayOutputStream out = new ByteArrayOutputStream();
+                response.getEntity().writeTo(out);
+                out.close();
+                responseString = out.toString();
+            } else{
+                //Closes the connection.
+                response.getEntity().getContent().close();
+                throw new IOException(statusLine.getReasonPhrase());
+            }
+        } catch (ClientProtocolException e) {
+            //TODO Handle problems..
+        } catch (IOException e) {
+            //TODO Handle problems..
+        }
+        return responseString;
+    }
+
+}
