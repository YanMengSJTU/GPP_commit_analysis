diff --git a/TMessagesProj/src/main/java/org/telegram/android/ImageReceiver.java b/TMessagesProj/src/main/java/org/telegram/android/ImageReceiver.java
index 8290a5f8a..36a8d1d9d 100644
--- a/TMessagesProj/src/main/java/org/telegram/android/ImageReceiver.java
+++ b/TMessagesProj/src/main/java/org/telegram/android/ImageReceiver.java
@@ -22,10 +22,19 @@
 import android.graphics.drawable.Drawable;
 import android.view.View;
 
+import com.aniways.data.AniwaysPrivateConfig;
+import com.aniways.volley.VolleyError;
+import com.aniways.volley.toolbox.Volley;
+
 import org.telegram.messenger.TLObject;
 import org.telegram.messenger.TLRPC;
 import org.telegram.messenger.FileLog;
 import org.telegram.messenger.Utilities;
+import org.telegram.ui.Cells.ChatMediaCell;
+
+import java.io.IOException;
+
+import pl.droidsonroids.gif.GifDrawable;
 
 public class ImageReceiver {
     private TLObject last_path = null;
@@ -36,7 +45,7 @@
     private int last_size = 0;
     private String currentPath = null;
     private boolean isPlaceholder = false;
-    private Drawable currentImage = null;
+    public Drawable currentImage = null;
     private Integer tag = null;
     private View parentView = null;
     private int imageX = 0, imageY = 0, imageW = 0, imageH = 0;
@@ -76,89 +85,7 @@ public void setImage(String path, String filter, Drawable placeholder, int size)
     }
 
     public void setImage(TLObject fileLocation, String httpUrl, String filter, Drawable placeholder, TLRPC.FileLocation placeholderLocation, int size, boolean cacheOnly) {
-        if ((fileLocation == null && httpUrl == null) || (fileLocation != null && !(fileLocation instanceof TLRPC.TL_fileLocation) && !(fileLocation instanceof TLRPC.TL_fileEncryptedLocation) && !(fileLocation instanceof TLRPC.TL_document))) {
-            recycleBitmap(null);
-            currentPath = null;
-            isPlaceholder = true;
-            last_path = null;
-            last_httpUrl = null;
-            last_filter = null;
-            lastCacheOnly = false;
-            bitmapShader = null;
-            last_placeholder = placeholder;
-            last_placeholderLocation = placeholderLocation;
-            last_size = 0;
-            currentImage = null;
-            ImageLoader.getInstance().cancelLoadingForImageView(this);
-            if (parentView != null) {
-                parentView.invalidate();
-            }
-            return;
-        }
-        String key = null;
-        if (fileLocation != null) {
-            if (fileLocation instanceof TLRPC.FileLocation) {
-                TLRPC.FileLocation location = (TLRPC.FileLocation) fileLocation;
-                key = location.volume_id + "_" + location.local_id;
-            } else if (fileLocation instanceof TLRPC.Document) {
-                TLRPC.Document location = (TLRPC.Document) fileLocation;
-                key = location.dc_id + "_" + location.id;
-            }
-        } else {
-            key = Utilities.MD5(httpUrl);
-        }
-        if (filter != null) {
-            key += "@" + filter;
-        }
-        boolean sameFile = false;
-        BitmapDrawable img = null;
-        if (currentPath != null) {
-            if (currentPath.equals(key)) {
-                sameFile = true;
-                if (currentImage != null) {
-                    return;
-                } else {
-                    img = ImageLoader.getInstance().getImageFromMemory(fileLocation, httpUrl, filter, this);
-                }
-            } else {
-                img = ImageLoader.getInstance().getImageFromMemory(fileLocation, httpUrl, filter, this);
-                recycleBitmap(img);
-            }
-        }
-        img = ImageLoader.getInstance().getImageFromMemory(fileLocation, httpUrl, filter, this);
-        currentPath = key;
-        last_path = fileLocation;
-        last_httpUrl = httpUrl;
-        last_filter = filter;
-        if (!sameFile) {
-            last_placeholder = placeholder;
-            last_placeholderLocation = placeholderLocation;
-        }
-        last_size = size;
-        lastCacheOnly = cacheOnly;
-        bitmapShader = null;
-        if (img == null) {
-            isPlaceholder = true;
-            if (!sameFile && last_placeholderLocation != null && last_placeholder == null) {
-                last_placeholder = ImageLoader.getInstance().getImageFromMemory(last_placeholderLocation, null, null, null);
-                if (last_placeholder != null) {
-                    try {
-                        Bitmap bitmap = ((BitmapDrawable) last_placeholder).getBitmap();
-                        bitmap = bitmap.copy(bitmap.getConfig(), true);
-                        Utilities.blurBitmap(bitmap, 1);
-                        last_placeholder = new BitmapDrawable(bitmap);
-                    } catch (Exception e) {
-                        FileLog.e("tmessages", e);
-                    }
-                }
-            }
-            ImageLoader.getInstance().loadImage(fileLocation, httpUrl, this, size, cacheOnly);
-            if (parentView != null) {
-                parentView.invalidate();
-            }
-        } else {
-            setImageBitmap(img, currentPath);
-        }
+        setImage(fileLocation, httpUrl, filter, placeholder, placeholderLocation, size, cacheOnly, null);
     }
 
     public void setImageBitmap(BitmapDrawable bitmap, String imgKey) {
@@ -245,18 +172,24 @@ private void recycleBitmap(BitmapDrawable newBitmap) {
 
     public boolean draw(Canvas canvas) {
         try {
-            Drawable bitmapDrawable = currentImage;
-            if (forcePreview || bitmapDrawable == null && last_placeholder != null && last_placeholder instanceof BitmapDrawable) {
-                bitmapDrawable = last_placeholder;
+            Drawable drawable = currentImage;
+            if (forcePreview || drawable == null && last_placeholder != null && last_placeholder instanceof BitmapDrawable) {
+                drawable = last_placeholder;
             }
-            if (bitmapDrawable != null) {
-                Paint paint = ((BitmapDrawable) bitmapDrawable).getPaint();
+            if (drawable != null) {
+                Paint paint = null;
+                if(drawable instanceof GifDrawable) {
+                    paint = ((GifDrawable) drawable).getPaint();
+                }
+                else {
+                    paint = ((BitmapDrawable) drawable).getPaint();
+                }
                 boolean hasFilter = paint != null && paint.getColorFilter() != null;
                 if (hasFilter && !isPressed) {
-                    bitmapDrawable.setColorFilter(null);
+                    drawable.setColorFilter(null);
                     hasFilter = false;
                 } else if (!hasFilter && isPressed) {
-                    bitmapDrawable.setColorFilter(new PorterDuffColorFilter(0xffdddddd, PorterDuff.Mode.MULTIPLY));
+                    drawable.setColorFilter(new PorterDuffColorFilter(0xffdddddd, PorterDuff.Mode.MULTIPLY));
                     hasFilter = true;
                 }
                 if (bitmapShader != null) {
@@ -269,8 +202,8 @@ public boolean draw(Canvas canvas) {
                         canvas.drawRoundRect(roundRect, roundRadius, roundRadius, roundPaint);
                     }
                 } else {
-                    int bitmapW = bitmapDrawable.getIntrinsicWidth();
-                    int bitmapH = bitmapDrawable.getIntrinsicHeight();
+                    int bitmapW = drawable.getIntrinsicWidth();
+                    int bitmapH = drawable.getIntrinsicHeight();
                     float scaleW = bitmapW / (float) imageW;
                     float scaleH = bitmapH / (float) imageH;
 
@@ -280,10 +213,10 @@ public boolean draw(Canvas canvas) {
                         bitmapW /= scale;
                         bitmapH /= scale;
                         drawRegion.set(imageX + (imageW - bitmapW) / 2, imageY + (imageH - bitmapH) / 2, imageX + (imageW + bitmapW) / 2, imageY + (imageH + bitmapH) / 2);
-                        bitmapDrawable.setBounds(drawRegion);
+                        drawable.setBounds(drawRegion);
                         try {
-                            bitmapDrawable.setAlpha(alpha);
-                            bitmapDrawable.draw(canvas);
+                            drawable.setAlpha(alpha);
+                            drawable.draw(canvas);
                         } catch (Exception e) {
                             if (currentPath != null) {
                                 ImageLoader.getInstance().removeImage(currentPath);
@@ -305,11 +238,11 @@ public boolean draw(Canvas canvas) {
                                 bitmapH /= scaleW;
                                 drawRegion.set(imageX, imageY - (bitmapH - imageH) / 2, imageX + imageW, imageY + (bitmapH + imageH) / 2);
                             }
-                            bitmapDrawable.setBounds(drawRegion);
+                            drawable.setBounds(drawRegion);
                             if (isVisible) {
                                 try {
-                                    bitmapDrawable.setAlpha(alpha);
-                                    bitmapDrawable.draw(canvas);
+                                    drawable.setAlpha(alpha);
+                                    drawable.draw(canvas);
                                 } catch (Exception e) {
                                     if (currentPath != null) {
                                         ImageLoader.getInstance().removeImage(currentPath);
@@ -323,11 +256,11 @@ public boolean draw(Canvas canvas) {
                             canvas.restore();
                         } else {
                             drawRegion.set(imageX, imageY, imageX + imageW, imageY + imageH);
-                            bitmapDrawable.setBounds(drawRegion);
+                            drawable.setBounds(drawRegion);
                             if (isVisible) {
                                 try {
-                                    bitmapDrawable.setAlpha(alpha);
-                                    bitmapDrawable.draw(canvas);
+                                    drawable.setAlpha(alpha);
+                                    drawable.draw(canvas);
                                 } catch (Exception e) {
                                     if (currentPath != null) {
                                         ImageLoader.getInstance().removeImage(currentPath);
@@ -475,4 +408,162 @@ public void setRoundRadius(int value) {
     public int getRoundRadius() {
         return roundRadius;
     }
+
+    public void setImage(TLObject fileLocation, String httpUrl, String filter, Drawable placeholder, TLRPC.FileLocation placeholderLocation, int size, boolean cacheOnly, final ChatMediaCell chatMediaCell) {
+        if ((fileLocation == null && httpUrl == null) || (fileLocation != null && !(fileLocation instanceof TLRPC.TL_fileLocation) && !(fileLocation instanceof TLRPC.TL_fileEncryptedLocation) && !(fileLocation instanceof TLRPC.TL_document))) {
+            recycleBitmap(null);
+            currentPath = null;
+            isPlaceholder = true;
+            last_path = null;
+            last_httpUrl = null;
+            last_filter = null;
+            lastCacheOnly = false;
+            bitmapShader = null;
+            last_placeholder = placeholder;
+            last_placeholderLocation = placeholderLocation;
+            last_size = 0;
+            currentImage = null;
+            ImageLoader.getInstance().cancelLoadingForImageView(this);
+            if (parentView != null) {
+                parentView.invalidate();
+            }
+            return;
+        }
+        String key = null;
+        if (fileLocation != null) {
+            if (fileLocation instanceof TLRPC.FileLocation) {
+                TLRPC.FileLocation location = (TLRPC.FileLocation) fileLocation;
+                key = location.volume_id + "_" + location.local_id;
+            } else if (fileLocation instanceof TLRPC.Document) {
+                TLRPC.Document location = (TLRPC.Document) fileLocation;
+                key = location.dc_id + "_" + location.id;
+            }
+        } else {
+            key = Utilities.MD5(httpUrl);
+        }
+        if (filter != null) {
+            key += "@" + filter;
+        }
+        boolean sameFile = false;
+        BitmapDrawable img = null;
+        if (currentPath != null) {
+            if (currentPath.equals(key)) {
+                sameFile = true;
+                if (currentImage != null) {
+                    return;
+                } else {
+                    img = ImageLoader.getInstance().getImageFromMemory(fileLocation, httpUrl, filter, this);
+                }
+            } else {
+                img = ImageLoader.getInstance().getImageFromMemory(fileLocation, httpUrl, filter, this);
+                recycleBitmap(img);
+            }
+        }
+        byte[] data = null;
+        GifDrawable gif = null;
+        if(httpUrl != null && httpUrl.endsWith(".gif")) {
+            data = (byte[])Volley.getImageLoader().getCached(httpUrl, AniwaysPrivateConfig.getInstance().bigIconWidth, AniwaysPrivateConfig.getInstance().bigIconHeight, httpUrl);
+            if(data != null){
+                try {
+                    gif = new GifDrawable(data);
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+        else {
+            img = ImageLoader.getInstance().getImageFromMemory(fileLocation, httpUrl, filter, this);
+        }
+        currentPath = key;
+        last_path = fileLocation;
+        last_httpUrl = httpUrl;
+        last_filter = filter;
+        if (!sameFile) {
+            last_placeholder = placeholder;
+            last_placeholderLocation = placeholderLocation;
+        }
+        last_size = size;
+        lastCacheOnly = cacheOnly;
+        bitmapShader = null;
+        if(httpUrl != null && httpUrl.endsWith(".gif")) {
+            if(gif == null){
+                Volley.getImageLoader().get(httpUrl, new com.aniways.volley.toolbox.ImageLoader.ImageListener() {
+                    @Override
+                    public void onResponse(com.aniways.volley.toolbox.ImageLoader.ImageContainer response, boolean isImmediate) {
+                        byte[] data = (byte[])response.getRawData();
+                        if(data != null){
+                            try {
+                                //TODO: make the reference to the chatMediaCell weak..
+                                //gif.parentView = new WeakReference<View>(chatMediaCell);
+                                GifDrawable gif = new GifDrawable(data);
+                                currentImage = gif;
+                                //TODO: need to know when to saver this link to no leak memory and tax CPU with endless animation
+                            } catch (IOException e) {
+                                e.printStackTrace();
+                            }
+                        }
+                        else{
+                            //TODO: Log
+                        }
+                    }
+
+                    @Override
+                    public void onErrorResponse(VolleyError error) {
+                        //TODO: log
+                    }
+                });
+
+                isPlaceholder = true;
+                if (!sameFile && last_placeholderLocation != null && last_placeholder == null) {
+                    last_placeholder = ImageLoader.getInstance().getImageFromMemory(last_placeholderLocation, null, null, null);
+                    if (last_placeholder != null) {
+                        try {
+                            Bitmap bitmap = ((BitmapDrawable) last_placeholder).getBitmap();
+                            bitmap = bitmap.copy(bitmap.getConfig(), true);
+                            Utilities.blurBitmap(bitmap, 1);
+                            last_placeholder = new BitmapDrawable(bitmap);
+                        } catch (Exception e) {
+                            FileLog.e("tmessages", e);
+                        }
+                    }
+                }
+                //ImageLoader.getInstance().loadImage(fileLocation, httpUrl, this, size, cacheOnly);
+                if (parentView != null) {
+                    parentView.invalidate();
+                }
+            }
+            else{
+                //TODO: need to know when to saver this link to no leak memory and tax CPU with endless animation
+                //TODO: make the reference to the chatMediaCell weak..
+                //gif.parentView = new WeakReference<View>(chatMediaCell);
+
+
+                currentImage = gif;
+            }
+        }
+        else {
+            if (img == null) {
+                isPlaceholder = true;
+                if (!sameFile && last_placeholderLocation != null && last_placeholder == null) {
+                    last_placeholder = ImageLoader.getInstance().getImageFromMemory(last_placeholderLocation, null, null, null);
+                    if (last_placeholder != null) {
+                        try {
+                            Bitmap bitmap = ((BitmapDrawable) last_placeholder).getBitmap();
+                            bitmap = bitmap.copy(bitmap.getConfig(), true);
+                            Utilities.blurBitmap(bitmap, 1);
+                            last_placeholder = new BitmapDrawable(bitmap);
+                        } catch (Exception e) {
+                            FileLog.e("tmessages", e);
+                        }
+                    }
+                }
+                ImageLoader.getInstance().loadImage(fileLocation, httpUrl, this, size, cacheOnly);
+                if (parentView != null) {
+                    parentView.invalidate();
+                }
+            } else {
+                setImageBitmap(img, currentPath);
+            }
+        }
+    }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/android/MessageObject.java b/TMessagesProj/src/main/java/org/telegram/android/MessageObject.java
index a19c6db0f..0c08ad803 100644
--- a/TMessagesProj/src/main/java/org/telegram/android/MessageObject.java
+++ b/TMessagesProj/src/main/java/org/telegram/android/MessageObject.java
@@ -31,6 +31,7 @@
 import com.aniways.IAniwaysTextContainer;
 import com.aniways.Log;
 import com.aniways.anigram.messenger.R;
+
 import org.telegram.messenger.UserConfig;
 import org.telegram.ui.Components.URLSpanNoUnderline;
 
@@ -67,6 +68,25 @@
     public int textWidth;
     public int textHeight;
     public int blockHeight = Integer.MAX_VALUE;
+    public Boolean isAniwaysSticker = null;
+    private String aniwaysStickerAttachPath;
+
+    public boolean isAniwaysSticker() {
+        if(isAniwaysSticker != null){
+            return isAniwaysSticker;
+        }
+
+        isAniwaysSticker = false;
+        String url = Aniways.getAniwaysStickerUrl(this.messageText);
+        if(url == null){
+            return isAniwaysSticker;
+        }
+
+        this.messageOwner.attachPath = url;
+        aniwaysStickerAttachPath = this.messageOwner.attachPath;
+        isAniwaysSticker = true;
+        return isAniwaysSticker;
+    }
 
     public static class TextLayoutBlock {
         public StaticLayout textLayout;
@@ -332,7 +352,8 @@ public MessageObject(TLRPC.Message message, AbstractMap<Integer, TLRPC.User> use
                         type = 8;
                     } else if (message.media.document.mime_type.equals("image/webp") && isSticker()) {
                         type = 13;
-                    } else {
+                    }
+                    else {
                         type = 9;
                     }
                 } else {
@@ -361,6 +382,12 @@ public MessageObject(TLRPC.Message message, AbstractMap<Integer, TLRPC.User> use
             }
         }
 
+        if(type == 0 && contentType == 0 && isAniwaysSticker()){
+            type = 13;
+            contentType = 1;
+            this.messageOwner.attachPath = aniwaysStickerAttachPath;
+        }
+
         Calendar rightNow = new GregorianCalendar();
         rightNow.setTimeInMillis((long)(messageOwner.date) * 1000);
         int dateDay = rightNow.get(Calendar.DAY_OF_YEAR);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMediaCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMediaCell.java
index 8313789c0..3765427b7 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMediaCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMediaCell.java
@@ -15,6 +15,8 @@
 import android.graphics.RectF;
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
+import android.os.Handler;
+import android.os.Looper;
 import android.text.Layout;
 import android.text.StaticLayout;
 import android.text.TextPaint;
@@ -30,6 +32,8 @@
 import org.telegram.messenger.FileLoader;
 import org.telegram.android.MediaController;
 import com.aniways.anigram.messenger.R;
+import com.aniways.data.AniwaysPrivateConfig;
+
 import org.telegram.messenger.TLRPC;
 import org.telegram.messenger.Utilities;
 import org.telegram.android.MessageObject;
@@ -157,6 +161,14 @@ public void setMediaDelegate(ChatMediaCellDelegate delegate) {
     @Override
     protected void onDetachedFromWindow() {
         super.onDetachedFromWindow();
+
+        if(photoImage != null && photoImage.currentImage != null && photoImage.currentImage instanceof pl.droidsonroids.gif.GifDrawable) {
+            photoImage.currentImage.setCallback(null);
+            pl.droidsonroids.gif.GifDrawable gif = (pl.droidsonroids.gif.GifDrawable)photoImage.currentImage;
+            gif.stop();
+            gif.recycle();
+        }
+
         if (photoImage != null) {
             photoImage.clearImage();
             currentPhotoObject = null;
@@ -526,11 +538,18 @@ public void setMessageObject(MessageObject messageObject) {
                 photoImage.setImage(currentUrl, null, null, 0);
             } else if (messageObject.type == 13) {
                 drawBackground = false;
-                for (TLRPC.DocumentAttribute attribute : messageObject.messageOwner.media.document.attributes) {
-                    if (attribute instanceof TLRPC.TL_documentAttributeImageSize) {
-                        photoWidth = attribute.w;
-                        photoHeight = attribute.h;
-                        break;
+                if(messageObject.isAniwaysSticker()) {
+                    photoWidth = AniwaysPrivateConfig.getInstance().bigIconWidth;
+                    photoHeight = AniwaysPrivateConfig.getInstance().bigIconHeight;
+                    photoImage.setAspectFit(true);
+                }
+                else{
+                    for (TLRPC.DocumentAttribute attribute : messageObject.messageOwner.media.document.attributes) {
+                        if (attribute instanceof TLRPC.TL_documentAttributeImageSize) {
+                            photoWidth = attribute.w;
+                            photoHeight = attribute.h;
+                            break;
+                        }
                     }
                 }
                 float maxWidth;
@@ -557,6 +576,14 @@ public void setMessageObject(MessageObject messageObject) {
                                 null,
                                 currentMessageObject.messageOwner.media.document.size, true);
                     }
+                    else if(messageObject.isAniwaysSticker()) {
+                        photoImage.setImage(null, currentMessageObject.messageOwner.attachPath,
+                                String.format(Locale.US, "%d_%d", photoWidth, photoHeight),
+                                messageObject.imagePreview != null ? new BitmapDrawable(messageObject.imagePreview) : null,
+                                null,
+                                6556, true, this); //TODO: Get better size estimation
+
+                    }
                 } else if (currentMessageObject.messageOwner.media.document.id != 0) {
                     photoImage.setImage(currentMessageObject.messageOwner.media.document, null,
                             String.format(Locale.US, "%d_%d", photoWidth, photoHeight),
@@ -831,6 +858,28 @@ public void setAllowedToSetPhoto(boolean value) {
         }
     }
 
+    Drawable.Callback aniwaysGifCallback = new Drawable.Callback() {
+        ChatMediaCell chatMediaCell = ChatMediaCell.this;
+        Handler mHandler = new Handler(Looper.getMainLooper());
+
+        @Override
+        public void invalidateDrawable(Drawable who) {
+            if(chatMediaCell != null){
+                chatMediaCell.invalidate();
+            }
+        }
+
+        @Override
+        public void scheduleDrawable(Drawable who, Runnable what, long when) {
+            mHandler.postAtTime(what, who, when);
+        }
+
+        @Override
+        public void unscheduleDrawable(Drawable who, Runnable what) {
+            mHandler.removeCallbacks(what, who);
+        }
+    };
+
     @Override
     protected void onAfterBackgroundDraw(Canvas canvas) {
         boolean imageDrawn = false;
@@ -842,6 +891,11 @@ protected void onAfterBackgroundDraw(Canvas canvas) {
         } else {
             photoImage.setPressed(isPressed() && isCheckPressed || !isCheckPressed && isPressed);
             photoImage.setVisible(!PhotoViewer.getInstance().isShowingImage(currentMessageObject), false);
+            if (photoImage.currentImage instanceof pl.droidsonroids.gif.GifDrawable){
+                if(photoImage.currentImage.getCallback() != aniwaysGifCallback) {
+                    photoImage.currentImage.setCallback(aniwaysGifCallback);
+                }
+            }
             imageDrawn = photoImage.draw(canvas);
             drawTime = photoImage.getVisible();
         }
