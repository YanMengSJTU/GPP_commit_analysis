diff --git a/TMessagesProj/jni/gifvideo.cpp b/TMessagesProj/jni/gifvideo.cpp
index 39c1d6fdd..ec24b0b3e 100644
--- a/TMessagesProj/jni/gifvideo.cpp
+++ b/TMessagesProj/jni/gifvideo.cpp
@@ -251,7 +251,7 @@ int64_t seekCallback(void *opaque, int64_t offset, int whence) {
 }
 
 enum PARAM_NUM {
-    PARAM_NUM_IS_AVC = 0,
+    PARAM_NUM_SUPPORTED_VIDEO_CODEC = 0,
     PARAM_NUM_WIDTH = 1,
     PARAM_NUM_HEIGHT = 2,
     PARAM_NUM_BITRATE = 3,
@@ -260,12 +260,12 @@ enum PARAM_NUM {
     PARAM_NUM_VIDEO_FRAME_SIZE = 6,
     PARAM_NUM_FRAMERATE = 7,
     PARAM_NUM_ROTATION = 8,
-    PARAM_NUM_AUDIO_SUPPORTED_CODEC = 9,
+    PARAM_NUM_SUPPORTED_AUDIO_CODEC = 9,
     PARAM_NUM_HAS_AUDIO = 10,
     PARAM_NUM_COUNT = 11,
 };
 
-void Java_org_telegram_ui_Components_AnimatedFileDrawable_getVideoInfo(JNIEnv *env, jclass clazz, jstring src, jintArray data) {
+void Java_org_telegram_ui_Components_AnimatedFileDrawable_getVideoInfo(JNIEnv *env, jclass clazz,jint sdkVersion, jstring src, jintArray data) {
     VideoInfo *info = new VideoInfo();
 
     char const *srcString = env->GetStringUTFChars(src, 0);
@@ -306,21 +306,41 @@ void Java_org_telegram_ui_Components_AnimatedFileDrawable_getVideoInfo(JNIEnv *e
 
     jint *dataArr = env->GetIntArrayElements(data, 0);
     if (dataArr != nullptr) {
-        dataArr[PARAM_NUM_IS_AVC] = info->video_stream->codecpar->codec_id == AV_CODEC_ID_H264;
-        if (strstr(info->fmt_ctx->iformat->name, "mov") != 0 && dataArr[PARAM_NUM_IS_AVC]) {
+        //https://developer.android.com/guide/topics/media/media-formats
+        dataArr[PARAM_NUM_SUPPORTED_VIDEO_CODEC] =
+                info->video_stream->codecpar->codec_id == AV_CODEC_ID_H264 ||
+                info->video_stream->codecpar->codec_id == AV_CODEC_ID_H263 ||
+                info->video_stream->codecpar->codec_id == AV_CODEC_ID_MPEG4 ||
+                info->video_stream->codecpar->codec_id == AV_CODEC_ID_VP8 ||
+                info->video_stream->codecpar->codec_id == AV_CODEC_ID_VP9 ||
+                (sdkVersion > 21 && info->video_stream->codecpar->codec_id == AV_CODEC_ID_HEVC);
+
+        if (strstr(info->fmt_ctx->iformat->name, "mov") != 0 && dataArr[PARAM_NUM_SUPPORTED_VIDEO_CODEC]) {
             MOVStreamContext *mov = (MOVStreamContext *) info->video_stream->priv_data;
             dataArr[PARAM_NUM_VIDEO_FRAME_SIZE] = (jint) mov->data_size;
 
             if (info->audio_stream != nullptr) {
                 mov = (MOVStreamContext *) info->audio_stream->priv_data;
                 dataArr[PARAM_NUM_AUDIO_FRAME_SIZE] = (jint) mov->data_size;
-                dataArr[PARAM_NUM_AUDIO_SUPPORTED_CODEC] =
-                        info->audio_stream->codecpar->codec_id == AV_CODEC_ID_AAC ||
-                        info->audio_stream->codecpar->codec_id == AV_CODEC_ID_AAC_LATM;
             }
+        }
 
-            dataArr[PARAM_NUM_HAS_AUDIO] = info->audio_stream != nullptr;
+        if (info->audio_stream != nullptr) {
+            //https://developer.android.com/guide/topics/media/media-formats
+            dataArr[PARAM_NUM_SUPPORTED_AUDIO_CODEC] =
+                    info->audio_stream->codecpar->codec_id == AV_CODEC_ID_AAC ||
+                    info->audio_stream->codecpar->codec_id == AV_CODEC_ID_AAC_LATM ||
+                    info->audio_stream->codecpar->codec_id == AV_CODEC_ID_VORBIS ||
+                    info->audio_stream->codecpar->codec_id == AV_CODEC_ID_AMR_NB ||
+                    info->audio_stream->codecpar->codec_id == AV_CODEC_ID_AMR_WB ||
+                    info->audio_stream->codecpar->codec_id == AV_CODEC_ID_FLAC ||
+                    info->audio_stream->codecpar->codec_id == AV_CODEC_ID_MP3 ||
+                    (sdkVersion > 21 && info->audio_stream->codecpar->codec_id == AV_CODEC_ID_OPUS);
+            dataArr[PARAM_NUM_HAS_AUDIO] = 1;
+        } else {
+            dataArr[PARAM_NUM_HAS_AUDIO] = 0;
         }
+
         dataArr[PARAM_NUM_BITRATE] = (jint) info->video_stream->codecpar->bit_rate;
         dataArr[PARAM_NUM_WIDTH] = info->video_stream->codecpar->width;
         dataArr[PARAM_NUM_HEIGHT] = info->video_stream->codecpar->height;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/AudioTranscoder.java b/TMessagesProj/src/main/java/org/telegram/messenger/AudioTranscoder.java
new file mode 100644
index 000000000..13fe03d0c
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/AudioTranscoder.java
@@ -0,0 +1,210 @@
+package org.telegram.messenger;
+
+import android.media.MediaCodec;
+import android.media.MediaExtractor;
+import android.media.MediaFormat;
+
+import org.telegram.messenger.video.MP4Builder;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+public class AudioTranscoder {
+
+    private ByteBuffer[] decoderInputBuffers;
+    private ByteBuffer[] decoderOutputBuffers;
+    private ByteBuffer[] encoderInputBuffers;
+    private ByteBuffer[] encoderOutputBuffers;
+    private final MediaCodec.BufferInfo decoderOutputBufferInfo = new MediaCodec.BufferInfo();
+    private final MediaCodec.BufferInfo encoderOutputBufferInfo = new MediaCodec.BufferInfo();
+    private final MediaCodec decoder;
+    private final MediaCodec encoder;
+    private final MediaExtractor extractor;
+
+
+    private boolean extractorDone = false;
+    private boolean decoderDone = false;
+    private boolean encoderDone = false;
+
+    private int pendingAudioDecoderOutputBufferIndex = -1;
+
+    private final int trackIndex;
+
+    private final int TIMEOUT_USEC = 2500;
+
+    public long startTime = 0;
+    public long endTime = 0;
+
+    public AudioTranscoder(MediaFormat inputAudioFormat, MediaExtractor extractor, int trackIndex) throws IOException {
+        this.extractor = extractor;
+        this.trackIndex = trackIndex;
+
+        decoder = MediaCodec.createDecoderByType(inputAudioFormat.getString(MediaFormat.KEY_MIME));
+        decoder.configure(inputAudioFormat, null, null, 0);
+        decoder.start();
+
+
+        encoder = MediaCodec.createEncoderByType(MediaController.AUIDO_MIME_TYPE);
+        MediaFormat Format = MediaFormat.createAudioFormat(MediaController.AUIDO_MIME_TYPE,
+                inputAudioFormat.getInteger(MediaFormat.KEY_SAMPLE_RATE),
+                inputAudioFormat.getInteger(MediaFormat.KEY_CHANNEL_COUNT)
+        );
+        Format.setInteger(MediaFormat.KEY_BIT_RATE, 64 * 1024);
+        encoder.configure(Format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);
+        encoder.start();
+
+
+        decoderInputBuffers = decoder.getInputBuffers();
+        decoderOutputBuffers = decoder.getOutputBuffers();
+        encoderInputBuffers = encoder.getInputBuffers();
+        encoderOutputBuffers = encoder.getOutputBuffers();
+    }
+
+    public void release() {
+        try {
+            encoder.stop();
+            decoder.stop();
+            extractor.unselectTrack(trackIndex);
+            extractor.release();
+        } catch (Exception e) {
+            FileLog.e(e);
+        }
+    }
+
+    public boolean step(MP4Builder muxer, int audioTrackIndex) throws Exception {
+        while (!extractorDone) {
+            int decoderInputBufferIndex = decoder.dequeueInputBuffer(TIMEOUT_USEC);
+            if (decoderInputBufferIndex == MediaCodec.INFO_TRY_AGAIN_LATER) {
+                break;
+            }
+
+            ByteBuffer decoderInputBuffer;
+            if (android.os.Build.VERSION.SDK_INT >= 21) {
+                decoderInputBuffer = decoder.getInputBuffer(decoderInputBufferIndex);
+            } else {
+                decoderInputBuffer = decoderInputBuffers[decoderInputBufferIndex];
+            }
+            int size = extractor.readSampleData(decoderInputBuffer, 0);
+
+            long presentationTime = extractor.getSampleTime();
+            if (endTime > 0 && presentationTime >= endTime) {
+                encoderDone = true;
+                decoderOutputBufferInfo.flags |= MediaCodec.BUFFER_FLAG_END_OF_STREAM;
+            }
+            if (size >= 0) {
+                decoder.queueInputBuffer(
+                        decoderInputBufferIndex,
+                        0,
+                        size,
+                        extractor.getSampleTime(),
+                        extractor.getSampleFlags());
+            }
+
+            extractorDone = !extractor.advance();
+            if (extractorDone) {
+                decoder.queueInputBuffer(
+                        decoderInputBufferIndex,
+                        0,
+                        0,
+                        0,
+                        MediaCodec.BUFFER_FLAG_END_OF_STREAM);
+            }
+            break;
+        }
+
+        while (!decoderDone && pendingAudioDecoderOutputBufferIndex == -1) {
+            int decoderOutputBufferIndex =
+                    decoder.dequeueOutputBuffer(
+                            decoderOutputBufferInfo, TIMEOUT_USEC);
+            if (decoderOutputBufferIndex == MediaCodec.INFO_TRY_AGAIN_LATER) {
+                break;
+            }
+            if (decoderOutputBufferIndex == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
+                decoderOutputBuffers = decoder.getOutputBuffers();
+                break;
+            }
+            if (decoderOutputBufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
+                break;
+            }
+
+            if ((decoderOutputBufferInfo.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG)
+                    != 0) {
+
+                decoder.releaseOutputBuffer(decoderOutputBufferIndex, false);
+                break;
+            }
+            pendingAudioDecoderOutputBufferIndex = decoderOutputBufferIndex;
+
+            break;
+        }
+
+        while (pendingAudioDecoderOutputBufferIndex != -1) {
+            int encoderInputBufferIndex = encoder.dequeueInputBuffer(TIMEOUT_USEC);
+            if (encoderInputBufferIndex == MediaCodec.INFO_TRY_AGAIN_LATER) {
+                break;
+            }
+
+            ByteBuffer encoderInputBuffer = encoderInputBuffers[encoderInputBufferIndex];
+            int size = decoderOutputBufferInfo.size;
+            long presentationTime = decoderOutputBufferInfo.presentationTimeUs;
+            if (size >= 0) {
+                ByteBuffer decoderOutputBuffer =
+                        decoderOutputBuffers[pendingAudioDecoderOutputBufferIndex]
+                                .duplicate();
+                decoderOutputBuffer.position(decoderOutputBufferInfo.offset);
+                decoderOutputBuffer.limit(decoderOutputBufferInfo.offset + size);
+                encoderInputBuffer.position(0);
+                encoderInputBuffer.put(decoderOutputBuffer);
+                encoder.queueInputBuffer(
+                        encoderInputBufferIndex,
+                        0,
+                        size,
+                        presentationTime,
+                        decoderOutputBufferInfo.flags);
+            }
+            decoder.releaseOutputBuffer(pendingAudioDecoderOutputBufferIndex, false);
+            pendingAudioDecoderOutputBufferIndex = -1;
+            if ((decoderOutputBufferInfo.flags
+                    & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
+                decoderDone = true;
+            }
+            break;
+        }
+
+        while (!encoderDone) {
+            int encoderOutputBufferIndex = encoder.dequeueOutputBuffer(
+                    encoderOutputBufferInfo, TIMEOUT_USEC);
+            if (encoderOutputBufferIndex == MediaCodec.INFO_TRY_AGAIN_LATER) {
+                break;
+            }
+            if (encoderOutputBufferIndex == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
+                encoderOutputBuffers = encoder.getOutputBuffers();
+                break;
+            }
+            if (encoderOutputBufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
+
+                break;
+            }
+
+            ByteBuffer encoderOutputBuffer =
+                    encoderOutputBuffers[encoderOutputBufferIndex];
+            if ((encoderOutputBufferInfo.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG)
+                    != 0) {
+                encoder.releaseOutputBuffer(encoderOutputBufferIndex, false);
+                break;
+            }
+
+            if (encoderOutputBufferInfo.size != 0) {
+                muxer.writeSampleData(audioTrackIndex, encoderOutputBuffer, encoderOutputBufferInfo, false);
+            }
+            if ((encoderOutputBufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM)
+                    != 0) {
+                encoderDone = true;
+            }
+            encoder.releaseOutputBuffer(encoderOutputBufferIndex, false);
+            break;
+        }
+
+        return encoderDone;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/MediaController.java b/TMessagesProj/src/main/java/org/telegram/messenger/MediaController.java
index 07a6a367c..e7960bbca 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/MediaController.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/MediaController.java
@@ -55,6 +55,7 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ui.AspectRatioFrameLayout;
+import com.google.android.exoplayer2.util.Log;
 
 import org.telegram.messenger.audioinfo.AudioInfo;
 import org.telegram.messenger.video.InputSurface;
@@ -296,7 +297,8 @@ public String getPathToAttach() {
         }
     }
 
-    public final static String MIME_TYPE = "video/avc";
+    public final static String VIDEO_MIME_TYPE = "video/avc";
+    public final static String AUIDO_MIME_TYPE = "audio/mp4a-latm";
     private final static int PROCESSOR_TYPE_OTHER = 0;
     private final static int PROCESSOR_TYPE_QCOM = 1;
     private final static int PROCESSOR_TYPE_INTEL = 2;
@@ -3853,6 +3855,11 @@ private boolean convertVideo(final MessageObject messageObject, int timoutUsec)
                 if (resultWidth != originalWidth || resultHeight != originalHeight || rotateRender != 0 || messageObject.videoEditedInfo.roundVideo || Build.VERSION.SDK_INT >= 18 && startTime != -1) {
                     int videoIndex = findTrack(extractor, false);
                     int audioIndex = bitrate != -1 ? findTrack(extractor, true) : -1;
+
+                    AudioTranscoder audioTranscoder = null;
+                    ByteBuffer audioBuffer = null;
+                    boolean copyAudioBuffer = true;
+
                     if (videoIndex >= 0) {
                         MediaCodec decoder = null;
                         MediaCodec encoder = null;
@@ -3872,8 +3879,8 @@ private boolean convertVideo(final MessageObject messageObject, int timoutUsec)
                             int processorType = PROCESSOR_TYPE_OTHER;
                             String manufacturer = Build.MANUFACTURER.toLowerCase();
                             if (Build.VERSION.SDK_INT < 18) {
-                                MediaCodecInfo codecInfo = selectCodec(MIME_TYPE);
-                                colorFormat = selectColorFormat(codecInfo, MIME_TYPE);
+                                MediaCodecInfo codecInfo = selectCodec(VIDEO_MIME_TYPE);
+                                colorFormat = selectColorFormat(codecInfo, VIDEO_MIME_TYPE);
                                 if (colorFormat == 0) {
                                     throw new RuntimeException("no supported color format");
                                 }
@@ -3936,14 +3943,6 @@ private boolean convertVideo(final MessageObject messageObject, int timoutUsec)
 
                             extractor.selectTrack(videoIndex);
                             MediaFormat videoFormat = extractor.getTrackFormat(videoIndex);
-                            ByteBuffer audioBuffer = null;
-                            if (audioIndex >= 0) {
-                                extractor.selectTrack(audioIndex);
-                                MediaFormat audioFormat = extractor.getTrackFormat(audioIndex);
-                                int maxBufferSize = audioFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE);
-                                audioBuffer = ByteBuffer.allocateDirect(maxBufferSize);
-                                audioTrackIndex = mediaMuxer.addTrack(audioFormat, true);
-                            }
 
                             if (startTime > 0) {
                                 extractor.seekTo(startTime, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
@@ -3951,7 +3950,7 @@ private boolean convertVideo(final MessageObject messageObject, int timoutUsec)
                                 extractor.seekTo(0, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
                             }
 
-                            MediaFormat outputFormat = MediaFormat.createVideoFormat(MIME_TYPE, resultWidth, resultHeight);
+                            MediaFormat outputFormat = MediaFormat.createVideoFormat(VIDEO_MIME_TYPE, resultWidth, resultHeight);
                             outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, colorFormat);
                             outputFormat.setInteger(MediaFormat.KEY_BIT_RATE, bitrate);
                             outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE, framerate);
@@ -3975,11 +3974,11 @@ private boolean convertVideo(final MessageObject messageObject, int timoutUsec)
                                     level = MediaCodecInfo.CodecProfileLevel.AVCLevel3;
                                 }
 
-                                MediaCodecInfo.CodecCapabilities capabilities = MediaCodecInfo.CodecCapabilities.createFromProfileLevel(MIME_TYPE, profile, level);
+                                MediaCodecInfo.CodecCapabilities capabilities = MediaCodecInfo.CodecCapabilities.createFromProfileLevel(VIDEO_MIME_TYPE, profile, level);
 
                                 if(capabilities == null && profile == MediaCodecInfo.CodecProfileLevel.AVCProfileHigh){
                                     profile = MediaCodecInfo.CodecProfileLevel.AVCProfileBaseline;
-                                    capabilities = MediaCodecInfo.CodecCapabilities.createFromProfileLevel(MIME_TYPE, profile, level);
+                                    capabilities = MediaCodecInfo.CodecCapabilities.createFromProfileLevel(VIDEO_MIME_TYPE, profile, level);
                                 }
                                 if (capabilities.getEncoderCapabilities() != null) {
                                     outputFormat.setInteger(MediaFormat.KEY_PROFILE, profile);
@@ -4010,7 +4009,7 @@ private boolean convertVideo(final MessageObject messageObject, int timoutUsec)
                                 outputFormat.setInteger("slice-height", resultHeight);
                             }
 
-                            encoder = MediaCodec.createEncoderByType(MIME_TYPE);
+                            encoder = MediaCodec.createEncoderByType(VIDEO_MIME_TYPE);
                             encoder.configure(outputFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);
                             if (Build.VERSION.SDK_INT >= 18) {
                                 inputSurface = new InputSurface(encoder.createInputSurface());
@@ -4038,10 +4037,43 @@ private boolean convertVideo(final MessageObject messageObject, int timoutUsec)
                                 }
                             }
 
+                            if (audioIndex >= 0) {
+                                MediaFormat audioFormat = extractor.getTrackFormat(audioIndex);
+                                copyAudioBuffer = audioFormat.getString(MediaFormat.KEY_MIME).equals(AUIDO_MIME_TYPE);
+                                audioTrackIndex = mediaMuxer.addTrack(audioFormat, true);
+
+                                if(copyAudioBuffer) {
+                                    extractor.selectTrack(audioIndex);
+                                    int maxBufferSize = audioFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE);
+                                    audioBuffer = ByteBuffer.allocateDirect(maxBufferSize);
+                                } else {
+
+                                    MediaExtractor audioExtractor = new MediaExtractor();
+                                    audioExtractor.setDataSource(videoPath);
+                                    audioExtractor.selectTrack(audioIndex);
+
+                                    if (startTime > 0) {
+                                        audioExtractor.seekTo(startTime, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
+                                    } else {
+                                        audioExtractor.seekTo(0, MediaExtractor.SEEK_TO_PREVIOUS_SYNC);
+                                    }
+
+                                    audioTranscoder = new AudioTranscoder(audioFormat, audioExtractor, audioIndex);
+                                    audioTranscoder.startTime = startTime;
+                                    audioTranscoder.endTime = endTime;
+                                }
+                            }
+                            boolean audioEncoderDone = false;
+
                             checkConversionCanceled();
 
-                            while (!outputDone) {
+                            while (!outputDone || (!copyAudioBuffer && !audioEncoderDone)) {
                                 checkConversionCanceled();
+
+                                if(!copyAudioBuffer && audioTranscoder != null){
+                                    audioEncoderDone = audioTranscoder.step(mediaMuxer,audioTrackIndex);
+                                }
+
                                 if (!inputDone) {
                                     boolean eof = false;
                                     int index = extractor.getSampleTrackIndex();
@@ -4063,7 +4095,7 @@ private boolean convertVideo(final MessageObject messageObject, int timoutUsec)
                                                 extractor.advance();
                                             }
                                         }
-                                    } else if (audioIndex != -1 && index == audioIndex) {
+                                    } else if (copyAudioBuffer && audioIndex != -1 && index == audioIndex) {
                                         info.size = extractor.readSampleData(audioBuffer, 0);
                                         if (Build.VERSION.SDK_INT < 21) {
                                             audioBuffer.position(0);
@@ -4151,7 +4183,7 @@ private boolean convertVideo(final MessageObject messageObject, int timoutUsec)
                                                     }
                                                 }
 
-                                                MediaFormat newFormat = MediaFormat.createVideoFormat(MIME_TYPE, resultWidth, resultHeight);
+                                                MediaFormat newFormat = MediaFormat.createVideoFormat(VIDEO_MIME_TYPE, resultWidth, resultHeight);
                                                 if (sps != null && pps != null) {
                                                     newFormat.setByteBuffer("csd-0", sps);
                                                     newFormat.setByteBuffer("csd-1", pps);
@@ -4260,6 +4292,7 @@ private boolean convertVideo(final MessageObject messageObject, int timoutUsec)
                             }
                             FileLog.e("bitrate: " + bitrate + " framerate: " + framerate + " size: " + resultHeight + "x" + resultWidth);
                             FileLog.e(e);
+                            e.printStackTrace();
                             error = true;
                         }
 
@@ -4280,6 +4313,7 @@ private boolean convertVideo(final MessageObject messageObject, int timoutUsec)
                             encoder.release();
                         }
 
+                        if(audioTranscoder != null) audioTranscoder.release();
                         checkConversionCanceled();
                     }
                 } else {
@@ -4327,7 +4361,6 @@ public static int getVideoBitrate(String path) {
             retriever.setDataSource(path);
             bitrate = Integer.parseInt(retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_BITRATE));
         } catch (Exception e) {
-            e.printStackTrace();
             FileLog.e(e);
         }
 
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/SendMessagesHelper.java b/TMessagesProj/src/main/java/org/telegram/messenger/SendMessagesHelper.java
index c9f8ed7b1..b46df127c 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/SendMessagesHelper.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/SendMessagesHelper.java
@@ -6171,7 +6171,7 @@ private static VideoEditedInfo createCompressionSettings(String videoPath) {
         int[] params = new int[AnimatedFileDrawable.PARAM_NUM_COUNT];
         AnimatedFileDrawable.getVideoInfo(videoPath, params);
 
-        if (params[AnimatedFileDrawable.PARAM_NUM_IS_AVC] == 0) {
+        if (params[AnimatedFileDrawable.PARAM_NUM_SUPPORTED_VIDEO_CODEC] == 0) {
             if (BuildVars.LOGS_ENABLED) {
                 FileLog.d("video hasn't avc1 atom");
             }
@@ -6191,10 +6191,10 @@ private static VideoEditedInfo createCompressionSettings(String videoPath) {
 
         if (Build.VERSION.SDK_INT < 18) {
             try {
-                MediaCodecInfo codecInfo = MediaController.selectCodec(MediaController.MIME_TYPE);
+                MediaCodecInfo codecInfo = MediaController.selectCodec(MediaController.VIDEO_MIME_TYPE);
                 if (codecInfo == null) {
                     if (BuildVars.LOGS_ENABLED) {
-                        FileLog.d("no codec info for " + MediaController.MIME_TYPE);
+                        FileLog.d("no codec info for " + MediaController.VIDEO_MIME_TYPE);
                     }
                     return null;
                 } else {
@@ -6211,9 +6211,9 @@ private static VideoEditedInfo createCompressionSettings(String videoPath) {
                         }
                         return null;
                     } else {
-                        if (MediaController.selectColorFormat(codecInfo, MediaController.MIME_TYPE) == 0) {
+                        if (MediaController.selectColorFormat(codecInfo, MediaController.VIDEO_MIME_TYPE) == 0) {
                             if (BuildVars.LOGS_ENABLED) {
-                                FileLog.d("no color format for " + MediaController.MIME_TYPE);
+                                FileLog.d("no color format for " + MediaController.VIDEO_MIME_TYPE);
                             }
                             return null;
                         }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/AnimatedFileDrawable.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/AnimatedFileDrawable.java
index 6a3e77b64..b1474e5cd 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/AnimatedFileDrawable.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/AnimatedFileDrawable.java
@@ -19,6 +19,7 @@
 import android.graphics.Shader;
 import android.graphics.drawable.Animatable;
 import android.graphics.drawable.BitmapDrawable;
+import android.os.Build;
 import android.os.Handler;
 import android.os.Looper;
 import android.view.View;
@@ -43,9 +44,9 @@
     private static native int getVideoFrame(long ptr, Bitmap bitmap, int[] params, int stride, boolean preview);
     private static native void seekToMs(long ptr, long ms, boolean precise);
     private static native void prepareToSeek(long ptr);
-    public static native void getVideoInfo(String src, int[] params);
+    private static native void getVideoInfo(int sdkVersion, String src, int[] params);
 
-    public final static int PARAM_NUM_IS_AVC = 0;
+    public final static int PARAM_NUM_SUPPORTED_VIDEO_CODEC = 0;
     public final static int PARAM_NUM_WIDTH = 1;
     public final static int PARAM_NUM_HEIGHT = 2;
     public final static int PARAM_NUM_BITRATE = 3;
@@ -54,7 +55,7 @@
     public final static int PARAM_NUM_VIDEO_FRAME_SIZE = 6;
     public final static int PARAM_NUM_FRAMERATE = 7;
     public final static int PARAM_NUM_ROTATION = 8;
-    public final static int PARAM_NUM_AUDIO_IS_AAC = 9;
+    public final static int PARAM_NUM_SUPPORTED_AUDIO_CODEC = 9;
     public final static int PARAM_NUM_HAS_AUDIO = 10;
     public final static int PARAM_NUM_COUNT = 11;
 
@@ -645,4 +646,8 @@ public AnimatedFileDrawable makeCopy() {
         drawable.metaData[1] = metaData[1];
         return drawable;
     }
+
+    public static void getVideoInfo(String src, int[] params) {
+        getVideoInfo(Build.VERSION.SDK_INT, src,  params);
+    }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java b/TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java
index 7a4f33a77..1b20520a1 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java
@@ -8514,7 +8514,7 @@ public boolean onDoubleTapEvent(MotionEvent e) {
     private int originalBitrate;
     private float videoDuration;
     private int videoFramerate;
-    private boolean videoCompressSupported;
+    private boolean videoConvertSupported;
     private long startTime;
     private long endTime;
     private float videoCutStart;
@@ -8652,7 +8652,7 @@ public void updateMuteButton() {
         if (videoPlayer != null) {
             videoPlayer.setMute(muteVideo);
         }
-        if (!videoCompressSupported) {
+        if (!videoConvertSupported) {
             muteItem.setEnabled(false);
             muteItem.setClickable(false);
             muteItem.setAlpha(0.5f);
@@ -8989,16 +8989,17 @@ public void run() {
                     if (parentActivity == null) {
                         return;
                     }
+
                     boolean hasAudio = params[AnimatedFileDrawable.PARAM_NUM_HAS_AUDIO] != 0;
-                    videoCompressSupported = params[AnimatedFileDrawable.PARAM_NUM_IS_AVC] != 0 &&
-                            (!hasAudio || params[AnimatedFileDrawable.PARAM_NUM_AUDIO_IS_AAC] != 0);
+                    videoConvertSupported = params[AnimatedFileDrawable.PARAM_NUM_SUPPORTED_VIDEO_CODEC] != 0 &&
+                            (!hasAudio || params[AnimatedFileDrawable.PARAM_NUM_SUPPORTED_AUDIO_CODEC] != 0);
                     audioFramesSize = params[AnimatedFileDrawable.PARAM_NUM_AUDIO_FRAME_SIZE];
                     videoDuration = params[AnimatedFileDrawable.PARAM_NUM_DURATION];
                     originalBitrate = bitrate = videoBitrate;
                     videoFramerate = params[AnimatedFileDrawable.PARAM_NUM_FRAMERATE];
                     videoFramesSize = (long) (bitrate / 8 * videoDuration / 1000);
 
-                    if (videoCompressSupported) {
+                    if (videoConvertSupported) {
                         rotationValue = params[AnimatedFileDrawable.PARAM_NUM_ROTATION];
                         resultWidth = originalWidth = params[AnimatedFileDrawable.PARAM_NUM_WIDTH];
                         resultHeight = originalHeight = params[AnimatedFileDrawable.PARAM_NUM_HEIGHT];
@@ -9017,11 +9018,12 @@ public void run() {
                         }
                         if (Build.VERSION.SDK_INT < 18 && compressItem.getTag() != null) {
                             try {
-                                MediaCodecInfo codecInfo = MediaController.selectCodec(MediaController.MIME_TYPE);
+                                MediaCodecInfo codecInfo = MediaController.selectCodec(MediaController.VIDEO_MIME_TYPE);
                                 if (codecInfo == null) {
                                     if (BuildVars.LOGS_ENABLED) {
-                                        FileLog.d("no codec info for " + MediaController.MIME_TYPE);
+                                        FileLog.d("no codec info for " + MediaController.VIDEO_MIME_TYPE);
                                     }
+                                    videoConvertSupported = false;
                                     setCompressItemEnabled(false, true);
                                 } else {
                                     String name = codecInfo.getName();
@@ -9035,11 +9037,12 @@ public void run() {
                                         if (BuildVars.LOGS_ENABLED) {
                                             FileLog.d("unsupported encoder = " + name);
                                         }
+                                        videoConvertSupported = false;
                                         setCompressItemEnabled(false, true);
                                     } else {
-                                        if (MediaController.selectColorFormat(codecInfo, MediaController.MIME_TYPE) == 0) {
+                                        if (MediaController.selectColorFormat(codecInfo, MediaController.VIDEO_MIME_TYPE) == 0) {
                                             if (BuildVars.LOGS_ENABLED) {
-                                                FileLog.d("no color format for " + MediaController.MIME_TYPE);
+                                                FileLog.d("no color format for " + MediaController.VIDEO_MIME_TYPE);
                                             }
                                             setCompressItemEnabled(false, true);
                                         }
