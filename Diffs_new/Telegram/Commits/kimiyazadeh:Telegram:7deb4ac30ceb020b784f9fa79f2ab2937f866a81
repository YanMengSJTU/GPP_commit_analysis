diff --git a/TMessagesProj/src/main/java/org/telegram/tgnet/AbstractSerializedData.java b/TMessagesProj/src/main/java/org/telegram/tgnet/AbstractSerializedData.java
index 19409cac9..1f3432a8f 100644
--- a/TMessagesProj/src/main/java/org/telegram/tgnet/AbstractSerializedData.java
+++ b/TMessagesProj/src/main/java/org/telegram/tgnet/AbstractSerializedData.java
@@ -1,52 +1,52 @@
-package org.telegram.tgnet;
-
-public abstract class AbstractSerializedData {
-
-    public abstract void writeInt32(int x);
-
-    public abstract void writeInt64(long x);
-
-    public abstract void writeBool(boolean value);
-
-    public abstract void writeBytes(byte[] b);
-
-    public abstract void writeBytes(byte[] b, int offset, int count);
-
-    public abstract void writeByte(int i);
-
-    public abstract void writeByte(byte b);
-
-    public abstract void writeString(String s);
-
-    public abstract void writeByteArray(byte[] b, int offset, int count);
-
-    public abstract void writeByteArray(byte[] b);
-
-    public abstract void writeDouble(double d);
-
-    public abstract void writeByteBuffer(NativeByteBuffer buffer);
-
-    public abstract int readInt32(boolean exception);
-
-    public abstract boolean readBool(boolean exception);
-
-    public abstract long readInt64(boolean exception);
-
-    public abstract void readBytes(byte[] b, boolean exception);
-
-    public abstract byte[] readData(int count, boolean exception);
-
-    public abstract String readString(boolean exception);
-
-    public abstract byte[] readByteArray(boolean exception);
-
-    public abstract NativeByteBuffer readByteBuffer(boolean exception);
-
-    public abstract double readDouble(boolean exception);
-
-    public abstract int length();
-
-    public abstract void skip(int count);
-
-    public abstract int getPosition();
-}
+package org.telegram.tgnet;
+
+public abstract class AbstractSerializedData {
+
+    public abstract void writeInt32(int x);
+
+    public abstract void writeInt64(long x);
+
+    public abstract void writeBool(boolean value);
+
+    public abstract void writeBytes(byte[] b);
+
+    public abstract void writeBytes(byte[] b, int offset, int count);
+
+    public abstract void writeByte(int i);
+
+    public abstract void writeByte(byte b);
+
+    public abstract void writeString(String s);
+
+    public abstract void writeByteArray(byte[] b, int offset, int count);
+
+    public abstract void writeByteArray(byte[] b);
+
+    public abstract void writeDouble(double d);
+
+    public abstract void writeByteBuffer(NativeByteBuffer buffer);
+
+    public abstract int readInt32(boolean exception);
+
+    public abstract boolean readBool(boolean exception);
+
+    public abstract long readInt64(boolean exception);
+
+    public abstract void readBytes(byte[] b, boolean exception);
+
+    public abstract byte[] readData(int count, boolean exception);
+
+    public abstract String readString(boolean exception);
+
+    public abstract byte[] readByteArray(boolean exception);
+
+    public abstract NativeByteBuffer readByteBuffer(boolean exception);
+
+    public abstract double readDouble(boolean exception);
+
+    public abstract int length();
+
+    public abstract void skip(int count);
+
+    public abstract int getPosition();
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/tgnet/ConnectionsManager.java b/TMessagesProj/src/main/java/org/telegram/tgnet/ConnectionsManager.java
index 8b6cf27d6..b6d1e0c74 100644
--- a/TMessagesProj/src/main/java/org/telegram/tgnet/ConnectionsManager.java
+++ b/TMessagesProj/src/main/java/org/telegram/tgnet/ConnectionsManager.java
@@ -1,518 +1,520 @@
-package org.telegram.tgnet;
-
-import android.annotation.SuppressLint;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.net.ConnectivityManager;
-import android.net.NetworkInfo;
-import android.os.Build;
-import android.os.PowerManager;
-
-import org.telegram.messenger.AndroidUtilities;
-import org.telegram.messenger.BuildVars;
-import org.telegram.messenger.ContactsController;
-import org.telegram.messenger.ApplicationLoader;
-import org.telegram.messenger.FileLog;
-import org.telegram.messenger.MessagesController;
-import org.telegram.messenger.NotificationCenter;
-import org.telegram.messenger.UserConfig;
-import org.telegram.messenger.Utilities;
-
-import java.net.Inet4Address;
-import java.net.Inet6Address;
-import java.net.InetAddress;
-import java.net.InterfaceAddress;
-import java.net.NetworkInterface;
-import java.util.Enumeration;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicInteger;
-
-public class ConnectionsManager {
-
-    public final static int ConnectionTypeGeneric = 1;
-    public final static int ConnectionTypeDownload = 2;
-    public final static int ConnectionTypeUpload = 4;
-    public final static int ConnectionTypePush = 8;
-    public final static int ConnectionTypeDownload2 = ConnectionTypeDownload | (1 << 16);
-
-    public final static int RequestFlagEnableUnauthorized = 1;
-    public final static int RequestFlagFailOnServerErrors = 2;
-    public final static int RequestFlagCanCompress = 4;
-    public final static int RequestFlagWithoutLogin = 8;
-    public final static int RequestFlagTryDifferentDc = 16;
-    public final static int RequestFlagForceDownload = 32;
-    public final static int RequestFlagInvokeAfter = 64;
-    public final static int RequestFlagNeedQuickAck = 128;
-
-    public final static int ConnectionStateConnecting = 1;
-    public final static int ConnectionStateWaitingForNetwork = 2;
-    public final static int ConnectionStateConnected = 3;
-    public final static int ConnectionStateUpdating = 4;
-
-    public final static int DEFAULT_DATACENTER_ID = Integer.MAX_VALUE;
-
-    private long lastPauseTime = System.currentTimeMillis();
-    private boolean appPaused = true;
-    private int lastClassGuid = 1;
-    private boolean isUpdating = false;
-    private int connectionState = native_getConnectionState();
-    private AtomicInteger lastRequestToken = new AtomicInteger(1);
-    private PowerManager.WakeLock wakeLock = null;
-
-    private static volatile ConnectionsManager Instance = null;
-
-    public static ConnectionsManager getInstance() {
-        ConnectionsManager localInstance = Instance;
-        if (localInstance == null) {
-            synchronized (ConnectionsManager.class) {
-                localInstance = Instance;
-                if (localInstance == null) {
-                    Instance = localInstance = new ConnectionsManager();
-                }
-            }
-        }
-        return localInstance;
-    }
-
-    public ConnectionsManager() {
-        try {
-            PowerManager pm = (PowerManager) ApplicationLoader.applicationContext.getSystemService(Context.POWER_SERVICE);
-            wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "lock");
-            wakeLock.setReferenceCounted(false);
-        } catch (Exception e) {
-            FileLog.e("tmessages", e);
-        }
-    }
-
-    public long getCurrentTimeMillis() {
-        return native_getCurrentTimeMillis();
-    }
-
-    public int getCurrentTime() {
-        return native_getCurrentTime();
-    }
-
-    public int getTimeDifference() {
-        return native_getTimeDifference();
-    }
-
-    public int sendRequest(TLObject object, RequestDelegate completionBlock) {
-        return sendRequest(object, completionBlock, null, 0);
-    }
-
-    public int sendRequest(TLObject object, RequestDelegate completionBlock, int flags) {
-        return sendRequest(object, completionBlock, null, flags, DEFAULT_DATACENTER_ID, ConnectionTypeGeneric, true);
-    }
-
-    public int sendRequest(TLObject object, RequestDelegate completionBlock, int flags, int connetionType) {
-        return sendRequest(object, completionBlock, null, flags, DEFAULT_DATACENTER_ID, connetionType, true);
-    }
-
-    public int sendRequest(TLObject object, RequestDelegate completionBlock, QuickAckDelegate quickAckBlock, int flags) {
-        return sendRequest(object, completionBlock, quickAckBlock, flags, DEFAULT_DATACENTER_ID, ConnectionTypeGeneric, true);
-    }
-
-    public int sendRequest(final TLObject object, final RequestDelegate onComplete, final QuickAckDelegate onQuickAck, final int flags, final int datacenterId, final int connetionType, final boolean immediate) {
-        final int requestToken = lastRequestToken.getAndIncrement();
-        Utilities.stageQueue.postRunnable(new Runnable() {
-            @Override
-            public void run() {
-                FileLog.d("tmessages", "send request " + object + " with token = " + requestToken);
-                try {
-                    NativeByteBuffer buffer = new NativeByteBuffer(object.getObjectSize());
-                    object.serializeToStream(buffer);
-                    object.freeResources();
-
-                    native_sendRequest(buffer.address, new RequestDelegateInternal() {
-                        @Override
-                        public void run(int response, int errorCode, String errorText) {
-                            try {
-                                TLObject resp = null;
-                                TLRPC.TL_error error = null;
-                                if (response != 0) {
-                                    NativeByteBuffer buff = NativeByteBuffer.wrap(response);
-                                    resp = object.deserializeResponse(buff, buff.readInt32(true), true);
-                                } else if (errorText != null) {
-                                    error = new TLRPC.TL_error();
-                                    error.code = errorCode;
-                                    error.text = errorText;
-                                    FileLog.e("tmessages", object + " got error " + error.code + " " + error.text);
-                                }
-                                FileLog.d("tmessages", "java received " + resp + " error = " + error);
-                                final TLObject finalResponse = resp;
-                                final TLRPC.TL_error finalError = error;
-                                Utilities.stageQueue.postRunnable(new Runnable() {
-                                    @Override
-                                    public void run() {
-                                        onComplete.run(finalResponse, finalError);
-                                        if (finalResponse != null) {
-                                            finalResponse.freeResources();
-                                        }
-                                    }
-                                });
-                            } catch (Exception e) {
-                                FileLog.e("tmessages", e);
-                            }
-                        }
-                    }, onQuickAck, flags, datacenterId, connetionType, immediate, requestToken);
-                } catch (Exception e) {
-                    FileLog.e("tmessages", e);
-                }
-            }
-        });
-        return requestToken;
-    }
-
-    public void cancelRequest(int token, boolean notifyServer) {
-        native_cancelRequest(token, notifyServer);
-    }
-
-    public void cleanUp() {
-        native_cleanUp();
-    }
-
-    public void cancelRequestsForGuid(int guid) {
-        native_cancelRequestsForGuid(guid);
-    }
-
-    public void bindRequestToGuid(int requestToken, int guid) {
-        native_bindRequestToGuid(requestToken, guid);
-    }
-
-    public void applyDatacenterAddress(int datacenterId, String ipAddress, int port) {
-        native_applyDatacenterAddress(datacenterId, ipAddress, port);
-    }
-
-    public int getConnectionState() {
-        if (connectionState == ConnectionStateConnected && isUpdating) {
-            return ConnectionStateUpdating;
-        }
-        return connectionState;
-    }
-
-    public void setUserId(int id) {
-        native_setUserId(id);
-    }
-
-    private void checkConnection() {
-        native_setUseIpv6(useIpv6Address());
-        native_setNetworkAvailable(isNetworkOnline());
-    }
-
-    public void init(int version, int layer, int apiId, String deviceModel, String systemVersion, String appVersion, String langCode, String configPath, String logPath, int userId) {
-        native_init(version, layer, apiId, deviceModel, systemVersion, appVersion, langCode, configPath, logPath, userId);
-        checkConnection();
-        BroadcastReceiver networkStateReceiver = new BroadcastReceiver() {
-            @Override
-            public void onReceive(Context context, Intent intent) {
-                checkConnection();
-            }
-        };
-        IntentFilter filter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);
-        ApplicationLoader.applicationContext.registerReceiver(networkStateReceiver, filter);
-    }
-
-    public void switchBackend() {
-        native_switchBackend();
-    }
-
-    public void resumeNetworkMaybe() {
-        native_resumeNetwork(true);
-    }
-
-    public void updateDcSettings() {
-        native_updateDcSettings();
-    }
-
-    public long getPauseTime() {
-        return lastPauseTime;
-    }
-
-    public void setAppPaused(final boolean value, final boolean byScreenState) {
-        if (!byScreenState) {
-            appPaused = value;
-            FileLog.d("tmessages", "app paused = " + value);
-        }
-        if (value) {
-            if (lastPauseTime == 0) {
-                lastPauseTime = System.currentTimeMillis();
-            }
-            native_pauseNetwork();
-        } else {
-            if (appPaused) {
-                return;
-            }
-            FileLog.e("tmessages", "reset app pause time");
-            if (lastPauseTime != 0 && System.currentTimeMillis() - lastPauseTime > 5000) {
-                ContactsController.getInstance().checkContacts();
-            }
-            lastPauseTime = 0;
-            native_resumeNetwork(false);
-        }
-    }
-
-    public static void onUnparsedMessageReceived(int address) {
-        try {
-            NativeByteBuffer buff = NativeByteBuffer.wrap(address);
-            final TLObject message = TLClassStore.Instance().TLdeserialize(buff, buff.readInt32(true), true);
-            if (message instanceof TLRPC.Updates) {
-                FileLog.d("tmessages", "java received " + message);
-                AndroidUtilities.runOnUIThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        if (getInstance().wakeLock.isHeld()) {
-                            FileLog.d("tmessages", "release wakelock");
-                            getInstance().wakeLock.release();
-                        }
-                    }
-                });
-                Utilities.stageQueue.postRunnable(new Runnable() {
-                    @Override
-                    public void run() {
-                        MessagesController.getInstance().processUpdates((TLRPC.Updates) message, false);
-                    }
-                });
-            }
-        } catch (Exception e) {
-            FileLog.e("tmessages", e);
-        }
-    }
-
-    public static void onUpdate() {
-        Utilities.stageQueue.postRunnable(new Runnable() {
-            @Override
-            public void run() {
-                MessagesController.getInstance().updateTimerProc();
-            }
-        });
-    }
-
-    public static void onSessionCreated() {
-        Utilities.stageQueue.postRunnable(new Runnable() {
-            @Override
-            public void run() {
-                MessagesController.getInstance().getDifference();
-            }
-        });
-    }
-
-    public static void onConnectionStateChanged(final int state) {
-        AndroidUtilities.runOnUIThread(new Runnable() {
-            @Override
-            public void run() {
-                getInstance().connectionState = state;
-                NotificationCenter.getInstance().postNotificationName(NotificationCenter.didUpdatedConnectionState);
-            }
-        });
-    }
-
-    public static void onLogout() {
-        AndroidUtilities.runOnUIThread(new Runnable() {
-            @Override
-            public void run() {
-                if (UserConfig.getClientUserId() != 0) {
-                    UserConfig.clearConfig();
-                    MessagesController.getInstance().performLogout(false);
-                }
-            }
-        });
-    }
-
-    public static void onUpdateConfig(int address) {
-        try {
-            NativeByteBuffer buff = NativeByteBuffer.wrap(address);
-            final TLRPC.TL_config message = TLRPC.TL_config.TLdeserialize(buff, buff.readInt32(true), true);
-            if (message != null) {
-                Utilities.stageQueue.postRunnable(new Runnable() {
-                    @Override
-                    public void run() {
-                        MessagesController.getInstance().updateConfig(message);
-                    }
-                });
-            }
-        } catch (Exception e) {
-            FileLog.e("tmessages", e);
-        }
-    }
-
-    public static void onInternalPushReceived() {
-        AndroidUtilities.runOnUIThread(new Runnable() {
-            @Override
-            public void run() {
-                try {
-                    getInstance().wakeLock.acquire(20000);
-                    FileLog.d("tmessages", "acquire wakelock");
-                } catch (Exception e) {
-                    FileLog.e("tmessages", e);
-                }
-            }
-        });
-    }
-
-    public static native void native_switchBackend();
-    public static native void native_pauseNetwork();
-    public static native void native_setUseIpv6(boolean value);
-    public static native void native_updateDcSettings();
-    public static native void native_setNetworkAvailable(boolean value);
-    public static native void native_resumeNetwork(boolean partial);
-    public static native long native_getCurrentTimeMillis();
-    public static native int native_getCurrentTime();
-    public static native int native_getTimeDifference();
-    public static native void native_sendRequest(int object, RequestDelegateInternal onComplete, QuickAckDelegate onQuickAck, int flags, int datacenterId, int connetionType, boolean immediate, int requestToken);
-    public static native void native_cancelRequest(int token, boolean notifyServer);
-    public static native void native_cleanUp();
-    public static native void native_cancelRequestsForGuid(int guid);
-    public static native void native_bindRequestToGuid(int requestToken, int guid);
-    public static native void native_applyDatacenterAddress(int datacenterId, String ipAddress, int port);
-    public static native int native_getConnectionState();
-    public static native void native_setUserId(int id);
-    public static native void native_init(int version, int layer, int apiId, String deviceModel, String systemVersion, String appVersion, String langCode, String configPath, String logPath, int userId);
-    public static native void native_setJava(boolean useJavaByteBuffers);
-
-    public int generateClassGuid() {
-        return lastClassGuid++;
-    }
-
-    public static boolean isRoaming() {
-        try {
-            ConnectivityManager cm = (ConnectivityManager) ApplicationLoader.applicationContext.getSystemService(Context.CONNECTIVITY_SERVICE);
-            NetworkInfo netInfo = cm.getActiveNetworkInfo();
-            if (netInfo != null) {
-                return netInfo.isRoaming();
-            }
-        } catch (Exception e) {
-            FileLog.e("tmessages", e);
-        }
-        return false;
-    }
-
-    public static boolean isConnectedToWiFi() {
-        try {
-            ConnectivityManager cm = (ConnectivityManager) ApplicationLoader.applicationContext.getSystemService(Context.CONNECTIVITY_SERVICE);
-            NetworkInfo netInfo = cm.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
-            if (netInfo != null && netInfo.getState() == NetworkInfo.State.CONNECTED) {
-                return true;
-            }
-        } catch (Exception e) {
-            FileLog.e("tmessages", e);
-        }
-        return false;
-    }
-
-    public void applyCountryPortNumber(String number) {
-
-    }
-
-    public void setIsUpdating(final boolean value) {
-        AndroidUtilities.runOnUIThread(new Runnable() {
-            @Override
-            public void run() {
-                if (isUpdating == value) {
-                    return;
-                }
-                isUpdating = value;
-                if (connectionState == ConnectionStateConnected) {
-                    NotificationCenter.getInstance().postNotificationName(NotificationCenter.didUpdatedConnectionState);
-                }
-            }
-        });
-    }
-
-    @SuppressLint("NewApi")
-    protected static boolean useIpv6Address() {
-        if (Build.VERSION.SDK_INT < 19) {
-            return false;
-        }
-        if (BuildVars.DEBUG_VERSION) {
-            try {
-                NetworkInterface networkInterface;
-                Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();
-                while (networkInterfaces.hasMoreElements()) {
-                    networkInterface = networkInterfaces.nextElement();
-                    if (!networkInterface.isUp() || networkInterface.isLoopback() || networkInterface.getInterfaceAddresses().isEmpty()) {
-                        continue;
-                    }
-                    FileLog.e("tmessages", "valid interface: " + networkInterface);
-                    List<InterfaceAddress> interfaceAddresses = networkInterface.getInterfaceAddresses();
-                    for (int a = 0; a < interfaceAddresses.size(); a++) {
-                        InterfaceAddress address = interfaceAddresses.get(a);
-                        InetAddress inetAddress = address.getAddress();
-                        if (BuildVars.DEBUG_VERSION) {
-                            FileLog.e("tmessages", "address: " + inetAddress.getHostAddress());
-                        }
-                        if (inetAddress.isLinkLocalAddress() || inetAddress.isLoopbackAddress() || inetAddress.isMulticastAddress()) {
-                            continue;
-                        }
-                        if (BuildVars.DEBUG_VERSION) {
-                            FileLog.e("tmessages", "address is good");
-                        }
-                    }
-                }
-            } catch (Throwable e) {
-                FileLog.e("tmessages", e);
-            }
-        }
-        try {
-            NetworkInterface networkInterface;
-            Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();
-            boolean hasIpv4 = false;
-            boolean hasIpv6 = false;
-            while (networkInterfaces.hasMoreElements()) {
-                networkInterface = networkInterfaces.nextElement();
-                if (!networkInterface.isUp() || networkInterface.isLoopback()) {
-                    continue;
-                }
-                List<InterfaceAddress> interfaceAddresses = networkInterface.getInterfaceAddresses();
-                for (int a = 0; a < interfaceAddresses.size(); a++) {
-                    InterfaceAddress address = interfaceAddresses.get(a);
-                    InetAddress inetAddress = address.getAddress();
-                    if (inetAddress.isLinkLocalAddress() || inetAddress.isLoopbackAddress() || inetAddress.isMulticastAddress()) {
-                        continue;
-                    }
-                    if (inetAddress instanceof Inet6Address) {
-                        hasIpv6 = true;
-                    } else if (inetAddress instanceof Inet4Address) {
-                        String addrr = inetAddress.getHostAddress();
-                        if (!addrr.startsWith("192.0.0.")) {
-                            hasIpv4 = true;
-                        }
-                    }
-                }
-            }
-            if (!hasIpv4 && hasIpv6) {
-                return true;
-            }
-        } catch (Throwable e) {
-            FileLog.e("tmessages", e);
-        }
-
-        return false;
-    }
-
-    public static boolean isNetworkOnline() {
-        try {
-            ConnectivityManager cm = (ConnectivityManager) ApplicationLoader.applicationContext.getSystemService(Context.CONNECTIVITY_SERVICE);
-            NetworkInfo netInfo = cm.getActiveNetworkInfo();
-            if (netInfo != null && (netInfo.isConnectedOrConnecting() || netInfo.isAvailable())) {
-                return true;
-            }
-
-            netInfo = cm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
-
-            if (netInfo != null && netInfo.isConnectedOrConnecting()) {
-                return true;
-            } else {
-                netInfo = cm.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
-                if (netInfo != null && netInfo.isConnectedOrConnecting()) {
-                    return true;
-                }
-            }
-        } catch (Exception e) {
-            FileLog.e("tmessages", e);
-            return true;
-        }
-        return false;
-    }
-}
+package org.telegram.tgnet;
+
+import android.annotation.SuppressLint;
+import android.app.Activity;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SharedPreferences;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.os.Build;
+import android.os.PowerManager;
+
+import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.ApplicationLoader;
+import org.telegram.messenger.BuildVars;
+import org.telegram.messenger.ContactsController;
+import org.telegram.messenger.FileLog;
+import org.telegram.messenger.MessagesController;
+import org.telegram.messenger.NotificationCenter;
+import org.telegram.messenger.UserConfig;
+import org.telegram.messenger.Utilities;
+
+import java.net.Inet4Address;
+import java.net.Inet6Address;
+import java.net.InetAddress;
+import java.net.InterfaceAddress;
+import java.net.NetworkInterface;
+import java.util.Enumeration;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class ConnectionsManager {
+
+    public final static int ConnectionTypeGeneric = 1;
+    public final static int ConnectionTypeDownload = 2;
+    public final static int ConnectionTypeUpload = 4;
+    public final static int ConnectionTypePush = 8;
+    public final static int ConnectionTypeDownload2 = ConnectionTypeDownload | (1 << 16);
+
+    public final static int RequestFlagEnableUnauthorized = 1;
+    public final static int RequestFlagFailOnServerErrors = 2;
+    public final static int RequestFlagCanCompress = 4;
+    public final static int RequestFlagWithoutLogin = 8;
+    public final static int RequestFlagTryDifferentDc = 16;
+    public final static int RequestFlagForceDownload = 32;
+    public final static int RequestFlagInvokeAfter = 64;
+    public final static int RequestFlagNeedQuickAck = 128;
+
+    public final static int ConnectionStateConnecting = 1;
+    public final static int ConnectionStateWaitingForNetwork = 2;
+    public final static int ConnectionStateConnected = 3;
+    public final static int ConnectionStateUpdating = 4;
+
+    public final static int DEFAULT_DATACENTER_ID = Integer.MAX_VALUE;
+
+    private long lastPauseTime = System.currentTimeMillis();
+    private boolean appPaused = true;
+    private int lastClassGuid = 1;
+    private boolean isUpdating = false;
+    private int connectionState = native_getConnectionState();
+    private AtomicInteger lastRequestToken = new AtomicInteger(1);
+    private PowerManager.WakeLock wakeLock = null;
+
+    private static volatile ConnectionsManager Instance = null;
+
+    public static ConnectionsManager getInstance() {
+        ConnectionsManager localInstance = Instance;
+        if (localInstance == null) {
+            synchronized (ConnectionsManager.class) {
+                localInstance = Instance;
+                if (localInstance == null) {
+                    Instance = localInstance = new ConnectionsManager();
+                }
+            }
+        }
+        return localInstance;
+    }
+
+    public ConnectionsManager() {
+        try {
+            PowerManager pm = (PowerManager) ApplicationLoader.applicationContext.getSystemService(Context.POWER_SERVICE);
+            wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "lock");
+            wakeLock.setReferenceCounted(false);
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+    }
+
+    public long getCurrentTimeMillis() {
+        return native_getCurrentTimeMillis();
+    }
+
+    public int getCurrentTime() {
+        return native_getCurrentTime();
+    }
+
+    public int getTimeDifference() {
+        return native_getTimeDifference();
+    }
+
+    public int sendRequest(TLObject object, RequestDelegate completionBlock) {
+        return sendRequest(object, completionBlock, null, 0);
+    }
+
+    public int sendRequest(TLObject object, RequestDelegate completionBlock, int flags) {
+        return sendRequest(object, completionBlock, null, flags, DEFAULT_DATACENTER_ID, ConnectionTypeGeneric, true);
+    }
+
+    public int sendRequest(TLObject object, RequestDelegate completionBlock, int flags, int connetionType) {
+        return sendRequest(object, completionBlock, null, flags, DEFAULT_DATACENTER_ID, connetionType, true);
+    }
+
+    public int sendRequest(TLObject object, RequestDelegate completionBlock, QuickAckDelegate quickAckBlock, int flags) {
+        return sendRequest(object, completionBlock, quickAckBlock, flags, DEFAULT_DATACENTER_ID, ConnectionTypeGeneric, true);
+    }
+
+    public int sendRequest(final TLObject object, final RequestDelegate onComplete, final QuickAckDelegate onQuickAck, final int flags, final int datacenterId, final int connetionType, final boolean immediate) {
+        final int requestToken = lastRequestToken.getAndIncrement();
+        Utilities.stageQueue.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                FileLog.d("tmessages", "send request " + object + " with token = " + requestToken);
+                try {
+                    NativeByteBuffer buffer = new NativeByteBuffer(object.getObjectSize());
+                    object.serializeToStream(buffer);
+                    object.freeResources();
+
+                    native_sendRequest(buffer.address, new RequestDelegateInternal() {
+                        @Override
+                        public void run(int response, int errorCode, String errorText) {
+                            try {
+                                TLObject resp = null;
+                                TLRPC.TL_error error = null;
+                                if (response != 0) {
+                                    NativeByteBuffer buff = NativeByteBuffer.wrap(response);
+                                    resp = object.deserializeResponse(buff, buff.readInt32(true), true);
+                                } else if (errorText != null) {
+                                    error = new TLRPC.TL_error();
+                                    error.code = errorCode;
+                                    error.text = errorText;
+                                    FileLog.e("tmessages", object + " got error " + error.code + " " + error.text);
+                                }
+                                FileLog.d("tmessages", "java received " + resp + " error = " + error);
+                                final TLObject finalResponse = resp;
+                                final TLRPC.TL_error finalError = error;
+                                Utilities.stageQueue.postRunnable(new Runnable() {
+                                    @Override
+                                    public void run() {
+                                        onComplete.run(finalResponse, finalError);
+                                        if (finalResponse != null) {
+                                            finalResponse.freeResources();
+                                        }
+                                    }
+                                });
+                            } catch (Exception e) {
+                                FileLog.e("tmessages", e);
+                            }
+                        }
+                    }, onQuickAck, flags, datacenterId, connetionType, immediate, requestToken);
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                }
+            }
+        });
+        return requestToken;
+    }
+
+    public void cancelRequest(int token, boolean notifyServer) {
+        native_cancelRequest(token, notifyServer);
+    }
+
+    public void cleanUp() {
+        native_cleanUp();
+    }
+
+    public void cancelRequestsForGuid(int guid) {
+        native_cancelRequestsForGuid(guid);
+    }
+
+    public void bindRequestToGuid(int requestToken, int guid) {
+        native_bindRequestToGuid(requestToken, guid);
+    }
+
+    public void applyDatacenterAddress(int datacenterId, String ipAddress, int port) {
+        native_applyDatacenterAddress(datacenterId, ipAddress, port);
+    }
+
+    public int getConnectionState() {
+        if (connectionState == ConnectionStateConnected && isUpdating) {
+            return ConnectionStateUpdating;
+        }
+        return connectionState;
+    }
+
+    public void setUserId(int id) {
+        native_setUserId(id);
+    }
+
+    private void checkConnection() {
+        native_setUseIpv6(useIpv6Address());
+        native_setNetworkAvailable(isNetworkOnline());
+    }
+
+    public void init(int version, int layer, int apiId, String deviceModel, String systemVersion, String appVersion, String langCode, String configPath, String logPath, int userId) {
+        native_init(version, layer, apiId, deviceModel, systemVersion, appVersion, langCode, configPath, logPath, userId);
+        checkConnection();
+        BroadcastReceiver networkStateReceiver = new BroadcastReceiver() {
+            @Override
+            public void onReceive(Context context, Intent intent) {
+                checkConnection();
+            }
+        };
+        IntentFilter filter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);
+        ApplicationLoader.applicationContext.registerReceiver(networkStateReceiver, filter);
+    }
+
+    public void switchBackend() {
+        native_switchBackend();
+    }
+
+    public void resumeNetworkMaybe() {
+        native_resumeNetwork(true);
+    }
+
+    public void updateDcSettings() {
+        native_updateDcSettings();
+    }
+
+    public long getPauseTime() {
+        return lastPauseTime;
+    }
+
+    public void setAppPaused(final boolean value, final boolean byScreenState) {
+        if (!byScreenState) {
+            appPaused = value;
+            FileLog.d("tmessages", "app paused = " + value);
+        }
+        if (value) {
+            if (lastPauseTime == 0) {
+                lastPauseTime = System.currentTimeMillis();
+            }
+            native_pauseNetwork();
+        } else {
+            if (appPaused) {
+                return;
+            }
+            FileLog.e("tmessages", "reset app pause time");
+            if (lastPauseTime != 0 && System.currentTimeMillis() - lastPauseTime > 5000) {
+                ContactsController.getInstance().checkContacts();
+            }
+            lastPauseTime = 0;
+            native_resumeNetwork(false);
+        }
+    }
+
+    public static void onUnparsedMessageReceived(int address) {
+        try {
+            NativeByteBuffer buff = NativeByteBuffer.wrap(address);
+            final TLObject message = TLClassStore.Instance().TLdeserialize(buff, buff.readInt32(true), true);
+            if (message instanceof TLRPC.Updates) {
+                FileLog.d("tmessages", "java received " + message);
+                AndroidUtilities.runOnUIThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        if (getInstance().wakeLock.isHeld()) {
+                            FileLog.d("tmessages", "release wakelock");
+                            getInstance().wakeLock.release();
+                        }
+                    }
+                });
+                Utilities.stageQueue.postRunnable(new Runnable() {
+                    @Override
+                    public void run() {
+                        MessagesController.getInstance().processUpdates((TLRPC.Updates) message, false);
+                    }
+                });
+            }
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+    }
+
+    public static void onUpdate() {
+        Utilities.stageQueue.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                MessagesController.getInstance().updateTimerProc();
+            }
+        });
+    }
+
+    public static void onSessionCreated() {
+        Utilities.stageQueue.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                MessagesController.getInstance().getDifference();
+            }
+        });
+    }
+
+    public static void onConnectionStateChanged(final int state) {
+        AndroidUtilities.runOnUIThread(new Runnable() {
+            @Override
+            public void run() {
+                getInstance().connectionState = state;
+                NotificationCenter.getInstance().postNotificationName(NotificationCenter.didUpdatedConnectionState);
+            }
+        });
+    }
+
+    public static void onLogout() {
+        AndroidUtilities.runOnUIThread(new Runnable() {
+            @Override
+            public void run() {
+                if (UserConfig.getClientUserId() != 0) {
+                    UserConfig.clearConfig();
+                    MessagesController.getInstance().performLogout(false);
+                }
+            }
+        });
+    }
+
+    public static void onUpdateConfig(int address) {
+        try {
+            NativeByteBuffer buff = NativeByteBuffer.wrap(address);
+            final TLRPC.TL_config message = TLRPC.TL_config.TLdeserialize(buff, buff.readInt32(true), true);
+            if (message != null) {
+                Utilities.stageQueue.postRunnable(new Runnable() {
+                    @Override
+                    public void run() {
+                        MessagesController.getInstance().updateConfig(message);
+                    }
+                });
+            }
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+    }
+
+    public static void onInternalPushReceived() {
+        AndroidUtilities.runOnUIThread(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    getInstance().wakeLock.acquire(20000);
+                    FileLog.d("tmessages", "acquire wakelock");
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                }
+            }
+        });
+    }
+
+    public static native void native_switchBackend();
+    public static native void native_pauseNetwork();
+    public static native void native_setUseIpv6(boolean value);
+    public static native void native_updateDcSettings();
+    public static native void native_setNetworkAvailable(boolean value);
+    public static native void native_resumeNetwork(boolean partial);
+    public static native long native_getCurrentTimeMillis();
+    public static native int native_getCurrentTime();
+    public static native int native_getTimeDifference();
+    public static native void native_sendRequest(int object, RequestDelegateInternal onComplete, QuickAckDelegate onQuickAck, int flags, int datacenterId, int connetionType, boolean immediate, int requestToken);
+    public static native void native_cancelRequest(int token, boolean notifyServer);
+    public static native void native_cleanUp();
+    public static native void native_cancelRequestsForGuid(int guid);
+    public static native void native_bindRequestToGuid(int requestToken, int guid);
+    public static native void native_applyDatacenterAddress(int datacenterId, String ipAddress, int port);
+    public static native int native_getConnectionState();
+    public static native void native_setUserId(int id);
+    public static native void native_init(int version, int layer, int apiId, String deviceModel, String systemVersion, String appVersion, String langCode, String configPath, String logPath, int userId);
+    public static native void native_setJava(boolean useJavaByteBuffers);
+
+    public int generateClassGuid() {
+        return lastClassGuid++;
+    }
+
+    public static boolean isRoaming() {
+        try {
+            ConnectivityManager cm = (ConnectivityManager) ApplicationLoader.applicationContext.getSystemService(Context.CONNECTIVITY_SERVICE);
+            NetworkInfo netInfo = cm.getActiveNetworkInfo();
+            if (netInfo != null) {
+                return netInfo.isRoaming();
+            }
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+        return false;
+    }
+
+    public static boolean isConnectedToWiFi() {
+        try {
+            ConnectivityManager cm = (ConnectivityManager) ApplicationLoader.applicationContext.getSystemService(Context.CONNECTIVITY_SERVICE);
+            NetworkInfo netInfo = cm.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
+            if (netInfo != null && netInfo.getState() == NetworkInfo.State.CONNECTED) {
+                return true;
+            }
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+        return false;
+    }
+
+    public void applyCountryPortNumber(String number) {
+
+    }
+
+    public void setIsUpdating(final boolean value) {
+        AndroidUtilities.runOnUIThread(new Runnable() {
+            @Override
+            public void run() {
+                if (isUpdating == value) {
+                    return;
+                }
+                isUpdating = value;
+                if (connectionState == ConnectionStateConnected) {
+                    NotificationCenter.getInstance().postNotificationName(NotificationCenter.didUpdatedConnectionState);
+                }
+            }
+        });
+    }
+
+    @SuppressLint("NewApi")
+    protected static boolean useIpv6Address() {
+        if (Build.VERSION.SDK_INT < 19) {
+            return false;
+        }
+        if (BuildVars.DEBUG_VERSION) {
+            try {
+                NetworkInterface networkInterface;
+                Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();
+                while (networkInterfaces.hasMoreElements()) {
+                    networkInterface = networkInterfaces.nextElement();
+                    if (!networkInterface.isUp() || networkInterface.isLoopback() || networkInterface.getInterfaceAddresses().isEmpty()) {
+                        continue;
+                    }
+                    FileLog.e("tmessages", "valid interface: " + networkInterface);
+                    List<InterfaceAddress> interfaceAddresses = networkInterface.getInterfaceAddresses();
+                    for (int a = 0; a < interfaceAddresses.size(); a++) {
+                        InterfaceAddress address = interfaceAddresses.get(a);
+                        InetAddress inetAddress = address.getAddress();
+                        if (BuildVars.DEBUG_VERSION) {
+                            FileLog.e("tmessages", "address: " + inetAddress.getHostAddress());
+                        }
+                        if (inetAddress.isLinkLocalAddress() || inetAddress.isLoopbackAddress() || inetAddress.isMulticastAddress()) {
+                            continue;
+                        }
+                        if (BuildVars.DEBUG_VERSION) {
+                            FileLog.e("tmessages", "address is good");
+                        }
+                    }
+                }
+            } catch (Throwable e) {
+                FileLog.e("tmessages", e);
+            }
+        }
+        try {
+            NetworkInterface networkInterface;
+            Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();
+            boolean hasIpv4 = false;
+            boolean hasIpv6 = false;
+            while (networkInterfaces.hasMoreElements()) {
+                networkInterface = networkInterfaces.nextElement();
+                if (!networkInterface.isUp() || networkInterface.isLoopback()) {
+                    continue;
+                }
+                List<InterfaceAddress> interfaceAddresses = networkInterface.getInterfaceAddresses();
+                for (int a = 0; a < interfaceAddresses.size(); a++) {
+                    InterfaceAddress address = interfaceAddresses.get(a);
+                    InetAddress inetAddress = address.getAddress();
+                    if (inetAddress.isLinkLocalAddress() || inetAddress.isLoopbackAddress() || inetAddress.isMulticastAddress()) {
+                        continue;
+                    }
+                    if (inetAddress instanceof Inet6Address) {
+                        hasIpv6 = true;
+                    } else if (inetAddress instanceof Inet4Address) {
+                        String addrr = inetAddress.getHostAddress();
+                        if (!addrr.startsWith("192.0.0.")) {
+                            hasIpv4 = true;
+                        }
+                    }
+                }
+            }
+            if (!hasIpv4 && hasIpv6) {
+                return true;
+            }
+        } catch (Throwable e) {
+            FileLog.e("tmessages", e);
+        }
+
+        return false;
+    }
+
+    public static boolean isNetworkOnline() {
+        try {
+            ConnectivityManager cm = (ConnectivityManager) ApplicationLoader.applicationContext.getSystemService(Context.CONNECTIVITY_SERVICE);
+            NetworkInfo netInfo = cm.getActiveNetworkInfo();
+            if (netInfo != null && (netInfo.isConnectedOrConnecting() || netInfo.isAvailable())) {
+                return true;
+            }
+
+            netInfo = cm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
+
+            if (netInfo != null && netInfo.isConnectedOrConnecting()) {
+                return true;
+            } else {
+                netInfo = cm.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
+                if (netInfo != null && netInfo.isConnectedOrConnecting()) {
+                    return true;
+                }
+            }
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+            return true;
+        }
+        return false;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/tgnet/NativeByteBuffer.java b/TMessagesProj/src/main/java/org/telegram/tgnet/NativeByteBuffer.java
index eddea361a..59c7d867f 100644
--- a/TMessagesProj/src/main/java/org/telegram/tgnet/NativeByteBuffer.java
+++ b/TMessagesProj/src/main/java/org/telegram/tgnet/NativeByteBuffer.java
@@ -1,506 +1,506 @@
-package org.telegram.tgnet;
-
-import org.telegram.messenger.FileLog;
-
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-
-public class NativeByteBuffer extends AbstractSerializedData {
-
-    protected int address;
-    public ByteBuffer buffer;
-    private boolean justCalc = false;
-    private int len = 0;
-
-    private static final ThreadLocal<NativeByteBuffer> addressWrapper = new ThreadLocal<NativeByteBuffer>() {
-        @Override
-        protected NativeByteBuffer initialValue() {
-            return new NativeByteBuffer(0, true);
-        }
-    };
-
-    public static NativeByteBuffer wrap(int address) {
-        NativeByteBuffer result = addressWrapper.get();
-        if (address != 0) {
-            result.address = address;
-            result.buffer = native_getJavaByteBuffer(address);
-            result.buffer.limit(native_limit(address));
-            int position = native_position(address);
-            if (position <= result.buffer.limit()) {
-                result.buffer.position(position);
-            } else {
-                FileLog.e("tmessages", "what with position " + position);
-            }
-            result.buffer.order(ByteOrder.LITTLE_ENDIAN);
-        }
-        return result;
-    }
-
-    private NativeByteBuffer(int address, boolean wrap) {
-
-    }
-
-    public NativeByteBuffer(int size) throws Exception {
-        if (size >= 0) {
-            address = native_getFreeBuffer(size);
-            if (address != 0) {
-                buffer = native_getJavaByteBuffer(address);
-                buffer.position(0);
-                buffer.limit(size);
-                buffer.order(ByteOrder.LITTLE_ENDIAN);
-            }
-        } else {
-            throw new Exception("invalid NativeByteBuffer size");
-        }
-    }
-
-    public NativeByteBuffer(boolean calculate) {
-        justCalc = calculate;
-    }
-
-    public int position() {
-        return buffer.position();
-    }
-
-    public void position(int position) {
-        buffer.position(position);
-    }
-
-    public int capacity() {
-        return buffer.capacity();
-    }
-
-    public int limit() {
-        return buffer.limit();
-    }
-
-    public void limit(int limit) {
-        buffer.limit(limit);
-    }
-
-    public void put(ByteBuffer buff) {
-        buffer.put(buff);
-    }
-
-    public void rewind() {
-        if (justCalc) {
-            len = 0;
-        } else {
-            buffer.rewind();
-        }
-    }
-
-    public void compact() {
-        buffer.compact();
-    }
-
-    public boolean hasRemaining() {
-        return buffer.hasRemaining();
-    }
-
-    public void writeInt32(int x) {
-        try {
-            if (!justCalc) {
-                buffer.putInt(x);
-            } else {
-                len += 4;
-            }
-        } catch(Exception e) {
-            FileLog.e("tmessages", "write int32 error");
-        }
-    }
-
-    public void writeInt64(long x) {
-        try {
-            if (!justCalc) {
-                buffer.putLong(x);
-            } else {
-                len += 8;
-            }
-        } catch(Exception e) {
-            FileLog.e("tmessages", "write int64 error");
-        }
-    }
-
-    public void writeBool(boolean value) {
-        if (!justCalc) {
-            if (value) {
-                writeInt32(0x997275b5);
-            } else {
-                writeInt32(0xbc799737);
-            }
-        } else {
-            len += 4;
-        }
-    }
-
-    public void writeBytes(byte[] b) {
-        try {
-            if (!justCalc) {
-                buffer.put(b);
-            } else {
-                len += b.length;
-            }
-        } catch (Exception e) {
-            FileLog.e("tmessages", "write raw error");
-        }
-    }
-
-    public void writeBytes(byte[] b, int offset, int count) {
-        try {
-            if (!justCalc) {
-                buffer.put(b, offset, count);
-            } else {
-                len += count;
-            }
-        } catch (Exception e) {
-            FileLog.e("tmessages", "write raw error");
-        }
-    }
-
-    public void writeByte(int i) {
-        writeByte((byte) i);
-    }
-
-    public void writeByte(byte b) {
-        try {
-            if (!justCalc) {
-                buffer.put(b);
-            } else {
-                len += 1;
-            }
-        } catch (Exception e) {
-            FileLog.e("tmessages", "write byte error");
-        }
-    }
-
-    public void writeString(String s) {
-        try {
-            writeByteArray(s.getBytes("UTF-8"));
-        } catch(Exception e) {
-            FileLog.e("tmessages", "write string error");
-        }
-    }
-
-    public void writeByteArray(byte[] b, int offset, int count) {
-        try {
-            if(count <= 253) {
-                if (!justCalc) {
-                    buffer.put((byte)count);
-                } else {
-                    len += 1;
-                }
-            } else {
-                if (!justCalc) {
-                    buffer.put((byte)254);
-                    buffer.put((byte)count);
-                    buffer.put((byte)(count >> 8));
-                    buffer.put((byte)(count >> 16));
-                } else {
-                    len += 4;
-                }
-            }
-            if (!justCalc) {
-                buffer.put(b, offset, count);
-            } else {
-                len += count;
-            }
-            int i = count <= 253 ? 1 : 4;
-            while ((count + i) % 4 != 0) {
-                if (!justCalc) {
-                    buffer.put((byte)0);
-                } else {
-                    len += 1;
-                }
-                i++;
-            }
-        } catch (Exception e) {
-            FileLog.e("tmessages", "write byte array error");
-        }
-    }
-
-    public void writeByteArray(byte[] b) {
-        try {
-            if (b.length <= 253) {
-                if (!justCalc) {
-                    buffer.put((byte) b.length);
-                } else {
-                    len += 1;
-                }
-            } else {
-                if (!justCalc) {
-                    buffer.put((byte) 254);
-                    buffer.put((byte) b.length);
-                    buffer.put((byte) (b.length >> 8));
-                    buffer.put((byte) (b.length >> 16));
-                } else {
-                    len += 4;
-                }
-            }
-            if (!justCalc) {
-                buffer.put(b);
-            } else {
-                len += b.length;
-            }
-            int i = b.length <= 253 ? 1 : 4;
-            while((b.length + i) % 4 != 0) {
-                if (!justCalc) {
-                    buffer.put((byte) 0);
-                } else {
-                    len += 1;
-                }
-                i++;
-            }
-        } catch (Exception e) {
-            FileLog.e("tmessages", "write byte array error");
-        }
-    }
-
-    public void writeDouble(double d) {
-        try {
-            writeInt64(Double.doubleToRawLongBits(d));
-        } catch(Exception e) {
-            FileLog.e("tmessages", "write double error");
-        }
-    }
-
-    public void writeByteBuffer(NativeByteBuffer b) {
-        try {
-            int l = b.limit();
-            if (l <= 253) {
-                if (!justCalc) {
-                    buffer.put((byte) l);
-                } else {
-                    len += 1;
-                }
-            } else {
-                if (!justCalc) {
-                    buffer.put((byte) 254);
-                    buffer.put((byte) l);
-                    buffer.put((byte) (l >> 8));
-                    buffer.put((byte) (l >> 16));
-                } else {
-                    len += 4;
-                }
-            }
-            if (!justCalc) {
-                b.rewind();
-                buffer.put(b.buffer);
-            } else {
-                len += l;
-            }
-            int i = l <= 253 ? 1 : 4;
-            while((l + i) % 4 != 0) {
-                if (!justCalc) {
-                    buffer.put((byte) 0);
-                } else {
-                    len += 1;
-                }
-                i++;
-            }
-        } catch (Exception e) {
-            FileLog.e("tmessages", e);
-        }
-    }
-
-    public void writeBytes(NativeByteBuffer b) {
-        if (justCalc) {
-            len += b.limit();
-        } else {
-            b.rewind();
-            buffer.put(b.buffer);
-        }
-    }
-
-    public int getIntFromByte(byte b) {
-        return b >= 0 ? b : ((int)b) + 256;
-    }
-
-    public int length() {
-        if (!justCalc) {
-            return buffer.position();
-        }
-        return len;
-    }
-
-    public void skip(int count) {
-        if (count == 0) {
-            return;
-        }
-        if (!justCalc) {
-            buffer.position(buffer.position() + count);
-        } else {
-            len += count;
-        }
-    }
-
-    public int getPosition() {
-        return buffer.position();
-    }
-
-    public int readInt32(boolean exception) {
-        try {
-            return buffer.getInt();
-        } catch (Exception e) {
-            if (exception) {
-                throw new RuntimeException("read int32 error", e);
-            } else {
-                FileLog.e("tmessages", "read int32 error");
-            }
-        }
-        return 0;
-    }
-
-    public boolean readBool(boolean exception) {
-        int consructor = readInt32(exception);
-        if (consructor == 0x997275b5) {
-            return true;
-        } else if (consructor == 0xbc799737) {
-            return false;
-        }
-        if (exception) {
-            throw new RuntimeException("Not bool value!");
-        } else {
-            FileLog.e("tmessages", "Not bool value!");
-        }
-        return false;
-    }
-
-    public long readInt64(boolean exception) {
-        try {
-            return buffer.getLong();
-        } catch (Exception e) {
-            if (exception) {
-                throw new RuntimeException("read int64 error", e);
-            } else {
-                FileLog.e("tmessages", "read int64 error");
-            }
-        }
-        return 0;
-    }
-
-    public void readBytes(byte[] b, boolean exception) {
-        try {
-            buffer.get(b);
-        } catch (Exception e) {
-            if (exception) {
-                throw new RuntimeException("read raw error", e);
-            } else {
-                FileLog.e("tmessages", "read raw error");
-            }
-        }
-    }
-
-    public byte[] readData(int count, boolean exception) {
-        byte[] arr = new byte[count];
-        readBytes(arr, exception);
-        return arr;
-    }
-
-    public String readString(boolean exception) {
-        try {
-            int sl = 1;
-            int l = getIntFromByte(buffer.get());
-            if(l >= 254) {
-                l = getIntFromByte(buffer.get()) | (getIntFromByte(buffer.get()) << 8) | (getIntFromByte(buffer.get()) << 16);
-                sl = 4;
-            }
-            byte[] b = new byte[l];
-            buffer.get(b);
-            int i = sl;
-            while((l + i) % 4 != 0) {
-                buffer.get();
-                i++;
-            }
-            return new String(b, "UTF-8");
-        } catch (Exception e) {
-            if (exception) {
-                throw new RuntimeException("read string error", e);
-            } else {
-                FileLog.e("tmessages", "read string error");
-            }
-        }
-        return null;
-    }
-
-    public byte[] readByteArray(boolean exception) {
-        try {
-            int sl = 1;
-            int l = getIntFromByte(buffer.get());
-            if (l >= 254) {
-                l = getIntFromByte(buffer.get()) | (getIntFromByte(buffer.get()) << 8) | (getIntFromByte(buffer.get()) << 16);
-                sl = 4;
-            }
-            byte[] b = new byte[l];
-            buffer.get(b);
-            int i = sl;
-            while((l + i) % 4 != 0) {
-                buffer.get();
-                i++;
-            }
-            return b;
-        } catch (Exception e) {
-            if (exception) {
-                throw new RuntimeException("read byte array error", e);
-            } else {
-                FileLog.e("tmessages", "read byte array error");
-            }
-        }
-        return null;
-    }
-
-    public NativeByteBuffer readByteBuffer(boolean exception) {
-        try {
-            int sl = 1;
-            int l = getIntFromByte(buffer.get());
-            if (l >= 254) {
-                l = getIntFromByte(buffer.get()) | (getIntFromByte(buffer.get()) << 8) | (getIntFromByte(buffer.get()) << 16);
-                sl = 4;
-            }
-            NativeByteBuffer b = new NativeByteBuffer(l);
-            int old = buffer.limit();
-            buffer.limit(buffer.position() + l);
-            b.buffer.put(buffer);
-            buffer.limit(old);
-            b.buffer.position(0);
-            int i = sl;
-            while((l + i) % 4 != 0) {
-                buffer.get();
-                i++;
-            }
-            return b;
-        } catch (Exception e) {
-            if (exception) {
-                throw new RuntimeException("read byte array error", e);
-            } else {
-                FileLog.e("tmessages", "read byte array error");
-            }
-        }
-        return null;
-    }
-
-    public double readDouble(boolean exception) {
-        try {
-            return Double.longBitsToDouble(readInt64(exception));
-        } catch(Exception e) {
-            if (exception) {
-                throw new RuntimeException("read double error", e);
-            } else {
-                FileLog.e("tmessages", "read double error");
-            }
-        }
-        return 0;
-    }
-
-    public void reuse() {
-        if (address != 0) {
-            native_reuse(address);
-        }
-    }
-
-    public static native int native_getFreeBuffer(int length);
-    public static native ByteBuffer native_getJavaByteBuffer(int address);
-    public static native int native_limit(int address);
-    public static native int native_position(int address);
-    public static native void native_reuse(int address);
-}
+package org.telegram.tgnet;
+
+import org.telegram.messenger.FileLog;
+
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+
+public class NativeByteBuffer extends AbstractSerializedData {
+
+    protected int address;
+    public ByteBuffer buffer;
+    private boolean justCalc = false;
+    private int len = 0;
+
+    private static final ThreadLocal<NativeByteBuffer> addressWrapper = new ThreadLocal<NativeByteBuffer>() {
+        @Override
+        protected NativeByteBuffer initialValue() {
+            return new NativeByteBuffer(0, true);
+        }
+    };
+
+    public static NativeByteBuffer wrap(int address) {
+        NativeByteBuffer result = addressWrapper.get();
+        if (address != 0) {
+            result.address = address;
+            result.buffer = native_getJavaByteBuffer(address);
+            result.buffer.limit(native_limit(address));
+            int position = native_position(address);
+            if (position <= result.buffer.limit()) {
+                result.buffer.position(position);
+            } else {
+                FileLog.e("tmessages", "what with position " + position);
+            }
+            result.buffer.order(ByteOrder.LITTLE_ENDIAN);
+        }
+        return result;
+    }
+
+    private NativeByteBuffer(int address, boolean wrap) {
+
+    }
+
+    public NativeByteBuffer(int size) throws Exception {
+        if (size >= 0) {
+            address = native_getFreeBuffer(size);
+            if (address != 0) {
+                buffer = native_getJavaByteBuffer(address);
+                buffer.position(0);
+                buffer.limit(size);
+                buffer.order(ByteOrder.LITTLE_ENDIAN);
+            }
+        } else {
+            throw new Exception("invalid NativeByteBuffer size");
+        }
+    }
+
+    public NativeByteBuffer(boolean calculate) {
+        justCalc = calculate;
+    }
+
+    public int position() {
+        return buffer.position();
+    }
+
+    public void position(int position) {
+        buffer.position(position);
+    }
+
+    public int capacity() {
+        return buffer.capacity();
+    }
+
+    public int limit() {
+        return buffer.limit();
+    }
+
+    public void limit(int limit) {
+        buffer.limit(limit);
+    }
+
+    public void put(ByteBuffer buff) {
+        buffer.put(buff);
+    }
+
+    public void rewind() {
+        if (justCalc) {
+            len = 0;
+        } else {
+            buffer.rewind();
+        }
+    }
+
+    public void compact() {
+        buffer.compact();
+    }
+
+    public boolean hasRemaining() {
+        return buffer.hasRemaining();
+    }
+
+    public void writeInt32(int x) {
+        try {
+            if (!justCalc) {
+                buffer.putInt(x);
+            } else {
+                len += 4;
+            }
+        } catch(Exception e) {
+            FileLog.e("tmessages", "write int32 error");
+        }
+    }
+
+    public void writeInt64(long x) {
+        try {
+            if (!justCalc) {
+                buffer.putLong(x);
+            } else {
+                len += 8;
+            }
+        } catch(Exception e) {
+            FileLog.e("tmessages", "write int64 error");
+        }
+    }
+
+    public void writeBool(boolean value) {
+        if (!justCalc) {
+            if (value) {
+                writeInt32(0x997275b5);
+            } else {
+                writeInt32(0xbc799737);
+            }
+        } else {
+            len += 4;
+        }
+    }
+
+    public void writeBytes(byte[] b) {
+        try {
+            if (!justCalc) {
+                buffer.put(b);
+            } else {
+                len += b.length;
+            }
+        } catch (Exception e) {
+            FileLog.e("tmessages", "write raw error");
+        }
+    }
+
+    public void writeBytes(byte[] b, int offset, int count) {
+        try {
+            if (!justCalc) {
+                buffer.put(b, offset, count);
+            } else {
+                len += count;
+            }
+        } catch (Exception e) {
+            FileLog.e("tmessages", "write raw error");
+        }
+    }
+
+    public void writeByte(int i) {
+        writeByte((byte) i);
+    }
+
+    public void writeByte(byte b) {
+        try {
+            if (!justCalc) {
+                buffer.put(b);
+            } else {
+                len += 1;
+            }
+        } catch (Exception e) {
+            FileLog.e("tmessages", "write byte error");
+        }
+    }
+
+    public void writeString(String s) {
+        try {
+            writeByteArray(s.getBytes("UTF-8"));
+        } catch(Exception e) {
+            FileLog.e("tmessages", "write string error");
+        }
+    }
+
+    public void writeByteArray(byte[] b, int offset, int count) {
+        try {
+            if(count <= 253) {
+                if (!justCalc) {
+                    buffer.put((byte)count);
+                } else {
+                    len += 1;
+                }
+            } else {
+                if (!justCalc) {
+                    buffer.put((byte)254);
+                    buffer.put((byte)count);
+                    buffer.put((byte)(count >> 8));
+                    buffer.put((byte)(count >> 16));
+                } else {
+                    len += 4;
+                }
+            }
+            if (!justCalc) {
+                buffer.put(b, offset, count);
+            } else {
+                len += count;
+            }
+            int i = count <= 253 ? 1 : 4;
+            while ((count + i) % 4 != 0) {
+                if (!justCalc) {
+                    buffer.put((byte)0);
+                } else {
+                    len += 1;
+                }
+                i++;
+            }
+        } catch (Exception e) {
+            FileLog.e("tmessages", "write byte array error");
+        }
+    }
+
+    public void writeByteArray(byte[] b) {
+        try {
+            if (b.length <= 253) {
+                if (!justCalc) {
+                    buffer.put((byte) b.length);
+                } else {
+                    len += 1;
+                }
+            } else {
+                if (!justCalc) {
+                    buffer.put((byte) 254);
+                    buffer.put((byte) b.length);
+                    buffer.put((byte) (b.length >> 8));
+                    buffer.put((byte) (b.length >> 16));
+                } else {
+                    len += 4;
+                }
+            }
+            if (!justCalc) {
+                buffer.put(b);
+            } else {
+                len += b.length;
+            }
+            int i = b.length <= 253 ? 1 : 4;
+            while((b.length + i) % 4 != 0) {
+                if (!justCalc) {
+                    buffer.put((byte) 0);
+                } else {
+                    len += 1;
+                }
+                i++;
+            }
+        } catch (Exception e) {
+            FileLog.e("tmessages", "write byte array error");
+        }
+    }
+
+    public void writeDouble(double d) {
+        try {
+            writeInt64(Double.doubleToRawLongBits(d));
+        } catch(Exception e) {
+            FileLog.e("tmessages", "write double error");
+        }
+    }
+
+    public void writeByteBuffer(NativeByteBuffer b) {
+        try {
+            int l = b.limit();
+            if (l <= 253) {
+                if (!justCalc) {
+                    buffer.put((byte) l);
+                } else {
+                    len += 1;
+                }
+            } else {
+                if (!justCalc) {
+                    buffer.put((byte) 254);
+                    buffer.put((byte) l);
+                    buffer.put((byte) (l >> 8));
+                    buffer.put((byte) (l >> 16));
+                } else {
+                    len += 4;
+                }
+            }
+            if (!justCalc) {
+                b.rewind();
+                buffer.put(b.buffer);
+            } else {
+                len += l;
+            }
+            int i = l <= 253 ? 1 : 4;
+            while((l + i) % 4 != 0) {
+                if (!justCalc) {
+                    buffer.put((byte) 0);
+                } else {
+                    len += 1;
+                }
+                i++;
+            }
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+    }
+
+    public void writeBytes(NativeByteBuffer b) {
+        if (justCalc) {
+            len += b.limit();
+        } else {
+            b.rewind();
+            buffer.put(b.buffer);
+        }
+    }
+
+    public int getIntFromByte(byte b) {
+        return b >= 0 ? b : ((int)b) + 256;
+    }
+
+    public int length() {
+        if (!justCalc) {
+            return buffer.position();
+        }
+        return len;
+    }
+
+    public void skip(int count) {
+        if (count == 0) {
+            return;
+        }
+        if (!justCalc) {
+            buffer.position(buffer.position() + count);
+        } else {
+            len += count;
+        }
+    }
+
+    public int getPosition() {
+        return buffer.position();
+    }
+
+    public int readInt32(boolean exception) {
+        try {
+            return buffer.getInt();
+        } catch (Exception e) {
+            if (exception) {
+                throw new RuntimeException("read int32 error", e);
+            } else {
+                FileLog.e("tmessages", "read int32 error");
+            }
+        }
+        return 0;
+    }
+
+    public boolean readBool(boolean exception) {
+        int consructor = readInt32(exception);
+        if (consructor == 0x997275b5) {
+            return true;
+        } else if (consructor == 0xbc799737) {
+            return false;
+        }
+        if (exception) {
+            throw new RuntimeException("Not bool value!");
+        } else {
+            FileLog.e("tmessages", "Not bool value!");
+        }
+        return false;
+    }
+
+    public long readInt64(boolean exception) {
+        try {
+            return buffer.getLong();
+        } catch (Exception e) {
+            if (exception) {
+                throw new RuntimeException("read int64 error", e);
+            } else {
+                FileLog.e("tmessages", "read int64 error");
+            }
+        }
+        return 0;
+    }
+
+    public void readBytes(byte[] b, boolean exception) {
+        try {
+            buffer.get(b);
+        } catch (Exception e) {
+            if (exception) {
+                throw new RuntimeException("read raw error", e);
+            } else {
+                FileLog.e("tmessages", "read raw error");
+            }
+        }
+    }
+
+    public byte[] readData(int count, boolean exception) {
+        byte[] arr = new byte[count];
+        readBytes(arr, exception);
+        return arr;
+    }
+
+    public String readString(boolean exception) {
+        try {
+            int sl = 1;
+            int l = getIntFromByte(buffer.get());
+            if(l >= 254) {
+                l = getIntFromByte(buffer.get()) | (getIntFromByte(buffer.get()) << 8) | (getIntFromByte(buffer.get()) << 16);
+                sl = 4;
+            }
+            byte[] b = new byte[l];
+            buffer.get(b);
+            int i = sl;
+            while((l + i) % 4 != 0) {
+                buffer.get();
+                i++;
+            }
+            return new String(b, "UTF-8");
+        } catch (Exception e) {
+            if (exception) {
+                throw new RuntimeException("read string error", e);
+            } else {
+                FileLog.e("tmessages", "read string error");
+            }
+        }
+        return null;
+    }
+
+    public byte[] readByteArray(boolean exception) {
+        try {
+            int sl = 1;
+            int l = getIntFromByte(buffer.get());
+            if (l >= 254) {
+                l = getIntFromByte(buffer.get()) | (getIntFromByte(buffer.get()) << 8) | (getIntFromByte(buffer.get()) << 16);
+                sl = 4;
+            }
+            byte[] b = new byte[l];
+            buffer.get(b);
+            int i = sl;
+            while((l + i) % 4 != 0) {
+                buffer.get();
+                i++;
+            }
+            return b;
+        } catch (Exception e) {
+            if (exception) {
+                throw new RuntimeException("read byte array error", e);
+            } else {
+                FileLog.e("tmessages", "read byte array error");
+            }
+        }
+        return null;
+    }
+
+    public NativeByteBuffer readByteBuffer(boolean exception) {
+        try {
+            int sl = 1;
+            int l = getIntFromByte(buffer.get());
+            if (l >= 254) {
+                l = getIntFromByte(buffer.get()) | (getIntFromByte(buffer.get()) << 8) | (getIntFromByte(buffer.get()) << 16);
+                sl = 4;
+            }
+            NativeByteBuffer b = new NativeByteBuffer(l);
+            int old = buffer.limit();
+            buffer.limit(buffer.position() + l);
+            b.buffer.put(buffer);
+            buffer.limit(old);
+            b.buffer.position(0);
+            int i = sl;
+            while((l + i) % 4 != 0) {
+                buffer.get();
+                i++;
+            }
+            return b;
+        } catch (Exception e) {
+            if (exception) {
+                throw new RuntimeException("read byte array error", e);
+            } else {
+                FileLog.e("tmessages", "read byte array error");
+            }
+        }
+        return null;
+    }
+
+    public double readDouble(boolean exception) {
+        try {
+            return Double.longBitsToDouble(readInt64(exception));
+        } catch(Exception e) {
+            if (exception) {
+                throw new RuntimeException("read double error", e);
+            } else {
+                FileLog.e("tmessages", "read double error");
+            }
+        }
+        return 0;
+    }
+
+    public void reuse() {
+        if (address != 0) {
+            native_reuse(address);
+        }
+    }
+
+    public static native int native_getFreeBuffer(int length);
+    public static native ByteBuffer native_getJavaByteBuffer(int address);
+    public static native int native_limit(int address);
+    public static native int native_position(int address);
+    public static native void native_reuse(int address);
+}
