diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Emoji.java b/TMessagesProj/src/main/java/org/telegram/messenger/Emoji.java
index bbcaf337d..c18a06e9f 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Emoji.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/Emoji.java
@@ -25,12 +25,15 @@
 import android.text.Spannable;
 import android.text.Spanned;
 import android.text.TextPaint;
+import android.text.style.CharacterStyle;
 import android.text.style.DynamicDrawableSpan;
 import android.text.style.ImageSpan;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.TextView;
 
+import org.telegram.ui.Components.TypefaceSpan;
+
 public class Emoji {
     private static HashMap<CharSequence, DrawableInfo> rects = new HashMap<>();
     private static int drawImgSize;
@@ -353,7 +356,7 @@ public static CharSequence replaceEmoji(CharSequence cs, Paint.FontMetricsInt fo
         StringBuilder addionalCode = new StringBuilder(2);
         boolean nextIsSkinTone;
         EmojiDrawable drawable;
-        EmojiSpan span;
+        CharacterStyle span;
         int length = cs.length();
         boolean doneEmoji = false;
         int nextValidLength;
@@ -451,7 +454,9 @@ public static CharSequence replaceEmoji(CharSequence cs, Paint.FontMetricsInt fo
                     }
                     drawable = Emoji.getEmojiDrawable(emojiCode.subSequence(0, emojiCode.length()));
                     if (drawable != null) {
-                        span = new EmojiSpan(drawable, DynamicDrawableSpan.ALIGN_BOTTOM, size, fontMetrics);
+                        //span = new EmojiSpan(drawable, DynamicDrawableSpan.ALIGN_BOTTOM, size, fontMetrics);
+                        span = new TypefaceSpan(AndroidUtilities.getTypeface("NotoColorEmoji.ttf"));
+                        //span = new TypefaceSpan(AndroidUtilities.getTypeface("fonts/NotoColorEmoji.ttf"));
                         s.setSpan(span, startIndex, startIndex + startLength, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
                         emojiCount++;
                     }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/EmojiView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/EmojiView.java
index db5717ec8..2d6facecc 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/EmojiView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/EmojiView.java
@@ -166,7 +166,7 @@ private static String addColorToCode(String code, String color) {
         return code;
     }
 
-    private class ImageViewEmoji extends ImageView {
+    private class ImageViewEmoji extends ForegroundTextView {
 
         private boolean touched;
         private float lastX;
@@ -235,8 +235,12 @@ public boolean onLongClick(View view) {
                     return false;
                 }
             });
-            setBackgroundDrawable(Theme.getSelectorDrawable(false));
-            setScaleType(ImageView.ScaleType.CENTER);
+            setBackgroundResource(R.drawable.list_selector_ex);
+            setGravity(Gravity.CENTER);
+            setTypeface(AndroidUtilities.getTypeface("NotoColorEmoji.ttf"));
+            //setTypeface(AndroidUtilities.getTypeface("fonts/NotoColorEmoji.ttf"));
+            setTextColor(0xff000000);
+            setForegroundGravity(Gravity.CENTER);
         }
 
         private void sendEmoji(String override) {
@@ -281,6 +285,9 @@ private void sendEmoji(String override) {
         @Override
         public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
             setMeasuredDimension(View.MeasureSpec.getSize(widthMeasureSpec), View.MeasureSpec.getSize(widthMeasureSpec));
+            if (getPaint().getTextSize() != 0.6f * getMeasuredWidth()) {
+                getPaint().setTextSize(0.6f * getMeasuredWidth());
+            }
         }
 
         @Override
@@ -316,7 +323,9 @@ public boolean onTouchEvent(MotionEvent event) {
                             } else {
                                 emojiColor.remove(code);
                             }
-                            setImageDrawable(Emoji.getEmojiBigDrawable(code));
+                            setText(code);
+                            setForeground(null);
+
                             sendEmoji(null);
                             saveEmojiColors();
                         } else {
@@ -475,6 +484,7 @@ public void dismiss() {
         private int selection;
         private Paint rectPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
         private RectF rect = new RectF();
+        private Paint textPaint = new Paint();
 
         public void setEmoji(String emoji, int arrowPosition) {
             currentEmoji = emoji;
@@ -504,6 +514,10 @@ public EmojiColorPickerView(Context context) {
 
             backgroundDrawable = getResources().getDrawable(R.drawable.stickers_back_all);
             arrowDrawable = getResources().getDrawable(R.drawable.stickers_back_arrow);
+
+            textPaint.setTypeface(AndroidUtilities.getTypeface("NotoColorEmoji.ttf"));
+            //textPaint.setTypeface(AndroidUtilities.getTypeface("fonts/NotoColorEmoji.ttf"));
+            textPaint.setColor(0xff000000);
         }
 
         @Override
@@ -547,11 +561,8 @@ protected void onDraw(Canvas canvas) {
                         }
                         code = addColorToCode(code, color);
                     }
-                    Drawable drawable = Emoji.getEmojiBigDrawable(code);
-                    if (drawable != null) {
-                        drawable.setBounds(x, y, x + emojiSize, y + emojiSize);
-                        drawable.draw(canvas);
-                    }
+                    textPaint.setTextSize(emojiSize * 0.8f);
+                    canvas.drawText(code, x, y + emojiSize * 0.8f, textPaint);
                 }
             }
         }
@@ -2335,7 +2346,8 @@ public View getView(int position, View view, ViewGroup paramViewGroup) {
                     coloredCode = addColorToCode(coloredCode, color);
                 }
             }
-            imageView.setImageDrawable(Emoji.getEmojiBigDrawable(coloredCode));
+            imageView.setText(code);
+            imageView.setForeground(null);
             imageView.setTag(code);
             return imageView;
         }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/ForegroundTextView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/ForegroundTextView.java
new file mode 100644
index 000000000..8ef21b19f
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/ForegroundTextView.java
@@ -0,0 +1,198 @@
+package org.telegram.ui.Components;
+
+import android.content.Context;
+import android.graphics.*;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.util.AttributeSet;
+import android.view.Gravity;
+import android.widget.TextView;
+
+/**
+ * Created by Rikka on 2016/10/17.
+ */
+
+public class ForegroundTextView extends TextView {
+
+    private Drawable mForeground;
+
+    private final android.graphics.Rect mSelfBounds = new android.graphics.Rect();
+
+    private final android.graphics.Rect mOverlayBounds = new android.graphics.Rect();
+
+    private int mForegroundGravity = Gravity.FILL;
+
+    protected boolean mForegroundInPadding = true;
+
+    boolean mForegroundBoundsChanged = false;
+
+    public ForegroundTextView(Context context) {
+        this(context, null);
+    }
+
+    public ForegroundTextView(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public ForegroundTextView(Context context, AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+    }
+
+    /**
+     * Describes how the foreground is positioned.
+     *
+     * @return foreground gravity.
+     * @see #setForegroundGravity(int)
+     */
+    public int getForegroundGravity() {
+        return mForegroundGravity;
+    }
+
+    /**
+     * Describes how the foreground is positioned. Defaults to START and TOP.
+     *
+     * @param foregroundGravity See {@link android.view.Gravity}
+     * @see #getForegroundGravity()
+     */
+    public void setForegroundGravity(int foregroundGravity) {
+        if (mForegroundGravity != foregroundGravity) {
+            if ((foregroundGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK) == 0) {
+                foregroundGravity |= Gravity.START;
+            }
+
+            if ((foregroundGravity & Gravity.VERTICAL_GRAVITY_MASK) == 0) {
+                foregroundGravity |= Gravity.TOP;
+            }
+
+            mForegroundGravity = foregroundGravity;
+
+            if (mForegroundGravity == Gravity.FILL && mForeground != null) {
+                android.graphics.Rect padding = new android.graphics.Rect();
+                mForeground.getPadding(padding);
+            }
+
+            requestLayout();
+        }
+    }
+
+    @Override
+    protected boolean verifyDrawable(Drawable who) {
+        return super.verifyDrawable(who) || (who == mForeground);
+    }
+
+    @Override
+    public void jumpDrawablesToCurrentState() {
+        super.jumpDrawablesToCurrentState();
+        if (mForeground != null) {
+            mForeground.jumpToCurrentState();
+        }
+    }
+
+    @Override
+    protected void drawableStateChanged() {
+        super.drawableStateChanged();
+        if (mForeground != null && mForeground.isStateful()) {
+            mForeground.setState(getDrawableState());
+        }
+    }
+
+    /**
+     * Supply a Drawable that is to be rendered on top of all of the child
+     * views in the frame layout.  Any padding in the Drawable will be taken
+     * into account by ensuring that the children are inset to be placed
+     * inside of the padding area.
+     *
+     * @param drawable The Drawable to be drawn on top of the children.
+     */
+    public void setForeground(Drawable drawable) {
+        if (mForeground != drawable) {
+            if (mForeground != null) {
+                mForeground.setCallback(null);
+                unscheduleDrawable(mForeground);
+            }
+
+            mForeground = drawable;
+
+            if (drawable != null) {
+                setWillNotDraw(false);
+                drawable.setCallback(this);
+                if (drawable.isStateful()) {
+                    drawable.setState(getDrawableState());
+                }
+                if (mForegroundGravity == Gravity.FILL) {
+                    android.graphics.Rect padding = new android.graphics.Rect();
+                    drawable.getPadding(padding);
+                }
+            } else {
+                setWillNotDraw(true);
+            }
+            requestLayout();
+            invalidate();
+        }
+    }
+
+    /**
+     * Returns the drawable used as the foreground of this FrameLayout. The
+     * foreground drawable, if non-null, is always drawn on top of the children.
+     *
+     * @return A Drawable or null if no foreground was set.
+     */
+    public Drawable getForeground() {
+        return mForeground;
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+        super.onLayout(changed, left, top, right, bottom);
+        mForegroundBoundsChanged |= changed;
+    }
+
+    @Override
+    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+        super.onSizeChanged(w, h, oldw, oldh);
+        mForegroundBoundsChanged = true;
+    }
+
+    @Override
+    public void draw(@NonNull Canvas canvas) {
+        super.draw(canvas);
+
+        if (mForeground != null) {
+            final Drawable foreground = mForeground;
+
+            if (mForegroundBoundsChanged) {
+                mForegroundBoundsChanged = false;
+                final android.graphics.Rect selfBounds = mSelfBounds;
+                final Rect overlayBounds = mOverlayBounds;
+
+                final int w = getRight() - getLeft();
+                final int h = getBottom() - getTop();
+
+                if (mForegroundInPadding) {
+                    selfBounds.set(0, 0, w, h);
+                } else {
+                    selfBounds.set(getPaddingLeft(), getPaddingTop(),
+                            w - getPaddingRight(), h - getPaddingBottom());
+                }
+
+                Gravity.apply(mForegroundGravity, foreground.getIntrinsicWidth(),
+                        foreground.getIntrinsicHeight(), selfBounds, overlayBounds);
+                foreground.setBounds(overlayBounds);
+            }
+
+            foreground.draw(canvas);
+        }
+    }
+
+    @Override
+    public void drawableHotspotChanged(float x, float y) {
+        super.drawableHotspotChanged(x, y);
+        if (mForeground != null) {
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+                mForeground.setHotspot(x, y);
+            }
+        }
+    }
+}
\ No newline at end of file
