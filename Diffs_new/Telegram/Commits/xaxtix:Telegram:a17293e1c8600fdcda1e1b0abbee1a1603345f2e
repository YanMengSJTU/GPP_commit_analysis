diff --git a/TMessagesProj/jni/ffmpeg/arm64/libx264.a b/TMessagesProj/jni/ffmpeg/arm64/libx264.a
new file mode 100644
index 000000000..4e90a3ffc
Binary files /dev/null and b/TMessagesProj/jni/ffmpeg/arm64/libx264.a differ
diff --git a/TMessagesProj/jni/ffmpeg/armv7-a/libx264.a b/TMessagesProj/jni/ffmpeg/armv7-a/libx264.a
new file mode 100644
index 000000000..2a84d8de0
Binary files /dev/null and b/TMessagesProj/jni/ffmpeg/armv7-a/libx264.a differ
diff --git a/TMessagesProj/jni/ffmpeg/i686/libx264.a b/TMessagesProj/jni/ffmpeg/i686/libx264.a
new file mode 100644
index 000000000..f0765f76a
Binary files /dev/null and b/TMessagesProj/jni/ffmpeg/i686/libx264.a differ
diff --git a/TMessagesProj/jni/ffmpeg/x86_64/libx264.a b/TMessagesProj/jni/ffmpeg/x86_64/libx264.a
new file mode 100644
index 000000000..419c8c853
Binary files /dev/null and b/TMessagesProj/jni/ffmpeg/x86_64/libx264.a differ
diff --git a/TMessagesProj/jni/video-compress.c b/TMessagesProj/jni/video-compress.c
index 79ea92f65..8fb0b0242 100644
--- a/TMessagesProj/jni/video-compress.c
+++ b/TMessagesProj/jni/video-compress.c
@@ -372,6 +372,12 @@ int compress_video(const char *src_in, const char *src_out, struct Context *cont
                     break;
                 }
 
+                if (dataBufSize == 3 && dataBuf[0] == 0x00 && dataBuf[1] == 0x00 &&
+                    dataBuf[2] == 0x12) {
+                    ret = -1;
+                    goto end;
+                }
+
                 AVPacket enc_pkt;
                 av_init_packet(&enc_pkt);
                 enc_pkt.data = NULL;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/MediaController.java b/TMessagesProj/src/main/java/org/telegram/messenger/MediaController.java
index dc9cc9cf6..2f0bd0166 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/MediaController.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/MediaController.java
@@ -3619,11 +3619,8 @@ public static void runConversion(final MessageObject obj) {
         }
     }
 
-    private boolean convertVideo(MessageObject messageObject) {
-        return convertVideo(messageObject, 2500);
-    }
 
-    private boolean convertVideo(final MessageObject messageObject, int timoutUsec) {
+    private boolean convertVideo(final MessageObject messageObject) {
         if (messageObject == null || messageObject.videoEditedInfo == null) {
             return false;
         }
@@ -3704,7 +3701,6 @@ public void updateProgress(float progress) {
                 long availableSize = cacheFile.length();
                 if(availableSize > lastLength) {
                     lastLength = availableSize;
-                    Log.d("kek","ffmpeg " + availableSize);
                     MediaController.this.didWriteData(messageObject, cacheFile, false, availableSize, false);
                 }
             }
@@ -3712,14 +3708,12 @@ public void updateProgress(float progress) {
             @Override
             public void didWriteData(long availableSize) {
                 if (messageObject.videoEditedInfo.canceled) return;
-                Log.d("kek","mediacodec " + availableSize);
                 MediaController.this.didWriteData(messageObject, cacheFile, false, availableSize, false);
             }
         };
 
         messageObject.videoEditedInfo.videoConvertFirstWrite = true;
         boolean error = false;
-        boolean mediacodec = true;
 
         MediaExtractor extractor = new MediaExtractor();
 
@@ -3742,7 +3736,6 @@ public void didWriteData(long availableSize) {
 
         if(needCompress && duration < 25_000000 && !isSecret && copyAudioStream) {
             try {
-                mediacodec = false;
                 FfmpegVideoConvertor convertor = new FfmpegVideoConvertor();
                 error = convertor.convertVideo(videoPath, cacheFile.getAbsolutePath(),
                         rotationValue,
@@ -3772,13 +3765,9 @@ public void didWriteData(long availableSize) {
             }
         }
 
-        int p = Math.min(resultHeight, resultWidth);
-
-        Log.d("kek", "mediacodec " + mediacodec +
-                " " + p + "p " +
-                " bitrate: " + bitrate +
-                " convert time: " + ((System.currentTimeMillis() - time) / 1000f) + "s " +
-                " file size= " + (cacheFile.length() / (1024 * 1024)) + "mb");
+        if (BuildVars.LOGS_ENABLED) {
+            FileLog.d("time = " + (System.currentTimeMillis() - time) + " canceled = " + canceled);
+        }
 
         preferences.edit().putBoolean("isPreviousOk", true).apply();
         didWriteData(messageObject, cacheFile, true, cacheFile.length(), error || canceled);
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/video/FfmpegVideoConvertor.java b/TMessagesProj/src/main/java/org/telegram/messenger/video/FfmpegVideoConvertor.java
index df60bdb5b..4a5975827 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/video/FfmpegVideoConvertor.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/video/FfmpegVideoConvertor.java
@@ -5,6 +5,7 @@
 import android.media.MediaFormat;
 import android.os.Build;
 
+import org.telegram.messenger.FileLog;
 import org.telegram.messenger.MediaController;
 import org.telegram.messenger.Utilities;
 
@@ -16,6 +17,7 @@
 public class FfmpegVideoConvertor {
 
     private final ByteBuffer endOfStream;
+    private final ByteBuffer errorBufer;
 
     private MediaCodec decoder;
     private OutputSurface outputSurface;
@@ -35,6 +37,11 @@ public FfmpegVideoConvertor() {
         endOfStream.put(0, (byte) 0x00);
         endOfStream.put(1, (byte) 0x00);
         endOfStream.put(2, (byte) 0x08);
+
+        errorBufer = ByteBuffer.allocateDirect(3);
+        errorBufer.put(0, (byte) 0x00);
+        errorBufer.put(1, (byte) 0x00);
+        errorBufer.put(2, (byte) 0x12);
     }
 
     public boolean convertVideo(String videoPath, String outPath,
@@ -58,7 +65,7 @@ public boolean convertVideo(String videoPath, String outPath,
         MediaFormat videoFormat = extractor.getTrackFormat(videoTrackIndex);
 
         decoder = MediaCodec.createDecoderByType(videoFormat.getString(MediaFormat.KEY_MIME));
-        outputSurface = new OutputSurface(resultWidth, resultHeight, rotate,true);
+        outputSurface = new OutputSurface(resultWidth, resultHeight, rotate, true);
 
         decoder.configure(videoFormat, outputSurface.getSurface(), null, 0);
         decoder.start();
@@ -88,85 +95,90 @@ public ByteBuffer pullDecoder() {
         ByteBuffer rgbBuf = null;
         if (inputDone && outputDone) return endOfStream;
 
-        if (!inputDone) {
-            int trackIndex;
-            while (true) {
-                trackIndex = extractor.getSampleTrackIndex();
-                if (trackIndex < 0) {
-                    inputDone = true;
-                    break;
-                }
-                if (trackIndex == videoTrackIndex) {
-                    break;
+        try {
+            if (!inputDone) {
+                int trackIndex;
+                while (true) {
+                    trackIndex = extractor.getSampleTrackIndex();
+                    if (trackIndex < 0) {
+                        inputDone = true;
+                        break;
+                    }
+                    if (trackIndex == videoTrackIndex) {
+                        break;
+                    }
+                    extractor.advance();
                 }
-                extractor.advance();
-            }
 
-            if (trackIndex == videoTrackIndex) {
-                int inputBufIndex = decoder.dequeueInputBuffer(0);
-                if (endTime > 0 && extractor.getSampleTime() > endTime) {
-                    inputDone = true;
-                } else {
-                    if (inputBufIndex >= 0) {
-                        ByteBuffer inputBuf;
-                        if (Build.VERSION.SDK_INT < 21) {
-                            inputBuf = decoder.getInputBuffers()[inputBufIndex];
-                        } else {
-                            inputBuf = decoder.getInputBuffer(inputBufIndex);
-                        }
-                        int chunkSize = extractor.readSampleData(inputBuf, 0);
-
-                        if (chunkSize < 0) {
-                            decoder.queueInputBuffer(inputBufIndex, 0, 0, 0L, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
-                            inputDone = true;
-                        } else {
-                            decoder.queueInputBuffer(inputBufIndex, 0, chunkSize, extractor.getSampleTime(), 0);
-                            extractor.advance();
+                if (trackIndex == videoTrackIndex) {
+                    int inputBufIndex = decoder.dequeueInputBuffer(0);
+                    if (endTime > 0 && extractor.getSampleTime() > endTime) {
+                        inputDone = true;
+                    } else {
+                        if (inputBufIndex >= 0) {
+                            ByteBuffer inputBuf;
+                            if (Build.VERSION.SDK_INT < 21) {
+                                inputBuf = decoder.getInputBuffers()[inputBufIndex];
+                            } else {
+                                inputBuf = decoder.getInputBuffer(inputBufIndex);
+                            }
+                            int chunkSize = extractor.readSampleData(inputBuf, 0);
+
+                            if (chunkSize < 0) {
+                                decoder.queueInputBuffer(inputBufIndex, 0, 0, 0L, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
+                                inputDone = true;
+                            } else {
+                                decoder.queueInputBuffer(inputBufIndex, 0, chunkSize, extractor.getSampleTime(), 0);
+                                extractor.advance();
+                            }
                         }
                     }
                 }
             }
-        }
 
-        if (!outputDone) {
-            int decoderStatus = decoder.dequeueOutputBuffer(info, 2500);
-            if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {
-                if (inputDone) {
-                    outputDone = true;
-                    return endOfStream;
-                }
-            } else if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
-
-            } else if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
-
-            } else if (decoderStatus < 0) {
-                throw new RuntimeException("unexpected result from decoder.dequeueOutputBuffer: " + decoderStatus);
-            } else {
-                if (info.size > 0) {
-                    boolean doRender = info.presentationTimeUs > startTime;
-                    decoder.releaseOutputBuffer(decoderStatus, doRender);
-                    if(doRender) {
-                        try {
-                            outputSurface.awaitNewImage();
-                            outputSurface.drawImage(false);
-                            rgbBuf = outputSurface.getFrame();
-                        } catch (Exception e) {
+            if (!outputDone) {
+                int decoderStatus = decoder.dequeueOutputBuffer(info, 2500);
+                if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {
+                    if (inputDone) {
+                        outputDone = true;
+                        return endOfStream;
+                    }
+                } else if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
+
+                } else if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
 
+                } else if (decoderStatus < 0) {
+                    throw new RuntimeException("unexpected result from decoder.dequeueOutputBuffer: " + decoderStatus);
+                } else {
+                    if (info.size > 0) {
+                        boolean doRender = info.presentationTimeUs > startTime;
+                        decoder.releaseOutputBuffer(decoderStatus, doRender);
+                        if (doRender) {
+                            try {
+                                outputSurface.awaitNewImage();
+                                outputSurface.drawImage(false);
+                                rgbBuf = outputSurface.getFrame();
+                            } catch (Exception e) {
+
+                            }
                         }
                     }
                 }
             }
+        } catch (Exception e) {
+            FileLog.e(e);
+            return errorBufer;
         }
         return rgbBuf;
     }
 
     public boolean checkConversionCanceled() {
-        if(callback != null) return callback.checkConversionCanceled();
+        if (callback != null) return callback.checkConversionCanceled();
         return false;
     }
 
-    public void updateProgress(float progress){
-        if(callback != null) callback.updateProgress(progress);
+    public void updateProgress(float progress) {
+        if (callback != null) callback.updateProgress(progress);
     }
 
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/video/MediaCodecVideoConvertor.java b/TMessagesProj/src/main/java/org/telegram/messenger/video/MediaCodecVideoConvertor.java
index 056ffab2e..8557405d1 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/video/MediaCodecVideoConvertor.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/video/MediaCodecVideoConvertor.java
@@ -40,9 +40,21 @@ public boolean convertVideo(String videoPath, File cacheFile,
                                 int framerate, int bitrate,
                                 long startTime, long endTime,
                                 boolean needCompress,
-                                MediaController.VideoConvertorListener callback){
+                                MediaController.VideoConvertorListener callback) {
         this.callback = callback;
+        return convertVideoInternal(videoPath, cacheFile, rotationValue, isSecret,
+                resultWidth, resultHeight, framerate, bitrate, startTime, endTime, needCompress, false);
+    }
+
+    private boolean convertVideoInternal(String videoPath, File cacheFile,
+                                         int rotationValue, boolean isSecret,
+                                         int resultWidth, int resultHeight,
+                                         int framerate, int bitrate,
+                                         long startTime, long endTime,
+                                         boolean needCompress, boolean increaseTimeout) {
+
         boolean error = false;
+        boolean repeatWithIncreasedTimeout = false;
 
         try {
             MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();
@@ -55,7 +67,6 @@ public boolean convertVideo(String videoPath, File cacheFile,
             extractor.setDataSource(videoPath);
 
 
-
             checkConversionCanceled();
 
             if (needCompress) {
@@ -226,7 +237,7 @@ public boolean convertVideo(String videoPath, File cacheFile,
                         if (Build.VERSION.SDK_INT >= 18) {
                             outputSurface = new OutputSurface();
                         } else {
-                            outputSurface = new OutputSurface(resultWidth, resultHeight, rotationValue,false);
+                            outputSurface = new OutputSurface(resultWidth, resultHeight, rotationValue, false);
                         }
                         decoder.configure(videoFormat, outputSurface.getSurface(), null, 0);
                         decoder.start();
@@ -318,7 +329,8 @@ public boolean convertVideo(String videoPath, File cacheFile,
                                         info.flags = extractor.getSampleFlags();
                                         long availableSize = mediaMuxer.writeSampleData(audioTrackIndex, audioBuffer, info, false);
                                         if (availableSize != 0) {
-                                            if(callback != null) callback.didWriteData(availableSize);
+                                            if (callback != null)
+                                                callback.didWriteData(availableSize);
                                         }
                                     }
                                 } else if (index == -1) {
@@ -337,7 +349,7 @@ public boolean convertVideo(String videoPath, File cacheFile,
                             boolean encoderOutputAvailable = true;
                             while (decoderOutputAvailable || encoderOutputAvailable) {
                                 checkConversionCanceled();
-                                int encoderStatus = encoder.dequeueOutputBuffer(info, 2500);
+                                int encoderStatus = encoder.dequeueOutputBuffer(info, increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);
                                 if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {
                                     encoderOutputAvailable = false;
                                 } else if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
@@ -365,7 +377,8 @@ public boolean convertVideo(String videoPath, File cacheFile,
                                         if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {
                                             long availableSize = mediaMuxer.writeSampleData(videoTrackIndex, encodedData, info, true);
                                             if (availableSize != 0) {
-                                                if(callback != null) callback.didWriteData(availableSize);
+                                                if (callback != null)
+                                                    callback.didWriteData(availableSize);
                                             }
                                         } else if (videoTrackIndex == -5) {
                                             byte[] csd = new byte[info.size];
@@ -492,9 +505,9 @@ public boolean convertVideo(String videoPath, File cacheFile,
                         // in some case encoder.dequeueOutputBuffer return IllegalStateException
                         // stable reproduced on xiaomi
                         // fix it by increasing timeout
-//                        if (e instanceof IllegalStateException && timoutUsec != MEDIACODEC_TIMEOUT_INCREASED) {
-//                            repeatWithIncreasedTimeout = true;
-//                        }
+                        if (e instanceof IllegalStateException && !increaseTimeout) {
+                            repeatWithIncreasedTimeout = true;
+                        }
                         e.printStackTrace();
                         FileLog.e("bitrate: " + bitrate + " framerate: " + framerate + " size: " + resultHeight + "x" + resultWidth);
                         FileLog.e(e);
@@ -541,9 +554,11 @@ public boolean convertVideo(String videoPath, File cacheFile,
                     FileLog.e(e);
                 }
             }
-            if (BuildVars.LOGS_ENABLED) {
-               // FileLog.d("time = " + (System.currentTimeMillis() - time));
-            }
+        }
+
+        if (repeatWithIncreasedTimeout) {
+            return convertVideoInternal(videoPath, cacheFile, rotationValue, isSecret,
+                    resultWidth, resultHeight, framerate, bitrate, startTime, endTime, needCompress, true);
         }
 
         return error;
@@ -639,7 +654,7 @@ private long readAndWriteTracks(MediaExtractor extractor, MP4Builder mediaMuxer,
                             info.flags = extractor.getSampleFlags();
                             long availableSize = mediaMuxer.writeSampleData(muxerTrackIndex, buffer, info, false);
                             if (availableSize != 0) {
-                                if(callback != null) callback.didWriteData(availableSize);
+                                if (callback != null) callback.didWriteData(availableSize);
                             }
                         } else {
                             eof = true;
@@ -669,6 +684,7 @@ private long readAndWriteTracks(MediaExtractor extractor, MP4Builder mediaMuxer,
     }
 
     private void checkConversionCanceled() {
-        if(callback != null && callback.checkConversionCanceled())  throw new RuntimeException("canceled conversion");
+        if (callback != null && callback.checkConversionCanceled())
+            throw new RuntimeException("canceled conversion");
     }
 }
