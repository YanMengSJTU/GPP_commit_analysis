diff --git a/rxandroid/src/main/java/rx/android/lifecycle/LifecycleHelper.java b/rxandroid/src/main/java/rx/android/lifecycle/LifecycleHelper.java
deleted file mode 100644
index 59d0d16b..00000000
--- a/rxandroid/src/main/java/rx/android/lifecycle/LifecycleHelper.java
+++ /dev/null
@@ -1,92 +0,0 @@
-package rx.android.lifecycle;
-
-import android.app.Activity;
-import android.app.Application;
-import android.os.Bundle;
-
-import rx.subjects.BehaviorSubject;
-
-/**
- * This instance lives within the scope of an {@code Activity} in order to forward Lifecycle events
- * to {@link rx.subjects.BehaviorSubject}
- *
- * Thread safe, since it's <i>Thread-confined</i> to the main Thread.
- *
- * @author Nabil Hachicha.
- */
-class LifecycleHelper implements Application.ActivityLifecycleCallbacks {
-    private final Activity activityToMonitor;
-    private final BehaviorSubject<LifecycleEvent> lifecycleSubject;
-    /**
-     * Help track if {@link #onActivityCreated(Activity, Bundle)} was called
-     */
-    private boolean isCreateCalled = false;
-    /**
-     * Help track if {@link #onActivityStarted(Activity)} was called
-     */
-    private boolean isStarted = false;
-
-    public LifecycleHelper(Activity instance, BehaviorSubject<LifecycleEvent> lifecycle) {
-        activityToMonitor = instance;
-        lifecycleSubject = lifecycle;
-    }
-
-    @Override
-    public void onActivityCreated(Activity activity, Bundle bundle) {
-        // We may have independents instance of the same Activity in the activity stack
-        // this is why we use identity comparison
-        if (activity == activityToMonitor) {
-            lifecycleSubject.onNext(LifecycleEvent.CREATE);
-            isCreateCalled = true;
-        }
-    }
-
-    @Override
-    public void onActivityStarted(Activity activity) {
-        if (activity == activityToMonitor) {
-            if (!isCreateCalled) {//client bound onStart, sending missed event
-                isCreateCalled = true;
-                lifecycleSubject.onNext(LifecycleEvent.CREATE);
-            }
-            lifecycleSubject.onNext(LifecycleEvent.START);
-            isStarted = true;
-        }
-    }
-
-    @Override
-    public void onActivityResumed(Activity activity) {
-        if (activity == activityToMonitor) {
-            if (!isStarted) {//client bound onStart, sending missed event
-                isStarted = true;
-                lifecycleSubject.onNext(LifecycleEvent.START);
-            }
-            lifecycleSubject.onNext(LifecycleEvent.RESUME);
-        }
-    }
-
-    @Override
-    public void onActivityPaused(Activity activity) {
-        if (activity == activityToMonitor) {
-            lifecycleSubject.onNext(LifecycleEvent.PAUSE);
-        }
-    }
-
-    @Override
-    public void onActivityStopped(Activity activity) {
-        if (activity == activityToMonitor) {
-            lifecycleSubject.onNext(LifecycleEvent.STOP);
-        }
-    }
-
-    @Override
-    public void onActivitySaveInstanceState(Activity activity, Bundle bundle) {}
-
-    @Override
-    public void onActivityDestroyed(Activity activity) {
-        if (activity == activityToMonitor) {
-            lifecycleSubject.onNext(LifecycleEvent.DESTROY);
-            //No more callback after this, it's safe to unregister this listener
-            activity.getApplication().unregisterActivityLifecycleCallbacks(this);
-        }
-    }
-}
diff --git a/rxandroid/src/main/java/rx/android/lifecycle/LifecycleObservable.java b/rxandroid/src/main/java/rx/android/lifecycle/LifecycleObservable.java
index e0b9567d..138e6945 100644
--- a/rxandroid/src/main/java/rx/android/lifecycle/LifecycleObservable.java
+++ b/rxandroid/src/main/java/rx/android/lifecycle/LifecycleObservable.java
@@ -21,7 +21,6 @@
 import rx.Observable;
 import rx.functions.Func1;
 import rx.functions.Func2;
-import rx.subjects.BehaviorSubject;
 
 public class LifecycleObservable {
 
@@ -83,21 +82,36 @@ public Boolean call(LifecycleEvent lifecycleEvent) {
      *
      * @param activity the activity we want to monitor lifecycle sequence for
      * @param source   the source sequence
+     * @param bindEvent the binding {@link LifecycleEvent} associated with the <code>source</code> Observable.
+     * <p>
+     * This helps figuring out the corresponding next lifecycle event in which to unsubscribe.
+     * <pre> {@code
+     *  @Override
+     *  protected void onStart() {
+     *      super.onStart();
+     *      subscription = LifecycleObservable.bindActivityLifecycle(
+     *          this,
+     *          ViewObservable.clicks(button),
+     *          LifecycleEvent.START)
+     *         .subscribe(...);
+     * }</pre>
      */
-
     @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-    public static <T> Observable<T> bindActivityLifecycle(Activity activity, Observable<T> source) {
+    public static <T> Observable<T> bindActivityLifecycle(Activity activity, Observable<T> source, final LifecycleEvent bindEvent) {
         // Make sure we're running on ICS or higher to use ActivityLifecycleCallbacks
         if (Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
             throw new IllegalStateException ("This method is only available on API >= 14");
+        }
 
-        } else {
-            final BehaviorSubject<LifecycleEvent> lifecycleSubject = BehaviorSubject.create();
+        OnSubscribeActivityLifecycleCallbacks lifecycleCallbacks = new OnSubscribeActivityLifecycleCallbacks(activity);
+        Observable<T> observable =  bindLifecycle(
+                Observable.create(lifecycleCallbacks),
+                source,
+                bindEvent);
 
-            activity.getApplication().registerActivityLifecycleCallbacks(new LifecycleHelper(activity, lifecycleSubject));
+        activity.getApplication().registerActivityLifecycleCallbacks(lifecycleCallbacks);
 
-            return LifecycleObservable.bindActivityLifecycle(lifecycleSubject.asObservable(), source);
-        }
+        return observable;
     }
 
     /**
@@ -151,6 +165,39 @@ public Boolean call(Boolean shouldComplete) {
         );
     }
 
+    private static <T> Observable<T> bindLifecycle(Observable<LifecycleEvent> lifecycle,
+                                                   Observable<T> source,
+                                                   LifecycleEvent registerEvent) {
+        if (lifecycle == null || source == null) {
+            throw new IllegalArgumentException("Lifecycle and Observable must be given");
+        }
+
+        // Make sure we're truly comparing a single stream to itself
+        Observable<LifecycleEvent> sharedLifecycle = lifecycle.share();
+        final Observable<LifecycleEvent> bindUntil = Observable.just(getActivityStoppingLifecycleEvent(registerEvent));
+
+        // Keep emitting from source until the corresponding event occurs in the lifecycle
+        return source.lift(
+                new OperatorSubscribeUntil<T, Boolean>(
+                        Observable.combineLatest(
+                                bindUntil,
+                                sharedLifecycle,
+                                new Func2<LifecycleEvent, LifecycleEvent, Boolean>() {
+                                    @Override
+                                    public Boolean call(LifecycleEvent bindUntilEvent, LifecycleEvent lifecycleEvent) {
+                                        return lifecycleEvent == bindUntilEvent;
+                                    }
+                                })
+                                .takeFirst(new Func1<Boolean, Boolean>() {
+                                    @Override
+                                    public Boolean call(Boolean shouldComplete) {
+                                        return shouldComplete;
+                                    }
+                                })
+                )
+        );
+    }
+
     // Figures out which corresponding next lifecycle event in which to unsubscribe, for Activities
     private static final Func1<LifecycleEvent, LifecycleEvent> ACTIVITY_LIFECYCLE =
             new Func1<LifecycleEvent, LifecycleEvent>() {
@@ -221,4 +268,33 @@ public LifecycleEvent call(LifecycleEvent lastEvent) {
                     }
                 }
             };
+
+    private static LifecycleEvent getActivityStoppingLifecycleEvent(LifecycleEvent lastEvent) {
+        if (lastEvent == null) {
+            throw new NullPointerException("Cannot bind to null LifecycleEvent.");
+        }
+
+        switch (lastEvent) {
+            case CREATE:
+                return LifecycleEvent.DESTROY;
+            case START:
+                return LifecycleEvent.STOP;
+            case RESUME:
+                return LifecycleEvent.PAUSE;
+            case PAUSE:
+                return LifecycleEvent.STOP;
+            case STOP:
+                return LifecycleEvent.DESTROY;
+            case DESTROY:
+                throw new IllegalStateException("Cannot bind to Activity lifecycle when outside of it.");
+            case ATTACH:
+            case CREATE_VIEW:
+            case DESTROY_VIEW:
+            case DETACH:
+                throw new IllegalStateException("Cannot bind to " + lastEvent + " for an Activity.");
+            default:
+                throw new UnsupportedOperationException("Binding to LifecycleEvent " + lastEvent
+                        + " not yet implemented");
+        }
+    }
 }
diff --git a/rxandroid/src/main/java/rx/android/lifecycle/OnSubscribeActivityLifecycleCallbacks.java b/rxandroid/src/main/java/rx/android/lifecycle/OnSubscribeActivityLifecycleCallbacks.java
new file mode 100644
index 00000000..72b75480
--- /dev/null
+++ b/rxandroid/src/main/java/rx/android/lifecycle/OnSubscribeActivityLifecycleCallbacks.java
@@ -0,0 +1,158 @@
+package rx.android.lifecycle;
+
+import android.app.Activity;
+import android.app.Application;
+import android.os.Bundle;
+
+import rx.Observable;
+import rx.Subscriber;
+import rx.functions.Action1;
+import rx.functions.Func1;
+
+/**
+ * This instance lives within the scope of an {@code Activity} in order to forward Lifecycle events
+ * to {@link rx.subjects.BehaviorSubject}
+ * <p/>
+ * Thread safe, since it's <i>Thread-confined</i> to the main Thread.
+ */
+class OnSubscribeActivityLifecycleCallbacks implements Application.ActivityLifecycleCallbacks, Observable.OnSubscribe<LifecycleEvent> {
+    private final Activity activityToMonitor;
+    private Subscriber<? super LifecycleEvent> subscriber;
+
+//    private final Observable<Activity> obsActivity;
+
+    public OnSubscribeActivityLifecycleCallbacks(Activity instance) {
+        activityToMonitor = instance;
+    }
+
+    @Override
+    public void call(Subscriber<? super LifecycleEvent> subscriber) {
+        this.subscriber = subscriber;
+    }
+
+    @Override
+    public void onActivityCreated(final Activity activity, Bundle bundle) {
+        Observable
+                .just(activity)
+                .filter(filter)
+                .subscribe(sendCreateEvent);
+    }
+
+    @Override
+    public void onActivityStarted(Activity activity) {
+        Observable
+                .just(activity)
+                .filter(filter)
+                .subscribe(sendStartEvent);
+    }
+
+    @Override
+    public void onActivityResumed(Activity activity) {
+        Observable
+                .just(activity)
+                .filter(filter)
+                .subscribe(sendResumeEvent);
+    }
+
+    @Override
+    public void onActivityPaused(Activity activity) {
+        Observable
+                .just(activity)
+                .filter(filter)
+                .subscribe(sendPauseEvent);
+    }
+
+    @Override
+    public void onActivityStopped(Activity activity) {
+        Observable
+                .just(activity)
+                .filter(filter)
+                .subscribe(sendStopEvent);
+    }
+
+    @Override
+    public void onActivitySaveInstanceState(Activity activity, Bundle bundle) {
+    }
+
+    @Override
+    public void onActivityDestroyed(Activity activity) {
+        Observable
+                .just(activity)
+                .filter(filter)
+                .doOnNext(sendDestroyEvent)
+                .subscribe(unregisterActivityLifecycleCallbacks);
+
+    }
+
+    private final Func1<Activity, Boolean> filter =
+            new Func1<Activity, Boolean>() {
+                @Override
+                public Boolean call(Activity callbackActivity) {
+                    // Application notify all instances of ActivityLifecycleCallbacks when a particular
+                    // event is emitted, we use identity comparison to filter out events related
+                    // to the instance of Activity we're currently monitoring
+                    return callbackActivity == activityToMonitor;
+                }
+            };
+
+
+    // Actions
+    private final Action1<Activity> sendCreateEvent = new Action1<Activity>() {
+        @Override
+        public void call(Activity activity) {
+            subscriber.onNext(LifecycleEvent.CREATE);
+        }
+    };
+
+    private final Action1<Activity> sendStartEvent = new Action1<Activity>() {
+        @Override
+        public void call(Activity activity) {
+            if (subscriber != null) {
+                subscriber.onNext(LifecycleEvent.START);
+            }
+        }
+    };
+
+    private final Action1<Activity> sendResumeEvent = new Action1<Activity>() {
+        @Override
+        public void call(Activity activity) {
+            if (subscriber != null) {
+                subscriber.onNext(LifecycleEvent.RESUME);
+            }
+        }
+    };
+
+    private final Action1<Activity> sendPauseEvent = new Action1<Activity>() {
+        @Override
+        public void call(Activity activity) {
+            if (subscriber != null) {
+                subscriber.onNext(LifecycleEvent.PAUSE);
+            }
+        }
+    };
+
+    private final Action1<Activity> sendStopEvent = new Action1<Activity>() {
+        @Override
+        public void call(Activity activity) {
+            if (subscriber != null) {
+                subscriber.onNext(LifecycleEvent.STOP);
+            }
+        }
+    };
+
+    private final Action1<Activity> sendDestroyEvent = new Action1<Activity>() {
+        @Override
+        public void call(Activity activity) {
+            if (subscriber != null) {
+                subscriber.onNext(LifecycleEvent.DESTROY);
+            }
+        }
+    };
+
+    private final Action1<Activity> unregisterActivityLifecycleCallbacks = new Action1<Activity>() {
+        @Override
+        public void call(Activity activity) {
+            activity.getApplication().unregisterActivityLifecycleCallbacks(OnSubscribeActivityLifecycleCallbacks.this);
+        }
+    };
+}
diff --git a/rxandroid/src/test/java/rx/android/lifecycle/ActivityLifecycleCallbacksObservableTest.java b/rxandroid/src/test/java/rx/android/lifecycle/ActivityLifecycleCallbacksObservableTest.java
new file mode 100644
index 00000000..ea412a8f
--- /dev/null
+++ b/rxandroid/src/test/java/rx/android/lifecycle/ActivityLifecycleCallbacksObservableTest.java
@@ -0,0 +1,222 @@
+package rx.android.lifecycle;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.util.ActivityController;
+
+import rx.android.lifecycle.scenarios.BaseLifecycleActivity;
+import rx.android.lifecycle.scenarios.BindActivityRule;
+import rx.android.lifecycle.scenarios.BindOnCreateEventActivity;
+import rx.android.lifecycle.scenarios.BindOnPauseEventActivity;
+import rx.android.lifecycle.scenarios.BindOnResumeEventActivity;
+import rx.android.lifecycle.scenarios.BindOnStartEventActivity;
+import rx.android.lifecycle.scenarios.BindOnStopEventActivity;
+import rx.android.lifecycle.scenarios.UseActivity;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class ActivityLifecycleCallbacksObservableTest {
+    @Rule
+    public BindActivityRule bindActivityRule = new BindActivityRule();
+
+    @UseActivity(BindOnCreateEventActivity.class)
+    @Test
+    public void testBindOnCreate() {
+        assertNotNull(bindActivityRule.activity.getSubscription());
+        assertFalse(bindActivityRule.activity.getSubscription().isUnsubscribed());
+
+        bindActivityRule.controller.start();
+        assertFalse(bindActivityRule.activity.getSubscription().isUnsubscribed());
+
+        bindActivityRule.controller.resume();
+        assertFalse(bindActivityRule.activity.getSubscription().isUnsubscribed());
+
+        bindActivityRule.controller.pause();
+        assertFalse(bindActivityRule.activity.getSubscription().isUnsubscribed());
+
+        bindActivityRule.controller.stop();
+        assertFalse(bindActivityRule.activity.getSubscription().isUnsubscribed());
+
+        // We will unsubscribe onDestroy, but the current version of Robolectric doesn't emit this event
+        // correctly  see https://github.com/robolectric/robolectric/issues/1429 (has been fixed on Snapshot BTW)
+        // FIXME update this test once Robolectric bug https://github.com/robolectric/robolectric/issues/1429
+        // once the fix (currently in robolectric:3.0-SNAPSHOT) will be released
+        //bindActivityRule.controller.destroy();
+        //assertTrue(bindActivityRule.activity.getSubscription().isUnsubscribed());
+    }
+
+
+    @UseActivity(BindOnStartEventActivity.class)
+    @Test
+    public void testBindOnStart() {
+        assertNull(bindActivityRule.activity.getSubscription());
+
+        bindActivityRule.controller.start();
+        assertNotNull(bindActivityRule.activity.getSubscription());
+        assertFalse(bindActivityRule.activity.getSubscription().isUnsubscribed());
+
+        bindActivityRule.controller.resume();
+        assertFalse(bindActivityRule.activity.getSubscription().isUnsubscribed());
+
+        bindActivityRule.controller.pause();
+        assertFalse(bindActivityRule.activity.getSubscription().isUnsubscribed());
+
+        bindActivityRule.controller.stop();
+        assertTrue(bindActivityRule.activity.getSubscription().isUnsubscribed());
+
+        bindActivityRule.controller.destroy();
+        assertTrue(bindActivityRule.activity.getSubscription().isUnsubscribed());
+    }
+
+    @UseActivity(BindOnResumeEventActivity.class)
+    @Test
+    public void testBindOnResume() {
+        assertNull(bindActivityRule.activity.getSubscription());
+
+        bindActivityRule.controller.start();
+        assertNull(bindActivityRule.activity.getSubscription());
+
+        bindActivityRule.controller.resume();
+        assertNotNull(bindActivityRule.activity.getSubscription());
+        assertFalse(bindActivityRule.activity.getSubscription().isUnsubscribed());
+
+        bindActivityRule.controller.pause();
+        assertTrue(bindActivityRule.activity.getSubscription().isUnsubscribed());
+
+        bindActivityRule.controller.stop();
+        assertTrue(bindActivityRule.activity.getSubscription().isUnsubscribed());
+
+        bindActivityRule.controller.destroy();
+        assertTrue(bindActivityRule.activity.getSubscription().isUnsubscribed());
+    }
+
+    @UseActivity(BindOnPauseEventActivity.class)
+    @Test
+    public void testBindOnPause() {
+        assertNull(bindActivityRule.activity.getSubscription());
+
+        bindActivityRule.controller.start();
+        assertNull(bindActivityRule.activity.getSubscription());
+
+        bindActivityRule.controller.resume();
+        assertNull(bindActivityRule.activity.getSubscription());
+
+        bindActivityRule.controller.pause();
+        assertFalse(bindActivityRule.activity.getSubscription().isUnsubscribed());
+
+        bindActivityRule.controller.stop();
+        assertTrue(bindActivityRule.activity.getSubscription().isUnsubscribed());
+
+        bindActivityRule.controller.destroy();
+        assertTrue(bindActivityRule.activity.getSubscription().isUnsubscribed());
+    }
+
+    @UseActivity(BindOnStopEventActivity.class)
+    @Test
+    public void testBindOnStop() {
+        assertNull(bindActivityRule.activity.getSubscription());
+
+        bindActivityRule.controller.start();
+        assertNull(bindActivityRule.activity.getSubscription());
+
+        bindActivityRule.controller.resume();
+        assertNull(bindActivityRule.activity.getSubscription());
+
+        bindActivityRule.controller.pause();
+        assertNull(bindActivityRule.activity.getSubscription());
+
+        bindActivityRule.controller.stop();
+        assertNotNull(bindActivityRule.activity.getSubscription());
+        assertFalse(bindActivityRule.activity.getSubscription().isUnsubscribed());
+
+        // We will unsubscribe onDestroy, but the current version of Robolectric doesn't emit this event
+        // correctly  see https://github.com/robolectric/robolectric/issues/1429 (has been fixed on Snapshot BTW)
+        // FIXME update this test once Robolectric bug https://github.com/robolectric/robolectric/issues/1429
+        // once the fix (currently in robolectric:3.0-SNAPSHOT) will be released
+        //bindActivityRule.controller.destroy();
+        //assertTrue(bindActivityRule.activity.getSubscription().isUnsubscribed());
+    }
+
+    @Test
+    public void testMultipleInstances() {
+        ActivityController<BindOnStartEventActivity> ctrlBndStart = Robolectric.buildActivity(BindOnStartEventActivity.class);
+        BaseLifecycleActivity actBndStart = ctrlBndStart.create().get();
+
+        ActivityController<BindOnResumeEventActivity> ctrlBndResume = Robolectric.buildActivity(BindOnResumeEventActivity.class);
+        BaseLifecycleActivity actBndResume = ctrlBndResume.create().get();
+
+        ActivityController<BindOnPauseEventActivity> ctrlBndPause = Robolectric.buildActivity(BindOnPauseEventActivity.class);
+        BaseLifecycleActivity actBndPause = ctrlBndPause.create().get();
+
+        //Other instances lifecycle change shouldn't interfere with each other
+
+        ctrlBndStart.start();
+        assertNotNull(actBndStart.getSubscription());
+        assertFalse(actBndStart.getSubscription().isUnsubscribed());
+
+        ctrlBndStart.resume();
+        assertFalse(actBndStart.getSubscription().isUnsubscribed());
+        assertNull(actBndResume.getSubscription());
+
+        ctrlBndStart.pause();
+        assertNull(actBndResume.getSubscription());
+        assertNull(actBndPause.getSubscription());
+
+        ctrlBndStart.stop();
+        assertNull(actBndResume.getSubscription());
+        assertNull(actBndPause.getSubscription());
+        assertTrue(actBndStart.getSubscription().isUnsubscribed());
+
+        ctrlBndResume.start();
+        assertTrue(actBndStart.getSubscription().isUnsubscribed());
+        assertNull(actBndResume.getSubscription());
+        assertNull(actBndPause.getSubscription());
+
+        ctrlBndResume.resume();
+        assertNotNull(actBndResume.getSubscription());
+        assertFalse(actBndResume.getSubscription().isUnsubscribed());
+
+        ctrlBndResume.pause();
+        assertNull(actBndPause.getSubscription());
+        assertTrue(actBndResume.getSubscription().isUnsubscribed());
+
+        ctrlBndResume.stop();
+        assertNull(actBndPause.getSubscription());
+        assertTrue(actBndStart.getSubscription().isUnsubscribed());
+        assertTrue(actBndResume.getSubscription().isUnsubscribed());
+
+        ctrlBndPause.start();
+        assertNull(actBndPause.getSubscription());
+        assertTrue(actBndStart.getSubscription().isUnsubscribed());
+        assertTrue(actBndResume.getSubscription().isUnsubscribed());
+
+        ctrlBndPause.resume();
+        assertNull(actBndPause.getSubscription());
+        assertTrue(actBndStart.getSubscription().isUnsubscribed());
+        assertTrue(actBndResume.getSubscription().isUnsubscribed());
+
+        ctrlBndPause.pause();
+        assertNotNull(actBndPause.getSubscription());
+        assertFalse(actBndPause.getSubscription().isUnsubscribed());
+        assertTrue(actBndStart.getSubscription().isUnsubscribed());
+        assertTrue(actBndResume.getSubscription().isUnsubscribed());
+
+        ctrlBndPause.stop();
+        assertTrue(actBndPause.getSubscription().isUnsubscribed());
+        assertTrue(actBndStart.getSubscription().isUnsubscribed());
+        assertTrue(actBndResume.getSubscription().isUnsubscribed());
+
+        ctrlBndStart.destroy();
+        ctrlBndResume.destroy();
+        ctrlBndPause.destroy();
+    }
+}
diff --git a/rxandroid/src/test/java/rx/android/lifecycle/scenarios/BaseLifecycleActivity.java b/rxandroid/src/test/java/rx/android/lifecycle/scenarios/BaseLifecycleActivity.java
new file mode 100644
index 00000000..5c5847d1
--- /dev/null
+++ b/rxandroid/src/test/java/rx/android/lifecycle/scenarios/BaseLifecycleActivity.java
@@ -0,0 +1,21 @@
+package rx.android.lifecycle.scenarios;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.widget.Button;
+
+import rx.Subscription;
+
+public abstract class  BaseLifecycleActivity extends Activity {
+    protected Button button;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        button = new Button(this);
+        button.setText("Click Me!");
+        setContentView(button);
+    }
+
+    public abstract Subscription getSubscription ();
+}
diff --git a/rxandroid/src/test/java/rx/android/lifecycle/scenarios/BindActivityRule.java b/rxandroid/src/test/java/rx/android/lifecycle/scenarios/BindActivityRule.java
new file mode 100644
index 00000000..2cddd7bd
--- /dev/null
+++ b/rxandroid/src/test/java/rx/android/lifecycle/scenarios/BindActivityRule.java
@@ -0,0 +1,38 @@
+package rx.android.lifecycle.scenarios;
+
+import org.junit.rules.ExternalResource;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+import org.robolectric.Robolectric;
+import org.robolectric.util.ActivityController;
+
+public class BindActivityRule extends ExternalResource {
+    private Class<? extends BaseLifecycleActivity> activityClass;
+
+    public ActivityController controller;
+    public BaseLifecycleActivity activity;
+
+    @Override
+    protected void before() throws Throwable {
+        if (activityClass != null) {
+            controller = Robolectric.buildActivity(activityClass);
+            activity = (BaseLifecycleActivity) controller.create().get();
+        }
+    }
+
+    @Override
+    protected void after() {
+        controller = null;
+        activity = null;
+    }
+
+    @Override
+    public Statement apply(final Statement base, Description description) {
+        UseActivity annotation = description.getAnnotation(UseActivity.class);
+        if (annotation != null) {
+            activityClass = annotation.value();
+        }
+
+        return super.apply(base, description);
+    }
+}
diff --git a/rxandroid/src/test/java/rx/android/lifecycle/scenarios/BindOnCreateEventActivity.java b/rxandroid/src/test/java/rx/android/lifecycle/scenarios/BindOnCreateEventActivity.java
new file mode 100644
index 00000000..f6ab63ac
--- /dev/null
+++ b/rxandroid/src/test/java/rx/android/lifecycle/scenarios/BindOnCreateEventActivity.java
@@ -0,0 +1,40 @@
+package rx.android.lifecycle.scenarios;
+
+import android.os.Bundle;
+import android.widget.Toast;
+
+import rx.Subscription;
+import rx.android.lifecycle.LifecycleEvent;
+import rx.android.lifecycle.LifecycleObservable;
+import rx.android.view.OnClickEvent;
+import rx.android.view.ViewObservable;
+import rx.functions.Action1;
+
+public class BindOnCreateEventActivity extends BaseLifecycleActivity {
+    private Subscription subscription;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        subscription = LifecycleObservable.bindActivityLifecycle(this,
+                ViewObservable.clicks(button),
+                LifecycleEvent.CREATE)
+                .subscribe(new Action1<OnClickEvent>() {
+                    @Override
+                    public void call(OnClickEvent onClickEvent) {
+                        Toast.makeText(BindOnCreateEventActivity.this,
+                                "Clicked button!",
+                                Toast.LENGTH_SHORT)
+                                .show();
+                    }
+                });
+
+        button.performClick();
+    }
+
+    @Override
+    public Subscription getSubscription() {
+        return subscription;
+    }
+}
diff --git a/rxandroid/src/test/java/rx/android/lifecycle/scenarios/BindOnDestroyEventActivity.java b/rxandroid/src/test/java/rx/android/lifecycle/scenarios/BindOnDestroyEventActivity.java
new file mode 100644
index 00000000..2fe9e3bf
--- /dev/null
+++ b/rxandroid/src/test/java/rx/android/lifecycle/scenarios/BindOnDestroyEventActivity.java
@@ -0,0 +1,38 @@
+package rx.android.lifecycle.scenarios;
+
+import android.widget.Toast;
+
+import rx.Subscription;
+import rx.android.lifecycle.LifecycleEvent;
+import rx.android.lifecycle.LifecycleObservable;
+import rx.android.view.OnClickEvent;
+import rx.android.view.ViewObservable;
+import rx.functions.Action1;
+
+public class BindOnDestroyEventActivity extends BaseLifecycleActivity {
+    private Subscription subscription;
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        subscription = LifecycleObservable.bindActivityLifecycle(this,
+                ViewObservable.clicks(button),
+                LifecycleEvent.DESTROY)
+                .subscribe(new Action1<OnClickEvent>() {
+                    @Override
+                    public void call(OnClickEvent onClickEvent) {
+                        Toast.makeText(BindOnDestroyEventActivity.this,
+                                "Clicked button!",
+                                Toast.LENGTH_SHORT)
+                                .show();
+                    }
+                });
+
+        button.performClick();
+    }
+
+    @Override
+    public Subscription getSubscription() {
+        return subscription;
+    }
+}
diff --git a/rxandroid/src/test/java/rx/android/lifecycle/scenarios/BindOnPauseEventActivity.java b/rxandroid/src/test/java/rx/android/lifecycle/scenarios/BindOnPauseEventActivity.java
new file mode 100644
index 00000000..8f5e9d4f
--- /dev/null
+++ b/rxandroid/src/test/java/rx/android/lifecycle/scenarios/BindOnPauseEventActivity.java
@@ -0,0 +1,38 @@
+package rx.android.lifecycle.scenarios;
+
+import android.widget.Toast;
+
+import rx.Subscription;
+import rx.android.lifecycle.LifecycleEvent;
+import rx.android.lifecycle.LifecycleObservable;
+import rx.android.view.OnClickEvent;
+import rx.android.view.ViewObservable;
+import rx.functions.Action1;
+
+public class BindOnPauseEventActivity extends BaseLifecycleActivity {
+    private Subscription subscription;
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+        subscription = LifecycleObservable.bindActivityLifecycle(this,
+                ViewObservable.clicks(button),
+                LifecycleEvent.PAUSE)
+                .subscribe(new Action1<OnClickEvent>() {
+                    @Override
+                    public void call(OnClickEvent onClickEvent) {
+                        Toast.makeText(BindOnPauseEventActivity.this,
+                                "Clicked button!",
+                                Toast.LENGTH_SHORT)
+                                .show();
+                    }
+                });
+
+        button.performClick();
+    }
+
+    @Override
+    public Subscription getSubscription() {
+        return subscription;
+    }
+}
diff --git a/rxandroid/src/test/java/rx/android/lifecycle/scenarios/BindOnResumeEventActivity.java b/rxandroid/src/test/java/rx/android/lifecycle/scenarios/BindOnResumeEventActivity.java
new file mode 100644
index 00000000..4991a839
--- /dev/null
+++ b/rxandroid/src/test/java/rx/android/lifecycle/scenarios/BindOnResumeEventActivity.java
@@ -0,0 +1,38 @@
+package rx.android.lifecycle.scenarios;
+
+import android.widget.Toast;
+
+import rx.Subscription;
+import rx.android.lifecycle.LifecycleEvent;
+import rx.android.lifecycle.LifecycleObservable;
+import rx.android.view.OnClickEvent;
+import rx.android.view.ViewObservable;
+import rx.functions.Action1;
+
+public class BindOnResumeEventActivity extends BaseLifecycleActivity {
+    private Subscription subscription;
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        subscription = LifecycleObservable.bindActivityLifecycle(this,
+                ViewObservable.clicks(button),
+                LifecycleEvent.RESUME)
+                .subscribe(new Action1<OnClickEvent>() {
+                    @Override
+                    public void call(OnClickEvent onClickEvent) {
+                        Toast.makeText(BindOnResumeEventActivity.this,
+                                "Clicked button!",
+                                Toast.LENGTH_SHORT)
+                                .show();
+                    }
+                });
+
+        button.performClick();
+    }
+
+    @Override
+    public Subscription getSubscription() {
+        return subscription;
+    }
+}
diff --git a/rxandroid/src/test/java/rx/android/lifecycle/scenarios/BindOnStartEventActivity.java b/rxandroid/src/test/java/rx/android/lifecycle/scenarios/BindOnStartEventActivity.java
new file mode 100644
index 00000000..2c546873
--- /dev/null
+++ b/rxandroid/src/test/java/rx/android/lifecycle/scenarios/BindOnStartEventActivity.java
@@ -0,0 +1,38 @@
+package rx.android.lifecycle.scenarios;
+
+import android.widget.Toast;
+
+import rx.Subscription;
+import rx.android.lifecycle.LifecycleEvent;
+import rx.android.lifecycle.LifecycleObservable;
+import rx.android.view.OnClickEvent;
+import rx.android.view.ViewObservable;
+import rx.functions.Action1;
+
+public class BindOnStartEventActivity extends BaseLifecycleActivity {
+    private Subscription subscription;
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+        subscription = LifecycleObservable.bindActivityLifecycle(this,
+                ViewObservable.clicks(button),
+                LifecycleEvent.START)
+                .subscribe(new Action1<OnClickEvent>() {
+                    @Override
+                    public void call(OnClickEvent onClickEvent) {
+                        Toast.makeText(BindOnStartEventActivity.this,
+                                "Clicked button!",
+                                Toast.LENGTH_SHORT)
+                                .show();
+                    }
+                });
+
+        button.performClick();
+    }
+
+    @Override
+    public Subscription getSubscription() {
+        return subscription;
+    }
+}
diff --git a/rxandroid/src/test/java/rx/android/lifecycle/scenarios/BindOnStopEventActivity.java b/rxandroid/src/test/java/rx/android/lifecycle/scenarios/BindOnStopEventActivity.java
new file mode 100644
index 00000000..4a580f65
--- /dev/null
+++ b/rxandroid/src/test/java/rx/android/lifecycle/scenarios/BindOnStopEventActivity.java
@@ -0,0 +1,38 @@
+package rx.android.lifecycle.scenarios;
+
+import android.widget.Toast;
+
+import rx.Subscription;
+import rx.android.lifecycle.LifecycleEvent;
+import rx.android.lifecycle.LifecycleObservable;
+import rx.android.view.OnClickEvent;
+import rx.android.view.ViewObservable;
+import rx.functions.Action1;
+
+public class BindOnStopEventActivity extends BaseLifecycleActivity {
+    private Subscription subscription;
+
+    @Override
+    protected void onStop() {
+        super.onStop();
+        subscription = LifecycleObservable.bindActivityLifecycle(this,
+                ViewObservable.clicks(button),
+                LifecycleEvent.STOP)
+                .subscribe(new Action1<OnClickEvent>() {
+                    @Override
+                    public void call(OnClickEvent onClickEvent) {
+                        Toast.makeText(BindOnStopEventActivity.this,
+                                "Clicked button!",
+                                Toast.LENGTH_SHORT)
+                                .show();
+                    }
+                });
+
+        button.performClick();
+    }
+
+    @Override
+    public Subscription getSubscription() {
+        return subscription;
+    }
+}
diff --git a/rxandroid/src/test/java/rx/android/lifecycle/scenarios/UseActivity.java b/rxandroid/src/test/java/rx/android/lifecycle/scenarios/UseActivity.java
new file mode 100644
index 00000000..7881b590
--- /dev/null
+++ b/rxandroid/src/test/java/rx/android/lifecycle/scenarios/UseActivity.java
@@ -0,0 +1,12 @@
+package rx.android.lifecycle.scenarios;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Target(ElementType.METHOD)
+@Retention(RetentionPolicy.RUNTIME)
+public @interface UseActivity {
+    Class<? extends BaseLifecycleActivity> value();
+}
diff --git a/sample-app/src/main/java/rx/android/samples/LifecycleObservableActivityComposition.java b/sample-app/src/main/java/rx/android/samples/LifecycleObservableActivityComposition.java
index a53cbee7..d24da26f 100644
--- a/sample-app/src/main/java/rx/android/samples/LifecycleObservableActivityComposition.java
+++ b/sample-app/src/main/java/rx/android/samples/LifecycleObservableActivityComposition.java
@@ -21,6 +21,7 @@
 import android.widget.Toast;
 
 import rx.Subscription;
+import rx.android.lifecycle.LifecycleEvent;
 import rx.android.lifecycle.LifecycleObservable;
 import rx.android.view.OnClickEvent;
 import rx.android.view.ViewObservable;
@@ -52,7 +53,9 @@ protected void onStart() {
         super.onStart();
 
         subscription =
-                LifecycleObservable.bindActivityLifecycle(this, ViewObservable.clicks(button))
+                LifecycleObservable.bindActivityLifecycle(this,
+                        ViewObservable.clicks(button),
+                        LifecycleEvent.START)
                         .subscribe(new Action1<OnClickEvent>() {
                             @Override
                             public void call(OnClickEvent onClickEvent) {
