diff --git a/rxandroid/src/main/java/rx/android/app/LifecycleEvent.java b/rxandroid/src/main/java/rx/android/app/LifecycleEvent.java
new file mode 100644
index 00000000..4d2bca49
--- /dev/null
+++ b/rxandroid/src/main/java/rx/android/app/LifecycleEvent.java
@@ -0,0 +1,15 @@
+package rx.android.app;
+
+/**
+ * Lifecycle events that we can create operators to observe.
+ */
+public enum LifecycleEvent {
+
+    CREATE,
+    START,
+    RESUME,
+    PAUSE,
+    STOP,
+    DESTROY
+
+}
diff --git a/rxandroid/src/main/java/rx/android/app/LifecycleListener.java b/rxandroid/src/main/java/rx/android/app/LifecycleListener.java
new file mode 100644
index 00000000..1f910bf6
--- /dev/null
+++ b/rxandroid/src/main/java/rx/android/app/LifecycleListener.java
@@ -0,0 +1,10 @@
+package rx.android.app;
+
+/**
+ * Listener for LifecycleEvents.
+ */
+public interface LifecycleListener {
+
+    void onLifecycleEvent(LifecycleEvent event);
+
+}
diff --git a/rxandroid/src/main/java/rx/android/app/LifecycleManager.java b/rxandroid/src/main/java/rx/android/app/LifecycleManager.java
new file mode 100644
index 00000000..5e680f19
--- /dev/null
+++ b/rxandroid/src/main/java/rx/android/app/LifecycleManager.java
@@ -0,0 +1,67 @@
+package rx.android.app;
+
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * Listens to lifecycle events and rebroadcasts them to other listeners.
+ *
+ * Also knows about the current state of the lifecycle so that it can handle changes.
+ */
+public class LifecycleManager {
+
+    private LifecycleEvent lastEvent = null;
+
+    private final Set<LifecycleListener> lifecycleListeners = new HashSet<LifecycleListener>();
+
+    public void addLifecycleListener(LifecycleListener listener) {
+        lifecycleListeners.add(listener);
+    }
+
+    public void removeLifecycleListener(LifecycleListener listener) {
+        lifecycleListeners.remove(listener);
+    }
+
+    public void onLifecycleEvent(LifecycleEvent event) {
+        lastEvent = event;
+
+        for (LifecycleListener listener : lifecycleListeners) {
+            listener.onLifecycleEvent(event);
+        }
+    }
+
+    /**
+     * A corresponding teardown event is the equivalent destructive event to the current creative event.
+     * For example, CREATE corresponds to DESTROY.
+     *
+     * If the lifecycle is in PAUSE or beyond, the next teardown event is returned.
+     * For example, PAUSE returns STOP.
+     *
+     * TODO: This could use a lot better terminology.
+     *
+     * @return the corresponding event from the last state seen, or null if we're entirely outside the lifecycle
+     */
+    public LifecycleEvent getCorrespondingTeardownEvent() {
+        if (lastEvent == null) {
+            return null;
+        }
+
+        switch(lastEvent) {
+            case CREATE:
+                return LifecycleEvent.DESTROY;
+            case START:
+                return LifecycleEvent.STOP;
+            case RESUME:
+                return LifecycleEvent.PAUSE;
+            case PAUSE:
+                return LifecycleEvent.STOP;
+            case STOP:
+                return LifecycleEvent.DESTROY;
+            case DESTROY:
+                return null;
+            default:
+                return null;
+        }
+    }
+
+}
diff --git a/rxandroid/src/main/java/rx/android/app/OperatorLifecycleEvent.java b/rxandroid/src/main/java/rx/android/app/OperatorLifecycleEvent.java
new file mode 100644
index 00000000..3de65e5b
--- /dev/null
+++ b/rxandroid/src/main/java/rx/android/app/OperatorLifecycleEvent.java
@@ -0,0 +1,59 @@
+package rx.android.app;
+
+import rx.Observable;
+import rx.Subscriber;
+import rx.Subscription;
+
+/**
+ * Created by dlew on 11/21/14.
+ */
+public class OperatorLifecycleEvent implements Observable.OnSubscribe<LifecycleEvent> {
+
+    private final LifecycleManager lifecycle;
+    private final LifecycleEvent lifecycleEvent;
+
+    public OperatorLifecycleEvent(LifecycleManager lifecycle, LifecycleEvent lifecycleEvent) {
+        this.lifecycle = lifecycle;
+        this.lifecycleEvent = lifecycleEvent;
+    }
+
+    @Override
+    public void call(Subscriber<? super LifecycleEvent> subscriber) {
+        new LifecycleSubscription(subscriber, lifecycle, lifecycleEvent);
+    }
+
+    private static final class LifecycleSubscription implements Subscription, LifecycleListener {
+        private Subscriber<? super LifecycleEvent> subscriber;
+        private LifecycleManager lifecycle;
+        private final LifecycleEvent lifecycleEvent;
+
+        public LifecycleSubscription(Subscriber<? super LifecycleEvent> subscriber,
+                                     LifecycleManager lifecycle,
+                                     LifecycleEvent lifecycleEvent) {
+            this.subscriber = subscriber;
+            this.lifecycle = lifecycle;
+            this.lifecycleEvent = lifecycleEvent;
+            lifecycle.addLifecycleListener(this);
+        }
+
+        @Override
+        public void onLifecycleEvent(LifecycleEvent event) {
+            if (event != lifecycleEvent) {
+                return;
+            }
+
+            subscriber.onNext(event);
+        }
+
+        @Override
+        public void unsubscribe() {
+            lifecycle.removeLifecycleListener(this);
+            subscriber.unsubscribe();
+        }
+
+        @Override
+        public boolean isUnsubscribed() {
+            return subscriber.isUnsubscribed();
+        }
+    }
+}
diff --git a/rxandroid/src/main/java/rx/android/app/RxActivity.java b/rxandroid/src/main/java/rx/android/app/RxActivity.java
new file mode 100644
index 00000000..e67c9b4c
--- /dev/null
+++ b/rxandroid/src/main/java/rx/android/app/RxActivity.java
@@ -0,0 +1,69 @@
+package rx.android.app;
+
+import android.app.Activity;
+import android.os.Bundle;
+import rx.Observable;
+
+/**
+ * An Activity with reactive extensions to make it easier to handle binding
+ * Observables to the lifecycle.
+ */
+public class RxActivity extends Activity {
+
+    private final LifecycleManager lifecycleManager = new LifecycleManager();
+
+    public <T> Observable<T> bindLifecycle(Observable<T> source) {
+        LifecycleEvent event = lifecycleManager.getCorrespondingTeardownEvent();
+        if (event == null) {
+            throw new IllegalStateException("Cannot automatically bind to lifecycle when completely outside of it.");
+        }
+
+        return bindUntilLifecycleEvent(source, event);
+    }
+
+    public <T> Observable<T> bindUntilLifecycleEvent(Observable<T> source, LifecycleEvent event) {
+        if (source == null) {
+            throw new IllegalArgumentException("Observable must be given");
+        }
+
+        return source.takeUntil(Observable.create(new OperatorLifecycleEvent(lifecycleManager, event)));
+    }
+
+    // Lifecycle manager notification
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        lifecycleManager.onLifecycleEvent(LifecycleEvent.CREATE);
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+        lifecycleManager.onLifecycleEvent(LifecycleEvent.START);
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        lifecycleManager.onLifecycleEvent(LifecycleEvent.RESUME);
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+        lifecycleManager.onLifecycleEvent(LifecycleEvent.PAUSE);
+    }
+
+    @Override
+    protected void onStop() {
+        super.onStop();
+        lifecycleManager.onLifecycleEvent(LifecycleEvent.STOP);
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        lifecycleManager.onLifecycleEvent(LifecycleEvent.DESTROY);
+    }
+}
