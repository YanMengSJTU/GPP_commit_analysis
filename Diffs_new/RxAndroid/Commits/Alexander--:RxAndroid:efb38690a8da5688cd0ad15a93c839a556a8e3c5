diff --git a/.travis.yml b/.travis.yml
index ebeb9fbc..2fbfdf0d 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -6,5 +6,6 @@ jdk:
 android:
   components:
     - android-20
+    - extra-android-m2repository
 
 script: "./gradlew build"
diff --git a/build.gradle b/build.gradle
index 6480d34d..f0d96979 100644
--- a/build.gradle
+++ b/build.gradle
@@ -8,7 +8,6 @@ buildscript {
     // The above dependency will bring in guava, which then pollutes child projects
     force 'com.google.guava:guava:15.0'
   }
-
 }
 
 apply plugin: 'rxjava-project'
@@ -19,8 +18,15 @@ configure(libraryModules) {
   apply plugin: 'rxjava-project'
   apply plugin: 'provided-base'
 
+  repositories {
+    maven {
+      url "file://$System.env.ANDROID_HOME/extras/android/m2repository"
+    }
+  }
+
   dependencies {
     compile "io.reactivex:rxjava:$rxJavaVersion"
+    compile 'com.android.support:support-annotations:20.0.0'
     provided 'com.google.android:android:4.0.1.2'
     provided 'com.google.android:support-v4:r7'
 
diff --git a/rxandroid/src/main/java/rx/android/AndroidSubscriptions.java b/rxandroid/src/main/java/rx/android/AndroidSubscriptions.java
index ddbff2bf..32260a29 100644
--- a/rxandroid/src/main/java/rx/android/AndroidSubscriptions.java
+++ b/rxandroid/src/main/java/rx/android/AndroidSubscriptions.java
@@ -13,6 +13,7 @@
  */
 package rx.android;
 
+import android.os.Handler;
 import rx.Scheduler.Worker;
 import rx.Subscription;
 import rx.android.schedulers.AndroidSchedulers;
@@ -49,4 +50,28 @@ public void call() {
             }
         });
     }
+
+    /**
+     * Create a {@link Subscription} that always runs <code>unsubscribe</code> in the thread,
+     * associated with given {@link Handler}.
+     */
+    public static Subscription unsubscribeInHandlerThread(final Action0 unsubscribe, final Handler handler) {
+        return Subscriptions.create(new Action0() {
+            @Override
+            public void call() {
+                if (handler.getLooper() == Looper.myLooper()) {
+                    unsubscribe.call();
+                } else {
+                    final Worker inner = AndroidSchedulers.handlerThread(handler).createWorker();
+                    inner.schedule(new Action0() {
+                        @Override
+                        public void call() {
+                            unsubscribe.call();
+                            inner.unsubscribe();
+                        }
+                    });
+                }
+            }
+        });
+    }
 }
diff --git a/rxandroid/src/main/java/rx/android/account/AccountObservable.java b/rxandroid/src/main/java/rx/android/account/AccountObservable.java
new file mode 100644
index 00000000..89c3f19d
--- /dev/null
+++ b/rxandroid/src/main/java/rx/android/account/AccountObservable.java
@@ -0,0 +1,57 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package rx.android.account;
+
+import android.accounts.Account;
+import android.accounts.AccountManager;
+import android.app.Activity;
+import android.support.annotation.NonNull;
+import rx.Observable;
+
+public final class AccountObservable {
+    private AccountObservable() {
+        throw new AssertionError("No instances");
+    }
+
+    /**
+     * Create an account if no accounts of specified type exist yet.
+     *<p>
+     * This convenience methods won't create an account, unless no accounts of required type
+     * exist. If you want to force account creation (for example, for custom account selection dialog),
+     * use {@link OnSubscribeAddAccount} directly.
+     *
+     * @param b Builder with {@link Account} parameters.
+     * @return Observable emitting existing Accounts (if any) or newly created Account.
+     */
+    public static Observable<Account> requireAccount(OnSubscribeAddAccount.Builder b) {
+        final AccountManager am = AccountManager.get(b.activity.getApplication());
+        final Account[] account = am.getAccountsByType(b.accountType);
+        return account.length == 0 ? Observable.create(b.build()) : Observable.from(account);
+    }
+
+    /**
+     * Create an account if no accounts of specified type exist yet.
+     *<p>
+     * This convenience methods won't create an account, unless no accounts of required type
+     * exist. If you want to force account creation (for example, for custom account selection dialog),
+     * use {@link OnSubscribeAddAccount} directly.
+     *
+     * @param activity used by {@link AccountManager} to launch Account creation Activity, if new Account is needed.
+     * @param accountType type of Account.
+     * @return Observable emitting existing Accounts (if any) or newly created Account.
+     */
+    public static Observable<Account> requireAccount(@NonNull Activity activity, @NonNull String accountType) {
+        return requireAccount(new OnSubscribeAddAccount.Builder(activity, accountType));
+    }
+}
diff --git a/rxandroid/src/main/java/rx/android/account/OnSubscribeAddAccount.java b/rxandroid/src/main/java/rx/android/account/OnSubscribeAddAccount.java
new file mode 100644
index 00000000..dd752ce8
--- /dev/null
+++ b/rxandroid/src/main/java/rx/android/account/OnSubscribeAddAccount.java
@@ -0,0 +1,214 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package rx.android.account;
+
+import android.accounts.Account;
+import android.accounts.AccountManager;
+import android.accounts.AccountManagerCallback;
+import android.accounts.AccountManagerFuture;
+import android.accounts.AccountAuthenticatorActivity;
+import android.app.Activity;
+import android.content.Context;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
+import rx.Observable;
+import rx.Subscriber;
+import rx.android.AndroidSubscriptions;
+import rx.functions.Action0;
+
+/**
+ * Initiate creation of {@link Account} via {@link AccountManager} and subscribe to results.
+ *<p>
+ * You will typically want to use {@link AccountObservable#requireAccount(Builder)}
+ * to create Account on-demand, only if it does not exist yet.
+ *<p>
+ * This method uses {@link AccountManagerCallback} to avoid creation of separate thread
+ * for blocking call, and as such, won't work for non-graphical AccountAuthenticator, as well
+ * as implementations, incompatible with {@link AccountAuthenticatorActivity}.
+ * If you want to create such AccountAuthenticator (which is generally a bad idea) or need to
+ * work around issues of existing one, use {@link AccountManagerFuture#getResult()}
+ * instead.
+ */
+public final class OnSubscribeAddAccount implements Observable.OnSubscribe<Account> {
+    private Activity activity;
+
+    private final String accountType;
+    private final Handler handler;
+
+    private final String authTokenType;
+    private final String[] requiredFeatures;
+    private final Bundle addAccountOptions;
+
+    /**
+     * Performs {@link AccountManager#addAccount(String, String, String[], Bundle, Activity, AccountManagerCallback, Handler)}
+     * to create an account without additional parameters. Account creation and Observable callbacks will
+     * be invoked on current thread or main thread (if current thread does not have a {@link Looper})
+     *<p>
+     * Use {@link #OnSubscribeAddAccount(Activity, String, Handler)} if you don't want
+     * current thread to be used.
+     *<p>
+     * Use {@link Builder} if you want to provide account creation parameters.
+     *
+     * @param activity used by AccountManager to launch Account creation Activity.
+     * @param accountType type of created Account.
+     */
+    public OnSubscribeAddAccount(@NonNull Activity activity, @NonNull String accountType) {
+        this(activity, accountType, new Handler(chooseLooper()));
+    }
+
+    /**
+     * Performs {@link AccountManager#addAccount(String, String, String[], Bundle, Activity, AccountManagerCallback, Handler)}
+     * to create an account without additional parameters. Account creation and Observable callbacks will
+     * be invoked on thread, associated with specified {@link Looper}.
+     *<p>
+     * Use {@link Builder} if you want to provide account creation parameters.
+     *
+     * @param activity used by AccountManager to launch account creation Activity.
+     * @param accountType type of created Account.
+     * @param handler used to invoke account creation and callbacks.
+     */
+    public OnSubscribeAddAccount(@NonNull Activity activity, @NonNull String accountType, @NonNull Handler handler) {
+        this(activity, accountType, handler, null, null, null);
+    }
+
+    private OnSubscribeAddAccount(Activity activity, String accountType, Handler handler,
+                                  String authTokenType,
+                                  String[] requiredFeatures,
+                                  Bundle addAccountOptions) {
+        if (activity == null || TextUtils.isEmpty(accountType))
+            throw new IllegalArgumentException("activity and account type must be specified");
+
+        this.activity = activity;
+        this.accountType = accountType;
+        this.handler = handler;
+        this.authTokenType = authTokenType;
+        this.requiredFeatures = requiredFeatures;
+        this.addAccountOptions = addAccountOptions;
+    }
+
+    @Override
+    public void call(final Subscriber<? super Account> subscriber) {
+        if (Thread.currentThread() == handler.getLooper().getThread()) {
+            subscribe(subscriber);
+        } else {
+            // follow the Observable contract if isn't subscribed to on the same thread as created
+            handler.post(new Runnable() {
+                @Override
+                public void run() {
+                    subscribe(subscriber);
+                }
+            });
+        }
+    }
+
+    private void subscribe(final Subscriber<? super Account> subscriber) {
+        final Context appContext = activity.getApplication();
+        final AccountManager am = AccountManager.get(appContext);
+        final AccountManagerCallback<Bundle> callback = new AccountManagerCallback<Bundle>() {
+            @Override
+            public void run(AccountManagerFuture<Bundle> future) {
+                if (subscriber.isUnsubscribed())
+                    return;
+
+                Exception errorDescription = null;
+                try {
+                    final Bundle results = future.getResult();
+
+                    Account[] accs = am.getAccountsByType(accountType);
+
+                    if (accs.length == 0) {
+                        errorDescription = new IllegalStateException("No Account created; results: " + results);
+                    } else {
+                        for (Account acc:accs) {
+                            subscriber.onNext(acc);
+                        }
+
+                        subscriber.onCompleted();
+                    }
+                } catch (Exception e) {
+                    errorDescription = e;
+                } finally {
+                    if (errorDescription != null) {
+                        subscriber.onError(errorDescription);
+                    }
+                }
+            }
+        };
+
+        final AccountManagerFuture<Bundle> f = am.addAccount(accountType,
+                authTokenType, requiredFeatures, addAccountOptions, activity, callback, handler);
+
+        // slightly reduce chance of leak, if something goes terribly wrong
+        activity = null;
+
+        subscriber.add(AndroidSubscriptions.unsubscribeInHandlerThread(new Action0() {
+            @Override
+            public void call() {
+                f.cancel(true);
+            }
+        }, handler));
+    }
+
+    public final static class Builder {
+        final Activity activity;
+        final String accountType;
+
+        private Handler handler;
+        private String authTokenType;
+        private String[] requiredFeatures;
+        private Bundle addAccountOptions;
+
+        public Builder(@NonNull Activity activity, @NonNull String accountType) {
+            this.activity = activity;
+            this.accountType = accountType;
+        }
+
+        public Builder setHandler(Handler handler) {
+            this.handler = handler;
+            return this;
+        }
+
+        public Builder setAuthTokenType(String authTokenType) {
+            this.authTokenType = authTokenType;
+            return this;
+        }
+
+        public Builder setAddAccountOptions(Bundle addAccountOptions) {
+            this.addAccountOptions = addAccountOptions;
+            return this;
+        }
+
+        public Builder setRequiredFeatures(String... requiredFeatures) {
+            this.requiredFeatures = requiredFeatures;
+            return this;
+        }
+
+        public OnSubscribeAddAccount build() {
+            return new OnSubscribeAddAccount(
+                    activity,
+                    accountType,
+                    handler == null ? new Handler(chooseLooper()) : handler,
+                    authTokenType,
+                    requiredFeatures,
+                    addAccountOptions);
+        }
+    }
+
+    private static Looper chooseLooper() {
+        return Looper.myLooper() == null ? Looper.getMainLooper() : Looper.myLooper();
+    }
+}
diff --git a/rxandroid/src/test/java/rx/android/account/AccountManagerShadow.java b/rxandroid/src/test/java/rx/android/account/AccountManagerShadow.java
new file mode 100644
index 00000000..fed18997
--- /dev/null
+++ b/rxandroid/src/test/java/rx/android/account/AccountManagerShadow.java
@@ -0,0 +1,374 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package rx.android.account;
+
+import android.accounts.Account;
+import android.accounts.AccountManager;
+import android.accounts.AccountManagerFuture;
+import android.accounts.AccountManagerCallback;
+import android.accounts.AuthenticatorException;
+import android.accounts.OperationCanceledException;
+import android.accounts.AuthenticatorDescription;
+import android.accounts.OnAccountsUpdateListener;
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowAccountManager;
+
+import java.io.IOException;
+import java.util.Map;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Shadow implementation for the Android {@code AccountManager } class,
+ * copied from Robolectric 2.4 sources (a1d4fed841b9984178a1be2c3a977a74d718994d)
+ * with couple of changes to allow testing RxAndroid
+ */
+@Implements(AccountManager.class)
+public class AccountManagerShadow extends ShadowAccountManager {
+    private static final Object lock = new Object();
+    private static AccountManager instance;
+    private final List<Account> accounts = new ArrayList<Account>();
+    private final Map<Account, Map<String, String>> authTokens = new HashMap<Account, Map<String,String>>();
+    private final Map<String, AuthenticatorDescription> authenticators = new LinkedHashMap<String, AuthenticatorDescription>();
+    private final List<OnAccountsUpdateListener> listeners = new ArrayList<OnAccountsUpdateListener>();
+    private final Map<Account, Map<String, String>> userData = new HashMap<Account, Map<String,String>>();
+    private final Map<Account, String> passwords = new HashMap<Account, String>();
+    private volatile Handler callbackHandler;
+    private volatile AccountManagerCallback<Bundle> pendingAddCallback;
+    private volatile RoboAccountManagerFuture pendingAddFuture;
+
+    public static void reset() {
+        synchronized (lock) {
+            instance = null;
+        }
+    }
+
+    @Implementation
+    public static AccountManager get(Context context) {
+        synchronized (lock) {
+            if (instance == null) {
+                instance = Robolectric.newInstanceOf(AccountManager.class);
+            }
+            return instance;
+        }
+    }
+    @Implementation
+    public Account[] getAccounts() {
+        return accounts.toArray(new Account[accounts.size()]);
+    }
+    @Implementation
+    public Account[] getAccountsByType(String type) {
+        List<Account> accountsByType = new ArrayList<Account>();
+        for (Account a : accounts) {
+            if (type.equals(a.type)) {
+                accountsByType.add(a);
+            }
+        }
+        return accountsByType.toArray(new Account[accountsByType.size()]);
+    }
+    @Implementation
+    public synchronized void setAuthToken(Account account, String tokenType, String authToken) {
+        if(accounts.contains(account)) {
+            Map<String, String> tokenMap = authTokens.get(account);
+            if(tokenMap == null) {
+                tokenMap = new HashMap<String, String>();
+                authTokens.put(account, tokenMap);
+            }
+            tokenMap.put(tokenType, authToken);
+        }
+    }
+    @Implementation
+    public String peekAuthToken(Account account, String tokenType) {
+        Map<String, String> tokenMap = authTokens.get(account);
+        if(tokenMap != null) {
+            return tokenMap.get(tokenType);
+        }
+        return null;
+    }
+    @Implementation
+    public boolean addAccountExplicitly(Account account, String password, Bundle userdata) {
+        if (account == null) {
+            throw new IllegalArgumentException("account is null");
+        }
+        for (Account a: getAccountsByType(account.type)) {
+            if (a.name.equals(account.name)) {
+                return false;
+            }
+        }
+        if (!accounts.add(account)) {
+            return false;
+        }
+        setPassword(account, password);
+        if(userdata != null) {
+            for (String key : userdata.keySet()) {
+                setUserData(account, key, userdata.get(key).toString());
+            }
+        }
+        return true;
+    }
+    @Implementation
+    public String blockingGetAuthToken(Account account, String authTokenType,
+                                       boolean notifyAuthFailure) {
+        if (account == null) {
+            throw new IllegalArgumentException("account is null");
+        }
+        if (authTokenType == null) {
+            throw new IllegalArgumentException("authTokenType is null");
+        }
+        Map<String, String> tokensForAccount = authTokens.get(account);
+        if (tokensForAccount == null) {
+            return null;
+        }
+        return tokensForAccount.get(authTokenType);
+    }
+    @Implementation
+    public AccountManagerFuture<Boolean> removeAccount (final Account account,
+                                                        AccountManagerCallback<Boolean> callback,
+                                                        Handler handler) {
+        if (account == null) throw new IllegalArgumentException("account is null");
+        final boolean accountRemoved = accounts.remove(account);
+        passwords.remove(account);
+        userData.remove(account);
+        return new AccountManagerFuture<Boolean>() {
+            @Override
+            public boolean cancel(boolean mayInterruptIfRunning) {
+                return false;
+            }
+            @Override
+            public boolean isCancelled() {
+                return false;
+            }
+            @Override
+            public boolean isDone() {
+                return false;
+            }
+            @Override
+            public Boolean getResult() throws OperationCanceledException, IOException,
+                    AuthenticatorException {
+                return accountRemoved;
+            }
+            @Override
+            public Boolean getResult(long timeout, TimeUnit unit) throws OperationCanceledException,
+                    IOException, AuthenticatorException {
+                return accountRemoved;
+            }
+        };
+    }
+    @Implementation
+    public AuthenticatorDescription[] getAuthenticatorTypes() {
+        return authenticators.values().toArray(new AuthenticatorDescription[authenticators.size()]);
+    }
+    @Implementation
+    public void addOnAccountsUpdatedListener(final OnAccountsUpdateListener listener,
+                                             Handler handler, boolean updateImmediately) {
+        if (listeners.contains(listener)) {
+            return;
+        }
+        listeners.add(listener);
+        if (updateImmediately) {
+            listener.onAccountsUpdated(getAccounts());
+        }
+    }
+    @Implementation
+    public String getUserData(Account account, String key) {
+        if (account == null) {
+            throw new IllegalArgumentException("account is null");
+        }
+        if (!userData.containsKey(account)) {
+            return null;
+        }
+        Map<String, String> userDataMap = userData.get(account);
+        if (userDataMap.containsKey(key)) {
+            return userDataMap.get(key);
+        }
+        return null;
+    }
+    @Implementation
+    public void setUserData(Account account, String key, String value) {
+        if (account == null) {
+            throw new IllegalArgumentException("account is null");
+        }
+        if (!userData.containsKey(account)) {
+            userData.put(account, new HashMap<String, String>());
+        }
+        Map<String, String> userDataMap = userData.get(account);
+        if (value == null) {
+            userDataMap.remove(key);
+        } else {
+            userDataMap.put(key, value);
+        }
+    }
+    @Implementation
+    public void setPassword (Account account, String password) {
+        if (account == null) {
+            throw new IllegalArgumentException("account is null");
+        }
+        if (password == null) {
+            passwords.remove(account);
+        } else {
+            passwords.put(account, password);
+        }
+    }
+    @Implementation
+    public String getPassword (Account account) {
+        if (account == null) {
+            throw new IllegalArgumentException("account is null");
+        }
+        if (passwords.containsKey(account)) {
+            return passwords.get(account);
+        } else {
+            return null;
+        }
+    }
+    @Implementation
+    public void invalidateAuthToken(final String accountType, final String authToken) {
+        Account[] accountsByType = getAccountsByType(accountType);
+        for (Account account : accountsByType) {
+            Map<String, String> tokenMap = authTokens.get(account);
+            if (tokenMap != null) {
+                Iterator<Map.Entry<String, String>> it = tokenMap.entrySet().iterator();
+                while (it.hasNext()) {
+                    Map.Entry<String, String> map = it.next();
+                    if (map.getValue().equals(authToken)) {
+                        it.remove();
+                    }
+                }
+                authTokens.put(account, tokenMap);
+            }
+        }
+    }
+    private void notifyListeners() {
+        Account[] accounts = getAccounts();
+        Iterator<OnAccountsUpdateListener> iter = listeners.iterator();
+        OnAccountsUpdateListener listener;
+        while (iter.hasNext()) {
+            listener = iter.next();
+            listener.onAccountsUpdated(accounts);
+        }
+    }
+
+    /**
+     * Non-android accessor. Allows the test case to cancel account creation,
+     * as if {@link android.accounts.AccountAuthenticatorActivity} was finished by user.
+     */
+    public void cancelAccountCreation() {
+        if (pendingAddCallback != null) {
+            pendingAddFuture.resultBundle.putInt(AccountManager.KEY_ERROR_CODE, AccountManager.ERROR_CODE_CANCELED);
+            pendingAddFuture.resultBundle.putString(AccountManager.KEY_ERROR_MESSAGE, "cancel");
+            pendingAddFuture.cancel(true);
+            callbackHandler.post(new Runnable() {
+                @Override
+                public void run() {
+                    pendingAddCallback.run(pendingAddFuture);
+                }
+            });
+        }
+    }
+
+    /**
+     * Non-android accessor. Allows the test case to populate the
+     * list of active accounts.
+     *
+     * @param account
+     */
+    public void addAccount(Account account) {
+        accounts.add(account);
+        if (pendingAddCallback != null) {
+            pendingAddFuture.resultBundle.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);
+            callbackHandler.post(new Runnable() {
+                @Override
+                public void run() {
+                    pendingAddCallback.run(pendingAddFuture);
+                }
+            });
+        }
+        notifyListeners();
+    }
+    private class RoboAccountManagerFuture implements AccountManagerFuture<Bundle> {
+        private final String accountType;
+        final Bundle resultBundle;
+        public RoboAccountManagerFuture(String accountType, Bundle resultBundle) {
+            this.accountType = accountType;
+            this.resultBundle = resultBundle;
+        }
+        @Override
+        public boolean cancel(boolean b) {
+            return false;
+        }
+        @Override
+        public boolean isCancelled() {
+            return false;
+        }
+        @Override
+        public boolean isDone() {
+            return resultBundle.containsKey(AccountManager.KEY_ACCOUNT_NAME);
+        }
+        @Override
+        public Bundle getResult() throws OperationCanceledException, IOException, AuthenticatorException {
+            if (!authenticators.containsKey(accountType)) {
+                throw new AuthenticatorException("No authenticator specified for " + accountType);
+            }
+            resultBundle.putString(AccountManager.KEY_ACCOUNT_TYPE, accountType);
+            return resultBundle;
+        }
+        @Override
+        public Bundle getResult(long l, TimeUnit timeUnit) throws OperationCanceledException, IOException, AuthenticatorException {
+            if (!authenticators.containsKey(accountType)) {
+                throw new AuthenticatorException("No authenticator specified for " + accountType);
+            }
+            return resultBundle;
+        }
+    }
+    @Implementation
+    public AccountManagerFuture<Bundle> addAccount(final String accountType, String authTokenType, String[] requiredFeatures, Bundle addAccountOptions, Activity activity, AccountManagerCallback<Bundle> callback, Handler handler) {
+        final Bundle resultBundle = new Bundle();
+        if (activity == null) {
+            Intent resultIntent = new Intent();
+            resultBundle.putParcelable(AccountManager.KEY_INTENT, resultIntent);
+        } else if (callback == null) {
+            resultBundle.putString(AccountManager.KEY_ACCOUNT_NAME, "some_user@gmail.com");
+        }
+        pendingAddCallback = callback;
+        callbackHandler = handler == null ? new Handler(Looper.getMainLooper()) : handler;
+        pendingAddFuture = new RoboAccountManagerFuture(accountType, resultBundle);
+        return pendingAddFuture;
+    }
+    /**
+     * Non-android accessor. Allows the test case to populate the
+     * list of active authenticators.
+     *
+     * @param authenticator
+     */
+    public void addAuthenticator(AuthenticatorDescription authenticator) {
+        authenticators.put(authenticator.type, authenticator);
+    }
+    /**
+     * @see #addAuthenticator(AuthenticatorDescription)
+     */
+    public void addAuthenticator(String type) {
+        addAuthenticator(AuthenticatorDescription.newKey(type));
+    }
+}
diff --git a/rxandroid/src/test/java/rx/android/account/AcountObservableTest.java b/rxandroid/src/test/java/rx/android/account/AcountObservableTest.java
new file mode 100644
index 00000000..cea381da
--- /dev/null
+++ b/rxandroid/src/test/java/rx/android/account/AcountObservableTest.java
@@ -0,0 +1,98 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package rx.android.account;
+
+import android.accounts.Account;
+import android.accounts.AccountManager;
+import android.accounts.AuthenticatorException;
+import android.accounts.OperationCanceledException;
+import android.accounts.NetworkErrorException;
+import android.app.Activity;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.Matchers;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import rx.Observer;
+import rx.observers.TestObserver;
+
+import java.io.IOException;
+
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.never;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(shadows = {AccountManagerShadow.class})
+public class AcountObservableTest {
+    static final String ACCOUNT_TYPE = "io.reactivex.test.account";
+
+    private @Mock Observer<Account> observer;
+
+    private AccountManagerShadow testShadow;
+    private Activity activity;
+
+    @Before
+    public void setup() {
+        MockitoAnnotations.initMocks(this);
+        activity = Robolectric.buildActivity(Activity.class).create().get();
+
+        testShadow = Robolectric.shadowOf_(AccountManager.get(activity));
+        testShadow.addAuthenticator(ACCOUNT_TYPE);
+    }
+
+    @Test
+    public void existingAccountsReturned() throws NetworkErrorException, AuthenticatorException, OperationCanceledException, IOException {
+        final Account existingAccount1 = new Account("test1", ACCOUNT_TYPE);
+        final Account existingAccount2 = new Account("test2", ACCOUNT_TYPE);
+        try {
+            testShadow.addAccount(existingAccount1);
+            testShadow.addAccount(existingAccount2);
+
+            AccountObservable.requireAccount(activity, ACCOUNT_TYPE).subscribe(new TestObserver<Account>(observer));
+
+            Robolectric.runUiThreadTasksIncludingDelayedTasks();
+
+            verify(observer, never()).onError(Matchers.any(Throwable.class));
+            verify(observer).onNext(existingAccount1);
+            verify(observer).onNext(existingAccount2);
+            verify(observer).onCompleted();
+        } finally {
+            testShadow.removeAccount(existingAccount1, null, null).getResult();
+            testShadow.removeAccount(existingAccount2, null, null).getResult();
+        }
+    }
+
+    @Test
+    public void accountCreated() throws NetworkErrorException, AuthenticatorException, OperationCanceledException, IOException {
+        final Account createdAccount = new Account("test3", ACCOUNT_TYPE);
+        try {
+            AccountObservable.requireAccount(activity, ACCOUNT_TYPE).subscribe(new TestObserver<Account>(observer));
+
+            // pretend, that an Account was added by authenticator
+            testShadow.addAccount(createdAccount);
+
+            Robolectric.runUiThreadTasksIncludingDelayedTasks();
+
+            verify(observer, never()).onError(Matchers.any(Throwable.class));
+            verify(observer).onNext(createdAccount);
+            verify(observer).onCompleted();
+        } finally {
+            testShadow.removeAccount(createdAccount, null, null).getResult();
+        }
+    }
+}
diff --git a/rxandroid/src/test/java/rx/android/account/OperatorAddAccountTest.java b/rxandroid/src/test/java/rx/android/account/OperatorAddAccountTest.java
new file mode 100644
index 00000000..2f04ef9c
--- /dev/null
+++ b/rxandroid/src/test/java/rx/android/account/OperatorAddAccountTest.java
@@ -0,0 +1,109 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package rx.android.account;
+
+import android.accounts.Account;
+import android.accounts.AccountManager;
+import android.accounts.AuthenticatorException;
+import android.accounts.OperationCanceledException;
+import android.app.Activity;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.Matchers;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import rx.Observable;
+import rx.Observer;
+import rx.Subscription;
+import rx.observers.TestObserver;
+
+import java.io.IOException;
+
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static rx.android.account.AcountObservableTest.ACCOUNT_TYPE;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(shadows = {AccountManagerShadow.class})
+public class OperatorAddAccountTest {
+    private @Mock Observer<Account> observer;
+
+    private Activity activity;
+    private AccountManagerShadow testShadow;
+
+    @Before
+    public void setup() {
+        MockitoAnnotations.initMocks(this);
+        activity = Robolectric.buildActivity(Activity.class).create().get();
+
+        testShadow = Robolectric.shadowOf_(AccountManager.get(activity));
+        testShadow.addAuthenticator(ACCOUNT_TYPE);
+    }
+
+    @SuppressWarnings("ConstantConditions")
+    @Test(expected = IllegalArgumentException.class)
+    public void failFastOnNullActivity() {
+        Observable.create(new OnSubscribeAddAccount(null, ACCOUNT_TYPE)).subscribe(new TestObserver<Account>(observer));
+    }
+
+    @SuppressWarnings("ConstantConditions")
+    @Test(expected = IllegalArgumentException.class)
+    public void failFastOnNullAccount() {
+        Observable.create(new OnSubscribeAddAccount(activity, null)).subscribe(new TestObserver<Account>(observer));
+    }
+
+    @Test
+    public void errorIfCancelledFromOutside() {
+        final Observable<Account> observable = Observable.create(new OnSubscribeAddAccount(activity, ACCOUNT_TYPE));
+        final Subscription subscription = observable.subscribe(new TestObserver<Account>(observer));
+
+        testShadow.cancelAccountCreation();
+
+        Robolectric.runUiThreadTasksIncludingDelayedTasks();
+
+        verify(observer).onError(Matchers.any(OperationCanceledException.class));
+        verify(observer, never()).onNext(Matchers.any(Account.class));
+        verify(observer, never()).onCompleted();
+
+        Assert.assertTrue(subscription.isUnsubscribed());
+    }
+
+    @Test
+    public void cancelCreationWhenUnsubscribedFrom() throws AuthenticatorException, OperationCanceledException, IOException {
+        final Account someOtherAccount = new Account("test999", ACCOUNT_TYPE);
+        try {
+            final Observable<Account> observable = Observable.create(new OnSubscribeAddAccount(activity, ACCOUNT_TYPE));
+            final Subscription subscription = observable.subscribe(new TestObserver<Account>(observer));
+            subscription.unsubscribe();
+
+            // pretend that something else created an Account
+            testShadow.addAccount(someOtherAccount);
+
+            Robolectric.runUiThreadTasksIncludingDelayedTasks();
+
+            verify(observer, never()).onError(Matchers.any(Exception.class));
+            verify(observer, never()).onNext(Matchers.any(Account.class));
+            verify(observer, never()).onCompleted();
+
+            Assert.assertTrue(subscription.isUnsubscribed());
+        } finally {
+            testShadow.removeAccount(someOtherAccount, null, null).getResult();
+        }
+    }
+}
