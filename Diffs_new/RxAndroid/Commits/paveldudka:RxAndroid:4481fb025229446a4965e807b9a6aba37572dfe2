diff --git a/rxandroid/src/main/java/rx/android/plugins/RxAndroidSchedulersHook.java b/rxandroid/src/main/java/rx/android/plugins/RxAndroidSchedulersHook.java
index 39979161..2f903770 100644
--- a/rxandroid/src/main/java/rx/android/plugins/RxAndroidSchedulersHook.java
+++ b/rxandroid/src/main/java/rx/android/plugins/RxAndroidSchedulersHook.java
@@ -34,6 +34,16 @@ public Scheduler getMainThreadScheduler() {
         return null;
     }
 
+    /**
+     * Scheduler to return from {@link AndroidSchedulers#backgroundThread()} ()} or {@code null} if default
+     * should be used.
+     * <p>
+     * This instance should be or behave like a stateless singleton.
+     */
+    public Scheduler getBackgroundThreadScheduler() {
+        return null;
+    }
+
     /**
      * Invoked before the Action is handed over to the scheduler.  Can be used for
      * wrapping/decorating/logging. The default is just a passthrough.
diff --git a/rxandroid/src/main/java/rx/android/schedulers/AndroidSchedulers.java b/rxandroid/src/main/java/rx/android/schedulers/AndroidSchedulers.java
index f24ac298..64ed77ed 100644
--- a/rxandroid/src/main/java/rx/android/schedulers/AndroidSchedulers.java
+++ b/rxandroid/src/main/java/rx/android/schedulers/AndroidSchedulers.java
@@ -18,8 +18,12 @@
 
 import rx.Scheduler;
 import rx.android.plugins.RxAndroidPlugins;
+import rx.android.schedulers.background.BackgroundThreadScheduler;
+import rx.android.schedulers.handler.HandlerScheduler;
 
-/** Android-specific Schedulers. */
+/**
+ * Android-specific Schedulers.
+ */
 public final class AndroidSchedulers {
     private AndroidSchedulers() {
         throw new AssertionError("No instances");
@@ -29,13 +33,36 @@ private AndroidSchedulers() {
     // https://en.wikipedia.org/wiki/Initialization-on-demand_holder_idiom
     private static class MainThreadSchedulerHolder {
         static final Scheduler MAIN_THREAD_SCHEDULER =
-                new HandlerScheduler(new Handler(Looper.getMainLooper()));
+                HandlerScheduler.from(new Handler(Looper.getMainLooper()));
+    }
+
+    private static class BackgroundThreadSchedulerHolder {
+        static final Scheduler BACKGROUND_THREAD_SCHEDULER =
+                BackgroundThreadScheduler.newInstance();
     }
 
-    /** A {@link Scheduler} which executes actions on the Android UI thread. */
+    /**
+     * A {@link Scheduler} which executes actions on the Android UI thread.
+     */
     public static Scheduler mainThread() {
         Scheduler scheduler =
                 RxAndroidPlugins.getInstance().getSchedulersHook().getMainThreadScheduler();
         return scheduler != null ? scheduler : MainThreadSchedulerHolder.MAIN_THREAD_SCHEDULER;
     }
+
+    /**
+     * Creates and returns a {@link Scheduler} that creates a new {@link Thread} for each unit of work.
+     * <p>
+     * Each thread created by this scheduler will have fixed priority ({@link Thread#NORM_PRIORITY} - 1)
+     * which is lower than Android main thread priority.
+     * <p>
+     * Unhandled errors will be delivered to the scheduler Thread's {@link java.lang.Thread.UncaughtExceptionHandler}.
+     *
+     * @return a {@link BackgroundThreadScheduler} instance
+     */
+    public static Scheduler backgroundThread() {
+        Scheduler scheduler =
+                RxAndroidPlugins.getInstance().getSchedulersHook().getBackgroundThreadScheduler();
+        return scheduler != null ? scheduler : BackgroundThreadSchedulerHolder.BACKGROUND_THREAD_SCHEDULER;
+    }
 }
diff --git a/rxandroid/src/main/java/rx/android/schedulers/background/BackgroundThreadFactory.java b/rxandroid/src/main/java/rx/android/schedulers/background/BackgroundThreadFactory.java
new file mode 100644
index 00000000..183754c2
--- /dev/null
+++ b/rxandroid/src/main/java/rx/android/schedulers/background/BackgroundThreadFactory.java
@@ -0,0 +1,26 @@
+package rx.android.schedulers.background;
+
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.atomic.AtomicLong;
+
+/**
+ * Thread factory which creates threads with lowered priority ({@link Thread#NORM_PRIORITY} - 1)
+ */
+public final class BackgroundThreadFactory extends AtomicLong implements ThreadFactory {
+    final String prefix;
+    final static int BACKGROUND_THREAD_PRIORITY = Thread.NORM_PRIORITY - 1;
+
+    public BackgroundThreadFactory(String prefix) {
+        this.prefix = prefix;
+    }
+
+    @Override
+    public Thread newThread(Runnable r) {
+        Thread t = new Thread(r, prefix + incrementAndGet());
+        if (t.getPriority() != BACKGROUND_THREAD_PRIORITY) {
+            t.setPriority(BACKGROUND_THREAD_PRIORITY);
+        }
+        t.setDaemon(true);
+        return t;
+    }
+}
diff --git a/rxandroid/src/main/java/rx/android/schedulers/background/BackgroundThreadScheduler.java b/rxandroid/src/main/java/rx/android/schedulers/background/BackgroundThreadScheduler.java
new file mode 100644
index 00000000..622da634
--- /dev/null
+++ b/rxandroid/src/main/java/rx/android/schedulers/background/BackgroundThreadScheduler.java
@@ -0,0 +1,27 @@
+package rx.android.schedulers.background;
+
+import rx.Scheduler;
+import rx.internal.schedulers.NewThreadWorker;
+
+/**
+ * Schedules each unit of work on a new thread. Threads created by this scheduler will
+ * have fixed priority ({@link Thread#NORM_PRIORITY} - 1) which is lower than Android
+ * main thread priority.
+ */
+public class BackgroundThreadScheduler extends Scheduler {
+
+    private static final String THREAD_NAME_PREFIX = "RxAndroidBackgroundThreadScheduler-";
+    private static final BackgroundThreadFactory THREAD_FACTORY = new BackgroundThreadFactory(THREAD_NAME_PREFIX);
+
+    public static BackgroundThreadScheduler newInstance() {
+        return new BackgroundThreadScheduler();
+    }
+
+    private BackgroundThreadScheduler() {
+    }
+
+    @Override
+    public Worker createWorker() {
+        return new NewThreadWorker(THREAD_FACTORY);
+    }
+}
diff --git a/rxandroid/src/main/java/rx/android/schedulers/HandlerScheduler.java b/rxandroid/src/main/java/rx/android/schedulers/handler/HandlerScheduler.java
similarity index 98%
rename from rxandroid/src/main/java/rx/android/schedulers/HandlerScheduler.java
rename to rxandroid/src/main/java/rx/android/schedulers/handler/HandlerScheduler.java
index 46d12f8d..f6869084 100644
--- a/rxandroid/src/main/java/rx/android/schedulers/HandlerScheduler.java
+++ b/rxandroid/src/main/java/rx/android/schedulers/handler/HandlerScheduler.java
@@ -11,7 +11,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package rx.android.schedulers;
+package rx.android.schedulers.handler;
 
 import java.util.concurrent.TimeUnit;
 
diff --git a/rxandroid/src/test/java/rx/android/schedulers/AndroidSchedulersTest.java b/rxandroid/src/test/java/rx/android/schedulers/AndroidSchedulersTest.java
index 081e67ea..e9c9c27a 100644
--- a/rxandroid/src/test/java/rx/android/schedulers/AndroidSchedulersTest.java
+++ b/rxandroid/src/test/java/rx/android/schedulers/AndroidSchedulersTest.java
@@ -43,4 +43,17 @@ public void mainThreadCallsThroughToHook() {
         Scheduler mainThread = AndroidSchedulers.mainThread();
         assertSame(scheduler, mainThread);
     }
+
+    @Test
+    public void backgroundThreadCallsThroughToHook() {
+        final Scheduler scheduler = mock(Scheduler.class);
+        RxAndroidPlugins.getInstance().registerSchedulersHook(new RxAndroidSchedulersHook() {
+            @Override public Scheduler getBackgroundThreadScheduler() {
+                return scheduler;
+            }
+        });
+
+        Scheduler backgroundThread = AndroidSchedulers.backgroundThread();
+        assertSame(scheduler, backgroundThread);
+    }
 }
diff --git a/rxandroid/src/test/java/rx/android/schedulers/background/BackgroundThreadSchedulerTest.java b/rxandroid/src/test/java/rx/android/schedulers/background/BackgroundThreadSchedulerTest.java
new file mode 100644
index 00000000..26e776c8
--- /dev/null
+++ b/rxandroid/src/test/java/rx/android/schedulers/background/BackgroundThreadSchedulerTest.java
@@ -0,0 +1,120 @@
+package rx.android.schedulers.background;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
+
+import rx.Scheduler.Worker;
+import rx.android.plugins.RxAndroidPlugins;
+import rx.functions.Action0;
+import rx.plugins.RxJavaPlugins;
+import rx.plugins.RxJavaSchedulersHook;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.mock;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(manifest = Config.NONE)
+public class BackgroundThreadSchedulerTest {
+
+    @Before @After
+    public void setUpAndTearDown() {
+        RxAndroidPlugins.getInstance().reset();
+    }
+
+    @Test
+    public void newInstanceWorks() {
+        BackgroundThreadScheduler scheduler = BackgroundThreadScheduler.newInstance();
+        assertNotNull(scheduler);
+    }
+
+    @Test
+    public void testScheduledThroughHook() throws InterruptedException {
+        Action0 action = mock(Action0.class);
+        final AtomicReference<Action0> ref = new AtomicReference<>();
+
+        RxJavaPlugins.getInstance().registerSchedulersHook(new RxJavaSchedulersHook() {
+            @Override public Action0 onSchedule(Action0 action) {
+                ref.set(action);
+                return action;
+            }
+        });
+
+        BackgroundThreadScheduler scheduler = BackgroundThreadScheduler.newInstance();
+        Worker worker = scheduler.createWorker();
+        worker.schedule(action);
+
+        assertSame(action, ref.get());
+    }
+
+    @Test
+    public void testActionIsCalled() throws InterruptedException {
+        BackgroundThreadScheduler scheduler = BackgroundThreadScheduler.newInstance();
+        Worker worker = scheduler.createWorker();
+        final CountDownLatch latch = new CountDownLatch(1);
+        final AtomicBoolean isCalled = new AtomicBoolean(false);
+        Action0 action = new Action0() {
+            @Override public void call() {
+                isCalled.set(true);
+                latch.countDown();
+            }
+        };
+
+        worker.schedule(action);
+
+        latch.await(1, TimeUnit.SECONDS);
+        assertTrue(isCalled.get());
+    }
+
+    @Test
+    public void testThreadIsDifferent() throws InterruptedException {
+        BackgroundThreadScheduler scheduler = BackgroundThreadScheduler.newInstance();
+        Worker worker = scheduler.createWorker();
+
+        final AtomicLong backgroundThreadId = new AtomicLong();
+        final CountDownLatch latch = new CountDownLatch(1);
+        Action0 action = new Action0() {
+            @Override public void call() {
+                backgroundThreadId.set(Thread.currentThread().getId());
+                latch.countDown();
+            }
+        };
+        worker.schedule(action);
+
+        latch.await(1, TimeUnit.SECONDS);
+        assertNotEquals(Thread.currentThread().getId(), backgroundThreadId.get());
+    }
+
+    @Test
+    public void testThreadPriority() throws InterruptedException {
+        BackgroundThreadScheduler scheduler = BackgroundThreadScheduler.newInstance();
+        Worker worker = scheduler.createWorker();
+
+        final AtomicInteger backgroundThreadPriority = new AtomicInteger();
+        final CountDownLatch latch = new CountDownLatch(1);
+        Action0 action = new Action0() {
+            @Override public void call() {
+                backgroundThreadPriority.set(Thread.currentThread().getPriority());
+                latch.countDown();
+            }
+        };
+        worker.schedule(action);
+
+        latch.await(1, TimeUnit.SECONDS);
+        assertEquals(Thread.NORM_PRIORITY - 1, backgroundThreadPriority.get());
+    }
+}
\ No newline at end of file
diff --git a/rxandroid/src/test/java/rx/android/schedulers/HandlerSchedulerTest.java b/rxandroid/src/test/java/rx/android/schedulers/handler/HandlerSchedulerTest.java
similarity index 98%
rename from rxandroid/src/test/java/rx/android/schedulers/HandlerSchedulerTest.java
rename to rxandroid/src/test/java/rx/android/schedulers/handler/HandlerSchedulerTest.java
index a8bf01f3..cb9a09dd 100644
--- a/rxandroid/src/test/java/rx/android/schedulers/HandlerSchedulerTest.java
+++ b/rxandroid/src/test/java/rx/android/schedulers/handler/HandlerSchedulerTest.java
@@ -11,7 +11,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package rx.android.schedulers;
+package rx.android.schedulers.handler;
 
 import android.os.Handler;
 import org.junit.After;
@@ -30,6 +30,7 @@
 import rx.Subscription;
 import rx.android.plugins.RxAndroidPlugins;
 import rx.android.plugins.RxAndroidSchedulersHook;
+import rx.android.schedulers.handler.HandlerScheduler;
 import rx.functions.Action0;
 
 import java.util.concurrent.TimeUnit;
diff --git a/sample-app/src/main/java/rx/android/samples/MainActivity.java b/sample-app/src/main/java/rx/android/samples/MainActivity.java
index 23ed1b26..7a6109c7 100644
--- a/sample-app/src/main/java/rx/android/samples/MainActivity.java
+++ b/sample-app/src/main/java/rx/android/samples/MainActivity.java
@@ -10,7 +10,7 @@
 import rx.Observable;
 import rx.Subscriber;
 import rx.android.schedulers.AndroidSchedulers;
-import rx.android.schedulers.HandlerScheduler;
+import rx.android.schedulers.handler.HandlerScheduler;
 import rx.exceptions.OnErrorThrowable;
 import rx.functions.Func0;
 
