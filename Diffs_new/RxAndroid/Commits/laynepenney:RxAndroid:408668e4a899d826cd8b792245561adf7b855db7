diff --git a/rxandroid/src/main/java/rx/android/schedulers/HandlerScheduler.java b/rxandroid/src/main/java/rx/android/schedulers/HandlerScheduler.java
index a80e790c..7d76f67c 100644
--- a/rxandroid/src/main/java/rx/android/schedulers/HandlerScheduler.java
+++ b/rxandroid/src/main/java/rx/android/schedulers/HandlerScheduler.java
@@ -23,6 +23,7 @@
 import rx.subscriptions.CompositeSubscription;
 import rx.subscriptions.Subscriptions;
 import android.os.Handler;
+import android.os.Looper;
 
 /** A {@link Scheduler} backed by a {@link Handler}. */
 public final class HandlerScheduler extends Scheduler {
@@ -71,6 +72,12 @@ public Subscription schedule(Action0 action, long delayTime, TimeUnit unit) {
 
             action = RxAndroidPlugins.getInstance().getSchedulersHook().onSchedule(action);
 
+            // Fast path if action is immediate and we are already on the correct thread
+            if (delayTime == 0 && Looper.myLooper() == handler.getLooper()) {
+                action.call();
+                return Subscriptions.unsubscribed();
+            }
+
             final ScheduledAction scheduledAction = new ScheduledAction(action);
             scheduledAction.addParent(compositeSubscription);
             compositeSubscription.add(scheduledAction);
diff --git a/rxandroid/src/test/java/rx/android/schedulers/HandlerSchedulerTest.java b/rxandroid/src/test/java/rx/android/schedulers/HandlerSchedulerTest.java
index b6e99e24..d6d9c68d 100644
--- a/rxandroid/src/test/java/rx/android/schedulers/HandlerSchedulerTest.java
+++ b/rxandroid/src/test/java/rx/android/schedulers/HandlerSchedulerTest.java
@@ -14,6 +14,7 @@
 package rx.android.schedulers;
 
 import android.os.Handler;
+import android.os.Looper;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -38,15 +39,18 @@
 import static java.util.concurrent.TimeUnit.MINUTES;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyLong;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(manifest=Config.NONE)
@@ -108,6 +112,8 @@ public void shouldScheduleDelayedActionOnHandlerThread() {
     @Test
     public void shouldRemoveCallbacksFromHandlerWhenUnsubscribedSubscription() {
         Handler handler = spy(new Handler());
+        // Avoid fast path: Trick handler looper into being different than Looper.myLooper()
+        when(handler.getLooper()).thenReturn(null);
         Observable.OnSubscribe<Integer> onSubscribe = mock(Observable.OnSubscribe.class);
         Subscription subscription = Observable.create(onSubscribe)
                 .subscribeOn(HandlerScheduler.from(handler))
@@ -220,4 +226,48 @@ public void call() {
 
         assertTrue(neverCalled.get());
     }
+
+    @Test
+    public void shouldPerformFastPathForImmediateActionIsAlreadyOnTargetThread() {
+        // Explicitly create handler with same looper as current thread
+        Looper myLooper = Looper.myLooper();
+        assertNotNull(myLooper);
+        Handler handler = spy(new Handler(myLooper));
+        Observable.OnSubscribe<Integer> onSubscribe = mock(Observable.OnSubscribe.class);
+
+        Subscription subscription = Observable.create(onSubscribe)
+                .subscribeOn(HandlerScheduler.from(handler))
+                .subscribe();
+
+        // Verify onSubscribe is called
+        verify(onSubscribe).call(any(Subscriber.class));
+
+        subscription.unsubscribe();
+
+        // Verify action was called directly, and not through handler
+        verify(handler, never()).postDelayed(any(Runnable.class), anyLong());
+        verify(handler, never()).removeCallbacks(any(Runnable.class));
+    }
+
+    @Test
+    public void shouldNotPerformFastPathForDelayedAction() {
+        // Explicitly create handler with same looper as current thread
+        Looper myLooper = Looper.myLooper();
+        assertNotNull(myLooper);
+        Handler handler = spy(new Handler(myLooper));
+        @SuppressWarnings("unchecked")
+        Action0 action = mock(Action0.class);
+
+        Scheduler scheduler = HandlerScheduler.from(handler);
+        Worker inner = scheduler.createWorker();
+        inner.schedule(action, 1, SECONDS);
+
+        // verify that we post to the given Handler
+        ArgumentCaptor<Runnable> runnable = ArgumentCaptor.forClass(Runnable.class);
+        verify(handler).postDelayed(runnable.capture(), eq(1000L));
+
+        // verify that the given handler delegates to our action
+        runnable.getValue().run();
+        verify(action).call();
+    }
 }
