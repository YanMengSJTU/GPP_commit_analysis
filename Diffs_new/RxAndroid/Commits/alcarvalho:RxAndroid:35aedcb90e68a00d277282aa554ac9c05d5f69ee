diff --git a/rxandroid/src/main/java/rx/android/view/OnFocusChangeEvent.java b/rxandroid/src/main/java/rx/android/view/OnFocusChangeEvent.java
new file mode 100644
index 00000000..adc36339
--- /dev/null
+++ b/rxandroid/src/main/java/rx/android/view/OnFocusChangeEvent.java
@@ -0,0 +1,31 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package rx.android.view;
+
+import android.view.View;
+import com.google.auto.value.AutoValue;
+
+@AutoValue
+public abstract class OnFocusChangeEvent {
+    public abstract View view();
+    public abstract boolean hasFocus();
+
+    public static OnFocusChangeEvent create(final View view) {
+        return create(view, view.hasFocus());
+    }
+
+    public static OnFocusChangeEvent create(final View view, boolean hasFocus) {
+        return new AutoValue_OnFocusChangeEvent(view, hasFocus);
+    }
+}
diff --git a/rxandroid/src/main/java/rx/android/view/OnSubscribeViewFocusChange.java b/rxandroid/src/main/java/rx/android/view/OnSubscribeViewFocusChange.java
new file mode 100644
index 00000000..14977edd
--- /dev/null
+++ b/rxandroid/src/main/java/rx/android/view/OnSubscribeViewFocusChange.java
@@ -0,0 +1,102 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package rx.android.view;
+
+import android.view.View;
+import rx.Observable;
+import rx.Subscriber;
+import rx.Subscription;
+import rx.android.internal.Assertions;
+import rx.android.AndroidSubscriptions;
+import rx.functions.Action0;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.WeakHashMap;
+
+final class OnSubscribeViewFocusChange implements Observable.OnSubscribe<OnFocusChangeEvent> {
+    private final boolean emitInitialValue;
+    private final View view;
+
+    public OnSubscribeViewFocusChange(final View view, final boolean emitInitialValue) {
+        this.emitInitialValue = emitInitialValue;
+        this.view = view;
+    }
+
+    @Override
+    public void call(final Subscriber<? super OnFocusChangeEvent> observer) {
+        Assertions.assertUiThread();
+        final CompositeOnFocusChangeListener composite = CachedListeners.getFromViewOrCreate(view);
+
+        final View.OnFocusChangeListener listener = new View.OnFocusChangeListener() {
+            @Override
+            public void onFocusChange(View view, boolean hasFocus) {
+                observer.onNext(OnFocusChangeEvent.create(view, hasFocus));
+            }
+        };
+
+        final Subscription subscription = AndroidSubscriptions.unsubscribeInUiThread(new Action0() {
+            @Override
+            public void call() {
+                composite.removeOnFocusChangeListener(listener);
+            }
+        });
+
+        if (emitInitialValue) {
+            observer.onNext(OnFocusChangeEvent.create(view));
+        }
+
+        composite.addOnFocusChangeListener(listener);
+        observer.add(subscription);
+    }
+
+    private static class CompositeOnFocusChangeListener implements View.OnFocusChangeListener {
+        private final List<View.OnFocusChangeListener> listeners = new ArrayList<View.OnFocusChangeListener>();
+
+        public boolean addOnFocusChangeListener(final View.OnFocusChangeListener listener) {
+            return listeners.add(listener);
+        }
+
+        public boolean removeOnFocusChangeListener(final View.OnFocusChangeListener listener) {
+            return listeners.remove(listener);
+        }
+
+        @Override
+        public void onFocusChange(final View view, final boolean hasFocus) {
+            for (View.OnFocusChangeListener listener : listeners) {
+                listener.onFocusChange(view, hasFocus);
+            }
+        }
+    }
+
+    private static class CachedListeners {
+        private static final Map<View, CompositeOnFocusChangeListener> sCachedListeners = new WeakHashMap<View, CompositeOnFocusChangeListener>();
+
+        public static CompositeOnFocusChangeListener getFromViewOrCreate(final View view) {
+            final CompositeOnFocusChangeListener cached = sCachedListeners.get(view);
+
+            if (cached != null) {
+                return cached;
+            }
+
+            final CompositeOnFocusChangeListener listener = new CompositeOnFocusChangeListener();
+
+            sCachedListeners.put(view, listener);
+            view.setOnFocusChangeListener(listener);
+
+            return listener;
+        }
+    }
+}
diff --git a/rxandroid/src/main/java/rx/android/view/ViewObservable.java b/rxandroid/src/main/java/rx/android/view/ViewObservable.java
index 53586d26..af2b4a15 100644
--- a/rxandroid/src/main/java/rx/android/view/ViewObservable.java
+++ b/rxandroid/src/main/java/rx/android/view/ViewObservable.java
@@ -34,6 +34,15 @@ private ViewObservable() {
         return Observable.create(new OnSubscribeViewClick(view, emitInitialValue));
     }
 
+    public static Observable<OnFocusChangeEvent> focus(final View input) {
+        return focus(input, false);
+    }
+
+    public static Observable<OnFocusChangeEvent> focus(final View input, final boolean emitInitialValue) {
+        return Observable.create(new OnSubscribeViewFocusChange(input, emitInitialValue));
+    }
+
+
     /**
      * Binds the given source sequence to the view.
      * <p>
diff --git a/rxandroid/src/test/java/rx/android/view/OperatorViewFocusChangeTest.java b/rxandroid/src/test/java/rx/android/view/OperatorViewFocusChangeTest.java
new file mode 100644
index 00000000..9105b787
--- /dev/null
+++ b/rxandroid/src/test/java/rx/android/view/OperatorViewFocusChangeTest.java
@@ -0,0 +1,143 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package rx.android.view;
+
+import android.app.Activity;
+import android.view.View;
+
+import android.widget.LinearLayout;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.InOrder;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+
+import rx.Observable;
+import rx.Observer;
+import rx.Subscription;
+import rx.observers.TestObserver;
+
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.refEq;
+import static org.mockito.Mockito.times;
+
+@RunWith(RobolectricTestRunner.class)
+public class OperatorViewFocusChangeTest {
+    private static OnFocusChangeEvent mkMockedEvent(final View view, final boolean hasFocus) {
+        return refEq(OnFocusChangeEvent.create(view, hasFocus));
+    }
+
+    private static View mkFocusableViewWithParent() {
+        final Activity context = Robolectric.buildActivity(Activity.class).create().get();
+        final View view = new View(context);
+        final LinearLayout parent = new LinearLayout(context);
+        view.setFocusable(true);
+        parent.setFocusable(true);
+        parent.addView(view);
+        return view;
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void testWithoutInitialValue() {
+        final View view = mkFocusableViewWithParent();
+        final Observable<OnFocusChangeEvent> observable = ViewObservable.focus(view, false);
+        final Observer<OnFocusChangeEvent> observer = mock(Observer.class);
+        final Subscription subscription = observable.subscribe(new TestObserver<OnFocusChangeEvent>(observer));
+
+        final InOrder inOrder = inOrder(observer);
+
+        inOrder.verify(observer, never()).onNext(any(OnFocusChangeEvent.class));
+
+        view.requestFocus();
+        inOrder.verify(observer, times(1)).onNext(mkMockedEvent(view, true));
+
+        view.clearFocus();
+        inOrder.verify(observer, times(1)).onNext(mkMockedEvent(view, false));
+
+        subscription.unsubscribe();
+        inOrder.verify(observer, never()).onNext(any(OnFocusChangeEvent.class));
+
+        inOrder.verify(observer, never()).onError(any(Throwable.class));
+        inOrder.verify(observer, never()).onCompleted();
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void testWithInitialValue() {
+        final View view = mkFocusableViewWithParent();
+        final Observable<OnFocusChangeEvent> observable = ViewObservable.focus(view, true);
+        final Observer<OnFocusChangeEvent> observer = mock(Observer.class);
+        final Subscription subscription = observable.subscribe(new TestObserver<OnFocusChangeEvent>(observer));
+
+        final InOrder inOrder = inOrder(observer);
+
+        inOrder.verify(observer, times(1)).onNext(mkMockedEvent(view, false));
+
+        view.requestFocus();
+        inOrder.verify(observer, times(1)).onNext(mkMockedEvent(view, true));
+
+        view.clearFocus();
+        inOrder.verify(observer, times(1)).onNext(mkMockedEvent(view, false));
+
+        subscription.unsubscribe();
+        inOrder.verify(observer, never()).onNext(any(OnFocusChangeEvent.class));
+
+        inOrder.verify(observer, never()).onError(any(Throwable.class));
+        inOrder.verify(observer, never()).onCompleted();
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void testMultipleSubscriptions() {
+        final View view = mkFocusableViewWithParent();
+        final Observable<OnFocusChangeEvent> observable = ViewObservable.focus(view, false);
+
+        final Observer<OnFocusChangeEvent> observer1 = mock(Observer.class);
+        final Observer<OnFocusChangeEvent> observer2 = mock(Observer.class);
+
+        final Subscription subscription1 = observable.subscribe(new TestObserver<OnFocusChangeEvent>(observer1));
+        final Subscription subscription2 = observable.subscribe(new TestObserver<OnFocusChangeEvent>(observer2));
+
+        final InOrder inOrder1 = inOrder(observer1);
+        final InOrder inOrder2 = inOrder(observer2);
+
+        view.requestFocus();
+        inOrder1.verify(observer1, times(1)).onNext(mkMockedEvent(view, true));
+        inOrder2.verify(observer2, times(1)).onNext(mkMockedEvent(view, true));
+
+        view.clearFocus();
+        inOrder1.verify(observer1, times(1)).onNext(mkMockedEvent(view, false));
+        inOrder2.verify(observer2, times(1)).onNext(mkMockedEvent(view, false));
+        subscription1.unsubscribe();
+
+        view.requestFocus();
+        inOrder1.verify(observer1, never()).onNext(any(OnFocusChangeEvent.class));
+        inOrder2.verify(observer2, times(1)).onNext(mkMockedEvent(view, true));
+        subscription2.unsubscribe();
+
+        view.clearFocus();
+        inOrder1.verify(observer1, never()).onNext(any(OnFocusChangeEvent.class));
+        inOrder2.verify(observer2, never()).onNext(any(OnFocusChangeEvent.class));
+
+        inOrder1.verify(observer1, never()).onError(any(Throwable.class));
+        inOrder2.verify(observer2, never()).onError(any(Throwable.class));
+
+        inOrder1.verify(observer1, never()).onCompleted();
+        inOrder2.verify(observer2, never()).onCompleted();
+    }
+}
