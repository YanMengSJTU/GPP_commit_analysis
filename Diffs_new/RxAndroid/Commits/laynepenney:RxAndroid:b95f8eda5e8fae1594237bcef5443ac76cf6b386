diff --git a/rxandroid/src/main/java/rx/android/internal/ChildSubscription.java b/rxandroid/src/main/java/rx/android/internal/ChildSubscription.java
new file mode 100644
index 00000000..19d19da0
--- /dev/null
+++ b/rxandroid/src/main/java/rx/android/internal/ChildSubscription.java
@@ -0,0 +1,51 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.android.internal;
+
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+
+import rx.Subscription;
+import rx.subscriptions.CompositeSubscription;
+
+final class ChildSubscription implements Subscription {
+    private static final AtomicIntegerFieldUpdater<ChildSubscription> UNSUBSCRIBED_UPDATER
+            = AtomicIntegerFieldUpdater.newUpdater(ChildSubscription.class, "unsubscribed");
+
+    private final Subscription actual;
+    private final CompositeSubscription parent;
+    private volatile int unsubscribed;
+
+    ChildSubscription(Subscription actual, CompositeSubscription parent) {
+        this.actual = actual;
+        this.parent = parent;
+    }
+
+    @Override
+    public void unsubscribe() {
+        if (UNSUBSCRIBED_UPDATER.compareAndSet(this, 0, 1)) {
+            actual.unsubscribe();
+            parent.remove(this);
+        }
+    }
+
+    @Override
+    public boolean isUnsubscribed() {
+        final boolean unsubscribed = actual.isUnsubscribed();
+        if (unsubscribed && UNSUBSCRIBED_UPDATER.compareAndSet(this, 0, 1)) {
+            parent.remove(this);
+        }
+        return unsubscribed;
+    }
+}
diff --git a/rxandroid/src/main/java/rx/android/internal/Util.java b/rxandroid/src/main/java/rx/android/internal/Util.java
new file mode 100644
index 00000000..7e3e8de5
--- /dev/null
+++ b/rxandroid/src/main/java/rx/android/internal/Util.java
@@ -0,0 +1,28 @@
+package rx.android.internal;
+
+import rx.Observable;
+import rx.Subscriber;
+import rx.Subscription;
+import rx.subscriptions.CompositeSubscription;
+
+public final class Util {
+    private Util() { throw new AssertionError("no instances"); }
+
+    public static Subscription attachToComposite(Subscription subscription,
+            CompositeSubscription cs) {
+        Subscription sub = new ChildSubscription(subscription, cs);
+        cs.add(sub);
+        return sub;
+    }
+
+    public static <T> Subscription subscribeWithComposite(Observable<T> observable,
+            Subscriber<? super T> subscriber,
+            CompositeSubscription cs) {
+        final Subscription actual = observable.subscribe(subscriber);
+        final Subscription sub = attachToComposite(actual, cs);
+        // NOTE: We have to do this in order to remove the subscription from the list if the
+        // observable completes before the composite is unsubscribed
+        subscriber.add(sub);
+        return sub;
+    }
+}
diff --git a/rxandroid/src/main/java/rx/android/lifecycle/LifecycleEvent.java b/rxandroid/src/main/java/rx/android/lifecycle/LifecycleEvent.java
new file mode 100644
index 00000000..7d3e3a61
--- /dev/null
+++ b/rxandroid/src/main/java/rx/android/lifecycle/LifecycleEvent.java
@@ -0,0 +1,31 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * <p/>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p/>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.android.lifecycle;
+
+/**
+ * Lifecycle events that can be emitted by Activities or Fragments.
+ */
+public enum LifecycleEvent {
+    ATTACH,
+    CREATE,
+    CREATE_VIEW,
+    START,
+    RESUME,
+    PAUSE,
+    STOP,
+    DESTROY_VIEW,
+    DESTROY,
+    DETACH
+}
diff --git a/rxandroid/src/main/java/rx/android/lifecycle/LifecycleObservationCalculator.java b/rxandroid/src/main/java/rx/android/lifecycle/LifecycleObservationCalculator.java
new file mode 100644
index 00000000..486d831f
--- /dev/null
+++ b/rxandroid/src/main/java/rx/android/lifecycle/LifecycleObservationCalculator.java
@@ -0,0 +1,77 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.android.lifecycle;
+
+public interface LifecycleObservationCalculator {
+    LifecycleObservationCalculator ACTIVITY = new LifecycleObservationCalculator() {
+        @Override public LifecycleEvent observeUntil(LifecycleEvent current) {
+            if (current == null) {
+                return LifecycleEvent.DESTROY;
+            }
+            switch (current) {
+                case CREATE:
+                    return LifecycleEvent.DESTROY;
+                case START:
+                    return LifecycleEvent.STOP;
+                case RESUME:
+                    return LifecycleEvent.PAUSE;
+                case PAUSE:
+                    return LifecycleEvent.STOP;
+                case STOP:
+                case DESTROY:
+                default:
+                    return LifecycleEvent.DESTROY;
+            }
+        }
+    };
+
+    LifecycleObservationCalculator FRAGMENT = new LifecycleObservationCalculator() {
+        @Override public LifecycleEvent observeUntil(LifecycleEvent current) {
+            if (current == null) {
+                return LifecycleEvent.DETACH;
+            }
+            switch (current) {
+                case ATTACH:
+                    return LifecycleEvent.DETACH;
+                case CREATE:
+                    return LifecycleEvent.DESTROY;
+                case CREATE_VIEW:
+                    return LifecycleEvent.DESTROY_VIEW;
+                case START:
+                    return LifecycleEvent.STOP;
+                case RESUME:
+                    return LifecycleEvent.PAUSE;
+                case PAUSE:
+                    return LifecycleEvent.STOP;
+                case STOP:
+                    return LifecycleEvent.DESTROY_VIEW;
+                case DESTROY_VIEW:
+                    return LifecycleEvent.DESTROY;
+                case DESTROY:
+                case DETACH:
+                default:
+                    return LifecycleEvent.DETACH;
+            }
+        }
+    };
+
+    LifecycleObservationCalculator UNTIL_STOP = new LifecycleObservationCalculator() {
+        @Override public LifecycleEvent observeUntil(LifecycleEvent current) {
+            return LifecycleEvent.STOP;
+        }
+    };
+
+    LifecycleEvent observeUntil(LifecycleEvent current);
+}
diff --git a/rxandroid/src/main/java/rx/android/lifecycle/LifecycleProducer.java b/rxandroid/src/main/java/rx/android/lifecycle/LifecycleProducer.java
new file mode 100644
index 00000000..3c752824
--- /dev/null
+++ b/rxandroid/src/main/java/rx/android/lifecycle/LifecycleProducer.java
@@ -0,0 +1,73 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.android.lifecycle;
+
+
+import rx.Observable;
+import rx.subjects.BehaviorSubject;
+
+public final class LifecycleProducer {
+    private final BehaviorSubject<LifecycleEvent> subject = BehaviorSubject.create();
+
+    private LifecycleProducer() {}
+
+    public static LifecycleProducer create() {
+        return new LifecycleProducer();
+    }
+
+    public void onAttach() {
+        subject.onNext(LifecycleEvent.ATTACH);
+    }
+
+    public void onCreate() {
+        subject.onNext(LifecycleEvent.CREATE);
+    }
+
+    public void onViewCreated() {
+        subject.onNext(LifecycleEvent.CREATE_VIEW);
+    }
+
+    public void onStart() {
+        subject.onNext(LifecycleEvent.START);
+    }
+
+    public void onResume() {
+        subject.onNext(LifecycleEvent.RESUME);
+    }
+
+    public void onPause() {
+        subject.onNext(LifecycleEvent.PAUSE);
+    }
+
+    public void onStop() {
+        subject.onNext(LifecycleEvent.STOP);
+    }
+
+    public void onDestroyView() {
+        subject.onNext(LifecycleEvent.DESTROY_VIEW);
+    }
+
+    public void onDestroy() {
+        subject.onNext(LifecycleEvent.DESTROY);
+    }
+
+    public void onDetach() {
+        subject.onNext(LifecycleEvent.DETACH);
+    }
+
+    public Observable<LifecycleEvent> asObservable() {
+        return subject.asObservable();
+    }
+}
diff --git a/rxandroid/src/main/java/rx/android/lifecycle/LifecycleSubscriptions.java b/rxandroid/src/main/java/rx/android/lifecycle/LifecycleSubscriptions.java
new file mode 100644
index 00000000..96c096af
--- /dev/null
+++ b/rxandroid/src/main/java/rx/android/lifecycle/LifecycleSubscriptions.java
@@ -0,0 +1,310 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.android.lifecycle;
+
+
+import android.util.Log;
+
+import java.util.concurrent.atomic.AtomicReference;
+
+import rx.Observable;
+import rx.Observer;
+import rx.Subscriber;
+import rx.Subscription;
+import rx.android.internal.Util;
+import rx.android.subscribers.NullingSubscriber;
+import rx.functions.Action0;
+import rx.functions.Action1;
+import rx.subscriptions.CompositeSubscription;
+import rx.subscriptions.Subscriptions;
+
+public final class LifecycleSubscriptions {
+    private static final String TAG = LifecycleSubscriptions.class.getSimpleName();
+
+    private final AtomicReference<LifecycleProducer> producer = new AtomicReference<LifecycleProducer>();
+    private final LifecycleObservationCalculator observationCalculator;
+    private final Thread thread = Thread.currentThread();
+    // We never recycle the current node, so create one initially instead of from the pool here
+    private SubscriptionNode current = new SubscriptionNode();
+
+    private LifecycleSubscriptions(LifecycleObservationCalculator observationCalculator) {
+        this.observationCalculator = observationCalculator;
+    }
+
+    public static LifecycleSubscriptions observeActivity() {
+        return new LifecycleSubscriptions(LifecycleObservationCalculator.ACTIVITY);
+    }
+
+    public static LifecycleSubscriptions observeFragment() {
+        return new LifecycleSubscriptions(LifecycleObservationCalculator.FRAGMENT);
+    }
+
+    public static LifecycleSubscriptions observeUntilStop() {
+        return new LifecycleSubscriptions(LifecycleObservationCalculator.UNTIL_STOP);
+    }
+
+    public static LifecycleSubscriptions observe(LifecycleObservationCalculator bindingCalculator) {
+        return new LifecycleSubscriptions(bindingCalculator);
+    }
+
+    public boolean setProducer(LifecycleProducer producer) {
+        if (this.producer.compareAndSet(null, producer)) {
+            producer.asObservable().subscribe(new LifecycleObserver());
+            return true;
+        }
+        return false;
+    }
+
+    public Observable<LifecycleEvent> lifecycleObservable() {
+        LifecycleProducer producer = this.producer.get();
+        if (producer == null) {
+            throw new IllegalStateException(
+                    "must set producer before calling lifecycleObservable()");
+        }
+        return producer.asObservable();
+    }
+
+    public <T> Subscription subscribe(Observable<T> observable, Action1<? super T> onNext) {
+        return with(observable)
+                .subscribe(onNext);
+    }
+
+    public <T> Subscription subscribe(Observable<T> observable,
+            Action1<? super T> onNext,
+            Action1<Throwable> onError) {
+        return with(observable)
+                .subscribe(onNext, onError);
+    }
+
+    public <T> Subscription subscribe(Observable<T> observable,
+            Action1<? super T> onNext,
+            Action1<Throwable> onError,
+            Action0 onCompleted) {
+        return with(observable)
+                .subscribe(onNext, onError, onCompleted);
+    }
+
+    public <T> Subscription subscribe(Observable<T> observable,
+            Observer<? super T> observer) {
+        return with(observable)
+                .subscribe(observer);
+    }
+
+    public <T> Subscription subscribe(Observable<T> observable,
+            Subscriber<? super T> subscriber) {
+        return with(observable)
+                .subscribe(subscriber);
+    }
+
+    public <T> SubscriptionBuilder<T> with(Observable<T> observable) {
+        return new SubscriptionBuilder<T>(this, observable);
+    }
+
+    public LifecycleEvent observeUntil() {
+        LifecycleEvent current = this.current.event;
+        return observationCalculator.observeUntil(current);
+    }
+
+    <T> Subscription subscribe(Observable<T> observable,
+            LifecycleEvent observeUntil,
+            NullingSubscriber<? super T> subscriber) {
+        assertThread();
+        // First verify that event has not already passed
+        if (!canSubscribe(observeUntil)) {
+            Log.w(TAG, "not subscribing to observable. Binding LifecycleEvent has already passed");
+            subscriber.unsubscribe();
+            return Subscriptions.unsubscribed();
+        }
+        // Subscribe and add to composite
+        final CompositeSubscription cs = current.insertAndPopulate(observeUntil).cs;
+        return Util.subscribeWithComposite(observable, subscriber, cs);
+    }
+
+    private void assertThread() {
+        if (thread != Thread.currentThread()) {
+            throw new AssertionError("LifecycleSubscriptions must only be used on one thread");
+        }
+    }
+
+    private boolean canSubscribe(LifecycleEvent event) {
+        return current.ordinal() < ordinal(event);
+    }
+
+    private static int ordinal(LifecycleEvent event) {
+        if (event != null) {
+            return event.ordinal();
+        }
+        return -1;
+    }
+
+    private final class LifecycleObserver implements Observer<LifecycleEvent> {
+        @Override public void onCompleted() {
+            // should never be called
+            assertThread();
+            current = current.drain(LifecycleEvent.DETACH);
+        }
+
+        @Override public void onError(Throwable throwable) {
+            // should never be called
+            assertThread();
+            current = current.drain(LifecycleEvent.DETACH);
+        }
+
+        @Override public void onNext(LifecycleEvent lifecycleEvent) {
+            assertThread();
+            current = current.drain(lifecycleEvent);
+        }
+    }
+
+    private static final class SubscriptionNode implements Subscription {
+        private static final Object sPoolSync = new Object();
+        private static SubscriptionNode sPool;
+        private static int sPoolSize = 0;
+        private static final int MAX_POOL_SIZE = 10;
+
+        SubscriptionNode prev;
+        SubscriptionNode next;
+        LifecycleEvent event;
+        CompositeSubscription cs;
+
+        int ordinal() {
+            return LifecycleSubscriptions.ordinal(event);
+        }
+
+        SubscriptionNode insertAndPopulate(LifecycleEvent event) {
+            SubscriptionNode node = insert(event);
+            if (node.cs == null) {
+                node.cs = new CompositeSubscription();
+            }
+            return node;
+        }
+
+        SubscriptionNode insert(LifecycleEvent event) {
+            final int ordinal = LifecycleSubscriptions.ordinal(event);
+            if (ordinal == ordinal()) {
+                return this;
+            } else if (ordinal < ordinal()) {
+                SubscriptionNode current = this;
+                while (current.prev != null) {
+                    if (ordinal == current.prev.ordinal()) {
+                        return current.prev;
+                    } else if (ordinal > current.prev.ordinal()) {
+                        SubscriptionNode node = obtain();
+                        node.event = event;
+                        node.prev = current.prev;
+                        node.next = current;
+                        current.prev.next = node;
+                        current.prev = node;
+                        return node;
+                    }
+                    current = current.prev;
+                }
+                SubscriptionNode node = obtain();
+                node.event = event;
+                node.next = current;
+                current.prev = node;
+                return node;
+            } else {
+                SubscriptionNode current = this;
+                while (current.next != null) {
+                    if (ordinal == current.next.ordinal()) {
+                        return current.next;
+                    } else if (ordinal < current.next.ordinal()) {
+                        SubscriptionNode node = obtain();
+                        node.event = event;
+                        node.next = current.next;
+                        node.prev = current;
+                        current.next.prev = node;
+                        current.next = node;
+                        return node;
+                    }
+                    current = current.next;
+                }
+                SubscriptionNode node = obtain();
+                node.event = event;
+                node.prev = current;
+                current.next = node;
+                return node;
+            }
+        }
+
+        SubscriptionNode drain(LifecycleEvent event) {
+            SubscriptionNode current = insert(event);
+            SubscriptionNode head = findHead(current);
+            while (head != current) {
+                SubscriptionNode next = head.next;
+                head.recycle();
+                head = next;
+            }
+            current.prev = null;
+            current.unsubscribe();
+            return current;
+        }
+
+        @Override public boolean isUnsubscribed() {
+            return cs == null || cs.isUnsubscribed();
+        }
+
+        @Override public void unsubscribe() {
+            if (cs != null) {
+                if (Log.isLoggable(TAG, Log.VERBOSE)) { Log.v(TAG, "unsubscribing " + this); }
+                cs.unsubscribe();
+                cs = null;
+            }
+        }
+
+        @Override public String toString() {
+            return "SubscriptionNode{" +
+                    "event=" + event +
+                    '}';
+        }
+
+        private void recycle() {
+            next = null;
+            prev = null;
+            event = null;
+            unsubscribe();
+
+            synchronized (sPoolSync) {
+                if (sPoolSize < MAX_POOL_SIZE) {
+                    next = sPool;
+                    sPool = this;
+                    sPoolSize++;
+                }
+            }
+        }
+
+        private static SubscriptionNode findHead(SubscriptionNode node) {
+            SubscriptionNode head = node;
+            while (head.prev != null) {
+                head = head.prev;
+            }
+            return head;
+        }
+
+        private static SubscriptionNode obtain() {
+            synchronized (sPoolSync) {
+                if (sPool != null) {
+                    SubscriptionNode n = sPool;
+                    sPool = n.next;
+                    n.next = null;
+                    sPoolSize--;
+                    return n;
+                }
+            }
+            return new SubscriptionNode();
+        }
+    }
+}
diff --git a/rxandroid/src/main/java/rx/android/lifecycle/SubscriptionBuilder.java b/rxandroid/src/main/java/rx/android/lifecycle/SubscriptionBuilder.java
new file mode 100644
index 00000000..722c4189
--- /dev/null
+++ b/rxandroid/src/main/java/rx/android/lifecycle/SubscriptionBuilder.java
@@ -0,0 +1,101 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.android.lifecycle;
+
+import rx.Observable;
+import rx.Observer;
+import rx.Scheduler;
+import rx.Subscriber;
+import rx.Subscription;
+import rx.android.schedulers.AndroidSchedulers;
+import rx.android.subscribers.ActionSubscriber;
+import rx.android.subscribers.NullingSubscriber;
+import rx.functions.Action0;
+import rx.functions.Action1;
+import rx.observers.Subscribers;
+
+public final class SubscriptionBuilder<T> {
+    private final LifecycleSubscriptions subscriptions;
+    private final Observable<T> observable;
+    private Scheduler subscribeOn;
+    private LifecycleEvent observeUntil;
+    private Scheduler observeOn;
+
+    SubscriptionBuilder(LifecycleSubscriptions subscriptions, Observable<T> observable) {
+        this.subscriptions = subscriptions;
+        this.observable = observable;
+    }
+
+    public SubscriptionBuilder<T> subscribeOn(Scheduler subscribeOn) {
+        this.subscribeOn = subscribeOn;
+        return this;
+    }
+
+    public SubscriptionBuilder<T> observeUntil(LifecycleEvent event) {
+        this.observeUntil = event;
+        return this;
+    }
+
+    public SubscriptionBuilder<T> observeOnMainThread() {
+        return observeOn(AndroidSchedulers.mainThread());
+    }
+
+    public SubscriptionBuilder<T> observeOn(Scheduler observeOn) {
+        this.observeOn = observeOn;
+        return this;
+    }
+
+    public Subscription subscribe(Action1<? super T> onNext) {
+        return subscribe(new ActionSubscriber<T>(onNext));
+    }
+
+    public Subscription subscribe(Action1<? super T> onNext, Action1<Throwable> onError) {
+        return subscribe(new ActionSubscriber<T>(onNext, onError));
+    }
+
+    public Subscription subscribe(Action1<? super T> onNext, Action1<Throwable> onError,
+            Action0 onCompleted) {
+        return subscribe(new ActionSubscriber<T>(onNext, onError, onCompleted));
+    }
+
+    public Subscription subscribe(Observer<? super T> observer) {
+        return subscribe(Subscribers.from(observer));
+    }
+
+    public Subscription subscribe(Subscriber<? super T> subscriber) {
+        // ObserveUntil
+        LifecycleEvent observeUntil = this.observeUntil;
+        if (observeUntil == null) {
+            observeUntil = subscriptions.observeUntil();
+        }
+
+        // SubscribeOn
+        Scheduler subscribeOn = this.subscribeOn;
+        Observable<T> observable = subscribeOn == null
+                ? this.observable
+                : this.observable.subscribeOn(subscribeOn);
+
+        // ObserveOn
+        Scheduler observeOn = this.observeOn;
+        observable = observeOn == null
+                ? observable
+                : observable.observeOn(observeOn);
+
+        // Actual subscribe
+        return subscriptions.subscribe(observable,
+                observeUntil,
+                NullingSubscriber.create(subscriber));
+    }
+}
diff --git a/rxandroid/src/main/java/rx/android/subscribers/ActionSubscriber.java b/rxandroid/src/main/java/rx/android/subscribers/ActionSubscriber.java
new file mode 100644
index 00000000..260931dc
--- /dev/null
+++ b/rxandroid/src/main/java/rx/android/subscribers/ActionSubscriber.java
@@ -0,0 +1,69 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.android.subscribers;
+
+import rx.Subscriber;
+import rx.exceptions.OnErrorNotImplementedException;
+import rx.functions.Action0;
+import rx.functions.Action1;
+
+/**
+ * Helper class to encapsulate actions into a subscriber.
+ *
+ * @param <T>
+ */
+public class ActionSubscriber<T> extends Subscriber<T> {
+    private final Action1<? super T> onNext;
+    private final Action1<Throwable> onError;
+    private final Action0 onCompleted;
+
+    public ActionSubscriber(Action1<? super T> onNext) {
+        this(onNext, null, null);
+    }
+
+    public ActionSubscriber(Action1<? super T> onNext, Action1<Throwable> onError) {
+        this(onNext, onError, null);
+    }
+
+    public ActionSubscriber(Action1<? super T> onNext, Action1<Throwable> onError,
+            Action0 onCompleted) {
+        this.onNext = onNext;
+        this.onError = onError;
+        this.onCompleted = onCompleted;
+    }
+
+    @Override
+    public void onNext(T t) {
+        if (onNext != null) {
+            onNext.call(t);
+        }
+    }
+
+    @Override
+    public void onError(Throwable e) {
+        if (onError != null) {
+            onError.call(e);
+        } else {
+            throw new OnErrorNotImplementedException(e);
+        }
+    }
+
+    @Override
+    public void onCompleted() {
+        if (onCompleted != null) {
+            onCompleted.call();
+        }
+    }
+}
diff --git a/rxandroid/src/main/java/rx/android/subscribers/NullingSubscriber.java b/rxandroid/src/main/java/rx/android/subscribers/NullingSubscriber.java
new file mode 100644
index 00000000..d52db1b0
--- /dev/null
+++ b/rxandroid/src/main/java/rx/android/subscribers/NullingSubscriber.java
@@ -0,0 +1,145 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.android.subscribers;
+
+import android.util.Log;
+
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+
+import rx.Observer;
+import rx.Producer;
+import rx.Subscriber;
+import rx.Subscription;
+import rx.functions.Action0;
+import rx.functions.Action1;
+import rx.observers.Subscribers;
+
+/**
+ * Helper class that removes its reference to a subscriber after unsubscribe is called.
+ *
+ * @param <T>
+ */
+public final class NullingSubscriber<T> extends Subscriber<T> {
+    private final Delegate<T> delegate;
+
+    private NullingSubscriber(Subscriber<? super T> actual, Delegate<T> delegate) {
+        super(delegate);
+        this.delegate = delegate;
+        add(new NullingSubscription(delegate, actual));
+    }
+
+    public static <T> NullingSubscriber<T> create(Action1<? super T> onNext) {
+        return create(new ActionSubscriber<T>(onNext));
+    }
+
+    public static <T> NullingSubscriber<T> create(Action1<? super T> onNext,
+            Action1<Throwable> onError) {
+        return create(new ActionSubscriber<T>(onNext, onError));
+    }
+
+    public static <T> NullingSubscriber<T> create(Action1<? super T> onNext,
+            Action1<Throwable> onError,
+            Action0 onCompleted) {
+        return create(new ActionSubscriber<T>(onNext, onError, onCompleted));
+    }
+
+    public static <T> NullingSubscriber<T> create(Observer<? super T> actual) {
+        return create(Subscribers.from(actual));
+    }
+
+    public static <T> NullingSubscriber<T> create(Subscriber<? super T> actual) {
+        return new NullingSubscriber<T>(actual, new Delegate<T>());
+    }
+
+    @Override public void onNext(T t) {
+        delegate.onNext(t);
+    }
+
+    @Override public void onError(Throwable e) {
+        delegate.onError(e);
+    }
+
+    @Override public void onCompleted() {
+        delegate.onCompleted();
+    }
+
+    @Override public void onStart() {
+        delegate.onStart();
+    }
+
+    private static final class NullingSubscription implements Subscription {
+        private static final AtomicIntegerFieldUpdater<NullingSubscription> UNSUBSCRIBED_UPDATER
+                = AtomicIntegerFieldUpdater.newUpdater(NullingSubscription.class, "unsubscribed");
+
+        private final Delegate<?> parent;
+        private volatile int unsubscribed;
+
+        private <T> NullingSubscription(Delegate<T> parent, Subscriber<? super T> child) {
+            parent.actual = child;
+            this.parent = parent;
+        }
+
+        @Override public void unsubscribe() {
+            if (UNSUBSCRIBED_UPDATER.compareAndSet(this, 0, 1)) {
+                Log.v("NullingSubscriber", "unsubscribed");
+                parent.actual.unsubscribe();
+                parent.actual = null;
+            }
+        }
+
+        @Override public boolean isUnsubscribed() {
+            return unsubscribed != 0;
+        }
+    }
+
+    private static final class Delegate<T> extends Subscriber<T> {
+        private volatile Subscriber<? super T> actual;
+
+        @Override public void onNext(T t) {
+            final Subscriber<? super T> actual = this.actual;
+            if (actual != null) {
+                actual.onNext(t);
+            }
+        }
+
+        @Override public void onError(Throwable e) {
+            final Subscriber<? super T> actual = this.actual;
+            if (actual != null) {
+                actual.onError(e);
+            }
+        }
+
+        @Override public void onCompleted() {
+            final Subscriber<? super T> actual = this.actual;
+            if (actual != null) {
+                actual.onCompleted();
+            }
+        }
+
+        @Override public void setProducer(Producer producer) {
+            Subscriber<? super T> actual = this.actual;
+            if (actual != null) {
+                actual.setProducer(producer);
+            }
+        }
+
+        @Override public void onStart() {
+            Subscriber<? super T> actual = this.actual;
+            if (actual != null) {
+                actual.onStart();
+            }
+        }
+    }
+}
diff --git a/sample-app/src/main/java/rx/android/samples/MainActivity.java b/sample-app/src/main/java/rx/android/samples/MainActivity.java
index 107ec661..9138c763 100644
--- a/sample-app/src/main/java/rx/android/samples/MainActivity.java
+++ b/sample-app/src/main/java/rx/android/samples/MainActivity.java
@@ -1,22 +1,23 @@
 package rx.android.samples;
 
-import android.app.Activity;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.util.Log;
 import android.view.View;
+
 import java.util.concurrent.TimeUnit;
+
 import rx.Observable;
 import rx.Subscriber;
-import rx.android.schedulers.AndroidSchedulers;
+import rx.android.lifecycle.LifecycleEvent;
 import rx.android.schedulers.HandlerScheduler;
 import rx.exceptions.OnErrorThrowable;
 import rx.functions.Func0;
 
 import static android.os.Process.THREAD_PRIORITY_BACKGROUND;
 
-public class MainActivity extends Activity {
+public class MainActivity extends RxActivity {
     private static final String TAG = "RxAndroidSamples";
 
     private Handler backgroundHandler;
@@ -38,11 +39,12 @@
     }
 
     void onRunSchedulerExampleButtonClicked() {
-        sampleObservable()
-                // Run on a background thread
+        subscriptions().with(sampleObservable())
                 .subscribeOn(HandlerScheduler.from(backgroundHandler))
+                // Observe until Stop
+                .observeUntil(LifecycleEvent.STOP)
                 // Be notified on the main thread
-                .observeOn(AndroidSchedulers.mainThread())
+                .observeOnMainThread()
                 .subscribe(new Subscriber<String>() {
                     @Override public void onCompleted() {
                         Log.d(TAG, "onCompleted()");
diff --git a/sample-app/src/main/java/rx/android/samples/RxActivity.java b/sample-app/src/main/java/rx/android/samples/RxActivity.java
new file mode 100644
index 00000000..6d4a4d82
--- /dev/null
+++ b/sample-app/src/main/java/rx/android/samples/RxActivity.java
@@ -0,0 +1,86 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * <p/>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p/>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.android.samples;
+
+import android.os.Bundle;
+
+import rx.Observable;
+import rx.android.lifecycle.LifecycleEvent;
+import rx.android.lifecycle.LifecycleProducer;
+import rx.android.lifecycle.LifecycleSubscriptions;
+
+/**
+ * An Activity with reactive extensions.
+ */
+public class RxActivity extends android.app.Activity {
+
+    private final LifecycleProducer producer = LifecycleProducer.create();
+    private final LifecycleSubscriptions subscriptions;
+
+    public RxActivity() {
+        this.subscriptions = createSubscriptions();
+        if (!subscriptions.setProducer(producer)) {
+            throw new IllegalStateException("subclass must not set producer");
+        }
+    }
+
+    protected LifecycleSubscriptions createSubscriptions() {
+        return LifecycleSubscriptions.observeActivity();
+    }
+
+    public LifecycleSubscriptions subscriptions() {
+        return subscriptions;
+    }
+
+    public Observable<LifecycleEvent> lifecycle() {
+        return producer.asObservable();
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        producer.onCreate();
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+        producer.onStart();
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        producer.onResume();
+    }
+
+    @Override
+    protected void onPause() {
+        producer.onPause();
+        super.onPause();
+    }
+
+    @Override
+    protected void onStop() {
+        producer.onStop();
+        super.onStop();
+    }
+
+    @Override
+    protected void onDestroy() {
+        producer.onDestroy();
+        super.onDestroy();
+    }
+}
