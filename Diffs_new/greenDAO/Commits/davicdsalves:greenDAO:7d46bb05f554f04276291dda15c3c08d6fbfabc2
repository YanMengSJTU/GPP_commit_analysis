diff --git a/DaoCore/gradle/wrapper/gradle-wrapper.jar b/DaoCore/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 00000000..3a99f7a9
Binary files /dev/null and b/DaoCore/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/DaoCore/gradle/wrapper/gradle-wrapper.properties b/DaoCore/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 00000000..025a6857
--- /dev/null
+++ b/DaoCore/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Thu Oct 03 04:33:01 CEST 2013
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-rc-1-bin.zip
diff --git a/DaoCore/gradlew b/DaoCore/gradlew
new file mode 100644
index 00000000..91a7e269
--- /dev/null
+++ b/DaoCore/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/DaoCore/gradlew.bat b/DaoCore/gradlew.bat
new file mode 100644
index 00000000..8a0b282a
--- /dev/null
+++ b/DaoCore/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/DaoCore/greendao.iml b/DaoCore/greendao.iml
new file mode 100644
index 00000000..3494e1b4
--- /dev/null
+++ b/DaoCore/greendao.iml
@@ -0,0 +1,55 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" type="JAVA_MODULE" version="4">
+  <component name="FacetManager">
+    <facet type="android" name="Android">
+      <configuration>
+        <option name="LIBRARY_PROJECT" value="true" />
+        <option name="UPDATE_PROPERTY_FILES" value="true" />
+      </configuration>
+    </facet>
+  </component>
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/test/resources" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/test/java" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" generated="true" />
+      <excludeFolder url="file://$MODULE_DIR$/.gradle" />
+      <excludeFolder url="file://$MODULE_DIR$/build" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="library" name="libs" level="project" />
+    <orderEntry type="module-library" scope="PROVIDED">
+      <library>
+        <CLASSES>
+          <root url="jar://$MODULE_DIR$/libs/sqlcipher.jar!/" />
+        </CLASSES>
+        <JAVADOC />
+        <SOURCES />
+      </library>
+    </orderEntry>
+    <orderEntry type="module-library" scope="PROVIDED">
+      <library>
+        <CLASSES>
+          <root url="jar://$MODULE_DIR$/libs/guava-r09.jar!/" />
+        </CLASSES>
+        <JAVADOC />
+        <SOURCES />
+      </library>
+    </orderEntry>
+    <orderEntry type="module-library" scope="PROVIDED">
+      <library>
+        <CLASSES>
+          <root url="jar://$MODULE_DIR$/libs/commons-codec.jar!/" />
+        </CLASSES>
+        <JAVADOC />
+        <SOURCES />
+      </library>
+    </orderEntry>
+  </component>
+</module>
+
diff --git a/DaoCore/project.properties b/DaoCore/project.properties
index 96db7421..0e58ae1c 100644
--- a/DaoCore/project.properties
+++ b/DaoCore/project.properties
@@ -9,4 +9,4 @@
 
 android.library=true
 # Project target.
-target=android-4
+target=android-17
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDao.java b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
index 042d4c3e..eada2c10 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDao.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
@@ -16,17 +16,19 @@
 
 package de.greenrobot.dao;
 
+import android.database.CrossProcessCursor;
+import android.database.Cursor;
+import android.database.CursorWindow;
+
+import net.sqlcipher.DatabaseUtils;
+import net.sqlcipher.database.SQLiteDatabase;
+import net.sqlcipher.database.SQLiteStatement;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
 
-import android.database.CrossProcessCursor;
-import android.database.Cursor;
-import android.database.CursorWindow;
-import android.database.DatabaseUtils;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
 import de.greenrobot.dao.identityscope.IdentityScope;
 import de.greenrobot.dao.identityscope.IdentityScopeLong;
 import de.greenrobot.dao.internal.DaoConfig;
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDaoMaster.java b/DaoCore/src/de/greenrobot/dao/AbstractDaoMaster.java
index 5b635bcd..7b14c4d6 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDaoMaster.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDaoMaster.java
@@ -16,10 +16,11 @@
 
 package de.greenrobot.dao;
 
+import net.sqlcipher.database.SQLiteDatabase;
+
 import java.util.HashMap;
 import java.util.Map;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.identityscope.IdentityScopeType;
 import de.greenrobot.dao.internal.DaoConfig;
 
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java b/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
index 6a37ef2a..689251c5 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
@@ -15,12 +15,13 @@
  */
 package de.greenrobot.dao;
 
+import net.sqlcipher.database.SQLiteDatabase;
+
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.Callable;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.async.AsyncSession;
 import de.greenrobot.dao.query.QueryBuilder;
 
diff --git a/DaoCore/src/de/greenrobot/dao/DaoException.java b/DaoCore/src/de/greenrobot/dao/DaoException.java
index 0b3acac6..55868952 100644
--- a/DaoCore/src/de/greenrobot/dao/DaoException.java
+++ b/DaoCore/src/de/greenrobot/dao/DaoException.java
@@ -15,7 +15,7 @@
  */
 package de.greenrobot.dao;
 
-import android.database.SQLException;
+import net.sqlcipher.SQLException;
 
 /**
  * Exception thrown when something goes wrong in the DAO/ORM layer.
diff --git a/DaoCore/src/de/greenrobot/dao/DbUtils.java b/DaoCore/src/de/greenrobot/dao/DbUtils.java
index 62e5c976..0d12b3e1 100644
--- a/DaoCore/src/de/greenrobot/dao/DbUtils.java
+++ b/DaoCore/src/de/greenrobot/dao/DbUtils.java
@@ -16,16 +16,17 @@
 
 package de.greenrobot.dao;
 
+import android.content.Context;
+import android.database.Cursor;
+
+import net.sqlcipher.DatabaseUtils;
+import net.sqlcipher.database.SQLiteDatabase;
+
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 
-import android.content.Context;
-import android.database.Cursor;
-import android.database.DatabaseUtils;
-import android.database.sqlite.SQLiteDatabase;
-
 /** Database utils, for example to execute SQL scripts */
 // TODO add unit tests
 public class DbUtils {
diff --git a/DaoCore/src/de/greenrobot/dao/InternalQueryDaoAccess.java b/DaoCore/src/de/greenrobot/dao/InternalQueryDaoAccess.java
index d1896079..f6a1c590 100644
--- a/DaoCore/src/de/greenrobot/dao/InternalQueryDaoAccess.java
+++ b/DaoCore/src/de/greenrobot/dao/InternalQueryDaoAccess.java
@@ -1,8 +1,9 @@
 package de.greenrobot.dao;
 
+import android.database.Cursor;
+
 import java.util.List;
 
-import android.database.Cursor;
 import de.greenrobot.dao.internal.TableStatements;
 
 /** For internal use by greenDAO only. */
diff --git a/DaoCore/src/de/greenrobot/dao/InternalUnitTestDaoAccess.java b/DaoCore/src/de/greenrobot/dao/InternalUnitTestDaoAccess.java
index 78df9030..1305bf58 100644
--- a/DaoCore/src/de/greenrobot/dao/InternalUnitTestDaoAccess.java
+++ b/DaoCore/src/de/greenrobot/dao/InternalUnitTestDaoAccess.java
@@ -16,10 +16,13 @@
 
 package de.greenrobot.dao;
 
-import java.lang.reflect.Constructor;
 
 import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
+
+import net.sqlcipher.database.SQLiteDatabase;
+
+import java.lang.reflect.Constructor;
+
 import de.greenrobot.dao.identityscope.IdentityScope;
 import de.greenrobot.dao.internal.DaoConfig;
 
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncOperation.java b/DaoCore/src/de/greenrobot/dao/async/AsyncOperation.java
index 7f1b1c02..5821a4e6 100644
--- a/DaoCore/src/de/greenrobot/dao/async/AsyncOperation.java
+++ b/DaoCore/src/de/greenrobot/dao/async/AsyncOperation.java
@@ -16,7 +16,8 @@
 
 package de.greenrobot.dao.async;
 
-import android.database.sqlite.SQLiteDatabase;
+import net.sqlcipher.database.SQLiteDatabase;
+
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoException;
 
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java b/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java
index b63ec1b4..e5601d25 100644
--- a/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java
+++ b/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java
@@ -15,6 +15,12 @@
  */
 package de.greenrobot.dao.async;
 
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+
+import net.sqlcipher.database.SQLiteDatabase;
+
 import java.util.ArrayList;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.Callable;
@@ -23,10 +29,6 @@
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
 
-import android.database.sqlite.SQLiteDatabase;
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
 import de.greenrobot.dao.DaoException;
 import de.greenrobot.dao.DaoLog;
 import de.greenrobot.dao.query.Query;
diff --git a/DaoCore/src/de/greenrobot/dao/internal/DaoConfig.java b/DaoCore/src/de/greenrobot/dao/internal/DaoConfig.java
index 96473029..3d042c64 100644
--- a/DaoCore/src/de/greenrobot/dao/internal/DaoConfig.java
+++ b/DaoCore/src/de/greenrobot/dao/internal/DaoConfig.java
@@ -15,12 +15,13 @@
  */
 package de.greenrobot.dao.internal;
 
+import net.sqlcipher.database.SQLiteDatabase;
+
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.List;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoException;
 import de.greenrobot.dao.Property;
diff --git a/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java b/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java
index 9414f1f7..3ca5029b 100644
--- a/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java
+++ b/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java
@@ -15,8 +15,8 @@
  */
 package de.greenrobot.dao.internal;
 
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
+import net.sqlcipher.database.SQLiteDatabase;
+import net.sqlcipher.database.SQLiteStatement;
 
 /** Helper class to create SQL statements for specific tables (used by greenDAO internally). */
 public class TableStatements {
diff --git a/DaoCore/src/de/greenrobot/dao/query/CountQuery.java b/DaoCore/src/de/greenrobot/dao/query/CountQuery.java
index ece51d72..4e2975c8 100644
--- a/DaoCore/src/de/greenrobot/dao/query/CountQuery.java
+++ b/DaoCore/src/de/greenrobot/dao/query/CountQuery.java
@@ -1,6 +1,7 @@
 package de.greenrobot.dao.query;
 
 import android.database.Cursor;
+
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoException;
 
diff --git a/DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java b/DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java
index 66dbe312..296a4af3 100644
--- a/DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java
+++ b/DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java
@@ -15,8 +15,9 @@
  */
 package de.greenrobot.dao.query;
 
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
+import net.sqlcipher.database.SQLiteDatabase;
+import net.sqlcipher.database.SQLiteStatement;
+
 import de.greenrobot.dao.AbstractDao;
 
 /**
diff --git a/DaoCore/src/de/greenrobot/dao/query/LazyList.java b/DaoCore/src/de/greenrobot/dao/query/LazyList.java
index 9bf12337..9a476c9d 100644
--- a/DaoCore/src/de/greenrobot/dao/query/LazyList.java
+++ b/DaoCore/src/de/greenrobot/dao/query/LazyList.java
@@ -15,6 +15,8 @@
  */
 package de.greenrobot.dao.query;
 
+import android.database.Cursor;
+
 import java.io.Closeable;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -24,7 +26,6 @@
 import java.util.NoSuchElementException;
 import java.util.concurrent.locks.ReentrantLock;
 
-import android.database.Cursor;
 import de.greenrobot.dao.DaoException;
 import de.greenrobot.dao.InternalQueryDaoAccess;
 
diff --git a/DaoCore/src/de/greenrobot/dao/query/Query.java b/DaoCore/src/de/greenrobot/dao/query/Query.java
index 15abe639..d555de5b 100644
--- a/DaoCore/src/de/greenrobot/dao/query/Query.java
+++ b/DaoCore/src/de/greenrobot/dao/query/Query.java
@@ -15,9 +15,10 @@
  */
 package de.greenrobot.dao.query;
 
+import android.database.Cursor;
+
 import java.util.List;
 
-import android.database.Cursor;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoException;
 
diff --git a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoSessionTest.java b/DaoCore/src/de/greenrobot/dao/test/AbstractDaoSessionTest.java
deleted file mode 100644
index 941f32ff..00000000
--- a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoSessionTest.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package de.greenrobot.dao.test;
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Method;
-
-import android.app.Application;
-import android.database.sqlite.SQLiteDatabase;
-import de.greenrobot.dao.AbstractDaoMaster;
-import de.greenrobot.dao.AbstractDaoSession;
-
-/**
- * Base class for DAO (master) related testing.
- * 
- * @author Markus
- * 
- * @param <T>
- *            Type of a concrete DAO master
- */
-public abstract class AbstractDaoSessionTest<A extends Application, T extends AbstractDaoMaster, S extends AbstractDaoSession>
-        extends DbTest<A> {
-
-    private final Class<T> daoMasterClass;
-    protected T daoMaster;
-    protected S daoSession;
-
-    public AbstractDaoSessionTest(Class<T> daoMasterClass) {
-        this(daoMasterClass, true);
-    }
-
-    public AbstractDaoSessionTest(Class<T> daoMasterClass, boolean inMemory) {
-        super(inMemory);
-        this.daoMasterClass = daoMasterClass;
-    }
-
-    public AbstractDaoSessionTest(Class<A> appClass, Class<T> daoMasterClass, boolean inMemory) {
-        super(appClass, inMemory);
-        this.daoMasterClass = daoMasterClass;
-    }
-
-    @SuppressWarnings("unchecked")
-    @Override
-    protected void setUp() {
-        super.setUp();
-        try {
-            Constructor<T> constructor = daoMasterClass.getConstructor(SQLiteDatabase.class);
-            daoMaster = constructor.newInstance(db);
-
-            Method createTableMethod = daoMasterClass.getMethod("createAllTables", SQLiteDatabase.class, boolean.class);
-            createTableMethod.invoke(null, db, false);
-        } catch (Exception e) {
-            throw new RuntimeException("Could not prepare DAO session test", e);
-        }
-        daoSession = (S) daoMaster.newSession();
-    }
-
-}
\ No newline at end of file
diff --git a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTest.java b/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTest.java
deleted file mode 100644
index ee8194e1..00000000
--- a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTest.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package de.greenrobot.dao.test;
-
-import java.lang.reflect.Method;
-
-import android.app.Application;
-import android.database.sqlite.SQLiteDatabase;
-import de.greenrobot.dao.AbstractDao;
-import de.greenrobot.dao.DaoLog;
-import de.greenrobot.dao.InternalUnitTestDaoAccess;
-import de.greenrobot.dao.Property;
-import de.greenrobot.dao.identityscope.IdentityScope;
-
-/**
- * Base class for DAO related testing. Prepares an in-memory DB and DAO.
- * 
- * @author Markus
- * 
- * @param <D>
- *            DAO class
- * @param <T>
- *            Entity type of the DAO
- * @param <K>
- *            Key type of the DAO
- */
-public abstract class AbstractDaoTest<D extends AbstractDao<T, K>, T, K> extends DbTest<Application> {
-
-    protected final Class<D> daoClass;
-    protected D dao;
-    protected InternalUnitTestDaoAccess<T, K> daoAccess;
-    protected Property pkColumn;
-    protected IdentityScope<K, T> identityScopeForDao;
-
-    public AbstractDaoTest(Class<D> daoClass) {
-        this(daoClass, true);
-    }
-
-    public AbstractDaoTest(Class<D> daoClass, boolean inMemory) {
-        super(inMemory);
-        this.daoClass = daoClass;
-    }
-
-    public void setIdentityScopeBeforeSetUp(IdentityScope<K, T> identityScope) {
-        this.identityScopeForDao = identityScope;
-    }
-
-    @SuppressWarnings("unchecked")
-    @Override
-    protected void setUp() {
-        super.setUp();
-        try {
-            setUpTableForDao();
-            daoAccess = new InternalUnitTestDaoAccess<T, K>(db, (Class<AbstractDao<T, K>>) daoClass, identityScopeForDao);
-            dao = (D) daoAccess.getDao();
-        } catch (Exception e) {
-            throw new RuntimeException("Could not prepare DAO Test", e);
-        }
-    }
-
-    protected void setUpTableForDao() throws Exception {
-        try {
-            Method createTableMethod = daoClass.getMethod("createTable", SQLiteDatabase.class, boolean.class);
-            createTableMethod.invoke(null, db, false);
-        } catch (NoSuchMethodException e) {
-            DaoLog.i("No createTable method");
-        }
-    }
-
-    protected void clearIdentityScopeIfAny() {
-        if (identityScopeForDao != null) {
-            identityScopeForDao.clear();
-            DaoLog.d("Identity scope cleared");
-        } else {
-            DaoLog.d("No identity scope to clear");
-        }
-    }
-
-    protected void logTableDump() {
-        logTableDump(dao.getTablename());
-    }
-}
\ No newline at end of file
diff --git a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestLongPk.java b/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestLongPk.java
deleted file mode 100644
index 6be8b3d5..00000000
--- a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestLongPk.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package de.greenrobot.dao.test;
-
-import de.greenrobot.dao.AbstractDao;
-import de.greenrobot.dao.DaoLog;
-
-/**
- * Base class for DAOs having a long/Long as a PK, which is quite common.
- * 
- * @author Markus
- * 
- * @param <D>
- *            DAO class
- * @param <T>
- *            Entity type of the DAO
- */
-public abstract class AbstractDaoTestLongPk<D extends AbstractDao<T, Long>, T> extends AbstractDaoTestSinglePk<D, T, Long> {
-
-    public AbstractDaoTestLongPk(Class<D> daoClass) {
-        super(daoClass);
-    }
-
-    /** {@inheritDoc} */
-    protected Long createRandomPk() {
-        return random.nextLong();
-    }
-    
-    public void testAssignPk() {
-        if (daoAccess.isEntityUpdateable()) {
-            T entity1 = createEntity(null);
-            if (entity1 != null) {
-                T entity2 = createEntity(null);
-
-                dao.insert(entity1);
-                dao.insert(entity2);
-
-                Long pk1 = daoAccess.getKey(entity1);
-                assertNotNull(pk1);
-                Long pk2 = daoAccess.getKey(entity2);
-                assertNotNull(pk2);
-
-                assertFalse(pk1.equals(pk2));
-
-                assertNotNull(dao.load(pk1));
-                assertNotNull(dao.load(pk2));
-            } else {
-                DaoLog.d("Skipping testAssignPk for " + daoClass + " (createEntity returned null for null key)");
-            }
-        } else {
-            DaoLog.d("Skipping testAssignPk for not updateable " + daoClass);
-        }
-    }
-
-
-}
\ No newline at end of file
diff --git a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestSinglePk.java b/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestSinglePk.java
deleted file mode 100644
index f2c102a7..00000000
--- a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestSinglePk.java
+++ /dev/null
@@ -1,335 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package de.greenrobot.dao.test;
-
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-import android.database.Cursor;
-import android.database.DatabaseUtils;
-import android.database.SQLException;
-import de.greenrobot.dao.AbstractDao;
-import de.greenrobot.dao.Property;
-import de.greenrobot.dao.internal.SqlUtils;
-
-/**
- * Default tests for single-PK entities.
- * 
- * @author Markus
- * 
- * @param <D>
- *            DAO class
- * @param <T>
- *            Entity type of the DAO
- * @param <K>
- *            Key type of the DAO
- */
-public abstract class AbstractDaoTestSinglePk<D extends AbstractDao<T, K>, T, K> extends AbstractDaoTest<D, T, K> {
-
-    protected Set<K> usedPks;
-    private Property pkColumn;
-
-    public AbstractDaoTestSinglePk(Class<D> daoClass) {
-        super(daoClass);
-        usedPks = new HashSet<K>();
-    }
-
-    @Override
-    protected void setUp() {
-        super.setUp();
-        Property[] columns = daoAccess.getProperties();
-        for (Property column : columns) {
-            if (column.primaryKey) {
-                if (pkColumn != null) {
-                    throw new RuntimeException("Test does not work with multiple PK columns");
-                }
-                pkColumn = column;
-            }
-        }
-        if (pkColumn == null) {
-            throw new RuntimeException("Test does not work without a PK column");
-        }
-    }
-
-    public void testInsertAndLoad() {
-        K pk = nextPk();
-        T entity = createEntity(pk);
-        dao.insert(entity);
-        assertEquals(pk, daoAccess.getKey(entity));
-        T entity2 = dao.load(pk);
-        assertNotNull(entity2);
-        assertEquals(daoAccess.getKey(entity), daoAccess.getKey(entity2));
-    }
-
-    public void testInsertInTx() {
-        dao.deleteAll();
-        List<T> list = new ArrayList<T>();
-        for (int i = 0; i < 20; i++) {
-            list.add(createEntityWithRandomPk());
-        }
-        dao.insertInTx(list);
-        assertEquals(list.size(), dao.count());
-    }
-
-    public void testCount() {
-        dao.deleteAll();
-        assertEquals(0, dao.count());
-        dao.insert(createEntityWithRandomPk());
-        assertEquals(1, dao.count());
-        dao.insert(createEntityWithRandomPk());
-        assertEquals(2, dao.count());
-    }
-
-    public void testInsertTwice() {
-        K pk = nextPk();
-        T entity = createEntity(pk);
-        dao.insert(entity);
-        try {
-            dao.insert(entity);
-            fail("Inserting twice should not work");
-        } catch (SQLException expected) {
-            // OK
-        }
-    }
-
-    public void testInsertOrReplaceTwice() {
-        T entity = createEntityWithRandomPk();
-        long rowId1 = dao.insert(entity);
-        long rowId2 = dao.insertOrReplace(entity);
-        if (dao.getPkProperty().type == Long.class) {
-            assertEquals(rowId1, rowId2);
-        }
-    }
-
-    public void testInsertOrReplaceInTx() {
-        dao.deleteAll();
-        List<T> listPartial = new ArrayList<T>();
-        List<T> listAll = new ArrayList<T>();
-        for (int i = 0; i < 20; i++) {
-            T entity = createEntityWithRandomPk();
-            if (i % 2 == 0) {
-                listPartial.add(entity);
-            }
-            listAll.add(entity);
-        }
-        dao.insertOrReplaceInTx(listPartial);
-        dao.insertOrReplaceInTx(listAll);
-        assertEquals(listAll.size(), dao.count());
-    }
-
-    public void testDelete() {
-        K pk = nextPk();
-        dao.deleteByKey(pk);
-        T entity = createEntity(pk);
-        dao.insert(entity);
-        assertNotNull(dao.load(pk));
-        dao.deleteByKey(pk);
-        assertNull(dao.load(pk));
-    }
-
-    public void testDeleteAll() {
-        List<T> entityList = new ArrayList<T>();
-        for (int i = 0; i < 10; i++) {
-            T entity = createEntityWithRandomPk();
-            entityList.add(entity);
-        }
-        dao.insertInTx(entityList);
-        dao.deleteAll();
-        assertEquals(0, dao.count());
-        for (T entity : entityList) {
-            K key = daoAccess.getKey(entity);
-            assertNotNull(key);
-            assertNull(dao.load(key));
-        }
-    }
-
-    public void testDeleteInTx() {
-        List<T> entityList = new ArrayList<T>();
-        for (int i = 0; i < 10; i++) {
-            T entity = createEntityWithRandomPk();
-            entityList.add(entity);
-        }
-        dao.insertInTx(entityList);
-        List<T> entitiesToDelete = new ArrayList<T>();
-        entitiesToDelete.add(entityList.get(0));
-        entitiesToDelete.add(entityList.get(3));
-        entitiesToDelete.add(entityList.get(4));
-        entitiesToDelete.add(entityList.get(8));
-        dao.deleteInTx(entitiesToDelete);
-        assertEquals(entityList.size() - entitiesToDelete.size(), dao.count());
-        for (T deletedEntity : entitiesToDelete) {
-            K key = daoAccess.getKey(deletedEntity);
-            assertNotNull(key);
-            assertNull(dao.load(key));
-        }
-    }
-
-    public void testDeleteByKeyInTx() {
-        List<T> entityList = new ArrayList<T>();
-        for (int i = 0; i < 10; i++) {
-            T entity = createEntityWithRandomPk();
-            entityList.add(entity);
-        }
-        dao.insertInTx(entityList);
-        List<K> keysToDelete = new ArrayList<K>();
-        keysToDelete.add(daoAccess.getKey(entityList.get(0)));
-        keysToDelete.add(daoAccess.getKey(entityList.get(3)));
-        keysToDelete.add(daoAccess.getKey(entityList.get(4)));
-        keysToDelete.add(daoAccess.getKey(entityList.get(8)));
-        dao.deleteByKeyInTx(keysToDelete);
-        assertEquals(entityList.size() - keysToDelete.size(), dao.count());
-        for (K key : keysToDelete) {
-            assertNotNull(key);
-            assertNull(dao.load(key));
-        }
-    }
-
-    public void testRowId() {
-        T entity1 = createEntityWithRandomPk();
-        T entity2 = createEntityWithRandomPk();
-        long rowId1 = dao.insert(entity1);
-        long rowId2 = dao.insert(entity2);
-        assertTrue(rowId1 != rowId2);
-    }
-
-    public void testLoadAll() {
-        dao.deleteAll();
-        List<T> list = new ArrayList<T>();
-        for (int i = 0; i < 15; i++) {
-            T entity = createEntity(nextPk());
-            list.add(entity);
-        }
-        dao.insertInTx(list);
-        List<T> loaded = dao.loadAll();
-        assertEquals(list.size(), loaded.size());
-    }
-
-    public void testQuery() {
-        dao.insert(createEntityWithRandomPk());
-        K pkForQuery = nextPk();
-        dao.insert(createEntity(pkForQuery));
-        dao.insert(createEntityWithRandomPk());
-
-        String where = "WHERE " + dao.getPkColumns()[0] + "=?";
-        List<T> list = dao.queryRaw(where, pkForQuery.toString());
-        assertEquals(1, list.size());
-        assertEquals(pkForQuery, daoAccess.getKey(list.get(0)));
-    }
-
-    public void testUpdate() {
-        dao.deleteAll();
-        T entity = createEntityWithRandomPk();
-        dao.insert(entity);
-        dao.update(entity);
-        assertEquals(1, dao.count());
-    }
-
-    public void testReadWithOffset() {
-        K pk = nextPk();
-        T entity = createEntity(pk);
-        dao.insert(entity);
-
-        Cursor cursor = queryWithDummyColumnsInFront(5, "42", pk);
-        try {
-            T entity2 = daoAccess.readEntity(cursor, 5);
-            assertEquals(pk, daoAccess.getKey(entity2));
-        } finally {
-            cursor.close();
-        }
-    }
-
-    public void testLoadPkWithOffset() {
-        runLoadPkTest(10);
-    }
-
-    public void testLoadPk() {
-        runLoadPkTest(0);
-    }
-
-    protected void runLoadPkTest(int offset) {
-        K pk = nextPk();
-        T entity = createEntity(pk);
-        dao.insert(entity);
-
-        Cursor cursor = queryWithDummyColumnsInFront(offset, "42", pk);
-        try {
-            K pk2 = daoAccess.readKey(cursor, offset);
-            assertEquals(pk, pk2);
-        } finally {
-            cursor.close();
-        }
-    }
-
-    protected Cursor queryWithDummyColumnsInFront(int dummyCount, String valueForColumn, K pk) {
-        StringBuilder builder = new StringBuilder("SELECT ");
-        for (int i = 0; i < dummyCount; i++) {
-            builder.append(valueForColumn).append(",");
-        }
-        SqlUtils.appendColumns(builder, "T", dao.getAllColumns()).append(" FROM ");
-        builder.append(dao.getTablename()).append(" T");
-        if (pk != null) {
-            builder.append(" WHERE ");
-
-            assertEquals(1, dao.getPkColumns().length);
-            builder.append(dao.getPkColumns()[0]).append("=");
-            DatabaseUtils.appendValueToSql(builder, pk);
-        }
-
-        String select = builder.toString();
-        Cursor cursor = db.rawQuery(select, null);
-        assertTrue(cursor.moveToFirst());
-        try {
-            for (int i = 0; i < dummyCount; i++) {
-                assertEquals(valueForColumn, cursor.getString(i));
-            }
-            if (pk != null) {
-                assertEquals(1, cursor.getCount());
-            }
-        } catch (RuntimeException ex) {
-            cursor.close();
-            throw ex;
-        }
-        return cursor;
-    }
-
-    /** Provides a collision free PK () not returned before in the current test. */
-    protected K nextPk() {
-        for (int i = 0; i < 100000; i++) {
-            K pk = createRandomPk();
-            if (usedPks.add(pk)) {
-                return pk;
-            }
-        }
-        throw new IllegalStateException("Could not find a new PK");
-    }
-
-    protected T createEntityWithRandomPk() {
-        return createEntity(nextPk());
-    }
-
-    /** K does not have to be collision free, check nextPk for collision free PKs. */
-    protected abstract K createRandomPk();
-
-    /**
-     * Creates an insertable entity. If the given key is null, but the entity's PK is not null the method must return
-     * null.
-     */
-    protected abstract T createEntity(K key);
-
-}
\ No newline at end of file
diff --git a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestStringPk.java b/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestStringPk.java
deleted file mode 100644
index e0c6ddff..00000000
--- a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTestStringPk.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.dao.test;
-
-import de.greenrobot.dao.AbstractDao;
-
-/**
- * Base class for DAOs having a String as a PK.
- * 
- * @author Markus
- * 
- * @param <D>
- *            DAO class
- * @param <T>
- *            Entity type of the DAO
- */
-public abstract class AbstractDaoTestStringPk<D extends AbstractDao<T, String>, T> extends
-        AbstractDaoTestSinglePk<D, T, String> {
-
-    public AbstractDaoTestStringPk(Class<D> daoClass) {
-        super(daoClass);
-    }
-
-    @Override
-    protected String createRandomPk() {
-        int len = 1 + random.nextInt(30);
-        StringBuilder builder = new StringBuilder();
-        for (int i = 0; i < len; i++) {
-            char c = (char) ('a' + random.nextInt('z' - 'a'));
-            builder.append(c);
-        }
-        return builder.toString();
-    }
-
-}
diff --git a/DaoCore/src/de/greenrobot/dao/test/DbTest.java b/DaoCore/src/de/greenrobot/dao/test/DbTest.java
deleted file mode 100644
index ee3a29df..00000000
--- a/DaoCore/src/de/greenrobot/dao/test/DbTest.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package de.greenrobot.dao.test;
-
-import java.util.Random;
-
-import android.app.Application;
-import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
-import android.test.ApplicationTestCase;
-import de.greenrobot.dao.DbUtils;
-
-/**
- * Base class for database related testing. Prepares an in-memory or an file-based DB.
- * 
- * @author Markus
- * 
- */
-public abstract class DbTest<T extends Application> extends ApplicationTestCase<T> {
-
-    protected SQLiteDatabase db;
-    protected Random random;
-    protected final boolean inMemory;
-    private boolean dontCreateApp;
-
-    public DbTest() {
-        this(true);
-    }
-
-    @SuppressWarnings("unchecked")
-    public DbTest(boolean inMemory) {
-        this((Class<T>) Application.class, inMemory);
-    }
-
-    public DbTest(Class<T> appClass, boolean inMemory) {
-        super(appClass);
-        this.inMemory = inMemory;
-        random = new Random();
-    }
-
-    protected void dontCreateApplicationDuringSetUp() {
-        dontCreateApp = true;
-    }
-
-    @Override
-    protected void setUp() {
-        try {
-            super.setUp();
-        } catch (Exception e) {
-            throw new RuntimeException(e);
-        }
-        if (!dontCreateApp) {
-            createApplication();
-        }
-        setUpDb();
-    }
-
-    /** Override if you create your own DB */
-    protected void setUpDb() {
-        if (inMemory) {
-            db = SQLiteDatabase.create(null);
-        } else {
-            getApplication().deleteDatabase("test-db");
-            db = getApplication().openOrCreateDatabase("test-db", Context.MODE_PRIVATE, null);
-        }
-    }
-
-    @Override
-    protected void tearDown() throws Exception {
-        db.close();
-        if (!inMemory) {
-            getApplication().deleteDatabase("test-db");
-        }
-        super.tearDown();
-    }
-
-    protected void logTableDump(String tablename) {
-        DbUtils.logTableDump(db, tablename);
-    }
-
-}
\ No newline at end of file
