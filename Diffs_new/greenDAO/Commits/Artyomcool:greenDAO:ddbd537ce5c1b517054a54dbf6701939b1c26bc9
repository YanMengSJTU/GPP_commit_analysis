diff --git a/greendao/src/main/java/de/greenrobot/dao/AbstractDao.java b/greendao/src/main/java/de/greenrobot/dao/AbstractDao.java
index b3b8cd1b..90bacc0e 100644
--- a/greendao/src/main/java/de/greenrobot/dao/AbstractDao.java
+++ b/greendao/src/main/java/de/greenrobot/dao/AbstractDao.java
@@ -188,21 +188,37 @@ public T loadByRowId(long rowId) {
     }
 
     protected T loadUniqueAndCloseCursor(Cursor cursor) {
+        return loadUniqueAndCloseCursor(cursor, false);
+    }
+
+    protected T loadUniqueDeepAndCloseCursor(Cursor cursor) {
+        return loadUniqueAndCloseCursor(cursor, true);
+    }
+
+    protected T loadUniqueAndCloseCursor(Cursor cursor, boolean deep) {
         try {
-            return loadUnique(cursor);
+            return loadUnique(cursor, deep);
         } finally {
             cursor.close();
         }
     }
 
     protected T loadUnique(Cursor cursor) {
+        return loadUnique(cursor, false);
+    }
+
+    protected T loadUniqueDeep(Cursor cursor) {
+        return loadUnique(cursor, true);
+    }
+
+    protected T loadUnique(Cursor cursor, boolean deep) {
         boolean available = cursor.moveToFirst();
         if (!available) {
             return null;
         } else if (!cursor.isLast()) {
             throw new DaoException("Expected unique result, but count was " + cursor.getCount());
         }
-        return loadCurrent(cursor, 0, true);
+        return deep ? loadCurrentDeep(cursor, true) : loadCurrent(cursor, 0, true);
     }
 
     /** Loads all available entities from the database. */
@@ -846,4 +862,15 @@ public SQLiteDatabase getDatabase() {
     /** Returns true if the Entity class can be updated, e.g. for setting the PK after insert. */
     abstract protected boolean isEntityUpdateable();
 
+    protected String getSelectDeep() {
+        throw new UnsupportedOperationException("This DAO has no one-to-one relations");
+    }
+
+    public List<T> loadAllDeepFromCursor(Cursor cursor) {
+        throw new UnsupportedOperationException("This DAO has no one-to-one relations");
+    }
+
+    protected T loadCurrentDeep(Cursor cursor, boolean lock) {
+        throw new UnsupportedOperationException("This DAO has no one-to-one relations");
+    }
 }
diff --git a/greendao/src/main/java/de/greenrobot/dao/InternalQueryDaoAccess.java b/greendao/src/main/java/de/greenrobot/dao/InternalQueryDaoAccess.java
index d1896079..bf70cb7a 100644
--- a/greendao/src/main/java/de/greenrobot/dao/InternalQueryDaoAccess.java
+++ b/greendao/src/main/java/de/greenrobot/dao/InternalQueryDaoAccess.java
@@ -17,6 +17,10 @@ public T loadCurrent(Cursor cursor, int offset, boolean lock) {
         return dao.loadCurrent(cursor, offset, lock);
     }
 
+    public T loadCurrentDeep(Cursor cursor, boolean lock) {
+        return dao.loadCurrentDeep(cursor, lock);
+    }
+
     public List<T> loadAllAndCloseCursor(Cursor cursor) {
         return dao.loadAllAndCloseCursor(cursor);
     }
@@ -25,6 +29,10 @@ public T loadUniqueAndCloseCursor(Cursor cursor) {
         return dao.loadUniqueAndCloseCursor(cursor);
     }
 
+    public T loadUniqueDeepAndCloseCursor(Cursor cursor) {
+        return dao.loadUniqueDeepAndCloseCursor(cursor);
+    }
+
     public TableStatements getStatements() {
         return dao.getStatements();
     }
@@ -33,4 +41,7 @@ public TableStatements getStatements() {
         return dao.getStatements();
     }
 
+    public static String getSelectDeep(AbstractDao<?, ?> dao) {
+        return dao.getSelectDeep();
+    }
 }
\ No newline at end of file
diff --git a/greendao/src/main/java/de/greenrobot/dao/query/LazyList.java b/greendao/src/main/java/de/greenrobot/dao/query/LazyList.java
index 9bf12337..a6ea1ddd 100644
--- a/greendao/src/main/java/de/greenrobot/dao/query/LazyList.java
+++ b/greendao/src/main/java/de/greenrobot/dao/query/LazyList.java
@@ -123,15 +123,18 @@ public void close() {
     }
 
     private final InternalQueryDaoAccess<E> daoAccess;
+    private final boolean deep;
     private final Cursor cursor;
     private final List<E> entities;
     private final int size;
     private final ReentrantLock lock;
     private volatile int loadedCount;
 
-    LazyList(InternalQueryDaoAccess<E> daoAccess, Cursor cursor, boolean cacheEntities) {
+    LazyList(InternalQueryDaoAccess<E> daoAccess, Cursor cursor, boolean cacheEntities,
+             boolean deep) {
         this.cursor = cursor;
         this.daoAccess = daoAccess;
+        this.deep = deep;
         size = cursor.getCount();
         if (cacheEntities) {
             entities = new ArrayList<E>(size);
@@ -256,7 +259,8 @@ public E get(int location) {
 
     protected E loadEntity(int location) {
         cursor.moveToPosition(location);
-        E entity = daoAccess.loadCurrent(cursor, 0, true);
+        E entity = deep ? daoAccess.loadCurrentDeep(cursor, true)
+                : daoAccess.loadCurrent(cursor, 0, true);
         if (entity == null) {
             throw new DaoException("Loading of entity failed (null) at position " + location);
         }
diff --git a/greendao/src/main/java/de/greenrobot/dao/query/Query.java b/greendao/src/main/java/de/greenrobot/dao/query/Query.java
index 15abe639..2d5a7ca4 100644
--- a/greendao/src/main/java/de/greenrobot/dao/query/Query.java
+++ b/greendao/src/main/java/de/greenrobot/dao/query/Query.java
@@ -39,19 +39,21 @@
         private final String[] initialValues;
         private final int limitPosition;
         private final int offsetPosition;
+        private final boolean deep;
 
         private ThreadLocalQuery(AbstractDao<T2, ?> dao, String sql, String[] initialValues, int limitPosition,
-                int offsetPosition) {
+                                 int offsetPosition, boolean deep) {
             this.dao = dao;
             this.sql = sql;
             this.initialValues = initialValues;
             this.limitPosition = limitPosition;
             this.offsetPosition = offsetPosition;
+            this.deep = deep;
         }
 
         @Override
         protected Query<T2> initialValue() {
-            return new Query<T2>(this, dao, sql, initialValues.clone(), limitPosition, offsetPosition);
+            return new Query<T2>(this, dao, sql, initialValues.clone(), limitPosition, offsetPosition, deep);
         }
     }
 
@@ -63,20 +65,29 @@ private ThreadLocalQuery(AbstractDao<T2, ?> dao, String sql, String[] initialVal
     static <T2> Query<T2> create(AbstractDao<T2, ?> dao, String sql, Object[] initialValues, int limitPosition,
             int offsetPosition) {
         ThreadLocalQuery<T2> threadLocal = new ThreadLocalQuery<T2>(dao, sql, toStringArray(initialValues),
-                limitPosition, offsetPosition);
+                limitPosition, offsetPosition, false);
         return threadLocal.get();
     }
 
+    static <T> Query<T> createDeep(AbstractDao<T, ?> dao, String sql, Object[] initialValues, int limitPosition,
+            int offsetPosition) {
+        ThreadLocalQuery<T> threadLocal = new ThreadLocalQuery<T>(dao, sql, toStringArray(initialValues),
+                limitPosition, offsetPosition, true);
+        return threadLocal.get();
+    }
+
+    private final boolean deep;
     private final int limitPosition;
     private final int offsetPosition;
     private final ThreadLocalQuery<T> threadLocalQuery;
 
     private Query(ThreadLocalQuery<T> threadLocalQuery, AbstractDao<T, ?> dao, String sql, String[] initialValues,
-            int limitPosition, int offsetPosition) {
+            int limitPosition, int offsetPosition, boolean deep) {
         super(dao, sql, initialValues);
         this.threadLocalQuery = threadLocalQuery;
         this.limitPosition = limitPosition;
         this.offsetPosition = offsetPosition;
+        this.deep = deep;
     }
 
     // public void compile() {
@@ -128,6 +139,13 @@ public void setOffset(int offset) {
     public List<T> list() {
         checkThread();
         Cursor cursor = dao.getDatabase().rawQuery(sql, parameters);
+        if (deep) {
+            try {
+                return dao.loadAllDeepFromCursor(cursor);
+            } finally {
+                cursor.close();
+            }
+        }
         return daoAccess.loadAllAndCloseCursor(cursor);
     }
 
@@ -139,7 +157,7 @@ public void setOffset(int offset) {
     public LazyList<T> listLazy() {
         checkThread();
         Cursor cursor = dao.getDatabase().rawQuery(sql, parameters);
-        return new LazyList<T>(daoAccess, cursor, true);
+        return new LazyList<T>(daoAccess, cursor, true, deep);
     }
 
     /**
@@ -149,7 +167,7 @@ public void setOffset(int offset) {
     public LazyList<T> listLazyUncached() {
         checkThread();
         Cursor cursor = dao.getDatabase().rawQuery(sql, parameters);
-        return new LazyList<T>(daoAccess, cursor, false);
+        return new LazyList<T>(daoAccess, cursor, false, deep);
     }
 
     /**
@@ -170,7 +188,8 @@ public void setOffset(int offset) {
     public T unique() {
         checkThread();
         Cursor cursor = dao.getDatabase().rawQuery(sql, parameters);
-        return daoAccess.loadUniqueAndCloseCursor(cursor);
+        return deep ? daoAccess.loadUniqueDeepAndCloseCursor(cursor)
+                    : daoAccess.loadUniqueAndCloseCursor(cursor);
     }
 
     /**
diff --git a/greendao/src/main/java/de/greenrobot/dao/query/QueryBuilder.java b/greendao/src/main/java/de/greenrobot/dao/query/QueryBuilder.java
index 2fcea5e2..7c24d827 100644
--- a/greendao/src/main/java/de/greenrobot/dao/query/QueryBuilder.java
+++ b/greendao/src/main/java/de/greenrobot/dao/query/QueryBuilder.java
@@ -65,7 +65,8 @@
     private Integer limit;
 
     private Integer offset;
-    
+    private boolean deep;
+
     /** For internal use by greenDAO only. */
     public static <T2> QueryBuilder<T2> internalCreate(AbstractDao<T2, ?> dao) {
         return new QueryBuilder<T2>(dao);
@@ -242,6 +243,11 @@ protected void checkProperty(Property property) {
         return this;
     }
 
+    public QueryBuilder<T> deep() {
+        this.deep = true;
+        return this;
+    }
+
     /**
      * Sets the offset for query results in combination with {@link #limit(int)}. The first {@code limit} results are
      * skipped and the total number of results will be limited by {@code limit}. You cannot use offset without limit.
@@ -258,7 +264,11 @@ protected void checkProperty(Property property) {
     public Query<T> build() {
         String select;
         if (joinBuilder == null || joinBuilder.length() == 0) {
-            select = InternalQueryDaoAccess.getStatements(dao).getSelectAll();
+            if (deep) {
+                select = InternalQueryDaoAccess.getSelectDeep(dao);
+            } else {
+                select = InternalQueryDaoAccess.getStatements(dao).getSelectAll();
+            }
         } else {
             select = SqlUtils.createSqlSelect(dao.getTablename(), tablePrefix, dao.getAllColumns());
         }
@@ -296,7 +306,9 @@ protected void checkProperty(Property property) {
             DaoLog.d("Values for query: " + values);
         }
 
-        return Query.create(dao, sql, values.toArray(), limitPosition, offsetPosition);
+        return deep
+                ? Query.createDeep(dao, sql, values.toArray(), limitPosition, offsetPosition)
+                : Query.create(dao, sql, values.toArray(), limitPosition, offsetPosition);
     }
 
     /**
diff --git a/source-generator/src/main/resources/dao-deep.ftl b/source-generator/src/main/resources/dao-deep.ftl
index eee5dc97..8b17c4cb 100644
--- a/source-generator/src/main/resources/dao-deep.ftl
+++ b/source-generator/src/main/resources/dao-deep.ftl
@@ -20,6 +20,8 @@ along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
 <#if entity.toOneRelations?has_content>
     private String selectDeep;
 
+    /** @inheritdoc */
+    @Override
     protected String getSelectDeep() {
         if (selectDeep == null) {
             StringBuilder builder = new StringBuilder("SELECT ");
@@ -41,7 +43,8 @@ along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
         }
         return selectDeep;
     }
-    
+
+    @Override
     protected ${entity.className} loadCurrentDeep(Cursor cursor, boolean lock) {
         ${entity.className} entity = loadCurrent(cursor, 0, lock);
         int offset = getAllColumns().length;
@@ -89,6 +92,7 @@ along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
     }
     
     /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. */
+    @Override
     public List<${entity.className}> loadAllDeepFromCursor(Cursor cursor) {
         int count = cursor.getCount();
         List<${entity.className}> list = new ArrayList<${entity.className}>(count);
@@ -110,7 +114,7 @@ along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
         }
         return list;
     }
-    
+
     protected List<${entity.className}> loadDeepAllAndCloseCursor(Cursor cursor) {
         try {
             return loadAllDeepFromCursor(cursor);
diff --git a/source-generator/src/main/resources/dao-session.ftl b/source-generator/src/main/resources/dao-session.ftl
index e0201a48..53b9eb62 100644
--- a/source-generator/src/main/resources/dao-session.ftl
+++ b/source-generator/src/main/resources/dao-session.ftl
@@ -63,7 +63,7 @@ public class DaoSession extends AbstractDaoSession {
 
 </#list>        
 <#list schema.entities as entity>
-        ${entity.classNameDao?uncap_first} = new ${entity.classNameDao}<#--
+        ${entity.classNameDao?uncap_first} = new ${entity.classNameDaoImpl}<#--
 -->(${entity.classNameDao?uncap_first}Config, this);
 </#list>        
 
