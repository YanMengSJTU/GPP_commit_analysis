diff --git a/DaoGenerator/src-template/dao-unit-test.ftl b/DaoGenerator/src-template/dao-unit-test.ftl
index 376cf431..b19301bb 100644
--- a/DaoGenerator/src-template/dao-unit-test.ftl
+++ b/DaoGenerator/src-template/dao-unit-test.ftl
@@ -1,53 +1,53 @@
-<#--
-
-Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
-                                                                           
-This file is part of greenDAO Generator.                                   
-                                                                           
-greenDAO Generator is free software: you can redistribute it and/or modify 
-it under the terms of the GNU General Public License as published by       
-the Free Software Foundation, either version 3 of the License, or          
-(at your option) any later version.                                        
-greenDAO Generator is distributed in the hope that it will be useful,      
-but WITHOUT ANY WARRANTY; without even the implied warranty of             
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
-GNU General Public License for more details.                               
-                                                                           
-You should have received a copy of the GNU General Public License          
-along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
-
--->
-package ${entity.javaPackageTest};
-
-<#assign isStringPK = entity.pkProperty?? && entity.pkProperty.propertyType == "String" />
-<#if isStringPK>
-import de.greenrobot.dao.test.AbstractDaoTestStringPk;
-<#else>
-import de.greenrobot.dao.test.AbstractDaoTestLongPk;
-</#if>
-
-import ${entity.javaPackage}.${entity.className};
-import ${entity.javaPackageDao}.${entity.classNameDao};
-
-public class ${entity.classNameTest} extends <#if
-isStringPK>AbstractDaoTestStringPk<${entity.classNameDao}, ${entity.className}><#else>AbstractDaoTestLongPk<${entity.classNameDao}, ${entity.className}></#if> {
-
-    public ${entity.classNameTest}() {
-        super(${entity.classNameDao}.class);
-    }
-
-    @Override
-    protected ${entity.className} createEntity(<#if isStringPK>String<#else>Long</#if> key) {
-        ${entity.className} entity = new ${entity.className}();
-<#if entity.pkProperty??>
-        entity.set${entity.pkProperty.propertyName?cap_first}(key);
-</#if>
-<#list entity.properties as property>
-<#if property.notNull>
-        entity.set${property.propertyName?cap_first}();
-</#if> 
-</#list>
-        return entity;
-    }
-
-}
+<#--
+
+Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
+                                                                           
+This file is part of greenDAO Generator.                                   
+                                                                           
+greenDAO Generator is free software: you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by       
+the Free Software Foundation, either version 3 of the License, or          
+(at your option) any later version.                                        
+greenDAO Generator is distributed in the hope that it will be useful,      
+but WITHOUT ANY WARRANTY; without even the implied warranty of             
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
+GNU General Public License for more details.                               
+                                                                           
+You should have received a copy of the GNU General Public License          
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+package ${entity.javaPackageTest};
+
+<#assign isStringPK = entity.pkProperty?? && entity.pkProperty.propertyType == "String" />
+<#if isStringPK>
+import de.greenrobot.dao.test.AbstractDaoTestStringPk;
+<#else>
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+</#if>
+
+import ${entity.javaPackage}.${entity.className};
+import ${entity.javaPackageDao}.${entity.classNameDao};
+
+public class ${entity.classNameTest} extends <#if
+isStringPK>AbstractDaoTestStringPk<${entity.classNameDao}, ${entity.className}><#else>AbstractDaoTestLongPk<${entity.classNameDao}, ${entity.className}></#if> {
+
+    public ${entity.classNameTest}() {
+        super(${entity.classNameDao}.class);
+    }
+
+    @Override
+    protected ${entity.className} createEntity(<#if isStringPK>String<#else>Long</#if> key) {
+        ${entity.className} entity = new ${entity.className}();
+<#if entity.pkProperty??>
+        entity.set${entity.pkProperty.propertyNameCamelCase}(key);
+</#if>
+<#list entity.properties as property>
+<#if property.notNull>
+        entity.set${property.propertyNameCamelCase}();
+</#if> 
+</#list>
+        return entity;
+    }
+
+}
diff --git a/DaoGenerator/src-template/dao.ftl b/DaoGenerator/src-template/dao.ftl
index b9275906..51100815 100644
--- a/DaoGenerator/src-template/dao.ftl
+++ b/DaoGenerator/src-template/dao.ftl
@@ -1,300 +1,300 @@
-<#--
-
-Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
-                                                                           
-This file is part of greenDAO Generator.                                   
-                                                                           
-greenDAO Generator is free software: you can redistribute it and/or modify 
-it under the terms of the GNU General Public License as published by       
-the Free Software Foundation, either version 3 of the License, or          
-(at your option) any later version.                                        
-greenDAO Generator is distributed in the hope that it will be useful,      
-but WITHOUT ANY WARRANTY; without even the implied warranty of             
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
-GNU General Public License for more details.                               
-                                                                           
-You should have received a copy of the GNU General Public License          
-along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
-
--->
-<#assign toBindType = {"Boolean":"Long", "Byte":"Long", "Short":"Long", "Int":"Long", "Long":"Long", "Float":"Double", "Double":"Double", "String":"String", "ByteArray":"Blob", "Date": "Long" } />
-<#assign toCursorType = {"Boolean":"Short", "Byte":"Short", "Short":"Short", "Int":"Int", "Long":"Long", "Float":"Float", "Double":"Double", "String":"String", "ByteArray":"Blob", "Date": "Long"  } />
-package ${entity.javaPackageDao};
-
-<#if entity.toOneRelations?has_content || entity.incomingToManyRelations?has_content>
-import java.util.List;
-</#if>
-<#if entity.toOneRelations?has_content>
-import java.util.ArrayList;
-</#if>
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
-
-import de.greenrobot.dao.AbstractDao;
-import de.greenrobot.dao.DaoConfig;
-import de.greenrobot.dao.Property;
-<#if entity.toOneRelations?has_content>
-import de.greenrobot.dao.SqlUtils;
-</#if>
-<#if entity.incomingToManyRelations?has_content>
-import de.greenrobot.dao.Query;
-import de.greenrobot.dao.QueryBuilder;
-</#if>
-
-<#if entity.javaPackageDao != schema.defaultJavaPackageDao>
-import ${schema.defaultJavaPackageDao}.DaoSession;
-
-</#if>
-<#if entity.additionalImportsDao?has_content>
-<#list entity.additionalImportsDao as additionalImport>
-import ${additionalImport};
-</#list>
-
-</#if>
-import ${entity.javaPackage}.${entity.className};
-<#if entity.protobuf>
-import ${entity.javaPackage}.${entity.className}.Builder;
-</#if>
-
-// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
-/** 
- * DAO for table ${entity.tableName}.
-*/
-public class ${entity.classNameDao} extends AbstractDao<${entity.className}, ${entity.pkType}> {
-
-    public static final String TABLENAME = "${entity.tableName}";
-
-    /**
-     * Properties of entity ${entity.className}.<br/>
-     * Can be used for QueryBuilder and for referencing column names.
-    */
-    public static class Properties {
-<#list entity.propertiesColumns as property>
-        public final static Property ${property.propertyName?cap_first} = new Property(${property_index}, ${property.javaType}.class, "${property.propertyName}", ${property.primaryKey?string}, "${property.columnName}");
-</#list>
-    };
-
-<#if entity.active>
-    private DaoSession daoSession;
-
-</#if>
-<#list entity.incomingToManyRelations as toMany>
-    private Query<${toMany.targetEntity.className}> ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query;
-</#list>
-
-    public ${entity.classNameDao}(DaoConfig config) {
-        super(config);
-    }
-    
-    public ${entity.classNameDao}(DaoConfig config, DaoSession daoSession) {
-        super(config, daoSession);
-<#if entity.active>        
-        this.daoSession = daoSession;
-</#if>
-    }
-
-<#if !entity.skipTableCreation>
-    /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
-        String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'${entity.tableName}' (" + //
-<#list entity.propertiesColumns as property>
-                "'${property.columnName}' ${property.columnType}<#if property.constraints??> ${property.constraints} </#if><#if property_has_next>," +<#else>);");</#if> // ${property_index}: ${property.propertyName}
-</#list>
-<#if entity.indexes?has_content >
-        // Add Indexes
-<#list entity.indexes as index>
-        db.execSQL("CREATE <#if index.unique>UNIQUE </#if>INDEX " + constraint + "${index.name} ON ${entity.tableName}" +
-                " (<#list index.properties 
-as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
-</#list>
-</#if>         
-    }
-
-    /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'${entity.tableName}'";
-        db.execSQL(sql);
-    }
-
-</#if>
-    /** @inheritdoc */
-    @Override
-    protected void bindValues(SQLiteStatement stmt, ${entity.className} entity) {
-        stmt.clearBindings();
-<#list entity.properties as property>
-<#if property.notNull || entity.protobuf>
-<#if entity.protobuf>
-        if(entity.has${property.propertyName?cap_first}()) {
-    </#if>        stmt.bind${toBindType[property.propertyType]}(${property_index + 1}, entity.get${property.propertyName?cap_first}()<#if
-     property.propertyType == "Boolean"> ? 1l: 0l</#if><#if property.propertyType == "Date">.getTime()</#if>);
-<#if entity.protobuf>
-        }
-</#if>
-<#else> <#-- nullable, non-protobuff -->
-        ${property.javaType} ${property.propertyName} = entity.get${property.propertyName?cap_first}();
-        if (${property.propertyName} != null) {
-            stmt.bind${toBindType[property.propertyType]}(${property_index + 1}, ${property.propertyName}<#if
- property.propertyType == "Boolean"> ? 1l: 0l</#if><#if property.propertyType == "Date">.getTime()</#if>);
-        }
-</#if>
-</#list>
-<#list entity.toOneRelations as toOne>
-<#if !toOne.fkProperties?has_content>
-
-        ${toOne.targetEntity.className} ${toOne.name} = entity.peak${toOne.name?cap_first}();
-        if(${toOne.name} != null) {
-            ${toOne.targetEntity.pkProperty.javaType} ${toOne.name}__targetKey = ${toOne.name}.get${toOne.targetEntity.pkProperty.propertyName?cap_first}();
-<#if !toOne.targetEntity.pkProperty.notNull>
-            if(${toOne.name}__targetKey != null) {
-                // TODO bind ${toOne.name}__targetKey
-            }
-<#else>
-            // TODO bind ${toOne.name}__targetKey
-</#if>
-        }
-</#if>
-</#list>
-    }
-
-<#if entity.active>
-    @Override
-    protected void attachEntity(${entity.className} entity) {
-        super.attachEntity(entity);
-        entity.__setDaoSession(daoSession);
-    }
-
-</#if>
-    /** @inheritdoc */
-    @Override
-    public ${entity.pkType} readKey(Cursor cursor, int offset) {
-<#if entity.pkProperty??>
-        return <#if !entity.pkProperty.notNull>cursor.isNull(offset + ${entity.pkProperty.ordinal}) ? null : </#if><#if
-            entity.pkProperty.propertyType == "Byte">(byte) </#if><#if
-            entity.pkProperty.propertyType == "Date">new java.util.Date(</#if>cursor.get${toCursorType[entity.pkProperty.propertyType]}(offset + ${entity.pkProperty.ordinal})<#if
-            entity.pkProperty.propertyType == "Boolean"> != 0</#if><#if
-            entity.pkProperty.propertyType == "Date">)</#if>;
-<#else>
-        return null;
-</#if>  
-    }    
-
-    /** @inheritdoc */
-    @Override
-    public ${entity.className} readEntity(Cursor cursor, int offset) {
-<#if entity.protobuf>
-        Builder builder = ${entity.className}.newBuilder();
-<#list entity.properties as property>
-<#if !property.notNull>
-        if (!cursor.isNull(offset + ${property_index})) {
-    </#if>        builder.set${property.propertyName?cap_first}(cursor.get${toCursorType[property.propertyType]}(offset + ${property_index}));
-<#if !property.notNull>
-        }
-</#if>        
-</#list>        
-        return builder.build();
-<#elseif entity.constructors>
-<#--
-############################## readEntity non-protobuff, constructor ############################## 
--->
-        ${entity.className} entity = new ${entity.className}( //
-<#list entity.properties as property>
-            <#if !property.notNull>cursor.isNull(offset + ${property_index}) ? null : </#if><#if
-            property.propertyType == "Byte">(byte) </#if><#if
-            property.propertyType == "Date">new java.util.Date(</#if>cursor.get${toCursorType[property.propertyType]}(offset + ${property_index})<#if
-            property.propertyType == "Boolean"> != 0</#if><#if
-            property.propertyType == "Date">)</#if><#if property_has_next>,</#if> // ${property.propertyName}
-</#list>        
-        );
-        return entity;
-<#else>
-<#--
-############################## readEntity non-protobuff, setters ############################## 
--->
-        ${entity.className} entity = new ${entity.className}();
-        readEntity(cursor, entity, offset);
-        return entity;
-</#if>
-    }
-     
-    /** @inheritdoc */
-    @Override
-    public void readEntity(Cursor cursor, ${entity.className} entity, int offset) {
-<#if entity.protobuf>
-        throw new UnsupportedOperationException("Protobuf objects cannot be modified");
-<#else> 
-<#list entity.properties as property>
-        entity.set${property.propertyName?cap_first}(<#if !property.notNull>cursor.isNull(offset + ${property_index}) ? null : </#if><#if
-            property.propertyType == "Byte">(byte) </#if><#if
-            property.propertyType == "Date">new java.util.Date(</#if>cursor.get${toCursorType[property.propertyType]}(offset + ${property_index})<#if
-            property.propertyType == "Boolean"> != 0</#if><#if
-            property.propertyType == "Date">)</#if>);
-</#list>
-</#if>
-     }
-    
-    /** @inheritdoc */
-    @Override
-    protected ${entity.pkType} updateKeyAfterInsert(${entity.className} entity, long rowId) {
-<#if entity.pkProperty??>
-<#if entity.pkProperty.propertyType == "Long">
-<#if !entity.protobuf>
-        entity.set${entity.pkProperty.propertyName?cap_first}(rowId);
-</#if>
-        return rowId;
-<#else>
-        return entity.get${entity.pkProperty.propertyName?cap_first}();
-</#if>
-<#else>
-        // Unsupported or missing PK type
-        return null;
-</#if>
-    }
-    
-    /** @inheritdoc */
-    @Override
-    public ${entity.pkType} getKey(${entity.className} entity) {
-<#if entity.pkProperty??>
-        if(entity != null) {
-            return entity.get${entity.pkProperty.propertyName?cap_first}();
-        } else {
-            return null;
-        }
-<#else>
-        return null;
-</#if>    
-    }
-
-    /** @inheritdoc */
-    @Override    
-    protected boolean isEntityUpdateable() {
-        return ${(!entity.protobuf)?string};
-    }
-    
-<#list entity.incomingToManyRelations as toMany>
-    /** Internal query to resolve the "${toMany.name}" to-many relationship of ${toMany.sourceEntity.className}. */
-    public synchronized List<${toMany.targetEntity.className}> _query${toMany.sourceEntity.className?cap_first}_${toMany.name?cap_first}(<#--
-    --><#list toMany.targetProperties as property>${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
-        if (${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query == null) {
-            QueryBuilder<${toMany.targetEntity.className}> queryBuilder = queryBuilder();
-<#list toMany.targetProperties as property>
-            queryBuilder.where(Properties.${property.propertyName?cap_first}.eq(${property.propertyName}));
-</#list>
-<#if toMany.order?has_content>
-            queryBuilder.orderRaw("${toMany.order}");
-</#if>
-            ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query = queryBuilder.build();
-        } else {
-<#list toMany.targetProperties as property>
-            ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query.setParameter(${property_index}, ${property.propertyName});
-</#list>
-        }
-        return ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query.list();
-    }
-
-</#list>   
-<#if entity.toOneRelations?has_content>
-    <#include "dao-deep.ftl">
-</#if>
-}
+<#--
+
+Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
+                                                                           
+This file is part of greenDAO Generator.                                   
+                                                                           
+greenDAO Generator is free software: you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by       
+the Free Software Foundation, either version 3 of the License, or          
+(at your option) any later version.                                        
+greenDAO Generator is distributed in the hope that it will be useful,      
+but WITHOUT ANY WARRANTY; without even the implied warranty of             
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
+GNU General Public License for more details.                               
+                                                                           
+You should have received a copy of the GNU General Public License          
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+<#assign toBindType = {"Boolean":"Long", "Byte":"Long", "Short":"Long", "Int":"Long", "Long":"Long", "Float":"Double", "Double":"Double", "String":"String", "ByteArray":"Blob", "Date": "Long" } />
+<#assign toCursorType = {"Boolean":"Short", "Byte":"Short", "Short":"Short", "Int":"Int", "Long":"Long", "Float":"Float", "Double":"Double", "String":"String", "ByteArray":"Blob", "Date": "Long"  } />
+package ${entity.javaPackageDao};
+
+<#if entity.toOneRelations?has_content || entity.incomingToManyRelations?has_content>
+import java.util.List;
+</#if>
+<#if entity.toOneRelations?has_content>
+import java.util.ArrayList;
+</#if>
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.DaoConfig;
+import de.greenrobot.dao.Property;
+<#if entity.toOneRelations?has_content>
+import de.greenrobot.dao.SqlUtils;
+</#if>
+<#if entity.incomingToManyRelations?has_content>
+import de.greenrobot.dao.Query;
+import de.greenrobot.dao.QueryBuilder;
+</#if>
+
+<#if entity.javaPackageDao != schema.defaultJavaPackageDao>
+import ${schema.defaultJavaPackageDao}.DaoSession;
+
+</#if>
+<#if entity.additionalImportsDao?has_content>
+<#list entity.additionalImportsDao as additionalImport>
+import ${additionalImport};
+</#list>
+
+</#if>
+import ${entity.javaPackage}.${entity.className};
+<#if entity.protobuf>
+import ${entity.javaPackage}.${entity.className}.Builder;
+</#if>
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table ${entity.tableName}.
+*/
+public class ${entity.classNameDao} extends AbstractDao<${entity.className}, ${entity.pkType}> {
+
+    public static final String TABLENAME = "${entity.tableName}";
+
+    /**
+     * Properties of entity ${entity.className}.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+<#list entity.propertiesColumns as property>
+        public final static Property ${property.propertyNameCamelCase} = new Property(${property_index}, ${property.javaType}.class, "${property.propertyName}", ${property.primaryKey?string}, "${property.columnName}");
+</#list>
+    };
+
+<#if entity.active>
+    private DaoSession daoSession;
+
+</#if>
+<#list entity.incomingToManyRelations as toMany>
+    private Query<${toMany.targetEntity.className}> ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query;
+</#list>
+
+    public ${entity.classNameDao}(DaoConfig config) {
+        super(config);
+    }
+    
+    public ${entity.classNameDao}(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+<#if entity.active>        
+        this.daoSession = daoSession;
+</#if>
+    }
+
+<#if !entity.skipTableCreation>
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'${entity.tableName}' (" + //
+<#list entity.propertiesColumns as property>
+                "'${property.columnName}' ${property.columnType}<#if property.constraints??> ${property.constraints} </#if><#if property_has_next>," +<#else>);");</#if> // ${property_index}: ${property.propertyName}
+</#list>
+<#if entity.indexes?has_content >
+        // Add Indexes
+<#list entity.indexes as index>
+        db.execSQL("CREATE <#if index.unique>UNIQUE </#if>INDEX " + constraint + "${index.name} ON ${entity.tableName}" +
+                " (<#list index.properties 
+as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
+</#list>
+</#if>         
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'${entity.tableName}'";
+        db.execSQL(sql);
+    }
+
+</#if>
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, ${entity.className} entity) {
+        stmt.clearBindings();
+<#list entity.properties as property>
+<#if property.notNull || entity.protobuf>
+<#if entity.protobuf>
+        if(entity.has${property.propertyNameCamelCase}()) {
+    </#if>        stmt.bind${toBindType[property.propertyType]}(${property_index + 1}, entity.get${property.propertyNameCamelCase}()<#if
+     property.propertyType == "Boolean"> ? 1l: 0l</#if><#if property.propertyType == "Date">.getTime()</#if>);
+<#if entity.protobuf>
+        }
+</#if>
+<#else> <#-- nullable, non-protobuff -->
+        ${property.javaType} ${property.propertyName} = entity.get${property.propertyNameCamelCase}();
+        if (${property.propertyName} != null) {
+            stmt.bind${toBindType[property.propertyType]}(${property_index + 1}, ${property.propertyName}<#if
+ property.propertyType == "Boolean"> ? 1l: 0l</#if><#if property.propertyType == "Date">.getTime()</#if>);
+        }
+</#if>
+</#list>
+<#list entity.toOneRelations as toOne>
+<#if !toOne.fkProperties?has_content>
+
+        ${toOne.targetEntity.className} ${toOne.name} = entity.peak${toOne.name?cap_first}();
+        if(${toOne.name} != null) {
+            ${toOne.targetEntity.pkProperty.javaType} ${toOne.name}__targetKey = ${toOne.name}.get${toOne.targetEntity.pkProperty.propertyNameCamelCase}();
+<#if !toOne.targetEntity.pkProperty.notNull>
+            if(${toOne.name}__targetKey != null) {
+                // TODO bind ${toOne.name}__targetKey
+            }
+<#else>
+            // TODO bind ${toOne.name}__targetKey
+</#if>
+        }
+</#if>
+</#list>
+    }
+
+<#if entity.active>
+    @Override
+    protected void attachEntity(${entity.className} entity) {
+        super.attachEntity(entity);
+        entity.__setDaoSession(daoSession);
+    }
+
+</#if>
+    /** @inheritdoc */
+    @Override
+    public ${entity.pkType} readKey(Cursor cursor, int offset) {
+<#if entity.pkProperty??>
+        return <#if !entity.pkProperty.notNull>cursor.isNull(offset + ${entity.pkProperty.ordinal}) ? null : </#if><#if
+            entity.pkProperty.propertyType == "Byte">(byte) </#if><#if
+            entity.pkProperty.propertyType == "Date">new java.util.Date(</#if>cursor.get${toCursorType[entity.pkProperty.propertyType]}(offset + ${entity.pkProperty.ordinal})<#if
+            entity.pkProperty.propertyType == "Boolean"> != 0</#if><#if
+            entity.pkProperty.propertyType == "Date">)</#if>;
+<#else>
+        return null;
+</#if>  
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public ${entity.className} readEntity(Cursor cursor, int offset) {
+<#if entity.protobuf>
+        Builder builder = ${entity.className}.newBuilder();
+<#list entity.properties as property>
+<#if !property.notNull>
+        if (!cursor.isNull(offset + ${property_index})) {
+    </#if>        builder.set${property.propertyNameCamelCase}(cursor.get${toCursorType[property.propertyType]}(offset + ${property_index}));
+<#if !property.notNull>
+        }
+</#if>        
+</#list>        
+        return builder.build();
+<#elseif entity.constructors>
+<#--
+############################## readEntity non-protobuff, constructor ############################## 
+-->
+        ${entity.className} entity = new ${entity.className}( //
+<#list entity.properties as property>
+            <#if !property.notNull>cursor.isNull(offset + ${property_index}) ? null : </#if><#if
+            property.propertyType == "Byte">(byte) </#if><#if
+            property.propertyType == "Date">new java.util.Date(</#if>cursor.get${toCursorType[property.propertyType]}(offset + ${property_index})<#if
+            property.propertyType == "Boolean"> != 0</#if><#if
+            property.propertyType == "Date">)</#if><#if property_has_next>,</#if> // ${property.propertyName}
+</#list>        
+        );
+        return entity;
+<#else>
+<#--
+############################## readEntity non-protobuff, setters ############################## 
+-->
+        ${entity.className} entity = new ${entity.className}();
+        readEntity(cursor, entity, offset);
+        return entity;
+</#if>
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, ${entity.className} entity, int offset) {
+<#if entity.protobuf>
+        throw new UnsupportedOperationException("Protobuf objects cannot be modified");
+<#else> 
+<#list entity.properties as property>
+        entity.set${property.propertyNameCamelCase}(<#if !property.notNull>cursor.isNull(offset + ${property_index}) ? null : </#if><#if
+            property.propertyType == "Byte">(byte) </#if><#if
+            property.propertyType == "Date">new java.util.Date(</#if>cursor.get${toCursorType[property.propertyType]}(offset + ${property_index})<#if
+            property.propertyType == "Boolean"> != 0</#if><#if
+            property.propertyType == "Date">)</#if>);
+</#list>
+</#if>
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected ${entity.pkType} updateKeyAfterInsert(${entity.className} entity, long rowId) {
+<#if entity.pkProperty??>
+<#if entity.pkProperty.propertyType == "Long">
+<#if !entity.protobuf>
+        entity.set${entity.pkProperty.propertyNameCamelCase}(rowId);
+</#if>
+        return rowId;
+<#else>
+        return entity.get${entity.pkProperty.propertyNameCamelCase}();
+</#if>
+<#else>
+        // Unsupported or missing PK type
+        return null;
+</#if>
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public ${entity.pkType} getKey(${entity.className} entity) {
+<#if entity.pkProperty??>
+        if(entity != null) {
+            return entity.get${entity.pkProperty.propertyNameCamelCase}();
+        } else {
+            return null;
+        }
+<#else>
+        return null;
+</#if>    
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return ${(!entity.protobuf)?string};
+    }
+    
+<#list entity.incomingToManyRelations as toMany>
+    /** Internal query to resolve the "${toMany.name}" to-many relationship of ${toMany.sourceEntity.className}. */
+    public synchronized List<${toMany.targetEntity.className}> _query${toMany.sourceEntity.className?cap_first}_${toMany.name?cap_first}(<#--
+    --><#list toMany.targetProperties as property>${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
+        if (${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query == null) {
+            QueryBuilder<${toMany.targetEntity.className}> queryBuilder = queryBuilder();
+<#list toMany.targetProperties as property>
+            queryBuilder.where(Properties.${property.propertyNameCamelCase}.eq(${property.propertyName}));
+</#list>
+<#if toMany.order?has_content>
+            queryBuilder.orderRaw("${toMany.order}");
+</#if>
+            ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query = queryBuilder.build();
+        } else {
+<#list toMany.targetProperties as property>
+            ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query.setParameter(${property_index}, ${property.propertyName});
+</#list>
+        }
+        return ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query.list();
+    }
+
+</#list>   
+<#if entity.toOneRelations?has_content>
+    <#include "dao-deep.ftl">
+</#if>
+}
diff --git a/DaoGenerator/src-template/entity.ftl b/DaoGenerator/src-template/entity.ftl
index 98cf2b14..db4fe4e5 100644
--- a/DaoGenerator/src-template/entity.ftl
+++ b/DaoGenerator/src-template/entity.ftl
@@ -1,249 +1,249 @@
-<#--
-
-Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
-                                                                           
-This file is part of greenDAO Generator.                                   
-                                                                           
-greenDAO Generator is free software: you can redistribute it and/or modify 
-it under the terms of the GNU General Public License as published by       
-the Free Software Foundation, either version 3 of the License, or          
-(at your option) any later version.                                        
-greenDAO Generator is distributed in the hope that it will be useful,      
-but WITHOUT ANY WARRANTY; without even the implied warranty of             
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
-GNU General Public License for more details.                               
-                                                                           
-You should have received a copy of the GNU General Public License          
-along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
-
--->
-<#assign toBindType = {"Boolean":"Long", "Byte":"Long", "Short":"Long", "Int":"Long", "Long":"Long", "Float":"Double", "Double":"Double", "String":"String", "ByteArray":"Blob" }/>
-<#assign toCursorType = {"Boolean":"Short", "Byte":"Short", "Short":"Short", "Int":"Int", "Long":"Long", "Float":"Float", "Double":"Double", "String":"String", "ByteArray":"Blob" }/>
-<#assign complexTypes = ["String", "ByteArray", "Date"]/>
-package ${entity.javaPackage};
-
-<#if entity.toManyRelations?has_content>
-import java.util.List;
-</#if>
-<#if entity.active>
-import ${schema.defaultJavaPackageDao}.DaoSession;
-import de.greenrobot.dao.DaoException;
-
-</#if>
-<#if entity.additionalImportsEntity?has_content>
-<#list entity.additionalImportsEntity as additionalImport>
-import ${additionalImport};
-</#list>
-
-</#if>
-<#if entity.hasKeepSections>
-// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS
-
-// KEEP INCLUDES - put your custom includes here
-<#if keepIncludes?has_content>${keepIncludes!}</#if>// KEEP INCLUDES END
-<#else>
-// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
-</#if>
-/**
- * Entity mapped to table ${entity.tableName}.
- */
-public class ${entity.className}<#if
-entity.superclass?has_content> extends ${entity.superclass} </#if><#if
-entity.interfacesToImplement?has_content> implements <#list entity.interfacesToImplement
-as ifc>${ifc}<#if ifc_has_next>, </#if></#list></#if> {
-
-<#list entity.properties as property>
-<#if property.notNull && complexTypes?seq_contains(property.propertyType)>
-    /** Not-null value. */
-</#if>
-    private ${property.javaType} ${property.propertyName};
-</#list>
-
-<#if entity.active>
-    /** Used to resolve relations */
-    private transient DaoSession daoSession;
-
-    /** Used for active entity operations. */
-    private transient ${entity.classNameDao} myDao;
-
-<#list entity.toOneRelations as toOne>
-    private ${toOne.targetEntity.className} ${toOne.name};
-<#if toOne.useFkProperty>
-    private ${toOne.resolvedKeyJavaType[0]} ${toOne.name}__resolvedKey;
-<#else>
-    private boolean ${toOne.name}__refreshed;
-</#if>
-
-</#list>
-<#list entity.toManyRelations as toMany>
-    private List<${toMany.targetEntity.className}> ${toMany.name};
-</#list>
-
-</#if>
-<#if entity.hasKeepSections>
-    // KEEP FIELDS - put your custom fields here
-${keepFields!}    // KEEP FIELDS END
-
-</#if>
-<#if entity.constructors>
-    public ${entity.className}() {
-    }
-<#if entity.propertiesPk?has_content && entity.propertiesPk?size != entity.properties?size>
-
-    public ${entity.className}(<#list entity.propertiesPk as
-property>${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
-<#list entity.propertiesPk as property>
-        this.${property.propertyName} = ${property.propertyName};
-</#list>
-    }
-</#if>
-
-    public ${entity.className}(<#list entity.properties as
-property>${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
-<#list entity.properties as property>
-        this.${property.propertyName} = ${property.propertyName};
-</#list>
-    }
-</#if>
-
-<#if entity.active>
-    /** called by internal mechanisms, do not call yourself. */
-    public void __setDaoSession(DaoSession daoSession) {
-        this.daoSession = daoSession;
-        myDao = daoSession != null ? daoSession.get${entity.classNameDao?cap_first}() : null;
-    }
-
-</#if>
-<#list entity.properties as property>
-<#if property.notNull && complexTypes?seq_contains(property.propertyType)>
-    /** Not-null value. */
-</#if>
-    public ${property.javaType} get${property.propertyName?cap_first}() {
-        return ${property.propertyName};
-    }
-
-<#if property.notNull && complexTypes?seq_contains(property.propertyType)>
-    /** Not-null value; ensure this value is available before it is saved to the database. */
-</#if>
-    public void set${property.propertyName?cap_first}(${property.javaType} ${property.propertyName}) {
-        this.${property.propertyName} = ${property.propertyName};
-    }
-
-</#list>
-<#--
-##########################################
-########## To-One Relations ##############
-##########################################
--->
-<#list entity.toOneRelations as toOne>
-    /** To-one relationship, resolved on first access. */
-    public ${toOne.targetEntity.className} get${toOne.name?cap_first}() {
-<#if toOne.useFkProperty>    
-        if (${toOne.name}__resolvedKey == null || <#--
-        --><#if toOne.resolvedKeyUseEquals[0]>!${toOne.name}__resolvedKey.equals(${toOne.fkProperties[0].propertyName})<#--
-        --><#else>${toOne.name}__resolvedKey != ${toOne.fkProperties[0].propertyName}</#if>) {
-            if (daoSession == null) {
-                throw new DaoException("Entity is detached from DAO context");
-            }
-            ${toOne.targetEntity.classNameDao} targetDao = daoSession.get${toOne.targetEntity.classNameDao?cap_first}();
-            ${toOne.name} = targetDao.load(${toOne.fkProperties[0].propertyName});
-            ${toOne.name}__resolvedKey = ${toOne.fkProperties[0].propertyName};
-        }
-<#else>
-        if (${toOne.name} != null || !${toOne.name}__refreshed) {
-            if (daoSession == null) {
-                throw new DaoException("Entity is detached from DAO context");
-            }
-            ${toOne.targetEntity.classNameDao} targetDao = daoSession.get${toOne.targetEntity.classNameDao?cap_first}();
-            targetDao.refresh(${toOne.name});
-            ${toOne.name}__refreshed = true;
-        }
-</#if>
-        return ${toOne.name};
-    }
-<#if !toOne.useFkProperty>
-
-    /** To-one relationship, returned entity is not refreshed and may carry only the PK property. */
-    public ${toOne.targetEntity.className} peak${toOne.name?cap_first}() {
-        return ${toOne.name};
-    }
-</#if>
-
-    public void set${toOne.name?cap_first}(${toOne.targetEntity.className} ${toOne.name}) {
-<#if toOne.fkProperties[0].notNull>
-        if (${toOne.name} == null) {
-            throw new DaoException("To-one property '${toOne.fkProperties[0].propertyName}' has not-null constraint; cannot set to-one to null");
-        }
-</#if>
-        this.${toOne.name} = ${toOne.name};
-<#if toOne.useFkProperty>        
-        ${toOne.fkProperties[0].propertyName} = <#if !toOne.fkProperties[0].notNull>${toOne.name} == null ? null : </#if>${toOne.name}.get${toOne.targetEntity.pkProperty.propertyName?cap_first}();
-        ${toOne.name}__resolvedKey = ${toOne.fkProperties[0].propertyName};
-<#else>
-        ${toOne.name}__refreshed = true;
-</#if>
-    }
-
-</#list>
-<#--
-##########################################
-########## To-Many Relations #############
-##########################################
--->
-<#list entity.toManyRelations as toMany>
-    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
-    public synchronized List<${toMany.targetEntity.className}> get${toMany.name?cap_first}() {
-        if (${toMany.name} == null) {
-            if (daoSession == null) {
-                throw new DaoException("Entity is detached from DAO context");
-            }
-            ${toMany.targetEntity.classNameDao} targetDao = daoSession.get${toMany.targetEntity.classNameDao?cap_first}();
-            ${toMany.name} = targetDao._query${toMany.sourceEntity.className?cap_first}_${toMany.name?cap_first}(<#--
-                --><#list toMany.sourceProperties as property>${property.propertyName}<#if property_has_next>, </#if></#list>);
-        }
-        return ${toMany.name};
-    }
-
-    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
-    public synchronized void reset${toMany.name?cap_first}() {
-        ${toMany.name} = null;
-    }
-
-</#list>
-<#--
-##########################################
-########## Active entity operations ######
-##########################################
--->
-<#if entity.active>
-    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
-    public void delete() {
-        if (myDao == null) {
-            throw new DaoException("Entity is detached from DAO context");
-        }    
-        myDao.delete(this);
-    }
-
-    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
-    public void update() {
-        if (myDao == null) {
-            throw new DaoException("Entity is detached from DAO context");
-        }    
-        myDao.update(this);
-    }
-
-    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
-    public void refresh() {
-        if (myDao == null) {
-            throw new DaoException("Entity is detached from DAO context");
-        }    
-        myDao.refresh(this);
-    }
-
-</#if>
-<#if entity.hasKeepSections>
-    // KEEP METHODS - put your custom methods here
-${keepMethods!}    // KEEP METHODS END
-
-</#if>
-}
+<#--
+
+Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
+                                                                           
+This file is part of greenDAO Generator.                                   
+                                                                           
+greenDAO Generator is free software: you can redistribute it and/or modify 
+it under the terms of the GNU General Public License as published by       
+the Free Software Foundation, either version 3 of the License, or          
+(at your option) any later version.                                        
+greenDAO Generator is distributed in the hope that it will be useful,      
+but WITHOUT ANY WARRANTY; without even the implied warranty of             
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
+GNU General Public License for more details.                               
+                                                                           
+You should have received a copy of the GNU General Public License          
+along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+
+-->
+<#assign toBindType = {"Boolean":"Long", "Byte":"Long", "Short":"Long", "Int":"Long", "Long":"Long", "Float":"Double", "Double":"Double", "String":"String", "ByteArray":"Blob" }/>
+<#assign toCursorType = {"Boolean":"Short", "Byte":"Short", "Short":"Short", "Int":"Int", "Long":"Long", "Float":"Float", "Double":"Double", "String":"String", "ByteArray":"Blob" }/>
+<#assign complexTypes = ["String", "ByteArray", "Date"]/>
+package ${entity.javaPackage};
+
+<#if entity.toManyRelations?has_content>
+import java.util.List;
+</#if>
+<#if entity.active>
+import ${schema.defaultJavaPackageDao}.DaoSession;
+import de.greenrobot.dao.DaoException;
+
+</#if>
+<#if entity.additionalImportsEntity?has_content>
+<#list entity.additionalImportsEntity as additionalImport>
+import ${additionalImport};
+</#list>
+
+</#if>
+<#if entity.hasKeepSections>
+// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS
+
+// KEEP INCLUDES - put your custom includes here
+<#if keepIncludes?has_content>${keepIncludes!}</#if>// KEEP INCLUDES END
+<#else>
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+</#if>
+/**
+ * Entity mapped to table ${entity.tableName}.
+ */
+public class ${entity.className}<#if
+entity.superclass?has_content> extends ${entity.superclass} </#if><#if
+entity.interfacesToImplement?has_content> implements <#list entity.interfacesToImplement
+as ifc>${ifc}<#if ifc_has_next>, </#if></#list></#if> {
+
+<#list entity.properties as property>
+<#if property.notNull && complexTypes?seq_contains(property.propertyType)>
+    /** Not-null value. */
+</#if>
+    private ${property.javaType} ${property.propertyName};
+</#list>
+
+<#if entity.active>
+    /** Used to resolve relations */
+    private transient DaoSession daoSession;
+
+    /** Used for active entity operations. */
+    private transient ${entity.classNameDao} myDao;
+
+<#list entity.toOneRelations as toOne>
+    private ${toOne.targetEntity.className} ${toOne.name};
+<#if toOne.useFkProperty>
+    private ${toOne.resolvedKeyJavaType[0]} ${toOne.name}__resolvedKey;
+<#else>
+    private boolean ${toOne.name}__refreshed;
+</#if>
+
+</#list>
+<#list entity.toManyRelations as toMany>
+    private List<${toMany.targetEntity.className}> ${toMany.name};
+</#list>
+
+</#if>
+<#if entity.hasKeepSections>
+    // KEEP FIELDS - put your custom fields here
+${keepFields!}    // KEEP FIELDS END
+
+</#if>
+<#if entity.constructors>
+    public ${entity.className}() {
+    }
+<#if entity.propertiesPk?has_content && entity.propertiesPk?size != entity.properties?size>
+
+    public ${entity.className}(<#list entity.propertiesPk as
+property>${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
+<#list entity.propertiesPk as property>
+        this.${property.propertyName} = ${property.propertyName};
+</#list>
+    }
+</#if>
+
+    public ${entity.className}(<#list entity.properties as
+property>${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
+<#list entity.properties as property>
+        this.${property.propertyName} = ${property.propertyName};
+</#list>
+    }
+</#if>
+
+<#if entity.active>
+    /** called by internal mechanisms, do not call yourself. */
+    public void __setDaoSession(DaoSession daoSession) {
+        this.daoSession = daoSession;
+        myDao = daoSession != null ? daoSession.get${entity.classNameDao?cap_first}() : null;
+    }
+
+</#if>
+<#list entity.properties as property>
+<#if property.notNull && complexTypes?seq_contains(property.propertyType)>
+    /** Not-null value. */
+</#if>
+    public ${property.javaType} get${property.propertyNameCamelCase}() {
+        return ${property.propertyName};
+    }
+
+<#if property.notNull && complexTypes?seq_contains(property.propertyType)>
+    /** Not-null value; ensure this value is available before it is saved to the database. */
+</#if>
+    public void set${property.propertyNameCamelCase}(${property.javaType} ${property.propertyName}) {
+        this.${property.propertyName} = ${property.propertyName};
+    }
+
+</#list>
+<#--
+##########################################
+########## To-One Relations ##############
+##########################################
+-->
+<#list entity.toOneRelations as toOne>
+    /** To-one relationship, resolved on first access. */
+    public ${toOne.targetEntity.className} get${toOne.name?cap_first}() {
+<#if toOne.useFkProperty>    
+        if (${toOne.name}__resolvedKey == null || <#--
+        --><#if toOne.resolvedKeyUseEquals[0]>!${toOne.name}__resolvedKey.equals(${toOne.fkProperties[0].propertyName})<#--
+        --><#else>${toOne.name}__resolvedKey != ${toOne.fkProperties[0].propertyName}</#if>) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            ${toOne.targetEntity.classNameDao} targetDao = daoSession.get${toOne.targetEntity.classNameDao?cap_first}();
+            ${toOne.name} = targetDao.load(${toOne.fkProperties[0].propertyName});
+            ${toOne.name}__resolvedKey = ${toOne.fkProperties[0].propertyName};
+        }
+<#else>
+        if (${toOne.name} != null || !${toOne.name}__refreshed) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            ${toOne.targetEntity.classNameDao} targetDao = daoSession.get${toOne.targetEntity.classNameDao?cap_first}();
+            targetDao.refresh(${toOne.name});
+            ${toOne.name}__refreshed = true;
+        }
+</#if>
+        return ${toOne.name};
+    }
+<#if !toOne.useFkProperty>
+
+    /** To-one relationship, returned entity is not refreshed and may carry only the PK property. */
+    public ${toOne.targetEntity.className} peak${toOne.name?cap_first}() {
+        return ${toOne.name};
+    }
+</#if>
+
+    public void set${toOne.name?cap_first}(${toOne.targetEntity.className} ${toOne.name}) {
+<#if toOne.fkProperties[0].notNull>
+        if (${toOne.name} == null) {
+            throw new DaoException("To-one property '${toOne.fkProperties[0].propertyName}' has not-null constraint; cannot set to-one to null");
+        }
+</#if>
+        this.${toOne.name} = ${toOne.name};
+<#if toOne.useFkProperty>        
+        ${toOne.fkProperties[0].propertyName} = <#if !toOne.fkProperties[0].notNull>${toOne.name} == null ? null : </#if>${toOne.name}.get${toOne.targetEntity.pkProperty.propertyNameCamelCase}();
+        ${toOne.name}__resolvedKey = ${toOne.fkProperties[0].propertyName};
+<#else>
+        ${toOne.name}__refreshed = true;
+</#if>
+    }
+
+</#list>
+<#--
+##########################################
+########## To-Many Relations #############
+##########################################
+-->
+<#list entity.toManyRelations as toMany>
+    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
+    public synchronized List<${toMany.targetEntity.className}> get${toMany.name?cap_first}() {
+        if (${toMany.name} == null) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            ${toMany.targetEntity.classNameDao} targetDao = daoSession.get${toMany.targetEntity.classNameDao?cap_first}();
+            ${toMany.name} = targetDao._query${toMany.sourceEntity.className?cap_first}_${toMany.name?cap_first}(<#--
+                --><#list toMany.sourceProperties as property>${property.propertyName}<#if property_has_next>, </#if></#list>);
+        }
+        return ${toMany.name};
+    }
+
+    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
+    public synchronized void reset${toMany.name?cap_first}() {
+        ${toMany.name} = null;
+    }
+
+</#list>
+<#--
+##########################################
+########## Active entity operations ######
+##########################################
+-->
+<#if entity.active>
+    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
+    public void delete() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.delete(this);
+    }
+
+    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
+    public void update() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.update(this);
+    }
+
+    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
+    public void refresh() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.refresh(this);
+    }
+
+</#if>
+<#if entity.hasKeepSections>
+    // KEEP METHODS - put your custom methods here
+${keepMethods!}    // KEEP METHODS END
+
+</#if>
+}
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/Property.java b/DaoGenerator/src/de/greenrobot/daogenerator/Property.java
index f54d05e8..7e259dfb 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/Property.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/Property.java
@@ -1,248 +1,281 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * This file is part of greenDAO Generator.
- * 
- * greenDAO Generator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- * greenDAO Generator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
- */
-package de.greenrobot.daogenerator;
-
-/** Model class for an entity's property: a Java property mapped to a data base column. */
-public class Property {
-
-    public static class PropertyBuilder {
-        private final Property property;
-
-        public PropertyBuilder(Schema schema, Entity entity, PropertyType propertyType, String propertyName) {
-            property = new Property(schema, entity, propertyType, propertyName);
-        }
-
-        public PropertyBuilder columnName(String columnName) {
-            property.columnName = columnName;
-            return this;
-        }
-
-        public PropertyBuilder columnType(String columnType) {
-            property.columnType = columnType;
-            return this;
-        }
-
-        public PropertyBuilder primaryKey() {
-            property.primaryKey = true;
-            return this;
-        }
-
-        public PropertyBuilder primaryKeyAsc() {
-            property.primaryKey = true;
-            property.pkAsc = true;
-            return this;
-        }
-
-        public PropertyBuilder primaryKeyDesc() {
-            property.primaryKey = true;
-            property.pkDesc = true;
-            return this;
-        }
-
-        public PropertyBuilder autoincrement() {
-            if (!property.primaryKey || property.propertyType != PropertyType.Long) {
-                throw new RuntimeException(
-                        "AUTOINCREMENT is only available to primary key properties of type long/Long");
-            }
-            property.pkAutoincrement = true;
-            return this;
-        }
-
-        public PropertyBuilder unique() {
-            property.unique = true;
-            return this;
-        }
-
-        public PropertyBuilder notNull() {
-            property.notNull = true;
-            return this;
-        }
-
-        public PropertyBuilder index() {
-            Index index = new Index();
-            index.addProperty(property);
-            property.entity.addIndex(index);
-            return this;
-        }
-
-        public PropertyBuilder indexAsc(String indexNameOrNull, boolean isUnique) {
-            Index index = new Index();
-            index.addPropertyAsc(property);
-            if (isUnique) {
-                index.makeUnique();
-            }
-            index.setName(indexNameOrNull);
-            property.entity.addIndex(index);
-            return this;
-        }
-
-        public PropertyBuilder indexDesc(String indexNameOrNull, boolean isUnique) {
-            Index index = new Index();
-            index.addPropertyDesc(property);
-            if (isUnique) {
-                index.makeUnique();
-            }
-            index.setName(indexNameOrNull);
-            property.entity.addIndex(index);
-            return this;
-        }
-
-        public Property getProperty() {
-            return property;
-        }
-    }
-
-    private final Schema schema;
-    private final Entity entity;
-    private PropertyType propertyType;
-    private final String propertyName;
-
-    private String columnName;
-    private String columnType;
-
-    private boolean primaryKey;
-    private boolean pkAsc;
-    private boolean pkDesc;
-    private boolean pkAutoincrement;
-
-    private boolean unique;
-    private boolean notNull;
-
-    /** Initialized in 2nd pass */
-    private String constraints;
-
-    private int ordinal;
-
-    private String javaType;
-
-    public Property(Schema schema, Entity entity, PropertyType propertyType, String propertyName) {
-        this.schema = schema;
-        this.entity = entity;
-        this.propertyName = propertyName;
-        this.propertyType = propertyType;
-    }
-
-    public String getPropertyName() {
-        return propertyName;
-    }
-
-    public PropertyType getPropertyType() {
-        return propertyType;
-    }
-
-    public void setPropertyType(PropertyType propertyType) {
-        this.propertyType = propertyType;
-    }
-
-    public String getColumnName() {
-        return columnName;
-    }
-
-    public String getColumnType() {
-        return columnType;
-    }
-
-    public boolean isPrimaryKey() {
-        return primaryKey;
-    }
-
-    public boolean isAutoincrement() {
-        return pkAutoincrement;
-    }
-
-    public String getConstraints() {
-        return constraints;
-    }
-
-    public boolean isUnique() {
-        return unique;
-    }
-
-    public boolean isNotNull() {
-        return notNull;
-    }
-
-    public String getJavaType() {
-        return javaType;
-    }
-
-    public int getOrdinal() {
-        return ordinal;
-    }
-
-    public void setOrdinal(int ordinal) {
-        this.ordinal = ordinal;
-    }
-
-    public Entity getEntity() {
-        return entity;
-    }
-
-    void init2ndPass() {
-        initConstraint();
-        if (columnType == null) {
-            columnType = schema.mapToDbType(propertyType);
-        }
-        if (columnName == null) {
-            columnName = DaoUtil.dbName(propertyName);
-        }
-        if (notNull) {
-            javaType = schema.mapToJavaTypeNotNull(propertyType);
-        } else {
-            javaType = schema.mapToJavaTypeNullable(propertyType);
-        }
-    }
-
-    private void initConstraint() {
-        StringBuilder constraintBuilder = new StringBuilder();
-        if (primaryKey) {
-            constraintBuilder.append("PRIMARY KEY");
-            if (pkAsc) {
-                constraintBuilder.append(" ASC");
-            }
-            if (pkDesc) {
-                constraintBuilder.append(" DESC");
-            }
-            if (pkAutoincrement) {
-                constraintBuilder.append(" AUTOINCREMENT");
-            }
-        }
-        // Always have String PKs NOT NULL because SQLite is pretty strange in this respect:
-        // One could insert multiple rows with NULL PKs
-        if (notNull || (primaryKey && propertyType == PropertyType.String)) {
-            constraintBuilder.append(" NOT NULL");
-        }
-        if (unique) {
-            constraintBuilder.append(" UNIQUE");
-        }
-        String newContraints = constraintBuilder.toString().trim();
-        if (constraintBuilder.length() > 0) {
-            constraints = newContraints;
-        }
-    }
-
-    void init3ndPass() {
-        // Nothing to do so far
-    }
-
-    @Override
-    public String toString() {
-        return "Property " + propertyName + " of " + entity.getClassName();
-    }
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package de.greenrobot.daogenerator;
+
+/**
+ * Model class for an entity's property: a Java property mapped to a data base
+ * column.
+ */
+public class Property {
+
+    public static class PropertyBuilder {
+        private final Property property;
+
+        public PropertyBuilder(Schema schema, Entity entity, PropertyType propertyType,
+                String propertyName) {
+            property = new Property(schema, entity, propertyType, propertyName);
+        }
+
+        public PropertyBuilder columnName(String columnName) {
+            property.columnName = columnName;
+            return this;
+        }
+
+        public PropertyBuilder columnType(String columnType) {
+            property.columnType = columnType;
+            return this;
+        }
+
+        public PropertyBuilder primaryKey() {
+            property.primaryKey = true;
+            return this;
+        }
+
+        public PropertyBuilder primaryKeyAsc() {
+            property.primaryKey = true;
+            property.pkAsc = true;
+            return this;
+        }
+
+        public PropertyBuilder primaryKeyDesc() {
+            property.primaryKey = true;
+            property.pkDesc = true;
+            return this;
+        }
+
+        public PropertyBuilder autoincrement() {
+            if (!property.primaryKey || property.propertyType != PropertyType.Long) {
+                throw new RuntimeException(
+                        "AUTOINCREMENT is only available to primary key properties of type long/Long");
+            }
+            property.pkAutoincrement = true;
+            return this;
+        }
+
+        public PropertyBuilder unique() {
+            property.unique = true;
+            return this;
+        }
+
+        public PropertyBuilder notNull() {
+            property.notNull = true;
+            return this;
+        }
+
+        public PropertyBuilder index() {
+            Index index = new Index();
+            index.addProperty(property);
+            property.entity.addIndex(index);
+            return this;
+        }
+
+        public PropertyBuilder indexAsc(String indexNameOrNull, boolean isUnique) {
+            Index index = new Index();
+            index.addPropertyAsc(property);
+            if (isUnique) {
+                index.makeUnique();
+            }
+            index.setName(indexNameOrNull);
+            property.entity.addIndex(index);
+            return this;
+        }
+
+        public PropertyBuilder indexDesc(String indexNameOrNull, boolean isUnique) {
+            Index index = new Index();
+            index.addPropertyDesc(property);
+            if (isUnique) {
+                index.makeUnique();
+            }
+            index.setName(indexNameOrNull);
+            property.entity.addIndex(index);
+            return this;
+        }
+
+        public Property getProperty() {
+            return property;
+        }
+    }
+
+    private final Schema schema;
+    private final Entity entity;
+    private PropertyType propertyType;
+    private final String propertyName;
+    private final String propertyNameCamelCase;
+
+    private String columnName;
+    private String columnType;
+
+    private boolean primaryKey;
+    private boolean pkAsc;
+    private boolean pkDesc;
+    private boolean pkAutoincrement;
+
+    private boolean unique;
+    private boolean notNull;
+
+    /** Initialized in 2nd pass */
+    private String constraints;
+
+    private int ordinal;
+
+    private String javaType;
+
+    public Property(Schema schema, Entity entity, PropertyType propertyType, String propertyName) {
+        this.schema = schema;
+        this.entity = entity;
+        this.propertyName = propertyName;
+        this.propertyNameCamelCase = capitalizeString(propertyName);
+        this.propertyType = propertyType;
+    }
+
+    public String getPropertyName() {
+        return propertyName;
+    }
+
+    public String getPropertyNameCamelCase() {
+        return propertyNameCamelCase;
+    }
+
+    public PropertyType getPropertyType() {
+        return propertyType;
+    }
+
+    public void setPropertyType(PropertyType propertyType) {
+        this.propertyType = propertyType;
+    }
+
+    public String getColumnName() {
+        return columnName;
+    }
+
+    public String getColumnType() {
+        return columnType;
+    }
+
+    public boolean isPrimaryKey() {
+        return primaryKey;
+    }
+
+    public boolean isAutoincrement() {
+        return pkAutoincrement;
+    }
+
+    public String getConstraints() {
+        return constraints;
+    }
+
+    public boolean isUnique() {
+        return unique;
+    }
+
+    public boolean isNotNull() {
+        return notNull;
+    }
+
+    public String getJavaType() {
+        return javaType;
+    }
+
+    public int getOrdinal() {
+        return ordinal;
+    }
+
+    public void setOrdinal(int ordinal) {
+        this.ordinal = ordinal;
+    }
+
+    public Entity getEntity() {
+        return entity;
+    }
+
+    void init2ndPass() {
+        initConstraint();
+        if (columnType == null) {
+            columnType = schema.mapToDbType(propertyType);
+        }
+        if (columnName == null) {
+            columnName = DaoUtil.dbName(propertyName);
+        }
+        if (notNull) {
+            javaType = schema.mapToJavaTypeNotNull(propertyType);
+        } else {
+            javaType = schema.mapToJavaTypeNullable(propertyType);
+        }
+    }
+
+    private void initConstraint() {
+        StringBuilder constraintBuilder = new StringBuilder();
+        if (primaryKey) {
+            constraintBuilder.append("PRIMARY KEY");
+            if (pkAsc) {
+                constraintBuilder.append(" ASC");
+            }
+            if (pkDesc) {
+                constraintBuilder.append(" DESC");
+            }
+            if (pkAutoincrement) {
+                constraintBuilder.append(" AUTOINCREMENT");
+            }
+        }
+        // Always have String PKs NOT NULL because SQLite is pretty strange in
+        // this respect:
+        // One could insert multiple rows with NULL PKs
+        if (notNull || (primaryKey && propertyType == PropertyType.String)) {
+            constraintBuilder.append(" NOT NULL");
+        }
+        if (unique) {
+            constraintBuilder.append(" UNIQUE");
+        }
+        String newContraints = constraintBuilder.toString().trim();
+        if (constraintBuilder.length() > 0) {
+            constraints = newContraints;
+        }
+    }
+
+    void init3ndPass() {
+        // Nothing to do so far
+    }
+
+    @Override
+    public String toString() {
+        return "Property " + propertyName + " of " + entity.getClassName();
+    }
+
+    public static String capitalizeString(String string) {
+        char[] chars = string.toLowerCase().toCharArray();
+        StringBuilder sb = new StringBuilder();
+        boolean found = false;
+        for (int i = 0; i < chars.length; i++) {
+            if (!found && Character.isLetter(chars[i])) {
+                sb.append(Character.toUpperCase(chars[i]));
+                found = true;
+            } else if (Character.isWhitespace(chars[i]) || chars[i] == '_') { // You
+                                                                              // can
+                                                                              // add
+                                                                              // other
+                                                                              // chars
+                                                                              // here
+                found = false;
+            } else {
+                sb.append(Character.toLowerCase(chars[i]));
+            }
+        }
+        return sb.toString();
+    }
+}
