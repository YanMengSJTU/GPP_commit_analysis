diff --git a/DaoCore/assets/icudt46l.zip b/DaoCore/assets/icudt46l.zip
new file mode 100644
index 00000000..91dc7f71
Binary files /dev/null and b/DaoCore/assets/icudt46l.zip differ
diff --git a/DaoCore/build.gradle b/DaoCore/build.gradle
index 82f43a50..e9957ccd 100644
--- a/DaoCore/build.gradle
+++ b/DaoCore/build.gradle
@@ -33,6 +33,8 @@ dependencies {
     provided 'com.google.android:support-v4:r7'
     // deployerJars 'org.apache.maven.wagon:wagon-webdav-jackrabbit:2.4'
     deployerJars 'org.apache.maven.wagon:wagon-webdav:1.0-beta-2'
+    compile files('libs/sqlcipher.jar')
+    compile files('libs/sqlcipher-javadoc.jar')
 }
 
 sourceSets {
diff --git a/DaoCore/libs/armeabi-v7a/libdatabase_sqlcipher.so b/DaoCore/libs/armeabi-v7a/libdatabase_sqlcipher.so
new file mode 100644
index 00000000..7bafa31a
Binary files /dev/null and b/DaoCore/libs/armeabi-v7a/libdatabase_sqlcipher.so differ
diff --git a/DaoCore/libs/armeabi-v7a/libsqlcipher_android.so b/DaoCore/libs/armeabi-v7a/libsqlcipher_android.so
new file mode 100644
index 00000000..c19a7c4d
Binary files /dev/null and b/DaoCore/libs/armeabi-v7a/libsqlcipher_android.so differ
diff --git a/DaoCore/libs/armeabi-v7a/libstlport_shared.so b/DaoCore/libs/armeabi-v7a/libstlport_shared.so
new file mode 100644
index 00000000..0ec49f44
Binary files /dev/null and b/DaoCore/libs/armeabi-v7a/libstlport_shared.so differ
diff --git a/DaoCore/libs/armeabi/libdatabase_sqlcipher.so b/DaoCore/libs/armeabi/libdatabase_sqlcipher.so
new file mode 100644
index 00000000..dfc03dde
Binary files /dev/null and b/DaoCore/libs/armeabi/libdatabase_sqlcipher.so differ
diff --git a/DaoCore/libs/armeabi/libsqlcipher_android.so b/DaoCore/libs/armeabi/libsqlcipher_android.so
new file mode 100644
index 00000000..d4d095c5
Binary files /dev/null and b/DaoCore/libs/armeabi/libsqlcipher_android.so differ
diff --git a/DaoCore/libs/armeabi/libstlport_shared.so b/DaoCore/libs/armeabi/libstlport_shared.so
new file mode 100644
index 00000000..050818bb
Binary files /dev/null and b/DaoCore/libs/armeabi/libstlport_shared.so differ
diff --git a/DaoCore/libs/sqlcipher-javadoc.jar b/DaoCore/libs/sqlcipher-javadoc.jar
new file mode 100644
index 00000000..ffaa00f4
Binary files /dev/null and b/DaoCore/libs/sqlcipher-javadoc.jar differ
diff --git a/DaoCore/libs/sqlcipher.jar b/DaoCore/libs/sqlcipher.jar
new file mode 100644
index 00000000..4d91f837
Binary files /dev/null and b/DaoCore/libs/sqlcipher.jar differ
diff --git a/DaoCore/libs/x86/libdatabase_sqlcipher.so b/DaoCore/libs/x86/libdatabase_sqlcipher.so
new file mode 100644
index 00000000..0d7871fe
Binary files /dev/null and b/DaoCore/libs/x86/libdatabase_sqlcipher.so differ
diff --git a/DaoCore/libs/x86/libsqlcipher_android.so b/DaoCore/libs/x86/libsqlcipher_android.so
new file mode 100644
index 00000000..51620697
Binary files /dev/null and b/DaoCore/libs/x86/libsqlcipher_android.so differ
diff --git a/DaoCore/libs/x86/libstlport_shared.so b/DaoCore/libs/x86/libstlport_shared.so
new file mode 100644
index 00000000..a5e8b357
Binary files /dev/null and b/DaoCore/libs/x86/libstlport_shared.so differ
diff --git a/DaoCore/project.properties b/DaoCore/project.properties
index 96db7421..ca813240 100644
--- a/DaoCore/project.properties
+++ b/DaoCore/project.properties
@@ -9,4 +9,4 @@
 
 android.library=true
 # Project target.
-target=android-4
+target=android-21
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDao.java b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
index 51349dfb..ad0f90c7 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDao.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
@@ -16,17 +16,15 @@
 
 package de.greenrobot.dao;
 
+import android.database.CrossProcessCursor;
+import android.database.Cursor;
+import android.database.CursorWindow;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
 
-import android.database.CrossProcessCursor;
-import android.database.Cursor;
-import android.database.CursorWindow;
-import android.database.DatabaseUtils;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
 import de.greenrobot.dao.identityscope.IdentityScope;
 import de.greenrobot.dao.identityscope.IdentityScopeLong;
 import de.greenrobot.dao.internal.DaoConfig;
@@ -34,6 +32,9 @@
 import de.greenrobot.dao.internal.TableStatements;
 import de.greenrobot.dao.query.Query;
 import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.dao.wrapper.DatabaseUtils;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 
 /**
  * Base class for all DAOs: Implements entity operations like insert, load, delete, and query.
@@ -57,7 +58,7 @@
  * 3.) identityScope
  */
 public abstract class AbstractDao<T, K> {
-    protected final SQLiteDatabase db;
+    protected final SQLiteDatabaseWrapper db;
     protected final DaoConfig config;
     protected IdentityScope<K, T> identityScope;
     protected IdentityScopeLong<T> identityScopeLong;
@@ -217,7 +218,7 @@ public void insertInTx(T... entities) {
      *            if true, the PKs of the given will be set after the insert; pass false to improve performance.
      */
     public void insertInTx(Iterable<T> entities, boolean setPrimaryKey) {
-        SQLiteStatement stmt = statements.getInsertStatement();
+        SQLiteStatementWrapper stmt = statements.getInsertStatement();
         executeInsertInTx(stmt, entities, setPrimaryKey);
     }
 
@@ -231,7 +232,7 @@ public void insertInTx(Iterable<T> entities, boolean setPrimaryKey) {
      *            if true, the PKs of the given will be set after the insert; pass false to improve performance.
      */
     public void insertOrReplaceInTx(Iterable<T> entities, boolean setPrimaryKey) {
-        SQLiteStatement stmt = statements.getInsertOrReplaceStatement();
+        SQLiteStatementWrapper stmt = statements.getInsertOrReplaceStatement();
         executeInsertInTx(stmt, entities, setPrimaryKey);
     }
 
@@ -255,7 +256,7 @@ public void insertOrReplaceInTx(T... entities) {
         insertOrReplaceInTx(Arrays.asList(entities), isEntityUpdateable());
     }
 
-    private void executeInsertInTx(SQLiteStatement stmt, Iterable<T> entities, boolean setPrimaryKey) {
+    private void executeInsertInTx(SQLiteStatementWrapper stmt, Iterable<T> entities, boolean setPrimaryKey) {
         db.beginTransaction();
         try {
             synchronized (stmt) {
@@ -300,7 +301,7 @@ public long insert(T entity) {
      * @return row ID of newly inserted entity
      */
     public long insertWithoutSettingPk(T entity) {
-        SQLiteStatement stmt = statements.getInsertStatement();
+        SQLiteStatementWrapper stmt = statements.getInsertStatement();
         long rowId;
         if (db.isDbLockedByCurrentThread()) {
             synchronized (stmt) {
@@ -332,7 +333,7 @@ public long insertOrReplace(T entity) {
         return executeInsert(entity, statements.getInsertOrReplaceStatement());
     }
 
-    private long executeInsert(T entity, SQLiteStatement stmt) {
+    private long executeInsert(T entity, SQLiteStatementWrapper stmt) {
         long rowId;
         if (db.isDbLockedByCurrentThread()) {
             synchronized (stmt) {
@@ -500,7 +501,7 @@ public void delete(T entity) {
     /** Deletes an entity with the given PK from the database. Currently, only single value PK entities are supported. */
     public void deleteByKey(K key) {
         assertSinglePk();
-        SQLiteStatement stmt = statements.getDeleteStatement();
+        SQLiteStatementWrapper stmt = statements.getDeleteStatement();
         if (db.isDbLockedByCurrentThread()) {
             synchronized (stmt) {
                 deleteByKeyInsideSynchronized(key, stmt);
@@ -522,7 +523,7 @@ public void deleteByKey(K key) {
         }
     }
 
-    private void deleteByKeyInsideSynchronized(K key, SQLiteStatement stmt) {
+    private void deleteByKeyInsideSynchronized(K key, SQLiteStatementWrapper stmt) {
         if (key instanceof Long) {
             stmt.bindLong(1, (Long) key);
         } else if (key == null) {
@@ -535,7 +536,7 @@ private void deleteByKeyInsideSynchronized(K key, SQLiteStatement stmt) {
 
     private void deleteInTxInternal(Iterable<T> entities, Iterable<K> keys) {
         assertSinglePk();
-        SQLiteStatement stmt = statements.getDeleteStatement();
+        SQLiteStatementWrapper stmt = statements.getDeleteStatement();
         List<K> keysToRemoveFromIdentityScope = null;
         db.beginTransaction();
         try {
@@ -641,7 +642,7 @@ public void refresh(T entity) {
 
     public void update(T entity) {
         assertSinglePk();
-        SQLiteStatement stmt = statements.getUpdateStatement();
+        SQLiteStatementWrapper stmt = statements.getUpdateStatement();
         if (db.isDbLockedByCurrentThread()) {
             synchronized (stmt) {
                 updateInsideSynchronized(entity, stmt, true);
@@ -664,7 +665,7 @@ public void update(T entity) {
         return QueryBuilder.internalCreate(this);
     }
 
-    protected void updateInsideSynchronized(T entity, SQLiteStatement stmt, boolean lock) {
+    protected void updateInsideSynchronized(T entity, SQLiteStatementWrapper stmt, boolean lock) {
         // To do? Check if it's worth not to bind PKs here (performance).
         bindValues(stmt, entity);
         int index = config.allColumns.length + 1;
@@ -716,7 +717,7 @@ protected void attachEntity(T entity) {
      *            The entities to insert.
      */
     public void updateInTx(Iterable<T> entities) {
-        SQLiteStatement stmt = statements.getUpdateStatement();
+        SQLiteStatementWrapper stmt = statements.getUpdateStatement();
         db.beginTransaction();
         RuntimeException txEx = null;
         try {
@@ -786,7 +787,7 @@ protected K getKeyVerified(T entity) {
     }
 
     /** Gets the SQLiteDatabase for custom database access. Not needed for greenDAO entities. */
-    public SQLiteDatabase getDatabase() {
+    public SQLiteDatabaseWrapper getDatabase() {
         return db;
     }
 
@@ -800,7 +801,7 @@ public SQLiteDatabase getDatabase() {
     abstract protected void readEntity(Cursor cursor, T entity, int offset);
 
     /** Binds the entity's values to the statement. Make sure to synchronize the statement outside of the method. */
-    abstract protected void bindValues(SQLiteStatement stmt, T entity);
+    abstract protected void bindValues(SQLiteStatementWrapper stmt, T entity);
 
     /**
      * Updates the entity's key if possible (only for Long PKs currently). This method must always return the entity's
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDaoMaster.java b/DaoCore/src/de/greenrobot/dao/AbstractDaoMaster.java
index 5b635bcd..50acf9c6 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDaoMaster.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDaoMaster.java
@@ -19,7 +19,7 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import android.database.sqlite.SQLiteDatabase;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
 import de.greenrobot.dao.identityscope.IdentityScopeType;
 import de.greenrobot.dao.internal.DaoConfig;
 
@@ -29,11 +29,11 @@
  * @author Markus
  */
 public abstract class AbstractDaoMaster {
-    protected final SQLiteDatabase db;
+    protected final SQLiteDatabaseWrapper db;
     protected final int schemaVersion;
     protected final Map<Class<? extends AbstractDao<?, ?>>, DaoConfig> daoConfigMap;
 
-    public AbstractDaoMaster(SQLiteDatabase db, int schemaVersion) {
+    public AbstractDaoMaster(SQLiteDatabaseWrapper db, int schemaVersion) {
         this.db = db;
         this.schemaVersion = schemaVersion;
 
@@ -50,7 +50,7 @@ public int getSchemaVersion() {
     }
 
     /** Gets the SQLiteDatabase for custom database access. Not needed for greenDAO entities. */
-    public SQLiteDatabase getDatabase() {
+    public SQLiteDatabaseWrapper getDatabase() {
         return db;
     }
 
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java b/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
index 6a37ef2a..b41b6ad4 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
@@ -20,7 +20,7 @@
 import java.util.Map;
 import java.util.concurrent.Callable;
 
-import android.database.sqlite.SQLiteDatabase;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
 import de.greenrobot.dao.async.AsyncSession;
 import de.greenrobot.dao.query.QueryBuilder;
 
@@ -44,10 +44,10 @@
  * 
  */
 public class AbstractDaoSession {
-    private final SQLiteDatabase db;
+    private final SQLiteDatabaseWrapper db;
     private final Map<Class<?>, AbstractDao<?, ?>> entityToDao;
 
-    public AbstractDaoSession(SQLiteDatabase db) {
+    public AbstractDaoSession(SQLiteDatabaseWrapper db) {
         this.db = db;
         this.entityToDao = new HashMap<Class<?>, AbstractDao<?, ?>>();
     }
@@ -183,7 +183,7 @@ public void runInTx(Runnable runnable) {
     }
 
     /** Gets the SQLiteDatabase for custom database access. Not needed for greenDAO entities. */
-    public SQLiteDatabase getDatabase() {
+    public SQLiteDatabaseWrapper getDatabase() {
         return db;
     }
 
diff --git a/DaoCore/src/de/greenrobot/dao/DbUtils.java b/DaoCore/src/de/greenrobot/dao/DbUtils.java
index 62e5c976..96cf8d20 100644
--- a/DaoCore/src/de/greenrobot/dao/DbUtils.java
+++ b/DaoCore/src/de/greenrobot/dao/DbUtils.java
@@ -16,30 +16,31 @@
 
 package de.greenrobot.dao;
 
+import android.content.Context;
+import android.database.Cursor;
+import android.database.DatabaseUtils;
+
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 
-import android.content.Context;
-import android.database.Cursor;
-import android.database.DatabaseUtils;
-import android.database.sqlite.SQLiteDatabase;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
 
 /** Database utils, for example to execute SQL scripts */
 // TODO add unit tests
 public class DbUtils {
 
-    public static void vacuum(SQLiteDatabase db) {
+    public static void vacuum(SQLiteDatabaseWrapper db) {
         db.execSQL("VACUUM");
     }
 
     /**
-     * Calls {@link #executeSqlScript(Context, SQLiteDatabase, String, boolean)} with transactional set to true.
+     * Calls {@link #executeSqlScript(Context, SQLiteDatabaseWrapper, String, boolean)} with transactional set to true.
      * 
      * @return number of statements executed.
      */
-    public static int executeSqlScript(Context context, SQLiteDatabase db, String assetFilename) throws IOException {
+    public static int executeSqlScript(Context context, SQLiteDatabaseWrapper db, String assetFilename) throws IOException {
         return executeSqlScript(context, db, assetFilename, true);
     }
 
@@ -51,7 +52,7 @@ public static int executeSqlScript(Context context, SQLiteDatabase db, String as
      * 
      * @return number of statements executed.
      */
-    public static int executeSqlScript(Context context, SQLiteDatabase db, String assetFilename, boolean transactional)
+    public static int executeSqlScript(Context context, SQLiteDatabaseWrapper db, String assetFilename, boolean transactional)
             throws IOException {
         byte[] bytes = readAsset(context, assetFilename);
         String sql = new String(bytes, "UTF-8");
@@ -66,7 +67,7 @@ public static int executeSqlScript(Context context, SQLiteDatabase db, String as
         return count;
     }
 
-    public static int executeSqlStatementsInTx(SQLiteDatabase db, String[] statements) {
+    public static int executeSqlStatementsInTx(SQLiteDatabaseWrapper db, String[] statements) {
         db.beginTransaction();
         try {
             int count = executeSqlStatements(db, statements);
@@ -77,7 +78,7 @@ public static int executeSqlStatementsInTx(SQLiteDatabase db, String[] statement
         }
     }
 
-    public static int executeSqlStatements(SQLiteDatabase db, String[] statements) {
+    public static int executeSqlStatements(SQLiteDatabaseWrapper db, String[] statements) {
         int count = 0;
         for (String line : statements) {
             line = line.trim();
@@ -123,7 +124,7 @@ public static int copyAllBytes(InputStream in, OutputStream out) throws IOExcept
         }
     }
 
-    public static void logTableDump(SQLiteDatabase db, String tablename) {
+    public static void logTableDump(SQLiteDatabaseWrapper db, String tablename) {
         Cursor cursor = db.query(tablename, null, null, null, null, null, null);
         try {
             String dump = DatabaseUtils.dumpCursorToString(cursor);
diff --git a/DaoCore/src/de/greenrobot/dao/InternalUnitTestDaoAccess.java b/DaoCore/src/de/greenrobot/dao/InternalUnitTestDaoAccess.java
index 78df9030..8c43a3ef 100644
--- a/DaoCore/src/de/greenrobot/dao/InternalUnitTestDaoAccess.java
+++ b/DaoCore/src/de/greenrobot/dao/InternalUnitTestDaoAccess.java
@@ -16,18 +16,19 @@
 
 package de.greenrobot.dao;
 
+import android.database.Cursor;
+
 import java.lang.reflect.Constructor;
 
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.identityscope.IdentityScope;
 import de.greenrobot.dao.internal.DaoConfig;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
 
 /** Reserved for internal unit tests that want to access some non-public methods. Don't use for anything else. */
 public class InternalUnitTestDaoAccess<T, K> {
     private final AbstractDao<T, K> dao;
 
-    public InternalUnitTestDaoAccess(SQLiteDatabase db, Class<AbstractDao<T, K>> daoClass, IdentityScope<?, ?> identityScope)
+    public InternalUnitTestDaoAccess(SQLiteDatabaseWrapper db, Class<AbstractDao<T, K>> daoClass, IdentityScope<?, ?> identityScope)
             throws Exception {
         DaoConfig daoConfig = new DaoConfig(db, daoClass);
         daoConfig.setIdentityScope(identityScope);
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncOperation.java b/DaoCore/src/de/greenrobot/dao/async/AsyncOperation.java
index 38136065..f6b3d5c7 100644
--- a/DaoCore/src/de/greenrobot/dao/async/AsyncOperation.java
+++ b/DaoCore/src/de/greenrobot/dao/async/AsyncOperation.java
@@ -16,9 +16,9 @@
 
 package de.greenrobot.dao.async;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
 
 /**
  * An operation that will be enqueued for asynchronous execution.
@@ -48,7 +48,7 @@
 
     final OperationType type;
     final AbstractDao<Object, Object> dao;
-    private final SQLiteDatabase database;
+    private final SQLiteDatabaseWrapper database;
     /** Entity, Iterable<Entity>, Entity[], or Runnable. */
     final Object parameter;
     final int flags;
@@ -65,7 +65,7 @@
 
     @SuppressWarnings("unchecked")
     /** Either supply dao or database (set other to null). */
-    AsyncOperation(OperationType type, AbstractDao<?, ?> dao, SQLiteDatabase database, Object parameter, int flags) {
+    AsyncOperation(OperationType type, AbstractDao<?, ?> dao, SQLiteDatabaseWrapper database, Object parameter, int flags) {
         this.type = type;
         this.flags = flags;
         this.dao = (AbstractDao<Object, Object>) dao;
@@ -112,7 +112,7 @@ public boolean isMergeTx() {
         return (flags & FLAG_MERGE_TX) != 0;
     }
 
-    SQLiteDatabase getDatabase() {
+    SQLiteDatabaseWrapper getDatabase() {
         return database != null ? database : dao.getDatabase();
     }
 
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java b/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java
index d57c1f74..221d3d81 100644
--- a/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java
+++ b/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java
@@ -15,13 +15,9 @@
  */
 package de.greenrobot.dao.async;
 
-import android.database.sqlite.SQLiteDatabase;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
-import de.greenrobot.dao.DaoException;
-import de.greenrobot.dao.DaoLog;
-import de.greenrobot.dao.query.Query;
 
 import java.util.ArrayList;
 import java.util.concurrent.BlockingQueue;
@@ -31,6 +27,11 @@
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
 
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+
 class AsyncOperationExecutor implements Runnable, Handler.Callback {
 
     private static ExecutorService executorService = Executors.newCachedThreadPool();
@@ -181,7 +182,7 @@ private void mergeTxAndExecute(AsyncOperation operation1, AsyncOperation operati
         mergedOps.add(operation1);
         mergedOps.add(operation2);
 
-        SQLiteDatabase db = operation1.getDatabase();
+        SQLiteDatabaseWrapper db = operation1.getDatabase();
         db.beginTransaction();
         boolean success = false;
         try {
@@ -342,7 +343,7 @@ private void executeOperation(AsyncOperation operation) {
     }
 
     private void executeTransactionRunnable(AsyncOperation operation) {
-        SQLiteDatabase db = operation.getDatabase();
+        SQLiteDatabaseWrapper db = operation.getDatabase();
         db.beginTransaction();
         try {
             ((Runnable) operation.parameter).run();
@@ -354,7 +355,7 @@ private void executeTransactionRunnable(AsyncOperation operation) {
 
     @SuppressWarnings("unchecked")
     private void executeTransactionCallable(AsyncOperation operation) throws Exception {
-        SQLiteDatabase db = operation.getDatabase();
+        SQLiteDatabaseWrapper db = operation.getDatabase();
         db.beginTransaction();
         try {
             operation.result = ((Callable<Object>) operation.parameter).call();
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncSession.java b/DaoCore/src/de/greenrobot/dao/async/AsyncSession.java
index e21257a6..51d02ddb 100644
--- a/DaoCore/src/de/greenrobot/dao/async/AsyncSession.java
+++ b/DaoCore/src/de/greenrobot/dao/async/AsyncSession.java
@@ -1,13 +1,13 @@
 package de.greenrobot.dao.async;
 
-import android.database.sqlite.SQLiteDatabase;
+import java.util.concurrent.Callable;
+
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.AbstractDaoSession;
 import de.greenrobot.dao.DaoException;
 import de.greenrobot.dao.async.AsyncOperation.OperationType;
 import de.greenrobot.dao.query.Query;
-
-import java.util.concurrent.Callable;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
 
 /**
  * Asynchronous interface to entity operations. All operations will enqueued a @link {@link AsyncOperation} and return
@@ -305,7 +305,7 @@ public AsyncOperation refresh(Object entity, int flags) {
     }
 
     private AsyncOperation enqueueDatabaseOperation(OperationType type, Object param, int flags) {
-        SQLiteDatabase database = daoSession.getDatabase();
+        SQLiteDatabaseWrapper database = daoSession.getDatabase();
         AsyncOperation operation = new AsyncOperation(type, null, database, param, flags | sessionFlags);
         executor.enqueue(operation);
         return operation;
diff --git a/DaoCore/src/de/greenrobot/dao/internal/DaoConfig.java b/DaoCore/src/de/greenrobot/dao/internal/DaoConfig.java
index 96473029..5519ecb5 100644
--- a/DaoCore/src/de/greenrobot/dao/internal/DaoConfig.java
+++ b/DaoCore/src/de/greenrobot/dao/internal/DaoConfig.java
@@ -20,7 +20,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import android.database.sqlite.SQLiteDatabase;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoException;
 import de.greenrobot.dao.Property;
@@ -35,7 +35,7 @@
  */
 public final class DaoConfig implements Cloneable {
 
-    public final SQLiteDatabase db;
+    public final SQLiteDatabaseWrapper db;
     public final String tablename;
     public final Property[] properties;
 
@@ -50,7 +50,7 @@
 
     private IdentityScope<?, ?> identityScope;
 
-    public DaoConfig(SQLiteDatabase db, Class<? extends AbstractDao<?, ?>> daoClass) {
+    public DaoConfig(SQLiteDatabaseWrapper db, Class<? extends AbstractDao<?, ?>> daoClass) {
         this.db = db;
         try {
             this.tablename = (String) daoClass.getField("TABLENAME").get(null);
diff --git a/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java b/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java
index 9414f1f7..7482f415 100644
--- a/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java
+++ b/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java
@@ -15,34 +15,34 @@
  */
 package de.greenrobot.dao.internal;
 
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 
 /** Helper class to create SQL statements for specific tables (used by greenDAO internally). */
 public class TableStatements {
-    private final SQLiteDatabase db;
+    private final SQLiteDatabaseWrapper db;
     private final String tablename;
     private final String[] allColumns;
     private final String[] pkColumns;
 
-    private SQLiteStatement insertStatement;
-    private SQLiteStatement insertOrReplaceStatement;
-    private SQLiteStatement updateStatement;
-    private SQLiteStatement deleteStatement;
+    private SQLiteStatementWrapper insertStatement;
+    private SQLiteStatementWrapper insertOrReplaceStatement;
+    private SQLiteStatementWrapper updateStatement;
+    private SQLiteStatementWrapper deleteStatement;
 
     private volatile String selectAll;
     private volatile String selectByKey;
     private volatile String selectByRowId;
     private volatile String selectKeys;
 
-    public TableStatements(SQLiteDatabase db, String tablename, String[] allColumns, String[] pkColumns) {
+    public TableStatements(SQLiteDatabaseWrapper db, String tablename, String[] allColumns, String[] pkColumns) {
         this.db = db;
         this.tablename = tablename;
         this.allColumns = allColumns;
         this.pkColumns = pkColumns;
     }
 
-    public SQLiteStatement getInsertStatement() {
+    public SQLiteStatementWrapper getInsertStatement() {
         if (insertStatement == null) {
             String sql = SqlUtils.createSqlInsert("INSERT INTO ", tablename, allColumns);
             insertStatement = db.compileStatement(sql);
@@ -50,7 +50,7 @@ public SQLiteStatement getInsertStatement() {
         return insertStatement;
     }
 
-    public SQLiteStatement getInsertOrReplaceStatement() {
+    public SQLiteStatementWrapper getInsertOrReplaceStatement() {
         if (insertOrReplaceStatement == null) {
             String sql = SqlUtils.createSqlInsert("INSERT OR REPLACE INTO ", tablename, allColumns);
             insertOrReplaceStatement = db.compileStatement(sql);
@@ -58,7 +58,7 @@ public SQLiteStatement getInsertOrReplaceStatement() {
         return insertOrReplaceStatement;
     }
 
-    public SQLiteStatement getDeleteStatement() {
+    public SQLiteStatementWrapper getDeleteStatement() {
         if (deleteStatement == null) {
             String sql = SqlUtils.createSqlDelete(tablename, pkColumns);
             deleteStatement = db.compileStatement(sql);
@@ -66,7 +66,7 @@ public SQLiteStatement getDeleteStatement() {
         return deleteStatement;
     }
 
-    public SQLiteStatement getUpdateStatement() {
+    public SQLiteStatementWrapper getUpdateStatement() {
         if (updateStatement == null) {
             String sql = SqlUtils.createSqlUpdate(tablename, allColumns, pkColumns);
             updateStatement = db.compileStatement(sql);
diff --git a/DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java b/DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java
index 983e3720..93eed36c 100644
--- a/DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java
+++ b/DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java
@@ -15,8 +15,8 @@
  */
 package de.greenrobot.dao.query;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
 
 /**
  * A repeatable query for deleting entities.<br/>
@@ -63,7 +63,7 @@ private DeleteQuery(QueryData<T> queryData, AbstractDao<T, ?> dao, String sql, S
      */
     public void executeDeleteWithoutDetachingEntities() {
         checkThread();
-        SQLiteDatabase db = dao.getDatabase();
+        SQLiteDatabaseWrapper db = dao.getDatabase();
         if (db.isDbLockedByCurrentThread()) {
             dao.getDatabase().execSQL(sql, parameters);
         } else {
diff --git a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoSessionTest.java b/DaoCore/src/de/greenrobot/dao/test/AbstractDaoSessionTest.java
index aa94a156..afab28fc 100644
--- a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoSessionTest.java
+++ b/DaoCore/src/de/greenrobot/dao/test/AbstractDaoSessionTest.java
@@ -19,9 +19,9 @@
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDaoMaster;
 import de.greenrobot.dao.AbstractDaoSession;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
 
 /**
  * Base class for DAO (master) related testing.
@@ -52,10 +52,10 @@ public AbstractDaoSessionTest(Class<T> daoMasterClass, boolean inMemory) {
     protected void setUp() throws Exception {
         super.setUp();
         try {
-            Constructor<T> constructor = daoMasterClass.getConstructor(SQLiteDatabase.class);
+            Constructor<T> constructor = daoMasterClass.getConstructor(SQLiteDatabaseWrapper.class);
             daoMaster = constructor.newInstance(db);
 
-            Method createTableMethod = daoMasterClass.getMethod("createAllTables", SQLiteDatabase.class, boolean.class);
+            Method createTableMethod = daoMasterClass.getMethod("createAllTables", SQLiteDatabaseWrapper.class, boolean.class);
             createTableMethod.invoke(null, db, false);
         } catch (Exception e) {
             throw new RuntimeException("Could not prepare DAO session test", e);
diff --git a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTest.java b/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTest.java
index 6c301da7..a324231d 100644
--- a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTest.java
+++ b/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTest.java
@@ -18,12 +18,12 @@
 
 import java.lang.reflect.Method;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoLog;
 import de.greenrobot.dao.InternalUnitTestDaoAccess;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.identityscope.IdentityScope;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
 
 /**
  * Base class for DAO related testing. Prepares an in-memory DB and DAO.
@@ -73,7 +73,7 @@ protected void setUp() throws Exception {
 
     protected void setUpTableForDao() throws Exception {
         try {
-            Method createTableMethod = daoClass.getMethod("createTable", SQLiteDatabase.class, boolean.class);
+            Method createTableMethod = daoClass.getMethod("createTable", SQLiteDatabaseWrapper.class, boolean.class);
             createTableMethod.invoke(null, db, false);
         } catch (NoSuchMethodException e) {
             DaoLog.i("No createTable method");
diff --git a/DaoCore/src/de/greenrobot/dao/test/DbTest.java b/DaoCore/src/de/greenrobot/dao/test/DbTest.java
index 6788eca0..782b277a 100644
--- a/DaoCore/src/de/greenrobot/dao/test/DbTest.java
+++ b/DaoCore/src/de/greenrobot/dao/test/DbTest.java
@@ -18,12 +18,14 @@
 
 import android.app.Application;
 import android.app.Instrumentation;
-import android.database.sqlite.SQLiteDatabase;
+import android.content.Context;
 import android.test.AndroidTestCase;
-import de.greenrobot.dao.DbUtils;
 
 import java.util.Random;
 
+import de.greenrobot.dao.DbUtils;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+
 /**
  * Base class for database related testing, which prepares an in-memory or an file-based DB (using the test {@link
  * android.content.Context}). Also, offers some convenience methods to create new {@link Application} objects similar to
@@ -41,7 +43,7 @@
 
     protected final Random random;
     protected final boolean inMemory;
-    protected SQLiteDatabase db;
+    protected SQLiteDatabaseWrapper db;
 
     private Application application;
 
@@ -88,12 +90,12 @@ public void terminateApplication() {
     }
 
     /** May be overriden by sub classes to set up a different db. */
-    protected SQLiteDatabase createDatabase() {
+    protected SQLiteDatabaseWrapper createDatabase() {
         if (inMemory) {
-            return SQLiteDatabase.create(null);
+            return SQLiteDatabaseWrapper.create(null,null);
         } else {
             getContext().deleteDatabase(DB_NAME);
-            return getContext().openOrCreateDatabase(DB_NAME, 0, null);
+            return new SQLiteDatabaseWrapper(getApplication().openOrCreateDatabase("test-db", Context.MODE_PRIVATE, null));
         }
     }
 
diff --git a/DaoCore/src/de/greenrobot/dao/wrapper/DatabaseUtils.java b/DaoCore/src/de/greenrobot/dao/wrapper/DatabaseUtils.java
new file mode 100644
index 00000000..62eb86b3
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/wrapper/DatabaseUtils.java
@@ -0,0 +1,28 @@
+package de.greenrobot.dao.wrapper;
+
+import android.database.Cursor;
+
+public class DatabaseUtils {
+
+	private static final String[] countProjection = new String[] { "count(*)" };
+
+	/**
+	 * Query the table for the number of rows in the table.
+	 * 
+	 * @param db
+	 *            the database the table is in
+	 * @param table
+	 *            the name of the table to query
+	 * @return the number of rows in the table
+	 */
+	public static long queryNumEntries(SQLiteDatabaseWrapper db, String table) {
+		Cursor cursor = db.query(table, countProjection, null, null, null, null, null);
+		try {
+			cursor.moveToFirst();
+			return cursor.getLong(0);
+		} finally {
+			cursor.close();
+		}
+	}
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteDatabaseHook.java b/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteDatabaseHook.java
new file mode 100644
index 00000000..f5b1e217
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteDatabaseHook.java
@@ -0,0 +1,5 @@
+package de.greenrobot.dao.wrapper;
+
+public interface SQLiteDatabaseHook extends net.sqlcipher.database.SQLiteDatabaseHook {
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteDatabaseWrapper.java b/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteDatabaseWrapper.java
new file mode 100644
index 00000000..67cba1b4
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteDatabaseWrapper.java
@@ -0,0 +1,958 @@
+package de.greenrobot.dao.wrapper;
+
+import java.io.File;
+import java.lang.ref.WeakReference;
+import java.util.HashSet;
+import java.util.Locale;
+import java.util.Map;
+import java.util.concurrent.locks.ReentrantLock;
+
+import net.sqlcipher.database.SQLiteDatabaseCorruptException;
+import net.sqlcipher.database.SQLiteDebug;
+import net.sqlcipher.database.SQLiteTransactionListener;
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteDatabase.CursorFactory;
+import android.database.sqlite.SQLiteException;
+import android.database.sqlite.SQLiteProgram;
+import android.database.sqlite.SQLiteStatement;
+import android.os.Debug;
+import android.os.SystemClock;
+import android.util.Log;
+import de.greenrobot.dao.wrapper.exception.NotSupportedOperationAndroidException;
+
+public class SQLiteDatabaseWrapper {
+
+	private static final String TAG = SQLiteDatabaseWrapper.class.getSimpleName();
+
+	/**
+	 * If set then the SQLiteDatabase is made thread-safe by using locks around critical sections
+	 */
+	private boolean mLockingEnabled = true;
+
+	/** Synchronize on this when accessing the database */
+	private final ReentrantLock mLock = new ReentrantLock(true);
+
+	private long mLockAcquiredWallTime = 0L;
+	private long mLockAcquiredThreadTime = 0L;
+	private long mLastLockMessageTime = 0L;
+
+	// limit the frequency of complaints about each database to one within 20 sec
+	// unless run command adb shell setprop log.tag.Database VERBOSE
+	private static final int LOCK_WARNING_WINDOW_IN_MS = 20000;
+	/** If the lock is held this long then a warning will be printed when it is released. */
+	private static final int LOCK_ACQUIRED_WARNING_TIME_IN_MS = 300;
+	private static final int LOCK_ACQUIRED_WARNING_THREAD_TIME_IN_MS = 100;
+	private static final int LOCK_ACQUIRED_WARNING_TIME_IN_MS_ALWAYS_PRINT = 2000;
+
+	private final SQLiteDatabase sqliteDatabase;
+	private final net.sqlcipher.database.SQLiteDatabase sqlCypheredDatabase;
+
+	private SQLiteDatabaseWrapper(String path, char[] password, CursorFactory factory, int flags, SQLiteDatabaseHook databaseHook) {
+		if (password == null || password.length == 0) {
+			sqliteDatabase = SQLiteDatabase.openDatabase(path, factory, flags);
+			sqlCypheredDatabase = null;
+		} else {
+			sqliteDatabase = null;
+			sqlCypheredDatabase = new net.sqlcipher.database.SQLiteDatabase(path, password, (net.sqlcipher.database.SQLiteDatabase.CursorFactory) factory, flags, databaseHook);
+		}
+	}
+
+	public SQLiteDatabaseWrapper(SQLiteDatabase sqliteDatabase) {
+		this.sqliteDatabase = sqliteDatabase;
+		this.sqlCypheredDatabase = null;
+	}
+
+	public SQLiteDatabaseWrapper(net.sqlcipher.database.SQLiteDatabase sqlCypheredDatabase) {
+		this.sqliteDatabase = null;
+		this.sqlCypheredDatabase = sqlCypheredDatabase;
+	}
+
+	public boolean isCypheredDb() {
+		return sqlCypheredDatabase != null;
+	}
+
+	public static void loadLibs(Context context) {
+		net.sqlcipher.database.SQLiteDatabase.loadLibs(context);
+	}
+
+	public static void loadLibs(Context context, File workingDir) {
+		net.sqlcipher.database.SQLiteDatabase.loadLibs(context, workingDir);
+	}
+
+	public static int releaseMemory() {
+		return net.sqlcipher.database.SQLiteDatabase.releaseMemory() + SQLiteDatabase.releaseMemory();
+	}
+
+	public void setLockingEnabled(boolean lockingEnabled) {
+		if (isCypheredDb())
+			sqlCypheredDatabase.setLockingEnabled(lockingEnabled);
+		else
+			sqliteDatabase.setLockingEnabled(lockingEnabled);
+	}
+
+	public void beginTransaction() {
+		if (isCypheredDb())
+			sqlCypheredDatabase.beginTransaction();
+		else
+			sqliteDatabase.beginTransaction();
+	}
+
+	public void beginTransactionWithListener(SQLiteTransactionListener transactionListener) {
+		if (isCypheredDb())
+			sqlCypheredDatabase.beginTransactionWithListener(transactionListener);
+		else
+			throw new NotSupportedOperationAndroidException();
+	}
+
+	public void setTransactionSuccessful() {
+		if (isCypheredDb())
+			sqlCypheredDatabase.setTransactionSuccessful();
+		else
+			sqliteDatabase.setTransactionSuccessful();
+	}
+
+	public void endTransaction() {
+		if (isCypheredDb())
+			sqlCypheredDatabase.endTransaction();
+		else
+			sqliteDatabase.endTransaction();
+	}
+
+	/**
+	 * return true if there is a transaction pending
+	 */
+	public boolean inTransaction() {
+		return isCypheredDb() ? sqlCypheredDatabase.inTransaction() : sqliteDatabase.inTransaction();
+	}
+
+	/**
+	 * Checks if the database lock is held by this thread.
+	 * 
+	 * @return true, if this thread is holding the database lock.
+	 */
+	public boolean isDbLockedByCurrentThread() {
+		return isCypheredDb() ? sqlCypheredDatabase.isDbLockedByCurrentThread() : sqliteDatabase.isDbLockedByCurrentThread();
+	}
+
+	/**
+	 * Checks if the database is locked by another thread. This is just an estimate, since this status can change at any time, including after the call is made but before the result has been acted upon.
+	 * 
+	 * @return true, if the database is locked by another thread
+	 */
+	public boolean isDbLockedByOtherThreads() {
+		return isCypheredDb() ? sqlCypheredDatabase.isDbLockedByOtherThreads() : sqliteDatabase.isDbLockedByOtherThreads();
+	}
+
+	/**
+	 * Temporarily end the transaction to let other threads run. The transaction is assumed to be successful so far. Do not call setTransactionSuccessful before calling this. When this returns a new transaction will have been created but not marked as successful.
+	 * 
+	 * @return true if the transaction was yielded
+	 * @deprecated if the db is locked more than once (becuase of nested transactions) then the lock will not be yielded. Use yieldIfContendedSafely instead.
+	 */
+	@Deprecated
+	public boolean yieldIfContended() {
+		return isCypheredDb() ? sqlCypheredDatabase.yieldIfContended() : sqliteDatabase.yieldIfContended();
+	}
+
+	/**
+	 * Temporarily end the transaction to let other threads run. The transaction is assumed to be successful so far. Do not call setTransactionSuccessful before calling this. When this returns a new transaction will have been created but not marked as successful. This assumes that there are no nested transactions (beginTransaction has only been called once) and will throw an exception if that is not the case.
+	 * 
+	 * @return true if the transaction was yielded
+	 */
+	public boolean yieldIfContendedSafely() {
+		return isCypheredDb() ? sqlCypheredDatabase.yieldIfContendedSafely() : sqliteDatabase.yieldIfContendedSafely();
+	}
+
+	/**
+	 * Temporarily end the transaction to let other threads run. The transaction is assumed to be successful so far. Do not call setTransactionSuccessful before calling this. When this returns a new transaction will have been created but not marked as successful. This assumes that there are no nested transactions (beginTransaction has only been called once) and will throw an exception if that is not the case.
+	 * 
+	 * @param sleepAfterYieldDelay
+	 *            if > 0, sleep this long before starting a new transaction if the lock was actually yielded. This will allow other background threads to make some more progress than they would if we started the transaction immediately.
+	 * @return true if the transaction was yielded
+	 */
+	public boolean yieldIfContendedSafely(long sleepAfterYieldDelay) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.yieldIfContendedSafely(sleepAfterYieldDelay);
+		else
+			throw new NotSupportedOperationAndroidException();
+	}
+
+	public Map<String, String> getSyncedTables() {
+		return isCypheredDb() ? sqlCypheredDatabase.getSyncedTables() : sqliteDatabase.getSyncedTables();
+	}
+
+	/**
+	 * Open the database according to the flags {@link #OPEN_READWRITE} {@link #OPEN_READONLY} {@link #CREATE_IF_NECESSARY} and/or {@link #NO_LOCALIZED_COLLATORS}.
+	 * 
+	 * <p>
+	 * Sets the locale of the database to the the system's current locale. Call {@link #setLocale} if you would like something else.
+	 * </p>
+	 * 
+	 * @param path
+	 *            to database file to open and/or create
+	 * @param factory
+	 *            an optional factory class that is called to instantiate a cursor when query is called, or null for default
+	 * @param flags
+	 *            to control database access mode
+	 * @return the newly opened database
+	 * @throws SQLiteException
+	 *             if the database cannot be opened
+	 */
+	public static SQLiteDatabaseWrapper openDatabase(String path, char[] password, CursorFactory factory, int flags, SQLiteDatabaseHook databaseHook) {
+		SQLiteDatabaseWrapper sqliteDatabase = null;
+		try {
+			// Open the database.
+			sqliteDatabase = new SQLiteDatabaseWrapper(path, password, factory, flags, databaseHook);
+			if (SQLiteDebug.DEBUG_SQL_STATEMENTS) {
+				sqliteDatabase.enableSqlTracing(path);
+			}
+			if (SQLiteDebug.DEBUG_SQL_TIME) {
+				sqliteDatabase.enableSqlProfiling(path);
+			}
+		} catch (SQLiteDatabaseCorruptException e) {
+			// Try to recover from this, if we can.
+			// TODO: should we do this for other open failures?
+			Log.e(TAG, "Deleting and re-creating corrupt database " + path, e);
+			// EventLog.writeEvent(EVENT_DB_CORRUPT, path);
+			if (!path.equalsIgnoreCase(":memory")) {
+				// delete is only for non-memory database files
+				new File(path).delete();
+			}
+			sqliteDatabase = new SQLiteDatabaseWrapper(path, password, factory, flags, databaseHook);
+		}
+		ActiveDatabases.getInstance().mActiveDatabases.add(new WeakReference<SQLiteDatabaseWrapper>(sqliteDatabase));
+		return sqliteDatabase;
+	}
+
+	private void enableSqlProfiling(String path) {
+		// TODO Need to call private native methods of SQLiteDatabase.... Should I use reflection ?
+	}
+
+	private void enableSqlTracing(String path) {
+		// TODO Need to call private native methods of SQLiteDatabase.... Should I use reflection ?
+	}
+
+	public static SQLiteDatabaseWrapper openDatabase(String path, char [] password, CursorFactory factory, int flags) {
+		return openDatabase(path, password, factory, flags, null);
+	}
+
+	public static SQLiteDatabaseWrapper openOrCreateDatabase(File file, char [] password, CursorFactory factory, SQLiteDatabaseHook databaseHook) {
+		return openOrCreateDatabase(file.getPath(), password, factory, databaseHook);
+	}
+
+	public static SQLiteDatabaseWrapper openOrCreateDatabase(String path, char [] password, CursorFactory factory, SQLiteDatabaseHook databaseHook) {
+		return openDatabase(path, password, factory, SQLiteDatabase.CREATE_IF_NECESSARY, databaseHook);
+	}
+
+	/**
+	 * Equivalent to openDatabase(file.getPath(), factory, CREATE_IF_NECESSARY).
+	 */
+	public static SQLiteDatabaseWrapper openOrCreateDatabase(File file, char [] password, CursorFactory factory) {
+		return openOrCreateDatabase(file.getPath(), password, factory, null);
+	}
+
+	/**
+	 * Equivalent to openDatabase(path, factory, CREATE_IF_NECESSARY).
+	 */
+	public static SQLiteDatabaseWrapper openOrCreateDatabase(String path, char [] password, CursorFactory factory) {
+		return openDatabase(path, password, factory, SQLiteDatabase.CREATE_IF_NECESSARY, null);
+	}
+
+	/**
+	 * Create a memory backed SQLite database. Its contents will be destroyed when the database is closed.
+	 * 
+	 * <p>
+	 * Sets the locale of the database to the the system's current locale. Call {@link #setLocale} if you would like something else.
+	 * </p>
+	 * 
+	 * @param factory
+	 *            an optional factory class that is called to instantiate a cursor when query is called
+	 * @return a SQLiteDatabase object, or null if the database can't be created
+	 */
+	public static SQLiteDatabaseWrapper create(CursorFactory factory, char [] password) {
+		return openDatabase(":memory:", password, factory, SQLiteDatabase.CREATE_IF_NECESSARY);
+	}
+
+	/**
+	 * Close the database.
+	 */
+	public void close() {
+		if (isCypheredDb())
+			sqlCypheredDatabase.close();
+		else
+			sqliteDatabase.close();
+	}
+
+	/**
+	 * Gets the database version.
+	 * 
+	 * @return the database version
+	 */
+	public int getVersion() {
+		return isCypheredDb() ? sqlCypheredDatabase.getVersion() : sqliteDatabase.getVersion();
+	}
+
+	/**
+	 * Sets the database version.
+	 * 
+	 * @param version
+	 *            the new database version
+	 */
+	public void setVersion(int version) {
+		if (isCypheredDb())
+			sqlCypheredDatabase.setVersion(version);
+		else
+			sqliteDatabase.setVersion(version);
+	}
+
+	/**
+	 * Returns the maximum size the database may grow to.
+	 * 
+	 * @return the new maximum database size
+	 */
+	public long getMaximumSize() {
+		return isCypheredDb() ? sqlCypheredDatabase.getMaximumSize() : sqliteDatabase.getMaximumSize();
+	}
+
+	/**
+	 * Sets the maximum size the database will grow to. The maximum size cannot be set below the current size.
+	 * 
+	 * @param numBytes
+	 *            the maximum database size, in bytes
+	 * @return the new maximum database size
+	 */
+	public long setMaximumSize(long numBytes) {
+		return isCypheredDb() ? sqlCypheredDatabase.setMaximumSize(numBytes) : sqliteDatabase.setMaximumSize(numBytes);
+	}
+
+	/**
+	 * Returns the current database page size, in bytes.
+	 * 
+	 * @return the database page size, in bytes
+	 */
+	public long getPageSize() {
+		return isCypheredDb() ? sqlCypheredDatabase.getPageSize() : sqliteDatabase.getPageSize();
+	}
+
+	/**
+	 * Sets the database page size. The page size must be a power of two. This method does not work if any data has been written to the database file, and must be called right after the database has been created.
+	 * 
+	 * @param numBytes
+	 *            the database page size, in bytes
+	 */
+	public void setPageSize(long numBytes) {
+		if (isCypheredDb())
+			sqlCypheredDatabase.setPageSize(numBytes);
+		else
+			sqliteDatabase.setPageSize(numBytes);
+	}
+
+	/**
+	 * Mark this table as syncable. When an update occurs in this table the _sync_dirty field will be set to ensure proper syncing operation.
+	 * 
+	 * @param table
+	 *            the table to mark as syncable
+	 * @param deletedTable
+	 *            The deleted table that corresponds to the syncable table
+	 */
+	public void markTableSyncable(String table, String deletedTable) {
+		if (isCypheredDb())
+			sqlCypheredDatabase.markTableSyncable(table, deletedTable);
+		else
+			sqliteDatabase.markTableSyncable(table, deletedTable);
+	}
+
+	/**
+	 * Mark this table as syncable, with the _sync_dirty residing in another table. When an update occurs in this table the _sync_dirty field of the row in updateTable with the _id in foreignKey will be set to ensure proper syncing operation.
+	 * 
+	 * @param table
+	 *            an update on this table will trigger a sync time removal
+	 * @param foreignKey
+	 *            this is the column in table whose value is an _id in updateTable
+	 * @param updateTable
+	 *            this is the table that will have its _sync_dirty
+	 */
+	public void markTableSyncable(String table, String foreignKey, String updateTable) {
+		if (isCypheredDb())
+			sqlCypheredDatabase.markTableSyncable(table, foreignKey, updateTable);
+		else
+			sqliteDatabase.markTableSyncable(table, foreignKey, updateTable);
+	}
+
+	/**
+	 * Finds the name of the first table, which is editable.
+	 * 
+	 * @param tables
+	 *            a list of tables
+	 * @return the first table listed
+	 */
+	public String findEditTable(String tables) {
+		if (isCypheredDb())
+			return net.sqlcipher.database.SQLiteDatabase.findEditTable(tables);
+		else
+			return SQLiteDatabase.findEditTable(tables);
+	}
+
+	/**
+	 * Compiles an SQL statement into a reusable pre-compiled statement object. The parameters are identical to {@link #execSQL(String)}. You may put ?s in the statement and fill in those values with {@link SQLiteProgram#bindString} and {@link SQLiteProgram#bindLong} each time you want to run the statement. Statements may not return result sets larger than 1x1.
+	 * 
+	 * @param sql
+	 *            The raw SQL statement, may contain ? for unknown values to be bound later.
+	 * @return A pre-compiled {@link SQLiteStatement} object. Note that {@link SQLiteStatement}s are not synchronized, see the documentation for more details.
+	 */
+	public SQLiteStatementWrapper compileStatement(String sql) throws SQLException {
+		if (isCypheredDb())
+			return new SQLiteStatementWrapper(sqlCypheredDatabase.compileStatement(sql));
+		else
+			return new SQLiteStatementWrapper(sqliteDatabase.compileStatement(sql));
+	}
+
+	/**
+	 * Query the given URL, returning a {@link Cursor} over the result set.
+	 * 
+	 * @param distinct
+	 *            true if you want each row to be unique, false otherwise.
+	 * @param table
+	 *            The table name to compile the query against.
+	 * @param columns
+	 *            A list of which columns to return. Passing null will return all columns, which is discouraged to prevent reading data from storage that isn't going to be used.
+	 * @param selection
+	 *            A filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given table.
+	 * @param selectionArgs
+	 *            You may include ?s in selection, which will be replaced by the values from selectionArgs, in order that they appear in the selection. The values will be bound as Strings.
+	 * @param groupBy
+	 *            A filter declaring how to group rows, formatted as an SQL GROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped.
+	 * @param having
+	 *            A filter declare which row groups to include in the cursor, if row grouping is being used, formatted as an SQL HAVING clause (excluding the HAVING itself). Passing null will cause all row groups to be included, and is required when row grouping is not being used.
+	 * @param orderBy
+	 *            How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.
+	 * @param limit
+	 *            Limits the number of rows returned by the query, formatted as LIMIT clause. Passing null denotes no LIMIT clause.
+	 * @return A {@link Cursor} object, which is positioned before the first entry. Note that {@link Cursor}s are not synchronized, see the documentation for more details.
+	 * @see Cursor
+	 */
+	public Cursor query(boolean distinct, String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.query(distinct, table, columns, selection, selectionArgs, groupBy, having, orderBy, limit);
+		else
+			return sqliteDatabase.query(distinct, table, columns, selection, selectionArgs, groupBy, having, orderBy, limit);
+
+	}
+
+	/**
+	 * Query the given URL, returning a {@link Cursor} over the result set.
+	 * 
+	 * @param cursorFactory
+	 *            the cursor factory to use, or null for the default factory
+	 * @param distinct
+	 *            true if you want each row to be unique, false otherwise.
+	 * @param table
+	 *            The table name to compile the query against.
+	 * @param columns
+	 *            A list of which columns to return. Passing null will return all columns, which is discouraged to prevent reading data from storage that isn't going to be used.
+	 * @param selection
+	 *            A filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given table.
+	 * @param selectionArgs
+	 *            You may include ?s in selection, which will be replaced by the values from selectionArgs, in order that they appear in the selection. The values will be bound as Strings.
+	 * @param groupBy
+	 *            A filter declaring how to group rows, formatted as an SQL GROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped.
+	 * @param having
+	 *            A filter declare which row groups to include in the cursor, if row grouping is being used, formatted as an SQL HAVING clause (excluding the HAVING itself). Passing null will cause all row groups to be included, and is required when row grouping is not being used.
+	 * @param orderBy
+	 *            How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.
+	 * @param limit
+	 *            Limits the number of rows returned by the query, formatted as LIMIT clause. Passing null denotes no LIMIT clause.
+	 * @return A {@link Cursor} object, which is positioned before the first entry. Note that {@link Cursor}s are not synchronized, see the documentation for more details.
+	 * @see Cursor
+	 */
+	public Cursor queryWithFactory(CursorFactory cursorFactory, boolean distinct, String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.queryWithFactory((net.sqlcipher.database.SQLiteDatabase.CursorFactory) cursorFactory, distinct, table, columns, selection, selectionArgs, groupBy, having, orderBy, limit);
+		else
+			return sqliteDatabase.queryWithFactory(cursorFactory, distinct, table, columns, selection, selectionArgs, groupBy, having, orderBy, limit);
+	}
+
+	/**
+	 * Query the given table, returning a {@link Cursor} over the result set.
+	 * 
+	 * @param table
+	 *            The table name to compile the query against.
+	 * @param columns
+	 *            A list of which columns to return. Passing null will return all columns, which is discouraged to prevent reading data from storage that isn't going to be used.
+	 * @param selection
+	 *            A filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given table.
+	 * @param selectionArgs
+	 *            You may include ?s in selection, which will be replaced by the values from selectionArgs, in order that they appear in the selection. The values will be bound as Strings.
+	 * @param groupBy
+	 *            A filter declaring how to group rows, formatted as an SQL GROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped.
+	 * @param having
+	 *            A filter declare which row groups to include in the cursor, if row grouping is being used, formatted as an SQL HAVING clause (excluding the HAVING itself). Passing null will cause all row groups to be included, and is required when row grouping is not being used.
+	 * @param orderBy
+	 *            How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.
+	 * @return A {@link Cursor} object, which is positioned before the first entry. Note that {@link Cursor}s are not synchronized, see the documentation for more details.
+	 * @see Cursor
+	 */
+	public Cursor query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.query(table, columns, selection, selectionArgs, groupBy, having, orderBy);
+		else
+			return sqliteDatabase.query(table, columns, selection, selectionArgs, groupBy, having, orderBy);
+	}
+
+	/**
+	 * Query the given table, returning a {@link Cursor} over the result set.
+	 * 
+	 * @param table
+	 *            The table name to compile the query against.
+	 * @param columns
+	 *            A list of which columns to return. Passing null will return all columns, which is discouraged to prevent reading data from storage that isn't going to be used.
+	 * @param selection
+	 *            A filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given table.
+	 * @param selectionArgs
+	 *            You may include ?s in selection, which will be replaced by the values from selectionArgs, in order that they appear in the selection. The values will be bound as Strings.
+	 * @param groupBy
+	 *            A filter declaring how to group rows, formatted as an SQL GROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped.
+	 * @param having
+	 *            A filter declare which row groups to include in the cursor, if row grouping is being used, formatted as an SQL HAVING clause (excluding the HAVING itself). Passing null will cause all row groups to be included, and is required when row grouping is not being used.
+	 * @param orderBy
+	 *            How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.
+	 * @param limit
+	 *            Limits the number of rows returned by the query, formatted as LIMIT clause. Passing null denotes no LIMIT clause.
+	 * @return A {@link Cursor} object, which is positioned before the first entry. Note that {@link Cursor}s are not synchronized, see the documentation for more details.
+	 * @see Cursor
+	 */
+	public Cursor query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.query(table, columns, selection, selectionArgs, groupBy, having, orderBy, limit);
+		else
+			return sqliteDatabase.query(table, columns, selection, selectionArgs, groupBy, having, orderBy, limit);
+	}
+
+	/**
+	 * Runs the provided SQL and returns a {@link Cursor} over the result set.
+	 * 
+	 * @param sql
+	 *            the SQL query. The SQL string must not be ; terminated
+	 * @param selectionArgs
+	 *            You may include ?s in where clause in the query, which will be replaced by the values from selectionArgs. The values will be bound as Strings.
+	 * @return A {@link Cursor} object, which is positioned before the first entry. Note that {@link Cursor}s are not synchronized, see the documentation for more details.
+	 */
+	public Cursor rawQuery(String sql, String[] selectionArgs) {
+		return isCypheredDb() ? sqlCypheredDatabase.rawQuery(sql, selectionArgs) : sqliteDatabase.rawQuery(sql, selectionArgs);
+	}
+
+	/**
+	 * Runs the provided SQL and returns a cursor over the result set.
+	 * 
+	 * @param cursorFactory
+	 *            the cursor factory to use, or null for the default factory
+	 * @param sql
+	 *            the SQL query. The SQL string must not be ; terminated
+	 * @param selectionArgs
+	 *            You may include ?s in where clause in the query, which will be replaced by the values from selectionArgs. The values will be bound as Strings.
+	 * @param editTable
+	 *            the name of the first table, which is editable
+	 * @return A {@link Cursor} object, which is positioned before the first entry. Note that {@link Cursor}s are not synchronized, see the documentation for more details.
+	 */
+	public Cursor rawQueryWithFactory(CursorFactory cursorFactory, String sql, String[] selectionArgs, String editTable) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.rawQueryWithFactory((net.sqlcipher.database.SQLiteDatabase.CursorFactory) cursorFactory, sql, selectionArgs, editTable);
+		else
+			return sqliteDatabase.rawQueryWithFactory(cursorFactory, sql, selectionArgs, editTable);
+	}
+
+	/**
+	 * Runs the provided SQL and returns a cursor over the result set. The cursor will read an initial set of rows and the return to the caller. It will continue to read in batches and send data changed notifications when the later batches are ready.
+	 * 
+	 * @param sql
+	 *            the SQL query. The SQL string must not be ; terminated
+	 * @param selectionArgs
+	 *            You may include ?s in where clause in the query, which will be replaced by the values from selectionArgs. The values will be bound as Strings.
+	 * @param initialRead
+	 *            set the initial count of items to read from the cursor
+	 * @param maxRead
+	 *            set the count of items to read on each iteration after the first
+	 * @return A {@link Cursor} object, which is positioned before the first entry. Note that {@link Cursor}s are not synchronized, see the documentation for more details.
+	 * 
+	 *         This work is incomplete and not fully tested or reviewed, so currently hidden.
+	 * @hide
+	 */
+	public Cursor rawQuery(String sql, String[] selectionArgs, int initialRead, int maxRead) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.rawQuery(sql, selectionArgs, initialRead, maxRead);
+		else
+			throw new NotSupportedOperationAndroidException();
+	}
+
+	/**
+	 * Convenience method for inserting a row into the database.
+	 * 
+	 * @param table
+	 *            the table to insert the row into
+	 * @param nullColumnHack
+	 *            SQL doesn't allow inserting a completely empty row, so if initialValues is empty this column will explicitly be assigned a NULL value
+	 * @param values
+	 *            this map contains the initial column values for the row. The keys should be the column names and the values the column values
+	 * @return the row ID of the newly inserted row, or -1 if an error occurred
+	 */
+	public long insert(String table, String nullColumnHack, ContentValues values) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.insert(table, nullColumnHack, values);
+		else
+			return sqliteDatabase.insert(table, nullColumnHack, values);
+	}
+
+	/**
+	 * Convenience method for inserting a row into the database.
+	 * 
+	 * @param table
+	 *            the table to insert the row into
+	 * @param nullColumnHack
+	 *            SQL doesn't allow inserting a completely empty row, so if initialValues is empty this column will explicitly be assigned a NULL value
+	 * @param values
+	 *            this map contains the initial column values for the row. The keys should be the column names and the values the column values
+	 * @throws SQLException
+	 * @return the row ID of the newly inserted row, or -1 if an error occurred
+	 */
+	public long insertOrThrow(String table, String nullColumnHack, ContentValues values) throws SQLException {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.insertOrThrow(table, nullColumnHack, values);
+		else
+			return sqliteDatabase.insertOrThrow(table, nullColumnHack, values);
+	}
+
+	/**
+	 * Convenience method for replacing a row in the database.
+	 * 
+	 * @param table
+	 *            the table in which to replace the row
+	 * @param nullColumnHack
+	 *            SQL doesn't allow inserting a completely empty row, so if initialValues is empty this row will explicitly be assigned a NULL value
+	 * @param initialValues
+	 *            this map contains the initial column values for the row. The key
+	 * @return the row ID of the newly inserted row, or -1 if an error occurred
+	 */
+	public long replace(String table, String nullColumnHack, ContentValues initialValues) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.replace(table, nullColumnHack, initialValues);
+		else
+			return sqliteDatabase.replace(table, nullColumnHack, initialValues);
+	}
+
+	/**
+	 * Convenience method for replacing a row in the database.
+	 * 
+	 * @param table
+	 *            the table in which to replace the row
+	 * @param nullColumnHack
+	 *            SQL doesn't allow inserting a completely empty row, so if initialValues is empty this row will explicitly be assigned a NULL value
+	 * @param initialValues
+	 *            this map contains the initial column values for the row. The key
+	 * @throws SQLException
+	 * @return the row ID of the newly inserted row, or -1 if an error occurred
+	 */
+	public long replaceOrThrow(String table, String nullColumnHack, ContentValues initialValues) throws SQLException {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.replaceOrThrow(table, nullColumnHack, initialValues);
+		else
+			return sqliteDatabase.replaceOrThrow(table, nullColumnHack, initialValues);
+	}
+
+	/**
+	 * General method for inserting a row into the database.
+	 * 
+	 * @param table
+	 *            the table to insert the row into
+	 * @param nullColumnHack
+	 *            SQL doesn't allow inserting a completely empty row, so if initialValues is empty this column will explicitly be assigned a NULL value
+	 * @param initialValues
+	 *            this map contains the initial column values for the row. The keys should be the column names and the values the column values
+	 * @param conflictAlgorithm
+	 *            for insert conflict resolver
+	 * @return the row ID of the newly inserted row OR the primary key of the existing row if the input param 'conflictAlgorithm' = {@link #CONFLICT_IGNORE} OR -1 if any error
+	 */
+	public long insertWithOnConflict(String table, String nullColumnHack, ContentValues initialValues, int conflictAlgorithm) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.insertWithOnConflict(table, nullColumnHack, initialValues, conflictAlgorithm);
+		else
+			throw new NotSupportedOperationAndroidException();
+	}
+
+	/**
+	 * Convenience method for deleting rows in the database.
+	 * 
+	 * @param table
+	 *            the table to delete from
+	 * @param whereClause
+	 *            the optional WHERE clause to apply when deleting. Passing null will delete all rows.
+	 * @return the number of rows affected if a whereClause is passed in, 0 otherwise. To remove all rows and get a count pass "1" as the whereClause.
+	 */
+	public int delete(String table, String whereClause, String[] whereArgs) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.delete(table, whereClause, whereArgs);
+		else
+			return sqliteDatabase.delete(table, whereClause, whereArgs);
+	}
+
+	/**
+	 * Convenience method for updating rows in the database.
+	 * 
+	 * @param table
+	 *            the table to update in
+	 * @param values
+	 *            a map from column names to new column values. null is a valid value that will be translated to NULL.
+	 * @param whereClause
+	 *            the optional WHERE clause to apply when updating. Passing null will update all rows.
+	 * @return the number of rows affected
+	 */
+	public int update(String table, ContentValues values, String whereClause, String[] whereArgs) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.update(table, values, whereClause, whereArgs);
+		else
+			return sqliteDatabase.update(table, values, whereClause, whereArgs);
+	}
+
+	/**
+	 * Convenience method for updating rows in the database.
+	 * 
+	 * @param table
+	 *            the table to update in
+	 * @param values
+	 *            a map from column names to new column values. null is a valid value that will be translated to NULL.
+	 * @param whereClause
+	 *            the optional WHERE clause to apply when updating. Passing null will update all rows.
+	 * @param conflictAlgorithm
+	 *            for update conflict resolver
+	 * @return the number of rows affected
+	 */
+	public int updateWithOnConflict(String table, ContentValues values, String whereClause, String[] whereArgs, int conflictAlgorithm) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.updateWithOnConflict(table, values, whereClause, whereArgs, conflictAlgorithm);
+		else
+			throw new NotSupportedOperationAndroidException();
+	}
+
+	/**
+	 * Execute a single SQL statement that is not a query. For example, CREATE TABLE, DELETE, INSERT, etc. Multiple statements separated by ;s are not supported. it takes a write lock
+	 * 
+	 * @throws SQLException
+	 *             If the SQL string is invalid for some reason
+	 */
+	public void execSQL(String sql) throws SQLException {
+		if (isCypheredDb())
+			sqlCypheredDatabase.execSQL(sql);
+		else
+			sqliteDatabase.execSQL(sql);
+	}
+
+	public void rawExecSQL(String sql) {
+		if (isCypheredDb())
+			sqlCypheredDatabase.rawExecSQL(sql);
+		else
+			throw new NotSupportedOperationAndroidException();
+	}
+
+	/**
+	 * Execute a single SQL statement that is not a query. For example, CREATE TABLE, DELETE, INSERT, etc. Multiple statements separated by ;s are not supported. it takes a write lock,
+	 * 
+	 * @param sql
+	 * @param bindArgs
+	 *            only byte[], String, Long and Double are supported in bindArgs.
+	 * @throws SQLException
+	 *             If the SQL string is invalid for some reason
+	 */
+	public void execSQL(String sql, Object[] bindArgs) throws SQLException {
+		if (isCypheredDb())
+			sqlCypheredDatabase.execSQL(sql, bindArgs);
+		else
+			sqliteDatabase.execSQL(sql, bindArgs);
+	}
+
+	/**
+	 * return whether the DB is opened as read only.
+	 * 
+	 * @return true if DB is opened as read only
+	 */
+	public boolean isReadOnly() {
+		return isCypheredDb() ? sqlCypheredDatabase.isReadOnly() : sqliteDatabase.isReadOnly();
+	}
+
+	/**
+	 * @return true if the DB is currently open (has not been closed)
+	 */
+	public boolean isOpen() {
+		return isCypheredDb() ? sqlCypheredDatabase.isOpen() : sqliteDatabase.isOpen();
+
+	}
+
+	public boolean needUpgrade(int newVersion) {
+		return isCypheredDb() ? sqlCypheredDatabase.needUpgrade(newVersion) : sqliteDatabase.needUpgrade(newVersion);
+
+	}
+
+	/**
+	 * Getter for the path to the database file.
+	 * 
+	 * @return the path to our database file.
+	 */
+	public final String getPath() {
+		return isCypheredDb() ? sqlCypheredDatabase.getPath() : sqliteDatabase.getPath();
+
+	}
+
+	/**
+	 * Sets the locale for this database. Does nothing if this database has the NO_LOCALIZED_COLLATORS flag set or was opened read only.
+	 * 
+	 * @throws SQLException
+	 *             if the locale could not be set. The most common reason for this is that there is no collator available for the locale you requested. In this case the database remains unchanged.
+	 */
+	public void setLocale(Locale locale) {
+		if (isCypheredDb())
+			sqlCypheredDatabase.setLocale(locale);
+		else
+			sqliteDatabase.setLocale(locale);
+	}
+
+	/**
+	 * returns true if the given sql is cached in compiled-sql cache.
+	 * 
+	 * @hide
+	 */
+	public boolean isInCompiledSqlCache(String sql) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.isInCompiledSqlCache(sql);
+		else
+			throw new NotSupportedOperationAndroidException();
+
+	}
+
+	/**
+	 * purges the given sql from the compiled-sql cache.
+	 * 
+	 * @hide
+	 */
+	public void purgeFromCompiledSqlCache(String sql) {
+		if (isCypheredDb())
+			sqlCypheredDatabase.purgeFromCompiledSqlCache(sql);
+		else
+			throw new NotSupportedOperationAndroidException();
+	}
+
+	/**
+	 * remove everything from the compiled sql cache
+	 * 
+	 * @hide
+	 */
+	public void resetCompiledSqlCache() {
+		if (isCypheredDb())
+			sqlCypheredDatabase.resetCompiledSqlCache();
+		else
+			throw new NotSupportedOperationAndroidException();
+	}
+
+	/**
+	 * return the current maxCacheSqlCacheSize
+	 * 
+	 * @hide
+	 */
+	public synchronized int getMaxSqlCacheSize() {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.getMaxSqlCacheSize();
+		else
+			throw new NotSupportedOperationAndroidException();
+
+	}
+
+	/**
+	 * set the max size of the compiled sql cache for this database after purging the cache. (size of the cache = number of compiled-sql-statements stored in the cache).
+	 * 
+	 * max cache size can ONLY be increased from its current size (default = 0). if this method is called with smaller size than the current value of mMaxSqlCacheSize, then IllegalStateException is thrown
+	 * 
+	 * synchronized because we don't want t threads to change cache size at the same time.
+	 * 
+	 * @param cacheSize
+	 *            the size of the cache. can be (0 to MAX_SQL_CACHE_SIZE)
+	 * @throws IllegalStateException
+	 *             if input cacheSize > MAX_SQL_CACHE_SIZE or < 0 or < the value set with previous setMaxSqlCacheSize() call.
+	 * 
+	 * @hide
+	 */
+	public synchronized void setMaxSqlCacheSize(int cacheSize) {
+		if (isCypheredDb())
+			sqlCypheredDatabase.setMaxSqlCacheSize(cacheSize);
+		else
+			throw new NotSupportedOperationAndroidException();
+	}
+
+	/**
+	 * Locks the database for exclusive access. The database lock must be held when touch the native sqlite3* object since it is single threaded and uses a polling lock contention algorithm. The lock is recursive, and may be acquired multiple times by the same thread. This is a no-op if mLockingEnabled is false.
+	 * 
+	 * @see #unlock()
+	 */
+	/* package */void lock() {
+		if (!mLockingEnabled)
+			return;
+		mLock.lock();
+		if (SQLiteDebug.DEBUG_LOCK_TIME_TRACKING) {
+			if (mLock.getHoldCount() == 1) {
+				// Use elapsed real-time since the CPU may sleep when waiting for IO
+				mLockAcquiredWallTime = SystemClock.elapsedRealtime();
+				mLockAcquiredThreadTime = Debug.threadCpuTimeNanos();
+			}
+		}
+	}
+
+	/**
+	 * Releases the database lock. This is a no-op if mLockingEnabled is false.
+	 * 
+	 * @see #unlock()
+	 */
+	/* package */void unlock() {
+		if (!mLockingEnabled)
+			return;
+		if (SQLiteDebug.DEBUG_LOCK_TIME_TRACKING) {
+			if (mLock.getHoldCount() == 1) {
+				checkLockHoldTime();
+			}
+		}
+		mLock.unlock();
+	}
+
+	private void checkLockHoldTime() {
+		// Use elapsed real-time since the CPU may sleep when waiting for IO
+		long elapsedTime = SystemClock.elapsedRealtime();
+		long lockedTime = elapsedTime - mLockAcquiredWallTime;
+		if (lockedTime < LOCK_ACQUIRED_WARNING_TIME_IN_MS_ALWAYS_PRINT && !Log.isLoggable(TAG, Log.VERBOSE) && (elapsedTime - mLastLockMessageTime) < LOCK_WARNING_WINDOW_IN_MS) {
+			return;
+		}
+		if (lockedTime > LOCK_ACQUIRED_WARNING_TIME_IN_MS) {
+			int threadTime = (int) ((Debug.threadCpuTimeNanos() - mLockAcquiredThreadTime) / 1000000);
+			if (threadTime > LOCK_ACQUIRED_WARNING_THREAD_TIME_IN_MS || lockedTime > LOCK_ACQUIRED_WARNING_TIME_IN_MS_ALWAYS_PRINT) {
+				mLastLockMessageTime = elapsedTime;
+				String msg = "lock held on " + getPath() + " for " + lockedTime + "ms. Thread time was " + threadTime + "ms";
+				if (SQLiteDebug.DEBUG_LOCK_TIME_TRACKING_STACK_TRACE) {
+					Log.d(TAG, msg, new Exception());
+				} else {
+					Log.d(TAG, msg);
+				}
+			}
+		}
+	}
+
+	static class ActiveDatabases {
+		private static final ActiveDatabases activeDatabases = new ActiveDatabases();
+		private HashSet<WeakReference<SQLiteDatabaseWrapper>> mActiveDatabases = new HashSet<WeakReference<SQLiteDatabaseWrapper>>();
+
+		private ActiveDatabases() {
+		} // disable instantiation of this class
+
+		static ActiveDatabases getInstance() {
+			return activeDatabases;
+		}
+	}
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteOpenHelperWrapper.java b/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteOpenHelperWrapper.java
new file mode 100644
index 00000000..12431b64
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteOpenHelperWrapper.java
@@ -0,0 +1,242 @@
+package de.greenrobot.dao.wrapper;
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteDatabase.CursorFactory;
+import android.util.Log;
+
+import net.sqlcipher.database.SQLiteException;
+
+import java.io.File;
+
+public abstract class SQLiteOpenHelperWrapper {
+
+	private static final String TAG = SQLiteOpenHelperWrapper.class.getSimpleName();
+
+	private final Context mContext;
+	private final String mName;
+	private final char[] mPassword;
+	private final CursorFactory mFactory;
+	private final int mNewVersion;
+
+	private SQLiteDatabaseWrapper mDatabase = null;
+	private boolean mIsInitializing = false;
+
+	/**
+	 * 
+	 * @param context
+	 * @param name
+	 *            name of the database
+	 * @param password
+	 *            if not null nor empty the database will be encrypted
+	 * @param factory
+	 * @param version
+	 */
+	public SQLiteOpenHelperWrapper(Context context, String name, char [] password, CursorFactory factory, int version) {
+		if (version < 1)
+			throw new IllegalArgumentException("Version must be >= 1, was " + version);
+
+		mContext = context;
+		mName = name;
+		mPassword = password;
+		mFactory = factory;
+		mNewVersion = version;
+
+		if (mPassword != null && mPassword.length > 0) {
+			// Load SQLcipher libraries if needed
+			SQLiteDatabaseWrapper.loadLibs(mContext);
+		}
+	}
+
+	public boolean isCypheredDb() {
+		return mDatabase.isCypheredDb();
+	}
+
+	/**
+	 * Create and/or open a database that will be used for reading and writing. Once opened successfully, the database is cached, so you can call this method every time you need to write to the database. Make sure to call {@link #close} when you no longer need it.
+	 * 
+	 * <p>
+	 * Errors such as bad permissions or a full disk may cause this operation to fail, but future attempts may succeed if the problem is fixed.
+	 * </p>
+	 * 
+	 * @throws SQLiteException
+	 *             if the database cannot be opened for writing
+	 * @return a read/write database object valid until {@link #close} is called
+	 */
+	public synchronized SQLiteDatabaseWrapper getWritableDatabase() {
+		if (mDatabase != null && mDatabase.isOpen() && !mDatabase.isReadOnly()) {
+			return mDatabase; // The database is already open for business
+		}
+
+		if (mIsInitializing) {
+			throw new IllegalStateException("getWritableDatabase called recursively");
+		}
+
+		// If we have a read-only database open, someone could be using it
+		// (though they shouldn't), which would cause a lock to be held on
+		// the file, and our attempts to open the database read-write would
+		// fail waiting for the file lock. To prevent that, we acquire the
+		// lock on the read-only database, which shuts out other users.
+
+		boolean success = false;
+		SQLiteDatabaseWrapper db = null;
+		if (mDatabase != null)
+			mDatabase.lock();
+		try {
+			mIsInitializing = true;
+			if (mName == null) {
+				db = SQLiteDatabaseWrapper.create(null, mPassword);
+			} else {
+				String path = mContext.getDatabasePath(mName).getPath();
+
+				File dbPathFile = new File(path);
+				if (!dbPathFile.exists())
+					dbPathFile.getParentFile().mkdirs();
+
+				db = SQLiteDatabaseWrapper.openOrCreateDatabase(path, mPassword, mFactory);
+			}
+
+			int version = db.getVersion();
+			if (version != mNewVersion) {
+				db.beginTransaction();
+				try {
+					if (version == 0) {
+						onCreate(db);
+					} else {
+						if (version > mNewVersion) {
+							Log.w(TAG, "Can't downgrade read-only database from version " + version + " to " + mNewVersion + ": " + db.getPath());
+						}
+						onUpgrade(db, version, mNewVersion);
+					}
+					db.setVersion(mNewVersion);
+					db.setTransactionSuccessful();
+				} finally {
+					db.endTransaction();
+				}
+			}
+
+			onOpen(db);
+			success = true;
+			return db;
+		} finally {
+			mIsInitializing = false;
+			if (success) {
+				if (mDatabase != null) {
+					try {
+						mDatabase.close();
+					} catch (Exception e) {
+					}
+					mDatabase.unlock();
+				}
+				mDatabase = db;
+			} else {
+				if (mDatabase != null)
+					mDatabase.unlock();
+				if (db != null)
+					db.close();
+			}
+		}
+	}
+
+	/**
+	 * Create and/or open a database. This will be the same object returned by {@link #getWritableDatabase} unless some problem, such as a full disk, requires the database to be opened read-only. In that case, a read-only database object will be returned. If the problem is fixed, a future call to {@link #getWritableDatabase} may succeed, in which case the read-only database object will be closed and the read/write object will be returned in the future.
+	 * 
+	 * @throws SQLiteException
+	 *             if the database cannot be opened
+	 * @return a database object valid until {@link #getWritableDatabase} or {@link #close} is called.
+	 */
+	public synchronized SQLiteDatabaseWrapper getReadableDatabase() {
+		if (mDatabase != null && mDatabase.isOpen()) {
+			return mDatabase; // The database is already open for business
+		}
+
+		if (mIsInitializing) {
+			throw new IllegalStateException("getReadableDatabase called recursively");
+		}
+
+		try {
+			return getWritableDatabase();
+		} catch (SQLiteException e) {
+			if (mName == null)
+				throw e; // Can't open a temp database read-only!
+			Log.e(TAG, "Couldn't open " + mName + " for writing (will try read-only):", e);
+		}
+
+		SQLiteDatabaseWrapper db = null;
+		try {
+			mIsInitializing = true;
+			String path = mContext.getDatabasePath(mName).getPath();
+			File databasePath = new File(path);
+			File databasesDirectory = new File(mContext.getDatabasePath(mName).getParent());
+
+			if (!databasesDirectory.exists()) {
+				databasesDirectory.mkdirs();
+			}
+			if (!databasePath.exists()) {
+				mIsInitializing = false;
+				db = getWritableDatabase();
+				mIsInitializing = true;
+				db.close();
+			}
+			db = SQLiteDatabaseWrapper.openDatabase(path, mPassword, mFactory, SQLiteDatabase.OPEN_READONLY);
+			if (db.getVersion() != mNewVersion) {
+				throw new SQLiteException("Can't upgrade read-only database from version " + db.getVersion() + " to " + mNewVersion + ": " + path);
+			}
+
+			onOpen(db);
+			Log.w(TAG, "Opened " + mName + " in read-only mode");
+			mDatabase = db;
+			return mDatabase;
+		} finally {
+			mIsInitializing = false;
+			if (db != null && db != mDatabase)
+				db.close();
+		}
+	}
+
+	/**
+	 * Close any open database object.
+	 */
+	public synchronized void close() {
+		if (mIsInitializing)
+			throw new IllegalStateException("Closed during initialization");
+
+		if (mDatabase != null && mDatabase.isOpen()) {
+			mDatabase.close();
+			mDatabase = null;
+		}
+	}
+
+	/**
+	 * Called when the database is created for the first time. This is where the creation of tables and the initial population of the tables should happen.
+	 * 
+	 * @param db
+	 *            The database.
+	 */
+	public abstract void onCreate(SQLiteDatabaseWrapper db);
+
+	/**
+	 * Called when the database needs to be upgraded. The implementation should use this method to drop tables, add tables, or do anything else it needs to upgrade to the new schema version.
+	 * 
+	 * <p>
+	 * The SQLite ALTER TABLE documentation can be found <a href="http://sqlite.org/lang_altertable.html">here</a>. If you add new columns you can use ALTER TABLE to insert them into a live table. If you rename or remove columns you can use ALTER TABLE to rename the old table, then create the new table and then populate the new table with the contents of the old table.
+	 * 
+	 * @param db
+	 *            The database.
+	 * @param oldVersion
+	 *            The old database version.
+	 * @param newVersion
+	 *            The new database version.
+	 */
+	public abstract void onUpgrade(SQLiteDatabaseWrapper db, int oldVersion, int newVersion);
+
+	/**
+	 * Called when the database has been opened. Override method should check {@link SQLiteDatabase#isReadOnly} before updating the database.
+	 * 
+	 * @param db
+	 *            The database.
+	 */
+	public void onOpen(SQLiteDatabaseWrapper db) {
+	}
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteProgramWrapper.java b/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteProgramWrapper.java
new file mode 100644
index 00000000..5168c197
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteProgramWrapper.java
@@ -0,0 +1,117 @@
+package de.greenrobot.dao.wrapper;
+
+import android.database.sqlite.SQLiteProgram;
+
+public class SQLiteProgramWrapper {
+
+	private final SQLiteProgram sqliteProgram;
+	private final net.sqlcipher.database.SQLiteProgram sqlCypheredProgram;
+
+	public SQLiteProgramWrapper(SQLiteProgram sqliteProgram) {
+		this.sqliteProgram = sqliteProgram;
+		this.sqlCypheredProgram = null;
+	}
+
+	public SQLiteProgramWrapper(net.sqlcipher.database.SQLiteProgram sqlCypheredProgram) {
+		this.sqliteProgram = null;
+		this.sqlCypheredProgram = sqlCypheredProgram;
+	}
+
+	public boolean isCypheredDb() {
+		return sqlCypheredProgram != null;
+	}
+
+	/**
+	 * Bind a NULL value to this statement. The value remains bound until {@link #clearBindings} is called.
+	 * 
+	 * @param index
+	 *            The 1-based index to the parameter to bind null to
+	 */
+	public void bindNull(int index) {
+		if (isCypheredDb())
+			sqlCypheredProgram.bindNull(index);
+		else
+			sqliteProgram.bindNull(index);
+	}
+
+	/**
+	 * Bind a long value to this statement. The value remains bound until {@link #clearBindings} is called.
+	 * 
+	 * @param index
+	 *            The 1-based index to the parameter to bind
+	 * @param value
+	 *            The value to bind
+	 */
+	public void bindLong(int index, long value) {
+		if (isCypheredDb())
+			sqlCypheredProgram.bindLong(index, value);
+		else
+			sqliteProgram.bindLong(index, value);
+	}
+
+	/**
+	 * Bind a double value to this statement. The value remains bound until {@link #clearBindings} is called.
+	 * 
+	 * @param index
+	 *            The 1-based index to the parameter to bind
+	 * @param value
+	 *            The value to bind
+	 */
+	public void bindDouble(int index, double value) {
+		if (isCypheredDb())
+			sqlCypheredProgram.bindDouble(index, value);
+		else
+			sqliteProgram.bindDouble(index, value);
+	}
+
+	/**
+	 * Bind a String value to this statement. The value remains bound until {@link #clearBindings} is called.
+	 * 
+	 * @param index
+	 *            The 1-based index to the parameter to bind
+	 * @param value
+	 *            The value to bind
+	 */
+	public void bindString(int index, String value) {
+		if (isCypheredDb())
+			sqlCypheredProgram.bindString(index, value);
+		else
+			sqliteProgram.bindString(index, value);
+	}
+
+	/**
+	 * Bind a byte array value to this statement. The value remains bound until {@link #clearBindings} is called.
+	 * 
+	 * @param index
+	 *            The 1-based index to the parameter to bind
+	 * @param value
+	 *            The value to bind
+	 */
+	public void bindBlob(int index, byte[] value) {
+		if (isCypheredDb())
+			sqlCypheredProgram.bindBlob(index, value);
+		else
+			sqliteProgram.bindBlob(index, value);
+	}
+
+	/**
+	 * Clears all existing bindings. Unset bindings are treated as NULL.
+	 */
+	public void clearBindings() {
+		if (isCypheredDb())
+			sqlCypheredProgram.clearBindings();
+		else
+			sqliteProgram.clearBindings();
+	}
+
+	/**
+	 * Release this program's resources, making it invalid.
+	 */
+	public void close() {
+		if (isCypheredDb())
+			sqlCypheredProgram.close();
+		else
+			sqliteProgram.close();
+	}
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteStatementWrapper.java b/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteStatementWrapper.java
new file mode 100644
index 00000000..7cc5fe9d
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteStatementWrapper.java
@@ -0,0 +1,75 @@
+package de.greenrobot.dao.wrapper;
+
+import android.database.sqlite.SQLiteStatement;
+
+public class SQLiteStatementWrapper extends SQLiteProgramWrapper {
+
+	private final SQLiteStatement sqliteStatement;
+	private final net.sqlcipher.database.SQLiteStatement sqlCypheredStatement;
+
+	public SQLiteStatementWrapper(SQLiteStatement sqliteStatement) {
+		super(sqliteStatement);
+		this.sqliteStatement = sqliteStatement;
+		this.sqlCypheredStatement = null;
+	}
+
+	public SQLiteStatementWrapper(net.sqlcipher.database.SQLiteStatement sqlCypheredStatement) {
+		super(sqlCypheredStatement);
+		this.sqliteStatement = null;
+		this.sqlCypheredStatement = sqlCypheredStatement;
+	}
+
+	public boolean isCypheredDb() {
+		return sqlCypheredStatement != null;
+	}
+
+	/**
+	 * Execute this SQL statement, if it is not a query. For example, CREATE TABLE, DELTE, INSERT, etc.
+	 * 
+	 * @throws android.database.SQLException
+	 *             If the SQL string is invalid for some reason
+	 */
+	public void execute() {
+		if (isCypheredDb())
+			sqlCypheredStatement.execute();
+		else
+			sqliteStatement.execute();
+	}
+
+	/**
+	 * Execute this SQL statement and return the ID of the row inserted due to this call. The SQL statement should be an INSERT for this to be a useful call.
+	 * 
+	 * @return the row ID of the last row inserted, if this insert is successful. -1 otherwise.
+	 * 
+	 * @throws android.database.SQLException
+	 *             If the SQL string is invalid for some reason
+	 */
+	public long executeInsert() {
+		return isCypheredDb() ? sqlCypheredStatement.executeInsert() : sqliteStatement.executeInsert();
+	}
+
+	/**
+	 * Execute a statement that returns a 1 by 1 table with a numeric value. For example, SELECT COUNT(*) FROM table;
+	 * 
+	 * @return The result of the query.
+	 * 
+	 * @throws android.database.sqlite.SQLiteDoneException
+	 *             if the query returns zero rows
+	 */
+	public long simpleQueryForLong() {
+		return isCypheredDb() ? sqlCypheredStatement.simpleQueryForLong() : sqliteStatement.simpleQueryForLong();
+	}
+
+	/**
+	 * Execute a statement that returns a 1 by 1 table with a text value. For example, SELECT COUNT(*) FROM table;
+	 * 
+	 * @return The result of the query.
+	 * 
+	 * @throws android.database.sqlite.SQLiteDoneException
+	 *             if the query returns zero rows
+	 */
+	public String simpleQueryForString() {
+		return isCypheredDb() ? sqlCypheredStatement.simpleQueryForString() : sqliteStatement.simpleQueryForString();
+	}
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/wrapper/exception/NotSupportedOperationAndroidException.java b/DaoCore/src/de/greenrobot/dao/wrapper/exception/NotSupportedOperationAndroidException.java
new file mode 100644
index 00000000..b6b9964f
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/wrapper/exception/NotSupportedOperationAndroidException.java
@@ -0,0 +1,23 @@
+package de.greenrobot.dao.wrapper.exception;
+
+public class NotSupportedOperationAndroidException extends RuntimeException {
+
+	private static final long serialVersionUID = -8708290373742559496L;
+
+	public NotSupportedOperationAndroidException() {
+		super("Android doesn't provide any implementation of this method");
+	}
+
+	public NotSupportedOperationAndroidException(String detailMessage, Throwable throwable) {
+		super("Android doesn't provide any implementation of this method : " + detailMessage, throwable);
+	}
+
+	public NotSupportedOperationAndroidException(String detailMessage) {
+		super("Android doesn't provide any implementation of this method : " + detailMessage);
+	}
+
+	public NotSupportedOperationAndroidException(Throwable throwable) {
+		super(throwable);
+	}
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/wrapper/exception/NotSupportedOperationSQLCypherException.java b/DaoCore/src/de/greenrobot/dao/wrapper/exception/NotSupportedOperationSQLCypherException.java
new file mode 100644
index 00000000..7800f736
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/wrapper/exception/NotSupportedOperationSQLCypherException.java
@@ -0,0 +1,23 @@
+package de.greenrobot.dao.wrapper.exception;
+
+public class NotSupportedOperationSQLCypherException extends RuntimeException {
+
+	private static final long serialVersionUID = -8708290373742559496L;
+
+	public NotSupportedOperationSQLCypherException() {
+		super("SQLCypher doesn't provide any implementation of this method");
+	}
+
+	public NotSupportedOperationSQLCypherException(String detailMessage, Throwable throwable) {
+		super("SQLCypher doesn't provide any implementation of this method : " + detailMessage, throwable);
+	}
+
+	public NotSupportedOperationSQLCypherException(String detailMessage) {
+		super("SQLCypher doesn't provide any implementation of this method : " + detailMessage);
+	}
+
+	public NotSupportedOperationSQLCypherException(Throwable throwable) {
+		super(throwable);
+	}
+
+}
diff --git a/DaoExample/settings.gradle b/DaoExample/settings.gradle
deleted file mode 100644
index 96dff2be..00000000
--- a/DaoExample/settings.gradle
+++ /dev/null
@@ -1 +0,0 @@
-rootProject.name = 'greendao-example'
\ No newline at end of file
diff --git a/DaoExampleGenerator/build.gradle b/DaoExampleGenerator/build.gradle
index f79e8e6e..51f7299b 100644
--- a/DaoExampleGenerator/build.gradle
+++ b/DaoExampleGenerator/build.gradle
@@ -13,7 +13,7 @@ repositories {
 }
 
 dependencies {
-    compile('de.greenrobot:greendao-generator:1.3.1-SNAPSHOT')
+    compile('de.greenrobot:greendao-generator:1.3.1')
 }
 
 sourceSets {
diff --git a/DaoExampleGenerator/settings.gradle b/DaoExampleGenerator/settings.gradle
deleted file mode 100644
index 4cd77a8b..00000000
--- a/DaoExampleGenerator/settings.gradle
+++ /dev/null
@@ -1 +0,0 @@
-rootProject.name = 'greendao-example-generator'
\ No newline at end of file
diff --git a/DaoGenerator/gradle/wrapper/gradle-wrapper.jar b/DaoGenerator/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 00000000..8c0fb64a
Binary files /dev/null and b/DaoGenerator/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/DaoGenerator/gradle/wrapper/gradle-wrapper.properties b/DaoGenerator/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 00000000..0c71e760
--- /dev/null
+++ b/DaoGenerator/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Wed Apr 10 15:27:10 PDT 2013
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
diff --git a/DaoGenerator/gradlew b/DaoGenerator/gradlew
new file mode 100644
index 00000000..91a7e269
--- /dev/null
+++ b/DaoGenerator/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/DaoGenerator/gradlew.bat b/DaoGenerator/gradlew.bat
new file mode 100644
index 00000000..8a0b282a
--- /dev/null
+++ b/DaoGenerator/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/DaoGenerator/settings.gradle b/DaoGenerator/settings.gradle
deleted file mode 100644
index 86014829..00000000
--- a/DaoGenerator/settings.gradle
+++ /dev/null
@@ -1 +0,0 @@
-rootProject.name = 'greendao-generator'
\ No newline at end of file
diff --git a/DaoGenerator/src-template/dao-master.ftl b/DaoGenerator/src-template/dao-master.ftl
index adaffc48..3bcf16e9 100644
--- a/DaoGenerator/src-template/dao-master.ftl
+++ b/DaoGenerator/src-template/dao-master.ftl
@@ -20,9 +20,9 @@ along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
 package ${schema.defaultJavaPackageDao};
 
 import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
 import android.database.sqlite.SQLiteDatabase.CursorFactory;
-import android.database.sqlite.SQLiteOpenHelper;
+import de.greenrobot.dao.wrapper.SQLiteOpenHelperWrapper;
 import android.util.Log;
 import de.greenrobot.dao.AbstractDaoMaster;
 import de.greenrobot.dao.identityscope.IdentityScopeType;
@@ -39,7 +39,7 @@ public class DaoMaster extends AbstractDaoMaster {
     public static final int SCHEMA_VERSION = ${schema.version?c};
 
     /** Creates underlying database table using DAOs. */
-    public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createAllTables(SQLiteDatabaseWrapper db, boolean ifNotExists) {
 <#list schema.entities as entity>
 <#if !entity.skipTableCreation>
         ${entity.classNameDao}.createTable(db, ifNotExists);
@@ -48,7 +48,7 @@ public class DaoMaster extends AbstractDaoMaster {
     }
     
     /** Drops underlying database table using DAOs. */
-    public static void dropAllTables(SQLiteDatabase db, boolean ifExists) {
+    public static void dropAllTables(SQLiteDatabaseWrapper db, boolean ifExists) {
 <#list schema.entities as entity>
 <#if !entity.skipTableCreation>
         ${entity.classNameDao}.dropTable(db, ifExists);
@@ -56,34 +56,34 @@ public class DaoMaster extends AbstractDaoMaster {
 </#list>
     }
     
-    public static abstract class OpenHelper extends SQLiteOpenHelper {
+    public static abstract class OpenHelper extends SQLiteOpenHelperWrapper  {
 
-        public OpenHelper(Context context, String name, CursorFactory factory) {
-            super(context, name, factory, SCHEMA_VERSION);
+        public OpenHelper(Context context, String name,char [] password, CursorFactory factory) {
+            super(context, name, password, factory, SCHEMA_VERSION);
         }
 
         @Override
-        public void onCreate(SQLiteDatabase db) {
+        public void onCreate(SQLiteDatabaseWrapper db) {
             Log.i("greenDAO", "Creating tables for schema version " + SCHEMA_VERSION);
             createAllTables(db, false);
         }
     }
     
     /** WARNING: Drops all table on Upgrade! Use only during development. */
-    public static class DevOpenHelper extends OpenHelper {
-        public DevOpenHelper(Context context, String name, CursorFactory factory) {
-            super(context, name, factory);
+    public static class DevOpenHelper extends SQLiteOpenHelperWrapper {
+        public DevOpenHelper(Context context, String name, char[] password, CursorFactory factory) {
+            super(context, name, password, factory);
         }
 
         @Override
-        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        public void onUpgrade(SQLiteDatabaseWrapper db, int oldVersion, int newVersion) {
             Log.i("greenDAO", "Upgrading schema from version " + oldVersion + " to " + newVersion + " by dropping all tables");
             dropAllTables(db, true);
             onCreate(db);
         }
     }
 
-    public DaoMaster(SQLiteDatabase db) {
+    public DaoMaster(SQLiteDatabaseWrapper db) {
         super(db, SCHEMA_VERSION);
 <#list schema.entities as entity>
         registerDaoClass(${entity.classNameDao}.class);
diff --git a/DaoGenerator/src-template/dao-session.ftl b/DaoGenerator/src-template/dao-session.ftl
index e0201a48..897143da 100644
--- a/DaoGenerator/src-template/dao-session.ftl
+++ b/DaoGenerator/src-template/dao-session.ftl
@@ -19,7 +19,7 @@ along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
 -->
 package ${schema.defaultJavaPackageDao};
 
-import android.database.sqlite.SQLiteDatabase;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
 
 import java.util.Map;
 
@@ -53,7 +53,7 @@ public class DaoSession extends AbstractDaoSession {
     private final ${entity.classNameDao} ${entity.classNameDao?uncap_first};
 </#list>        
 
-    public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>
+    public DaoSession(SQLiteDatabaseWrapper db, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>
             daoConfigMap) {
         super(db);
 
diff --git a/DaoGenerator/src-template/dao.ftl b/DaoGenerator/src-template/dao.ftl
index 443f74dc..ea8b3a99 100644
--- a/DaoGenerator/src-template/dao.ftl
+++ b/DaoGenerator/src-template/dao.ftl
@@ -28,8 +28,8 @@ import java.util.List;
 import java.util.ArrayList;
 </#if>
 import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.Property;
@@ -96,7 +96,7 @@ public class ${entity.classNameDao} extends AbstractDao<${entity.className}, ${e
 
 <#if !entity.skipTableCreation>
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(SQLiteDatabaseWrapper db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         db.execSQL("CREATE TABLE " + constraint + "'${entity.tableName}' (" + //
 <#list entity.propertiesColumns as property>
@@ -113,7 +113,7 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+    public static void dropTable(SQLiteDatabaseWrapper db, boolean ifExists) {
         String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'${entity.tableName}'";
         db.execSQL(sql);
     }
@@ -121,7 +121,7 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
 </#if>
     /** @inheritdoc */
     @Override
-    protected void bindValues(SQLiteStatement stmt, ${entity.className} entity) {
+    protected void bindValues(SQLiteStatementWrapper stmt, ${entity.className} entity) {
         stmt.clearBindings();
 <#list entity.properties as property>
 <#if property.notNull || entity.protobuf>
@@ -151,7 +151,15 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
                 // TODO bind ${toOne.name}__targetKey
             }
 <#else>
-            // TODO bind ${toOne.name}__targetKey
+
+            if (entity.get${entity.pkProperty.propertyName?cap_first}() == null) {
+            // TODO: Handle cyclic dependency to avoid recursive saving
+            ${toOne.targetEntity.className} ${toOne.name} = entity.get${toOne.name?cap_first}();
+            if (${toOne.name} != null && ${toOne.name}.get${toOne.targetEntity.pkProperty.propertyName?cap_first}() == null) {
+            daoSession.get${toOne.targetEntity.classNameDao}().insert(${toOne.name});
+            entity.set${toOne.name?cap_first}(${toOne.name});
+            }
+            }
 </#if>
         }
 </#if>
diff --git a/DaoGenerator/src-template/entity.ftl b/DaoGenerator/src-template/entity.ftl
index e40c0a18..9e9f678f 100644
--- a/DaoGenerator/src-template/entity.ftl
+++ b/DaoGenerator/src-template/entity.ftl
@@ -140,9 +140,9 @@ property>${property.javaType} ${property.propertyName}<#if property_has_next>, <
     public ${toOne.targetEntity.className} get${toOne.name?cap_first}() {
 <#if toOne.useFkProperty>
         ${toOne.fkProperties[0].javaType} __key = this.${toOne.fkProperties[0].propertyName};
-        if (${toOne.name}__resolvedKey == null || <#--
+        if (id != null && (${toOne.name}__resolvedKey == null || <#--
         --><#if toOne.resolvedKeyUseEquals[0]>!${toOne.name}__resolvedKey.equals(__key)<#--
-        --><#else>${toOne.name}__resolvedKey != __key</#if>) {
+        --><#else>${toOne.name}__resolvedKey != __key</#if>)) {
             if (daoSession == null) {
                 throw new DaoException("Entity is detached from DAO context");
             }
@@ -154,7 +154,7 @@ property>${property.javaType} ${property.propertyName}<#if property_has_next>, <
             }
         }
 <#else>
-        if (${toOne.name} != null || !${toOne.name}__refreshed) {
+        if (id != null && (${toOne.name} != null || !${toOne.name}__refreshed)) {
             if (daoSession == null) {
                 throw new DaoException("Entity is detached from DAO context");
             }
diff --git a/DaoTest/build.gradle b/DaoTest/build.gradle
index 4ba40c49..4189bc9c 100644
--- a/DaoTest/build.gradle
+++ b/DaoTest/build.gradle
@@ -4,7 +4,7 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:0.13.3'
+        classpath 'com.android.tools.build:gradle:1.0.1'
     }
 }
 
@@ -35,4 +35,4 @@ android {
         testApplicationId "de.greenrobot.daotest"
         testInstrumentationRunner "android.test.InstrumentationTestRunner"
     }
-}
+}
\ No newline at end of file
diff --git a/GreenDAO-Cipher b/GreenDAO-Cipher
new file mode 160000
index 00000000..03d1693b
--- /dev/null
+++ b/GreenDAO-Cipher
@@ -0,0 +1 @@
+Subproject commit 03d1693bedd3c90b2d4c91c81d293168d1ded8da
diff --git a/build.gradle b/build.gradle
index b62fff62..732328e9 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,3 +1,3 @@
 task wrapper(type: Wrapper) {
-    gradleVersion = '1.12'
+    gradleVersion = '2.0'
 }
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 3c7abdf1..c97a8bdb 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 54df5249..2aae77c6 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Sat May 24 08:38:11 CEST 2014
+#Tue Feb 03 21:51:29 CET 2015
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.1-all.zip
