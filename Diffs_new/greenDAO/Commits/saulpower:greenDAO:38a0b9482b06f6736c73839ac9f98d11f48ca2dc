diff --git a/DaoCore/build.gradle b/DaoCore/build.gradle
index 2a53a4a2..659e887b 100644
--- a/DaoCore/build.gradle
+++ b/DaoCore/build.gradle
@@ -27,6 +27,7 @@ configurations {
 }
 
 dependencies {
+    compile('com.google.code.gson:gson:2.2.4')
     provided 'com.google.android:android:4.1.1.4'
     provided 'com.google.android:android-test:4.1.1.4'
     provided 'com.google.android:annotations:4.1.1.4'
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDao.java b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
index 5c8f5b69..8c6b9fee 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDao.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
@@ -130,7 +130,7 @@ public T load(K key) {
         if (identityScope != null) {
             T entity = identityScope.get(key);
             if (entity != null) {
-                onLoadEntity(entity);
+                onPreLoadEntity(entity);
                 return entity;
             }
         }
@@ -265,7 +265,7 @@ private void executeInsertInTx(SQLiteStatement stmt, Iterable<T> entities, boole
                 }
                 try {
                     for (T entity : entities) {
-                        onInsertEntity(entity);
+                        onPreInsertEntity(entity);
                         bindValues(stmt, entity);
                         if (setPrimaryKey) {
                             long rowId = stmt.executeInsert();
@@ -306,7 +306,7 @@ public long insertWithoutSettingPk(T entity) {
         long rowId;
         if (db.isDbLockedByCurrentThread()) {
             synchronized (stmt) {
-                onInsertEntity(entity);
+                onPreInsertEntity(entity);
                 bindValues(stmt, entity);
                 rowId = stmt.executeInsert();
             }
@@ -315,7 +315,7 @@ public long insertWithoutSettingPk(T entity) {
             db.beginTransaction();
             try {
                 synchronized (stmt) {
-                    onInsertEntity(entity);
+                    onPreInsertEntity(entity);
                     bindValues(stmt, entity);
                     rowId = stmt.executeInsert();
                 }
@@ -340,7 +340,7 @@ private long executeInsert(T entity, SQLiteStatement stmt) {
         long rowId;
         if (db.isDbLockedByCurrentThread()) {
             synchronized (stmt) {
-                onInsertEntity(entity);
+                onPreInsertEntity(entity);
                 bindValues(stmt, entity);
                 rowId = stmt.executeInsert();
             }
@@ -349,7 +349,7 @@ private long executeInsert(T entity, SQLiteStatement stmt) {
             db.beginTransaction();
             try {
                 synchronized (stmt) {
-                    onInsertEntity(entity);
+                    onPreInsertEntity(entity);
                     bindValues(stmt, entity);
                     rowId = stmt.executeInsert();
                 }
@@ -418,11 +418,11 @@ final protected T loadCurrent(Cursor cursor, int offset, boolean lock) {
             long key = cursor.getLong(pkOrdinal + offset);
             T entity = lock ? identityScopeLong.get2(key) : identityScopeLong.get2NoLock(key);
             if (entity != null) {
-                onLoadEntity(entity);
+                onPreLoadEntity(entity);
                 return entity;
             } else {
                 entity = readEntity(cursor, offset);
-                onLoadEntity(entity);
+                onPreLoadEntity(entity);
                 attachEntity(entity);
                 if (lock) {
                     identityScopeLong.put2(key, entity);
@@ -442,7 +442,7 @@ final protected T loadCurrent(Cursor cursor, int offset, boolean lock) {
                 return entity;
             } else {
                 entity = readEntity(cursor, offset);
-                onLoadEntity(entity);
+                onPreLoadEntity(entity);
                 attachEntity(key, entity, lock);
                 return entity;
             }
@@ -456,7 +456,7 @@ final protected T loadCurrent(Cursor cursor, int offset, boolean lock) {
                 }
             }
             T entity = readEntity(cursor, offset);
-            onLoadEntity(entity);
+            onPreLoadEntity(entity);
             attachEntity(entity);
             return entity;
         }
@@ -503,7 +503,7 @@ public void deleteAll() {
     /** Deletes the given entity from the database. Currently, only single value PK entities are supported. */
     public void delete(T entity) {
         assertSinglePk();
-        onDeleteEntity(entity);
+        onPreDeleteEntity(entity);
         K key = getKeyVerified(entity);
         deleteByKey(key);
     }
@@ -558,7 +558,7 @@ private void deleteInTxInternal(Iterable<T> entities, Iterable<K> keys) {
                 try {
                     if (entities != null) {
                         for (T entity : entities) {
-                            onDeleteEntity(entity);
+                            onPreDeleteEntity(entity);
                             K key = getKeyVerified(entity);
                             deleteByKeyInsideSynchronized(key, stmt);
                             if (keysToRemoveFromIdentityScope != null) {
@@ -632,7 +632,7 @@ public void deleteByKeyInTx(K... keys) {
     /** Resets all locally changed properties of the entity by reloading the values from the database. */
     public void refresh(T entity) {
 
-        onRefreshEntity(entity);
+        onPreRefreshEntity(entity);
 
         assertSinglePk();
         K key = getKeyVerified(entity);
@@ -681,7 +681,7 @@ public void update(T entity) {
 
     protected void updateInsideSynchronized(T entity, SQLiteStatement stmt, boolean lock) {
 
-        onUpdateEntity(entity);
+        onPreUpdateEntity(entity);
 
         // To do? Check if it's worth not to bind PKs here (performance).
         bindValues(stmt, entity);
@@ -823,18 +823,18 @@ public SQLiteDatabase getDatabase() {
     /** Returns true if the Entity class can be updated, e.g. for setting the PK after insert. */
     abstract protected boolean isEntityUpdateable();
 
-    protected void onInsertEntity(T entity) {
+    protected void onPreInsertEntity(T entity) {
     }
 
-    protected void onLoadEntity(T entity) {
+    protected void onPreLoadEntity(T entity) {
     }
 
-    protected void onRefreshEntity(T entity) {
+    protected void onPreRefreshEntity(T entity) {
     }
 
-    protected void onUpdateEntity(T entity) {
+    protected void onPreUpdateEntity(T entity) {
     }
 
-    protected void onDeleteEntity(T entity) {
+    protected void onPreDeleteEntity(T entity) {
     }
 }
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java b/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
index 6a37ef2a..347f3571 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
@@ -15,15 +15,15 @@
  */
 package de.greenrobot.dao;
 
+import android.database.sqlite.SQLiteDatabase;
+import de.greenrobot.dao.async.AsyncSession;
+import de.greenrobot.dao.query.QueryBuilder;
+
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.Callable;
 
-import android.database.sqlite.SQLiteDatabase;
-import de.greenrobot.dao.async.AsyncSession;
-import de.greenrobot.dao.query.QueryBuilder;
-
 /**
  * DaoSession gives you access to your DAOs, offers convenient persistence methods, and also serves as a session cache.<br/>
  * <br/>
@@ -56,6 +56,10 @@ public AbstractDaoSession(SQLiteDatabase db) {
         entityToDao.put(entityClass, dao);
     }
 
+    public Map<Class<?>, AbstractDao<?, ?>> getDaos() {
+        return entityToDao;
+    }
+
     /** Convenient call for {@link AbstractDao#insert(Object)}. */
     public <T> long insert(T entity) {
         @SuppressWarnings("unchecked")
diff --git a/DaoCore/src/de/greenrobot/dao/query/Query.java b/DaoCore/src/de/greenrobot/dao/query/Query.java
index 4d36b1b0..2e8e0572 100644
--- a/DaoCore/src/de/greenrobot/dao/query/Query.java
+++ b/DaoCore/src/de/greenrobot/dao/query/Query.java
@@ -15,13 +15,12 @@
  */
 package de.greenrobot.dao.query;
 
-import java.util.List;
-
 import android.database.Cursor;
-import android.os.Process;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoException;
 
+import java.util.List;
+
 /**
  * A repeatable query returning entities.
  * 
@@ -121,6 +120,15 @@ public void setOffset(int offset) {
         return daoAccess.loadAllAndCloseCursor(cursor);
     }
 
+    /**
+     * Executes the query and returns the cursor
+     * @return the cursor
+     */
+    public Cursor getCursor() {
+        checkThread();
+        return dao.getDatabase().rawQuery(sql, parameters);
+    }
+
     /**
      * Executes the query and returns the result as a list that lazy loads the entities on first access. Entities are
      * cached, so accessing the same entity more than once will not result in loading an entity from the underlying
diff --git a/DaoCore/src/de/greenrobot/dao/sync/EntityTypeAdapterFactory.java b/DaoCore/src/de/greenrobot/dao/sync/EntityTypeAdapterFactory.java
new file mode 100644
index 00000000..b82d259b
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/sync/EntityTypeAdapterFactory.java
@@ -0,0 +1,124 @@
+package de.greenrobot.dao.sync;
+
+import com.google.gson.Gson;
+import com.google.gson.TypeAdapter;
+import com.google.gson.TypeAdapterFactory;
+import com.google.gson.reflect.TypeToken;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonToken;
+import com.google.gson.stream.JsonWriter;
+import de.greenrobot.dao.DaoEnum;
+
+import java.io.IOException;
+import java.lang.reflect.Type;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Created by saulhoward on 3/25/14.
+ */
+public class EntityTypeAdapterFactory implements TypeAdapterFactory {
+
+    public final String TAG = getClass().getSimpleName();
+
+    private GreenSync mGreenSync;
+
+    public EntityTypeAdapterFactory(GreenSync greenSync) {
+        mGreenSync = greenSync;
+    }
+
+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
+
+        Class<T> rawType = (Class<T>) type.getRawType();
+
+        if (rawType.isEnum()) {
+            return new EnumTypeAdapter<T>((Class<? extends DaoEnum>) rawType);
+        }
+
+        if (Map.class.isAssignableFrom(rawType)) {
+            return new MapTypeAdapter<T>(gson, gson.getDelegateAdapter(this, type));
+        }
+
+        return null;
+    }
+
+    private class EnumTypeAdapter<T> extends TypeAdapter<T> {
+
+        private EnumAdapter adapter;
+
+        public EnumTypeAdapter(Class<? extends DaoEnum> rawType) {
+            adapter = mGreenSync.enumAdapter(rawType);
+        }
+
+        public void write(JsonWriter out, T value) throws IOException {
+            if (value == null) {
+                out.nullValue();
+            } else {
+                out.value(adapter.toInt((DaoEnum) value));
+            }
+        }
+
+        public T read(JsonReader reader) throws IOException {
+            if (reader.peek() == JsonToken.NULL) {
+                reader.nextNull();
+                return null;
+            } else {
+                return (T) adapter.fromInt(reader.nextInt());
+            }
+        }
+    };
+
+    private class MapTypeAdapter<T> extends TypeAdapter<T> {
+
+        private TypeAdapter<T> mDefault;
+        private Gson mGson;
+
+        public MapTypeAdapter(Gson gson, TypeAdapter<T> mDefault) {
+            mGson = gson;
+            this.mDefault = mDefault;
+        }
+
+        @Override
+        public void write(JsonWriter out, T value) throws IOException {
+            mDefault.write(out, value);
+        }
+
+        @Override
+        public T read(JsonReader in) throws IOException {
+
+            JsonToken peek = in.peek();
+            if (peek == JsonToken.NULL) {
+                in.nextNull();
+                return null;
+            }
+
+            Map<String, Map> map = new HashMap<String, Map>();
+
+            in.beginObject();
+            while (in.hasNext()) {
+                String name = in.nextName();
+                map.put(name, readAction(in));
+            }
+            in.endObject();
+
+            return (T) map;
+        }
+
+        private Map readAction(JsonReader in) throws IOException {
+
+            Map<String, List> map = new HashMap<String, List>();
+
+            in.beginObject();
+            while (in.hasNext()) {
+                String name = in.nextName();
+                Type type = GreenSync.getTypeToken(name);
+                List list = mGson.fromJson(in, type);
+                map.put(name, list);
+            }
+            in.endObject();
+
+            return map;
+        }
+    }
+}
\ No newline at end of file
diff --git a/GreenSync/src/de/greenrobot/sync/EnumAdapter.java b/DaoCore/src/de/greenrobot/dao/sync/EnumAdapter.java
similarity index 97%
rename from GreenSync/src/de/greenrobot/sync/EnumAdapter.java
rename to DaoCore/src/de/greenrobot/dao/sync/EnumAdapter.java
index bdb066d7..0b8dd753 100644
--- a/GreenSync/src/de/greenrobot/sync/EnumAdapter.java
+++ b/DaoCore/src/de/greenrobot/dao/sync/EnumAdapter.java
@@ -1,4 +1,4 @@
-package de.greenrobot.sync;
+package de.greenrobot.dao.sync;
 
 import de.greenrobot.dao.DaoEnum;
 
diff --git a/DaoCore/src/de/greenrobot/dao/sync/GreenSync.java b/DaoCore/src/de/greenrobot/dao/sync/GreenSync.java
new file mode 100644
index 00000000..c8f0254d
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/sync/GreenSync.java
@@ -0,0 +1,130 @@
+package de.greenrobot.dao.sync;
+
+import com.google.gson.FieldNamingPolicy;
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.reflect.TypeToken;
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.AbstractDaoSession;
+import de.greenrobot.dao.DaoEnum;
+
+import java.lang.reflect.Modifier;
+import java.lang.reflect.Type;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Created by saulhoward on 3/21/14.
+ */
+public class GreenSync {
+
+    private static Map<String, Type> sListTypeTokensMap = new HashMap<String, Type>();
+    private static Map<String, Class<?>> sClassMap = new HashMap<String, Class<?>>();
+
+    public static final String CREATED = "Created";
+    public static final String UPDATED = "Updated";
+    public static final String DELETED = "Deleted";
+
+    private Gson mGson;
+    private GreenSyncDaoBase mGreenSyncDaoBase;
+    private AbstractDaoSession mSession;
+
+    private final Map<Class<? extends DaoEnum>, EnumAdapter<? extends DaoEnum>> enumAdapters =
+            new LinkedHashMap<Class<? extends DaoEnum>, EnumAdapter<? extends DaoEnum>>();
+
+    public static void registerListTypeToken(String key, Type type) {
+        sListTypeTokensMap.put(key, type);
+    }
+
+    public static void registerTypeToken(String key, Class<?> clazz) {
+        sClassMap.put(key, clazz);
+    }
+
+    public static Type getTypeToken(String key) {
+        return sListTypeTokensMap.get(key);
+    }
+
+    public GreenSync(AbstractDaoSession session) {
+        final GsonBuilder builder = new GsonBuilder();
+        builder.excludeFieldsWithModifiers(Modifier.TRANSIENT);
+        builder.registerTypeAdapterFactory(new EntityTypeAdapterFactory(this));
+        builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE);
+        mGson = builder.create();
+        mSession = session;
+
+        for (AbstractDao dao : mSession.getDaos().values()) {
+            if (dao instanceof GreenSyncDaoBase) {
+                mGreenSyncDaoBase = (GreenSyncDaoBase) dao;
+            }
+        }
+
+        if (mGreenSyncDaoBase == null) throw new ExceptionInInitializerError("Missing sync base");
+    }
+
+    /**
+     * Returns an enum adapter for {@code enumClass}.
+     */
+    @SuppressWarnings("unchecked")
+    synchronized <E extends DaoEnum> EnumAdapter<E> enumAdapter(Class<E> enumClass) {
+        EnumAdapter<E> adapter = (EnumAdapter<E>) enumAdapters.get(enumClass);
+        if (adapter == null) {
+            adapter = new EnumAdapter<E>(enumClass);
+            enumAdapters.put(enumClass, adapter);
+        }
+        return adapter;
+    }
+
+    public String sync() {
+
+        Map<String, Map> syncObjects = new HashMap<String, Map>();
+
+        syncObjects.put(CREATED, mGreenSyncDaoBase.getCreatedObjects());
+        syncObjects.put(UPDATED, mGreenSyncDaoBase.getUpdatedObjects());
+        syncObjects.put(DELETED, mGreenSyncDaoBase.getDeletedObjects());
+
+        return mGson.toJson(syncObjects);
+    }
+
+    public void processResponse(String json) {
+
+        Type listType = new TypeToken<Map<String, List>>() {}.getType();
+        Map<String, Map> map =  mGson.fromJson(json, listType);
+
+        for (Map.Entry<String, Map> action : map.entrySet()) {
+            if (action.getKey().equals(CREATED)) {
+                processCreated(action.getValue());
+            } else if (action.getKey().equals(UPDATED)) {
+                processUpdated(action.getValue());
+            } else if (action.getKey().equals(DELETED)) {
+                processDeleted(action.getValue());
+            }
+        }
+    }
+
+    private void processCreated(Map<String, List> objects) {
+        for (Map.Entry<String, List> object : objects.entrySet()) {
+            Class<?> clazz = sClassMap.get(object.getKey());
+            mSession.getDao(clazz).insertInTx(object.getValue());
+        }
+    }
+
+    private void processUpdated(Map<String, List> objects) {
+        for (Map.Entry<String, List> object : objects.entrySet()) {
+            Class<?> clazz = sClassMap.get(object.getKey());
+            mSession.getDao(clazz).updateInTx(object.getValue());
+        }
+    }
+
+    private void processDeleted(Map<String, List> objects) {
+        for (Map.Entry<String, List> object : objects.entrySet()) {
+            Class<?> clazz = sClassMap.get(object.getKey());
+            mSession.getDao(clazz).deleteInTx(object.getValue());
+        }
+    }
+
+    private void loadPrimaryKey(AbstractDao dao, List<GreenSyncBase> objects) {
+        dao.getDatabase();
+    }
+}
diff --git a/DaoCore/src/de/greenrobot/dao/sync/GreenSyncBase.java b/DaoCore/src/de/greenrobot/dao/sync/GreenSyncBase.java
new file mode 100644
index 00000000..5eb2891d
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/sync/GreenSyncBase.java
@@ -0,0 +1,8 @@
+package de.greenrobot.dao.sync;
+
+/**
+ * Created by saulhoward on 3/31/14.
+ */
+public interface GreenSyncBase {
+    String getExternalId();
+}
diff --git a/DaoCore/src/de/greenrobot/dao/sync/GreenSyncDaoBase.java b/DaoCore/src/de/greenrobot/dao/sync/GreenSyncDaoBase.java
new file mode 100644
index 00000000..0eb7dca3
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/sync/GreenSyncDaoBase.java
@@ -0,0 +1,13 @@
+package de.greenrobot.dao.sync;
+
+import java.util.Map;
+
+/**
+ * Created by saulhoward on 3/27/14.
+ */
+public interface GreenSyncDaoBase {
+
+    Map getUpdatedObjects();
+    Map getDeletedObjects();
+    Map getCreatedObjects();
+}
diff --git a/DaoExample/.classpath b/DaoExample/.classpath
deleted file mode 100644
index 6a988e59..00000000
--- a/DaoExample/.classpath
+++ /dev/null
@@ -1,11 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="src" path="src-gen"/>
-	<classpathentry kind="src" path="src-test"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/DaoExample/.project b/DaoExample/.project
deleted file mode 100644
index 0d480710..00000000
--- a/DaoExample/.project
+++ /dev/null
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>DaoExample</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/DaoExample/.settings/org.eclipse.core.resources.prefs b/DaoExample/.settings/org.eclipse.core.resources.prefs
deleted file mode 100644
index 3d916f29..00000000
--- a/DaoExample/.settings/org.eclipse.core.resources.prefs
+++ /dev/null
@@ -1,2 +0,0 @@
-eclipse.preferences.version=1
-encoding/<project>=Cp1252
diff --git a/DaoExample/.settings/org.eclipse.jdt.core.prefs b/DaoExample/.settings/org.eclipse.jdt.core.prefs
deleted file mode 100644
index e8465841..00000000
--- a/DaoExample/.settings/org.eclipse.jdt.core.prefs
+++ /dev/null
@@ -1,12 +0,0 @@
-#Sat Jan 28 16:28:37 CET 2012
-eclipse.preferences.version=1
-org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
-org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
-org.eclipse.jdt.core.compiler.compliance=1.6
-org.eclipse.jdt.core.compiler.debug.lineNumber=generate
-org.eclipse.jdt.core.compiler.debug.localVariable=generate
-org.eclipse.jdt.core.compiler.debug.sourceFile=generate
-org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
-org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
-org.eclipse.jdt.core.compiler.source=1.6
diff --git a/DaoExample/build.gradle b/DaoExample/build.gradle
index 6bce52b3..ed5308d1 100644
--- a/DaoExample/build.gradle
+++ b/DaoExample/build.gradle
@@ -11,14 +11,13 @@ repositories {
 }
 
 dependencies {
-    compile('de.greenrobot:greendao:1.3.0')
+    compile fileTree(dir: 'libs', include: '*.jar')
 }
 
 sourceSets {
     main {
         java {
             srcDir 'src'
-            srcDir 'src-gen'
             srcDir 'gen'
         }
     }
diff --git a/DaoExample/libs/greendao-1.3.0-beta-1.jar b/DaoExample/libs/greendao-1.3.0-beta-1.jar
deleted file mode 100644
index 473993d4..00000000
Binary files a/DaoExample/libs/greendao-1.3.0-beta-1.jar and /dev/null differ
diff --git a/DaoExample/settings.gradle b/DaoExample/settings.gradle
index 96dff2be..2bffdb4c 100644
--- a/DaoExample/settings.gradle
+++ b/DaoExample/settings.gradle
@@ -1 +1,2 @@
+include 'DaoCore'
 rootProject.name = 'greendao-example'
\ No newline at end of file
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/database/BaseObjectDao.java b/DaoExample/src-gen/de/greenrobot/daoexample/database/BaseObjectDao.java
deleted file mode 100644
index da33994b..00000000
--- a/DaoExample/src-gen/de/greenrobot/daoexample/database/BaseObjectDao.java
+++ /dev/null
@@ -1,139 +0,0 @@
-package de.greenrobot.daoexample.database;
-
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
-
-import de.greenrobot.dao.AbstractDao;
-import de.greenrobot.dao.Property;
-import de.greenrobot.dao.internal.DaoConfig;
-
-import de.greenrobot.daoexample.database.BaseObject;
-
-// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
-/** 
- * DAO for table BASE_OBJECT.
-*/
-public class BaseObjectDao extends AbstractDao<BaseObject, Long> {
-
-    public static final String TABLENAME = "BASE_OBJECT";
-
-    /**
-     * Properties of entity BaseObject.<br/>
-     * Can be used for QueryBuilder and for referencing column names.
-    */
-    public static class Properties {
-        public final static Property UpdatedOn = new Property(0, java.util.Date.class, "updatedOn", false, "UPDATED_ON");
-        public final static Property CreatedOn = new Property(1, java.util.Date.class, "createdOn", false, "CREATED_ON");
-        public final static Property DerivedEntityType = new Property(2, String.class, "derivedEntityType", false, "DERIVED_ENTITY_TYPE");
-        public final static Property BaseId = new Property(3, Long.class, "baseId", true, "BASE_ID");
-    };
-
-    private DaoSession daoSession;
-
-
-    public BaseObjectDao(DaoConfig config) {
-        super(config);
-    }
-    
-    public BaseObjectDao(DaoConfig config, DaoSession daoSession) {
-        super(config, daoSession);
-        this.daoSession = daoSession;
-    }
-
-    /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
-        String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'BASE_OBJECT' (" + //
-                "'UPDATED_ON' INTEGER," + // 0: updatedOn
-                "'CREATED_ON' INTEGER," + // 1: createdOn
-                "'DERIVED_ENTITY_TYPE' TEXT NOT NULL ," + // 2: derivedEntityType
-                "'BASE_ID' INTEGER PRIMARY KEY );"); // 3: baseId
-    }
-
-    /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'BASE_OBJECT'";
-        db.execSQL(sql);
-    }
-
-    /** @inheritdoc */
-    @Override
-    protected void bindValues(SQLiteStatement stmt, BaseObject entity) {
-        stmt.clearBindings();
- 
-        java.util.Date updatedOn = entity.getUpdatedOn();
-        if (updatedOn != null) {
-            stmt.bindLong(1, updatedOn.getTime());
-        }
- 
-        java.util.Date createdOn = entity.getCreatedOn();
-        if (createdOn != null) {
-            stmt.bindLong(2, createdOn.getTime());
-        }
-        stmt.bindString(3, entity.getDerivedEntityType());
- 
-        Long baseId = entity.getBaseId();
-        if (baseId != null) {
-            stmt.bindLong(4, baseId);
-        }
-    }
-
-    @Override
-    protected void attachEntity(BaseObject entity) {
-        super.attachEntity(entity);
-        entity.__setDaoSession(daoSession);
-    }
-
-    /** @inheritdoc */
-    @Override
-    public Long readKey(Cursor cursor, int offset) {
-        return cursor.isNull(offset + 3) ? null : cursor.getLong(offset + 3);
-    }    
-
-    /** @inheritdoc */
-    @Override
-    public BaseObject readEntity(Cursor cursor, int offset) {
-        BaseObject entity = new BaseObject( //
-            cursor.isNull(offset + 0) ? null : new java.util.Date(cursor.getLong(offset + 0)), // updatedOn
-            cursor.isNull(offset + 1) ? null : new java.util.Date(cursor.getLong(offset + 1)), // createdOn
-            cursor.getString(offset + 2), // derivedEntityType
-            cursor.isNull(offset + 3) ? null : cursor.getLong(offset + 3) // baseId
-        );
-        return entity;
-    }
-     
-    /** @inheritdoc */
-    @Override
-    public void readEntity(Cursor cursor, BaseObject entity, int offset) {
-        entity.setUpdatedOn(cursor.isNull(offset + 0) ? null : new java.util.Date(cursor.getLong(offset + 0)));
-        entity.setCreatedOn(cursor.isNull(offset + 1) ? null : new java.util.Date(cursor.getLong(offset + 1)));
-        entity.setDerivedEntityType(cursor.getString(offset + 2));
-        entity.setBaseId(cursor.isNull(offset + 3) ? null : cursor.getLong(offset + 3));
-     }
-    
-    /** @inheritdoc */
-    @Override
-    protected Long updateKeyAfterInsert(BaseObject entity, long rowId) {
-        entity.setBaseId(rowId);
-        return rowId;
-    }
-    
-    /** @inheritdoc */
-    @Override
-    public Long getKey(BaseObject entity) {
-        if(entity != null) {
-            return entity.getBaseId();
-        } else {
-            return null;
-        }
-    }
-
-    /** @inheritdoc */
-    @Override    
-    protected boolean isEntityUpdateable() {
-        return true;
-    }
-    
-
-}
diff --git a/DaoExample/src/de/greenrobot/daoexample/NoteActivity.java b/DaoExample/src/de/greenrobot/daoexample/NoteActivity.java
index f60401e4..c8067b3f 100644
--- a/DaoExample/src/de/greenrobot/daoexample/NoteActivity.java
+++ b/DaoExample/src/de/greenrobot/daoexample/NoteActivity.java
@@ -16,28 +16,35 @@
 package de.greenrobot.daoexample;
 
 import android.app.ListActivity;
-import android.database.Cursor;
+import android.content.Context;
 import android.database.sqlite.SQLiteDatabase;
 import android.os.Bundle;
 import android.text.Editable;
 import android.text.TextWatcher;
 import android.util.Log;
 import android.view.KeyEvent;
+import android.view.LayoutInflater;
 import android.view.View;
+import android.view.ViewGroup;
 import android.view.inputmethod.EditorInfo;
+import android.widget.ArrayAdapter;
 import android.widget.EditText;
 import android.widget.ListView;
-import android.widget.SimpleCursorAdapter;
 import android.widget.TextView;
 import android.widget.TextView.OnEditorActionListener;
+import de.greenrobot.dao.sync.GreenSync;
 import de.greenrobot.daoexample.database.*;
 import de.greenrobot.daoexample.database.DaoMaster.DevOpenHelper;
 
 import java.text.DateFormat;
+import java.util.ArrayList;
 import java.util.Date;
+import java.util.List;
 
 public class NoteActivity extends ListActivity {
 
+    public final String TAG = getClass().getSimpleName();
+
     private SQLiteDatabase db;
 
     private EditText editText;
@@ -45,8 +52,59 @@
     private DaoMaster daoMaster;
     private DaoSession daoSession;
     private NoteDao noteDao;
+    private CustomerDao customerDao;
+    private List<Note> notes;
+    private List<Customer> customers;
+    private MyAdapter adapter;
+    private GreenSync greenSync;
+
+    public static class MyAdapter extends ArrayAdapter<Note> {
+
+        int mResource;
+        LayoutInflater mInflater;
+
+        public MyAdapter(Context context, int resource, List<Note> objects) {
+            super(context, resource, objects);
+
+            mResource = resource;
+            mInflater = (LayoutInflater) getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+        }
+
+        @Override
+        public View getView(int position, View convertView, ViewGroup parent) {
+
+            View view = convertView;
+            ViewHolder viewHolder;
+
+            if (view == null) {
+                view = mInflater.inflate(mResource, parent, false);
+                TextView title = (TextView) view.findViewById(android.R.id.text1);
+                TextView subTitle = (TextView) view.findViewById(android.R.id.text2);
+                viewHolder = new ViewHolder(title, subTitle);
+                view.setTag(viewHolder);
+            } else {
+                viewHolder = (ViewHolder) view.getTag();
+            }
+
+            Note note = getItem(position);
+
+            viewHolder.title.setText(note.getText());
+            viewHolder.subTitle.setText(note.getComment());
+
+            return view;
+        }
+
+        static class ViewHolder {
+
+            public ViewHolder(TextView title, TextView subTitle) {
+                this.title = title;
+                this.subTitle = subTitle;
+            }
 
-    private Cursor cursor;
+            TextView title;
+            TextView subTitle;
+        }
+    }
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
@@ -56,24 +114,56 @@ public void onCreate(Bundle savedInstanceState) {
 
         DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, "notes-db", null);
         db = helper.getWritableDatabase();
+
+        DaoMaster.dropAllTables(db, true);
+        DaoMaster.createAllTables(db, true);
+
         daoMaster = new DaoMaster(db);
         daoSession = daoMaster.newSession();
         noteDao = daoSession.getNoteDao();
+        customerDao = daoSession.getCustomerDao();
 
-        String textColumn = NoteDao.Properties.Text.columnName;
-        String orderBy = textColumn + " COLLATE LOCALIZED ASC";
-        cursor = db.query(noteDao.getTablename(), noteDao.getAllColumns(), null, null, null, null, orderBy);
-        String[] from = { textColumn, NoteDao.Properties.Comment.columnName };
-        int[] to = { android.R.id.text1, android.R.id.text2 };
+        greenSync = new GreenSync(daoSession);
 
-        SimpleCursorAdapter adapter = new SimpleCursorAdapter(this, android.R.layout.simple_list_item_2, cursor, from,
-                to);
+        createDemoData();
+
+        notes = noteDao.loadAll();
+        customers = customerDao.loadAll();
+        toJson();
+
+        adapter = new MyAdapter(this, android.R.layout.simple_list_item_2, notes);
         setListAdapter(adapter);
 
         editText = (EditText) findViewById(R.id.editTextNote);
         addUiListeners();
     }
 
+    private void createDemoData() {
+
+        int max = 5;
+
+        List<Note> demoNotes = new ArrayList<Note>();
+        List<Customer> demoCustomers = new ArrayList<Customer>();
+
+        for (int i = 0; i < max; i++) {
+
+            Note note = new Note("comment " + i, "text " + i, null, NoteType.fromInt(i % 3));
+            note.setCreatedOn(new Date());
+            note.setUpdatedOn(new Date());
+            demoNotes.add(note);
+
+            Customer customer = new Customer("Joe Bob" + i, null);
+            customer.setCreatedOn(new Date());
+            customer.setUpdatedOn(new Date());
+            demoCustomers.add(customer);
+        }
+
+        noteDao.insertInTx(demoNotes);
+        customerDao.insertInTx(demoCustomers);
+
+        noteDao.updateInTx(demoNotes.subList(0, max / 2));
+    }
+
     protected void addUiListeners() {
         editText.setOnEditorActionListener(new OnEditorActionListener() {
 
@@ -117,18 +207,36 @@ private void addNote() {
 
         final DateFormat df = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM);
         String comment = "Added on " + df.format(new Date());
-        Note note = new Note(comment, new Date(), noteText, null, NoteType.FRISBEE);
+        Note note = new Note(comment, noteText, null, NoteType.FRISBEE);
+        note.setCreatedOn(new Date());
+        note.setUpdatedOn(new Date());
         noteDao.insert(note);
-        Log.d("DaoExample", "Inserted new note, ID: " + note.getId());
 
-        cursor.requery();
+        Customer customer = new Customer("Joe Bob", null);
+        customerDao.insert(customer);
+
+        notes.add(note);
+        customers.add(customer);
+        adapter.notifyDataSetChanged();
+
+        toJson();
     }
 
     @Override
     protected void onListItemClick(ListView l, View v, int position, long id) {
-        noteDao.deleteByKey(id);
-        Log.d("DaoExample", "Deleted note, ID: " + id);
-        cursor.requery();
+
+        noteDao.delete(notes.get(position));
+
+        notes.remove(position);
+        adapter.notifyDataSetChanged();
     }
 
+    private void toJson() {
+        Long start = System.currentTimeMillis();
+        String json = greenSync.sync();
+        Log.i(TAG, "Write: " + json);
+        start = System.currentTimeMillis();
+        greenSync.processResponse(json);
+        Log.i(TAG, "Read: " + (System.currentTimeMillis() - start));
+    }
 }
\ No newline at end of file
diff --git a/DaoExample/src/de/greenrobot/daoexample/database/BaseState.java b/DaoExample/src/de/greenrobot/daoexample/database/BaseState.java
new file mode 100644
index 00000000..45225866
--- /dev/null
+++ b/DaoExample/src/de/greenrobot/daoexample/database/BaseState.java
@@ -0,0 +1,38 @@
+package de.greenrobot.daoexample.database;
+
+import de.greenrobot.dao.DaoEnum;
+import java.util.HashMap;
+import java.util.Map;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+
+public enum BaseState implements DaoEnum {
+    CREATE(1),
+    UPDATE(2),
+    DELETE(3),
+    CLEAN(3);
+
+    private static final Map<Long, BaseState> intToTypeMap = new HashMap<Long, BaseState>();
+
+    static {
+        for (BaseState type : BaseState.values()) {
+            intToTypeMap.put(type.value, type);
+        }
+    }
+
+    public static BaseState fromInt(long i) {
+        BaseState type = intToTypeMap.get(Long.valueOf(i));
+        return type;
+    }
+
+    private final long value;
+
+    private BaseState(long value) {
+        this.value = value;
+    }
+
+    @Override
+    public long getValue() {
+        return value;
+    }
+}
\ No newline at end of file
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/database/Customer.java b/DaoExample/src/de/greenrobot/daoexample/database/Customer.java
similarity index 82%
rename from DaoExample/src-gen/de/greenrobot/daoexample/database/Customer.java
rename to DaoExample/src/de/greenrobot/daoexample/database/Customer.java
index 33e96c8a..ba9bfde4 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/database/Customer.java
+++ b/DaoExample/src/de/greenrobot/daoexample/database/Customer.java
@@ -1,19 +1,21 @@
 package de.greenrobot.daoexample.database;
 
 import java.util.List;
+import de.greenrobot.dao.sync.GreenSync;
+import com.google.gson.reflect.TypeToken;
 import de.greenrobot.dao.DaoEnum;
-import java.util.HashMap;
 import java.util.Map;
+import java.util.HashMap;
 
-import de.greenrobot.daoexample.database.DaoSession;
 import de.greenrobot.dao.DaoException;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
  * Entity mapped to table CUSTOMER.
  */
-public class Customer {
+public class Customer extends SyncBase  {
 
+    private transient Long syncBaseId;
     /** Not-null value. */
     private String name;
     private transient Long id;
@@ -23,7 +25,6 @@
 
     /** Used for active entity operations. */
     private transient CustomerDao myDao;
-
     private List<Order> orders;
 
     public Customer() {
@@ -31,31 +32,47 @@ public Customer() {
 
     public Customer(Long id) {
         this.id = id;
+        setDerivedEntityType(getClass().getCanonicalName());
+    }
+
+    Customer(Long syncBaseId, String name, Long id) {
+        this.syncBaseId = syncBaseId;
+        this.name = name;
+        this.id = id;
     }
 
     public Customer(String name, Long id) {
         this.name = name;
         this.id = id;
+        setDerivedEntityType(getClass().getCanonicalName());
     }
 
     /** called by internal mechanisms, do not call yourself. */
+    @Override
     public void __setDaoSession(DaoSession daoSession) {
+        super.__setDaoSession(daoSession);
         this.daoSession = daoSession;
         myDao = daoSession != null ? daoSession.getCustomerDao() : null;
     }
 
+    public Long getSyncBaseId() {
+        return syncBaseId;
+    }
+
+    public void setSyncBaseId(Long syncBaseId) {
+        this.syncBaseId = syncBaseId;
+    }
 
     /** Not-null value. */
     public String getName() {
         return name;
     }
-    /** Not-null value; ensure this value is available before it is saved to the database. */
 
+    /** Not-null value; ensure this value is available before it is saved to the database. */
     public void setName(String name) {
         this.name = name;
     }
 
-
     public Long getId() {
         return id;
     }
@@ -140,4 +157,9 @@ public void refresh() {
         myDao.refresh(this);
     }
 
-}
+    static {
+        GreenSync.registerListTypeToken("Customer", new TypeToken<List<Customer>>(){}.getType());
+        GreenSync.registerTypeToken("Customer", Customer.class);
+    }
+
+}
\ No newline at end of file
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/database/CustomerDao.java b/DaoExample/src/de/greenrobot/daoexample/database/CustomerDao.java
similarity index 58%
rename from DaoExample/src-gen/de/greenrobot/daoexample/database/CustomerDao.java
rename to DaoExample/src/de/greenrobot/daoexample/database/CustomerDao.java
index 152708db..afd3a33c 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/database/CustomerDao.java
+++ b/DaoExample/src/de/greenrobot/daoexample/database/CustomerDao.java
@@ -23,13 +23,13 @@
      * Can be used for QueryBuilder and for referencing column names.
     */
     public static class Properties {
-        public final static Property Name = new Property(0, String.class, "name", false, "NAME");
-        public final static Property Id = new Property(1, Long.class, "id", true, "_id");
+        public final static Property SyncBaseId = new Property(0, Long.class, "syncBaseId", false, "SYNC_BASE_ID");
+        public final static Property Name = new Property(1, String.class, "name", false, "NAME");
+        public final static Property Id = new Property(2, Long.class, "id", true, "_id");
     };
 
     private DaoSession daoSession;
 
-
     public CustomerDao(DaoConfig config) {
         super(config);
     }
@@ -43,8 +43,9 @@ public CustomerDao(DaoConfig config, DaoSession daoSession) {
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         db.execSQL("CREATE TABLE " + constraint + "'CUSTOMER' (" + //
-                "'NAME' TEXT NOT NULL ," + // 0: name
-                "'_id' INTEGER PRIMARY KEY );"); // 1: id
+                "'SYNC_BASE_ID' INTEGER REFERENCES 'SYNC_BASE'('SYNC_BASE_ID') ," + // 0: syncBaseId
+                "'NAME' TEXT NOT NULL ," + // 1: name
+                "'_id' INTEGER PRIMARY KEY );"); // 2: id
     }
 
     /** Drops the underlying database table. */
@@ -57,11 +58,16 @@ public static void dropTable(SQLiteDatabase db, boolean ifExists) {
     @Override
     protected void bindValues(SQLiteStatement stmt, Customer entity) {
         stmt.clearBindings();
-        stmt.bindString(1, entity.getName());
+ 
+        Long syncBaseId = entity.getSyncBaseId();
+        if (syncBaseId != null) {
+            stmt.bindLong(1, syncBaseId);
+        }
+        stmt.bindString(2, entity.getName());
  
         Long id = entity.getId();
         if (id != null) {
-            stmt.bindLong(2, id);
+            stmt.bindLong(3, id);
         }
     }
 
@@ -74,15 +80,16 @@ protected void attachEntity(Customer entity) {
     /** @inheritdoc */
     @Override
     public Long readKey(Cursor cursor, int offset) {
-        return cursor.isNull(offset + 1) ? null : cursor.getLong(offset + 1);
+        return cursor.isNull(offset + 2) ? null : cursor.getLong(offset + 2);
     }    
 
     /** @inheritdoc */
     @Override
     public Customer readEntity(Cursor cursor, int offset) {
         Customer entity = new Customer( //
-            cursor.getString(offset + 0), // name
-            cursor.isNull(offset + 1) ? null : cursor.getLong(offset + 1) // id
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // syncBaseId
+            cursor.getString(offset + 1), // name
+            cursor.isNull(offset + 2) ? null : cursor.getLong(offset + 2) // id
         );
         return entity;
     }
@@ -90,8 +97,9 @@ public Customer readEntity(Cursor cursor, int offset) {
     /** @inheritdoc */
     @Override
     public void readEntity(Cursor cursor, Customer entity, int offset) {
-        entity.setName(cursor.getString(offset + 0));
-        entity.setId(cursor.isNull(offset + 1) ? null : cursor.getLong(offset + 1));
+        entity.setSyncBaseId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setName(cursor.getString(offset + 1));
+        entity.setId(cursor.isNull(offset + 2) ? null : cursor.getLong(offset + 2));
      }
     
     /** @inheritdoc */
@@ -117,5 +125,30 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
+    @Override
+    protected void onPreInsertEntity(Customer entity) {
+        entity.insertBase(daoSession.getSyncBaseDao());
+        entity.setSyncBaseId(entity.getSyncBaseId());
+    }
+
+    @Override
+    protected void onPreLoadEntity(Customer entity) {
+        entity.loadBase(daoSession.getSyncBaseDao(), entity.getSyncBaseId());
+    }
+
+    @Override
+    protected void onPreRefreshEntity(Customer entity) {
+        entity.loadBase(daoSession.getSyncBaseDao(), entity.getSyncBaseId());
+    }
+
+    @Override
+    protected void onPreUpdateEntity(Customer entity) {
+        entity.updateBase(daoSession.getSyncBaseDao());
+    }
+
+    @Override
+    protected void onPreDeleteEntity(Customer entity) {
+        entity.deleteBase(daoSession.getSyncBaseDao());
+    }
 
 }
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/database/DaoMaster.java b/DaoExample/src/de/greenrobot/daoexample/database/DaoMaster.java
similarity index 93%
rename from DaoExample/src-gen/de/greenrobot/daoexample/database/DaoMaster.java
rename to DaoExample/src/de/greenrobot/daoexample/database/DaoMaster.java
index 4f6edde2..f75ac81d 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/database/DaoMaster.java
+++ b/DaoExample/src/de/greenrobot/daoexample/database/DaoMaster.java
@@ -8,7 +8,7 @@
 import de.greenrobot.dao.AbstractDaoMaster;
 import de.greenrobot.dao.identityscope.IdentityScopeType;
 
-import de.greenrobot.daoexample.database.BaseObjectDao;
+import de.greenrobot.daoexample.database.SyncBaseDao;
 import de.greenrobot.daoexample.database.NoteDao;
 import de.greenrobot.daoexample.database.CustomerDao;
 import de.greenrobot.daoexample.database.OrderDao;
@@ -22,7 +22,7 @@
 
     /** Creates underlying database table using DAOs. */
     public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
-        BaseObjectDao.createTable(db, ifNotExists);
+        SyncBaseDao.createTable(db, ifNotExists);
         NoteDao.createTable(db, ifNotExists);
         CustomerDao.createTable(db, ifNotExists);
         OrderDao.createTable(db, ifNotExists);
@@ -30,7 +30,7 @@ public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
     
     /** Drops underlying database table using DAOs. */
     public static void dropAllTables(SQLiteDatabase db, boolean ifExists) {
-        BaseObjectDao.dropTable(db, ifExists);
+        SyncBaseDao.dropTable(db, ifExists);
         NoteDao.dropTable(db, ifExists);
         CustomerDao.dropTable(db, ifExists);
         OrderDao.dropTable(db, ifExists);
@@ -65,7 +65,7 @@ public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 
     public DaoMaster(SQLiteDatabase db) {
         super(db, SCHEMA_VERSION);
-        registerDaoClass(BaseObjectDao.class);
+        registerDaoClass(SyncBaseDao.class);
         registerDaoClass(NoteDao.class);
         registerDaoClass(CustomerDao.class);
         registerDaoClass(OrderDao.class);
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/database/DaoSession.java b/DaoExample/src/de/greenrobot/daoexample/database/DaoSession.java
similarity index 79%
rename from DaoExample/src-gen/de/greenrobot/daoexample/database/DaoSession.java
rename to DaoExample/src/de/greenrobot/daoexample/database/DaoSession.java
index d701df4b..23aaa60f 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/database/DaoSession.java
+++ b/DaoExample/src/de/greenrobot/daoexample/database/DaoSession.java
@@ -9,13 +9,14 @@
 import de.greenrobot.dao.identityscope.IdentityScopeType;
 import de.greenrobot.dao.internal.DaoConfig;
 
-import de.greenrobot.daoexample.database.BaseObject;
+import de.greenrobot.daoexample.database.SyncBase;
+import de.greenrobot.daoexample.database.BaseState;
 import de.greenrobot.daoexample.database.Note;
 import de.greenrobot.daoexample.database.NoteType;
 import de.greenrobot.daoexample.database.Customer;
 import de.greenrobot.daoexample.database.Order;
 
-import de.greenrobot.daoexample.database.BaseObjectDao;
+import de.greenrobot.daoexample.database.SyncBaseDao;
 import de.greenrobot.daoexample.database.NoteDao;
 import de.greenrobot.daoexample.database.CustomerDao;
 import de.greenrobot.daoexample.database.OrderDao;
@@ -29,12 +30,12 @@
  */
 public class DaoSession extends AbstractDaoSession {
 
-    private final DaoConfig baseObjectDaoConfig;
+    private final DaoConfig syncBaseDaoConfig;
     private final DaoConfig noteDaoConfig;
     private final DaoConfig customerDaoConfig;
     private final DaoConfig orderDaoConfig;
 
-    private final BaseObjectDao baseObjectDao;
+    private final SyncBaseDao syncBaseDao;
     private final NoteDao noteDao;
     private final CustomerDao customerDao;
     private final OrderDao orderDao;
@@ -43,8 +44,8 @@ public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends
             daoConfigMap) {
         super(db);
 
-        baseObjectDaoConfig = daoConfigMap.get(BaseObjectDao.class).clone();
-        baseObjectDaoConfig.initIdentityScope(type);
+        syncBaseDaoConfig = daoConfigMap.get(SyncBaseDao.class).clone();
+        syncBaseDaoConfig.initIdentityScope(type);
 
         noteDaoConfig = daoConfigMap.get(NoteDao.class).clone();
         noteDaoConfig.initIdentityScope(type);
@@ -55,26 +56,26 @@ public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends
         orderDaoConfig = daoConfigMap.get(OrderDao.class).clone();
         orderDaoConfig.initIdentityScope(type);
 
-        baseObjectDao = new BaseObjectDao(baseObjectDaoConfig, this);
+        syncBaseDao = new SyncBaseDao(syncBaseDaoConfig, this);
         noteDao = new NoteDao(noteDaoConfig, this);
         customerDao = new CustomerDao(customerDaoConfig, this);
         orderDao = new OrderDao(orderDaoConfig, this);
 
-        registerDao(BaseObject.class, baseObjectDao);
+        registerDao(SyncBase.class, syncBaseDao);
         registerDao(Note.class, noteDao);
         registerDao(Customer.class, customerDao);
         registerDao(Order.class, orderDao);
     }
     
     public void clear() {
-        baseObjectDaoConfig.getIdentityScope().clear();
+        syncBaseDaoConfig.getIdentityScope().clear();
         noteDaoConfig.getIdentityScope().clear();
         customerDaoConfig.getIdentityScope().clear();
         orderDaoConfig.getIdentityScope().clear();
     }
 
-    public BaseObjectDao getBaseObjectDao() {
-        return baseObjectDao;
+    public SyncBaseDao getSyncBaseDao() {
+        return syncBaseDao;
     }
 
     public NoteDao getNoteDao() {
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/database/Note.java b/DaoExample/src/de/greenrobot/daoexample/database/Note.java
similarity index 79%
rename from DaoExample/src-gen/de/greenrobot/daoexample/database/Note.java
rename to DaoExample/src/de/greenrobot/daoexample/database/Note.java
index e37338de..256fde20 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/database/Note.java
+++ b/DaoExample/src/de/greenrobot/daoexample/database/Note.java
@@ -1,21 +1,23 @@
 package de.greenrobot.daoexample.database;
 
+import java.util.List;
+import de.greenrobot.dao.sync.GreenSync;
+import com.google.gson.reflect.TypeToken;
 import de.greenrobot.daoexample.database.NoteType;
-import de.greenrobot.daoexample.database.DaoSession;
 import de.greenrobot.dao.DaoException;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
  * Entity mapped to table NOTE.
  */
-public class Note extends BaseObject  {
+public class Note extends SyncBase  {
 
+    private transient Long syncBaseId;
     /** Not-null value. */
     private String text;
     private String comment;
     private transient Long id;
     private NoteType type;
-    private transient Long baseObjectId;
 
     /** Used to resolve relations */
     private transient DaoSession daoSession;
@@ -23,21 +25,20 @@
     /** Used for active entity operations. */
     private transient NoteDao myDao;
 
-
     public Note() {
     }
 
     public Note(Long id) {
         this.id = id;
-        setDerivedEntityType(getClass().getSimpleName());
+        setDerivedEntityType(getClass().getCanonicalName());
     }
 
-    Note(String text, String comment, Long id, NoteType type, Long baseObjectId) {
+    Note(Long syncBaseId, String text, String comment, Long id, NoteType type) {
+        this.syncBaseId = syncBaseId;
         this.text = text;
         this.comment = comment;
         this.id = id;
         this.type = type;
-        this.baseObjectId = baseObjectId;
     }
 
     public Note(String text, String comment, Long id, NoteType type) {
@@ -45,7 +46,7 @@ public Note(String text, String comment, Long id, NoteType type) {
         this.comment = comment;
         this.id = id;
         this.type = type;
-        setDerivedEntityType(getClass().getSimpleName());
+        setDerivedEntityType(getClass().getCanonicalName());
     }
 
     /** called by internal mechanisms, do not call yourself. */
@@ -56,18 +57,24 @@ public void __setDaoSession(DaoSession daoSession) {
         myDao = daoSession != null ? daoSession.getNoteDao() : null;
     }
 
+    public Long getSyncBaseId() {
+        return syncBaseId;
+    }
+
+    public void setSyncBaseId(Long syncBaseId) {
+        this.syncBaseId = syncBaseId;
+    }
 
     /** Not-null value. */
     public String getText() {
         return text;
     }
-    /** Not-null value; ensure this value is available before it is saved to the database. */
 
+    /** Not-null value; ensure this value is available before it is saved to the database. */
     public void setText(String text) {
         this.text = text;
     }
 
-
     public String getComment() {
         return comment;
     }
@@ -76,7 +83,6 @@ public void setComment(String comment) {
         this.comment = comment;
     }
 
-
     public Long getId() {
         return id;
     }
@@ -85,7 +91,6 @@ public void setId(Long id) {
         this.id = id;
     }
 
-
     public NoteType getType() {
         return type;
     }
@@ -94,15 +99,6 @@ public void setType(NoteType type) {
         this.type = type;
     }
 
-
-    Long getBaseObjectId() {
-        return baseObjectId;
-    }
-
-    void setBaseObjectId(Long baseObjectId) {
-        this.baseObjectId = baseObjectId;
-    }
-
     /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
     public void delete() {
         if (myDao == null) {
@@ -127,4 +123,9 @@ public void refresh() {
         myDao.refresh(this);
     }
 
-}
+    static {
+        GreenSync.registerListTypeToken("Note", new TypeToken<List<Note>>(){}.getType());
+        GreenSync.registerTypeToken("Note", Note.class);
+    }
+
+}
\ No newline at end of file
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/database/NoteDao.java b/DaoExample/src/de/greenrobot/daoexample/database/NoteDao.java
similarity index 54%
rename from DaoExample/src-gen/de/greenrobot/daoexample/database/NoteDao.java
rename to DaoExample/src/de/greenrobot/daoexample/database/NoteDao.java
index 7b922a28..2ff81f6c 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/database/NoteDao.java
+++ b/DaoExample/src/de/greenrobot/daoexample/database/NoteDao.java
@@ -3,14 +3,10 @@
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteStatement;
-
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.internal.DaoConfig;
 
-import de.greenrobot.daoexample.database.Note;
-import de.greenrobot.daoexample.database.NoteType;
-
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
  * DAO for table NOTE.
@@ -24,16 +20,15 @@
      * Can be used for QueryBuilder and for referencing column names.
     */
     public static class Properties {
-        public final static Property Text = new Property(0, String.class, "text", false, "TEXT");
-        public final static Property Comment = new Property(1, String.class, "comment", false, "COMMENT");
-        public final static Property Id = new Property(2, Long.class, "id", true, "_id");
-        public final static Property Type = new Property(3, NoteType.class, "type", false, "TYPE");
-        public final static Property BaseObjectId = new Property(4, Long.class, "baseObjectId", false, "BASE_OBJECT_ID");
+        public final static Property SyncBaseId = new Property(0, Long.class, "syncBaseId", false, "SYNC_BASE_ID");
+        public final static Property Text = new Property(1, String.class, "text", false, "TEXT");
+        public final static Property Comment = new Property(2, String.class, "comment", false, "COMMENT");
+        public final static Property Id = new Property(3, Long.class, "id", true, "_id");
+        public final static Property Type = new Property(4, NoteType.class, "type", false, "TYPE");
     };
 
     private DaoSession daoSession;
 
-
     public NoteDao(DaoConfig config) {
         super(config);
     }
@@ -47,11 +42,11 @@ public NoteDao(DaoConfig config, DaoSession daoSession) {
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         db.execSQL("CREATE TABLE " + constraint + "'NOTE' (" + //
-                "'TEXT' TEXT NOT NULL ," + // 0: text
-                "'COMMENT' TEXT," + // 1: comment
-                "'_id' INTEGER PRIMARY KEY ," + // 2: id
-                "'TYPE' INTEGER," + // 3: type
-                "'BASE_OBJECT_ID' INTEGER REFERENCES 'BASE_OBJECT'('BASE_ID') );"); // 4: baseObjectId
+                "'SYNC_BASE_ID' INTEGER REFERENCES 'SYNC_BASE'('SYNC_BASE_ID') ," + // 0: syncBaseId
+                "'TEXT' TEXT NOT NULL ," + // 1: text
+                "'COMMENT' TEXT," + // 2: comment
+                "'_id' INTEGER PRIMARY KEY ," + // 3: id
+                "'TYPE' INTEGER);"); // 4: type
     }
 
     /** Drops the underlying database table. */
@@ -64,26 +59,26 @@ public static void dropTable(SQLiteDatabase db, boolean ifExists) {
     @Override
     protected void bindValues(SQLiteStatement stmt, Note entity) {
         stmt.clearBindings();
-        stmt.bindString(1, entity.getText());
+ 
+        Long syncBaseId = entity.getSyncBaseId();
+        if (syncBaseId != null) {
+            stmt.bindLong(1, syncBaseId);
+        }
+        stmt.bindString(2, entity.getText());
  
         String comment = entity.getComment();
         if (comment != null) {
-            stmt.bindString(2, comment);
+            stmt.bindString(3, comment);
         }
  
         Long id = entity.getId();
         if (id != null) {
-            stmt.bindLong(3, id);
+            stmt.bindLong(4, id);
         }
  
         NoteType type = entity.getType();
         if (type != null) {
-            stmt.bindLong(4, type.getValue());
-        }
- 
-        Long baseObjectId = entity.getBaseObjectId();
-        if (baseObjectId != null) {
-            stmt.bindLong(5, baseObjectId);
+            stmt.bindLong(5, type.getValue());
         }
     }
 
@@ -96,18 +91,18 @@ protected void attachEntity(Note entity) {
     /** @inheritdoc */
     @Override
     public Long readKey(Cursor cursor, int offset) {
-        return cursor.isNull(offset + 2) ? null : cursor.getLong(offset + 2);
+        return cursor.isNull(offset + 3) ? null : cursor.getLong(offset + 3);
     }    
 
     /** @inheritdoc */
     @Override
     public Note readEntity(Cursor cursor, int offset) {
         Note entity = new Note( //
-            cursor.getString(offset + 0), // text
-            cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1), // comment
-            cursor.isNull(offset + 2) ? null : cursor.getLong(offset + 2), // id
-            cursor.isNull(offset + 3) ? null : NoteType.fromInt(cursor.getLong(offset + 3)), // type
-            cursor.isNull(offset + 4) ? null : cursor.getLong(offset + 4) // baseObjectId
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // syncBaseId
+            cursor.getString(offset + 1), // text
+            cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2), // comment
+            cursor.isNull(offset + 3) ? null : cursor.getLong(offset + 3), // id
+            cursor.isNull(offset + 4) ? null : NoteType.fromInt(cursor.getLong(offset + 4)) // type
         );
         return entity;
     }
@@ -115,11 +110,11 @@ public Note readEntity(Cursor cursor, int offset) {
     /** @inheritdoc */
     @Override
     public void readEntity(Cursor cursor, Note entity, int offset) {
-        entity.setText(cursor.getString(offset + 0));
-        entity.setComment(cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1));
-        entity.setId(cursor.isNull(offset + 2) ? null : cursor.getLong(offset + 2));
-        entity.setType(cursor.isNull(offset + 3) ? null : NoteType.fromInt(cursor.getLong(offset + 3)));
-        entity.setBaseObjectId(cursor.isNull(offset + 4) ? null : cursor.getLong(offset + 4));
+        entity.setSyncBaseId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setText(cursor.getString(offset + 1));
+        entity.setComment(cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2));
+        entity.setId(cursor.isNull(offset + 3) ? null : cursor.getLong(offset + 3));
+        entity.setType(cursor.isNull(offset + 4) ? null : NoteType.fromInt(cursor.getLong(offset + 4)));
      }
     
     /** @inheritdoc */
@@ -145,30 +140,30 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
-
     @Override
-    protected void onInsertEntity(Note entity) {
-        entity.insertBase(daoSession.getBaseObjectDao());
-        entity.setBaseObjectId(entity.getBaseId());
+    protected void onPreInsertEntity(Note entity) {
+        entity.insertBase(daoSession.getSyncBaseDao());
+        entity.setSyncBaseId(entity.getSyncBaseId());
     }
 
     @Override
-    protected void onLoadEntity(Note entity) {
-        entity.loadBase(daoSession.getBaseObjectDao(), entity.getBaseObjectId());
+    protected void onPreLoadEntity(Note entity) {
+        entity.loadBase(daoSession.getSyncBaseDao(), entity.getSyncBaseId());
     }
 
     @Override
-    protected void onRefreshEntity(Note entity) {
-        entity.loadBase(daoSession.getBaseObjectDao(), entity.getBaseObjectId());
+    protected void onPreRefreshEntity(Note entity) {
+        entity.loadBase(daoSession.getSyncBaseDao(), entity.getSyncBaseId());
     }
 
     @Override
-    protected void onUpdateEntity(Note entity) {
-        entity.updateBase();
+    protected void onPreUpdateEntity(Note entity) {
+        entity.updateBase(daoSession.getSyncBaseDao());
     }
 
     @Override
-    protected void onDeleteEntity(Note entity) {
-        entity.deleteBase();
+    protected void onPreDeleteEntity(Note entity) {
+        entity.deleteBase(daoSession.getSyncBaseDao());
     }
+
 }
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/database/NoteType.java b/DaoExample/src/de/greenrobot/daoexample/database/NoteType.java
similarity index 93%
rename from DaoExample/src-gen/de/greenrobot/daoexample/database/NoteType.java
rename to DaoExample/src/de/greenrobot/daoexample/database/NoteType.java
index 115ab396..b7b0155e 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/database/NoteType.java
+++ b/DaoExample/src/de/greenrobot/daoexample/database/NoteType.java
@@ -4,6 +4,8 @@
 import java.util.HashMap;
 import java.util.Map;
 
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+
 public enum NoteType implements DaoEnum {
     ULTIMATE(1),
     FRISBEE(2),
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/database/Order.java b/DaoExample/src/de/greenrobot/daoexample/database/Order.java
similarity index 79%
rename from DaoExample/src-gen/de/greenrobot/daoexample/database/Order.java
rename to DaoExample/src/de/greenrobot/daoexample/database/Order.java
index cca7ab7e..77ff2d5a 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/database/Order.java
+++ b/DaoExample/src/de/greenrobot/daoexample/database/Order.java
@@ -1,15 +1,18 @@
 package de.greenrobot.daoexample.database;
 
+import java.util.List;
+import de.greenrobot.dao.sync.GreenSync;
+import com.google.gson.reflect.TypeToken;
 import de.greenrobot.daoexample.database.Customer.OrderType;
-import de.greenrobot.daoexample.database.DaoSession;
 import de.greenrobot.dao.DaoException;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
  * Entity mapped to table ORDERS.
  */
-public class Order {
+public class Order extends SyncBase  {
 
+    private transient Long syncBaseId;
     private java.util.Date date;
     private transient Long id;
     private OrderType type;
@@ -20,16 +23,23 @@
 
     /** Used for active entity operations. */
     private transient OrderDao myDao;
-
     private Customer customer;
     private Long customer__resolvedKey;
 
-
     public Order() {
     }
 
     public Order(Long id) {
         this.id = id;
+        setDerivedEntityType(getClass().getCanonicalName());
+    }
+
+    Order(Long syncBaseId, java.util.Date date, Long id, OrderType type, long customerId) {
+        this.syncBaseId = syncBaseId;
+        this.date = date;
+        this.id = id;
+        this.type = type;
+        this.customerId = customerId;
     }
 
     public Order(java.util.Date date, Long id, OrderType type, long customerId) {
@@ -37,14 +47,24 @@ public Order(java.util.Date date, Long id, OrderType type, long customerId) {
         this.id = id;
         this.type = type;
         this.customerId = customerId;
+        setDerivedEntityType(getClass().getCanonicalName());
     }
 
     /** called by internal mechanisms, do not call yourself. */
+    @Override
     public void __setDaoSession(DaoSession daoSession) {
+        super.__setDaoSession(daoSession);
         this.daoSession = daoSession;
         myDao = daoSession != null ? daoSession.getOrderDao() : null;
     }
 
+    public Long getSyncBaseId() {
+        return syncBaseId;
+    }
+
+    public void setSyncBaseId(Long syncBaseId) {
+        this.syncBaseId = syncBaseId;
+    }
 
     public java.util.Date getDate() {
         return date;
@@ -54,7 +74,6 @@ public void setDate(java.util.Date date) {
         this.date = date;
     }
 
-
     public Long getId() {
         return id;
     }
@@ -63,7 +82,6 @@ public void setId(Long id) {
         this.id = id;
     }
 
-
     public OrderType getType() {
         return type;
     }
@@ -72,7 +90,6 @@ public void setType(OrderType type) {
         this.type = type;
     }
 
-
     public long getCustomerId() {
         return customerId;
     }
@@ -133,4 +150,9 @@ public void refresh() {
         myDao.refresh(this);
     }
 
-}
+    static {
+        GreenSync.registerListTypeToken("Order", new TypeToken<List<Order>>(){}.getType());
+        GreenSync.registerTypeToken("Order", Order.class);
+    }
+
+}
\ No newline at end of file
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/database/OrderDao.java b/DaoExample/src/de/greenrobot/daoexample/database/OrderDao.java
similarity index 71%
rename from DaoExample/src-gen/de/greenrobot/daoexample/database/OrderDao.java
rename to DaoExample/src/de/greenrobot/daoexample/database/OrderDao.java
index 376e1873..aa44a6ff 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/database/OrderDao.java
+++ b/DaoExample/src/de/greenrobot/daoexample/database/OrderDao.java
@@ -29,10 +29,11 @@
      * Can be used for QueryBuilder and for referencing column names.
     */
     public static class Properties {
-        public final static Property Date = new Property(0, java.util.Date.class, "date", false, "DATE");
-        public final static Property Id = new Property(1, Long.class, "id", true, "_id");
-        public final static Property Type = new Property(2, OrderType.class, "type", false, "TYPE");
-        public final static Property CustomerId = new Property(3, long.class, "customerId", false, "CUSTOMER_ID");
+        public final static Property SyncBaseId = new Property(0, Long.class, "syncBaseId", false, "SYNC_BASE_ID");
+        public final static Property Date = new Property(1, java.util.Date.class, "date", false, "DATE");
+        public final static Property Id = new Property(2, Long.class, "id", true, "_id");
+        public final static Property Type = new Property(3, OrderType.class, "type", false, "TYPE");
+        public final static Property CustomerId = new Property(4, long.class, "customerId", false, "CUSTOMER_ID");
     };
 
     private DaoSession daoSession;
@@ -52,10 +53,11 @@ public OrderDao(DaoConfig config, DaoSession daoSession) {
     public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         db.execSQL("CREATE TABLE " + constraint + "'ORDERS' (" + //
-                "'DATE' INTEGER," + // 0: date
-                "'_id' INTEGER PRIMARY KEY ," + // 1: id
-                "'TYPE' INTEGER," + // 2: type
-                "'CUSTOMER_ID' INTEGER NOT NULL );"); // 3: customerId
+                "'SYNC_BASE_ID' INTEGER REFERENCES 'SYNC_BASE'('SYNC_BASE_ID') ," + // 0: syncBaseId
+                "'DATE' INTEGER," + // 1: date
+                "'_id' INTEGER PRIMARY KEY ," + // 2: id
+                "'TYPE' INTEGER," + // 3: type
+                "'CUSTOMER_ID' INTEGER NOT NULL );"); // 4: customerId
     }
 
     /** Drops the underlying database table. */
@@ -69,21 +71,26 @@ public static void dropTable(SQLiteDatabase db, boolean ifExists) {
     protected void bindValues(SQLiteStatement stmt, Order entity) {
         stmt.clearBindings();
  
+        Long syncBaseId = entity.getSyncBaseId();
+        if (syncBaseId != null) {
+            stmt.bindLong(1, syncBaseId);
+        }
+ 
         java.util.Date date = entity.getDate();
         if (date != null) {
-            stmt.bindLong(1, date.getTime());
+            stmt.bindLong(2, date.getTime());
         }
  
         Long id = entity.getId();
         if (id != null) {
-            stmt.bindLong(2, id);
+            stmt.bindLong(3, id);
         }
  
         OrderType type = entity.getType();
         if (type != null) {
-            stmt.bindLong(3, type.getValue());
+            stmt.bindLong(4, type.getValue());
         }
-        stmt.bindLong(4, entity.getCustomerId());
+        stmt.bindLong(5, entity.getCustomerId());
     }
 
     @Override
@@ -95,17 +102,18 @@ protected void attachEntity(Order entity) {
     /** @inheritdoc */
     @Override
     public Long readKey(Cursor cursor, int offset) {
-        return cursor.isNull(offset + 1) ? null : cursor.getLong(offset + 1);
+        return cursor.isNull(offset + 2) ? null : cursor.getLong(offset + 2);
     }    
 
     /** @inheritdoc */
     @Override
     public Order readEntity(Cursor cursor, int offset) {
         Order entity = new Order( //
-            cursor.isNull(offset + 0) ? null : new java.util.Date(cursor.getLong(offset + 0)), // date
-            cursor.isNull(offset + 1) ? null : cursor.getLong(offset + 1), // id
-            cursor.isNull(offset + 2) ? null : OrderType.fromInt(cursor.getLong(offset + 2)), // type
-            cursor.getLong(offset + 3) // customerId
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // syncBaseId
+            cursor.isNull(offset + 1) ? null : new java.util.Date(cursor.getLong(offset + 1)), // date
+            cursor.isNull(offset + 2) ? null : cursor.getLong(offset + 2), // id
+            cursor.isNull(offset + 3) ? null : OrderType.fromInt(cursor.getLong(offset + 3)), // type
+            cursor.getLong(offset + 4) // customerId
         );
         return entity;
     }
@@ -113,10 +121,11 @@ public Order readEntity(Cursor cursor, int offset) {
     /** @inheritdoc */
     @Override
     public void readEntity(Cursor cursor, Order entity, int offset) {
-        entity.setDate(cursor.isNull(offset + 0) ? null : new java.util.Date(cursor.getLong(offset + 0)));
-        entity.setId(cursor.isNull(offset + 1) ? null : cursor.getLong(offset + 1));
-        entity.setType(cursor.isNull(offset + 2) ? null : OrderType.fromInt(cursor.getLong(offset + 2)));
-        entity.setCustomerId(cursor.getLong(offset + 3));
+        entity.setSyncBaseId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setDate(cursor.isNull(offset + 1) ? null : new java.util.Date(cursor.getLong(offset + 1)));
+        entity.setId(cursor.isNull(offset + 2) ? null : cursor.getLong(offset + 2));
+        entity.setType(cursor.isNull(offset + 3) ? null : OrderType.fromInt(cursor.getLong(offset + 3)));
+        entity.setCustomerId(cursor.getLong(offset + 4));
      }
     
     /** @inheritdoc */
@@ -250,5 +259,30 @@ public Order loadDeep(Long key) {
         return loadDeepAllAndCloseCursor(cursor);
     }
  
+    @Override
+    protected void onPreInsertEntity(Order entity) {
+        entity.insertBase(daoSession.getSyncBaseDao());
+        entity.setSyncBaseId(entity.getSyncBaseId());
+    }
+
+    @Override
+    protected void onPreLoadEntity(Order entity) {
+        entity.loadBase(daoSession.getSyncBaseDao(), entity.getSyncBaseId());
+    }
+
+    @Override
+    protected void onPreRefreshEntity(Order entity) {
+        entity.loadBase(daoSession.getSyncBaseDao(), entity.getSyncBaseId());
+    }
+
+    @Override
+    protected void onPreUpdateEntity(Order entity) {
+        entity.updateBase(daoSession.getSyncBaseDao());
+    }
+
+    @Override
+    protected void onPreDeleteEntity(Order entity) {
+        entity.deleteBase(daoSession.getSyncBaseDao());
+    }
 
 }
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/database/BaseObject.java b/DaoExample/src/de/greenrobot/daoexample/database/SyncBase.java
similarity index 60%
rename from DaoExample/src-gen/de/greenrobot/daoexample/database/BaseObject.java
rename to DaoExample/src/de/greenrobot/daoexample/database/SyncBase.java
index 04e90bff..a1628138 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/database/BaseObject.java
+++ b/DaoExample/src/de/greenrobot/daoexample/database/SyncBase.java
@@ -1,66 +1,73 @@
 package de.greenrobot.daoexample.database;
 
-import de.greenrobot.daoexample.database.DaoSession;
+import de.greenrobot.daoexample.database.BaseState;
+import de.greenrobot.dao.sync.GreenSyncBase;
 import de.greenrobot.dao.DaoException;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 /**
- * Entity mapped to table BASE_OBJECT.
+ * Entity mapped to table SYNC_BASE.
  */
-public class BaseObject {
+public class SyncBase implements GreenSyncBase {
 
     private java.util.Date updatedOn;
+    private transient BaseState state;
+    private transient Long syncBaseId;
+    private String externalId;
     private java.util.Date createdOn;
-    /** Not-null value. */
     private transient String derivedEntityType;
-    private transient Long baseId;
 
     /** Used to resolve relations */
     private transient DaoSession daoSession;
 
     /** Used for active entity operations. */
-    private transient BaseObjectDao myDao;
+    private transient SyncBaseDao myDao;
 
-
-    public BaseObject() {
+    public SyncBase() {
     }
 
-    public BaseObject(Long baseId) {
-        this.baseId = baseId;
+    public SyncBase(Long syncBaseId) {
+        this.syncBaseId = syncBaseId;
     }
 
-    public BaseObject(java.util.Date updatedOn, java.util.Date createdOn, String derivedEntityType, Long baseId) {
+    public SyncBase(java.util.Date updatedOn, BaseState state, Long syncBaseId, String externalId, java.util.Date createdOn, String derivedEntityType) {
         this.updatedOn = updatedOn;
+        this.state = state;
+        this.syncBaseId = syncBaseId;
+        this.externalId = externalId;
         this.createdOn = createdOn;
         this.derivedEntityType = derivedEntityType;
-        this.baseId = baseId;
     }
 
     /** called by internal mechanisms, do not call yourself. */
     public void __setDaoSession(DaoSession daoSession) {
         this.daoSession = daoSession;
-        myDao = daoSession != null ? daoSession.getBaseObjectDao() : null;
+        myDao = daoSession != null ? daoSession.getSyncBaseDao() : null;
     }
 
-    void loadBase(BaseObjectDao dao, Long baseId) {
+    void loadBase(SyncBaseDao dao, Long syncBaseId) {
         myDao = dao;
-        this.baseId = baseId;
+        this.syncBaseId = syncBaseId;
         myDao.refresh(this);
     }
 
-    void insertBase(BaseObjectDao dao) {
+    void insertBase(SyncBaseDao dao) {
         myDao = dao;
+        setState(BaseState.CREATE);
         dao.insert(this);
     }
 
-    void updateBase() {
+    void updateBase(SyncBaseDao dao) {
+        myDao = dao;
+        setState(BaseState.UPDATE);
         myDao.update(this);
     }
 
-    void deleteBase() {
+    void deleteBase(SyncBaseDao dao) {
+        myDao = dao;
+        setState(BaseState.DELETE);
         myDao.delete(this);
     }
-
     public java.util.Date getUpdatedOn() {
         return updatedOn;
     }
@@ -69,6 +76,29 @@ public void setUpdatedOn(java.util.Date updatedOn) {
         this.updatedOn = updatedOn;
     }
 
+    public BaseState getState() {
+        return state;
+    }
+
+    public void setState(BaseState state) {
+        this.state = state;
+    }
+
+    public Long getSyncBaseId() {
+        return syncBaseId;
+    }
+
+    public void setSyncBaseId(Long syncBaseId) {
+        this.syncBaseId = syncBaseId;
+    }
+
+    public String getExternalId() {
+        return externalId;
+    }
+
+    public void setExternalId(String externalId) {
+        this.externalId = externalId;
+    }
 
     public java.util.Date getCreatedOn() {
         return createdOn;
@@ -78,26 +108,14 @@ public void setCreatedOn(java.util.Date createdOn) {
         this.createdOn = createdOn;
     }
 
-
-    /** Not-null value. */
     public String getDerivedEntityType() {
         return derivedEntityType;
     }
-    /** Not-null value; ensure this value is available before it is saved to the database. */
 
     public void setDerivedEntityType(String derivedEntityType) {
         this.derivedEntityType = derivedEntityType;
     }
 
-
-    public Long getBaseId() {
-        return baseId;
-    }
-
-    public void setBaseId(Long baseId) {
-        this.baseId = baseId;
-    }
-
     /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
     public void delete() {
         if (myDao == null) {
@@ -122,4 +140,4 @@ public void refresh() {
         myDao.refresh(this);
     }
 
-}
+}
\ No newline at end of file
diff --git a/DaoExample/src/de/greenrobot/daoexample/database/SyncBaseDao.java b/DaoExample/src/de/greenrobot/daoexample/database/SyncBaseDao.java
new file mode 100644
index 00000000..b8c73f2a
--- /dev/null
+++ b/DaoExample/src/de/greenrobot/daoexample/database/SyncBaseDao.java
@@ -0,0 +1,221 @@
+package de.greenrobot.daoexample.database;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+import android.util.Log;
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.sync.GreenSyncDaoBase;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table SYNC_BASE.
+*/
+public class SyncBaseDao extends AbstractDao<SyncBase, Long> implements GreenSyncDaoBase {
+
+    public static final String TABLENAME = "SYNC_BASE";
+
+    /**
+     * Properties of entity SyncBase.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property UpdatedOn = new Property(0, java.util.Date.class, "updatedOn", false, "UPDATED_ON");
+        public final static Property State = new Property(1, BaseState.class, "state", false, "STATE");
+        public final static Property SyncBaseId = new Property(2, Long.class, "syncBaseId", true, "SYNC_BASE_ID");
+        public final static Property ExternalId = new Property(3, String.class, "externalId", false, "EXTERNAL_ID");
+        public final static Property CreatedOn = new Property(4, java.util.Date.class, "createdOn", false, "CREATED_ON");
+        public final static Property DerivedEntityType = new Property(5, String.class, "derivedEntityType", false, "DERIVED_ENTITY_TYPE");
+    };
+
+    private DaoSession daoSession;
+
+    public SyncBaseDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public SyncBaseDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+        this.daoSession = daoSession;
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'SYNC_BASE' (" + //
+                "'UPDATED_ON' INTEGER," + // 0: updatedOn
+                "'STATE' INTEGER," + // 1: state
+                "'SYNC_BASE_ID' INTEGER PRIMARY KEY ," + // 2: syncBaseId
+                "'EXTERNAL_ID' TEXT," + // 3: externalId
+                "'CREATED_ON' INTEGER," + // 4: createdOn
+                "'DERIVED_ENTITY_TYPE' TEXT);"); // 5: derivedEntityType
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'SYNC_BASE'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, SyncBase entity) {
+        stmt.clearBindings();
+ 
+        java.util.Date updatedOn = entity.getUpdatedOn();
+        if (updatedOn != null) {
+            stmt.bindLong(1, updatedOn.getTime());
+        }
+ 
+        BaseState state = entity.getState();
+        if (state != null) {
+            stmt.bindLong(2, state.getValue());
+        }
+ 
+        Long syncBaseId = entity.getSyncBaseId();
+        if (syncBaseId != null) {
+            stmt.bindLong(3, syncBaseId);
+        }
+ 
+        String externalId = entity.getExternalId();
+        if (externalId != null) {
+            stmt.bindString(4, externalId);
+        }
+ 
+        java.util.Date createdOn = entity.getCreatedOn();
+        if (createdOn != null) {
+            stmt.bindLong(5, createdOn.getTime());
+        }
+ 
+        String derivedEntityType = entity.getDerivedEntityType();
+        if (derivedEntityType != null) {
+            stmt.bindString(6, derivedEntityType);
+        }
+    }
+
+    @Override
+    protected void attachEntity(SyncBase entity) {
+        super.attachEntity(entity);
+        entity.__setDaoSession(daoSession);
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 2) ? null : cursor.getLong(offset + 2);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public SyncBase readEntity(Cursor cursor, int offset) {
+        SyncBase entity = new SyncBase( //
+            cursor.isNull(offset + 0) ? null : new java.util.Date(cursor.getLong(offset + 0)), // updatedOn
+            cursor.isNull(offset + 1) ? null : BaseState.fromInt(cursor.getLong(offset + 1)), // state
+            cursor.isNull(offset + 2) ? null : cursor.getLong(offset + 2), // syncBaseId
+            cursor.isNull(offset + 3) ? null : cursor.getString(offset + 3), // externalId
+            cursor.isNull(offset + 4) ? null : new java.util.Date(cursor.getLong(offset + 4)), // createdOn
+            cursor.isNull(offset + 5) ? null : cursor.getString(offset + 5) // derivedEntityType
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, SyncBase entity, int offset) {
+        entity.setUpdatedOn(cursor.isNull(offset + 0) ? null : new java.util.Date(cursor.getLong(offset + 0)));
+        entity.setState(cursor.isNull(offset + 1) ? null : BaseState.fromInt(cursor.getLong(offset + 1)));
+        entity.setSyncBaseId(cursor.isNull(offset + 2) ? null : cursor.getLong(offset + 2));
+        entity.setExternalId(cursor.isNull(offset + 3) ? null : cursor.getString(offset + 3));
+        entity.setCreatedOn(cursor.isNull(offset + 4) ? null : new java.util.Date(cursor.getLong(offset + 4)));
+        entity.setDerivedEntityType(cursor.isNull(offset + 5) ? null : cursor.getString(offset + 5));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(SyncBase entity, long rowId) {
+        entity.setSyncBaseId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(SyncBase entity) {
+        if(entity != null) {
+            return entity.getSyncBaseId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+    /**
+    * 1. SELECT BASE_ID, DERIVED_ENTITY_TYPE FROM SyncBase WHERE state = ?
+    * 2. Use derivedType to get dao and load entity on baseId
+    * @param state
+    * @return
+    */
+    private Map loadState(BaseState state) {
+
+        Query query = queryBuilder().where(Properties.State.eq(state.getValue())).orderAsc(Properties.DerivedEntityType).build();
+        Cursor cursor = query.getCursor();
+
+        Map<String, List> map = new HashMap<String, List>();
+
+        if (cursor.moveToFirst()) {
+
+            List list = new ArrayList<Object>();
+
+            do {
+                Long baseId = cursor.getLong(Properties.SyncBaseId.ordinal);
+                String type = cursor.getString(Properties.DerivedEntityType.ordinal);
+                String[] key = type.split("\\.");
+
+                if (!map.containsKey(key[key.length - 1])) {
+                    list = new ArrayList<Object>();
+                    map.put(key[key.length - 1], list);
+                }
+
+                try {
+                    AbstractDao abstractDao = daoSession.getDao(Class.forName(type));
+                    Object object = abstractDao.queryBuilder().where(Properties.SyncBaseId.eq(baseId)).uniqueOrThrow();
+                    list.add(object);
+                } catch (ClassNotFoundException ex) {
+                    Log.e("SyncBaseDao", "Could not load dao for class " + type);
+                } catch (DaoException ex) {
+                    Log.e("SyncBaseDao", "Could not load object from class " + type + " with id " + baseId);
+                }
+            } while (cursor.moveToNext());
+        }
+
+        return map;
+    }
+
+    @Override
+    public Map getUpdatedObjects() {
+        return loadState(BaseState.UPDATE);
+    }
+
+    @Override
+    public Map getDeletedObjects() {
+        return loadState(BaseState.DELETE);
+    }
+
+    @Override
+    public Map getCreatedObjects() {
+        return loadState(BaseState.CREATE);
+    }
+}
diff --git a/DaoExampleGenerator/src/de/greenrobot/daogenerator/gentest/ExampleDaoGenerator.java b/DaoExampleGenerator/src/de/greenrobot/daogenerator/gentest/ExampleDaoGenerator.java
index 06452eb5..b0cbd7f6 100644
--- a/DaoExampleGenerator/src/de/greenrobot/daogenerator/gentest/ExampleDaoGenerator.java
+++ b/DaoExampleGenerator/src/de/greenrobot/daogenerator/gentest/ExampleDaoGenerator.java
@@ -28,29 +28,18 @@
  */
 public class ExampleDaoGenerator {
 
-    private static Entity base;
-
     public static void main(String[] args) throws Exception {
         Schema schema = new Schema(3, "de.greenrobot.daoexample.database");
-
-        createBaseEntity(schema);
+        schema.enableGreenSync();
 
         addNote(schema);
         addCustomerOrder(schema);
 
-        new DaoGenerator().generateAll(schema, "/Users/saulhoward/Developer/greenDAO/DaoExample/src-gen");
-    }
-
-    private static void createBaseEntity(Schema schema) {
-        base = schema.addEntity("BaseObject");
-        base.addLongProperty("baseId").primaryKey().markTransient();
-        base.addDateProperty("createdOn");
-        base.addDateProperty("updatedOn");
+        new DaoGenerator().generateAll(schema, "/Users/saulhoward/Developer/greenDAO/DaoExample/src");
     }
 
     private static void addNote(Schema schema) {
         Entity note = schema.addEntity("Note");
-        note.setBaseEntity(base);
         note.addIdProperty().markTransient();
         note.addStringProperty("text").notNull();
         note.addStringProperty("comment");
diff --git a/DaoGenerator/src-template/dao.ftl b/DaoGenerator/src-template/dao.ftl
index b08e8bbc..d43762c0 100644
--- a/DaoGenerator/src-template/dao.ftl
+++ b/DaoGenerator/src-template/dao.ftl
@@ -37,7 +37,7 @@ import de.greenrobot.dao.Property;
 import de.greenrobot.dao.internal.SqlUtils;
 </#if>
 import de.greenrobot.dao.internal.DaoConfig;
-<#if entity.incomingToManyRelations?has_content>
+<#if entity.incomingToManyRelations?has_content || entity.aBaseEntity>
 import de.greenrobot.dao.query.Query;
 import de.greenrobot.dao.query.QueryBuilder;
 </#if>
@@ -61,12 +61,22 @@ import ${entity.javaPackage}.${property.entityEnum.entity.className}<#if !proper
 <#if entity.protobuf>
 import ${entity.javaPackage}.${entity.className}.Builder;
 </#if>
+<#if entity.aBaseEntity>
+import android.util.Log;
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.sync.GreenSyncDaoBase;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+</#if>
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
  * DAO for table ${entity.tableName}.
 */
-public class ${entity.classNameDao} extends AbstractDao<${entity.className}, ${entity.pkType}> {
+public class ${entity.classNameDao} extends AbstractDao<${entity.className}, ${entity.pkType}><#if entity.aBaseEntity> implements GreenSyncDaoBase</#if> {
 
     public static final String TABLENAME = "${entity.tableName}";
 
@@ -86,8 +96,8 @@ public class ${entity.classNameDao} extends AbstractDao<${entity.className}, ${e
 </#if>
 <#list entity.incomingToManyRelations as toMany>
     private Query<${toMany.targetEntity.className}> ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query;
-</#list>
 
+</#list>
     public ${entity.classNameDao}(DaoConfig config) {
         super(config);
     }
@@ -308,32 +318,90 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
 <#if entity.toOneRelations?has_content>
     <#include "dao-deep.ftl">
 </#if>
-
 <#if entity.baseEntity?? && entity.referenceProperty??>
     @Override
-    protected void onInsertEntity(${entity.className} entity) {
+    protected void onPreInsertEntity(${entity.className} entity) {
         entity.insertBase(daoSession.get${entity.baseEntity.classNameDao?cap_first}());
         entity.set${entity.referenceProperty.propertyName?cap_first}(entity.get${entity.baseEntity.pkProperty.propertyName?cap_first}());
     }
 
     @Override
-    protected void onLoadEntity(${entity.className} entity) {
+    protected void onPreLoadEntity(${entity.className} entity) {
         entity.loadBase(daoSession.get${entity.baseEntity.classNameDao?cap_first}(), entity.get${entity.referenceProperty.propertyName?cap_first}());
     }
 
     @Override
-    protected void onRefreshEntity(${entity.className} entity) {
+    protected void onPreRefreshEntity(${entity.className} entity) {
         entity.loadBase(daoSession.get${entity.baseEntity.classNameDao?cap_first}(), entity.get${entity.referenceProperty.propertyName?cap_first}());
     }
 
     @Override
-    protected void onUpdateEntity(${entity.className} entity) {
-        entity.updateBase();
+    protected void onPreUpdateEntity(${entity.className} entity) {
+        entity.updateBase(daoSession.get${entity.baseEntity.classNameDao?cap_first}());
+    }
+
+    @Override
+    protected void onPreDeleteEntity(${entity.className} entity) {
+        entity.deleteBase(daoSession.get${entity.baseEntity.classNameDao?cap_first}());
+    }
+
+</#if>
+<#if entity.aBaseEntity>
+    /**
+    * 1. SELECT BASE_ID, DERIVED_ENTITY_TYPE FROM SyncBase WHERE state = ?
+    * 2. Use derivedType to get dao and load entity on baseId
+    * @param state
+    * @return
+    */
+    private Map loadState(BaseState state) {
+
+        Query query = queryBuilder().where(Properties.State.eq(state.getValue())).orderAsc(Properties.DerivedEntityType).build();
+        Cursor cursor = query.getCursor();
+
+        Map<String, List> map = new HashMap<String, List>();
+
+        if (cursor.moveToFirst()) {
+
+            List list = new ArrayList<Object>();
+
+            do {
+                Long baseId = cursor.getLong(Properties.SyncBaseId.ordinal);
+                String type = cursor.getString(Properties.DerivedEntityType.ordinal);
+                String[] key = type.split("\\.");
+
+                if (!map.containsKey(key[key.length - 1])) {
+                    list = new ArrayList<Object>();
+                    map.put(key[key.length - 1], list);
+                }
+
+                try {
+                    AbstractDao abstractDao = daoSession.getDao(Class.forName(type));
+                    Object object = abstractDao.queryBuilder().where(Properties.SyncBaseId.eq(baseId)).uniqueOrThrow();
+                    list.add(object);
+                } catch (ClassNotFoundException ex) {
+                    Log.e("SyncBaseDao", "Could not load dao for class " + type);
+                } catch (DaoException ex) {
+                    Log.e("SyncBaseDao", "Could not load object from class " + type + " with id " + baseId);
+                }
+            } while (cursor.moveToNext());
+        }
+
+        return map;
+    }
+
+    @Override
+    public Map getUpdatedObjects() {
+        return loadState(BaseState.UPDATE);
+    }
+
+    @Override
+    public Map getDeletedObjects() {
+        return loadState(BaseState.DELETE);
     }
 
     @Override
-    protected void onDeleteEntity(${entity.className} entity) {
-        entity.deleteBase();
+    public Map getCreatedObjects() {
+        return loadState(BaseState.CREATE);
     }
 </#if>
 }
diff --git a/DaoGenerator/src-template/entity.ftl b/DaoGenerator/src-template/entity.ftl
index b346502f..3d34c1a6 100644
--- a/DaoGenerator/src-template/entity.ftl
+++ b/DaoGenerator/src-template/entity.ftl
@@ -22,13 +22,17 @@ along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
 <#assign complexTypes = ["String", "ByteArray", "Date"]/>
 package ${entity.javaPackage};
 
-<#if entity.toManyRelations?has_content>
+<#if entity.toManyRelations?has_content || (schema.greenSyncEnabled && !entity.aBaseEntity)>
 import java.util.List;
 </#if>
+<#if schema.greenSyncEnabled && !entity.aBaseEntity>
+import de.greenrobot.dao.sync.GreenSync;
+import com.google.gson.reflect.TypeToken;
+</#if>
 <#if entity.enums?has_content>
 import de.greenrobot.dao.DaoEnum;
-import java.util.HashMap;
 import java.util.Map;
+import java.util.HashMap;
 
 </#if>
 <#list entity.properties as property>
@@ -36,8 +40,10 @@ import java.util.Map;
 import ${entity.javaPackage}.${property.entityEnum.entity.className}<#if !property.entityEnum.entity.anEnum>.${property.entityEnum.enumName}</#if>;
     </#if>
 </#list>
+<#if entity.aBaseEntity>
+import de.greenrobot.dao.sync.GreenSyncBase;
+</#if>
 <#if entity.active>
-import ${schema.defaultJavaPackageDao}.DaoSession;
 import de.greenrobot.dao.DaoException;
 
 </#if>
@@ -76,7 +82,6 @@ as ifc>${ifc}<#if ifc_has_next>, </#if></#list></#if> {
 
     /** Used for active entity operations. */
     private transient ${entity.classNameDao} myDao;
-
 <#list entity.toOneRelations as toOne>
     private ${toOne.targetEntity.className} ${toOne.name};
 <#if toOne.useFkProperty>
@@ -84,7 +89,6 @@ as ifc>${ifc}<#if ifc_has_next>, </#if></#list></#if> {
 <#else>
     private boolean ${toOne.name}__refreshed;
 </#if>
-
 </#list>
 <#list entity.toManyRelations as toMany>
     private List<${toMany.targetEntity.className}> ${toMany.name};
@@ -99,41 +103,42 @@ ${keepFields!}    // KEEP FIELDS END
 <#if entity.constructors>
     public ${entity.className}() {
     }
-<#if entity.propertiesPk?has_content && entity.propertiesPk?size != entity.properties?size>
 
+<#if entity.propertiesPk?has_content && entity.propertiesPk?size != entity.properties?size>
     public ${entity.className}(<#list entity.propertiesPk as
-property><#if property_index != 0>, </#if>${property.javaType} ${property.propertyName}</#list>) {
+property><#if property_index != 0 && property.reference>, </#if>${property.javaType} ${property.propertyName}</#list>) {
 <#list entity.propertiesPk as property>
         this.${property.propertyName} = ${property.propertyName};
 </#list>
     <#if entity.baseEntity??>
-        setDerivedEntityType(getClass().getSimpleName());
+        setDerivedEntityType(getClass().getCanonicalName());
     </#if>
     }
+
 </#if>
 <#if entity.hasReferenceProperty>
-
     ${entity.className}(<#list entity.properties as
 property>${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
 <#list entity.properties as property>
         this.${property.propertyName} = ${property.propertyName};
 </#list>
     }
-</#if>
 
+</#if>
+    <#assign x = 0>
     public ${entity.className}(<#list entity.properties as
-        property><#if !property.reference><#if property_index != 0>, </#if>${property.javaType} ${property.propertyName}</#if></#list>) {
+        property><#if !property.reference><#if x != 0>, </#if>${property.javaType} ${property.propertyName}<#assign x = x + 1></#if></#list>) {
     <#list entity.properties as property>
         <#if !property.reference>
         this.${property.propertyName} = ${property.propertyName};
         </#if>
     </#list>
     <#if entity.baseEntity??>
-        setDerivedEntityType(getClass().getSimpleName());
+        setDerivedEntityType(getClass().getCanonicalName());
     </#if>
     }
-</#if>
 
+</#if>
 <#if entity.active>
     /** called by internal mechanisms, do not call yourself. */
 <#if entity.baseEntity??>
@@ -160,30 +165,34 @@ property>${property.javaType} ${property.propertyName}<#if property_has_next>, <
 
     void insertBase(${entity.classNameDao} dao) {
         myDao = dao;
+        setState(BaseState.CREATE);
         dao.insert(this);
     }
 
-    void updateBase() {
+    void updateBase(SyncBaseDao dao) {
+        myDao = dao;
+        setState(BaseState.UPDATE);
         myDao.update(this);
     }
 
-    void deleteBase() {
+    void deleteBase(SyncBaseDao dao) {
+        myDao = dao;
+        setState(BaseState.DELETE);
         myDao.delete(this);
     }
 </#if>
 <#list entity.properties as property>
-
 <#if property.notNull && complexTypes?seq_contains(property.propertyType)>
     /** Not-null value. */
 </#if>
-    <#if !property.reference>public </#if>${property.javaType} get${property.propertyName?cap_first}() {
+    public ${property.javaType} get${property.propertyName?cap_first}() {
         return ${property.propertyName};
     }
+
 <#if property.notNull && complexTypes?seq_contains(property.propertyType)>
     /** Not-null value; ensure this value is available before it is saved to the database. */
 </#if>
-
-    <#if !property.reference>public </#if>void set${property.propertyName?cap_first}(${property.javaType} ${property.propertyName}) {
+    public void set${property.propertyName?cap_first}(${property.javaType} ${property.propertyName}) {
         this.${property.propertyName} = ${property.propertyName};
     }
 
@@ -347,4 +356,11 @@ property>${property.javaType} ${property.propertyName}<#if property_has_next>, <
 ${keepMethods!}    // KEEP METHODS END
 
 </#if>
-}
+<#if schema.greenSyncEnabled && !entity.aBaseEntity>
+    static {
+        GreenSync.registerListTypeToken("${entity.className}", new TypeToken<List<${entity.className}>>(){}.getType());
+        GreenSync.registerTypeToken("${entity.className}", ${entity.className}.class);
+    }
+
+</#if>
+}
\ No newline at end of file
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java b/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
index ee86fea1..1f8f2af5 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
@@ -470,6 +470,9 @@ public String getSuperclass() {
     }
 
     public void setSuperclass(String classToExtend) {
+        if (superclass != null) {
+            throw new IllegalArgumentException("Superclass already set, you are trying to extend two different classes!");
+        }
         this.superclass = classToExtend;
     }
 
@@ -478,6 +481,9 @@ public Entity getBaseEntity() {
     }
 
     public void setBaseEntity(Entity baseEntity) {
+        if (this.baseEntity != null) {
+            throw new IllegalArgumentException("Base entity already set, you cannot set two base entities!");
+        }
         if (!baseEntity.isaBaseEntity()) {
             baseEntity.setaBaseEntity();
         }
@@ -494,7 +500,7 @@ public void setaBaseEntity() {
         // initialize derived type property
         if (!aBaseEntity) {
             aBaseEntity = true;
-            addStringProperty("derivedEntityType").notNull().markTransient();
+            addStringProperty("derivedEntityType").markTransient();
         }
     }
 
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/Schema.java b/DaoGenerator/src/de/greenrobot/daogenerator/Schema.java
index 310447e8..26a79c0a 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/Schema.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/Schema.java
@@ -38,6 +38,7 @@
     private Map<PropertyType, String> propertyToJavaTypeNullable;
     private boolean hasKeepSectionsByDefault;
     private boolean useActiveEntitiesByDefault;
+    private Entity syncBaseEntity;
 
     public Schema(int version, String defaultJavaPackage) {
         this.version = version;
@@ -54,6 +55,28 @@ public void enableActiveEntitiesByDefault() {
         useActiveEntitiesByDefault = true;
     }
 
+    public void enableGreenSync() {
+        syncBaseEntity = addEntity("SyncBase");
+        syncBaseEntity.addLongProperty("syncBaseId").primaryKey().markTransient();
+        syncBaseEntity.addDateProperty("createdOn");
+        syncBaseEntity.addDateProperty("updatedOn");
+        syncBaseEntity.addStringProperty("externalId");
+        syncBaseEntity.implementsInterface("GreenSyncBase");
+
+        ArrayList<EntityEnum.Value> values = new ArrayList<EntityEnum.Value>();
+        values.add(new EntityEnum.Value("create", 1));
+        values.add(new EntityEnum.Value("update", 2));
+        values.add(new EntityEnum.Value("delete", 3));
+        values.add(new EntityEnum.Value("clean", 3));
+        EnumEntity enumEntity = addEnumEntity("BaseState", values);
+
+        syncBaseEntity.addEnumProperty(enumEntity.getEntityEnum(), "state").markTransient();
+    }
+
+    public boolean isGreenSyncEnabled() {
+        return syncBaseEntity != null;
+    }
+
     private void initTypeMappings() {
         propertyToDbType = new HashMap<PropertyType, String>();
         propertyToDbType.put(PropertyType.Boolean, "INTEGER");
@@ -100,7 +123,22 @@ private void initTypeMappings() {
      * per table to create table scripts, etc.
      */
     public Entity addEntity(String className) {
+        return addEntity(className, true);
+    }
+
+    /**
+     * Adds a new entity to the schema. There can be multiple entities per table, but only one may be the primary entity
+     * per table to create table scripts, etc.
+     *
+     * If GreenSync is enabled the entity can be added to the syncing process
+     */
+    public Entity addEntity(String className, boolean syncable) {
         Entity entity = new Entity(this, className);
+
+        if (syncBaseEntity != null && syncable) {
+            entity.setBaseEntity(syncBaseEntity);
+        }
+
         entities.add(entity);
         return entity;
     }
diff --git a/GreenSync/build.gradle b/GreenSync/build.gradle
deleted file mode 100644
index 6a353d8f..00000000
--- a/GreenSync/build.gradle
+++ /dev/null
@@ -1,36 +0,0 @@
-apply plugin: 'java'
-apply plugin: 'maven'
-
-group = 'de.greenrobot'
-sourceCompatibility = 1.6
-version = '1.3.0'
-
-repositories {
-    mavenCentral()
-}
-
-configurations {
-    provided
-}
-
-dependencies {
-    compile project(':DaoCore')
-    compile('com.google.code.gson:gson:2.2.4')
-}
-
-artifacts {
-    archives jar
-}
-
-sourceSets {
-    main {
-        java {
-            srcDir 'src'
-        }
-    }
-    test {
-        java {
-            srcDir 'src-test'
-        }
-    }
-}
\ No newline at end of file
diff --git a/GreenSync/gradle/wrapper/gradle-wrapper.jar b/GreenSync/gradle/wrapper/gradle-wrapper.jar
deleted file mode 100644
index d5c591c9..00000000
Binary files a/GreenSync/gradle/wrapper/gradle-wrapper.jar and /dev/null differ
diff --git a/GreenSync/gradle/wrapper/gradle-wrapper.properties b/GreenSync/gradle/wrapper/gradle-wrapper.properties
deleted file mode 100644
index 77861e64..00000000
--- a/GreenSync/gradle/wrapper/gradle-wrapper.properties
+++ /dev/null
@@ -1,6 +0,0 @@
-#Fri Mar 21 14:54:56 MDT 2014
-distributionBase=GRADLE_USER_HOME
-distributionPath=wrapper/dists
-zipStoreBase=GRADLE_USER_HOME
-zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-1.9-bin.zip
diff --git a/GreenSync/settings.gradle b/GreenSync/settings.gradle
deleted file mode 100644
index fbd11505..00000000
--- a/GreenSync/settings.gradle
+++ /dev/null
@@ -1,2 +0,0 @@
-include 'DaoCore'
-rootProject.name = 'greensync'
\ No newline at end of file
diff --git a/GreenSync/src/de/greenrobot/sync/GreenSync.java b/GreenSync/src/de/greenrobot/sync/GreenSync.java
deleted file mode 100644
index 945e8938..00000000
--- a/GreenSync/src/de/greenrobot/sync/GreenSync.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package de.greenrobot.sync;
-
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import de.greenrobot.dao.DaoEnum;
-
-import java.lang.reflect.Modifier;
-import java.util.*;
-
-/**
- * Created by saulhoward on 3/21/14.
- */
-public class GreenSync {
-
-    private Gson gson;
-
-    private final Map<Class<? extends DaoEnum>, EnumAdapter<? extends DaoEnum>> enumAdapters =
-            new LinkedHashMap<Class<? extends DaoEnum>, EnumAdapter<? extends DaoEnum>>();
-
-    public GreenSync() {
-        final GsonBuilder builder = new GsonBuilder();
-        builder.excludeFieldsWithModifiers(Modifier.TRANSIENT);
-        gson = builder.create();
-    }
-
-    /**
-     * Returns an enum adapter for {@code enumClass}.
-     */
-    @SuppressWarnings("unchecked")
-    synchronized <E extends DaoEnum> EnumAdapter<E> enumAdapter(Class<E> enumClass) {
-        EnumAdapter<E> adapter = (EnumAdapter<E>) enumAdapters.get(enumClass);
-        if (adapter == null) {
-            adapter = new EnumAdapter<E>(enumClass);
-            enumAdapters.put(enumClass, adapter);
-        }
-        return adapter;
-    }
-
-    public <T> boolean sync(T object) {
-        return false;
-    }
-
-    public <T> String sync(Class<T> clazz, List<T> objects) {
-
-        Map<String, List<T>> map = new HashMap<String, List<T>>();
-        map.put(clazz.getSimpleName(), objects);
-
-        return gson.toJson(map);
-    }
-}
diff --git a/settings.gradle b/settings.gradle
index 39da9b7e..dc0c4aa2 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,2 +1,2 @@
-include 'DaoCore', 'DaoGenerator', 'DaoExampleGenerator', 'DaoExample', 'GreenSync'
+include 'DaoCore', 'DaoGenerator', 'DaoExampleGenerator', 'DaoExample'
 // include 'DaoTest' // Travis needs some Android setup for this
\ No newline at end of file
