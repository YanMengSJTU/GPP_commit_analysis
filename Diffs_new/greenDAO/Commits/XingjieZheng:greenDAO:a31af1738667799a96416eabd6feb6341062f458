diff --git a/DaoCore/build.gradle b/DaoCore/build.gradle
index e3e42811..1dafff0e 100644
--- a/DaoCore/build.gradle
+++ b/DaoCore/build.gradle
@@ -19,8 +19,8 @@ dependencies {
     compileOnly 'com.google.android:annotations:4.1.1.4'
     compileOnly 'com.google.android:support-v4:r7'
 
-    compileOnly 'io.reactivex:rxjava:1.1.8'
-    compileOnly 'io.reactivex.rxjava2:rxjava:2.0.9'
+//    compileOnly 'io.reactivex:rxjava:1.1.8'
+    compileOnly 'io.reactivex.rxjava2:rxjava:2.1.8'
 
     compileOnly files('libs/sqlcipher.jar')
 }
diff --git a/DaoCore/src/main/java/org/greenrobot/greendao/AbstractDao.java b/DaoCore/src/main/java/org/greenrobot/greendao/AbstractDao.java
index 17fbd4fa..315b299b 100644
--- a/DaoCore/src/main/java/org/greenrobot/greendao/AbstractDao.java
+++ b/DaoCore/src/main/java/org/greenrobot/greendao/AbstractDao.java
@@ -32,7 +32,6 @@
 import org.greenrobot.greendao.internal.TableStatements;
 import org.greenrobot.greendao.query.Query;
 import org.greenrobot.greendao.query.QueryBuilder;
-import org.greenrobot.greendao.rx.RxDao;
 import org.greenrobot.greendao.rx2.Rx2Dao;
 
 import java.util.ArrayList;
@@ -40,8 +39,6 @@
 import java.util.Collection;
 import java.util.List;
 
-import rx.schedulers.Schedulers;
-
 /**
  * Base class for all DAOs: Implements entity operations like insert, load, delete, and query.
  * <p>
@@ -53,11 +50,11 @@
  */
 /*
  * When operating on TX, statements, or identity scope the following locking order must be met to avoid deadlocks:
- * 
+ *
  * 1.) If not inside a TX already, begin a TX to acquire a DB connection (connection is to be handled like a lock)
- * 
+ *
  * 2.) The DatabaseStatement
- * 
+ *
  * 3.) identityScope
  */
 public abstract class AbstractDao<T, K> {
@@ -71,9 +68,6 @@
     protected final AbstractDaoSession session;
     protected final int pkOrdinal;
 
-    private volatile RxDao<T, K> rxDao;
-    private volatile RxDao<T, K> rxDaoPlain;
-
     private volatile Rx2Dao<T, K> rx2Dao;
     private volatile Rx2Dao<T, K> rx2DaoPlain;
 
@@ -176,13 +170,17 @@ protected T loadUnique(Cursor cursor) {
         return loadCurrent(cursor, 0, true);
     }
 
-    /** Loads all available entities from the database. */
+    /**
+     * Loads all available entities from the database.
+     */
     public List<T> loadAll() {
         Cursor cursor = db.rawQuery(statements.getSelectAll(), null);
         return loadAllAndCloseCursor(cursor);
     }
 
-    /** Detaches an entity from the identity scope (session). Subsequent query results won't return this object. */
+    /**
+     * Detaches an entity from the identity scope (session). Subsequent query results won't return this object.
+     */
     public boolean detach(T entity) {
         if (identityScope != null) {
             K key = getKeyVerified(entity);
@@ -452,7 +450,9 @@ public void saveInTx(Iterable<T> entities) {
         }
     }
 
-    /** Reads all available rows from the given cursor and returns a list of entities. */
+    /**
+     * Reads all available rows from the given cursor and returns a list of entities.
+     */
     protected List<T> loadAllFromCursor(Cursor cursor) {
         int count = cursor.getCount();
         if (count == 0) {
@@ -532,7 +532,9 @@ private CursorWindow moveToNextUnlocked(Cursor cursor) {
         }
     }
 
-    /** Internal use only. Considers identity scope. */
+    /**
+     * Internal use only. Considers identity scope.
+     */
     final protected T loadCurrent(Cursor cursor, int offset, boolean lock) {
         if (identityScopeLong != null) {
             if (offset != 0) {
@@ -585,12 +587,16 @@ final protected T loadCurrent(Cursor cursor, int offset, boolean lock) {
         }
     }
 
-    /** Internal use only. Considers identity scope. */
+    /**
+     * Internal use only. Considers identity scope.
+     */
     final protected <O> O loadCurrentOther(AbstractDao<O, ?> dao, Cursor cursor, int offset) {
         return dao.loadCurrent(cursor, offset, /* TODO check this */true);
     }
 
-    /** A raw-style query where you can pass any WHERE clause and arguments. */
+    /**
+     * A raw-style query where you can pass any WHERE clause and arguments.
+     */
     public List<T> queryRaw(String where, String... selectionArg) {
         Cursor cursor = db.rawQuery(statements.getSelectAll() + where, selectionArg);
         return loadAllAndCloseCursor(cursor);
@@ -623,14 +629,18 @@ public void deleteAll() {
         }
     }
 
-    /** Deletes the given entity from the database. Currently, only single value PK entities are supported. */
+    /**
+     * Deletes the given entity from the database. Currently, only single value PK entities are supported.
+     */
     public void delete(T entity) {
         assertSinglePk();
         K key = getKeyVerified(entity);
         deleteByKey(key);
     }
 
-    /** Deletes an entity with the given PK from the database. Currently, only single value PK entities are supported. */
+    /**
+     * Deletes an entity with the given PK from the database. Currently, only single value PK entities are supported.
+     */
     public void deleteByKey(K key) {
         assertSinglePk();
         DatabaseStatement stmt = statements.getDeleteStatement();
@@ -746,7 +756,9 @@ public void deleteByKeyInTx(K... keys) {
         deleteInTxInternal(null, Arrays.asList(keys));
     }
 
-    /** Resets all locally changed properties of the entity by reloading the values from the database. */
+    /**
+     * Resets all locally changed properties of the entity by reloading the values from the database.
+     */
     public void refresh(T entity) {
         assertSinglePk();
         K key = getKeyVerified(entity);
@@ -926,7 +938,9 @@ public long count() {
         return statements.getCountStatement().simpleQueryForLong();
     }
 
-    /** See {@link #getKey(Object)}, but guarantees that the returned key is never null (throws if null). */
+    /**
+     * See {@link #getKey(Object)}, but guarantees that the returned key is never null (throws if null).
+     */
     protected K getKeyVerified(T entity) {
         K key = getKey(entity);
         if (key == null) {
@@ -940,34 +954,6 @@ protected K getKeyVerified(T entity) {
         }
     }
 
-    /**
-     * The returned RxDao is a special DAO that let's you interact with Rx Observables without any Scheduler set
-     * for subscribeOn.
-     *
-     * @see #rx()
-     */
-    @Experimental
-    public RxDao<T, K> rxPlain() {
-        if (rxDaoPlain == null) {
-            rxDaoPlain = new RxDao<>(this);
-        }
-        return rxDaoPlain;
-    }
-
-    /**
-     * The returned RxDao is a special DAO that let's you interact with Rx Observables using RX's IO scheduler for
-     * subscribeOn.
-     *
-     * @see #rxPlain()
-     */
-    @Experimental
-    public RxDao<T, K> rx() {
-        if (rxDao == null) {
-            rxDao = new RxDao<>(this, Schedulers.io());
-        }
-        return rxDao;
-    }
-
     /**
      * The returned Rx2Dao is a special DAO that let's you interact with Rx Observables without any Scheduler set
      * for subscribeOn.
@@ -996,22 +982,32 @@ protected K getKeyVerified(T entity) {
         return rx2Dao;
     }
 
-    /** Gets the SQLiteDatabase for custom database access. Not needed for greenDAO entities. */
+    /**
+     * Gets the SQLiteDatabase for custom database access. Not needed for greenDAO entities.
+     */
     public Database getDatabase() {
         return db;
     }
 
-    /** Reads the values from the current position of the given cursor and returns a new entity. */
+    /**
+     * Reads the values from the current position of the given cursor and returns a new entity.
+     */
     abstract protected T readEntity(Cursor cursor, int offset);
 
 
-    /** Reads the key from the current position of the given cursor, or returns null if there's no single-value key. */
+    /**
+     * Reads the key from the current position of the given cursor, or returns null if there's no single-value key.
+     */
     abstract protected K readKey(Cursor cursor, int offset);
 
-    /** Reads the values from the current position of the given cursor into an existing entity. */
+    /**
+     * Reads the values from the current position of the given cursor into an existing entity.
+     */
     abstract protected void readEntity(Cursor cursor, T entity, int offset);
 
-    /** Binds the entity's values to the statement. Make sure to synchronize the statement outside of the method. */
+    /**
+     * Binds the entity's values to the statement. Make sure to synchronize the statement outside of the method.
+     */
     abstract protected void bindValues(DatabaseStatement stmt, T entity);
 
     /**
@@ -1038,7 +1034,9 @@ public Database getDatabase() {
      */
     abstract protected boolean hasKey(T entity);
 
-    /** Returns true if the Entity class can be updated, e.g. for setting the PK after insert. */
+    /**
+     * Returns true if the Entity class can be updated, e.g. for setting the PK after insert.
+     */
     abstract protected boolean isEntityUpdateable();
 
 }
diff --git a/DaoCore/src/main/java/org/greenrobot/greendao/AbstractDaoSession.java b/DaoCore/src/main/java/org/greenrobot/greendao/AbstractDaoSession.java
index f8636bb6..d0ed1b25 100644
--- a/DaoCore/src/main/java/org/greenrobot/greendao/AbstractDaoSession.java
+++ b/DaoCore/src/main/java/org/greenrobot/greendao/AbstractDaoSession.java
@@ -26,9 +26,9 @@
 import org.greenrobot.greendao.async.AsyncSession;
 import org.greenrobot.greendao.database.Database;
 import org.greenrobot.greendao.query.QueryBuilder;
-import org.greenrobot.greendao.rx.RxTransaction;
+import org.greenrobot.greendao.rx2.Rx2Transaction;
 
-import rx.schedulers.Schedulers;
+import io.reactivex.schedulers.Schedulers;
 
 /**
  * DaoSession gives you access to your DAOs, offers convenient persistence methods, and also serves as a session cache.<br>
@@ -53,8 +53,8 @@
     private final Database db;
     private final Map<Class<?>, AbstractDao<?, ?>> entityToDao;
 
-    private volatile RxTransaction rxTxPlain;
-    private volatile RxTransaction rxTxIo;
+    private volatile Rx2Transaction rxTxPlain;
+    private volatile Rx2Transaction rxTxIo;
 
     public AbstractDaoSession(Database db) {
         this.db = db;
@@ -209,29 +209,29 @@ public AsyncSession startAsyncSession() {
     }
 
     /**
-     * The returned {@link RxTransaction} allows DB transactions using Rx Observables without any Scheduler set for
+     * The returned {@link Rx2Transaction} allows DB transactions using Rx Observables without any Scheduler set for
      * subscribeOn.
      *
      * @see #rxTx()
      */
     @Experimental
-    public RxTransaction rxTxPlain() {
+    public Rx2Transaction rxTxPlain() {
         if (rxTxPlain == null) {
-            rxTxPlain = new RxTransaction(this);
+            rxTxPlain = new Rx2Transaction(this);
         }
         return rxTxPlain;
     }
 
     /**
-     * The returned {@link RxTransaction} allows DB transactions using Rx Observables using RX's IO scheduler for
+     * The returned {@link Rx2Transaction} allows DB transactions using Rx Observables using RX's IO scheduler for
      * subscribeOn.
      *
      * @see #rxTxPlain()
      */
     @Experimental
-    public RxTransaction rxTx() {
+    public Rx2Transaction rxTx() {
         if (rxTxIo == null) {
-            rxTxIo = new RxTransaction(this, Schedulers.io());
+            rxTxIo = new Rx2Transaction(this, Schedulers.io());
         }
         return rxTxIo;
     }
diff --git a/DaoCore/src/main/java/org/greenrobot/greendao/query/Query.java b/DaoCore/src/main/java/org/greenrobot/greendao/query/Query.java
index 1a3c8bc0..16523a21 100644
--- a/DaoCore/src/main/java/org/greenrobot/greendao/query/Query.java
+++ b/DaoCore/src/main/java/org/greenrobot/greendao/query/Query.java
@@ -20,16 +20,12 @@
 import org.greenrobot.greendao.AbstractDao;
 import org.greenrobot.greendao.DaoException;
 import org.greenrobot.greendao.annotation.apihint.Internal;
-import org.greenrobot.greendao.rx.RxQuery;
-import org.greenrobot.greendao.rx.RxTransaction;
 import org.greenrobot.greendao.rx2.Rx2Query;
 import org.greenrobot.greendao.rx2.Rx2Transaction;
 
 import java.util.Date;
 import java.util.List;
 
-import rx.schedulers.Schedulers;
-
 /**
  * A repeatable query returning entities.
  *
@@ -54,7 +50,9 @@
 
     }
 
-    /** For internal use by greenDAO only. */
+    /**
+     * For internal use by greenDAO only.
+     */
     public static <T2> Query<T2> internalCreate(AbstractDao<T2, ?> dao, String sql, Object[] initialValues) {
         return create(dao, sql, initialValues, -1, -1);
     }
@@ -68,9 +66,6 @@
 
     private final QueryData<T> queryData;
 
-    private volatile RxQuery rxTxPlain;
-    private volatile RxQuery rxTxIo;
-
     private volatile Rx2Query rx2TxPlain;
     private volatile Rx2Query rx2TxIo;
 
@@ -87,7 +82,9 @@ private Query(QueryData<T> queryData, AbstractDao<T, ?> dao, String sql, String[
         return queryData.forCurrentThread(this);
     }
 
-    /** Executes the query and returns the result as a list containing all entities loaded into memory. */
+    /**
+     * Executes the query and returns the result as a list containing all entities loaded into memory.
+     */
     public List<T> list() {
         checkThread();
         Cursor cursor = dao.getDatabase().rawQuery(sql, parameters);
@@ -164,42 +161,12 @@ public T uniqueOrThrow() {
         return (Query<T>) super.setParameter(index, parameter);
     }
 
-    /**
-     * DO NOT USE.
-     * The returned {@link RxTransaction} allows getting query results using Rx Observables without any Scheduler set
-     * for subscribeOn.
-     *
-     * @see #__InternalRx()
-     */
-    @Internal
-    public RxQuery __internalRxPlain() {
-        if (rxTxPlain == null) {
-            rxTxPlain = new RxQuery(this);
-        }
-        return rxTxPlain;
-    }
-
-    /**
-     * DO NOT USE.
-     * The returned {@link RxTransaction} allows getting query results using Rx Observables using RX's IO scheduler for
-     * subscribeOn.
-     *
-     * @see #__internalRxPlain()
-     */
-    @Internal
-    public RxQuery __InternalRx() {
-        if (rxTxIo == null) {
-            rxTxIo = new RxQuery(this, Schedulers.io());
-        }
-        return rxTxIo;
-    }
-
     /**
      * DO NOT USE.
      * The returned {@link Rx2Transaction} allows getting query results using Rx Observables without any Scheduler set
      * for subscribeOn.
-     *
-     * @see #__InternalRx()
+     * <p>
+     * //     * @see #__InternalRx()
      */
     @Internal
     public Rx2Query __internalRx2Plain() {
@@ -214,7 +181,7 @@ public Rx2Query __internalRx2Plain() {
      * The returned {@link Rx2Transaction} allows getting query results using Rx Observables using RX's IO scheduler for
      * subscribeOn.
      *
-     * @see #__internalRxPlain()
+     * @see #__internalRx2Plain()
      */
     @Internal
     public Rx2Query __InternalRx2() {
diff --git a/DaoCore/src/main/java/org/greenrobot/greendao/query/QueryBuilder.java b/DaoCore/src/main/java/org/greenrobot/greendao/query/QueryBuilder.java
index 8a030e4d..d09cebd2 100644
--- a/DaoCore/src/main/java/org/greenrobot/greendao/query/QueryBuilder.java
+++ b/DaoCore/src/main/java/org/greenrobot/greendao/query/QueryBuilder.java
@@ -25,7 +25,6 @@
 import org.greenrobot.greendao.Property;
 import org.greenrobot.greendao.annotation.apihint.Experimental;
 import org.greenrobot.greendao.internal.SqlUtils;
-import org.greenrobot.greendao.rx.RxQuery;
 import org.greenrobot.greendao.rx2.Rx2Query;
 
 import java.util.ArrayList;
@@ -48,10 +47,14 @@
  */
 public class QueryBuilder<T> {
 
-    /** Set to true to debug the SQL. */
+    /**
+     * Set to true to debug the SQL.
+     */
     public static boolean LOG_SQL;
 
-    /** Set to see the given values. */
+    /**
+     * Set to see the given values.
+     */
     public static boolean LOG_VALUES;
     private final WhereCollector<T> whereCollector;
 
@@ -66,10 +69,14 @@
     private Integer offset;
     private boolean distinct;
 
-    /** stored with a leading space */
+    /**
+     * stored with a leading space
+     */
     private String stringOrderCollation;
 
-    /** For internal use by greenDAO only. */
+    /**
+     * For internal use by greenDAO only.
+     */
     public static <T2> QueryBuilder<T2> internalCreate(AbstractDao<T2, ?> dao) {
         return new QueryBuilder<T2>(dao);
     }
@@ -95,7 +102,9 @@ private void checkOrderBuilder() {
         }
     }
 
-    /** Use a SELECT DISTINCT to avoid duplicate entities returned, e.g. when doing joins. */
+    /**
+     * Use a SELECT DISTINCT to avoid duplicate entities returned, e.g. when doing joins.
+     */
     public QueryBuilder<T> distinct() {
         distinct = true;
         return this;
@@ -215,13 +224,17 @@ public WhereCondition and(WhereCondition cond1, WhereCondition cond2, WhereCondi
         return join;
     }
 
-    /** Adds the given properties to the ORDER BY section using ascending order. */
+    /**
+     * Adds the given properties to the ORDER BY section using ascending order.
+     */
     public QueryBuilder<T> orderAsc(Property... properties) {
         orderAscOrDesc(" ASC", properties);
         return this;
     }
 
-    /** Adds the given properties to the ORDER BY section using descending order. */
+    /**
+     * Adds the given properties to the ORDER BY section using descending order.
+     */
     public QueryBuilder<T> orderDesc(Property... properties) {
         orderAscOrDesc(" DESC", properties);
         return this;
@@ -238,7 +251,9 @@ private void orderAscOrDesc(String ascOrDescWithLeadingSpace, Property... proper
         }
     }
 
-    /** Adds the given properties to the ORDER BY section using the given custom order. */
+    /**
+     * Adds the given properties to the ORDER BY section using the given custom order.
+     */
     public QueryBuilder<T> orderCustom(Property property, String customOrderForProperty) {
         checkOrderBuilder();
         append(orderBuilder, property).append(' ');
@@ -263,7 +278,9 @@ protected StringBuilder append(StringBuilder builder, Property property) {
     }
 
 
-    /** Limits the number of results returned by queries. */
+    /**
+     * Limits the number of results returned by queries.
+     */
     public QueryBuilder<T> limit(int limit) {
         this.limit = limit;
         return this;
@@ -444,22 +461,6 @@ private void appendJoinsAndWheres(StringBuilder builder, String tablePrefixOrNul
         return build().__internalRx2Plain();
     }
 
-    /**
-     * Shorthand for {@link QueryBuilder#build() build()}.{@link Query#__InternalRx()}.
-     */
-    @Experimental
-    public RxQuery<T> rx() {
-        return build().__InternalRx();
-    }
-
-    /**
-     * Shorthand for {@link QueryBuilder#build() build()}.{@link Query#__internalRxPlain()}.
-     */
-    @Experimental
-    public RxQuery<T> rxPlain() {
-        return build().__internalRxPlain();
-    }
-
     /**
      * Shorthand for {@link QueryBuilder#build() build()}.{@link Query#listLazy() listLazy()}; see
      * {@link Query#listLazy()} for details. To execute a query more than once, you should build the query and keep the
diff --git a/DaoCore/src/main/java/org/greenrobot/greendao/rx/RxBase.java b/DaoCore/src/main/java/org/greenrobot/greendao/rx/RxBase.java
deleted file mode 100644
index 47aa355c..00000000
--- a/DaoCore/src/main/java/org/greenrobot/greendao/rx/RxBase.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (C) 2011-2016 Markus Junginger, greenrobot (http://greenrobot.org)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.greenrobot.greendao.rx;
-
-import org.greenrobot.greendao.annotation.apihint.Experimental;
-import org.greenrobot.greendao.annotation.apihint.Internal;
-
-import java.util.concurrent.Callable;
-
-import rx.Observable;
-import rx.Scheduler;
-
-/**
- * Base functionality for Rx, e.g. default scheduler.
- */
-@Internal
-class RxBase {
-
-    protected final Scheduler scheduler;
-
-    /**
-     * No default scheduler.
-     */
-    RxBase() {
-        scheduler = null;
-    }
-
-    /**
-     * Sets the default scheduler, which is used to configure returned observables with
-     * {@link Observable#subscribeOn(Scheduler)}.
-     */
-    @Experimental
-    RxBase(Scheduler scheduler) {
-        this.scheduler = scheduler;
-    }
-
-    /**
-     * The default scheduler (or null) used for wrapping.
-     */
-    @Experimental
-    public Scheduler getScheduler() {
-        return scheduler;
-    }
-
-    protected <R> Observable<R> wrap(Callable<R> callable) {
-        return wrap(RxUtils.fromCallable(callable));
-    }
-
-    protected <R> Observable<R> wrap(Observable<R> observable) {
-        if (scheduler != null) {
-            return observable.subscribeOn(scheduler);
-        } else {
-            return observable;
-        }
-    }
-
-}
diff --git a/DaoCore/src/main/java/org/greenrobot/greendao/rx/RxDao.java b/DaoCore/src/main/java/org/greenrobot/greendao/rx/RxDao.java
deleted file mode 100644
index 229b3ce2..00000000
--- a/DaoCore/src/main/java/org/greenrobot/greendao/rx/RxDao.java
+++ /dev/null
@@ -1,406 +0,0 @@
-/*
- * Copyright (C) 2011-2016 Markus Junginger, greenrobot (http://greenrobot.org)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.greenrobot.greendao.rx;
-
-import org.greenrobot.greendao.AbstractDao;
-import org.greenrobot.greendao.annotation.apihint.Experimental;
-
-import java.util.List;
-import java.util.concurrent.Callable;
-
-import rx.Observable;
-import rx.Scheduler;
-
-/**
- * Like {@link AbstractDao} but with Rx support. Most methods from AbstractDao are present here, but will return an
- * {@link Observable}. Modifying operations return the given entities, so they can be further processed in Rx.
- * <p>
- * Instances of RxDao may have an default {@link rx.Scheduler}, which is used to configure returned observables with
- * {@link Observable#subscribeOn(Scheduler)} (see {@link AbstractDao#rxPlain()}, which uses the IO scheduler).
- *
- * Note: DO NOT call more than one data modification operation when you can use a transaction instead (see
- * {@link RxTransaction}. Individual calls use a transaction each and are much slower.
- *
- * @param <T> Entity type
- * @param <K> Primary key (PK) type; use Void if entity does not have exactly one PK
- * @see AbstractDao#rxPlain()
- */
-@Experimental
-public class RxDao<T, K> extends RxBase {
-
-    private final AbstractDao<T, K> dao;
-
-    /**
-     * Creates a new RxDao without a default scheduler.
-     */
-    @Experimental
-    public RxDao(AbstractDao<T, K> dao) {
-        this(dao, null);
-    }
-
-    /**
-     * Creates a new RxDao with a default scheduler, which is used to configure returned observables with
-     * {@link Observable#subscribeOn(Scheduler)}.
-     */
-    @Experimental
-    public RxDao(AbstractDao<T, K> dao, Scheduler scheduler) {
-        super(scheduler);
-        this.dao = dao;
-    }
-
-    /**
-     * Rx version of {@link AbstractDao#loadAll()} returning an Observable.
-     */
-    @Experimental
-    public Observable<List<T>> loadAll() {
-        return wrap(new Callable<List<T>>() {
-            @Override
-            public List<T> call() throws Exception {
-                return dao.loadAll();
-            }
-        });
-    }
-
-    /**
-     * Rx version of {@link AbstractDao#loadAll()} returning an Observable.
-     */
-    @Experimental
-    public Observable<T> load(final K key) {
-        return wrap(new Callable<T>() {
-            @Override
-            public T call() throws Exception {
-                return dao.load(key);
-            }
-        });
-    }
-
-    /**
-     * Rx version of {@link AbstractDao#refresh(Object)} returning an Observable.
-     * Note that the Observable will emit the given entity back to its subscribers.
-     */
-    @Experimental
-    public Observable<T> refresh(final T entity) {
-        return wrap(new Callable<T>() {
-            @Override
-            public T call() throws Exception {
-                dao.refresh(entity);
-                return entity;
-            }
-        });
-    }
-
-    /**
-     * Rx version of {@link AbstractDao#insert(Object)} returning an Observable.
-     * Note that the Observable will emit the given entity back to its subscribers.
-     */
-    @Experimental
-    public Observable<T> insert(final T entity) {
-        return wrap(new Callable<T>() {
-            @Override
-            public T call() throws Exception {
-                dao.insert(entity);
-                return entity;
-            }
-        });
-    }
-
-    /**
-     * Rx version of {@link AbstractDao#insertInTx(Iterable)} returning an Observable.
-     * Note that the Observable will emit the given entities back to its subscribers.
-     */
-    @Experimental
-    public Observable<Iterable<T>> insertInTx(final Iterable<T> entities) {
-        return wrap(new Callable<Iterable<T>>() {
-            @Override
-            public Iterable<T> call() throws Exception {
-                dao.insertInTx(entities);
-                return entities;
-            }
-        });
-    }
-
-    /**
-     * Rx version of {@link AbstractDao#insertInTx(Object[])} returning an Observable.
-     * Note that the Observable will emit the given entities back to its subscribers.
-     */
-    @Experimental
-    public Observable<Object[]> insertInTx(final T... entities) {
-        return wrap(new Callable<Object[]>() {
-            @Override
-            public Object[] call() throws Exception {
-                dao.insertInTx(entities);
-                return entities;
-            }
-        });
-    }
-
-    /**
-     * Rx version of {@link AbstractDao#insertOrReplace(Object)} returning an Observable.
-     * Note that the Observable will emit the given entity back to its subscribers.
-     */
-    @Experimental
-    public Observable<T> insertOrReplace(final T entity) {
-        return wrap(new Callable<T>() {
-            @Override
-            public T call() throws Exception {
-                dao.insertOrReplace(entity);
-                return entity;
-            }
-        });
-    }
-
-    /**
-     * Rx version of {@link AbstractDao#insertOrReplaceInTx(Iterable)} returning an Observable.
-     * Note that the Observable will emit the given entities back to its subscribers.
-     */
-    @Experimental
-    public Observable<Iterable<T>> insertOrReplaceInTx(final Iterable<T> entities) {
-        return wrap(new Callable<Iterable<T>>() {
-            @Override
-            public Iterable<T> call() throws Exception {
-                dao.insertOrReplaceInTx(entities);
-                return entities;
-            }
-        });
-    }
-
-    /**
-     * Rx version of {@link AbstractDao#insertOrReplaceInTx(Object[])} returning an Observable.
-     * Note that the Observable will emit the given entities back to its subscribers.
-     */
-    @Experimental
-    public Observable<Object[]> insertOrReplaceInTx(final T... entities) {
-        return wrap(new Callable<Object[]>() {
-            @Override
-            public Object[] call() throws Exception {
-                dao.insertOrReplaceInTx(entities);
-                return entities;
-            }
-        });
-    }
-
-    /**
-     * Rx version of {@link AbstractDao#save(Object)} returning an Observable.
-     * Note that the Observable will emit the given entity back to its subscribers.
-     */
-    @Experimental
-    public Observable<T> save(final T entity) {
-        return wrap(new Callable<T>() {
-            @Override
-            public T call() throws Exception {
-                dao.save(entity);
-                return entity;
-            }
-        });
-    }
-
-    /**
-     * Rx version of {@link AbstractDao#saveInTx(Iterable)} returning an Observable.
-     * Note that the Observable will emit the given entities back to its subscribers.
-     */
-    @Experimental
-    public Observable<Iterable<T>> saveInTx(final Iterable<T> entities) {
-        return wrap(new Callable<Iterable<T>>() {
-            @Override
-            public Iterable<T> call() throws Exception {
-                dao.saveInTx(entities);
-                return entities;
-            }
-        });
-    }
-
-    /**
-     * Rx version of {@link AbstractDao#saveInTx(Object[])} returning an Observable.
-     * Note that the Observable will emit the given entities back to its subscribers.
-     */
-    @Experimental
-    public Observable<Object[]> saveInTx(final T... entities) {
-        return wrap(new Callable<Object[]>() {
-            @Override
-            public Object[] call() throws Exception {
-                dao.saveInTx(entities);
-                return entities;
-            }
-        });
-    }
-
-    /**
-     * Rx version of {@link AbstractDao#update(Object)} returning an Observable.
-     * Note that the Observable will emit the given entity back to its subscribers.
-     */
-    @Experimental
-    public Observable<T> update(final T entity) {
-        return wrap(new Callable<T>() {
-            @Override
-            public T call() throws Exception {
-                dao.update(entity);
-                return entity;
-            }
-        });
-    }
-
-    /**
-     * Rx version of {@link AbstractDao#updateInTx(Iterable)} returning an Observable.
-     * Note that the Observable will emit the given entities back to its subscribers.
-     */
-    @Experimental
-    public Observable<Iterable<T>> updateInTx(final Iterable<T> entities) {
-        return wrap(new Callable<Iterable<T>>() {
-            @Override
-            public Iterable<T> call() throws Exception {
-                dao.updateInTx(entities);
-                return entities;
-            }
-        });
-    }
-
-    /**
-     * Rx version of {@link AbstractDao#updateInTx(Object[])} returning an Observable.
-     * Note that the Observable will emit the given entities back to its subscribers.
-     */
-    @Experimental
-    public Observable<Object[]> updateInTx(final T... entities) {
-        return wrap(new Callable<Object[]>() {
-            @Override
-            public Object[] call() throws Exception {
-                dao.updateInTx(entities);
-                return entities;
-            }
-        });
-    }
-
-
-    /**
-     * Rx version of {@link AbstractDao#delete(Object)} returning an Observable.
-     */
-    @Experimental
-    public Observable<Void> delete(final T entity) {
-        return wrap(new Callable<Void>() {
-            @Override
-            public Void call() throws Exception {
-                dao.delete(entity);
-                return null;
-            }
-        });
-    }
-
-    /**
-     * Rx version of {@link AbstractDao#deleteByKey(Object)} returning an Observable.
-     */
-    @Experimental
-    public Observable<Void> deleteByKey(final K key) {
-        return wrap(new Callable<Void>() {
-            @Override
-            public Void call() throws Exception {
-                dao.deleteByKey(key);
-                return null;
-            }
-        });
-    }
-
-    /**
-     * Rx version of {@link AbstractDao#deleteAll()} returning an Observable.
-     */
-    @Experimental
-    public Observable<Void> deleteAll() {
-        return wrap(new Callable<Void>() {
-            @Override
-            public Void call() throws Exception {
-                dao.deleteAll();
-                return null;
-            }
-        });
-    }
-
-    /**
-     * Rx version of {@link AbstractDao#deleteInTx(Iterable)} returning an Observable.
-     */
-    @Experimental
-    public Observable<Void> deleteInTx(final Iterable<T> entities) {
-        return wrap(new Callable<Void>() {
-            @Override
-            public Void call() throws Exception {
-                dao.deleteInTx(entities);
-                return null;
-            }
-        });
-    }
-
-    /**
-     * Rx version of {@link AbstractDao#deleteInTx(Object[])} returning an Observable.
-     */
-    @Experimental
-    public Observable<Void> deleteInTx(final T... entities) {
-        return wrap(new Callable<Void>() {
-            @Override
-            public Void call() throws Exception {
-                dao.deleteInTx(entities);
-                return null;
-            }
-        });
-    }
-
-    /**
-     * Rx version of {@link AbstractDao#deleteByKeyInTx(Iterable)} returning an Observable.
-     */
-    @Experimental
-    public Observable<Void> deleteByKeyInTx(final Iterable<K> keys) {
-        return wrap(new Callable<Void>() {
-            @Override
-            public Void call() throws Exception {
-                dao.deleteByKeyInTx(keys);
-                return null;
-            }
-        });
-    }
-
-    /**
-     * Rx version of {@link AbstractDao#deleteByKeyInTx(Object[])} returning an Observable.
-     */
-    @Experimental
-    public Observable<Void> deleteByKeyInTx(final K... keys) {
-        return wrap(new Callable<Void>() {
-            @Override
-            public Void call() throws Exception {
-                dao.deleteByKeyInTx(keys);
-                return null;
-            }
-        });
-    }
-
-    /**
-     * Rx version of {@link AbstractDao#count()} returning an Observable.
-     */
-    @Experimental
-    public Observable<Long> count() {
-        return wrap(new Callable<Long>() {
-            @Override
-            public Long call() throws Exception {
-                return dao.count();
-            }
-        });
-    }
-
-    /**
-     * The plain DAO.
-     */
-    @Experimental
-    public AbstractDao<T, K> getDao() {
-        return dao;
-    }
-
-}
diff --git a/DaoCore/src/main/java/org/greenrobot/greendao/rx/RxQuery.java b/DaoCore/src/main/java/org/greenrobot/greendao/rx/RxQuery.java
deleted file mode 100644
index cc01be35..00000000
--- a/DaoCore/src/main/java/org/greenrobot/greendao/rx/RxQuery.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright (C) 2011-2016 Markus Junginger, greenrobot (http://greenrobot.org)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.greenrobot.greendao.rx;
-
-import org.greenrobot.greendao.annotation.apihint.Experimental;
-import org.greenrobot.greendao.query.LazyList;
-import org.greenrobot.greendao.query.Query;
-
-import java.util.List;
-import java.util.concurrent.Callable;
-
-import rx.Observable;
-import rx.Observable.OnSubscribe;
-import rx.Scheduler;
-import rx.Subscriber;
-import rx.exceptions.Exceptions;
-
-/**
- * Gets {@link org.greenrobot.greendao.query.Query} results in Rx fashion.
- */
-@Experimental
-// TODO Pass parameters: currently, parameters are always set to their initial values because of forCurrentThread()
-public class RxQuery<T> extends RxBase {
-    private final Query<T> query;
-
-    public RxQuery(Query<T> query) {
-        this.query = query;
-    }
-
-    public RxQuery(Query<T> query, Scheduler scheduler) {
-        super(scheduler);
-        this.query = query;
-    }
-
-    /**
-     * Rx version of {@link Query#list()} returning an Observable.
-     */
-    @Experimental
-    public Observable<List<T>> list() {
-        return wrap(new Callable<List<T>>() {
-            @Override
-            public List<T> call() throws Exception {
-                return query.forCurrentThread().list();
-            }
-        });
-    }
-
-    /**
-     * Rx version of {@link Query#unique()} returning an Observable.
-     */
-    @Experimental
-    public Observable<T> unique() {
-        return wrap(new Callable<T>() {
-            @Override
-            public T call() throws Exception {
-                return query.forCurrentThread().unique();
-            }
-        });
-    }
-
-    /**
-     * Emits the resulting entities one by one, producing them on the fly ("streaming" entities).
-     * Unlike {@link #list()}, it does not wait for the query to gather all results. Thus, the first entities are
-     * immediately available as soon the underlying database cursor has data. This approach may be more memory
-     * efficient for large number of entities (or large entities) at the cost of additional overhead caused by a
-     * per-entity delivery through Rx.
-     */
-    public Observable<T> oneByOne() {
-        Observable<T> observable = Observable.create(new OnSubscribe<T>() {
-            @Override
-            public void call(Subscriber<? super T> subscriber) {
-                try {
-                    LazyList<T> lazyList = query.forCurrentThread().listLazyUncached();
-                    try {
-                        for (T entity : lazyList) {
-                            if (subscriber.isUnsubscribed()) {
-                                break;
-                            }
-                            subscriber.onNext(entity);
-                        }
-                    } finally {
-                        lazyList.close();
-                    }
-                    if (!subscriber.isUnsubscribed()) {
-                        subscriber.onCompleted();
-                    }
-                } catch (Throwable e) {
-                    Exceptions.throwIfFatal(e);
-                    subscriber.onError(e);
-                }
-            }
-        });
-        return wrap(observable);
-    }
-
-//    @Experimental
-//    public Query<T> getQuery() {
-//        return query;
-//    }
-}
diff --git a/DaoCore/src/main/java/org/greenrobot/greendao/rx/RxTransaction.java b/DaoCore/src/main/java/org/greenrobot/greendao/rx/RxTransaction.java
deleted file mode 100644
index 8ef01d33..00000000
--- a/DaoCore/src/main/java/org/greenrobot/greendao/rx/RxTransaction.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright (C) 2011-2016 Markus Junginger, greenrobot (http://greenrobot.org)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.greenrobot.greendao.rx;
-
-import org.greenrobot.greendao.AbstractDaoSession;
-import org.greenrobot.greendao.annotation.apihint.Experimental;
-
-import java.util.concurrent.Callable;
-
-import rx.Observable;
-import rx.Scheduler;
-
-/**
- * Allows to do transactions using Rx Observable.
- */
-@Experimental
-public class RxTransaction extends RxBase {
-    private final AbstractDaoSession daoSession;
-
-    public RxTransaction(AbstractDaoSession daoSession) {
-        this.daoSession = daoSession;
-    }
-
-    public RxTransaction(AbstractDaoSession daoSession, Scheduler scheduler) {
-        super(scheduler);
-        this.daoSession = daoSession;
-    }
-
-    /**
-     * Rx version of {@link AbstractDaoSession#runInTx(Runnable)} returning an Observable.
-     */
-    @Experimental
-    public Observable<Void> run(final Runnable runnable) {
-        return wrap(new Callable<Void>() {
-            @Override
-            public Void call() throws Exception {
-                daoSession.runInTx(runnable);
-                return null;
-            }
-        });
-    }
-
-    /**
-     * Rx version of {@link AbstractDaoSession#callInTx(Callable)} returning an Observable.
-     */
-    @Experimental
-    public <T> Observable<T> call(final Callable<T> callable) {
-        return wrap(new Callable<T>() {
-            @Override
-            public T call() throws Exception {
-                return daoSession.callInTx(callable);
-            }
-        });
-    }
-
-    // Note: wrapping callInTxNoException does not make sense, because the Exception is handled by Rx anyway.
-
-
-    @Experimental
-    public AbstractDaoSession getDaoSession() {
-        return daoSession;
-    }
-}
diff --git a/DaoCore/src/main/java/org/greenrobot/greendao/rx/RxUtils.java b/DaoCore/src/main/java/org/greenrobot/greendao/rx/RxUtils.java
deleted file mode 100644
index 0754754f..00000000
--- a/DaoCore/src/main/java/org/greenrobot/greendao/rx/RxUtils.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2011-2016 Markus Junginger, greenrobot (http://greenrobot.org)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.greenrobot.greendao.rx;
-
-import org.greenrobot.greendao.annotation.apihint.Internal;
-
-import java.util.concurrent.Callable;
-
-import rx.Observable;
-import rx.functions.Func0;
-
-@Internal
-class RxUtils {
-    /** As of RxJava 1.1.7, Observable.fromCallable is still @Beta, so just in case... */
-    @Internal
-    static <T> Observable<T> fromCallable(final Callable<T> callable) {
-        return Observable.defer(new Func0<Observable<T>>() {
-
-            @Override
-            public Observable<T> call() {
-                T result;
-                try {
-                    result = callable.call();
-                } catch (Exception e) {
-                    return Observable.error(e);
-                }
-                return Observable.just(result);
-            }
-        });
-    }
-}
diff --git a/build.gradle b/build.gradle
index 43bbcf71..53842003 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,5 +1,5 @@
 // Sub projects may reference rootProject.version
-version = '3.2.3-SNAPSHOT'
+version = '3.2.3-Rxjava2-SNAPSHOT'
 
 task wrapper(type: Wrapper) {
     gradleVersion = '3.5'
@@ -15,9 +15,11 @@ ext {
 
     // common dependencies for Android projects (not to be used in example projects for better copy and paste)
     dep = [
-            androidPlugin: 'com.android.tools.build:gradle:2.3.1',
+            androidPlugin : 'com.android.tools.build:gradle:2.3.1',
             greendaoPlugin: 'org.greenrobot:greendao-gradle-plugin:3.2.2'
     ]
+
+    localMaven = 'D:/AndroidStudio/LocalMaven'
 }
 
 if (JavaVersion.current().isJava8Compatible()) {
@@ -59,6 +61,9 @@ subprojects {
         uploadArchives {
             repositories {
                 mavenDeployer {
+                    //电脑本地Maven仓库地址
+//                    repository(url: uri(rootProject.ext.localMaven))
+
                     def isSnapshot = version.endsWith('-SNAPSHOT')
                     def sonatypeRepositoryUrl = isSnapshot ?
                             "https://oss.sonatype.org/content/repositories/snapshots/"
