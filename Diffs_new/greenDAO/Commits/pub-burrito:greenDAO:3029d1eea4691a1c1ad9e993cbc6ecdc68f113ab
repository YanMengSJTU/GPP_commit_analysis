diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDao.java b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
index 5a605524..10276387 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDao.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
@@ -266,9 +266,8 @@ public void insertOrReplaceInTx(T... entities) throws SQLException {
         insertOrReplaceInTx(Arrays.asList(entities), isEntityUpdateable());
     }
 
-//	TODO transaction
-    private void executeInsertInTx(PreparedStatement stmt, Iterable<T> entities, boolean setPrimaryKey) {
-//    	connection.beginTransaction();
+    private void executeInsertInTx(PreparedStatement stmt, Iterable<T> entities, boolean setPrimaryKey) throws SQLException {
+    	connection.setAutoCommit( false );
         try {
             synchronized (stmt) {
                 if (identityScope != null) {
@@ -287,17 +286,17 @@ private void executeInsertInTx(PreparedStatement stmt, Iterable<T> entities, boo
                 }
 				catch ( SQLException e )
 				{
+					connection.rollback();
 					e.printStackTrace();
-					// rollback?!
 				} finally {
                     if (identityScope != null) {
                         identityScope.unlock();
                     }
                 }
             }
-//            db.setTransactionSuccessful();
+            connection.commit();
         } finally {
-//            db.endTransaction();
+        	connection.setAutoCommit( true );
         }
     }
 
@@ -320,27 +319,19 @@ public long insert(T entity) throws SQLException {
      */
     public long insertWithoutSettingPk(T entity) throws SQLException {
     	PreparedStatement stmt = statements.getInsertStatement();
-        long rowId;
-        // FIXME not sure what to do here...
-//        if (db.isDbLockedByCurrentThread()) {
-        if (!connection.isClosed()) {
+        long rowId = 0;
+        // Do TX to acquire a connection before locking the stmt to avoid deadlocks
+        connection.setAutoCommit( false );
+        try {
             synchronized (stmt) {
                 bindValues(stmt, entity);
                 rowId = stmt.executeUpdate();
+                connection.commit();
             }
-        } else {
-            // Do TX to acquire a connection before locking the stmt to avoid deadlocks
-// TODO transaction        	
-//            db.beginTransaction();
-            try {
-                synchronized (stmt) {
-                    bindValues(stmt, entity);
-                    rowId = stmt.executeUpdate();
-                }
-//                db.setTransactionSuccessful();
-            } finally {
-//                db.endTransaction();
-            }
+        } catch (SQLException e) {
+        	connection.rollback();
+        } finally {
+        	connection.setAutoCommit( true );
         }
         return rowId;
     }
@@ -356,27 +347,20 @@ public long insertOrReplace(T entity) throws SQLException {
     }
 
     private long executeInsert(T entity, PreparedStatement stmt) throws SQLException {
-        long rowId;
-        // FIXME not sure what to do here...
-//        if (connection.isDbLockedByCurrentThread()) {
-        if (!connection.isClosed()) {
+        long rowId = 0;
+        // Do TX to acquire a connection before locking the stmt to avoid deadlocks
+        connection.setAutoCommit( false );
+        try {
             synchronized (stmt) {
                 bindValues(stmt, entity);
                 rowId = stmt.executeUpdate();
             }
-        } else {
-            // Do TX to acquire a connection before locking the stmt to avoid deadlocks
-// TODO transaction
-//            db.beginTransaction();
-            try {
-                synchronized (stmt) {
-                    bindValues(stmt, entity);
-                    rowId = stmt.executeUpdate();
-                }
-//                db.setTransactionSuccessful();
-            } finally {
-//                db.endTransaction();
-            }
+            connection.commit();
+        } catch (SQLException e) {
+        	connection.rollback();
+        	e.printStackTrace();
+        } finally {
+        	connection.setAutoCommit( true );
         }
         updateKeyAfterInsertAndAttach(entity, rowId, true);
         return rowId;
@@ -532,24 +516,18 @@ public void delete(T entity) throws SQLException {
     public void deleteByKey(K key) throws SQLException {
         assertSinglePk();
         PreparedStatement stmt = statements.getDeleteStatement();
-        // FIXME not sure what to do here...
-//        if (db.isDbLockedByCurrentThread()) {
-        if (!connection.isClosed()) {
+        // Do TX to acquire a connection before locking the stmt to avoid deadlocks
+        connection.setAutoCommit( false );
+        try {
             synchronized (stmt) {
                 deleteByKeyInsideSynchronized(key, stmt);
             }
-        } else {
-            // Do TX to acquire a connection before locking the stmt to avoid deadlocks
-// TODO transaction
-//            db.beginTransaction();
-            try {
-                synchronized (stmt) {
-                    deleteByKeyInsideSynchronized(key, stmt);
-                }
-//                db.setTransactionSuccessful();
-            } finally {
-//                db.endTransaction();
-            }
+            connection.commit();
+        } catch (SQLException e) {
+        	connection.rollback();
+        	e.printStackTrace();
+        } finally {
+        	connection.setAutoCommit( true );
         }
         if (identityScope != null) {
             identityScope.remove(key);
@@ -571,8 +549,7 @@ private void deleteInTxInternal(Iterable<T> entities, Iterable<K> keys) throws S
         assertSinglePk();
         PreparedStatement stmt = statements.getDeleteStatement();
         List<K> keysToRemoveFromIdentityScope = null;
-// TODO transaction
-//        db.beginTransaction();
+        connection.setAutoCommit( false );
         try {
             synchronized (stmt) {
                 if (identityScope != null) {
@@ -603,12 +580,15 @@ private void deleteInTxInternal(Iterable<T> entities, Iterable<K> keys) throws S
                     }
                 }
             }
-//            db.setTransactionSuccessful();
+            connection.commit();
             if (keysToRemoveFromIdentityScope != null && identityScope != null) {
                 identityScope.remove(keysToRemoveFromIdentityScope);
             }
+        } catch (SQLException e) {
+        	connection.rollback();
+        	e.printStackTrace();
         } finally {
-//            db.endTransaction();
+        	connection.setAutoCommit( true );
         }
     }
 
@@ -683,24 +663,18 @@ public void refresh(T entity) throws SQLException {
     public void update(T entity) throws SQLException {
         assertSinglePk();
         PreparedStatement stmt = statements.getUpdateStatement();
-// FIXME not sure what to do here...        
-//        if (db.isDbLockedByCurrentThread()) {
-        if (!connection.isClosed()) {
+        // Do TX to acquire a connection before locking the stmt to avoid deadlocks
+        connection.setAutoCommit( false );
+        try {
             synchronized (stmt) {
                 updateInsideSynchronized(entity, stmt, true);
             }
-        } else {
-            // Do TX to acquire a connection before locking the stmt to avoid deadlocks
-// TODO transaction        	
-//            db.beginTransaction();
-            try {
-                synchronized (stmt) {
-                    updateInsideSynchronized(entity, stmt, true);
-                }
-//                db.setTransactionSuccessful();
-            } finally {
-//                db.endTransaction();
-            }
+            connection.commit();
+        } catch (SQLException e){
+        	connection.rollback();
+        	e.printStackTrace();
+        } finally {
+        	connection.setAutoCommit( true );
         }
     }
 
@@ -762,8 +736,7 @@ protected void attachEntity(T entity) {
      */
     public void updateInTx(Iterable<T> entities) throws SQLException {
         PreparedStatement stmt = statements.getUpdateStatement();
-// TODO transaction        
-//        db.beginTransaction();
+    	connection.setAutoCommit( false );
         try {
             synchronized (stmt) {
                 if (identityScope != null) {
@@ -779,9 +752,12 @@ public void updateInTx(Iterable<T> entities) throws SQLException {
                     }
                 }
             }
-//            db.setTransactionSuccessful();
+            connection.commit();
+        } catch(SQLException e) {
+        	connection.rollback();
+        	e.printStackTrace();
         } finally {
-//            db.endTransaction();
+        	connection.setAutoCommit( true );
         }
     }
 
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java b/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
index 19f19421..186d121e 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
@@ -146,15 +146,18 @@ public AbstractDaoSession(Connection connection) {
 
     /**
      * Run the given Runnable inside a database transaction. If you except a result, consider callInTx.
+     * @throws SQLException 
      */
-    public void runInTx(Runnable runnable) {
-    	// TODO transaction
-//        connection.beginTransaction();
+    public void runInTx(Runnable runnable) throws SQLException {
+    	connection.setAutoCommit( false );
         try {
             runnable.run();
-//            connection.setTransactionSuccessful();
+            connection.commit();
+        } catch(SQLException e) {
+        	connection.rollback();
+        	e.printStackTrace();
         } finally {
-//            connection.endTransaction();
+        	connection.setAutoCommit( true );
         }
     }
 
@@ -163,15 +166,18 @@ public void runInTx(Runnable runnable) {
      * except a result, consider runInTx.
      */
     public <V> V callInTx(Callable<V> callable) throws Exception {
-// TODO transaction
-//    	connection.beginTransaction();
+    	connection.setAutoCommit( false );
+    	V result = null;
         try {
-            V result = callable.call();
-//            connection.setTransactionSuccessful();
-            return result;
+            result = callable.call();
+            connection.commit();
+        } catch(SQLException e) {
+        	connection.rollback();
+        	e.printStackTrace();
         } finally {
-//            connection.endTransaction();
+        	connection.setAutoCommit( true );
         }
+        return result;
     }
 
     /**
@@ -179,20 +185,22 @@ public void runInTx(Runnable runnable) {
      * DaoException).
      */
     public <V> V callInTxNoException(Callable<V> callable) {
-// TODO transaction
-//    	connection.beginTransaction();
-        try {
-            V result;
-            try {
-                result = callable.call();
-            } catch (Exception e) {
-                throw new DaoException("Callable failed", e);
-            }
-//            connection.setTransactionSuccessful();
-            return result;
-        } finally {
-//            connection.endTransaction();
-        }
+    	V result = null;
+    	try {
+	    	connection.setAutoCommit( false );
+	        try {
+	            result = callable.call();
+	            connection.commit();
+	        } catch (Exception e) {
+	        	connection.rollback();
+	            throw new DaoException("Callable failed", e);
+	        } finally {
+	        	connection.setAutoCommit( true );
+	        }
+    	} catch (SQLException e){
+    		throw new DaoException("Callable failed", e);
+    	}
+        return result;
     }
 
     /** Gets the SQLiteDatabase for custom database access. Not needed for greenDAO entities. */
diff --git a/DaoCore/src/de/greenrobot/dao/DbUtils.java b/DaoCore/src/de/greenrobot/dao/DbUtils.java
index f13a44ba..24020feb 100644
--- a/DaoCore/src/de/greenrobot/dao/DbUtils.java
+++ b/DaoCore/src/de/greenrobot/dao/DbUtils.java
@@ -70,15 +70,18 @@ public static int executeSqlScript(Context context, Connection connection, Strin
     }
 
     public static int executeSqlStatementsInTx(Connection connection, String[] statements) throws SQLException {
-// TODO transaction
-//    	connection.beginTransaction();
+    	int count = 0;
+    	connection.setAutoCommit( false );
         try {
-            int count = executeSqlStatements(connection, statements);
-//            connection.setTransactionSuccessful();
-            return count;
+            count = executeSqlStatements(connection, statements);
+            connection.commit();
+        } catch(SQLException e) {
+        	connection.rollback();
+        	e.printStackTrace();
         } finally {
-//            connection.endTransaction();
+        	connection.setAutoCommit( true );
         }
+        return count;
     }
 
     public static int executeSqlStatements(Connection connection, String[] statements) throws SQLException {
diff --git a/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java b/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java
index e0fbc794..bf0b4572 100644
--- a/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java
+++ b/DaoCore/src/de/greenrobot/dao/async/AsyncOperationExecutor.java
@@ -15,6 +15,8 @@
  */
 package de.greenrobot.dao.async;
 
+import java.sql.Connection;
+import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.Callable;
@@ -153,7 +155,14 @@ public void run() {
                         AsyncOperation operation2 = queue.poll(waitForMergeMillis, TimeUnit.MILLISECONDS);
                         if (operation2 != null) {
                             if (operation.isMergeableWith(operation2)) {
-                                mergeTxAndExecute(operation, operation2);
+                                try
+								{
+									mergeTxAndExecute(operation, operation2);
+								}
+								catch ( SQLException e )
+								{
+									e.printStackTrace();
+								}
                             } else {
                                 // Cannot merge, execute both
                                 executeOperationAndPostCompleted(operation);
@@ -172,14 +181,13 @@ public void run() {
         }
     }
 
-    private void mergeTxAndExecute(AsyncOperation operation1, AsyncOperation operation2) {
+    private void mergeTxAndExecute(AsyncOperation operation1, AsyncOperation operation2) throws SQLException {
         ArrayList<AsyncOperation> mergedOps = new ArrayList<AsyncOperation>();
         mergedOps.add(operation1);
         mergedOps.add(operation2);
 
-// TODO transaction
-//        Connection connection = operation1.getConnection();
-//        connection.beginTransaction();
+        Connection connection = operation1.getConnection();
+        connection.setAutoCommit( false );
         boolean failed = false;
         try {
             for (int i = 0; i < mergedOps.size(); i++) {
@@ -201,12 +209,15 @@ private void mergeTxAndExecute(AsyncOperation operation1, AsyncOperation operati
                         mergedOps.add(removedOp);
                     } else {
                         // No more ops in the queue to merge, finish it
-//                        connection.setTransactionSuccessful();
+                    	connection.commit();
                     }
                 }
             }
+        } catch(SQLException e) {
+        	connection.rollback();
+        	e.printStackTrace();
         } finally {
-//            connection.endTransaction();
+            connection.setAutoCommit( true );
         }
         if (failed) {
             DaoLog.i("Revered merged transaction because one of the operations failed. Executing operations one by one instead...");
@@ -331,28 +342,32 @@ private void executeOperation(AsyncOperation operation) {
         // Do not set it to completed here because it might be a merged TX
     }
 
-    private void executeTransactionRunnable(AsyncOperation operation) {
-// TODO transaction
-//    	Connection connection = operation.getConnection();
-//      connection.beginTransaction();
+    private void executeTransactionRunnable(AsyncOperation operation) throws SQLException {
+    	Connection connection = operation.getConnection();
+    	connection.setAutoCommit( false );
         try {
             ((Runnable) operation.parameter).run();
-//            connection.setTransactionSuccessful();
+            connection.commit();
+        } catch(SQLException e) {
+        	connection.rollback();
+        	e.printStackTrace();
         } finally {
-//            connection.endTransaction();
+        	connection.setAutoCommit( true );
         }
     }
 
     @SuppressWarnings("unchecked")
     private void executeTransactionCallable(AsyncOperation operation) throws Exception {
-// TODO transaction
-//        Connection connection = operation.getConnection();
-//        connection.beginTransaction();
+        Connection connection = operation.getConnection();
+        connection.setAutoCommit( false );
         try {
             operation.result = ((Callable<Object>) operation.parameter).call();
-//            connection.setTransactionSuccessful();
+            connection.commit();
+        } catch(SQLException e) {
+        	connection.rollback();
+        	e.printStackTrace();
         } finally {
-//            connection.endTransaction();
+        	connection.setAutoCommit( true );
         }
     }
 
diff --git a/DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java b/DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java
index 3dec1363..ccd5f284 100644
--- a/DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java
+++ b/DaoCore/src/de/greenrobot/dao/query/DeleteQuery.java
@@ -68,31 +68,24 @@ private DeleteQuery(QueryData<T> queryData, AbstractDao<T, ?> dao, String sql, S
     public void executeDeleteWithoutDetachingEntities() throws SQLException {
         checkThread();
         Connection connection = dao.getConnection();
-// FIXME not sure what to do here...
-//        if (connection.isDbLockedByCurrentThread()) {
-        if (!connection.isClosed()) {
+
+        // Do TX to acquire a connection before locking this to avoid deadlocks
+        // Locking order as described in AbstractDao
+        connection.setAutoCommit( false );
+        try {
         	PreparedStatement statement = connection.prepareStatement( sql );
         	for ( int i = 0; i < parameters.length; i++ )
 			{
-				statement.setString( i, parameters[i] );
+        		int index = i+1;
+				statement.setString( index, parameters[i] );
 			}
             statement.executeUpdate();
-        } else {
-            // Do TX to acquire a connection before locking this to avoid deadlocks
-            // Locking order as described in AbstractDao
-// TODO transaction (it might need to open a new connection too)
-//        	connection.beginTransaction();
-            try {
-            	PreparedStatement statement = connection.prepareStatement( sql );
-            	for ( int i = 0; i < parameters.length; i++ )
-    			{
-    				statement.setString( i, parameters[i] );
-    			}
-                statement.executeUpdate();
-//                connection.setTransactionSuccessful();
-            } finally {
-//                connection.endTransaction();
-            }
+            connection.commit();
+        } catch(SQLException e) {
+        	connection.rollback();
+        	e.printStackTrace();
+        } finally {
+        	connection.setAutoCommit( true );
         }
     }
 
diff --git a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoSessionTest.java b/DaoCore/src/de/greenrobot/dao/test/AbstractDaoSessionTest.java
index 2e7a55f4..c093e648 100644
--- a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoSessionTest.java
+++ b/DaoCore/src/de/greenrobot/dao/test/AbstractDaoSessionTest.java
@@ -20,7 +20,6 @@
 import java.lang.reflect.Method;
 import java.sql.Connection;
 
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDaoMaster;
 import de.greenrobot.dao.AbstractDaoSession;
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityContentProvider.java b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityContentProvider.java
index 98f3be7f..cacfee24 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityContentProvider.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityContentProvider.java
@@ -5,7 +5,6 @@
 import android.content.ContentProvider;
 import android.content.ContentResolver;
 import android.content.ContentValues;
-import android.content.Context;
 import android.content.UriMatcher;
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
@@ -21,7 +20,6 @@
         android:authorities="de.greenrobot.daotest" />
 */
 
-////TODO check if this class is really necessary
 public class SimpleEntityContentProvider extends ContentProvider {
 
     public static final String AUTHORITY = "de.greenrobot.daotest";
diff --git a/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentTest.java b/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentTest.java
index bb2e13e5..004a3d3d 100644
--- a/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentTest.java
@@ -91,19 +91,26 @@ public void run() {
         Runnable runnable3 = new Runnable() {
             @Override
             public void run() {
-                daoSession.runInTx(new Runnable() {
-                    @Override
-                    public void run() {
-                        try
-						{
-							dao.insert(createEntity(null));
-						}
-						catch ( SQLException e )
-						{
-							e.printStackTrace();
-						}
-                    }
-                });
+                try
+				{
+					daoSession.runInTx(new Runnable() {
+					    @Override
+					    public void run() {
+					        try
+							{
+								dao.insert(createEntity(null));
+							}
+							catch ( SQLException e )
+							{
+								e.printStackTrace();
+							}
+					    }
+					});
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
             }
         };
         Runnable runnable4 = new Runnable() {
@@ -184,19 +191,26 @@ public void run() {
         Runnable runnable3 = new Runnable() {
             @Override
             public void run() {
-                daoSession.runInTx(new Runnable() {
-                    @Override
-                    public void run() {
-                        try
-						{
-							dao.update(entity);
-						}
-						catch ( SQLException e )
-						{
-							e.printStackTrace();
-						}
-                    }
-                });
+                try
+				{
+					daoSession.runInTx(new Runnable() {
+					    @Override
+					    public void run() {
+					        try
+							{
+								dao.update(entity);
+							}
+							catch ( SQLException e )
+							{
+								e.printStackTrace();
+							}
+					    }
+					});
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
             }
         };
         initThreads(runnable1, runnable2, runnable3);
@@ -250,19 +264,26 @@ public void run() {
         Runnable runnable3 = new Runnable() {
             @Override
             public void run() {
-                daoSession.runInTx(new Runnable() {
-                    @Override
-                    public void run() {
-                        try
-						{
-							dao.delete(entity);
-						}
-						catch ( SQLException e )
-						{
-							e.printStackTrace();
-						}
-                    }
-                });
+                try
+				{
+					daoSession.runInTx(new Runnable() {
+					    @Override
+					    public void run() {
+					        try
+							{
+								dao.delete(entity);
+							}
+							catch ( SQLException e )
+							{
+								e.printStackTrace();
+							}
+					    }
+					});
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
             }
         };
         initThreads(runnable1, runnable2, runnable3);
@@ -505,7 +526,7 @@ protected PreparedStatement initialValue() {
         assertTrue(time < 10);
     }
 
-    protected void doTx(final Runnable runnableInsideTx) {
+    protected void doTx(final Runnable runnableInsideTx) throws SQLException {
         daoSession.runInTx(new Runnable() {
             @Override
             public void run() {
