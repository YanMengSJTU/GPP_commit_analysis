diff --git a/DaoCore/.classpath b/DaoCore/.classpath
index 8981741b..26bdfa6e 100644
--- a/DaoCore/.classpath
+++ b/DaoCore/.classpath
@@ -4,5 +4,6 @@
 	<classpathentry kind="src" path="gen"/>
 	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
 	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
 	<classpathentry kind="output" path="bin/classes"/>
 </classpath>
diff --git a/DaoExample/.classpath b/DaoExample/.classpath
index 61534931..6710a6f8 100644
--- a/DaoExample/.classpath
+++ b/DaoExample/.classpath
@@ -1,10 +1,11 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="src" path="src-gen"/>
-	<classpathentry kind="src" path="src-test"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="src" path="src-gen"/>
+	<classpathentry kind="src" path="src-test"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/DaoGenerator/.classpath b/DaoGenerator/.classpath
index 0012de0c..de62e108 100644
--- a/DaoGenerator/.classpath
+++ b/DaoGenerator/.classpath
@@ -1,13 +1,14 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="src-template"/>
-	<classpathentry kind="src" path="src-test"/>
-	<classpathentry kind="con" path="GROOVY_DSL_SUPPORT"/>
-	<classpathentry kind="con" path="GROOVY_SUPPORT"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
-	<classpathentry exported="true" kind="con" path="org.springsource.ide.eclipse.gradle.classpathcontainer"/>
-	<classpathentry kind="con" path="org.springsource.ide.eclipse.gradle.dsld.classpathcontainer"/>
-	<classpathentry kind="output" path="bin"/>
-</classpath>
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="src-template"/>
+	<classpathentry kind="src" path="src-test"/>
+	<classpathentry kind="src" path="src-generator-testentities"/>
+	<classpathentry kind="con" path="GROOVY_DSL_SUPPORT"/>
+	<classpathentry kind="con" path="GROOVY_SUPPORT"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
+	<classpathentry exported="true" kind="con" path="org.springsource.ide.eclipse.gradle.classpathcontainer"/>
+	<classpathentry kind="con" path="org.springsource.ide.eclipse.gradle.dsld.classpathcontainer"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/DaoGenerator/build.gradle b/DaoGenerator/build.gradle
index 5cf871c0..cf2f4a29 100644
--- a/DaoGenerator/build.gradle
+++ b/DaoGenerator/build.gradle
@@ -3,7 +3,7 @@ apply plugin: 'maven'
 apply plugin: 'signing'
 
 group = 'de.greenrobot'
-version = '1.3.0'
+version = '1.3.0.keineantwort.github1-SNAPSHOT'
 sourceCompatibility = 1.6
 
 def isSnapshot = version.endsWith('-SNAPSHOT')
diff --git a/DaoGenerator/src-generator-testentities/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java b/DaoGenerator/src-generator-testentities/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
index ef92bf31..4e55a6ea 100644
--- a/DaoGenerator/src-generator-testentities/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
+++ b/DaoGenerator/src-generator-testentities/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
@@ -30,242 +30,249 @@
  */
 public class TestDaoGenerator {
 
-    public static void main(String[] args) throws Exception {
-        TestDaoGenerator testDaoGenerator = new TestDaoGenerator();
-        testDaoGenerator.generate();
-    }
-
-    private Schema schema;
-    private Entity testEntity;
-    private Schema schema2;
-
-    public TestDaoGenerator() {
-        schema = new Schema(1, "de.greenrobot.daotest");
-        schema.setDefaultJavaPackageTest("de.greenrobot.daotest.entity");
-
-        createSimple();
-        createSimpleNotNull();
-        testEntity = createTest();
-        createRelation();
-        createDate();
-        createSpecialNames();
-        createAbcdef();
-        createToMany();
-        createTreeEntity();
-        createActive();
-        createExtendsImplements();
-        createStringKeyValue();
-        createAutoincrement();
-        createSqliteMaster();
-
-        createSchema2();
-    }
-
-    public void generate() throws Exception {
-        DaoGenerator daoGenerator = new DaoGenerator();
-        daoGenerator.generateAll(schema, "../DaoTest/src-gen", "../DaoTest/src");
-        daoGenerator.generateAll(schema2, "../DaoTest/src-gen", "../DaoTest/src");
-    }
-
-    protected void createSimple() {
-        Entity simple = schema.addEntity("SimpleEntity");
-        simple.addIdProperty();
-        simple.addBooleanProperty("simpleBoolean");
-        simple.addByteProperty("simpleByte");
-        simple.addShortProperty("simpleShort");
-        simple.addIntProperty("simpleInt");
-        simple.addLongProperty("simpleLong");
-        simple.addFloatProperty("simpleFloat");
-        simple.addDoubleProperty("simpleDouble");
-        simple.addStringProperty("simpleString");
-        simple.addByteArrayProperty("simpleByteArray");
-    }
-
-    protected void createSimpleNotNull() {
-        Entity notNull = schema.addEntity("SimpleEntityNotNull");
-        notNull.addIdProperty().notNull();
-        notNull.addBooleanProperty("simpleBoolean").notNull();
-        notNull.addByteProperty("simpleByte").notNull();
-        notNull.addShortProperty("simpleShort").notNull();
-        notNull.addIntProperty("simpleInt").notNull();
-        notNull.addLongProperty("simpleLong").notNull();
-        notNull.addFloatProperty("simpleFloat").notNull();
-        notNull.addDoubleProperty("simpleDouble").notNull();
-        notNull.addStringProperty("simpleString").notNull();
-        notNull.addByteArrayProperty("simpleByteArray").notNull();
-    }
-
-    protected Entity createTest() {
-        Entity testEntity = schema.addEntity("TestEntity");
-        testEntity.addIdProperty();
-        testEntity.addIntProperty("simpleInt").notNull();
-        testEntity.addIntProperty("simpleInteger");
-        testEntity.addStringProperty("simpleStringNotNull").notNull();
-        testEntity.addStringProperty("simpleString");
-        testEntity.addStringProperty("indexedString").index();
-        testEntity.addStringProperty("indexedStringAscUnique").indexAsc(null, true);
-        testEntity.addDateProperty("simpleDate");
-        testEntity.addBooleanProperty("simpleBoolean");
-        return testEntity;
-    }
-
-    protected void createRelation() {
-        Entity relationEntity = schema.addEntity("RelationEntity");
-        relationEntity.addIdProperty();
-        Property parentIdProperty = relationEntity.addLongProperty("parentId").getProperty();
-        relationEntity.addToOne(relationEntity, parentIdProperty).setName("parent");
-        Property testIdProperty = relationEntity.addLongProperty("testId").getProperty();
-        relationEntity.addToOne(testEntity, testIdProperty);
-        Property testIdNotNullProperty = relationEntity.addLongProperty("testIdNotNull").notNull().getProperty();
-        relationEntity.addToOne(testEntity, testIdNotNullProperty).setName("testNotNull");
-        relationEntity.addStringProperty("simpleString");
-        relationEntity.addToOneWithoutProperty("testWithoutProperty", testEntity, "WITHOUT_PROPERTY_TEST_ID");
-    }
-
-    protected void createToMany() {
-        Entity toManyTargetEntity = schema.addEntity("ToManyTargetEntity");
-        Property toManyIdProperty = toManyTargetEntity.addLongProperty("toManyId").getProperty();
-        Property toManyIdDescProperty = toManyTargetEntity.addLongProperty("toManyIdDesc").getProperty();
-        Property targetIdProperty = toManyTargetEntity.addIdProperty().getProperty();
-        Property targetJoinProperty = toManyTargetEntity.addStringProperty("targetJoinProperty").getProperty();
-
-        Entity toManyEntity = schema.addEntity("ToManyEntity");
-        Property sourceIdProperty = toManyEntity.addIdProperty().getProperty();
-        Property sourceJoinProperty = toManyEntity.addStringProperty("sourceJoinProperty").getProperty();
-
-        ToMany toMany = toManyEntity.addToMany(toManyTargetEntity, toManyIdProperty);
-        toMany.orderAsc(targetIdProperty);
-
-        ToMany toManyDesc = toManyEntity.addToMany(toManyTargetEntity, toManyIdDescProperty);
-        toManyDesc.setName("toManyDescList");
-        toManyDesc.orderDesc(targetIdProperty);
-
-        ToMany toManyByJoinProperty = toManyEntity
-                .addToMany(sourceJoinProperty, toManyTargetEntity, targetJoinProperty);
-        toManyByJoinProperty.setName("toManyByJoinProperty");
-        toManyByJoinProperty.orderAsc(targetIdProperty);
-
-        Property[] sourceProperties = { sourceIdProperty, sourceJoinProperty };
-        Property[] targetProperties = { toManyIdProperty, targetJoinProperty };
-        ToMany toManyJoinTwo = toManyEntity.addToMany(sourceProperties, toManyTargetEntity, targetProperties);
-        toManyJoinTwo.setName("toManyJoinTwo");
-        toManyJoinTwo.orderDesc(targetJoinProperty);
-        toManyJoinTwo.orderDesc(targetIdProperty);
-    }
-
-    protected void createTreeEntity() {
-        Entity treeEntity = schema.addEntity("TreeEntity");
-        treeEntity.addIdProperty();
-        Property parentIdProperty = treeEntity.addLongProperty("parentId").getProperty();
-        treeEntity.addToOne(treeEntity, parentIdProperty).setName("parent");
-        treeEntity.addToMany(treeEntity, parentIdProperty).setName("children");
-    }
-
-    protected void createDate() {
-        Entity dateEntity = schema.addEntity("DateEntity");
-        dateEntity.addIdProperty();
-        dateEntity.addDateProperty("date");
-        dateEntity.addDateProperty("dateNotNull").notNull();
-    }
-
-    protected void createSpecialNames() {
-        Entity specialNamesEntity = schema.addEntity("SpecialNamesEntity");
-        specialNamesEntity.addIdProperty();
-        specialNamesEntity.addStringProperty("count");
-        specialNamesEntity.addStringProperty("select");
-        specialNamesEntity.addStringProperty("sum");
-        specialNamesEntity.addStringProperty("avg");
-        specialNamesEntity.addStringProperty("join");
-        specialNamesEntity.addStringProperty("distinct");
-        specialNamesEntity.addStringProperty("on");
-        specialNamesEntity.addStringProperty("index");
-        specialNamesEntity.addIntProperty("order");
-    }
-
-    private void createAbcdef() {
-        Entity entity = schema.addEntity("AbcdefEntity");
-        entity.addIdProperty();
-        entity.addIntProperty("a");
-        entity.addIntProperty("b");
-        entity.addIntProperty("c");
-        entity.addIntProperty("d");
-        entity.addIntProperty("e");
-        entity.addIntProperty("f");
-        entity.addIntProperty("g");
-        entity.addIntProperty("h");
-        entity.addIntProperty("j");
-        entity.addIntProperty("i");
-        entity.addIntProperty("k");
-    }
-
-    protected void createActive() {
-        Entity activeEntity = schema.addEntity("AnActiveEntity");
-        activeEntity.addIdProperty();
-        activeEntity.addStringProperty("text");
-        activeEntity.setActive(true);
-    }
-
-    protected void createExtendsImplements() {
-        Entity entity = schema.addEntity("ExtendsImplementsEntity");
-        entity.addIdProperty();
-        entity.addStringProperty("text");
-        entity.setSuperclass("TestSuperclass");
-        entity.implementsInterface("TestInterface");
-        entity.implementsSerializable();
-    }
-
-    private void createSchema2() {
-        schema2 = new Schema(1, "de.greenrobot.daotest2");
-        schema2.setDefaultJavaPackageTest("de.greenrobot.daotest2.entity");
-        schema2.setDefaultJavaPackageDao("de.greenrobot.daotest2.dao");
-        schema2.enableKeepSectionsByDefault();
-
-        Entity keepEntity = schema2.addEntity("KeepEntity");
-        keepEntity.addIdProperty();
-
-        Entity toManyTarget2 = schema2.addEntity("ToManyTarget2");
-        toManyTarget2.addIdProperty();
-        Property toManyTarget2FkId = toManyTarget2.addLongProperty("fkId").getProperty();
-        toManyTarget2.setSkipGenerationTest(true);
-
-        Entity toOneTarget2 = schema2.addEntity("ToOneTarget2");
-        toOneTarget2.addIdProperty();
-        toOneTarget2.setJavaPackage("de.greenrobot.daotest2.to1_specialentity");
-        toOneTarget2.setJavaPackageDao("de.greenrobot.daotest2.to1_specialdao");
-        toOneTarget2.setJavaPackageTest("de.greenrobot.daotest2.to1_specialtest");
-        toOneTarget2.setSkipGenerationTest(true);
-
-        Entity relationSource2 = schema2.addEntity("RelationSource2");
-        relationSource2.addIdProperty();
-        relationSource2.addToMany(toManyTarget2, toManyTarget2FkId);
-        Property toOneId = relationSource2.addLongProperty("toOneId").getProperty();
-        relationSource2.addToOne(toOneTarget2, toOneId);
-        relationSource2.setJavaPackage("de.greenrobot.daotest2.specialentity");
-        relationSource2.setJavaPackageDao("de.greenrobot.daotest2.specialdao");
-        relationSource2.setJavaPackageTest("de.greenrobot.daotest2.specialtest");
-        relationSource2.setSkipGenerationTest(true);
-    }
-
-    protected void createStringKeyValue() {
-        Entity entity = schema.addEntity("StringKeyValueEntity");
-        entity.addStringProperty("key").primaryKey();
-        entity.addStringProperty("value");
-    }
-
-    protected void createAutoincrement() {
-        Entity entity = schema.addEntity("AutoincrementEntity");
-        entity.addIdProperty().autoincrement();
-    }
-
-    protected void createSqliteMaster() {
-        Entity entity = schema.addEntity("SqliteMaster");
-        entity.setSkipTableCreation(true);
-        entity.setHasKeepSections(true);
-        entity.addStringProperty("type");
-        entity.addStringProperty("name");
-        entity.addStringProperty("tableName").columnName("tbl_name");
-        entity.addLongProperty("rootpage");
-        entity.addStringProperty("sql");
-    }
+  public static void main(String[] args) throws Exception {
+    TestDaoGenerator testDaoGenerator = new TestDaoGenerator();
+    testDaoGenerator.generate();
+  }
+
+  private Schema schema;
+  private Entity testEntity;
+  private Schema schema2;
+
+  public TestDaoGenerator() {
+    this.schema = new Schema(1, "de.greenrobot.daotest");
+    this.schema.setDefaultJavaPackageTest("de.greenrobot.daotest.entity");
+
+    this.createSimple();
+    this.createSimpleNotNull();
+    this.testEntity = this.createTest();
+    this.createRelation();
+    this.createDate();
+    this.createSpecialNames();
+    this.createAbcdef();
+    this.createToMany();
+    this.createTreeEntity();
+    this.createActive();
+    this.createExtendsImplements();
+    this.createChildclass();
+    this.createStringKeyValue();
+    this.createAutoincrement();
+    this.createSqliteMaster();
+
+    this.createSchema2();
+  }
+
+  public void generate() throws Exception {
+    DaoGenerator daoGenerator = new DaoGenerator();
+    daoGenerator.generateAll(this.schema, "../DaoTest/src-gen", "../DaoTest/src");
+    daoGenerator.generateAll(this.schema2, "../DaoTest/src-gen", "../DaoTest/src");
+  }
+
+  protected void createSimple() {
+    Entity simple = this.schema.addEntity("SimpleEntity");
+    simple.addIdProperty();
+    simple.addBooleanProperty("simpleBoolean");
+    simple.addByteProperty("simpleByte");
+    simple.addShortProperty("simpleShort");
+    simple.addIntProperty("simpleInt");
+    simple.addLongProperty("simpleLong");
+    simple.addFloatProperty("simpleFloat");
+    simple.addDoubleProperty("simpleDouble");
+    simple.addStringProperty("simpleString");
+    simple.addByteArrayProperty("simpleByteArray");
+  }
+
+  protected void createSimpleNotNull() {
+    Entity notNull = this.schema.addEntity("SimpleEntityNotNull");
+    notNull.addIdProperty().notNull();
+    notNull.addBooleanProperty("simpleBoolean").notNull();
+    notNull.addByteProperty("simpleByte").notNull();
+    notNull.addShortProperty("simpleShort").notNull();
+    notNull.addIntProperty("simpleInt").notNull();
+    notNull.addLongProperty("simpleLong").notNull();
+    notNull.addFloatProperty("simpleFloat").notNull();
+    notNull.addDoubleProperty("simpleDouble").notNull();
+    notNull.addStringProperty("simpleString").notNull();
+    notNull.addByteArrayProperty("simpleByteArray").notNull();
+  }
+
+  protected Entity createTest() {
+    Entity testEntity = this.schema.addEntity("TestEntity");
+    testEntity.addIdProperty();
+    testEntity.addIntProperty("simpleInt").notNull();
+    testEntity.addIntProperty("simpleInteger");
+    testEntity.addStringProperty("simpleStringNotNull").notNull();
+    testEntity.addStringProperty("simpleString");
+    testEntity.addStringProperty("indexedString").index();
+    testEntity.addStringProperty("indexedStringAscUnique").indexAsc(null, true);
+    testEntity.addDateProperty("simpleDate");
+    testEntity.addBooleanProperty("simpleBoolean");
+    return testEntity;
+  }
+
+  protected void createRelation() {
+    Entity relationEntity = this.schema.addEntity("RelationEntity");
+    relationEntity.addIdProperty();
+    Property parentIdProperty = relationEntity.addLongProperty("parentId").getProperty();
+    relationEntity.addToOne(relationEntity, parentIdProperty).setName("parent");
+    Property testIdProperty = relationEntity.addLongProperty("testId").getProperty();
+    relationEntity.addToOne(this.testEntity, testIdProperty);
+    Property testIdNotNullProperty = relationEntity.addLongProperty("testIdNotNull").notNull().getProperty();
+    relationEntity.addToOne(this.testEntity, testIdNotNullProperty).setName("testNotNull");
+    relationEntity.addStringProperty("simpleString");
+    relationEntity.addToOneWithoutProperty("testWithoutProperty", this.testEntity, "WITHOUT_PROPERTY_TEST_ID");
+  }
+
+  protected void createToMany() {
+    Entity toManyTargetEntity = this.schema.addEntity("ToManyTargetEntity");
+    Property toManyIdProperty = toManyTargetEntity.addLongProperty("toManyId").getProperty();
+    Property toManyIdDescProperty = toManyTargetEntity.addLongProperty("toManyIdDesc").getProperty();
+    Property targetIdProperty = toManyTargetEntity.addIdProperty().getProperty();
+    Property targetJoinProperty = toManyTargetEntity.addStringProperty("targetJoinProperty").getProperty();
+
+    Entity toManyEntity = this.schema.addEntity("ToManyEntity");
+    Property sourceIdProperty = toManyEntity.addIdProperty().getProperty();
+    Property sourceJoinProperty = toManyEntity.addStringProperty("sourceJoinProperty").getProperty();
+
+    ToMany toMany = toManyEntity.addToMany(toManyTargetEntity, toManyIdProperty);
+    toMany.orderAsc(targetIdProperty);
+
+    ToMany toManyDesc = toManyEntity.addToMany(toManyTargetEntity, toManyIdDescProperty);
+    toManyDesc.setName("toManyDescList");
+    toManyDesc.orderDesc(targetIdProperty);
+
+    ToMany toManyByJoinProperty = toManyEntity.addToMany(sourceJoinProperty, toManyTargetEntity, targetJoinProperty);
+    toManyByJoinProperty.setName("toManyByJoinProperty");
+    toManyByJoinProperty.orderAsc(targetIdProperty);
+
+    Property[] sourceProperties = { sourceIdProperty, sourceJoinProperty };
+    Property[] targetProperties = { toManyIdProperty, targetJoinProperty };
+    ToMany toManyJoinTwo = toManyEntity.addToMany(sourceProperties, toManyTargetEntity, targetProperties);
+    toManyJoinTwo.setName("toManyJoinTwo");
+    toManyJoinTwo.orderDesc(targetJoinProperty);
+    toManyJoinTwo.orderDesc(targetIdProperty);
+  }
+
+  protected void createTreeEntity() {
+    Entity treeEntity = this.schema.addEntity("TreeEntity");
+    treeEntity.addIdProperty();
+    Property parentIdProperty = treeEntity.addLongProperty("parentId").getProperty();
+    treeEntity.addToOne(treeEntity, parentIdProperty).setName("parent");
+    treeEntity.addToMany(treeEntity, parentIdProperty).setName("children");
+  }
+
+  protected void createDate() {
+    Entity dateEntity = this.schema.addEntity("DateEntity");
+    dateEntity.addIdProperty();
+    dateEntity.addDateProperty("date");
+    dateEntity.addDateProperty("dateNotNull").notNull();
+  }
+
+  protected void createSpecialNames() {
+    Entity specialNamesEntity = this.schema.addEntity("SpecialNamesEntity");
+    specialNamesEntity.addIdProperty();
+    specialNamesEntity.addStringProperty("count");
+    specialNamesEntity.addStringProperty("select");
+    specialNamesEntity.addStringProperty("sum");
+    specialNamesEntity.addStringProperty("avg");
+    specialNamesEntity.addStringProperty("join");
+    specialNamesEntity.addStringProperty("distinct");
+    specialNamesEntity.addStringProperty("on");
+    specialNamesEntity.addStringProperty("index");
+    specialNamesEntity.addIntProperty("order");
+  }
+
+  private void createAbcdef() {
+    Entity entity = this.schema.addEntity("AbcdefEntity");
+    entity.addIdProperty();
+    entity.addIntProperty("a");
+    entity.addIntProperty("b");
+    entity.addIntProperty("c");
+    entity.addIntProperty("d");
+    entity.addIntProperty("e");
+    entity.addIntProperty("f");
+    entity.addIntProperty("g");
+    entity.addIntProperty("h");
+    entity.addIntProperty("j");
+    entity.addIntProperty("i");
+    entity.addIntProperty("k");
+  }
+
+  protected void createActive() {
+    Entity activeEntity = this.schema.addEntity("AnActiveEntity");
+    activeEntity.addIdProperty();
+    activeEntity.addStringProperty("text");
+    activeEntity.setActive(true);
+  }
+
+  protected void createExtendsImplements() {
+    Entity entity = this.schema.addEntity("ExtendsImplementsEntity");
+    entity.addIdProperty();
+    entity.addStringProperty("text");
+    entity.setSuperclass("TestSuperclass");
+    entity.implementsInterface("TestInterface");
+    entity.implementsSerializable();
+  }
+
+  protected void createChildclass() {
+    Entity entity = this.schema.addEntity("ChildclassEntity");
+    entity.addIdProperty();
+    entity.addStringProperty("text");
+    entity.setChildclass("TestChildclass");
+  }
+
+  private void createSchema2() {
+    this.schema2 = new Schema(1, "de.greenrobot.daotest2");
+    this.schema2.setDefaultJavaPackageTest("de.greenrobot.daotest2.entity");
+    this.schema2.setDefaultJavaPackageDao("de.greenrobot.daotest2.dao");
+    this.schema2.enableKeepSectionsByDefault();
+
+    Entity keepEntity = this.schema2.addEntity("KeepEntity");
+    keepEntity.addIdProperty();
+
+    Entity toManyTarget2 = this.schema2.addEntity("ToManyTarget2");
+    toManyTarget2.addIdProperty();
+    Property toManyTarget2FkId = toManyTarget2.addLongProperty("fkId").getProperty();
+    toManyTarget2.setSkipGenerationTest(true);
+
+    Entity toOneTarget2 = this.schema2.addEntity("ToOneTarget2");
+    toOneTarget2.addIdProperty();
+    toOneTarget2.setJavaPackage("de.greenrobot.daotest2.to1_specialentity");
+    toOneTarget2.setJavaPackageDao("de.greenrobot.daotest2.to1_specialdao");
+    toOneTarget2.setJavaPackageTest("de.greenrobot.daotest2.to1_specialtest");
+    toOneTarget2.setSkipGenerationTest(true);
+
+    Entity relationSource2 = this.schema2.addEntity("RelationSource2");
+    relationSource2.addIdProperty();
+    relationSource2.addToMany(toManyTarget2, toManyTarget2FkId);
+    Property toOneId = relationSource2.addLongProperty("toOneId").getProperty();
+    relationSource2.addToOne(toOneTarget2, toOneId);
+    relationSource2.setJavaPackage("de.greenrobot.daotest2.specialentity");
+    relationSource2.setJavaPackageDao("de.greenrobot.daotest2.specialdao");
+    relationSource2.setJavaPackageTest("de.greenrobot.daotest2.specialtest");
+    relationSource2.setSkipGenerationTest(true);
+  }
+
+  protected void createStringKeyValue() {
+    Entity entity = this.schema.addEntity("StringKeyValueEntity");
+    entity.addStringProperty("key").primaryKey();
+    entity.addStringProperty("value");
+  }
+
+  protected void createAutoincrement() {
+    Entity entity = this.schema.addEntity("AutoincrementEntity");
+    entity.addIdProperty().autoincrement();
+  }
+
+  protected void createSqliteMaster() {
+    Entity entity = this.schema.addEntity("SqliteMaster");
+    entity.setSkipTableCreation(true);
+    entity.setHasKeepSections(true);
+    entity.addStringProperty("type");
+    entity.addStringProperty("name");
+    entity.addStringProperty("tableName").columnName("tbl_name");
+    entity.addLongProperty("rootpage");
+    entity.addStringProperty("sql");
+  }
 
 }
diff --git a/DaoGenerator/src-template/dao-deep.ftl b/DaoGenerator/src-template/dao-deep.ftl
index eee5dc97..17e651e4 100644
--- a/DaoGenerator/src-template/dao-deep.ftl
+++ b/DaoGenerator/src-template/dao-deep.ftl
@@ -42,12 +42,12 @@ along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
         return selectDeep;
     }
     
-    protected ${entity.className} loadCurrentDeep(Cursor cursor, boolean lock) {
-        ${entity.className} entity = loadCurrent(cursor, 0, lock);
+    protected ${entity.referencedClassName} loadCurrentDeep(Cursor cursor, boolean lock) {
+        ${entity.referencedClassName} entity = loadCurrent(cursor, 0, lock);
         int offset = getAllColumns().length;
 
 <#list entity.toOneRelations as toOne>
-        ${toOne.targetEntity.className} ${toOne.name} = loadCurrentOther(daoSession.get${toOne.targetEntity.classNameDao}(), cursor, offset);
+        ${toOne.targetEntity.referencedClassName} ${toOne.name} = loadCurrentOther(daoSession.get${toOne.targetEntity.classNameDao}(), cursor, offset);
 <#if toOne.fkProperties[0].notNull>         if(${toOne.name} != null) {
     </#if>        entity.set${toOne.name?cap_first}(${toOne.name});
 <#if toOne.fkProperties[0].notNull>
@@ -61,7 +61,7 @@ along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
         return entity;    
     }
 
-    public ${entity.className} loadDeep(Long key) {
+    public ${entity.referencedClassName} loadDeep(Long key) {
         assertSinglePk();
         if (key == null) {
             return null;
@@ -89,9 +89,9 @@ along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
     }
     
     /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. */
-    public List<${entity.className}> loadAllDeepFromCursor(Cursor cursor) {
+    public List<${entity.referencedClassName}> loadAllDeepFromCursor(Cursor cursor) {
         int count = cursor.getCount();
-        List<${entity.className}> list = new ArrayList<${entity.className}>(count);
+        List<${entity.referencedClassName}> list = new ArrayList<${entity.referencedClassName}>(count);
         
         if (cursor.moveToFirst()) {
             if (identityScope != null) {
@@ -111,7 +111,7 @@ along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
         return list;
     }
     
-    protected List<${entity.className}> loadDeepAllAndCloseCursor(Cursor cursor) {
+    protected List<${entity.referencedClassName}> loadDeepAllAndCloseCursor(Cursor cursor) {
         try {
             return loadAllDeepFromCursor(cursor);
         } finally {
@@ -121,7 +121,7 @@ along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
     
 
     /** A raw-style query where you can pass any WHERE clause and arguments. */
-    public List<${entity.className}> queryDeep(String where, String... selectionArg) {
+    public List<${entity.referencedClassName}> queryDeep(String where, String... selectionArg) {
         Cursor cursor = db.rawQuery(getSelectDeep() + where, selectionArg);
         return loadDeepAllAndCloseCursor(cursor);
     }
diff --git a/DaoGenerator/src-template/dao-session.ftl b/DaoGenerator/src-template/dao-session.ftl
index e0201a48..6cd4a411 100644
--- a/DaoGenerator/src-template/dao-session.ftl
+++ b/DaoGenerator/src-template/dao-session.ftl
@@ -29,7 +29,13 @@ import de.greenrobot.dao.identityscope.IdentityScopeType;
 import de.greenrobot.dao.internal.DaoConfig;
 
 <#list schema.entities as entity>
+<#if entity.hasChildclassWithPackage>
+import ${entity.childclass};
+<#elseif entity.hasChildclassInEntityPackage>
+import ${entity.javaPackage}.${entity.childclass};
+<#else>
 import ${entity.javaPackage}.${entity.className};
+</#if>
 </#list>
 
 <#list schema.entities as entity>
@@ -68,7 +74,7 @@ public class DaoSession extends AbstractDaoSession {
 </#list>        
 
 <#list schema.entities as entity>
-        registerDao(${entity.className}.class, ${entity.classNameDao?uncap_first});
+        registerDao(${entity.referencedClassName}.class, ${entity.classNameDao?uncap_first});
 </#list>        
     }
     
diff --git a/DaoGenerator/src-template/dao-unit-test.ftl b/DaoGenerator/src-template/dao-unit-test.ftl
index 376cf431..c3d960bb 100644
--- a/DaoGenerator/src-template/dao-unit-test.ftl
+++ b/DaoGenerator/src-template/dao-unit-test.ftl
@@ -26,19 +26,25 @@ import de.greenrobot.dao.test.AbstractDaoTestStringPk;
 import de.greenrobot.dao.test.AbstractDaoTestLongPk;
 </#if>
 
+<#if entity.hasChildclassWithPackage>
+import ${entity.childclass};
+<#elseif entity.hasChildclassInEntityPackage>
+import ${entity.javaPackage}.${entity.childclass};
+<#else>
 import ${entity.javaPackage}.${entity.className};
+</#if>
 import ${entity.javaPackageDao}.${entity.classNameDao};
 
 public class ${entity.classNameTest} extends <#if
-isStringPK>AbstractDaoTestStringPk<${entity.classNameDao}, ${entity.className}><#else>AbstractDaoTestLongPk<${entity.classNameDao}, ${entity.className}></#if> {
+isStringPK>AbstractDaoTestStringPk<${entity.classNameDao}, ${entity.referencedClassName}><#else>AbstractDaoTestLongPk<${entity.classNameDao}, ${entity.referencedClassName}></#if> {
 
     public ${entity.classNameTest}() {
         super(${entity.classNameDao}.class);
     }
 
     @Override
-    protected ${entity.className} createEntity(<#if isStringPK>String<#else>Long</#if> key) {
-        ${entity.className} entity = new ${entity.className}();
+    protected ${entity.referencedClassName} createEntity(<#if isStringPK>String<#else>Long</#if> key) {
+        ${entity.referencedClassName} entity = new ${entity.referencedClassName}();
 <#if entity.pkProperty??>
         entity.set${entity.pkProperty.propertyName?cap_first}(key);
 </#if>
diff --git a/DaoGenerator/src-template/dao.ftl b/DaoGenerator/src-template/dao.ftl
index 443f74dc..6d3cb347 100644
--- a/DaoGenerator/src-template/dao.ftl
+++ b/DaoGenerator/src-template/dao.ftl
@@ -52,7 +52,13 @@ import ${additionalImport};
 </#list>
 
 </#if>
+<#if entity.hasChildclassWithPackage>
+import ${entity.childclass};
+<#elseif entity.hasChildclassInEntityPackage>
+import ${entity.javaPackage}.${entity.childclass};
+<#else>
 import ${entity.javaPackage}.${entity.className};
+</#if>
 <#if entity.protobuf>
 import ${entity.javaPackage}.${entity.className}.Builder;
 </#if>
@@ -61,7 +67,7 @@ import ${entity.javaPackage}.${entity.className}.Builder;
 /** 
  * DAO for table ${entity.tableName}.
 */
-public class ${entity.classNameDao} extends AbstractDao<${entity.className}, ${entity.pkType}> {
+public class ${entity.classNameDao} extends AbstractDao<${entity.referencedClassName}, ${entity.pkType}> {
 
     public static final String TABLENAME = "${entity.tableName}";
 
@@ -80,7 +86,7 @@ public class ${entity.classNameDao} extends AbstractDao<${entity.className}, ${e
 
 </#if>
 <#list entity.incomingToManyRelations as toMany>
-    private Query<${toMany.targetEntity.className}> ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query;
+    private Query<${toMany.targetEntity.referencedClassName}> ${toMany.sourceEntity.referencedClassName?uncap_first}_${toMany.name?cap_first}Query;
 </#list>
 
     public ${entity.classNameDao}(DaoConfig config) {
@@ -121,7 +127,7 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
 </#if>
     /** @inheritdoc */
     @Override
-    protected void bindValues(SQLiteStatement stmt, ${entity.className} entity) {
+    protected void bindValues(SQLiteStatement stmt, ${entity.referencedClassName} entity) {
         stmt.clearBindings();
 <#list entity.properties as property>
 <#if property.notNull || entity.protobuf>
@@ -143,7 +149,7 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
 <#list entity.toOneRelations as toOne>
 <#if !toOne.fkProperties?has_content>
 
-        ${toOne.targetEntity.className} ${toOne.name} = entity.peak${toOne.name?cap_first}();
+        ${toOne.targetEntity.referencedClassName} ${toOne.name} = entity.peak${toOne.name?cap_first}();
         if(${toOne.name} != null) {
             ${toOne.targetEntity.pkProperty.javaType} ${toOne.name}__targetKey = ${toOne.name}.get${toOne.targetEntity.pkProperty.propertyName?cap_first}();
 <#if !toOne.targetEntity.pkProperty.notNull>
@@ -160,7 +166,7 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
 
 <#if entity.active>
     @Override
-    protected void attachEntity(${entity.className} entity) {
+    protected void attachEntity(${entity.referencedClassName} entity) {
         super.attachEntity(entity);
         entity.__setDaoSession(daoSession);
     }
@@ -182,9 +188,9 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
 
     /** @inheritdoc */
     @Override
-    public ${entity.className} readEntity(Cursor cursor, int offset) {
+    public ${entity.referencedClassName} readEntity(Cursor cursor, int offset) {
 <#if entity.protobuf>
-        Builder builder = ${entity.className}.newBuilder();
+        Builder builder = ${entity.referencedClassName}.newBuilder();
 <#list entity.properties as property>
 <#if !property.notNull>
         if (!cursor.isNull(offset + ${property_index})) {
@@ -194,11 +200,11 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
 </#if>        
 </#list>        
         return builder.build();
-<#elseif entity.constructors>
+<#elseif entity.constructors && !entity.hasChildclass>
 <#--
 ############################## readEntity non-protobuff, constructor ############################## 
 -->
-        ${entity.className} entity = new ${entity.className}( //
+        ${entity.referencedClassName} entity = new ${entity.referencedClassName}( //
 <#list entity.properties as property>
             <#if !property.notNull>cursor.isNull(offset + ${property_index}) ? null : </#if><#if
             property.propertyType == "Byte">(byte) </#if><#if
@@ -212,7 +218,7 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
 <#--
 ############################## readEntity non-protobuff, setters ############################## 
 -->
-        ${entity.className} entity = new ${entity.className}();
+        ${entity.referencedClassName} entity = new ${entity.referencedClassName}();
         readEntity(cursor, entity, offset);
         return entity;
 </#if>
@@ -220,7 +226,7 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
      
     /** @inheritdoc */
     @Override
-    public void readEntity(Cursor cursor, ${entity.className} entity, int offset) {
+    public void readEntity(Cursor cursor, ${entity.referencedClassName} entity, int offset) {
 <#if entity.protobuf>
         throw new UnsupportedOperationException("Protobuf objects cannot be modified");
 <#else> 
@@ -236,7 +242,7 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
     
     /** @inheritdoc */
     @Override
-    protected ${entity.pkType} updateKeyAfterInsert(${entity.className} entity, long rowId) {
+    protected ${entity.pkType} updateKeyAfterInsert(${entity.referencedClassName} entity, long rowId) {
 <#if entity.pkProperty??>
 <#if entity.pkProperty.propertyType == "Long">
 <#if !entity.protobuf>
@@ -254,7 +260,7 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
     
     /** @inheritdoc */
     @Override
-    public ${entity.pkType} getKey(${entity.className} entity) {
+    public ${entity.pkType} getKey(${entity.referencedClassName} entity) {
 <#if entity.pkProperty??>
         if(entity != null) {
             return entity.get${entity.pkProperty.propertyName?cap_first}();
@@ -273,22 +279,22 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
     }
     
 <#list entity.incomingToManyRelations as toMany>
-    /** Internal query to resolve the "${toMany.name}" to-many relationship of ${toMany.sourceEntity.className}. */
-    public List<${toMany.targetEntity.className}> _query${toMany.sourceEntity.className?cap_first}_${toMany.name?cap_first}(<#--
+    /** Internal query to resolve the "${toMany.name}" to-many relationship of ${toMany.sourceEntity.referencedClassName}. */
+    public List<${toMany.targetEntity.referencedClassName}> _query${toMany.sourceEntity.referencedClassName?cap_first}_${toMany.name?cap_first}(<#--
     --><#list toMany.targetProperties as property>${property.javaType} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
         synchronized (this) {
-            if (${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query == null) {
-                QueryBuilder<${toMany.targetEntity.className}> queryBuilder = queryBuilder();
+            if (${toMany.sourceEntity.referencedClassName?uncap_first}_${toMany.name?cap_first}Query == null) {
+                QueryBuilder<${toMany.targetEntity.referencedClassName}> queryBuilder = queryBuilder();
 <#list toMany.targetProperties as property>
                 queryBuilder.where(Properties.${property.propertyName?cap_first}.eq(null));
 </#list>
 <#if toMany.order?has_content>
                 queryBuilder.orderRaw("${toMany.order}");
 </#if>
-                ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query = queryBuilder.build();
+                ${toMany.sourceEntity.referencedClassName?uncap_first}_${toMany.name?cap_first}Query = queryBuilder.build();
             }
         }
-        Query<${toMany.targetEntity.className}> query = ${toMany.sourceEntity.className?uncap_first}_${toMany.name?cap_first}Query.forCurrentThread();
+        Query<${toMany.targetEntity.referencedClassName}> query = ${toMany.sourceEntity.referencedClassName?uncap_first}_${toMany.name?cap_first}Query.forCurrentThread();
 <#list toMany.targetProperties as property>
         query.setParameter(${property_index}, ${property.propertyName});
 </#list>
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java b/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
index 27f6cb3c..08698032 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
@@ -27,591 +27,641 @@
 import de.greenrobot.daogenerator.Property.PropertyBuilder;
 
 /**
- * Model class for an entity: a Java data object mapped to a data base table. A new entity is added to a {@link Schema}
- * by the method {@link Schema#addEntity(String)} (there is no public constructor for {@link Entity} itself). <br/>
+ * Model class for an entity: a Java data object mapped to a data base table. A
+ * new entity is added to a {@link Schema} by the method
+ * {@link Schema#addEntity(String)} (there is no public constructor for
+ * {@link Entity} itself). <br/>
  * <br/>
- * Use the various addXXX methods to add entity properties, indexes, and relations to other entities (addToOne,
- * addToMany).<br/>
+ * Use the various addXXX methods to add entity properties, indexes, and
+ * relations to other entities (addToOne, addToMany).<br/>
  * <br/>
  * There are further configuration possibilities:
  * <ul>
- * <li>{@link Entity#implementsInterface(String...)} and {@link #implementsSerializable()} to specify interfaces the
- * entity will implement</li>
- * <li>{@link #setSuperclass(String)} to specify a class of which the entity will extend from</li>
+ * <li>{@link Entity#implementsInterface(String...)} and
+ * {@link #implementsSerializable()} to specify interfaces the entity will
+ * implement</li>
+ * <li>{@link #setSuperclass(String)} to specify a class of which the entity
+ * will extend from</li>
  * <li>Various setXXX methods</li>
  * </ul>
  * 
- * @see <a href="http://greendao-orm.com/documentation/modelling-entities/">Modelling Entities (Documentation page)</a>
- * @see <a href="http://greendao-orm.com/documentation/relations/">Relations (Documentation page)</a>
+ * @see <a
+ *      href="http://greendao-orm.com/documentation/modelling-entities/">Modelling
+ *      Entities (Documentation page)</a>
+ * @see <a href="http://greendao-orm.com/documentation/relations/">Relations
+ *      (Documentation page)</a>
  */
 public class Entity {
-    private final Schema schema;
-    private final String className;
-    private final List<Property> properties;
-    private List<Property> propertiesColumns;
-    private final List<Property> propertiesPk;
-    private final List<Property> propertiesNonPk;
-    private final Set<String> propertyNames;
-    private final List<Index> indexes;
-    private final List<ToOne> toOneRelations;
-    private final List<ToMany> toManyRelations;
-    private final List<ToMany> incomingToManyRelations;
-    private final Collection<String> additionalImportsEntity;
-    private final Collection<String> additionalImportsDao;
-    private final List<String> interfacesToImplement;
-
-    private String tableName;
-    private String classNameDao;
-    private String classNameTest;
-    private String javaPackage;
-    private String javaPackageDao;
-    private String javaPackageTest;
-    private Property pkProperty;
-    private String pkType;
-    private String superclass;
-
-    private boolean protobuf;
-    private boolean constructors;
-    private boolean skipGeneration;
-    private boolean skipGenerationTest;
-    private boolean skipTableCreation;
-    private Boolean active;
-    private Boolean hasKeepSections;
-
-    Entity(Schema schema, String className) {
-        this.schema = schema;
-        this.className = className;
-        properties = new ArrayList<Property>();
-        propertiesPk = new ArrayList<Property>();
-        propertiesNonPk = new ArrayList<Property>();
-        propertyNames = new HashSet<String>();
-        indexes = new ArrayList<Index>();
-        toOneRelations = new ArrayList<ToOne>();
-        toManyRelations = new ArrayList<ToMany>();
-        incomingToManyRelations = new ArrayList<ToMany>();
-        additionalImportsEntity = new TreeSet<String>();
-        additionalImportsDao = new TreeSet<String>();
-        interfacesToImplement = new ArrayList<String>();
-        constructors = true;
-    }
-
-    public PropertyBuilder addBooleanProperty(String propertyName) {
-        return addProperty(PropertyType.Boolean, propertyName);
-    }
-
-    public PropertyBuilder addByteProperty(String propertyName) {
-        return addProperty(PropertyType.Byte, propertyName);
-    }
-
-    public PropertyBuilder addShortProperty(String propertyName) {
-        return addProperty(PropertyType.Short, propertyName);
-    }
-
-    public PropertyBuilder addIntProperty(String propertyName) {
-        return addProperty(PropertyType.Int, propertyName);
-    }
-
-    public PropertyBuilder addLongProperty(String propertyName) {
-        return addProperty(PropertyType.Long, propertyName);
-    }
-
-    public PropertyBuilder addFloatProperty(String propertyName) {
-        return addProperty(PropertyType.Float, propertyName);
-    }
-
-    public PropertyBuilder addDoubleProperty(String propertyName) {
-        return addProperty(PropertyType.Double, propertyName);
-    }
-
-    public PropertyBuilder addByteArrayProperty(String propertyName) {
-        return addProperty(PropertyType.ByteArray, propertyName);
-    }
-
-    public PropertyBuilder addStringProperty(String propertyName) {
-        return addProperty(PropertyType.String, propertyName);
-    }
-
-    public PropertyBuilder addDateProperty(String propertyName) {
-        return addProperty(PropertyType.Date, propertyName);
-    }
-
-    public PropertyBuilder addProperty(PropertyType propertyType, String propertyName) {
-        if (!propertyNames.add(propertyName)) {
-            throw new RuntimeException("Property already defined: " + propertyName);
-        }
-        PropertyBuilder builder = new Property.PropertyBuilder(schema, this, propertyType, propertyName);
-        properties.add(builder.getProperty());
-        return builder;
-    }
-
-    /** Adds a standard _id column required by standard Android classes, e.g. list adapters. */
-    public PropertyBuilder addIdProperty() {
-        PropertyBuilder builder = addLongProperty("id");
-        builder.columnName("_id").primaryKey();
-        return builder;
-    }
-
-    /** Adds a to-many relationship; the target entity is joined to the PK property of this entity (typically the ID). */
-    public ToMany addToMany(Entity target, Property targetProperty) {
-        Property[] targetProperties = { targetProperty };
-        return addToMany(null, target, targetProperties);
-    }
-
-    /**
-     * Convenience method for {@link Entity#addToMany(Entity, Property)} with a subsequent call to
-     * {@link ToMany#setName(String)}.
-     */
-    public ToMany addToMany(Entity target, Property targetProperty, String name) {
-        ToMany toMany = addToMany(target, targetProperty);
-        toMany.setName(name);
-        return toMany;
-    }
-
-    /**
-     * Add a to-many relationship; the target entity is joined using the given target property (of the target entity)
-     * and given source property (of this entity).
-     */
-    public ToMany addToMany(Property sourceProperty, Entity target, Property targetProperty) {
-        Property[] sourceProperties = { sourceProperty };
-        Property[] targetProperties = { targetProperty };
-        return addToMany(sourceProperties, target, targetProperties);
-    }
-
-    public ToMany addToMany(Property[] sourceProperties, Entity target, Property[] targetProperties) {
-        if(protobuf) {
-            throw new IllegalStateException("Protobuf entities do not support realtions, currently");
-        }
-
-        ToMany toMany = new ToMany(schema, this, sourceProperties, target, targetProperties);
-        toManyRelations.add(toMany);
-        target.incomingToManyRelations.add(toMany);
-        return toMany;
-    }
-
-    /**
-     * Adds a to-one relationship to the given target entity using the given given foreign key property (which belongs
-     * to this entity).
-     */
-    public ToOne addToOne(Entity target, Property fkProperty) {
-        if(protobuf) {
-            throw new IllegalStateException("Protobuf entities do not support realtions, currently");
-        }
-
-        Property[] fkProperties = { fkProperty };
-        ToOne toOne = new ToOne(schema, this, target, fkProperties, true);
-        toOneRelations.add(toOne);
-        return toOne;
-    }
-
-    /** Convenience for {@link #addToOne(Entity, Property)} with a subsequent call to {@link ToOne#setName(String)}. */
-    public ToOne addToOne(Entity target, Property fkProperty, String name) {
-        ToOne toOne = addToOne(target, fkProperty);
-        toOne.setName(name);
-        return toOne;
-    }
-
-    public ToOne addToOneWithoutProperty(String name, Entity target, String fkColumnName) {
-        return addToOneWithoutProperty(name, target, fkColumnName, false, false);
-    }
-
-    public ToOne addToOneWithoutProperty(String name, Entity target, String fkColumnName, boolean notNull,
-            boolean unique) {
-        PropertyBuilder propertyBuilder = new PropertyBuilder(schema, this, null, name);
-        if (notNull) {
-            propertyBuilder.notNull();
+  private final Schema schema;
+  private final String className;
+  private final List<Property> properties;
+  private List<Property> propertiesColumns;
+  private final List<Property> propertiesPk;
+  private final List<Property> propertiesNonPk;
+  private final Set<String> propertyNames;
+  private final List<Index> indexes;
+  private final List<ToOne> toOneRelations;
+  private final List<ToMany> toManyRelations;
+  private final List<ToMany> incomingToManyRelations;
+  private final Collection<String> additionalImportsEntity;
+  private final Collection<String> additionalImportsDao;
+  private final List<String> interfacesToImplement;
+
+  private String tableName;
+  private String classNameDao;
+  private String classNameTest;
+  private String javaPackage;
+  private String javaPackageDao;
+  private String javaPackageTest;
+  private Property pkProperty;
+  private String pkType;
+  private String superclass;
+  private String childclass;
+
+  private boolean protobuf;
+  private boolean constructors;
+  private boolean skipGeneration;
+  private boolean skipGenerationTest;
+  private boolean skipTableCreation;
+  private Boolean active;
+  private Boolean hasKeepSections;
+
+  Entity(Schema schema, String className) {
+    this.schema = schema;
+    this.className = className;
+    this.properties = new ArrayList<Property>();
+    this.propertiesPk = new ArrayList<Property>();
+    this.propertiesNonPk = new ArrayList<Property>();
+    this.propertyNames = new HashSet<String>();
+    this.indexes = new ArrayList<Index>();
+    this.toOneRelations = new ArrayList<ToOne>();
+    this.toManyRelations = new ArrayList<ToMany>();
+    this.incomingToManyRelations = new ArrayList<ToMany>();
+    this.additionalImportsEntity = new TreeSet<String>();
+    this.additionalImportsDao = new TreeSet<String>();
+    this.interfacesToImplement = new ArrayList<String>();
+    this.constructors = true;
+  }
+
+  public PropertyBuilder addBooleanProperty(String propertyName) {
+    return this.addProperty(PropertyType.Boolean, propertyName);
+  }
+
+  public PropertyBuilder addByteProperty(String propertyName) {
+    return this.addProperty(PropertyType.Byte, propertyName);
+  }
+
+  public PropertyBuilder addShortProperty(String propertyName) {
+    return this.addProperty(PropertyType.Short, propertyName);
+  }
+
+  public PropertyBuilder addIntProperty(String propertyName) {
+    return this.addProperty(PropertyType.Int, propertyName);
+  }
+
+  public PropertyBuilder addLongProperty(String propertyName) {
+    return this.addProperty(PropertyType.Long, propertyName);
+  }
+
+  public PropertyBuilder addFloatProperty(String propertyName) {
+    return this.addProperty(PropertyType.Float, propertyName);
+  }
+
+  public PropertyBuilder addDoubleProperty(String propertyName) {
+    return this.addProperty(PropertyType.Double, propertyName);
+  }
+
+  public PropertyBuilder addByteArrayProperty(String propertyName) {
+    return this.addProperty(PropertyType.ByteArray, propertyName);
+  }
+
+  public PropertyBuilder addStringProperty(String propertyName) {
+    return this.addProperty(PropertyType.String, propertyName);
+  }
+
+  public PropertyBuilder addDateProperty(String propertyName) {
+    return this.addProperty(PropertyType.Date, propertyName);
+  }
+
+  public PropertyBuilder addProperty(PropertyType propertyType, String propertyName) {
+    if (!this.propertyNames.add(propertyName)) {
+      throw new RuntimeException("Property already defined: " + propertyName);
+    }
+    PropertyBuilder builder = new Property.PropertyBuilder(this.schema, this, propertyType, propertyName);
+    this.properties.add(builder.getProperty());
+    return builder;
+  }
+
+  /**
+   * Adds a standard _id column required by standard Android classes, e.g. list
+   * adapters.
+   */
+  public PropertyBuilder addIdProperty() {
+    PropertyBuilder builder = this.addLongProperty("id");
+    builder.columnName("_id").primaryKey();
+    return builder;
+  }
+
+  /**
+   * Adds a to-many relationship; the target entity is joined to the PK property
+   * of this entity (typically the ID).
+   */
+  public ToMany addToMany(Entity target, Property targetProperty) {
+    Property[] targetProperties = { targetProperty };
+    return this.addToMany(null, target, targetProperties);
+  }
+
+  /**
+   * Convenience method for {@link Entity#addToMany(Entity, Property)} with a
+   * subsequent call to {@link ToMany#setName(String)}.
+   */
+  public ToMany addToMany(Entity target, Property targetProperty, String name) {
+    ToMany toMany = this.addToMany(target, targetProperty);
+    toMany.setName(name);
+    return toMany;
+  }
+
+  /**
+   * Add a to-many relationship; the target entity is joined using the given
+   * target property (of the target entity) and given source property (of this
+   * entity).
+   */
+  public ToMany addToMany(Property sourceProperty, Entity target, Property targetProperty) {
+    Property[] sourceProperties = { sourceProperty };
+    Property[] targetProperties = { targetProperty };
+    return this.addToMany(sourceProperties, target, targetProperties);
+  }
+
+  public ToMany addToMany(Property[] sourceProperties, Entity target, Property[] targetProperties) {
+    if (this.protobuf) {
+      throw new IllegalStateException("Protobuf entities do not support realtions, currently");
+    }
+
+    ToMany toMany = new ToMany(this.schema, this, sourceProperties, target, targetProperties);
+    this.toManyRelations.add(toMany);
+    target.incomingToManyRelations.add(toMany);
+    return toMany;
+  }
+
+  /**
+   * Adds a to-one relationship to the given target entity using the given given
+   * foreign key property (which belongs to this entity).
+   */
+  public ToOne addToOne(Entity target, Property fkProperty) {
+    if (this.protobuf) {
+      throw new IllegalStateException("Protobuf entities do not support realtions, currently");
+    }
+
+    Property[] fkProperties = { fkProperty };
+    ToOne toOne = new ToOne(this.schema, this, target, fkProperties, true);
+    this.toOneRelations.add(toOne);
+    return toOne;
+  }
+
+  /**
+   * Convenience for {@link #addToOne(Entity, Property)} with a subsequent call
+   * to {@link ToOne#setName(String)}.
+   */
+  public ToOne addToOne(Entity target, Property fkProperty, String name) {
+    ToOne toOne = this.addToOne(target, fkProperty);
+    toOne.setName(name);
+    return toOne;
+  }
+
+  public ToOne addToOneWithoutProperty(String name, Entity target, String fkColumnName) {
+    return this.addToOneWithoutProperty(name, target, fkColumnName, false, false);
+  }
+
+  public ToOne addToOneWithoutProperty(String name, Entity target, String fkColumnName, boolean notNull, boolean unique) {
+    PropertyBuilder propertyBuilder = new PropertyBuilder(this.schema, this, null, name);
+    if (notNull) {
+      propertyBuilder.notNull();
+    }
+    if (unique) {
+      propertyBuilder.unique();
+    }
+    propertyBuilder.columnName(fkColumnName);
+    Property column = propertyBuilder.getProperty();
+    Property[] fkColumns = { column };
+    ToOne toOne = new ToOne(this.schema, this, target, fkColumns, false);
+    toOne.setName(name);
+    this.toOneRelations.add(toOne);
+    return toOne;
+  }
+
+  protected void addIncomingToMany(ToMany toMany) {
+    this.incomingToManyRelations.add(toMany);
+  }
+
+  /**
+   * Adds a new index to the entity.
+   */
+  public Entity addIndex(Index index) {
+    this.indexes.add(index);
+    return this;
+  }
+
+  /**
+   * The entity is represented by a protocol buffers object. Requires some
+   * special actions like using builders.
+   */
+  Entity useProtobuf() {
+    this.protobuf = true;
+    return this;
+  }
+
+  public boolean isProtobuf() {
+    return this.protobuf;
+  }
+
+  public Schema getSchema() {
+    return this.schema;
+  }
+
+  public String getTableName() {
+    return this.tableName;
+  }
+
+  public void setTableName(String tableName) {
+    this.tableName = tableName;
+  }
+
+  public String getClassName() {
+    return this.className;
+  }
+
+  public String getReferencedClassName() {
+    if (this.getHasChildclass()) {
+      return this.childclass;
+    } else {
+      return this.className;
+    }
+  }
+
+  public List<Property> getProperties() {
+    return this.properties;
+  }
+
+  public List<Property> getPropertiesColumns() {
+    return this.propertiesColumns;
+  }
+
+  public String getJavaPackage() {
+    return this.javaPackage;
+  }
+
+  public void setJavaPackage(String javaPackage) {
+    this.javaPackage = javaPackage;
+  }
+
+  public String getJavaPackageDao() {
+    return this.javaPackageDao;
+  }
+
+  public void setJavaPackageDao(String javaPackageDao) {
+    this.javaPackageDao = javaPackageDao;
+  }
+
+  public String getClassNameDao() {
+    return this.classNameDao;
+  }
+
+  public void setClassNameDao(String classNameDao) {
+    this.classNameDao = classNameDao;
+  }
+
+  public String getClassNameTest() {
+    return this.classNameTest;
+  }
+
+  public void setClassNameTest(String classNameTest) {
+    this.classNameTest = classNameTest;
+  }
+
+  public String getJavaPackageTest() {
+    return this.javaPackageTest;
+  }
+
+  public void setJavaPackageTest(String javaPackageTest) {
+    this.javaPackageTest = javaPackageTest;
+  }
+
+  public List<Property> getPropertiesPk() {
+    return this.propertiesPk;
+  }
+
+  public List<Property> getPropertiesNonPk() {
+    return this.propertiesNonPk;
+  }
+
+  public Property getPkProperty() {
+    return this.pkProperty;
+  }
+
+  public List<Index> getIndexes() {
+    return this.indexes;
+  }
+
+  public String getPkType() {
+    return this.pkType;
+  }
+
+  public boolean isConstructors() {
+    return this.constructors;
+  }
+
+  public void setConstructors(boolean constructors) {
+    this.constructors = constructors;
+  }
+
+  public boolean isSkipGeneration() {
+    return this.skipGeneration;
+  }
+
+  /**
+   * Flag if the entity's code generation should be skipped. E.g. if you need to
+   * change the class after initial generation.
+   */
+  public void setSkipGeneration(boolean skipGeneration) {
+    this.skipGeneration = skipGeneration;
+  }
+
+  /**
+   * Flag if CREATE & DROP TABLE scripts should be skipped in Dao.
+   */
+  public void setSkipTableCreation(boolean skipTableCreation) {
+    this.skipTableCreation = skipTableCreation;
+  }
+
+  public boolean isSkipTableCreation() {
+    return this.skipTableCreation;
+  }
+
+  public boolean isSkipGenerationTest() {
+    return this.skipGenerationTest;
+  }
+
+  public void setSkipGenerationTest(boolean skipGenerationTest) {
+    this.skipGenerationTest = skipGenerationTest;
+  }
+
+  public List<ToOne> getToOneRelations() {
+    return this.toOneRelations;
+  }
+
+  public List<ToMany> getToManyRelations() {
+    return this.toManyRelations;
+  }
+
+  public List<ToMany> getIncomingToManyRelations() {
+    return this.incomingToManyRelations;
+  }
+
+  /**
+   * Entities with relations are active, but this method allows to make the
+   * entities active even if it does not have relations.
+   */
+  public void setActive(Boolean active) {
+    this.active = active;
+  }
+
+  public Boolean getActive() {
+    return this.active;
+  }
+
+  public Boolean getHasKeepSections() {
+    return this.hasKeepSections;
+  }
+
+  public Collection<String> getAdditionalImportsEntity() {
+    return this.additionalImportsEntity;
+  }
+
+  public Collection<String> getAdditionalImportsDao() {
+    return this.additionalImportsDao;
+  }
+
+  public void setHasKeepSections(Boolean hasKeepSections) {
+    this.hasKeepSections = hasKeepSections;
+  }
+
+  public List<String> getInterfacesToImplement() {
+    return this.interfacesToImplement;
+  }
+
+  public void implementsInterface(String... interfaces) {
+    for (String interfaceToImplement : interfaces) {
+      this.interfacesToImplement.add(interfaceToImplement);
+    }
+  }
+
+  public void implementsSerializable() {
+    this.interfacesToImplement.add("java.io.Serializable");
+  }
+
+  public String getSuperclass() {
+    return this.superclass;
+  }
+
+  public void setSuperclass(String classToExtend) {
+    this.superclass = classToExtend;
+  }
+
+  public String getChildclass() {
+    return this.childclass;
+  }
+
+  public void setChildclass(String childclass) {
+    this.childclass = childclass;
+  }
+
+  public boolean getHasChildclassWithPackage() {
+    return this.getHasChildclass() && this.childclass.contains(".");
+  }
+
+  public boolean getHasChildclass() {
+    return (this.childclass != null) && !"".equals(this.childclass.trim());
+  }
+
+  public boolean getHasChildclassInEntityPackage() {
+    return this.getHasChildclass() && !this.childclass.contains(".");
+  }
+
+  void init2ndPass() {
+    this.init2nPassNamesWithDefaults();
+
+    for (int i = 0; i < this.properties.size(); i++) {
+      Property property = this.properties.get(i);
+      property.setOrdinal(i);
+      property.init2ndPass();
+      if (property.isPrimaryKey()) {
+        this.propertiesPk.add(property);
+      } else {
+        this.propertiesNonPk.add(property);
+      }
+    }
+
+    if (this.propertiesPk.size() == 1) {
+      this.pkProperty = this.propertiesPk.get(0);
+      this.pkType = this.schema.mapToJavaTypeNullable(this.pkProperty.getPropertyType());
+    } else {
+      this.pkType = "Void";
+    }
+
+    this.propertiesColumns = new ArrayList<Property>(this.properties);
+    for (ToOne toOne : this.toOneRelations) {
+      toOne.init2ndPass();
+      Property[] fkProperties = toOne.getFkProperties();
+      for (Property fkProperty : fkProperties) {
+        if (!this.propertiesColumns.contains(fkProperty)) {
+          this.propertiesColumns.add(fkProperty);
         }
-        if (unique) {
-            propertyBuilder.unique();
-        }
-        propertyBuilder.columnName(fkColumnName);
-        Property column = propertyBuilder.getProperty();
-        Property[] fkColumns = { column };
-        ToOne toOne = new ToOne(schema, this, target, fkColumns, false);
-        toOne.setName(name);
-        toOneRelations.add(toOne);
-        return toOne;
-    }
-
-    protected void addIncomingToMany(ToMany toMany) {
-        incomingToManyRelations.add(toMany);
-    }
-
-    /**
-     * Adds a new index to the entity.
-     */
-    public Entity addIndex(Index index) {
-        indexes.add(index);
-        return this;
-    }
-
-    /** The entity is represented by a protocol buffers object. Requires some special actions like using builders. */
-    Entity useProtobuf() {
-        protobuf = true;
-        return this;
-    }
-
-    public boolean isProtobuf() {
-        return protobuf;
-    }
-
-    public Schema getSchema() {
-        return schema;
-    }
-
-    public String getTableName() {
-        return tableName;
-    }
-
-    public void setTableName(String tableName) {
-        this.tableName = tableName;
-    }
-
-    public String getClassName() {
-        return className;
-    }
-
-    public List<Property> getProperties() {
-        return properties;
-    }
-
-    public List<Property> getPropertiesColumns() {
-        return propertiesColumns;
-    }
-
-    public String getJavaPackage() {
-        return javaPackage;
-    }
-
-    public void setJavaPackage(String javaPackage) {
-        this.javaPackage = javaPackage;
-    }
-
-    public String getJavaPackageDao() {
-        return javaPackageDao;
-    }
-
-    public void setJavaPackageDao(String javaPackageDao) {
-        this.javaPackageDao = javaPackageDao;
-    }
-
-    public String getClassNameDao() {
-        return classNameDao;
-    }
-
-    public void setClassNameDao(String classNameDao) {
-        this.classNameDao = classNameDao;
-    }
-
-    public String getClassNameTest() {
-        return classNameTest;
+      }
     }
 
-    public void setClassNameTest(String classNameTest) {
-        this.classNameTest = classNameTest;
+    for (ToMany toMany : this.toManyRelations) {
+      toMany.init2ndPass();
+      // Source Properties may not be virtual, so we do not need the following
+      // code:
+      // for (Property sourceProperty : toMany.getSourceProperties()) {
+      // if (!propertiesColumns.contains(sourceProperty)) {
+      // propertiesColumns.add(sourceProperty);
+      // }
+      // }
     }
 
-    public String getJavaPackageTest() {
-        return javaPackageTest;
+    if (this.active == null) {
+      this.active = this.schema.isUseActiveEntitiesByDefault();
     }
+    this.active |= !this.toOneRelations.isEmpty() || !this.toManyRelations.isEmpty();
 
-    public void setJavaPackageTest(String javaPackageTest) {
-        this.javaPackageTest = javaPackageTest;
+    if (this.hasKeepSections == null) {
+      this.hasKeepSections = this.schema.isHasKeepSectionsByDefault();
     }
 
-    public List<Property> getPropertiesPk() {
-        return propertiesPk;
-    }
-
-    public List<Property> getPropertiesNonPk() {
-        return propertiesNonPk;
-    }
-
-    public Property getPkProperty() {
-        return pkProperty;
-    }
-
-    public List<Index> getIndexes() {
-        return indexes;
-    }
-
-    public String getPkType() {
-        return pkType;
-    }
-
-    public boolean isConstructors() {
-        return constructors;
-    }
-
-    public void setConstructors(boolean constructors) {
-        this.constructors = constructors;
-    }
-
-    public boolean isSkipGeneration() {
-        return skipGeneration;
-    }
-
-    /**
-     * Flag if the entity's code generation should be skipped. E.g. if you need to change the class after initial
-     * generation.
-     */
-    public void setSkipGeneration(boolean skipGeneration) {
-        this.skipGeneration = skipGeneration;
-    }
-
-    /**
-     * Flag if CREATE & DROP TABLE scripts should be skipped in Dao.
-     */
-    public void setSkipTableCreation(boolean skipTableCreation) {
-        this.skipTableCreation = skipTableCreation;
-    }
-    
-    public boolean isSkipTableCreation() {
-        return skipTableCreation;
-    }
-
-    public boolean isSkipGenerationTest() {
-        return skipGenerationTest;
-    }
-
-    public void setSkipGenerationTest(boolean skipGenerationTest) {
-        this.skipGenerationTest = skipGenerationTest;
-    }
-
-    public List<ToOne> getToOneRelations() {
-        return toOneRelations;
-    }
-
-    public List<ToMany> getToManyRelations() {
-        return toManyRelations;
-    }
-
-    public List<ToMany> getIncomingToManyRelations() {
-        return incomingToManyRelations;
-    }
-
-    /**
-     * Entities with relations are active, but this method allows to make the entities active even if it does not have
-     * relations.
-     */
-    public void setActive(Boolean active) {
-        this.active = active;
-    }
-
-    public Boolean getActive() {
-        return active;
-    }
-
-    public Boolean getHasKeepSections() {
-        return hasKeepSections;
-    }
-
-    public Collection<String> getAdditionalImportsEntity() {
-        return additionalImportsEntity;
-    }
-
-    public Collection<String> getAdditionalImportsDao() {
-        return additionalImportsDao;
-    }
+    this.init2ndPassIndexNamesWithDefaults();
+  }
 
-    public void setHasKeepSections(Boolean hasKeepSections) {
-        this.hasKeepSections = hasKeepSections;
+  protected void init2nPassNamesWithDefaults() {
+    if (this.tableName == null) {
+      this.tableName = DaoUtil.dbName(this.className);
     }
 
-    public List<String> getInterfacesToImplement() {
-        return interfacesToImplement;
+    if (this.classNameDao == null) {
+      this.classNameDao = this.className + "Dao";
     }
-
-    public void implementsInterface(String... interfaces) {
-        for (String interfaceToImplement : interfaces) {
-            interfacesToImplement.add(interfaceToImplement);
-        }
+    if (this.classNameTest == null) {
+      this.classNameTest = this.className + "Test";
     }
 
-    public void implementsSerializable() {
-        interfacesToImplement.add("java.io.Serializable");
+    if (this.javaPackage == null) {
+      this.javaPackage = this.schema.getDefaultJavaPackage();
     }
 
-    public String getSuperclass() {
-        return superclass;
+    if (this.javaPackageDao == null) {
+      this.javaPackageDao = this.schema.getDefaultJavaPackageDao();
+      if (this.javaPackageDao == null) {
+        this.javaPackageDao = this.javaPackage;
+      }
     }
-
-    public void setSuperclass(String classToExtend) {
-        this.superclass = classToExtend;
-    }
-
-    void init2ndPass() {
-        init2nPassNamesWithDefaults();
-
-        for (int i = 0; i < properties.size(); i++) {
-            Property property = properties.get(i);
-            property.setOrdinal(i);
-            property.init2ndPass();
-            if (property.isPrimaryKey()) {
-                propertiesPk.add(property);
-            } else {
-                propertiesNonPk.add(property);
-            }
-        }
-
-        if (propertiesPk.size() == 1) {
-            pkProperty = propertiesPk.get(0);
-            pkType = schema.mapToJavaTypeNullable(pkProperty.getPropertyType());
-        } else {
-            pkType = "Void";
-        }
-
-        propertiesColumns = new ArrayList<Property>(properties);
-        for (ToOne toOne : toOneRelations) {
-            toOne.init2ndPass();
-            Property[] fkProperties = toOne.getFkProperties();
-            for (Property fkProperty : fkProperties) {
-                if (!propertiesColumns.contains(fkProperty)) {
-                    propertiesColumns.add(fkProperty);
-                }
-            }
-        }
-
-        for (ToMany toMany : toManyRelations) {
-            toMany.init2ndPass();
-            // Source Properties may not be virtual, so we do not need the following code:
-            // for (Property sourceProperty : toMany.getSourceProperties()) {
-            // if (!propertiesColumns.contains(sourceProperty)) {
-            // propertiesColumns.add(sourceProperty);
-            // }
-            // }
-        }
-
-        if (active == null) {
-            active = schema.isUseActiveEntitiesByDefault();
-        }
-        active |= !toOneRelations.isEmpty() || !toManyRelations.isEmpty();
-
-        if (hasKeepSections == null) {
-            hasKeepSections = schema.isHasKeepSectionsByDefault();
-        }
-
-        init2ndPassIndexNamesWithDefaults();
+    if (this.javaPackageTest == null) {
+      this.javaPackageTest = this.schema.getDefaultJavaPackageTest();
+      if (this.javaPackageTest == null) {
+        this.javaPackageTest = this.javaPackage;
+      }
     }
+  }
 
-    protected void init2nPassNamesWithDefaults() {
-        if (tableName == null) {
-            tableName = DaoUtil.dbName(className);
-        }
-
-        if (classNameDao == null) {
-            classNameDao = className + "Dao";
-        }
-        if (classNameTest == null) {
-            classNameTest = className + "Test";
-        }
-
-        if (javaPackage == null) {
-            javaPackage = schema.getDefaultJavaPackage();
+  protected void init2ndPassIndexNamesWithDefaults() {
+    for (int i = 0; i < this.indexes.size(); i++) {
+      Index index = this.indexes.get(i);
+      if (index.getName() == null) {
+        String indexName = "IDX_" + this.getTableName();
+        List<Property> properties = index.getProperties();
+        for (int j = 0; j < properties.size(); j++) {
+          Property property = properties.get(j);
+          indexName += "_" + property.getColumnName();
+          if ("DESC".equalsIgnoreCase(index.getPropertiesOrder().get(j))) {
+            indexName += "_DESC";
+          }
         }
-
-        if (javaPackageDao == null) {
-            javaPackageDao = schema.getDefaultJavaPackageDao();
-            if (javaPackageDao == null) {
-                javaPackageDao = javaPackage;
-            }
-        }
-        if (javaPackageTest == null) {
-            javaPackageTest = schema.getDefaultJavaPackageTest();
-            if (javaPackageTest == null) {
-                javaPackageTest = javaPackage;
-            }
+        // TODO can this get too long? how to shorten reliably without depending
+        // on the order (i)
+        index.setName(indexName);
+      }
+    }
+  }
+
+  void init3ndPass() {
+    for (Property property : this.properties) {
+      property.init3ndPass();
+    }
+
+    this.init3rdPassRelations();
+    this.init3rdPassAdditionalImports();
+  }
+
+  private void init3rdPassRelations() {
+    Set<String> toOneNames = new HashSet<String>();
+    for (ToOne toOne : this.toOneRelations) {
+      toOne.init3ndPass();
+      if (!toOneNames.add(toOne.getName().toLowerCase())) {
+        throw new RuntimeException("Duplicate name for " + toOne);
+      }
+    }
+
+    Set<String> toManyNames = new HashSet<String>();
+    for (ToMany toMany : this.toManyRelations) {
+      toMany.init3ndPass();
+      Entity targetEntity = toMany.getTargetEntity();
+      for (Property targetProperty : toMany.getTargetProperties()) {
+        if (!targetEntity.propertiesColumns.contains(targetProperty)) {
+          targetEntity.propertiesColumns.add(targetProperty);
         }
+      }
+      if (!toManyNames.add(toMany.getName().toLowerCase())) {
+        throw new RuntimeException("Duplicate name for " + toMany);
+      }
     }
+  }
 
-    protected void init2ndPassIndexNamesWithDefaults() {
-        for (int i = 0; i < indexes.size(); i++) {
-            Index index = indexes.get(i);
-            if (index.getName() == null) {
-                String indexName = "IDX_" + getTableName();
-                List<Property> properties = index.getProperties();
-                for (int j = 0; j < properties.size(); j++) {
-                    Property property = properties.get(j);
-                    indexName += "_" + property.getColumnName();
-                    if ("DESC".equalsIgnoreCase(index.getPropertiesOrder().get(j))) {
-                        indexName += "_DESC";
-                    }
-                }
-                // TODO can this get too long? how to shorten reliably without depending on the order (i)
-                index.setName(indexName);
-            }
-        }
+  private void init3rdPassAdditionalImports() {
+    if (this.active && !this.javaPackage.equals(this.javaPackageDao)) {
+      this.additionalImportsEntity.add(this.javaPackageDao + "." + this.classNameDao);
     }
 
-    void init3ndPass() {
-        for (Property property : properties) {
-            property.init3ndPass();
-        }
-
-        init3rdPassRelations();
-        init3rdPassAdditionalImports();
+    for (ToOne toOne : this.toOneRelations) {
+      Entity targetEntity = toOne.getTargetEntity();
+      this.checkAdditionalImportsEntityTargetEntity(targetEntity);
+      // For deep loading
+      if (!targetEntity.getJavaPackage().equals(this.javaPackageDao)) {
+        this.additionalImportsDao.add(targetEntity.getJavaPackage() + "." + targetEntity.getClassName());
+      }
     }
 
-    private void init3rdPassRelations() {
-        Set<String> toOneNames = new HashSet<String>();
-        for (ToOne toOne : toOneRelations) {
-            toOne.init3ndPass();
-            if (!toOneNames.add(toOne.getName().toLowerCase())) {
-                throw new RuntimeException("Duplicate name for " + toOne);
-            }
-        }
-
-        Set<String> toManyNames = new HashSet<String>();
-        for (ToMany toMany : toManyRelations) {
-            toMany.init3ndPass();
-            Entity targetEntity = toMany.getTargetEntity();
-            for (Property targetProperty : toMany.getTargetProperties()) {
-                if (!targetEntity.propertiesColumns.contains(targetProperty)) {
-                    targetEntity.propertiesColumns.add(targetProperty);
-                }
-            }
-            if (!toManyNames.add(toMany.getName().toLowerCase())) {
-                throw new RuntimeException("Duplicate name for " + toMany);
-            }
-        }
+    for (ToMany toMany : this.toManyRelations) {
+      Entity targetEntity = toMany.getTargetEntity();
+      this.checkAdditionalImportsEntityTargetEntity(targetEntity);
     }
+  }
 
-    private void init3rdPassAdditionalImports() {
-        if (active && !javaPackage.equals(javaPackageDao)) {
-            additionalImportsEntity.add(javaPackageDao + "." + classNameDao);
-        }
-
-        for (ToOne toOne : toOneRelations) {
-            Entity targetEntity = toOne.getTargetEntity();
-            checkAdditionalImportsEntityTargetEntity(targetEntity);
-            // For deep loading
-            if (!targetEntity.getJavaPackage().equals(javaPackageDao)) {
-                additionalImportsDao.add(targetEntity.getJavaPackage() + "." + targetEntity.getClassName());
-            }
-        }
-
-        for (ToMany toMany : toManyRelations) {
-            Entity targetEntity = toMany.getTargetEntity();
-            checkAdditionalImportsEntityTargetEntity(targetEntity);
-        }
+  private void checkAdditionalImportsEntityTargetEntity(Entity targetEntity) {
+    if (!targetEntity.getJavaPackage().equals(this.javaPackage)) {
+      this.additionalImportsEntity.add(targetEntity.getJavaPackage() + "." + targetEntity.getClassName());
     }
-
-    private void checkAdditionalImportsEntityTargetEntity(Entity targetEntity) {
-        if (!targetEntity.getJavaPackage().equals(javaPackage)) {
-            additionalImportsEntity.add(targetEntity.getJavaPackage() + "." + targetEntity.getClassName());
-        }
-        if (!targetEntity.getJavaPackageDao().equals(javaPackage)) {
-            additionalImportsEntity.add(targetEntity.getJavaPackageDao() + "." + targetEntity.getClassNameDao());
-        }
+    if (!targetEntity.getJavaPackageDao().equals(this.javaPackage)) {
+      this.additionalImportsEntity.add(targetEntity.getJavaPackageDao() + "." + targetEntity.getClassNameDao());
     }
+  }
 
-    public void validatePropertyExists(Property property) {
-        if (!properties.contains(property)) {
-            throw new RuntimeException("Property " + property + " does not exist in " + this);
-        }
+  public void validatePropertyExists(Property property) {
+    if (!this.properties.contains(property)) {
+      throw new RuntimeException("Property " + property + " does not exist in " + this);
     }
+  }
 
-    @Override
-    public String toString() {
-        return "Entity " + className + " (package: " + javaPackage + ")";
-    }
+  @Override
+  public String toString() {
+    return "Entity " + this.className + " (package: " + this.javaPackage + ")";
+  }
 }
diff --git a/DaoTest/.classpath b/DaoTest/.classpath
index 96ce885e..6e692568 100644
--- a/DaoTest/.classpath
+++ b/DaoTest/.classpath
@@ -1,9 +1,10 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="src" path="src-gen"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="src" path="src-gen"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ChildclassEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/ChildclassEntity.java
new file mode 100644
index 00000000..0e9c601b
--- /dev/null
+++ b/DaoTest/src-gen/de/greenrobot/daotest/ChildclassEntity.java
@@ -0,0 +1,40 @@
+package de.greenrobot.daotest;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table CHILDCLASS_ENTITY.
+ */
+public class ChildclassEntity {
+
+    private Long id;
+    private String text;
+
+    public ChildclassEntity() {
+    }
+
+    public ChildclassEntity(Long id) {
+        this.id = id;
+    }
+
+    public ChildclassEntity(Long id, String text) {
+        this.id = id;
+        this.text = text;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public String getText() {
+        return text;
+    }
+
+    public void setText(String text) {
+        this.text = text;
+    }
+
+}
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ChildclassEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/ChildclassEntityDao.java
new file mode 100644
index 00000000..c1576b2a
--- /dev/null
+++ b/DaoTest/src-gen/de/greenrobot/daotest/ChildclassEntityDao.java
@@ -0,0 +1,113 @@
+package de.greenrobot.daotest;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daotest.TestChildclass;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table CHILDCLASS_ENTITY.
+*/
+public class ChildclassEntityDao extends AbstractDao<TestChildclass, Long> {
+
+    public static final String TABLENAME = "CHILDCLASS_ENTITY";
+
+    /**
+     * Properties of entity ChildclassEntity.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property Text = new Property(1, String.class, "text", false, "TEXT");
+    };
+
+
+    public ChildclassEntityDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public ChildclassEntityDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'CHILDCLASS_ENTITY' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'TEXT' TEXT);"); // 1: text
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'CHILDCLASS_ENTITY'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, TestChildclass entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+ 
+        String text = entity.getText();
+        if (text != null) {
+            stmt.bindString(2, text);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public TestChildclass readEntity(Cursor cursor, int offset) {
+        TestChildclass entity = new TestChildclass();
+        readEntity(cursor, entity, offset);
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, TestChildclass entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setText(cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(TestChildclass entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(TestChildclass entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java b/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java
index b68069c5..f959538d 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java
@@ -20,6 +20,7 @@
 import de.greenrobot.daotest.TreeEntityDao;
 import de.greenrobot.daotest.AnActiveEntityDao;
 import de.greenrobot.daotest.ExtendsImplementsEntityDao;
+import de.greenrobot.daotest.ChildclassEntityDao;
 import de.greenrobot.daotest.StringKeyValueEntityDao;
 import de.greenrobot.daotest.AutoincrementEntityDao;
 import de.greenrobot.daotest.SqliteMasterDao;
@@ -45,6 +46,7 @@ public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
         TreeEntityDao.createTable(db, ifNotExists);
         AnActiveEntityDao.createTable(db, ifNotExists);
         ExtendsImplementsEntityDao.createTable(db, ifNotExists);
+        ChildclassEntityDao.createTable(db, ifNotExists);
         StringKeyValueEntityDao.createTable(db, ifNotExists);
         AutoincrementEntityDao.createTable(db, ifNotExists);
     }
@@ -63,6 +65,7 @@ public static void dropAllTables(SQLiteDatabase db, boolean ifExists) {
         TreeEntityDao.dropTable(db, ifExists);
         AnActiveEntityDao.dropTable(db, ifExists);
         ExtendsImplementsEntityDao.dropTable(db, ifExists);
+        ChildclassEntityDao.dropTable(db, ifExists);
         StringKeyValueEntityDao.dropTable(db, ifExists);
         AutoincrementEntityDao.dropTable(db, ifExists);
     }
@@ -108,6 +111,7 @@ public DaoMaster(SQLiteDatabase db) {
         registerDaoClass(TreeEntityDao.class);
         registerDaoClass(AnActiveEntityDao.class);
         registerDaoClass(ExtendsImplementsEntityDao.class);
+        registerDaoClass(ChildclassEntityDao.class);
         registerDaoClass(StringKeyValueEntityDao.class);
         registerDaoClass(AutoincrementEntityDao.class);
         registerDaoClass(SqliteMasterDao.class);
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java b/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java
index 0a9a8e95..d0c0853a 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java
@@ -21,6 +21,7 @@
 import de.greenrobot.daotest.TreeEntity;
 import de.greenrobot.daotest.AnActiveEntity;
 import de.greenrobot.daotest.ExtendsImplementsEntity;
+import de.greenrobot.daotest.TestChildclass;
 import de.greenrobot.daotest.StringKeyValueEntity;
 import de.greenrobot.daotest.AutoincrementEntity;
 import de.greenrobot.daotest.SqliteMaster;
@@ -37,6 +38,7 @@
 import de.greenrobot.daotest.TreeEntityDao;
 import de.greenrobot.daotest.AnActiveEntityDao;
 import de.greenrobot.daotest.ExtendsImplementsEntityDao;
+import de.greenrobot.daotest.ChildclassEntityDao;
 import de.greenrobot.daotest.StringKeyValueEntityDao;
 import de.greenrobot.daotest.AutoincrementEntityDao;
 import de.greenrobot.daotest.SqliteMasterDao;
@@ -62,6 +64,7 @@
     private final DaoConfig treeEntityDaoConfig;
     private final DaoConfig anActiveEntityDaoConfig;
     private final DaoConfig extendsImplementsEntityDaoConfig;
+    private final DaoConfig childclassEntityDaoConfig;
     private final DaoConfig stringKeyValueEntityDaoConfig;
     private final DaoConfig autoincrementEntityDaoConfig;
     private final DaoConfig sqliteMasterDaoConfig;
@@ -78,6 +81,7 @@
     private final TreeEntityDao treeEntityDao;
     private final AnActiveEntityDao anActiveEntityDao;
     private final ExtendsImplementsEntityDao extendsImplementsEntityDao;
+    private final ChildclassEntityDao childclassEntityDao;
     private final StringKeyValueEntityDao stringKeyValueEntityDao;
     private final AutoincrementEntityDao autoincrementEntityDao;
     private final SqliteMasterDao sqliteMasterDao;
@@ -122,6 +126,9 @@ public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends
         extendsImplementsEntityDaoConfig = daoConfigMap.get(ExtendsImplementsEntityDao.class).clone();
         extendsImplementsEntityDaoConfig.initIdentityScope(type);
 
+        childclassEntityDaoConfig = daoConfigMap.get(ChildclassEntityDao.class).clone();
+        childclassEntityDaoConfig.initIdentityScope(type);
+
         stringKeyValueEntityDaoConfig = daoConfigMap.get(StringKeyValueEntityDao.class).clone();
         stringKeyValueEntityDaoConfig.initIdentityScope(type);
 
@@ -143,6 +150,7 @@ public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends
         treeEntityDao = new TreeEntityDao(treeEntityDaoConfig, this);
         anActiveEntityDao = new AnActiveEntityDao(anActiveEntityDaoConfig, this);
         extendsImplementsEntityDao = new ExtendsImplementsEntityDao(extendsImplementsEntityDaoConfig, this);
+        childclassEntityDao = new ChildclassEntityDao(childclassEntityDaoConfig, this);
         stringKeyValueEntityDao = new StringKeyValueEntityDao(stringKeyValueEntityDaoConfig, this);
         autoincrementEntityDao = new AutoincrementEntityDao(autoincrementEntityDaoConfig, this);
         sqliteMasterDao = new SqliteMasterDao(sqliteMasterDaoConfig, this);
@@ -159,6 +167,7 @@ public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends
         registerDao(TreeEntity.class, treeEntityDao);
         registerDao(AnActiveEntity.class, anActiveEntityDao);
         registerDao(ExtendsImplementsEntity.class, extendsImplementsEntityDao);
+        registerDao(TestChildclass.class, childclassEntityDao);
         registerDao(StringKeyValueEntity.class, stringKeyValueEntityDao);
         registerDao(AutoincrementEntity.class, autoincrementEntityDao);
         registerDao(SqliteMaster.class, sqliteMasterDao);
@@ -177,6 +186,7 @@ public void clear() {
         treeEntityDaoConfig.getIdentityScope().clear();
         anActiveEntityDaoConfig.getIdentityScope().clear();
         extendsImplementsEntityDaoConfig.getIdentityScope().clear();
+        childclassEntityDaoConfig.getIdentityScope().clear();
         stringKeyValueEntityDaoConfig.getIdentityScope().clear();
         autoincrementEntityDaoConfig.getIdentityScope().clear();
         sqliteMasterDaoConfig.getIdentityScope().clear();
@@ -230,6 +240,10 @@ public ExtendsImplementsEntityDao getExtendsImplementsEntityDao() {
         return extendsImplementsEntityDao;
     }
 
+    public ChildclassEntityDao getChildclassEntityDao() {
+        return childclassEntityDao;
+    }
+
     public StringKeyValueEntityDao getStringKeyValueEntityDao() {
         return stringKeyValueEntityDao;
     }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/RelationEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/RelationEntityDao.java
index 4f09837e..e98cf0e2 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/RelationEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/RelationEntityDao.java
@@ -149,118 +149,118 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
-    private String selectDeep;
-
-    protected String getSelectDeep() {
-        if (selectDeep == null) {
-            StringBuilder builder = new StringBuilder("SELECT ");
-            SqlUtils.appendColumns(builder, "T", getAllColumns());
-            builder.append(',');
-            SqlUtils.appendColumns(builder, "T0", daoSession.getRelationEntityDao().getAllColumns());
-            builder.append(',');
-            SqlUtils.appendColumns(builder, "T1", daoSession.getTestEntityDao().getAllColumns());
-            builder.append(',');
-            SqlUtils.appendColumns(builder, "T2", daoSession.getTestEntityDao().getAllColumns());
-            builder.append(',');
-            SqlUtils.appendColumns(builder, "T3", daoSession.getTestEntityDao().getAllColumns());
-            builder.append(" FROM RELATION_ENTITY T");
-            builder.append(" LEFT JOIN RELATION_ENTITY T0 ON T.'PARENT_ID'=T0.'_id'");
-            builder.append(" LEFT JOIN TEST_ENTITY T1 ON T.'TEST_ID'=T1.'_id'");
-            builder.append(" LEFT JOIN TEST_ENTITY T2 ON T.'TEST_ID_NOT_NULL'=T2.'_id'");
-            builder.append(" LEFT JOIN TEST_ENTITY T3 ON T.'WITHOUT_PROPERTY_TEST_ID'=T3.'_id'");
-            builder.append(' ');
-            selectDeep = builder.toString();
-        }
-        return selectDeep;
-    }
-    
-    protected RelationEntity loadCurrentDeep(Cursor cursor, boolean lock) {
-        RelationEntity entity = loadCurrent(cursor, 0, lock);
-        int offset = getAllColumns().length;
-
-        RelationEntity parent = loadCurrentOther(daoSession.getRelationEntityDao(), cursor, offset);
-        entity.setParent(parent);
-        offset += daoSession.getRelationEntityDao().getAllColumns().length;
-
-        TestEntity testEntity = loadCurrentOther(daoSession.getTestEntityDao(), cursor, offset);
-        entity.setTestEntity(testEntity);
-        offset += daoSession.getTestEntityDao().getAllColumns().length;
-
-        TestEntity testNotNull = loadCurrentOther(daoSession.getTestEntityDao(), cursor, offset);
-         if(testNotNull != null) {
-            entity.setTestNotNull(testNotNull);
-        }
-        offset += daoSession.getTestEntityDao().getAllColumns().length;
-
-        TestEntity testWithoutProperty = loadCurrentOther(daoSession.getTestEntityDao(), cursor, offset);
-        entity.setTestWithoutProperty(testWithoutProperty);
-
-        return entity;    
-    }
-
-    public RelationEntity loadDeep(Long key) {
-        assertSinglePk();
-        if (key == null) {
-            return null;
-        }
-
-        StringBuilder builder = new StringBuilder(getSelectDeep());
-        builder.append("WHERE ");
-        SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
-        String sql = builder.toString();
-        
-        String[] keyArray = new String[] { key.toString() };
-        Cursor cursor = db.rawQuery(sql, keyArray);
-        
-        try {
-            boolean available = cursor.moveToFirst();
-            if (!available) {
-                return null;
-            } else if (!cursor.isLast()) {
-                throw new IllegalStateException("Expected unique result, but count was " + cursor.getCount());
-            }
-            return loadCurrentDeep(cursor, true);
-        } finally {
-            cursor.close();
-        }
-    }
-    
-    /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. */
-    public List<RelationEntity> loadAllDeepFromCursor(Cursor cursor) {
-        int count = cursor.getCount();
-        List<RelationEntity> list = new ArrayList<RelationEntity>(count);
-        
-        if (cursor.moveToFirst()) {
-            if (identityScope != null) {
-                identityScope.lock();
-                identityScope.reserveRoom(count);
-            }
-            try {
-                do {
-                    list.add(loadCurrentDeep(cursor, false));
-                } while (cursor.moveToNext());
-            } finally {
-                if (identityScope != null) {
-                    identityScope.unlock();
-                }
-            }
-        }
-        return list;
-    }
-    
-    protected List<RelationEntity> loadDeepAllAndCloseCursor(Cursor cursor) {
-        try {
-            return loadAllDeepFromCursor(cursor);
-        } finally {
-            cursor.close();
-        }
-    }
-    
-
-    /** A raw-style query where you can pass any WHERE clause and arguments. */
-    public List<RelationEntity> queryDeep(String where, String... selectionArg) {
-        Cursor cursor = db.rawQuery(getSelectDeep() + where, selectionArg);
-        return loadDeepAllAndCloseCursor(cursor);
-    }
- 
+    private String selectDeep;
+
+    protected String getSelectDeep() {
+        if (selectDeep == null) {
+            StringBuilder builder = new StringBuilder("SELECT ");
+            SqlUtils.appendColumns(builder, "T", getAllColumns());
+            builder.append(',');
+            SqlUtils.appendColumns(builder, "T0", daoSession.getRelationEntityDao().getAllColumns());
+            builder.append(',');
+            SqlUtils.appendColumns(builder, "T1", daoSession.getTestEntityDao().getAllColumns());
+            builder.append(',');
+            SqlUtils.appendColumns(builder, "T2", daoSession.getTestEntityDao().getAllColumns());
+            builder.append(',');
+            SqlUtils.appendColumns(builder, "T3", daoSession.getTestEntityDao().getAllColumns());
+            builder.append(" FROM RELATION_ENTITY T");
+            builder.append(" LEFT JOIN RELATION_ENTITY T0 ON T.'PARENT_ID'=T0.'_id'");
+            builder.append(" LEFT JOIN TEST_ENTITY T1 ON T.'TEST_ID'=T1.'_id'");
+            builder.append(" LEFT JOIN TEST_ENTITY T2 ON T.'TEST_ID_NOT_NULL'=T2.'_id'");
+            builder.append(" LEFT JOIN TEST_ENTITY T3 ON T.'WITHOUT_PROPERTY_TEST_ID'=T3.'_id'");
+            builder.append(' ');
+            selectDeep = builder.toString();
+        }
+        return selectDeep;
+    }
+    
+    protected RelationEntity loadCurrentDeep(Cursor cursor, boolean lock) {
+        RelationEntity entity = loadCurrent(cursor, 0, lock);
+        int offset = getAllColumns().length;
+
+        RelationEntity parent = loadCurrentOther(daoSession.getRelationEntityDao(), cursor, offset);
+        entity.setParent(parent);
+        offset += daoSession.getRelationEntityDao().getAllColumns().length;
+
+        TestEntity testEntity = loadCurrentOther(daoSession.getTestEntityDao(), cursor, offset);
+        entity.setTestEntity(testEntity);
+        offset += daoSession.getTestEntityDao().getAllColumns().length;
+
+        TestEntity testNotNull = loadCurrentOther(daoSession.getTestEntityDao(), cursor, offset);
+         if(testNotNull != null) {
+            entity.setTestNotNull(testNotNull);
+        }
+        offset += daoSession.getTestEntityDao().getAllColumns().length;
+
+        TestEntity testWithoutProperty = loadCurrentOther(daoSession.getTestEntityDao(), cursor, offset);
+        entity.setTestWithoutProperty(testWithoutProperty);
+
+        return entity;    
+    }
+
+    public RelationEntity loadDeep(Long key) {
+        assertSinglePk();
+        if (key == null) {
+            return null;
+        }
+
+        StringBuilder builder = new StringBuilder(getSelectDeep());
+        builder.append("WHERE ");
+        SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
+        String sql = builder.toString();
+        
+        String[] keyArray = new String[] { key.toString() };
+        Cursor cursor = db.rawQuery(sql, keyArray);
+        
+        try {
+            boolean available = cursor.moveToFirst();
+            if (!available) {
+                return null;
+            } else if (!cursor.isLast()) {
+                throw new IllegalStateException("Expected unique result, but count was " + cursor.getCount());
+            }
+            return loadCurrentDeep(cursor, true);
+        } finally {
+            cursor.close();
+        }
+    }
+    
+    /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. */
+    public List<RelationEntity> loadAllDeepFromCursor(Cursor cursor) {
+        int count = cursor.getCount();
+        List<RelationEntity> list = new ArrayList<RelationEntity>(count);
+        
+        if (cursor.moveToFirst()) {
+            if (identityScope != null) {
+                identityScope.lock();
+                identityScope.reserveRoom(count);
+            }
+            try {
+                do {
+                    list.add(loadCurrentDeep(cursor, false));
+                } while (cursor.moveToNext());
+            } finally {
+                if (identityScope != null) {
+                    identityScope.unlock();
+                }
+            }
+        }
+        return list;
+    }
+    
+    protected List<RelationEntity> loadDeepAllAndCloseCursor(Cursor cursor) {
+        try {
+            return loadAllDeepFromCursor(cursor);
+        } finally {
+            cursor.close();
+        }
+    }
+    
+
+    /** A raw-style query where you can pass any WHERE clause and arguments. */
+    public List<RelationEntity> queryDeep(String where, String... selectionArg) {
+        Cursor cursor = db.rawQuery(getSelectDeep() + where, selectionArg);
+        return loadDeepAllAndCloseCursor(cursor);
+    }
+ 
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/TreeEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/TreeEntityDao.java
index 14d3521a..0e0009b9 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/TreeEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/TreeEntityDao.java
@@ -141,95 +141,95 @@ protected boolean isEntityUpdateable() {
         return query.list();
     }
 
-    private String selectDeep;
-
-    protected String getSelectDeep() {
-        if (selectDeep == null) {
-            StringBuilder builder = new StringBuilder("SELECT ");
-            SqlUtils.appendColumns(builder, "T", getAllColumns());
-            builder.append(',');
-            SqlUtils.appendColumns(builder, "T0", daoSession.getTreeEntityDao().getAllColumns());
-            builder.append(" FROM TREE_ENTITY T");
-            builder.append(" LEFT JOIN TREE_ENTITY T0 ON T.'PARENT_ID'=T0.'_id'");
-            builder.append(' ');
-            selectDeep = builder.toString();
-        }
-        return selectDeep;
-    }
-    
-    protected TreeEntity loadCurrentDeep(Cursor cursor, boolean lock) {
-        TreeEntity entity = loadCurrent(cursor, 0, lock);
-        int offset = getAllColumns().length;
-
-        TreeEntity parent = loadCurrentOther(daoSession.getTreeEntityDao(), cursor, offset);
-        entity.setParent(parent);
-
-        return entity;    
-    }
-
-    public TreeEntity loadDeep(Long key) {
-        assertSinglePk();
-        if (key == null) {
-            return null;
-        }
-
-        StringBuilder builder = new StringBuilder(getSelectDeep());
-        builder.append("WHERE ");
-        SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
-        String sql = builder.toString();
-        
-        String[] keyArray = new String[] { key.toString() };
-        Cursor cursor = db.rawQuery(sql, keyArray);
-        
-        try {
-            boolean available = cursor.moveToFirst();
-            if (!available) {
-                return null;
-            } else if (!cursor.isLast()) {
-                throw new IllegalStateException("Expected unique result, but count was " + cursor.getCount());
-            }
-            return loadCurrentDeep(cursor, true);
-        } finally {
-            cursor.close();
-        }
-    }
-    
-    /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. */
-    public List<TreeEntity> loadAllDeepFromCursor(Cursor cursor) {
-        int count = cursor.getCount();
-        List<TreeEntity> list = new ArrayList<TreeEntity>(count);
-        
-        if (cursor.moveToFirst()) {
-            if (identityScope != null) {
-                identityScope.lock();
-                identityScope.reserveRoom(count);
-            }
-            try {
-                do {
-                    list.add(loadCurrentDeep(cursor, false));
-                } while (cursor.moveToNext());
-            } finally {
-                if (identityScope != null) {
-                    identityScope.unlock();
-                }
-            }
-        }
-        return list;
-    }
-    
-    protected List<TreeEntity> loadDeepAllAndCloseCursor(Cursor cursor) {
-        try {
-            return loadAllDeepFromCursor(cursor);
-        } finally {
-            cursor.close();
-        }
-    }
-    
-
-    /** A raw-style query where you can pass any WHERE clause and arguments. */
-    public List<TreeEntity> queryDeep(String where, String... selectionArg) {
-        Cursor cursor = db.rawQuery(getSelectDeep() + where, selectionArg);
-        return loadDeepAllAndCloseCursor(cursor);
-    }
- 
+    private String selectDeep;
+
+    protected String getSelectDeep() {
+        if (selectDeep == null) {
+            StringBuilder builder = new StringBuilder("SELECT ");
+            SqlUtils.appendColumns(builder, "T", getAllColumns());
+            builder.append(',');
+            SqlUtils.appendColumns(builder, "T0", daoSession.getTreeEntityDao().getAllColumns());
+            builder.append(" FROM TREE_ENTITY T");
+            builder.append(" LEFT JOIN TREE_ENTITY T0 ON T.'PARENT_ID'=T0.'_id'");
+            builder.append(' ');
+            selectDeep = builder.toString();
+        }
+        return selectDeep;
+    }
+    
+    protected TreeEntity loadCurrentDeep(Cursor cursor, boolean lock) {
+        TreeEntity entity = loadCurrent(cursor, 0, lock);
+        int offset = getAllColumns().length;
+
+        TreeEntity parent = loadCurrentOther(daoSession.getTreeEntityDao(), cursor, offset);
+        entity.setParent(parent);
+
+        return entity;    
+    }
+
+    public TreeEntity loadDeep(Long key) {
+        assertSinglePk();
+        if (key == null) {
+            return null;
+        }
+
+        StringBuilder builder = new StringBuilder(getSelectDeep());
+        builder.append("WHERE ");
+        SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
+        String sql = builder.toString();
+        
+        String[] keyArray = new String[] { key.toString() };
+        Cursor cursor = db.rawQuery(sql, keyArray);
+        
+        try {
+            boolean available = cursor.moveToFirst();
+            if (!available) {
+                return null;
+            } else if (!cursor.isLast()) {
+                throw new IllegalStateException("Expected unique result, but count was " + cursor.getCount());
+            }
+            return loadCurrentDeep(cursor, true);
+        } finally {
+            cursor.close();
+        }
+    }
+    
+    /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. */
+    public List<TreeEntity> loadAllDeepFromCursor(Cursor cursor) {
+        int count = cursor.getCount();
+        List<TreeEntity> list = new ArrayList<TreeEntity>(count);
+        
+        if (cursor.moveToFirst()) {
+            if (identityScope != null) {
+                identityScope.lock();
+                identityScope.reserveRoom(count);
+            }
+            try {
+                do {
+                    list.add(loadCurrentDeep(cursor, false));
+                } while (cursor.moveToNext());
+            } finally {
+                if (identityScope != null) {
+                    identityScope.unlock();
+                }
+            }
+        }
+        return list;
+    }
+    
+    protected List<TreeEntity> loadDeepAllAndCloseCursor(Cursor cursor) {
+        try {
+            return loadAllDeepFromCursor(cursor);
+        } finally {
+            cursor.close();
+        }
+    }
+    
+
+    /** A raw-style query where you can pass any WHERE clause and arguments. */
+    public List<TreeEntity> queryDeep(String where, String... selectionArg) {
+        Cursor cursor = db.rawQuery(getSelectDeep() + where, selectionArg);
+        return loadDeepAllAndCloseCursor(cursor);
+    }
+ 
 }
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java b/DaoTest/src-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java
index 107160bc..f4748a52 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java
@@ -128,95 +128,95 @@ protected boolean isEntityUpdateable() {
         return true;
     }
     
-    private String selectDeep;
-
-    protected String getSelectDeep() {
-        if (selectDeep == null) {
-            StringBuilder builder = new StringBuilder("SELECT ");
-            SqlUtils.appendColumns(builder, "T", getAllColumns());
-            builder.append(',');
-            SqlUtils.appendColumns(builder, "T0", daoSession.getToOneTarget2Dao().getAllColumns());
-            builder.append(" FROM RELATION_SOURCE2 T");
-            builder.append(" LEFT JOIN TO_ONE_TARGET2 T0 ON T.'TO_ONE_ID'=T0.'_id'");
-            builder.append(' ');
-            selectDeep = builder.toString();
-        }
-        return selectDeep;
-    }
-    
-    protected RelationSource2 loadCurrentDeep(Cursor cursor, boolean lock) {
-        RelationSource2 entity = loadCurrent(cursor, 0, lock);
-        int offset = getAllColumns().length;
-
-        ToOneTarget2 toOneTarget2 = loadCurrentOther(daoSession.getToOneTarget2Dao(), cursor, offset);
-        entity.setToOneTarget2(toOneTarget2);
-
-        return entity;    
-    }
-
-    public RelationSource2 loadDeep(Long key) {
-        assertSinglePk();
-        if (key == null) {
-            return null;
-        }
-
-        StringBuilder builder = new StringBuilder(getSelectDeep());
-        builder.append("WHERE ");
-        SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
-        String sql = builder.toString();
-        
-        String[] keyArray = new String[] { key.toString() };
-        Cursor cursor = db.rawQuery(sql, keyArray);
-        
-        try {
-            boolean available = cursor.moveToFirst();
-            if (!available) {
-                return null;
-            } else if (!cursor.isLast()) {
-                throw new IllegalStateException("Expected unique result, but count was " + cursor.getCount());
-            }
-            return loadCurrentDeep(cursor, true);
-        } finally {
-            cursor.close();
-        }
-    }
-    
-    /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. */
-    public List<RelationSource2> loadAllDeepFromCursor(Cursor cursor) {
-        int count = cursor.getCount();
-        List<RelationSource2> list = new ArrayList<RelationSource2>(count);
-        
-        if (cursor.moveToFirst()) {
-            if (identityScope != null) {
-                identityScope.lock();
-                identityScope.reserveRoom(count);
-            }
-            try {
-                do {
-                    list.add(loadCurrentDeep(cursor, false));
-                } while (cursor.moveToNext());
-            } finally {
-                if (identityScope != null) {
-                    identityScope.unlock();
-                }
-            }
-        }
-        return list;
-    }
-    
-    protected List<RelationSource2> loadDeepAllAndCloseCursor(Cursor cursor) {
-        try {
-            return loadAllDeepFromCursor(cursor);
-        } finally {
-            cursor.close();
-        }
-    }
-    
-
-    /** A raw-style query where you can pass any WHERE clause and arguments. */
-    public List<RelationSource2> queryDeep(String where, String... selectionArg) {
-        Cursor cursor = db.rawQuery(getSelectDeep() + where, selectionArg);
-        return loadDeepAllAndCloseCursor(cursor);
-    }
- 
+    private String selectDeep;
+
+    protected String getSelectDeep() {
+        if (selectDeep == null) {
+            StringBuilder builder = new StringBuilder("SELECT ");
+            SqlUtils.appendColumns(builder, "T", getAllColumns());
+            builder.append(',');
+            SqlUtils.appendColumns(builder, "T0", daoSession.getToOneTarget2Dao().getAllColumns());
+            builder.append(" FROM RELATION_SOURCE2 T");
+            builder.append(" LEFT JOIN TO_ONE_TARGET2 T0 ON T.'TO_ONE_ID'=T0.'_id'");
+            builder.append(' ');
+            selectDeep = builder.toString();
+        }
+        return selectDeep;
+    }
+    
+    protected RelationSource2 loadCurrentDeep(Cursor cursor, boolean lock) {
+        RelationSource2 entity = loadCurrent(cursor, 0, lock);
+        int offset = getAllColumns().length;
+
+        ToOneTarget2 toOneTarget2 = loadCurrentOther(daoSession.getToOneTarget2Dao(), cursor, offset);
+        entity.setToOneTarget2(toOneTarget2);
+
+        return entity;    
+    }
+
+    public RelationSource2 loadDeep(Long key) {
+        assertSinglePk();
+        if (key == null) {
+            return null;
+        }
+
+        StringBuilder builder = new StringBuilder(getSelectDeep());
+        builder.append("WHERE ");
+        SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
+        String sql = builder.toString();
+        
+        String[] keyArray = new String[] { key.toString() };
+        Cursor cursor = db.rawQuery(sql, keyArray);
+        
+        try {
+            boolean available = cursor.moveToFirst();
+            if (!available) {
+                return null;
+            } else if (!cursor.isLast()) {
+                throw new IllegalStateException("Expected unique result, but count was " + cursor.getCount());
+            }
+            return loadCurrentDeep(cursor, true);
+        } finally {
+            cursor.close();
+        }
+    }
+    
+    /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. */
+    public List<RelationSource2> loadAllDeepFromCursor(Cursor cursor) {
+        int count = cursor.getCount();
+        List<RelationSource2> list = new ArrayList<RelationSource2>(count);
+        
+        if (cursor.moveToFirst()) {
+            if (identityScope != null) {
+                identityScope.lock();
+                identityScope.reserveRoom(count);
+            }
+            try {
+                do {
+                    list.add(loadCurrentDeep(cursor, false));
+                } while (cursor.moveToNext());
+            } finally {
+                if (identityScope != null) {
+                    identityScope.unlock();
+                }
+            }
+        }
+        return list;
+    }
+    
+    protected List<RelationSource2> loadDeepAllAndCloseCursor(Cursor cursor) {
+        try {
+            return loadAllDeepFromCursor(cursor);
+        } finally {
+            cursor.close();
+        }
+    }
+    
+
+    /** A raw-style query where you can pass any WHERE clause and arguments. */
+    public List<RelationSource2> queryDeep(String where, String... selectionArg) {
+        Cursor cursor = db.rawQuery(getSelectDeep() + where, selectionArg);
+        return loadDeepAllAndCloseCursor(cursor);
+    }
+ 
 }
diff --git a/DaoTest/src/de/greenrobot/daotest/TestChildclass.java b/DaoTest/src/de/greenrobot/daotest/TestChildclass.java
new file mode 100644
index 00000000..2fdf13d4
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/TestChildclass.java
@@ -0,0 +1,5 @@
+package de.greenrobot.daotest;
+
+public class TestChildclass extends ChildclassEntity {
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/ChildclassEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/ChildclassEntityTest.java
new file mode 100644
index 00000000..f9a983fc
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/entity/ChildclassEntityTest.java
@@ -0,0 +1,27 @@
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+import de.greenrobot.daotest.ChildclassEntity;
+import de.greenrobot.daotest.ChildclassEntityDao;
+import de.greenrobot.daotest.TestChildclass;
+
+public class ChildclassEntityTest extends AbstractDaoTestLongPk<ChildclassEntityDao, TestChildclass> {
+
+  public ChildclassEntityTest() {
+    super(ChildclassEntityDao.class);
+  }
+
+  @Override
+  protected TestChildclass createEntity(Long key) {
+    TestChildclass entity = new TestChildclass();
+    entity.setId(key);
+    return entity;
+  }
+
+  public void testInheritance() {
+    TestChildclass entity = this.createEntityWithRandomPk();
+    assertTrue(entity instanceof TestChildclass);
+    assertTrue(entity instanceof ChildclassEntity);
+  }
+
+}
