diff --git a/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentTest.java b/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentTest.java
new file mode 100644
index 00000000..004a3d3d
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentTest.java
@@ -0,0 +1,550 @@
+package de.greenrobot.daotest;
+
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.SQLException;
+import java.util.concurrent.CountDownLatch;
+
+import android.os.SystemClock;
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.query.DeleteQuery;
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+
+public class DaoSessionConcurrentTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
+    class TestThread extends Thread {
+        final Runnable runnable;
+
+        public TestThread(Runnable runnable) {
+            this.runnable = runnable;
+        }
+
+        @Override
+        public void run() {
+            latchThreadsReady.countDown();
+            try {
+                latchInsideTx.await();
+            } catch (InterruptedException e) {
+                throw new RuntimeException(e);
+            }
+            runnable.run();
+            latchThreadsDone.countDown();
+        }
+
+    }
+
+    private final static int TIME_TO_WAIT_FOR_THREAD = 100; // Use 1000 to be on the safe side, 100 once stable
+
+    protected TestEntityDao dao;
+
+    protected CountDownLatch latchThreadsReady;
+    protected CountDownLatch latchInsideTx;
+    protected CountDownLatch latchThreadsDone;
+
+    public DaoSessionConcurrentTest() {
+        super(DaoMaster.class);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        dao = daoSession.getTestEntityDao();
+    }
+
+    protected void initThreads(Runnable... runnables) throws InterruptedException {
+        latchThreadsReady = new CountDownLatch(runnables.length);
+        latchInsideTx = new CountDownLatch(1);
+        latchThreadsDone = new CountDownLatch(runnables.length);
+        for (Runnable runnable : runnables) {
+            new TestThread(runnable).start();
+        }
+        latchThreadsReady.await();
+    }
+
+    public void testConcurrentInsertDuringTx() throws InterruptedException, SQLException {
+        Runnable runnable1 = new Runnable() {
+            @Override
+            public void run() {
+                try
+				{
+					dao.insert(createEntity(null));
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
+            }
+        };
+        Runnable runnable2 = new Runnable() {
+            @Override
+            public void run() {
+                try
+				{
+					dao.insertInTx(createEntity(null));
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
+            }
+        };
+        Runnable runnable3 = new Runnable() {
+            @Override
+            public void run() {
+                try
+				{
+					daoSession.runInTx(new Runnable() {
+					    @Override
+					    public void run() {
+					        try
+							{
+								dao.insert(createEntity(null));
+							}
+							catch ( SQLException e )
+							{
+								e.printStackTrace();
+							}
+					    }
+					});
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
+            }
+        };
+        Runnable runnable4 = new Runnable() {
+            @Override
+            public void run() {
+                try
+				{
+					dao.insertWithoutSettingPk(createEntity(null));
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
+            }
+        };
+        Runnable runnable5 = new Runnable() {
+            @Override
+            public void run() {
+                try
+				{
+					dao.insertOrReplace(createEntity(null));
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
+            }
+        };
+        initThreads(runnable1, runnable2, runnable3, runnable4, runnable5);
+        // Builds the statement so it is ready immediately in the thread
+        dao.insert(createEntity(null));
+        doTx(new Runnable() {
+            @Override
+            public void run() {
+                try
+				{
+					dao.insert(createEntity(null));
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
+            }
+        });
+        latchThreadsDone.await();
+        assertEquals(7, dao.count());
+    }
+
+    public void testConcurrentUpdateDuringTx() throws InterruptedException, SQLException {
+        final TestEntity entity = createEntity(null);
+        dao.insert(entity);
+        Runnable runnable1 = new Runnable() {
+            @Override
+            public void run() {
+                try
+				{
+					dao.update(entity);
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
+            }
+        };
+        Runnable runnable2 = new Runnable() {
+            @Override
+            public void run() {
+                try
+				{
+					dao.updateInTx(entity);
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
+            }
+        };
+        Runnable runnable3 = new Runnable() {
+            @Override
+            public void run() {
+                try
+				{
+					daoSession.runInTx(new Runnable() {
+					    @Override
+					    public void run() {
+					        try
+							{
+								dao.update(entity);
+							}
+							catch ( SQLException e )
+							{
+								e.printStackTrace();
+							}
+					    }
+					});
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
+            }
+        };
+        initThreads(runnable1, runnable2, runnable3);
+        // Builds the statement so it is ready immediately in the thread
+        dao.update(entity);
+        doTx(new Runnable() {
+            @Override
+            public void run() {
+                try
+				{
+					dao.update(entity);
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
+            }
+        });
+        latchThreadsDone.await();
+    }
+
+    public void testConcurrentDeleteDuringTx() throws InterruptedException, SQLException {
+        final TestEntity entity = createEntity(null);
+        dao.insert(entity);
+        Runnable runnable1 = new Runnable() {
+            @Override
+            public void run() {
+                try
+				{
+					dao.delete(entity);
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
+            }
+        };
+        Runnable runnable2 = new Runnable() {
+            @Override
+            public void run() {
+                try
+				{
+					dao.deleteInTx(entity);
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
+            }
+        };
+        Runnable runnable3 = new Runnable() {
+            @Override
+            public void run() {
+                try
+				{
+					daoSession.runInTx(new Runnable() {
+					    @Override
+					    public void run() {
+					        try
+							{
+								dao.delete(entity);
+							}
+							catch ( SQLException e )
+							{
+								e.printStackTrace();
+							}
+					    }
+					});
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
+            }
+        };
+        initThreads(runnable1, runnable2, runnable3);
+        // Builds the statement so it is ready immediately in the thread
+        dao.delete(entity);
+        doTx(new Runnable() {
+            @Override
+            public void run() {
+                try
+				{
+					dao.delete(entity);
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
+            }
+        });
+        latchThreadsDone.await();
+    }
+
+    // Query doesn't involve any statement locking currently, but just to stay on the safe side...
+    public void testConcurrentQueryDuringTx() throws InterruptedException, SQLException {
+        final TestEntity entity = createEntity(null);
+        dao.insert(entity);
+        final Query<TestEntity> query = dao.queryBuilder().build();
+        Runnable runnable1 = new Runnable() {
+            @Override
+            public void run() {
+                try
+				{
+					query.forCurrentThread().list();
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
+            }
+        };
+
+        initThreads(runnable1);
+        // Builds the statement so it is ready immediately in the thread
+        query.list();
+        doTx(new Runnable() {
+            @Override
+            public void run() {
+                try
+				{
+					query.list();
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
+            }
+        });
+        latchThreadsDone.await();
+    }
+
+    // No connection for read can be acquired while TX is active; this will deadlock!
+    public void _testConcurrentLockAndQueryDuringTx() throws InterruptedException, SQLException {
+        final TestEntity entity = createEntity(null);
+        dao.insert(entity);
+        final Query<TestEntity> query = dao.queryBuilder().build();
+        Runnable runnable1 = new Runnable() {
+            @Override
+            public void run() {
+                synchronized (query) {
+                    try
+					{
+						query.list();
+					}
+					catch ( SQLException e )
+					{
+						e.printStackTrace();
+					}
+                }
+            }
+        };
+
+        initThreads(runnable1);
+        // Builds the statement so it is ready immediately in the thread
+        query.list();
+        doTx(new Runnable() {
+            @Override
+            public void run() {
+                synchronized (query) {
+                    try
+					{
+						query.list();
+					}
+					catch ( SQLException e )
+					{
+						e.printStackTrace();
+					}
+                }
+            }
+        });
+        latchThreadsDone.await();
+    }
+
+    public void testConcurrentDeleteQueryDuringTx() throws InterruptedException, SQLException {
+        final TestEntity entity = createEntity(null);
+        dao.insert(entity);
+        final DeleteQuery<TestEntity> query = dao.queryBuilder().buildDelete();
+        Runnable runnable1 = new Runnable() {
+            @Override
+            public void run() {
+                try
+				{
+					query.forCurrentThread().executeDeleteWithoutDetachingEntities();
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
+            }
+        };
+
+        initThreads(runnable1);
+        // Builds the statement so it is ready immediately in the thread
+        query.executeDeleteWithoutDetachingEntities();
+        doTx(new Runnable() {
+            @Override
+            public void run() {
+                try
+				{
+					query.executeDeleteWithoutDetachingEntities();
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
+            }
+        });
+        latchThreadsDone.await();
+    }
+
+    public void testConcurrentResolveToMany() throws InterruptedException, SQLException {
+        final ToManyEntity entity = new ToManyEntity();
+        ToManyEntityDao toManyDao = daoSession.getToManyEntityDao();
+        toManyDao.insert(entity);
+
+        Runnable runnable1 = new Runnable() {
+            @Override
+            public void run() {
+                try
+				{
+					entity.getToManyTargetEntityList();
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
+            }
+        };
+
+        initThreads(runnable1);
+        doTx(new Runnable() {
+            @Override
+            public void run() {
+                try
+				{
+					entity.getToManyTargetEntityList();
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
+            }
+        });
+        latchThreadsDone.await();
+    }
+
+    public void testConcurrentResolveToOne() throws InterruptedException, SQLException {
+        final TreeEntity entity = new TreeEntity();
+        TreeEntityDao toOneDao = daoSession.getTreeEntityDao();
+        toOneDao.insert(entity);
+
+        Runnable runnable1 = new Runnable() {
+            @Override
+            public void run() {
+                try
+				{
+					entity.getParent();
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
+            }
+        };
+
+        initThreads(runnable1);
+        doTx(new Runnable() {
+            @Override
+            public void run() {
+                try
+				{
+					entity.getParent();
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
+            }
+        });
+        latchThreadsDone.await();
+    }
+
+    /**
+     * We could put the statements inside ThreadLocals (fast enough), but it comes with initialization penalty for new
+     * threads and costs more memory.
+     */
+    public void _testThreadLocalSpeed() {
+        final Connection connection = dao.getConnection();
+        ThreadLocal<PreparedStatement> threadLocal = new ThreadLocal<PreparedStatement>() {
+            @Override
+            protected PreparedStatement initialValue() {
+                try
+				{
+					return connection.prepareStatement("SELECT 42");
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+					return null;
+				}
+            }
+        };
+        threadLocal.get();
+        long start = SystemClock.currentThreadTimeMillis();
+        for (int i = 0; i < 1000; i++) {
+        	PreparedStatement sqLiteStatement = threadLocal.get();
+            assertNotNull(sqLiteStatement);
+        }
+        Long time = SystemClock.currentThreadTimeMillis() - start;
+        DaoLog.d("TIME: " + time + "ms");
+        // Around 1ms on a S3
+        assertTrue(time < 10);
+    }
+
+    protected void doTx(final Runnable runnableInsideTx) throws SQLException {
+        daoSession.runInTx(new Runnable() {
+            @Override
+            public void run() {
+                latchInsideTx.countDown();
+                // Give the concurrent thread time so it will try to acquire locks
+                try {
+                    Thread.sleep(TIME_TO_WAIT_FOR_THREAD);
+                } catch (InterruptedException e) {
+                    throw new RuntimeException(e);
+                }
+                runnableInsideTx.run();
+            }
+        });
+    }
+
+    protected TestEntity createEntity(Long key) {
+        TestEntity entity = new TestEntity(key);
+        entity.setSimpleStringNotNull("green");
+        return entity;
+    }
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentWALTest.java b/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentWALTest.java
new file mode 100644
index 00000000..b870495d
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/DaoSessionConcurrentWALTest.java
@@ -0,0 +1,55 @@
+package de.greenrobot.daotest;
+
+
+public class DaoSessionConcurrentWALTest extends DaoSessionConcurrentTest {
+
+// FIXME is there a WriteAheadLogging on JDBC?
+//    @Override
+//    protected SQLiteDatabase createDatabase() {
+//        int MODE_ENABLE_WRITE_AHEAD_LOGGING = 8;
+//        getContext().deleteDatabase(DB_NAME);
+//        return getContext().openOrCreateDatabase(DB_NAME, MODE_ENABLE_WRITE_AHEAD_LOGGING, null);
+//    }
+//
+//    public void testConcurrentLockAndQueryDuringTxWAL() throws InterruptedException {
+//        if (Build.VERSION.SDK_INT >= 16) {
+//            try {
+//                Method method = db.getClass().getMethod("isWriteAheadLoggingEnabled");
+//                boolean walEnabled = (Boolean) method.invoke(db);
+//                if (!walEnabled) {
+//                    throw new RuntimeException("WAL is disabled. This test will deadlock without WAL");
+//                }
+//            } catch (Exception e) {
+//                throw new RuntimeException(e);
+//            }
+//        } else {
+//            DaoLog.e("Sorry, we need at least API level 16 for WAL");
+//            return;
+//        }
+//
+//        final TestEntity entity = createEntity(null);
+//        dao.insert(entity);
+//        final Query<TestEntity> query = dao.queryBuilder().build();
+//        Runnable runnable1 = new Runnable() {
+//            @Override
+//            public void run() {
+//                synchronized (query) {
+//                    query.forCurrentThread().list();
+//                }
+//            }
+//        };
+//
+//        initThreads(runnable1);
+//        // Builds the statement so it is ready immediately in the thread
+//        query.list();
+//        doTx(new Runnable() {
+//            @Override
+//            public void run() {
+//                synchronized (query) {
+//                    query.list();
+//                }
+//            }
+//        });
+//        latchThreadsDone.await();
+//    }
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/DaoSessionTest.java b/DaoTest/src/de/greenrobot/daotest/DaoSessionTest.java
new file mode 100644
index 00000000..a2a2e041
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/DaoSessionTest.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest;
+
+import java.sql.SQLException;
+
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+
+public class DaoSessionTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
+
+    public DaoSessionTest() {
+        super(DaoMaster.class);
+    }
+
+    public void testInsertAndLoad() throws SQLException {
+        SimpleEntity entity = new SimpleEntity();
+        daoSession.insert(entity);
+        Long id = entity.getId();
+        assertNotNull(id);
+        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, id);
+        assertNotNull(entity2);
+    }
+
+    public void testIdentity() throws SQLException {
+        SimpleEntity entity = new SimpleEntity();
+        daoSession.insert(entity);
+        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, entity.getId());
+        SimpleEntity entity3 = daoSession.load(SimpleEntity.class, entity.getId());
+        assertSame(entity, entity2);
+        assertSame(entity, entity3);
+    }
+
+    public void testIdentityPerSession() throws SQLException {
+        SimpleEntity entity = new SimpleEntity();
+        daoSession.insert(entity);
+        DaoSession session2 = daoMaster.newSession();
+        SimpleEntity entity2 = session2.load(SimpleEntity.class, entity.getId());
+        assertNotSame(entity, entity2);
+    }
+
+    public void testSessionReset() throws SQLException {
+        SimpleEntity entity = new SimpleEntity();
+        daoSession.insert(entity);
+        daoSession.clear();
+        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, entity.getId());
+        assertNotSame(entity, entity2);
+    }
+}
\ No newline at end of file
diff --git a/DaoTest/src/de/greenrobot/daotest/DbTestTest.java b/DaoTest/src/de/greenrobot/daotest/DbTestTest.java
new file mode 100644
index 00000000..657408fc
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/DbTestTest.java
@@ -0,0 +1,117 @@
+package de.greenrobot.daotest;
+
+import junit.framework.AssertionFailedError;
+import android.app.Application;
+import de.greenrobot.dao.test.DbTest;
+
+public class DbTestTest extends DbTest {
+    public static class MyApp extends Application {
+        static int onCreateCounterStatic;
+        static int onTerminateCounterStatic;
+
+        int onCreateCounter;
+        int onTerminateCounter;
+
+        @Override
+        public void onCreate() {
+            super.onCreate();
+            onCreateCounter++;
+            onCreateCounterStatic++;
+        }
+
+        @Override
+        public void onTerminate() {
+            super.onTerminate();
+            onTerminateCounterStatic++;
+            onTerminateCounter++;
+        }
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        MyApp.onCreateCounterStatic = 0;
+        MyApp.onTerminateCounterStatic = 0;
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        super.tearDown();
+        assertEquals(MyApp.onCreateCounterStatic, MyApp.onTerminateCounterStatic);
+    }
+
+    public void testCreateApplication() {
+        MyApp app = createApplication(MyApp.class);
+        assertNotNull(app);
+
+        assertEquals(1, app.onCreateCounter);
+        assertEquals(1, MyApp.onCreateCounterStatic);
+        assertEquals(0, app.onTerminateCounter);
+        assertEquals(0, MyApp.onTerminateCounterStatic);
+    }
+
+    public void testTerminateApplication() {
+        MyApp app = createApplication(MyApp.class);
+        terminateApplication();
+
+        assertEquals(1, app.onCreateCounter);
+        assertEquals(1, MyApp.onCreateCounterStatic);
+        assertEquals(1, app.onTerminateCounter);
+        assertEquals(1, MyApp.onTerminateCounterStatic);
+    }
+
+    public void testGetApplicationBeforeCreate() {
+        try {
+            getApplication();
+            fail("Should have thrown");
+        } catch (AssertionFailedError e) {
+            // Expected
+        }
+    }
+
+    public void testGetApplication() {
+        try {
+            getApplication();
+            fail("Should have thrown");
+        } catch (AssertionFailedError e) {
+            // Expected
+        }
+
+        MyApp app = createApplication(MyApp.class);
+        MyApp app2 = getApplication();
+        assertSame(app, app2);
+    }
+
+    public void testGetApplicationAfterTerminate() {
+        MyApp app = createApplication(MyApp.class);
+        terminateApplication();
+        try {
+            getApplication();
+            fail("Should have thrown");
+        } catch (AssertionFailedError e) {
+            // Expected
+        }
+    }
+
+
+    public void testMultipleApplications() {
+        MyApp app1 = createApplication(MyApp.class);
+        terminateApplication();
+
+        MyApp app2 = createApplication(MyApp.class);
+        assertNotSame(app2, app1);
+
+        MyApp app = getApplication();
+        assertSame(app2, app);
+
+        assertEquals(1, app1.onCreateCounter);
+        assertEquals(1, app1.onTerminateCounter);
+        assertEquals(1, app2.onCreateCounter);
+        assertEquals(0, app2.onTerminateCounter);
+
+        assertEquals(2, MyApp.onCreateCounterStatic);
+        assertEquals(1, MyApp.onTerminateCounterStatic);
+    }
+
+
+}
\ No newline at end of file
diff --git a/DaoTest/src/de/greenrobot/daotest/DbUtilsTest.java b/DaoTest/src/de/greenrobot/daotest/DbUtilsTest.java
new file mode 100644
index 00000000..0abfa312
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/DbUtilsTest.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest;
+
+import java.io.IOException;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+
+import de.greenrobot.dao.DbUtils;
+import de.greenrobot.dao.test.DbTest;
+
+public class DbUtilsTest extends DbTest {
+    public void testExecuteSqlScript() throws IOException, SQLException {
+        DbUtils.executeSqlScript(getContext(), connection, "minimal-entity.sql");
+        PreparedStatement statement = connection.prepareStatement( "SELECT count(*) from MINIMAL_ENTITY" );
+        ResultSet resultSet = statement.executeQuery();
+        try {
+            resultSet.next();
+            assertEquals(5, resultSet.getInt(1));
+        } finally {
+            statement.close();
+        }
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/IndexTest.java b/DaoTest/src/de/greenrobot/daotest/IndexTest.java
new file mode 100644
index 00000000..8549fc1d
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/IndexTest.java
@@ -0,0 +1,50 @@
+package de.greenrobot.daotest;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import junit.framework.Assert;
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.test.AbstractDaoTest;
+import de.greenrobot.daotest.SqliteMasterDao.Properties;
+
+public class IndexTest extends AbstractDaoTest<SqliteMasterDao, SqliteMaster, Long> {
+
+    public IndexTest() {
+        super(SqliteMasterDao.class);
+    }
+
+    public void testIndexesCreated() throws SQLException {
+        Assert.assertEquals(0, getIndexes().size());
+
+        TestEntityDao.createTable(connection, false);
+        List<SqliteMaster> indexes = getIndexes();
+        Assert.assertEquals(2, indexes.size());
+
+        SqliteMaster index1 = indexes.get(0);
+        SqliteMaster index2 = indexes.get(1);
+        Assert.assertEquals(TestEntityDao.TABLENAME, index1.getTableName());
+        Assert.assertEquals(TestEntityDao.TABLENAME, index2.getTableName());
+        Assert.assertEquals("IDX_TEST_ENTITY_INDEXED_STRING", index1.getName());
+        Assert.assertEquals("IDX_TEST_ENTITY_INDEXED_STRING_ASC_UNIQUE", index2.getName());
+
+        for (SqliteMaster index : indexes) {
+            DaoLog.v(index.toString());
+        }
+    }
+    
+    public void testIndexCreateIfNotExists() throws SQLException {
+        Assert.assertEquals(0, getIndexes().size());
+        TestEntityDao.createTable(connection, false);
+        Assert.assertEquals(2, getIndexes().size());
+        TestEntityDao.createTable(connection, true);
+        Assert.assertEquals(2, getIndexes().size());
+    }
+
+    private List<SqliteMaster> getIndexes() throws SQLException {
+        String where = "WHERE " + Properties.Type.columnName + "=? ORDER BY " + Properties.Name.columnName;
+        List<SqliteMaster> indexes = dao.queryRaw(where, "index");
+        return indexes;
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/LongHashMapTest.java b/DaoTest/src/de/greenrobot/daotest/LongHashMapTest.java
new file mode 100644
index 00000000..433658bd
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/LongHashMapTest.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest;
+
+import java.util.Random;
+
+import junit.framework.TestCase;
+import de.greenrobot.dao.internal.LongHashMap;
+
+public class LongHashMapTest extends TestCase {
+
+    Random random;
+    private String traceName;
+    private long start;
+
+    public LongHashMapTest() {
+        this.random = new Random();
+    }
+
+    public void testLongHashMapSimple() {
+        LongHashMap<Object> map = new LongHashMap<Object>();
+
+        map.put(1l << 33, "OK");
+        assertNull(map.get(0));
+        assertEquals("OK", map.get(1l << 33));
+
+        long keyLong = 0x7fffffffl << 33l + 14;
+        assertNull(map.remove(keyLong));
+        map.put(keyLong, "OK");
+        assertTrue(map.containsKey(keyLong));
+        assertEquals("OK", map.remove(keyLong));
+
+        keyLong = Long.MAX_VALUE;
+        map.put(keyLong, "OK");
+        assertTrue(map.containsKey(keyLong));
+
+        keyLong = 8064216579113853113l;
+        map.put(keyLong, "OK");
+        assertTrue(map.containsKey(keyLong));
+
+    }
+
+    public void testLongHashMapRandom() {
+        LongHashMap<Object> map = new LongHashMap<Object>();
+        for (int i = 0; i < 5000; i++) {
+            long key = random.nextLong();
+            String value = "Value-" + key;
+            map.put(key, value);
+            assertTrue("" + key, map.containsKey(key));
+
+            int keyInt = (int) key;
+            String valueInt = "Value-" + keyInt;
+            map.put(keyInt, valueInt);
+            assertTrue(map.containsKey(keyInt));
+
+            assertEquals(value, map.get(key));
+            assertEquals(valueInt, map.get(keyInt));
+
+            assertEquals(value, map.remove(key));
+            assertEquals(valueInt, map.remove(keyInt));
+
+            assertNull(map.get(key));
+            assertNull(map.get(keyInt));
+        }
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/TestInterface.java b/DaoTest/src/de/greenrobot/daotest/TestInterface.java
new file mode 100644
index 00000000..7c38baab
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/TestInterface.java
@@ -0,0 +1,5 @@
+package de.greenrobot.daotest;
+
+public interface TestInterface {
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/TestSuperclass.java b/DaoTest/src/de/greenrobot/daotest/TestSuperclass.java
new file mode 100644
index 00000000..8687b520
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/TestSuperclass.java
@@ -0,0 +1,5 @@
+package de.greenrobot.daotest;
+
+public class TestSuperclass {
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/async/AbstractAsyncTest.java b/DaoTest/src/de/greenrobot/daotest/async/AbstractAsyncTest.java
new file mode 100644
index 00000000..423733c0
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/async/AbstractAsyncTest.java
@@ -0,0 +1,47 @@
+package de.greenrobot.daotest.async;
+
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import de.greenrobot.dao.async.AsyncOperation;
+import de.greenrobot.dao.async.AsyncOperationListener;
+import de.greenrobot.dao.async.AsyncSession;
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+import de.greenrobot.daotest.DaoMaster;
+import de.greenrobot.daotest.DaoSession;
+
+public abstract class AbstractAsyncTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> implements
+        AsyncOperationListener {
+
+    protected AsyncSession asyncSession;
+    protected List<AsyncOperation> completedOperations;
+
+    public AbstractAsyncTest() {
+        super(DaoMaster.class);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        asyncSession = daoSession.startAsyncSession();
+        asyncSession.setListener(this);
+        completedOperations = new CopyOnWriteArrayList<AsyncOperation>();
+    }
+
+    public void assertWaitForCompletion1Sec() {
+        assertTrue(asyncSession.waitForCompletion(1000));
+        assertTrue(asyncSession.isCompleted());
+    }
+
+    @Override
+    public void onAsyncOperationCompleted(AsyncOperation operation) {
+        completedOperations.add(operation);
+    }
+
+    protected void assertSingleOperationCompleted(AsyncOperation operation) {
+        assertSame(operation, completedOperations.get(0));
+        assertEquals(1, completedOperations.size());
+        assertTrue(operation.isCompleted());
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/async/BasicAsyncTest.java b/DaoTest/src/de/greenrobot/daotest/async/BasicAsyncTest.java
new file mode 100644
index 00000000..db949788
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/async/BasicAsyncTest.java
@@ -0,0 +1,157 @@
+package de.greenrobot.daotest.async;
+
+import java.sql.SQLException;
+import java.util.concurrent.Callable;
+
+import android.os.Looper;
+import de.greenrobot.dao.async.AsyncDaoException;
+import de.greenrobot.dao.async.AsyncOperation;
+import de.greenrobot.dao.async.AsyncOperationListener;
+import de.greenrobot.daotest.SimpleEntity;
+
+public class BasicAsyncTest extends AbstractAsyncTest {
+
+    Thread txThread;
+    boolean testListenerMainThread_done;
+
+    public void testSequenceNumber() {
+        AsyncOperation op1 = asyncSession.count(SimpleEntity.class);
+        assertEquals(1, op1.getSequenceNumber());
+        AsyncOperation op2 = asyncSession.count(SimpleEntity.class);
+        assertEquals(2, op2.getSequenceNumber());
+    }
+
+    public void testWaitForCompletionNoOps() {
+        assertTrue(asyncSession.isCompleted());
+        assertTrue(asyncSession.waitForCompletion(1));
+        asyncSession.waitForCompletion();
+    }
+
+    public void testAsyncInsert() throws SQLException {
+        SimpleEntity entity = new SimpleEntity();
+        entity.setSimpleString("heho");
+        AsyncOperation operation = asyncSession.insert(entity);
+        assertWaitForCompletion1Sec();
+        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, entity.getId());
+        assertNotNull(entity2);
+        assertEquals("heho", entity2.getSimpleString());
+        assertFalse(operation.isFailed());
+        assertSingleOperationCompleted(operation);
+    }
+
+    public void testAsyncUpdate() throws SQLException {
+        SimpleEntity entity = new SimpleEntity();
+        entity.setSimpleString("heho");
+        daoSession.insert(entity);
+        entity.setSimpleString("updated");
+        AsyncOperation operation = asyncSession.update(entity);
+        assertWaitForCompletion1Sec();
+        daoSession.clear();
+        SimpleEntity entity2 = daoSession.load(SimpleEntity.class, entity.getId());
+        assertNotNull(entity2);
+        assertEquals("updated", entity2.getSimpleString());
+        assertFalse(operation.isFailed());
+        assertSingleOperationCompleted(operation);
+    }
+
+    public void testOperationGetResult() throws SQLException {
+        SimpleEntity entity = new SimpleEntity();
+        entity.setSimpleString("heho");
+        daoSession.insert(entity);
+        daoSession.clear();
+
+        AsyncOperation operation = asyncSession.load(SimpleEntity.class, entity.getId());
+        SimpleEntity result = (SimpleEntity) operation.getResult();
+        assertTrue(operation.isCompleted());
+        assertTrue(operation.isCompletedSucessfully());
+        assertNotNull(result);
+        assertNotSame(entity, result);
+        assertEquals(entity.getId(), result.getId());
+        assertEquals(entity.getSimpleString(), result.getSimpleString());
+    }
+
+    public void testOperationGetResultException() throws SQLException {
+        SimpleEntity entity = new SimpleEntity();
+        daoSession.insert(entity);
+        AsyncOperation operation = asyncSession.insert(entity);
+        try {
+            operation.getResult();
+            fail("getResult should have thrown");
+        } catch (AsyncDaoException expected) {
+            // OK
+        }
+        assertTrue(operation.isCompleted());
+        assertFalse(operation.isCompletedSucessfully());
+        assertTrue(operation.isFailed());
+    }
+
+    public void testAsyncException() throws SQLException {
+        SimpleEntity entity = new SimpleEntity();
+        daoSession.insert(entity);
+        AsyncOperation operation = asyncSession.insert(entity);
+        assertWaitForCompletion1Sec();
+        assertSingleOperationCompleted(operation);
+
+        assertTrue(operation.isFailed());
+        assertNotNull(operation.getThrowable());
+    }
+
+    public void testAsyncOperationWaitMillis() {
+        AsyncOperation operation = asyncSession.insert(new SimpleEntity());
+        assertTrue(asyncSession.waitForCompletion(1000));
+        assertSingleOperationCompleted(operation);
+    }
+
+    public void testAsyncOperationWait() {
+        AsyncOperation operation = asyncSession.insert(new SimpleEntity());
+        asyncSession.waitForCompletion();
+        assertSingleOperationCompleted(operation);
+    }
+
+    public void testAsyncRunInTx() {
+        AsyncOperation operation = asyncSession.runInTx(new Runnable() {
+
+            @Override
+            public void run() {
+                txThread = Thread.currentThread();
+            }
+        });
+        assertWaitForCompletion1Sec();
+        assertSingleOperationCompleted(operation);
+        assertNotNull(txThread);
+        assertFalse(Thread.currentThread().equals(txThread));
+    }
+
+    public void testAsynCallInTx() {
+        AsyncOperation operation = asyncSession.callInTx(new Callable<String>() {
+
+            @Override
+            public String call() throws Exception {
+                txThread = Thread.currentThread();
+                return "OK";
+            }
+        });
+        assertEquals("OK", operation.waitForCompletion());
+        assertNotNull(txThread);
+        assertFalse(Thread.currentThread().equals(txThread));
+    }
+
+    public void testListenerMainThread() throws InterruptedException {
+        AsyncOperationListener listener = new AsyncOperationListener() {
+            @Override
+            public synchronized void onAsyncOperationCompleted(AsyncOperation operation) {
+                assertEquals(Looper.getMainLooper(), Looper.myLooper());
+                testListenerMainThread_done = true;
+                notifyAll();
+            }
+        };
+        asyncSession.setListenerMainThread(listener);
+        asyncSession.insert(new SimpleEntity());
+        assertWaitForCompletion1Sec();
+        while (!testListenerMainThread_done) {
+            synchronized (listener) {
+                listener.wait();
+            }
+        }
+    }
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/async/MergeTxAsyncTest.java b/DaoTest/src/de/greenrobot/daotest/async/MergeTxAsyncTest.java
new file mode 100644
index 00000000..cdcc2a42
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/async/MergeTxAsyncTest.java
@@ -0,0 +1,32 @@
+package de.greenrobot.daotest.async;
+
+import java.sql.SQLException;
+
+import de.greenrobot.dao.async.AsyncOperation;
+import de.greenrobot.daotest.SimpleEntity;
+
+public class MergeTxAsyncTest extends AbstractAsyncTest {
+
+    public void testMergeInsertAndUpdate() throws SQLException {
+        SimpleEntity entity = new SimpleEntity();
+        entity.setId(42l);
+        entity.setSimpleString("heho");
+        
+        SimpleEntity entity2 = new SimpleEntity();
+        entity2.setId(42l);
+        entity2.setSimpleString("updated");
+        
+        AsyncOperation op1 = asyncSession.insert(entity, AsyncOperation.FLAG_MERGE_TX);
+        AsyncOperation op2 = asyncSession.update(entity2, AsyncOperation.FLAG_MERGE_TX);
+        
+        assertWaitForCompletion1Sec();
+        daoSession.clear();
+        SimpleEntity entity3 = daoSession.load(SimpleEntity.class, 42l);
+        assertNotNull(entity3);
+        assertEquals(entity2.getSimpleString(), entity3.getSimpleString());
+        
+        assertEquals(2, op1.getMergedOperationsCount());
+        assertEquals(2, op2.getMergedOperationsCount());
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/contentprovider/SimpleEntityContentProviderTest.java b/DaoTest/src/de/greenrobot/daotest/contentprovider/SimpleEntityContentProviderTest.java
new file mode 100644
index 00000000..ef319e62
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/contentprovider/SimpleEntityContentProviderTest.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.contentprovider;
+
+import java.sql.SQLException;
+
+import android.database.Cursor;
+import android.test.suitebuilder.annotation.Suppress;
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+import de.greenrobot.daotest.DaoMaster;
+import de.greenrobot.daotest.DaoSession;
+import de.greenrobot.daotest.SimpleEntity;
+import de.greenrobot.daotest.SimpleEntityContentProvider;
+import de.greenrobot.daotest.SimpleEntityDao;
+
+@Suppress
+// TODO Activate once the gradle build is fixed (AndroidManifest.xml is not used for instrumentTest)
+public class SimpleEntityContentProviderTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
+
+    public SimpleEntityContentProviderTest() {
+        super(DaoMaster.class);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        SimpleEntityContentProvider.connection = connection;
+    }
+
+    public void testQuery() throws SQLException {
+        SimpleEntity entity = new SimpleEntity();
+        entity.setSimpleString("hello");
+        daoSession.insert(entity);
+        long id = entity.getId();
+
+        SimpleEntity entity2 = new SimpleEntity();
+        entity2.setSimpleString("content");
+        daoSession.insert(entity2);
+        long id2 = entity2.getId();
+        Cursor cursor = getContext().getContentResolver().query(SimpleEntityContentProvider.CONTENT_URI, null,
+                null, null, "_id");
+        assertEquals(2, cursor.getCount());
+        int idxId = cursor.getColumnIndexOrThrow(SimpleEntityDao.Properties.Id.columnName);
+        int idxString = cursor.getColumnIndexOrThrow(SimpleEntityDao.Properties.SimpleString.columnName);
+
+        assertTrue(cursor.moveToFirst());
+        assertEquals("hello", cursor.getString(idxString));
+        assertEquals(id, cursor.getLong(idxId));
+
+        assertTrue(cursor.moveToNext());
+        assertEquals("content", cursor.getString(idxString));
+        assertEquals(id2, cursor.getLong(idxId));
+    }
+
+}
\ No newline at end of file
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/AnActiveEntityMultithreadingTest.java b/DaoTest/src/de/greenrobot/daotest/entity/AnActiveEntityMultithreadingTest.java
new file mode 100644
index 00000000..d498e80e
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/entity/AnActiveEntityMultithreadingTest.java
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2013 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import java.lang.reflect.Field;
+import java.sql.SQLException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.test.AbstractDaoSessionTest;
+import de.greenrobot.daotest.AnActiveEntity;
+import de.greenrobot.daotest.AnActiveEntityDao;
+import de.greenrobot.daotest.DaoMaster;
+import de.greenrobot.daotest.DaoSession;
+
+public class AnActiveEntityMultithreadingTest extends AbstractDaoSessionTest<DaoMaster, DaoSession> {
+
+    /** Serious multithreading tests require this set to true. */
+    private static final boolean LONG_RUNNING = false;
+    private static final int ENTITIES_TO_CHECK = LONG_RUNNING ? 1000000 : 10000;
+
+    private AnActiveEntityDao dao;
+    private CountDownLatch latch = new CountDownLatch(2);
+    volatile boolean running = true;
+
+    public AnActiveEntityMultithreadingTest() {
+        super(DaoMaster.class);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        dao = daoSession.getAnActiveEntityDao();
+    }
+
+    public void testAlwaysAttachedWithInsertDelete() throws Exception {
+        doTestAlwaysAttached(new InsertDeleteThread());
+    }
+
+    public void testAlwaysAttachedWithDetach() throws Exception {
+        doTestAlwaysAttached(new DetachThread());
+    }
+
+    private void doTestAlwaysAttached(Thread thread) throws Exception {
+        thread.start();
+
+        Field daoSessionField = AnActiveEntity.class.getDeclaredField("daoSession");
+        daoSessionField.setAccessible(true);
+
+        int countEntity = 0;
+        countDownAndAwaitLatch();
+
+        try {
+            assertTrue(latch.await(10, TimeUnit.SECONDS));
+            for (int i = 0;; i++) {
+                AnActiveEntity entity = dao.load(1l);
+                if (entity != null) {
+                    countEntity++;
+                    assertNotNull(daoSessionField.get(entity));
+                }
+                if (i == 1000000 && countEntity == 0) {
+                    fail("No entity available");
+                }
+                if (countEntity % 10000 == 0) {
+                    DaoLog.d("Checked entities " + countEntity + " in " + i + " iterations");
+                }
+                if (countEntity == ENTITIES_TO_CHECK) {
+                    break;
+                }
+            }
+        } finally {
+            running = false;
+            thread.join();
+        }
+    }
+
+    private void countDownAndAwaitLatch() {
+        latch.countDown();
+        try {
+            assertTrue(latch.await(10, TimeUnit.SECONDS));
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    class InsertDeleteThread extends Thread {
+        @Override
+        public void run() {
+            countDownAndAwaitLatch();
+
+            while (running) {
+                AnActiveEntity entity = null;
+                entity = new AnActiveEntity(1l);
+                try
+				{
+					dao.insert(entity);
+					dao.delete(entity);
+				}
+				catch ( SQLException e )
+				{
+					e.printStackTrace();
+				}
+            }
+        }
+    }
+
+    class DetachThread extends Thread {
+        @Override
+        public void run() {
+            countDownAndAwaitLatch();
+
+            AnActiveEntity entity = new AnActiveEntity(1l);
+            try
+			{
+				dao.insert(entity);
+				while (running) {
+					dao.detach(entity);
+					entity = dao.load(1l);
+				}
+			}
+			catch ( SQLException e )
+			{
+				e.printStackTrace();
+			}
+        }
+    }
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/RelationEntityTest.java b/DaoTest/src/de/greenrobot/daotest/entity/RelationEntityTest.java
index e7ff7884..0750be74 100644
--- a/DaoTest/src/de/greenrobot/daotest/entity/RelationEntityTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/entity/RelationEntityTest.java
@@ -1,24 +1,204 @@
-package de.greenrobot.daotest.entity;
-
-import de.greenrobot.dao.test.AbstractDaoTestLongPk;
-
-import de.greenrobot.daotest.RelationEntity;
-import de.greenrobot.daotest.RelationEntityDao;
-
-public class RelationEntityTest extends AbstractDaoTestLongPk<RelationEntityDao, RelationEntity> {
-
-	private long testIdNotNull;
-	
-    public RelationEntityTest() {
-        super(RelationEntityDao.class);
-    }
-
-    @Override
-    protected RelationEntity createEntity(Long key) {
-        RelationEntity entity = new RelationEntity();
-        entity.setId(key);
-		entity.setTestIdNotNull(testIdNotNull);
-		return entity;
-    }
-
-}
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import de.greenrobot.dao.identityscope.IdentityScopeType;
+import de.greenrobot.dao.test.AbstractDaoTestLongPk;
+import de.greenrobot.daotest.DaoMaster;
+import de.greenrobot.daotest.DaoSession;
+import de.greenrobot.daotest.RelationEntity;
+import de.greenrobot.daotest.RelationEntityDao;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao;
+
+public class RelationEntityTest extends AbstractDaoTestLongPk<RelationEntityDao, RelationEntity> {
+
+    protected DaoMaster daoMaster;
+    protected DaoSession daoSession;
+    /** set before calling setUp of this class. */
+    protected IdentityScopeType identityScopeTypeForSession;
+
+    public RelationEntityTest() {
+        super(RelationEntityDao.class);
+        identityScopeTypeForSession = IdentityScopeType.None;
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        TestEntityDao.createTable(connection, false);
+        daoMaster = new DaoMaster(connection);
+        daoSession = daoMaster.newSession(identityScopeTypeForSession);
+        dao = daoSession.getRelationEntityDao();
+    }
+
+    @Override
+    protected RelationEntity createEntity(Long key) {
+        RelationEntity entity = new RelationEntity();
+        entity.setId(key);
+        return entity;
+    }
+
+    public void testToOne() throws SQLException {
+        RelationEntity entity = insertEntityWithRelations(42l);
+        entity = dao.load(entity.getId());
+        assertTestEntity(entity);
+    }
+
+    public void testToOneSelf() throws SQLException {
+        RelationEntity entity = createEntity(1l);
+        dao.insert(entity);
+
+        entity = dao.load(1l);
+        assertNull(entity.getParent());
+
+        entity.setParentId(entity.getId());
+        dao.update(entity);
+
+        entity = dao.load(1l);
+        RelationEntity parent = entity.getParent();
+        assertEquals(entity.getId(), parent.getId());
+    }
+
+    public void testToOneClearKey() throws SQLException {
+        RelationEntity entity = insertEntityWithRelations(42l);
+        assertNotNull(entity.getParent());
+        entity.setParentId(null);
+        assertNull(entity.getParent());
+    }
+
+    public void testToOneClearEntity() throws SQLException {
+        RelationEntity entity = insertEntityWithRelations(42l);
+        assertNotNull(entity.getParentId());
+        entity.setParent(null);
+        assertNull(entity.getParentId());
+    }
+
+    public void testToOneUpdateKey() throws SQLException {
+        RelationEntity entity = insertEntityWithRelations(42l);
+        TestEntity testEntity = entity.getTestEntity();
+        RelationEntity entity2 = insertEntityWithRelations(43l);
+        TestEntity testEntity2 = entity2.getTestEntity();
+
+        entity.setTestId(testEntity2.getId());
+        assertEquals(testEntity2.getId(), entity.getTestEntity().getId());
+
+        entity.setTestId(null);
+        assertNull(entity.getTestEntity());
+
+        entity.setTestId(testEntity.getId());
+        assertEquals(testEntity.getId(), entity.getTestEntity().getId());
+    }
+
+    public void testToOneUpdateEntity() throws SQLException {
+        RelationEntity entity = insertEntityWithRelations(42l);
+        TestEntity testEntity = entity.getTestEntity();
+        RelationEntity entity2 = insertEntityWithRelations(43l);
+        TestEntity testEntity2 = entity2.getTestEntity();
+
+        entity.setTestEntity(testEntity2);
+        assertEquals(testEntity2.getId(), entity.getTestId());
+
+        entity.setTestEntity(null);
+        assertNull(entity.getTestId());
+
+        entity.setTestEntity(testEntity);
+        assertEquals(testEntity.getId(), entity.getTestId());
+    }
+
+    public void testToOneLoadDeep() throws SQLException {
+        RelationEntity entity = insertEntityWithRelations(42l);
+        entity = dao.loadDeep(entity.getId());
+        assertTestEntity(entity);
+    }
+
+    public void testToOneNoMatch() throws SQLException {
+        RelationEntity entity = insertEntityWithRelations(42l);
+        assertNotNull(entity.getTestEntity());
+        entity.setTestId(23l);
+        entity.setTestIdNotNull(-78);
+        assertNull(entity.getTestEntity());
+        assertNull(entity.getTestNotNull());
+    }
+
+    public void testToOneNoMatchLoadDeep() throws SQLException {
+        RelationEntity entity = insertEntityWithRelations(42l);
+        assertNotNull(entity.getTestEntity());
+        entity.setTestId(23l);
+        entity.setTestIdNotNull(-78);
+        dao.update(entity);
+        entity = dao.loadDeep(entity.getId());
+        assertNull(entity.getTestEntity());
+        assertNull(entity.getTestNotNull());
+    }
+
+    public void testToOneLoadDeepNull() throws SQLException {
+        RelationEntity entity = insertEntityWithRelations(42l);
+        entity.setParentId(null);
+        entity.setTestId(null);
+        dao.update(entity);
+        entity = dao.loadDeep(entity.getId());
+        assertNull(entity.getParent());
+        assertNull(entity.getTestEntity());
+    }
+
+    public void testQueryDeep() throws SQLException {
+        insertEntityWithRelations(42l);
+        String columnName = RelationEntityDao.Properties.SimpleString.columnName;
+        List<RelationEntity> entityList = dao.queryDeep("WHERE T." + columnName + "=?", "findMe");
+        assertEquals(1, entityList.size());
+        assertTestEntity(entityList.get(0));
+    }
+
+    protected RelationEntity insertEntityWithRelations(Long testEntityId) throws SQLException {
+        TestEntity testEntity = daoSession.getTestEntityDao().load(testEntityId);
+        if (testEntity == null) {
+            testEntity = new TestEntity(testEntityId);
+            testEntity.setSimpleStringNotNull("mytest");
+            daoSession.getTestEntityDao().insert(testEntity);
+        }
+
+        RelationEntity parentEntity = createEntity(null);
+        parentEntity.setSimpleString("I'm a parent");
+        parentEntity.setTestNotNull(testEntity);
+        dao.insert(parentEntity);
+
+        RelationEntity entity = createEntity(null);
+        entity.setTestId(testEntityId);
+        entity.setParentId(parentEntity.getId());
+        entity.setSimpleString("findMe");
+        entity.setTestNotNull(testEntity);
+        dao.insert(entity);
+
+        return entity;
+    }
+
+    protected void assertTestEntity(RelationEntity entity) throws SQLException {
+        TestEntity testEntity = entity.getTestEntity();
+        assertNotNull(testEntity);
+        assertEquals(42l, (long) testEntity.getId());
+        assertEquals("mytest", testEntity.getSimpleStringNotNull());
+        assertEquals("I'm a parent", entity.getParent().getSimpleString());
+        assertEquals(entity.getParentId(), entity.getParent().getId());
+        assertNotNull(entity.getTestNotNull());
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/RelationEntityTestIdentityScope.java b/DaoTest/src/de/greenrobot/daotest/entity/RelationEntityTestIdentityScope.java
new file mode 100644
index 00000000..8ebdc5c4
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/entity/RelationEntityTestIdentityScope.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import de.greenrobot.dao.identityscope.IdentityScopeType;
+import de.greenrobot.daotest.RelationEntity;
+import de.greenrobot.daotest.RelationEntityDao;
+
+/**
+ * @author Markus
+ */
+public class RelationEntityTestIdentityScope extends RelationEntityTest {
+
+    @Override
+    protected void setUp() throws Exception {
+        identityScopeTypeForSession = IdentityScopeType.Session;
+        super.setUp();
+    }
+
+    public void testToOneLoadDeepIdentityScope() throws SQLException {
+        RelationEntity entity = insertEntityWithRelations(42l);
+        RelationEntity entity2 = insertEntityWithRelations(42l);
+        entity = dao.loadDeep(entity.getId());
+        entity2 = dao.loadDeep(entity2.getId());
+        assertFalse(entity.getId().equals(entity2.getId()));
+        assertTestEntity(entity);
+        assertTestEntity(entity2);
+        assertSame(entity.getTestEntity(), entity2.getTestEntity());
+    }
+
+    public void testToQueryDeepIdentityScope() throws SQLException {
+        insertEntityWithRelations(42l);
+        RelationEntity entity2 = insertEntityWithRelations(42l);
+        String columnName = RelationEntityDao.Properties.SimpleString.columnName;
+        List<RelationEntity> entityList = dao.queryDeep("WHERE T." + columnName + "=?", "findMe");
+        assertEquals(2, entityList.size());
+        RelationEntity entity = entityList.get(0);
+        assertTestEntity(entity);
+        entity2 = entityList.get(1);
+        assertTestEntity(entity2);
+        assertSame(entity.getTestEntity(), entity2.getTestEntity());
+    }
+
+    public void testLoadDeepIdentityScope() throws SQLException {
+        RelationEntity entity = insertEntityWithRelations(42l);
+        RelationEntity entity2 = dao.loadDeep(entity.getId());
+        RelationEntity entity3 = dao.loadDeep(entity.getId());
+        assertSame(entity, entity2);
+        assertSame(entity, entity3);
+        assertTestEntity(entity);
+    }
+
+    public void testQueryDeepIdentityScope() throws SQLException {
+        RelationEntity entity = insertEntityWithRelations(42l);
+
+        String columnName = RelationEntityDao.Properties.SimpleString.columnName;
+        List<RelationEntity> entityList = dao.queryDeep("WHERE T." + columnName + "=?", "findMe");
+        RelationEntity entity2 = entityList.get(0);
+        entityList = dao.queryDeep("WHERE T." + columnName + "=?", "findMe");
+        RelationEntity entity3 = entityList.get(0);
+
+        assertSame(entity, entity2);
+        assertSame(entity, entity3);
+        assertTestEntity(entity);
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityNotNullHelper.java b/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityNotNullHelper.java
new file mode 100644
index 00000000..9a174bc6
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/entity/SimpleEntityNotNullHelper.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import de.greenrobot.daotest.SimpleEntityNotNull;
+
+
+public class SimpleEntityNotNullHelper {
+    public static SimpleEntityNotNull createEntity(Long key) {
+        if (key == null) {
+            return null;
+        }
+        SimpleEntityNotNull entity = new SimpleEntityNotNull();
+        entity.setId(key);
+        entity.setSimpleBoolean(true);
+        entity.setSimpleByte(Byte.MAX_VALUE);
+        entity.setSimpleShort(Short.MAX_VALUE);
+        entity.setSimpleInt(Integer.MAX_VALUE);
+        entity.setSimpleLong(Long.MAX_VALUE);
+        entity.setSimpleFloat(Float.MAX_VALUE);
+        entity.setSimpleDouble(Double.MAX_VALUE);
+        entity.setSimpleString("greenrobot greenDAO");
+        byte[] bytes = { 42, -17, 23, 0, 127, -128 };
+        entity.setSimpleByteArray(bytes);
+        return entity;
+    }
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/StringKeyValueEntityIdentityScopeTest.java b/DaoTest/src/de/greenrobot/daotest/entity/StringKeyValueEntityIdentityScopeTest.java
new file mode 100644
index 00000000..3a4cd925
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/entity/StringKeyValueEntityIdentityScopeTest.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import java.sql.SQLException;
+
+import de.greenrobot.dao.identityscope.IdentityScopeObject;
+import de.greenrobot.daotest.StringKeyValueEntity;
+
+public class StringKeyValueEntityIdentityScopeTest extends StringKeyValueEntityTest {
+    @Override
+    protected void setUp() throws Exception {
+        setIdentityScopeBeforeSetUp(new IdentityScopeObject<String, StringKeyValueEntity>());
+        super.setUp();
+    }
+
+    public void testLoadIdScope() throws SQLException {
+        StringKeyValueEntity entity = createEntityWithRandomPk();
+        dao.insert(entity);
+        StringKeyValueEntity entity2 = dao.load(entity.getKey());
+        StringKeyValueEntity entity3 = dao.load(entity.getKey());
+
+        assertSame(entity, entity2);
+        assertSame(entity2, entity3);
+    }
+
+    public void testLoadIdScope_load() throws SQLException {
+        StringKeyValueEntity entity = createEntityWithRandomPk();
+        dao.insert(entity);
+        dao.detach(entity);
+        StringKeyValueEntity entity2 = dao.load(entity.getKey());
+        StringKeyValueEntity entity3 = dao.load(entity.getKey());
+
+        assertNotSame(entity, entity2);
+        assertSame(entity2, entity3);
+    }
+
+    public void testDetach() throws SQLException {
+        StringKeyValueEntity entity = createEntityWithRandomPk();
+        dao.insert(entity);
+        dao.detach(entity);
+        StringKeyValueEntity entity2 = dao.load(entity.getKey());
+        dao.detach(entity2);
+        StringKeyValueEntity entity3 = dao.load(entity.getKey());
+
+        assertNotSame(entity, entity2);
+        assertNotSame(entity2, entity3);
+        assertNotSame(entity, entity3);
+    }
+
+    public void testDetachOther() throws SQLException {
+        StringKeyValueEntity entity = createEntityWithRandomPk();
+        dao.insert(entity);
+        dao.detach(entity);
+        StringKeyValueEntity entity2 = dao.load(entity.getKey());
+        dao.detach(entity);
+        StringKeyValueEntity entity3 = dao.load(entity.getKey());
+
+        assertSame(entity2, entity3);
+    }
+
+    public void testLoadAllScope() throws SQLException {
+        StringKeyValueEntity entity = createEntityWithRandomPk();
+        dao.insert(entity);
+        StringKeyValueEntity entity2 = dao.loadAll().get(0);
+        StringKeyValueEntity entity3 = dao.loadAll().get(0);
+
+        assertSame(entity, entity2);
+        assertSame(entity2, entity3);
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/TestEntityIdentityScopeTest.java b/DaoTest/src/de/greenrobot/daotest/entity/TestEntityIdentityScopeTest.java
new file mode 100644
index 00000000..db9bebba
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/entity/TestEntityIdentityScopeTest.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import java.sql.SQLException;
+
+import de.greenrobot.dao.identityscope.IdentityScopeLong;
+import de.greenrobot.daotest.TestEntity;
+
+public class TestEntityIdentityScopeTest extends TestEntityTest {
+    @Override
+    protected void setUp() throws Exception {
+        setIdentityScopeBeforeSetUp(new IdentityScopeLong<TestEntity>());
+        super.setUp();
+    }
+
+    public void testLoadIdScope() throws SQLException {
+        TestEntity entity = createEntity(null);
+        dao.insert(entity);
+        TestEntity entity2 = dao.load(entity.getId());
+        TestEntity entity3 = dao.load(entity.getId());
+
+        assertSame(entity, entity2);
+        assertSame(entity2, entity3);
+    }
+
+    public void testDetach() throws SQLException {
+        TestEntity entity = createEntity(null);
+        dao.insert(entity);
+        dao.detach(entity);
+        TestEntity entity2 = dao.load(entity.getId());
+        dao.detach(entity2);
+        TestEntity entity3 = dao.load(entity.getId());
+
+        assertNotSame(entity, entity2);
+        assertNotSame(entity2, entity3);
+        assertNotSame(entity, entity3);
+    }
+
+    public void testDetachOther() throws SQLException {
+        TestEntity entity = createEntity(null);
+        dao.insert(entity);
+        dao.detach(entity);
+        TestEntity entity2 = dao.load(entity.getId());
+        dao.detach(entity);
+        TestEntity entity3 = dao.load(entity.getId());
+
+        assertSame(entity2, entity3);
+    }
+
+    public void testLoadAllScope() throws SQLException {
+        TestEntity entity = createEntity(null);
+        dao.insert(entity);
+        TestEntity entity2 = dao.loadAll().get(0);
+        TestEntity entity3 = dao.loadAll().get(0);
+
+        assertSame(entity, entity2);
+        assertSame(entity2, entity3);
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/entity/TestEntityTestBase.java b/DaoTest/src/de/greenrobot/daotest/entity/TestEntityTestBase.java
new file mode 100644
index 00000000..2ace247e
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/entity/TestEntityTestBase.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.entity;
+
+import java.sql.SQLException;
+import java.util.ArrayList;
+
+import de.greenrobot.dao.query.LazyList;
+import de.greenrobot.dao.test.AbstractDaoTest;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao;
+
+public abstract class TestEntityTestBase extends AbstractDaoTest<TestEntityDao, TestEntity, Long> {
+
+    public TestEntityTestBase() {
+        super(TestEntityDao.class);
+    }
+
+    protected TestEntity createEntity(int simpleInteger, String simpleString) {
+        TestEntity entity = new TestEntity();
+        entity.setId(null);
+        entity.setSimpleStringNotNull("green");
+        entity.setSimpleInteger(simpleInteger);
+        entity.setSimpleString(simpleString);
+        return entity;
+    }
+
+    protected ArrayList<TestEntity> insert(int count) throws SQLException {
+        ArrayList<TestEntity> list = new ArrayList<TestEntity>();
+        for (int i = 0; i < count; i++) {
+            TestEntity entity = createEntity(getSimpleInteger(i), getSimpleString(i));
+            list.add(entity);
+        }
+        dao.insertInTx(list);
+        return list;
+    }
+
+    protected String getSimpleString(int i) {
+        return "String" + (i + 100);
+    }
+
+    protected int getSimpleInteger(int i) {
+        return 100 + i;
+    }
+
+    protected void assertIds(ArrayList<TestEntity> list, LazyList<TestEntity> list2) {
+        for (int i = 0; i < list.size(); i++) {
+            TestEntity entity = list.get(i);
+            TestEntity lazyEntity = list2.get(i);
+            assertIds(entity, lazyEntity);
+        }
+    }
+
+    protected void assertIds(TestEntity entity, TestEntity entity2) {
+        assertEquals(entity.getId(), entity2.getId());
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/LoockupPerformanceTest.java b/DaoTest/src/de/greenrobot/daotest/performance/LoockupPerformanceTest.java
new file mode 100644
index 00000000..9b697d53
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/performance/LoockupPerformanceTest.java
@@ -0,0 +1,199 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.performance;
+
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Random;
+
+import junit.framework.TestCase;
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.internal.LongHashMap;
+import de.greenrobot.daotest.performance.target.LongHashMapAmarena2DZechner;
+import de.greenrobot.daotest.performance.target.LongHashMapJDBM;
+import de.greenrobot.daotest.performance.target.LongSparseArray;
+
+public class LoockupPerformanceTest extends TestCase {
+
+    Random random;
+    private String traceName;
+    private long start;
+
+    public LoockupPerformanceTest() {
+        this.random = new Random();
+    }
+
+    public void testHashMapPerformance() {
+        // runTests(100);
+        // runTests(1000);
+        // runTests(10000);
+        // runTests(100000); // hash: 1485/420ms; sparse: 148196/196ms
+        DaoLog.d("testHashMapPerformance DONE");
+    }
+
+    private void runTests(int count) {
+        runTests(count, false);
+        runTests(count, true);
+    }
+
+    private void runTests(int count, boolean randomKeys) {
+        DaoLog.d("-----------------------------------");
+        DaoLog.d("Look up " + count + (randomKeys ? " random" : " linear") + " keys on " + new Date());
+        DaoLog.d("-----------------------------------");
+        long[] keys = new long[count];
+        for (int i = 0; i < count; i++) {
+            if (randomKeys) {
+                keys[i] = random.nextLong();
+            } else {
+                keys[i] = i;
+            }
+        }
+        for (int i = 0; i < 3; i++) {
+            runMapTest(new HashMap<Long, Object>(count), keys, "hashmap");
+            // runMapTest(new WeakHashMap<Long, Object>(count), keys, "weakhashmap");
+            // runMapTest(new ConcurrentHashMap<Long, Object>(count), keys, "concurrent-hashmap");
+            // runLongSparseArrayTest(keys);
+            runLongHashMap(keys);
+            runLongHashMapAmarena2DZechnerTest(keys);
+            // runLongHashMapJDBMTest(keys);
+            DaoLog.d("-----------------------------------");
+        }
+    }
+
+    protected void runMapTest(Map<Long, Object> map, long[] keys, String name) {
+        startClock("put-" + name + "-" + keys.length);
+        for (long key : keys) {
+            map.put(key, this);
+        }
+        stopClock();
+
+        startClock("get-" + name + "-" + keys.length);
+        int lossCount = 0;
+        for (long key : keys) {
+            Object object = map.get(key);
+            if (object != this) {
+                lossCount++;
+            }
+        }
+        if (lossCount > 0) {
+            stopClock("losses: " + lossCount);
+        } else {
+            stopClock();
+        }
+    }
+
+    private void runLongSparseArrayTest(long[] keys) {
+        if (keys.length > 10000) {
+            DaoLog.d("Skipping runLongSparseArrayTest for " + keys.length);
+            return;
+        }
+        LongSparseArray<Object> array = new LongSparseArray<Object>(keys.length);
+
+        startClock("put-sparsearray-" + keys.length);
+        for (long key : keys) {
+            array.put(key, this);
+        }
+        stopClock();
+
+        startClock("get-sparsearray-" + keys.length);
+        for (long key : keys) {
+            Object object = array.get(key);
+            if (object != this) {
+                fail("Ups: " + object);
+            }
+        }
+        stopClock();
+    }
+
+    private void runLongHashMapJDBMTest(long[] keys) {
+        LongHashMapJDBM<Object> map = new LongHashMapJDBM<Object>(keys.length);
+
+        startClock("put-jdbm-" + keys.length);
+        for (long key : keys) {
+            map.put(key, this);
+        }
+        stopClock();
+
+        startClock("get-jdbm-" + keys.length);
+        for (long key : keys) {
+            Object object = map.get(key);
+            if (object != this) {
+                fail("Ups: " + object);
+            }
+        }
+        stopClock();
+    }
+
+    private void runLongHashMap(long[] keys) {
+        LongHashMap<Object> map = new LongHashMap<Object>(keys.length);
+        map.reserveRoom(keys.length);
+
+        startClock("put-my-" + keys.length);
+        for (long key : keys) {
+            map.put(key, this);
+        }
+        stopClock();
+
+        startClock("get-my-" + keys.length);
+        for (long key : keys) {
+            Object object = map.get(key);
+            if (object != this) {
+                fail("Ups: " + object);
+            }
+        }
+        stopClock();
+        map.logStats();
+    }
+
+    private void runLongHashMapAmarena2DZechnerTest(long[] keys) {
+        LongHashMapAmarena2DZechner<Object> map = new LongHashMapAmarena2DZechner<Object>(keys.length);
+
+        startClock("put-amarena-" + keys.length);
+        for (long key : keys) {
+            map.put(key, this);
+        }
+        stopClock();
+
+        startClock("get-amarena-" + keys.length);
+        for (long key : keys) {
+            Object object = map.get(key);
+            if (object != this) {
+                fail("Ups: " + object);
+            }
+        }
+        stopClock();
+        map.logStats();
+    }
+
+    protected void startClock(String traceName) {
+        this.traceName = traceName;
+        start = System.currentTimeMillis();
+    }
+
+    protected void stopClock() {
+        stopClock(null);
+    }
+
+    protected void stopClock(String extraInfoOrNull) {
+        long time = System.currentTimeMillis() - start;
+        String extraLog = extraInfoOrNull != null ? " (" + extraInfoOrNull + ")" : "";
+        DaoLog.d(traceName + " completed in " + time + "ms" + extraLog);
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTest.java b/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTest.java
new file mode 100644
index 00000000..c01c3276
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTest.java
@@ -0,0 +1,170 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.performance;
+
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+import android.os.Debug;
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.test.AbstractDaoTest;
+
+public abstract class PerformanceTest<D extends AbstractDao<T, K>, T, K> extends AbstractDaoTest<D, T, K> {
+    long start;
+    private String traceName;
+    boolean useTraceView = false;
+
+    public PerformanceTest(Class<D> daoClass) {
+        super(daoClass, false);
+    }
+
+    public void testPerformance() throws Exception {
+        // runTests(1000);
+        // runTests(1000);
+        // runTests(1000);
+        // runTests(1000);
+        // runTests(1000);
+        // runTests(1000);
+    }
+
+    protected void runTests(int entityCount) throws SQLException {
+        DaoLog.d("####################");
+        DaoLog.d(getClass().getSimpleName() + ": " + entityCount + " entities on " + new Date());
+        DaoLog.d("####################");
+        clearIdentityScopeIfAny();
+
+        List<T> list = new ArrayList<T>(entityCount);
+        for (int i = 0; i < entityCount; i++) {
+            list.add(createEntity());
+        }
+        System.gc();
+
+        dao.deleteAll();
+        // runOneByOneTests(list, entityCount, entityCount / 10);
+        dao.deleteAll();
+        DaoLog.d("------------------------");
+        System.gc();
+
+        // runBatchTests(list);
+
+        startClock("delete-all");
+        dao.deleteAll();
+        stopClock();
+        System.gc();
+    }
+
+    protected void runOneByOneTests(List<T> list, int loadCount, int modifyCount) throws SQLException {
+        dao.insertInTx(list);
+        List<K> keys = new ArrayList<K>(loadCount);
+        for (int i = 0; i < loadCount; i++) {
+            keys.add(daoAccess.getKey(list.get(i)));
+        }
+        clearIdentityScopeIfAny();
+        System.gc();
+
+        list = runLoadOneByOne(keys, "load-one-by-one-1");
+        list = runLoadOneByOne(keys, "load-one-by-one-2");
+        Debug.stopMethodTracing();
+
+        dao.deleteAll();
+        System.gc();
+
+        startClock("insert-one-by-one");
+        for (int i = 0; i < modifyCount; i++) {
+            dao.insert(list.get(i));
+        }
+        stopClock(modifyCount + " entities");
+        System.gc();
+
+        startClock("update-one-by-one");
+        for (int i = 0; i < modifyCount; i++) {
+            dao.update(list.get(i));
+        }
+        stopClock(modifyCount + " entities");
+        System.gc();
+
+        startClock("delete-one-by-one");
+        for (int i = 0; i < modifyCount; i++) {
+            dao.delete(list.get(i));
+        }
+        stopClock(modifyCount + " entities");
+        System.gc();
+    }
+
+    protected List<T> runLoadOneByOne(List<K> keys, String traceName) throws SQLException {
+        List<T> list = new ArrayList<T>(keys.size());
+        startClock(traceName);
+        for (K key : keys) {
+            list.add(dao.load(key));
+        }
+        stopClock(keys.size() + " entities");
+        return list;
+    }
+
+    protected void runBatchTests(List<T> list) throws SQLException {
+        startClock("insert");
+        dao.insertInTx(list);
+        stopClock(list.size() + " entities");
+
+        list = null;
+        System.gc();
+
+        clearIdentityScopeIfAny();
+        list = runLoadAll("load-all-1");
+        list = runLoadAll("load-all-2");
+
+        startClock("update");
+        dao.updateInTx(list);
+        stopClock(list.size() + " entities");
+    }
+
+    protected List<T> runLoadAll(String traceName) throws SQLException {
+        startClock(traceName);
+        List<T> list = dao.loadAll();
+        stopClock(list.size() + " entities");
+        return list;
+    }
+
+    protected void startClock(String traceName) {
+        System.gc();
+        this.traceName = traceName;
+        if (useTraceView) {
+            Debug.startMethodTracing(traceName);
+        }
+        start = System.currentTimeMillis();
+    }
+
+    protected void stopClock() {
+        stopClock(null);
+    }
+
+    protected void stopClock(String extraInfoOrNull) {
+        long time = System.currentTimeMillis() - start;
+        String extraLog = extraInfoOrNull != null ? " (" + extraInfoOrNull + ")" : "";
+        DaoLog.d(traceName + " completed in " + time + "ms" + extraLog);
+        if (useTraceView) {
+            Debug.stopMethodTracing();
+        }
+        System.gc();
+    }
+
+    protected abstract T createEntity();
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTestNotNull.java b/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTestNotNull.java
new file mode 100644
index 00000000..7b6be735
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTestNotNull.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.performance;
+
+import de.greenrobot.daotest.SimpleEntityNotNull;
+import de.greenrobot.daotest.SimpleEntityNotNullDao;
+import de.greenrobot.daotest.entity.SimpleEntityNotNullHelper;
+
+public class PerformanceTestNotNull extends PerformanceTest<SimpleEntityNotNullDao, SimpleEntityNotNull, Long> {
+
+    static long sequence;
+
+    public PerformanceTestNotNull() {
+        super(SimpleEntityNotNullDao.class);
+    }
+
+    @Override
+    protected SimpleEntityNotNull createEntity() {
+        return SimpleEntityNotNullHelper.createEntity(sequence++);
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTestNotNullIdentityScope.java b/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTestNotNullIdentityScope.java
new file mode 100644
index 00000000..eabbb7c0
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/performance/PerformanceTestNotNullIdentityScope.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.performance;
+
+import de.greenrobot.dao.identityscope.IdentityScopeLong;
+import de.greenrobot.daotest.SimpleEntityNotNull;
+
+public class PerformanceTestNotNullIdentityScope extends PerformanceTestNotNull {
+
+    @Override
+    protected void setUp() throws Exception {
+        IdentityScopeLong<SimpleEntityNotNull> identityScope = new IdentityScopeLong< SimpleEntityNotNull>();
+        setIdentityScopeBeforeSetUp(identityScope);
+        super.setUp();
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/ReflectionPerformanceTest.java b/DaoTest/src/de/greenrobot/daotest/performance/ReflectionPerformanceTest.java
new file mode 100644
index 00000000..e71f1ab8
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/performance/ReflectionPerformanceTest.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.performance;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+import de.greenrobot.dao.DaoLog;
+
+public class ReflectionPerformanceTest // extends TestCase
+{
+
+    int intValue;
+    String stringValue;
+
+    public int getIntValue() {
+        return intValue;
+    }
+
+    public void setIntValue(int inValue) {
+        this.intValue = inValue;
+    }
+
+    public String getStringValue() {
+        return stringValue;
+    }
+
+    public void setStringValue(String stringValue) {
+        this.stringValue = stringValue;
+    }
+
+    public void testSetIntPerf() throws SecurityException, NoSuchMethodException, IllegalArgumentException,
+            IllegalAccessException, InvocationTargetException {
+        int count = 100000;
+
+        long start = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            setIntValue(i);
+        }
+        long time = System.currentTimeMillis() - start;
+
+        Method method = getClass().getMethod("setIntValue", int.class);
+        long start2 = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            method.invoke(this, i);
+        }
+        long time2 = System.currentTimeMillis() - start2;
+        DaoLog.d("set int: normal=" + time + "ms, reflected=" + time2 + "ms, " + 1000 * count / time2
+                + " refelected ops/s, slower=" + ((float) time2) / time);
+
+    }
+
+    public void testGetIntPerf() throws SecurityException, NoSuchMethodException, IllegalArgumentException,
+            IllegalAccessException, InvocationTargetException {
+        int count = 100000;
+
+        long start = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            int x = getIntValue();
+        }
+        long time = System.currentTimeMillis() - start;
+
+        Method method = getClass().getMethod("getIntValue");
+        long start2 = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            int x = (Integer) method.invoke(this);
+        }
+        long time2 = System.currentTimeMillis() - start2;
+        DaoLog.d("get int: normal=" + time + "ms, reflected=" + time2 + "ms, " + 1000 * count / time2
+                + " refelected ops/s, slower=" + ((float) time2) / time);
+    }
+
+    public void testSetStringPerf() throws SecurityException, NoSuchMethodException, IllegalArgumentException,
+            IllegalAccessException, InvocationTargetException {
+        int count = 100000;
+
+        long start = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            setStringValue("the quick brown fox");
+        }
+        long time = System.currentTimeMillis() - start;
+
+        Method method = getClass().getMethod("setStringValue", String.class);
+        long start2 = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            method.invoke(this, "the quick brown fox");
+        }
+        long time2 = System.currentTimeMillis() - start2;
+        DaoLog.d("set String: normal=" + time + "ms, reflected=" + time2 + "ms, " + 1000 * count / time2
+                + " refelected ops/s, slower=" + ((float) time2) / time);
+
+    }
+
+    public void testGetStringPerf() throws SecurityException, NoSuchMethodException, IllegalArgumentException,
+            IllegalAccessException, InvocationTargetException {
+        int count = 100000;
+
+        long start = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            String x = getStringValue();
+        }
+        long time = System.currentTimeMillis() - start;
+
+        Method method = getClass().getMethod("getStringValue");
+        long start2 = System.currentTimeMillis();
+        for (int i = 0; i < count; i++) {
+            String x = (String) method.invoke(this);
+        }
+        long time2 = System.currentTimeMillis() - start2;
+        DaoLog.d("get String: normal=" + time + "ms, reflected=" + time2 + "ms, " + 1000 * count / time2
+                + " refelected ops/s, slower=" + ((float) time2) / time);
+    }
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/target/ArrayUtils.java b/DaoTest/src/de/greenrobot/daotest/performance/target/ArrayUtils.java
new file mode 100644
index 00000000..cb415d53
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/performance/target/ArrayUtils.java
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package de.greenrobot.daotest.performance.target;
+
+import java.lang.reflect.Array;
+
+// XXX these should be changed to reflect the actual memory allocator we use.
+// it looks like right now objects want to be powers of 2 minus 8
+// and the array size eats another 4 bytes
+
+/**
+ * ArrayUtils contains some methods that you can call to find out
+ * the most efficient increments by which to grow arrays.
+ */
+public class ArrayUtils
+{
+    private static Object[] EMPTY = new Object[0];
+    private static final int CACHE_SIZE = 73;
+    private static Object[] sCache = new Object[CACHE_SIZE];
+
+    private ArrayUtils() { /* cannot be instantiated */ }
+
+    public static int idealByteArraySize(int need) {
+        for (int i = 4; i < 32; i++)
+            if (need <= (1 << i) - 12)
+                return (1 << i) - 12;
+
+        return need;
+    }
+
+    public static int idealBooleanArraySize(int need) {
+        return idealByteArraySize(need);
+    }
+
+    public static int idealShortArraySize(int need) {
+        return idealByteArraySize(need * 2) / 2;
+    }
+
+    public static int idealCharArraySize(int need) {
+        return idealByteArraySize(need * 2) / 2;
+    }
+
+    public static int idealIntArraySize(int need) {
+        return idealByteArraySize(need * 4) / 4;
+    }
+
+    public static int idealFloatArraySize(int need) {
+        return idealByteArraySize(need * 4) / 4;
+    }
+
+    public static int idealObjectArraySize(int need) {
+        return idealByteArraySize(need * 4) / 4;
+    }
+
+    public static int idealLongArraySize(int need) {
+        return idealByteArraySize(need * 8) / 8;
+    }
+
+    /**
+     * Checks if the beginnings of two byte arrays are equal.
+     *
+     * @param array1 the first byte array
+     * @param array2 the second byte array
+     * @param length the number of bytes to check
+     * @return true if they're equal, false otherwise
+     */
+    public static boolean equals(byte[] array1, byte[] array2, int length) {
+        if (array1 == array2) {
+            return true;
+        }
+        if (array1 == null || array2 == null || array1.length < length || array2.length < length) {
+            return false;
+        }
+        for (int i = 0; i < length; i++) {
+            if (array1[i] != array2[i]) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Returns an empty array of the specified type.  The intent is that
+     * it will return the same empty array every time to avoid reallocation,
+     * although this is not guaranteed.
+     */
+    public static <T> T[] emptyArray(Class<T> kind) {
+        if (kind == Object.class) {
+            return (T[]) EMPTY;
+        }
+
+        int bucket = ((System.identityHashCode(kind) / 8) & 0x7FFFFFFF) % CACHE_SIZE;
+        Object cache = sCache[bucket];
+
+        if (cache == null || cache.getClass().getComponentType() != kind) {
+            cache = Array.newInstance(kind, 0);
+            sCache[bucket] = cache;
+
+            // Log.e("cache", "new empty " + kind.getName() + " at " + bucket);
+        }
+
+        return (T[]) cache;
+    }
+
+    /**
+     * Checks that value is present as at least one of the elements of the array.
+     * @param array the array to check in
+     * @param value the value to check for
+     * @return true if the value is present in the array
+     */
+    public static <T> boolean contains(T[] array, T value) {
+        for (T element : array) {
+            if (element == null) {
+                if (value == null) return true;
+            } else {
+                if (value != null && element.equals(value)) return true;
+            }
+        }
+        return false;
+    }
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/target/LongHashMapAmarena2DZechner.java b/DaoTest/src/de/greenrobot/daotest/performance/target/LongHashMapAmarena2DZechner.java
new file mode 100644
index 00000000..a28e836b
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/performance/target/LongHashMapAmarena2DZechner.java
@@ -0,0 +1,249 @@
+/*******************************************************************************
+ * Copyright 2010 Mario Zechner (contact@badlogicgames.com)
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ ******************************************************************************/
+
+package de.greenrobot.daotest.performance.target;
+
+import java.util.Iterator;
+
+import de.greenrobot.dao.DaoLog;
+
+/**
+ * An long to object hashmap, taken from Amarena2D (thanks Christoph :p).
+ * 
+ * @author christop widulle
+ * 
+ * @param <T>
+ */
+public class LongHashMapAmarena2DZechner<T> {
+
+    private Entry[] table;
+    private float loadFactor;
+    private int size, mask, capacity, threshold;
+
+    public LongHashMapAmarena2DZechner() {
+        this(16, 0.75f);
+    }
+
+    public LongHashMapAmarena2DZechner(int initialCapacity) {
+        this(initialCapacity, 0.75f);
+    }
+
+    public LongHashMapAmarena2DZechner(int initialCapacity, float loadFactor) {
+        if (initialCapacity > 1 << 30)
+            throw new IllegalArgumentException("initialCapacity is too large.");
+        if (initialCapacity < 0)
+            throw new IllegalArgumentException("initialCapacity must be greater than zero.");
+        if (loadFactor <= 0)
+            throw new IllegalArgumentException("initialCapacity must be greater than zero.");
+        capacity = 1;
+        while (capacity < initialCapacity) {
+            capacity <<= 1;
+        }
+        this.loadFactor = loadFactor;
+        this.threshold = (int) (capacity * loadFactor);
+        this.table = new Entry[capacity];
+        this.mask = capacity - 1;
+    }
+
+    public boolean containsValue(Object value) {
+        Entry[] table = this.table;
+        for (int i = table.length; i-- > 0;)
+            for (Entry e = table[i]; e != null; e = e.next)
+                if (e.value.equals(value))
+                    return true;
+        return false;
+    }
+
+    public boolean containsKey(long key) {
+        int index = ((int) key) & mask;
+        for (Entry e = table[index]; e != null; e = e.next)
+            if (e.key == key)
+                return true;
+        return false;
+    }
+
+    @SuppressWarnings("unchecked")
+    public T get(long key) {
+        int index = (int) (key & mask);
+        for (Entry e = table[index]; e != null; e = e.next)
+            if (e.key == key)
+                return (T) e.value;
+        return null;
+    }
+
+    @SuppressWarnings("unchecked")
+    public T put(long key, T value) {
+        int index = (int) (key & mask);
+        // Check if key already exists.
+        for (Entry e = table[index]; e != null; e = e.next) {
+            if (e.key != key)
+                continue;
+            Object oldValue = e.value;
+            e.value = value;
+            return (T) oldValue;
+        }
+        table[index] = new Entry(key, value, table[index]);
+        if (size++ >= threshold) {
+            // Rehash.
+            int newCapacity = 2 * capacity;
+            Entry[] newTable = new Entry[newCapacity];
+            Entry[] src = table;
+            int bucketmask = newCapacity - 1;
+            for (int j = 0; j < src.length; j++) {
+                Entry e = src[j];
+                if (e != null) {
+                    src[j] = null;
+                    do {
+                        Entry next = e.next;
+                        index = (int) (e.key & bucketmask);
+                        e.next = newTable[index];
+                        newTable[index] = e;
+                        e = next;
+                    } while (e != null);
+                }
+            }
+            table = newTable;
+            capacity = newCapacity;
+            threshold = (int) (newCapacity * loadFactor);
+            mask = capacity - 1;
+        }
+        return null;
+    }
+
+    @SuppressWarnings("unchecked")
+    public T remove(long key) {
+        int index = (int) (key & mask);
+        Entry prev = table[index];
+        Entry e = prev;
+        while (e != null) {
+            Entry next = e.next;
+            if (e.key == key) {
+                size--;
+                if (prev == e) {
+                    table[index] = next;
+                } else {
+                    prev.next = next;
+                }
+                return (T) e.value;
+            }
+            prev = e;
+            e = next;
+        }
+        return null;
+    }
+
+    public int size() {
+        return size;
+    }
+
+    public void clear() {
+        Entry[] table = this.table;
+        for (int index = table.length; --index >= 0;)
+            table[index] = null;
+        size = 0;
+    }
+
+    static class Entry {
+        final long key;
+        Object value;
+        Entry next;
+
+        Entry(long k, Object v, Entry n) {
+            key = k;
+            value = v;
+            next = n;
+        }
+    }
+
+    EntryIterable iterable = new EntryIterable();
+
+    public Iterable<T> values() {
+        iterable.reset();
+        return iterable;
+    }
+
+    class EntryIterable implements Iterable<T> {
+        int currIndex = -1;
+        Entry currEntry = null;
+
+        Iterator<T> iter = new Iterator<T>() {
+            @Override
+            public boolean hasNext() {
+                if (currEntry == null) {
+                    if (!loadNextEntry())
+                        return false;
+                } else {
+                    if (currEntry.next == null) {
+                        if (loadNextEntry() == false)
+                            return false;
+                    } else
+                        currEntry = currEntry.next;
+                }
+
+                return true;
+            }
+
+            @SuppressWarnings("synthetic-access")
+            private boolean loadNextEntry() {
+                while (true) {
+                    currIndex++;
+                    if (currIndex >= table.length)
+                        return false;
+
+                    if (table[currIndex] == null)
+                        continue;
+                    else {
+                        currEntry = table[currIndex];
+                        return true;
+                    }
+                }
+            }
+
+            @SuppressWarnings("unchecked")
+            @Override
+            public T next() {
+                return (T) currEntry.value;
+            }
+
+            @Override
+            public void remove() {
+                throw new UnsupportedOperationException("not implemented");
+            }
+
+        };
+
+        public void reset() {
+            currIndex = -1;
+            currEntry = null;
+        }
+
+        @Override
+        public Iterator<T> iterator() {
+            return iter;
+        }
+
+    }
+
+    public void logStats() {
+        int collisions = 0;
+        for (Entry entry : table) {
+            while (entry != null && entry.next != null) {
+                collisions++;
+                entry = entry.next;
+            }
+        }
+        DaoLog.d("load: " + ((float) size) / capacity + ", size: " + size + ", capa: " + capacity + ", collisions: "
+                + collisions + ", collision ratio: " + ((float) collisions) / size);
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/target/LongHashMapJDBM.java b/DaoTest/src/de/greenrobot/daotest/performance/target/LongHashMapJDBM.java
new file mode 100644
index 00000000..3eeee1cb
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/performance/target/LongHashMapJDBM.java
@@ -0,0 +1,587 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package de.greenrobot.daotest.performance.target;
+
+import java.io.Serializable;
+import java.util.Arrays;
+import java.util.ConcurrentModificationException;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/**
+ * Hash Map which uses primitive long as key. 
+ * Main advantage is new instanceof of Long does not have to be created for each lookup.
+ * <p>
+ * This code comes from Android, which in turns comes to Apache Harmony. 
+ * This class was modified to use primitive longs and stripped down to consume less space. 
+ * <p>
+ * Author of JDBM modifications: Jan Kotek
+ * <p>
+ * Note: This map have weakened hash function, this works well for JDBM, but may be wrong for many other applications.  
+ */
+public class LongHashMapJDBM<V> implements  Serializable {
+    private static final long serialVersionUID = 362499999763181265L;
+
+    protected int elementCount;
+
+    protected Entry<V>[] elementData;
+
+    private final float loadFactor;
+
+    protected int threshold;
+
+    transient int modCount = 0;	
+
+    private static final int DEFAULT_SIZE = 16;
+    
+    transient Entry<V> reuseAfterDelete = null;
+
+    static final class Entry<V> {
+
+        Entry<V> next;
+
+        long key;
+        V value;
+        
+        public boolean equals(Object object) {
+            if (this == object) {
+                return true;
+            }
+            if (object instanceof Entry) {
+                Entry<?> entry = (Entry) object;
+                return ( key == entry.key)
+                        && (value == null ? entry.value == null : value
+                                .equals(entry.value));
+            }
+            return false;
+        }
+
+
+        
+        public int hashCode() {
+            return (int)(key)
+                    ^ (value == null ? 0 : value.hashCode());
+        }
+
+        
+        
+        public String toString() {
+            return key + "=" + value;
+        }
+        
+
+        
+        Entry(long theKey) {
+        	this.key = theKey;
+        	this.value = null;
+        }
+
+        Entry(long theKey, V theValue) {
+            this.key = theKey;
+            this.value = theValue;
+            //origKeyHash = (int)(theKey ^ (theKey >>> 32));
+        }
+
+    }
+    
+
+    interface EntryType<RT,VT> {
+        RT get(Entry<VT> entry);
+    }
+
+    static class HashMapIterator<E,VT> implements Iterator<E> {
+        private int position = 0;
+
+        int expectedModCount;
+
+        final EntryType<E, VT> type;
+
+        boolean canRemove = false;
+
+        Entry<VT> entry;
+
+        Entry<VT> lastEntry;
+
+        final LongHashMapJDBM<VT> associatedMap;
+
+        HashMapIterator(EntryType<E, VT> value, LongHashMapJDBM<VT> hm) {
+            associatedMap = hm;
+            type = value;
+            expectedModCount = hm.modCount;
+        }
+
+        public boolean hasNext() {
+            if (entry != null) {
+                return true;
+            }
+            // BEGIN android-changed
+            Entry<VT>[] elementData = associatedMap.elementData;
+            int length = elementData.length;
+            int newPosition = position;
+            boolean result = false;
+
+            while (newPosition < length) {
+                if (elementData[newPosition] == null) {
+                    newPosition++;
+                } else {
+                    result = true;
+                    break;
+                }
+            }
+
+            position = newPosition;
+            return result;
+            // END android-changed
+        }
+
+        void checkConcurrentMod() throws ConcurrentModificationException {
+            if (expectedModCount != associatedMap.modCount) {
+                throw new ConcurrentModificationException();
+            }
+        }
+
+        public E next() {
+            // BEGIN android-changed
+            // inline checkConcurrentMod()
+            if (expectedModCount != associatedMap.modCount) {
+                throw new ConcurrentModificationException();
+            }
+            if (!hasNext()) {
+                throw new NoSuchElementException();
+            }
+
+            Entry<VT> result;
+            Entry<VT> _entry  = entry;
+            if (_entry == null) {
+                result = lastEntry = associatedMap.elementData[position++];
+                entry = lastEntry.next;
+            } else {
+                if (lastEntry.next != _entry) {
+                    lastEntry = lastEntry.next;
+                }
+                result = _entry;
+                entry = _entry.next;
+            }
+            canRemove = true;
+            return type.get(result);
+            // END android-changed
+        }
+
+        public void remove() {
+            checkConcurrentMod();
+            if (!canRemove) {
+                throw new IllegalStateException();
+            }
+
+            canRemove = false;
+            associatedMap.modCount++;
+            if (lastEntry.next == entry) {
+                while (associatedMap.elementData[--position] == null) {
+                    // Do nothing
+                }
+                associatedMap.elementData[position] = associatedMap.elementData[position].next;
+                entry = null;
+            } else {
+                lastEntry.next = entry;
+            }
+            if(lastEntry!=null){
+            	Entry<VT> reuse = lastEntry;
+            	lastEntry = null;
+            	reuse.key = Long.MIN_VALUE;
+            	reuse.value = null;
+            	associatedMap.reuseAfterDelete = reuse;
+            }
+
+            associatedMap.elementCount--;
+            expectedModCount++;
+        }
+    }
+
+
+
+    @SuppressWarnings("unchecked")
+    Entry<V>[] newElementArray(int s) {
+        return new Entry[s];
+    }
+
+    /**
+     * Constructs a new empty {@code HashMap} instance.
+     * 
+     * @since Android 1.0
+     */
+    public LongHashMapJDBM() {
+        this(DEFAULT_SIZE);
+    }
+
+    /**
+     * Constructs a new {@code HashMap} instance with the specified capacity.
+     * 
+     * @param capacity
+     *            the initial capacity of this hash map.
+     * @throws IllegalArgumentException
+     *                when the capacity is less than zero.
+     * @since Android 1.0
+     */
+    public LongHashMapJDBM(int capacity) {
+        if (capacity >= 0) {
+            elementCount = 0;
+            elementData = newElementArray(capacity == 0 ? 1 : capacity);
+            loadFactor = 0.75f; // Default load factor of 0.75
+            computeMaxSize();
+        } else {
+            throw new IllegalArgumentException();
+        }
+    }
+
+    /**
+     * Constructs a new {@code HashMap} instance with the specified capacity and
+     * load factor.
+     * 
+     * @param capacity
+     *            the initial capacity of this hash map.
+     * @param loadFactor
+     *            the initial load factor.
+     * @throws IllegalArgumentException
+     *                when the capacity is less than zero or the load factor is
+     *                less or equal to zero.
+     * @since Android 1.0
+     */
+    public LongHashMapJDBM(int capacity, float loadFactor) {
+        if (capacity >= 0 && loadFactor > 0) {
+            elementCount = 0;
+            elementData = newElementArray(capacity == 0 ? 1 : capacity);
+            this.loadFactor = loadFactor;
+            computeMaxSize();
+        } else {
+            throw new IllegalArgumentException();
+        }
+    }
+
+
+
+    // BEGIN android-changed
+    /**
+     * Removes all mappings from this hash map, leaving it empty.
+     * 
+     * @see #isEmpty
+     * @see #size
+     * @since Android 1.0
+     */
+    
+    public void clear() {
+        if (elementCount > 0) {
+            elementCount = 0;
+            Arrays.fill(elementData, null);
+            modCount++;
+        }
+    }
+    // END android-changed
+
+    /**
+     * Returns a shallow copy of this map.
+     * 
+     * @return a shallow copy of this map.
+     * @since Android 1.0
+     */
+    
+
+    private void computeMaxSize() {
+        threshold = (int) (elementData.length * loadFactor);
+    }
+
+    /**
+     * Returns whether this map contains the specified key.
+     * 
+     * @param key
+     *            the key to search for.
+     * @return {@code true} if this map contains the specified key,
+     *         {@code false} otherwise.
+     * @since Android 1.0
+     */
+    
+    public boolean containsKey(long key) {
+            int hash = (int)(key);
+            int index = (hash & 0x7FFFFFFF) % elementData.length;
+            Entry<V> m = findNonNullKeyEntry(key, index, hash);
+        return m != null;
+    }
+
+    /**
+     * Returns whether this map contains the specified value.
+     * 
+     * @param value
+     *            the value to search for.
+     * @return {@code true} if this map contains the specified value,
+     *         {@code false} otherwise.
+     * @since Android 1.0
+     */
+    
+    public boolean containsValue(Object value) {
+        if (value != null) {
+            for (int i = elementData.length; --i >= 0;) {
+                Entry<V> entry = elementData[i];
+                while (entry != null) {
+                    if (value.equals(entry.value)) {
+                        return true;
+                    }
+                    entry = entry.next;
+                }
+            }
+        } else {
+            for (int i = elementData.length; --i >= 0;) {
+                Entry<V> entry = elementData[i];
+                while (entry != null) {
+                    if (entry.value == null) {
+                        return true;
+                    }
+                    entry = entry.next;
+                }
+            }
+        }
+        return false;
+    }
+
+
+    /**
+     * Returns the value of the mapping with the specified key.
+     * 
+     * @param key
+     *            the key.
+     * @return the value of the mapping with the specified key, or {@code null}
+     *         if no mapping for the specified key is found.
+     * @since Android 1.0
+     */
+    
+    public V get(long key) {
+        Entry<V> m;
+        int hash = (int)(key);
+        int index = (hash & 0x7FFFFFFF) % elementData.length;
+        m = findNonNullKeyEntry(key, index, hash);
+
+        if (m != null) {
+            return m.value;
+        }
+        return null;
+    }
+
+    final Entry<V> findNonNullKeyEntry(long key, int index, int keyHash) {
+        Entry<V> m = elementData[index];
+            while (m != null) {
+
+                    if (key == m.key) {
+                        return m;
+                    }
+
+                m = m.next;
+
+        }
+        return null;
+    }
+
+
+    /**
+     * Returns whether this map is empty.
+     * 
+     * @return {@code true} if this map has no elements, {@code false}
+     *         otherwise.
+     * @see #size()
+     * @since Android 1.0
+     */
+    
+    public boolean isEmpty() {
+        return elementCount == 0;
+    }
+
+    /**
+     * @return iterator over keys
+     */
+    
+//      public Iterator<K> keyIterator(){
+//                 return new HashMapIterator<K, K, V>(
+//                            new MapEntry.Type<K, K, V>() {
+//                                public K get(Entry<K, V> entry) {
+//                                    return entry.key;
+//                                }
+//                            }, HashMap.this);
+//
+//     }
+
+    /**
+     * Maps the specified key to the specified value.
+     * 
+     * @param key
+     *            the key.
+     * @param value
+     *            the value.
+     * @return the value of any previous mapping with the specified key or
+     *         {@code null} if there was no such mapping.
+     * @since Android 1.0
+     */
+    
+
+    public V put(long key, V value) {
+        Entry<V> entry;
+            int hash =(int)(key);
+            int index = (hash & 0x7FFFFFFF) % elementData.length;
+            entry = findNonNullKeyEntry(key, index, hash);
+            if (entry == null) {
+                modCount++;
+                if (++elementCount > threshold) {
+                    rehash();
+                    index = (hash & 0x7FFFFFFF) % elementData.length;
+                }
+                entry = createHashedEntry(key, index);
+            }
+
+
+        V result = entry.value;
+        entry.value = value;
+        return result;
+    }
+
+    Entry<V> createEntry(long key, int index, V value) {
+        Entry<V> entry = reuseAfterDelete; 
+        if(entry == null){ 
+        	entry = new Entry<V>(key, value);
+        }else{
+        	reuseAfterDelete = null;
+        	entry.key = key;
+        	entry.value = value;
+        }
+        
+        entry.next = elementData[index];
+        elementData[index] = entry;
+        return entry;
+    }
+
+    Entry<V> createHashedEntry(long key, int index) {
+        Entry<V> entry = reuseAfterDelete; 
+        if(entry == null) {
+        	entry = new Entry<V>(key);
+        }else{
+        	reuseAfterDelete = null;
+        	entry.key = key;
+        	entry.value = null;
+        }
+
+        entry.next = elementData[index];
+        elementData[index] = entry;
+        return entry;
+    }
+
+
+    void rehash(int capacity) {
+        int length = (capacity == 0 ? 1 : capacity << 1);
+
+        Entry<V>[] newData = newElementArray(length);
+        for (int i = 0; i < elementData.length; i++) {
+            Entry<V> entry = elementData[i];
+            while (entry != null) {
+                int index = ((int)entry.key & 0x7FFFFFFF) % length;
+                Entry<V> next = entry.next;
+                entry.next = newData[index];
+                newData[index] = entry;
+                entry = next;
+            }
+        }
+        elementData = newData;
+        computeMaxSize();
+    }
+
+    void rehash() {
+        rehash(elementData.length);
+    }
+
+    /**
+     * Removes the mapping with the specified key from this map.
+     * 
+     * @param key
+     *            the key of the mapping to remove.
+     * @return the value of the removed mapping or {@code null} if no mapping
+     *         for the specified key was found.
+     * @since Android 1.0
+     */
+    
+    public V remove(long key) {
+        Entry<V> entry = removeEntry(key);
+        if(entry == null)
+        	return null;
+        V ret = entry.value;
+        entry.value = null;
+        entry.key = Long.MIN_VALUE;
+        reuseAfterDelete = entry;
+        
+        return ret;
+    }
+
+    Entry<V> removeEntry(long key) {
+        int index = 0;
+        Entry<V> entry;
+        Entry<V> last = null;
+
+        int hash = (int)(key);
+        index = (hash & 0x7FFFFFFF) % elementData.length;
+        entry = elementData[index];
+         while (entry != null && !(/*((int)entry.key) == hash &&*/ key == entry.key)) {
+             last = entry;
+              entry = entry.next;
+         }
+         
+         if (entry == null) {
+             return null;
+         }
+         
+        if (last == null) {
+            elementData[index] = entry.next;
+        } else {
+            last.next = entry.next;
+        }
+        modCount++;
+        elementCount--;
+        return entry;
+    }
+
+    /**
+     * Returns the number of elements in this map.
+     * 
+     * @return the number of elements in this map.
+     * @since Android 1.0
+     */
+    
+    public int size() {
+        return elementCount;
+    }
+
+    /**
+     * @returns iterator over values in map
+     */
+    public Iterator<V> valuesIterator() {
+        return new HashMapIterator<V, V>(
+                new EntryType<V,  V>() {
+                    public V get(Entry< V> entry) {
+                        return entry.value;
+                    }
+                }, LongHashMapJDBM.this);
+
+    }
+
+
+}
+
+
+
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/target/LongSparseArray.java b/DaoTest/src/de/greenrobot/daotest/performance/target/LongSparseArray.java
new file mode 100644
index 00000000..f515ad05
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/performance/target/LongSparseArray.java
@@ -0,0 +1,364 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package de.greenrobot.daotest.performance.target;
+
+import android.util.Log;
+
+/**
+ * SparseArrays map longs to Objects.  Unlike a normal array of Objects,
+ * there can be gaps in the indices.  It is intended to be more efficient
+ * than using a HashMap to map Longs to Objects.
+ *
+ * @hide
+ */
+public class LongSparseArray<E> {
+    private static final Object DELETED = new Object();
+    private boolean mGarbage = false;
+
+    /**
+     * Creates a new SparseArray containing no mappings.
+     */
+    public LongSparseArray() {
+        this(10);
+    }
+
+    /**
+     * Creates a new SparseArray containing no mappings that will not
+     * require any additional memory allocation to store the specified
+     * number of mappings.
+     */
+    public LongSparseArray(int initialCapacity) {
+        initialCapacity = ArrayUtils.idealIntArraySize(initialCapacity);
+
+        mKeys = new long[initialCapacity];
+        mValues = new Object[initialCapacity];
+        mSize = 0;
+    }
+    
+    /**
+     * @return A copy of all keys contained in the sparse array.
+     */
+    public long[] getKeys() {
+        int length = mKeys.length;
+        long[] result = new long[length];
+        System.arraycopy(mKeys, 0, result, 0, length);
+        return result;
+    }
+    
+    /**
+     * Sets all supplied keys to the given unique value.
+     * @param keys Keys to set
+     * @param uniqueValue Value to set all supplied keys to
+     */
+    public void setValues(long[] keys, E uniqueValue) {
+        int length = keys.length;
+        for (int i = 0; i < length; i++) {
+            put(keys[i], uniqueValue);
+        }
+    }
+
+    /**
+     * Gets the Object mapped from the specified key, or <code>null</code>
+     * if no such mapping has been made.
+     */
+    public E get(long key) {
+        return get(key, null);
+    }
+
+    /**
+     * Gets the Object mapped from the specified key, or the specified Object
+     * if no such mapping has been made.
+     */
+    public E get(long key, E valueIfKeyNotFound) {
+        int i = binarySearch(mKeys, 0, mSize, key);
+
+        if (i < 0 || mValues[i] == DELETED) {
+            return valueIfKeyNotFound;
+        } else {
+            return (E) mValues[i];
+        }
+    }
+
+    /**
+     * Removes the mapping from the specified key, if there was any.
+     */
+    public void delete(long key) {
+        int i = binarySearch(mKeys, 0, mSize, key);
+
+        if (i >= 0) {
+            if (mValues[i] != DELETED) {
+                mValues[i] = DELETED;
+                mGarbage = true;
+            }
+        }
+    }
+
+    /**
+     * Alias for {@link #delete(long)}.
+     */
+    public void remove(long key) {
+        delete(key);
+    }
+
+    private void gc() {
+        // Log.e("SparseArray", "gc start with " + mSize);
+
+        int n = mSize;
+        int o = 0;
+        long[] keys = mKeys;
+        Object[] values = mValues;
+
+        for (int i = 0; i < n; i++) {
+            Object val = values[i];
+
+            if (val != DELETED) {
+                if (i != o) {
+                    keys[o] = keys[i];
+                    values[o] = val;
+                }
+
+                o++;
+            }
+        }
+
+        mGarbage = false;
+        mSize = o;
+
+        // Log.e("SparseArray", "gc end with " + mSize);
+    }
+
+    /**
+     * Adds a mapping from the specified key to the specified value,
+     * replacing the previous mapping from the specified key if there
+     * was one.
+     */
+    public void put(long key, E value) {
+        int i = binarySearch(mKeys, 0, mSize, key);
+
+        if (i >= 0) {
+            mValues[i] = value;
+        } else {
+            i = ~i;
+
+            if (i < mSize && mValues[i] == DELETED) {
+                mKeys[i] = key;
+                mValues[i] = value;
+                return;
+            }
+
+            if (mGarbage && mSize >= mKeys.length) {
+                gc();
+
+                // Search again because indices may have changed.
+                i = ~binarySearch(mKeys, 0, mSize, key);
+            }
+
+            if (mSize >= mKeys.length) {
+                int n = ArrayUtils.idealIntArraySize(mSize + 1);
+
+                long[] nkeys = new long[n];
+                Object[] nvalues = new Object[n];
+
+                // Log.e("SparseArray", "grow " + mKeys.length + " to " + n);
+                System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
+                System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
+
+                mKeys = nkeys;
+                mValues = nvalues;
+            }
+
+            if (mSize - i != 0) {
+                // Log.e("SparseArray", "move " + (mSize - i));
+                System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
+                System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
+            }
+
+            mKeys[i] = key;
+            mValues[i] = value;
+            mSize++;
+        }
+    }
+
+    /**
+     * Returns the number of key-value mappings that this SparseArray
+     * currently stores.
+     */
+    public int size() {
+        if (mGarbage) {
+            gc();
+        }
+
+        return mSize;
+    }
+
+    /**
+     * Given an index in the range <code>0...size()-1</code>, returns
+     * the key from the <code>index</code>th key-value mapping that this
+     * SparseArray stores.
+     */
+    public long keyAt(int index) {
+        if (mGarbage) {
+            gc();
+        }
+
+        return mKeys[index];
+    }
+
+    /**
+     * Given an index in the range <code>0...size()-1</code>, returns
+     * the value from the <code>index</code>th key-value mapping that this
+     * SparseArray stores.
+     */
+    public E valueAt(int index) {
+        if (mGarbage) {
+            gc();
+        }
+
+        return (E) mValues[index];
+    }
+
+    /**
+     * Given an index in the range <code>0...size()-1</code>, sets a new
+     * value for the <code>index</code>th key-value mapping that this
+     * SparseArray stores.
+     */
+    public void setValueAt(int index, E value) {
+        if (mGarbage) {
+            gc();
+        }
+
+        mValues[index] = value;
+    }
+
+    /**
+     * Returns the index for which {@link #keyAt} would return the
+     * specified key, or a negative number if the specified
+     * key is not mapped.
+     */
+    public int indexOfKey(long key) {
+        if (mGarbage) {
+            gc();
+        }
+
+        return binarySearch(mKeys, 0, mSize, key);
+    }
+
+    /**
+     * Returns an index for which {@link #valueAt} would return the
+     * specified key, or a negative number if no keys map to the
+     * specified value.
+     * Beware that this is a linear search, unlike lookups by key,
+     * and that multiple keys can map to the same value and this will
+     * find only one of them.
+     */
+    public int indexOfValue(E value) {
+        if (mGarbage) {
+            gc();
+        }
+
+        for (int i = 0; i < mSize; i++)
+            if (mValues[i] == value)
+                return i;
+
+        return -1;
+    }
+
+    /**
+     * Removes all key-value mappings from this SparseArray.
+     */
+    public void clear() {
+        int n = mSize;
+        Object[] values = mValues;
+
+        for (int i = 0; i < n; i++) {
+            values[i] = null;
+        }
+
+        mSize = 0;
+        mGarbage = false;
+    }
+
+    /**
+     * Puts a key/value pair into the array, optimizing for the case where
+     * the key is greater than all existing keys in the array.
+     */
+    public void append(long key, E value) {
+        if (mSize != 0 && key <= mKeys[mSize - 1]) {
+            put(key, value);
+            return;
+        }
+
+        if (mGarbage && mSize >= mKeys.length) {
+            gc();
+        }
+
+        int pos = mSize;
+        if (pos >= mKeys.length) {
+            int n = ArrayUtils.idealIntArraySize(pos + 1);
+
+            long[] nkeys = new long[n];
+            Object[] nvalues = new Object[n];
+
+            // Log.e("SparseArray", "grow " + mKeys.length + " to " + n);
+            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
+            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
+
+            mKeys = nkeys;
+            mValues = nvalues;
+        }
+
+        mKeys[pos] = key;
+        mValues[pos] = value;
+        mSize = pos + 1;
+    }
+
+    private static int binarySearch(long[] a, int start, int len, long key) {
+        int high = start + len, low = start - 1, guess;
+
+        while (high - low > 1) {
+            guess = (high + low) / 2;
+
+            if (a[guess] < key)
+                low = guess;
+            else
+                high = guess;
+        }
+
+        if (high == start + len)
+            return ~(start + len);
+        else if (a[high] == key)
+            return high;
+        else
+            return ~high;
+    }
+
+    private void checkIntegrity() {
+        for (int i = 1; i < mSize; i++) {
+            if (mKeys[i] <= mKeys[i - 1]) {
+                for (int j = 0; j < mSize; j++) {
+                    Log.e("FAIL", j + ": " + mKeys[j] + " -> " + mValues[j]);
+                }
+
+                throw new RuntimeException();
+            }
+        }
+    }
+
+    private long[] mKeys;
+    private Object[] mValues;
+    private int mSize;
+}
\ No newline at end of file
diff --git a/DaoTest/src/de/greenrobot/daotest/query/CountQueryTest.java b/DaoTest/src/de/greenrobot/daotest/query/CountQueryTest.java
new file mode 100644
index 00000000..12bd4a21
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/query/CountQueryTest.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.sql.SQLException;
+import java.util.ArrayList;
+
+import de.greenrobot.dao.query.CountQuery;
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+// TODO more tests
+public class CountQueryTest extends TestEntityTestBase {
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    public void testCountQuerySimple() throws SQLException {
+        int value = getSimpleInteger(1);
+        CountQuery<TestEntity> query = dao.queryBuilder().where(Properties.SimpleInteger.eq(value)).buildCount();
+        assertEquals(0, query.count());
+
+        ArrayList<TestEntity> inserted = insert(3);
+        assertEquals(1, query.count());
+
+        inserted.get(2).setSimpleInteger(value);
+        dao.update(inserted.get(2));
+        assertEquals(2, query.count());
+
+        dao.deleteAll();
+        assertEquals(0, query.count());
+    }
+
+    public void testCountQueryTwoParameters() throws SQLException {
+        int value = getSimpleInteger(1);
+        String valueString = getSimpleString(1);
+        
+        QueryBuilder<TestEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.where(Properties.SimpleInteger.eq(value), Properties.SimpleString.eq(valueString));
+        CountQuery<TestEntity> query = queryBuilder.buildCount();
+        assertEquals(0, query.count());
+
+        ArrayList<TestEntity> inserted = insert(3);
+        assertEquals(1, query.count());
+
+        inserted.get(2).setSimpleInteger(value);
+        dao.update(inserted.get(2));
+        assertEquals(1, query.count());
+        
+        inserted.get(2).setSimpleString(valueString);
+        dao.update(inserted.get(2));
+        assertEquals(2, query.count());
+
+        dao.deleteAll();
+        assertEquals(0, query.count());
+    }
+
+    public void testCountQueryTwoParametersOr() throws SQLException {
+        int value = getSimpleInteger(1);
+        String valueString = getSimpleString(2);
+        
+        QueryBuilder<TestEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.whereOr(Properties.SimpleInteger.eq(value), Properties.SimpleString.eq(valueString));
+        CountQuery<TestEntity> query = queryBuilder.buildCount();
+        assertEquals(0, query.count());
+
+        ArrayList<TestEntity> inserted = insert(3);
+        assertEquals(2, query.count());
+
+        inserted.get(1).setSimpleInteger(getSimpleInteger(2));
+        dao.update(inserted.get(1));
+        assertEquals(1, query.count());
+        
+        inserted.get(2).setSimpleString(getSimpleString(3));
+        dao.update(inserted.get(2));
+        assertEquals(0, query.count());
+    }
+
+    public void testCountQueryChangeParameter() throws SQLException {
+        insert(3);
+
+        String value = "not existing value";
+        CountQuery<TestEntity> query = dao.queryBuilder().where(Properties.SimpleString.eq(value)).buildCount();
+        assertEquals(0, query.count());
+        query.setParameter(0, getSimpleString(1));
+        assertEquals(1, query.count());
+        query.setParameter(0, getSimpleString(2));
+        assertEquals(1, query.count());
+        query.setParameter(0, "you won't find me either");
+        assertEquals(0, query.count());
+    }
+
+    public void testBuildQueryAndCountQuery() throws SQLException {
+        insert(3);
+        int value = getSimpleInteger(1);
+
+        QueryBuilder<TestEntity> builder = dao.queryBuilder().where(Properties.SimpleInteger.eq(value));
+        Query<TestEntity> query = builder.build();
+        CountQuery<TestEntity> countQuery = builder.buildCount();
+
+        assertEquals(1, query.list().size());
+        assertEquals(1, countQuery.count());
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/CountQueryThreadLocalTest.java b/DaoTest/src/de/greenrobot/daotest/query/CountQueryThreadLocalTest.java
new file mode 100644
index 00000000..ee4c466f
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/query/CountQueryThreadLocalTest.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2011-2013 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.sql.SQLException;
+
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.query.CountQuery;
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+public class CountQueryThreadLocalTest extends TestEntityTestBase {
+    private CountQuery<TestEntity> queryFromOtherThread;
+
+    public void testGetForCurrentThread_SameInstance() {
+        CountQuery<TestEntity> query = dao.queryBuilder().buildCount();
+        assertSame(query, query.forCurrentThread());
+    }
+
+    public void testGetForCurrentThread_ParametersAreReset() throws SQLException {
+        insert(3);
+        int value = getSimpleInteger(1);
+        CountQuery<TestEntity> query = dao.queryBuilder().where(Properties.SimpleInteger.eq(value)).buildCount();
+        query.setParameter(0, value + 100);
+        assertEquals(0, query.count());
+        query = query.forCurrentThread();
+        assertEquals(1, query.count());
+    }
+
+    public void testGetForCurrentThread_TwoThreads() throws InterruptedException, SQLException {
+        insert(3);
+        createQueryFromOtherThread();
+        CountQuery<TestEntity> query = queryFromOtherThread.forCurrentThread();
+        assertNotSame(queryFromOtherThread, query);
+        assertEquals(1, query.count());
+        query.setParameter(0, -10);
+        assertEquals(0, query.count());
+    }
+
+    public void testThrowOutsideOwnerThread() throws InterruptedException, SQLException {
+        createQueryFromOtherThread();
+        try {
+            queryFromOtherThread.count();
+            fail("Did not throw");
+        } catch (DaoException expected) {
+        }
+        try {
+            queryFromOtherThread.setParameter(0, 42);
+            fail("Did not throw");
+        } catch (DaoException expected) {
+        }
+    }
+
+    private void createQueryFromOtherThread() throws InterruptedException {
+        Thread thread = new Thread() {
+
+            @Override
+            public void run() {
+                QueryBuilder<TestEntity> builder = dao.queryBuilder();
+                builder.where(Properties.SimpleInteger.eq(getSimpleInteger(1)));
+                queryFromOtherThread = builder.buildCount();
+            }
+        };
+        thread.start();
+        thread.join();
+        assertNotNull(queryFromOtherThread);
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/DeleteQueryTest.java b/DaoTest/src/de/greenrobot/daotest/query/DeleteQueryTest.java
new file mode 100644
index 00000000..b313bc5c
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/query/DeleteQueryTest.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.List;
+
+import de.greenrobot.dao.query.DeleteQuery;
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+// TODO more tests
+public class DeleteQueryTest extends TestEntityTestBase {
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    public void testDeleteQuerySimple() throws SQLException {
+        ArrayList<TestEntity> inserted = insert(3);
+        int value = getSimpleInteger(1);
+        inserted.get(2).setSimpleInteger(value);
+        dao.update(inserted.get(2));
+
+        DeleteQuery<TestEntity> deleteQuery = dao.queryBuilder().where(Properties.SimpleInteger.eq(value))
+                .buildDelete();
+
+        deleteQuery.executeDeleteWithoutDetachingEntities();
+
+        List<TestEntity> allAfterDelete = dao.loadAll();
+        assertEquals(1, allAfterDelete.size());
+        assertEquals(getSimpleInteger(0), (int) allAfterDelete.get(0).getSimpleInteger());
+    }
+
+    public void testDeleteQueryOr() throws SQLException {
+        ArrayList<TestEntity> inserted = insert(3);
+
+        QueryBuilder<TestEntity> queryBuilder = dao.queryBuilder();
+        Integer value1 = inserted.get(0).getSimpleInteger();
+        Integer value2 = inserted.get(2).getSimpleInteger();
+        queryBuilder.whereOr(Properties.SimpleInteger.eq(value1), Properties.SimpleInteger.eq(value2));
+        DeleteQuery<TestEntity> deleteQuery = queryBuilder.buildDelete();
+
+        deleteQuery.executeDeleteWithoutDetachingEntities();
+
+        List<TestEntity> allAfterDelete = dao.loadAll();
+        assertEquals(1, allAfterDelete.size());
+        assertEquals(inserted.get(1).getSimpleInteger(), allAfterDelete.get(0).getSimpleInteger());
+    }
+
+    public void testDeleteQueryExecutingMultipleTimes() throws SQLException {
+        insert(3);
+
+        String value = getSimpleString(1);
+        DeleteQuery<TestEntity> deleteQuery = dao.queryBuilder().where(Properties.SimpleString.eq(value)).buildDelete();
+        deleteQuery.executeDeleteWithoutDetachingEntities();
+        assertEquals(2, dao.count());
+
+        deleteQuery.executeDeleteWithoutDetachingEntities();
+        assertEquals(2, dao.count());
+
+        insert(3);
+        assertEquals(5, dao.count());
+
+        deleteQuery.executeDeleteWithoutDetachingEntities();
+        assertEquals(4, dao.count());
+    }
+
+    public void testDeleteQueryChangeParameter() throws SQLException {
+        insert(3);
+
+        String value = getSimpleString(1);
+        DeleteQuery<TestEntity> deleteQuery = dao.queryBuilder().where(Properties.SimpleString.eq(value)).buildDelete();
+        deleteQuery.executeDeleteWithoutDetachingEntities();
+        assertEquals(2, dao.count());
+
+        deleteQuery.setParameter(0, getSimpleString(0));
+        deleteQuery.executeDeleteWithoutDetachingEntities();
+        assertEquals(1, dao.count());
+
+        TestEntity remaining = dao.loadAll().get(0);
+        assertEquals(getSimpleString(2), remaining.getSimpleString());
+    }
+
+    public void testBuildQueryAndDeleteQuery() throws SQLException {
+        insert(3);
+        int value = getSimpleInteger(1);
+
+        QueryBuilder<TestEntity> builder = dao.queryBuilder().where(Properties.SimpleInteger.eq(value));
+        Query<TestEntity> query = builder.build();
+        DeleteQuery<TestEntity> deleteQuery = builder.buildDelete();
+
+        assertEquals(1, query.list().size());
+        deleteQuery.executeDeleteWithoutDetachingEntities();
+        assertEquals(0, query.list().size());
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/DeleteQueryThreadLocalTest.java b/DaoTest/src/de/greenrobot/daotest/query/DeleteQueryThreadLocalTest.java
new file mode 100644
index 00000000..ae8cfd97
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/query/DeleteQueryThreadLocalTest.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2011-2013 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.sql.SQLException;
+
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.query.DeleteQuery;
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+public class DeleteQueryThreadLocalTest extends TestEntityTestBase {
+    private DeleteQuery<TestEntity> queryFromOtherThread;
+
+    public void testGetForCurrentThread_SameInstance() {
+        DeleteQuery<TestEntity> query = dao.queryBuilder().buildDelete();
+        assertSame(query, query.forCurrentThread());
+    }
+
+    public void testGetForCurrentThread_ParametersAreReset() throws SQLException {
+        insert(3);
+        int value = getSimpleInteger(1);
+        DeleteQuery<TestEntity> query = dao.queryBuilder().where(Properties.SimpleInteger.eq(value)).buildDelete();
+        query.setParameter(0, value + 100);
+        query.executeDeleteWithoutDetachingEntities();
+        assertEquals(3, dao.count());
+        query = query.forCurrentThread();
+        query.executeDeleteWithoutDetachingEntities();
+        assertEquals(2, dao.count());
+    }
+
+    public void testGetForCurrentThread_TwoThreads() throws InterruptedException, SQLException {
+        insert(3);
+        createQueryFromOtherThread();
+        DeleteQuery<TestEntity> query = queryFromOtherThread.forCurrentThread();
+        assertNotSame(queryFromOtherThread, query);
+        query.setParameter(0, getSimpleInteger(2));
+        query.executeDeleteWithoutDetachingEntities();
+        assertEquals(2, dao.count());
+    }
+
+    public void testThrowOutsideOwnerThread() throws InterruptedException, SQLException {
+        createQueryFromOtherThread();
+        try {
+            queryFromOtherThread.executeDeleteWithoutDetachingEntities();
+            fail("Did not throw");
+        } catch (DaoException expected) {
+        }
+        try {
+            queryFromOtherThread.setParameter(0, 42);
+            fail("Did not throw");
+        } catch (DaoException expected) {
+        }
+    }
+
+    private void createQueryFromOtherThread() throws InterruptedException {
+        Thread thread = new Thread() {
+
+            @Override
+            public void run() {
+                QueryBuilder<TestEntity> builder = dao.queryBuilder();
+                builder.where(Properties.SimpleInteger.eq(getSimpleInteger(1)));
+                queryFromOtherThread = builder.buildDelete();
+            }
+        };
+        thread.start();
+        thread.join();
+        assertNotNull(queryFromOtherThread);
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/LazyListTest.java b/DaoTest/src/de/greenrobot/daotest/query/LazyListTest.java
new file mode 100644
index 00000000..316bdca9
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/query/LazyListTest.java
@@ -0,0 +1,188 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.ListIterator;
+import java.util.NoSuchElementException;
+
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.query.CloseableListIterator;
+import de.greenrobot.dao.query.LazyList;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+public class LazyListTest extends TestEntityTestBase {
+
+    public void testSizeAndGetAndPeak() throws SQLException {
+        ArrayList<TestEntity> list = insert(2);
+
+        LazyList<TestEntity> listLazy = dao.queryBuilder().build().listLazy();
+        assertEquals(list.size(), listLazy.size());
+        assertNull(listLazy.peak(0));
+        assertNull(listLazy.peak(1));
+
+        assertNotNull(listLazy.get(1));
+        assertNull(listLazy.peak(0));
+        assertNotNull(listLazy.peak(1));
+
+        assertNotNull(listLazy.get(0));
+        assertNotNull(listLazy.peak(0));
+        assertNotNull(listLazy.peak(1));
+    }
+
+    public void testGetAll100() throws SQLException {
+        ArrayList<TestEntity> list = insert(100);
+        LazyList<TestEntity> listLazy = dao.queryBuilder().orderAsc(Properties.SimpleInteger).build().listLazy();
+        assertIds(list, listLazy);
+        assertTrue(listLazy.isClosed());
+    }
+
+    public void testGetAll100Uncached() throws SQLException {
+        ArrayList<TestEntity> list = insert(100);
+        LazyList<TestEntity> listLazy = dao.queryBuilder().orderAsc(Properties.SimpleInteger).build()
+                .listLazyUncached();
+        assertIds(list, listLazy);
+        assertFalse(listLazy.isClosed());
+        listLazy.close();
+    }
+
+    public void testIterator() throws SQLException {
+        ArrayList<TestEntity> list = insert(100);
+        LazyList<TestEntity> listLazy = dao.queryBuilder().orderAsc(Properties.SimpleInteger).build().listLazy();
+        testIerator(list, listLazy, false);
+        assertTrue(listLazy.isClosed());
+    }
+
+    public void testIteratorUncached() throws SQLException {
+        ArrayList<TestEntity> list = insert(100);
+        LazyList<TestEntity> listLazy = dao.queryBuilder().orderAsc(Properties.SimpleInteger).build()
+                .listLazyUncached();
+        testIerator(list, listLazy, true);
+        assertFalse(listLazy.isClosed());
+        listLazy.close();
+    }
+
+    protected void testIerator(ArrayList<TestEntity> list, LazyList<TestEntity> listLazy, boolean uncached) {
+        ListIterator<TestEntity> iterator = listLazy.listIterator();
+        try {
+            iterator.previous();
+            fail("previous should throw here");
+        } catch (NoSuchElementException expected) {
+            // OK
+        }
+        int size = list.size();
+        for (int i = 0; i < size; i++) {
+            assertTrue(iterator.hasNext());
+            assertEquals(i > 0, iterator.hasPrevious());
+            assertEquals(i, iterator.nextIndex());
+            assertEquals(i - 1, iterator.previousIndex());
+
+            if (i > 0) {
+                TestEntity entityPrevious = list.get(i - 1);
+                assertEquals(entityPrevious.getId(), iterator.previous().getId());
+                iterator.next();
+            }
+
+            TestEntity entity = list.get(i);
+            assertNull(listLazy.peak(i));
+            TestEntity lazyEntity = iterator.next();
+            if (uncached) {
+                assertNull(listLazy.peak(i));
+            } else {
+                assertNotNull(listLazy.peak(i));
+            }
+            assertEquals(entity.getId(), lazyEntity.getId());
+        }
+        assertFalse(iterator.hasNext());
+        try {
+            iterator.next();
+            fail("next should throw here");
+        } catch (NoSuchElementException expected) {
+            // OK
+        }
+    }
+
+    public void testEmpty() throws SQLException {
+        insert(1);
+
+        LazyList<TestEntity> listLazy = dao.queryBuilder().where(Properties.SimpleInteger.eq(-1)).build().listLazy();
+        assertTrue(listLazy.isEmpty());
+        assertTrue(listLazy.isClosed());
+        try {
+            listLazy.get(0);
+            fail("Not empty");
+        } catch (RuntimeException e) {
+            // Expected, OK
+        }
+
+    }
+
+    public void testUncached() throws SQLException {
+        insert(1);
+
+        LazyList<TestEntity> listLazy = dao.queryBuilder().build().listLazyUncached();
+        assertFalse(listLazy.isEmpty());
+        assertFalse(listLazy.isClosed());
+        TestEntity entity1 = listLazy.get(0);
+        TestEntity entity2 = listLazy.get(0);
+        assertEquals(entity1.getId(), entity2.getId());
+        if (identityScopeForDao == null) {
+            assertNotSame(entity1, entity2);
+        } else {
+            assertSame(entity1, entity2);
+        }
+        assertFalse(listLazy.isClosed());
+        try {
+            listLazy.loadRemaining();
+            fail("Not empty");
+        } catch (DaoException expected) {
+            // Expected, OK
+        }
+        listLazy.close();
+        assertTrue(listLazy.isClosed());
+    }
+
+    public void testClose() throws SQLException {
+        insert(1);
+
+        LazyList<TestEntity> listLazy = dao.queryBuilder().build().listLazy();
+        assertFalse(listLazy.isEmpty());
+        assertFalse(listLazy.isClosed());
+        listLazy.get(0);
+        assertTrue(listLazy.isClosed());
+
+        // Closing again should not harm
+        listLazy.close();
+        listLazy.close();
+    }
+
+    public void testAutoClose() throws SQLException {
+        insert(10);
+        LazyList<TestEntity> lazyList = dao.queryBuilder().build().listLazyUncached();
+        CloseableListIterator<TestEntity> iterator = lazyList.listIteratorAutoClose();
+        while (iterator.hasNext()) {
+            assertFalse(lazyList.isClosed());
+            iterator.next();
+        }
+        assertTrue(lazyList.isClosed());
+    }
+    
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderAndOrTest.java b/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderAndOrTest.java
new file mode 100644
index 00000000..387245c8
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderAndOrTest.java
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.List;
+
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.dao.test.AbstractDaoTest;
+import de.greenrobot.daotest.AbcdefEntity;
+import de.greenrobot.daotest.AbcdefEntityDao;
+import de.greenrobot.daotest.AbcdefEntityDao.Properties;
+
+public class QueryBuilderAndOrTest extends AbstractDaoTest<AbcdefEntityDao, AbcdefEntity, Long> {
+
+    public QueryBuilderAndOrTest() {
+        super(AbcdefEntityDao.class);
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    protected ArrayList<AbcdefEntity> insert(int count) throws SQLException {
+        ArrayList<AbcdefEntity> list = new ArrayList<AbcdefEntity>();
+        for (int i = 0; i < count; i++) {
+            int base = i * 100;
+            AbcdefEntity entity = new AbcdefEntity(null, base + 1, base + 2, base + 3, base + 4, base + 5, base + 6,
+                    base + 7, base + 8, base + 9, base + 10, base + 11);
+            list.add(entity);
+        }
+        dao.insertInTx(list);
+        return list;
+    }
+
+    public void testSimpleQuery() throws SQLException {
+        insert(3);
+
+        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder().where(Properties.A.eq(1)).orderAsc(Properties.A);
+        List<AbcdefEntity> result = queryBuilder.list();
+        assertEquals(1, result.size());
+        assertEquals(1, queryBuilder.count());
+
+        AbcdefEntity resultEntity = result.get(0);
+        assertEquals(1, (int) resultEntity.getA());
+
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+    public void testOr() throws SQLException {
+        insert(3);
+
+        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.whereOr(Properties.A.eq(1), Properties.A.eq(101));
+        List<AbcdefEntity> result = queryBuilder.orderAsc(Properties.A).list();
+        assertEquals(2, result.size());
+        assertEquals(2, queryBuilder.count());
+
+        assertEquals(1, (int) result.get(0).getA());
+        assertEquals(101, (int) result.get(1).getA());
+
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+    public void testOr3() throws SQLException {
+        insert(5);
+
+        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.whereOr(Properties.A.eq(1), Properties.A.eq(101), Properties.B.eq(302));
+        List<AbcdefEntity> result = queryBuilder.orderAsc(Properties.A).list();
+        assertEquals(3, result.size());
+        assertEquals(3, queryBuilder.count());
+
+        assertEquals(1, (int) result.get(0).getA());
+        assertEquals(101, (int) result.get(1).getA());
+        assertEquals(301, (int) result.get(2).getA());
+
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+    public void testOrNested() throws SQLException {
+        insert(10);
+
+        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.whereOr(Properties.A.eq(101), //
+                Properties.B.eq(302), Properties.C.eq(603));
+        List<AbcdefEntity> result = queryBuilder.orderAsc(Properties.A).list();
+        assertEquals(3, result.size());
+        assertEquals(3, queryBuilder.count());
+
+        assertEquals(101, (int) result.get(0).getA());
+        assertEquals(301, (int) result.get(1).getA());
+        assertEquals(601, (int) result.get(2).getA());
+
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+    public void testOrNestedNested() throws SQLException {
+        insert(10);
+
+        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.whereOr(Properties.A.eq(101), //
+                queryBuilder.or(Properties.B.eq(302), //
+                        queryBuilder.or(Properties.C.eq(503), Properties.D.eq(804))));
+        List<AbcdefEntity> result = queryBuilder.orderAsc(Properties.A).list();
+        assertEquals(4, result.size());
+        assertEquals(4, queryBuilder.count());
+
+        assertEquals(101, (int) result.get(0).getA());
+        assertEquals(301, (int) result.get(1).getA());
+        assertEquals(501, (int) result.get(2).getA());
+        assertEquals(801, (int) result.get(3).getA());
+
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+    public void testAnd() throws SQLException {
+        insert(5);
+
+        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.where(Properties.A.eq(201), Properties.B.eq(202));
+        List<AbcdefEntity> result = queryBuilder.orderAsc(Properties.A).list();
+        assertEquals(1, result.size());
+        assertEquals(1, queryBuilder.count());
+
+        assertEquals(201, (int) result.get(0).getA());
+
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+    public void testOrAnd() throws SQLException {
+        insert(10);
+
+        QueryBuilder<AbcdefEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.whereOr(Properties.A.eq(201), //
+                queryBuilder.and(Properties.B.gt(402), Properties.C.lt(703)));
+        List<AbcdefEntity> result = queryBuilder.orderAsc(Properties.A).list();
+        assertEquals(3, result.size());
+        assertEquals(3, queryBuilder.count());
+
+        assertEquals(201, (int) result.get(0).getA());
+        assertEquals(501, (int) result.get(1).getA());
+        assertEquals(601, (int) result.get(2).getA());
+
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderOrderTest.java b/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderOrderTest.java
new file mode 100644
index 00000000..9533d27d
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderOrderTest.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+public class QueryBuilderOrderTest extends TestEntityTestBase {
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    public void testOrderAsc() throws SQLException {
+        ArrayList<TestEntity> inserted = insert(2);
+        TestEntity entity = inserted.get(0);
+        List<TestEntity> result = dao.queryBuilder().orderAsc(Properties.SimpleInteger).list();
+        assertEquals(2, result.size());
+        assertEquals(entity.getId(), result.get(0).getId());
+        result = dao.queryBuilder().orderAsc(Properties.SimpleInteger, Properties.SimpleString).list();
+        assertEquals(2, result.size());
+        assertEquals(entity.getId(), result.get(0).getId());
+    }
+
+    public void testOrderDesc() throws SQLException {
+        ArrayList<TestEntity> inserted = insert(2);
+        TestEntity entity = inserted.get(1);
+        List<TestEntity> result = dao.queryBuilder().orderDesc(Properties.SimpleInteger).list();
+        assertEquals(2, result.size());
+        assertEquals(entity.getId(), result.get(0).getId());
+        result = dao.queryBuilder().orderDesc(Properties.SimpleInteger, Properties.SimpleString).list();
+        assertEquals(2, result.size());
+        assertEquals(entity.getId(), result.get(0).getId());
+    }
+
+    public void testOrderUpperLowercase() throws SQLException {
+        List<TestEntity> list = new ArrayList<TestEntity>();
+        TestEntity entityAA = addEntity(list, "aa");
+        TestEntity entityAB = addEntity(list, "Ab");
+        TestEntity entityAC = addEntity(list, "ac");
+        TestEntity entityZA = addEntity(list, "ZA");
+        TestEntity entityZB = addEntity(list, "zB");
+        TestEntity entityZC = addEntity(list, "ZC");
+        Collections.shuffle(list);
+        dao.insertInTx(list);
+
+        List<TestEntity> result = dao.queryBuilder().orderAsc(Properties.SimpleString).list();
+        assertEquals(list.size(), result.size());
+        assertEquals(entityAA.getId(), result.get(0).getId());
+        assertEquals(entityAB.getId(), result.get(1).getId());
+        assertEquals(entityAC.getId(), result.get(2).getId());
+        assertEquals(entityZA.getId(), result.get(3).getId());
+        assertEquals(entityZB.getId(), result.get(4).getId());
+        assertEquals(entityZC.getId(), result.get(5).getId());
+    }
+
+    public void testOrderUmlauts() throws SQLException {
+        List<TestEntity> list = new ArrayList<TestEntity>();
+        TestEntity entityV = addEntity(list, "V");
+        TestEntity entityB = addEntity(list, "B");
+        TestEntity entityUE = addEntity(list, "Ü");
+        TestEntity entityAE = addEntity(list, "Ä");
+        dao.insertInTx(list);
+
+        List<TestEntity> result = dao.queryBuilder().orderAsc(Properties.SimpleString).list();
+        assertEquals(list.size(), result.size());
+        assertEquals(entityAE.getId(), result.get(0).getId());
+        assertEquals(entityB.getId(), result.get(1).getId());
+        assertEquals(entityUE.getId(), result.get(2).getId());
+        assertEquals(entityV.getId(), result.get(3).getId());
+    }
+
+    public void testOrderCustom() throws SQLException {
+        List<TestEntity> list = new ArrayList<TestEntity>();
+        TestEntity entityAA = addEntity(list, "Aa");
+        TestEntity entityAB = addEntity(list, "ab");
+        TestEntity entityAC = addEntity(list, "Ac");
+        dao.insertInTx(list);
+
+        List<TestEntity> result = dao.queryBuilder().orderCustom(Properties.SimpleString, "ASC").list();
+        assertEquals(list.size(), result.size());
+        assertEquals(entityAA.getId(), result.get(0).getId());
+        assertEquals(entityAC.getId(), result.get(1).getId());
+        assertEquals(entityAB.getId(), result.get(2).getId());
+    }
+
+    public void testOrderRaw() throws SQLException {
+        ArrayList<TestEntity> inserted = insert(2);
+        TestEntity entity = inserted.get(0);
+        List<TestEntity> result = dao.queryBuilder().orderRaw(Properties.SimpleInteger.columnName + " ASC").list();
+        assertEquals(2, result.size());
+        assertEquals(entity.getId(), result.get(0).getId());
+    }
+
+    private TestEntity addEntity(List<TestEntity> list, String simpleString) {
+        TestEntity entityAB = createEntity(42, simpleString);
+        list.add(entityAB);
+        return entityAB;
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java b/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java
new file mode 100644
index 00000000..ad4fc02e
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java
@@ -0,0 +1,219 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+public class QueryBuilderSimpleTest extends TestEntityTestBase {
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    public void testEqInteger() throws SQLException {
+        ArrayList<TestEntity> inserted = insert(3);
+        int value = getSimpleInteger(1);
+
+        List<TestEntity> result = dao.queryBuilder().where(Properties.SimpleInteger.eq(value)).list();
+        assertEquals(1, result.size());
+
+        TestEntity resultEntity = result.get(0);
+        assertEquals(value, (int) resultEntity.getSimpleInteger());
+        assertEquals(inserted.get(1).getId(), resultEntity.getId());
+    }
+
+    public void testEqString() throws SQLException {
+        ArrayList<TestEntity> inserted = insert(3);
+        String value = getSimpleString(1);
+
+        List<TestEntity> result = dao.queryBuilder().where(Properties.SimpleString.eq(value)).list();
+        assertEquals(1, result.size());
+
+        TestEntity resultEntity = result.get(0);
+        assertEquals(value, resultEntity.getSimpleString());
+        assertEquals(inserted.get(1).getId(), resultEntity.getId());
+    }
+
+    public void testIn() throws SQLException {
+        ArrayList<TestEntity> inserted = insert(10);
+        String value1 = getSimpleString(2);
+        String value2 = getSimpleString(8);
+        String value3 = getSimpleString(9);
+
+        List<TestEntity> result = dao.queryBuilder().where(Properties.SimpleString.in(value1, value2, value3))
+                .orderAsc(Properties.SimpleString).list();
+        assertEquals(3, result.size());
+
+        TestEntity resultEntity1 = result.get(0);
+        assertEquals(value1, resultEntity1.getSimpleString());
+        assertEquals(inserted.get(2).getId(), resultEntity1.getId());
+
+        TestEntity resultEntity2 = result.get(1);
+        assertEquals(value2, resultEntity2.getSimpleString());
+        assertEquals(inserted.get(8).getId(), resultEntity2.getId());
+
+        TestEntity resultEntity3 = result.get(2);
+        assertEquals(value3, resultEntity3.getSimpleString());
+        assertEquals(inserted.get(9).getId(), resultEntity3.getId());
+    }
+
+    public void testNotIn() throws SQLException {
+        ArrayList<TestEntity> inserted = insert(5);
+        String value1 = getSimpleString(0);
+        String value2 = getSimpleString(2);
+        String value3 = getSimpleString(4);
+
+        List<TestEntity> result = dao.queryBuilder().where(Properties.SimpleString.notIn(value1, value2, value3))
+                .orderAsc(Properties.SimpleString).list();
+        assertEquals(2, result.size());
+
+        TestEntity resultEntity1 = result.get(0);
+        assertEquals(inserted.get(1).getId(), resultEntity1.getId());
+
+        TestEntity resultEntity2 = result.get(1);
+        assertEquals(inserted.get(3).getId(), resultEntity2.getId());
+    }
+
+    public void testEqStringAndInteger() throws SQLException {
+        ArrayList<TestEntity> inserted = insert(3);
+        String valueStr = getSimpleString(1);
+        int valueInt = getSimpleInteger(1);
+
+        List<TestEntity> result = dao.queryBuilder()
+                .where(Properties.SimpleString.eq(valueStr), Properties.SimpleInteger.eq(valueInt)).list();
+        assertEquals(1, result.size());
+
+        TestEntity resultEntity = result.get(0);
+        assertEquals(inserted.get(1).getId(), resultEntity.getId());
+    }
+
+    public void testNotEqString() throws SQLException {
+        ArrayList<TestEntity> inserted = insert(3);
+        String value = getSimpleString(1);
+
+        List<TestEntity> result = dao.queryBuilder().where(Properties.SimpleString.notEq(value)).list();
+        assertEquals(2, result.size());
+
+        TestEntity resultEntity1 = result.get(0);
+        TestEntity resultEntity2 = result.get(1);
+        long loId = Math.min(resultEntity1.getId(), resultEntity2.getId());
+        long hiId = Math.max(resultEntity1.getId(), resultEntity2.getId());
+        assertEquals((long) inserted.get(0).getId(), loId);
+        assertEquals((long) inserted.get(2).getId(), hiId);
+    }
+
+    public void testEqDate() throws SQLException {
+        ArrayList<TestEntity> inserted = insert(3);
+        TestEntity testEntity = inserted.get(1);
+
+        Date date = new Date();
+        testEntity.setSimpleDate(date);
+        dao.update(testEntity);
+
+        TestEntity testEntity2 = dao.queryBuilder().where(Properties.SimpleDate.eq(date)).uniqueOrThrow();
+        assertEquals(testEntity.getId(), testEntity2.getId());
+
+        testEntity2 = dao.queryBuilder().where(Properties.SimpleDate.eq(date.getTime())).uniqueOrThrow();
+        assertEquals(testEntity.getId(), testEntity2.getId());
+    }
+
+    public void testEqBoolean() throws SQLException {
+        ArrayList<TestEntity> inserted = insert(3);
+        TestEntity testEntity = inserted.get(1);
+
+        testEntity.setSimpleBoolean(true);
+        dao.update(testEntity);
+
+        TestEntity testEntity2 = dao.queryBuilder().where(Properties.SimpleBoolean.eq(true)).uniqueOrThrow();
+        assertEquals(testEntity.getId(), testEntity2.getId());
+
+        testEntity2 = dao.queryBuilder().where(Properties.SimpleBoolean.eq(Boolean.TRUE)).uniqueOrThrow();
+        assertEquals(testEntity.getId(), testEntity2.getId());
+
+        testEntity2 = dao.queryBuilder().where(Properties.SimpleBoolean.eq("TRUE")).uniqueOrThrow();
+        assertEquals(testEntity.getId(), testEntity2.getId());
+
+        testEntity2 = dao.queryBuilder().where(Properties.SimpleBoolean.eq("truE")).uniqueOrThrow();
+        assertEquals(testEntity.getId(), testEntity2.getId());
+    }
+
+    public void testIsNullIsNotNull() throws SQLException {
+        ArrayList<TestEntity> inserted = insert(2);
+        TestEntity testEntityNull = inserted.get(0);
+        TestEntity testEntityNotNull = inserted.get(1);
+
+        testEntityNull.setSimpleInteger(null);
+        testEntityNotNull.setSimpleInteger(42);
+        dao.update(testEntityNull);
+        dao.update(testEntityNotNull);
+
+        TestEntity testEntityNull2 = dao.queryBuilder().where(Properties.SimpleInteger.isNull()).uniqueOrThrow();
+        assertEquals(testEntityNull.getId(), testEntityNull2.getId());
+
+        TestEntity testEntityNotNull2 = dao.queryBuilder().where(Properties.SimpleInteger.isNotNull()).uniqueOrThrow();
+        assertEquals(testEntityNotNull.getId(), testEntityNotNull2.getId());
+    }
+
+    public void testBuildTwice() throws SQLException {
+        insert(3);
+        String value = getSimpleString(1);
+
+        QueryBuilder<TestEntity> builder = dao.queryBuilder().where(Properties.SimpleString.eq(value));
+        Query<TestEntity> query1 = builder.build();
+        Query<TestEntity> query2 = builder.build();
+        List<TestEntity> list1 = query1.list();
+        List<TestEntity> list2 = query2.list();
+        assertEquals(1, list1.size());
+        assertEquals(1, list2.size());
+        assertEquals(list1.get(0).getId(), list2.get(0).getId());
+    }
+
+    public void testLike() throws SQLException {
+        TestEntity entity = insert(3).get(1);
+        entity.setSimpleString("greenrobot");
+        dao.update(entity);
+
+        Query<TestEntity> query = dao.queryBuilder().where(Properties.SimpleString.like("%robot")).build();
+        TestEntity entity2 = query.uniqueOrThrow();
+        assertEquals(entity.getId(), entity2.getId());
+        
+        query.setParameter(0, "green%");
+        entity2 = query.uniqueOrThrow();
+        assertEquals(entity.getId(), entity2.getId());
+        
+        query.setParameter(0, "%enrob%");
+        entity2 = query.uniqueOrThrow();
+        assertEquals(entity.getId(), entity2.getId());
+        
+        query.setParameter(0, "%nothere%");
+        entity2 = query.unique();
+        assertNull(entity2);
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QueryForThreadTest.java b/DaoTest/src/de/greenrobot/daotest/query/QueryForThreadTest.java
new file mode 100644
index 00000000..5154054a
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/query/QueryForThreadTest.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) 2011-2013 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.sql.SQLException;
+
+import android.util.SparseArray;
+import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.DaoLog;
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+public class QueryForThreadTest extends TestEntityTestBase {
+    /** Takes longer when activated */
+    private final static boolean DO_LEAK_TESTS = false;
+    private final static int LEAK_TEST_ITERATIONS = DO_LEAK_TESTS ? 100000 : 2500;
+
+    private Query<TestEntity> queryFromOtherThread;
+
+    public void testGetForCurrentThread_SameInstance() {
+        Query<TestEntity> query = dao.queryBuilder().build();
+        assertSame(query, query.forCurrentThread());
+    }
+
+    public void testGetForCurrentThread_ParametersAreReset() throws SQLException {
+        insert(3);
+        int value = getSimpleInteger(1);
+        Query<TestEntity> query = dao.queryBuilder().where(Properties.SimpleInteger.eq(value)).build();
+        query.setParameter(0, value + 1);
+        TestEntity entityFor2 = query.unique();
+        assertEquals(value + 1, (int) entityFor2.getSimpleInteger());
+        query = query.forCurrentThread();
+        TestEntity entityFor1 = query.unique();
+    }
+
+    public void testGetForCurrentThread_ManyThreadsDontLeak() throws Exception {
+        QueryBuilder<TestEntity> builder = dao.queryBuilder().where(Properties.SimpleInteger.eq("dummy"));
+        final Query<TestEntity> query = builder.build();
+        for (int i = 1; i <= LEAK_TEST_ITERATIONS; i++) {
+            Thread thread = new Thread() {
+                public void run() {
+                    query.forCurrentThread();
+                };
+            };
+            thread.start();
+            if (i % 10 == 0) {
+                thread.join();
+            }
+        }
+        Field queryDataField = Query.class.getDeclaredField("queryData");
+        queryDataField.setAccessible(true);
+        Object queryData = queryDataField.get(query);
+        Class<?> dataSuperclass = queryData.getClass().getSuperclass();
+        Field mapField = dataSuperclass.getDeclaredField("queriesForThreads");
+        mapField.setAccessible(true);
+
+        Method gcMethod = dataSuperclass.getDeclaredMethod("gc");
+        gcMethod.setAccessible(true);
+        SparseArray<?> map = (SparseArray<?>) mapField.get(queryData);
+        for (int i = 0; map.size() > 1 && i < 1000; i++) {
+            DaoLog.d("Queries left after " + i + ". GC: " + map.size());
+            System.gc();
+            gcMethod.invoke(queryData);
+        }
+        assertEquals(1, map.size());
+    }
+
+    public void testBuildQueryDoesntLeak() {
+        QueryBuilder<TestEntity> builder = dao.queryBuilder().where(Properties.SimpleInteger.eq("dummy"));
+        for (int i = 0; i < LEAK_TEST_ITERATIONS; i++) {
+            builder.build();
+        }
+    }
+
+    public void testGetForCurrentThread_TwoThreads() throws InterruptedException, SQLException {
+        insert(3);
+        createQueryFromOtherThread();
+        Query<TestEntity> query = queryFromOtherThread.forCurrentThread();
+        assertNotSame(queryFromOtherThread, query);
+        query.setLimit(10);
+        query.setOffset(0);
+        assertEquals(getSimpleInteger(1), (int) query.uniqueOrThrow().getSimpleInteger());
+        int expected = getSimpleInteger(2);
+        query.setParameter(0, expected);
+        assertEquals(expected, (int) query.list().get(0).getSimpleInteger());
+        assertEquals(expected, (int) query.listLazy().get(0).getSimpleInteger());
+        assertEquals(expected, (int) query.listLazyUncached().get(0).getSimpleInteger());
+        assertEquals(expected, (int) query.unique().getSimpleInteger());
+        assertEquals(expected, (int) query.uniqueOrThrow().getSimpleInteger());
+    }
+
+    public void testThrowOutsideOwnerThread() throws InterruptedException, SQLException {
+        createQueryFromOtherThread();
+        try {
+            queryFromOtherThread.list();
+            fail("Did not throw");
+        } catch (DaoException expected) {
+        }
+        try {
+            queryFromOtherThread.listIterator();
+            fail("Did not throw");
+        } catch (DaoException expected) {
+        }
+        try {
+            queryFromOtherThread.listLazyUncached();
+            fail("Did not throw");
+        } catch (DaoException expected) {
+        }
+        try {
+            queryFromOtherThread.setLimit(2);
+            fail("Did not throw");
+        } catch (DaoException expected) {
+        }
+        try {
+            queryFromOtherThread.setOffset(2);
+            fail("Did not throw");
+        } catch (DaoException expected) {
+        }
+        try {
+            queryFromOtherThread.setParameter(0, 42);
+            fail("Did not throw");
+        } catch (DaoException expected) {
+        }
+        try {
+            queryFromOtherThread.unique();
+            fail("Did not throw");
+        } catch (DaoException expected) {
+        }
+        try {
+            queryFromOtherThread.uniqueOrThrow();
+            fail("Did not throw");
+        } catch (DaoException expected) {
+        }
+    }
+
+    private void createQueryFromOtherThread() throws InterruptedException {
+        Thread thread = new Thread() {
+
+            @Override
+            public void run() {
+                QueryBuilder<TestEntity> builder = dao.queryBuilder();
+                builder.where(Properties.SimpleInteger.eq(getSimpleInteger(1)));
+                builder.limit(10).offset(20);
+                queryFromOtherThread = builder.build();
+            }
+        };
+        thread.start();
+        thread.join();
+        assertNotNull(queryFromOtherThread);
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QueryLimitOffsetTest.java b/DaoTest/src/de/greenrobot/daotest/query/QueryLimitOffsetTest.java
new file mode 100644
index 00000000..d83bc185
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/query/QueryLimitOffsetTest.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+public class QueryLimitOffsetTest extends TestEntityTestBase {
+    
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    public void testQueryBuilderLimit() throws SQLException {
+        insert(10);
+        List<TestEntity> result = dao.queryBuilder().limit(3).orderAsc(Properties.SimpleInt).list();
+        assertEquals(3, result.size());
+
+        assertEquals(getSimpleInteger(0), result.get(0).getSimpleInteger().intValue());
+        assertEquals(getSimpleInteger(1), result.get(1).getSimpleInteger().intValue());
+        assertEquals(getSimpleInteger(2), result.get(2).getSimpleInteger().intValue());
+    }
+
+    public void testQueryBuilderOffsetAndLimit() throws SQLException {
+        insert(10);
+        List<TestEntity> result = dao.queryBuilder().offset(3).limit(3).orderAsc(Properties.SimpleInt).list();
+        assertEquals(3, result.size());
+
+        assertEquals(getSimpleInteger(3), result.get(0).getSimpleInteger().intValue());
+        assertEquals(getSimpleInteger(4), result.get(1).getSimpleInteger().intValue());
+        assertEquals(getSimpleInteger(5), result.get(2).getSimpleInteger().intValue());
+    }
+
+    public void testQueryBuilderOffsetAndLimitWithWhere() throws SQLException {
+        insert(10);
+        List<TestEntity> result = dao.queryBuilder().where(Properties.SimpleInteger.gt(getSimpleInteger(1))).offset(2)
+                .limit(3).orderAsc(Properties.SimpleInt).list();
+        assertEquals(3, result.size());
+
+        assertEquals(getSimpleInteger(4), result.get(0).getSimpleInteger().intValue());
+        assertEquals(getSimpleInteger(5), result.get(1).getSimpleInteger().intValue());
+        assertEquals(getSimpleInteger(6), result.get(2).getSimpleInteger().intValue());
+    }
+
+    public void testQueryOffsetAndLimit() throws SQLException {
+        insert(10);
+        Query<TestEntity> query = dao.queryBuilder().where(Properties.SimpleInteger.gt(getSimpleInteger(-1))).offset(-1)
+                .limit(-1).orderAsc(Properties.SimpleInt).build(); 
+        query.setParameter(0, getSimpleInteger(1));
+        query.setLimit(3);
+        query.setOffset(2);
+        List<TestEntity> result = query.list();
+        assertEquals(3, result.size());
+
+        assertEquals(getSimpleInteger(4), result.get(0).getSimpleInteger().intValue());
+        assertEquals(getSimpleInteger(5), result.get(1).getSimpleInteger().intValue());
+        assertEquals(getSimpleInteger(6), result.get(2).getSimpleInteger().intValue());
+    }
+    
+    public void testQueryBuilderOffsetWithoutLimit() {
+        try{
+            dao.queryBuilder().offset(7).orderAsc(Properties.SimpleInt).build();
+            fail("Offset may not be set alone");
+        } catch(RuntimeException expected) {
+            //OK
+        }
+    }
+    
+    public void testQueryLimitAndSetParameter() {
+        Query<TestEntity> query = dao.queryBuilder().limit(5).offset(1).build();
+        try{
+            query.setParameter(0, null);
+            fail("Offset/limit parameters must not interfere with user parameters");
+        } catch(RuntimeException expected) {
+            //OK
+        }
+    }
+    
+    public void testQueryUnsetLimit() {
+        Query<TestEntity> query = dao.queryBuilder().build();
+        try{
+            query.setLimit(1);
+            fail("Limit must be defined in builder first");
+        } catch(RuntimeException expected) {
+            //OK
+        }
+    } 
+
+    public void testQueryUnsetOffset() {
+        Query<TestEntity> query = dao.queryBuilder().limit(1).build();
+        try{
+            query.setOffset(1);
+            fail("Offset must be defined in builder first");
+        } catch(RuntimeException expected) {
+            //OK
+        }
+    } 
+
+
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QuerySpecialNamesTest.java b/DaoTest/src/de/greenrobot/daotest/query/QuerySpecialNamesTest.java
new file mode 100644
index 00000000..c941447e
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/query/QuerySpecialNamesTest.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.sql.SQLException;
+
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.dao.test.AbstractDaoTest;
+import de.greenrobot.daotest.SpecialNamesEntity;
+import de.greenrobot.daotest.SpecialNamesEntityDao;
+import de.greenrobot.daotest.SpecialNamesEntityDao.Properties;
+
+public class QuerySpecialNamesTest extends AbstractDaoTest<SpecialNamesEntityDao, SpecialNamesEntity, Long> {
+
+    public QuerySpecialNamesTest() {
+        super(SpecialNamesEntityDao.class);
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    public void testWhereWithSpecialNames() throws SQLException {
+        QueryBuilder<SpecialNamesEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.where(Properties.Avg.isNotNull());
+        queryBuilder.where(Properties.Count.isNotNull());
+        queryBuilder.where(Properties.Distinct.isNotNull());
+        queryBuilder.where(Properties.Index.isNotNull());
+        queryBuilder.where(Properties.Join.isNotNull());
+        queryBuilder.where(Properties.On.isNotNull());
+        queryBuilder.where(Properties.Select.isNotNull());
+        queryBuilder.where(Properties.Sum.isNotNull());
+        queryBuilder.where(Properties.Order.isNotNull());
+        queryBuilder.list();
+        queryBuilder.buildCount().count();
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+    public void testWhereWithSpecialNamesWithValues() throws SQLException {
+        QueryBuilder<SpecialNamesEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.where(Properties.Avg.eq("test"));
+        queryBuilder.where(Properties.Count.notIn("test", "test2"));
+        queryBuilder.where(Properties.Distinct.ge("test"));
+        queryBuilder.where(Properties.Index.le("test"));
+        queryBuilder.where(Properties.Join.like("test"));
+        queryBuilder.where(Properties.On.notEq("test"));
+        queryBuilder.where(Properties.Select.in("test", "test2"));
+        queryBuilder.where(Properties.Sum.lt(1));
+        queryBuilder.where(Properties.Order.gt(1));
+        queryBuilder.list();
+        queryBuilder.buildCount().count();
+        queryBuilder.buildDelete().executeDeleteWithoutDetachingEntities();
+    }
+
+    public void testOrderWithSpecialNames() throws SQLException {
+        QueryBuilder<SpecialNamesEntity> queryBuilder = dao.queryBuilder();
+        queryBuilder.orderAsc(Properties.Avg);
+        queryBuilder.orderAsc(Properties.Count);
+        queryBuilder.orderAsc(Properties.Distinct);
+        queryBuilder.orderAsc(Properties.Index);
+        queryBuilder.orderAsc(Properties.Join);
+        queryBuilder.orderAsc(Properties.On);
+        queryBuilder.orderAsc(Properties.Select);
+        queryBuilder.orderAsc(Properties.Sum);
+        queryBuilder.orderAsc(Properties.Order);
+        queryBuilder.list();
+    }
+
+}
diff --git a/DaoTest/src/de/greenrobot/daotest/query/RawQueryTest.java b/DaoTest/src/de/greenrobot/daotest/query/RawQueryTest.java
new file mode 100644
index 00000000..8fa65184
--- /dev/null
+++ b/DaoTest/src/de/greenrobot/daotest/query/RawQueryTest.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * This file is part of greenDAO Generator.
+ * 
+ * greenDAO Generator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * greenDAO Generator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package de.greenrobot.daotest.query;
+
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.List;
+
+import de.greenrobot.dao.query.LazyList;
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.daotest.TestEntityDao.Properties;
+import de.greenrobot.daotest.entity.TestEntityTestBase;
+
+public class RawQueryTest extends TestEntityTestBase {
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        QueryBuilder.LOG_SQL = true;
+        QueryBuilder.LOG_VALUES = true;
+    }
+
+    public void testRawQueryEmptySql() throws SQLException {
+        insert(3);
+        Query<TestEntity> query = dao.queryRawCreate("");
+        List<TestEntity> result = query.list();
+        assertEquals(3, result.size());
+    }
+
+    public void testRawQueryEqualsString() throws SQLException {
+        ArrayList<TestEntity> inserted = insert(3);
+        String value = getSimpleString(1);
+
+        String sql = "WHERE " + Properties.SimpleString.columnName + "=?";
+        List<TestEntity> result = dao.queryRawCreate(sql, value).list();
+        assertEquals(1, result.size());
+
+        TestEntity resultEntity = result.get(0);
+        assertEquals(value, resultEntity.getSimpleString());
+        assertEquals(inserted.get(1).getId(), resultEntity.getId());
+    }
+
+    public void testRawQueryCreate_setParameterInQuery() throws SQLException {
+        insert(3);
+        String value = getSimpleString(2);
+
+        String sql = "WHERE " + Properties.SimpleString.columnName + "=?";
+        Query<TestEntity> query = dao.queryRawCreate(sql, getSimpleString(1));
+        query.list();
+
+        query.setParameter(0, value);
+        List<TestEntity> result = query.list();
+
+        assertEquals(1, result.size());
+        assertEquals(value, result.get(0).getSimpleString());
+    }
+    
+    public void testRawQueryLazyList() throws SQLException {
+        ArrayList<TestEntity> list = insert(2);
+
+        LazyList<TestEntity> listLazy = dao.queryRawCreate("").listLazy();
+        assertEquals(list.size(), listLazy.size());
+        assertNull(listLazy.peak(0));
+        assertNull(listLazy.peak(1));
+
+        assertNotNull(listLazy.get(1));
+        assertNull(listLazy.peak(0));
+        assertNotNull(listLazy.peak(1));
+
+        assertNotNull(listLazy.get(0));
+        assertNotNull(listLazy.peak(0));
+        assertNotNull(listLazy.peak(1));
+    }
+
+}
