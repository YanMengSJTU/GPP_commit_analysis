diff --git a/DaoCore/.classpath b/DaoCore/.classpath
index 8981741b..a33c2fa2 100644
--- a/DaoCore/.classpath
+++ b/DaoCore/.classpath
@@ -1,8 +1,9 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="lib" path="libs/sqlcipher.jar"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/DaoCore/assets/icudt44l.zip b/DaoCore/assets/icudt44l.zip
new file mode 100644
index 00000000..3b6372e5
Binary files /dev/null and b/DaoCore/assets/icudt44l.zip differ
diff --git a/DaoCore/libs/armeabi/libdatabase_sqlcipher.so b/DaoCore/libs/armeabi/libdatabase_sqlcipher.so
new file mode 100755
index 00000000..34819f84
Binary files /dev/null and b/DaoCore/libs/armeabi/libdatabase_sqlcipher.so differ
diff --git a/DaoCore/libs/armeabi/libsqlcipher_android.so b/DaoCore/libs/armeabi/libsqlcipher_android.so
new file mode 100755
index 00000000..662b7d8c
Binary files /dev/null and b/DaoCore/libs/armeabi/libsqlcipher_android.so differ
diff --git a/DaoCore/libs/armeabi/libstlport_shared.so b/DaoCore/libs/armeabi/libstlport_shared.so
new file mode 100755
index 00000000..35771c34
Binary files /dev/null and b/DaoCore/libs/armeabi/libstlport_shared.so differ
diff --git a/DaoCore/libs/sqlcipher.jar b/DaoCore/libs/sqlcipher.jar
new file mode 100644
index 00000000..527aea97
Binary files /dev/null and b/DaoCore/libs/sqlcipher.jar differ
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDao.java b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
index af01658a..263dada5 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDao.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
@@ -23,9 +23,9 @@
 import android.database.CrossProcessCursor;
 import android.database.Cursor;
 import android.database.CursorWindow;
-import android.database.DatabaseUtils;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
+import de.greenrobot.dao.wrapper.DatabaseUtils;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 
 /**
  * Base class for all DAOs: Implements entity operations like insert, load, delete, and query.
@@ -40,649 +40,643 @@
  *            Primary key (PK) type; use Void if entity does not have exactly one PK
  */
 public abstract class AbstractDao<T, K> {
-    protected final SQLiteDatabase db;
-    protected final DaoConfig config;
-    protected IdentityScope<K, T> identityScope;
-    protected IdentityScopeLong<T> identityScopeLong;
-    protected TableStatements statements;
-
-    protected final AbstractDaoSession session;
-    protected final int pkOrdinal;
-
-    public AbstractDao(DaoConfig config) {
-        this(config, null);
-    }
-
-    @SuppressWarnings("unchecked")
-    public AbstractDao(DaoConfig config, AbstractDaoSession daoSession) {
-        this.config = config;
-        this.session = daoSession;
-        db = config.db;
-        identityScope = (IdentityScope<K, T>) config.getIdentityScope();
-        if (identityScope instanceof IdentityScopeLong) {
-            identityScopeLong = (IdentityScopeLong<T>) identityScope;
-        }
-        statements = config.statements;
-        pkOrdinal = config.pkProperty != null ? config.pkProperty.ordinal : -1;
-    }
-
-    public AbstractDaoSession getSession() {
-        return session;
-    }
-
-    TableStatements getStatements() {
-        return config.statements;
-    }
-
-    public String getTablename() {
-        return config.tablename;
-    }
-
-    public Property[] getProperties() {
-        return config.properties;
-    }
-
-    public Property getPkProperty() {
-        return config.pkProperty;
-    }
-
-    public String[] getAllColumns() {
-        return config.allColumns;
-    }
-
-    public String[] getPkColumns() {
-        return config.pkColumns;
-    }
-
-    public String[] getNonPkColumns() {
-        return config.nonPkColumns;
-    }
-
-    /**
-     * Loads and entity for the given PK.
-     * 
-     * @param key
-     *            a PK value or null
-     * @return The entity or null, if no entity matched the PK value
-     */
-    public T load(K key) {
-        assertSinglePk();
-        if (key == null) {
-            return null;
-        }
-        if (identityScope != null) {
-            T entity = identityScope.get(key);
-            if (entity != null) {
-                return entity;
-            }
-        }
-        String sql = statements.getSelectByKey();
-        String[] keyArray = new String[] { key.toString() };
-        Cursor cursor = db.rawQuery(sql, keyArray);
-        return loadUniqueAndCloseCursor(cursor);
-    }
-
-    public T loadByRowId(long rowId) {
-        String[] idArray = new String[] { Long.toString(rowId) };
-        Cursor cursor = db.rawQuery(statements.getSelectByRowId(), idArray);
-        return loadUniqueAndCloseCursor(cursor);
-    }
-
-    protected T loadUniqueAndCloseCursor(Cursor cursor) {
-        try {
-            return loadUnique(cursor);
-        } finally {
-            cursor.close();
-        }
-    }
-
-    protected T loadUnique(Cursor cursor) {
-        boolean available = cursor.moveToFirst();
-        if (!available) {
-            return null;
-        } else if (!cursor.isLast()) {
-            throw new DaoException("Expected unique result, but count was " + cursor.getCount());
-        }
-        return loadCurrent(cursor, 0, true);
-    }
-
-    /** Loads all available entities from the database. */
-    public List<T> loadAll() {
-        Cursor cursor = db.rawQuery(statements.getSelectAll(), null);
-        return loadAllAndCloseCursor(cursor);
-    }
-
-    /** Detaches an entity from the identity scope (session). Subsequent query results won't return this object. */
-    public boolean detach(T entity) {
-        if (identityScope != null) {
-            K key = getKeyVerified(entity);
-            return identityScope.detach(key, entity);
-        } else {
-            return false;
-        }
-    }
-
-    protected List<T> loadAllAndCloseCursor(Cursor cursor) {
-        try {
-            return loadAllFromCursor(cursor);
-        } finally {
-            cursor.close();
-        }
-    }
-
-    /**
-     * Inserts the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to insert.
-     */
-    public void insertInTx(Iterable<T> entities) {
-        insertInTx(entities, isEntityUpdateable());
-    }
-
-    /**
-     * Inserts the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to insert.
-     */
-    public void insertInTx(T... entities) {
-        insertInTx(Arrays.asList(entities), isEntityUpdateable());
-    }
-
-    /**
-     * Inserts the given entities in the database using a transaction. The given entities will become tracked if the PK
-     * is set.
-     * 
-     * @param entities
-     *            The entities to insert.
-     * @param setPrimaryKey
-     *            if true, the PKs of the given will be set after the insert; pass false to improve performance.
-     */
-    public void insertInTx(Iterable<T> entities, boolean setPrimaryKey) {
-        SQLiteStatement stmt = statements.getInsertStatement();
-        executeInsertInTx(stmt, entities, setPrimaryKey);
-    }
-
-    /**
-     * Inserts or replaces the given entities in the database using a transaction. The given entities will become
-     * tracked if the PK is set.
-     * 
-     * @param entities
-     *            The entities to insert.
-     * @param setPrimaryKey
-     *            if true, the PKs of the given will be set after the insert; pass false to improve performance.
-     */
-    public void insertOrReplaceInTx(Iterable<T> entities, boolean setPrimaryKey) {
-        SQLiteStatement stmt = statements.getInsertOrReplaceStatement();
-        executeInsertInTx(stmt, entities, setPrimaryKey);
-    }
-
-    /**
-     * Inserts or replaces the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to insert.
-     */
-    public void insertOrReplaceInTx(Iterable<T> entities) {
-        insertOrReplaceInTx(entities, isEntityUpdateable());
-    }
-
-    /**
-     * Inserts or replaces the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to insert.
-     */
-    public void insertOrReplaceInTx(T... entities) {
-        insertOrReplaceInTx(Arrays.asList(entities), isEntityUpdateable());
-    }
-
-    private void executeInsertInTx(SQLiteStatement stmt, Iterable<T> entities, boolean setPrimaryKey) {
-        synchronized (stmt) {
-            db.beginTransaction();
-            try {
-                if (identityScope != null) {
-                    identityScope.lock();
-                }
-                try {
-                    for (T entity : entities) {
-                        bindValues(stmt, entity);
-                        if (setPrimaryKey) {
-                            long rowId = stmt.executeInsert();
-                            updateKeyAfterInsertAndAttach(entity, rowId, false);
-                        } else {
-                            stmt.execute();
-                        }
-                    }
-                } finally {
-                    if (identityScope != null) {
-                        identityScope.unlock();
-                    }
-                }
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-            }
-        }
-    }
-
-    /**
-     * Insert an entity into the table associated with a concrete DAO.
-     * 
-     * @return row ID of newly inserted entity
-     */
-    public long insert(T entity) {
-        return executeInsert(entity, statements.getInsertStatement());
-    }
-
-    /**
-     * Insert an entity into the table associated with a concrete DAO <b>without</b> setting key property. Warning: This
-     * may be faster, but the entity should not be used anymore. The entity also won't be attached to identy scope.
-     * 
-     * @return row ID of newly inserted entity
-     */
-    public long insertWithoutSettingPk(T entity) {
-        SQLiteStatement stmt = statements.getInsertStatement();
-        synchronized (stmt) {
-            bindValues(stmt, entity);
-            return stmt.executeInsert();
-        }
-    }
-
-    /**
-     * Insert an entity into the table associated with a concrete DAO.
-     * 
-     * @return row ID of newly inserted entity
-     */
-    public long insertOrReplace(T entity) {
-        return executeInsert(entity, statements.getInsertOrReplaceStatement());
-    }
-
-    private long executeInsert(T entity, SQLiteStatement stmt) {
-        long rowId;
-        synchronized (stmt) {
-            bindValues(stmt, entity);
-            rowId = stmt.executeInsert();
-        }
-        updateKeyAfterInsertAndAttach(entity, rowId, true);
-        return rowId;
-    }
-
-    protected void updateKeyAfterInsertAndAttach(T entity, long rowId, boolean lock) {
-        if (rowId != -1) {
-            K key = updateKeyAfterInsert(entity, rowId);
-            attachEntity(key, entity, lock);
-        } else {
-            // TODO When does this actually happen? Should we throw instead?
-            DaoLog.w("Could not insert row (executeInsert returned -1)");
-        }
-    }
-
-    /** Reads all available rows from the given cursor and returns a list of entities. */
-    protected List<T> loadAllFromCursor(Cursor cursor) {
-        int count = cursor.getCount();
-        List<T> list = new ArrayList<T>(count);
-        if (cursor instanceof CrossProcessCursor) {
-            CursorWindow window = ((CrossProcessCursor) cursor).getWindow();
-            if (window != null) { // E.g. Roboelectric has no Window at this point
-                if (window.getNumRows() == count) {
-                    cursor = new FastCursor(window);
-                } else {
-                    DaoLog.d("Window vs. result size: " + window.getNumRows() + "/" + count);
-                }
-            }
-        }
-
-        if (cursor.moveToFirst()) {
-            if (identityScope != null) {
-                identityScope.lock();
-                identityScope.reserveRoom(count);
-            }
-            try {
-                do {
-                    list.add(loadCurrent(cursor, 0, false));
-                } while (cursor.moveToNext());
-            } finally {
-                if (identityScope != null) {
-                    identityScope.unlock();
-                }
-            }
-        }
-        return list;
-    }
-
-    /** Internal use only. Considers identity scope. */
-    final protected T loadCurrent(Cursor cursor, int offset, boolean lock) {
-        if (identityScopeLong != null) {
-            if (offset != 0) {
-                // Occurs with deep loads (left outer joins)
-                if (cursor.isNull(pkOrdinal + offset)) {
-                    return null;
-                }
-            }
-
-            long key = cursor.getLong(pkOrdinal + offset);
-            T entity = lock ? identityScopeLong.get2(key) : identityScopeLong.get2NoLock(key);
-            if (entity != null) {
-                return entity;
-            } else {
-                entity = readEntity(cursor, offset);
-                if (lock) {
-                    identityScopeLong.put2(key, entity);
-                } else {
-                    identityScopeLong.put2NoLock(key, entity);
-                }
-                attachEntity(entity);
-                return entity;
-            }
-        } else if (identityScope != null) {
-            K key = readKey(cursor, offset);
-            if (offset != 0 && key == null) {
-                // Occurs with deep loads (left outer joins)
-                return null;
-            }
-            T entity = lock ? identityScope.get(key) : identityScope.getNoLock(key);
-            if (entity != null) {
-                return entity;
-            } else {
-                entity = readEntity(cursor, offset);
-                attachEntity(key, entity, lock);
-                return entity;
-            }
-        } else {
-            // Check offset, assume a value !=0 indicating a potential outer join, so check PK
-            if (offset != 0) {
-                K key = readKey(cursor, offset);
-                if (key == null) {
-                    // Occurs with deep loads (left outer joins)
-                    return null;
-                }
-            }
-            T entity = readEntity(cursor, offset);
-            attachEntity(entity);
-            return entity;
-        }
-    }
-
-    /** Internal use only. Considers identity scope. */
-    final protected <O> O loadCurrentOther(AbstractDao<O, ?> dao, Cursor cursor, int offset) {
-        return dao.loadCurrent(cursor, offset, /* TODO check this */true);
-    }
-
-    /** A raw-style query where you can pass any WHERE clause and arguments. */
-    public List<T> queryRaw(String where, String... selectionArg) {
-        Cursor cursor = db.rawQuery(statements.getSelectAll() + where, selectionArg);
-        return loadAllAndCloseCursor(cursor);
-    }
-
-    /** @deprecated groupBy & having does not make sense for entities. Method will be removed. */
-    public List<T> query(String selection, String[] selectionArgs, String groupBy, String having, String orderby) {
-        Cursor cursor = db.query(config.tablename, getAllColumns(), selection, selectionArgs, groupBy, having, orderby);
-        return loadAllAndCloseCursor(cursor);
-    }
-
-    public void deleteAll() {
-        // String sql = SqlUtils.createSqlDelete(config.tablename, null);
-        // db.execSQL(sql);
-
-        db.execSQL("DELETE FROM '" + config.tablename + "'");
-        if (identityScope != null) {
-            identityScope.clear();
-        }
-    }
-
-    /** Deletes the given entity from the database. Currently, only single value PK entities are supported. */
-    public void delete(T entity) {
-        assertSinglePk();
-        K key = getKeyVerified(entity);
-        deleteByKey(key);
-        if (identityScope != null) {
-            identityScope.remove(key);
-        }
-    }
-
-    /** Deletes an entity with the given PK from the database. Currently, only single value PK entities are supported. */
-    public void deleteByKey(K key) {
-        assertSinglePk();
-        SQLiteStatement stmt = statements.getDeleteStatement();
-        synchronized (stmt) {
-            deleteByKeyInsideSynchronized(key, stmt);
-        }
-        if (identityScope != null) {
-            identityScope.remove(key);
-        }
-    }
-
-    private void deleteByKeyInsideSynchronized(K key, SQLiteStatement stmt) {
-        if (key instanceof Long) {
-            stmt.bindLong(1, (Long) key);
-        } else {
-            stmt.bindString(1, key.toString());
-        }
-        stmt.execute();
-    }
-
-    /**
-     * Deletes the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to delete.
-     */
-    public void deleteInTx(Iterable<T> entities) {
-        assertSinglePk();
-        SQLiteStatement stmt = statements.getDeleteStatement();
-        synchronized (stmt) {
-            db.beginTransaction();
-            try {
-                List<K> keysToRemoveFromIdentityScope = null;
-                if (identityScope != null) {
-                    identityScope.lock();
-                    keysToRemoveFromIdentityScope = new ArrayList<K>();
-                }
-                try {
-                    for (T entity : entities) {
-                        K key = getKeyVerified(entity);
-                        deleteByKeyInsideSynchronized(key, stmt);
-                        if (keysToRemoveFromIdentityScope != null) {
-                            keysToRemoveFromIdentityScope.add(key);
-                        }
-                    }
-                } finally {
-                    if (identityScope != null) {
-                        identityScope.unlock();
-                    }
-                }
-                db.setTransactionSuccessful();
-                if (keysToRemoveFromIdentityScope != null && identityScope != null) {
-                    identityScope.remove(keysToRemoveFromIdentityScope);
-                }
-            } finally {
-                db.endTransaction();
-            }
-        }
-    }
-
-    /**
-     * Deletes the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to delete.
-     */
-    public void deleteInTx(T... entities) {
-        deleteInTx(Arrays.asList(entities));
-    }
-
-    /** Resets all locally changed properties of the entity by reloading the values from the database. */
-    public void refresh(T entity) {
-        assertSinglePk();
-        K key = getKeyVerified(entity);
-        String sql = statements.getSelectByKey();
-        String[] keyArray = new String[] { key.toString() };
-        Cursor cursor = db.rawQuery(sql, keyArray);
-        try {
-            boolean available = cursor.moveToFirst();
-            if (!available) {
-                throw new DaoException("Entity does not exist in the database anymore: " + entity.getClass()
-                        + " with key " + key);
-            } else if (!cursor.isLast()) {
-                throw new DaoException("Expected unique result, but count was " + cursor.getCount());
-            }
-            readEntity(cursor, entity, 0);
-            attachEntity(key, entity, true);
-        } finally {
-            cursor.close();
-        }
-    }
-
-    public void update(T entity) {
-        assertSinglePk();
-        SQLiteStatement stmt = statements.getUpdateStatement();
-        synchronized (stmt) {
-            updateInsideSynchronized(entity, stmt, true);
-        }
-    }
-
-    public QueryBuilder<T> queryBuilder() {
-        return new QueryBuilder<T>(this);
-    }
-
-    protected void updateInsideSynchronized(T entity, SQLiteStatement stmt, boolean lock) {
-        // To do? Check if it's worth not to bind PKs here (performance).
-        bindValues(stmt, entity);
-        int index = config.allColumns.length + 1;
-        K key = getKey(entity);
-        if (key instanceof Long) {
-            stmt.bindLong(index, (Long) key);
-        } else {
-            stmt.bindString(index, key.toString());
-        }
-        stmt.execute();
-        attachEntity(key, entity, lock);
-    }
-
-    /**
-     * Attaches the entity to the identity scope. Calls attachEntity(T entity).
-     * 
-     * @param key
-     *            Needed only for identity scope, pass null if there's none.
-     * @param entity
-     *            The entitiy to attach
-     * */
-    protected final void attachEntity(K key, T entity, boolean lock) {
-        if (identityScope != null && key != null) {
-            if (lock) {
-                identityScope.put(key, entity);
-            } else {
-                identityScope.putNoLock(key, entity);
-            }
-        }
-        attachEntity(entity);
-    }
-
-    /**
-     * Sub classes with relations additionally set the DaoMaster here.
-     * 
-     * @param entity
-     *            The entitiy to attach
-     * */
-    protected void attachEntity(T entity) {
-    }
-
-    /**
-     * Updates the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to insert.
-     */
-    public void updateInTx(Iterable<T> entities) {
-        SQLiteStatement stmt = statements.getUpdateStatement();
-        synchronized (stmt) {
-            db.beginTransaction();
-            try {
-                if (identityScope != null) {
-                    identityScope.lock();
-                }
-                try {
-                    for (T entity : entities) {
-                        updateInsideSynchronized(entity, stmt, false);
-                    }
-                } finally {
-                    if (identityScope != null) {
-                        identityScope.unlock();
-                    }
-                }
-                db.setTransactionSuccessful();
-            } finally {
-                db.endTransaction();
-            }
-        }
-    }
-
-    /**
-     * Updates the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to update.
-     */
-    public void updateInTx(T... entities) {
-        updateInTx(Arrays.asList(entities));
-    }
-
-    protected void assertSinglePk() {
-        if (config.pkColumns.length != 1) {
-            throw new DaoException(this + " (" + config.tablename + ") does not have a single-column primary key");
-        }
-    }
-
-    public long count() {
-        return DatabaseUtils.queryNumEntries(db, '\'' + config.tablename + '\'');
-    }
-
-    /** See {@link #getKey(Object)}, but guarantees that the returned key is never null (throws if null). */
-    protected K getKeyVerified(T entity) {
-        K key = getKey(entity);
-        if (key == null) {
-            if (entity == null) {
-                throw new NullPointerException("Entity may not be null");
-            } else {
-                throw new DaoException("Entity has no key");
-            }
-        } else {
-            return key;
-        }
-    }
-
-    /** Gets the SQLiteDatabase for custom database access. Not needed for greenDAO entities. */
-    public SQLiteDatabase getDatabase() {
-        return db;
-    }
-
-    /** Reads the values from the current position of the given cursor and returns a new entity. */
-    abstract protected T readEntity(Cursor cursor, int offset);
-
-    /** Reads the key from the current position of the given cursor, or returns null if there's no single-value key. */
-    abstract protected K readKey(Cursor cursor, int offset);
-
-    /** Reads the values from the current position of the given cursor into an existing entity. */
-    abstract protected void readEntity(Cursor cursor, T entity, int offset);
-
-    /** Binds the entity's values to the statement. Make sure to synchronize the statement outside of the method. */
-    abstract protected void bindValues(SQLiteStatement stmt, T entity);
-
-    /**
-     * Updates the entity's key if possible (only for Long PKs currently). This method must always return the entity's
-     * key regardless of whether the key existed before or not.
-     */
-    abstract protected K updateKeyAfterInsert(T entity, long rowId);
-
-    /**
-     * Returns the value of the primary key, if the entity has a single primary key, or, if not, null. Returns null if
-     * entity is null.
-     */
-    abstract protected K getKey(T entity);
-
-    /** Returns true if the Entity class can be updated, e.g. for setting the PK after insert. */
-    abstract protected boolean isEntityUpdateable();
+	protected final SQLiteDatabaseWrapper db;
+	protected final DaoConfig config;
+	protected IdentityScope<K, T> identityScope;
+	protected IdentityScopeLong<T> identityScopeLong;
+	protected TableStatements statements;
+
+	protected final AbstractDaoSession session;
+	protected final int pkOrdinal;
+
+	public AbstractDao(DaoConfig config) {
+		this(config, null);
+	}
+
+	@SuppressWarnings("unchecked")
+	public AbstractDao(DaoConfig config, AbstractDaoSession daoSession) {
+		this.config = config;
+		this.session = daoSession;
+		db = config.db;
+		identityScope = (IdentityScope<K, T>) config.getIdentityScope();
+		if (identityScope instanceof IdentityScopeLong) {
+			identityScopeLong = (IdentityScopeLong<T>) identityScope;
+		}
+		statements = config.statements;
+		pkOrdinal = config.pkProperty != null ? config.pkProperty.ordinal : -1;
+	}
+
+	public AbstractDaoSession getSession() {
+		return session;
+	}
+
+	TableStatements getStatements() {
+		return config.statements;
+	}
+
+	public String getTablename() {
+		return config.tablename;
+	}
+
+	public Property[] getProperties() {
+		return config.properties;
+	}
+
+	public Property getPkProperty() {
+		return config.pkProperty;
+	}
+
+	public String[] getAllColumns() {
+		return config.allColumns;
+	}
+
+	public String[] getPkColumns() {
+		return config.pkColumns;
+	}
+
+	public String[] getNonPkColumns() {
+		return config.nonPkColumns;
+	}
+
+	/**
+	 * Loads and entity for the given PK.
+	 * 
+	 * @param key
+	 *            a PK value or null
+	 * @return The entity or null, if no entity matched the PK value
+	 */
+	public T load(K key) {
+		assertSinglePk();
+		if (key == null) {
+			return null;
+		}
+		if (identityScope != null) {
+			T entity = identityScope.get(key);
+			if (entity != null) {
+				return entity;
+			}
+		}
+		String sql = statements.getSelectByKey();
+		String[] keyArray = new String[] { key.toString() };
+		Cursor cursor = db.rawQuery(sql, keyArray);
+		return loadUniqueAndCloseCursor(cursor);
+	}
+
+	public T loadByRowId(long rowId) {
+		String[] idArray = new String[] { Long.toString(rowId) };
+		Cursor cursor = db.rawQuery(statements.getSelectByRowId(), idArray);
+		return loadUniqueAndCloseCursor(cursor);
+	}
+
+	protected T loadUniqueAndCloseCursor(Cursor cursor) {
+		try {
+			return loadUnique(cursor);
+		} finally {
+			cursor.close();
+		}
+	}
+
+	protected T loadUnique(Cursor cursor) {
+		boolean available = cursor.moveToFirst();
+		if (!available) {
+			return null;
+		} else if (!cursor.isLast()) {
+			throw new DaoException("Expected unique result, but count was " + cursor.getCount());
+		}
+		return loadCurrent(cursor, 0, true);
+	}
+
+	/** Loads all available entities from the database. */
+	public List<T> loadAll() {
+		Cursor cursor = db.rawQuery(statements.getSelectAll(), null);
+		return loadAllAndCloseCursor(cursor);
+	}
+
+	/** Detaches an entity from the identity scope (session). Subsequent query results won't return this object. */
+	public boolean detach(T entity) {
+		if (identityScope != null) {
+			K key = getKeyVerified(entity);
+			return identityScope.detach(key, entity);
+		} else {
+			return false;
+		}
+	}
+
+	protected List<T> loadAllAndCloseCursor(Cursor cursor) {
+		try {
+			return loadAllFromCursor(cursor);
+		} finally {
+			cursor.close();
+		}
+	}
+
+	/**
+	 * Inserts the given entities in the database using a transaction.
+	 * 
+	 * @param entities
+	 *            The entities to insert.
+	 */
+	public void insertInTx(Iterable<T> entities) {
+		insertInTx(entities, isEntityUpdateable());
+	}
+
+	/**
+	 * Inserts the given entities in the database using a transaction.
+	 * 
+	 * @param entities
+	 *            The entities to insert.
+	 */
+	public void insertInTx(T... entities) {
+		insertInTx(Arrays.asList(entities), isEntityUpdateable());
+	}
+
+	/**
+	 * Inserts the given entities in the database using a transaction. The given entities will become tracked if the PK is set.
+	 * 
+	 * @param entities
+	 *            The entities to insert.
+	 * @param setPrimaryKey
+	 *            if true, the PKs of the given will be set after the insert; pass false to improve performance.
+	 */
+	public void insertInTx(Iterable<T> entities, boolean setPrimaryKey) {
+		SQLiteStatementWrapper stmt = statements.getInsertStatement();
+		executeInsertInTx(stmt, entities, setPrimaryKey);
+	}
+
+	/**
+	 * Inserts or replaces the given entities in the database using a transaction. The given entities will become tracked if the PK is set.
+	 * 
+	 * @param entities
+	 *            The entities to insert.
+	 * @param setPrimaryKey
+	 *            if true, the PKs of the given will be set after the insert; pass false to improve performance.
+	 */
+	public void insertOrReplaceInTx(Iterable<T> entities, boolean setPrimaryKey) {
+		SQLiteStatementWrapper stmt = statements.getInsertOrReplaceStatement();
+		executeInsertInTx(stmt, entities, setPrimaryKey);
+	}
+
+	/**
+	 * Inserts or replaces the given entities in the database using a transaction.
+	 * 
+	 * @param entities
+	 *            The entities to insert.
+	 */
+	public void insertOrReplaceInTx(Iterable<T> entities) {
+		insertOrReplaceInTx(entities, isEntityUpdateable());
+	}
+
+	/**
+	 * Inserts or replaces the given entities in the database using a transaction.
+	 * 
+	 * @param entities
+	 *            The entities to insert.
+	 */
+	public void insertOrReplaceInTx(T... entities) {
+		insertOrReplaceInTx(Arrays.asList(entities), isEntityUpdateable());
+	}
+
+	private void executeInsertInTx(SQLiteStatementWrapper stmt, Iterable<T> entities, boolean setPrimaryKey) {
+		synchronized (stmt) {
+			db.beginTransaction();
+			try {
+				if (identityScope != null) {
+					identityScope.lock();
+				}
+				try {
+					for (T entity : entities) {
+						bindValues(stmt, entity);
+						if (setPrimaryKey) {
+							long rowId = stmt.executeInsert();
+							updateKeyAfterInsertAndAttach(entity, rowId, false);
+						} else {
+							stmt.execute();
+						}
+					}
+				} finally {
+					if (identityScope != null) {
+						identityScope.unlock();
+					}
+				}
+				db.setTransactionSuccessful();
+			} finally {
+				db.endTransaction();
+			}
+		}
+	}
+
+	/**
+	 * Insert an entity into the table associated with a concrete DAO.
+	 * 
+	 * @return row ID of newly inserted entity
+	 */
+	public long insert(T entity) {
+		return executeInsert(entity, statements.getInsertStatement());
+	}
+
+	/**
+	 * Insert an entity into the table associated with a concrete DAO <b>without</b> setting key property. Warning: This may be faster, but the entity should not be used anymore. The entity also won't be attached to identy scope.
+	 * 
+	 * @return row ID of newly inserted entity
+	 */
+	public long insertWithoutSettingPk(T entity) {
+		SQLiteStatementWrapper stmt = statements.getInsertStatement();
+		synchronized (stmt) {
+			bindValues(stmt, entity);
+			return stmt.executeInsert();
+		}
+	}
+
+	/**
+	 * Insert an entity into the table associated with a concrete DAO.
+	 * 
+	 * @return row ID of newly inserted entity
+	 */
+	public long insertOrReplace(T entity) {
+		return executeInsert(entity, statements.getInsertOrReplaceStatement());
+	}
+
+	private long executeInsert(T entity, SQLiteStatementWrapper stmt) {
+		long rowId;
+		synchronized (stmt) {
+			bindValues(stmt, entity);
+			rowId = stmt.executeInsert();
+		}
+		updateKeyAfterInsertAndAttach(entity, rowId, true);
+		return rowId;
+	}
+
+	protected void updateKeyAfterInsertAndAttach(T entity, long rowId, boolean lock) {
+		if (rowId != -1) {
+			K key = updateKeyAfterInsert(entity, rowId);
+			attachEntity(key, entity, lock);
+		} else {
+			// TODO When does this actually happen? Should we throw instead?
+			DaoLog.w("Could not insert row (executeInsert returned -1)");
+		}
+	}
+
+	/** Reads all available rows from the given cursor and returns a list of entities. */
+	protected List<T> loadAllFromCursor(Cursor cursor) {
+		int count = cursor.getCount();
+		List<T> list = new ArrayList<T>(count);
+		if (cursor instanceof CrossProcessCursor) {
+			CursorWindow window = ((CrossProcessCursor) cursor).getWindow();
+			if (window != null) { // E.g. Roboelectric has no Window at this point
+				if (window.getNumRows() == count) {
+					cursor = new FastCursor(window);
+				} else {
+					DaoLog.d("Window vs. result size: " + window.getNumRows() + "/" + count);
+				}
+			}
+		}
+
+		if (cursor.moveToFirst()) {
+			if (identityScope != null) {
+				identityScope.lock();
+				identityScope.reserveRoom(count);
+			}
+			try {
+				do {
+					list.add(loadCurrent(cursor, 0, false));
+				} while (cursor.moveToNext());
+			} finally {
+				if (identityScope != null) {
+					identityScope.unlock();
+				}
+			}
+		}
+		return list;
+	}
+
+	/** Internal use only. Considers identity scope. */
+	final protected T loadCurrent(Cursor cursor, int offset, boolean lock) {
+		if (identityScopeLong != null) {
+			if (offset != 0) {
+				// Occurs with deep loads (left outer joins)
+				if (cursor.isNull(pkOrdinal + offset)) {
+					return null;
+				}
+			}
+
+			long key = cursor.getLong(pkOrdinal + offset);
+			T entity = lock ? identityScopeLong.get2(key) : identityScopeLong.get2NoLock(key);
+			if (entity != null) {
+				return entity;
+			} else {
+				entity = readEntity(cursor, offset);
+				if (lock) {
+					identityScopeLong.put2(key, entity);
+				} else {
+					identityScopeLong.put2NoLock(key, entity);
+				}
+				attachEntity(entity);
+				return entity;
+			}
+		} else if (identityScope != null) {
+			K key = readKey(cursor, offset);
+			if (offset != 0 && key == null) {
+				// Occurs with deep loads (left outer joins)
+				return null;
+			}
+			T entity = lock ? identityScope.get(key) : identityScope.getNoLock(key);
+			if (entity != null) {
+				return entity;
+			} else {
+				entity = readEntity(cursor, offset);
+				attachEntity(key, entity, lock);
+				return entity;
+			}
+		} else {
+			// Check offset, assume a value !=0 indicating a potential outer join, so check PK
+			if (offset != 0) {
+				K key = readKey(cursor, offset);
+				if (key == null) {
+					// Occurs with deep loads (left outer joins)
+					return null;
+				}
+			}
+			T entity = readEntity(cursor, offset);
+			attachEntity(entity);
+			return entity;
+		}
+	}
+
+	/** Internal use only. Considers identity scope. */
+	final protected <O> O loadCurrentOther(AbstractDao<O, ?> dao, Cursor cursor, int offset) {
+		return dao.loadCurrent(cursor, offset, /* TODO check this */true);
+	}
+
+	/** A raw-style query where you can pass any WHERE clause and arguments. */
+	public List<T> queryRaw(String where, String... selectionArg) {
+		Cursor cursor = db.rawQuery(statements.getSelectAll() + where, selectionArg);
+		return loadAllAndCloseCursor(cursor);
+	}
+
+	/** @deprecated groupBy & having does not make sense for entities. Method will be removed. */
+	public List<T> query(String selection, String[] selectionArgs, String groupBy, String having, String orderby) {
+		Cursor cursor = db.query(config.tablename, getAllColumns(), selection, selectionArgs, groupBy, having, orderby);
+		return loadAllAndCloseCursor(cursor);
+	}
+
+	public void deleteAll() {
+		// String sql = SqlUtils.createSqlDelete(config.tablename, null);
+		// db.execSQL(sql);
+
+		db.execSQL("DELETE FROM '" + config.tablename + "'");
+		if (identityScope != null) {
+			identityScope.clear();
+		}
+	}
+
+	/** Deletes the given entity from the database. Currently, only single value PK entities are supported. */
+	public void delete(T entity) {
+		assertSinglePk();
+		K key = getKeyVerified(entity);
+		deleteByKey(key);
+		if (identityScope != null) {
+			identityScope.remove(key);
+		}
+	}
+
+	/** Deletes an entity with the given PK from the database. Currently, only single value PK entities are supported. */
+	public void deleteByKey(K key) {
+		assertSinglePk();
+		SQLiteStatementWrapper stmt = statements.getDeleteStatement();
+		synchronized (stmt) {
+			deleteByKeyInsideSynchronized(key, stmt);
+		}
+		if (identityScope != null) {
+			identityScope.remove(key);
+		}
+	}
+
+	private void deleteByKeyInsideSynchronized(K key, SQLiteStatementWrapper stmt) {
+		if (key instanceof Long) {
+			stmt.bindLong(1, (Long) key);
+		} else {
+			stmt.bindString(1, key.toString());
+		}
+		stmt.execute();
+	}
+
+	/**
+	 * Deletes the given entities in the database using a transaction.
+	 * 
+	 * @param entities
+	 *            The entities to delete.
+	 */
+	public void deleteInTx(Iterable<T> entities) {
+		assertSinglePk();
+		SQLiteStatementWrapper stmt = statements.getDeleteStatement();
+		synchronized (stmt) {
+			db.beginTransaction();
+			try {
+				List<K> keysToRemoveFromIdentityScope = null;
+				if (identityScope != null) {
+					identityScope.lock();
+					keysToRemoveFromIdentityScope = new ArrayList<K>();
+				}
+				try {
+					for (T entity : entities) {
+						K key = getKeyVerified(entity);
+						deleteByKeyInsideSynchronized(key, stmt);
+						if (keysToRemoveFromIdentityScope != null) {
+							keysToRemoveFromIdentityScope.add(key);
+						}
+					}
+				} finally {
+					if (identityScope != null) {
+						identityScope.unlock();
+					}
+				}
+				db.setTransactionSuccessful();
+				if (keysToRemoveFromIdentityScope != null && identityScope != null) {
+					identityScope.remove(keysToRemoveFromIdentityScope);
+				}
+			} finally {
+				db.endTransaction();
+			}
+		}
+	}
+
+	/**
+	 * Deletes the given entities in the database using a transaction.
+	 * 
+	 * @param entities
+	 *            The entities to delete.
+	 */
+	public void deleteInTx(T... entities) {
+		deleteInTx(Arrays.asList(entities));
+	}
+
+	/** Resets all locally changed properties of the entity by reloading the values from the database. */
+	public void refresh(T entity) {
+		assertSinglePk();
+		K key = getKeyVerified(entity);
+		String sql = statements.getSelectByKey();
+		String[] keyArray = new String[] { key.toString() };
+		Cursor cursor = db.rawQuery(sql, keyArray);
+		try {
+			boolean available = cursor.moveToFirst();
+			if (!available) {
+				throw new DaoException("Entity does not exist in the database anymore: " + entity.getClass() + " with key " + key);
+			} else if (!cursor.isLast()) {
+				throw new DaoException("Expected unique result, but count was " + cursor.getCount());
+			}
+			readEntity(cursor, entity, 0);
+			attachEntity(key, entity, true);
+		} finally {
+			cursor.close();
+		}
+	}
+
+	public void update(T entity) {
+		assertSinglePk();
+		SQLiteStatementWrapper stmt = statements.getUpdateStatement();
+		synchronized (stmt) {
+			updateInsideSynchronized(entity, stmt, true);
+		}
+	}
+
+	public QueryBuilder<T> queryBuilder() {
+		return new QueryBuilder<T>(this);
+	}
+
+	protected void updateInsideSynchronized(T entity, SQLiteStatementWrapper stmt, boolean lock) {
+		// To do? Check if it's worth not to bind PKs here (performance).
+		bindValues(stmt, entity);
+		int index = config.allColumns.length + 1;
+		K key = getKey(entity);
+		if (key instanceof Long) {
+			stmt.bindLong(index, (Long) key);
+		} else {
+			stmt.bindString(index, key.toString());
+		}
+		stmt.execute();
+		attachEntity(key, entity, lock);
+	}
+
+	/**
+	 * Attaches the entity to the identity scope. Calls attachEntity(T entity).
+	 * 
+	 * @param key
+	 *            Needed only for identity scope, pass null if there's none.
+	 * @param entity
+	 *            The entitiy to attach
+	 * */
+	protected final void attachEntity(K key, T entity, boolean lock) {
+		if (identityScope != null && key != null) {
+			if (lock) {
+				identityScope.put(key, entity);
+			} else {
+				identityScope.putNoLock(key, entity);
+			}
+		}
+		attachEntity(entity);
+	}
+
+	/**
+	 * Sub classes with relations additionally set the DaoMaster here.
+	 * 
+	 * @param entity
+	 *            The entitiy to attach
+	 * */
+	protected void attachEntity(T entity) {
+	}
+
+	/**
+	 * Updates the given entities in the database using a transaction.
+	 * 
+	 * @param entities
+	 *            The entities to insert.
+	 */
+	public void updateInTx(Iterable<T> entities) {
+		SQLiteStatementWrapper stmt = statements.getUpdateStatement();
+		synchronized (stmt) {
+			db.beginTransaction();
+			try {
+				if (identityScope != null) {
+					identityScope.lock();
+				}
+				try {
+					for (T entity : entities) {
+						updateInsideSynchronized(entity, stmt, false);
+					}
+				} finally {
+					if (identityScope != null) {
+						identityScope.unlock();
+					}
+				}
+				db.setTransactionSuccessful();
+			} finally {
+				db.endTransaction();
+			}
+		}
+	}
+
+	/**
+	 * Updates the given entities in the database using a transaction.
+	 * 
+	 * @param entities
+	 *            The entities to update.
+	 */
+	public void updateInTx(T... entities) {
+		updateInTx(Arrays.asList(entities));
+	}
+
+	protected void assertSinglePk() {
+		if (config.pkColumns.length != 1) {
+			throw new DaoException(this + " (" + config.tablename + ") does not have a single-column primary key");
+		}
+	}
+
+	public long count() {
+		return DatabaseUtils.queryNumEntries(db, '\'' + config.tablename + '\'');
+	}
+
+	/** See {@link #getKey(Object)}, but guarantees that the returned key is never null (throws if null). */
+	protected K getKeyVerified(T entity) {
+		K key = getKey(entity);
+		if (key == null) {
+			if (entity == null) {
+				throw new NullPointerException("Entity may not be null");
+			} else {
+				throw new DaoException("Entity has no key");
+			}
+		} else {
+			return key;
+		}
+	}
+
+	/** Gets the SQLiteDatabaseWrapper for custom database access. Not needed for greenDAO entities. */
+	public SQLiteDatabaseWrapper getDatabase() {
+		return db;
+	}
+
+	/** Reads the values from the current position of the given cursor and returns a new entity. */
+	abstract protected T readEntity(Cursor cursor, int offset);
+
+	/** Reads the key from the current position of the given cursor, or returns null if there's no single-value key. */
+	abstract protected K readKey(Cursor cursor, int offset);
+
+	/** Reads the values from the current position of the given cursor into an existing entity. */
+	abstract protected void readEntity(Cursor cursor, T entity, int offset);
+
+	/** Binds the entity's values to the statement. Make sure to synchronize the statement outside of the method. */
+	abstract protected void bindValues(SQLiteStatementWrapper stmt, T entity);
+
+	/**
+	 * Updates the entity's key if possible (only for Long PKs currently). This method must always return the entity's key regardless of whether the key existed before or not.
+	 */
+	abstract protected K updateKeyAfterInsert(T entity, long rowId);
+
+	/**
+	 * Returns the value of the primary key, if the entity has a single primary key, or, if not, null. Returns null if entity is null.
+	 */
+	abstract protected K getKey(T entity);
+
+	/** Returns true if the Entity class can be updated, e.g. for setting the PK after insert. */
+	abstract protected boolean isEntityUpdateable();
 
 }
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDaoMaster.java b/DaoCore/src/de/greenrobot/dao/AbstractDaoMaster.java
index 708d049d..7c073811 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDaoMaster.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDaoMaster.java
@@ -19,7 +19,7 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import android.database.sqlite.SQLiteDatabase;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
 
 /**
  * The master of dao will guide you: start dao sessions with the master.
@@ -27,11 +27,11 @@
  * @author Markus
  */
 public abstract class AbstractDaoMaster {
-    protected final SQLiteDatabase db;
+    protected final SQLiteDatabaseWrapper db;
     protected final int schemaVersion;
     protected final Map<Class<? extends AbstractDao<?, ?>>, DaoConfig> daoConfigMap;
 
-    public AbstractDaoMaster(SQLiteDatabase db, int schemaVersion) {
+    public AbstractDaoMaster(SQLiteDatabaseWrapper db, int schemaVersion) {
         this.db = db;
         this.schemaVersion = schemaVersion;
 
@@ -47,8 +47,8 @@ public int getSchemaVersion() {
         return schemaVersion;
     }
 
-    /** Gets the SQLiteDatabase for custom database access. Not needed for greenDAO entities. */
-    public SQLiteDatabase getDatabase() {
+    /** Gets the SQLiteDatabaseWrapper for custom database access. Not needed for greenDAO entities. */
+    public SQLiteDatabaseWrapper getDatabase() {
         return db;
     }
 
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java b/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
index 081ee710..b4742d73 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDaoSession.java
@@ -20,7 +20,7 @@
 import java.util.Map;
 import java.util.concurrent.Callable;
 
-import android.database.sqlite.SQLiteDatabase;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
 
 /**
  * DaoSession gives you access to your DAOs, offers convenient persistence methods, and also serves as a session cache.<br/>
@@ -42,10 +42,10 @@
  * 
  */
 public class AbstractDaoSession {
-    private final SQLiteDatabase db;
+    private final SQLiteDatabaseWrapper db;
     private final Map<Class<?>, AbstractDao<?, ?>> entityToDao;
 
-    public AbstractDaoSession(SQLiteDatabase db) {
+    public AbstractDaoSession(SQLiteDatabaseWrapper db) {
         this.db = db;
         this.entityToDao = new HashMap<Class<?>, AbstractDao<?, ?>>();
     }
@@ -180,8 +180,8 @@ public void runInTx(Runnable runnable) {
         }
     }
 
-    /** Gets the SQLiteDatabase for custom database access. Not needed for greenDAO entities. */
-    public SQLiteDatabase getDatabase() {
+    /** Gets the SQLiteDatabaseWrapper for custom database access. Not needed for greenDAO entities. */
+    public SQLiteDatabaseWrapper getDatabase() {
         return db;
     }
 
diff --git a/DaoCore/src/de/greenrobot/dao/DaoConfig.java b/DaoCore/src/de/greenrobot/dao/DaoConfig.java
index 0d146b15..553ca225 100644
--- a/DaoCore/src/de/greenrobot/dao/DaoConfig.java
+++ b/DaoCore/src/de/greenrobot/dao/DaoConfig.java
@@ -20,7 +20,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import android.database.sqlite.SQLiteDatabase;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
 
 /**
  * Internal class used by greenDAO. DaoConfig stores essential data for DAOs, and is hold by AbstractDaoMaster. This
@@ -28,7 +28,7 @@
  */
 public final class DaoConfig implements Cloneable {
 
-    final SQLiteDatabase db;
+    final SQLiteDatabaseWrapper db;
     final String tablename;
     final Property[] properties;
 
@@ -45,7 +45,7 @@
 
     private IdentityScope<?, ?> identityScope;
 
-    DaoConfig(SQLiteDatabase db, Class<? extends AbstractDao<?, ?>> daoClass) {
+    DaoConfig(SQLiteDatabaseWrapper db, Class<? extends AbstractDao<?, ?>> daoClass) {
         this.db = db;
         try {
             this.tablename = (String) daoClass.getField("TABLENAME").get(null);
diff --git a/DaoCore/src/de/greenrobot/dao/DbUtils.java b/DaoCore/src/de/greenrobot/dao/DbUtils.java
index 62e5c976..7bba9f39 100644
--- a/DaoCore/src/de/greenrobot/dao/DbUtils.java
+++ b/DaoCore/src/de/greenrobot/dao/DbUtils.java
@@ -21,25 +21,26 @@
 import java.io.InputStream;
 import java.io.OutputStream;
 
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+
 import android.content.Context;
 import android.database.Cursor;
 import android.database.DatabaseUtils;
-import android.database.sqlite.SQLiteDatabase;
 
 /** Database utils, for example to execute SQL scripts */
 // TODO add unit tests
 public class DbUtils {
 
-    public static void vacuum(SQLiteDatabase db) {
+    public static void vacuum(SQLiteDatabaseWrapper db) {
         db.execSQL("VACUUM");
     }
 
     /**
-     * Calls {@link #executeSqlScript(Context, SQLiteDatabase, String, boolean)} with transactional set to true.
+     * Calls {@link #executeSqlScript(Context, SQLiteDatabaseWrapper, String, boolean)} with transactional set to true.
      * 
      * @return number of statements executed.
      */
-    public static int executeSqlScript(Context context, SQLiteDatabase db, String assetFilename) throws IOException {
+    public static int executeSqlScript(Context context, SQLiteDatabaseWrapper db, String assetFilename) throws IOException {
         return executeSqlScript(context, db, assetFilename, true);
     }
 
@@ -51,7 +52,7 @@ public static int executeSqlScript(Context context, SQLiteDatabase db, String as
      * 
      * @return number of statements executed.
      */
-    public static int executeSqlScript(Context context, SQLiteDatabase db, String assetFilename, boolean transactional)
+    public static int executeSqlScript(Context context, SQLiteDatabaseWrapper db, String assetFilename, boolean transactional)
             throws IOException {
         byte[] bytes = readAsset(context, assetFilename);
         String sql = new String(bytes, "UTF-8");
@@ -66,7 +67,7 @@ public static int executeSqlScript(Context context, SQLiteDatabase db, String as
         return count;
     }
 
-    public static int executeSqlStatementsInTx(SQLiteDatabase db, String[] statements) {
+    public static int executeSqlStatementsInTx(SQLiteDatabaseWrapper db, String[] statements) {
         db.beginTransaction();
         try {
             int count = executeSqlStatements(db, statements);
@@ -77,7 +78,7 @@ public static int executeSqlStatementsInTx(SQLiteDatabase db, String[] statement
         }
     }
 
-    public static int executeSqlStatements(SQLiteDatabase db, String[] statements) {
+    public static int executeSqlStatements(SQLiteDatabaseWrapper db, String[] statements) {
         int count = 0;
         for (String line : statements) {
             line = line.trim();
@@ -123,7 +124,7 @@ public static int copyAllBytes(InputStream in, OutputStream out) throws IOExcept
         }
     }
 
-    public static void logTableDump(SQLiteDatabase db, String tablename) {
+    public static void logTableDump(SQLiteDatabaseWrapper db, String tablename) {
         Cursor cursor = db.query(tablename, null, null, null, null, null, null);
         try {
             String dump = DatabaseUtils.dumpCursorToString(cursor);
diff --git a/DaoCore/src/de/greenrobot/dao/DeleteQuery.java b/DaoCore/src/de/greenrobot/dao/DeleteQuery.java
index 6289f1e7..f354eca8 100644
--- a/DaoCore/src/de/greenrobot/dao/DeleteQuery.java
+++ b/DaoCore/src/de/greenrobot/dao/DeleteQuery.java
@@ -17,7 +17,7 @@
 
 import java.util.Collection;
 
-import android.database.sqlite.SQLiteStatement;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 
 /**
  * A repeatable query for deleting entities.<br/>
@@ -30,7 +30,7 @@
  */
 public class DeleteQuery<T> extends AbstractQuery<T> {
 
-    private SQLiteStatement compiledStatement;
+    private SQLiteStatementWrapper compiledStatement;
 
     public DeleteQuery(AbstractDao<T, ?> dao, String sql, Collection<Object> valueList) {
         super(dao, sql, valueList);
diff --git a/DaoCore/src/de/greenrobot/dao/TableStatements.java b/DaoCore/src/de/greenrobot/dao/TableStatements.java
index 8c8fe198..72e9f8d0 100644
--- a/DaoCore/src/de/greenrobot/dao/TableStatements.java
+++ b/DaoCore/src/de/greenrobot/dao/TableStatements.java
@@ -15,33 +15,33 @@
  */
 package de.greenrobot.dao;
 
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 
 /** Helper class to create SQL statements for specific tables (used by greenDAO internally). */
 public class TableStatements {
-    private final SQLiteDatabase db;
+    private final SQLiteDatabaseWrapper db;
     private final String tablename;
     private final String[] allColumns;
     private final String[] pkColumns;
 
-    private SQLiteStatement insertStatement;
-    private SQLiteStatement insertOrReplaceStatement;
-    private SQLiteStatement updateStatement;
-    private SQLiteStatement deleteStatement;
+    private SQLiteStatementWrapper insertStatement;
+    private SQLiteStatementWrapper insertOrReplaceStatement;
+    private SQLiteStatementWrapper updateStatement;
+    private SQLiteStatementWrapper deleteStatement;
 
     private volatile String selectAll;
     private volatile String selectByKey;
     private volatile String selectByRowId;
 
-    protected TableStatements(SQLiteDatabase db, String tablename, String[] allColumns, String[] pkColumns) {
+    protected TableStatements(SQLiteDatabaseWrapper db, String tablename, String[] allColumns, String[] pkColumns) {
         this.db = db;
         this.tablename = tablename;
         this.allColumns = allColumns;
         this.pkColumns = pkColumns;
     }
 
-    protected SQLiteStatement getInsertStatement() {
+    protected SQLiteStatementWrapper getInsertStatement() {
         if (insertStatement == null) {
             String sql = SqlUtils.createSqlInsert("INSERT INTO ", tablename, allColumns);
             insertStatement = db.compileStatement(sql);
@@ -49,7 +49,7 @@ protected SQLiteStatement getInsertStatement() {
         return insertStatement;
     }
 
-    protected SQLiteStatement getInsertOrReplaceStatement() {
+    protected SQLiteStatementWrapper getInsertOrReplaceStatement() {
         if (insertOrReplaceStatement == null) {
             String sql = SqlUtils.createSqlInsert("INSERT OR REPLACE INTO ", tablename, allColumns);
             insertOrReplaceStatement = db.compileStatement(sql);
@@ -57,7 +57,7 @@ protected SQLiteStatement getInsertOrReplaceStatement() {
         return insertOrReplaceStatement;
     }
 
-    protected SQLiteStatement getDeleteStatement() {
+    protected SQLiteStatementWrapper getDeleteStatement() {
         if (deleteStatement == null) {
             String sql = SqlUtils.createSqlDelete(tablename, pkColumns);
             deleteStatement = db.compileStatement(sql);
@@ -65,7 +65,7 @@ protected SQLiteStatement getDeleteStatement() {
         return deleteStatement;
     }
 
-    protected SQLiteStatement getUpdateStatement() {
+    protected SQLiteStatementWrapper getUpdateStatement() {
         if (updateStatement == null) {
             String sql = SqlUtils.createSqlUpdate(tablename, allColumns, pkColumns);
             updateStatement = db.compileStatement(sql);
diff --git a/DaoCore/src/de/greenrobot/dao/UnitTestDaoAccess.java b/DaoCore/src/de/greenrobot/dao/UnitTestDaoAccess.java
index 82081024..7db9ba34 100644
--- a/DaoCore/src/de/greenrobot/dao/UnitTestDaoAccess.java
+++ b/DaoCore/src/de/greenrobot/dao/UnitTestDaoAccess.java
@@ -18,14 +18,15 @@
 
 import java.lang.reflect.Constructor;
 
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+
 import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
 
 /** Reserved for internal unit tests that want to access some non-public methods. Don't use for anything else. */
 public class UnitTestDaoAccess<T, K> {
     private final AbstractDao<T, K> dao;
 
-    public UnitTestDaoAccess(SQLiteDatabase db, Class<AbstractDao<T, K>> daoClass, IdentityScope<?, ?> identityScope)
+    public UnitTestDaoAccess(SQLiteDatabaseWrapper db, Class<AbstractDao<T, K>> daoClass, IdentityScope<?, ?> identityScope)
             throws Exception {
         DaoConfig daoConfig = new DaoConfig(db, daoClass);
         daoConfig.setIdentityScope(identityScope);
diff --git a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoSessionTest.java b/DaoCore/src/de/greenrobot/dao/test/AbstractDaoSessionTest.java
index 941f32ff..2e8898d6 100644
--- a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoSessionTest.java
+++ b/DaoCore/src/de/greenrobot/dao/test/AbstractDaoSessionTest.java
@@ -20,9 +20,9 @@
 import java.lang.reflect.Method;
 
 import android.app.Application;
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDaoMaster;
 import de.greenrobot.dao.AbstractDaoSession;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
 
 /**
  * Base class for DAO (master) related testing.
@@ -32,41 +32,40 @@
  * @param <T>
  *            Type of a concrete DAO master
  */
-public abstract class AbstractDaoSessionTest<A extends Application, T extends AbstractDaoMaster, S extends AbstractDaoSession>
-        extends DbTest<A> {
+public abstract class AbstractDaoSessionTest<A extends Application, T extends AbstractDaoMaster, S extends AbstractDaoSession> extends DbTest<A> {
 
-    private final Class<T> daoMasterClass;
-    protected T daoMaster;
-    protected S daoSession;
+	private final Class<T> daoMasterClass;
+	protected T daoMaster;
+	protected S daoSession;
 
-    public AbstractDaoSessionTest(Class<T> daoMasterClass) {
-        this(daoMasterClass, true);
-    }
+	public AbstractDaoSessionTest(Class<T> daoMasterClass) {
+		this(daoMasterClass, true);
+	}
 
-    public AbstractDaoSessionTest(Class<T> daoMasterClass, boolean inMemory) {
-        super(inMemory);
-        this.daoMasterClass = daoMasterClass;
-    }
+	public AbstractDaoSessionTest(Class<T> daoMasterClass, boolean inMemory) {
+		super(inMemory);
+		this.daoMasterClass = daoMasterClass;
+	}
 
-    public AbstractDaoSessionTest(Class<A> appClass, Class<T> daoMasterClass, boolean inMemory) {
-        super(appClass, inMemory);
-        this.daoMasterClass = daoMasterClass;
-    }
+	public AbstractDaoSessionTest(Class<A> appClass, Class<T> daoMasterClass, boolean inMemory) {
+		super(appClass, inMemory);
+		this.daoMasterClass = daoMasterClass;
+	}
 
-    @SuppressWarnings("unchecked")
-    @Override
-    protected void setUp() {
-        super.setUp();
-        try {
-            Constructor<T> constructor = daoMasterClass.getConstructor(SQLiteDatabase.class);
-            daoMaster = constructor.newInstance(db);
+	@SuppressWarnings("unchecked")
+	@Override
+	protected void setUp() {
+		super.setUp();
+		try {
+			Constructor<T> constructor = daoMasterClass.getConstructor(SQLiteDatabaseWrapper.class);
+			daoMaster = constructor.newInstance(db);
 
-            Method createTableMethod = daoMasterClass.getMethod("createAllTables", SQLiteDatabase.class, boolean.class);
-            createTableMethod.invoke(null, db, false);
-        } catch (Exception e) {
-            throw new RuntimeException("Could not prepare DAO session test", e);
-        }
-        daoSession = (S) daoMaster.newSession();
-    }
+			Method createTableMethod = daoMasterClass.getMethod("createAllTables", SQLiteDatabaseWrapper.class, boolean.class);
+			createTableMethod.invoke(null, db, false);
+		} catch (Exception e) {
+			throw new RuntimeException("Could not prepare DAO session test", e);
+		}
+		daoSession = (S) daoMaster.newSession();
+	}
 
 }
\ No newline at end of file
diff --git a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTest.java b/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTest.java
index 78baedce..9975ae6b 100644
--- a/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTest.java
+++ b/DaoCore/src/de/greenrobot/dao/test/AbstractDaoTest.java
@@ -19,12 +19,12 @@
 import java.lang.reflect.Method;
 
 import android.app.Application;
-import android.database.sqlite.SQLiteDatabase;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoLog;
 import de.greenrobot.dao.IdentityScope;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.UnitTestDaoAccess;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
 
 /**
  * Base class for DAO related testing. Prepares an in-memory DB and DAO.
@@ -74,7 +74,7 @@ protected void setUp() {
 
     protected void setUpTableForDao() throws Exception {
         try {
-            Method createTableMethod = daoClass.getMethod("createTable", SQLiteDatabase.class, boolean.class);
+            Method createTableMethod = daoClass.getMethod("createTable", SQLiteDatabaseWrapper.class, boolean.class);
             createTableMethod.invoke(null, db, false);
         } catch (NoSuchMethodException e) {
             DaoLog.i("No createTable method");
diff --git a/DaoCore/src/de/greenrobot/dao/test/DbTest.java b/DaoCore/src/de/greenrobot/dao/test/DbTest.java
index df55ae36..7c56d871 100644
--- a/DaoCore/src/de/greenrobot/dao/test/DbTest.java
+++ b/DaoCore/src/de/greenrobot/dao/test/DbTest.java
@@ -20,9 +20,9 @@
 
 import android.app.Application;
 import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
 import android.test.ApplicationTestCase;
 import de.greenrobot.dao.DbUtils;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
 
 /**
  * Base class for database related testing. Prepares an in-memory or an file-based DB.
@@ -32,57 +32,57 @@
  */
 public abstract class DbTest<T extends Application> extends ApplicationTestCase<T> {
 
-    protected SQLiteDatabase db;
-    protected Random random;
-    protected final boolean inMemory;
+	protected SQLiteDatabaseWrapper db;
+	protected Random random;
+	protected final boolean inMemory;
 
-    public DbTest() {
-        this(true);
-    }
+	public DbTest() {
+		this(true);
+	}
 
-    @SuppressWarnings("unchecked")
-    public DbTest(boolean inMemory) {
-        this((Class<T>) Application.class, inMemory);
-    }
+	@SuppressWarnings("unchecked")
+	public DbTest(boolean inMemory) {
+		this((Class<T>) Application.class, inMemory);
+	}
 
-    public DbTest(Class<T> appClass, boolean inMemory) {
-        super(appClass);
-        this.inMemory = inMemory;
-        random = new Random();
-    }
+	public DbTest(Class<T> appClass, boolean inMemory) {
+		super(appClass);
+		this.inMemory = inMemory;
+		random = new Random();
+	}
 
-    @Override
-    protected void setUp() {
-        try {
-            super.setUp();
-        } catch (Exception e) {
-            throw new RuntimeException(e);
-        }
-        createApplication();
-        setUpDb();
-    }
+	@Override
+	protected void setUp() {
+		try {
+			super.setUp();
+		} catch (Exception e) {
+			throw new RuntimeException(e);
+		}
+		createApplication();
+		setUpDb();
+	}
 
-    /** Override if you create your own DB */
-    protected void setUpDb() {
-        if (inMemory) {
-            db = SQLiteDatabase.create(null);
-        } else {
-            getApplication().deleteDatabase("test-db");
-            db = getApplication().openOrCreateDatabase("test-db", Context.MODE_PRIVATE, null);
-        }
-    }
+	/** Override if you create your own DB */
+	protected void setUpDb() {
+		if (inMemory) {
+			db = SQLiteDatabaseWrapper.create(null, null);
+		} else {
+			getApplication().deleteDatabase("test-db");
+			db = new SQLiteDatabaseWrapper(getApplication().openOrCreateDatabase("test-db", Context.MODE_PRIVATE, null));
+		}
+	}
 
-    @Override
-    protected void tearDown() throws Exception {
-        db.close();
-        if (!inMemory) {
-            getApplication().deleteDatabase("test-db");
-        }
-        super.tearDown();
-    }
+	@Override
+	protected void tearDown() throws Exception {
+		db.close();
+		if (!inMemory) {
+			getApplication().deleteDatabase("test-db");
+		}
+		super.tearDown();
+	}
 
-    protected void logTableDump(String tablename) {
-        DbUtils.logTableDump(db, tablename);
-    }
+	protected void logTableDump(String tablename) {
+		DbUtils.logTableDump(db, tablename);
+	}
 
 }
\ No newline at end of file
diff --git a/DaoCore/src/de/greenrobot/dao/wrapper/DatabaseUtils.java b/DaoCore/src/de/greenrobot/dao/wrapper/DatabaseUtils.java
new file mode 100644
index 00000000..62eb86b3
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/wrapper/DatabaseUtils.java
@@ -0,0 +1,28 @@
+package de.greenrobot.dao.wrapper;
+
+import android.database.Cursor;
+
+public class DatabaseUtils {
+
+	private static final String[] countProjection = new String[] { "count(*)" };
+
+	/**
+	 * Query the table for the number of rows in the table.
+	 * 
+	 * @param db
+	 *            the database the table is in
+	 * @param table
+	 *            the name of the table to query
+	 * @return the number of rows in the table
+	 */
+	public static long queryNumEntries(SQLiteDatabaseWrapper db, String table) {
+		Cursor cursor = db.query(table, countProjection, null, null, null, null, null);
+		try {
+			cursor.moveToFirst();
+			return cursor.getLong(0);
+		} finally {
+			cursor.close();
+		}
+	}
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteDatabaseHook.java b/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteDatabaseHook.java
new file mode 100644
index 00000000..f5b1e217
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteDatabaseHook.java
@@ -0,0 +1,5 @@
+package de.greenrobot.dao.wrapper;
+
+public interface SQLiteDatabaseHook extends net.sqlcipher.database.SQLiteDatabaseHook {
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteDatabaseWrapper.java b/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteDatabaseWrapper.java
new file mode 100644
index 00000000..fb251aaa
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteDatabaseWrapper.java
@@ -0,0 +1,958 @@
+package de.greenrobot.dao.wrapper;
+
+import java.io.File;
+import java.lang.ref.WeakReference;
+import java.util.HashSet;
+import java.util.Locale;
+import java.util.Map;
+import java.util.concurrent.locks.ReentrantLock;
+
+import net.sqlcipher.database.SQLiteDatabaseCorruptException;
+import net.sqlcipher.database.SQLiteDebug;
+import net.sqlcipher.database.SQLiteTransactionListener;
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteDatabase.CursorFactory;
+import android.database.sqlite.SQLiteException;
+import android.database.sqlite.SQLiteProgram;
+import android.database.sqlite.SQLiteStatement;
+import android.os.Debug;
+import android.os.SystemClock;
+import android.util.Log;
+import de.greenrobot.dao.wrapper.exception.NotSupportedOperationAndroidException;
+
+public class SQLiteDatabaseWrapper {
+
+	private static final String TAG = SQLiteDatabaseWrapper.class.getSimpleName();
+
+	/**
+	 * If set then the SQLiteDatabase is made thread-safe by using locks around critical sections
+	 */
+	private boolean mLockingEnabled = true;
+
+	/** Synchronize on this when accessing the database */
+	private final ReentrantLock mLock = new ReentrantLock(true);
+
+	private long mLockAcquiredWallTime = 0L;
+	private long mLockAcquiredThreadTime = 0L;
+	private long mLastLockMessageTime = 0L;
+
+	// limit the frequency of complaints about each database to one within 20 sec
+	// unless run command adb shell setprop log.tag.Database VERBOSE
+	private static final int LOCK_WARNING_WINDOW_IN_MS = 20000;
+	/** If the lock is held this long then a warning will be printed when it is released. */
+	private static final int LOCK_ACQUIRED_WARNING_TIME_IN_MS = 300;
+	private static final int LOCK_ACQUIRED_WARNING_THREAD_TIME_IN_MS = 100;
+	private static final int LOCK_ACQUIRED_WARNING_TIME_IN_MS_ALWAYS_PRINT = 2000;
+
+	private final SQLiteDatabase sqliteDatabase;
+	private final net.sqlcipher.database.SQLiteDatabase sqlCypheredDatabase;
+
+	private SQLiteDatabaseWrapper(String path, String password, CursorFactory factory, int flags, SQLiteDatabaseHook databaseHook) {
+		if (password == null || password.length() == 0) {
+			sqliteDatabase = SQLiteDatabase.openDatabase(path, factory, flags);
+			sqlCypheredDatabase = null;
+		} else {
+			sqliteDatabase = null;
+			sqlCypheredDatabase = new net.sqlcipher.database.SQLiteDatabase(path, password, (net.sqlcipher.database.SQLiteDatabase.CursorFactory) factory, flags, databaseHook);
+		}
+	}
+
+	public SQLiteDatabaseWrapper(SQLiteDatabase sqliteDatabase) {
+		this.sqliteDatabase = sqliteDatabase;
+		this.sqlCypheredDatabase = null;
+	}
+
+	public SQLiteDatabaseWrapper(net.sqlcipher.database.SQLiteDatabase sqlCypheredDatabase) {
+		this.sqliteDatabase = null;
+		this.sqlCypheredDatabase = sqlCypheredDatabase;
+	}
+
+	public boolean isCypheredDb() {
+		return sqlCypheredDatabase != null;
+	}
+
+	public static void loadLibs(Context context) {
+		net.sqlcipher.database.SQLiteDatabase.loadLibs(context);
+	}
+
+	public static void loadLibs(Context context, File workingDir) {
+		net.sqlcipher.database.SQLiteDatabase.loadLibs(context, workingDir);
+	}
+
+	public static int releaseMemory() {
+		return net.sqlcipher.database.SQLiteDatabase.releaseMemory() + SQLiteDatabase.releaseMemory();
+	}
+
+	public void setLockingEnabled(boolean lockingEnabled) {
+		if (isCypheredDb())
+			sqlCypheredDatabase.setLockingEnabled(lockingEnabled);
+		else
+			sqliteDatabase.setLockingEnabled(lockingEnabled);
+	}
+
+	public void beginTransaction() {
+		if (isCypheredDb())
+			sqlCypheredDatabase.beginTransaction();
+		else
+			sqliteDatabase.beginTransaction();
+	}
+
+	public void beginTransactionWithListener(SQLiteTransactionListener transactionListener) {
+		if (isCypheredDb())
+			sqlCypheredDatabase.beginTransactionWithListener(transactionListener);
+		else
+			throw new NotSupportedOperationAndroidException();
+	}
+
+	public void setTransactionSuccessful() {
+		if (isCypheredDb())
+			sqlCypheredDatabase.setTransactionSuccessful();
+		else
+			sqliteDatabase.setTransactionSuccessful();
+	}
+
+	public void endTransaction() {
+		if (isCypheredDb())
+			sqlCypheredDatabase.endTransaction();
+		else
+			sqliteDatabase.endTransaction();
+	}
+
+	/**
+	 * return true if there is a transaction pending
+	 */
+	public boolean inTransaction() {
+		return isCypheredDb() ? sqlCypheredDatabase.inTransaction() : sqliteDatabase.inTransaction();
+	}
+
+	/**
+	 * Checks if the database lock is held by this thread.
+	 * 
+	 * @return true, if this thread is holding the database lock.
+	 */
+	public boolean isDbLockedByCurrentThread() {
+		return isCypheredDb() ? sqlCypheredDatabase.isDbLockedByCurrentThread() : sqliteDatabase.isDbLockedByCurrentThread();
+	}
+
+	/**
+	 * Checks if the database is locked by another thread. This is just an estimate, since this status can change at any time, including after the call is made but before the result has been acted upon.
+	 * 
+	 * @return true, if the database is locked by another thread
+	 */
+	public boolean isDbLockedByOtherThreads() {
+		return isCypheredDb() ? sqlCypheredDatabase.isDbLockedByOtherThreads() : sqliteDatabase.isDbLockedByOtherThreads();
+	}
+
+	/**
+	 * Temporarily end the transaction to let other threads run. The transaction is assumed to be successful so far. Do not call setTransactionSuccessful before calling this. When this returns a new transaction will have been created but not marked as successful.
+	 * 
+	 * @return true if the transaction was yielded
+	 * @deprecated if the db is locked more than once (becuase of nested transactions) then the lock will not be yielded. Use yieldIfContendedSafely instead.
+	 */
+	@Deprecated
+	public boolean yieldIfContended() {
+		return isCypheredDb() ? sqlCypheredDatabase.yieldIfContended() : sqliteDatabase.yieldIfContended();
+	}
+
+	/**
+	 * Temporarily end the transaction to let other threads run. The transaction is assumed to be successful so far. Do not call setTransactionSuccessful before calling this. When this returns a new transaction will have been created but not marked as successful. This assumes that there are no nested transactions (beginTransaction has only been called once) and will throw an exception if that is not the case.
+	 * 
+	 * @return true if the transaction was yielded
+	 */
+	public boolean yieldIfContendedSafely() {
+		return isCypheredDb() ? sqlCypheredDatabase.yieldIfContendedSafely() : sqliteDatabase.yieldIfContendedSafely();
+	}
+
+	/**
+	 * Temporarily end the transaction to let other threads run. The transaction is assumed to be successful so far. Do not call setTransactionSuccessful before calling this. When this returns a new transaction will have been created but not marked as successful. This assumes that there are no nested transactions (beginTransaction has only been called once) and will throw an exception if that is not the case.
+	 * 
+	 * @param sleepAfterYieldDelay
+	 *            if > 0, sleep this long before starting a new transaction if the lock was actually yielded. This will allow other background threads to make some more progress than they would if we started the transaction immediately.
+	 * @return true if the transaction was yielded
+	 */
+	public boolean yieldIfContendedSafely(long sleepAfterYieldDelay) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.yieldIfContendedSafely(sleepAfterYieldDelay);
+		else
+			throw new NotSupportedOperationAndroidException();
+	}
+
+	public Map<String, String> getSyncedTables() {
+		return isCypheredDb() ? sqlCypheredDatabase.getSyncedTables() : sqliteDatabase.getSyncedTables();
+	}
+
+	/**
+	 * Open the database according to the flags {@link #OPEN_READWRITE} {@link #OPEN_READONLY} {@link #CREATE_IF_NECESSARY} and/or {@link #NO_LOCALIZED_COLLATORS}.
+	 * 
+	 * <p>
+	 * Sets the locale of the database to the the system's current locale. Call {@link #setLocale} if you would like something else.
+	 * </p>
+	 * 
+	 * @param path
+	 *            to database file to open and/or create
+	 * @param factory
+	 *            an optional factory class that is called to instantiate a cursor when query is called, or null for default
+	 * @param flags
+	 *            to control database access mode
+	 * @return the newly opened database
+	 * @throws SQLiteException
+	 *             if the database cannot be opened
+	 */
+	public static SQLiteDatabaseWrapper openDatabase(String path, String password, CursorFactory factory, int flags, SQLiteDatabaseHook databaseHook) {
+		SQLiteDatabaseWrapper sqliteDatabase = null;
+		try {
+			// Open the database.
+			sqliteDatabase = new SQLiteDatabaseWrapper(path, password, factory, flags, databaseHook);
+			if (SQLiteDebug.DEBUG_SQL_STATEMENTS) {
+				sqliteDatabase.enableSqlTracing(path);
+			}
+			if (SQLiteDebug.DEBUG_SQL_TIME) {
+				sqliteDatabase.enableSqlProfiling(path);
+			}
+		} catch (SQLiteDatabaseCorruptException e) {
+			// Try to recover from this, if we can.
+			// TODO: should we do this for other open failures?
+			Log.e(TAG, "Deleting and re-creating corrupt database " + path, e);
+			// EventLog.writeEvent(EVENT_DB_CORRUPT, path);
+			if (!path.equalsIgnoreCase(":memory")) {
+				// delete is only for non-memory database files
+				new File(path).delete();
+			}
+			sqliteDatabase = new SQLiteDatabaseWrapper(path, password, factory, flags, databaseHook);
+		}
+		ActiveDatabases.getInstance().mActiveDatabases.add(new WeakReference<SQLiteDatabaseWrapper>(sqliteDatabase));
+		return sqliteDatabase;
+	}
+
+	private void enableSqlProfiling(String path) {
+		// TODO Need to call private native methods of SQLiteDatabase.... Should I use reflection ?
+	}
+
+	private void enableSqlTracing(String path) {
+		// TODO Need to call private native methods of SQLiteDatabase.... Should I use reflection ?
+	}
+
+	public static SQLiteDatabaseWrapper openDatabase(String path, String password, CursorFactory factory, int flags) {
+		return openDatabase(path, password, factory, flags, null);
+	}
+
+	public static SQLiteDatabaseWrapper openOrCreateDatabase(File file, String password, CursorFactory factory, SQLiteDatabaseHook databaseHook) {
+		return openOrCreateDatabase(file.getPath(), password, factory, databaseHook);
+	}
+
+	public static SQLiteDatabaseWrapper openOrCreateDatabase(String path, String password, CursorFactory factory, SQLiteDatabaseHook databaseHook) {
+		return openDatabase(path, password, factory, SQLiteDatabase.CREATE_IF_NECESSARY, databaseHook);
+	}
+
+	/**
+	 * Equivalent to openDatabase(file.getPath(), factory, CREATE_IF_NECESSARY).
+	 */
+	public static SQLiteDatabaseWrapper openOrCreateDatabase(File file, String password, CursorFactory factory) {
+		return openOrCreateDatabase(file.getPath(), password, factory, null);
+	}
+
+	/**
+	 * Equivalent to openDatabase(path, factory, CREATE_IF_NECESSARY).
+	 */
+	public static SQLiteDatabaseWrapper openOrCreateDatabase(String path, String password, CursorFactory factory) {
+		return openDatabase(path, password, factory, SQLiteDatabase.CREATE_IF_NECESSARY, null);
+	}
+
+	/**
+	 * Create a memory backed SQLite database. Its contents will be destroyed when the database is closed.
+	 * 
+	 * <p>
+	 * Sets the locale of the database to the the system's current locale. Call {@link #setLocale} if you would like something else.
+	 * </p>
+	 * 
+	 * @param factory
+	 *            an optional factory class that is called to instantiate a cursor when query is called
+	 * @return a SQLiteDatabase object, or null if the database can't be created
+	 */
+	public static SQLiteDatabaseWrapper create(CursorFactory factory, String password) {
+		return openDatabase(":memory:", password, factory, SQLiteDatabase.CREATE_IF_NECESSARY);
+	}
+
+	/**
+	 * Close the database.
+	 */
+	public void close() {
+		if (isCypheredDb())
+			sqlCypheredDatabase.close();
+		else
+			sqliteDatabase.close();
+	}
+
+	/**
+	 * Gets the database version.
+	 * 
+	 * @return the database version
+	 */
+	public int getVersion() {
+		return isCypheredDb() ? sqlCypheredDatabase.getVersion() : sqliteDatabase.getVersion();
+	}
+
+	/**
+	 * Sets the database version.
+	 * 
+	 * @param version
+	 *            the new database version
+	 */
+	public void setVersion(int version) {
+		if (isCypheredDb())
+			sqlCypheredDatabase.setVersion(version);
+		else
+			sqliteDatabase.setVersion(version);
+	}
+
+	/**
+	 * Returns the maximum size the database may grow to.
+	 * 
+	 * @return the new maximum database size
+	 */
+	public long getMaximumSize() {
+		return isCypheredDb() ? sqlCypheredDatabase.getMaximumSize() : sqliteDatabase.getMaximumSize();
+	}
+
+	/**
+	 * Sets the maximum size the database will grow to. The maximum size cannot be set below the current size.
+	 * 
+	 * @param numBytes
+	 *            the maximum database size, in bytes
+	 * @return the new maximum database size
+	 */
+	public long setMaximumSize(long numBytes) {
+		return isCypheredDb() ? sqlCypheredDatabase.setMaximumSize(numBytes) : sqliteDatabase.setMaximumSize(numBytes);
+	}
+
+	/**
+	 * Returns the current database page size, in bytes.
+	 * 
+	 * @return the database page size, in bytes
+	 */
+	public long getPageSize() {
+		return isCypheredDb() ? sqlCypheredDatabase.getPageSize() : sqliteDatabase.getPageSize();
+	}
+
+	/**
+	 * Sets the database page size. The page size must be a power of two. This method does not work if any data has been written to the database file, and must be called right after the database has been created.
+	 * 
+	 * @param numBytes
+	 *            the database page size, in bytes
+	 */
+	public void setPageSize(long numBytes) {
+		if (isCypheredDb())
+			sqlCypheredDatabase.setPageSize(numBytes);
+		else
+			sqliteDatabase.setPageSize(numBytes);
+	}
+
+	/**
+	 * Mark this table as syncable. When an update occurs in this table the _sync_dirty field will be set to ensure proper syncing operation.
+	 * 
+	 * @param table
+	 *            the table to mark as syncable
+	 * @param deletedTable
+	 *            The deleted table that corresponds to the syncable table
+	 */
+	public void markTableSyncable(String table, String deletedTable) {
+		if (isCypheredDb())
+			sqlCypheredDatabase.markTableSyncable(table, deletedTable);
+		else
+			sqliteDatabase.markTableSyncable(table, deletedTable);
+	}
+
+	/**
+	 * Mark this table as syncable, with the _sync_dirty residing in another table. When an update occurs in this table the _sync_dirty field of the row in updateTable with the _id in foreignKey will be set to ensure proper syncing operation.
+	 * 
+	 * @param table
+	 *            an update on this table will trigger a sync time removal
+	 * @param foreignKey
+	 *            this is the column in table whose value is an _id in updateTable
+	 * @param updateTable
+	 *            this is the table that will have its _sync_dirty
+	 */
+	public void markTableSyncable(String table, String foreignKey, String updateTable) {
+		if (isCypheredDb())
+			sqlCypheredDatabase.markTableSyncable(table, foreignKey, updateTable);
+		else
+			sqliteDatabase.markTableSyncable(table, foreignKey, updateTable);
+	}
+
+	/**
+	 * Finds the name of the first table, which is editable.
+	 * 
+	 * @param tables
+	 *            a list of tables
+	 * @return the first table listed
+	 */
+	public String findEditTable(String tables) {
+		if (isCypheredDb())
+			return net.sqlcipher.database.SQLiteDatabase.findEditTable(tables);
+		else
+			return SQLiteDatabase.findEditTable(tables);
+	}
+
+	/**
+	 * Compiles an SQL statement into a reusable pre-compiled statement object. The parameters are identical to {@link #execSQL(String)}. You may put ?s in the statement and fill in those values with {@link SQLiteProgram#bindString} and {@link SQLiteProgram#bindLong} each time you want to run the statement. Statements may not return result sets larger than 1x1.
+	 * 
+	 * @param sql
+	 *            The raw SQL statement, may contain ? for unknown values to be bound later.
+	 * @return A pre-compiled {@link SQLiteStatement} object. Note that {@link SQLiteStatement}s are not synchronized, see the documentation for more details.
+	 */
+	public SQLiteStatementWrapper compileStatement(String sql) throws SQLException {
+		if (isCypheredDb())
+			return new SQLiteStatementWrapper(sqlCypheredDatabase.compileStatement(sql));
+		else
+			return new SQLiteStatementWrapper(sqliteDatabase.compileStatement(sql));
+	}
+
+	/**
+	 * Query the given URL, returning a {@link Cursor} over the result set.
+	 * 
+	 * @param distinct
+	 *            true if you want each row to be unique, false otherwise.
+	 * @param table
+	 *            The table name to compile the query against.
+	 * @param columns
+	 *            A list of which columns to return. Passing null will return all columns, which is discouraged to prevent reading data from storage that isn't going to be used.
+	 * @param selection
+	 *            A filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given table.
+	 * @param selectionArgs
+	 *            You may include ?s in selection, which will be replaced by the values from selectionArgs, in order that they appear in the selection. The values will be bound as Strings.
+	 * @param groupBy
+	 *            A filter declaring how to group rows, formatted as an SQL GROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped.
+	 * @param having
+	 *            A filter declare which row groups to include in the cursor, if row grouping is being used, formatted as an SQL HAVING clause (excluding the HAVING itself). Passing null will cause all row groups to be included, and is required when row grouping is not being used.
+	 * @param orderBy
+	 *            How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.
+	 * @param limit
+	 *            Limits the number of rows returned by the query, formatted as LIMIT clause. Passing null denotes no LIMIT clause.
+	 * @return A {@link Cursor} object, which is positioned before the first entry. Note that {@link Cursor}s are not synchronized, see the documentation for more details.
+	 * @see Cursor
+	 */
+	public Cursor query(boolean distinct, String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.query(distinct, table, columns, selection, selectionArgs, groupBy, having, orderBy, limit);
+		else
+			return sqliteDatabase.query(distinct, table, columns, selection, selectionArgs, groupBy, having, orderBy, limit);
+
+	}
+
+	/**
+	 * Query the given URL, returning a {@link Cursor} over the result set.
+	 * 
+	 * @param cursorFactory
+	 *            the cursor factory to use, or null for the default factory
+	 * @param distinct
+	 *            true if you want each row to be unique, false otherwise.
+	 * @param table
+	 *            The table name to compile the query against.
+	 * @param columns
+	 *            A list of which columns to return. Passing null will return all columns, which is discouraged to prevent reading data from storage that isn't going to be used.
+	 * @param selection
+	 *            A filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given table.
+	 * @param selectionArgs
+	 *            You may include ?s in selection, which will be replaced by the values from selectionArgs, in order that they appear in the selection. The values will be bound as Strings.
+	 * @param groupBy
+	 *            A filter declaring how to group rows, formatted as an SQL GROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped.
+	 * @param having
+	 *            A filter declare which row groups to include in the cursor, if row grouping is being used, formatted as an SQL HAVING clause (excluding the HAVING itself). Passing null will cause all row groups to be included, and is required when row grouping is not being used.
+	 * @param orderBy
+	 *            How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.
+	 * @param limit
+	 *            Limits the number of rows returned by the query, formatted as LIMIT clause. Passing null denotes no LIMIT clause.
+	 * @return A {@link Cursor} object, which is positioned before the first entry. Note that {@link Cursor}s are not synchronized, see the documentation for more details.
+	 * @see Cursor
+	 */
+	public Cursor queryWithFactory(CursorFactory cursorFactory, boolean distinct, String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.queryWithFactory((net.sqlcipher.database.SQLiteDatabase.CursorFactory) cursorFactory, distinct, table, columns, selection, selectionArgs, groupBy, having, orderBy, limit);
+		else
+			return sqliteDatabase.queryWithFactory(cursorFactory, distinct, table, columns, selection, selectionArgs, groupBy, having, orderBy, limit);
+	}
+
+	/**
+	 * Query the given table, returning a {@link Cursor} over the result set.
+	 * 
+	 * @param table
+	 *            The table name to compile the query against.
+	 * @param columns
+	 *            A list of which columns to return. Passing null will return all columns, which is discouraged to prevent reading data from storage that isn't going to be used.
+	 * @param selection
+	 *            A filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given table.
+	 * @param selectionArgs
+	 *            You may include ?s in selection, which will be replaced by the values from selectionArgs, in order that they appear in the selection. The values will be bound as Strings.
+	 * @param groupBy
+	 *            A filter declaring how to group rows, formatted as an SQL GROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped.
+	 * @param having
+	 *            A filter declare which row groups to include in the cursor, if row grouping is being used, formatted as an SQL HAVING clause (excluding the HAVING itself). Passing null will cause all row groups to be included, and is required when row grouping is not being used.
+	 * @param orderBy
+	 *            How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.
+	 * @return A {@link Cursor} object, which is positioned before the first entry. Note that {@link Cursor}s are not synchronized, see the documentation for more details.
+	 * @see Cursor
+	 */
+	public Cursor query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.query(table, columns, selection, selectionArgs, groupBy, having, orderBy);
+		else
+			return sqliteDatabase.query(table, columns, selection, selectionArgs, groupBy, having, orderBy);
+	}
+
+	/**
+	 * Query the given table, returning a {@link Cursor} over the result set.
+	 * 
+	 * @param table
+	 *            The table name to compile the query against.
+	 * @param columns
+	 *            A list of which columns to return. Passing null will return all columns, which is discouraged to prevent reading data from storage that isn't going to be used.
+	 * @param selection
+	 *            A filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given table.
+	 * @param selectionArgs
+	 *            You may include ?s in selection, which will be replaced by the values from selectionArgs, in order that they appear in the selection. The values will be bound as Strings.
+	 * @param groupBy
+	 *            A filter declaring how to group rows, formatted as an SQL GROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped.
+	 * @param having
+	 *            A filter declare which row groups to include in the cursor, if row grouping is being used, formatted as an SQL HAVING clause (excluding the HAVING itself). Passing null will cause all row groups to be included, and is required when row grouping is not being used.
+	 * @param orderBy
+	 *            How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered.
+	 * @param limit
+	 *            Limits the number of rows returned by the query, formatted as LIMIT clause. Passing null denotes no LIMIT clause.
+	 * @return A {@link Cursor} object, which is positioned before the first entry. Note that {@link Cursor}s are not synchronized, see the documentation for more details.
+	 * @see Cursor
+	 */
+	public Cursor query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.query(table, columns, selection, selectionArgs, groupBy, having, orderBy, limit);
+		else
+			return sqliteDatabase.query(table, columns, selection, selectionArgs, groupBy, having, orderBy, limit);
+	}
+
+	/**
+	 * Runs the provided SQL and returns a {@link Cursor} over the result set.
+	 * 
+	 * @param sql
+	 *            the SQL query. The SQL string must not be ; terminated
+	 * @param selectionArgs
+	 *            You may include ?s in where clause in the query, which will be replaced by the values from selectionArgs. The values will be bound as Strings.
+	 * @return A {@link Cursor} object, which is positioned before the first entry. Note that {@link Cursor}s are not synchronized, see the documentation for more details.
+	 */
+	public Cursor rawQuery(String sql, String[] selectionArgs) {
+		return isCypheredDb() ? sqlCypheredDatabase.rawQuery(sql, selectionArgs) : sqliteDatabase.rawQuery(sql, selectionArgs);
+	}
+
+	/**
+	 * Runs the provided SQL and returns a cursor over the result set.
+	 * 
+	 * @param cursorFactory
+	 *            the cursor factory to use, or null for the default factory
+	 * @param sql
+	 *            the SQL query. The SQL string must not be ; terminated
+	 * @param selectionArgs
+	 *            You may include ?s in where clause in the query, which will be replaced by the values from selectionArgs. The values will be bound as Strings.
+	 * @param editTable
+	 *            the name of the first table, which is editable
+	 * @return A {@link Cursor} object, which is positioned before the first entry. Note that {@link Cursor}s are not synchronized, see the documentation for more details.
+	 */
+	public Cursor rawQueryWithFactory(CursorFactory cursorFactory, String sql, String[] selectionArgs, String editTable) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.rawQueryWithFactory((net.sqlcipher.database.SQLiteDatabase.CursorFactory) cursorFactory, sql, selectionArgs, editTable);
+		else
+			return sqliteDatabase.rawQueryWithFactory(cursorFactory, sql, selectionArgs, editTable);
+	}
+
+	/**
+	 * Runs the provided SQL and returns a cursor over the result set. The cursor will read an initial set of rows and the return to the caller. It will continue to read in batches and send data changed notifications when the later batches are ready.
+	 * 
+	 * @param sql
+	 *            the SQL query. The SQL string must not be ; terminated
+	 * @param selectionArgs
+	 *            You may include ?s in where clause in the query, which will be replaced by the values from selectionArgs. The values will be bound as Strings.
+	 * @param initialRead
+	 *            set the initial count of items to read from the cursor
+	 * @param maxRead
+	 *            set the count of items to read on each iteration after the first
+	 * @return A {@link Cursor} object, which is positioned before the first entry. Note that {@link Cursor}s are not synchronized, see the documentation for more details.
+	 * 
+	 *         This work is incomplete and not fully tested or reviewed, so currently hidden.
+	 * @hide
+	 */
+	public Cursor rawQuery(String sql, String[] selectionArgs, int initialRead, int maxRead) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.rawQuery(sql, selectionArgs, initialRead, maxRead);
+		else
+			throw new NotSupportedOperationAndroidException();
+	}
+
+	/**
+	 * Convenience method for inserting a row into the database.
+	 * 
+	 * @param table
+	 *            the table to insert the row into
+	 * @param nullColumnHack
+	 *            SQL doesn't allow inserting a completely empty row, so if initialValues is empty this column will explicitly be assigned a NULL value
+	 * @param values
+	 *            this map contains the initial column values for the row. The keys should be the column names and the values the column values
+	 * @return the row ID of the newly inserted row, or -1 if an error occurred
+	 */
+	public long insert(String table, String nullColumnHack, ContentValues values) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.insert(table, nullColumnHack, values);
+		else
+			return sqliteDatabase.insert(table, nullColumnHack, values);
+	}
+
+	/**
+	 * Convenience method for inserting a row into the database.
+	 * 
+	 * @param table
+	 *            the table to insert the row into
+	 * @param nullColumnHack
+	 *            SQL doesn't allow inserting a completely empty row, so if initialValues is empty this column will explicitly be assigned a NULL value
+	 * @param values
+	 *            this map contains the initial column values for the row. The keys should be the column names and the values the column values
+	 * @throws SQLException
+	 * @return the row ID of the newly inserted row, or -1 if an error occurred
+	 */
+	public long insertOrThrow(String table, String nullColumnHack, ContentValues values) throws SQLException {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.insertOrThrow(table, nullColumnHack, values);
+		else
+			return sqliteDatabase.insertOrThrow(table, nullColumnHack, values);
+	}
+
+	/**
+	 * Convenience method for replacing a row in the database.
+	 * 
+	 * @param table
+	 *            the table in which to replace the row
+	 * @param nullColumnHack
+	 *            SQL doesn't allow inserting a completely empty row, so if initialValues is empty this row will explicitly be assigned a NULL value
+	 * @param initialValues
+	 *            this map contains the initial column values for the row. The key
+	 * @return the row ID of the newly inserted row, or -1 if an error occurred
+	 */
+	public long replace(String table, String nullColumnHack, ContentValues initialValues) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.replace(table, nullColumnHack, initialValues);
+		else
+			return sqliteDatabase.replace(table, nullColumnHack, initialValues);
+	}
+
+	/**
+	 * Convenience method for replacing a row in the database.
+	 * 
+	 * @param table
+	 *            the table in which to replace the row
+	 * @param nullColumnHack
+	 *            SQL doesn't allow inserting a completely empty row, so if initialValues is empty this row will explicitly be assigned a NULL value
+	 * @param initialValues
+	 *            this map contains the initial column values for the row. The key
+	 * @throws SQLException
+	 * @return the row ID of the newly inserted row, or -1 if an error occurred
+	 */
+	public long replaceOrThrow(String table, String nullColumnHack, ContentValues initialValues) throws SQLException {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.replaceOrThrow(table, nullColumnHack, initialValues);
+		else
+			return sqliteDatabase.replaceOrThrow(table, nullColumnHack, initialValues);
+	}
+
+	/**
+	 * General method for inserting a row into the database.
+	 * 
+	 * @param table
+	 *            the table to insert the row into
+	 * @param nullColumnHack
+	 *            SQL doesn't allow inserting a completely empty row, so if initialValues is empty this column will explicitly be assigned a NULL value
+	 * @param initialValues
+	 *            this map contains the initial column values for the row. The keys should be the column names and the values the column values
+	 * @param conflictAlgorithm
+	 *            for insert conflict resolver
+	 * @return the row ID of the newly inserted row OR the primary key of the existing row if the input param 'conflictAlgorithm' = {@link #CONFLICT_IGNORE} OR -1 if any error
+	 */
+	public long insertWithOnConflict(String table, String nullColumnHack, ContentValues initialValues, int conflictAlgorithm) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.insertWithOnConflict(table, nullColumnHack, initialValues, conflictAlgorithm);
+		else
+			throw new NotSupportedOperationAndroidException();
+	}
+
+	/**
+	 * Convenience method for deleting rows in the database.
+	 * 
+	 * @param table
+	 *            the table to delete from
+	 * @param whereClause
+	 *            the optional WHERE clause to apply when deleting. Passing null will delete all rows.
+	 * @return the number of rows affected if a whereClause is passed in, 0 otherwise. To remove all rows and get a count pass "1" as the whereClause.
+	 */
+	public int delete(String table, String whereClause, String[] whereArgs) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.delete(table, whereClause, whereArgs);
+		else
+			return sqliteDatabase.delete(table, whereClause, whereArgs);
+	}
+
+	/**
+	 * Convenience method for updating rows in the database.
+	 * 
+	 * @param table
+	 *            the table to update in
+	 * @param values
+	 *            a map from column names to new column values. null is a valid value that will be translated to NULL.
+	 * @param whereClause
+	 *            the optional WHERE clause to apply when updating. Passing null will update all rows.
+	 * @return the number of rows affected
+	 */
+	public int update(String table, ContentValues values, String whereClause, String[] whereArgs) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.update(table, values, whereClause, whereArgs);
+		else
+			return sqliteDatabase.update(table, values, whereClause, whereArgs);
+	}
+
+	/**
+	 * Convenience method for updating rows in the database.
+	 * 
+	 * @param table
+	 *            the table to update in
+	 * @param values
+	 *            a map from column names to new column values. null is a valid value that will be translated to NULL.
+	 * @param whereClause
+	 *            the optional WHERE clause to apply when updating. Passing null will update all rows.
+	 * @param conflictAlgorithm
+	 *            for update conflict resolver
+	 * @return the number of rows affected
+	 */
+	public int updateWithOnConflict(String table, ContentValues values, String whereClause, String[] whereArgs, int conflictAlgorithm) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.updateWithOnConflict(table, values, whereClause, whereArgs, conflictAlgorithm);
+		else
+			throw new NotSupportedOperationAndroidException();
+	}
+
+	/**
+	 * Execute a single SQL statement that is not a query. For example, CREATE TABLE, DELETE, INSERT, etc. Multiple statements separated by ;s are not supported. it takes a write lock
+	 * 
+	 * @throws SQLException
+	 *             If the SQL string is invalid for some reason
+	 */
+	public void execSQL(String sql) throws SQLException {
+		if (isCypheredDb())
+			sqlCypheredDatabase.execSQL(sql);
+		else
+			sqliteDatabase.execSQL(sql);
+	}
+
+	public void rawExecSQL(String sql) {
+		if (isCypheredDb())
+			sqlCypheredDatabase.rawExecSQL(sql);
+		else
+			throw new NotSupportedOperationAndroidException();
+	}
+
+	/**
+	 * Execute a single SQL statement that is not a query. For example, CREATE TABLE, DELETE, INSERT, etc. Multiple statements separated by ;s are not supported. it takes a write lock,
+	 * 
+	 * @param sql
+	 * @param bindArgs
+	 *            only byte[], String, Long and Double are supported in bindArgs.
+	 * @throws SQLException
+	 *             If the SQL string is invalid for some reason
+	 */
+	public void execSQL(String sql, Object[] bindArgs) throws SQLException {
+		if (isCypheredDb())
+			sqlCypheredDatabase.execSQL(sql, bindArgs);
+		else
+			sqliteDatabase.execSQL(sql, bindArgs);
+	}
+
+	/**
+	 * return whether the DB is opened as read only.
+	 * 
+	 * @return true if DB is opened as read only
+	 */
+	public boolean isReadOnly() {
+		return isCypheredDb() ? sqlCypheredDatabase.isReadOnly() : sqliteDatabase.isReadOnly();
+	}
+
+	/**
+	 * @return true if the DB is currently open (has not been closed)
+	 */
+	public boolean isOpen() {
+		return isCypheredDb() ? sqlCypheredDatabase.isOpen() : sqliteDatabase.isOpen();
+
+	}
+
+	public boolean needUpgrade(int newVersion) {
+		return isCypheredDb() ? sqlCypheredDatabase.needUpgrade(newVersion) : sqliteDatabase.needUpgrade(newVersion);
+
+	}
+
+	/**
+	 * Getter for the path to the database file.
+	 * 
+	 * @return the path to our database file.
+	 */
+	public final String getPath() {
+		return isCypheredDb() ? sqlCypheredDatabase.getPath() : sqliteDatabase.getPath();
+
+	}
+
+	/**
+	 * Sets the locale for this database. Does nothing if this database has the NO_LOCALIZED_COLLATORS flag set or was opened read only.
+	 * 
+	 * @throws SQLException
+	 *             if the locale could not be set. The most common reason for this is that there is no collator available for the locale you requested. In this case the database remains unchanged.
+	 */
+	public void setLocale(Locale locale) {
+		if (isCypheredDb())
+			sqlCypheredDatabase.setLocale(locale);
+		else
+			sqliteDatabase.setLocale(locale);
+	}
+
+	/**
+	 * returns true if the given sql is cached in compiled-sql cache.
+	 * 
+	 * @hide
+	 */
+	public boolean isInCompiledSqlCache(String sql) {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.isInCompiledSqlCache(sql);
+		else
+			throw new NotSupportedOperationAndroidException();
+
+	}
+
+	/**
+	 * purges the given sql from the compiled-sql cache.
+	 * 
+	 * @hide
+	 */
+	public void purgeFromCompiledSqlCache(String sql) {
+		if (isCypheredDb())
+			sqlCypheredDatabase.purgeFromCompiledSqlCache(sql);
+		else
+			throw new NotSupportedOperationAndroidException();
+	}
+
+	/**
+	 * remove everything from the compiled sql cache
+	 * 
+	 * @hide
+	 */
+	public void resetCompiledSqlCache() {
+		if (isCypheredDb())
+			sqlCypheredDatabase.resetCompiledSqlCache();
+		else
+			throw new NotSupportedOperationAndroidException();
+	}
+
+	/**
+	 * return the current maxCacheSqlCacheSize
+	 * 
+	 * @hide
+	 */
+	public synchronized int getMaxSqlCacheSize() {
+		if (isCypheredDb())
+			return sqlCypheredDatabase.getMaxSqlCacheSize();
+		else
+			throw new NotSupportedOperationAndroidException();
+
+	}
+
+	/**
+	 * set the max size of the compiled sql cache for this database after purging the cache. (size of the cache = number of compiled-sql-statements stored in the cache).
+	 * 
+	 * max cache size can ONLY be increased from its current size (default = 0). if this method is called with smaller size than the current value of mMaxSqlCacheSize, then IllegalStateException is thrown
+	 * 
+	 * synchronized because we don't want t threads to change cache size at the same time.
+	 * 
+	 * @param cacheSize
+	 *            the size of the cache. can be (0 to MAX_SQL_CACHE_SIZE)
+	 * @throws IllegalStateException
+	 *             if input cacheSize > MAX_SQL_CACHE_SIZE or < 0 or < the value set with previous setMaxSqlCacheSize() call.
+	 * 
+	 * @hide
+	 */
+	public synchronized void setMaxSqlCacheSize(int cacheSize) {
+		if (isCypheredDb())
+			sqlCypheredDatabase.setMaxSqlCacheSize(cacheSize);
+		else
+			throw new NotSupportedOperationAndroidException();
+	}
+
+	/**
+	 * Locks the database for exclusive access. The database lock must be held when touch the native sqlite3* object since it is single threaded and uses a polling lock contention algorithm. The lock is recursive, and may be acquired multiple times by the same thread. This is a no-op if mLockingEnabled is false.
+	 * 
+	 * @see #unlock()
+	 */
+	/* package */void lock() {
+		if (!mLockingEnabled)
+			return;
+		mLock.lock();
+		if (SQLiteDebug.DEBUG_LOCK_TIME_TRACKING) {
+			if (mLock.getHoldCount() == 1) {
+				// Use elapsed real-time since the CPU may sleep when waiting for IO
+				mLockAcquiredWallTime = SystemClock.elapsedRealtime();
+				mLockAcquiredThreadTime = Debug.threadCpuTimeNanos();
+			}
+		}
+	}
+
+	/**
+	 * Releases the database lock. This is a no-op if mLockingEnabled is false.
+	 * 
+	 * @see #unlock()
+	 */
+	/* package */void unlock() {
+		if (!mLockingEnabled)
+			return;
+		if (SQLiteDebug.DEBUG_LOCK_TIME_TRACKING) {
+			if (mLock.getHoldCount() == 1) {
+				checkLockHoldTime();
+			}
+		}
+		mLock.unlock();
+	}
+
+	private void checkLockHoldTime() {
+		// Use elapsed real-time since the CPU may sleep when waiting for IO
+		long elapsedTime = SystemClock.elapsedRealtime();
+		long lockedTime = elapsedTime - mLockAcquiredWallTime;
+		if (lockedTime < LOCK_ACQUIRED_WARNING_TIME_IN_MS_ALWAYS_PRINT && !Log.isLoggable(TAG, Log.VERBOSE) && (elapsedTime - mLastLockMessageTime) < LOCK_WARNING_WINDOW_IN_MS) {
+			return;
+		}
+		if (lockedTime > LOCK_ACQUIRED_WARNING_TIME_IN_MS) {
+			int threadTime = (int) ((Debug.threadCpuTimeNanos() - mLockAcquiredThreadTime) / 1000000);
+			if (threadTime > LOCK_ACQUIRED_WARNING_THREAD_TIME_IN_MS || lockedTime > LOCK_ACQUIRED_WARNING_TIME_IN_MS_ALWAYS_PRINT) {
+				mLastLockMessageTime = elapsedTime;
+				String msg = "lock held on " + getPath() + " for " + lockedTime + "ms. Thread time was " + threadTime + "ms";
+				if (SQLiteDebug.DEBUG_LOCK_TIME_TRACKING_STACK_TRACE) {
+					Log.d(TAG, msg, new Exception());
+				} else {
+					Log.d(TAG, msg);
+				}
+			}
+		}
+	}
+
+	static class ActiveDatabases {
+		private static final ActiveDatabases activeDatabases = new ActiveDatabases();
+		private HashSet<WeakReference<SQLiteDatabaseWrapper>> mActiveDatabases = new HashSet<WeakReference<SQLiteDatabaseWrapper>>();
+
+		private ActiveDatabases() {
+		} // disable instantiation of this class
+
+		static ActiveDatabases getInstance() {
+			return activeDatabases;
+		}
+	}
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteOpenHelperWrapper.java b/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteOpenHelperWrapper.java
new file mode 100644
index 00000000..d5fa0e3f
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteOpenHelperWrapper.java
@@ -0,0 +1,241 @@
+package de.greenrobot.dao.wrapper;
+
+import java.io.File;
+
+import net.sqlcipher.database.SQLiteException;
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteDatabase.CursorFactory;
+import android.util.Log;
+
+public abstract class SQLiteOpenHelperWrapper {
+
+	private static final String TAG = SQLiteOpenHelperWrapper.class.getSimpleName();
+
+	private final Context mContext;
+	private final String mName;
+	private final String mPassword;
+	private final CursorFactory mFactory;
+	private final int mNewVersion;
+
+	private SQLiteDatabaseWrapper mDatabase = null;
+	private boolean mIsInitializing = false;
+
+	/**
+	 * 
+	 * @param context
+	 * @param name
+	 *            name of the database
+	 * @param password
+	 *            if not null nor empty the database will be encrypted
+	 * @param factory
+	 * @param version
+	 */
+	public SQLiteOpenHelperWrapper(Context context, String name, String password, CursorFactory factory, int version) {
+		if (version < 1)
+			throw new IllegalArgumentException("Version must be >= 1, was " + version);
+
+		mContext = context;
+		mName = name;
+		mPassword = password;
+		mFactory = factory;
+		mNewVersion = version;
+
+		if (mPassword != null && mPassword.length() > 0) {
+			// Load SQLcipher libraries if needed
+			SQLiteDatabaseWrapper.loadLibs(mContext);
+		}
+	}
+
+	public boolean isCypheredDb() {
+		return mDatabase.isCypheredDb();
+	}
+
+	/**
+	 * Create and/or open a database that will be used for reading and writing. Once opened successfully, the database is cached, so you can call this method every time you need to write to the database. Make sure to call {@link #close} when you no longer need it.
+	 * 
+	 * <p>
+	 * Errors such as bad permissions or a full disk may cause this operation to fail, but future attempts may succeed if the problem is fixed.
+	 * </p>
+	 * 
+	 * @throws SQLiteException
+	 *             if the database cannot be opened for writing
+	 * @return a read/write database object valid until {@link #close} is called
+	 */
+	public synchronized SQLiteDatabaseWrapper getWritableDatabase() {
+		if (mDatabase != null && mDatabase.isOpen() && !mDatabase.isReadOnly()) {
+			return mDatabase; // The database is already open for business
+		}
+
+		if (mIsInitializing) {
+			throw new IllegalStateException("getWritableDatabase called recursively");
+		}
+
+		// If we have a read-only database open, someone could be using it
+		// (though they shouldn't), which would cause a lock to be held on
+		// the file, and our attempts to open the database read-write would
+		// fail waiting for the file lock. To prevent that, we acquire the
+		// lock on the read-only database, which shuts out other users.
+
+		boolean success = false;
+		SQLiteDatabaseWrapper db = null;
+		if (mDatabase != null)
+			mDatabase.lock();
+		try {
+			mIsInitializing = true;
+			if (mName == null) {
+				db = SQLiteDatabaseWrapper.create(null, mPassword);
+			} else {
+				String path = mContext.getDatabasePath(mName).getPath();
+
+				File dbPathFile = new File(path);
+				if (!dbPathFile.exists())
+					dbPathFile.getParentFile().mkdirs();
+
+				db = SQLiteDatabaseWrapper.openOrCreateDatabase(path, mPassword, mFactory);
+			}
+
+			int version = db.getVersion();
+			if (version != mNewVersion) {
+				db.beginTransaction();
+				try {
+					if (version == 0) {
+						onCreate(db);
+					} else {
+						if (version > mNewVersion) {
+							Log.w(TAG, "Can't downgrade read-only database from version " + version + " to " + mNewVersion + ": " + db.getPath());
+						}
+						onUpgrade(db, version, mNewVersion);
+					}
+					db.setVersion(mNewVersion);
+					db.setTransactionSuccessful();
+				} finally {
+					db.endTransaction();
+				}
+			}
+
+			onOpen(db);
+			success = true;
+			return db;
+		} finally {
+			mIsInitializing = false;
+			if (success) {
+				if (mDatabase != null) {
+					try {
+						mDatabase.close();
+					} catch (Exception e) {
+					}
+					mDatabase.unlock();
+				}
+				mDatabase = db;
+			} else {
+				if (mDatabase != null)
+					mDatabase.unlock();
+				if (db != null)
+					db.close();
+			}
+		}
+	}
+
+	/**
+	 * Create and/or open a database. This will be the same object returned by {@link #getWritableDatabase} unless some problem, such as a full disk, requires the database to be opened read-only. In that case, a read-only database object will be returned. If the problem is fixed, a future call to {@link #getWritableDatabase} may succeed, in which case the read-only database object will be closed and the read/write object will be returned in the future.
+	 * 
+	 * @throws SQLiteException
+	 *             if the database cannot be opened
+	 * @return a database object valid until {@link #getWritableDatabase} or {@link #close} is called.
+	 */
+	public synchronized SQLiteDatabaseWrapper getReadableDatabase() {
+		if (mDatabase != null && mDatabase.isOpen()) {
+			return mDatabase; // The database is already open for business
+		}
+
+		if (mIsInitializing) {
+			throw new IllegalStateException("getReadableDatabase called recursively");
+		}
+
+		try {
+			return getWritableDatabase();
+		} catch (SQLiteException e) {
+			if (mName == null)
+				throw e; // Can't open a temp database read-only!
+			Log.e(TAG, "Couldn't open " + mName + " for writing (will try read-only):", e);
+		}
+
+		SQLiteDatabaseWrapper db = null;
+		try {
+			mIsInitializing = true;
+			String path = mContext.getDatabasePath(mName).getPath();
+			File databasePath = new File(path);
+			File databasesDirectory = new File(mContext.getDatabasePath(mName).getParent());
+
+			if (!databasesDirectory.exists()) {
+				databasesDirectory.mkdirs();
+			}
+			if (!databasePath.exists()) {
+				mIsInitializing = false;
+				db = getWritableDatabase();
+				mIsInitializing = true;
+				db.close();
+			}
+			db = SQLiteDatabaseWrapper.openDatabase(path, mPassword, mFactory, SQLiteDatabase.OPEN_READONLY);
+			if (db.getVersion() != mNewVersion) {
+				throw new SQLiteException("Can't upgrade read-only database from version " + db.getVersion() + " to " + mNewVersion + ": " + path);
+			}
+
+			onOpen(db);
+			Log.w(TAG, "Opened " + mName + " in read-only mode");
+			mDatabase = db;
+			return mDatabase;
+		} finally {
+			mIsInitializing = false;
+			if (db != null && db != mDatabase)
+				db.close();
+		}
+	}
+
+	/**
+	 * Close any open database object.
+	 */
+	public synchronized void close() {
+		if (mIsInitializing)
+			throw new IllegalStateException("Closed during initialization");
+
+		if (mDatabase != null && mDatabase.isOpen()) {
+			mDatabase.close();
+			mDatabase = null;
+		}
+	}
+
+	/**
+	 * Called when the database is created for the first time. This is where the creation of tables and the initial population of the tables should happen.
+	 * 
+	 * @param db
+	 *            The database.
+	 */
+	public abstract void onCreate(SQLiteDatabaseWrapper db);
+
+	/**
+	 * Called when the database needs to be upgraded. The implementation should use this method to drop tables, add tables, or do anything else it needs to upgrade to the new schema version.
+	 * 
+	 * <p>
+	 * The SQLite ALTER TABLE documentation can be found <a href="http://sqlite.org/lang_altertable.html">here</a>. If you add new columns you can use ALTER TABLE to insert them into a live table. If you rename or remove columns you can use ALTER TABLE to rename the old table, then create the new table and then populate the new table with the contents of the old table.
+	 * 
+	 * @param db
+	 *            The database.
+	 * @param oldVersion
+	 *            The old database version.
+	 * @param newVersion
+	 *            The new database version.
+	 */
+	public abstract void onUpgrade(SQLiteDatabaseWrapper db, int oldVersion, int newVersion);
+
+	/**
+	 * Called when the database has been opened. Override method should check {@link SQLiteDatabase#isReadOnly} before updating the database.
+	 * 
+	 * @param db
+	 *            The database.
+	 */
+	public void onOpen(SQLiteDatabaseWrapper db) {
+	}
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteProgramWrapper.java b/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteProgramWrapper.java
new file mode 100644
index 00000000..5168c197
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteProgramWrapper.java
@@ -0,0 +1,117 @@
+package de.greenrobot.dao.wrapper;
+
+import android.database.sqlite.SQLiteProgram;
+
+public class SQLiteProgramWrapper {
+
+	private final SQLiteProgram sqliteProgram;
+	private final net.sqlcipher.database.SQLiteProgram sqlCypheredProgram;
+
+	public SQLiteProgramWrapper(SQLiteProgram sqliteProgram) {
+		this.sqliteProgram = sqliteProgram;
+		this.sqlCypheredProgram = null;
+	}
+
+	public SQLiteProgramWrapper(net.sqlcipher.database.SQLiteProgram sqlCypheredProgram) {
+		this.sqliteProgram = null;
+		this.sqlCypheredProgram = sqlCypheredProgram;
+	}
+
+	public boolean isCypheredDb() {
+		return sqlCypheredProgram != null;
+	}
+
+	/**
+	 * Bind a NULL value to this statement. The value remains bound until {@link #clearBindings} is called.
+	 * 
+	 * @param index
+	 *            The 1-based index to the parameter to bind null to
+	 */
+	public void bindNull(int index) {
+		if (isCypheredDb())
+			sqlCypheredProgram.bindNull(index);
+		else
+			sqliteProgram.bindNull(index);
+	}
+
+	/**
+	 * Bind a long value to this statement. The value remains bound until {@link #clearBindings} is called.
+	 * 
+	 * @param index
+	 *            The 1-based index to the parameter to bind
+	 * @param value
+	 *            The value to bind
+	 */
+	public void bindLong(int index, long value) {
+		if (isCypheredDb())
+			sqlCypheredProgram.bindLong(index, value);
+		else
+			sqliteProgram.bindLong(index, value);
+	}
+
+	/**
+	 * Bind a double value to this statement. The value remains bound until {@link #clearBindings} is called.
+	 * 
+	 * @param index
+	 *            The 1-based index to the parameter to bind
+	 * @param value
+	 *            The value to bind
+	 */
+	public void bindDouble(int index, double value) {
+		if (isCypheredDb())
+			sqlCypheredProgram.bindDouble(index, value);
+		else
+			sqliteProgram.bindDouble(index, value);
+	}
+
+	/**
+	 * Bind a String value to this statement. The value remains bound until {@link #clearBindings} is called.
+	 * 
+	 * @param index
+	 *            The 1-based index to the parameter to bind
+	 * @param value
+	 *            The value to bind
+	 */
+	public void bindString(int index, String value) {
+		if (isCypheredDb())
+			sqlCypheredProgram.bindString(index, value);
+		else
+			sqliteProgram.bindString(index, value);
+	}
+
+	/**
+	 * Bind a byte array value to this statement. The value remains bound until {@link #clearBindings} is called.
+	 * 
+	 * @param index
+	 *            The 1-based index to the parameter to bind
+	 * @param value
+	 *            The value to bind
+	 */
+	public void bindBlob(int index, byte[] value) {
+		if (isCypheredDb())
+			sqlCypheredProgram.bindBlob(index, value);
+		else
+			sqliteProgram.bindBlob(index, value);
+	}
+
+	/**
+	 * Clears all existing bindings. Unset bindings are treated as NULL.
+	 */
+	public void clearBindings() {
+		if (isCypheredDb())
+			sqlCypheredProgram.clearBindings();
+		else
+			sqliteProgram.clearBindings();
+	}
+
+	/**
+	 * Release this program's resources, making it invalid.
+	 */
+	public void close() {
+		if (isCypheredDb())
+			sqlCypheredProgram.close();
+		else
+			sqliteProgram.close();
+	}
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteStatementWrapper.java b/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteStatementWrapper.java
new file mode 100644
index 00000000..7cc5fe9d
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/wrapper/SQLiteStatementWrapper.java
@@ -0,0 +1,75 @@
+package de.greenrobot.dao.wrapper;
+
+import android.database.sqlite.SQLiteStatement;
+
+public class SQLiteStatementWrapper extends SQLiteProgramWrapper {
+
+	private final SQLiteStatement sqliteStatement;
+	private final net.sqlcipher.database.SQLiteStatement sqlCypheredStatement;
+
+	public SQLiteStatementWrapper(SQLiteStatement sqliteStatement) {
+		super(sqliteStatement);
+		this.sqliteStatement = sqliteStatement;
+		this.sqlCypheredStatement = null;
+	}
+
+	public SQLiteStatementWrapper(net.sqlcipher.database.SQLiteStatement sqlCypheredStatement) {
+		super(sqlCypheredStatement);
+		this.sqliteStatement = null;
+		this.sqlCypheredStatement = sqlCypheredStatement;
+	}
+
+	public boolean isCypheredDb() {
+		return sqlCypheredStatement != null;
+	}
+
+	/**
+	 * Execute this SQL statement, if it is not a query. For example, CREATE TABLE, DELTE, INSERT, etc.
+	 * 
+	 * @throws android.database.SQLException
+	 *             If the SQL string is invalid for some reason
+	 */
+	public void execute() {
+		if (isCypheredDb())
+			sqlCypheredStatement.execute();
+		else
+			sqliteStatement.execute();
+	}
+
+	/**
+	 * Execute this SQL statement and return the ID of the row inserted due to this call. The SQL statement should be an INSERT for this to be a useful call.
+	 * 
+	 * @return the row ID of the last row inserted, if this insert is successful. -1 otherwise.
+	 * 
+	 * @throws android.database.SQLException
+	 *             If the SQL string is invalid for some reason
+	 */
+	public long executeInsert() {
+		return isCypheredDb() ? sqlCypheredStatement.executeInsert() : sqliteStatement.executeInsert();
+	}
+
+	/**
+	 * Execute a statement that returns a 1 by 1 table with a numeric value. For example, SELECT COUNT(*) FROM table;
+	 * 
+	 * @return The result of the query.
+	 * 
+	 * @throws android.database.sqlite.SQLiteDoneException
+	 *             if the query returns zero rows
+	 */
+	public long simpleQueryForLong() {
+		return isCypheredDb() ? sqlCypheredStatement.simpleQueryForLong() : sqliteStatement.simpleQueryForLong();
+	}
+
+	/**
+	 * Execute a statement that returns a 1 by 1 table with a text value. For example, SELECT COUNT(*) FROM table;
+	 * 
+	 * @return The result of the query.
+	 * 
+	 * @throws android.database.sqlite.SQLiteDoneException
+	 *             if the query returns zero rows
+	 */
+	public String simpleQueryForString() {
+		return isCypheredDb() ? sqlCypheredStatement.simpleQueryForString() : sqliteStatement.simpleQueryForString();
+	}
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/wrapper/exception/NotSupportedOperationAndroidException.java b/DaoCore/src/de/greenrobot/dao/wrapper/exception/NotSupportedOperationAndroidException.java
new file mode 100644
index 00000000..b6b9964f
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/wrapper/exception/NotSupportedOperationAndroidException.java
@@ -0,0 +1,23 @@
+package de.greenrobot.dao.wrapper.exception;
+
+public class NotSupportedOperationAndroidException extends RuntimeException {
+
+	private static final long serialVersionUID = -8708290373742559496L;
+
+	public NotSupportedOperationAndroidException() {
+		super("Android doesn't provide any implementation of this method");
+	}
+
+	public NotSupportedOperationAndroidException(String detailMessage, Throwable throwable) {
+		super("Android doesn't provide any implementation of this method : " + detailMessage, throwable);
+	}
+
+	public NotSupportedOperationAndroidException(String detailMessage) {
+		super("Android doesn't provide any implementation of this method : " + detailMessage);
+	}
+
+	public NotSupportedOperationAndroidException(Throwable throwable) {
+		super(throwable);
+	}
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/wrapper/exception/NotSupportedOperationSQLCypherException.java b/DaoCore/src/de/greenrobot/dao/wrapper/exception/NotSupportedOperationSQLCypherException.java
new file mode 100644
index 00000000..7800f736
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/wrapper/exception/NotSupportedOperationSQLCypherException.java
@@ -0,0 +1,23 @@
+package de.greenrobot.dao.wrapper.exception;
+
+public class NotSupportedOperationSQLCypherException extends RuntimeException {
+
+	private static final long serialVersionUID = -8708290373742559496L;
+
+	public NotSupportedOperationSQLCypherException() {
+		super("SQLCypher doesn't provide any implementation of this method");
+	}
+
+	public NotSupportedOperationSQLCypherException(String detailMessage, Throwable throwable) {
+		super("SQLCypher doesn't provide any implementation of this method : " + detailMessage, throwable);
+	}
+
+	public NotSupportedOperationSQLCypherException(String detailMessage) {
+		super("SQLCypher doesn't provide any implementation of this method : " + detailMessage);
+	}
+
+	public NotSupportedOperationSQLCypherException(Throwable throwable) {
+		super(throwable);
+	}
+
+}
diff --git a/DaoGenerator/src-template/dao-master.ftl b/DaoGenerator/src-template/dao-master.ftl
index 7ead78a7..f50484fe 100644
--- a/DaoGenerator/src-template/dao-master.ftl
+++ b/DaoGenerator/src-template/dao-master.ftl
@@ -20,12 +20,12 @@ along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
 package ${schema.defaultJavaPackageDao};
 
 import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteDatabase.CursorFactory;
-import android.database.sqlite.SQLiteOpenHelper;
 import android.util.Log;
 import de.greenrobot.dao.AbstractDaoMaster;
 import de.greenrobot.dao.IdentityScopeType;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteOpenHelperWrapper;
 
 <#list schema.entities as entity>
 import ${entity.javaPackageDao}.${entity.classNameDao};
@@ -39,7 +39,7 @@ public class DaoMaster extends AbstractDaoMaster {
     public static final int SCHEMA_VERSION = ${schema.version};
 
     /** Creates underlying database table using DAOs. */
-    public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createAllTables(SQLiteDatabaseWrapper db, boolean ifNotExists) {
 <#list schema.entities as entity>
 <#if !entity.skipTableCreation>
         ${entity.classNameDao}.createTable(db, ifNotExists);
@@ -48,7 +48,7 @@ public class DaoMaster extends AbstractDaoMaster {
     }
     
     /** Drops underlying database table using DAOs. */
-    public static void dropAllTables(SQLiteDatabase db, boolean ifExists) {
+    public static void dropAllTables(SQLiteDatabaseWrapper db, boolean ifExists) {
 <#list schema.entities as entity>
 <#if !entity.skipTableCreation>
         ${entity.classNameDao}.dropTable(db, ifExists);
@@ -56,14 +56,14 @@ public class DaoMaster extends AbstractDaoMaster {
 </#list>
     }
     
-    public static abstract class OpenHelper extends SQLiteOpenHelper {
+    public static abstract class OpenHelper extends SQLiteOpenHelperWrapper {
 
-        public OpenHelper(Context context, String name, CursorFactory factory) {
-            super(context, name, factory, SCHEMA_VERSION);
+        public OpenHelper(Context context, String name, String password, CursorFactory factory) {
+            super(context, name, password, factory, SCHEMA_VERSION);
         }
 
         @Override
-        public void onCreate(SQLiteDatabase db) {
+        public void onCreate(SQLiteDatabaseWrapper db) {
             Log.i("greenDAO", "Creating tables for schema version " + SCHEMA_VERSION);
             createAllTables(db, false);
         }
@@ -71,19 +71,19 @@ public class DaoMaster extends AbstractDaoMaster {
     
     /** WARNING: Drops all table on Upgrade! Use only during development. */
     public static class DevOpenHelper extends OpenHelper {
-        public DevOpenHelper(Context context, String name, CursorFactory factory) {
-            super(context, name, factory);
+        public DevOpenHelper(Context context, String name, String password, CursorFactory factory) {
+            super(context, name, password, factory);
         }
 
         @Override
-        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        public void onUpgrade(SQLiteDatabaseWrapper db, int oldVersion, int newVersion) {
             Log.i("greenDAO", "Upgrading schema from version " + oldVersion + " to " + newVersion + " by dropping all tables");
             dropAllTables(db, true);
             onCreate(db);
         }
     }
 
-    public DaoMaster(SQLiteDatabase db) {
+    public DaoMaster(SQLiteDatabaseWrapper db) {
         super(db, SCHEMA_VERSION);
 <#list schema.entities as entity>
         registerDaoClass(${entity.classNameDao}.class);
diff --git a/DaoGenerator/src-template/dao-session.ftl b/DaoGenerator/src-template/dao-session.ftl
index 1fe41e76..37c4dcdc 100644
--- a/DaoGenerator/src-template/dao-session.ftl
+++ b/DaoGenerator/src-template/dao-session.ftl
@@ -19,14 +19,13 @@ along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
 -->
 package ${schema.defaultJavaPackageDao};
 
-import android.database.sqlite.SQLiteDatabase;
-
 import java.util.Map;
 
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.AbstractDaoSession;
 import de.greenrobot.dao.IdentityScopeType;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
 
 <#list schema.entities as entity>
 import ${entity.javaPackage}.${entity.className};
@@ -53,7 +52,7 @@ public class DaoSession extends AbstractDaoSession {
     private final ${entity.classNameDao} ${entity.classNameDao?uncap_first};
 </#list>        
 
-    public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>
+    public DaoSession(SQLiteDatabaseWrapper db, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>
             daoConfigMap) {
         super(db);
 
diff --git a/DaoGenerator/src-template/dao.ftl b/DaoGenerator/src-template/dao.ftl
index b9275906..b4d40a1e 100644
--- a/DaoGenerator/src-template/dao.ftl
+++ b/DaoGenerator/src-template/dao.ftl
@@ -28,8 +28,6 @@ import java.util.List;
 import java.util.ArrayList;
 </#if>
 import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
 
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoConfig;
@@ -41,6 +39,8 @@ import de.greenrobot.dao.SqlUtils;
 import de.greenrobot.dao.Query;
 import de.greenrobot.dao.QueryBuilder;
 </#if>
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 
 <#if entity.javaPackageDao != schema.defaultJavaPackageDao>
 import ${schema.defaultJavaPackageDao}.DaoSession;
@@ -96,7 +96,7 @@ public class ${entity.classNameDao} extends AbstractDao<${entity.className}, ${e
 
 <#if !entity.skipTableCreation>
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(SQLiteDatabaseWrapper db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         db.execSQL("CREATE TABLE " + constraint + "'${entity.tableName}' (" + //
 <#list entity.propertiesColumns as property>
@@ -113,7 +113,7 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+    public static void dropTable(SQLiteDatabaseWrapper db, boolean ifExists) {
         String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'${entity.tableName}'";
         db.execSQL(sql);
     }
@@ -121,7 +121,7 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
 </#if>
     /** @inheritdoc */
     @Override
-    protected void bindValues(SQLiteStatement stmt, ${entity.className} entity) {
+    protected void bindValues(SQLiteStatementWrapper stmt, ${entity.className} entity) {
         stmt.clearBindings();
 <#list entity.properties as property>
 <#if property.notNull || entity.protobuf>
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntityDao.java
index c7c94933..147f49df 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/AbcdefEntityDao.java
@@ -1,14 +1,11 @@
 package de.greenrobot.daotest;
 
 import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
-
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.Property;
-
-import de.greenrobot.daotest.AbcdefEntity;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -47,7 +44,7 @@ public AbcdefEntityDao(DaoConfig config, DaoSession daoSession) {
     }
 
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(SQLiteDatabaseWrapper db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         db.execSQL("CREATE TABLE " + constraint + "'ABCDEF_ENTITY' (" + //
                 "'_id' INTEGER PRIMARY KEY ," + // 0: id
@@ -65,14 +62,14 @@ public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+    public static void dropTable(SQLiteDatabaseWrapper db, boolean ifExists) {
         String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'ABCDEF_ENTITY'";
         db.execSQL(sql);
     }
 
     /** @inheritdoc */
     @Override
-    protected void bindValues(SQLiteStatement stmt, AbcdefEntity entity) {
+    protected void bindValues(SQLiteStatementWrapper stmt, AbcdefEntity entity) {
         stmt.clearBindings();
  
         Long id = entity.getId();
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntityDao.java
index e04f94cf..7de702ef 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/AnActiveEntityDao.java
@@ -1,14 +1,11 @@
 package de.greenrobot.daotest;
 
 import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
-
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.Property;
-
-import de.greenrobot.daotest.AnActiveEntity;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -40,7 +37,7 @@ public AnActiveEntityDao(DaoConfig config, DaoSession daoSession) {
     }
 
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(SQLiteDatabaseWrapper db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         db.execSQL("CREATE TABLE " + constraint + "'AN_ACTIVE_ENTITY' (" + //
                 "'_id' INTEGER PRIMARY KEY ," + // 0: id
@@ -48,14 +45,14 @@ public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+    public static void dropTable(SQLiteDatabaseWrapper db, boolean ifExists) {
         String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'AN_ACTIVE_ENTITY'";
         db.execSQL(sql);
     }
 
     /** @inheritdoc */
     @Override
-    protected void bindValues(SQLiteStatement stmt, AnActiveEntity entity) {
+    protected void bindValues(SQLiteStatementWrapper stmt, AnActiveEntity entity) {
         stmt.clearBindings();
  
         Long id = entity.getId();
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntityDao.java
index b1a32a2d..6ef42395 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/AutoincrementEntityDao.java
@@ -1,14 +1,11 @@
 package de.greenrobot.daotest;
 
 import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
-
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.Property;
-
-import de.greenrobot.daotest.AutoincrementEntity;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -36,21 +33,21 @@ public AutoincrementEntityDao(DaoConfig config, DaoSession daoSession) {
     }
 
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(SQLiteDatabaseWrapper db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         db.execSQL("CREATE TABLE " + constraint + "'AUTOINCREMENT_ENTITY' (" + //
                 "'_id' INTEGER PRIMARY KEY AUTOINCREMENT );"); // 0: id
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+    public static void dropTable(SQLiteDatabaseWrapper db, boolean ifExists) {
         String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'AUTOINCREMENT_ENTITY'";
         db.execSQL(sql);
     }
 
     /** @inheritdoc */
     @Override
-    protected void bindValues(SQLiteStatement stmt, AutoincrementEntity entity) {
+    protected void bindValues(SQLiteStatementWrapper stmt, AutoincrementEntity entity) {
         stmt.clearBindings();
  
         Long id = entity.getId();
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java b/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java
index 9b15ea02..2960030f 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/DaoMaster.java
@@ -1,28 +1,12 @@
 package de.greenrobot.daotest;
 
 import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteDatabase.CursorFactory;
-import android.database.sqlite.SQLiteOpenHelper;
 import android.util.Log;
 import de.greenrobot.dao.AbstractDaoMaster;
 import de.greenrobot.dao.IdentityScopeType;
-
-import de.greenrobot.daotest.SimpleEntityDao;
-import de.greenrobot.daotest.SimpleEntityNotNullDao;
-import de.greenrobot.daotest.TestEntityDao;
-import de.greenrobot.daotest.RelationEntityDao;
-import de.greenrobot.daotest.DateEntityDao;
-import de.greenrobot.daotest.SpecialNamesEntityDao;
-import de.greenrobot.daotest.AbcdefEntityDao;
-import de.greenrobot.daotest.ToManyTargetEntityDao;
-import de.greenrobot.daotest.ToManyEntityDao;
-import de.greenrobot.daotest.TreeEntityDao;
-import de.greenrobot.daotest.AnActiveEntityDao;
-import de.greenrobot.daotest.ExtendsImplementsEntityDao;
-import de.greenrobot.daotest.StringKeyValueEntityDao;
-import de.greenrobot.daotest.AutoincrementEntityDao;
-import de.greenrobot.daotest.SqliteMasterDao;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteOpenHelperWrapper;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -32,7 +16,7 @@
     public static final int SCHEMA_VERSION = 1;
 
     /** Creates underlying database table using DAOs. */
-    public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createAllTables(SQLiteDatabaseWrapper db, boolean ifNotExists) {
         SimpleEntityDao.createTable(db, ifNotExists);
         SimpleEntityNotNullDao.createTable(db, ifNotExists);
         TestEntityDao.createTable(db, ifNotExists);
@@ -50,7 +34,7 @@ public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
     }
     
     /** Drops underlying database table using DAOs. */
-    public static void dropAllTables(SQLiteDatabase db, boolean ifExists) {
+    public static void dropAllTables(SQLiteDatabaseWrapper db, boolean ifExists) {
         SimpleEntityDao.dropTable(db, ifExists);
         SimpleEntityNotNullDao.dropTable(db, ifExists);
         TestEntityDao.dropTable(db, ifExists);
@@ -67,14 +51,14 @@ public static void dropAllTables(SQLiteDatabase db, boolean ifExists) {
         AutoincrementEntityDao.dropTable(db, ifExists);
     }
     
-    public static abstract class OpenHelper extends SQLiteOpenHelper {
+    public static abstract class OpenHelper extends SQLiteOpenHelperWrapper {
 
         public OpenHelper(Context context, String name, CursorFactory factory) {
-            super(context, name, factory, SCHEMA_VERSION);
+            super(context, name, null, factory, SCHEMA_VERSION);
         }
 
         @Override
-        public void onCreate(SQLiteDatabase db) {
+        public void onCreate(SQLiteDatabaseWrapper db) {
             Log.i("greenDAO", "Creating tables for schema version " + SCHEMA_VERSION);
             createAllTables(db, false);
         }
@@ -87,14 +71,14 @@ public DevOpenHelper(Context context, String name, CursorFactory factory) {
         }
 
         @Override
-        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        public void onUpgrade(SQLiteDatabaseWrapper db, int oldVersion, int newVersion) {
             Log.i("greenDAO", "Upgrading schema from version " + oldVersion + " to " + newVersion + " by dropping all tables");
             dropAllTables(db, true);
             onCreate(db);
         }
     }
 
-    public DaoMaster(SQLiteDatabase db) {
+    public DaoMaster(SQLiteDatabaseWrapper db) {
         super(db, SCHEMA_VERSION);
         registerDaoClass(SimpleEntityDao.class);
         registerDaoClass(SimpleEntityNotNullDao.class);
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java b/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java
index 9626fff1..444f4be4 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/DaoSession.java
@@ -1,45 +1,12 @@
 package de.greenrobot.daotest;
 
-import android.database.sqlite.SQLiteDatabase;
-
 import java.util.Map;
 
 import de.greenrobot.dao.AbstractDao;
-import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.AbstractDaoSession;
+import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.IdentityScopeType;
-
-import de.greenrobot.daotest.SimpleEntity;
-import de.greenrobot.daotest.SimpleEntityNotNull;
-import de.greenrobot.daotest.TestEntity;
-import de.greenrobot.daotest.RelationEntity;
-import de.greenrobot.daotest.DateEntity;
-import de.greenrobot.daotest.SpecialNamesEntity;
-import de.greenrobot.daotest.AbcdefEntity;
-import de.greenrobot.daotest.ToManyTargetEntity;
-import de.greenrobot.daotest.ToManyEntity;
-import de.greenrobot.daotest.TreeEntity;
-import de.greenrobot.daotest.AnActiveEntity;
-import de.greenrobot.daotest.ExtendsImplementsEntity;
-import de.greenrobot.daotest.StringKeyValueEntity;
-import de.greenrobot.daotest.AutoincrementEntity;
-import de.greenrobot.daotest.SqliteMaster;
-
-import de.greenrobot.daotest.SimpleEntityDao;
-import de.greenrobot.daotest.SimpleEntityNotNullDao;
-import de.greenrobot.daotest.TestEntityDao;
-import de.greenrobot.daotest.RelationEntityDao;
-import de.greenrobot.daotest.DateEntityDao;
-import de.greenrobot.daotest.SpecialNamesEntityDao;
-import de.greenrobot.daotest.AbcdefEntityDao;
-import de.greenrobot.daotest.ToManyTargetEntityDao;
-import de.greenrobot.daotest.ToManyEntityDao;
-import de.greenrobot.daotest.TreeEntityDao;
-import de.greenrobot.daotest.AnActiveEntityDao;
-import de.greenrobot.daotest.ExtendsImplementsEntityDao;
-import de.greenrobot.daotest.StringKeyValueEntityDao;
-import de.greenrobot.daotest.AutoincrementEntityDao;
-import de.greenrobot.daotest.SqliteMasterDao;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 
@@ -82,7 +49,7 @@
     private final AutoincrementEntityDao autoincrementEntityDao;
     private final SqliteMasterDao sqliteMasterDao;
 
-    public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>
+    public DaoSession(SQLiteDatabaseWrapper db, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>
             daoConfigMap) {
         super(db);
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/DateEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/DateEntityDao.java
index 5471c1a7..87cc6df9 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/DateEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/DateEntityDao.java
@@ -1,14 +1,11 @@
 package de.greenrobot.daotest;
 
 import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
-
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.Property;
-
-import de.greenrobot.daotest.DateEntity;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -38,7 +35,7 @@ public DateEntityDao(DaoConfig config, DaoSession daoSession) {
     }
 
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(SQLiteDatabaseWrapper db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         db.execSQL("CREATE TABLE " + constraint + "'DATE_ENTITY' (" + //
                 "'_id' INTEGER PRIMARY KEY ," + // 0: id
@@ -47,14 +44,14 @@ public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+    public static void dropTable(SQLiteDatabaseWrapper db, boolean ifExists) {
         String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'DATE_ENTITY'";
         db.execSQL(sql);
     }
 
     /** @inheritdoc */
     @Override
-    protected void bindValues(SQLiteStatement stmt, DateEntity entity) {
+    protected void bindValues(SQLiteStatementWrapper stmt, DateEntity entity) {
         stmt.clearBindings();
  
         Long id = entity.getId();
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntityDao.java
index 5ffd8c6b..bcf6803e 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/ExtendsImplementsEntityDao.java
@@ -1,14 +1,11 @@
 package de.greenrobot.daotest;
 
 import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
-
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.Property;
-
-import de.greenrobot.daotest.ExtendsImplementsEntity;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -37,7 +34,7 @@ public ExtendsImplementsEntityDao(DaoConfig config, DaoSession daoSession) {
     }
 
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(SQLiteDatabaseWrapper db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         db.execSQL("CREATE TABLE " + constraint + "'EXTENDS_IMPLEMENTS_ENTITY' (" + //
                 "'_id' INTEGER PRIMARY KEY ," + // 0: id
@@ -45,14 +42,14 @@ public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+    public static void dropTable(SQLiteDatabaseWrapper db, boolean ifExists) {
         String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'EXTENDS_IMPLEMENTS_ENTITY'";
         db.execSQL(sql);
     }
 
     /** @inheritdoc */
     @Override
-    protected void bindValues(SQLiteStatement stmt, ExtendsImplementsEntity entity) {
+    protected void bindValues(SQLiteStatementWrapper stmt, ExtendsImplementsEntity entity) {
         stmt.clearBindings();
  
         Long id = entity.getId();
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/RelationEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/RelationEntityDao.java
index 6c3963f0..d2d99749 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/RelationEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/RelationEntityDao.java
@@ -1,17 +1,15 @@
 package de.greenrobot.daotest;
 
-import java.util.List;
 import java.util.ArrayList;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
+import java.util.List;
 
+import android.database.Cursor;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.SqlUtils;
-
-import de.greenrobot.daotest.RelationEntity;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -47,7 +45,7 @@ public RelationEntityDao(DaoConfig config, DaoSession daoSession) {
     }
 
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(SQLiteDatabaseWrapper db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         db.execSQL("CREATE TABLE " + constraint + "'RELATION_ENTITY' (" + //
                 "'_id' INTEGER PRIMARY KEY ," + // 0: id
@@ -59,14 +57,14 @@ public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+    public static void dropTable(SQLiteDatabaseWrapper db, boolean ifExists) {
         String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'RELATION_ENTITY'";
         db.execSQL(sql);
     }
 
     /** @inheritdoc */
     @Override
-    protected void bindValues(SQLiteStatement stmt, RelationEntity entity) {
+    protected void bindValues(SQLiteStatementWrapper stmt, RelationEntity entity) {
         stmt.clearBindings();
  
         Long id = entity.getId();
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityDao.java
index 52ff931e..8a7b4226 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityDao.java
@@ -1,14 +1,11 @@
 package de.greenrobot.daotest;
 
 import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
-
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.Property;
-
-import de.greenrobot.daotest.SimpleEntity;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -45,7 +42,7 @@ public SimpleEntityDao(DaoConfig config, DaoSession daoSession) {
     }
 
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(SQLiteDatabaseWrapper db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         db.execSQL("CREATE TABLE " + constraint + "'SIMPLE_ENTITY' (" + //
                 "'_id' INTEGER PRIMARY KEY ," + // 0: id
@@ -61,14 +58,14 @@ public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+    public static void dropTable(SQLiteDatabaseWrapper db, boolean ifExists) {
         String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'SIMPLE_ENTITY'";
         db.execSQL(sql);
     }
 
     /** @inheritdoc */
     @Override
-    protected void bindValues(SQLiteStatement stmt, SimpleEntity entity) {
+    protected void bindValues(SQLiteStatementWrapper stmt, SimpleEntity entity) {
         stmt.clearBindings();
  
         Long id = entity.getId();
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNullDao.java b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNullDao.java
index fcb0e7c0..6bceb2e9 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNullDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SimpleEntityNotNullDao.java
@@ -1,14 +1,11 @@
 package de.greenrobot.daotest;
 
 import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
-
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.Property;
-
-import de.greenrobot.daotest.SimpleEntityNotNull;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -45,7 +42,7 @@ public SimpleEntityNotNullDao(DaoConfig config, DaoSession daoSession) {
     }
 
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(SQLiteDatabaseWrapper db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         db.execSQL("CREATE TABLE " + constraint + "'SIMPLE_ENTITY_NOT_NULL' (" + //
                 "'_id' INTEGER PRIMARY KEY NOT NULL ," + // 0: id
@@ -61,14 +58,14 @@ public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+    public static void dropTable(SQLiteDatabaseWrapper db, boolean ifExists) {
         String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'SIMPLE_ENTITY_NOT_NULL'";
         db.execSQL(sql);
     }
 
     /** @inheritdoc */
     @Override
-    protected void bindValues(SQLiteStatement stmt, SimpleEntityNotNull entity) {
+    protected void bindValues(SQLiteStatementWrapper stmt, SimpleEntityNotNull entity) {
         stmt.clearBindings();
         stmt.bindLong(1, entity.getId());
         stmt.bindLong(2, entity.getSimpleBoolean() ? 1l: 0l);
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntityDao.java
index bdc22f84..94a89dec 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SpecialNamesEntityDao.java
@@ -1,14 +1,11 @@
 package de.greenrobot.daotest;
 
 import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
-
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.Property;
-
-import de.greenrobot.daotest.SpecialNamesEntity;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -45,7 +42,7 @@ public SpecialNamesEntityDao(DaoConfig config, DaoSession daoSession) {
     }
 
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(SQLiteDatabaseWrapper db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         db.execSQL("CREATE TABLE " + constraint + "'SPECIAL_NAMES_ENTITY' (" + //
                 "'_id' INTEGER PRIMARY KEY ," + // 0: id
@@ -61,14 +58,14 @@ public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+    public static void dropTable(SQLiteDatabaseWrapper db, boolean ifExists) {
         String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'SPECIAL_NAMES_ENTITY'";
         db.execSQL(sql);
     }
 
     /** @inheritdoc */
     @Override
-    protected void bindValues(SQLiteStatement stmt, SpecialNamesEntity entity) {
+    protected void bindValues(SQLiteStatementWrapper stmt, SpecialNamesEntity entity) {
         stmt.clearBindings();
  
         Long id = entity.getId();
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/SqliteMasterDao.java b/DaoTest/src-gen/de/greenrobot/daotest/SqliteMasterDao.java
index 46ef631e..f810d51b 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/SqliteMasterDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/SqliteMasterDao.java
@@ -1,14 +1,10 @@
 package de.greenrobot.daotest;
 
 import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
-
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.Property;
-
-import de.greenrobot.daotest.SqliteMaster;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -41,7 +37,7 @@ public SqliteMasterDao(DaoConfig config, DaoSession daoSession) {
 
     /** @inheritdoc */
     @Override
-    protected void bindValues(SQLiteStatement stmt, SqliteMaster entity) {
+    protected void bindValues(SQLiteStatementWrapper stmt, SqliteMaster entity) {
         stmt.clearBindings();
  
         String type = entity.getType();
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntityDao.java
index 8285af83..6ac91fdf 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/StringKeyValueEntityDao.java
@@ -1,14 +1,11 @@
 package de.greenrobot.daotest;
 
 import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
-
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.Property;
-
-import de.greenrobot.daotest.StringKeyValueEntity;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -37,7 +34,7 @@ public StringKeyValueEntityDao(DaoConfig config, DaoSession daoSession) {
     }
 
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(SQLiteDatabaseWrapper db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         db.execSQL("CREATE TABLE " + constraint + "'STRING_KEY_VALUE_ENTITY' (" + //
                 "'KEY' TEXT PRIMARY KEY NOT NULL ," + // 0: key
@@ -45,14 +42,14 @@ public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+    public static void dropTable(SQLiteDatabaseWrapper db, boolean ifExists) {
         String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'STRING_KEY_VALUE_ENTITY'";
         db.execSQL(sql);
     }
 
     /** @inheritdoc */
     @Override
-    protected void bindValues(SQLiteStatement stmt, StringKeyValueEntity entity) {
+    protected void bindValues(SQLiteStatementWrapper stmt, StringKeyValueEntity entity) {
         stmt.clearBindings();
  
         String key = entity.getKey();
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/TestEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/TestEntityDao.java
index 26daf170..4364e5fb 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/TestEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/TestEntityDao.java
@@ -1,14 +1,11 @@
 package de.greenrobot.daotest;
 
 import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
-
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.Property;
-
-import de.greenrobot.daotest.TestEntity;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -44,7 +41,7 @@ public TestEntityDao(DaoConfig config, DaoSession daoSession) {
     }
 
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(SQLiteDatabaseWrapper db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         db.execSQL("CREATE TABLE " + constraint + "'TEST_ENTITY' (" + //
                 "'_id' INTEGER PRIMARY KEY ," + // 0: id
@@ -64,14 +61,14 @@ public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+    public static void dropTable(SQLiteDatabaseWrapper db, boolean ifExists) {
         String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TEST_ENTITY'";
         db.execSQL(sql);
     }
 
     /** @inheritdoc */
     @Override
-    protected void bindValues(SQLiteStatement stmt, TestEntity entity) {
+    protected void bindValues(SQLiteStatementWrapper stmt, TestEntity entity) {
         stmt.clearBindings();
  
         Long id = entity.getId();
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntityDao.java
index c734d967..d2eef61f 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/ToManyEntityDao.java
@@ -1,14 +1,11 @@
 package de.greenrobot.daotest;
 
 import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
-
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.Property;
-
-import de.greenrobot.daotest.ToManyEntity;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -40,7 +37,7 @@ public ToManyEntityDao(DaoConfig config, DaoSession daoSession) {
     }
 
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(SQLiteDatabaseWrapper db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         db.execSQL("CREATE TABLE " + constraint + "'TO_MANY_ENTITY' (" + //
                 "'_id' INTEGER PRIMARY KEY ," + // 0: id
@@ -48,14 +45,14 @@ public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+    public static void dropTable(SQLiteDatabaseWrapper db, boolean ifExists) {
         String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TO_MANY_ENTITY'";
         db.execSQL(sql);
     }
 
     /** @inheritdoc */
     @Override
-    protected void bindValues(SQLiteStatement stmt, ToManyEntity entity) {
+    protected void bindValues(SQLiteStatementWrapper stmt, ToManyEntity entity) {
         stmt.clearBindings();
  
         Long id = entity.getId();
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntityDao.java
index 7ba772af..62ae695e 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/ToManyTargetEntityDao.java
@@ -1,17 +1,15 @@
 package de.greenrobot.daotest;
 
 import java.util.List;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
 
+import android.database.Cursor;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.Query;
 import de.greenrobot.dao.QueryBuilder;
-
-import de.greenrobot.daotest.ToManyTargetEntity;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -46,7 +44,7 @@ public ToManyTargetEntityDao(DaoConfig config, DaoSession daoSession) {
     }
 
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(SQLiteDatabaseWrapper db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         db.execSQL("CREATE TABLE " + constraint + "'TO_MANY_TARGET_ENTITY' (" + //
                 "'TO_MANY_ID' INTEGER," + // 0: toManyId
@@ -56,14 +54,14 @@ public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+    public static void dropTable(SQLiteDatabaseWrapper db, boolean ifExists) {
         String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TO_MANY_TARGET_ENTITY'";
         db.execSQL(sql);
     }
 
     /** @inheritdoc */
     @Override
-    protected void bindValues(SQLiteStatement stmt, ToManyTargetEntity entity) {
+    protected void bindValues(SQLiteStatementWrapper stmt, ToManyTargetEntity entity) {
         stmt.clearBindings();
  
         Long toManyId = entity.getToManyId();
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/TreeEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest/TreeEntityDao.java
index 4c02d266..446e6723 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/TreeEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/TreeEntityDao.java
@@ -1,19 +1,17 @@
 package de.greenrobot.daotest;
 
-import java.util.List;
 import java.util.ArrayList;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
+import java.util.List;
 
+import android.database.Cursor;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.Property;
-import de.greenrobot.dao.SqlUtils;
 import de.greenrobot.dao.Query;
 import de.greenrobot.dao.QueryBuilder;
-
-import de.greenrobot.daotest.TreeEntity;
+import de.greenrobot.dao.SqlUtils;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -46,7 +44,7 @@ public TreeEntityDao(DaoConfig config, DaoSession daoSession) {
     }
 
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(SQLiteDatabaseWrapper db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         db.execSQL("CREATE TABLE " + constraint + "'TREE_ENTITY' (" + //
                 "'_id' INTEGER PRIMARY KEY ," + // 0: id
@@ -54,14 +52,14 @@ public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+    public static void dropTable(SQLiteDatabaseWrapper db, boolean ifExists) {
         String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TREE_ENTITY'";
         db.execSQL(sql);
     }
 
     /** @inheritdoc */
     @Override
-    protected void bindValues(SQLiteStatement stmt, TreeEntity entity) {
+    protected void bindValues(SQLiteStatementWrapper stmt, TreeEntity entity) {
         stmt.clearBindings();
  
         Long id = entity.getId();
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/dao/DaoMaster.java b/DaoTest/src-gen/de/greenrobot/daotest2/dao/DaoMaster.java
index 8d97cdbc..3b2ff17c 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/dao/DaoMaster.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/dao/DaoMaster.java
@@ -1,17 +1,14 @@
 package de.greenrobot.daotest2.dao;
 
 import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteDatabase.CursorFactory;
-import android.database.sqlite.SQLiteOpenHelper;
 import android.util.Log;
 import de.greenrobot.dao.AbstractDaoMaster;
 import de.greenrobot.dao.IdentityScopeType;
-
-import de.greenrobot.daotest2.dao.KeepEntityDao;
-import de.greenrobot.daotest2.dao.ToManyTarget2Dao;
-import de.greenrobot.daotest2.to1_specialdao.ToOneTarget2Dao;
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteOpenHelperWrapper;
 import de.greenrobot.daotest2.specialdao.RelationSource2Dao;
+import de.greenrobot.daotest2.to1_specialdao.ToOneTarget2Dao;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -21,7 +18,7 @@
     public static final int SCHEMA_VERSION = 1;
 
     /** Creates underlying database table using DAOs. */
-    public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createAllTables(SQLiteDatabaseWrapper db, boolean ifNotExists) {
         KeepEntityDao.createTable(db, ifNotExists);
         ToManyTarget2Dao.createTable(db, ifNotExists);
         ToOneTarget2Dao.createTable(db, ifNotExists);
@@ -29,21 +26,21 @@ public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
     }
     
     /** Drops underlying database table using DAOs. */
-    public static void dropAllTables(SQLiteDatabase db, boolean ifExists) {
+    public static void dropAllTables(SQLiteDatabaseWrapper db, boolean ifExists) {
         KeepEntityDao.dropTable(db, ifExists);
         ToManyTarget2Dao.dropTable(db, ifExists);
         ToOneTarget2Dao.dropTable(db, ifExists);
         RelationSource2Dao.dropTable(db, ifExists);
     }
     
-    public static abstract class OpenHelper extends SQLiteOpenHelper {
+    public static abstract class OpenHelper extends SQLiteOpenHelperWrapper {
 
         public OpenHelper(Context context, String name, CursorFactory factory) {
-            super(context, name, factory, SCHEMA_VERSION);
+            super(context, name, null, factory, SCHEMA_VERSION);
         }
 
         @Override
-        public void onCreate(SQLiteDatabase db) {
+        public void onCreate(SQLiteDatabaseWrapper db) {
             Log.i("greenDAO", "Creating tables for schema version " + SCHEMA_VERSION);
             createAllTables(db, false);
         }
@@ -56,14 +53,14 @@ public DevOpenHelper(Context context, String name, CursorFactory factory) {
         }
 
         @Override
-        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        public void onUpgrade(SQLiteDatabaseWrapper db, int oldVersion, int newVersion) {
             Log.i("greenDAO", "Upgrading schema from version " + oldVersion + " to " + newVersion + " by dropping all tables");
             dropAllTables(db, true);
             onCreate(db);
         }
     }
 
-    public DaoMaster(SQLiteDatabase db) {
+    public DaoMaster(SQLiteDatabaseWrapper db) {
         super(db, SCHEMA_VERSION);
         registerDaoClass(KeepEntityDao.class);
         registerDaoClass(ToManyTarget2Dao.class);
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/dao/DaoSession.java b/DaoTest/src-gen/de/greenrobot/daotest2/dao/DaoSession.java
index df62f951..ac3bcaae 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/dao/DaoSession.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/dao/DaoSession.java
@@ -1,23 +1,18 @@
 package de.greenrobot.daotest2.dao;
 
-import android.database.sqlite.SQLiteDatabase;
-
 import java.util.Map;
 
 import de.greenrobot.dao.AbstractDao;
-import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.AbstractDaoSession;
+import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.IdentityScopeType;
-
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
 import de.greenrobot.daotest2.KeepEntity;
 import de.greenrobot.daotest2.ToManyTarget2;
-import de.greenrobot.daotest2.to1_specialentity.ToOneTarget2;
+import de.greenrobot.daotest2.specialdao.RelationSource2Dao;
 import de.greenrobot.daotest2.specialentity.RelationSource2;
-
-import de.greenrobot.daotest2.dao.KeepEntityDao;
-import de.greenrobot.daotest2.dao.ToManyTarget2Dao;
 import de.greenrobot.daotest2.to1_specialdao.ToOneTarget2Dao;
-import de.greenrobot.daotest2.specialdao.RelationSource2Dao;
+import de.greenrobot.daotest2.to1_specialentity.ToOneTarget2;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 
@@ -38,7 +33,7 @@
     private final ToOneTarget2Dao toOneTarget2Dao;
     private final RelationSource2Dao relationSource2Dao;
 
-    public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>
+    public DaoSession(SQLiteDatabaseWrapper db, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>
             daoConfigMap) {
         super(db);
 
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/dao/KeepEntityDao.java b/DaoTest/src-gen/de/greenrobot/daotest2/dao/KeepEntityDao.java
index ff6ffbdd..611b21da 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/dao/KeepEntityDao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/dao/KeepEntityDao.java
@@ -1,13 +1,11 @@
 package de.greenrobot.daotest2.dao;
 
 import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
-
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.Property;
-
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 import de.greenrobot.daotest2.KeepEntity;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
@@ -36,21 +34,21 @@ public KeepEntityDao(DaoConfig config, DaoSession daoSession) {
     }
 
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(SQLiteDatabaseWrapper db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         db.execSQL("CREATE TABLE " + constraint + "'KEEP_ENTITY' (" + //
                 "'_id' INTEGER PRIMARY KEY );"); // 0: id
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+    public static void dropTable(SQLiteDatabaseWrapper db, boolean ifExists) {
         String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'KEEP_ENTITY'";
         db.execSQL(sql);
     }
 
     /** @inheritdoc */
     @Override
-    protected void bindValues(SQLiteStatement stmt, KeepEntity entity) {
+    protected void bindValues(SQLiteStatementWrapper stmt, KeepEntity entity) {
         stmt.clearBindings();
  
         Long id = entity.getId();
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/dao/ToManyTarget2Dao.java b/DaoTest/src-gen/de/greenrobot/daotest2/dao/ToManyTarget2Dao.java
index 94e08039..9c020f2f 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/dao/ToManyTarget2Dao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/dao/ToManyTarget2Dao.java
@@ -1,16 +1,15 @@
 package de.greenrobot.daotest2.dao;
 
 import java.util.List;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
 
+import android.database.Cursor;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.Query;
 import de.greenrobot.dao.QueryBuilder;
-
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 import de.greenrobot.daotest2.ToManyTarget2;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
@@ -41,7 +40,7 @@ public ToManyTarget2Dao(DaoConfig config, DaoSession daoSession) {
     }
 
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(SQLiteDatabaseWrapper db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         db.execSQL("CREATE TABLE " + constraint + "'TO_MANY_TARGET2' (" + //
                 "'_id' INTEGER PRIMARY KEY ," + // 0: id
@@ -49,14 +48,14 @@ public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+    public static void dropTable(SQLiteDatabaseWrapper db, boolean ifExists) {
         String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TO_MANY_TARGET2'";
         db.execSQL(sql);
     }
 
     /** @inheritdoc */
     @Override
-    protected void bindValues(SQLiteStatement stmt, ToManyTarget2 entity) {
+    protected void bindValues(SQLiteStatementWrapper stmt, ToManyTarget2 entity) {
         stmt.clearBindings();
  
         Long id = entity.getId();
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java b/DaoTest/src-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java
index 1a73a286..b9d36ab0 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/specialdao/RelationSource2Dao.java
@@ -1,21 +1,18 @@
 package de.greenrobot.daotest2.specialdao;
 
-import java.util.List;
 import java.util.ArrayList;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
+import java.util.List;
 
+import android.database.Cursor;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.Property;
 import de.greenrobot.dao.SqlUtils;
-
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 import de.greenrobot.daotest2.dao.DaoSession;
-
-import de.greenrobot.daotest2.to1_specialentity.ToOneTarget2;
-
 import de.greenrobot.daotest2.specialentity.RelationSource2;
+import de.greenrobot.daotest2.to1_specialentity.ToOneTarget2;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
 /** 
@@ -47,7 +44,7 @@ public RelationSource2Dao(DaoConfig config, DaoSession daoSession) {
     }
 
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(SQLiteDatabaseWrapper db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         db.execSQL("CREATE TABLE " + constraint + "'RELATION_SOURCE2' (" + //
                 "'_id' INTEGER PRIMARY KEY ," + // 0: id
@@ -55,14 +52,14 @@ public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+    public static void dropTable(SQLiteDatabaseWrapper db, boolean ifExists) {
         String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'RELATION_SOURCE2'";
         db.execSQL(sql);
     }
 
     /** @inheritdoc */
     @Override
-    protected void bindValues(SQLiteStatement stmt, RelationSource2 entity) {
+    protected void bindValues(SQLiteStatementWrapper stmt, RelationSource2 entity) {
         stmt.clearBindings();
  
         Long id = entity.getId();
diff --git a/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialdao/ToOneTarget2Dao.java b/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialdao/ToOneTarget2Dao.java
index f4868ef1..928ab8ce 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialdao/ToOneTarget2Dao.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest2/to1_specialdao/ToOneTarget2Dao.java
@@ -1,15 +1,12 @@
 package de.greenrobot.daotest2.to1_specialdao;
 
 import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
-
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoConfig;
 import de.greenrobot.dao.Property;
-
+import de.greenrobot.dao.wrapper.SQLiteDatabaseWrapper;
+import de.greenrobot.dao.wrapper.SQLiteStatementWrapper;
 import de.greenrobot.daotest2.dao.DaoSession;
-
 import de.greenrobot.daotest2.to1_specialentity.ToOneTarget2;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
@@ -38,21 +35,21 @@ public ToOneTarget2Dao(DaoConfig config, DaoSession daoSession) {
     }
 
     /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+    public static void createTable(SQLiteDatabaseWrapper db, boolean ifNotExists) {
         String constraint = ifNotExists? "IF NOT EXISTS ": "";
         db.execSQL("CREATE TABLE " + constraint + "'TO_ONE_TARGET2' (" + //
                 "'_id' INTEGER PRIMARY KEY );"); // 0: id
     }
 
     /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+    public static void dropTable(SQLiteDatabaseWrapper db, boolean ifExists) {
         String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'TO_ONE_TARGET2'";
         db.execSQL(sql);
     }
 
     /** @inheritdoc */
     @Override
-    protected void bindValues(SQLiteStatement stmt, ToOneTarget2 entity) {
+    protected void bindValues(SQLiteStatementWrapper stmt, ToOneTarget2 entity) {
         stmt.clearBindings();
  
         Long id = entity.getId();
