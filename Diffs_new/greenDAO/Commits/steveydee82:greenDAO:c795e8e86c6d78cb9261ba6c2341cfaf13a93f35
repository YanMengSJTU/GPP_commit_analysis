diff --git a/DaoCore/.classpath b/DaoCore/.classpath
index 7bc01d9a..51769745 100644
--- a/DaoCore/.classpath
+++ b/DaoCore/.classpath
@@ -1,9 +1,9 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
 	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
 	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
 	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
 	<classpathentry kind="output" path="bin/classes"/>
 </classpath>
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDao.java b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
index 95c29eb2..e94c14d9 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDao.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
@@ -56,7 +56,7 @@
  * 
  * 3.) identityScope
  */
-public abstract class AbstractDao<T, K> {
+public abstract class AbstractDao<T, K> implements Dao<T, K>  {
     protected final SQLiteDatabase db;
     protected final DaoConfig config;
     protected IdentityScope<K, T> identityScope;
@@ -83,7 +83,11 @@ public AbstractDao(DaoConfig config, AbstractDaoSession daoSession) {
         pkOrdinal = config.pkProperty != null ? config.pkProperty.ordinal : -1;
     }
 
-    public AbstractDaoSession getSession() {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#getSession()
+	 */
+    @Override
+	public AbstractDaoSession getSession() {
         return session;
     }
 
@@ -91,38 +95,59 @@ TableStatements getStatements() {
         return config.statements;
     }
 
-    public String getTablename() {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#getTablename()
+	 */
+    @Override
+	public String getTablename() {
         return config.tablename;
     }
 
-    public Property[] getProperties() {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#getProperties()
+	 */
+    @Override
+	public Property[] getProperties() {
         return config.properties;
     }
 
-    public Property getPkProperty() {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#getPkProperty()
+	 */
+    @Override
+	public Property getPkProperty() {
         return config.pkProperty;
     }
 
-    public String[] getAllColumns() {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#getAllColumns()
+	 */
+    @Override
+	public String[] getAllColumns() {
         return config.allColumns;
     }
 
-    public String[] getPkColumns() {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#getPkColumns()
+	 */
+    @Override
+	public String[] getPkColumns() {
         return config.pkColumns;
     }
 
-    public String[] getNonPkColumns() {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#getNonPkColumns()
+	 */
+    @Override
+	public String[] getNonPkColumns() {
         return config.nonPkColumns;
     }
 
-    /**
-     * Loads and entity for the given PK.
-     * 
-     * @param key
-     *            a PK value or null
-     * @return The entity or null, if no entity matched the PK value
-     */
-    public T load(K key) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#load(K)
+	 */
+    @Override
+	public T load(K key) {
         assertSinglePk();
         if (key == null) {
             return null;
@@ -139,7 +164,11 @@ public T load(K key) {
         return loadUniqueAndCloseCursor(cursor);
     }
 
-    public T loadByRowId(long rowId) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#loadByRowId(long)
+	 */
+    @Override
+	public T loadByRowId(long rowId) {
         String[] idArray = new String[] { Long.toString(rowId) };
         Cursor cursor = db.rawQuery(statements.getSelectByRowId(), idArray);
         return loadUniqueAndCloseCursor(cursor);
@@ -163,14 +192,20 @@ protected T loadUnique(Cursor cursor) {
         return loadCurrent(cursor, 0, true);
     }
 
-    /** Loads all available entities from the database. */
-    public List<T> loadAll() {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#loadAll()
+	 */
+    @Override
+	public List<T> loadAll() {
         Cursor cursor = db.rawQuery(statements.getSelectAll(), null);
         return loadAllAndCloseCursor(cursor);
     }
 
-    /** Detaches an entity from the identity scope (session). Subsequent query results won't return this object. */
-    public boolean detach(T entity) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#detach(T)
+	 */
+    @Override
+	public boolean detach(T entity) {
         if (identityScope != null) {
             K key = getKeyVerified(entity);
             return identityScope.detach(key, entity);
@@ -187,71 +222,53 @@ public boolean detach(T entity) {
         }
     }
 
-    /**
-     * Inserts the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to insert.
-     */
-    public void insertInTx(Iterable<T> entities) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#insertInTx(java.lang.Iterable)
+	 */
+    @Override
+	public void insertInTx(Iterable<T> entities) {
         insertInTx(entities, isEntityUpdateable());
     }
 
-    /**
-     * Inserts the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to insert.
-     */
-    public void insertInTx(T... entities) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#insertInTx(T)
+	 */
+    @Override
+	public void insertInTx(T... entities) {
         insertInTx(Arrays.asList(entities), isEntityUpdateable());
     }
 
-    /**
-     * Inserts the given entities in the database using a transaction. The given entities will become tracked if the PK
-     * is set.
-     * 
-     * @param entities
-     *            The entities to insert.
-     * @param setPrimaryKey
-     *            if true, the PKs of the given will be set after the insert; pass false to improve performance.
-     */
-    public void insertInTx(Iterable<T> entities, boolean setPrimaryKey) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#insertInTx(java.lang.Iterable, boolean)
+	 */
+    @Override
+	public void insertInTx(Iterable<T> entities, boolean setPrimaryKey) {
         SQLiteStatement stmt = statements.getInsertStatement();
         executeInsertInTx(stmt, entities, setPrimaryKey);
     }
 
-    /**
-     * Inserts or replaces the given entities in the database using a transaction. The given entities will become
-     * tracked if the PK is set.
-     * 
-     * @param entities
-     *            The entities to insert.
-     * @param setPrimaryKey
-     *            if true, the PKs of the given will be set after the insert; pass false to improve performance.
-     */
-    public void insertOrReplaceInTx(Iterable<T> entities, boolean setPrimaryKey) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#insertOrReplaceInTx(java.lang.Iterable, boolean)
+	 */
+    @Override
+	public void insertOrReplaceInTx(Iterable<T> entities, boolean setPrimaryKey) {
         SQLiteStatement stmt = statements.getInsertOrReplaceStatement();
         executeInsertInTx(stmt, entities, setPrimaryKey);
     }
 
-    /**
-     * Inserts or replaces the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to insert.
-     */
-    public void insertOrReplaceInTx(Iterable<T> entities) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#insertOrReplaceInTx(java.lang.Iterable)
+	 */
+    @Override
+	public void insertOrReplaceInTx(Iterable<T> entities) {
         insertOrReplaceInTx(entities, isEntityUpdateable());
     }
 
-    /**
-     * Inserts or replaces the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to insert.
-     */
-    public void insertOrReplaceInTx(T... entities) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#insertOrReplaceInTx(T)
+	 */
+    @Override
+	public void insertOrReplaceInTx(T... entities) {
         insertOrReplaceInTx(Arrays.asList(entities), isEntityUpdateable());
     }
 
@@ -284,22 +301,19 @@ private void executeInsertInTx(SQLiteStatement stmt, Iterable<T> entities, boole
         }
     }
 
-    /**
-     * Insert an entity into the table associated with a concrete DAO.
-     * 
-     * @return row ID of newly inserted entity
-     */
-    public long insert(T entity) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#insert(T)
+	 */
+    @Override
+	public long insert(T entity) {
         return executeInsert(entity, statements.getInsertStatement());
     }
 
-    /**
-     * Insert an entity into the table associated with a concrete DAO <b>without</b> setting key property. Warning: This
-     * may be faster, but the entity should not be used anymore. The entity also won't be attached to identy scope.
-     * 
-     * @return row ID of newly inserted entity
-     */
-    public long insertWithoutSettingPk(T entity) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#insertWithoutSettingPk(T)
+	 */
+    @Override
+	public long insertWithoutSettingPk(T entity) {
         SQLiteStatement stmt = statements.getInsertStatement();
         long rowId;
         if (db.isDbLockedByCurrentThread()) {
@@ -323,12 +337,11 @@ public long insertWithoutSettingPk(T entity) {
         return rowId;
     }
 
-    /**
-     * Insert an entity into the table associated with a concrete DAO.
-     * 
-     * @return row ID of newly inserted entity
-     */
-    public long insertOrReplace(T entity) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#insertOrReplace(T)
+	 */
+    @Override
+	public long insertOrReplace(T entity) {
         return executeInsert(entity, statements.getInsertOrReplaceStatement());
     }
 
@@ -457,30 +470,37 @@ final protected T loadCurrent(Cursor cursor, int offset, boolean lock) {
         return dao.loadCurrent(cursor, offset, /* TODO check this */true);
     }
 
-    /** A raw-style query where you can pass any WHERE clause and arguments. */
-    public List<T> queryRaw(String where, String... selectionArg) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#queryRaw(java.lang.String, java.lang.String)
+	 */
+    @Override
+	public List<T> queryRaw(String where, String... selectionArg) {
         Cursor cursor = db.rawQuery(statements.getSelectAll() + where, selectionArg);
         return loadAllAndCloseCursor(cursor);
     }
 
-    /**
-     * Creates a repeatable {@link Query} object based on the given raw SQL where you can pass any WHERE clause and
-     * arguments.
-     */
-    public Query<T> queryRawCreate(String where, Object... selectionArg) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#queryRawCreate(java.lang.String, java.lang.Object)
+	 */
+    @Override
+	public Query<T> queryRawCreate(String where, Object... selectionArg) {
         List<Object> argList = Arrays.asList(selectionArg);
         return queryRawCreateListArgs(where, argList);
     }
 
-    /**
-     * Creates a repeatable {@link Query} object based on the given raw SQL where you can pass any WHERE clause and
-     * arguments.
-     */
-    public Query<T> queryRawCreateListArgs(String where, Collection<Object> selectionArg) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#queryRawCreateListArgs(java.lang.String, java.util.Collection)
+	 */
+    @Override
+	public Query<T> queryRawCreateListArgs(String where, Collection<Object> selectionArg) {
         return Query.internalCreate(this, statements.getSelectAll() + where, selectionArg.toArray());
     }
 
-    public void deleteAll() {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#deleteAll()
+	 */
+    @Override
+	public void deleteAll() {
         // String sql = SqlUtils.createSqlDelete(config.tablename, null);
         // db.execSQL(sql);
 
@@ -490,15 +510,21 @@ public void deleteAll() {
         }
     }
 
-    /** Deletes the given entity from the database. Currently, only single value PK entities are supported. */
-    public void delete(T entity) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#delete(T)
+	 */
+    @Override
+	public void delete(T entity) {
         assertSinglePk();
         K key = getKeyVerified(entity);
         deleteByKey(key);
     }
 
-    /** Deletes an entity with the given PK from the database. Currently, only single value PK entities are supported. */
-    public void deleteByKey(K key) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#deleteByKey(K)
+	 */
+    @Override
+	public void deleteByKey(K key) {
         assertSinglePk();
         SQLiteStatement stmt = statements.getDeleteStatement();
         if (db.isDbLockedByCurrentThread()) {
@@ -577,48 +603,43 @@ private void deleteInTxInternal(Iterable<T> entities, Iterable<K> keys) {
         }
     }
 
-    /**
-     * Deletes the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to delete.
-     */
-    public void deleteInTx(Iterable<T> entities) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#deleteInTx(java.lang.Iterable)
+	 */
+    @Override
+	public void deleteInTx(Iterable<T> entities) {
         deleteInTxInternal(entities, null);
     }
 
-    /**
-     * Deletes the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to delete.
-     */
-    public void deleteInTx(T... entities) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#deleteInTx(T)
+	 */
+    @Override
+	public void deleteInTx(T... entities) {
         deleteInTxInternal(Arrays.asList(entities), null);
     }
 
-    /**
-     * Deletes all entities with the given keys in the database using a transaction.
-     * 
-     * @param keys
-     *            Keys of the entities to delete.
-     */
-    public void deleteByKeyInTx(Iterable<K> keys) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#deleteByKeyInTx(java.lang.Iterable)
+	 */
+    @Override
+	public void deleteByKeyInTx(Iterable<K> keys) {
         deleteInTxInternal(null, keys);
     }
 
-    /**
-     * Deletes all entities with the given keys in the database using a transaction.
-     * 
-     * @param keys
-     *            Keys of the entities to delete.
-     */
-    public void deleteByKeyInTx(K... keys) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#deleteByKeyInTx(K)
+	 */
+    @Override
+	public void deleteByKeyInTx(K... keys) {
         deleteInTxInternal(null, Arrays.asList(keys));
     }
 
-    /** Resets all locally changed properties of the entity by reloading the values from the database. */
-    public void refresh(T entity) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#refresh(T)
+	 */
+    @Override
+	public void refresh(T entity) {
         assertSinglePk();
         K key = getKeyVerified(entity);
         String sql = statements.getSelectByKey();
@@ -639,7 +660,11 @@ public void refresh(T entity) {
         }
     }
 
-    public void update(T entity) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#update(T)
+	 */
+    @Override
+	public void update(T entity) {
         assertSinglePk();
         SQLiteStatement stmt = statements.getUpdateStatement();
         if (db.isDbLockedByCurrentThread()) {
@@ -660,7 +685,11 @@ public void update(T entity) {
         }
     }
 
-    public QueryBuilder<T> queryBuilder() {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#queryBuilder()
+	 */
+    @Override
+	public QueryBuilder<T> queryBuilder() {
         return QueryBuilder.internalCreate(this);
     }
 
@@ -709,13 +738,11 @@ protected final void attachEntity(K key, T entity, boolean lock) {
     protected void attachEntity(T entity) {
     }
 
-    /**
-     * Updates the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to insert.
-     */
-    public void updateInTx(Iterable<T> entities) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#updateInTx(java.lang.Iterable)
+	 */
+    @Override
+	public void updateInTx(Iterable<T> entities) {
         SQLiteStatement stmt = statements.getUpdateStatement();
         db.beginTransaction();
         try {
@@ -739,13 +766,11 @@ public void updateInTx(Iterable<T> entities) {
         }
     }
 
-    /**
-     * Updates the given entities in the database using a transaction.
-     * 
-     * @param entities
-     *            The entities to update.
-     */
-    public void updateInTx(T... entities) {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#updateInTx(T)
+	 */
+    @Override
+	public void updateInTx(T... entities) {
         updateInTx(Arrays.asList(entities));
     }
 
@@ -755,7 +780,11 @@ protected void assertSinglePk() {
         }
     }
 
-    public long count() {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#count()
+	 */
+    @Override
+	public long count() {
         return DatabaseUtils.queryNumEntries(db, '\'' + config.tablename + '\'');
     }
 
@@ -773,8 +802,11 @@ protected K getKeyVerified(T entity) {
         }
     }
 
-    /** Gets the SQLiteDatabase for custom database access. Not needed for greenDAO entities. */
-    public SQLiteDatabase getDatabase() {
+    /* (non-Javadoc)
+	 * @see de.greenrobot.dao.Dao#getDatabase()
+	 */
+    @Override
+	public SQLiteDatabase getDatabase() {
         return db;
     }
 
diff --git a/DaoCore/src/de/greenrobot/dao/Dao.java b/DaoCore/src/de/greenrobot/dao/Dao.java
new file mode 100644
index 00000000..abe682c3
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/Dao.java
@@ -0,0 +1,206 @@
+package de.greenrobot.dao;
+
+import java.util.Collection;
+import java.util.List;
+
+import android.database.sqlite.SQLiteDatabase;
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+
+public interface Dao<T, K> {
+
+	public abstract AbstractDaoSession getSession();
+
+	public abstract String getTablename();
+
+	public abstract Property[] getProperties();
+
+	public abstract Property getPkProperty();
+
+	public abstract String[] getAllColumns();
+
+	public abstract String[] getPkColumns();
+
+	public abstract String[] getNonPkColumns();
+
+	/**
+	 * Loads and entity for the given PK.
+	 * 
+	 * @param key
+	 *            a PK value or null
+	 * @return The entity or null, if no entity matched the PK value
+	 */
+	public abstract T load(K key);
+
+	public abstract T loadByRowId(long rowId);
+
+	/** Loads all available entities from the database. */
+	public abstract List<T> loadAll();
+
+	/** Detaches an entity from the identity scope (session). Subsequent query results won't return this object. */
+	public abstract boolean detach(T entity);
+
+	/**
+	 * Inserts the given entities in the database using a transaction.
+	 * 
+	 * @param entities
+	 *            The entities to insert.
+	 */
+	public abstract void insertInTx(Iterable<T> entities);
+
+	/**
+	 * Inserts the given entities in the database using a transaction.
+	 * 
+	 * @param entities
+	 *            The entities to insert.
+	 */
+	public abstract void insertInTx(T... entities);
+
+	/**
+	 * Inserts the given entities in the database using a transaction. The given entities will become tracked if the PK
+	 * is set.
+	 * 
+	 * @param entities
+	 *            The entities to insert.
+	 * @param setPrimaryKey
+	 *            if true, the PKs of the given will be set after the insert; pass false to improve performance.
+	 */
+	public abstract void insertInTx(Iterable<T> entities, boolean setPrimaryKey);
+
+	/**
+	 * Inserts or replaces the given entities in the database using a transaction. The given entities will become
+	 * tracked if the PK is set.
+	 * 
+	 * @param entities
+	 *            The entities to insert.
+	 * @param setPrimaryKey
+	 *            if true, the PKs of the given will be set after the insert; pass false to improve performance.
+	 */
+	public abstract void insertOrReplaceInTx(Iterable<T> entities,
+			boolean setPrimaryKey);
+
+	/**
+	 * Inserts or replaces the given entities in the database using a transaction.
+	 * 
+	 * @param entities
+	 *            The entities to insert.
+	 */
+	public abstract void insertOrReplaceInTx(Iterable<T> entities);
+
+	/**
+	 * Inserts or replaces the given entities in the database using a transaction.
+	 * 
+	 * @param entities
+	 *            The entities to insert.
+	 */
+	public abstract void insertOrReplaceInTx(T... entities);
+
+	/**
+	 * Insert an entity into the table associated with a concrete DAO.
+	 * 
+	 * @return row ID of newly inserted entity
+	 */
+	public abstract long insert(T entity);
+
+	/**
+	 * Insert an entity into the table associated with a concrete DAO <b>without</b> setting key property. Warning: This
+	 * may be faster, but the entity should not be used anymore. The entity also won't be attached to identy scope.
+	 * 
+	 * @return row ID of newly inserted entity
+	 */
+	public abstract long insertWithoutSettingPk(T entity);
+
+	/**
+	 * Insert an entity into the table associated with a concrete DAO.
+	 * 
+	 * @return row ID of newly inserted entity
+	 */
+	public abstract long insertOrReplace(T entity);
+
+
+	/** A raw-style query where you can pass any WHERE clause and arguments. */
+	public abstract List<T> queryRaw(String where, String... selectionArg);
+
+	/**
+	 * Creates a repeatable {@link Query} object based on the given raw SQL where you can pass any WHERE clause and
+	 * arguments.
+	 */
+	public abstract Query<T> queryRawCreate(String where,
+			Object... selectionArg);
+
+	/**
+	 * Creates a repeatable {@link Query} object based on the given raw SQL where you can pass any WHERE clause and
+	 * arguments.
+	 */
+	public abstract Query<T> queryRawCreateListArgs(String where,
+			Collection<Object> selectionArg);
+
+	public abstract void deleteAll();
+
+	/** Deletes the given entity from the database. Currently, only single value PK entities are supported. */
+	public abstract void delete(T entity);
+
+	/** Deletes an entity with the given PK from the database. Currently, only single value PK entities are supported. */
+	public abstract void deleteByKey(K key);
+
+	/**
+	 * Deletes the given entities in the database using a transaction.
+	 * 
+	 * @param entities
+	 *            The entities to delete.
+	 */
+	public abstract void deleteInTx(Iterable<T> entities);
+
+	/**
+	 * Deletes the given entities in the database using a transaction.
+	 * 
+	 * @param entities
+	 *            The entities to delete.
+	 */
+	public abstract void deleteInTx(T... entities);
+
+	/**
+	 * Deletes all entities with the given keys in the database using a transaction.
+	 * 
+	 * @param keys
+	 *            Keys of the entities to delete.
+	 */
+	public abstract void deleteByKeyInTx(Iterable<K> keys);
+
+	/**
+	 * Deletes all entities with the given keys in the database using a transaction.
+	 * 
+	 * @param keys
+	 *            Keys of the entities to delete.
+	 */
+	public abstract void deleteByKeyInTx(K... keys);
+
+	/** Resets all locally changed properties of the entity by reloading the values from the database. */
+	public abstract void refresh(T entity);
+
+	public abstract void update(T entity);
+
+	public abstract QueryBuilder<T> queryBuilder();
+
+	/**
+	 * Updates the given entities in the database using a transaction.
+	 * 
+	 * @param entities
+	 *            The entities to insert.
+	 */
+	public abstract void updateInTx(Iterable<T> entities);
+
+	/**
+	 * Updates the given entities in the database using a transaction.
+	 * 
+	 * @param entities
+	 *            The entities to update.
+	 */
+	public abstract void updateInTx(T... entities);
+
+	public abstract long count();
+
+	/** Gets the SQLiteDatabase for custom database access. Not needed for greenDAO entities. */
+	public abstract SQLiteDatabase getDatabase();
+
+}
\ No newline at end of file
diff --git a/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java b/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java
index 9414f1f7..db85526f 100644
--- a/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java
+++ b/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java
@@ -81,6 +81,14 @@ public String getSelectAll() {
         }
         return selectAll;
     }
+    
+    /** ends with an space to simplify appending to this string. */
+    public String getSelectColumns(String[] columns) {
+        if (selectAll == null) {
+            selectAll = SqlUtils.createSqlSelect(tablename, "T", columns);
+        }
+        return selectAll;
+    }
 
     /** ends with an space to simplify appending to this string. */
     public String getSelectKeys() {
diff --git a/DaoCore/src/de/greenrobot/dao/query/Query.java b/DaoCore/src/de/greenrobot/dao/query/Query.java
index 4d36b1b0..4d08527e 100644
--- a/DaoCore/src/de/greenrobot/dao/query/Query.java
+++ b/DaoCore/src/de/greenrobot/dao/query/Query.java
@@ -120,6 +120,12 @@ public void setOffset(int offset) {
         Cursor cursor = dao.getDatabase().rawQuery(sql, parameters);
         return daoAccess.loadAllAndCloseCursor(cursor);
     }
+    
+    /** Executes the query and returns the results as a cursor. */
+    public Cursor cursor() {
+        checkThread();
+        return dao.getDatabase().rawQuery(sql, parameters);
+    }
 
     /**
      * Executes the query and returns the result as a list that lazy loads the entities on first access. Entities are
@@ -162,6 +168,7 @@ public T unique() {
         Cursor cursor = dao.getDatabase().rawQuery(sql, parameters);
         return daoAccess.loadUniqueAndCloseCursor(cursor);
     }
+   
 
     /**
      * Executes the query and returns the unique result (never null).
diff --git a/DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java b/DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java
index fdd58004..e8f9fa19 100644
--- a/DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java
+++ b/DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java
@@ -19,6 +19,7 @@
 import java.util.List;
 import java.util.ListIterator;
 
+import android.database.Cursor;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.AbstractDaoSession;
 import de.greenrobot.dao.DaoException;
@@ -65,6 +66,8 @@
     private Integer limit;
 
     private Integer offset;
+    
+    private String[] selectColumns;
 
     /** For internal use by greenDAO only. */
     public static <T2> QueryBuilder<T2> internalCreate(AbstractDao<T2, ?> dao) {
@@ -195,7 +198,7 @@ private void orderAscOrDesc(String ascOrDescWithLeadingSpace, Property... proper
             orderBuilder.append(ascOrDescWithLeadingSpace);
         }
     }
-
+    
     /** Adds the given properties to the ORDER BY section using the given custom order. */
     public QueryBuilder<T> orderCustom(Property property, String customOrderForProperty) {
         checkOrderBuilder();
@@ -213,6 +216,21 @@ private void orderAscOrDesc(String ascOrDescWithLeadingSpace, Property... proper
         orderBuilder.append(rawOrder);
         return this;
     }
+    
+    /**
+     * Sets the properties that will be returned. For use only if retrieving a Cursor using .cursor()
+     * @param properties
+     * @return
+     */
+    public QueryBuilder<T> select(Property...properties) {
+    	selectColumns = new String[properties.length];
+    	
+    	for(int ii = 0; ii < properties.length; ii++) {
+    		selectColumns[ii] = properties[ii].columnName;
+    	}
+    	
+    	return this;
+    }
 
     protected StringBuilder append(StringBuilder builder, Property property) {
         checkProperty(property);
@@ -258,9 +276,17 @@ protected void checkProperty(Property property) {
     public Query<T> build() {
         String select;
         if (joinBuilder == null || joinBuilder.length() == 0) {
-            select = InternalQueryDaoAccess.getStatements(dao).getSelectAll();
+        	if(selectColumns != null) {
+        		select = InternalQueryDaoAccess.getStatements(dao).getSelectColumns(selectColumns);
+        	} else {
+        		select = InternalQueryDaoAccess.getStatements(dao).getSelectAll();	
+        	}
         } else {
-            select = SqlUtils.createSqlSelect(dao.getTablename(), tablePrefix, dao.getAllColumns());
+        	if(selectColumns != null) {
+        		select = SqlUtils.createSqlSelect(dao.getTablename(), tablePrefix, selectColumns);
+        	} else {
+        		select = SqlUtils.createSqlSelect(dao.getTablename(), tablePrefix, dao.getAllColumns());	
+        	}
         }
         StringBuilder builder = new StringBuilder(select);
 
@@ -418,6 +444,15 @@ public T unique() {
     public T uniqueOrThrow() {
         return build().uniqueOrThrow();
     }
+    
+    /**
+     * Shorthand for {@link QueryBuilder#build() build()}.{@link Query#cursor() cursor()}; see
+     * {@link Query#cursor()} for details. To execute a query more than once, you should build the query and keep
+     * the {@link Query} object for efficiency reasons.
+     */
+    public Cursor cursor() {
+    	return build().cursor();
+    }
 
     /**
      * Shorthand for {@link QueryBuilder#buildCount() buildCount()}.{@link CountQuery#count() count()}; see
