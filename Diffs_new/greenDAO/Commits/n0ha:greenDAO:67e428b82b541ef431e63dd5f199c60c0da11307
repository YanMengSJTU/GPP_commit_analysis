diff --git a/.gitignore b/.gitignore
index 2ccd1fa7..e93f148a 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,4 @@
 .gradle
 *.iml
-.idea/
\ No newline at end of file
+.idea/
+local.properties
\ No newline at end of file
diff --git a/DaoCore/src/de/greenrobot/dao/AbstractDao.java b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
index 017d0214..054fdbb5 100644
--- a/DaoCore/src/de/greenrobot/dao/AbstractDao.java
+++ b/DaoCore/src/de/greenrobot/dao/AbstractDao.java
@@ -16,17 +16,14 @@
 
 package de.greenrobot.dao;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.List;
-
 import android.database.CrossProcessCursor;
 import android.database.Cursor;
 import android.database.CursorWindow;
 import android.database.DatabaseUtils;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteStatement;
+import de.greenrobot.dao.callbacks.ActiveEntity;
+import de.greenrobot.dao.callbacks.OnBeforeInsertCallback;
 import de.greenrobot.dao.identityscope.IdentityScope;
 import de.greenrobot.dao.identityscope.IdentityScopeLong;
 import de.greenrobot.dao.internal.DaoConfig;
@@ -35,13 +32,18 @@
 import de.greenrobot.dao.query.Query;
 import de.greenrobot.dao.query.QueryBuilder;
 
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+
 /**
  * Base class for all DAOs: Implements entity operations like insert, load, delete, and query.
- * 
+ *
  * This class is thread-safe.
- * 
+ *
  * @author Markus
- * 
+ *
  * @param <T>
  *            Entity type
  * @param <K>
@@ -49,11 +51,11 @@
  */
 /*
  * When operating on TX, statements, or identity scope the following locking order must be met to avoid deadlocks:
- * 
+ *
  * 1.) If not inside a TX already, begin a TX to acquire a DB connection (connection is to be handled like a lock)
- * 
+ *
  * 2.) The SQLiteStatement
- * 
+ *
  * 3.) identityScope
  */
 public abstract class AbstractDao<T, K> {
@@ -117,7 +119,7 @@ public Property getPkProperty() {
 
     /**
      * Loads and entity for the given PK.
-     * 
+     *
      * @param key
      *            a PK value or null
      * @return The entity or null, if no entity matched the PK value
@@ -189,7 +191,7 @@ public boolean detach(T entity) {
 
     /**
      * Inserts the given entities in the database using a transaction.
-     * 
+     *
      * @param entities
      *            The entities to insert.
      */
@@ -199,7 +201,7 @@ public void insertInTx(Iterable<T> entities) {
 
     /**
      * Inserts the given entities in the database using a transaction.
-     * 
+     *
      * @param entities
      *            The entities to insert.
      */
@@ -210,7 +212,7 @@ public void insertInTx(T... entities) {
     /**
      * Inserts the given entities in the database using a transaction. The given entities will become tracked if the PK
      * is set.
-     * 
+     *
      * @param entities
      *            The entities to insert.
      * @param setPrimaryKey
@@ -224,7 +226,7 @@ public void insertInTx(Iterable<T> entities, boolean setPrimaryKey) {
     /**
      * Inserts or replaces the given entities in the database using a transaction. The given entities will become
      * tracked if the PK is set.
-     * 
+     *
      * @param entities
      *            The entities to insert.
      * @param setPrimaryKey
@@ -237,7 +239,7 @@ public void insertOrReplaceInTx(Iterable<T> entities, boolean setPrimaryKey) {
 
     /**
      * Inserts or replaces the given entities in the database using a transaction.
-     * 
+     *
      * @param entities
      *            The entities to insert.
      */
@@ -247,7 +249,7 @@ public void insertOrReplaceInTx(Iterable<T> entities) {
 
     /**
      * Inserts or replaces the given entities in the database using a transaction.
-     * 
+     *
      * @param entities
      *            The entities to insert.
      */
@@ -255,6 +257,18 @@ public void insertOrReplaceInTx(T... entities) {
         insertOrReplaceInTx(Arrays.asList(entities), isEntityUpdateable());
     }
 
+    protected void callOnBeforeInsertCallback(T entity) {
+        // first set actual DAO for entity
+        if (entity instanceof ActiveEntity) {
+            ((ActiveEntity) entity).__setDaoSession(session);
+        }
+
+        // now let the entity update itself before insert
+        if (entity instanceof OnBeforeInsertCallback) {
+            ((OnBeforeInsertCallback) entity).onBeforeInsert();
+        }
+    }
+
     private void executeInsertInTx(SQLiteStatement stmt, Iterable<T> entities, boolean setPrimaryKey) {
         db.beginTransaction();
         try {
@@ -264,6 +278,7 @@ private void executeInsertInTx(SQLiteStatement stmt, Iterable<T> entities, boole
                 }
                 try {
                     for (T entity : entities) {
+                        callOnBeforeInsertCallback(entity);
                         bindValues(stmt, entity);
                         if (setPrimaryKey) {
                             long rowId = stmt.executeInsert();
@@ -286,7 +301,7 @@ private void executeInsertInTx(SQLiteStatement stmt, Iterable<T> entities, boole
 
     /**
      * Insert an entity into the table associated with a concrete DAO.
-     * 
+     *
      * @return row ID of newly inserted entity
      */
     public long insert(T entity) {
@@ -296,10 +311,11 @@ public long insert(T entity) {
     /**
      * Insert an entity into the table associated with a concrete DAO <b>without</b> setting key property. Warning: This
      * may be faster, but the entity should not be used anymore. The entity also won't be attached to identy scope.
-     * 
+     *
      * @return row ID of newly inserted entity
      */
     public long insertWithoutSettingPk(T entity) {
+        callOnBeforeInsertCallback(entity);
         SQLiteStatement stmt = statements.getInsertStatement();
         long rowId;
         if (db.isDbLockedByCurrentThread()) {
@@ -325,7 +341,7 @@ public long insertWithoutSettingPk(T entity) {
 
     /**
      * Insert an entity into the table associated with a concrete DAO.
-     * 
+     *
      * @return row ID of newly inserted entity
      */
     public long insertOrReplace(T entity) {
@@ -333,6 +349,7 @@ public long insertOrReplace(T entity) {
     }
 
     private long executeInsert(T entity, SQLiteStatement stmt) {
+        callOnBeforeInsertCallback(entity);
         long rowId;
         if (db.isDbLockedByCurrentThread()) {
             synchronized (stmt) {
@@ -579,7 +596,7 @@ private void deleteInTxInternal(Iterable<T> entities, Iterable<K> keys) {
 
     /**
      * Deletes the given entities in the database using a transaction.
-     * 
+     *
      * @param entities
      *            The entities to delete.
      */
@@ -589,7 +606,7 @@ public void deleteInTx(Iterable<T> entities) {
 
     /**
      * Deletes the given entities in the database using a transaction.
-     * 
+     *
      * @param entities
      *            The entities to delete.
      */
@@ -599,7 +616,7 @@ public void deleteInTx(T... entities) {
 
     /**
      * Deletes all entities with the given keys in the database using a transaction.
-     * 
+     *
      * @param keys
      *            Keys of the entities to delete.
      */
@@ -609,7 +626,7 @@ public void deleteByKeyInTx(Iterable<K> keys) {
 
     /**
      * Deletes all entities with the given keys in the database using a transaction.
-     * 
+     *
      * @param keys
      *            Keys of the entities to delete.
      */
@@ -682,7 +699,7 @@ protected void updateInsideSynchronized(T entity, SQLiteStatement stmt, boolean
 
     /**
      * Attaches the entity to the identity scope. Calls attachEntity(T entity).
-     * 
+     *
      * @param key
      *            Needed only for identity scope, pass null if there's none.
      * @param entity
@@ -702,7 +719,7 @@ protected final void attachEntity(K key, T entity, boolean lock) {
     /**
      * Sub classes with relations additionally set the DaoMaster here. Must be called before the entity is attached to
      * the identity scope.
-     * 
+     *
      * @param entity
      *            The entitiy to attach
      * */
@@ -711,7 +728,7 @@ protected void attachEntity(T entity) {
 
     /**
      * Updates the given entities in the database using a transaction.
-     * 
+     *
      * @param entities
      *            The entities to insert.
      */
@@ -741,7 +758,7 @@ public void updateInTx(Iterable<T> entities) {
 
     /**
      * Updates the given entities in the database using a transaction.
-     * 
+     *
      * @param entities
      *            The entities to update.
      */
@@ -785,7 +802,7 @@ public SQLiteDatabase getDatabase() {
    * just stores the given entity, if the primary key field is filled, it will
    * be updated, a check if the given primary key exists will be performed.
    * Otherwise it will be inserted.
-   * 
+   *
    * @see AbstractDao#save(Object, boolean)
    * @param entity
    *          the entity to save
@@ -799,7 +816,7 @@ public T save(T entity) {
    * just stores the given entity. if <code>checkExisting</code> is set to
    * <code>true</code>, it will be checked if the given entity with the given
    * primary key exists in the database
-   * 
+   *
    * @param entity
    *          the entity to save
    * @param checkExistingPK
diff --git a/DaoCore/src/de/greenrobot/dao/callbacks/ActiveEntity.java b/DaoCore/src/de/greenrobot/dao/callbacks/ActiveEntity.java
new file mode 100644
index 00000000..b296b523
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/callbacks/ActiveEntity.java
@@ -0,0 +1,8 @@
+package de.greenrobot.dao.callbacks;
+
+import de.greenrobot.dao.AbstractDaoSession;
+
+public interface ActiveEntity {
+
+    public void __setDaoSession(AbstractDaoSession daoSession);
+}
diff --git a/DaoCore/src/de/greenrobot/dao/callbacks/OnBeforeInsertCallback.java b/DaoCore/src/de/greenrobot/dao/callbacks/OnBeforeInsertCallback.java
new file mode 100644
index 00000000..993b7aa9
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/callbacks/OnBeforeInsertCallback.java
@@ -0,0 +1,6 @@
+package de.greenrobot.dao.callbacks;
+
+public interface OnBeforeInsertCallback {
+
+    public void onBeforeInsert();
+}
diff --git a/DaoGenerator/src-template/dao.ftl b/DaoGenerator/src-template/dao.ftl
index 337ad35e..0fd4addb 100644
--- a/DaoGenerator/src-template/dao.ftl
+++ b/DaoGenerator/src-template/dao.ftl
@@ -1,19 +1,19 @@
 <#--
 
-Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
-                                                                           
-This file is part of greenDAO Generator.                                   
-                                                                           
-greenDAO Generator is free software: you can redistribute it and/or modify 
-it under the terms of the GNU General Public License as published by       
-the Free Software Foundation, either version 3 of the License, or          
-(at your option) any later version.                                        
-greenDAO Generator is distributed in the hope that it will be useful,      
-but WITHOUT ANY WARRANTY; without even the implied warranty of             
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
-GNU General Public License for more details.                               
-                                                                           
-You should have received a copy of the GNU General Public License          
+Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+
+This file is part of greenDAO Generator.
+
+greenDAO Generator is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+greenDAO Generator is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
 along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
 
 -->
@@ -23,6 +23,7 @@ package ${entity.javaPackageDao};
 
 <#if entity.toOneRelations?has_content || entity.incomingToManyRelations?has_content>
 import java.util.List;
+import ${schema.defaultJavaPackageDao}.${entity.referencedClassName};
 </#if>
 <#if entity.toOneRelations?has_content || entity.hasEntityQueryBuilder>
 import java.util.ArrayList;
@@ -67,7 +68,7 @@ import ${entity.javaPackage}.${entity.className}.Builder;
 </#if>
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
-/** 
+/**
  * DAO for table ${entity.tableName}.
 */
 public class ${entity.classNameDao} extends AbstractDao<${entity.referencedClassName}, ${entity.pkType}> {
@@ -95,10 +96,10 @@ public class ${entity.classNameDao} extends AbstractDao<${entity.referencedClass
     public ${entity.classNameDao}(DaoConfig config) {
         super(config);
     }
-    
+
     public ${entity.classNameDao}(DaoConfig config, DaoSession daoSession) {
         super(config, daoSession);
-<#if entity.active>        
+<#if entity.active>
         this.daoSession = daoSession;
 </#if>
     }
@@ -115,10 +116,10 @@ public class ${entity.classNameDao} extends AbstractDao<${entity.referencedClass
         // Add Indexes
 <#list entity.indexes as index>
         db.execSQL("CREATE <#if index.unique>UNIQUE </#if>INDEX " + constraint + "${index.name} ON ${entity.tableName}" +
-                " (<#list index.properties 
+                " (<#list index.properties
 as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
 </#list>
-</#if>         
+</#if>
     }
 
     /** Drops the underlying database table. */
@@ -186,8 +187,8 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
             entity.pkProperty.propertyType == "Date">)</#if>;
 <#else>
         return null;
-</#if>  
-    }    
+</#if>
+    }
 
     /** @inheritdoc */
     @Override
@@ -200,12 +201,12 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
     </#if>        builder.set${property.propertyName?cap_first}(cursor.get${toCursorType[property.propertyType]}(offset + ${property_index}));
 <#if !property.notNull>
         }
-</#if>        
-</#list>        
+</#if>
+</#list>
         return builder.build();
 <#elseif entity.constructors && !entity.hasChildclass>
 <#--
-############################## readEntity non-protobuff, constructor ############################## 
+############################## readEntity non-protobuff, constructor ##############################
 -->
         ${entity.referencedClassName} entity = new ${entity.referencedClassName}( //
 <#list entity.properties as property>
@@ -214,25 +215,25 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
             property.propertyType == "Date">new java.util.Date(</#if>cursor.get${toCursorType[property.propertyType]}(offset + ${property_index})<#if
             property.propertyType == "Boolean"> != 0</#if><#if
             property.propertyType == "Date">)</#if><#if property_has_next>,</#if> // ${property.propertyName}
-</#list>        
+</#list>
         );
         return entity;
 <#else>
 <#--
-############################## readEntity non-protobuff, setters ############################## 
+############################## readEntity non-protobuff, setters ##############################
 -->
         ${entity.referencedClassName} entity = new ${entity.referencedClassName}();
         readEntity(cursor, entity, offset);
         return entity;
 </#if>
     }
-     
+
     /** @inheritdoc */
     @Override
     public void readEntity(Cursor cursor, ${entity.referencedClassName} entity, int offset) {
 <#if entity.protobuf>
         throw new UnsupportedOperationException("Protobuf objects cannot be modified");
-<#else> 
+<#else>
 <#list entity.properties as property>
         entity.set${property.propertyName?cap_first}(<#if !property.notNull>cursor.isNull(offset + ${property_index}) ? null : </#if><#if
             property.propertyType == "Byte">(byte) </#if><#if
@@ -242,7 +243,7 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
 </#list>
 </#if>
      }
-    
+
     /** @inheritdoc */
     @Override
     protected ${entity.pkType} updateKeyAfterInsert(${entity.referencedClassName} entity, long rowId) {
@@ -260,7 +261,7 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
         return null;
 </#if>
     }
-    
+
     /** @inheritdoc */
     @Override
     public ${entity.pkType} getKey(${entity.referencedClassName} entity) {
@@ -272,15 +273,15 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
         }
 <#else>
         return null;
-</#if>    
+</#if>
     }
 
     /** @inheritdoc */
-    @Override    
+    @Override
     protected boolean isEntityUpdateable() {
         return ${(!entity.protobuf)?string};
     }
-    
+
 <#list entity.incomingToManyRelations as toMany>
     /** Internal query to resolve the "${toMany.name}" to-many relationship of ${toMany.sourceEntity.referencedClassName}. */
     public List<${toMany.targetEntity.referencedClassName}> _query${toMany.sourceEntity.referencedClassName?cap_first}_${toMany.name?cap_first}(<#--
@@ -304,8 +305,8 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
         return query.list();
     }
 
-</#list>   
- 
+</#list>
+
 <#if entity.toOneRelations?has_content>
     <#include "dao-deep.ftl">
 </#if>
@@ -318,16 +319,16 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
         ${entity.referencedClassName}QueryBuilder(AbstractDao<${entity.referencedClassName}, ?> dao) {
             super(dao);
         }
-        
+
         public Query<${entity.referencedClassName}> findByPrimaryKey(${entity.pkProperty.propertyType} pk) {
             this.where(Properties.${entity.pkProperty.propertyName?cap_first}.eq(pk));
             return this.build();
         }
-        
+
         public Query<${entity.referencedClassName}> findAll() {
             return this.build();
         }
-        
+
         /**
          * <p>creates a {@link Query} for {@link ${entity.referencedClassName}} to find one by example.
          * <p>Just nullable fields can be used. Just set one of these properties:
@@ -341,14 +342,14 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
          *
          * @param example
          *          the entity filled with example values
-         * 
+         *
          * @return a {@link Query} to find the example entity
          */
-        public Query<${entity.referencedClassName}> findByExample(${entity.referencedClassName} example) { 
+        public Query<${entity.referencedClassName}> findByExample(${entity.referencedClassName} example) {
             if(example.get${entity.pkProperty.propertyName?cap_first}() != null) {
                 return findByPrimaryKey(example.get${entity.pkProperty.propertyName?cap_first}());
             }
-        	
+
             ArrayList<WhereCondition> conditions = new ArrayList<WhereCondition>();
 
 <#list entity.properties as property>
@@ -358,7 +359,7 @@ as property>${property.columnName}<#if property_has_next>,</#if></#list>);");
             }
   </#if>
 </#list>
-           
+
             if (conditions.isEmpty()) {
                 throw new IllegalArgumentException("No example values given. Please provide at least one value!");
             }
diff --git a/DaoGenerator/src-template/entity.ftl b/DaoGenerator/src-template/entity.ftl
index 03bb9227..0f6127b0 100644
--- a/DaoGenerator/src-template/entity.ftl
+++ b/DaoGenerator/src-template/entity.ftl
@@ -1,19 +1,19 @@
 <#--
 
-Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)     
-                                                                           
-This file is part of greenDAO Generator.                                   
-                                                                           
-greenDAO Generator is free software: you can redistribute it and/or modify 
-it under the terms of the GNU General Public License as published by       
-the Free Software Foundation, either version 3 of the License, or          
-(at your option) any later version.                                        
-greenDAO Generator is distributed in the hope that it will be useful,      
-but WITHOUT ANY WARRANTY; without even the implied warranty of             
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              
-GNU General Public License for more details.                               
-                                                                           
-You should have received a copy of the GNU General Public License          
+Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+
+This file is part of greenDAO Generator.
+
+greenDAO Generator is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+greenDAO Generator is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
 along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
 
 -->
@@ -28,6 +28,7 @@ import java.util.List;
 <#if entity.active>
 import ${schema.defaultJavaPackageDao}.DaoSession;
 import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.AbstractDaoSession;
 
 </#if>
 <#if entity.additionalImportsEntity?has_content>
@@ -42,7 +43,7 @@ import ${additionalImport};
 // KEEP INCLUDES - put your custom includes here
 <#if keepIncludes?has_content>${keepIncludes!}</#if>// KEEP INCLUDES END
 <#else>
-// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit.
 </#if>
 /**
  * Entity mapped to table ${entity.tableName}.
@@ -56,27 +57,27 @@ as ifc>${ifc}<#if ifc_has_next>, </#if></#list></#if> {
 <#if property.notNull && complexTypes?seq_contains(property.propertyType)>
     /** Not-null value. */
 </#if>
-    private ${property.javaType} ${property.propertyName};
+    protected ${property.javaType} ${property.propertyName};
 </#list>
 
 <#if entity.active>
     /** Used to resolve relations */
-    private transient DaoSession daoSession;
+    protected transient DaoSession daoSession;
 
     /** Used for active entity operations. */
-    private transient ${entity.classNameDao} myDao;
+    protected transient ${entity.classNameDao} myDao;
 
 <#list entity.toOneRelations as toOne>
-    private ${toOne.targetEntity.className} ${toOne.name};
+    protected ${toOne.targetEntity.className} ${toOne.name};
 <#if toOne.useFkProperty>
-    private ${toOne.resolvedKeyJavaType[0]} ${toOne.name}__resolvedKey;
+    protected ${toOne.resolvedKeyJavaType[0]} ${toOne.name}__resolvedKey;
 <#else>
-    private boolean ${toOne.name}__refreshed;
+    protected boolean ${toOne.name}__refreshed;
 </#if>
 
 </#list>
 <#list entity.toManyRelations as toMany>
-    private List<${toMany.targetEntity.className}> ${toMany.name};
+    protected List<${toMany.targetEntity.className}> ${toMany.name};
 </#list>
 
 </#if>
@@ -108,9 +109,9 @@ property>${property.javaType} ${property.propertyName}<#if property_has_next>, <
 
 <#if entity.active>
     /** called by internal mechanisms, do not call yourself. */
-    public void __setDaoSession(DaoSession daoSession) {
-        this.daoSession = daoSession;
-        myDao = daoSession != null ? daoSession.get${entity.classNameDao?cap_first}() : null;
+    public void __setDaoSession(AbstractDaoSession daoSession) {
+        this.daoSession = (DaoSession)daoSession;
+        myDao = this.daoSession != null ? this.daoSession.get${entity.classNameDao?cap_first}() : null;
     }
 
 </#if>
@@ -181,7 +182,7 @@ property>${property.javaType} ${property.propertyName}<#if property_has_next>, <
 </#if>
         synchronized (this) {
             this.${toOne.name} = ${toOne.name};
-<#if toOne.useFkProperty>        
+<#if toOne.useFkProperty>
             ${toOne.fkProperties[0].propertyName} = <#if !toOne.fkProperties[0].notNull>${toOne.name} == null ? null : </#if>${toOne.name}.get${toOne.targetEntity.pkProperty.propertyName?cap_first}();
             ${toOne.name}__resolvedKey = ${toOne.fkProperties[0].propertyName};
 <#else>
@@ -231,24 +232,27 @@ property>${property.javaType} ${property.propertyName}<#if property_has_next>, <
     public void delete() {
         if (myDao == null) {
             throw new DaoException("Entity is detached from DAO context");
-        }    
-        myDao.delete(this);
+        }
+        // TODO fix this
+        myDao.delete((${entity.referencedClassName})this);
     }
 
     /** Convenient call for {@link de.greenrobot.dao.AbstractDao#update(Object)}. Entity must attached to an entity context. */
     public void update() {
         if (myDao == null) {
             throw new DaoException("Entity is detached from DAO context");
-        }    
-        myDao.update(this);
+        }
+        // TODO fix this
+        myDao.update((${entity.referencedClassName})this);
     }
 
     /** Convenient call for {@link de.greenrobot.dao.AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
     public void refresh() {
         if (myDao == null) {
             throw new DaoException("Entity is detached from DAO context");
-        }    
-        myDao.refresh(this);
+        }
+        // TODO fix this
+        myDao.refresh((${entity.referencedClassName})this);
     }
 
 </#if>
