diff --git a/.gitignore b/.gitignore
index 20374e4a..b91594d1 100644
--- a/.gitignore
+++ b/.gitignore
@@ -4,3 +4,4 @@
 out/
 build/
 local.properties
+/bin/
diff --git a/CHANGELOG.md b/CHANGELOG.md
index f1548666..eea4cd15 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,13 +1,11 @@
 Release History
 ---------------
-### V2.1.0 Minor feature and bugfix release (2015-11-12, both core and generator)
+### V2.1.0 Minor feature release (2015-09-XX, both core and generator)
 * Official Robolectric support: workaround for a broken system call in Robolectric triggered by Query.forCurrentThread
-* QueryBuilder now allows to create DISTINCT queries to avoid duplicate entities returned
 * CursorQuery (beta, API might change)
-* Deadlock prevention when loading a list of entities while doing concurrent updates
 * Fixed async queries
 * Better Android Studio support
-* Generator: Possibility to supply custom JavaDoc for entities and their properties
+* Added performance tests for: ActiveAndroid, Realm, Parse
 * Generator: Fixed codeBeforeGetter, added codeBeforeGetterAndSetter
 
 ### V2.0.0 Major feature release (2015-07-30, both core and generator)
diff --git a/DaoCore/build.gradle b/DaoCore/build.gradle
index 4f3e7e2c..4978cc07 100644
--- a/DaoCore/build.gradle
+++ b/DaoCore/build.gradle
@@ -4,7 +4,7 @@ apply plugin: 'signing'
 
 group = 'de.greenrobot'
 archivesBaseName = 'greendao'
-version = '2.1.0'
+version = '2.1.0-SNAPSHOT'
 sourceCompatibility = 1.6
 
 def isSnapshot = version.endsWith('-SNAPSHOT')
@@ -45,7 +45,7 @@ javadoc {
     failOnError = false
     classpath += configurations.provided
     title = " greenDAO ${version} API"
-	options.bottom = 'Available under the Apache License, Version 2.0 - <i>Copyright &#169; 2011-2015 <a href="http://greenrobot.de/">greenrobot.de</a>. All Rights Reserved.</i>'
+	options.bottom = 'Available under the Apache License, Version 2.0 - <i>Copyright &#169; 2011-2013 <a href="http://greenrobot.de/">greenrobot.de</a>. All Rights Reserved.</i>'
 	excludes = ['de/greenrobot/dao/internal','de/greenrobot/dao/Internal*']
 }
 
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/AbstractDao.java b/DaoCore/src/main/java/de/greenrobot/dao/AbstractDao.java
index d39b306a..51349dfb 100644
--- a/DaoCore/src/main/java/de/greenrobot/dao/AbstractDao.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/AbstractDao.java
@@ -16,19 +16,17 @@
 
 package de.greenrobot.dao;
 
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+
 import android.database.CrossProcessCursor;
 import android.database.Cursor;
 import android.database.CursorWindow;
 import android.database.DatabaseUtils;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteStatement;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-
 import de.greenrobot.dao.identityscope.IdentityScope;
 import de.greenrobot.dao.identityscope.IdentityScopeLong;
 import de.greenrobot.dao.internal.DaoConfig;
@@ -39,12 +37,15 @@
 
 /**
  * Base class for all DAOs: Implements entity operations like insert, load, delete, and query.
- * <p>
+ *
  * This class is thread-safe.
  *
- * @param <T> Entity type
- * @param <K> Primary key (PK) type; use Void if entity does not have exactly one PK
  * @author Markus
+ *
+ * @param <T>
+ *            Entity type
+ * @param <K>
+ *            Primary key (PK) type; use Void if entity does not have exactly one PK
  */
 /*
  * When operating on TX, statements, or identity scope the following locking order must be met to avoid deadlocks:
@@ -117,7 +118,8 @@ public Property getPkProperty() {
     /**
      * Loads and entity for the given PK.
      *
-     * @param key a PK value or null
+     * @param key
+     *            a PK value or null
      * @return The entity or null, if no entity matched the PK value
      */
     public T load(K key) {
@@ -132,13 +134,13 @@ public T load(K key) {
             }
         }
         String sql = statements.getSelectByKey();
-        String[] keyArray = new String[]{key.toString()};
+        String[] keyArray = new String[] { key.toString() };
         Cursor cursor = db.rawQuery(sql, keyArray);
         return loadUniqueAndCloseCursor(cursor);
     }
 
     public T loadByRowId(long rowId) {
-        String[] idArray = new String[]{Long.toString(rowId)};
+        String[] idArray = new String[] { Long.toString(rowId) };
         Cursor cursor = db.rawQuery(statements.getSelectByRowId(), idArray);
         return loadUniqueAndCloseCursor(cursor);
     }
@@ -188,7 +190,8 @@ public boolean detach(T entity) {
     /**
      * Inserts the given entities in the database using a transaction.
      *
-     * @param entities The entities to insert.
+     * @param entities
+     *            The entities to insert.
      */
     public void insertInTx(Iterable<T> entities) {
         insertInTx(entities, isEntityUpdateable());
@@ -197,7 +200,8 @@ public void insertInTx(Iterable<T> entities) {
     /**
      * Inserts the given entities in the database using a transaction.
      *
-     * @param entities The entities to insert.
+     * @param entities
+     *            The entities to insert.
      */
     public void insertInTx(T... entities) {
         insertInTx(Arrays.asList(entities), isEntityUpdateable());
@@ -207,8 +211,10 @@ public void insertInTx(T... entities) {
      * Inserts the given entities in the database using a transaction. The given entities will become tracked if the PK
      * is set.
      *
-     * @param entities      The entities to insert.
-     * @param setPrimaryKey if true, the PKs of the given will be set after the insert; pass false to improve performance.
+     * @param entities
+     *            The entities to insert.
+     * @param setPrimaryKey
+     *            if true, the PKs of the given will be set after the insert; pass false to improve performance.
      */
     public void insertInTx(Iterable<T> entities, boolean setPrimaryKey) {
         SQLiteStatement stmt = statements.getInsertStatement();
@@ -219,8 +225,10 @@ public void insertInTx(Iterable<T> entities, boolean setPrimaryKey) {
      * Inserts or replaces the given entities in the database using a transaction. The given entities will become
      * tracked if the PK is set.
      *
-     * @param entities      The entities to insert.
-     * @param setPrimaryKey if true, the PKs of the given will be set after the insert; pass false to improve performance.
+     * @param entities
+     *            The entities to insert.
+     * @param setPrimaryKey
+     *            if true, the PKs of the given will be set after the insert; pass false to improve performance.
      */
     public void insertOrReplaceInTx(Iterable<T> entities, boolean setPrimaryKey) {
         SQLiteStatement stmt = statements.getInsertOrReplaceStatement();
@@ -230,7 +238,8 @@ public void insertOrReplaceInTx(Iterable<T> entities, boolean setPrimaryKey) {
     /**
      * Inserts or replaces the given entities in the database using a transaction.
      *
-     * @param entities The entities to insert.
+     * @param entities
+     *            The entities to insert.
      */
     public void insertOrReplaceInTx(Iterable<T> entities) {
         insertOrReplaceInTx(entities, isEntityUpdateable());
@@ -239,7 +248,8 @@ public void insertOrReplaceInTx(Iterable<T> entities) {
     /**
      * Inserts or replaces the given entities in the database using a transaction.
      *
-     * @param entities The entities to insert.
+     * @param entities
+     *            The entities to insert.
      */
     public void insertOrReplaceInTx(T... entities) {
         insertOrReplaceInTx(Arrays.asList(entities), isEntityUpdateable());
@@ -359,18 +369,12 @@ protected void updateKeyAfterInsertAndAttach(T entity, long rowId, boolean lock)
     /** Reads all available rows from the given cursor and returns a list of entities. */
     protected List<T> loadAllFromCursor(Cursor cursor) {
         int count = cursor.getCount();
-        if (count == 0) {
-            return Collections.EMPTY_LIST;
-        }
         List<T> list = new ArrayList<T>(count);
-        CursorWindow window = null;
-        boolean useFastCursor = false;
         if (cursor instanceof CrossProcessCursor) {
-            window = ((CrossProcessCursor) cursor).getWindow();
-            if (window != null) { // E.g. Robolectric has no Window at this point
+            CursorWindow window = ((CrossProcessCursor) cursor).getWindow();
+            if (window != null) { // E.g. Roboelectric has no Window at this point
                 if (window.getNumRows() == count) {
                     cursor = new FastCursor(window);
-                    useFastCursor = true;
                 } else {
                     DaoLog.d("Window vs. result size: " + window.getNumRows() + "/" + count);
                 }
@@ -382,15 +386,10 @@ protected void updateKeyAfterInsertAndAttach(T entity, long rowId, boolean lock)
                 identityScope.lock();
                 identityScope.reserveRoom(count);
             }
-
             try {
-                if (!useFastCursor && window != null && identityScope != null) {
-                    loadAllUnlockOnWindowBounds(cursor, window, list);
-                } else {
-                    do {
-                        list.add(loadCurrent(cursor, 0, false));
-                    } while (cursor.moveToNext());
-                }
+                do {
+                    list.add(loadCurrent(cursor, 0, false));
+                } while (cursor.moveToNext());
             } finally {
                 if (identityScope != null) {
                     identityScope.unlock();
@@ -400,42 +399,6 @@ protected void updateKeyAfterInsertAndAttach(T entity, long rowId, boolean lock)
         return list;
     }
 
-    private void loadAllUnlockOnWindowBounds(Cursor cursor, CursorWindow window, List<T> list) {
-        int windowEnd = window.getStartPosition() + window.getNumRows();
-        for (int row = 0; ; row++) {
-            list.add(loadCurrent(cursor, 0, false));
-            row++;
-            if (row >= windowEnd) {
-                window = moveToNextUnlocked(cursor);
-                if(window == null) {
-                    break;
-                }
-                windowEnd = window.getStartPosition() + window.getNumRows();
-            } else {
-                if(!cursor.moveToNext()) {
-                    break;
-                }
-            }
-        }
-    }
-
-    /**
-     * Unlock identityScope during cursor.moveToNext() when it is about to fill the window (needs a db connection):
-     * We should not hold the lock while trying to acquire a db connection to avoid deadlocks.
-     */
-    private CursorWindow moveToNextUnlocked(Cursor cursor) {
-        identityScope.unlock();
-        try {
-            if(cursor.moveToNext()) {
-                return ((CrossProcessCursor) cursor).getWindow();
-            } else {
-                return null;
-            }
-        } finally {
-            identityScope.lock();
-        }
-    }
-
     /** Internal use only. Considers identity scope. */
     final protected T loadCurrent(Cursor cursor, int offset, boolean lock) {
         if (identityScopeLong != null) {
@@ -617,7 +580,8 @@ private void deleteInTxInternal(Iterable<T> entities, Iterable<K> keys) {
     /**
      * Deletes the given entities in the database using a transaction.
      *
-     * @param entities The entities to delete.
+     * @param entities
+     *            The entities to delete.
      */
     public void deleteInTx(Iterable<T> entities) {
         deleteInTxInternal(entities, null);
@@ -626,7 +590,8 @@ public void deleteInTx(Iterable<T> entities) {
     /**
      * Deletes the given entities in the database using a transaction.
      *
-     * @param entities The entities to delete.
+     * @param entities
+     *            The entities to delete.
      */
     public void deleteInTx(T... entities) {
         deleteInTxInternal(Arrays.asList(entities), null);
@@ -635,7 +600,8 @@ public void deleteInTx(T... entities) {
     /**
      * Deletes all entities with the given keys in the database using a transaction.
      *
-     * @param keys Keys of the entities to delete.
+     * @param keys
+     *            Keys of the entities to delete.
      */
     public void deleteByKeyInTx(Iterable<K> keys) {
         deleteInTxInternal(null, keys);
@@ -644,7 +610,8 @@ public void deleteByKeyInTx(Iterable<K> keys) {
     /**
      * Deletes all entities with the given keys in the database using a transaction.
      *
-     * @param keys Keys of the entities to delete.
+     * @param keys
+     *            Keys of the entities to delete.
      */
     public void deleteByKeyInTx(K... keys) {
         deleteInTxInternal(null, Arrays.asList(keys));
@@ -655,7 +622,7 @@ public void refresh(T entity) {
         assertSinglePk();
         K key = getKeyVerified(entity);
         String sql = statements.getSelectByKey();
-        String[] keyArray = new String[]{key.toString()};
+        String[] keyArray = new String[] { key.toString() };
         Cursor cursor = db.rawQuery(sql, keyArray);
         try {
             boolean available = cursor.moveToFirst();
@@ -716,9 +683,11 @@ protected void updateInsideSynchronized(T entity, SQLiteStatement stmt, boolean
     /**
      * Attaches the entity to the identity scope. Calls attachEntity(T entity).
      *
-     * @param key    Needed only for identity scope, pass null if there's none.
-     * @param entity The entitiy to attach
-     */
+     * @param key
+     *            Needed only for identity scope, pass null if there's none.
+     * @param entity
+     *            The entitiy to attach
+     * */
     protected final void attachEntity(K key, T entity, boolean lock) {
         attachEntity(entity);
         if (identityScope != null && key != null) {
@@ -734,15 +703,17 @@ protected final void attachEntity(K key, T entity, boolean lock) {
      * Sub classes with relations additionally set the DaoMaster here. Must be called before the entity is attached to
      * the identity scope.
      *
-     * @param entity The entitiy to attach
-     */
+     * @param entity
+     *            The entitiy to attach
+     * */
     protected void attachEntity(T entity) {
     }
 
     /**
      * Updates the given entities in the database using a transaction.
      *
-     * @param entities The entities to insert.
+     * @param entities
+     *            The entities to insert.
      */
     public void updateInTx(Iterable<T> entities) {
         SQLiteStatement stmt = statements.getUpdateStatement();
@@ -783,7 +754,8 @@ public void updateInTx(Iterable<T> entities) {
     /**
      * Updates the given entities in the database using a transaction.
      *
-     * @param entities The entities to update.
+     * @param entities
+     *            The entities to update.
      */
     public void updateInTx(T... entities) {
         updateInTx(Arrays.asList(entities));
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/internal/SqlUtils.java b/DaoCore/src/main/java/de/greenrobot/dao/internal/SqlUtils.java
index 3e328bc9..b9cdf407 100644
--- a/DaoCore/src/main/java/de/greenrobot/dao/internal/SqlUtils.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/internal/SqlUtils.java
@@ -104,12 +104,12 @@ public static String createSqlInsert(String insertInto, String tablename, String
     }
 
     /** Creates an select for given columns with a trailing space */
-    public static String createSqlSelect(String tablename, String tableAlias, String[] columns, boolean distinct) {
+    public static String createSqlSelect(String tablename, String tableAlias, String[] columns) {
         if (tableAlias == null || tableAlias.length() < 0) {
             throw new DaoException("Table alias required");
         }
 
-        StringBuilder builder = new StringBuilder(distinct ? "SELECT DISTINCT " : "SELECT ");
+        StringBuilder builder = new StringBuilder("SELECT ");
         SqlUtils.appendColumns(builder, tableAlias, columns).append(" FROM ");
         builder.append('"').append(tablename).append('"').append(' ').append(tableAlias).append(' ');
         return builder.toString();
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/internal/TableStatements.java b/DaoCore/src/main/java/de/greenrobot/dao/internal/TableStatements.java
index 864b6e04..9414f1f7 100644
--- a/DaoCore/src/main/java/de/greenrobot/dao/internal/TableStatements.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/internal/TableStatements.java
@@ -77,7 +77,7 @@ public SQLiteStatement getUpdateStatement() {
     /** ends with an space to simplify appending to this string. */
     public String getSelectAll() {
         if (selectAll == null) {
-            selectAll = SqlUtils.createSqlSelect(tablename, "T", allColumns, false);
+            selectAll = SqlUtils.createSqlSelect(tablename, "T", allColumns);
         }
         return selectAll;
     }
@@ -85,7 +85,7 @@ public String getSelectAll() {
     /** ends with an space to simplify appending to this string. */
     public String getSelectKeys() {
         if (selectKeys == null) {
-            selectKeys = SqlUtils.createSqlSelect(tablename, "T", pkColumns, false);
+            selectKeys = SqlUtils.createSqlSelect(tablename, "T", pkColumns);
         }
         return selectKeys;
     }
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/query/Join.java b/DaoCore/src/main/java/de/greenrobot/dao/query/Join.java
index 04dba3fe..ab142a06 100644
--- a/DaoCore/src/main/java/de/greenrobot/dao/query/Join.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/Join.java
@@ -80,12 +80,4 @@ public WhereCondition and(WhereCondition cond1, WhereCondition cond2, WhereCondi
         return whereCollector.combineWhereConditions(" AND ", cond1, cond2, condMore);
     }
 
-    /**
-     * Usually you don't need this value; just in case you are mixing custom
-     * {@link de.greenrobot.dao.query.WhereCondition.StringCondition} into the query, this value allows to reference
-     * the joined (target) table.
-     */
-    public String getTablePrefix() {
-        return tablePrefix;
-    }
 }
diff --git a/DaoCore/src/main/java/de/greenrobot/dao/query/QueryBuilder.java b/DaoCore/src/main/java/de/greenrobot/dao/query/QueryBuilder.java
index 2e621838..e6c15ec6 100644
--- a/DaoCore/src/main/java/de/greenrobot/dao/query/QueryBuilder.java
+++ b/DaoCore/src/main/java/de/greenrobot/dao/query/QueryBuilder.java
@@ -58,7 +58,6 @@
 
     private Integer limit;
     private Integer offset;
-    private boolean distinct;
 
     /** For internal use by greenDAO only. */
     public static <T2> QueryBuilder<T2> internalCreate(AbstractDao<T2, ?> dao) {
@@ -85,12 +84,6 @@ private void checkOrderBuilder() {
         }
     }
 
-    /** Use a SELECT DISTINCT to avoid duplicate entities returned, e.g. when doing joins. */
-    public QueryBuilder<T> distinct() {
-        distinct = true;
-        return this;
-    }
-
     /**
      * Adds the given conditions to the where clause using an logical AND. To create new conditions, use the properties
      * given in the generated dao classes.
@@ -269,7 +262,7 @@ public CursorQuery buildCursor() {
     }
 
     private StringBuilder createSelectBuilder() {
-        String select = SqlUtils.createSqlSelect(dao.getTablename(), tablePrefix, dao.getAllColumns(), distinct);
+        String select = SqlUtils.createSqlSelect(dao.getTablename(), tablePrefix, dao.getAllColumns());
         StringBuilder builder = new StringBuilder(select);
 
         appendJoinsAndWheres(builder, tablePrefix);
@@ -280,6 +273,7 @@ private StringBuilder createSelectBuilder() {
         return builder;
     }
 
+
     private int checkAddLimit(StringBuilder builder) {
         int limitPosition = -1;
         if (limit != null) {
diff --git a/DaoGenerator/build.gradle b/DaoGenerator/build.gradle
index 843f8141..ccdbde8b 100644
--- a/DaoGenerator/build.gradle
+++ b/DaoGenerator/build.gradle
@@ -4,8 +4,8 @@ apply plugin: 'signing'
 
 group = 'de.greenrobot'
 archivesBaseName = 'greendao-generator'
-version = '2.1.1-SNAPSHOT'
-sourceCompatibility = 1.7
+version = '2.0.0'
+sourceCompatibility = 1.6
 
 def isSnapshot = version.endsWith('-SNAPSHOT')
 def sonatypeRepositoryUrl
@@ -27,7 +27,7 @@ configurations {
 }
 
 dependencies {
-    compile 'org.freemarker:freemarker:2.3.23'
+    compile 'org.freemarker:freemarker:2.3.22'
     testCompile 'junit:junit:4.12'
     // deployerJars 'org.apache.maven.wagon:wagon-webdav-jackrabbit:2.4'
     deployerJars 'org.apache.maven.wagon:wagon-webdav:1.0-beta-2'
diff --git a/DaoGenerator/src-template/entity.ftl b/DaoGenerator/src-template/entity.ftl
index 0e383d84..5fd44b8b 100644
--- a/DaoGenerator/src-template/entity.ftl
+++ b/DaoGenerator/src-template/entity.ftl
@@ -44,17 +44,9 @@ import ${additionalImport};
 <#else>
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
 </#if>
-<#if entity.javaDoc ??>
-
-${entity.javaDoc}
-<#else>
 /**
  * Entity mapped to table "${entity.tableName}".
  */
-</#if>
-<#if entity.codeBeforeClass ??>
-${entity.codeBeforeClass}
-</#if>
 public class ${entity.className}<#if
 entity.superclass?has_content> extends ${entity.superclass} </#if><#if
 entity.interfacesToImplement?has_content> implements <#list entity.interfacesToImplement
@@ -64,9 +56,6 @@ as ifc>${ifc}<#if ifc_has_next>, </#if></#list></#if> {
 <#if property.notNull && complexTypes?seq_contains(property.propertyType)>
     /** Not-null value. */
 </#if>
-<#if property.javaDocField ??>
-${property.javaDocField}
-</#if>
 <#if property.codeBeforeField ??>
      ${property.codeBeforeField}
 </#if>
@@ -112,6 +101,36 @@ property>${property.javaType} ${property.propertyName}<#if property_has_next>, <
     }
 </#if>
 
+<#if entity.parcelable>
+	@Override
+ 	public int describeContents() {
+ 		return 0;
+ 	}
+
+ 	@Override
+ 	public void writeToParcel(Parcel out, int flags) {
+<#list entity.properties as property>
+		${property.parcelableWriteStatement}
+</#list>
+ 	}
+
+ 	private ${entity.className}(Parcel in) {
+<#list entity.properties as property>
+		${property.parcelableReadStatement}
+</#list>
+ 	}
+
+ 	public static final Parcelable.Creator<${entity.className}> CREATOR = new Parcelable.Creator<${entity.className}>() {
+		public ${entity.className} createFromParcel(Parcel in) {
+		    return new ${entity.className}(in);
+		}
+		
+		public ${entity.className} [] newArray(int size) {
+		    return new ${entity.className}[size];
+		}
+ 	};
+</#if>
+
     public ${entity.className}(<#list entity.properties as
 property>${property.javaTypeInEntity} ${property.propertyName}<#if property_has_next>, </#if></#list>) {
 <#list entity.properties as property>
@@ -132,9 +151,6 @@ property>${property.javaTypeInEntity} ${property.propertyName}<#if property_has_
 <#if property.notNull && complexTypes?seq_contains(property.propertyType)>
     /** Not-null value. */
 </#if>
-<#if property.javaDocGetter ??>
-${property.javaDocGetter}
-</#if>
 <#if property.codeBeforeGetter ??>
     ${property.codeBeforeGetter}
 </#if>
@@ -145,9 +161,6 @@ ${property.javaDocGetter}
 <#if property.notNull && complexTypes?seq_contains(property.propertyType)>
     /** Not-null value; ensure this value is available before it is saved to the database. */
 </#if>
-<#if property.javaDocSetter ??>
-${property.javaDocSetter}
-</#if>
 <#if property.codeBeforeSetter ??>
     ${property.codeBeforeSetter}
 </#if>
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/DaoGenerator.java b/DaoGenerator/src/de/greenrobot/daogenerator/DaoGenerator.java
index bb25fe9a..0828ca40 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/DaoGenerator.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/DaoGenerator.java
@@ -28,6 +28,7 @@
 import java.util.regex.Pattern;
 
 import freemarker.template.Configuration;
+import freemarker.template.DefaultObjectWrapper;
 import freemarker.template.Template;
 
 /**
@@ -57,8 +58,9 @@ public DaoGenerator() throws IOException {
         patternKeepFields = compilePattern("FIELDS");
         patternKeepMethods = compilePattern("METHODS");
 
-        Configuration config = new Configuration(Configuration.VERSION_2_3_23);
+        Configuration config = new Configuration();
         config.setClassForTemplateLoading(this.getClass(), "/");
+        config.setObjectWrapper(new DefaultObjectWrapper());
 
         templateDao = config.getTemplate("dao.ftl");
         templateDaoMaster = config.getTemplate("dao-master.ftl");
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/DaoUtil.java b/DaoGenerator/src/de/greenrobot/daogenerator/DaoUtil.java
index a8a2e965..feb76469 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/DaoUtil.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/DaoUtil.java
@@ -104,11 +104,5 @@ public static int copyAllBytes(InputStream in, OutputStream out) throws IOExcept
         return byteCount;
     }
 
-    public static String checkConvertToJavaDoc(String javaDoc, String indent) {
-        if (javaDoc != null && !javaDoc.trim().startsWith("/**")) {
-            javaDoc = javaDoc.replace("\n", "\n" + indent + " * ");
-            javaDoc = indent + "/**\n" + indent + " * " + javaDoc + "\n" + indent + " */";
-        }
-        return javaDoc;
-    }
+
 }
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java b/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
index da865a42..2d46158e 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
@@ -17,6 +17,8 @@
  */
 package de.greenrobot.daogenerator;
 
+import de.greenrobot.daogenerator.Property.PropertyBuilder;
+
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashSet;
@@ -24,8 +26,6 @@
 import java.util.Set;
 import java.util.TreeSet;
 
-import de.greenrobot.daogenerator.Property.PropertyBuilder;
-
 /**
  * Model class for an entity: a Java data object mapped to a data base table. A new entity is added to a {@link Schema}
  * by the method {@link Schema#addEntity(String)} (there is no public constructor for {@link Entity} itself). <br/>
@@ -64,8 +64,6 @@
     private Property pkProperty;
     private String pkType;
     private String superclass;
-    private String javaDoc;
-    private String codeBeforeClass;
 
     private boolean protobuf;
     private boolean constructors;
@@ -74,6 +72,7 @@
     private boolean skipTableCreation;
     private Boolean active;
     private Boolean hasKeepSections;
+    private boolean parcelable = false;
 
     Entity(Schema schema, String className) {
         this.schema = schema;
@@ -444,41 +443,41 @@ public void setHasKeepSections(Boolean hasKeepSections) {
         return contentProviders;
     }
 
-    public void implementsInterface(String... interfaces) {
+    public Entity implementsInterface(String... interfaces) {
         for (String interfaceToImplement : interfaces) {
             if (interfacesToImplement.contains(interfaceToImplement)) {
                 throw new RuntimeException("Interface defined more than once: " + interfaceToImplement);
             }
             interfacesToImplement.add(interfaceToImplement);
         }
+        return this;
     }
 
     public void implementsSerializable() {
         interfacesToImplement.add("java.io.Serializable");
     }
+    
+    /**
+     * Generates all the Android Parcelable methods.  Only Fields marked as notNull() will be parceled.
+     * @return
+     */
+    public Entity implementsParcelable() {
+    	interfacesToImplement.add("Parcelable");
+    	parcelable = true;
+    	return addImport("android.os.*");
+    }
+    
+    public boolean isParcelable() {
+    	return parcelable;
+    }
 
     public String getSuperclass() {
         return superclass;
     }
 
-    public void setSuperclass(String classToExtend) {
+    public Entity setSuperclass(String classToExtend) {
         this.superclass = classToExtend;
-    }
-
-    public String getJavaDoc() {
-        return javaDoc;
-    }
-
-    public void setJavaDoc(String javaDoc) {
-        this.javaDoc = DaoUtil.checkConvertToJavaDoc(javaDoc, "");
-    }
-
-    public String getCodeBeforeClass() {
-        return codeBeforeClass;
-    }
-
-    public void setCodeBeforeClass(String codeBeforeClass) {
-        this.codeBeforeClass = codeBeforeClass;
+        return this;
     }
 
     void init2ndPass() {
@@ -596,6 +595,12 @@ void init3rdPass() {
         init3rdPassRelations();
         init3rdPassAdditionalImports();
     }
+    
+    void initParcelablePass() {
+    	for (Property property: properties) {
+    		property.initParcelableMethods();
+    	}
+    }
 
     private void init3rdPassRelations() {
         Set<String> toOneNames = new HashSet<String>();
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/Property.java b/DaoGenerator/src/de/greenrobot/daogenerator/Property.java
index 14534df5..3af4607a 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/Property.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/Property.java
@@ -131,32 +131,6 @@ public PropertyBuilder codeBeforeGetterAndSetter(String code) {
             return this;
         }
 
-        public PropertyBuilder javaDocField(String javaDoc) {
-            property.javaDocField = checkConvertToJavaDoc(javaDoc);
-            return this;
-        }
-
-        private String checkConvertToJavaDoc(String javaDoc) {
-            return DaoUtil.checkConvertToJavaDoc(javaDoc, "    ");
-        }
-
-        public PropertyBuilder javaDocGetter(String javaDoc) {
-            property.javaDocGetter = checkConvertToJavaDoc(javaDoc);
-            return this;
-        }
-
-        public PropertyBuilder javaDocSetter(String javaDoc) {
-            property.javaDocSetter = checkConvertToJavaDoc(javaDoc);
-            return this;
-        }
-
-        public PropertyBuilder javaDocGetterAndSetter(String javaDoc) {
-            javaDoc = checkConvertToJavaDoc(javaDoc);
-            property.javaDocGetter = javaDoc;
-            property.javaDocSetter = javaDoc;
-            return this;
-        }
-
         public Property getProperty() {
             return property;
         }
@@ -179,10 +153,6 @@ public Property getProperty() {
     private String codeBeforeGetter;
     private String codeBeforeSetter;
 
-    private String javaDocField;
-    private String javaDocGetter;
-    private String javaDocSetter;
-
     private boolean primaryKey;
     private boolean pkAsc;
     private boolean pkDesc;
@@ -197,6 +167,8 @@ public Property getProperty() {
     private int ordinal;
 
     private String javaType;
+    private String parcelableWriteStatement = "";
+    private String parcelableReadStatement = "";
 
     public Property(Schema schema, Entity entity, PropertyType propertyType, String propertyName) {
         this.schema = schema;
@@ -249,7 +221,15 @@ public String getJavaType() {
         return javaType;
     }
 
-    public String getJavaTypeInEntity() {
+    public final String getParcelableWriteStatement() {
+		return parcelableWriteStatement;
+	}
+
+	public final String getParcelableReadStatement() {
+		return parcelableReadStatement;
+	}
+
+	public String getJavaTypeInEntity() {
         if (customTypeClassName != null) {
             return customTypeClassName;
         } else {
@@ -293,18 +273,6 @@ public String getCodeBeforeSetter() {
         return codeBeforeSetter;
     }
 
-    public String getJavaDocField() {
-        return javaDocField;
-    }
-
-    public String getJavaDocGetter() {
-        return javaDocGetter;
-    }
-
-    public String getJavaDocSetter() {
-        return javaDocSetter;
-    }
-
     public String getDatabaseValueExpression() {
         return getDatabaseValueExpression(propertyName);
     }
@@ -326,9 +294,9 @@ public String getDatabaseValueExpression(String entityValue) {
         if (customType != null) {
             builder.append(')');
         }
-        if (propertyType == PropertyType.Boolean) {
+        if(propertyType == PropertyType.Boolean) {
             builder.append(" ? 1L: 0L");
-        } else if (propertyType == PropertyType.Date) {
+        } else if(propertyType == PropertyType.Date) {
             builder.append(".getTime()");
         }
         return builder.toString();
@@ -345,15 +313,16 @@ public String getEntityValueExpression(String databaseValue) {
         if (customType != null) {
             builder.append(propertyName).append("Converter.convertToEntityProperty(");
         }
-        if (propertyType == PropertyType.Byte) {
+        if(propertyType == PropertyType.Byte) {
             builder.append("(byte) ");
-        } else if (propertyType == PropertyType.Date) {
+        }else
+        if(propertyType == PropertyType.Date) {
             builder.append("new java.util.Date(");
         }
         builder.append(databaseValue);
-        if (propertyType == PropertyType.Boolean) {
+        if(propertyType == PropertyType.Boolean) {
             builder.append(" != 0");
-        } else if (propertyType == PropertyType.Date) {
+        } else if(propertyType == PropertyType.Date) {
             builder.append(")");
         }
         if (customType != null) {
@@ -412,6 +381,67 @@ private void initConstraint() {
     void init3ndPass() {
         // Nothing to do so far
     }
+    
+    void initParcelableMethods() {
+    	switch (propertyType) {
+		case Boolean:
+			if (notNull) {
+				parcelableReadStatement = propertyName + " = in.readByte() != 0;";
+				parcelableWriteStatement = "out.writeByte((byte)(" + propertyName + " ? 1 : 0));";
+			}
+			break;
+		case Byte:
+			if (notNull) {
+				parcelableReadStatement = propertyName + " = in.readByte();";
+				parcelableWriteStatement = "out.writeByte(" + propertyName + ");";
+			}
+			break;
+		case ByteArray:
+			if (notNull) {
+				parcelableReadStatement = propertyName + "in.readByteArray(" + propertyName + ");";
+				parcelableWriteStatement = "out.writeByteArray(" + propertyName + ");";
+			}
+			break;
+		case Date:
+			parcelableReadStatement = propertyName + " = new java.util.Date(in.readLong());";
+			parcelableWriteStatement = "out.writeLong(" + propertyName + " == null ? 0 : " + propertyName + ".getTime());";
+			break;
+		case Double:
+			if (notNull) {
+				parcelableReadStatement = propertyName + " = in.readDouble();";
+				parcelableWriteStatement = "out.writeDouble(" + propertyName + ");";
+			}
+			break;
+		case Float:
+			if (notNull) {
+				parcelableReadStatement = propertyName + " = in.readFloat();";
+				parcelableWriteStatement = "out.writeFloat(" + propertyName + ");";
+			}
+			break;
+		case Int:
+			if (notNull) {
+				parcelableReadStatement = propertyName + " = in.readInt();";
+				parcelableWriteStatement = "out.writeInt(" + propertyName + ");";
+			}
+			break;
+		case Long:
+			if (notNull) {
+				parcelableReadStatement = propertyName + " = in.readLong();";
+				parcelableWriteStatement = "out.writeLong(" + propertyName + ");";
+			}
+			break;
+		case Short:
+			if (notNull) {
+				parcelableReadStatement = propertyName + " = in.readInt();";
+				parcelableWriteStatement = "out.writeInt(" + propertyName + ");";
+			}
+			break;
+		case String:
+			parcelableReadStatement = propertyName + " = in.readString();";
+			parcelableWriteStatement = "out.writeString(" + propertyName + ");";
+			break;
+    	}
+    }
 
     @Override
     public String toString() {
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/Schema.java b/DaoGenerator/src/de/greenrobot/daogenerator/Schema.java
index 8351ecb5..236a1768 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/Schema.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/Schema.java
@@ -183,6 +183,9 @@ void init2ndPass() {
     void init3rdPass() {
         for (Entity entity : entities) {
             entity.init3rdPass();
+            if (entity.isParcelable()) {
+            	entity.initParcelablePass();
+            }
         }
     }
 
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/ToManyWithJoinEntity.java b/DaoGenerator/src/de/greenrobot/daogenerator/ToManyWithJoinEntity.java
index 0f897f05..75221566 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/ToManyWithJoinEntity.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/ToManyWithJoinEntity.java
@@ -45,8 +45,8 @@ public Property getTargetProperty() {
         return targetProperty;
     }
 
-    void init3rdPass() {
-        super.init3rdPass();
+    void init2ndPass() {
+        super.init2ndPass();
         List<Property> pks = sourceEntity.getPropertiesPk();
         if (pks.isEmpty()) {
             throw new RuntimeException("Source entity has no primary key, but we need it for " + this);
@@ -57,4 +57,8 @@ void init3rdPass() {
         }
     }
 
+    void init3rdPass() {
+        super.init3rdPass();
+    }
+
 }
diff --git a/DaoTest/build.gradle b/DaoTest/build.gradle
index 0947debd..74707af2 100644
--- a/DaoTest/build.gradle
+++ b/DaoTest/build.gradle
@@ -12,6 +12,7 @@ apply plugin: 'com.android.application'
 
 dependencies {
     androidTestCompile project(':DaoCore')
+    androidTestCompile project(':PerformanceTests:Common')
 
     testCompile project(':DaoCore')
     testCompile 'org.robolectric:robolectric:3.0'
diff --git a/DaoTest/src-gen/de/greenrobot/daotest/TestEntity.java b/DaoTest/src-gen/de/greenrobot/daotest/TestEntity.java
index 15863049..748cee08 100644
--- a/DaoTest/src-gen/de/greenrobot/daotest/TestEntity.java
+++ b/DaoTest/src-gen/de/greenrobot/daotest/TestEntity.java
@@ -1,17 +1,11 @@
 package de.greenrobot.daotest;
 
 // THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
-
 /**
- * This entity is used by internal tests of greenDAO.
- * (This JavaDoc is defined in the generator project.)
+ * Entity mapped to table "TEST_ENTITY".
  */
-// This is another test comment, you could also apply annotations like this
 public class TestEntity {
 
-    /**
-     * JavaDoc test field
-     */
     private Long id;
     private int simpleInt;
     private Integer simpleInteger;
@@ -52,9 +46,6 @@ public void setId(Long id) {
         this.id = id;
     }
 
-    /**
-     * JavaDoc test getter
-     */
     public int getSimpleInt() {
         return simpleInt;
     }
@@ -67,25 +58,16 @@ public Integer getSimpleInteger() {
         return simpleInteger;
     }
 
-    /**
-     * JavaDoc test setter
-     */
     public void setSimpleInteger(Integer simpleInteger) {
         this.simpleInteger = simpleInteger;
     }
 
     /** Not-null value. */
-    /**
-     * JavaDoc test getter and setter
-     */
     public String getSimpleStringNotNull() {
         return simpleStringNotNull;
     }
 
     /** Not-null value; ensure this value is available before it is saved to the database. */
-    /**
-     * JavaDoc test getter and setter
-     */
     public void setSimpleStringNotNull(String simpleStringNotNull) {
         this.simpleStringNotNull = simpleStringNotNull;
     }
diff --git a/DaoTest/src/de/greenrobot/daotest/performance/IndexedStringPerformanceTest.java b/DaoTest/src/de/greenrobot/daotest/performance/IndexedStringPerformanceTest.java
index dfb30b63..1a0822ec 100644
--- a/DaoTest/src/de/greenrobot/daotest/performance/IndexedStringPerformanceTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/performance/IndexedStringPerformanceTest.java
@@ -4,7 +4,7 @@
 import de.greenrobot.dao.test.AbstractDaoTest;
 import de.greenrobot.daotest.IndexedStringEntity;
 import de.greenrobot.daotest.IndexedStringEntityDao;
-
+import de.greenrobot.performance.StringGenerator;
 import java.util.ArrayList;
 import java.util.List;
 
diff --git a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java b/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java
index 221a80bd..a8dbcc4b 100644
--- a/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java
+++ b/DaoTest/src/de/greenrobot/daotest/query/QueryBuilderSimpleTest.java
@@ -250,14 +250,4 @@ public void testLike() {
         assertNull(entity2);
     }
 
-    public void testDistinct() {
-        TestEntity entity = insert(3).get(1);
-
-        Query<TestEntity> query = dao.queryBuilder().distinct()
-                .where(Properties.SimpleString.eq(entity.getSimpleString())).build();
-        TestEntity entity2 = query.uniqueOrThrow();
-        assertEquals(entity.getId(), entity2.getId());
-        // TODO improve test to check functionality
-    }
-
 }
diff --git a/DaoTestGenerator/src/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java b/DaoTestGenerator/src/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
index f42d1d36..88ba6080 100644
--- a/DaoTestGenerator/src/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
+++ b/DaoTestGenerator/src/de/greenrobot/daogenerator/gentest/TestDaoGenerator.java
@@ -105,13 +105,10 @@ protected void createSimpleNotNull() {
 
     protected Entity createTest() {
         Entity testEntity = schema.addEntity("TestEntity");
-        testEntity.setJavaDoc("This entity is used by internal tests of greenDAO.\n" +
-                "(This JavaDoc is defined in the generator project.)");
-        testEntity.setCodeBeforeClass("// This is another test comment, you could also apply annotations like this");
-        testEntity.addIdProperty().javaDocField("JavaDoc test field");
-        testEntity.addIntProperty("simpleInt").notNull().javaDocGetter("JavaDoc test getter");
-        testEntity.addIntProperty("simpleInteger").javaDocSetter("JavaDoc test setter");
-        testEntity.addStringProperty("simpleStringNotNull").notNull().javaDocGetterAndSetter("JavaDoc test getter and setter");
+        testEntity.addIdProperty();
+        testEntity.addIntProperty("simpleInt").notNull();
+        testEntity.addIntProperty("simpleInteger");
+        testEntity.addStringProperty("simpleStringNotNull").notNull();
         testEntity.addStringProperty("simpleString");
         testEntity.addStringProperty("indexedString").index();
         testEntity.addStringProperty("indexedStringAscUnique").indexAsc(null, true);
diff --git a/README.md b/README.md
index 5df7e694..2560bd88 100644
--- a/README.md
+++ b/README.md
@@ -1,10 +1,8 @@
-**Please help us with this short survey: http://bit.ly/greendao-survey Thanks for your support!**
-
 greenDAO
 ========
 greenDAO is a light & fast ORM solution for Android that maps objects to SQLite databases. Being highly optimized for Android, greenDAO offers great performance and consumes minimal memory.
 
-**<font size="+1">Home page, documentation, and support links: http://greenrobot.org/greendao/</font>**
+**<font size="+1">Home page, documentation, and support links: http://greendao-orm.com/</font>**
 
 [![Build Status](https://travis-ci.org/greenrobot/greenDAO.svg?branch=master)](https://travis-ci.org/greenrobot/greenDAO)
 
diff --git a/settings.gradle b/settings.gradle
index ef5f41d2..660b6cd5 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -2,4 +2,12 @@ include 'DaoCore', 'DaoGenerator', 'DaoExampleGenerator'
 include 'DaoTest' // Travis needs some Android setup for this
 include 'DaoTestGenerator'
 include ':DaoExample'
-
+include ':PerformanceTests:Common'
+include ':PerformanceTests:ActiveAndroid'
+include ':PerformanceTests:Couchbase'
+include ':PerformanceTests:Cupboard'
+include ':PerformanceTests:Firebase'
+include ':PerformanceTests:OrmLite'
+include ':PerformanceTests:Parse'
+include ':PerformanceTests:Realm'
+include ':PerformanceTests:Sqlite'
