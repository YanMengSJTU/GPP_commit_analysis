diff --git a/DaoGenerator/src-template/entity.ftl b/DaoGenerator/src-template/entity.ftl
index 45796a64..1ac0f16c 100644
--- a/DaoGenerator/src-template/entity.ftl
+++ b/DaoGenerator/src-template/entity.ftl
@@ -36,6 +36,7 @@ import ${additionalImport};
 </#list>
 
 </#if>
+
 <#if entity.hasKeepSections>
 // THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS
 
@@ -59,6 +60,13 @@ as ifc>${ifc}<#if ifc_has_next>, </#if></#list></#if> {
     private ${property.javaType} ${property.propertyName};
 </#list>
 
+<#if entity.hasEasyDatastoreIntegration>
+    public static String ds_entityName = "${entity.className}";
+<#list entity.properties as property>
+    public static String ds_${property.propertyName} = "${property.propertyName}";
+</#list>
+</#if>
+
 <#if entity.active>
     /** Used to resolve relations */
     private DaoSession daoSession;
@@ -241,6 +249,25 @@ property>${property.javaType} ${property.propertyName}<#if property_has_next>, <
     }
 
 </#if>
+
+<#if entity.hasEasyDatastoreIntegration>
+	public ${entity.className}(com.google.appengine.api.datastore.Entity entity) {
+	<#list entity.properties as property>
+		try {
+			this.${property.propertyName} = (${property.javaType}) entity.getProperty(ds_${property.propertyName});
+		} catch (Exception e) {}
+	</#list>
+	}
+	
+	public com.google.appengine.api.datastore.Entity toDatastoreEntity () {
+		com.google.appengine.api.datastore.Entity result = new com.google.appengine.api.datastore.Entity(ds_entityName);
+		<#list entity.properties as property>
+		result.setProperty(ds_${property.propertyName},this.${property.propertyName});
+		</#list>
+		return result;
+	}
+</#if>
+
 <#if entity.hasKeepSections>
     // KEEP METHODS - put your custom methods here
 ${keepMethods!}    // KEEP METHODS END
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java b/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
index 38689052..ec7d7718 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/Entity.java
@@ -27,571 +27,605 @@
 import de.greenrobot.daogenerator.Property.PropertyBuilder;
 
 /**
- * Model class for an entity: a Java data object mapped to a data base table. A new entity is added to a {@link Schema}
- * by the method {@link Schema#addEntity(String)} (there is no public constructor for {@link Entity} itself). <br/>
+ * Model class for an entity: a Java data object mapped to a data base table. A
+ * new entity is added to a {@link Schema} by the method
+ * {@link Schema#addEntity(String)} (there is no public constructor for
+ * {@link Entity} itself). <br/>
  * <br/>
- * Use the various addXXX methods to add entity properties, indexes, and relations to other entities (addToOne,
- * addToMany).<br/>
+ * Use the various addXXX methods to add entity properties, indexes, and
+ * relations to other entities (addToOne, addToMany).<br/>
  * <br/>
  * There are further configuration possibilities:
  * <ul>
- * <li>{@link Entity#implementsInterface(String...)} and {@link #implementsSerializable()} to specify interfaces the
- * entity will implement</li>
- * <li>{@link #setSuperclass(String)} to specify a class of which the entity will extend from</li>
+ * <li>{@link Entity#implementsInterface(String...)} and
+ * {@link #implementsSerializable()} to specify interfaces the entity will
+ * implement</li>
+ * <li>{@link #setSuperclass(String)} to specify a class of which the entity
+ * will extend from</li>
  * <li>Various setXXX methods</li>
  * </ul>
  * 
- * @see <a href="http://greendao-orm.com/documentation/modelling-entities/">Modelling Entities (Documentation page)</a>
- * @see <a href="http://greendao-orm.com/documentation/relations/">Relations (Documentation page)</a>
+ * @see <a
+ *      href="http://greendao-orm.com/documentation/modelling-entities/">Modelling
+ *      Entities (Documentation page)</a>
+ * @see <a href="http://greendao-orm.com/documentation/relations/">Relations
+ *      (Documentation page)</a>
  */
 public class Entity {
-    private final Schema schema;
-    private final String className;
-    private final List<Property> properties;
-    private List<Property> propertiesColumns;
-    private final List<Property> propertiesPk;
-    private final List<Property> propertiesNonPk;
-    private final Set<String> propertyNames;
-    private final List<Index> indexes;
-    private final List<ToOne> toOneRelations;
-    private final List<ToMany> toManyRelations;
-    private final List<ToMany> incomingToManyRelations;
-    private final Collection<String> additionalImportsEntity;
-    private final Collection<String> additionalImportsDao;
-    private final List<String> interfacesToImplement;
-
-    private String tableName;
-    private String classNameDao;
-    private String classNameTest;
-    private String javaPackage;
-    private String javaPackageDao;
-    private String javaPackageTest;
-    private Property pkProperty;
-    private String pkType;
-    private String superclass;
-
-    private boolean protobuf;
-    private boolean constructors;
-    private boolean skipGeneration;
-    private boolean skipGenerationTest;
-    private Boolean active;
-    private Boolean hasKeepSections;
-
-    Entity(Schema schema, String className) {
-        this.schema = schema;
-        this.className = className;
-        properties = new ArrayList<Property>();
-        propertiesPk = new ArrayList<Property>();
-        propertiesNonPk = new ArrayList<Property>();
-        propertyNames = new HashSet<String>();
-        indexes = new ArrayList<Index>();
-        toOneRelations = new ArrayList<ToOne>();
-        toManyRelations = new ArrayList<ToMany>();
-        incomingToManyRelations = new ArrayList<ToMany>();
-        additionalImportsEntity = new TreeSet<String>();
-        additionalImportsDao = new TreeSet<String>();
-        interfacesToImplement = new ArrayList<String>();
-        constructors = true;
-    }
-
-    public PropertyBuilder addBooleanProperty(String propertyName) {
-        return addProperty(PropertyType.Boolean, propertyName);
-    }
-
-    public PropertyBuilder addByteProperty(String propertyName) {
-        return addProperty(PropertyType.Byte, propertyName);
-    }
-
-    public PropertyBuilder addShortProperty(String propertyName) {
-        return addProperty(PropertyType.Short, propertyName);
-    }
-
-    public PropertyBuilder addIntProperty(String propertyName) {
-        return addProperty(PropertyType.Int, propertyName);
-    }
-
-    public PropertyBuilder addLongProperty(String propertyName) {
-        return addProperty(PropertyType.Long, propertyName);
-    }
-
-    public PropertyBuilder addFloatProperty(String propertyName) {
-        return addProperty(PropertyType.Float, propertyName);
-    }
-
-    public PropertyBuilder addDoubleProperty(String propertyName) {
-        return addProperty(PropertyType.Double, propertyName);
-    }
-
-    public PropertyBuilder addByteArrayProperty(String propertyName) {
-        return addProperty(PropertyType.ByteArray, propertyName);
-    }
-
-    public PropertyBuilder addStringProperty(String propertyName) {
-        return addProperty(PropertyType.String, propertyName);
-    }
-
-    public PropertyBuilder addDateProperty(String propertyName) {
-        return addProperty(PropertyType.Date, propertyName);
-    }
-
-    public PropertyBuilder addProperty(PropertyType propertyType, String propertyName) {
-        if (!propertyNames.add(propertyName)) {
-            throw new RuntimeException("Property already defined: " + propertyName);
-        }
-        PropertyBuilder builder = new Property.PropertyBuilder(schema, this, propertyType, propertyName);
-        properties.add(builder.getProperty());
-        return builder;
-    }
-
-    /** Adds a standard _id column required by standard Android classes, e.g. list adapters. */
-    public PropertyBuilder addIdProperty() {
-        PropertyBuilder builder = addLongProperty("id");
-        builder.columnName("_id").primaryKey();
-        return builder;
-    }
-
-    /** Adds a to-many relationship; the target entity is joined to the PK property of this entity (typically the ID). */
-    public ToMany addToMany(Entity target, Property targetProperty) {
-        Property[] targetProperties = { targetProperty };
-        return addToMany(null, target, targetProperties);
-    }
-
-    /**
-     * Convenience method for {@link Entity#addToMany(Entity, Property)} with a subsequent call to
-     * {@link ToMany#setName(String)}.
-     */
-    public ToMany addToMany(Entity target, Property targetProperty, String name) {
-        ToMany toMany = addToMany(target, targetProperty);
-        toMany.setName(name);
-        return toMany;
-    }
-
-    /**
-     * Add a to-many relationship; the target entity is joined using the given target property (of the target entity)
-     * and given source property (of this entity).
-     */
-    public ToMany addToMany(Property sourceProperty, Entity target, Property targetProperty) {
-        Property[] sourceProperties = { sourceProperty };
-        Property[] targetProperties = { targetProperty };
-        return addToMany(sourceProperties, target, targetProperties);
-    }
-
-    public ToMany addToMany(Property[] sourceProperties, Entity target, Property[] targetProperties) {
-        ToMany toMany = new ToMany(schema, this, sourceProperties, target, targetProperties);
-        toManyRelations.add(toMany);
-        target.incomingToManyRelations.add(toMany);
-        return toMany;
-    }
-
-    /**
-     * Adds a to-one relationship to the given target entity using the given given foreign key property (which belongs
-     * to this entity).
-     */
-    public ToOne addToOne(Entity target, Property fkProperty) {
-        Property[] fkProperties = { fkProperty };
-        ToOne toOne = new ToOne(schema, this, target, fkProperties, true);
-        toOneRelations.add(toOne);
-        return toOne;
-    }
-
-    /** Convenience for {@link #addToOne(Entity, Property)} with a subsequent call to {@link ToOne#setName(String)}. */
-    public ToOne addToOne(Entity target, Property fkProperty, String name) {
-        ToOne toOne = addToOne(target, fkProperty);
-        toOne.setName(name);
-        return toOne;
-    }
-
-    public ToOne addToOneWithoutProperty(String name, Entity target, String fkColumnName) {
-        return addToOneWithoutProperty(name, target, fkColumnName, false, false);
-    }
-
-    public ToOne addToOneWithoutProperty(String name, Entity target, String fkColumnName, boolean notNull,
-            boolean unique) {
-        PropertyBuilder propertyBuilder = new PropertyBuilder(schema, this, null, name);
-        if (notNull) {
-            propertyBuilder.notNull();
-        }
-        if (unique) {
-            propertyBuilder.unique();
-        }
-        propertyBuilder.columnName(fkColumnName);
-        Property column = propertyBuilder.getProperty();
-        Property[] fkColumns = { column };
-        ToOne toOne = new ToOne(schema, this, target, fkColumns, false);
-        toOne.setName(name);
-        toOneRelations.add(toOne);
-        return toOne;
-    }
-
-    protected void addIncomingToMany(ToMany toMany) {
-        incomingToManyRelations.add(toMany);
-    }
-
-    /**
-     * Adds a new index to the entity.
-     */
-    public Entity addIndex(Index index) {
-        indexes.add(index);
-        return this;
-    }
-
-    /** The entity is represented by a protocol buffers object. Requires some special actions like using builders. */
-    Entity useProtobuf() {
-        protobuf = true;
-        return this;
-    }
-
-    public boolean isProtobuf() {
-        return protobuf;
-    }
-
-    public Schema getSchema() {
-        return schema;
-    }
-
-    public String getTableName() {
-        return tableName;
-    }
-
-    public void setTableName(String tableName) {
-        this.tableName = tableName;
-    }
-
-    public String getClassName() {
-        return className;
-    }
-
-    public List<Property> getProperties() {
-        return properties;
-    }
-
-    public List<Property> getPropertiesColumns() {
-        return propertiesColumns;
-    }
-
-    public String getJavaPackage() {
-        return javaPackage;
-    }
-
-    public void setJavaPackage(String javaPackage) {
-        this.javaPackage = javaPackage;
-    }
-
-    public String getJavaPackageDao() {
-        return javaPackageDao;
-    }
-
-    public void setJavaPackageDao(String javaPackageDao) {
-        this.javaPackageDao = javaPackageDao;
-    }
-
-    public String getClassNameDao() {
-        return classNameDao;
-    }
-
-    public void setClassNameDao(String classNameDao) {
-        this.classNameDao = classNameDao;
-    }
-
-    public String getClassNameTest() {
-        return classNameTest;
-    }
-
-    public void setClassNameTest(String classNameTest) {
-        this.classNameTest = classNameTest;
-    }
-
-    public String getJavaPackageTest() {
-        return javaPackageTest;
-    }
-
-    public void setJavaPackageTest(String javaPackageTest) {
-        this.javaPackageTest = javaPackageTest;
-    }
-
-    public List<Property> getPropertiesPk() {
-        return propertiesPk;
-    }
-
-    public List<Property> getPropertiesNonPk() {
-        return propertiesNonPk;
-    }
-
-    public Property getPkProperty() {
-        return pkProperty;
-    }
-
-    public List<Index> getIndexes() {
-        return indexes;
-    }
-
-    public String getPkType() {
-        return pkType;
-    }
-
-    public boolean isConstructors() {
-        return constructors;
-    }
-
-    public void setConstructors(boolean constructors) {
-        this.constructors = constructors;
-    }
-
-    public boolean isSkipGeneration() {
-        return skipGeneration;
-    }
-
-    /**
-     * Flag if the entity's code generation should be skipped. E.g. if you need to change the class after initial
-     * generation.
-     */
-    public void setSkipGeneration(boolean skipGeneration) {
-        this.skipGeneration = skipGeneration;
-    }
-
-    public boolean isSkipGenerationTest() {
-        return skipGenerationTest;
-    }
-
-    public void setSkipGenerationTest(boolean skipGenerationTest) {
-        this.skipGenerationTest = skipGenerationTest;
-    }
-
-    public List<ToOne> getToOneRelations() {
-        return toOneRelations;
-    }
-
-    public List<ToMany> getToManyRelations() {
-        return toManyRelations;
-    }
-
-    public List<ToMany> getIncomingToManyRelations() {
-        return incomingToManyRelations;
-    }
-
-    /**
-     * Entities with relations are active, but this method allows to make the entities active even if it does not have
-     * relations.
-     */
-    public void setActive(Boolean active) {
-        this.active = active;
-    }
-
-    public Boolean getActive() {
-        return active;
-    }
-
-    public Boolean getHasKeepSections() {
-        return hasKeepSections;
-    }
-
-    public Collection<String> getAdditionalImportsEntity() {
-        return additionalImportsEntity;
-    }
-
-    public Collection<String> getAdditionalImportsDao() {
-        return additionalImportsDao;
-    }
-
-    public void setHasKeepSections(Boolean hasKeepSections) {
-        this.hasKeepSections = hasKeepSections;
-    }
-
-    public List<String> getInterfacesToImplement() {
-        return interfacesToImplement;
-    }
-
-    public void implementsInterface(String... interfaces) {
-        for (String interfaceToImplement : interfaces) {
-            interfacesToImplement.add(interfaceToImplement);
-        }
-    }
-
-    public void implementsSerializable() {
-        interfacesToImplement.add("java.io.Serializable");
-    }
-
-    public String getSuperclass() {
-        return superclass;
-    }
-
-    public void setSuperclass(String classToExtend) {
-        this.superclass = classToExtend;
-    }
-
-    void init2ndPass() {
-        init2nPassNamesWithDefaults();
-
-        for (int i = 0; i < properties.size(); i++) {
-            Property property = properties.get(i);
-            property.setOrdinal(i);
-            property.init2ndPass();
-            if (property.isPrimaryKey()) {
-                propertiesPk.add(property);
-            } else {
-                propertiesNonPk.add(property);
-            }
-        }
-
-        if (propertiesPk.size() == 1) {
-            pkProperty = propertiesPk.get(0);
-            pkType = schema.mapToJavaTypeNullable(pkProperty.getPropertyType());
-        } else {
-            pkType = "Void";
-        }
-
-        propertiesColumns = new ArrayList<Property>(properties);
-        for (ToOne toOne : toOneRelations) {
-            toOne.init2ndPass();
-            Property[] fkProperties = toOne.getFkProperties();
-            for (Property fkProperty : fkProperties) {
-                if (!propertiesColumns.contains(fkProperty)) {
-                    propertiesColumns.add(fkProperty);
-                }
-            }
-        }
-
-        for (ToMany toMany : toManyRelations) {
-            toMany.init2ndPass();
-            // Source Properties may not be virtual, so we do not need the following code:
-            // for (Property sourceProperty : toMany.getSourceProperties()) {
-            // if (!propertiesColumns.contains(sourceProperty)) {
-            // propertiesColumns.add(sourceProperty);
-            // }
-            // }
-        }
-
-        if (active == null) {
-            active = schema.isUseActiveEntitiesByDefault();
-        }
-        active |= !toOneRelations.isEmpty() || !toManyRelations.isEmpty();
-
-        if (hasKeepSections == null) {
-            hasKeepSections = schema.isHasKeepSectionsByDefault();
-        }
-
-        init2ndPassIndexNamesWithDefaults();
-    }
-
-    protected void init2nPassNamesWithDefaults() {
-        if (tableName == null) {
-            tableName = DaoUtil.dbName(className);
-        }
-
-        if (classNameDao == null) {
-            classNameDao = className + "Dao";
-        }
-        if (classNameTest == null) {
-            classNameTest = className + "Test";
-        }
-
-        if (javaPackage == null) {
-            javaPackage = schema.getDefaultJavaPackage();
-        }
-
-        if (javaPackageDao == null) {
-            javaPackageDao = schema.getDefaultJavaPackageDao();
-            if (javaPackageDao == null) {
-                javaPackageDao = javaPackage;
-            }
-        }
-        if (javaPackageTest == null) {
-            javaPackageTest = schema.getDefaultJavaPackageTest();
-            if (javaPackageTest == null) {
-                javaPackageTest = javaPackage;
-            }
-        }
-    }
-
-    protected void init2ndPassIndexNamesWithDefaults() {
-        for (int i = 0; i < indexes.size(); i++) {
-            Index index = indexes.get(i);
-            if (index.getName() == null) {
-                String indexName = "IDX_" + getTableName();
-                List<Property> properties = index.getProperties();
-                for (int j = 0; j < properties.size(); j++) {
-                    Property property = properties.get(j);
-                    indexName += "_" + property.getColumnName();
-                    if ("DESC".equalsIgnoreCase(index.getPropertiesOrder().get(j))) {
-                        indexName += "_DESC";
-                    }
-                }
-                // TODO can this get too long? how to shorten reliably without depending on the order (i)
-                index.setName(indexName);
-            }
-        }
-    }
-
-    void init3ndPass() {
-        for (Property property : properties) {
-            property.init3ndPass();
-        }
-
-        init3rdPassRelations();
-        init3rdPassAdditionalImports();
-    }
-
-    private void init3rdPassRelations() {
-        Set<String> toOneNames = new HashSet<String>();
-        for (ToOne toOne : toOneRelations) {
-            toOne.init3ndPass();
-            if (!toOneNames.add(toOne.getName().toLowerCase())) {
-                throw new RuntimeException("Duplicate name for " + toOne);
-            }
-        }
-
-        Set<String> toManyNames = new HashSet<String>();
-        for (ToMany toMany : toManyRelations) {
-            toMany.init3ndPass();
-            Entity targetEntity = toMany.getTargetEntity();
-            for (Property targetProperty : toMany.getTargetProperties()) {
-                if (!targetEntity.propertiesColumns.contains(targetProperty)) {
-                    targetEntity.propertiesColumns.add(targetProperty);
-                }
-            }
-            if (!toManyNames.add(toMany.getName().toLowerCase())) {
-                throw new RuntimeException("Duplicate name for " + toMany);
-            }
-        }
-    }
-
-    private void init3rdPassAdditionalImports() {
-        if (!javaPackage.equals(javaPackageDao)) {
-            additionalImportsEntity.add(javaPackageDao + "." + classNameDao);
-        }
-
-        for (ToOne toOne : toOneRelations) {
-            Entity targetEntity = toOne.getTargetEntity();
-            checkAdditionalImportsEntityTargetEntity(targetEntity);
-            // For deep loading
-            if (!targetEntity.getJavaPackage().equals(javaPackageDao)) {
-                additionalImportsDao.add(targetEntity.getJavaPackage() + "." + targetEntity.getClassName());
-            }
-        }
-
-        for (ToMany toMany : toManyRelations) {
-            Entity targetEntity = toMany.getTargetEntity();
-            checkAdditionalImportsEntityTargetEntity(targetEntity);
-        }
-    }
-
-    private void checkAdditionalImportsEntityTargetEntity(Entity targetEntity) {
-        if (!targetEntity.getJavaPackage().equals(javaPackage)) {
-            additionalImportsEntity.add(targetEntity.getJavaPackage() + "." + targetEntity.getClassName());
-        }
-        if (!targetEntity.getJavaPackageDao().equals(javaPackage)) {
-            additionalImportsEntity.add(targetEntity.getJavaPackageDao() + "." + targetEntity.getClassNameDao());
-        }
-    }
-
-    public void validatePropertyExists(Property property) {
-        if (!properties.contains(property)) {
-            throw new RuntimeException("Property " + property + " does not exist in " + this);
-        }
-    }
-
-    @Override
-    public String toString() {
-        return "Entity " + className + " (package: " + javaPackage + ")";
-    }
+	private final Schema				schema;
+	private final String				className;
+	private final List<Property>		properties;
+	private List<Property>				propertiesColumns;
+	private final List<Property>		propertiesPk;
+	private final List<Property>		propertiesNonPk;
+	private final Set<String>			propertyNames;
+	private final List<Index>			indexes;
+	private final List<ToOne>			toOneRelations;
+	private final List<ToMany>			toManyRelations;
+	private final List<ToMany>			incomingToManyRelations;
+	private final Collection<String>	additionalImportsEntity;
+	private final Collection<String>	additionalImportsDao;
+	private final List<String>			interfacesToImplement;
+
+	private String						tableName;
+	private String						classNameDao;
+	private String						classNameTest;
+	private String						javaPackage;
+	private String						javaPackageDao;
+	private String						javaPackageTest;
+	private Property					pkProperty;
+	private String						pkType;
+	private String						superclass;
+
+	private boolean						protobuf;
+	private boolean						constructors;
+	private boolean						skipGeneration;
+	private boolean						skipGenerationTest;
+	private Boolean						active;
+	private Boolean						hasKeepSections;
+	private Boolean						hasEasyDatastoreIntegration;
+
+	Entity(Schema schema, String className) {
+		this.schema = schema;
+		this.className = className;
+		this.properties = new ArrayList<Property>();
+		this.propertiesPk = new ArrayList<Property>();
+		this.propertiesNonPk = new ArrayList<Property>();
+		this.propertyNames = new HashSet<String>();
+		this.indexes = new ArrayList<Index>();
+		this.toOneRelations = new ArrayList<ToOne>();
+		this.toManyRelations = new ArrayList<ToMany>();
+		this.incomingToManyRelations = new ArrayList<ToMany>();
+		this.additionalImportsEntity = new TreeSet<String>();
+		this.additionalImportsDao = new TreeSet<String>();
+		this.interfacesToImplement = new ArrayList<String>();
+		this.constructors = true;
+	}
+
+	public PropertyBuilder addBooleanProperty(String propertyName) {
+		return addProperty(PropertyType.Boolean, propertyName);
+	}
+
+	public PropertyBuilder addByteProperty(String propertyName) {
+		return addProperty(PropertyType.Byte, propertyName);
+	}
+
+	public PropertyBuilder addShortProperty(String propertyName) {
+		return addProperty(PropertyType.Short, propertyName);
+	}
+
+	public PropertyBuilder addIntProperty(String propertyName) {
+		return addProperty(PropertyType.Int, propertyName);
+	}
+
+	public PropertyBuilder addLongProperty(String propertyName) {
+		return addProperty(PropertyType.Long, propertyName);
+	}
+
+	public PropertyBuilder addFloatProperty(String propertyName) {
+		return addProperty(PropertyType.Float, propertyName);
+	}
+
+	public PropertyBuilder addDoubleProperty(String propertyName) {
+		return addProperty(PropertyType.Double, propertyName);
+	}
+
+	public PropertyBuilder addByteArrayProperty(String propertyName) {
+		return addProperty(PropertyType.ByteArray, propertyName);
+	}
+
+	public PropertyBuilder addStringProperty(String propertyName) {
+		return addProperty(PropertyType.String, propertyName);
+	}
+
+	public PropertyBuilder addDateProperty(String propertyName) {
+		return addProperty(PropertyType.Date, propertyName);
+	}
+
+	public PropertyBuilder addProperty(PropertyType propertyType, String propertyName) {
+		if (!this.propertyNames.add(propertyName)) {
+			throw new RuntimeException("Property already defined: " + propertyName);
+		}
+		PropertyBuilder builder = new Property.PropertyBuilder(this.schema, this, propertyType, propertyName);
+		this.properties.add(builder.getProperty());
+		return builder;
+	}
+
+	/**
+	 * Adds a standard _id column required by standard Android classes, e.g.
+	 * list adapters.
+	 */
+	public PropertyBuilder addIdProperty() {
+		PropertyBuilder builder = addLongProperty("id");
+		builder.columnName("_id").primaryKey();
+		return builder;
+	}
+
+	/**
+	 * Adds a to-many relationship; the target entity is joined to the PK
+	 * property of this entity (typically the ID).
+	 */
+	public ToMany addToMany(Entity target, Property targetProperty) {
+		Property[] targetProperties = { targetProperty };
+		return addToMany(null, target, targetProperties);
+	}
+
+	/**
+	 * Convenience method for {@link Entity#addToMany(Entity, Property)} with a
+	 * subsequent call to {@link ToMany#setName(String)}.
+	 */
+	public ToMany addToMany(Entity target, Property targetProperty, String name) {
+		ToMany toMany = addToMany(target, targetProperty);
+		toMany.setName(name);
+		return toMany;
+	}
+
+	/**
+	 * Add a to-many relationship; the target entity is joined using the given
+	 * target property (of the target entity) and given source property (of this
+	 * entity).
+	 */
+	public ToMany addToMany(Property sourceProperty, Entity target, Property targetProperty) {
+		Property[] sourceProperties = { sourceProperty };
+		Property[] targetProperties = { targetProperty };
+		return addToMany(sourceProperties, target, targetProperties);
+	}
+
+	public ToMany addToMany(Property[] sourceProperties, Entity target, Property[] targetProperties) {
+		ToMany toMany = new ToMany(this.schema, this, sourceProperties, target, targetProperties);
+		this.toManyRelations.add(toMany);
+		target.incomingToManyRelations.add(toMany);
+		return toMany;
+	}
+
+	/**
+	 * Adds a to-one relationship to the given target entity using the given
+	 * given foreign key property (which belongs to this entity).
+	 */
+	public ToOne addToOne(Entity target, Property fkProperty) {
+		Property[] fkProperties = { fkProperty };
+		ToOne toOne = new ToOne(this.schema, this, target, fkProperties, true);
+		this.toOneRelations.add(toOne);
+		return toOne;
+	}
+
+	/**
+	 * Convenience for {@link #addToOne(Entity, Property)} with a subsequent
+	 * call to {@link ToOne#setName(String)}.
+	 */
+	public ToOne addToOne(Entity target, Property fkProperty, String name) {
+		ToOne toOne = addToOne(target, fkProperty);
+		toOne.setName(name);
+		return toOne;
+	}
+
+	public ToOne addToOneWithoutProperty(String name, Entity target, String fkColumnName) {
+		return addToOneWithoutProperty(name, target, fkColumnName, false, false);
+	}
+
+	public ToOne addToOneWithoutProperty(String name, Entity target, String fkColumnName, boolean notNull, boolean unique) {
+		PropertyBuilder propertyBuilder = new PropertyBuilder(this.schema, this, null, name);
+		if (notNull) {
+			propertyBuilder.notNull();
+		}
+		if (unique) {
+			propertyBuilder.unique();
+		}
+		propertyBuilder.columnName(fkColumnName);
+		Property column = propertyBuilder.getProperty();
+		Property[] fkColumns = { column };
+		ToOne toOne = new ToOne(this.schema, this, target, fkColumns, false);
+		toOne.setName(name);
+		this.toOneRelations.add(toOne);
+		return toOne;
+	}
+
+	protected void addIncomingToMany(ToMany toMany) {
+		this.incomingToManyRelations.add(toMany);
+	}
+
+	/**
+	 * Adds a new index to the entity.
+	 */
+	public Entity addIndex(Index index) {
+		this.indexes.add(index);
+		return this;
+	}
+
+	/**
+	 * The entity is represented by a protocol buffers object. Requires some
+	 * special actions like using builders.
+	 */
+	Entity useProtobuf() {
+		this.protobuf = true;
+		return this;
+	}
+
+	public boolean isProtobuf() {
+		return this.protobuf;
+	}
+
+	public Schema getSchema() {
+		return this.schema;
+	}
+
+	public String getTableName() {
+		return this.tableName;
+	}
+
+	public void setTableName(String tableName) {
+		this.tableName = tableName;
+	}
+
+	public String getClassName() {
+		return this.className;
+	}
+
+	public List<Property> getProperties() {
+		return this.properties;
+	}
+
+	public List<Property> getPropertiesColumns() {
+		return this.propertiesColumns;
+	}
+
+	public String getJavaPackage() {
+		return this.javaPackage;
+	}
+
+	public void setJavaPackage(String javaPackage) {
+		this.javaPackage = javaPackage;
+	}
+
+	public String getJavaPackageDao() {
+		return this.javaPackageDao;
+	}
+
+	public void setJavaPackageDao(String javaPackageDao) {
+		this.javaPackageDao = javaPackageDao;
+	}
+
+	public String getClassNameDao() {
+		return this.classNameDao;
+	}
+
+	public void setClassNameDao(String classNameDao) {
+		this.classNameDao = classNameDao;
+	}
+
+	public String getClassNameTest() {
+		return this.classNameTest;
+	}
+
+	public void setClassNameTest(String classNameTest) {
+		this.classNameTest = classNameTest;
+	}
+
+	public String getJavaPackageTest() {
+		return this.javaPackageTest;
+	}
+
+	public void setJavaPackageTest(String javaPackageTest) {
+		this.javaPackageTest = javaPackageTest;
+	}
+
+	public List<Property> getPropertiesPk() {
+		return this.propertiesPk;
+	}
+
+	public List<Property> getPropertiesNonPk() {
+		return this.propertiesNonPk;
+	}
+
+	public Property getPkProperty() {
+		return this.pkProperty;
+	}
+
+	public List<Index> getIndexes() {
+		return this.indexes;
+	}
+
+	public String getPkType() {
+		return this.pkType;
+	}
+
+	public boolean isConstructors() {
+		return this.constructors;
+	}
+
+	public void setConstructors(boolean constructors) {
+		this.constructors = constructors;
+	}
+
+	public boolean isSkipGeneration() {
+		return this.skipGeneration;
+	}
+
+	/**
+	 * Flag if the entity's code generation should be skipped. E.g. if you need
+	 * to change the class after initial generation.
+	 */
+	public void setSkipGeneration(boolean skipGeneration) {
+		this.skipGeneration = skipGeneration;
+	}
+
+	public boolean isSkipGenerationTest() {
+		return this.skipGenerationTest;
+	}
+
+	public void setSkipGenerationTest(boolean skipGenerationTest) {
+		this.skipGenerationTest = skipGenerationTest;
+	}
+
+	public List<ToOne> getToOneRelations() {
+		return this.toOneRelations;
+	}
+
+	public List<ToMany> getToManyRelations() {
+		return this.toManyRelations;
+	}
+
+	public List<ToMany> getIncomingToManyRelations() {
+		return this.incomingToManyRelations;
+	}
+
+	/**
+	 * Entities with relations are active, but this method allows to make the
+	 * entities active even if it does not have relations.
+	 */
+	public void setActive(Boolean active) {
+		this.active = active;
+	}
+
+	public Boolean getActive() {
+		return this.active;
+	}
+
+	public Boolean getHasKeepSections() {
+		return this.hasKeepSections;
+	}
+
+	public Collection<String> getAdditionalImportsEntity() {
+		return this.additionalImportsEntity;
+	}
+
+	public Collection<String> getAdditionalImportsDao() {
+		return this.additionalImportsDao;
+	}
+
+	public void setHasKeepSections(Boolean hasKeepSections) {
+		this.hasKeepSections = hasKeepSections;
+	}
+
+	public Boolean getHasEasyDatastoreIntegration() {
+		return this.hasEasyDatastoreIntegration;
+	}
+
+	public void setHasEasyDatastoreIntegration(Boolean hasEasyDatastoreIntegration) {
+		this.hasEasyDatastoreIntegration = hasEasyDatastoreIntegration;
+	}
+
+	public List<String> getInterfacesToImplement() {
+		return this.interfacesToImplement;
+	}
+
+	public void implementsInterface(String... interfaces) {
+		for (String interfaceToImplement : interfaces) {
+			this.interfacesToImplement.add(interfaceToImplement);
+		}
+	}
+
+	public void implementsSerializable() {
+		this.interfacesToImplement.add("java.io.Serializable");
+	}
+
+	public String getSuperclass() {
+		return this.superclass;
+	}
+
+	public void setSuperclass(String classToExtend) {
+		this.superclass = classToExtend;
+	}
+
+	void init2ndPass() {
+		init2nPassNamesWithDefaults();
+
+		for (int i = 0; i < this.properties.size(); i++) {
+			Property property = this.properties.get(i);
+			property.setOrdinal(i);
+			property.init2ndPass();
+			if (property.isPrimaryKey()) {
+				this.propertiesPk.add(property);
+			} else {
+				this.propertiesNonPk.add(property);
+			}
+		}
+
+		if (this.propertiesPk.size() == 1) {
+			this.pkProperty = this.propertiesPk.get(0);
+			this.pkType = this.schema.mapToJavaTypeNullable(this.pkProperty.getPropertyType());
+		} else {
+			this.pkType = "Void";
+		}
+
+		this.propertiesColumns = new ArrayList<Property>(this.properties);
+		for (ToOne toOne : this.toOneRelations) {
+			toOne.init2ndPass();
+			Property[] fkProperties = toOne.getFkProperties();
+			for (Property fkProperty : fkProperties) {
+				if (!this.propertiesColumns.contains(fkProperty)) {
+					this.propertiesColumns.add(fkProperty);
+				}
+			}
+		}
+
+		for (ToMany toMany : this.toManyRelations) {
+			toMany.init2ndPass();
+			// Source Properties may not be virtual, so we do not need the
+			// following code:
+			// for (Property sourceProperty : toMany.getSourceProperties()) {
+			// if (!propertiesColumns.contains(sourceProperty)) {
+			// propertiesColumns.add(sourceProperty);
+			// }
+			// }
+		}
+
+		if (this.active == null) {
+			this.active = this.schema.isUseActiveEntitiesByDefault();
+		}
+		this.active |= !this.toOneRelations.isEmpty() || !this.toManyRelations.isEmpty();
+
+		if (this.hasKeepSections == null) {
+			this.hasKeepSections = this.schema.isHasKeepSectionsByDefault();
+		}
+
+		if (this.hasEasyDatastoreIntegration == null) {
+			this.hasEasyDatastoreIntegration = this.schema.isHasEasyDatastoreIntegration();
+		}
+
+		init2ndPassIndexNamesWithDefaults();
+	}
+
+	protected void init2nPassNamesWithDefaults() {
+		if (this.tableName == null) {
+			this.tableName = DaoUtil.dbName(this.className);
+		}
+
+		if (this.classNameDao == null) {
+			this.classNameDao = this.className + "Dao";
+		}
+		if (this.classNameTest == null) {
+			this.classNameTest = this.className + "Test";
+		}
+
+		if (this.javaPackage == null) {
+			this.javaPackage = this.schema.getDefaultJavaPackage();
+		}
+
+		if (this.javaPackageDao == null) {
+			this.javaPackageDao = this.schema.getDefaultJavaPackageDao();
+			if (this.javaPackageDao == null) {
+				this.javaPackageDao = this.javaPackage;
+			}
+		}
+		if (this.javaPackageTest == null) {
+			this.javaPackageTest = this.schema.getDefaultJavaPackageTest();
+			if (this.javaPackageTest == null) {
+				this.javaPackageTest = this.javaPackage;
+			}
+		}
+	}
+
+	protected void init2ndPassIndexNamesWithDefaults() {
+		for (int i = 0; i < this.indexes.size(); i++) {
+			Index index = this.indexes.get(i);
+			if (index.getName() == null) {
+				String indexName = "IDX_" + getTableName();
+				List<Property> properties = index.getProperties();
+				for (int j = 0; j < properties.size(); j++) {
+					Property property = properties.get(j);
+					indexName += "_" + property.getColumnName();
+					if ("DESC".equalsIgnoreCase(index.getPropertiesOrder().get(j))) {
+						indexName += "_DESC";
+					}
+				}
+				// TODO can this get too long? how to shorten reliably without
+				// depending on the order (i)
+				index.setName(indexName);
+			}
+		}
+	}
+
+	void init3ndPass() {
+		for (Property property : this.properties) {
+			property.init3ndPass();
+		}
+
+		init3rdPassRelations();
+		init3rdPassAdditionalImports();
+	}
+
+	private void init3rdPassRelations() {
+		Set<String> toOneNames = new HashSet<String>();
+		for (ToOne toOne : this.toOneRelations) {
+			toOne.init3ndPass();
+			if (!toOneNames.add(toOne.getName().toLowerCase())) {
+				throw new RuntimeException("Duplicate name for " + toOne);
+			}
+		}
+
+		Set<String> toManyNames = new HashSet<String>();
+		for (ToMany toMany : this.toManyRelations) {
+			toMany.init3ndPass();
+			Entity targetEntity = toMany.getTargetEntity();
+			for (Property targetProperty : toMany.getTargetProperties()) {
+				if (!targetEntity.propertiesColumns.contains(targetProperty)) {
+					targetEntity.propertiesColumns.add(targetProperty);
+				}
+			}
+			if (!toManyNames.add(toMany.getName().toLowerCase())) {
+				throw new RuntimeException("Duplicate name for " + toMany);
+			}
+		}
+	}
+
+	private void init3rdPassAdditionalImports() {
+		if (!this.javaPackage.equals(this.javaPackageDao)) {
+			this.additionalImportsEntity.add(this.javaPackageDao + "." + this.classNameDao);
+		}
+
+		for (ToOne toOne : this.toOneRelations) {
+			Entity targetEntity = toOne.getTargetEntity();
+			checkAdditionalImportsEntityTargetEntity(targetEntity);
+			// For deep loading
+			if (!targetEntity.getJavaPackage().equals(this.javaPackageDao)) {
+				this.additionalImportsDao.add(targetEntity.getJavaPackage() + "." + targetEntity.getClassName());
+			}
+		}
+
+		for (ToMany toMany : this.toManyRelations) {
+			Entity targetEntity = toMany.getTargetEntity();
+			checkAdditionalImportsEntityTargetEntity(targetEntity);
+		}
+	}
+
+	private void checkAdditionalImportsEntityTargetEntity(Entity targetEntity) {
+		if (!targetEntity.getJavaPackage().equals(this.javaPackage)) {
+			this.additionalImportsEntity.add(targetEntity.getJavaPackage() + "." + targetEntity.getClassName());
+		}
+		if (!targetEntity.getJavaPackageDao().equals(this.javaPackage)) {
+			this.additionalImportsEntity.add(targetEntity.getJavaPackageDao() + "." + targetEntity.getClassNameDao());
+		}
+	}
+
+	public void validatePropertyExists(Property property) {
+		if (!this.properties.contains(property)) {
+			throw new RuntimeException("Property " + property + " does not exist in " + this);
+		}
+	}
+
+	@Override
+	public String toString() {
+		return "Entity " + this.className + " (package: " + this.javaPackage + ")";
+	}
 }
diff --git a/DaoGenerator/src/de/greenrobot/daogenerator/Schema.java b/DaoGenerator/src/de/greenrobot/daogenerator/Schema.java
index e94c58f5..fc61f8e3 100644
--- a/DaoGenerator/src/de/greenrobot/daogenerator/Schema.java
+++ b/DaoGenerator/src/de/greenrobot/daogenerator/Schema.java
@@ -28,162 +28,171 @@
  * @see <a href="http://greendao-orm.com/documentation/modelling-entities/">Modelling Entities (Documentation page)</a>
  */
 public class Schema {
-    private final int version;
-    private final String defaultJavaPackage;
-    private String defaultJavaPackageDao;
-    private String defaultJavaPackageTest;
-    private final List<Entity> entities;
-    private Map<PropertyType, String> propertyToDbType;
-    private Map<PropertyType, String> propertyToJavaTypeNotNull;
-    private Map<PropertyType, String> propertyToJavaTypeNullable;
-    private boolean hasKeepSectionsByDefault;
-    private boolean useActiveEntitiesByDefault;
-
-    public Schema(int version, String defaultJavaPackage) {
-        this.version = version;
-        this.defaultJavaPackage = defaultJavaPackage;
-        this.entities = new ArrayList<Entity>();
-        initTypeMappings();
-    }
-
-    public void enableKeepSectionsByDefault() {
-        hasKeepSectionsByDefault = true;
-    }
-
-    public void enableActiveEntitiesByDefault() {
-        useActiveEntitiesByDefault = true;
-    }
-
-    private void initTypeMappings() {
-        propertyToDbType = new HashMap<PropertyType, String>();
-        propertyToDbType.put(PropertyType.Boolean, "INTEGER");
-        propertyToDbType.put(PropertyType.Byte, "INTEGER");
-        propertyToDbType.put(PropertyType.Short, "INTEGER");
-        propertyToDbType.put(PropertyType.Int, "INTEGER");
-        propertyToDbType.put(PropertyType.Long, "INTEGER");
-        propertyToDbType.put(PropertyType.Float, "REAL");
-        propertyToDbType.put(PropertyType.Double, "REAL");
-        propertyToDbType.put(PropertyType.String, "TEXT");
-        propertyToDbType.put(PropertyType.ByteArray, "BLOB");
-        propertyToDbType.put(PropertyType.Date, "INTEGER");
-
-        propertyToJavaTypeNotNull = new HashMap<PropertyType, String>();
-        propertyToJavaTypeNotNull.put(PropertyType.Boolean, "boolean");
-        propertyToJavaTypeNotNull.put(PropertyType.Byte, "byte");
-        propertyToJavaTypeNotNull.put(PropertyType.Short, "short");
-        propertyToJavaTypeNotNull.put(PropertyType.Int, "int");
-        propertyToJavaTypeNotNull.put(PropertyType.Long, "long");
-        propertyToJavaTypeNotNull.put(PropertyType.Float, "float");
-        propertyToJavaTypeNotNull.put(PropertyType.Double, "double");
-        propertyToJavaTypeNotNull.put(PropertyType.String, "String");
-        propertyToJavaTypeNotNull.put(PropertyType.ByteArray, "byte[]");
-        propertyToJavaTypeNotNull.put(PropertyType.Date, "java.util.Date");
-
-        propertyToJavaTypeNullable = new HashMap<PropertyType, String>();
-        propertyToJavaTypeNullable.put(PropertyType.Boolean, "Boolean");
-        propertyToJavaTypeNullable.put(PropertyType.Byte, "Byte");
-        propertyToJavaTypeNullable.put(PropertyType.Short, "Short");
-        propertyToJavaTypeNullable.put(PropertyType.Int, "Integer");
-        propertyToJavaTypeNullable.put(PropertyType.Long, "Long");
-        propertyToJavaTypeNullable.put(PropertyType.Float, "Float");
-        propertyToJavaTypeNullable.put(PropertyType.Double, "Double");
-        propertyToJavaTypeNullable.put(PropertyType.String, "String");
-        propertyToJavaTypeNullable.put(PropertyType.ByteArray, "byte[]");
-        propertyToJavaTypeNullable.put(PropertyType.Date, "java.util.Date");
-    }
-
-    /**
-     * Adds a new entity to the schema. There can be multiple entities per table, but only one may be the primary entity
-     * per table to create table scripts, etc.
-     */
-    public Entity addEntity(String className) {
-        Entity entity = new Entity(this, className);
-        entities.add(entity);
-        return entity;
-    }
-
-    /**
-     * Adds a new protocol buffers entity to the schema. There can be multiple entities per table, but only one may be
-     * the primary entity per table to create table scripts, etc.
-     */
-    public Entity addProtobufEntity(String className) {
-        Entity entity = addEntity(className);
-        entity.useProtobuf();
-        return entity;
-    }
-
-    public String mapToDbType(PropertyType propertyType) {
-        return mapType(propertyToDbType, propertyType);
-    }
-
-    public String mapToJavaTypeNullable(PropertyType propertyType) {
-        return mapType(propertyToJavaTypeNullable, propertyType);
-    }
-
-    public String mapToJavaTypeNotNull(PropertyType propertyType) {
-        return mapType(propertyToJavaTypeNotNull, propertyType);
-    }
-
-    private String mapType(Map<PropertyType, String> map, PropertyType propertyType) {
-        String dbType = map.get(propertyType);
-        if (dbType == null) {
-            throw new IllegalStateException("No mapping for " + propertyType);
-        }
-        return dbType;
-    }
-
-    public int getVersion() {
-        return version;
-    }
-
-    public String getDefaultJavaPackage() {
-        return defaultJavaPackage;
-    }
-
-    public String getDefaultJavaPackageDao() {
-        return defaultJavaPackageDao;
-    }
-
-    public void setDefaultJavaPackageDao(String defaultJavaPackageDao) {
-        this.defaultJavaPackageDao = defaultJavaPackageDao;
-    }
-
-    public String getDefaultJavaPackageTest() {
-        return defaultJavaPackageTest;
-    }
-
-    public void setDefaultJavaPackageTest(String defaultJavaPackageTest) {
-        this.defaultJavaPackageTest = defaultJavaPackageTest;
-    }
-
-    public List<Entity> getEntities() {
-        return entities;
-    }
-
-    public boolean isHasKeepSectionsByDefault() {
-        return hasKeepSectionsByDefault;
-    }
-
-    public boolean isUseActiveEntitiesByDefault() {
-        return useActiveEntitiesByDefault;
-    }
-
-    void init2ndPass() {
-        if (defaultJavaPackageDao == null) {
-            defaultJavaPackageDao = defaultJavaPackage;
-        }
-        if (defaultJavaPackageTest == null) {
-            defaultJavaPackageTest = defaultJavaPackageDao;
-        }
-        for (Entity entity : entities) {
-            entity.init2ndPass();
-        }
-    }
-
-    void init3ndPass() {
-        for (Entity entity : entities) {
-            entity.init3ndPass();
-        }
-    }
+	private final int					version;
+	private final String				defaultJavaPackage;
+	private String						defaultJavaPackageDao;
+	private String						defaultJavaPackageTest;
+	private final List<Entity>			entities;
+	private Map<PropertyType, String>	propertyToDbType;
+	private Map<PropertyType, String>	propertyToJavaTypeNotNull;
+	private Map<PropertyType, String>	propertyToJavaTypeNullable;
+	private boolean						hasKeepSectionsByDefault;
+	private boolean						useActiveEntitiesByDefault;
+	private boolean						hasEasyDatastoreIntegration;
+
+	public Schema(int version, String defaultJavaPackage) {
+		this.version = version;
+		this.defaultJavaPackage = defaultJavaPackage;
+		this.entities = new ArrayList<Entity>();
+		initTypeMappings();
+	}
+
+	public void enableKeepSectionsByDefault() {
+		this.hasKeepSectionsByDefault = true;
+	}
+
+	public void enableActiveEntitiesByDefault() {
+		this.useActiveEntitiesByDefault = true;
+	}
+
+	public void hasEasyDatastoreIntegration() {
+		this.hasEasyDatastoreIntegration = true;
+	}
+
+	private void initTypeMappings() {
+		this.propertyToDbType = new HashMap<PropertyType, String>();
+		this.propertyToDbType.put(PropertyType.Boolean, "INTEGER");
+		this.propertyToDbType.put(PropertyType.Byte, "INTEGER");
+		this.propertyToDbType.put(PropertyType.Short, "INTEGER");
+		this.propertyToDbType.put(PropertyType.Int, "INTEGER");
+		this.propertyToDbType.put(PropertyType.Long, "INTEGER");
+		this.propertyToDbType.put(PropertyType.Float, "REAL");
+		this.propertyToDbType.put(PropertyType.Double, "REAL");
+		this.propertyToDbType.put(PropertyType.String, "TEXT");
+		this.propertyToDbType.put(PropertyType.ByteArray, "BLOB");
+		this.propertyToDbType.put(PropertyType.Date, "INTEGER");
+
+		this.propertyToJavaTypeNotNull = new HashMap<PropertyType, String>();
+		this.propertyToJavaTypeNotNull.put(PropertyType.Boolean, "boolean");
+		this.propertyToJavaTypeNotNull.put(PropertyType.Byte, "byte");
+		this.propertyToJavaTypeNotNull.put(PropertyType.Short, "short");
+		this.propertyToJavaTypeNotNull.put(PropertyType.Int, "int");
+		this.propertyToJavaTypeNotNull.put(PropertyType.Long, "long");
+		this.propertyToJavaTypeNotNull.put(PropertyType.Float, "float");
+		this.propertyToJavaTypeNotNull.put(PropertyType.Double, "double");
+		this.propertyToJavaTypeNotNull.put(PropertyType.String, "String");
+		this.propertyToJavaTypeNotNull.put(PropertyType.ByteArray, "byte[]");
+		this.propertyToJavaTypeNotNull.put(PropertyType.Date, "java.util.Date");
+
+		this.propertyToJavaTypeNullable = new HashMap<PropertyType, String>();
+		this.propertyToJavaTypeNullable.put(PropertyType.Boolean, "Boolean");
+		this.propertyToJavaTypeNullable.put(PropertyType.Byte, "Byte");
+		this.propertyToJavaTypeNullable.put(PropertyType.Short, "Short");
+		this.propertyToJavaTypeNullable.put(PropertyType.Int, "Integer");
+		this.propertyToJavaTypeNullable.put(PropertyType.Long, "Long");
+		this.propertyToJavaTypeNullable.put(PropertyType.Float, "Float");
+		this.propertyToJavaTypeNullable.put(PropertyType.Double, "Double");
+		this.propertyToJavaTypeNullable.put(PropertyType.String, "String");
+		this.propertyToJavaTypeNullable.put(PropertyType.ByteArray, "byte[]");
+		this.propertyToJavaTypeNullable.put(PropertyType.Date, "java.util.Date");
+	}
+
+	/**
+	 * Adds a new entity to the schema. There can be multiple entities per table, but only one may be the primary entity
+	 * per table to create table scripts, etc.
+	 */
+	public Entity addEntity(String className) {
+		Entity entity = new Entity(this, className);
+		this.entities.add(entity);
+		return entity;
+	}
+
+	/**
+	 * Adds a new protocol buffers entity to the schema. There can be multiple entities per table, but only one may be
+	 * the primary entity per table to create table scripts, etc.
+	 */
+	public Entity addProtobufEntity(String className) {
+		Entity entity = addEntity(className);
+		entity.useProtobuf();
+		return entity;
+	}
+
+	public String mapToDbType(PropertyType propertyType) {
+		return mapType(this.propertyToDbType, propertyType);
+	}
+
+	public String mapToJavaTypeNullable(PropertyType propertyType) {
+		return mapType(this.propertyToJavaTypeNullable, propertyType);
+	}
+
+	public String mapToJavaTypeNotNull(PropertyType propertyType) {
+		return mapType(this.propertyToJavaTypeNotNull, propertyType);
+	}
+
+	private String mapType(Map<PropertyType, String> map, PropertyType propertyType) {
+		String dbType = map.get(propertyType);
+		if (dbType == null) {
+			throw new IllegalStateException("No mapping for " + propertyType);
+		}
+		return dbType;
+	}
+
+	public int getVersion() {
+		return this.version;
+	}
+
+	public String getDefaultJavaPackage() {
+		return this.defaultJavaPackage;
+	}
+
+	public String getDefaultJavaPackageDao() {
+		return this.defaultJavaPackageDao;
+	}
+
+	public void setDefaultJavaPackageDao(String defaultJavaPackageDao) {
+		this.defaultJavaPackageDao = defaultJavaPackageDao;
+	}
+
+	public String getDefaultJavaPackageTest() {
+		return this.defaultJavaPackageTest;
+	}
+
+	public void setDefaultJavaPackageTest(String defaultJavaPackageTest) {
+		this.defaultJavaPackageTest = defaultJavaPackageTest;
+	}
+
+	public List<Entity> getEntities() {
+		return this.entities;
+	}
+
+	public boolean isHasKeepSectionsByDefault() {
+		return this.hasKeepSectionsByDefault;
+	}
+
+	public boolean isUseActiveEntitiesByDefault() {
+		return this.useActiveEntitiesByDefault;
+	}
+
+	public boolean isHasEasyDatastoreIntegration() {
+		return this.hasEasyDatastoreIntegration;
+	}
+
+	void init2ndPass() {
+		if (this.defaultJavaPackageDao == null) {
+			this.defaultJavaPackageDao = this.defaultJavaPackage;
+		}
+		if (this.defaultJavaPackageTest == null) {
+			this.defaultJavaPackageTest = this.defaultJavaPackageDao;
+		}
+		for (Entity entity : this.entities) {
+			entity.init2ndPass();
+		}
+	}
+
+	void init3ndPass() {
+		for (Entity entity : this.entities) {
+			entity.init3ndPass();
+		}
+	}
 
 }
