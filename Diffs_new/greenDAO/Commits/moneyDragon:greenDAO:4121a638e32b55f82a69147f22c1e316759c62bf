diff --git a/DaoCore/.classpath b/DaoCore/.classpath
index 7bc01d9a..b76ec6cd 100644
--- a/DaoCore/.classpath
+++ b/DaoCore/.classpath
@@ -1,9 +1,9 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/DaoExample/.classpath b/DaoExample/.classpath
index 6a988e59..ae7fcfa8 100644
--- a/DaoExample/.classpath
+++ b/DaoExample/.classpath
@@ -1,11 +1,11 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="src" path="src-gen"/>
-	<classpathentry kind="src" path="src-test"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src-gen"/>
+	<classpathentry kind="src" path="src-test"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/AmericanNeighbour.java b/DaoExample/src-gen/de/greenrobot/daoexample/AmericanNeighbour.java
new file mode 100644
index 00000000..df8d297e
--- /dev/null
+++ b/DaoExample/src-gen/de/greenrobot/daoexample/AmericanNeighbour.java
@@ -0,0 +1,90 @@
+package de.greenrobot.daoexample;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table AMERICAN_NEIGHBOUR.
+ */
+public class AmericanNeighbour {
+
+    private Long id;
+    private Integer channel_id;
+    private String request_url;
+    private String reponse;
+    private Integer list_index;
+    private Integer update_time;
+    private Integer operation_type;
+
+    public AmericanNeighbour() {
+    }
+
+    public AmericanNeighbour(Long id) {
+        this.id = id;
+    }
+
+    public AmericanNeighbour(Long id, Integer channel_id, String request_url, String reponse, Integer list_index, Integer update_time, Integer operation_type) {
+        this.id = id;
+        this.channel_id = channel_id;
+        this.request_url = request_url;
+        this.reponse = reponse;
+        this.list_index = list_index;
+        this.update_time = update_time;
+        this.operation_type = operation_type;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public Integer getChannel_id() {
+        return channel_id;
+    }
+
+    public void setChannel_id(Integer channel_id) {
+        this.channel_id = channel_id;
+    }
+
+    public String getRequest_url() {
+        return request_url;
+    }
+
+    public void setRequest_url(String request_url) {
+        this.request_url = request_url;
+    }
+
+    public String getReponse() {
+        return reponse;
+    }
+
+    public void setReponse(String reponse) {
+        this.reponse = reponse;
+    }
+
+    public Integer getList_index() {
+        return list_index;
+    }
+
+    public void setList_index(Integer list_index) {
+        this.list_index = list_index;
+    }
+
+    public Integer getUpdate_time() {
+        return update_time;
+    }
+
+    public void setUpdate_time(Integer update_time) {
+        this.update_time = update_time;
+    }
+
+    public Integer getOperation_type() {
+        return operation_type;
+    }
+
+    public void setOperation_type(Integer operation_type) {
+        this.operation_type = operation_type;
+    }
+
+}
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/AmericanNeighbourDao.java b/DaoExample/src-gen/de/greenrobot/daoexample/AmericanNeighbourDao.java
new file mode 100644
index 00000000..9790b968
--- /dev/null
+++ b/DaoExample/src-gen/de/greenrobot/daoexample/AmericanNeighbourDao.java
@@ -0,0 +1,160 @@
+package de.greenrobot.daoexample;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daoexample.AmericanNeighbour;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table AMERICAN_NEIGHBOUR.
+*/
+public class AmericanNeighbourDao extends AbstractDao<AmericanNeighbour, Long> {
+
+    public static final String TABLENAME = "AMERICAN_NEIGHBOUR";
+
+    /**
+     * Properties of entity AmericanNeighbour.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property Channel_id = new Property(1, Integer.class, "channel_id", false, "CHANNEL_ID");
+        public final static Property Request_url = new Property(2, String.class, "request_url", false, "REQUEST_URL");
+        public final static Property Reponse = new Property(3, String.class, "reponse", false, "REPONSE");
+        public final static Property List_index = new Property(4, Integer.class, "list_index", false, "LIST_INDEX");
+        public final static Property Update_time = new Property(5, Integer.class, "update_time", false, "UPDATE_TIME");
+        public final static Property Operation_type = new Property(6, Integer.class, "operation_type", false, "OPERATION_TYPE");
+    };
+
+
+    public AmericanNeighbourDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public AmericanNeighbourDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'AMERICAN_NEIGHBOUR' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'CHANNEL_ID' INTEGER," + // 1: channel_id
+                "'REQUEST_URL' TEXT," + // 2: request_url
+                "'REPONSE' TEXT," + // 3: reponse
+                "'LIST_INDEX' INTEGER," + // 4: list_index
+                "'UPDATE_TIME' INTEGER," + // 5: update_time
+                "'OPERATION_TYPE' INTEGER);"); // 6: operation_type
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'AMERICAN_NEIGHBOUR'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, AmericanNeighbour entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+ 
+        Integer channel_id = entity.getChannel_id();
+        if (channel_id != null) {
+            stmt.bindLong(2, channel_id);
+        }
+ 
+        String request_url = entity.getRequest_url();
+        if (request_url != null) {
+            stmt.bindString(3, request_url);
+        }
+ 
+        String reponse = entity.getReponse();
+        if (reponse != null) {
+            stmt.bindString(4, reponse);
+        }
+ 
+        Integer list_index = entity.getList_index();
+        if (list_index != null) {
+            stmt.bindLong(5, list_index);
+        }
+ 
+        Integer update_time = entity.getUpdate_time();
+        if (update_time != null) {
+            stmt.bindLong(6, update_time);
+        }
+ 
+        Integer operation_type = entity.getOperation_type();
+        if (operation_type != null) {
+            stmt.bindLong(7, operation_type);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public AmericanNeighbour readEntity(Cursor cursor, int offset) {
+        AmericanNeighbour entity = new AmericanNeighbour( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.isNull(offset + 1) ? null : cursor.getInt(offset + 1), // channel_id
+            cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2), // request_url
+            cursor.isNull(offset + 3) ? null : cursor.getString(offset + 3), // reponse
+            cursor.isNull(offset + 4) ? null : cursor.getInt(offset + 4), // list_index
+            cursor.isNull(offset + 5) ? null : cursor.getInt(offset + 5), // update_time
+            cursor.isNull(offset + 6) ? null : cursor.getInt(offset + 6) // operation_type
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, AmericanNeighbour entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setChannel_id(cursor.isNull(offset + 1) ? null : cursor.getInt(offset + 1));
+        entity.setRequest_url(cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2));
+        entity.setReponse(cursor.isNull(offset + 3) ? null : cursor.getString(offset + 3));
+        entity.setList_index(cursor.isNull(offset + 4) ? null : cursor.getInt(offset + 4));
+        entity.setUpdate_time(cursor.isNull(offset + 5) ? null : cursor.getInt(offset + 5));
+        entity.setOperation_type(cursor.isNull(offset + 6) ? null : cursor.getInt(offset + 6));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(AmericanNeighbour entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(AmericanNeighbour entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/ApkDownload.java b/DaoExample/src-gen/de/greenrobot/daoexample/ApkDownload.java
new file mode 100644
index 00000000..bfc784a8
--- /dev/null
+++ b/DaoExample/src-gen/de/greenrobot/daoexample/ApkDownload.java
@@ -0,0 +1,146 @@
+package de.greenrobot.daoexample;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table APK_DOWNLOAD.
+ */
+public class ApkDownload {
+
+    private String package_name;
+    private Integer version;
+    private String tip;
+    private String name;
+    private Integer downing_state;
+    private Integer total_filesize;
+    private Integer download_beginning;
+    private Integer downloaded_size;
+    private Integer download_percent;
+    private Integer create_time;
+    private String download_url;
+    private String save_dir;
+    private String save_name;
+
+    public ApkDownload() {
+    }
+
+    public ApkDownload(String package_name, Integer version, String tip, String name, Integer downing_state, Integer total_filesize, Integer download_beginning, Integer downloaded_size, Integer download_percent, Integer create_time, String download_url, String save_dir, String save_name) {
+        this.package_name = package_name;
+        this.version = version;
+        this.tip = tip;
+        this.name = name;
+        this.downing_state = downing_state;
+        this.total_filesize = total_filesize;
+        this.download_beginning = download_beginning;
+        this.downloaded_size = downloaded_size;
+        this.download_percent = download_percent;
+        this.create_time = create_time;
+        this.download_url = download_url;
+        this.save_dir = save_dir;
+        this.save_name = save_name;
+    }
+
+    public String getPackage_name() {
+        return package_name;
+    }
+
+    public void setPackage_name(String package_name) {
+        this.package_name = package_name;
+    }
+
+    public Integer getVersion() {
+        return version;
+    }
+
+    public void setVersion(Integer version) {
+        this.version = version;
+    }
+
+    public String getTip() {
+        return tip;
+    }
+
+    public void setTip(String tip) {
+        this.tip = tip;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public Integer getDowning_state() {
+        return downing_state;
+    }
+
+    public void setDowning_state(Integer downing_state) {
+        this.downing_state = downing_state;
+    }
+
+    public Integer getTotal_filesize() {
+        return total_filesize;
+    }
+
+    public void setTotal_filesize(Integer total_filesize) {
+        this.total_filesize = total_filesize;
+    }
+
+    public Integer getDownload_beginning() {
+        return download_beginning;
+    }
+
+    public void setDownload_beginning(Integer download_beginning) {
+        this.download_beginning = download_beginning;
+    }
+
+    public Integer getDownloaded_size() {
+        return downloaded_size;
+    }
+
+    public void setDownloaded_size(Integer downloaded_size) {
+        this.downloaded_size = downloaded_size;
+    }
+
+    public Integer getDownload_percent() {
+        return download_percent;
+    }
+
+    public void setDownload_percent(Integer download_percent) {
+        this.download_percent = download_percent;
+    }
+
+    public Integer getCreate_time() {
+        return create_time;
+    }
+
+    public void setCreate_time(Integer create_time) {
+        this.create_time = create_time;
+    }
+
+    public String getDownload_url() {
+        return download_url;
+    }
+
+    public void setDownload_url(String download_url) {
+        this.download_url = download_url;
+    }
+
+    public String getSave_dir() {
+        return save_dir;
+    }
+
+    public void setSave_dir(String save_dir) {
+        this.save_dir = save_dir;
+    }
+
+    public String getSave_name() {
+        return save_name;
+    }
+
+    public void setSave_name(String save_name) {
+        this.save_name = save_name;
+    }
+
+}
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/ApkDownloadDao.java b/DaoExample/src-gen/de/greenrobot/daoexample/ApkDownloadDao.java
new file mode 100644
index 00000000..b526007a
--- /dev/null
+++ b/DaoExample/src-gen/de/greenrobot/daoexample/ApkDownloadDao.java
@@ -0,0 +1,210 @@
+package de.greenrobot.daoexample;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daoexample.ApkDownload;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table APK_DOWNLOAD.
+*/
+public class ApkDownloadDao extends AbstractDao<ApkDownload, Void> {
+
+    public static final String TABLENAME = "APK_DOWNLOAD";
+
+    /**
+     * Properties of entity ApkDownload.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Package_name = new Property(0, String.class, "package_name", false, "PACKAGE_NAME");
+        public final static Property Version = new Property(1, Integer.class, "version", false, "VERSION");
+        public final static Property Tip = new Property(2, String.class, "tip", false, "TIP");
+        public final static Property Name = new Property(3, String.class, "name", false, "NAME");
+        public final static Property Downing_state = new Property(4, Integer.class, "downing_state", false, "DOWNING_STATE");
+        public final static Property Total_filesize = new Property(5, Integer.class, "total_filesize", false, "TOTAL_FILESIZE");
+        public final static Property Download_beginning = new Property(6, Integer.class, "download_beginning", false, "DOWNLOAD_BEGINNING");
+        public final static Property Downloaded_size = new Property(7, Integer.class, "downloaded_size", false, "DOWNLOADED_SIZE");
+        public final static Property Download_percent = new Property(8, Integer.class, "download_percent", false, "DOWNLOAD_PERCENT");
+        public final static Property Create_time = new Property(9, Integer.class, "create_time", false, "CREATE_TIME");
+        public final static Property Download_url = new Property(10, String.class, "download_url", false, "DOWNLOAD_URL");
+        public final static Property Save_dir = new Property(11, String.class, "save_dir", false, "SAVE_DIR");
+        public final static Property Save_name = new Property(12, String.class, "save_name", false, "SAVE_NAME");
+    };
+
+
+    public ApkDownloadDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public ApkDownloadDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'APK_DOWNLOAD' (" + //
+                "'PACKAGE_NAME' TEXT," + // 0: package_name
+                "'VERSION' INTEGER," + // 1: version
+                "'TIP' TEXT," + // 2: tip
+                "'NAME' TEXT," + // 3: name
+                "'DOWNING_STATE' INTEGER," + // 4: downing_state
+                "'TOTAL_FILESIZE' INTEGER," + // 5: total_filesize
+                "'DOWNLOAD_BEGINNING' INTEGER," + // 6: download_beginning
+                "'DOWNLOADED_SIZE' INTEGER," + // 7: downloaded_size
+                "'DOWNLOAD_PERCENT' INTEGER," + // 8: download_percent
+                "'CREATE_TIME' INTEGER," + // 9: create_time
+                "'DOWNLOAD_URL' TEXT," + // 10: download_url
+                "'SAVE_DIR' TEXT," + // 11: save_dir
+                "'SAVE_NAME' TEXT);"); // 12: save_name
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'APK_DOWNLOAD'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, ApkDownload entity) {
+        stmt.clearBindings();
+ 
+        String package_name = entity.getPackage_name();
+        if (package_name != null) {
+            stmt.bindString(1, package_name);
+        }
+ 
+        Integer version = entity.getVersion();
+        if (version != null) {
+            stmt.bindLong(2, version);
+        }
+ 
+        String tip = entity.getTip();
+        if (tip != null) {
+            stmt.bindString(3, tip);
+        }
+ 
+        String name = entity.getName();
+        if (name != null) {
+            stmt.bindString(4, name);
+        }
+ 
+        Integer downing_state = entity.getDowning_state();
+        if (downing_state != null) {
+            stmt.bindLong(5, downing_state);
+        }
+ 
+        Integer total_filesize = entity.getTotal_filesize();
+        if (total_filesize != null) {
+            stmt.bindLong(6, total_filesize);
+        }
+ 
+        Integer download_beginning = entity.getDownload_beginning();
+        if (download_beginning != null) {
+            stmt.bindLong(7, download_beginning);
+        }
+ 
+        Integer downloaded_size = entity.getDownloaded_size();
+        if (downloaded_size != null) {
+            stmt.bindLong(8, downloaded_size);
+        }
+ 
+        Integer download_percent = entity.getDownload_percent();
+        if (download_percent != null) {
+            stmt.bindLong(9, download_percent);
+        }
+ 
+        Integer create_time = entity.getCreate_time();
+        if (create_time != null) {
+            stmt.bindLong(10, create_time);
+        }
+ 
+        String download_url = entity.getDownload_url();
+        if (download_url != null) {
+            stmt.bindString(11, download_url);
+        }
+ 
+        String save_dir = entity.getSave_dir();
+        if (save_dir != null) {
+            stmt.bindString(12, save_dir);
+        }
+ 
+        String save_name = entity.getSave_name();
+        if (save_name != null) {
+            stmt.bindString(13, save_name);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Void readKey(Cursor cursor, int offset) {
+        return null;
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public ApkDownload readEntity(Cursor cursor, int offset) {
+        ApkDownload entity = new ApkDownload( //
+            cursor.isNull(offset + 0) ? null : cursor.getString(offset + 0), // package_name
+            cursor.isNull(offset + 1) ? null : cursor.getInt(offset + 1), // version
+            cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2), // tip
+            cursor.isNull(offset + 3) ? null : cursor.getString(offset + 3), // name
+            cursor.isNull(offset + 4) ? null : cursor.getInt(offset + 4), // downing_state
+            cursor.isNull(offset + 5) ? null : cursor.getInt(offset + 5), // total_filesize
+            cursor.isNull(offset + 6) ? null : cursor.getInt(offset + 6), // download_beginning
+            cursor.isNull(offset + 7) ? null : cursor.getInt(offset + 7), // downloaded_size
+            cursor.isNull(offset + 8) ? null : cursor.getInt(offset + 8), // download_percent
+            cursor.isNull(offset + 9) ? null : cursor.getInt(offset + 9), // create_time
+            cursor.isNull(offset + 10) ? null : cursor.getString(offset + 10), // download_url
+            cursor.isNull(offset + 11) ? null : cursor.getString(offset + 11), // save_dir
+            cursor.isNull(offset + 12) ? null : cursor.getString(offset + 12) // save_name
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, ApkDownload entity, int offset) {
+        entity.setPackage_name(cursor.isNull(offset + 0) ? null : cursor.getString(offset + 0));
+        entity.setVersion(cursor.isNull(offset + 1) ? null : cursor.getInt(offset + 1));
+        entity.setTip(cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2));
+        entity.setName(cursor.isNull(offset + 3) ? null : cursor.getString(offset + 3));
+        entity.setDowning_state(cursor.isNull(offset + 4) ? null : cursor.getInt(offset + 4));
+        entity.setTotal_filesize(cursor.isNull(offset + 5) ? null : cursor.getInt(offset + 5));
+        entity.setDownload_beginning(cursor.isNull(offset + 6) ? null : cursor.getInt(offset + 6));
+        entity.setDownloaded_size(cursor.isNull(offset + 7) ? null : cursor.getInt(offset + 7));
+        entity.setDownload_percent(cursor.isNull(offset + 8) ? null : cursor.getInt(offset + 8));
+        entity.setCreate_time(cursor.isNull(offset + 9) ? null : cursor.getInt(offset + 9));
+        entity.setDownload_url(cursor.isNull(offset + 10) ? null : cursor.getString(offset + 10));
+        entity.setSave_dir(cursor.isNull(offset + 11) ? null : cursor.getString(offset + 11));
+        entity.setSave_name(cursor.isNull(offset + 12) ? null : cursor.getString(offset + 12));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Void updateKeyAfterInsert(ApkDownload entity, long rowId) {
+        // Unsupported or missing PK type
+        return null;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Void getKey(ApkDownload entity) {
+        return null;
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/Customer.java b/DaoExample/src-gen/de/greenrobot/daoexample/Customer.java
index ed2996f7..8ed39287 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/Customer.java
+++ b/DaoExample/src-gen/de/greenrobot/daoexample/Customer.java
@@ -1,107 +1,107 @@
-package de.greenrobot.daoexample;
-
-import java.util.List;
-import de.greenrobot.daoexample.DaoSession;
-import de.greenrobot.dao.DaoException;
-
-// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
-/**
- * Entity mapped to table CUSTOMER.
- */
-public class Customer {
-
-    private Long id;
-    /** Not-null value. */
-    private String name;
-
-    /** Used to resolve relations */
-    private transient DaoSession daoSession;
-
-    /** Used for active entity operations. */
-    private transient CustomerDao myDao;
-
-    private List<Order> orders;
-
-    public Customer() {
-    }
-
-    public Customer(Long id) {
-        this.id = id;
-    }
-
-    public Customer(Long id, String name) {
-        this.id = id;
-        this.name = name;
-    }
-
-    /** called by internal mechanisms, do not call yourself. */
-    public void __setDaoSession(DaoSession daoSession) {
-        this.daoSession = daoSession;
-        myDao = daoSession != null ? daoSession.getCustomerDao() : null;
-    }
-
-    public Long getId() {
-        return id;
-    }
-
-    public void setId(Long id) {
-        this.id = id;
-    }
-
-    /** Not-null value. */
-    public String getName() {
-        return name;
-    }
-
-    /** Not-null value; ensure this value is available before it is saved to the database. */
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
-    public List<Order> getOrders() {
-        if (orders == null) {
-            if (daoSession == null) {
-                throw new DaoException("Entity is detached from DAO context");
-            }
-            OrderDao targetDao = daoSession.getOrderDao();
-            List<Order> ordersNew = targetDao._queryCustomer_Orders(id);
-            synchronized (this) {
-                if(orders == null) {
-                    orders = ordersNew;
-                }
-            }
-        }
-        return orders;
-    }
-
-    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
-    public synchronized void resetOrders() {
-        orders = null;
-    }
-
-    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
-    public void delete() {
-        if (myDao == null) {
-            throw new DaoException("Entity is detached from DAO context");
-        }    
-        myDao.delete(this);
-    }
-
-    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
-    public void update() {
-        if (myDao == null) {
-            throw new DaoException("Entity is detached from DAO context");
-        }    
-        myDao.update(this);
-    }
-
-    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
-    public void refresh() {
-        if (myDao == null) {
-            throw new DaoException("Entity is detached from DAO context");
-        }    
-        myDao.refresh(this);
-    }
-
-}
+package de.greenrobot.daoexample;
+
+import java.util.List;
+import de.greenrobot.daoexample.DaoSession;
+import de.greenrobot.dao.DaoException;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table CUSTOMER.
+ */
+public class Customer {
+
+    private Long id;
+    /** Not-null value. */
+    private String name;
+
+    /** Used to resolve relations */
+    private transient DaoSession daoSession;
+
+    /** Used for active entity operations. */
+    private transient CustomerDao myDao;
+
+    private List<Order> orders;
+
+    public Customer() {
+    }
+
+    public Customer(Long id) {
+        this.id = id;
+    }
+
+    public Customer(Long id, String name) {
+        this.id = id;
+        this.name = name;
+    }
+
+    /** called by internal mechanisms, do not call yourself. */
+    public void __setDaoSession(DaoSession daoSession) {
+        this.daoSession = daoSession;
+        myDao = daoSession != null ? daoSession.getCustomerDao() : null;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    /** Not-null value. */
+    public String getName() {
+        return name;
+    }
+
+    /** Not-null value; ensure this value is available before it is saved to the database. */
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
+    public List<Order> getOrders() {
+        if (orders == null) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            OrderDao targetDao = daoSession.getOrderDao();
+            List<Order> ordersNew = targetDao._queryCustomer_Orders(id);
+            synchronized (this) {
+                if(orders == null) {
+                    orders = ordersNew;
+                }
+            }
+        }
+        return orders;
+    }
+
+    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
+    public synchronized void resetOrders() {
+        orders = null;
+    }
+
+    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
+    public void delete() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.delete(this);
+    }
+
+    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
+    public void update() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.update(this);
+    }
+
+    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
+    public void refresh() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.refresh(this);
+    }
+
+}
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/CustomerDao.java b/DaoExample/src-gen/de/greenrobot/daoexample/CustomerDao.java
index 25a88fc3..30711e36 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/CustomerDao.java
+++ b/DaoExample/src-gen/de/greenrobot/daoexample/CustomerDao.java
@@ -1,120 +1,120 @@
-package de.greenrobot.daoexample;
-
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
-
-import de.greenrobot.dao.AbstractDao;
-import de.greenrobot.dao.Property;
-import de.greenrobot.dao.internal.DaoConfig;
-
-import de.greenrobot.daoexample.Customer;
-
-// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
-/** 
- * DAO for table CUSTOMER.
-*/
-public class CustomerDao extends AbstractDao<Customer, Long> {
-
-    public static final String TABLENAME = "CUSTOMER";
-
-    /**
-     * Properties of entity Customer.<br/>
-     * Can be used for QueryBuilder and for referencing column names.
-    */
-    public static class Properties {
-        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
-        public final static Property Name = new Property(1, String.class, "name", false, "NAME");
-    };
-
-    private DaoSession daoSession;
-
-
-    public CustomerDao(DaoConfig config) {
-        super(config);
-    }
-    
-    public CustomerDao(DaoConfig config, DaoSession daoSession) {
-        super(config, daoSession);
-        this.daoSession = daoSession;
-    }
-
-    /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
-        String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'CUSTOMER' (" + //
-                "'_id' INTEGER PRIMARY KEY ," + // 0: id
-                "'NAME' TEXT NOT NULL );"); // 1: name
-    }
-
-    /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'CUSTOMER'";
-        db.execSQL(sql);
-    }
-
-    /** @inheritdoc */
-    @Override
-    protected void bindValues(SQLiteStatement stmt, Customer entity) {
-        stmt.clearBindings();
- 
-        Long id = entity.getId();
-        if (id != null) {
-            stmt.bindLong(1, id);
-        }
-        stmt.bindString(2, entity.getName());
-    }
-
-    @Override
-    protected void attachEntity(Customer entity) {
-        super.attachEntity(entity);
-        entity.__setDaoSession(daoSession);
-    }
-
-    /** @inheritdoc */
-    @Override
-    public Long readKey(Cursor cursor, int offset) {
-        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
-    }    
-
-    /** @inheritdoc */
-    @Override
-    public Customer readEntity(Cursor cursor, int offset) {
-        Customer entity = new Customer( //
-            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
-            cursor.getString(offset + 1) // name
-        );
-        return entity;
-    }
-     
-    /** @inheritdoc */
-    @Override
-    public void readEntity(Cursor cursor, Customer entity, int offset) {
-        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
-        entity.setName(cursor.getString(offset + 1));
-     }
-    
-    /** @inheritdoc */
-    @Override
-    protected Long updateKeyAfterInsert(Customer entity, long rowId) {
-        entity.setId(rowId);
-        return rowId;
-    }
-    
-    /** @inheritdoc */
-    @Override
-    public Long getKey(Customer entity) {
-        if(entity != null) {
-            return entity.getId();
-        } else {
-            return null;
-        }
-    }
-
-    /** @inheritdoc */
-    @Override    
-    protected boolean isEntityUpdateable() {
-        return true;
-    }
-    
-}
+package de.greenrobot.daoexample;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daoexample.Customer;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table CUSTOMER.
+*/
+public class CustomerDao extends AbstractDao<Customer, Long> {
+
+    public static final String TABLENAME = "CUSTOMER";
+
+    /**
+     * Properties of entity Customer.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property Name = new Property(1, String.class, "name", false, "NAME");
+    };
+
+    private DaoSession daoSession;
+
+
+    public CustomerDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public CustomerDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+        this.daoSession = daoSession;
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'CUSTOMER' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'NAME' TEXT NOT NULL );"); // 1: name
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'CUSTOMER'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, Customer entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+        stmt.bindString(2, entity.getName());
+    }
+
+    @Override
+    protected void attachEntity(Customer entity) {
+        super.attachEntity(entity);
+        entity.__setDaoSession(daoSession);
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public Customer readEntity(Cursor cursor, int offset) {
+        Customer entity = new Customer( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.getString(offset + 1) // name
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, Customer entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setName(cursor.getString(offset + 1));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(Customer entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(Customer entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/DaoMaster.java b/DaoExample/src-gen/de/greenrobot/daoexample/DaoMaster.java
index 53627f13..96d3170a 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/DaoMaster.java
+++ b/DaoExample/src-gen/de/greenrobot/daoexample/DaoMaster.java
@@ -1,78 +1,98 @@
-package de.greenrobot.daoexample;
-
-import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteDatabase.CursorFactory;
-import android.database.sqlite.SQLiteOpenHelper;
-import android.util.Log;
-import de.greenrobot.dao.AbstractDaoMaster;
-import de.greenrobot.dao.identityscope.IdentityScopeType;
-
-import de.greenrobot.daoexample.NoteDao;
-import de.greenrobot.daoexample.CustomerDao;
-import de.greenrobot.daoexample.OrderDao;
-
-// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
-/** 
- * Master of DAO (schema version 1000): knows all DAOs.
-*/
-public class DaoMaster extends AbstractDaoMaster {
-    public static final int SCHEMA_VERSION = 1000;
-
-    /** Creates underlying database table using DAOs. */
-    public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
-        NoteDao.createTable(db, ifNotExists);
-        CustomerDao.createTable(db, ifNotExists);
-        OrderDao.createTable(db, ifNotExists);
-    }
-    
-    /** Drops underlying database table using DAOs. */
-    public static void dropAllTables(SQLiteDatabase db, boolean ifExists) {
-        NoteDao.dropTable(db, ifExists);
-        CustomerDao.dropTable(db, ifExists);
-        OrderDao.dropTable(db, ifExists);
-    }
-    
-    public static abstract class OpenHelper extends SQLiteOpenHelper {
-
-        public OpenHelper(Context context, String name, CursorFactory factory) {
-            super(context, name, factory, SCHEMA_VERSION);
-        }
-
-        @Override
-        public void onCreate(SQLiteDatabase db) {
-            Log.i("greenDAO", "Creating tables for schema version " + SCHEMA_VERSION);
-            createAllTables(db, false);
-        }
-    }
-    
-    /** WARNING: Drops all table on Upgrade! Use only during development. */
-    public static class DevOpenHelper extends OpenHelper {
-        public DevOpenHelper(Context context, String name, CursorFactory factory) {
-            super(context, name, factory);
-        }
-
-        @Override
-        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-            Log.i("greenDAO", "Upgrading schema from version " + oldVersion + " to " + newVersion + " by dropping all tables");
-            dropAllTables(db, true);
-            onCreate(db);
-        }
-    }
-
-    public DaoMaster(SQLiteDatabase db) {
-        super(db, SCHEMA_VERSION);
-        registerDaoClass(NoteDao.class);
-        registerDaoClass(CustomerDao.class);
-        registerDaoClass(OrderDao.class);
-    }
-    
-    public DaoSession newSession() {
-        return new DaoSession(db, IdentityScopeType.Session, daoConfigMap);
-    }
-    
-    public DaoSession newSession(IdentityScopeType type) {
-        return new DaoSession(db, type, daoConfigMap);
-    }
-    
-}
+package de.greenrobot.daoexample;
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteDatabase.CursorFactory;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.util.Log;
+import de.greenrobot.dao.AbstractDaoMaster;
+import de.greenrobot.dao.identityscope.IdentityScopeType;
+
+import de.greenrobot.daoexample.NoteDao;
+import de.greenrobot.daoexample.CustomerDao;
+import de.greenrobot.daoexample.OrderDao;
+import de.greenrobot.daoexample.LocalMediaDao;
+import de.greenrobot.daoexample.LocalPlayHistoryDao;
+import de.greenrobot.daoexample.AmericanNeighbourDao;
+import de.greenrobot.daoexample.ApkDownloadDao;
+import de.greenrobot.daoexample.PlayHistoryDao;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * Master of DAO (schema version 1000): knows all DAOs.
+*/
+public class DaoMaster extends AbstractDaoMaster {
+    public static final int SCHEMA_VERSION = 1000;
+
+    /** Creates underlying database table using DAOs. */
+    public static void createAllTables(SQLiteDatabase db, boolean ifNotExists) {
+        NoteDao.createTable(db, ifNotExists);
+        CustomerDao.createTable(db, ifNotExists);
+        OrderDao.createTable(db, ifNotExists);
+        LocalMediaDao.createTable(db, ifNotExists);
+        LocalPlayHistoryDao.createTable(db, ifNotExists);
+        AmericanNeighbourDao.createTable(db, ifNotExists);
+        ApkDownloadDao.createTable(db, ifNotExists);
+        PlayHistoryDao.createTable(db, ifNotExists);
+    }
+    
+    /** Drops underlying database table using DAOs. */
+    public static void dropAllTables(SQLiteDatabase db, boolean ifExists) {
+        NoteDao.dropTable(db, ifExists);
+        CustomerDao.dropTable(db, ifExists);
+        OrderDao.dropTable(db, ifExists);
+        LocalMediaDao.dropTable(db, ifExists);
+        LocalPlayHistoryDao.dropTable(db, ifExists);
+        AmericanNeighbourDao.dropTable(db, ifExists);
+        ApkDownloadDao.dropTable(db, ifExists);
+        PlayHistoryDao.dropTable(db, ifExists);
+    }
+    
+    public static abstract class OpenHelper extends SQLiteOpenHelper {
+
+        public OpenHelper(Context context, String name, CursorFactory factory) {
+            super(context, name, factory, SCHEMA_VERSION);
+        }
+
+        @Override
+        public void onCreate(SQLiteDatabase db) {
+            Log.i("greenDAO", "Creating tables for schema version " + SCHEMA_VERSION);
+            createAllTables(db, false);
+        }
+    }
+    
+    /** WARNING: Drops all table on Upgrade! Use only during development. */
+    public static class DevOpenHelper extends OpenHelper {
+        public DevOpenHelper(Context context, String name, CursorFactory factory) {
+            super(context, name, factory);
+        }
+
+        @Override
+        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+            Log.i("greenDAO", "Upgrading schema from version " + oldVersion + " to " + newVersion + " by dropping all tables");
+            dropAllTables(db, true);
+            onCreate(db);
+        }
+    }
+
+    public DaoMaster(SQLiteDatabase db) {
+        super(db, SCHEMA_VERSION);
+        registerDaoClass(NoteDao.class);
+        registerDaoClass(CustomerDao.class);
+        registerDaoClass(OrderDao.class);
+        registerDaoClass(LocalMediaDao.class);
+        registerDaoClass(LocalPlayHistoryDao.class);
+        registerDaoClass(AmericanNeighbourDao.class);
+        registerDaoClass(ApkDownloadDao.class);
+        registerDaoClass(PlayHistoryDao.class);
+    }
+    
+    public DaoSession newSession() {
+        return new DaoSession(db, IdentityScopeType.Session, daoConfigMap);
+    }
+    
+    public DaoSession newSession(IdentityScopeType type) {
+        return new DaoSession(db, type, daoConfigMap);
+    }
+    
+}
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/DaoSession.java b/DaoExample/src-gen/de/greenrobot/daoexample/DaoSession.java
index e6d19f42..3a06784a 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/DaoSession.java
+++ b/DaoExample/src-gen/de/greenrobot/daoexample/DaoSession.java
@@ -1,77 +1,147 @@
-package de.greenrobot.daoexample;
-
-import android.database.sqlite.SQLiteDatabase;
-
-import java.util.Map;
-
-import de.greenrobot.dao.AbstractDao;
-import de.greenrobot.dao.AbstractDaoSession;
-import de.greenrobot.dao.identityscope.IdentityScopeType;
-import de.greenrobot.dao.internal.DaoConfig;
-
-import de.greenrobot.daoexample.Note;
-import de.greenrobot.daoexample.Customer;
-import de.greenrobot.daoexample.Order;
-
-import de.greenrobot.daoexample.NoteDao;
-import de.greenrobot.daoexample.CustomerDao;
-import de.greenrobot.daoexample.OrderDao;
-
-// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
-
-/**
- * {@inheritDoc}
- * 
- * @see de.greenrobot.dao.AbstractDaoSession
- */
-public class DaoSession extends AbstractDaoSession {
-
-    private final DaoConfig noteDaoConfig;
-    private final DaoConfig customerDaoConfig;
-    private final DaoConfig orderDaoConfig;
-
-    private final NoteDao noteDao;
-    private final CustomerDao customerDao;
-    private final OrderDao orderDao;
-
-    public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>
-            daoConfigMap) {
-        super(db);
-
-        noteDaoConfig = daoConfigMap.get(NoteDao.class).clone();
-        noteDaoConfig.initIdentityScope(type);
-
-        customerDaoConfig = daoConfigMap.get(CustomerDao.class).clone();
-        customerDaoConfig.initIdentityScope(type);
-
-        orderDaoConfig = daoConfigMap.get(OrderDao.class).clone();
-        orderDaoConfig.initIdentityScope(type);
-
-        noteDao = new NoteDao(noteDaoConfig, this);
-        customerDao = new CustomerDao(customerDaoConfig, this);
-        orderDao = new OrderDao(orderDaoConfig, this);
-
-        registerDao(Note.class, noteDao);
-        registerDao(Customer.class, customerDao);
-        registerDao(Order.class, orderDao);
-    }
-    
-    public void clear() {
-        noteDaoConfig.getIdentityScope().clear();
-        customerDaoConfig.getIdentityScope().clear();
-        orderDaoConfig.getIdentityScope().clear();
-    }
-
-    public NoteDao getNoteDao() {
-        return noteDao;
-    }
-
-    public CustomerDao getCustomerDao() {
-        return customerDao;
-    }
-
-    public OrderDao getOrderDao() {
-        return orderDao;
-    }
-
-}
+package de.greenrobot.daoexample;
+
+import android.database.sqlite.SQLiteDatabase;
+
+import java.util.Map;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.AbstractDaoSession;
+import de.greenrobot.dao.identityscope.IdentityScopeType;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daoexample.Note;
+import de.greenrobot.daoexample.Customer;
+import de.greenrobot.daoexample.Order;
+import de.greenrobot.daoexample.LocalMedia;
+import de.greenrobot.daoexample.LocalPlayHistory;
+import de.greenrobot.daoexample.AmericanNeighbour;
+import de.greenrobot.daoexample.ApkDownload;
+import de.greenrobot.daoexample.PlayHistory;
+
+import de.greenrobot.daoexample.NoteDao;
+import de.greenrobot.daoexample.CustomerDao;
+import de.greenrobot.daoexample.OrderDao;
+import de.greenrobot.daoexample.LocalMediaDao;
+import de.greenrobot.daoexample.LocalPlayHistoryDao;
+import de.greenrobot.daoexample.AmericanNeighbourDao;
+import de.greenrobot.daoexample.ApkDownloadDao;
+import de.greenrobot.daoexample.PlayHistoryDao;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+
+/**
+ * {@inheritDoc}
+ * 
+ * @see de.greenrobot.dao.AbstractDaoSession
+ */
+public class DaoSession extends AbstractDaoSession {
+
+    private final DaoConfig noteDaoConfig;
+    private final DaoConfig customerDaoConfig;
+    private final DaoConfig orderDaoConfig;
+    private final DaoConfig localMediaDaoConfig;
+    private final DaoConfig localPlayHistoryDaoConfig;
+    private final DaoConfig americanNeighbourDaoConfig;
+    private final DaoConfig apkDownloadDaoConfig;
+    private final DaoConfig playHistoryDaoConfig;
+
+    private final NoteDao noteDao;
+    private final CustomerDao customerDao;
+    private final OrderDao orderDao;
+    private final LocalMediaDao localMediaDao;
+    private final LocalPlayHistoryDao localPlayHistoryDao;
+    private final AmericanNeighbourDao americanNeighbourDao;
+    private final ApkDownloadDao apkDownloadDao;
+    private final PlayHistoryDao playHistoryDao;
+
+    public DaoSession(SQLiteDatabase db, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>
+            daoConfigMap) {
+        super(db);
+
+        noteDaoConfig = daoConfigMap.get(NoteDao.class).clone();
+        noteDaoConfig.initIdentityScope(type);
+
+        customerDaoConfig = daoConfigMap.get(CustomerDao.class).clone();
+        customerDaoConfig.initIdentityScope(type);
+
+        orderDaoConfig = daoConfigMap.get(OrderDao.class).clone();
+        orderDaoConfig.initIdentityScope(type);
+
+        localMediaDaoConfig = daoConfigMap.get(LocalMediaDao.class).clone();
+        localMediaDaoConfig.initIdentityScope(type);
+
+        localPlayHistoryDaoConfig = daoConfigMap.get(LocalPlayHistoryDao.class).clone();
+        localPlayHistoryDaoConfig.initIdentityScope(type);
+
+        americanNeighbourDaoConfig = daoConfigMap.get(AmericanNeighbourDao.class).clone();
+        americanNeighbourDaoConfig.initIdentityScope(type);
+
+        apkDownloadDaoConfig = daoConfigMap.get(ApkDownloadDao.class).clone();
+        apkDownloadDaoConfig.initIdentityScope(type);
+
+        playHistoryDaoConfig = daoConfigMap.get(PlayHistoryDao.class).clone();
+        playHistoryDaoConfig.initIdentityScope(type);
+
+        noteDao = new NoteDao(noteDaoConfig, this);
+        customerDao = new CustomerDao(customerDaoConfig, this);
+        orderDao = new OrderDao(orderDaoConfig, this);
+        localMediaDao = new LocalMediaDao(localMediaDaoConfig, this);
+        localPlayHistoryDao = new LocalPlayHistoryDao(localPlayHistoryDaoConfig, this);
+        americanNeighbourDao = new AmericanNeighbourDao(americanNeighbourDaoConfig, this);
+        apkDownloadDao = new ApkDownloadDao(apkDownloadDaoConfig, this);
+        playHistoryDao = new PlayHistoryDao(playHistoryDaoConfig, this);
+
+        registerDao(Note.class, noteDao);
+        registerDao(Customer.class, customerDao);
+        registerDao(Order.class, orderDao);
+        registerDao(LocalMedia.class, localMediaDao);
+        registerDao(LocalPlayHistory.class, localPlayHistoryDao);
+        registerDao(AmericanNeighbour.class, americanNeighbourDao);
+        registerDao(ApkDownload.class, apkDownloadDao);
+        registerDao(PlayHistory.class, playHistoryDao);
+    }
+    
+    public void clear() {
+        noteDaoConfig.getIdentityScope().clear();
+        customerDaoConfig.getIdentityScope().clear();
+        orderDaoConfig.getIdentityScope().clear();
+        localMediaDaoConfig.getIdentityScope().clear();
+        localPlayHistoryDaoConfig.getIdentityScope().clear();
+        americanNeighbourDaoConfig.getIdentityScope().clear();
+        apkDownloadDaoConfig.getIdentityScope().clear();
+        playHistoryDaoConfig.getIdentityScope().clear();
+    }
+
+    public NoteDao getNoteDao() {
+        return noteDao;
+    }
+
+    public CustomerDao getCustomerDao() {
+        return customerDao;
+    }
+
+    public OrderDao getOrderDao() {
+        return orderDao;
+    }
+
+    public LocalMediaDao getLocalMediaDao() {
+        return localMediaDao;
+    }
+
+    public LocalPlayHistoryDao getLocalPlayHistoryDao() {
+        return localPlayHistoryDao;
+    }
+
+    public AmericanNeighbourDao getAmericanNeighbourDao() {
+        return americanNeighbourDao;
+    }
+
+    public ApkDownloadDao getApkDownloadDao() {
+        return apkDownloadDao;
+    }
+
+    public PlayHistoryDao getPlayHistoryDao() {
+        return playHistoryDao;
+    }
+
+}
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/LocalMedia.java b/DaoExample/src-gen/de/greenrobot/daoexample/LocalMedia.java
new file mode 100644
index 00000000..de8f18da
--- /dev/null
+++ b/DaoExample/src-gen/de/greenrobot/daoexample/LocalMedia.java
@@ -0,0 +1,60 @@
+package de.greenrobot.daoexample;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table LOCAL_MEDIA.
+ */
+public class LocalMedia {
+
+    private Long id;
+    private String dir;
+    private String file;
+    private Integer size;
+
+    public LocalMedia() {
+    }
+
+    public LocalMedia(Long id) {
+        this.id = id;
+    }
+
+    public LocalMedia(Long id, String dir, String file, Integer size) {
+        this.id = id;
+        this.dir = dir;
+        this.file = file;
+        this.size = size;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public String getDir() {
+        return dir;
+    }
+
+    public void setDir(String dir) {
+        this.dir = dir;
+    }
+
+    public String getFile() {
+        return file;
+    }
+
+    public void setFile(String file) {
+        this.file = file;
+    }
+
+    public Integer getSize() {
+        return size;
+    }
+
+    public void setSize(Integer size) {
+        this.size = size;
+    }
+
+}
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/LocalMediaDao.java b/DaoExample/src-gen/de/greenrobot/daoexample/LocalMediaDao.java
new file mode 100644
index 00000000..93ca1078
--- /dev/null
+++ b/DaoExample/src-gen/de/greenrobot/daoexample/LocalMediaDao.java
@@ -0,0 +1,133 @@
+package de.greenrobot.daoexample;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daoexample.LocalMedia;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table LOCAL_MEDIA.
+*/
+public class LocalMediaDao extends AbstractDao<LocalMedia, Long> {
+
+    public static final String TABLENAME = "LOCAL_MEDIA";
+
+    /**
+     * Properties of entity LocalMedia.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property Dir = new Property(1, String.class, "dir", false, "DIR");
+        public final static Property File = new Property(2, String.class, "file", false, "FILE");
+        public final static Property Size = new Property(3, Integer.class, "size", false, "SIZE");
+    };
+
+
+    public LocalMediaDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public LocalMediaDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'LOCAL_MEDIA' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'DIR' TEXT," + // 1: dir
+                "'FILE' TEXT," + // 2: file
+                "'SIZE' INTEGER);"); // 3: size
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'LOCAL_MEDIA'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, LocalMedia entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+ 
+        String dir = entity.getDir();
+        if (dir != null) {
+            stmt.bindString(2, dir);
+        }
+ 
+        String file = entity.getFile();
+        if (file != null) {
+            stmt.bindString(3, file);
+        }
+ 
+        Integer size = entity.getSize();
+        if (size != null) {
+            stmt.bindLong(4, size);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public LocalMedia readEntity(Cursor cursor, int offset) {
+        LocalMedia entity = new LocalMedia( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1), // dir
+            cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2), // file
+            cursor.isNull(offset + 3) ? null : cursor.getInt(offset + 3) // size
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, LocalMedia entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setDir(cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1));
+        entity.setFile(cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2));
+        entity.setSize(cursor.isNull(offset + 3) ? null : cursor.getInt(offset + 3));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(LocalMedia entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(LocalMedia entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/LocalPlayHistory.java b/DaoExample/src-gen/de/greenrobot/daoexample/LocalPlayHistory.java
new file mode 100644
index 00000000..2a283b45
--- /dev/null
+++ b/DaoExample/src-gen/de/greenrobot/daoexample/LocalPlayHistory.java
@@ -0,0 +1,80 @@
+package de.greenrobot.daoexample;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table LOCAL_PLAY_HISTORY.
+ */
+public class LocalPlayHistory {
+
+    private Long id;
+    private String videoTitle;
+    private String playedTime;
+    private Integer tvLength;
+    private String lastWatchTime;
+    private String localUrl;
+
+    public LocalPlayHistory() {
+    }
+
+    public LocalPlayHistory(Long id) {
+        this.id = id;
+    }
+
+    public LocalPlayHistory(Long id, String videoTitle, String playedTime, Integer tvLength, String lastWatchTime, String localUrl) {
+        this.id = id;
+        this.videoTitle = videoTitle;
+        this.playedTime = playedTime;
+        this.tvLength = tvLength;
+        this.lastWatchTime = lastWatchTime;
+        this.localUrl = localUrl;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public String getVideoTitle() {
+        return videoTitle;
+    }
+
+    public void setVideoTitle(String videoTitle) {
+        this.videoTitle = videoTitle;
+    }
+
+    public String getPlayedTime() {
+        return playedTime;
+    }
+
+    public void setPlayedTime(String playedTime) {
+        this.playedTime = playedTime;
+    }
+
+    public Integer getTvLength() {
+        return tvLength;
+    }
+
+    public void setTvLength(Integer tvLength) {
+        this.tvLength = tvLength;
+    }
+
+    public String getLastWatchTime() {
+        return lastWatchTime;
+    }
+
+    public void setLastWatchTime(String lastWatchTime) {
+        this.lastWatchTime = lastWatchTime;
+    }
+
+    public String getLocalUrl() {
+        return localUrl;
+    }
+
+    public void setLocalUrl(String localUrl) {
+        this.localUrl = localUrl;
+    }
+
+}
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/LocalPlayHistoryDao.java b/DaoExample/src-gen/de/greenrobot/daoexample/LocalPlayHistoryDao.java
new file mode 100644
index 00000000..d29499a0
--- /dev/null
+++ b/DaoExample/src-gen/de/greenrobot/daoexample/LocalPlayHistoryDao.java
@@ -0,0 +1,151 @@
+package de.greenrobot.daoexample;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daoexample.LocalPlayHistory;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table LOCAL_PLAY_HISTORY.
+*/
+public class LocalPlayHistoryDao extends AbstractDao<LocalPlayHistory, Long> {
+
+    public static final String TABLENAME = "LOCAL_PLAY_HISTORY";
+
+    /**
+     * Properties of entity LocalPlayHistory.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property VideoTitle = new Property(1, String.class, "videoTitle", false, "VIDEO_TITLE");
+        public final static Property PlayedTime = new Property(2, String.class, "playedTime", false, "PLAYED_TIME");
+        public final static Property TvLength = new Property(3, Integer.class, "tvLength", false, "TV_LENGTH");
+        public final static Property LastWatchTime = new Property(4, String.class, "lastWatchTime", false, "LAST_WATCH_TIME");
+        public final static Property LocalUrl = new Property(5, String.class, "localUrl", false, "LOCAL_URL");
+    };
+
+
+    public LocalPlayHistoryDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public LocalPlayHistoryDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'LOCAL_PLAY_HISTORY' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'VIDEO_TITLE' TEXT," + // 1: videoTitle
+                "'PLAYED_TIME' TEXT," + // 2: playedTime
+                "'TV_LENGTH' INTEGER," + // 3: tvLength
+                "'LAST_WATCH_TIME' TEXT," + // 4: lastWatchTime
+                "'LOCAL_URL' TEXT);"); // 5: localUrl
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'LOCAL_PLAY_HISTORY'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, LocalPlayHistory entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+ 
+        String videoTitle = entity.getVideoTitle();
+        if (videoTitle != null) {
+            stmt.bindString(2, videoTitle);
+        }
+ 
+        String playedTime = entity.getPlayedTime();
+        if (playedTime != null) {
+            stmt.bindString(3, playedTime);
+        }
+ 
+        Integer tvLength = entity.getTvLength();
+        if (tvLength != null) {
+            stmt.bindLong(4, tvLength);
+        }
+ 
+        String lastWatchTime = entity.getLastWatchTime();
+        if (lastWatchTime != null) {
+            stmt.bindString(5, lastWatchTime);
+        }
+ 
+        String localUrl = entity.getLocalUrl();
+        if (localUrl != null) {
+            stmt.bindString(6, localUrl);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public LocalPlayHistory readEntity(Cursor cursor, int offset) {
+        LocalPlayHistory entity = new LocalPlayHistory( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1), // videoTitle
+            cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2), // playedTime
+            cursor.isNull(offset + 3) ? null : cursor.getInt(offset + 3), // tvLength
+            cursor.isNull(offset + 4) ? null : cursor.getString(offset + 4), // lastWatchTime
+            cursor.isNull(offset + 5) ? null : cursor.getString(offset + 5) // localUrl
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, LocalPlayHistory entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setVideoTitle(cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1));
+        entity.setPlayedTime(cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2));
+        entity.setTvLength(cursor.isNull(offset + 3) ? null : cursor.getInt(offset + 3));
+        entity.setLastWatchTime(cursor.isNull(offset + 4) ? null : cursor.getString(offset + 4));
+        entity.setLocalUrl(cursor.isNull(offset + 5) ? null : cursor.getString(offset + 5));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(LocalPlayHistory entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(LocalPlayHistory entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/Note.java b/DaoExample/src-gen/de/greenrobot/daoexample/Note.java
index ed057058..627b4d42 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/Note.java
+++ b/DaoExample/src-gen/de/greenrobot/daoexample/Note.java
@@ -1,63 +1,63 @@
-package de.greenrobot.daoexample;
-
-// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
-/**
- * Entity mapped to table NOTE.
- */
-public class Note {
-
-    private Long id;
-    /** Not-null value. */
-    private String text;
-    private String comment;
-    private java.util.Date date;
-
-    public Note() {
-    }
-
-    public Note(Long id) {
-        this.id = id;
-    }
-
-    public Note(Long id, String text, String comment, java.util.Date date) {
-        this.id = id;
-        this.text = text;
-        this.comment = comment;
-        this.date = date;
-    }
-
-    public Long getId() {
-        return id;
-    }
-
-    public void setId(Long id) {
-        this.id = id;
-    }
-
-    /** Not-null value. */
-    public String getText() {
-        return text;
-    }
-
-    /** Not-null value; ensure this value is available before it is saved to the database. */
-    public void setText(String text) {
-        this.text = text;
-    }
-
-    public String getComment() {
-        return comment;
-    }
-
-    public void setComment(String comment) {
-        this.comment = comment;
-    }
-
-    public java.util.Date getDate() {
-        return date;
-    }
-
-    public void setDate(java.util.Date date) {
-        this.date = date;
-    }
-
-}
+package de.greenrobot.daoexample;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table NOTE.
+ */
+public class Note {
+
+    private Long id;
+    /** Not-null value. */
+    private String text;
+    private String comment;
+    private java.util.Date date;
+
+    public Note() {
+    }
+
+    public Note(Long id) {
+        this.id = id;
+    }
+
+    public Note(Long id, String text, String comment, java.util.Date date) {
+        this.id = id;
+        this.text = text;
+        this.comment = comment;
+        this.date = date;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    /** Not-null value. */
+    public String getText() {
+        return text;
+    }
+
+    /** Not-null value; ensure this value is available before it is saved to the database. */
+    public void setText(String text) {
+        this.text = text;
+    }
+
+    public String getComment() {
+        return comment;
+    }
+
+    public void setComment(String comment) {
+        this.comment = comment;
+    }
+
+    public java.util.Date getDate() {
+        return date;
+    }
+
+    public void setDate(java.util.Date date) {
+        this.date = date;
+    }
+
+}
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/NoteDao.java b/DaoExample/src-gen/de/greenrobot/daoexample/NoteDao.java
index 0fcaceee..dfaab391 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/NoteDao.java
+++ b/DaoExample/src-gen/de/greenrobot/daoexample/NoteDao.java
@@ -1,129 +1,129 @@
-package de.greenrobot.daoexample;
-
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
-
-import de.greenrobot.dao.AbstractDao;
-import de.greenrobot.dao.Property;
-import de.greenrobot.dao.internal.DaoConfig;
-
-import de.greenrobot.daoexample.Note;
-
-// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
-/** 
- * DAO for table NOTE.
-*/
-public class NoteDao extends AbstractDao<Note, Long> {
-
-    public static final String TABLENAME = "NOTE";
-
-    /**
-     * Properties of entity Note.<br/>
-     * Can be used for QueryBuilder and for referencing column names.
-    */
-    public static class Properties {
-        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
-        public final static Property Text = new Property(1, String.class, "text", false, "TEXT");
-        public final static Property Comment = new Property(2, String.class, "comment", false, "COMMENT");
-        public final static Property Date = new Property(3, java.util.Date.class, "date", false, "DATE");
-    };
-
-
-    public NoteDao(DaoConfig config) {
-        super(config);
-    }
-    
-    public NoteDao(DaoConfig config, DaoSession daoSession) {
-        super(config, daoSession);
-    }
-
-    /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
-        String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'NOTE' (" + //
-                "'_id' INTEGER PRIMARY KEY ," + // 0: id
-                "'TEXT' TEXT NOT NULL ," + // 1: text
-                "'COMMENT' TEXT," + // 2: comment
-                "'DATE' INTEGER);"); // 3: date
-    }
-
-    /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'NOTE'";
-        db.execSQL(sql);
-    }
-
-    /** @inheritdoc */
-    @Override
-    protected void bindValues(SQLiteStatement stmt, Note entity) {
-        stmt.clearBindings();
- 
-        Long id = entity.getId();
-        if (id != null) {
-            stmt.bindLong(1, id);
-        }
-        stmt.bindString(2, entity.getText());
- 
-        String comment = entity.getComment();
-        if (comment != null) {
-            stmt.bindString(3, comment);
-        }
- 
-        java.util.Date date = entity.getDate();
-        if (date != null) {
-            stmt.bindLong(4, date.getTime());
-        }
-    }
-
-    /** @inheritdoc */
-    @Override
-    public Long readKey(Cursor cursor, int offset) {
-        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
-    }    
-
-    /** @inheritdoc */
-    @Override
-    public Note readEntity(Cursor cursor, int offset) {
-        Note entity = new Note( //
-            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
-            cursor.getString(offset + 1), // text
-            cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2), // comment
-            cursor.isNull(offset + 3) ? null : new java.util.Date(cursor.getLong(offset + 3)) // date
-        );
-        return entity;
-    }
-     
-    /** @inheritdoc */
-    @Override
-    public void readEntity(Cursor cursor, Note entity, int offset) {
-        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
-        entity.setText(cursor.getString(offset + 1));
-        entity.setComment(cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2));
-        entity.setDate(cursor.isNull(offset + 3) ? null : new java.util.Date(cursor.getLong(offset + 3)));
-     }
-    
-    /** @inheritdoc */
-    @Override
-    protected Long updateKeyAfterInsert(Note entity, long rowId) {
-        entity.setId(rowId);
-        return rowId;
-    }
-    
-    /** @inheritdoc */
-    @Override
-    public Long getKey(Note entity) {
-        if(entity != null) {
-            return entity.getId();
-        } else {
-            return null;
-        }
-    }
-
-    /** @inheritdoc */
-    @Override    
-    protected boolean isEntityUpdateable() {
-        return true;
-    }
-    
-}
+package de.greenrobot.daoexample;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daoexample.Note;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table NOTE.
+*/
+public class NoteDao extends AbstractDao<Note, Long> {
+
+    public static final String TABLENAME = "NOTE";
+
+    /**
+     * Properties of entity Note.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property Text = new Property(1, String.class, "text", false, "TEXT");
+        public final static Property Comment = new Property(2, String.class, "comment", false, "COMMENT");
+        public final static Property Date = new Property(3, java.util.Date.class, "date", false, "DATE");
+    };
+
+
+    public NoteDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public NoteDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'NOTE' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'TEXT' TEXT NOT NULL ," + // 1: text
+                "'COMMENT' TEXT," + // 2: comment
+                "'DATE' INTEGER);"); // 3: date
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'NOTE'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, Note entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+        stmt.bindString(2, entity.getText());
+ 
+        String comment = entity.getComment();
+        if (comment != null) {
+            stmt.bindString(3, comment);
+        }
+ 
+        java.util.Date date = entity.getDate();
+        if (date != null) {
+            stmt.bindLong(4, date.getTime());
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public Note readEntity(Cursor cursor, int offset) {
+        Note entity = new Note( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.getString(offset + 1), // text
+            cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2), // comment
+            cursor.isNull(offset + 3) ? null : new java.util.Date(cursor.getLong(offset + 3)) // date
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, Note entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setText(cursor.getString(offset + 1));
+        entity.setComment(cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2));
+        entity.setDate(cursor.isNull(offset + 3) ? null : new java.util.Date(cursor.getLong(offset + 3)));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(Note entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(Note entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/Order.java b/DaoExample/src-gen/de/greenrobot/daoexample/Order.java
index 95ecfb86..88663792 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/Order.java
+++ b/DaoExample/src-gen/de/greenrobot/daoexample/Order.java
@@ -1,121 +1,121 @@
-package de.greenrobot.daoexample;
-
-import de.greenrobot.daoexample.DaoSession;
-import de.greenrobot.dao.DaoException;
-
-// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
-/**
- * Entity mapped to table ORDERS.
- */
-public class Order {
-
-    private Long id;
-    private java.util.Date date;
-    private long customerId;
-
-    /** Used to resolve relations */
-    private transient DaoSession daoSession;
-
-    /** Used for active entity operations. */
-    private transient OrderDao myDao;
-
-    private Customer customer;
-    private Long customer__resolvedKey;
-
-
-    public Order() {
-    }
-
-    public Order(Long id) {
-        this.id = id;
-    }
-
-    public Order(Long id, java.util.Date date, long customerId) {
-        this.id = id;
-        this.date = date;
-        this.customerId = customerId;
-    }
-
-    /** called by internal mechanisms, do not call yourself. */
-    public void __setDaoSession(DaoSession daoSession) {
-        this.daoSession = daoSession;
-        myDao = daoSession != null ? daoSession.getOrderDao() : null;
-    }
-
-    public Long getId() {
-        return id;
-    }
-
-    public void setId(Long id) {
-        this.id = id;
-    }
-
-    public java.util.Date getDate() {
-        return date;
-    }
-
-    public void setDate(java.util.Date date) {
-        this.date = date;
-    }
-
-    public long getCustomerId() {
-        return customerId;
-    }
-
-    public void setCustomerId(long customerId) {
-        this.customerId = customerId;
-    }
-
-    /** To-one relationship, resolved on first access. */
-    public Customer getCustomer() {
-        long __key = this.customerId;
-        if (customer__resolvedKey == null || !customer__resolvedKey.equals(__key)) {
-            if (daoSession == null) {
-                throw new DaoException("Entity is detached from DAO context");
-            }
-            CustomerDao targetDao = daoSession.getCustomerDao();
-            Customer customerNew = targetDao.load(__key);
-            synchronized (this) {
-                customer = customerNew;
-            	customer__resolvedKey = __key;
-            }
-        }
-        return customer;
-    }
-
-    public void setCustomer(Customer customer) {
-        if (customer == null) {
-            throw new DaoException("To-one property 'customerId' has not-null constraint; cannot set to-one to null");
-        }
-        synchronized (this) {
-            this.customer = customer;
-            customerId = customer.getId();
-            customer__resolvedKey = customerId;
-        }
-    }
-
-    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
-    public void delete() {
-        if (myDao == null) {
-            throw new DaoException("Entity is detached from DAO context");
-        }    
-        myDao.delete(this);
-    }
-
-    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
-    public void update() {
-        if (myDao == null) {
-            throw new DaoException("Entity is detached from DAO context");
-        }    
-        myDao.update(this);
-    }
-
-    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
-    public void refresh() {
-        if (myDao == null) {
-            throw new DaoException("Entity is detached from DAO context");
-        }    
-        myDao.refresh(this);
-    }
-
-}
+package de.greenrobot.daoexample;
+
+import de.greenrobot.daoexample.DaoSession;
+import de.greenrobot.dao.DaoException;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table ORDERS.
+ */
+public class Order {
+
+    private Long id;
+    private java.util.Date date;
+    private long customerId;
+
+    /** Used to resolve relations */
+    private transient DaoSession daoSession;
+
+    /** Used for active entity operations. */
+    private transient OrderDao myDao;
+
+    private Customer customer;
+    private Long customer__resolvedKey;
+
+
+    public Order() {
+    }
+
+    public Order(Long id) {
+        this.id = id;
+    }
+
+    public Order(Long id, java.util.Date date, long customerId) {
+        this.id = id;
+        this.date = date;
+        this.customerId = customerId;
+    }
+
+    /** called by internal mechanisms, do not call yourself. */
+    public void __setDaoSession(DaoSession daoSession) {
+        this.daoSession = daoSession;
+        myDao = daoSession != null ? daoSession.getOrderDao() : null;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public java.util.Date getDate() {
+        return date;
+    }
+
+    public void setDate(java.util.Date date) {
+        this.date = date;
+    }
+
+    public long getCustomerId() {
+        return customerId;
+    }
+
+    public void setCustomerId(long customerId) {
+        this.customerId = customerId;
+    }
+
+    /** To-one relationship, resolved on first access. */
+    public Customer getCustomer() {
+        long __key = this.customerId;
+        if (customer__resolvedKey == null || !customer__resolvedKey.equals(__key)) {
+            if (daoSession == null) {
+                throw new DaoException("Entity is detached from DAO context");
+            }
+            CustomerDao targetDao = daoSession.getCustomerDao();
+            Customer customerNew = targetDao.load(__key);
+            synchronized (this) {
+                customer = customerNew;
+            	customer__resolvedKey = __key;
+            }
+        }
+        return customer;
+    }
+
+    public void setCustomer(Customer customer) {
+        if (customer == null) {
+            throw new DaoException("To-one property 'customerId' has not-null constraint; cannot set to-one to null");
+        }
+        synchronized (this) {
+            this.customer = customer;
+            customerId = customer.getId();
+            customer__resolvedKey = customerId;
+        }
+    }
+
+    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
+    public void delete() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.delete(this);
+    }
+
+    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
+    public void update() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.update(this);
+    }
+
+    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
+    public void refresh() {
+        if (myDao == null) {
+            throw new DaoException("Entity is detached from DAO context");
+        }    
+        myDao.refresh(this);
+    }
+
+}
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/OrderDao.java b/DaoExample/src-gen/de/greenrobot/daoexample/OrderDao.java
index d3ac55a7..72adbb00 100644
--- a/DaoExample/src-gen/de/greenrobot/daoexample/OrderDao.java
+++ b/DaoExample/src-gen/de/greenrobot/daoexample/OrderDao.java
@@ -1,243 +1,243 @@
-package de.greenrobot.daoexample;
-
-import java.util.List;
-import java.util.ArrayList;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteStatement;
-
-import de.greenrobot.dao.AbstractDao;
-import de.greenrobot.dao.Property;
-import de.greenrobot.dao.internal.SqlUtils;
-import de.greenrobot.dao.internal.DaoConfig;
-import de.greenrobot.dao.query.Query;
-import de.greenrobot.dao.query.QueryBuilder;
-
-import de.greenrobot.daoexample.Order;
-
-// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
-/** 
- * DAO for table ORDERS.
-*/
-public class OrderDao extends AbstractDao<Order, Long> {
-
-    public static final String TABLENAME = "ORDERS";
-
-    /**
-     * Properties of entity Order.<br/>
-     * Can be used for QueryBuilder and for referencing column names.
-    */
-    public static class Properties {
-        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
-        public final static Property Date = new Property(1, java.util.Date.class, "date", false, "DATE");
-        public final static Property CustomerId = new Property(2, long.class, "customerId", false, "CUSTOMER_ID");
-    };
-
-    private DaoSession daoSession;
-
-    private Query<Order> customer_OrdersQuery;
-
-    public OrderDao(DaoConfig config) {
-        super(config);
-    }
-    
-    public OrderDao(DaoConfig config, DaoSession daoSession) {
-        super(config, daoSession);
-        this.daoSession = daoSession;
-    }
-
-    /** Creates the underlying database table. */
-    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
-        String constraint = ifNotExists? "IF NOT EXISTS ": "";
-        db.execSQL("CREATE TABLE " + constraint + "'ORDERS' (" + //
-                "'_id' INTEGER PRIMARY KEY ," + // 0: id
-                "'DATE' INTEGER," + // 1: date
-                "'CUSTOMER_ID' INTEGER NOT NULL );"); // 2: customerId
-    }
-
-    /** Drops the underlying database table. */
-    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
-        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'ORDERS'";
-        db.execSQL(sql);
-    }
-
-    /** @inheritdoc */
-    @Override
-    protected void bindValues(SQLiteStatement stmt, Order entity) {
-        stmt.clearBindings();
- 
-        Long id = entity.getId();
-        if (id != null) {
-            stmt.bindLong(1, id);
-        }
- 
-        java.util.Date date = entity.getDate();
-        if (date != null) {
-            stmt.bindLong(2, date.getTime());
-        }
-        stmt.bindLong(3, entity.getCustomerId());
-    }
-
-    @Override
-    protected void attachEntity(Order entity) {
-        super.attachEntity(entity);
-        entity.__setDaoSession(daoSession);
-    }
-
-    /** @inheritdoc */
-    @Override
-    public Long readKey(Cursor cursor, int offset) {
-        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
-    }    
-
-    /** @inheritdoc */
-    @Override
-    public Order readEntity(Cursor cursor, int offset) {
-        Order entity = new Order( //
-            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
-            cursor.isNull(offset + 1) ? null : new java.util.Date(cursor.getLong(offset + 1)), // date
-            cursor.getLong(offset + 2) // customerId
-        );
-        return entity;
-    }
-     
-    /** @inheritdoc */
-    @Override
-    public void readEntity(Cursor cursor, Order entity, int offset) {
-        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
-        entity.setDate(cursor.isNull(offset + 1) ? null : new java.util.Date(cursor.getLong(offset + 1)));
-        entity.setCustomerId(cursor.getLong(offset + 2));
-     }
-    
-    /** @inheritdoc */
-    @Override
-    protected Long updateKeyAfterInsert(Order entity, long rowId) {
-        entity.setId(rowId);
-        return rowId;
-    }
-    
-    /** @inheritdoc */
-    @Override
-    public Long getKey(Order entity) {
-        if(entity != null) {
-            return entity.getId();
-        } else {
-            return null;
-        }
-    }
-
-    /** @inheritdoc */
-    @Override    
-    protected boolean isEntityUpdateable() {
-        return true;
-    }
-    
-    /** Internal query to resolve the "orders" to-many relationship of Customer. */
-    public List<Order> _queryCustomer_Orders(long customerId) {
-        synchronized (this) {
-            if (customer_OrdersQuery == null) {
-                QueryBuilder<Order> queryBuilder = queryBuilder();
-                queryBuilder.where(Properties.CustomerId.eq(null));
-                queryBuilder.orderRaw("DATE ASC");
-                customer_OrdersQuery = queryBuilder.build();
-            }
-        }
-        Query<Order> query = customer_OrdersQuery.forCurrentThread();
-        query.setParameter(0, customerId);
-        return query.list();
-    }
-
-    private String selectDeep;
-
-    protected String getSelectDeep() {
-        if (selectDeep == null) {
-            StringBuilder builder = new StringBuilder("SELECT ");
-            SqlUtils.appendColumns(builder, "T", getAllColumns());
-            builder.append(',');
-            SqlUtils.appendColumns(builder, "T0", daoSession.getCustomerDao().getAllColumns());
-            builder.append(" FROM ORDERS T");
-            builder.append(" LEFT JOIN CUSTOMER T0 ON T.'CUSTOMER_ID'=T0.'_id'");
-            builder.append(' ');
-            selectDeep = builder.toString();
-        }
-        return selectDeep;
-    }
-    
-    protected Order loadCurrentDeep(Cursor cursor, boolean lock) {
-        Order entity = loadCurrent(cursor, 0, lock);
-        int offset = getAllColumns().length;
-
-        Customer customer = loadCurrentOther(daoSession.getCustomerDao(), cursor, offset);
-         if(customer != null) {
-            entity.setCustomer(customer);
-        }
-
-        return entity;    
-    }
-
-    public Order loadDeep(Long key) {
-        assertSinglePk();
-        if (key == null) {
-            return null;
-        }
-
-        StringBuilder builder = new StringBuilder(getSelectDeep());
-        builder.append("WHERE ");
-        SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
-        String sql = builder.toString();
-        
-        String[] keyArray = new String[] { key.toString() };
-        Cursor cursor = db.rawQuery(sql, keyArray);
-        
-        try {
-            boolean available = cursor.moveToFirst();
-            if (!available) {
-                return null;
-            } else if (!cursor.isLast()) {
-                throw new IllegalStateException("Expected unique result, but count was " + cursor.getCount());
-            }
-            return loadCurrentDeep(cursor, true);
-        } finally {
-            cursor.close();
-        }
-    }
-    
-    /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. */
-    public List<Order> loadAllDeepFromCursor(Cursor cursor) {
-        int count = cursor.getCount();
-        List<Order> list = new ArrayList<Order>(count);
-        
-        if (cursor.moveToFirst()) {
-            if (identityScope != null) {
-                identityScope.lock();
-                identityScope.reserveRoom(count);
-            }
-            try {
-                do {
-                    list.add(loadCurrentDeep(cursor, false));
-                } while (cursor.moveToNext());
-            } finally {
-                if (identityScope != null) {
-                    identityScope.unlock();
-                }
-            }
-        }
-        return list;
-    }
-    
-    protected List<Order> loadDeepAllAndCloseCursor(Cursor cursor) {
-        try {
-            return loadAllDeepFromCursor(cursor);
-        } finally {
-            cursor.close();
-        }
-    }
-    
-
-    /** A raw-style query where you can pass any WHERE clause and arguments. */
-    public List<Order> queryDeep(String where, String... selectionArg) {
-        Cursor cursor = db.rawQuery(getSelectDeep() + where, selectionArg);
-        return loadDeepAllAndCloseCursor(cursor);
-    }
- 
-}
+package de.greenrobot.daoexample;
+
+import java.util.List;
+import java.util.ArrayList;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.SqlUtils;
+import de.greenrobot.dao.internal.DaoConfig;
+import de.greenrobot.dao.query.Query;
+import de.greenrobot.dao.query.QueryBuilder;
+
+import de.greenrobot.daoexample.Order;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table ORDERS.
+*/
+public class OrderDao extends AbstractDao<Order, Long> {
+
+    public static final String TABLENAME = "ORDERS";
+
+    /**
+     * Properties of entity Order.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property Date = new Property(1, java.util.Date.class, "date", false, "DATE");
+        public final static Property CustomerId = new Property(2, long.class, "customerId", false, "CUSTOMER_ID");
+    };
+
+    private DaoSession daoSession;
+
+    private Query<Order> customer_OrdersQuery;
+
+    public OrderDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public OrderDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+        this.daoSession = daoSession;
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'ORDERS' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'DATE' INTEGER," + // 1: date
+                "'CUSTOMER_ID' INTEGER NOT NULL );"); // 2: customerId
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'ORDERS'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, Order entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+ 
+        java.util.Date date = entity.getDate();
+        if (date != null) {
+            stmt.bindLong(2, date.getTime());
+        }
+        stmt.bindLong(3, entity.getCustomerId());
+    }
+
+    @Override
+    protected void attachEntity(Order entity) {
+        super.attachEntity(entity);
+        entity.__setDaoSession(daoSession);
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public Order readEntity(Cursor cursor, int offset) {
+        Order entity = new Order( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.isNull(offset + 1) ? null : new java.util.Date(cursor.getLong(offset + 1)), // date
+            cursor.getLong(offset + 2) // customerId
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, Order entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setDate(cursor.isNull(offset + 1) ? null : new java.util.Date(cursor.getLong(offset + 1)));
+        entity.setCustomerId(cursor.getLong(offset + 2));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(Order entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(Order entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+    /** Internal query to resolve the "orders" to-many relationship of Customer. */
+    public List<Order> _queryCustomer_Orders(long customerId) {
+        synchronized (this) {
+            if (customer_OrdersQuery == null) {
+                QueryBuilder<Order> queryBuilder = queryBuilder();
+                queryBuilder.where(Properties.CustomerId.eq(null));
+                queryBuilder.orderRaw("DATE ASC");
+                customer_OrdersQuery = queryBuilder.build();
+            }
+        }
+        Query<Order> query = customer_OrdersQuery.forCurrentThread();
+        query.setParameter(0, customerId);
+        return query.list();
+    }
+
+    private String selectDeep;
+
+    protected String getSelectDeep() {
+        if (selectDeep == null) {
+            StringBuilder builder = new StringBuilder("SELECT ");
+            SqlUtils.appendColumns(builder, "T", getAllColumns());
+            builder.append(',');
+            SqlUtils.appendColumns(builder, "T0", daoSession.getCustomerDao().getAllColumns());
+            builder.append(" FROM ORDERS T");
+            builder.append(" LEFT JOIN CUSTOMER T0 ON T.'CUSTOMER_ID'=T0.'_id'");
+            builder.append(' ');
+            selectDeep = builder.toString();
+        }
+        return selectDeep;
+    }
+    
+    protected Order loadCurrentDeep(Cursor cursor, boolean lock) {
+        Order entity = loadCurrent(cursor, 0, lock);
+        int offset = getAllColumns().length;
+
+        Customer customer = loadCurrentOther(daoSession.getCustomerDao(), cursor, offset);
+         if(customer != null) {
+            entity.setCustomer(customer);
+        }
+
+        return entity;    
+    }
+
+    public Order loadDeep(Long key) {
+        assertSinglePk();
+        if (key == null) {
+            return null;
+        }
+
+        StringBuilder builder = new StringBuilder(getSelectDeep());
+        builder.append("WHERE ");
+        SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
+        String sql = builder.toString();
+        
+        String[] keyArray = new String[] { key.toString() };
+        Cursor cursor = db.rawQuery(sql, keyArray);
+        
+        try {
+            boolean available = cursor.moveToFirst();
+            if (!available) {
+                return null;
+            } else if (!cursor.isLast()) {
+                throw new IllegalStateException("Expected unique result, but count was " + cursor.getCount());
+            }
+            return loadCurrentDeep(cursor, true);
+        } finally {
+            cursor.close();
+        }
+    }
+    
+    /** Reads all available rows from the given cursor and returns a list of new ImageTO objects. */
+    public List<Order> loadAllDeepFromCursor(Cursor cursor) {
+        int count = cursor.getCount();
+        List<Order> list = new ArrayList<Order>(count);
+        
+        if (cursor.moveToFirst()) {
+            if (identityScope != null) {
+                identityScope.lock();
+                identityScope.reserveRoom(count);
+            }
+            try {
+                do {
+                    list.add(loadCurrentDeep(cursor, false));
+                } while (cursor.moveToNext());
+            } finally {
+                if (identityScope != null) {
+                    identityScope.unlock();
+                }
+            }
+        }
+        return list;
+    }
+    
+    protected List<Order> loadDeepAllAndCloseCursor(Cursor cursor) {
+        try {
+            return loadAllDeepFromCursor(cursor);
+        } finally {
+            cursor.close();
+        }
+    }
+    
+
+    /** A raw-style query where you can pass any WHERE clause and arguments. */
+    public List<Order> queryDeep(String where, String... selectionArg) {
+        Cursor cursor = db.rawQuery(getSelectDeep() + where, selectionArg);
+        return loadDeepAllAndCloseCursor(cursor);
+    }
+ 
+}
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/PlayHistory.java b/DaoExample/src-gen/de/greenrobot/daoexample/PlayHistory.java
new file mode 100644
index 00000000..870bb318
--- /dev/null
+++ b/DaoExample/src-gen/de/greenrobot/daoexample/PlayHistory.java
@@ -0,0 +1,220 @@
+package de.greenrobot.daoexample;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
+/**
+ * Entity mapped to table PLAY_HISTORY.
+ */
+public class PlayHistory {
+
+    private Long id;
+    private String playId;
+    private String subjectId;
+    private String videoTitle;
+    private String playedTime;
+    private String clientType;
+    private String definition;
+    private String episode;
+    private String picPath;
+    private String categoryId;
+    private Integer tvLength;
+    private Integer isSynchronized;
+    private String albumName;
+    private Integer nextplayId;
+    private String lastWatchTime;
+    private String passport;
+    private String localUrl;
+    private Integer tvisfee;
+    private Integer real_playorder;
+    private Integer site;
+
+    public PlayHistory() {
+    }
+
+    public PlayHistory(Long id) {
+        this.id = id;
+    }
+
+    public PlayHistory(Long id, String playId, String subjectId, String videoTitle, String playedTime, String clientType, String definition, String episode, String picPath, String categoryId, Integer tvLength, Integer isSynchronized, String albumName, Integer nextplayId, String lastWatchTime, String passport, String localUrl, Integer tvisfee, Integer real_playorder, Integer site) {
+        this.id = id;
+        this.playId = playId;
+        this.subjectId = subjectId;
+        this.videoTitle = videoTitle;
+        this.playedTime = playedTime;
+        this.clientType = clientType;
+        this.definition = definition;
+        this.episode = episode;
+        this.picPath = picPath;
+        this.categoryId = categoryId;
+        this.tvLength = tvLength;
+        this.isSynchronized = isSynchronized;
+        this.albumName = albumName;
+        this.nextplayId = nextplayId;
+        this.lastWatchTime = lastWatchTime;
+        this.passport = passport;
+        this.localUrl = localUrl;
+        this.tvisfee = tvisfee;
+        this.real_playorder = real_playorder;
+        this.site = site;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public void setId(Long id) {
+        this.id = id;
+    }
+
+    public String getPlayId() {
+        return playId;
+    }
+
+    public void setPlayId(String playId) {
+        this.playId = playId;
+    }
+
+    public String getSubjectId() {
+        return subjectId;
+    }
+
+    public void setSubjectId(String subjectId) {
+        this.subjectId = subjectId;
+    }
+
+    public String getVideoTitle() {
+        return videoTitle;
+    }
+
+    public void setVideoTitle(String videoTitle) {
+        this.videoTitle = videoTitle;
+    }
+
+    public String getPlayedTime() {
+        return playedTime;
+    }
+
+    public void setPlayedTime(String playedTime) {
+        this.playedTime = playedTime;
+    }
+
+    public String getClientType() {
+        return clientType;
+    }
+
+    public void setClientType(String clientType) {
+        this.clientType = clientType;
+    }
+
+    public String getDefinition() {
+        return definition;
+    }
+
+    public void setDefinition(String definition) {
+        this.definition = definition;
+    }
+
+    public String getEpisode() {
+        return episode;
+    }
+
+    public void setEpisode(String episode) {
+        this.episode = episode;
+    }
+
+    public String getPicPath() {
+        return picPath;
+    }
+
+    public void setPicPath(String picPath) {
+        this.picPath = picPath;
+    }
+
+    public String getCategoryId() {
+        return categoryId;
+    }
+
+    public void setCategoryId(String categoryId) {
+        this.categoryId = categoryId;
+    }
+
+    public Integer getTvLength() {
+        return tvLength;
+    }
+
+    public void setTvLength(Integer tvLength) {
+        this.tvLength = tvLength;
+    }
+
+    public Integer getIsSynchronized() {
+        return isSynchronized;
+    }
+
+    public void setIsSynchronized(Integer isSynchronized) {
+        this.isSynchronized = isSynchronized;
+    }
+
+    public String getAlbumName() {
+        return albumName;
+    }
+
+    public void setAlbumName(String albumName) {
+        this.albumName = albumName;
+    }
+
+    public Integer getNextplayId() {
+        return nextplayId;
+    }
+
+    public void setNextplayId(Integer nextplayId) {
+        this.nextplayId = nextplayId;
+    }
+
+    public String getLastWatchTime() {
+        return lastWatchTime;
+    }
+
+    public void setLastWatchTime(String lastWatchTime) {
+        this.lastWatchTime = lastWatchTime;
+    }
+
+    public String getPassport() {
+        return passport;
+    }
+
+    public void setPassport(String passport) {
+        this.passport = passport;
+    }
+
+    public String getLocalUrl() {
+        return localUrl;
+    }
+
+    public void setLocalUrl(String localUrl) {
+        this.localUrl = localUrl;
+    }
+
+    public Integer getTvisfee() {
+        return tvisfee;
+    }
+
+    public void setTvisfee(Integer tvisfee) {
+        this.tvisfee = tvisfee;
+    }
+
+    public Integer getReal_playorder() {
+        return real_playorder;
+    }
+
+    public void setReal_playorder(Integer real_playorder) {
+        this.real_playorder = real_playorder;
+    }
+
+    public Integer getSite() {
+        return site;
+    }
+
+    public void setSite(Integer site) {
+        this.site = site;
+    }
+
+}
diff --git a/DaoExample/src-gen/de/greenrobot/daoexample/PlayHistoryDao.java b/DaoExample/src-gen/de/greenrobot/daoexample/PlayHistoryDao.java
new file mode 100644
index 00000000..cc3066e9
--- /dev/null
+++ b/DaoExample/src-gen/de/greenrobot/daoexample/PlayHistoryDao.java
@@ -0,0 +1,277 @@
+package de.greenrobot.daoexample;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteStatement;
+
+import de.greenrobot.dao.AbstractDao;
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.internal.DaoConfig;
+
+import de.greenrobot.daoexample.PlayHistory;
+
+// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
+/** 
+ * DAO for table PLAY_HISTORY.
+*/
+public class PlayHistoryDao extends AbstractDao<PlayHistory, Long> {
+
+    public static final String TABLENAME = "PLAY_HISTORY";
+
+    /**
+     * Properties of entity PlayHistory.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+        public final static Property Id = new Property(0, Long.class, "id", true, "_id");
+        public final static Property PlayId = new Property(1, String.class, "playId", false, "PLAY_ID");
+        public final static Property SubjectId = new Property(2, String.class, "subjectId", false, "SUBJECT_ID");
+        public final static Property VideoTitle = new Property(3, String.class, "videoTitle", false, "VIDEO_TITLE");
+        public final static Property PlayedTime = new Property(4, String.class, "playedTime", false, "PLAYED_TIME");
+        public final static Property ClientType = new Property(5, String.class, "clientType", false, "CLIENT_TYPE");
+        public final static Property Definition = new Property(6, String.class, "definition", false, "DEFINITION");
+        public final static Property Episode = new Property(7, String.class, "episode", false, "EPISODE");
+        public final static Property PicPath = new Property(8, String.class, "picPath", false, "PIC_PATH");
+        public final static Property CategoryId = new Property(9, String.class, "categoryId", false, "CATEGORY_ID");
+        public final static Property TvLength = new Property(10, Integer.class, "tvLength", false, "TV_LENGTH");
+        public final static Property IsSynchronized = new Property(11, Integer.class, "isSynchronized", false, "IS_SYNCHRONIZED");
+        public final static Property AlbumName = new Property(12, String.class, "albumName", false, "ALBUM_NAME");
+        public final static Property NextplayId = new Property(13, Integer.class, "nextplayId", false, "NEXTPLAY_ID");
+        public final static Property LastWatchTime = new Property(14, String.class, "lastWatchTime", false, "LAST_WATCH_TIME");
+        public final static Property Passport = new Property(15, String.class, "passport", false, "PASSPORT");
+        public final static Property LocalUrl = new Property(16, String.class, "localUrl", false, "LOCAL_URL");
+        public final static Property Tvisfee = new Property(17, Integer.class, "tvisfee", false, "TVISFEE");
+        public final static Property Real_playorder = new Property(18, Integer.class, "real_playorder", false, "REAL_PLAYORDER");
+        public final static Property Site = new Property(19, Integer.class, "site", false, "SITE");
+    };
+
+
+    public PlayHistoryDao(DaoConfig config) {
+        super(config);
+    }
+    
+    public PlayHistoryDao(DaoConfig config, DaoSession daoSession) {
+        super(config, daoSession);
+    }
+
+    /** Creates the underlying database table. */
+    public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
+        String constraint = ifNotExists? "IF NOT EXISTS ": "";
+        db.execSQL("CREATE TABLE " + constraint + "'PLAY_HISTORY' (" + //
+                "'_id' INTEGER PRIMARY KEY ," + // 0: id
+                "'PLAY_ID' TEXT," + // 1: playId
+                "'SUBJECT_ID' TEXT," + // 2: subjectId
+                "'VIDEO_TITLE' TEXT," + // 3: videoTitle
+                "'PLAYED_TIME' TEXT," + // 4: playedTime
+                "'CLIENT_TYPE' TEXT," + // 5: clientType
+                "'DEFINITION' TEXT," + // 6: definition
+                "'EPISODE' TEXT," + // 7: episode
+                "'PIC_PATH' TEXT," + // 8: picPath
+                "'CATEGORY_ID' TEXT," + // 9: categoryId
+                "'TV_LENGTH' INTEGER," + // 10: tvLength
+                "'IS_SYNCHRONIZED' INTEGER," + // 11: isSynchronized
+                "'ALBUM_NAME' TEXT," + // 12: albumName
+                "'NEXTPLAY_ID' INTEGER," + // 13: nextplayId
+                "'LAST_WATCH_TIME' TEXT," + // 14: lastWatchTime
+                "'PASSPORT' TEXT," + // 15: passport
+                "'LOCAL_URL' TEXT," + // 16: localUrl
+                "'TVISFEE' INTEGER," + // 17: tvisfee
+                "'REAL_PLAYORDER' INTEGER," + // 18: real_playorder
+                "'SITE' INTEGER);"); // 19: site
+    }
+
+    /** Drops the underlying database table. */
+    public static void dropTable(SQLiteDatabase db, boolean ifExists) {
+        String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'PLAY_HISTORY'";
+        db.execSQL(sql);
+    }
+
+    /** @inheritdoc */
+    @Override
+    protected void bindValues(SQLiteStatement stmt, PlayHistory entity) {
+        stmt.clearBindings();
+ 
+        Long id = entity.getId();
+        if (id != null) {
+            stmt.bindLong(1, id);
+        }
+ 
+        String playId = entity.getPlayId();
+        if (playId != null) {
+            stmt.bindString(2, playId);
+        }
+ 
+        String subjectId = entity.getSubjectId();
+        if (subjectId != null) {
+            stmt.bindString(3, subjectId);
+        }
+ 
+        String videoTitle = entity.getVideoTitle();
+        if (videoTitle != null) {
+            stmt.bindString(4, videoTitle);
+        }
+ 
+        String playedTime = entity.getPlayedTime();
+        if (playedTime != null) {
+            stmt.bindString(5, playedTime);
+        }
+ 
+        String clientType = entity.getClientType();
+        if (clientType != null) {
+            stmt.bindString(6, clientType);
+        }
+ 
+        String definition = entity.getDefinition();
+        if (definition != null) {
+            stmt.bindString(7, definition);
+        }
+ 
+        String episode = entity.getEpisode();
+        if (episode != null) {
+            stmt.bindString(8, episode);
+        }
+ 
+        String picPath = entity.getPicPath();
+        if (picPath != null) {
+            stmt.bindString(9, picPath);
+        }
+ 
+        String categoryId = entity.getCategoryId();
+        if (categoryId != null) {
+            stmt.bindString(10, categoryId);
+        }
+ 
+        Integer tvLength = entity.getTvLength();
+        if (tvLength != null) {
+            stmt.bindLong(11, tvLength);
+        }
+ 
+        Integer isSynchronized = entity.getIsSynchronized();
+        if (isSynchronized != null) {
+            stmt.bindLong(12, isSynchronized);
+        }
+ 
+        String albumName = entity.getAlbumName();
+        if (albumName != null) {
+            stmt.bindString(13, albumName);
+        }
+ 
+        Integer nextplayId = entity.getNextplayId();
+        if (nextplayId != null) {
+            stmt.bindLong(14, nextplayId);
+        }
+ 
+        String lastWatchTime = entity.getLastWatchTime();
+        if (lastWatchTime != null) {
+            stmt.bindString(15, lastWatchTime);
+        }
+ 
+        String passport = entity.getPassport();
+        if (passport != null) {
+            stmt.bindString(16, passport);
+        }
+ 
+        String localUrl = entity.getLocalUrl();
+        if (localUrl != null) {
+            stmt.bindString(17, localUrl);
+        }
+ 
+        Integer tvisfee = entity.getTvisfee();
+        if (tvisfee != null) {
+            stmt.bindLong(18, tvisfee);
+        }
+ 
+        Integer real_playorder = entity.getReal_playorder();
+        if (real_playorder != null) {
+            stmt.bindLong(19, real_playorder);
+        }
+ 
+        Integer site = entity.getSite();
+        if (site != null) {
+            stmt.bindLong(20, site);
+        }
+    }
+
+    /** @inheritdoc */
+    @Override
+    public Long readKey(Cursor cursor, int offset) {
+        return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
+    }    
+
+    /** @inheritdoc */
+    @Override
+    public PlayHistory readEntity(Cursor cursor, int offset) {
+        PlayHistory entity = new PlayHistory( //
+            cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
+            cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1), // playId
+            cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2), // subjectId
+            cursor.isNull(offset + 3) ? null : cursor.getString(offset + 3), // videoTitle
+            cursor.isNull(offset + 4) ? null : cursor.getString(offset + 4), // playedTime
+            cursor.isNull(offset + 5) ? null : cursor.getString(offset + 5), // clientType
+            cursor.isNull(offset + 6) ? null : cursor.getString(offset + 6), // definition
+            cursor.isNull(offset + 7) ? null : cursor.getString(offset + 7), // episode
+            cursor.isNull(offset + 8) ? null : cursor.getString(offset + 8), // picPath
+            cursor.isNull(offset + 9) ? null : cursor.getString(offset + 9), // categoryId
+            cursor.isNull(offset + 10) ? null : cursor.getInt(offset + 10), // tvLength
+            cursor.isNull(offset + 11) ? null : cursor.getInt(offset + 11), // isSynchronized
+            cursor.isNull(offset + 12) ? null : cursor.getString(offset + 12), // albumName
+            cursor.isNull(offset + 13) ? null : cursor.getInt(offset + 13), // nextplayId
+            cursor.isNull(offset + 14) ? null : cursor.getString(offset + 14), // lastWatchTime
+            cursor.isNull(offset + 15) ? null : cursor.getString(offset + 15), // passport
+            cursor.isNull(offset + 16) ? null : cursor.getString(offset + 16), // localUrl
+            cursor.isNull(offset + 17) ? null : cursor.getInt(offset + 17), // tvisfee
+            cursor.isNull(offset + 18) ? null : cursor.getInt(offset + 18), // real_playorder
+            cursor.isNull(offset + 19) ? null : cursor.getInt(offset + 19) // site
+        );
+        return entity;
+    }
+     
+    /** @inheritdoc */
+    @Override
+    public void readEntity(Cursor cursor, PlayHistory entity, int offset) {
+        entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
+        entity.setPlayId(cursor.isNull(offset + 1) ? null : cursor.getString(offset + 1));
+        entity.setSubjectId(cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2));
+        entity.setVideoTitle(cursor.isNull(offset + 3) ? null : cursor.getString(offset + 3));
+        entity.setPlayedTime(cursor.isNull(offset + 4) ? null : cursor.getString(offset + 4));
+        entity.setClientType(cursor.isNull(offset + 5) ? null : cursor.getString(offset + 5));
+        entity.setDefinition(cursor.isNull(offset + 6) ? null : cursor.getString(offset + 6));
+        entity.setEpisode(cursor.isNull(offset + 7) ? null : cursor.getString(offset + 7));
+        entity.setPicPath(cursor.isNull(offset + 8) ? null : cursor.getString(offset + 8));
+        entity.setCategoryId(cursor.isNull(offset + 9) ? null : cursor.getString(offset + 9));
+        entity.setTvLength(cursor.isNull(offset + 10) ? null : cursor.getInt(offset + 10));
+        entity.setIsSynchronized(cursor.isNull(offset + 11) ? null : cursor.getInt(offset + 11));
+        entity.setAlbumName(cursor.isNull(offset + 12) ? null : cursor.getString(offset + 12));
+        entity.setNextplayId(cursor.isNull(offset + 13) ? null : cursor.getInt(offset + 13));
+        entity.setLastWatchTime(cursor.isNull(offset + 14) ? null : cursor.getString(offset + 14));
+        entity.setPassport(cursor.isNull(offset + 15) ? null : cursor.getString(offset + 15));
+        entity.setLocalUrl(cursor.isNull(offset + 16) ? null : cursor.getString(offset + 16));
+        entity.setTvisfee(cursor.isNull(offset + 17) ? null : cursor.getInt(offset + 17));
+        entity.setReal_playorder(cursor.isNull(offset + 18) ? null : cursor.getInt(offset + 18));
+        entity.setSite(cursor.isNull(offset + 19) ? null : cursor.getInt(offset + 19));
+     }
+    
+    /** @inheritdoc */
+    @Override
+    protected Long updateKeyAfterInsert(PlayHistory entity, long rowId) {
+        entity.setId(rowId);
+        return rowId;
+    }
+    
+    /** @inheritdoc */
+    @Override
+    public Long getKey(PlayHistory entity) {
+        if(entity != null) {
+            return entity.getId();
+        } else {
+            return null;
+        }
+    }
+
+    /** @inheritdoc */
+    @Override    
+    protected boolean isEntityUpdateable() {
+        return true;
+    }
+    
+}
diff --git a/DaoExample/src/de/greenrobot/daoexample/NoteActivity.java b/DaoExample/src/de/greenrobot/daoexample/NoteActivity.java
index 48a3ba53..81000671 100644
--- a/DaoExample/src/de/greenrobot/daoexample/NoteActivity.java
+++ b/DaoExample/src/de/greenrobot/daoexample/NoteActivity.java
@@ -1,133 +1,150 @@
-/*
- * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package de.greenrobot.daoexample;
-
-import java.text.DateFormat;
-import java.util.Date;
-
-import android.app.ListActivity;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.os.Bundle;
-import android.text.Editable;
-import android.text.TextWatcher;
-import android.util.Log;
-import android.view.KeyEvent;
-import android.view.View;
-import android.view.inputmethod.EditorInfo;
-import android.widget.EditText;
-import android.widget.ListView;
-import android.widget.SimpleCursorAdapter;
-import android.widget.TextView;
-import android.widget.TextView.OnEditorActionListener;
-import de.greenrobot.daoexample.DaoMaster.DevOpenHelper;
-
-public class NoteActivity extends ListActivity {
-
-    private SQLiteDatabase db;
-
-    private EditText editText;
-
-    private DaoMaster daoMaster;
-    private DaoSession daoSession;
-    private NoteDao noteDao;
-
-    private Cursor cursor;
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        setContentView(R.layout.main);
-
-        DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, "notes-db", null);
-        db = helper.getWritableDatabase();
-        daoMaster = new DaoMaster(db);
-        daoSession = daoMaster.newSession();
-        noteDao = daoSession.getNoteDao();
-
-        String textColumn = NoteDao.Properties.Text.columnName;
-        String orderBy = textColumn + " COLLATE LOCALIZED ASC";
-        cursor = db.query(noteDao.getTablename(), noteDao.getAllColumns(), null, null, null, null, orderBy);
-        String[] from = { textColumn, NoteDao.Properties.Comment.columnName };
-        int[] to = { android.R.id.text1, android.R.id.text2 };
-
-        SimpleCursorAdapter adapter = new SimpleCursorAdapter(this, android.R.layout.simple_list_item_2, cursor, from,
-                to);
-        setListAdapter(adapter);
-
-        editText = (EditText) findViewById(R.id.editTextNote);
-        addUiListeners();
-    }
-
-    protected void addUiListeners() {
-        editText.setOnEditorActionListener(new OnEditorActionListener() {
-
-            @Override
-            public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
-                if (actionId == EditorInfo.IME_ACTION_DONE) {
-                    addNote();
-                    return true;
-                }
-                return false;
-            }
-        });
-
-        final View button = findViewById(R.id.buttonAdd);
-        button.setEnabled(false);
-        editText.addTextChangedListener(new TextWatcher() {
-
-            @Override
-            public void onTextChanged(CharSequence s, int start, int before, int count) {
-                boolean enable = s.length() != 0;
-                button.setEnabled(enable);
-            }
-
-            @Override
-            public void beforeTextChanged(CharSequence s, int start, int count, int after) {
-            }
-
-            @Override
-            public void afterTextChanged(Editable s) {
-            }
-        });
-    }
-
-    public void onMyButtonClick(View view) {
-        addNote();
-    }
-
-    private void addNote() {
-        String noteText = editText.getText().toString();
-        editText.setText("");
-
-        final DateFormat df = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM);
-        String comment = "Added on " + df.format(new Date());
-        Note note = new Note(null, noteText, comment, new Date());
-        noteDao.insert(note);
-        Log.d("DaoExample", "Inserted new note, ID: " + note.getId());
-
-        cursor.requery();
-    }
-
-    @Override
-    protected void onListItemClick(ListView l, View v, int position, long id) {
-        noteDao.deleteByKey(id);
-        Log.d("DaoExample", "Deleted note, ID: " + id);
-        cursor.requery();
-    }
-
+/*
+ * Copyright (C) 2011 Markus Junginger, greenrobot (http://greenrobot.de)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package de.greenrobot.daoexample;
+
+import java.text.DateFormat;
+import java.util.Date;
+import java.util.List;
+
+import android.app.ListActivity;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.ProviderInfo;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.os.Bundle;
+import android.text.Editable;
+import android.text.TextWatcher;
+import android.util.Log;
+import android.view.KeyEvent;
+import android.view.View;
+import android.view.inputmethod.EditorInfo;
+import android.widget.EditText;
+import android.widget.ListView;
+import android.widget.SimpleCursorAdapter;
+import android.widget.TextView;
+import android.widget.TextView.OnEditorActionListener;
+
+import de.greenrobot.daoexample.DaoMaster.DevOpenHelper;
+
+public class NoteActivity extends ListActivity {
+
+    private SQLiteDatabase db;
+
+    private EditText editText;
+
+    private DaoMaster daoMaster;
+    private DaoSession daoSession;
+    private NoteDao noteDao;
+
+    private Cursor cursor;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        setContentView(R.layout.main);
+
+        DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, "notes-db", null);
+        db = helper.getWritableDatabase();
+        daoMaster = new DaoMaster(db);
+        daoSession = daoMaster.newSession();
+        noteDao = daoSession.getNoteDao();
+
+        String textColumn = NoteDao.Properties.Text.columnName;
+        String orderBy = textColumn + " COLLATE LOCALIZED ASC";
+        cursor = db.query(noteDao.getTablename(), noteDao.getAllColumns(), null, null, null, null, orderBy);
+        String[] from = { textColumn, NoteDao.Properties.Comment.columnName };
+        int[] to = { android.R.id.text1, android.R.id.text2 };
+
+        SimpleCursorAdapter adapter = new SimpleCursorAdapter(this, android.R.layout.simple_list_item_2, cursor, from,
+                to);
+        setListAdapter(adapter);
+
+        editText = (EditText) findViewById(R.id.editTextNote);
+        addUiListeners();
+        
+        List<PackageInfo> packs = getBaseContext().getPackageManager().getInstalledPackages(PackageManager.GET_PROVIDERS);
+        if (packs != null) {
+            for (PackageInfo pack : packs) { 
+                ProviderInfo[] providers = pack.providers; 
+                if (providers != null) { 
+                    for (ProviderInfo provider : providers) { 
+                        System.out.println(provider.readPermission+"   "+provider.writePermission+"  "+provider.authority);
+                    } 
+                }
+            }
+        }
+    }
+
+    protected void addUiListeners() {
+        editText.setOnEditorActionListener(new OnEditorActionListener() {
+
+            @Override
+            public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
+                if (actionId == EditorInfo.IME_ACTION_DONE) {
+                    addNote();
+                    return true;
+                }
+                return false;
+            }
+        });
+
+        final View button = findViewById(R.id.buttonAdd);
+        button.setEnabled(false);
+        editText.addTextChangedListener(new TextWatcher() {
+
+            @Override
+            public void onTextChanged(CharSequence s, int start, int before, int count) {
+                boolean enable = s.length() != 0;
+                button.setEnabled(enable);
+            }
+
+            @Override
+            public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+            }
+
+            @Override
+            public void afterTextChanged(Editable s) {
+            }
+        });
+    }
+
+    public void onMyButtonClick(View view) {
+        addNote();
+    }
+
+    private void addNote() {
+        String noteText = editText.getText().toString();
+        editText.setText("");
+
+        final DateFormat df = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM);
+        String comment = "Added on " + df.format(new Date());
+        Note note = new Note(null, noteText, comment, new Date());
+        noteDao.insert(note);
+        Log.d("DaoExample", "Inserted new note, ID: " + note.getId());
+
+        cursor.requery();
+    }
+
+    @Override
+    protected void onListItemClick(ListView l, View v, int position, long id) {
+        noteDao.deleteByKey(id);
+        Log.d("DaoExample", "Deleted note, ID: " + id);
+        cursor.requery();
+    }
+
 }
\ No newline at end of file
diff --git a/DaoExampleGenerator/.classpath b/DaoExampleGenerator/.classpath
index 1fe2a4f1..d9a40690 100644
--- a/DaoExampleGenerator/.classpath
+++ b/DaoExampleGenerator/.classpath
@@ -1,10 +1,12 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="GROOVY_DSL_SUPPORT"/>
-	<classpathentry kind="con" path="GROOVY_SUPPORT"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
-	<classpathentry exported="true" kind="con" path="org.springsource.ide.eclipse.gradle.classpathcontainer"/>
-	<classpathentry kind="con" path="org.springsource.ide.eclipse.gradle.dsld.classpathcontainer"/>
-	<classpathentry kind="output" path="bin"/>
-</classpath>
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
+	<classpathentry exported="true" kind="con" path="org.springsource.ide.eclipse.gradle.classpathcontainer"/>
+	<classpathentry kind="con" path="org.springsource.ide.eclipse.gradle.dsld.classpathcontainer"/>
+	<classpathentry kind="con" path="GROOVY_DSL_SUPPORT"/>
+	<classpathentry kind="con" path="GROOVY_SUPPORT"/>
+	<classpathentry kind="lib" path="/DaoGenerator"/>
+	<classpathentry kind="lib" path="/DaoGenerator/build/libs/greendao-generator-1.3.1.jar"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/DaoExampleGenerator/.settings/gradle/org.springsource.ide.eclipse.gradle.core.prefs b/DaoExampleGenerator/.settings/gradle/org.springsource.ide.eclipse.gradle.core.prefs
index c83b29e0..a6f217f0 100644
--- a/DaoExampleGenerator/.settings/gradle/org.springsource.ide.eclipse.gradle.core.prefs
+++ b/DaoExampleGenerator/.settings/gradle/org.springsource.ide.eclipse.gradle.core.prefs
@@ -1,4 +1,5 @@
-#org.springsource.ide.eclipse.gradle.core.preferences.GradleProjectPreferences
-#Sun Feb 24 10:59:34 CET 2013
-org.springsource.ide.eclipse.gradle.linkedresources=
-org.springsource.ide.eclipse.gradle.rootprojectloc=
+#org.springsource.ide.eclipse.gradle.core.preferences.GradleProjectPreferences
+#Tue Jun 02 11:26:35 CST 2015
+build.family.org.gradle.tooling.model.eclipse.HierarchicalEclipseProject=;
+org.springsource.ide.eclipse.gradle.linkedresources=
+org.springsource.ide.eclipse.gradle.rootprojectloc=
diff --git a/DaoExampleGenerator/.settings/org.eclipse.core.resources.prefs b/DaoExampleGenerator/.settings/org.eclipse.core.resources.prefs
index 3d916f29..4a39c415 100644
--- a/DaoExampleGenerator/.settings/org.eclipse.core.resources.prefs
+++ b/DaoExampleGenerator/.settings/org.eclipse.core.resources.prefs
@@ -1,2 +1,3 @@
 eclipse.preferences.version=1
+encoding//src/de/greenrobot/daogenerator/gentest/ExampleDaoGenerator.java=UTF-8
 encoding/<project>=Cp1252
diff --git a/DaoExampleGenerator/build.gradle b/DaoExampleGenerator/build.gradle
index f79e8e6e..a3bb1586 100644
--- a/DaoExampleGenerator/build.gradle
+++ b/DaoExampleGenerator/build.gradle
@@ -1,30 +1,29 @@
-apply plugin: 'java'
-apply plugin: 'maven'
-apply plugin:'application'
-
-group = 'de.greenrobot'
-version = '1.3.1-SNAPSHOT'
-sourceCompatibility = 1.6
-mainClassName = "de.greenrobot.daogenerator.gentest.ExampleDaoGenerator"
-
-repositories {
-    mavenLocal()
-    mavenCentral()
-}
-
-dependencies {
-    compile('de.greenrobot:greendao-generator:1.3.1-SNAPSHOT')
-}
-
-sourceSets {
-    main {
-        java {
-            srcDir 'src'
-            srcDir 'src-gen'
-        }
-    }
-}
-
-artifacts {
-    archives jar
-}
+apply plugin: 'java'
+apply plugin: 'maven'
+apply plugin:'application'
+
+group = 'de.greenrobot'
+version = '1.3.1-SNAPSHOT'
+sourceCompatibility = 1.6
+mainClassName = "de.greenrobot.daogenerator.gentest.ExampleDaoGenerator"
+
+repositories {
+    mavenLocal()
+    mavenCentral()
+}
+
+dependencies {
+}
+
+sourceSets {
+    main {
+        java {
+            srcDir 'src'
+            srcDir 'src-gen'
+        }
+    }
+}
+
+artifacts {
+    archives jar
+}
diff --git a/DaoExampleGenerator/src/de/greenrobot/daogenerator/gentest/ExampleDaoGenerator.java b/DaoExampleGenerator/src/de/greenrobot/daogenerator/gentest/ExampleDaoGenerator.java
index 7dde5f94..cd0c18d4 100644
--- a/DaoExampleGenerator/src/de/greenrobot/daogenerator/gentest/ExampleDaoGenerator.java
+++ b/DaoExampleGenerator/src/de/greenrobot/daogenerator/gentest/ExampleDaoGenerator.java
@@ -36,6 +36,13 @@ public static void main(String[] args) throws Exception {
         addNote(schema);
         addCustomerOrder(schema);
 
+        // 模拟生成搜狐视频相关表
+        addLocalMedia(schema);
+        addLocalPlayHistory(schema);
+        addAmericanNeighbour(schema);
+        addApkDownload(schema);
+        addPlayHistory(schema);
+
         new DaoGenerator().generateAll(schema, "../DaoExample/src-gen");
     }
 
@@ -64,4 +71,75 @@ private static void addCustomerOrder(Schema schema) {
         customerToOrders.orderAsc(orderDate);
     }
 
+    private static void addLocalMedia(Schema schema) {
+        Entity localMedia = schema.addEntity("LocalMedia");
+
+        localMedia.addIdProperty();
+        localMedia.addStringProperty("dir");
+        localMedia.addStringProperty("file");
+        localMedia.addIntProperty("size");
+    }
+
+    private static void addLocalPlayHistory(Schema schema) {
+        Entity lp = schema.addEntity("LocalPlayHistory");
+        lp.addIdProperty();
+        lp.addStringProperty("videoTitle");
+        lp.addStringProperty("playedTime");
+        lp.addIntProperty("tvLength");
+        lp.addStringProperty("lastWatchTime");
+        lp.addStringProperty("localUrl");
+    }
+
+    private static void addAmericanNeighbour(Schema schema) {
+        Entity neighBour = schema.addEntity("AmericanNeighbour");
+        neighBour.addIdProperty();
+        neighBour.addIntProperty("channel_id");
+        neighBour.addStringProperty("request_url");
+        neighBour.addStringProperty("reponse");
+        neighBour.addIntProperty("list_index");
+        neighBour.addIntProperty("update_time");
+        neighBour.addIntProperty("operation_type");
+    }
+
+    private static void addApkDownload(Schema schema) {
+        Entity down = schema.addEntity("ApkDownload");
+        down.addStringProperty("package_name");
+        down.addIntProperty("version");
+        down.addStringProperty("tip");
+        down.addStringProperty("name");
+        down.addIntProperty("downing_state");
+        down.addIntProperty("total_filesize");
+        down.addIntProperty("download_beginning");
+        down.addIntProperty("downloaded_size");
+        down.addIntProperty("download_percent");
+        down.addIntProperty("create_time");
+        down.addStringProperty("download_url");
+        down.addStringProperty("save_dir");
+        down.addStringProperty("save_name");
+    }
+
+    private static void addPlayHistory(Schema schema) {
+        Entity his = schema.addEntity("PlayHistory");
+        his.addIdProperty();
+        his.addStringProperty("playId");
+        his.addStringProperty("subjectId");
+        his.addStringProperty("videoTitle");
+        his.addStringProperty("playedTime");
+        his.addStringProperty("clientType");
+        his.addStringProperty("definition");
+        his.addStringProperty("episode");
+        his.addStringProperty("picPath");
+        his.addStringProperty("categoryId");
+        his.addIntProperty("tvLength");
+        his.addIntProperty("isSynchronized");
+        his.addStringProperty("albumName");
+        his.addIntProperty("nextplayId");
+        his.addStringProperty("lastWatchTime");
+        his.addStringProperty("passport");
+        his.addStringProperty("localUrl");
+        his.addIntProperty("tvisfee");
+        his.addIntProperty("real_playorder");
+        his.addIntProperty("site");
+    }
+
 }
diff --git a/DaoGenerator/.classpath b/DaoGenerator/.classpath
index a82e8447..e22fa60c 100644
--- a/DaoGenerator/.classpath
+++ b/DaoGenerator/.classpath
@@ -1,14 +1,13 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="src-template"/>
-	<classpathentry kind="src" path="src-test"/>
-	<classpathentry kind="src" path="src-generator-testentities"/>
-	<classpathentry kind="con" path="GROOVY_DSL_SUPPORT"/>
-	<classpathentry kind="con" path="GROOVY_SUPPORT"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
-	<classpathentry exported="true" kind="con" path="org.springsource.ide.eclipse.gradle.classpathcontainer"/>
-	<classpathentry kind="con" path="org.springsource.ide.eclipse.gradle.dsld.classpathcontainer"/>
-	<classpathentry kind="output" path="bin"/>
-</classpath>
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="src-template"/>
+	<classpathentry kind="src" path="src-test"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
+	<classpathentry exported="true" kind="con" path="org.springsource.ide.eclipse.gradle.classpathcontainer"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
+	<classpathentry kind="con" path="org.springsource.ide.eclipse.gradle.dsld.classpathcontainer"/>
+	<classpathentry kind="con" path="GROOVY_DSL_SUPPORT"/>
+	<classpathentry kind="con" path="GROOVY_SUPPORT"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/DaoGenerator/.settings/gradle/org.springsource.ide.eclipse.gradle.core.prefs b/DaoGenerator/.settings/gradle/org.springsource.ide.eclipse.gradle.core.prefs
index 734e6cba..1dbcae30 100644
--- a/DaoGenerator/.settings/gradle/org.springsource.ide.eclipse.gradle.core.prefs
+++ b/DaoGenerator/.settings/gradle/org.springsource.ide.eclipse.gradle.core.prefs
@@ -1,4 +1,5 @@
-#org.springsource.ide.eclipse.gradle.core.preferences.GradleProjectPreferences
-#Sun Feb 24 10:56:04 CET 2013
-org.springsource.ide.eclipse.gradle.linkedresources=
-org.springsource.ide.eclipse.gradle.rootprojectloc=
+#org.springsource.ide.eclipse.gradle.core.preferences.GradleProjectPreferences
+#Tue Jun 02 11:26:34 CST 2015
+build.family.org.gradle.tooling.model.eclipse.HierarchicalEclipseProject=;
+org.springsource.ide.eclipse.gradle.linkedresources=
+org.springsource.ide.eclipse.gradle.rootprojectloc=
diff --git a/DaoTest/.classpath b/DaoTest/.classpath
index 80819056..3621c31d 100644
--- a/DaoTest/.classpath
+++ b/DaoTest/.classpath
@@ -1,10 +1,10 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="src" path="src-gen"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src-gen"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/DaoTest/build.gradle b/DaoTest/build.gradle
index 4ba40c49..4db2fa5b 100644
--- a/DaoTest/build.gradle
+++ b/DaoTest/build.gradle
@@ -1,38 +1,38 @@
-buildscript {
-    repositories {
-        mavenCentral()
-    }
-
-    dependencies {
-        classpath 'com.android.tools.build:gradle:0.13.3'
-    }
-}
-
-apply plugin: 'android'
-
-dependencies {
-    androidTestCompile project(':DaoCore')
-}
-
-android {
-    buildToolsVersion '20.0.0'
-    compileSdkVersion 19
-
-    sourceSets {
-        main {
-            manifest.srcFile 'AndroidManifest.xml'
-            // Workaround: assets.srcDirs in androidTest doesn't seem to work currently
-            assets.srcDirs = ['assets']
-        }
-
-        androidTest {
-            assets.srcDirs = ['assets']
-            java.srcDirs = ['src','src-gen']
-        }
-    }
-
-    defaultConfig {
-        testApplicationId "de.greenrobot.daotest"
-        testInstrumentationRunner "android.test.InstrumentationTestRunner"
-    }
-}
+buildscript {
+    repositories {
+        mavenCentral()
+    }
+
+    dependencies {
+        classpath 'com.android.tools.build:gradle:0.13.3'
+    }
+}
+
+apply plugin: 'android'
+
+dependencies {
+    androidTestCompile project(':DaoCore')
+}
+
+android {
+    buildToolsVersion '20.0.0'
+    compileSdkVersion 19
+
+    sourceSets {
+        main {
+            manifest.srcFile 'AndroidManifest.xml'
+            // Workaround: assets.srcDirs in androidTest doesn't seem to work currently
+            assets.srcDirs = ['assets']
+        }
+
+        androidTest {
+            assets.srcDirs = ['assets']
+            java.srcDirs = ['src','src-gen']
+        }
+    }
+
+    defaultConfig {
+        testApplicationId "de.greenrobot.daotest"
+        testInstrumentationRunner "android.test.InstrumentationTestRunner"
+    }
+}
diff --git a/PerformanceTestOrmLite/.classpath b/PerformanceTestOrmLite/.classpath
index 2a829e2f..c0946bea 100644
--- a/PerformanceTestOrmLite/.classpath
+++ b/PerformanceTestOrmLite/.classpath
@@ -1,11 +1,11 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry kind="lib" path="lib/ormlite-android-4.34-SNAPSHOT.jar"/>
-	<classpathentry kind="lib" path="lib/ormlite-core-4.34-SNAPSHOT.jar"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry kind="lib" path="lib/ormlite-android-4.34-SNAPSHOT.jar"/>
+	<classpathentry kind="lib" path="lib/ormlite-core-4.34-SNAPSHOT.jar"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 54df5249..dac2de8f 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Sat May 24 08:38:11 CEST 2014
-distributionBase=GRADLE_USER_HOME
-distributionPath=wrapper/dists
-zipStoreBase=GRADLE_USER_HOME
-zipStorePath=wrapper/dists
-distributionUrl=http\://services.gradle.org/distributions/gradle-2.1-all.zip
+#Sat May 24 08:38:11 CEST 2014
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=http\://services.gradle.org/distributions/gradle-2.1-all.zip
