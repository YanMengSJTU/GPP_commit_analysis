diff --git a/DaoCore/build.xml b/DaoCore/build.xml
index cb6372cc..7559ddc9 100644
--- a/DaoCore/build.xml
+++ b/DaoCore/build.xml
@@ -1,92 +1,88 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project name="DaoCore" default="help">
-
-    <!-- The local.properties file is created and updated by the 'android' tool.
-         It contains the path to the SDK. It should *NOT* be checked into
-         Version Control Systems. -->
-    <property file="local.properties" />
-
-    <!-- The ant.properties file can be created by you. It is only edited by the
-         'android' tool to add properties to it.
-         This is the place to change some Ant specific build properties.
-         Here are some properties you may want to change/update:
-
-         source.dir
-             The name of the source directory. Default is 'src'.
-         out.dir
-             The name of the output directory. Default is 'bin'.
-
-         For other overridable properties, look at the beginning of the rules
-         files in the SDK, at tools/ant/build.xml
-
-         Properties related to the SDK location or the project target should
-         be updated using the 'android' tool with the 'update' action.
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems.
-
-         -->
-    <property file="ant.properties" />
-
-    <!-- if sdk.dir was not set from one of the property file, then
-         get it from the ANDROID_HOME env var.
-         This must be done before we load project.properties since
-         the proguard config can use sdk.dir -->
-    <property environment="env" />
-    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
-        <isset property="env.ANDROID_HOME" />
-    </condition>
-
-    <!-- The project.properties file is created and updated by the 'android'
-         tool, as well as ADT.
-
-         This contains project specific properties such as project target, and library
-         dependencies. Lower level build properties are stored in ant.properties
-         (or in .classpath for Eclipse projects).
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems. -->
-    <loadproperties srcFile="project.properties" />
-
-    <!-- quick check on sdk.dir -->
-    <fail
-            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
-            unless="sdk.dir"
-    />
-
-    <!--
-        Import per project custom build rules if present at the root of the project.
-        This is the place to put custom intermediary targets such as:
-            -pre-build
-            -pre-compile
-            -post-compile (This is typically used for code obfuscation.
-                           Compiled code location: ${out.classes.absolute.dir}
-                           If this is not done in place, override ${out.dex.input.absolute.dir})
-            -post-package
-            -post-build
-            -pre-clean
-    -->
-    <import file="custom_rules.xml" optional="true" />
-
-    <!-- Import the actual build file.
-
-         To customize existing targets, there are two options:
-         - Customize only one target:
-             - copy/paste the target into this file, *before* the
-               <import> task.
-             - customize it to your needs.
-         - Customize the whole content of build.xml
-             - copy/paste the content of the rules files (minus the top node)
-               into this file, replacing the <import> task.
-             - customize to your needs.
-
-         ***********************
-         ****** IMPORTANT ******
-         ***********************
-         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
-         in order to avoid having your file be overridden by tools such as "android update project"
-    -->
-    <!-- version-tag: 1 -->
-    <import file="${sdk.dir}/tools/ant/build.xml" />
-
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- WARNING: Eclipse auto-generated file.
+              Any modifications will be overwritten.
+              To include a user specific buildfile here, simply create one in the same
+              directory with the processing instruction <?eclipse.ant.import?>
+              as the first entry and export the buildfile again. --><project basedir="." default="build" name="DaoCore">
+    <property environment="env"/>
+    <property name="AndroidCore.location" value="../../androidcore/Android"/>
+    <property name="DaoGenerator.location" value="../DaoGenerator"/>
+    <property name="GenieCommon.location" value="../../androidcore/GenieCommon"/>
+    <property name="ECLIPSE_HOME" value="../../../droid/eclipse"/>
+    <property name="debuglevel" value="source,lines,vars"/>
+    <property name="target" value="1.6"/>
+    <property name="source" value="1.6"/>
+    <path id="Android 1.6.libraryclasspath">
+        <pathelement location="../../../android-sdk-windows/platforms/android-4/android.jar"/>
+    </path>
+    <path id="Android Private Libraries.libraryclasspath"/>
+    <path id="Android Dependencies.libraryclasspath">
+        <pathelement location="../../../android-sdk-windows/tools/support/annotations.jar"/>
+    </path>
+    <path id="DaoCore.classpath">
+        <path refid="Android 1.6.libraryclasspath"/>
+        <path refid="Android Private Libraries.libraryclasspath"/>
+        <path refid="Android Dependencies.libraryclasspath"/>
+        <pathelement location="bin/classes"/>
+    </path>
+    <target name="init">
+        <mkdir dir="bin/classes"/>
+        <copy includeemptydirs="false" todir="bin/classes">
+            <fileset dir="src">
+                <exclude name="**/*.java"/>
+            </fileset>
+        </copy>
+        <copy includeemptydirs="false" todir="bin/classes">
+            <fileset dir="gen">
+                <exclude name="**/*.java"/>
+            </fileset>
+        </copy>
+    </target>
+    <target name="clean">
+        <delete dir="bin/classes"/>
+    </target>
+    <target depends="clean" name="cleanall"/>
+    <target depends="build-subprojects,build-project" name="build"/>
+    <target name="build-subprojects"/>
+    <target depends="init" name="build-project">
+        <echo message="${ant.project.name}: ${ant.file}"/>
+        <javac debug="true" debuglevel="${debuglevel}" destdir="bin/classes" includeantruntime="false" source="${source}" target="${target}">
+            <src path="src"/>
+            <src path="gen"/>
+            <classpath refid="DaoCore.classpath"/>
+        </javac>
+    </target>
+    <target description="Build all projects which reference this project. Useful to propagate changes." name="build-refprojects">
+        <ant antfile="build.xml" dir="${AndroidCore.location}" inheritAll="false" target="clean"/>
+        <ant antfile="build.xml" dir="${AndroidCore.location}" inheritAll="false" target="build">
+            <propertyset>
+                <propertyref name="build.compiler"/>
+            </propertyset>
+        </ant>
+        <ant antfile="build.xml" dir="${DaoGenerator.location}" inheritAll="false" target="clean"/>
+        <ant antfile="build.xml" dir="${DaoGenerator.location}" inheritAll="false" target="build">
+            <propertyset>
+                <propertyref name="build.compiler"/>
+            </propertyset>
+        </ant>
+        <ant antfile="build.xml" dir="${GenieCommon.location}" inheritAll="false" target="clean"/>
+        <ant antfile="build.xml" dir="${GenieCommon.location}" inheritAll="false" target="build">
+            <propertyset>
+                <propertyref name="build.compiler"/>
+            </propertyset>
+        </ant>
+    </target>
+    <target description="copy Eclipse compiler jars to ant lib directory" name="init-eclipse-compiler">
+        <copy todir="${ant.library.dir}">
+            <fileset dir="${ECLIPSE_HOME}/plugins" includes="org.eclipse.jdt.core_*.jar"/>
+        </copy>
+        <unzip dest="${ant.library.dir}">
+            <patternset includes="jdtCompilerAdapter.jar"/>
+            <fileset dir="${ECLIPSE_HOME}/plugins" includes="org.eclipse.jdt.core_*.jar"/>
+        </unzip>
+    </target>
+    <target description="compile project with Eclipse compiler" name="build-eclipse-compiler">
+        <property name="build.compiler" value="org.eclipse.jdt.core.JDTCompilerAdapter"/>
+        <antcall target="build"/>
+    </target>
 </project>
diff --git a/DaoCore/src/de/greenrobot/dao/Property.java b/DaoCore/src/de/greenrobot/dao/Property.java
index 77923eb7..232d5efc 100644
--- a/DaoCore/src/de/greenrobot/dao/Property.java
+++ b/DaoCore/src/de/greenrobot/dao/Property.java
@@ -19,6 +19,7 @@
 import java.util.Collection;
 
 import de.greenrobot.dao.internal.SqlUtils;
+import de.greenrobot.dao.join.PropertyWithAlias;
 import de.greenrobot.dao.query.WhereCondition;
 import de.greenrobot.dao.query.WhereCondition.PropertyCondition;
 
@@ -27,19 +28,21 @@
  * 
  * @author Markus
  */
-public class Property {
+public class Property implements Selectable {
     public final int ordinal;
     public final Class<?> type;
     public final String name;
     public final boolean primaryKey;
     public final String columnName;
+    public final String tableName;
 
-    public Property(int ordinal, Class<?> type, String name, boolean primaryKey, String columnName) {
+    public Property(int ordinal, Class<?> type, String name, boolean primaryKey, String columnName, String tableName) {
         this.ordinal = ordinal;
         this.type = type;
         this.name = name;
         this.primaryKey = primaryKey;
         this.columnName = columnName;
+        this.tableName = tableName;
     }
 
     /** Creates an "equal ('=')" condition  for this property. */
@@ -116,5 +119,20 @@ public WhereCondition isNull() {
     public WhereCondition isNotNull() {
         return new PropertyCondition(this, " IS NOT NULL");
     }
+    
+    public PropertyWithAlias withAlias(String alias) {
+    	return new PropertyWithAlias(this, alias);
+    }
+    
+	@Override
+	public String getColumnName() {
+		return this.columnName;
+	}
+
+	@Override
+	public String getColumnPrefix() {
+		// TODO Auto-generated method stub
+		return this.tableName;
+	}
 
 }
diff --git a/DaoCore/src/de/greenrobot/dao/Selectable.java b/DaoCore/src/de/greenrobot/dao/Selectable.java
new file mode 100644
index 00000000..ce2ff66a
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/Selectable.java
@@ -0,0 +1,12 @@
+package de.greenrobot.dao;
+
+/**
+ * Represents a selectable item
+ * @author Stephen Dunford
+ *
+ */
+public interface Selectable {
+
+	public String getColumnName();
+	public String getColumnPrefix();
+}
diff --git a/DaoCore/src/de/greenrobot/dao/internal/DaoConfig.java b/DaoCore/src/de/greenrobot/dao/internal/DaoConfig.java
index 96473029..b5f99dfc 100644
--- a/DaoCore/src/de/greenrobot/dao/internal/DaoConfig.java
+++ b/DaoCore/src/de/greenrobot/dao/internal/DaoConfig.java
@@ -17,6 +17,7 @@
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
+import java.lang.reflect.ParameterizedType;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -54,7 +55,9 @@ public DaoConfig(SQLiteDatabase db, Class<? extends AbstractDao<?, ?>> daoClass)
         this.db = db;
         try {
             this.tablename = (String) daoClass.getField("TABLENAME").get(null);
-            Property[] properties = reflectProperties(daoClass);
+            //SD 2014-12-17 - Genie modification here, because we moved the properties from the DAO to the entity class.
+            Class<?> entityClass = (Class<?>)((ParameterizedType)daoClass.getGenericSuperclass()).getActualTypeArguments()[0];
+            Property[] properties = reflectProperties(entityClass);
             this.properties = properties;
 
             allColumns = new String[properties.length];
@@ -95,9 +98,9 @@ public DaoConfig(SQLiteDatabase db, Class<? extends AbstractDao<?, ?>> daoClass)
         }
     }
 
-    private static Property[] reflectProperties(Class<? extends AbstractDao<?, ?>> daoClass)
+    private static Property[] reflectProperties(Class<?> entityClass)
             throws ClassNotFoundException, IllegalArgumentException, IllegalAccessException {
-        Class<?> propertiesClass = Class.forName(daoClass.getName() + "$Properties");
+        Class<?> propertiesClass = Class.forName(entityClass.getName() + "$Properties");
         Field[] fields = propertiesClass.getDeclaredFields();
 
         ArrayList<Property> propertyList = new ArrayList<Property>();
diff --git a/DaoCore/src/de/greenrobot/dao/internal/SqlUtils.java b/DaoCore/src/de/greenrobot/dao/internal/SqlUtils.java
index fe1fd406..e380577c 100644
--- a/DaoCore/src/de/greenrobot/dao/internal/SqlUtils.java
+++ b/DaoCore/src/de/greenrobot/dao/internal/SqlUtils.java
@@ -40,6 +40,17 @@ public static StringBuilder appendColumns(StringBuilder builder, String tableAli
         }
         return builder;
     }
+    
+    public static StringBuilder appendColumns(StringBuilder builder, String tableAliases[], String[] columns) {
+        int length = columns.length;
+        for (int i = 0; i < length; i++) {
+            appendColumn(builder, tableAliases[i], columns[i]);
+            if (i < length - 1) {
+                builder.append(',');
+            }
+        }
+        return builder;
+    }
 
     public static StringBuilder appendColumns(StringBuilder builder, String[] columns) {
         int length = columns.length;
@@ -94,8 +105,12 @@ public static String createSqlInsert(String insertInto, String tablename, String
     }
 
     /** Creates an select for given columns with a trailing space */
-    public static String createSqlSelect(String tablename, String tableAlias, String[] columns) {
+    public static String createSqlSelect(String tablename, String tableAlias, String[] columns, boolean distinct) {
         StringBuilder builder = new StringBuilder("SELECT ");
+        
+        if(distinct) {
+        	builder.append("DISTINCT ");
+        }
         if (tableAlias == null || tableAlias.length() < 0) {
             throw new DaoException("Table alias required");
         }
@@ -104,6 +119,22 @@ public static String createSqlSelect(String tablename, String tableAlias, String
         builder.append(tablename).append(' ').append(tableAlias).append(' ');
         return builder.toString();
     }
+    
+    /** Creates an select for given columns with a trailing space */
+    public static String createSqlSelect(String tablename, String[] tableAliases, String masterAlias, String[] columns, boolean distinct) {
+        StringBuilder builder = new StringBuilder("SELECT ");
+        
+        if(distinct) {
+        	builder.append("DISTINCT ");
+        }
+        if (tableAliases == null || tableAliases.length != columns.length) {
+            throw new DaoException("Table alias required for each column");
+        }
+
+        SqlUtils.appendColumns(builder, tableAliases, columns).append(" FROM ");
+        builder.append(tablename).append(' ').append(masterAlias).append(' ');
+        return builder.toString();
+    }
 
     /** Creates SELECT COUNT(*) with a trailing space. */
     public static String createSqlSelectCountStar(String tablename, String tableAliasOrNull) {
diff --git a/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java b/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java
index db85526f..753d7fe2 100644
--- a/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java
+++ b/DaoCore/src/de/greenrobot/dao/internal/TableStatements.java
@@ -74,34 +74,50 @@ public SQLiteStatement getUpdateStatement() {
         return updateStatement;
     }
 
-    /** ends with an space to simplify appending to this string. */
     public String getSelectAll() {
+    	return getSelectAll(false);
+    }
+    
+    /** ends with an space to simplify appending to this string. */
+    public String getSelectAll(boolean distinct) {
         if (selectAll == null) {
-            selectAll = SqlUtils.createSqlSelect(tablename, "T", allColumns);
+            selectAll = SqlUtils.createSqlSelect(tablename, "T", allColumns, distinct);
         }
         return selectAll;
     }
     
+    public String getSelectColumns(String[] columns, String[] aliases) {
+    	return getSelectColumns(columns, aliases, false);
+    }
+    
     /** ends with an space to simplify appending to this string. */
-    public String getSelectColumns(String[] columns) {
+    public String getSelectColumns(String[] columns, String[] aliases, boolean distinct) {
         if (selectAll == null) {
-            selectAll = SqlUtils.createSqlSelect(tablename, "T", columns);
+            selectAll = SqlUtils.createSqlSelect(tablename, aliases, "T", columns, distinct);
         }
         return selectAll;
     }
 
-    /** ends with an space to simplify appending to this string. */
     public String getSelectKeys() {
+    	return getSelectKeys(false);
+    }
+    
+    /** ends with an space to simplify appending to this string. */
+    public String getSelectKeys(boolean distinct) {
         if (selectKeys == null) {
-            selectKeys = SqlUtils.createSqlSelect(tablename, "T", pkColumns);
+            selectKeys = SqlUtils.createSqlSelect(tablename, "T", pkColumns, distinct);
         }
         return selectKeys;
     }
 
-    // TODO precompile
     public String getSelectByKey() {
+    	return getSelectByKey(false);
+    }
+    
+    // TODO precompile
+    public String getSelectByKey(boolean distinct) {
         if (selectByKey == null) {
-            StringBuilder builder = new StringBuilder(getSelectAll());
+            StringBuilder builder = new StringBuilder(getSelectAll(distinct));
             builder.append("WHERE ");
             SqlUtils.appendColumnsEqValue(builder, "T", pkColumns);
             selectByKey = builder.toString();
@@ -110,8 +126,13 @@ public String getSelectByKey() {
     }
 
     public String getSelectByRowId() {
+    	return getSelectByRowId(false);
+    }
+    
+    
+    public String getSelectByRowId(boolean distinct) {
         if (selectByRowId == null) {
-            selectByRowId = getSelectAll() + "WHERE ROWID=?";
+            selectByRowId = getSelectAll(distinct) + "WHERE ROWID=?";
         }
         return selectByRowId;
     }
diff --git a/DaoCore/src/de/greenrobot/dao/join/JoinBuilder.java b/DaoCore/src/de/greenrobot/dao/join/JoinBuilder.java
new file mode 100644
index 00000000..1f3fda12
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/join/JoinBuilder.java
@@ -0,0 +1,86 @@
+package de.greenrobot.dao.join;
+
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.Selectable;
+import de.greenrobot.dao.query.QueryBuilder;
+
+public class JoinBuilder<T> {
+
+	private QueryBuilder<T> mQueryBuilder;
+	private String mJoinTable;
+	private String mJoinTableAlias;
+	private JoinType mJoinType;
+	private String mSourceProperty;
+	private String mDestProperty;
+	
+	public JoinBuilder(QueryBuilder<T> queryBuilder, String joinTable, JoinType joinType) {
+		mQueryBuilder = queryBuilder;
+		mJoinTable = joinTable;
+		mJoinType = joinType;
+	}
+	
+	public JoinBuilder<T> alias(String joinTableAlias) {
+		mJoinTableAlias = joinTableAlias;
+		return this;
+	}
+
+	private String getQualitifedColumn(Selectable column) {
+		if(mQueryBuilder.isMasterTable(column.getColumnPrefix())) {
+			return "T." + column.getColumnName();
+		} else {
+			return column.getColumnPrefix() + "." + column.getColumnName();
+		}
+	}
+	
+	public QueryBuilder<T> on(Selectable sourceProperty, Selectable destProperty) {
+		return on(getQualitifedColumn(sourceProperty), getQualitifedColumn(destProperty));
+	}
+	
+	public QueryBuilder<T> on(Selectable sourceProperty, String destProperty) {
+		return on(getQualitifedColumn(sourceProperty), destProperty);
+	}
+	
+	public QueryBuilder<T> on(String sourceProperty, Selectable destProperty) {
+		return on(sourceProperty, getQualitifedColumn(destProperty));
+	}
+	
+	public QueryBuilder<T> on(String sourceProperty, String destProperty) {
+		mSourceProperty = sourceProperty;
+		mDestProperty = destProperty;
+		return mQueryBuilder;
+	}
+	
+	public String getJoinClause() {
+		StringBuilder sb = new StringBuilder();
+		
+		sb.append(getJoinSql());
+		sb.append(getJoinToSql());
+		sb.append("ON ");
+		sb.append(mSourceProperty);
+		sb.append(" = ");
+		sb.append(mDestProperty);
+		sb.append(" ");
+		return sb.toString();
+	}
+	
+	private String getJoinToSql() {
+		String joinTo = "[" + mJoinTable + "] ";
+		if(mJoinTableAlias != null && mJoinTableAlias.length() > 0) {
+			joinTo +=  mJoinTableAlias + " ";
+		}
+		
+		return joinTo;
+	}
+	
+	
+	private String getJoinSql() {
+		switch(mJoinType) {
+		case Left:
+			return "LEFT JOIN ";
+		case Cross:
+			return "CROSS JOIN ";
+		default:
+			return "INNER JOIN ";
+		}
+	}
+}
diff --git a/DaoCore/src/de/greenrobot/dao/join/JoinCondition.java b/DaoCore/src/de/greenrobot/dao/join/JoinCondition.java
new file mode 100644
index 00000000..6ce41996
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/join/JoinCondition.java
@@ -0,0 +1,5 @@
+package de.greenrobot.dao.join;
+
+public class JoinCondition {
+
+}
diff --git a/DaoCore/src/de/greenrobot/dao/join/JoinType.java b/DaoCore/src/de/greenrobot/dao/join/JoinType.java
new file mode 100644
index 00000000..47b1b79b
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/join/JoinType.java
@@ -0,0 +1,7 @@
+package de.greenrobot.dao.join;
+
+public enum JoinType {
+	Inner,
+	Left,
+	Cross
+}
diff --git a/DaoCore/src/de/greenrobot/dao/join/PropertyWithAlias.java b/DaoCore/src/de/greenrobot/dao/join/PropertyWithAlias.java
new file mode 100644
index 00000000..6562019e
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/join/PropertyWithAlias.java
@@ -0,0 +1,32 @@
+package de.greenrobot.dao.join;
+
+import de.greenrobot.dao.Property;
+import de.greenrobot.dao.Selectable;
+
+/**
+ * Allows attaching of a table alias to a property
+ * @author Stephen Dunford
+ *
+ */
+public class PropertyWithAlias implements Selectable {
+
+	private final Property property;
+	private String alias;
+	
+	public PropertyWithAlias(Property property, String alias) {
+		this.property = property;
+		this.alias = alias;
+	}
+	
+	@Override
+	public String getColumnName() {
+		return property.columnName;
+	}
+
+	@Override
+	public String getColumnPrefix() {
+		// TODO Auto-generated method stub
+		return alias;
+	}
+	
+}
diff --git a/DaoCore/src/de/greenrobot/dao/query/FieldType.java b/DaoCore/src/de/greenrobot/dao/query/FieldType.java
new file mode 100644
index 00000000..0fa03a2e
--- /dev/null
+++ b/DaoCore/src/de/greenrobot/dao/query/FieldType.java
@@ -0,0 +1,9 @@
+package de.greenrobot.dao.query;
+
+public enum FieldType {
+	String,
+	Long,
+	Int,
+	Double,
+	ByteArray
+}
diff --git a/DaoCore/src/de/greenrobot/dao/query/Query.java b/DaoCore/src/de/greenrobot/dao/query/Query.java
index 4d08527e..f0164bc3 100644
--- a/DaoCore/src/de/greenrobot/dao/query/Query.java
+++ b/DaoCore/src/de/greenrobot/dao/query/Query.java
@@ -15,12 +15,14 @@
  */
 package de.greenrobot.dao.query;
 
+import java.util.ArrayList;
 import java.util.List;
 
 import android.database.Cursor;
 import android.os.Process;
 import de.greenrobot.dao.AbstractDao;
 import de.greenrobot.dao.DaoException;
+import de.greenrobot.dao.Property;
 
 /**
  * A repeatable query returning entities.
@@ -121,6 +123,199 @@ public void setOffset(int offset) {
         return daoAccess.loadAllAndCloseCursor(cursor);
     }
     
+    /**
+     * Returns a single string field of a list of results
+     * @param property		The property to retrieve
+     * @param fieldType		The type of the property
+     * @return				The values of the property for all matches
+     */
+    public List<String> listOfFieldAsString(Property property) {
+    	List<Object> values = listOfField(property, FieldType.String);
+    	
+    	List<String> typedValues = new ArrayList<String>();
+    	
+    	for(Object value: values) {
+    		typedValues.add((String)value);
+    	}
+    	
+    	return typedValues;
+    }
+    
+    /**
+     * Returns a double field of a list of results
+     * @param property		The property to retrieve
+     * @param fieldType		The type of the property
+     * @return				The values of the property for all matches
+     */
+    public List<Double> listOfFieldAsDouble(Property property) {
+    	List<Object> values = listOfField(property, FieldType.Double);
+    	
+    	List<Double> typedValues = new ArrayList<Double>();
+    	
+    	for(Object value: values) {
+    		typedValues.add((Double)value);
+    	}
+    	
+    	return typedValues;
+    }
+    
+    /**
+     * Returns an integer field of a list of results
+     * @param property		The property to retrieve
+     * @param fieldType		The type of the property
+     * @return				The values of the property for all matches
+     */
+    public List<Integer> listOfFieldAsInt(Property property) {
+    	List<Object> values = listOfField(property, FieldType.Int);
+    	
+    	List<Integer> typedValues = new ArrayList<Integer>();
+    	
+    	for(Object value: values) {
+    		typedValues.add((Integer)value);
+    	}
+    	
+    	return typedValues;
+    }
+    
+    /**
+     * Returns a long field of a list of results
+     * @param property		The property to retrieve
+     * @param fieldType		The type of the property
+     * @return				The values of the property for all matches
+     */
+    public List<Long> listOfFieldAsLong(Property property) {
+    	List<Object> values = listOfField(property, FieldType.Long);
+    	
+    	List<Long> typedValues = new ArrayList<Long>();
+    	
+    	for(Object value: values) {
+    		typedValues.add((Long)value);
+    	}
+    	
+    	return typedValues;
+    }
+    
+    /**
+     * Returns a byte array string field of a list of results
+     * @param property		The property to retrieve
+     * @param fieldType		The type of the property
+     * @return				The values of the property for all matches
+     */
+    public List<Byte[]> listOfFieldAsByteArray(Property property) {
+    	List<Object> values = listOfField(property, FieldType.ByteArray);
+    	
+    	List<Byte[]> typedValues = new ArrayList<Byte[]>();
+    	
+    	for(Object value: values) {
+    		typedValues.add((Byte[])value);
+    	}
+    	
+    	return typedValues;
+    }
+    
+    /**
+     * Returns a single field of a single result as a string
+     * @param property		The property to retrieve
+     * @return				The value of the property
+     */
+    public String uniqueFieldAsString(Property property) {
+    	return (String)uniqueField(property, FieldType.String);
+    }
+    
+    /**
+     * Returns a single field of a single result as an int
+     * @param property		The property to retrieve
+     * @return				The value of the property
+     */
+    public Integer uniqueFieldAsInt(Property property) {
+    	return (Integer)uniqueField(property, FieldType.Int);
+    }
+    
+    /**
+     * Returns a single field of a single result as a double
+     * @param property		The property to retrieve
+     * @return				The value of the property
+     */
+    public Double uniqueFieldAsDouble(Property property) {
+    	return (Double)uniqueField(property, FieldType.Double);
+    }
+    
+    /**
+     * Returns a single field of a single result as a long
+     * @param property		The property to retrieve
+     * @return				The value of the property
+     */
+    public Long uniqueFieldAsLong(Property property) {
+    	return (Long)uniqueField(property, FieldType.Long);
+    }
+    
+    /**
+     * Returns a single field of a single result as a byte array
+     * @param property		The property to retrieve
+     * @return				The value of the property
+     */
+    public Byte[] uniqueFieldAsByteArray(Property property) {
+    	return (Byte[])uniqueField(property, FieldType.ByteArray);
+    }
+    
+    /**
+     * Returns a single field of a single result
+     * @param property		The property to retrieve
+     * @param fieldType		The type of the property
+     * @return				The value of the property
+     */
+    public Object uniqueField(Property property, FieldType fieldType) {
+    	checkThread();
+        Cursor cursor = dao.getDatabase().rawQuery(sql, parameters);
+        
+        int columnIndex = cursor.getColumnIndex(property.columnName);
+        
+        if(cursor.moveToNext()) {
+        	return getValueFromCursor(cursor, columnIndex, fieldType);
+        }
+        
+        return null;
+    }
+    
+    /**
+     * Returns a single field of a list of results
+     * @param property		The property to retrieve
+     * @param fieldType		The type of the property
+     * @return				The values of the property for all matches
+     */
+    public List<Object> listOfField(Property property, FieldType fieldType) {
+    	checkThread();
+        Cursor cursor = dao.getDatabase().rawQuery(sql, parameters);
+        
+        List<Object> toReturn = new ArrayList<Object>();
+        
+        int columnIndex = cursor.getColumnIndex(property.columnName);
+        
+        while(cursor.moveToNext()) {
+        	toReturn.add(getValueFromCursor(cursor, columnIndex, fieldType));
+        }
+        
+        return toReturn;
+    }
+    
+    
+    private Object getValueFromCursor(Cursor cursor, int columnIndex, FieldType fieldType) {
+    	switch(fieldType) {
+	    	case ByteArray:
+	    		return cursor.getBlob(columnIndex);
+	    	case Double:
+	    		return cursor.getDouble(columnIndex);
+	    	case String:
+	    		return cursor.getString(columnIndex);
+	    	case Int:
+	    		return cursor.getInt(columnIndex);
+	    	case Long:
+	    		return cursor.getLong(columnIndex);
+	    	}
+    	
+    	return null;
+    }
+    
     /** Executes the query and returns the results as a cursor. */
     public Cursor cursor() {
         checkThread();
diff --git a/DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java b/DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java
index e8f9fa19..8c310bf1 100644
--- a/DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java
+++ b/DaoCore/src/de/greenrobot/dao/query/QueryBuilder.java
@@ -26,7 +26,10 @@
 import de.greenrobot.dao.DaoLog;
 import de.greenrobot.dao.InternalQueryDaoAccess;
 import de.greenrobot.dao.Property;
+import de.greenrobot.dao.Selectable;
 import de.greenrobot.dao.internal.SqlUtils;
+import de.greenrobot.dao.join.JoinBuilder;
+import de.greenrobot.dao.join.JoinType;
 import de.greenrobot.dao.query.WhereCondition.PropertyCondition;
 
 /**
@@ -55,8 +58,9 @@
     public static boolean LOG_VALUES;
 
     private StringBuilder orderBuilder;
-    private StringBuilder joinBuilder;
 
+    private List<JoinBuilder<T>> joinBuilders;
+    
     private final List<WhereCondition> whereConditions;
 
     private final List<Object> values;
@@ -66,8 +70,10 @@
     private Integer limit;
 
     private Integer offset;
+    private boolean distinct;
     
     private String[] selectColumns;
+    private String[] tableAliases;
 
     /** For internal use by greenDAO only. */
     public static <T2> QueryBuilder<T2> internalCreate(AbstractDao<T2, ?> dao) {
@@ -83,6 +89,7 @@ protected QueryBuilder(AbstractDao<T, ?> dao, String tablePrefix) {
         this.tablePrefix = tablePrefix;
         values = new ArrayList<Object>();
         whereConditions = new ArrayList<WhereCondition>();
+        joinBuilders = new ArrayList<JoinBuilder<T>>();
     }
 
     private void checkOrderBuilder() {
@@ -163,17 +170,138 @@ protected void checkCondition(WhereCondition whereCondition) {
     }
 
     /** Not supported yet. */
-    public <J> QueryBuilder<J> join(Class<J> entityClass, Property toOneProperty) {
-        throw new UnsupportedOperationException();
-        // return new QueryBuilder<J>();
+//    public <J> QueryBuilder<J> join(Class<J> entityClass, Property toOneProperty) {
+//        throw new UnsupportedOperationException();
+//        // return new QueryBuilder<J>();
+//    }
+//
+//    /** Not supported yet. */
+//    public <J> QueryBuilder<J> joinToMany(Class<J> entityClass, Property toManyProperty) {
+//        throw new UnsupportedOperationException();
+//        // @SuppressWarnings("unchecked")
+//        // AbstractDao<J, ?> joinDao = (AbstractDao<J, ?>) dao.getSession().getDao(entityClass);
+//        // return new QueryBuilder<J>(joinDao, "TX");
+//    }
+    
+    /**
+     * Performs an inner join to the table represented by the specified entity class
+     * @param entityClass		Class of the entity representing the table to join to
+     */
+    public JoinBuilder<T> innerJoin(Class<?> entityClass) {
+    	return join(entityClass, null, JoinType.Inner);
     }
-
-    /** Not supported yet. */
-    public <J> QueryBuilder<J> joinToMany(Class<J> entityClass, Property toManyProperty) {
-        throw new UnsupportedOperationException();
-        // @SuppressWarnings("unchecked")
-        // AbstractDao<J, ?> joinDao = (AbstractDao<J, ?>) dao.getSession().getDao(entityClass);
-        // return new QueryBuilder<J>(joinDao, "TX");
+    
+    /**
+     * Performs an inner join to the table represented by the specified entity class
+     * @param entityClass		Class of the entity representing the table to join to
+     */
+    public JoinBuilder<T> innerJoin(Class<?> entityClass, String alias) {
+    	return join(entityClass, alias, JoinType.Inner);
+    }
+    
+    /**
+     * Performs an inner join to the table with the specified name
+     * @param tableName		The table to join to
+     */
+    public JoinBuilder<T> innerJoin(String tableName) {
+    	return join(tableName, null, JoinType.Inner);
+    }
+    
+    /**
+     * Performs an inner join to the table with the specified name
+     * @param tableName		The table to join to
+     */
+    public JoinBuilder<T> innerJoin(String tableName, String alias) {
+    	return join(tableName, alias, JoinType.Inner);
+    }
+    
+    /**
+     * Performs a left join to the table represented by the specified entity class
+     * @param entityClass		Class of the entity representing the table to join to
+     */
+    public JoinBuilder<T> leftJoin(Class<?> entityClass) {
+    	return join(entityClass, null, JoinType.Left);
+    }
+    
+    /**
+     * Performs a left join to the table represented by the specified entity class
+     * @param entityClass		Class of the entity representing the table to join to
+     */
+    public JoinBuilder<T> leftJoin(Class<?> entityClass, String alias) {
+    	return join(entityClass, alias, JoinType.Left);
+    }
+    
+    /**
+     * Performs a left outer join to the table with the specified name
+     * @param tableName		The table to join to
+     */
+    public JoinBuilder<T> leftJoin(String tableName) {
+    	return join(tableName, null, JoinType.Left);
+    }
+    
+    /**
+     * Performs a left outer join to the table with the specified name
+     * @param tableName		The table to join to
+     */
+    public JoinBuilder<T> leftJoin(String tableName, String alias) {
+    	return join(tableName, alias, JoinType.Left);
+    }
+    
+    /**
+     * Performs a left join to the table represented by the specified entity class
+     * @param entityClass		Class of the entity representing the table to join to
+     */
+    public JoinBuilder<T> crossJoin(Class<?> entityClass) {
+    	return join(entityClass, null, JoinType.Left);
+    }
+    
+    /**
+     * Performs a left join to the table represented by the specified entity class
+     * @param entityClass		Class of the entity representing the table to join to
+     * @param alias				The alias to use for the table
+     */
+    public JoinBuilder<T> crossJoin(Class<?> entityClass, String alias) {
+    	return join(entityClass, alias, JoinType.Left);
+    }
+    
+    /**
+     * Performs a cross join to the table with the specified name
+     * @param tableName		The table to join to
+     */
+    public JoinBuilder<T> crossJoin(String tableName) {
+    	return join(tableName, null, JoinType.Cross);
+    }
+    
+    /**
+     * Performs a cross join to the table with the specified name
+     * @param tableName		The table to join to
+     * @param alias			The alias to use for the table
+     */
+    public JoinBuilder<T> crossJoin(String tableName, String alias) {
+    	return join(tableName, alias, JoinType.Cross);
+    }
+    
+    private JoinBuilder<T> join(Class<?> entityClass, String alias, JoinType joinType) {
+    	try 
+    	{
+    		String tableName = (String)entityClass.getField("TABLE_NAME").get(null);
+    		return join(tableName, alias, joinType);
+    		
+    	} catch(IllegalAccessException ex) {
+    		return null;
+    	} catch(NoSuchFieldException ex) {
+    		return null;
+    	}
+    }
+    
+    private JoinBuilder<T> join(String tableName, String alias, JoinType joinType) {
+    	
+    	final JoinBuilder<T> jBuilder = new JoinBuilder<T>(this,tableName,joinType);
+    	jBuilder.alias(alias);
+    	
+    	joinBuilders.add(jBuilder);
+    	
+    	return jBuilder;
     }
 
     /** Adds the given properties to the ORDER BY section using ascending order. */
@@ -222,15 +350,28 @@ private void orderAscOrDesc(String ascOrDescWithLeadingSpace, Property... proper
      * @param properties
      * @return
      */
-    public QueryBuilder<T> select(Property...properties) {
+    public QueryBuilder<T> select(Selectable...properties) {
+    	
     	selectColumns = new String[properties.length];
+    	tableAliases = new String[properties.length];
     	
     	for(int ii = 0; ii < properties.length; ii++) {
-    		selectColumns[ii] = properties[ii].columnName;
+   		
+    		selectColumns[ii] = properties[ii].getColumnName();
+    		
+    		if(isMasterTable(properties[ii].getColumnPrefix())) {
+    			tableAliases[ii] = "T";
+    		} else {
+    			tableAliases[ii] = properties[ii].getColumnPrefix();
+    		}
     	}
     	
     	return this;
     }
+    
+    public boolean isMasterTable(String tableName) {
+    	return dao.getTablename().equalsIgnoreCase(tableName);
+    }
 
     protected StringBuilder append(StringBuilder builder, Property property) {
         checkProperty(property);
@@ -268,6 +409,11 @@ protected void checkProperty(Property property) {
         this.offset = offset;
         return this;
     }
+    
+    public QueryBuilder<T> distinct() {
+    	this.distinct = true;
+    	return this;
+    }
 
     /**
      * Builds a reusable query object (Query objects can be executed more efficiently than creating a QueryBuilder for
@@ -275,20 +421,18 @@ protected void checkProperty(Property property) {
      */
     public Query<T> build() {
         String select;
-        if (joinBuilder == null || joinBuilder.length() == 0) {
-        	if(selectColumns != null) {
-        		select = InternalQueryDaoAccess.getStatements(dao).getSelectColumns(selectColumns);
-        	} else {
-        		select = InternalQueryDaoAccess.getStatements(dao).getSelectAll();	
-        	}
-        } else {
-        	if(selectColumns != null) {
-        		select = SqlUtils.createSqlSelect(dao.getTablename(), tablePrefix, selectColumns);
-        	} else {
-        		select = SqlUtils.createSqlSelect(dao.getTablename(), tablePrefix, dao.getAllColumns());	
-        	}
-        }
+        
+    	if(selectColumns != null) {
+    		select = InternalQueryDaoAccess.getStatements(dao).getSelectColumns(selectColumns, tableAliases, distinct);
+    	} else {
+    		select = InternalQueryDaoAccess.getStatements(dao).getSelectAll(distinct);	
+    	}
+        
         StringBuilder builder = new StringBuilder(select);
+        
+        for(JoinBuilder<T> jBuilder : joinBuilders) {
+        	builder.append(jBuilder.getJoinClause());
+        }
 
         appendWhereClause(builder, tablePrefix);
 
@@ -399,6 +543,14 @@ private void appendWhereClause(StringBuilder builder, String tablePrefixOrNull)
     public List<T> list() {
         return build().list();
     }
+    
+    public List<String> listOfFieldAsString(Property property) {
+        return select(property).build().listOfFieldAsString(property);
+    }
+    
+    public String uniqueFieldAsString(Property property) {
+        return select(property).build().uniqueFieldAsString(property);
+    }
 
     /**
      * Shorthand for {@link QueryBuilder#build() build()}.{@link Query#listLazy() listLazy()}; see
diff --git a/DaoGenerator/src-template/dao.ftl b/DaoGenerator/src-template/dao.ftl
index 2d2107de..7481009e 100644
--- a/DaoGenerator/src-template/dao.ftl
+++ b/DaoGenerator/src-template/dao.ftl
@@ -64,17 +64,7 @@ import ${entity.javaPackage}.${entity.className}.Builder;
 public class ${entity.classNameDao} extends AbstractDao<${entity.className}, ${entity.pkType}> {
 
     public static final String TABLENAME = "${entity.tableName}";
-
-    /**
-     * Properties of entity ${entity.className}.<br/>
-     * Can be used for QueryBuilder and for referencing column names.
-    */
-    public static class Properties {
-<#list entity.propertiesColumns as property>
-        public final static Property ${property.propertyName?cap_first} = new Property(${property_index}, ${property.javaType}.class, "${property.propertyName}", ${property.primaryKey?string}, "${property.columnName}");
-</#list>
-    };
-    
+   
 <#if entity.active>
     private DaoSession daoSession;
 
diff --git a/DaoGenerator/src-template/entity.ftl b/DaoGenerator/src-template/entity.ftl
index 959aa228..3cb5c97e 100644
--- a/DaoGenerator/src-template/entity.ftl
+++ b/DaoGenerator/src-template/entity.ftl
@@ -22,6 +22,7 @@ along with greenDAO Generator.  If not, see <http://www.gnu.org/licenses/>.
 <#assign complexTypes = ["String", "ByteArray", "Date"]/>
 package ${entity.javaPackage};
 
+import de.greenrobot.dao.Property;
 <#if entity.toManyRelations?has_content>
 import java.util.List;
 </#if>
@@ -87,9 +88,21 @@ ${keepFields!}    // KEEP FIELDS END
 
 </#if>
 
+    /**
+     * Properties of entity ${entity.className}.<br/>
+     * Can be used for QueryBuilder and for referencing column names.
+    */
+    public static class Properties {
+<#list entity.propertiesColumns as property>
+        public final static Property ${property.propertyName?cap_first} = new Property(${property_index}, ${property.javaType}.class, "${property.propertyName}", ${property.primaryKey?string}, "${property.columnName}", "${entity.tableName}");
+</#list>
+    };
+    
+    public static final String TABLE_NAME = "${entity.tableName}";
+    
 	@Override
 	public String getTableName() {
-		return "${entity.tableName}";
+		return TABLE_NAME; 
 	}
 
 
