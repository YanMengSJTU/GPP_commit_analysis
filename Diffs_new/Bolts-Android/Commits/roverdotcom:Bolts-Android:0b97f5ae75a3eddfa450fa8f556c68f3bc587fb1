diff --git a/bolts-tasks/src/main/java/bolts/Task.java b/bolts-tasks/src/main/java/bolts/Task.java
index aa72632..9d63213 100644
--- a/bolts-tasks/src/main/java/bolts/Task.java
+++ b/bolts-tasks/src/main/java/bolts/Task.java
@@ -20,12 +20,13 @@
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
 /**
  * Represents the result of an asynchronous operation.
- * 
+ *
  * @param <TResult>
  *          The type of the result of the task.
  */
@@ -114,6 +115,30 @@ public TResult getResult() {
     }
   }
 
+  /**
+   * @return The result of the task.
+   */
+  public TResult waitAndGetResult() throws InterruptedException, TimeoutException {
+    return waitAndGetResult(0, TimeUnit.MILLISECONDS);
+  }
+
+  /**
+   * @return The result of the task.
+   */
+  public TResult waitAndGetResult(long duration, TimeUnit timeUnit) throws InterruptedException, TimeoutException {
+    synchronized (lock) {
+      if (!waitForCompletion(duration, timeUnit))
+        throw new TimeoutException();
+      if (isFaulted()) {
+        throw new RuntimeException(getError());
+      }
+      if (isCancelled()) {
+        throw new TaskCanceledException(this);
+      }
+      return result;
+    }
+  }
+
   /**
    * @return The error for the task, if set. {@code null} otherwise.
    */
@@ -340,7 +365,7 @@ public void run() {
    *
    * @param tasks
    *          The tasks to wait on for completion.
-   * @return A task that represents the completion of one of the supplied tasks. 
+   * @return A task that represents the completion of one of the supplied tasks.
    *         The return task's result is the task that completed.
    */
   public static <TResult> Task<Task<TResult>> whenAnyResult(Collection<? extends Task<TResult>> tasks) {
@@ -374,7 +399,7 @@ public Void then(Task<TResult> task) {
    *
    * @param tasks
    *          The tasks to wait on for completion.
-   * @return A task that represents the completion of one of the supplied tasks. 
+   * @return A task that represents the completion of one of the supplied tasks.
    *         The return task's Result is the task that completed.
    */
   @SuppressWarnings("unchecked")
@@ -382,10 +407,10 @@ public Void then(Task<TResult> task) {
     if (tasks.size() == 0) {
       return Task.forResult(null);
     }
-      
+
     final bolts.TaskCompletionSource<Task<?>> firstCompleted = new bolts.TaskCompletionSource<>();
     final AtomicBoolean isAnyTaskComplete = new AtomicBoolean(false);
-      
+
     for (Task<?> task : tasks) {
       ((Task<Object>) task).continueWith(new Continuation<Object, Void>() {
         @Override
diff --git a/bolts-tasks/src/main/java/bolts/TaskCanceledException.java b/bolts-tasks/src/main/java/bolts/TaskCanceledException.java
new file mode 100644
index 0000000..e1d37f3
--- /dev/null
+++ b/bolts-tasks/src/main/java/bolts/TaskCanceledException.java
@@ -0,0 +1,26 @@
+package bolts;
+
+/**
+ * Represents an exception used to communicate task cancellation.
+ */
+public class TaskCanceledException extends RuntimeException {
+  private final Task<?> canceledTask;
+
+  /**
+   * Constructs a new {@code TaskCanceledException} with the current stack trace, and with a
+   * reference to the task that is the cause of this exception.
+   *
+   * @param canceledTask
+   *            The task that was canceled.
+   */
+  TaskCanceledException(Task<?> canceledTask) {
+    this.canceledTask = canceledTask;
+  }
+
+  /**
+   * @return The task associated with this exception.
+   */
+  public Task<?> getTask() {
+    return canceledTask;
+  }
+}
diff --git a/bolts-tasks/src/test/java/bolts/TaskTest.java b/bolts-tasks/src/test/java/bolts/TaskTest.java
index 910a867..71858ca 100644
--- a/bolts-tasks/src/test/java/bolts/TaskTest.java
+++ b/bolts-tasks/src/test/java/bolts/TaskTest.java
@@ -20,6 +20,7 @@
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import static org.junit.Assert.assertEquals;
@@ -85,6 +86,78 @@ public void testPrimitives() {
     assertTrue(cancelled.isCancelled());
   }
 
+  @Test
+  public void testWaitAndGetResultSuccess() throws InterruptedException, TimeoutException {
+    Task<Integer> complete = Task.forResult(5);
+
+    assertEquals(5, complete.waitAndGetResult().intValue());
+  }
+
+  @Test(expected = RuntimeException.class)
+  public void testWaitAndGetResultError() throws InterruptedException, TimeoutException {
+    Task<Integer> error = Task.forError(new RuntimeException());
+
+    assertEquals(5, error.waitAndGetResult().intValue());
+  }
+
+  @Test(expected = TaskCanceledException.class)
+  public void testWaitAndGetResultCanceled() throws InterruptedException, TimeoutException {
+    Task<Integer> cancelled = Task.cancelled();
+
+    assertEquals(5, cancelled.waitAndGetResult().intValue());
+  }
+
+  @Test
+  public void testWaitAndGetResultDelayedSuccess() throws InterruptedException, TimeoutException {
+    final Task<Integer> complete = Task.forResult(5);
+    Task<Integer> task = Task.delay(200).continueWithTask(new Continuation<Void, Task<Integer>>() {
+      @Override
+      public Task<Integer> then(Task<Void> task) throws Exception {
+        return complete;
+      }
+    });
+
+    assertEquals(5, task.waitAndGetResult().intValue());
+  }
+
+  @Test(expected = RuntimeException.class)
+  public void testWaitAndGetResultDelayedError() throws InterruptedException, TimeoutException {
+    final Task<Integer> error = Task.forError(new RuntimeException());
+    Task<Integer> task = Task.delay(200).continueWithTask(new Continuation<Void, Task<Integer>>() {
+      @Override
+      public Task<Integer> then(Task<Void> task) throws Exception {
+        return error;
+      }
+    });
+
+    assertEquals(5, task.waitAndGetResult().intValue());
+  }
+
+  @Test(expected = TaskCanceledException.class)
+  public void testWaitAndGetResultDelayedCanceled() throws InterruptedException, TimeoutException {
+    final Task<Integer> cancelled = Task.cancelled();
+    Task<Integer> task = Task.delay(200).continueWithTask(new Continuation<Void, Task<Integer>>() {
+      @Override
+      public Task<Integer> then(Task<Void> task) throws Exception {
+        return cancelled;
+      }
+    });
+
+    assertEquals(5, task.waitAndGetResult().intValue());
+  }
+
+  @Test(expected = TimeoutException.class)
+  public void testWaitAndGetResultTimeOut() throws InterruptedException, TimeoutException {
+    Task<Integer> task = Task.delay(5000).continueWith(new Continuation<Void, Integer>() {
+      @Override
+      public Integer then(Task<Void> task) throws Exception {
+        return 5;
+      }
+    });
+
+    assertEquals(5, task.waitAndGetResult(1, TimeUnit.MILLISECONDS).intValue());
+  }
+
   @Test
   public void testDelay() throws InterruptedException {
     final Task<Void> delayed = Task.delay(200);
