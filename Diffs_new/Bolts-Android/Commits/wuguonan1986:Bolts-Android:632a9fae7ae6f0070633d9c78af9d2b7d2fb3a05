diff --git a/bolts-android/build.gradle b/bolts-android/build.gradle
index bc0b35a..4f1e3f9 100644
--- a/bolts-android/build.gradle
+++ b/bolts-android/build.gradle
@@ -25,8 +25,8 @@ android {
 }
 
 dependencies {
-    compile project(':bolts-tasks')
-    compile project(':bolts-applinks')
+//    compile project(':bolts-tasks')
+//    compile project(':bolts-applinks')
 }
 
 android.libraryVariants.all { variant ->
diff --git a/bolts-tasks/src/main/java/bolts/AggregateException.java b/bolts-tasks/src/main/java/bolts/AggregateException.java
index 5123e13..07d19a0 100644
--- a/bolts-tasks/src/main/java/bolts/AggregateException.java
+++ b/bolts-tasks/src/main/java/bolts/AggregateException.java
@@ -3,7 +3,7 @@
  *  All rights reserved.
  *
  *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant 
+ *  LICENSE file in the root directory of this source tree. An additional grant
  *  of patent rights can be found in the PATENTS file in the same directory.
  *
  */
@@ -22,116 +22,114 @@
  * @see Task#whenAll(java.util.Collection)
  */
 public class AggregateException extends Exception {
-  private static final long serialVersionUID = 1L;
-
-  private static final String DEFAULT_MESSAGE = "There were multiple errors.";
-
-  private List<Throwable> innerThrowables;
-
-  /**
-   * Constructs a new {@code AggregateException} with the current stack trace, the specified detail
-   * message and with references to the inner throwables that are the cause of this exception.
-   *
-   * @param detailMessage
-   *            The detail message for this exception.
-   * @param innerThrowables
-   *            The exceptions that are the cause of the current exception.
-   */
-  public AggregateException(String detailMessage, Throwable[] innerThrowables) {
-    this(detailMessage, Arrays.asList(innerThrowables));
-  }
-
-
-  /**
-   * Constructs a new {@code AggregateException} with the current stack trace, the specified detail
-   * message and with references to the inner throwables that are the cause of this exception.
-   *
-   * @param detailMessage
-   *            The detail message for this exception.
-   * @param innerThrowables
-   *            The exceptions that are the cause of the current exception.
-   */
-  public AggregateException(String detailMessage, List<? extends Throwable> innerThrowables) {
-    super(detailMessage,
-        innerThrowables != null && innerThrowables.size() > 0 ? innerThrowables.get(0) : null);
-    this.innerThrowables = Collections.unmodifiableList(innerThrowables);
-  }
-
-  /**
-   * Constructs a new {@code AggregateException} with the current stack trace and with references to
-   * the inner throwables that are the cause of this exception.
-   *
-   * @param innerThrowables
-   *            The exceptions that are the cause of the current exception.
-   */
-  public AggregateException(List<? extends Throwable> innerThrowables) {
-    this(DEFAULT_MESSAGE, innerThrowables);
-  }
-
-  /**
-   * Returns a read-only {@link List} of the {@link Throwable} instances that caused the current
-   * exception.
-   */
-  public List<Throwable> getInnerThrowables() {
-    return innerThrowables;
-  }
-
-  @Override
-  public void printStackTrace(PrintStream err) {
-    super.printStackTrace(err);
-
-    int currentIndex = -1;
-    for (Throwable throwable : innerThrowables) {
-      err.append("\n");
-      err.append("  Inner throwable #");
-      err.append(Integer.toString(++currentIndex));
-      err.append(": ");
-      throwable.printStackTrace(err);
-      err.append("\n");
+    private static final long serialVersionUID = 1L;
+
+    private static final String DEFAULT_MESSAGE = "There were multiple errors.";
+
+    private List<Throwable> innerThrowables;
+
+    /**
+     * Constructs a new {@code AggregateException} with the current stack trace, the specified
+     * detail
+     * message and with references to the inner throwables that are the cause of this exception.
+     *
+     * @param detailMessage   The detail message for this exception.
+     * @param innerThrowables The exceptions that are the cause of the current exception.
+     */
+    public AggregateException(String detailMessage, Throwable[] innerThrowables) {
+        this(detailMessage, Arrays.asList(innerThrowables));
     }
-  }
-
-  @Override
-  public void printStackTrace(PrintWriter err) {
-    super.printStackTrace(err);
-
-    int currentIndex = -1;
-    for (Throwable throwable : innerThrowables) {
-      err.append("\n");
-      err.append("  Inner throwable #");
-      err.append(Integer.toString(++currentIndex));
-      err.append(": ");
-      throwable.printStackTrace(err);
-      err.append("\n");
+
+
+    /**
+     * Constructs a new {@code AggregateException} with the current stack trace, the specified
+     * detail
+     * message and with references to the inner throwables that are the cause of this exception.
+     *
+     * @param detailMessage   The detail message for this exception.
+     * @param innerThrowables The exceptions that are the cause of the current exception.
+     */
+    public AggregateException(String detailMessage, List<? extends Throwable> innerThrowables) {
+        super(detailMessage, innerThrowables != null && innerThrowables.size() > 0 ?
+                innerThrowables.get(0) : null);
+        this.innerThrowables = Collections.unmodifiableList(innerThrowables);
+    }
+
+    /**
+     * Constructs a new {@code AggregateException} with the current stack trace and with
+     * references to
+     * the inner throwables that are the cause of this exception.
+     *
+     * @param innerThrowables The exceptions that are the cause of the current exception.
+     */
+    public AggregateException(List<? extends Throwable> innerThrowables) {
+        this(DEFAULT_MESSAGE, innerThrowables);
+    }
+
+    /**
+     * Returns a read-only {@link List} of the {@link Throwable} instances that caused the current
+     * exception.
+     */
+    public List<Throwable> getInnerThrowables() {
+        return innerThrowables;
     }
-  }
-
-  /**
-   * @deprecated Please use {@link #getInnerThrowables()} instead.
-   */
-  @Deprecated
-  public List<Exception> getErrors() {
-    List<Exception> errors = new ArrayList<Exception>();
-    if (innerThrowables == null) {
-      return errors;
+
+    @Override
+    public void printStackTrace(PrintStream err) {
+        super.printStackTrace(err);
+
+        int currentIndex = -1;
+        for (Throwable throwable : innerThrowables) {
+            err.append("\n");
+            err.append("  Inner throwable #");
+            err.append(Integer.toString(++currentIndex));
+            err.append(": ");
+            throwable.printStackTrace(err);
+            err.append("\n");
+        }
+    }
+
+    @Override
+    public void printStackTrace(PrintWriter err) {
+        super.printStackTrace(err);
+
+        int currentIndex = -1;
+        for (Throwable throwable : innerThrowables) {
+            err.append("\n");
+            err.append("  Inner throwable #");
+            err.append(Integer.toString(++currentIndex));
+            err.append(": ");
+            throwable.printStackTrace(err);
+            err.append("\n");
+        }
+    }
+
+    /**
+     * @deprecated Please use {@link #getInnerThrowables()} instead.
+     */
+    @Deprecated
+    public List<Exception> getErrors() {
+        List<Exception> errors = new ArrayList<Exception>();
+        if (innerThrowables == null) {
+            return errors;
+        }
+
+        for (Throwable cause : innerThrowables) {
+            if (cause instanceof Exception) {
+                errors.add((Exception) cause);
+            } else {
+                errors.add(new Exception(cause));
+            }
+        }
+        return errors;
     }
 
-    for (Throwable cause : innerThrowables) {
-      if (cause instanceof Exception) {
-        errors.add((Exception) cause);
-      } else {
-        errors.add(new Exception(cause));
-      }
+    /**
+     * @deprecated Please use {@link #getInnerThrowables()} instead.
+     */
+    @Deprecated
+    public Throwable[] getCauses() {
+        return innerThrowables.toArray(new Throwable[innerThrowables.size()]);
     }
-    return errors;
-  }
-
-  /**
-   * @deprecated Please use {@link #getInnerThrowables()} instead.
-   */
-  @Deprecated
-  public Throwable[] getCauses() {
-    return innerThrowables.toArray(new Throwable[innerThrowables.size()]);
-  }
 
 }
diff --git a/bolts-tasks/src/main/java/bolts/AndroidExecutors.java b/bolts-tasks/src/main/java/bolts/AndroidExecutors.java
index 483776a..33c2f16 100644
--- a/bolts-tasks/src/main/java/bolts/AndroidExecutors.java
+++ b/bolts-tasks/src/main/java/bolts/AndroidExecutors.java
@@ -24,12 +24,12 @@
 /**
  * This was created because the helper methods in {@link java.util.concurrent.Executors} do not work
  * as people would normally expect.
- *
+ * <p>
  * Normally, you would think that a cached thread pool would create new threads when necessary,
  * queue them when the pool is full, and kill threads when they've been inactive for a certain
  * period of time. This is not how {@link java.util.concurrent.Executors#newCachedThreadPool()}
  * works.
- *
+ * <p>
  * Instead, {@link java.util.concurrent.Executors#newCachedThreadPool()} executes all tasks on
  * a new or cached thread immediately because corePoolSize is 0, SynchronousQueue is a queue with
  * size 0 and maxPoolSize is Integer.MAX_VALUE. This is dangerous because it can create an unchecked
@@ -37,105 +37,100 @@
  */
 /* package */ final class AndroidExecutors {
 
-  private static final AndroidExecutors INSTANCE = new AndroidExecutors();
-
-  private final Executor uiThread;
-
-  private AndroidExecutors() {
-    uiThread = new UIThreadExecutor();
-  }
-
-  /**
-   * Nexus 5: Quad-Core
-   * Moto X: Dual-Core
-   *
-   * AsyncTask:
-   *   CORE_POOL_SIZE = CPU_COUNT + 1
-   *   MAX_POOL_SIZE = CPU_COUNT * 2 + 1
-   *
-   * https://github.com/android/platform_frameworks_base/commit/719c44e03b97e850a46136ba336d729f5fbd1f47
-   */
-  private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
-  /* package */ static final int CORE_POOL_SIZE = CPU_COUNT + 1;
-  /* package */ static final int MAX_POOL_SIZE = CPU_COUNT * 2 + 1;
-  /* package */ static final long KEEP_ALIVE_TIME = 1L;
-
-  /**
-   * Creates a proper Cached Thread Pool. Tasks will reuse cached threads if available
-   * or create new threads until the core pool is full. tasks will then be queued. If an
-   * task cannot be queued, a new thread will be created unless this would exceed max pool
-   * size, then the task will be rejected. Threads will time out after 1 second.
-   *
-   * Core thread timeout is only available on android-9+.
-   *
-   * @return the newly created thread pool
-   */
-  public static ExecutorService newCachedThreadPool() {
-    ThreadPoolExecutor executor =  new ThreadPoolExecutor(
-        CORE_POOL_SIZE,
-        MAX_POOL_SIZE,
-        KEEP_ALIVE_TIME, TimeUnit.SECONDS,
-        new LinkedBlockingQueue<Runnable>());
-
-    allowCoreThreadTimeout(executor, true);
-
-    return executor;
-  }
-
-  /**
-   * Creates a proper Cached Thread Pool. Tasks will reuse cached threads if available
-   * or create new threads until the core pool is full. tasks will then be queued. If an
-   * task cannot be queued, a new thread will be created unless this would exceed max pool
-   * size, then the task will be rejected. Threads will time out after 1 second.
-   *
-   * Core thread timeout is only available on android-9+.
-   *
-   * @param threadFactory the factory to use when creating new threads
-   * @return the newly created thread pool
-   */
-  public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
-    ThreadPoolExecutor executor =  new ThreadPoolExecutor(
-            CORE_POOL_SIZE,
-            MAX_POOL_SIZE,
-            KEEP_ALIVE_TIME, TimeUnit.SECONDS,
-            new LinkedBlockingQueue<Runnable>(),
-            threadFactory);
-
-    allowCoreThreadTimeout(executor, true);
-
-    return executor;
-  }
-
-  /**
-   * Compatibility helper function for
-   * {@link java.util.concurrent.ThreadPoolExecutor#allowCoreThreadTimeOut(boolean)}
-   *
-   * Only available on android-9+.
-   *
-   * @param executor the {@link java.util.concurrent.ThreadPoolExecutor}
-   * @param value true if should time out, else false
-   */
-  @SuppressLint("NewApi")
-  public static void allowCoreThreadTimeout(ThreadPoolExecutor executor, boolean value) {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {
-      executor.allowCoreThreadTimeOut(value);
+    private static final AndroidExecutors INSTANCE = new AndroidExecutors();
+
+    private final Executor uiThread;
+
+    private AndroidExecutors() {
+        uiThread = new UIThreadExecutor();
     }
-  }
-
-  /**
-   * An {@link java.util.concurrent.Executor} that executes tasks on the UI thread.
-   */
-  public static Executor uiThread() {
-    return INSTANCE.uiThread;
-  }
-
-  /**
-   * An {@link java.util.concurrent.Executor} that runs tasks on the UI thread.
-   */
-  private static class UIThreadExecutor implements Executor {
-    @Override
-    public void execute(Runnable command) {
-      new Handler(Looper.getMainLooper()).post(command);
+
+    /**
+     * Nexus 5: Quad-Core
+     * Moto X: Dual-Core
+     * <p>
+     * AsyncTask:
+     * CORE_POOL_SIZE = CPU_COUNT + 1
+     * MAX_POOL_SIZE = CPU_COUNT * 2 + 1
+     * <p>
+     * https://github.com/android/platform_frameworks_base/commit
+     * /719c44e03b97e850a46136ba336d729f5fbd1f47
+     */
+    private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
+    /* package */ static final int CORE_POOL_SIZE = CPU_COUNT + 1;
+    /* package */ static final int MAX_POOL_SIZE = CPU_COUNT * 2 + 1;
+    /* package */ static final long KEEP_ALIVE_TIME = 1L;
+
+    /**
+     * Creates a proper Cached Thread Pool. Tasks will reuse cached threads if available
+     * or create new threads until the core pool is full. tasks will then be queued. If an
+     * task cannot be queued, a new thread will be created unless this would exceed max pool
+     * size, then the task will be rejected. Threads will time out after 1 second.
+     * <p>
+     * Core thread timeout is only available on android-9+.
+     *
+     * @return the newly created thread pool
+     */
+    public static ExecutorService newCachedThreadPool() {
+        ThreadPoolExecutor executor = new ThreadPoolExecutor(CORE_POOL_SIZE, MAX_POOL_SIZE,
+                KEEP_ALIVE_TIME, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
+
+        allowCoreThreadTimeout(executor, true);
+
+        return executor;
+    }
+
+    /**
+     * Creates a proper Cached Thread Pool. Tasks will reuse cached threads if available
+     * or create new threads until the core pool is full. tasks will then be queued. If an
+     * task cannot be queued, a new thread will be created unless this would exceed max pool
+     * size, then the task will be rejected. Threads will time out after 1 second.
+     * <p>
+     * Core thread timeout is only available on android-9+.
+     *
+     * @param threadFactory the factory to use when creating new threads
+     * @return the newly created thread pool
+     */
+    public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
+        ThreadPoolExecutor executor = new ThreadPoolExecutor(CORE_POOL_SIZE, MAX_POOL_SIZE,
+                KEEP_ALIVE_TIME, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),
+                threadFactory);
+
+        allowCoreThreadTimeout(executor, true);
+
+        return executor;
+    }
+
+    /**
+     * Compatibility helper function for
+     * {@link java.util.concurrent.ThreadPoolExecutor#allowCoreThreadTimeOut(boolean)}
+     * <p>
+     * Only available on android-9+.
+     *
+     * @param executor the {@link java.util.concurrent.ThreadPoolExecutor}
+     * @param value    true if should time out, else false
+     */
+    @SuppressLint("NewApi")
+    public static void allowCoreThreadTimeout(ThreadPoolExecutor executor, boolean value) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {
+            executor.allowCoreThreadTimeOut(value);
+        }
+    }
+
+    /**
+     * An {@link java.util.concurrent.Executor} that executes tasks on the UI thread.
+     */
+    public static Executor uiThread() {
+        return INSTANCE.uiThread;
+    }
+
+    /**
+     * An {@link java.util.concurrent.Executor} that runs tasks on the UI thread.
+     */
+    private static class UIThreadExecutor implements Executor {
+        @Override
+        public void execute(Runnable command) {
+            new Handler(Looper.getMainLooper()).post(command);
+        }
     }
-  }
 }
diff --git a/bolts-tasks/src/main/java/bolts/BoltsExecutors.java b/bolts-tasks/src/main/java/bolts/BoltsExecutors.java
index cbab41a..1813f40 100644
--- a/bolts-tasks/src/main/java/bolts/BoltsExecutors.java
+++ b/bolts-tasks/src/main/java/bolts/BoltsExecutors.java
@@ -11,104 +11,107 @@
  */
 /* package */ final class BoltsExecutors {
 
-  private static final BoltsExecutors INSTANCE = new BoltsExecutors();
+    private static final BoltsExecutors INSTANCE = new BoltsExecutors();
 
-  private static boolean isAndroidRuntime() {
-    String javaRuntimeName = System.getProperty("java.runtime.name");
-    if (javaRuntimeName == null) {
-      return false;
+    private static boolean isAndroidRuntime() {
+        String javaRuntimeName = System.getProperty("java.runtime.name");
+        if (javaRuntimeName == null) {
+            return false;
+        }
+        return javaRuntimeName.toLowerCase(Locale.US).contains("android");
     }
-    return javaRuntimeName.toLowerCase(Locale.US).contains("android");
-  }
-
-  private final ExecutorService background;
-  private final ScheduledExecutorService scheduled;
-  private final Executor immediate;
 
-  private BoltsExecutors() {
-    background = !isAndroidRuntime()
-        ? java.util.concurrent.Executors.newCachedThreadPool()
-        : AndroidExecutors.newCachedThreadPool();
-    scheduled = Executors.newSingleThreadScheduledExecutor();
-    immediate = new ImmediateExecutor();
-  }
+    private final ExecutorService background;
+    private final ScheduledExecutorService scheduled;
+    private final Executor immediate;
 
-  /**
-   * An {@link java.util.concurrent.Executor} that executes tasks in parallel.
-   */
-  public static ExecutorService background() {
-    return INSTANCE.background;
-  }
-
-  /* package */ static ScheduledExecutorService scheduled() {
-    return INSTANCE.scheduled;
-  }
+    private BoltsExecutors() {
+        background = !isAndroidRuntime() ? java.util.concurrent.Executors.newCachedThreadPool() :
+                AndroidExecutors.newCachedThreadPool();
+        scheduled = Executors.newSingleThreadScheduledExecutor();
+        immediate = new ImmediateExecutor();
+    }
 
-  /**
-   * An {@link java.util.concurrent.Executor} that executes tasks in the current thread unless
-   * the stack runs too deep, at which point it will delegate to {@link BoltsExecutors#background}
-   * in order to trim the stack.
-   */
-  /* package */ static Executor immediate() {
-    return INSTANCE.immediate;
-  }
+    /**
+     * An {@link java.util.concurrent.Executor} that executes tasks in parallel.
+     */
+    public static ExecutorService background() {
+        return INSTANCE.background;
+    }
 
-  /**
-   * An {@link java.util.concurrent.Executor} that runs a runnable inline (rather than scheduling it
-   * on a thread pool) as long as the recursion depth is less than MAX_DEPTH. If the executor has
-   * recursed too deeply, it will instead delegate to the {@link Task#BACKGROUND_EXECUTOR} in order
-   * to trim the stack.
-   */
-  private static class ImmediateExecutor implements Executor {
-    private static final int MAX_DEPTH = 15;
-    private ThreadLocal<Integer> executionDepth = new ThreadLocal<>();
+    /* package */
+    static ScheduledExecutorService scheduled() {
+        return INSTANCE.scheduled;
+    }
 
     /**
-     * Increments the depth.
-     *
-     * @return the new depth value.
+     * An {@link java.util.concurrent.Executor} that executes tasks in the current thread unless
+     * the stack runs too deep, at which point it will delegate to {@link BoltsExecutors#background}
+     * in order to trim the stack.
      */
-    private int incrementDepth() {
-      Integer oldDepth = executionDepth.get();
-      if (oldDepth == null) {
-        oldDepth = 0;
-      }
-      int newDepth = oldDepth + 1;
-      executionDepth.set(newDepth);
-      return newDepth;
+    /* package */
+    static Executor immediate() {
+        return INSTANCE.immediate;
     }
 
     /**
-     * Decrements the depth.
-     *
-     * @return the new depth value.
+     * An {@link java.util.concurrent.Executor} that runs a runnable inline (rather than
+     * scheduling it
+     * on a thread pool) as long as the recursion depth is less than MAX_DEPTH. If the executor has
+     * recursed too deeply, it will instead delegate to the {@link Task#BACKGROUND_EXECUTOR} in
+     * order
+     * to trim the stack.
      */
-    private int decrementDepth() {
-      Integer oldDepth = executionDepth.get();
-      if (oldDepth == null) {
-        oldDepth = 0;
-      }
-      int newDepth = oldDepth - 1;
-      if (newDepth == 0) {
-        executionDepth.remove();
-      } else {
-        executionDepth.set(newDepth);
-      }
-      return newDepth;
-    }
+    private static class ImmediateExecutor implements Executor {
+        private static final int MAX_DEPTH = 15;
+        private ThreadLocal<Integer> executionDepth = new ThreadLocal<>();
+
+        /**
+         * Increments the depth.
+         *
+         * @return the new depth value.
+         */
+        private int incrementDepth() {
+            Integer oldDepth = executionDepth.get();
+            if (oldDepth == null) {
+                oldDepth = 0;
+            }
+            int newDepth = oldDepth + 1;
+            executionDepth.set(newDepth);
+            return newDepth;
+        }
+
+        /**
+         * Decrements the depth.
+         *
+         * @return the new depth value.
+         */
+        private int decrementDepth() {
+            Integer oldDepth = executionDepth.get();
+            if (oldDepth == null) {
+                oldDepth = 0;
+            }
+            int newDepth = oldDepth - 1;
+            if (newDepth == 0) {
+                executionDepth.remove();
+            } else {
+                executionDepth.set(newDepth);
+            }
+            return newDepth;
+        }
 
-    @Override
-    public void execute(Runnable command) {
-      int depth = incrementDepth();
-      try {
-        if (depth <= MAX_DEPTH) {
-          command.run();
-        } else {
-          BoltsExecutors.background().execute(command);
+        @Override
+        public void execute(Runnable command) {
+            int depth = incrementDepth();
+            try {
+                if (depth <= MAX_DEPTH) {
+                    command.run();
+                } else {
+                    BoltsExecutors.background().execute(command);
+                }
+            } finally {
+                decrementDepth();
+            }
         }
-      } finally {
-        decrementDepth();
-      }
     }
-  }
 }
diff --git a/bolts-tasks/src/main/java/bolts/CancellationToken.java b/bolts-tasks/src/main/java/bolts/CancellationToken.java
index dd6b536..e1e0b7c 100644
--- a/bolts-tasks/src/main/java/bolts/CancellationToken.java
+++ b/bolts-tasks/src/main/java/bolts/CancellationToken.java
@@ -9,8 +9,6 @@
  */
 package bolts;
 
-import java.util.ArrayList;
-import java.util.List;
 import java.util.Locale;
 import java.util.concurrent.CancellationException;
 
@@ -21,7 +19,8 @@
  * {@code CancellationTokenSource#getToken()} to the asynchronous operation(s).
  * Call {@code CancellationTokenSource#cancel()} to cancel the operations.
  * <p/>
- * A {@code CancellationToken} can only be cancelled once - it should not be passed to future operations
+ * A {@code CancellationToken} can only be cancelled once - it should not be passed to future
+ * operations
  * once cancelled.
  *
  * @see CancellationTokenSource
@@ -31,43 +30,44 @@
  */
 public class CancellationToken {
 
-  private final CancellationTokenSource tokenSource;
+    private final CancellationTokenSource tokenSource;
 
-  /* package */ CancellationToken(CancellationTokenSource tokenSource) {
-    this.tokenSource = tokenSource;
-  }
+    /* package */ CancellationToken(CancellationTokenSource tokenSource) {
+        this.tokenSource = tokenSource;
+    }
 
-  /**
-   * @return {@code true} if the cancellation was requested from the source, {@code false} otherwise.
-   */
-  public boolean isCancellationRequested() {
-    return tokenSource.isCancellationRequested();
-  }
+    /**
+     * @return {@code true} if the cancellation was requested from the source, {@code false}
+     * otherwise.
+     */
+    public boolean isCancellationRequested() {
+        return tokenSource.isCancellationRequested();
+    }
 
-  /**
-   * Registers a runnable that will be called when this CancellationToken is canceled.
-   * If this token is already in the canceled state, the runnable will be run immediately and synchronously.
-   * @param action the runnable to be run when the token is cancelled.
-   * @return a {@link CancellationTokenRegistration} instance that can be used to unregister
-   * the action.
-   */
-  public CancellationTokenRegistration register(Runnable action) {
-    return tokenSource.register(action);
-  }
+    /**
+     * Registers a runnable that will be called when this CancellationToken is canceled.
+     * If this token is already in the canceled state, the runnable will be run immediately and
+     * synchronously.
+     *
+     * @param action the runnable to be run when the token is cancelled.
+     * @return a {@link CancellationTokenRegistration} instance that can be used to unregister
+     * the action.
+     */
+    public CancellationTokenRegistration register(Runnable action) {
+        return tokenSource.register(action);
+    }
 
-  /**
-   * @throws CancellationException if this token has had cancellation requested.
-   * May be used to stop execution of a thread or runnable.
-   */
-  public void throwIfCancellationRequested() throws CancellationException {
-    tokenSource.throwIfCancellationRequested();
-  }
+    /**
+     * @throws CancellationException if this token has had cancellation requested.
+     *                               May be used to stop execution of a thread or runnable.
+     */
+    public void throwIfCancellationRequested() throws CancellationException {
+        tokenSource.throwIfCancellationRequested();
+    }
 
-  @Override
-  public String toString() {
-    return String.format(Locale.US, "%s@%s[cancellationRequested=%s]",
-        getClass().getName(),
-        Integer.toHexString(hashCode()),
-        Boolean.toString(tokenSource.isCancellationRequested()));
-  }
+    @Override
+    public String toString() {
+        return String.format(Locale.US, "%s@%s[cancellationRequested=%s]", getClass().getName(),
+                Integer.toHexString(hashCode()), Boolean.toString(tokenSource.isCancellationRequested()));
+    }
 }
diff --git a/bolts-tasks/src/main/java/bolts/CancellationTokenRegistration.java b/bolts-tasks/src/main/java/bolts/CancellationTokenRegistration.java
index 1e2cc7e..efd4998 100644
--- a/bolts-tasks/src/main/java/bolts/CancellationTokenRegistration.java
+++ b/bolts-tasks/src/main/java/bolts/CancellationTokenRegistration.java
@@ -18,45 +18,46 @@
  */
 public class CancellationTokenRegistration implements Closeable {
 
-  private final Object lock = new Object();
-  private CancellationTokenSource tokenSource;
-  private Runnable action;
-  private boolean closed;
-
-  /* package */ CancellationTokenRegistration(CancellationTokenSource tokenSource, Runnable action) {
-    this.tokenSource = tokenSource;
-    this.action = action;
-  }
-
-  /**
-   * Unregisters the callback runnable from the cancellation token.
-   */
-  @Override
-  public void close() {
-    synchronized (lock) {
-      if (closed) {
-        return;
-      }
-
-      closed = true;
-      tokenSource.unregister(this);
-      tokenSource = null;
-      action = null;
+    private final Object lock = new Object();
+    private CancellationTokenSource tokenSource;
+    private Runnable action;
+    private boolean closed;
+
+    /* package */ CancellationTokenRegistration(CancellationTokenSource tokenSource, Runnable
+            action) {
+        this.tokenSource = tokenSource;
+        this.action = action;
     }
-  }
 
-  /* package */ void runAction() {
-    synchronized (lock) {
-      throwIfClosed();
-      action.run();
-      close();
+    /**
+     * Unregisters the callback runnable from the cancellation token.
+     */
+    @Override
+    public void close() {
+        synchronized (lock) {
+            if (closed) {
+                return;
+            }
+
+            closed = true;
+            tokenSource.unregister(this);
+            tokenSource = null;
+            action = null;
+        }
     }
-  }
 
-  private void throwIfClosed() {
-    if (closed) {
-      throw new IllegalStateException("Object already closed");
+    /* package */ void runAction() {
+        synchronized (lock) {
+            throwIfClosed();
+            action.run();
+            close();
+        }
+    }
+
+    private void throwIfClosed() {
+        if (closed) {
+            throw new IllegalStateException("Object already closed");
+        }
     }
-  }
 
 }
diff --git a/bolts-tasks/src/main/java/bolts/CancellationTokenSource.java b/bolts-tasks/src/main/java/bolts/CancellationTokenSource.java
index 2ae70a4..8412e5b 100644
--- a/bolts-tasks/src/main/java/bolts/CancellationTokenSource.java
+++ b/bolts-tasks/src/main/java/bolts/CancellationTokenSource.java
@@ -28,184 +28,188 @@
  */
 public class CancellationTokenSource implements Closeable {
 
-  private final Object lock = new Object();
-  private final List<CancellationTokenRegistration> registrations = new ArrayList<>();
-  private final ScheduledExecutorService executor = BoltsExecutors.scheduled();
-  private ScheduledFuture<?> scheduledCancellation;
-  private boolean cancellationRequested;
-  private boolean closed;
-
-  /**
-   * Create a new {@code CancellationTokenSource}.
-   */
-  public CancellationTokenSource() {
-  }
-
-  /**
-   * @return {@code true} if cancellation has been requested for this {@code CancellationTokenSource}.
-   */
-  public boolean isCancellationRequested() {
-    synchronized (lock) {
-      throwIfClosed();
-      return cancellationRequested;
+    private final Object lock = new Object();
+    private final List<CancellationTokenRegistration> registrations = new ArrayList<>();
+    private final ScheduledExecutorService executor = BoltsExecutors.scheduled();
+    private ScheduledFuture<?> scheduledCancellation;
+    private boolean cancellationRequested;
+    private boolean closed;
+
+    /**
+     * Create a new {@code CancellationTokenSource}.
+     */
+    public CancellationTokenSource() {
     }
-  }
-
-  /**
-   * @return the token that can be passed to asynchronous method to control cancellation.
-   */
-  public CancellationToken getToken() {
-    synchronized (lock) {
-      throwIfClosed();
-      return new CancellationToken(this);
+
+    /**
+     * @return {@code true} if cancellation has been requested for this {@code
+     * CancellationTokenSource}.
+     */
+    public boolean isCancellationRequested() {
+        synchronized (lock) {
+            throwIfClosed();
+            return cancellationRequested;
+        }
     }
-  }
-
-  /**
-   * Cancels the token if it has not already been cancelled.
-   */
-  public void cancel() {
-    List<CancellationTokenRegistration> registrations;
-    synchronized (lock) {
-      throwIfClosed();
-      if (cancellationRequested) {
-        return;
-      }
-
-      cancelScheduledCancellation();
-
-      cancellationRequested = true;
-      registrations = new ArrayList<>(this.registrations);
+
+    /**
+     * @return the token that can be passed to asynchronous method to control cancellation.
+     */
+    public CancellationToken getToken() {
+        synchronized (lock) {
+            throwIfClosed();
+            return new CancellationToken(this);
+        }
     }
-    notifyListeners(registrations);
-  }
-
-  /**
-   * Schedules a cancel operation on this {@code CancellationTokenSource} after the specified number of milliseconds.
-   * @param delay The number of milliseconds to wait before completing the returned task. If delay is {@code 0}
-   *              the cancel is executed immediately. If delay is {@code -1} any scheduled cancellation is stopped.
-   */
-  public void cancelAfter(final long delay) {
-    cancelAfter(delay, TimeUnit.MILLISECONDS);
-  }
-
-  private void cancelAfter(long delay, TimeUnit timeUnit) {
-    if (delay < -1) {
-      throw new IllegalArgumentException("Delay must be >= -1");
+
+    /**
+     * Cancels the token if it has not already been cancelled.
+     */
+    public void cancel() {
+        List<CancellationTokenRegistration> registrations;
+        synchronized (lock) {
+            throwIfClosed();
+            if (cancellationRequested) {
+                return;
+            }
+
+            cancelScheduledCancellation();
+
+            cancellationRequested = true;
+            registrations = new ArrayList<>(this.registrations);
+        }
+        notifyListeners(registrations);
     }
 
-    if (delay == 0) {
-      cancel();
-      return;
+    /**
+     * Schedules a cancel operation on this {@code CancellationTokenSource} after the specified
+     * number of milliseconds.
+     *
+     * @param delay The number of milliseconds to wait before completing the returned task. If
+     *              delay is {@code 0}
+     *              the cancel is executed immediately. If delay is {@code -1} any scheduled
+     *              cancellation is stopped.
+     */
+    public void cancelAfter(final long delay) {
+        cancelAfter(delay, TimeUnit.MILLISECONDS);
     }
 
-    synchronized (lock) {
-      if (cancellationRequested) {
-        return;
-      }
+    private void cancelAfter(long delay, TimeUnit timeUnit) {
+        if (delay < -1) {
+            throw new IllegalArgumentException("Delay must be >= -1");
+        }
 
-      cancelScheduledCancellation();
+        if (delay == 0) {
+            cancel();
+            return;
+        }
 
-      if (delay != -1) {
-        scheduledCancellation = executor.schedule(new Runnable() {
-          @Override
-          public void run() {
-            synchronized (lock) {
-              scheduledCancellation = null;
+        synchronized (lock) {
+            if (cancellationRequested) {
+                return;
             }
-            cancel();
-          }
-        }, delay, timeUnit);
-      }
+
+            cancelScheduledCancellation();
+
+            if (delay != -1) {
+                scheduledCancellation = executor.schedule(new Runnable() {
+                    @Override
+                    public void run() {
+                        synchronized (lock) {
+                            scheduledCancellation = null;
+                        }
+                        cancel();
+                    }
+                }, delay, timeUnit);
+            }
+        }
+    }
+
+    @Override
+    public void close() {
+        synchronized (lock) {
+            if (closed) {
+                return;
+            }
+
+            cancelScheduledCancellation();
+
+            List<CancellationTokenRegistration> registrations = new ArrayList<>(this.registrations);
+            for (CancellationTokenRegistration registration : registrations) {
+                registration.close();
+            }
+            this.registrations.clear();
+            closed = true;
+        }
     }
-  }
-
-  @Override
-  public void close() {
-    synchronized (lock) {
-      if (closed) {
-        return;
-      }
-
-      cancelScheduledCancellation();
-
-      List<CancellationTokenRegistration> registrations = new ArrayList<>(this.registrations);
-      for (CancellationTokenRegistration registration : registrations) {
-        registration.close();
-      }
-      this.registrations.clear();
-      closed = true;
+
+    /* package */ CancellationTokenRegistration register(Runnable action) {
+        CancellationTokenRegistration ctr;
+        synchronized (lock) {
+            throwIfClosed();
+
+            ctr = new CancellationTokenRegistration(this, action);
+            if (cancellationRequested) {
+                ctr.runAction();
+            } else {
+                registrations.add(ctr);
+            }
+        }
+        return ctr;
     }
-  }
-
-  /* package */ CancellationTokenRegistration register(Runnable action) {
-    CancellationTokenRegistration ctr;
-    synchronized (lock) {
-      throwIfClosed();
-
-      ctr = new CancellationTokenRegistration(this, action);
-      if (cancellationRequested) {
-        ctr.runAction();
-      } else {
-        registrations.add(ctr);
-      }
+
+    /**
+     * @throws CancellationException if this token has had cancellation requested.
+     *                               May be used to stop execution of a thread or runnable.
+     */
+    /* package */ void throwIfCancellationRequested() throws CancellationException {
+        synchronized (lock) {
+            throwIfClosed();
+            if (cancellationRequested) {
+                throw new CancellationException();
+            }
+        }
     }
-    return ctr;
-  }
-
-  /**
-   * @throws CancellationException if this token has had cancellation requested.
-   * May be used to stop execution of a thread or runnable.
-   */
-  /* package */ void throwIfCancellationRequested() throws CancellationException {
-    synchronized (lock) {
-      throwIfClosed();
-      if (cancellationRequested) {
-        throw new CancellationException();
-      }
+
+    /* package */ void unregister(CancellationTokenRegistration registration) {
+        synchronized (lock) {
+            throwIfClosed();
+            registrations.remove(registration);
+        }
     }
-  }
 
-  /* package */ void unregister(CancellationTokenRegistration registration) {
-    synchronized (lock) {
-      throwIfClosed();
-      registrations.remove(registration);
+    // This method makes no attempt to perform any synchronization or state checks itself and once
+    // invoked will notify all runnables unconditionally. As such if you require the notification
+    // event
+    // to be synchronized with state changes you should provide external synchronization.
+    // If this is invoked without external synchronization there is a probability the token becomes
+    // cancelled concurrently.
+    private void notifyListeners(List<CancellationTokenRegistration> registrations) {
+        for (CancellationTokenRegistration registration : registrations) {
+            registration.runAction();
+        }
     }
-  }
-
-  // This method makes no attempt to perform any synchronization or state checks itself and once
-  // invoked will notify all runnables unconditionally. As such if you require the notification event
-  // to be synchronized with state changes you should provide external synchronization.
-  // If this is invoked without external synchronization there is a probability the token becomes
-  // cancelled concurrently.
-  private void notifyListeners(List<CancellationTokenRegistration> registrations) {
-    for (CancellationTokenRegistration registration : registrations) {
-      registration.runAction();
+
+    @Override
+    public String toString() {
+        return String.format(Locale.US, "%s@%s[cancellationRequested=%s]", getClass().getName(),
+                Integer.toHexString(hashCode()), Boolean.toString(isCancellationRequested()));
     }
-  }
-
-  @Override
-  public String toString() {
-    return String.format(Locale.US, "%s@%s[cancellationRequested=%s]",
-        getClass().getName(),
-        Integer.toHexString(hashCode()),
-        Boolean.toString(isCancellationRequested()));
-  }
-
-  // This method makes no attempt to perform any synchronization itself - you should ensure
-  // accesses to this method are synchronized if you want to ensure correct behaviour in the
-  // face of a concurrent invocation of the close method.
-  private void throwIfClosed() {
-    if (closed) {
-      throw new IllegalStateException("Object already closed");
+
+    // This method makes no attempt to perform any synchronization itself - you should ensure
+    // accesses to this method are synchronized if you want to ensure correct behaviour in the
+    // face of a concurrent invocation of the close method.
+    private void throwIfClosed() {
+        if (closed) {
+            throw new IllegalStateException("Object already closed");
+        }
     }
-  }
 
-  // Performs no synchronization.
-  private void cancelScheduledCancellation() {
-    if (scheduledCancellation != null) {
-      scheduledCancellation.cancel(true);
-      scheduledCancellation = null;
+    // Performs no synchronization.
+    private void cancelScheduledCancellation() {
+        if (scheduledCancellation != null) {
+            scheduledCancellation.cancel(true);
+            scheduledCancellation = null;
+        }
     }
-  }
 }
diff --git a/bolts-tasks/src/main/java/bolts/Capture.java b/bolts-tasks/src/main/java/bolts/Capture.java
index 3fb6418..7065fee 100644
--- a/bolts-tasks/src/main/java/bolts/Capture.java
+++ b/bolts-tasks/src/main/java/bolts/Capture.java
@@ -3,7 +3,7 @@
  *  All rights reserved.
  *
  *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant 
+ *  LICENSE file in the root directory of this source tree. An additional grant
  *  of patent rights can be found in the PATENTS file in the same directory.
  *
  */
@@ -11,24 +11,24 @@
 
 /**
  * Provides a class that can be used for capturing variables in an anonymous class implementation.
- * 
+ *
  * @param <T>
  */
 public class Capture<T> {
-  private T value;
+    private T value;
 
-  public Capture() {
-  }
+    public Capture() {
+    }
 
-  public Capture(T value) {
-    this.value = value;
-  }
+    public Capture(T value) {
+        this.value = value;
+    }
 
-  public T get() {
-    return value;
-  }
+    public T get() {
+        return value;
+    }
 
-  public void set(T value) {
-    this.value = value;
-  }
+    public void set(T value) {
+        this.value = value;
+    }
 }
diff --git a/bolts-tasks/src/main/java/bolts/Continuation.java b/bolts-tasks/src/main/java/bolts/Continuation.java
index 1faa1a0..6e15f6b 100644
--- a/bolts-tasks/src/main/java/bolts/Continuation.java
+++ b/bolts-tasks/src/main/java/bolts/Continuation.java
@@ -3,7 +3,7 @@
  *  All rights reserved.
  *
  *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant 
+ *  LICENSE file in the root directory of this source tree. An additional grant
  *  of patent rights can be found in the PATENTS file in the same directory.
  *
  */
@@ -11,12 +11,12 @@
 
 /**
  * A function to be called after a task completes.
- *
+ * <p>
  * If you wish to have the Task from a Continuation that does not return a Task be cancelled
  * then throw a {@link java.util.concurrent.CancellationException} from the Continuation.
  *
  * @see Task
  */
 public interface Continuation<TTaskResult, TContinuationResult> {
-  TContinuationResult then(Task<TTaskResult> task) throws Exception;
+    TContinuationResult then(Task<TTaskResult> task) throws Exception;
 }
diff --git a/bolts-tasks/src/main/java/bolts/ExecutorException.java b/bolts-tasks/src/main/java/bolts/ExecutorException.java
index 4997ea0..b107fb0 100644
--- a/bolts-tasks/src/main/java/bolts/ExecutorException.java
+++ b/bolts-tasks/src/main/java/bolts/ExecutorException.java
@@ -6,7 +6,7 @@
  */
 public class ExecutorException extends RuntimeException {
 
-  public ExecutorException(Exception e) {
-    super("An exception was thrown by an Executor", e);
-  }
+    public ExecutorException(Exception e) {
+        super("An exception was thrown by an Executor", e);
+    }
 }
diff --git a/bolts-tasks/src/main/java/bolts/Task.java b/bolts-tasks/src/main/java/bolts/Task.java
index d6bf6a2..85311df 100644
--- a/bolts-tasks/src/main/java/bolts/Task.java
+++ b/bolts-tasks/src/main/java/bolts/Task.java
@@ -3,7 +3,7 @@
  *  All rights reserved.
  *
  *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant 
+ *  LICENSE file in the root directory of this source tree. An additional grant
  *  of patent rights can be found in the PATENTS file in the same directory.
  *
  */
@@ -25,1007 +25,1034 @@
 
 /**
  * Represents the result of an asynchronous operation.
- * 
- * @param <TResult>
- *          The type of the result of the task.
+ *
+ * @param <TResult> The type of the result of the task.
  */
 public class Task<TResult> {
-  /**
-   * An {@link java.util.concurrent.Executor} that executes tasks in parallel.
-   */
-  public static final ExecutorService BACKGROUND_EXECUTOR = BoltsExecutors.background();
-
-  /**
-   * An {@link java.util.concurrent.Executor} that executes tasks in the current thread unless
-   * the stack runs too deep, at which point it will delegate to {@link Task#BACKGROUND_EXECUTOR} in
-   * order to trim the stack.
-   */
-  private static final Executor IMMEDIATE_EXECUTOR = BoltsExecutors.immediate();
-
-  /**
-   * An {@link java.util.concurrent.Executor} that executes tasks on the UI thread.
-   */
-  public static final Executor UI_THREAD_EXECUTOR = AndroidExecutors.uiThread();
-
-  /**
-   * Interface for handlers invoked when a failed {@code Task} is about to be
-   * finalized, but the exception has not been consumed.
-   *
-   * <p>The handler will execute in the GC thread, so if the handler needs to do
-   * anything time consuming or complex it is a good idea to fire off a {@code Task}
-   * to handle the exception.
-   *
-   * @see #getUnobservedExceptionHandler
-   * @see #setUnobservedExceptionHandler
-   */
-  public interface UnobservedExceptionHandler {
     /**
-     * Method invoked when the given task has an unobserved exception.
-     * <p>Any exception thrown by this method will be ignored.
-     * @param t the task
-     * @param e the exception
+     * An {@link java.util.concurrent.Executor} that executes tasks in parallel.
+     */
+    public static final ExecutorService BACKGROUND_EXECUTOR = BoltsExecutors.background();
+
+    /**
+     * An {@link java.util.concurrent.Executor} that executes tasks in the current thread unless
+     * the stack runs too deep, at which point it will delegate to
+     * {@link Task#BACKGROUND_EXECUTOR} in
+     * order to trim the stack.
+     */
+    private static final Executor IMMEDIATE_EXECUTOR = BoltsExecutors.immediate();
+
+    /**
+     * An {@link java.util.concurrent.Executor} that executes tasks on the UI thread.
+     */
+    public static final Executor UI_THREAD_EXECUTOR = AndroidExecutors.uiThread();
+
+    /**
+     * Interface for handlers invoked when a failed {@code Task} is about to be
+     * finalized, but the exception has not been consumed.
+     * <p>
+     * <p>The handler will execute in the GC thread, so if the handler needs to do
+     * anything time consuming or complex it is a good idea to fire off a {@code Task}
+     * to handle the exception.
+     *
+     * @see #getUnobservedExceptionHandler
+     * @see #setUnobservedExceptionHandler
      */
-    void unobservedException(Task<?> t, UnobservedTaskException e);
-  }
-
-  // null unless explicitly set
-  private static volatile UnobservedExceptionHandler unobservedExceptionHandler;
-
-  /**
-   * Returns the handler invoked when a task has an unobserved
-   * exception or {@code null}.
-   */
-  public static UnobservedExceptionHandler getUnobservedExceptionHandler() {
-    return unobservedExceptionHandler;
-  }
-
-  /**
-   * Set the handler invoked when a task has an unobserved exception.
-   * @param eh the object to use as an unobserved exception handler. If
-   *           <tt>null</tt> then unobserved exceptions will be ignored.
-   */
-  public static void setUnobservedExceptionHandler(UnobservedExceptionHandler eh) {
-    unobservedExceptionHandler = eh;
-  }
-
-  private final Object lock = new Object();
-  private boolean complete;
-  private boolean cancelled;
-  private TResult result;
-  private Exception error;
-  private boolean errorHasBeenObserved;
-  private UnobservedErrorNotifier unobservedErrorNotifier;
-  private List<Continuation<TResult, Void>> continuations = new ArrayList<>();
-
-  /* package */ Task() {
-  }
-
-  private Task(TResult result) {
-    trySetResult(result);
-  }
-
-  private Task(boolean cancelled) {
-    if (cancelled) {
-      trySetCancelled();
-    } else {
-      trySetResult(null);
+    public interface UnobservedExceptionHandler {
+        /**
+         * Method invoked when the given task has an unobserved exception.
+         * <p>Any exception thrown by this method will be ignored.
+         *
+         * @param t the task
+         * @param e the exception
+         */
+        void unobservedException(Task<?> t, UnobservedTaskException e);
     }
-  }
-
-  /**
-   * @deprecated Please use {@link bolts.TaskCompletionSource()} instead.
-   */
-  public static <TResult> Task<TResult>.TaskCompletionSource create() {
-    Task<TResult> task = new Task<>();
-    return task.new TaskCompletionSource();
-  }
-
-  /**
-   * @return {@code true} if the task completed (has a result, an error, or was cancelled.
-   *         {@code false} otherwise.
-   */
-  public boolean isCompleted() {
-    synchronized (lock) {
-      return complete;
+
+    // null unless explicitly set
+    private static volatile UnobservedExceptionHandler unobservedExceptionHandler;
+
+    /**
+     * Returns the handler invoked when a task has an unobserved
+     * exception or {@code null}.
+     */
+    public static UnobservedExceptionHandler getUnobservedExceptionHandler() {
+        return unobservedExceptionHandler;
     }
-  }
-
-  /**
-   * @return {@code true} if the task was cancelled, {@code false} otherwise.
-   */
-  public boolean isCancelled() {
-    synchronized (lock) {
-      return cancelled;
+
+    /**
+     * Set the handler invoked when a task has an unobserved exception.
+     *
+     * @param eh the object to use as an unobserved exception handler. If
+     *           <tt>null</tt> then unobserved exceptions will be ignored.
+     */
+    public static void setUnobservedExceptionHandler(UnobservedExceptionHandler eh) {
+        unobservedExceptionHandler = eh;
     }
-  }
-
-  /**
-   * @return {@code true} if the task has an error, {@code false} otherwise.
-   */
-  public boolean isFaulted() {
-    synchronized (lock) {
-      return getError() != null;
+
+    private final Object lock = new Object();
+    private boolean complete;
+    private boolean cancelled;
+    private TResult result;
+    private Exception error;
+    private boolean errorHasBeenObserved;
+    private UnobservedErrorNotifier unobservedErrorNotifier;
+    private List<Continuation<TResult, Void>> continuations = new ArrayList<>();
+
+    /* package */ Task() {
     }
-  }
-
-  /**
-   * @return The result of the task, if set. {@code null} otherwise.
-   */
-  public TResult getResult() {
-    synchronized (lock) {
-      return result;
+
+    private Task(TResult result) {
+        trySetResult(result);
     }
-  }
-
-  /**
-   * @return The error for the task, if set. {@code null} otherwise.
-   */
-  public Exception getError() {
-    synchronized (lock) {
-      if (error != null) {
-        errorHasBeenObserved = true;
-        if (unobservedErrorNotifier != null) {
-          unobservedErrorNotifier.setObserved();
-          unobservedErrorNotifier = null;
+
+    private Task(boolean cancelled) {
+        if (cancelled) {
+            trySetCancelled();
+        } else {
+            trySetResult(null);
         }
-      }
-      return error;
     }
-  }
-
-  /**
-   * Blocks until the task is complete.
-   */
-  public void waitForCompletion() throws InterruptedException {
-    synchronized (lock) {
-      if (!isCompleted()) {
-        lock.wait();
-      }
+
+    /**
+     * @deprecated Please use {@link bolts.TaskCompletionSource()} instead.
+     */
+    public static <TResult> Task<TResult>.TaskCompletionSource create() {
+        Task<TResult> task = new Task<>();
+        return task.new TaskCompletionSource();
     }
-  }
-
-  /**
-   * Blocks until the task is complete or times out.
-   * @return {@code true} if the task completed (has a result, an error, or was cancelled).
-   *         {@code false} otherwise.
-   */
-  public boolean waitForCompletion(long duration, TimeUnit timeUnit) throws InterruptedException {
-    synchronized (lock) {
-      if (!isCompleted()) {
-        lock.wait(timeUnit.toMillis(duration));
-      }
-      return isCompleted();
+
+    /**
+     * @return {@code true} if the task completed (has a result, an error, or was cancelled.
+     * {@code false} otherwise.
+     */
+    public boolean isCompleted() {
+        synchronized (lock) {
+            return complete;
+        }
     }
-  }
-
-  /**
-   * Creates a completed task with the given value.
-   */
-  @SuppressWarnings("unchecked")
-  public static <TResult> Task<TResult> forResult(TResult value) {
-    if (value == null) {
-      return (Task<TResult>) TASK_NULL;
+
+    /**
+     * @return {@code true} if the task was cancelled, {@code false} otherwise.
+     */
+    public boolean isCancelled() {
+        synchronized (lock) {
+            return cancelled;
+        }
     }
-    if (value instanceof Boolean) {
-      return (Task<TResult>) ((Boolean) value ? TASK_TRUE : TASK_FALSE);
+
+    /**
+     * @return {@code true} if the task has an error, {@code false} otherwise.
+     */
+    public boolean isFaulted() {
+        synchronized (lock) {
+            return getError() != null;
+        }
     }
-    bolts.TaskCompletionSource<TResult> tcs = new bolts.TaskCompletionSource<>();
-    tcs.setResult(value);
-    return tcs.getTask();
-  }
-
-  /**
-   * Creates a faulted task with the given error.
-   */
-  public static <TResult> Task<TResult> forError(Exception error) {
-    bolts.TaskCompletionSource<TResult> tcs = new bolts.TaskCompletionSource<>();
-    tcs.setError(error);
-    return tcs.getTask();
-  }
-
-  /**
-   * Creates a cancelled task.
-   */
-  @SuppressWarnings("unchecked")
-  public static <TResult> Task<TResult> cancelled() {
-    return (Task<TResult>) TASK_CANCELLED;
-  }
-
-  /**
-   * Creates a task that completes after a time delay.
-   *
-   * @param delay The number of milliseconds to wait before completing the returned task. Zero and
-   *              negative values are treated as requests for immediate execution.
-   */
-  public static Task<Void> delay(long delay) {
-    return delay(delay, BoltsExecutors.scheduled(), null);
-  }
-
-  /**
-   * Creates a task that completes after a time delay.
-   *
-   * @param delay The number of milliseconds to wait before completing the returned task. Zero and
-   *              negative values are treated as requests for immediate execution.
-   * @param cancellationToken The optional cancellation token that will be checked prior to
-   *                          completing the returned task.
-   */
-  public static Task<Void> delay(long delay, CancellationToken cancellationToken) {
-    return delay(delay, BoltsExecutors.scheduled(), cancellationToken);
-  }
-
-  /* package */ static Task<Void> delay(long delay, ScheduledExecutorService executor, final CancellationToken cancellationToken) {
-    if (cancellationToken != null && cancellationToken.isCancellationRequested()) {
-      return Task.cancelled();
+
+    /**
+     * @return The result of the task, if set. {@code null} otherwise.
+     */
+    public TResult getResult() {
+        synchronized (lock) {
+            return result;
+        }
     }
 
-    if (delay <= 0) {
-      return Task.forResult(null);
+    /**
+     * @return The error for the task, if set. {@code null} otherwise.
+     */
+    public Exception getError() {
+        synchronized (lock) {
+            if (error != null) {
+                errorHasBeenObserved = true;
+                if (unobservedErrorNotifier != null) {
+                    unobservedErrorNotifier.setObserved();
+                    unobservedErrorNotifier = null;
+                }
+            }
+            return error;
+        }
     }
 
-    final bolts.TaskCompletionSource<Void> tcs = new bolts.TaskCompletionSource<>();
-    final ScheduledFuture<?> scheduled = executor.schedule(new Runnable() {
-      @Override
-      public void run() {
-        tcs.trySetResult(null);
-      }
-    }, delay, TimeUnit.MILLISECONDS);
-
-    if (cancellationToken != null) {
-      cancellationToken.register(new Runnable() {
-        @Override
-        public void run() {
-          scheduled.cancel(true);
-          tcs.trySetCancelled();
+    /**
+     * Blocks until the task is complete.
+     */
+    public void waitForCompletion() throws InterruptedException {
+        synchronized (lock) {
+            if (!isCompleted()) {
+                lock.wait();
+            }
         }
-      });
     }
 
-    return tcs.getTask();
-  }
+    /**
+     * Blocks until the task is complete or times out.
+     *
+     * @return {@code true} if the task completed (has a result, an error, or was cancelled).
+     * {@code false} otherwise.
+     */
+    public boolean waitForCompletion(long duration, TimeUnit timeUnit) throws InterruptedException {
+        synchronized (lock) {
+            if (!isCompleted()) {
+                lock.wait(timeUnit.toMillis(duration));
+            }
+            return isCompleted();
+        }
+    }
 
-  /**
-   * Makes a fluent cast of a Task's result possible, avoiding an extra continuation just to cast
-   * the type of the result.
-   */
-  public <TOut> Task<TOut> cast() {
+    /**
+     * Creates a completed task with the given value.
+     */
     @SuppressWarnings("unchecked")
-    Task<TOut> task = (Task<TOut>) this;
-    return task;
-  }
-
-  /**
-   * Turns a Task<T> into a Task<Void>, dropping any result.
-   */
-  public Task<Void> makeVoid() {
-    return this.continueWithTask(new Continuation<TResult, Task<Void>>() {
-      @Override
-      public Task<Void> then(Task<TResult> task) throws Exception {
-        if (task.isCancelled()) {
-          return Task.cancelled();
+    public static <TResult> Task<TResult> forResult(TResult value) {
+        if (value == null) {
+            return (Task<TResult>) TASK_NULL;
         }
-        if (task.isFaulted()) {
-          return Task.forError(task.getError());
+        if (value instanceof Boolean) {
+            return (Task<TResult>) ((Boolean) value ? TASK_TRUE : TASK_FALSE);
         }
-        return Task.forResult(null);
-      }
-    });
-  }
-
-  /**
-   * Invokes the callable on a background thread, returning a Task to represent the operation.
-   *
-   * If you want to cancel the resulting Task throw a {@link java.util.concurrent.CancellationException}
-   * from the callable.
-   */
-  public static <TResult> Task<TResult> callInBackground(Callable<TResult> callable) {
-    return call(callable, BACKGROUND_EXECUTOR, null);
-  }
-
-  /**
-   * Invokes the callable on a background thread, returning a Task to represent the operation.
-   */
-  public static <TResult> Task<TResult> callInBackground(Callable<TResult> callable, CancellationToken ct) {
-    return call(callable, BACKGROUND_EXECUTOR, ct);
-  }
-
-  /**
-   * Invokes the callable using the given executor, returning a Task to represent the operation.
-   *
-   * If you want to cancel the resulting Task throw a {@link java.util.concurrent.CancellationException}
-   * from the callable.
-   */
-  public static <TResult> Task<TResult> call(final Callable<TResult> callable, Executor executor) {
-    return call(callable, executor, null);
-  }
-
-  /**
-   * Invokes the callable using the given executor, returning a Task to represent the operation.
-   */
-  public static <TResult> Task<TResult> call(final Callable<TResult> callable, Executor executor,
-      final CancellationToken ct) {
-    final bolts.TaskCompletionSource<TResult> tcs = new bolts.TaskCompletionSource<>();
-    try {
-      executor.execute(new Runnable() {
-        @Override
-        public void run() {
-          if (ct != null && ct.isCancellationRequested()) {
-            tcs.setCancelled();
-            return;
-          }
-
-          try {
-            tcs.setResult(callable.call());
-          } catch (CancellationException e) {
-            tcs.setCancelled();
-          } catch (Exception e) {
-            tcs.setError(e);
-          }
+        bolts.TaskCompletionSource<TResult> tcs = new bolts.TaskCompletionSource<>();
+        tcs.setResult(value);
+        return tcs.getTask();
+    }
+
+    /**
+     * Creates a faulted task with the given error.
+     */
+    public static <TResult> Task<TResult> forError(Exception error) {
+        bolts.TaskCompletionSource<TResult> tcs = new bolts.TaskCompletionSource<>();
+        tcs.setError(error);
+        return tcs.getTask();
+    }
+
+    /**
+     * Creates a cancelled task.
+     */
+    @SuppressWarnings("unchecked")
+    public static <TResult> Task<TResult> cancelled() {
+        return (Task<TResult>) TASK_CANCELLED;
+    }
+
+    /**
+     * Creates a task that completes after a time delay.
+     *
+     * @param delay The number of milliseconds to wait before completing the returned task. Zero and
+     *              negative values are treated as requests for immediate execution.
+     */
+    public static Task<Void> delay(long delay) {
+        return delay(delay, BoltsExecutors.scheduled(), null);
+    }
+
+    /**
+     * Creates a task that completes after a time delay.
+     *
+     * @param delay             The number of milliseconds to wait before completing the returned
+     *                          task. Zero and
+     *                          negative values are treated as requests for immediate execution.
+     * @param cancellationToken The optional cancellation token that will be checked prior to
+     *                          completing the returned task.
+     */
+    public static Task<Void> delay(long delay, CancellationToken cancellationToken) {
+        return delay(delay, BoltsExecutors.scheduled(), cancellationToken);
+    }
+
+    /* package */
+    static Task<Void> delay(long delay, ScheduledExecutorService executor, final
+    CancellationToken cancellationToken) {
+        if (cancellationToken != null && cancellationToken.isCancellationRequested()) {
+            return Task.cancelled();
+        }
+
+        if (delay <= 0) {
+            return Task.forResult(null);
+        }
+
+        final bolts.TaskCompletionSource<Void> tcs = new bolts.TaskCompletionSource<>();
+        final ScheduledFuture<?> scheduled = executor.schedule(new Runnable() {
+            @Override
+            public void run() {
+                tcs.trySetResult(null);
+            }
+        }, delay, TimeUnit.MILLISECONDS);
+
+        if (cancellationToken != null) {
+            cancellationToken.register(new Runnable() {
+                @Override
+                public void run() {
+                    scheduled.cancel(true);
+                    tcs.trySetCancelled();
+                }
+            });
         }
-      });
-    } catch (Exception e) {
-      tcs.setError(new ExecutorException(e));
+
+        return tcs.getTask();
     }
 
-    return tcs.getTask();
-  }
-
-  /**
-   * Invokes the callable on the current thread, producing a Task.
-   *
-   * If you want to cancel the resulting Task throw a {@link java.util.concurrent.CancellationException}
-   * from the callable.
-   */
-  public static <TResult> Task<TResult> call(final Callable<TResult> callable) {
-    return call(callable, IMMEDIATE_EXECUTOR, null);
-  }
-
-  /**
-   * Invokes the callable on the current thread, producing a Task.
-   */
-  public static <TResult> Task<TResult> call(final Callable<TResult> callable, CancellationToken ct) {
-    return call(callable, IMMEDIATE_EXECUTOR, ct);
-  }
-
-  /**
-   * Creates a task that will complete when any of the supplied tasks have completed.
-   * <p/>
-   * The returned task will complete when any of the supplied tasks has completed. The returned task
-   * will always end in the completed state with its result set to the first task to complete. This
-   * is true even if the first task to complete ended in the canceled or faulted state.
-   *
-   * @param tasks
-   *          The tasks to wait on for completion.
-   * @return A task that represents the completion of one of the supplied tasks. 
-   *         The return task's result is the task that completed.
-   */
-  public static <TResult> Task<Task<TResult>> whenAnyResult(Collection<? extends Task<TResult>> tasks) {
-    if (tasks.size() == 0) {
-      return Task.forResult(null);
+    /**
+     * Makes a fluent cast of a Task's result possible, avoiding an extra continuation just to cast
+     * the type of the result.
+     */
+    public <TOut> Task<TOut> cast() {
+        @SuppressWarnings("unchecked") Task<TOut> task = (Task<TOut>) this;
+        return task;
+    }
+
+    /**
+     * Turns a Task<T> into a Task<Void>, dropping any result.
+     */
+    public Task<Void> makeVoid() {
+        return this.continueWithTask(new Continuation<TResult, Task<Void>>() {
+            @Override
+            public Task<Void> then(Task<TResult> task) throws Exception {
+                if (task.isCancelled()) {
+                    return Task.cancelled();
+                }
+                if (task.isFaulted()) {
+                    return Task.forError(task.getError());
+                }
+                return Task.forResult(null);
+            }
+        });
+    }
+
+    /**
+     * Invokes the callable on a background thread, returning a Task to represent the operation.
+     * <p>
+     * If you want to cancel the resulting Task throw a
+     * {@link java.util.concurrent.CancellationException}
+     * from the callable.
+     */
+    public static <TResult> Task<TResult> callInBackground(Callable<TResult> callable) {
+        return call(callable, BACKGROUND_EXECUTOR, null);
+    }
+
+    /**
+     * Invokes the callable on a background thread, returning a Task to represent the operation.
+     */
+    public static <TResult> Task<TResult> callInBackground(Callable<TResult> callable,
+                                                           CancellationToken ct) {
+        return call(callable, BACKGROUND_EXECUTOR, ct);
+    }
+
+    /**
+     * Invokes the callable using the given executor, returning a Task to represent the operation.
+     * <p>
+     * If you want to cancel the resulting Task throw a
+     * {@link java.util.concurrent.CancellationException}
+     * from the callable.
+     */
+    public static <TResult> Task<TResult> call(final Callable<TResult> callable, Executor
+            executor) {
+        return call(callable, executor, null);
     }
 
-    final bolts.TaskCompletionSource<Task<TResult>> firstCompleted = new bolts.TaskCompletionSource<>();
-    final AtomicBoolean isAnyTaskComplete = new AtomicBoolean(false);
-
-    for (Task<TResult> task : tasks) {
-      task.continueWith(new Continuation<TResult, Void>() {
-        @Override
-        public Void then(Task<TResult> task) {
-          if (isAnyTaskComplete.compareAndSet(false, true)) {
-            firstCompleted.setResult(task);
-          } else {
-            Throwable ensureObserved = task.getError();
-          }
-          return null;
+    /**
+     * Invokes the callable using the given executor, returning a Task to represent the operation.
+     */
+    public static <TResult> Task<TResult> call(final Callable<TResult> callable, Executor
+            executor, final CancellationToken ct) {
+        final bolts.TaskCompletionSource<TResult> tcs = new bolts.TaskCompletionSource<>();
+        try {
+            executor.execute(new Runnable() {
+                @Override
+                public void run() {
+                    if (ct != null && ct.isCancellationRequested()) {
+                        tcs.setCancelled();
+                        return;
+                    }
+
+                    try {
+                        tcs.setResult(callable.call());
+                    } catch (CancellationException e) {
+                        tcs.setCancelled();
+                    } catch (Exception e) {
+                        tcs.setError(e);
+                    }
+                }
+            });
+        } catch (Exception e) {
+            tcs.setError(new ExecutorException(e));
         }
-      });
+
+        return tcs.getTask();
+    }
+
+    /**
+     * Invokes the callable on the current thread, producing a Task.
+     * <p>
+     * If you want to cancel the resulting Task throw a
+     * {@link java.util.concurrent.CancellationException}
+     * from the callable.
+     */
+    public static <TResult> Task<TResult> call(final Callable<TResult> callable) {
+        return call(callable, IMMEDIATE_EXECUTOR, null);
     }
-    return firstCompleted.getTask();
-  }
-
-   /**
-   * Creates a task that will complete when any of the supplied tasks have completed.
-   * <p/>
-   * The returned task will complete when any of the supplied tasks has completed. The returned task
-   * will always end in the completed state with its result set to the first task to complete. This
-   * is true even if the first task to complete ended in the canceled or faulted state.
-   *
-   * @param tasks
-   *          The tasks to wait on for completion.
-   * @return A task that represents the completion of one of the supplied tasks. 
-   *         The return task's Result is the task that completed.
-   */
-  @SuppressWarnings("unchecked")
-  public static Task<Task<?>> whenAny(Collection<? extends Task<?>> tasks) {
-    if (tasks.size() == 0) {
-      return Task.forResult(null);
+
+    /**
+     * Invokes the callable on the current thread, producing a Task.
+     */
+    public static <TResult> Task<TResult> call(final Callable<TResult> callable,
+                                               CancellationToken ct) {
+        return call(callable, IMMEDIATE_EXECUTOR, ct);
     }
-      
-    final bolts.TaskCompletionSource<Task<?>> firstCompleted = new bolts.TaskCompletionSource<>();
-    final AtomicBoolean isAnyTaskComplete = new AtomicBoolean(false);
-      
-    for (Task<?> task : tasks) {
-      ((Task<Object>) task).continueWith(new Continuation<Object, Void>() {
-        @Override
-        public Void then(Task<Object> task) {
-          if (isAnyTaskComplete.compareAndSet(false, true)) {
-            firstCompleted.setResult(task);
-          } else {
-            Throwable ensureObserved = task.getError();
-          }
-          return null;
+
+    /**
+     * Creates a task that will complete when any of the supplied tasks have completed.
+     * <p/>
+     * The returned task will complete when any of the supplied tasks has completed. The returned
+     * task
+     * will always end in the completed state with its result set to the first task to complete.
+     * This
+     * is true even if the first task to complete ended in the canceled or faulted state.
+     *
+     * @param tasks The tasks to wait on for completion.
+     * @return A task that represents the completion of one of the supplied tasks.
+     * The return task's result is the task that completed.
+     */
+    public static <TResult> Task<Task<TResult>> whenAnyResult(Collection<? extends Task<TResult>>
+                                                                      tasks) {
+        if (tasks.size() == 0) {
+            return Task.forResult(null);
         }
-      });
+
+        final bolts.TaskCompletionSource<Task<TResult>> firstCompleted = new bolts
+                .TaskCompletionSource<>();
+        final AtomicBoolean isAnyTaskComplete = new AtomicBoolean(false);
+
+        for (Task<TResult> task : tasks) {
+            task.continueWith(new Continuation<TResult, Void>() {
+                @Override
+                public Void then(Task<TResult> task) {
+                    if (isAnyTaskComplete.compareAndSet(false, true)) {
+                        firstCompleted.setResult(task);
+                    } else {
+                        Throwable ensureObserved = task.getError();
+                    }
+                    return null;
+                }
+            });
+        }
+        return firstCompleted.getTask();
     }
-    return firstCompleted.getTask();
-  }
-
-  /**
-   * Creates a task that completes when all of the provided tasks are complete.
-   * <p/>
-   * If any of the supplied tasks completes in a faulted state, the returned task will also complete
-   * in a faulted state, where its exception will resolve to that {@link java.lang.Exception} if a
-   * single task fails or an {@link AggregateException} of all the {@link java.lang.Exception}s
-   * if multiple tasks fail.
-   * <p/>
-   * If none of the supplied tasks faulted but at least one of them was cancelled, the returned
-   * task will end as cancelled.
-   * <p/>
-   * If none of the tasks faulted and none of the tasks were cancelled, the resulting task will end
-   * completed. The result of the returned task will be set to a list containing all of the results
-   * of the supplied tasks in the same order as they were provided (e.g. if the input tasks collection
-   * contained t1, t2, t3, the output task's result will return an {@code List&lt;TResult&gt;}
-   * where {@code list.get(0) == t1.getResult(), list.get(1) == t2.getResult(), and
-   * list.get(2) == t3.getResult()}).
-   * <p/>
-   * If the supplied collection contains no tasks, the returned task will immediately transition to
-   * a completed state before it's returned to the caller.
-   * The returned {@code List&lt;TResult&gt;} will contain 0 elements.
-   *
-   * @param tasks The tasks that the return value will wait for before completing.
-   * @return A Task that will resolve to {@code List&lt;TResult&gt;} when all the tasks are resolved.
-   */
-  public static <TResult> Task<List<TResult>> whenAllResult(final Collection<? extends Task<TResult>> tasks) {
-    return whenAll(tasks).onSuccess(new Continuation<Void, List<TResult>>() {
-      @Override
-      public List<TResult> then(Task<Void> task) throws Exception {
+
+    /**
+     * Creates a task that will complete when any of the supplied tasks have completed.
+     * <p/>
+     * The returned task will complete when any of the supplied tasks has completed. The returned
+     * task
+     * will always end in the completed state with its result set to the first task to complete.
+     * This
+     * is true even if the first task to complete ended in the canceled or faulted state.
+     *
+     * @param tasks The tasks to wait on for completion.
+     * @return A task that represents the completion of one of the supplied tasks.
+     * The return task's Result is the task that completed.
+     */
+    @SuppressWarnings("unchecked")
+    public static Task<Task<?>> whenAny(Collection<? extends Task<?>> tasks) {
         if (tasks.size() == 0) {
-          return Collections.emptyList();
+            return Task.forResult(null);
         }
 
-        List<TResult> results = new ArrayList<>();
-        for (Task<TResult> individualTask : tasks) {
-          results.add(individualTask.getResult());
+        final bolts.TaskCompletionSource<Task<?>> firstCompleted = new bolts
+                .TaskCompletionSource<>();
+        final AtomicBoolean isAnyTaskComplete = new AtomicBoolean(false);
+
+        for (Task<?> task : tasks) {
+            ((Task<Object>) task).continueWith(new Continuation<Object, Void>() {
+                @Override
+                public Void then(Task<Object> task) {
+                    if (isAnyTaskComplete.compareAndSet(false, true)) {
+                        firstCompleted.setResult(task);
+                    } else {
+                        Throwable ensureObserved = task.getError();
+                    }
+                    return null;
+                }
+            });
         }
-        return results;
-      }
-    });
-  }
-
-  /**
-   * Creates a task that completes when all of the provided tasks are complete.
-   * <p/>
-   * If any of the supplied tasks completes in a faulted state, the returned task will also complete
-   * in a faulted state, where its exception will resolve to that {@link java.lang.Exception} if a
-   * single task fails or an {@link AggregateException} of all the {@link java.lang.Exception}s
-   * if multiple tasks fail.
-   * <p/>
-   * If none of the supplied tasks faulted but at least one of them was cancelled, the returned
-   * task will end as cancelled.
-   * <p/>
-   * If none of the tasks faulted and none of the tasks were canceled, the resulting task will
-   * end in the completed state.
-   * <p/>
-   * If the supplied collection contains no tasks, the returned task will immediately transition
-   * to a completed state before it's returned to the caller.
-   *
-   * @param tasks The tasks that the return value will wait for before completing.
-   * @return A Task that will resolve to {@code Void} when all the tasks are resolved.
-   */
-  public static Task<Void> whenAll(Collection<? extends Task<?>> tasks) {
-    if (tasks.size() == 0) {
-      return Task.forResult(null);
+        return firstCompleted.getTask();
     }
 
-    final bolts.TaskCompletionSource<Void> allFinished = new bolts.TaskCompletionSource<>();
-    final ArrayList<Exception> causes = new ArrayList<>();
-    final Object errorLock = new Object();
-    final AtomicInteger count = new AtomicInteger(tasks.size());
-    final AtomicBoolean isCancelled = new AtomicBoolean(false);
-
-    for (Task<?> task : tasks) {
-      @SuppressWarnings("unchecked")
-      Task<Object> t = (Task<Object>) task;
-      t.continueWith(new Continuation<Object, Void>() {
-        @Override
-        public Void then(Task<Object> task) {
-          if (task.isFaulted()) {
-            synchronized (errorLock) {
-              causes.add(task.getError());
-            }
-          }
-
-          if (task.isCancelled()) {
-            isCancelled.set(true);
-          }
-
-          if (count.decrementAndGet() == 0) {
-            if (causes.size() != 0) {
-              if (causes.size() == 1) {
-                allFinished.setError(causes.get(0));
-              } else {
-                Exception error = new AggregateException(
-                    String.format("There were %d exceptions.", causes.size()),
-                    causes);
-                allFinished.setError(error);
-              }
-            } else if (isCancelled.get()) {
-              allFinished.setCancelled();
-            } else {
-              allFinished.setResult(null);
+    /**
+     * Creates a task that completes when all of the provided tasks are complete.
+     * <p/>
+     * If any of the supplied tasks completes in a faulted state, the returned task will also
+     * complete
+     * in a faulted state, where its exception will resolve to that {@link java.lang.Exception} if a
+     * single task fails or an {@link AggregateException} of all the {@link java.lang.Exception}s
+     * if multiple tasks fail.
+     * <p/>
+     * If none of the supplied tasks faulted but at least one of them was cancelled, the returned
+     * task will end as cancelled.
+     * <p/>
+     * If none of the tasks faulted and none of the tasks were cancelled, the resulting task will
+     * end
+     * completed. The result of the returned task will be set to a list containing all of the
+     * results
+     * of the supplied tasks in the same order as they were provided (e.g. if the input tasks
+     * collection
+     * contained t1, t2, t3, the output task's result will return an {@code List&lt;TResult&gt;}
+     * where {@code list.get(0) == t1.getResult(), list.get(1) == t2.getResult(), and
+     * list.get(2) == t3.getResult()}).
+     * <p/>
+     * If the supplied collection contains no tasks, the returned task will immediately
+     * transition to
+     * a completed state before it's returned to the caller.
+     * The returned {@code List&lt;TResult&gt;} will contain 0 elements.
+     *
+     * @param tasks The tasks that the return value will wait for before completing.
+     * @return A Task that will resolve to {@code List&lt;TResult&gt;} when all the tasks are
+     * resolved.
+     */
+    public static <TResult> Task<List<TResult>> whenAllResult(final Collection<? extends
+            Task<TResult>> tasks) {
+        return whenAll(tasks).onSuccess(new Continuation<Void, List<TResult>>() {
+            @Override
+            public List<TResult> then(Task<Void> task) throws Exception {
+                if (tasks.size() == 0) {
+                    return Collections.emptyList();
+                }
+
+                List<TResult> results = new ArrayList<>();
+                for (Task<TResult> individualTask : tasks) {
+                    results.add(individualTask.getResult());
+                }
+                return results;
             }
-          }
-          return null;
-        }
-      });
+        });
     }
 
-    return allFinished.getTask();
-  }
-
-  /**
-   * Continues a task with the equivalent of a Task-based while loop, where the body of the loop is
-   * a task continuation.
-   */
-  public Task<Void> continueWhile(Callable<Boolean> predicate,
-      Continuation<Void, Task<Void>> continuation) {
-    return continueWhile(predicate, continuation, IMMEDIATE_EXECUTOR, null);
-  }
-
-  /**
-   * Continues a task with the equivalent of a Task-based while loop, where the body of the loop is
-   * a task continuation.
-   */
-  public Task<Void> continueWhile(Callable<Boolean> predicate,
-      Continuation<Void, Task<Void>> continuation, CancellationToken ct) {
-    return continueWhile(predicate, continuation, IMMEDIATE_EXECUTOR, ct);
-  }
-
-  /**
-   * Continues a task with the equivalent of a Task-based while loop, where the body of the loop is
-   * a task continuation.
-   */
-  public Task<Void> continueWhile(final Callable<Boolean> predicate,
-      final Continuation<Void, Task<Void>> continuation, final Executor executor) {
-    return continueWhile(predicate, continuation, executor, null);
-  }
-
-  /**
-   * Continues a task with the equivalent of a Task-based while loop, where the body of the loop is
-   * a task continuation.
-   */
-  public Task<Void> continueWhile(final Callable<Boolean> predicate,
-      final Continuation<Void, Task<Void>> continuation, final Executor executor,
-      final CancellationToken ct) {
-    final Capture<Continuation<Void, Task<Void>>> predicateContinuation =
-        new Capture<>();
-    predicateContinuation.set(new Continuation<Void, Task<Void>>() {
-      @Override
-      public Task<Void> then(Task<Void> task) throws Exception {
-        if (ct != null && ct.isCancellationRequested()) {
-          return Task.cancelled();
+    /**
+     * Creates a task that completes when all of the provided tasks are complete.
+     * <p/>
+     * If any of the supplied tasks completes in a faulted state, the returned task will also
+     * complete
+     * in a faulted state, where its exception will resolve to that {@link java.lang.Exception} if a
+     * single task fails or an {@link AggregateException} of all the {@link java.lang.Exception}s
+     * if multiple tasks fail.
+     * <p/>
+     * If none of the supplied tasks faulted but at least one of them was cancelled, the returned
+     * task will end as cancelled.
+     * <p/>
+     * If none of the tasks faulted and none of the tasks were canceled, the resulting task will
+     * end in the completed state.
+     * <p/>
+     * If the supplied collection contains no tasks, the returned task will immediately transition
+     * to a completed state before it's returned to the caller.
+     *
+     * @param tasks The tasks that the return value will wait for before completing.
+     * @return A Task that will resolve to {@code Void} when all the tasks are resolved.
+     */
+    public static Task<Void> whenAll(Collection<? extends Task<?>> tasks) {
+        if (tasks.size() == 0) {
+            return Task.forResult(null);
         }
 
-        if (predicate.call()) {
-          return Task.<Void> forResult(null).onSuccessTask(continuation, executor)
-              .onSuccessTask(predicateContinuation.get(), executor);
+        final bolts.TaskCompletionSource<Void> allFinished = new bolts.TaskCompletionSource<>();
+        final ArrayList<Exception> causes = new ArrayList<>();
+        final Object errorLock = new Object();
+        final AtomicInteger count = new AtomicInteger(tasks.size());
+        final AtomicBoolean isCancelled = new AtomicBoolean(false);
+
+        for (Task<?> task : tasks) {
+            @SuppressWarnings("unchecked") Task<Object> t = (Task<Object>) task;
+            t.continueWith(new Continuation<Object, Void>() {
+                @Override
+                public Void then(Task<Object> task) {
+                    if (task.isFaulted()) {
+                        synchronized (errorLock) {
+                            causes.add(task.getError());
+                        }
+                    }
+
+                    if (task.isCancelled()) {
+                        isCancelled.set(true);
+                    }
+
+                    if (count.decrementAndGet() == 0) {
+                        if (causes.size() != 0) {
+                            if (causes.size() == 1) {
+                                allFinished.setError(causes.get(0));
+                            } else {
+                                Exception error = new AggregateException(String.format("There " +
+                                        "were %d exceptions.", causes.size()), causes);
+                                allFinished.setError(error);
+                            }
+                        } else if (isCancelled.get()) {
+                            allFinished.setCancelled();
+                        } else {
+                            allFinished.setResult(null);
+                        }
+                    }
+                    return null;
+                }
+            });
         }
-        return Task.forResult(null);
-      }
-    });
-    return makeVoid().continueWithTask(predicateContinuation.get(), executor);
-  }
-
-  /**
-   * Adds a continuation that will be scheduled using the executor, returning a new task that
-   * completes after the continuation has finished running. This allows the continuation to be
-   * scheduled on different thread.
-   */
-  public <TContinuationResult> Task<TContinuationResult> continueWith(
-      final Continuation<TResult, TContinuationResult> continuation, final Executor executor) {
-    return continueWith(continuation, executor, null);
-  }
-
-  /**
-   * Adds a continuation that will be scheduled using the executor, returning a new task that
-   * completes after the continuation has finished running. This allows the continuation to be
-   * scheduled on different thread.
-   */
-  public <TContinuationResult> Task<TContinuationResult> continueWith(
-      final Continuation<TResult, TContinuationResult> continuation, final Executor executor,
-      final CancellationToken ct) {
-    boolean completed;
-    final bolts.TaskCompletionSource<TContinuationResult> tcs = new bolts.TaskCompletionSource<>();
-    synchronized (lock) {
-      completed = this.isCompleted();
-      if (!completed) {
-        this.continuations.add(new Continuation<TResult, Void>() {
-          @Override
-          public Void then(Task<TResult> task) {
-            completeImmediately(tcs, continuation, task, executor, ct);
-            return null;
-          }
-        });
-      }
+
+        return allFinished.getTask();
+    }
+
+    /**
+     * Continues a task with the equivalent of a Task-based while loop, where the body of the
+     * loop is
+     * a task continuation.
+     */
+    public Task<Void> continueWhile(Callable<Boolean> predicate, Continuation<Void, Task<Void>>
+            continuation) {
+        return continueWhile(predicate, continuation, IMMEDIATE_EXECUTOR, null);
     }
-    if (completed) {
-      completeImmediately(tcs, continuation, this, executor, ct);
+
+    /**
+     * Continues a task with the equivalent of a Task-based while loop, where the body of the
+     * loop is
+     * a task continuation.
+     */
+    public Task<Void> continueWhile(Callable<Boolean> predicate, Continuation<Void, Task<Void>>
+            continuation, CancellationToken ct) {
+        return continueWhile(predicate, continuation, IMMEDIATE_EXECUTOR, ct);
     }
-    return tcs.getTask();
-  }
-
-  /**
-   * Adds a synchronous continuation to this task, returning a new task that completes after the
-   * continuation has finished running.
-   */
-  public <TContinuationResult> Task<TContinuationResult> continueWith(
-      Continuation<TResult, TContinuationResult> continuation) {
-    return continueWith(continuation, IMMEDIATE_EXECUTOR, null);
-  }
-
-  /**
-   * Adds a synchronous continuation to this task, returning a new task that completes after the
-   * continuation has finished running.
-   */
-  public <TContinuationResult> Task<TContinuationResult> continueWith(
-      Continuation<TResult, TContinuationResult> continuation, CancellationToken ct) {
-    return continueWith(continuation, IMMEDIATE_EXECUTOR, ct);
-  }
-
-  /**
-   * Adds an Task-based continuation to this task that will be scheduled using the executor,
-   * returning a new task that completes after the task returned by the continuation has completed.
-   */
-  public <TContinuationResult> Task<TContinuationResult> continueWithTask(
-      final Continuation<TResult, Task<TContinuationResult>> continuation, final Executor executor) {
-    return continueWithTask(continuation, executor, null);
-  }
-
-  /**
-   * Adds an Task-based continuation to this task that will be scheduled using the executor,
-   * returning a new task that completes after the task returned by the continuation has completed.
-   */
-  public <TContinuationResult> Task<TContinuationResult> continueWithTask(
-      final Continuation<TResult, Task<TContinuationResult>> continuation, final Executor executor,
-      final CancellationToken ct) {
-    boolean completed;
-    final bolts.TaskCompletionSource<TContinuationResult> tcs = new bolts.TaskCompletionSource<>();
-    synchronized (lock) {
-      completed = this.isCompleted();
-      if (!completed) {
-        this.continuations.add(new Continuation<TResult, Void>() {
-          @Override
-          public Void then(Task<TResult> task) {
-            completeAfterTask(tcs, continuation, task, executor, ct);
-            return null;
-          }
+
+    /**
+     * Continues a task with the equivalent of a Task-based while loop, where the body of the
+     * loop is
+     * a task continuation.
+     */
+    public Task<Void> continueWhile(final Callable<Boolean> predicate, final Continuation<Void,
+            Task<Void>> continuation, final Executor executor) {
+        return continueWhile(predicate, continuation, executor, null);
+    }
+
+    /**
+     * Continues a task with the equivalent of a Task-based while loop, where the body of the
+     * loop is
+     * a task continuation.
+     */
+    public Task<Void> continueWhile(final Callable<Boolean> predicate, final Continuation<Void,
+            Task<Void>> continuation, final Executor executor, final CancellationToken ct) {
+        final Capture<Continuation<Void, Task<Void>>> predicateContinuation = new Capture<>();
+        predicateContinuation.set(new Continuation<Void, Task<Void>>() {
+            @Override
+            public Task<Void> then(Task<Void> task) throws Exception {
+                if (ct != null && ct.isCancellationRequested()) {
+                    return Task.cancelled();
+                }
+
+                if (predicate.call()) {
+                    return Task.<Void>forResult(null).onSuccessTask(continuation, executor)
+                            .onSuccessTask(predicateContinuation.get(), executor);
+                }
+                return Task.forResult(null);
+            }
         });
-      }
+        return makeVoid().continueWithTask(predicateContinuation.get(), executor);
     }
-    if (completed) {
-      completeAfterTask(tcs, continuation, this, executor, ct);
+
+    /**
+     * Adds a continuation that will be scheduled using the executor, returning a new task that
+     * completes after the continuation has finished running. This allows the continuation to be
+     * scheduled on different thread.
+     */
+    public <TContinuationResult> Task<TContinuationResult> continueWith(final
+                                                                        Continuation<TResult,
+                                                                                TContinuationResult> continuation, final Executor executor) {
+        return continueWith(continuation, executor, null);
     }
-    return tcs.getTask();
-  }
-
-  /**
-   * Adds an asynchronous continuation to this task, returning a new task that completes after the
-   * task returned by the continuation has completed.
-   */
-  public <TContinuationResult> Task<TContinuationResult> continueWithTask(
-      Continuation<TResult, Task<TContinuationResult>> continuation) {
-    return continueWithTask(continuation, IMMEDIATE_EXECUTOR, null);
-  }
-
-  /**
-   * Adds an asynchronous continuation to this task, returning a new task that completes after the
-   * task returned by the continuation has completed.
-   */
-  public <TContinuationResult> Task<TContinuationResult> continueWithTask(
-      Continuation<TResult, Task<TContinuationResult>> continuation, CancellationToken ct) {
-    return continueWithTask(continuation, IMMEDIATE_EXECUTOR, ct);
-  }
-
-  /**
-   * Runs a continuation when a task completes successfully, forwarding along
-   * {@link java.lang.Exception} or cancellation.
-   */
-  public <TContinuationResult> Task<TContinuationResult> onSuccess(
-      final Continuation<TResult, TContinuationResult> continuation, Executor executor) {
-    return onSuccess(continuation, executor, null);
-  }
-
-  /**
-   * Runs a continuation when a task completes successfully, forwarding along
-   * {@link java.lang.Exception} or cancellation.
-   */
-  public <TContinuationResult> Task<TContinuationResult> onSuccess(
-      final Continuation<TResult, TContinuationResult> continuation, Executor executor,
-      final CancellationToken ct) {
-    return continueWithTask(new Continuation<TResult, Task<TContinuationResult>>() {
-      @Override
-      public Task<TContinuationResult> then(Task<TResult> task) {
-        if (ct != null && ct.isCancellationRequested()) {
-          return Task.cancelled();
-        }
 
-        if (task.isFaulted()) {
-          return Task.forError(task.getError());
-        } else if (task.isCancelled()) {
-          return Task.cancelled();
-        } else {
-          return task.continueWith(continuation);
+    /**
+     * Adds a continuation that will be scheduled using the executor, returning a new task that
+     * completes after the continuation has finished running. This allows the continuation to be
+     * scheduled on different thread.
+     */
+    public <TContinuationResult> Task<TContinuationResult> continueWith(final
+                                                                        Continuation<TResult,
+                                                                                TContinuationResult> continuation, final Executor executor, final CancellationToken ct) {
+        boolean completed;
+        final bolts.TaskCompletionSource<TContinuationResult> tcs = new bolts
+                .TaskCompletionSource<>();
+        synchronized (lock) {
+            completed = this.isCompleted();
+            if (!completed) {
+                this.continuations.add(new Continuation<TResult, Void>() {
+                    @Override
+                    public Void then(Task<TResult> task) {
+                        completeImmediately(tcs, continuation, task, executor, ct);
+                        return null;
+                    }
+                });
+            }
         }
-      }
-    }, executor);
-  }
-
-  /**
-   * Runs a continuation when a task completes successfully, forwarding along
-   * {@link java.lang.Exception}s or cancellation.
-   */
-  public <TContinuationResult> Task<TContinuationResult> onSuccess(
-      final Continuation<TResult, TContinuationResult> continuation) {
-    return onSuccess(continuation, IMMEDIATE_EXECUTOR, null);
-  }
-
-  /**
-   * Runs a continuation when a task completes successfully, forwarding along
-   * {@link java.lang.Exception}s or cancellation.
-   */
-  public <TContinuationResult> Task<TContinuationResult> onSuccess(
-      final Continuation<TResult, TContinuationResult> continuation, CancellationToken ct) {
-    return onSuccess(continuation, IMMEDIATE_EXECUTOR, ct);
-  }
-
-  /**
-   * Runs a continuation when a task completes successfully, forwarding along
-   * {@link java.lang.Exception}s or cancellation.
-   */
-  public <TContinuationResult> Task<TContinuationResult> onSuccessTask(
-      final Continuation<TResult, Task<TContinuationResult>> continuation, Executor executor) {
-    return onSuccessTask(continuation, executor, null);
-  }
-
-  /**
-   * Runs a continuation when a task completes successfully, forwarding along
-   * {@link java.lang.Exception}s or cancellation.
-   */
-  public <TContinuationResult> Task<TContinuationResult> onSuccessTask(
-      final Continuation<TResult, Task<TContinuationResult>> continuation, Executor executor,
-      final CancellationToken ct) {
-    return continueWithTask(new Continuation<TResult, Task<TContinuationResult>>() {
-      @Override
-      public Task<TContinuationResult> then(Task<TResult> task) {
-        if (ct != null && ct.isCancellationRequested()) {
-          return Task.cancelled();
+        if (completed) {
+            completeImmediately(tcs, continuation, this, executor, ct);
         }
+        return tcs.getTask();
+    }
 
-        if (task.isFaulted()) {
-          return Task.forError(task.getError());
-        } else if (task.isCancelled()) {
-          return Task.cancelled();
-        } else {
-          return task.continueWithTask(continuation);
+
+    /**
+     * Adds an Task-based continuation to this task that will be scheduled using the executor,
+     * returning a new task that completes after the task returned by the continuation has
+     * completed.
+     */
+    public <TContinuationResult> Task<TContinuationResult> continueWithTask(final
+                                                                            Continuation<TResult,
+                                                                                    Task<TContinuationResult>> continuation, final Executor executor, final CancellationToken ct) {
+        boolean completed;
+        final bolts.TaskCompletionSource<TContinuationResult> tcs = new bolts
+                .TaskCompletionSource<>();
+        synchronized (lock) {
+            completed = this.isCompleted();
+            if (!completed) {
+                this.continuations.add(new Continuation<TResult, Void>() {
+                    @Override
+                    public Void then(Task<TResult> task) {
+                        completeAfterTask(tcs, continuation, task, executor, ct);
+                        return null;
+                    }
+                });
+            }
         }
-      }
-    }, executor);
-  }
-
-  /**
-   * Runs a continuation when a task completes successfully, forwarding along
-   * {@link java.lang.Exception}s or cancellation.
-   */
-  public <TContinuationResult> Task<TContinuationResult> onSuccessTask(
-      final Continuation<TResult, Task<TContinuationResult>> continuation) {
-    return onSuccessTask(continuation, IMMEDIATE_EXECUTOR);
-  }
-
-  /**
-   * Runs a continuation when a task completes successfully, forwarding along
-   * {@link java.lang.Exception}s or cancellation.
-   */
-  public <TContinuationResult> Task<TContinuationResult> onSuccessTask(
-      final Continuation<TResult, Task<TContinuationResult>> continuation,
-      CancellationToken ct) {
-    return onSuccessTask(continuation, IMMEDIATE_EXECUTOR, ct);
-  }
-
-  /**
-   * Handles the non-async (i.e. the continuation doesn't return a Task) continuation case, passing
-   * the results of the given Task through to the given continuation and using the results of that
-   * call to set the result of the TaskContinuationSource.
-   *
-   * @param tcs
-   *          The TaskContinuationSource that will be orchestrated by this call.
-   * @param continuation
-   *          The non-async continuation.
-   * @param task
-   *          The task being completed.
-   * @param executor
-   *          The executor to use when running the continuation (allowing the continuation to be
-   *          scheduled on a different thread).
-   */
-  private static <TContinuationResult, TResult> void completeImmediately(
-      final bolts.TaskCompletionSource<TContinuationResult> tcs,
-      final Continuation<TResult, TContinuationResult> continuation, final Task<TResult> task,
-      Executor executor, final CancellationToken ct) {
-    try {
-      executor.execute(new Runnable() {
-        @Override
-        public void run() {
-          if (ct != null && ct.isCancellationRequested()) {
-            tcs.setCancelled();
-            return;
-          }
-
-          try {
-            TContinuationResult result = continuation.then(task);
-            tcs.setResult(result);
-          } catch (CancellationException e) {
-            tcs.setCancelled();
-          } catch (Exception e) {
-            tcs.setError(e);
-          }
+        if (completed) {
+            completeAfterTask(tcs, continuation, this, executor, ct);
         }
-      });
-    } catch (Exception e) {
-      tcs.setError(new ExecutorException(e));
+        return tcs.getTask();
     }
-  }
-
-  /**
-   * Handles the async (i.e. the continuation does return a Task) continuation case, passing the
-   * results of the given Task through to the given continuation to get a new Task. The
-   * TaskCompletionSource's results are only set when the new Task has completed, unwrapping the
-   * results of the task returned by the continuation.
-   *
-   * @param tcs
-   *          The TaskContinuationSource that will be orchestrated by this call.
-   * @param continuation
-   *          The async continuation.
-   * @param task
-   *          The task being completed.
-   * @param executor
-   *          The executor to use when running the continuation (allowing the continuation to be
-   *          scheduled on a different thread).
-   */
-  private static <TContinuationResult, TResult> void completeAfterTask(
-      final bolts.TaskCompletionSource<TContinuationResult> tcs,
-      final Continuation<TResult, Task<TContinuationResult>> continuation,
-      final Task<TResult> task, final Executor executor,
-      final CancellationToken ct) {
-    try {
-      executor.execute(new Runnable() {
-        @Override
-        public void run() {
-          if (ct != null && ct.isCancellationRequested()) {
-            tcs.setCancelled();
-            return;
-          }
-
-          try {
-            Task<TContinuationResult> result = continuation.then(task);
-            if (result == null) {
-              tcs.setResult(null);
-            } else {
-              result.continueWith(new Continuation<TContinuationResult, Void>() {
-                @Override
-                public Void then(Task<TContinuationResult> task) {
-                  if (ct != null && ct.isCancellationRequested()) {
-                    tcs.setCancelled();
-                    return null;
-                  }
-
-                  if (task.isCancelled()) {
-                    tcs.setCancelled();
-                  } else if (task.isFaulted()) {
-                    tcs.setError(task.getError());
-                  } else {
-                    tcs.setResult(task.getResult());
-                  }
-                  return null;
+
+    /**
+     * Adds a synchronous continuation to this task, returning a new task that completes after the
+     * continuation has finished running.
+     */
+    public <TContinuationResult> Task<TContinuationResult> continueWith(Continuation<TResult,
+            TContinuationResult> continuation) {
+        return continueWith(continuation, IMMEDIATE_EXECUTOR, null);
+    }
+
+    /**
+     * Adds a synchronous continuation to this task, returning a new task that completes after the
+     * continuation has finished running.
+     */
+    public <TContinuationResult> Task<TContinuationResult> continueWith(Continuation<TResult,
+            TContinuationResult> continuation, CancellationToken ct) {
+        return continueWith(continuation, IMMEDIATE_EXECUTOR, ct);
+    }
+
+    /**
+     * Adds an Task-based continuation to this task that will be scheduled using the executor,
+     * returning a new task that completes after the task returned by the continuation has
+     * completed.
+     */
+    public <TContinuationResult> Task<TContinuationResult> continueWithTask(final
+                                                                            Continuation<TResult,
+                                                                                    Task<TContinuationResult>> continuation, final Executor executor) {
+        return continueWithTask(continuation, executor, null);
+    }
+
+    /**
+     * Adds an asynchronous continuation to this task, returning a new task that completes after the
+     * task returned by the continuation has completed.
+     */
+    public <TContinuationResult> Task<TContinuationResult> continueWithTask(Continuation<TResult,
+            Task<TContinuationResult>> continuation) {
+        return continueWithTask(continuation, IMMEDIATE_EXECUTOR, null);
+    }
+
+    /**
+     * Adds an asynchronous continuation to this task, returning a new task that completes after the
+     * task returned by the continuation has completed.
+     */
+    public <TContinuationResult> Task<TContinuationResult> continueWithTask(Continuation<TResult,
+            Task<TContinuationResult>> continuation, CancellationToken ct) {
+        return continueWithTask(continuation, IMMEDIATE_EXECUTOR, ct);
+    }
+
+    /**
+     * Runs a continuation when a task completes successfully, forwarding along
+     * {@link java.lang.Exception} or cancellation.
+     */
+    public <TContinuationResult> Task<TContinuationResult> onSuccess(final Continuation<TResult,
+            TContinuationResult> continuation, Executor executor) {
+        return onSuccess(continuation, executor, null);
+    }
+
+    /**
+     * Runs a continuation when a task completes successfully, forwarding along
+     * {@link java.lang.Exception} or cancellation.
+     */
+    public <TContinuationResult> Task<TContinuationResult> onSuccess(final Continuation<TResult,
+            TContinuationResult> continuation, Executor executor, final CancellationToken ct) {
+        return continueWithTask(new Continuation<TResult, Task<TContinuationResult>>() {
+            @Override
+            public Task<TContinuationResult> then(Task<TResult> task) {
+                if (ct != null && ct.isCancellationRequested()) {
+                    return Task.cancelled();
+                }
+
+                if (task.isFaulted()) {
+                    return Task.forError(task.getError());
+                } else if (task.isCancelled()) {
+                    return Task.cancelled();
+                } else {
+                    return task.continueWith(continuation);
+                }
+            }
+        }, executor);
+    }
+
+
+    /**
+     * Runs a continuation when a task completes successfully, forwarding along
+     * {@link java.lang.Exception}s or cancellation.
+     */
+    public <TContinuationResult> Task<TContinuationResult> onSuccessTask(final
+                                                                         Continuation<TResult,
+                                                                                 Task<TContinuationResult>> continuation, Executor executor, final CancellationToken ct) {
+        return continueWithTask(new Continuation<TResult, Task<TContinuationResult>>() {
+            @Override
+            public Task<TContinuationResult> then(Task<TResult> task) {
+                if (ct != null && ct.isCancellationRequested()) {
+                    return Task.cancelled();
+                }
+
+                if (task.isFaulted()) {
+                    return Task.forError(task.getError());
+                } else if (task.isCancelled()) {
+                    return Task.cancelled();
+                } else {
+                    return task.continueWithTask(continuation);
                 }
-              });
             }
-          } catch (CancellationException e) {
-            tcs.setCancelled();
-          } catch (Exception e) {
-            tcs.setError(e);
-          }
+        }, executor);
+    }
+
+    /**
+     * Runs a continuation when a task completes successfully, forwarding along
+     * {@link java.lang.Exception}s or cancellation.
+     */
+    public <TContinuationResult> Task<TContinuationResult> onSuccess(final Continuation<TResult,
+            TContinuationResult> continuation) {
+        return onSuccess(continuation, IMMEDIATE_EXECUTOR, null);
+    }
+
+    /**
+     * Runs a continuation when a task completes successfully, forwarding along
+     * {@link java.lang.Exception}s or cancellation.
+     */
+    public <TContinuationResult> Task<TContinuationResult> onSuccess(final Continuation<TResult,
+            TContinuationResult> continuation, CancellationToken ct) {
+        return onSuccess(continuation, IMMEDIATE_EXECUTOR, ct);
+    }
+
+    /**
+     * Runs a continuation when a task completes successfully, forwarding along
+     * {@link java.lang.Exception}s or cancellation.
+     */
+    public <TContinuationResult> Task<TContinuationResult> onSuccessTask(final
+                                                                         Continuation<TResult,
+                                                                                 Task<TContinuationResult>> continuation, Executor executor) {
+        return onSuccessTask(continuation, executor, null);
+    }
+
+    /**
+     * Runs a continuation when a task completes successfully, forwarding along
+     * {@link java.lang.Exception}s or cancellation.
+     */
+    public <TContinuationResult> Task<TContinuationResult> onSuccessTask(final
+                                                                         Continuation<TResult,
+                                                                                 Task<TContinuationResult>> continuation) {
+        return onSuccessTask(continuation, IMMEDIATE_EXECUTOR);
+    }
+
+    /**
+     * Runs a continuation when a task completes successfully, forwarding along
+     * {@link java.lang.Exception}s or cancellation.
+     */
+    public <TContinuationResult> Task<TContinuationResult> onSuccessTask(final
+                                                                         Continuation<TResult,
+                                                                                 Task<TContinuationResult>> continuation, CancellationToken ct) {
+        return onSuccessTask(continuation, IMMEDIATE_EXECUTOR, ct);
+    }
+
+    /**
+     * Handles the non-async (i.e. the continuation doesn't return a Task) continuation case,
+     * passing
+     * the results of the given Task through to the given continuation and using the results of that
+     * call to set the result of the TaskContinuationSource.
+     *
+     * @param tcs          The TaskContinuationSource that will be orchestrated by this call.
+     * @param continuation The non-async continuation.
+     * @param task         The task being completed.
+     * @param executor     The executor to use when running the continuation (allowing the
+     *                     continuation to be
+     *                     scheduled on a different thread).
+     */
+    private static <TContinuationResult, TResult> void completeImmediately(final bolts
+            .TaskCompletionSource<TContinuationResult> tcs, final Continuation<TResult,
+            TContinuationResult> continuation, final Task<TResult> task, Executor executor, final
+    CancellationToken ct) {
+        try {
+            executor.execute(new Runnable() {
+                @Override
+                public void run() {
+                    if (ct != null && ct.isCancellationRequested()) {
+                        tcs.setCancelled();
+                        return;
+                    }
+
+                    try {
+                        TContinuationResult result = continuation.then(task);
+                        tcs.setResult(result);
+                    } catch (CancellationException e) {
+                        tcs.setCancelled();
+                    } catch (Exception e) {
+                        tcs.setError(e);
+                    }
+                }
+            });
+        } catch (Exception e) {
+            tcs.setError(new ExecutorException(e));
         }
-      });
-    } catch (Exception e) {
-      tcs.setError(new ExecutorException(e));
     }
-  }
 
-  private void runContinuations() {
-    synchronized (lock) {
-      for (Continuation<TResult, ?> continuation : continuations) {
+    /**
+     * Handles the async (i.e. the continuation does return a Task) continuation case, passing the
+     * results of the given Task through to the given continuation to get a new Task. The
+     * TaskCompletionSource's results are only set when the new Task has completed, unwrapping the
+     * results of the task returned by the continuation.
+     *
+     * @param tcs          The TaskContinuationSource that will be orchestrated by this call.
+     * @param continuation The async continuation.
+     * @param task         The task being completed.
+     * @param executor     The executor to use when running the continuation (allowing the
+     *                     continuation to be
+     *                     scheduled on a different thread).
+     */
+    private static <TContinuationResult, TResult> void completeAfterTask(final bolts
+            .TaskCompletionSource<TContinuationResult> tcs, final Continuation<TResult,
+            Task<TContinuationResult>> continuation, final Task<TResult> task, final Executor
+            executor, final CancellationToken ct) {
         try {
-          continuation.then(this);
-        } catch (RuntimeException e) {
-          throw e;
+            executor.execute(new Runnable() {
+                @Override
+                public void run() {
+                    if (ct != null && ct.isCancellationRequested()) {
+                        tcs.setCancelled();
+                        return;
+                    }
+
+                    try {
+                        Task<TContinuationResult> result = continuation.then(task);
+                        if (result == null) {
+                            tcs.setResult(null);
+                        } else {
+                            result.continueWith(new Continuation<TContinuationResult, Void>() {
+                                @Override
+                                public Void then(Task<TContinuationResult> task) {
+                                    if (ct != null && ct.isCancellationRequested()) {
+                                        tcs.setCancelled();
+                                        return null;
+                                    }
+
+                                    if (task.isCancelled()) {
+                                        tcs.setCancelled();
+                                    } else if (task.isFaulted()) {
+                                        tcs.setError(task.getError());
+                                    } else {
+                                        tcs.setResult(task.getResult());
+                                    }
+                                    return null;
+                                }
+                            });
+                        }
+                    } catch (CancellationException e) {
+                        tcs.setCancelled();
+                    } catch (Exception e) {
+                        tcs.setError(e);
+                    }
+                }
+            });
         } catch (Exception e) {
-          throw new RuntimeException(e);
+            tcs.setError(new ExecutorException(e));
         }
-      }
-      continuations = null;
     }
-  }
-
-  /**
-   * Sets the cancelled flag on the Task if the Task hasn't already been completed.
-   */
-  /* package */ boolean trySetCancelled() {
-    synchronized (lock) {
-      if (complete) {
-        return false;
-      }
-      complete = true;
-      cancelled = true;
-      lock.notifyAll();
-      runContinuations();
-      return true;
+
+    private void runContinuations() {
+        synchronized (lock) {
+            for (Continuation<TResult, ?> continuation : continuations) {
+                try {
+                    continuation.then(this);
+                } catch (RuntimeException e) {
+                    throw e;
+                } catch (Exception e) {
+                    throw new RuntimeException(e);
+                }
+            }
+            continuations = null;
+        }
     }
-  }
-
-  /**
-   * Sets the result on the Task if the Task hasn't already been completed.
-   */
-  /* package */ boolean trySetResult(TResult result) {
-    synchronized (lock) {
-      if (complete) {
-        return false;
-      }
-      complete = true;
-      Task.this.result = result;
-      lock.notifyAll();
-      runContinuations();
-      return true;
+
+    /**
+     * Sets the cancelled flag on the Task if the Task hasn't already been completed.
+     */
+    /* package */ boolean trySetCancelled() {
+        synchronized (lock) {
+            if (complete) {
+                return false;
+            }
+            complete = true;
+            cancelled = true;
+            lock.notifyAll();
+            runContinuations();
+            return true;
+        }
     }
-  }
-
-  /**
-   * Sets the error on the Task if the Task hasn't already been completed.
-   */
-  /* package */ boolean trySetError(Exception error) {
-    synchronized (lock) {
-      if (complete) {
-        return false;
-      }
-      complete = true;
-      Task.this.error = error;
-      errorHasBeenObserved = false;
-      lock.notifyAll();
-      runContinuations();
-      if (!errorHasBeenObserved && getUnobservedExceptionHandler() != null)
-        unobservedErrorNotifier = new UnobservedErrorNotifier(this);
-      return true;
+
+    /**
+     * Sets the result on the Task if the Task hasn't already been completed.
+     */
+    /* package */ boolean trySetResult(TResult result) {
+        synchronized (lock) {
+            if (complete) {
+                return false;
+            }
+            complete = true;
+            Task.this.result = result;
+            lock.notifyAll();
+            runContinuations();
+            return true;
+        }
     }
-  }
 
-  /**
-   * @deprecated Please use {@link bolts.TaskCompletionSource} instead.
-   */
-  public class TaskCompletionSource extends bolts.TaskCompletionSource<TResult> {
+    /**
+     * Sets the error on the Task if the Task hasn't already been completed.
+     */
+    /* package */ boolean trySetError(Exception error) {
+        synchronized (lock) {
+            if (complete) {
+                return false;
+            }
+            complete = true;
+            Task.this.error = error;
+            errorHasBeenObserved = false;
+            lock.notifyAll();
+            runContinuations();
+            if (!errorHasBeenObserved && getUnobservedExceptionHandler() != null)
+                unobservedErrorNotifier = new UnobservedErrorNotifier(this);
+            return true;
+        }
+    }
 
-    /* package */ TaskCompletionSource() {
+    /**
+     * @deprecated Please use {@link bolts.TaskCompletionSource} instead.
+     */
+    public class TaskCompletionSource extends bolts.TaskCompletionSource<TResult> {
+
+        /* package */ TaskCompletionSource() {
+        }
     }
-  }
 
-  private static Task<?> TASK_NULL = new Task<>(null);
-  private static Task<Boolean> TASK_TRUE = new Task<>((Boolean) true);
-  private static Task<Boolean> TASK_FALSE = new Task<>((Boolean) false);
-  private static Task<?> TASK_CANCELLED = new Task(true);
+    private static Task<?> TASK_NULL = new Task<>(null);
+    private static Task<Boolean> TASK_TRUE = new Task<>((Boolean) true);
+    private static Task<Boolean> TASK_FALSE = new Task<>((Boolean) false);
+    private static Task<?> TASK_CANCELLED = new Task(true);
 }
diff --git a/bolts-tasks/src/main/java/bolts/TaskCompletionSource.java b/bolts-tasks/src/main/java/bolts/TaskCompletionSource.java
index b611b5e..5ad97ac 100644
--- a/bolts-tasks/src/main/java/bolts/TaskCompletionSource.java
+++ b/bolts-tasks/src/main/java/bolts/TaskCompletionSource.java
@@ -8,68 +8,68 @@
  */
 public class TaskCompletionSource<TResult> {
 
-  private final Task<TResult> task;
+    private final Task<TResult> task;
 
-  /**
-   * Creates a TaskCompletionSource that orchestrates a Task. This allows the creator of a task to
-   * be solely responsible for its completion.
-   */
-  public TaskCompletionSource() {
-    task = new Task<>();
-  }
+    /**
+     * Creates a TaskCompletionSource that orchestrates a Task. This allows the creator of a task to
+     * be solely responsible for its completion.
+     */
+    public TaskCompletionSource() {
+        task = new Task<>();
+    }
 
-  /**
-   * @return the Task associated with this TaskCompletionSource.
-   */
-  public Task<TResult> getTask() {
-    return task;
-  }
+    /**
+     * @return the Task associated with this TaskCompletionSource.
+     */
+    public Task<TResult> getTask() {
+        return task;
+    }
 
-  /**
-   * Sets the cancelled flag on the Task if the Task hasn't already been completed.
-   */
-  public boolean trySetCancelled() {
-    return task.trySetCancelled();
-  }
+    /**
+     * Sets the cancelled flag on the Task if the Task hasn't already been completed.
+     */
+    public boolean trySetCancelled() {
+        return task.trySetCancelled();
+    }
 
-  /**
-   * Sets the result on the Task if the Task hasn't already been completed.
-   */
-  public boolean trySetResult(TResult result) {
-    return task.trySetResult(result);
-  }
+    /**
+     * Sets the result on the Task if the Task hasn't already been completed.
+     */
+    public boolean trySetResult(TResult result) {
+        return task.trySetResult(result);
+    }
 
-  /**
-   * Sets the error on the Task if the Task hasn't already been completed.
-   */
-  public boolean trySetError(Exception error) {
-    return task.trySetError(error);
-  }
+    /**
+     * Sets the error on the Task if the Task hasn't already been completed.
+     */
+    public boolean trySetError(Exception error) {
+        return task.trySetError(error);
+    }
 
-  /**
-   * Sets the cancelled flag on the task, throwing if the Task has already been completed.
-   */
-  public void setCancelled() {
-    if (!trySetCancelled()) {
-      throw new IllegalStateException("Cannot cancel a completed task.");
+    /**
+     * Sets the cancelled flag on the task, throwing if the Task has already been completed.
+     */
+    public void setCancelled() {
+        if (!trySetCancelled()) {
+            throw new IllegalStateException("Cannot cancel a completed task.");
+        }
     }
-  }
 
-  /**
-   * Sets the result of the Task, throwing if the Task has already been completed.
-   */
-  public void setResult(TResult result) {
-    if (!trySetResult(result)) {
-      throw new IllegalStateException("Cannot set the result of a completed task.");
+    /**
+     * Sets the result of the Task, throwing if the Task has already been completed.
+     */
+    public void setResult(TResult result) {
+        if (!trySetResult(result)) {
+            throw new IllegalStateException("Cannot set the result of a completed task.");
+        }
     }
-  }
 
-  /**
-   * Sets the error of the Task, throwing if the Task has already been completed.
-   */
-  public void setError(Exception error) {
-    if (!trySetError(error)) {
-      throw new IllegalStateException("Cannot set the error on a completed task.");
+    /**
+     * Sets the error of the Task, throwing if the Task has already been completed.
+     */
+    public void setError(Exception error) {
+        if (!trySetError(error)) {
+            throw new IllegalStateException("Cannot set the error on a completed task.");
+        }
     }
-  }
 }
diff --git a/bolts-tasks/src/main/java/bolts/UnobservedErrorNotifier.java b/bolts-tasks/src/main/java/bolts/UnobservedErrorNotifier.java
index afb3c57..cb841e5 100644
--- a/bolts-tasks/src/main/java/bolts/UnobservedErrorNotifier.java
+++ b/bolts-tasks/src/main/java/bolts/UnobservedErrorNotifier.java
@@ -6,28 +6,29 @@
  * with an UnobservedTaskException.
  */
 class UnobservedErrorNotifier {
-  private Task<?> task;
+    private Task<?> task;
 
-  public UnobservedErrorNotifier(Task<?> task) {
-      this.task = task;
-  }
+    public UnobservedErrorNotifier(Task<?> task) {
+        this.task = task;
+    }
 
-  @Override
-  protected void finalize() throws Throwable {
-    try {
-      Task faultedTask = this.task;
-      if (faultedTask != null) {
-        Task.UnobservedExceptionHandler ueh = Task.getUnobservedExceptionHandler();
-        if (ueh != null) {
-          ueh.unobservedException(faultedTask, new UnobservedTaskException(faultedTask.getError()));
+    @Override
+    protected void finalize() throws Throwable {
+        try {
+            Task faultedTask = this.task;
+            if (faultedTask != null) {
+                Task.UnobservedExceptionHandler ueh = Task.getUnobservedExceptionHandler();
+                if (ueh != null) {
+                    ueh.unobservedException(faultedTask, new UnobservedTaskException(faultedTask
+                            .getError()));
+                }
+            }
+        } finally {
+            super.finalize();
         }
-      }
-    } finally {
-      super.finalize();
     }
-  }
 
-  public void setObserved() {
-    task = null;
-  }
+    public void setObserved() {
+        task = null;
+    }
 }
diff --git a/bolts-tasks/src/main/java/bolts/UnobservedTaskException.java b/bolts-tasks/src/main/java/bolts/UnobservedTaskException.java
index c3868cc..b4265e8 100644
--- a/bolts-tasks/src/main/java/bolts/UnobservedTaskException.java
+++ b/bolts-tasks/src/main/java/bolts/UnobservedTaskException.java
@@ -4,7 +4,7 @@
  * Used to signify that a Task's error went unobserved.
  */
 public class UnobservedTaskException extends RuntimeException {
-  public UnobservedTaskException(Throwable cause) {
-    super(cause);
-  }
+    public UnobservedTaskException(Throwable cause) {
+        super(cause);
+    }
 }
diff --git a/bolts-tasks/src/test/java/bolts/CancellationTest.java b/bolts-tasks/src/test/java/bolts/CancellationTest.java
index b7859f0..c0c807f 100644
--- a/bolts-tasks/src/test/java/bolts/CancellationTest.java
+++ b/bolts-tasks/src/test/java/bolts/CancellationTest.java
@@ -21,171 +21,171 @@
 
 public class CancellationTest {
 
-  @Test
-  public void testTokenIsCancelled() {
-    CancellationTokenSource cts = new CancellationTokenSource();
-    CancellationToken token = cts.getToken();
+    @Test
+    public void testTokenIsCancelled() {
+        CancellationTokenSource cts = new CancellationTokenSource();
+        CancellationToken token = cts.getToken();
 
-    assertFalse(token.isCancellationRequested());
-    assertFalse(cts.isCancellationRequested());
+        assertFalse(token.isCancellationRequested());
+        assertFalse(cts.isCancellationRequested());
 
-    cts.cancel();
+        cts.cancel();
 
-    assertTrue(token.isCancellationRequested());
-    assertTrue(cts.isCancellationRequested());
-  }
+        assertTrue(token.isCancellationRequested());
+        assertTrue(cts.isCancellationRequested());
+    }
+
+    @Test
+    public void testTokenIsCancelledAfterNoDelay() throws Exception {
+        CancellationTokenSource cts = new CancellationTokenSource();
+        CancellationToken token = cts.getToken();
 
-  @Test
-  public void testTokenIsCancelledAfterNoDelay() throws Exception {
-    CancellationTokenSource cts = new CancellationTokenSource();
-    CancellationToken token = cts.getToken();
+        assertFalse(token.isCancellationRequested());
 
-    assertFalse(token.isCancellationRequested());
+        cts.cancelAfter(0);
 
-    cts.cancelAfter(0);
+        assertTrue(token.isCancellationRequested());
+        assertTrue(cts.isCancellationRequested());
+    }
 
-    assertTrue(token.isCancellationRequested());
-    assertTrue(cts.isCancellationRequested());
-  }
+    @Test
+    public void testTokenIsCancelledAfterDelay() throws Exception {
+        CancellationTokenSource cts = new CancellationTokenSource();
+        CancellationToken token = cts.getToken();
 
-  @Test
-  public void testTokenIsCancelledAfterDelay() throws Exception {
-    CancellationTokenSource cts = new CancellationTokenSource();
-    CancellationToken token = cts.getToken();
+        assertFalse(token.isCancellationRequested());
 
-    assertFalse(token.isCancellationRequested());
+        cts.cancelAfter(100);
 
-    cts.cancelAfter(100);
+        assertFalse(token.isCancellationRequested());
+        assertFalse(cts.isCancellationRequested());
 
-    assertFalse(token.isCancellationRequested());
-    assertFalse(cts.isCancellationRequested());
+        Thread.sleep(150);
+
+        assertTrue(token.isCancellationRequested());
+        assertTrue(cts.isCancellationRequested());
+    }
 
-    Thread.sleep(150);
+    @Test
+    public void testTokenCancelAfterDelayCancellation() throws Exception {
+        CancellationTokenSource cts = new CancellationTokenSource();
+        CancellationToken token = cts.getToken();
 
-    assertTrue(token.isCancellationRequested());
-    assertTrue(cts.isCancellationRequested());
-  }
+        assertFalse(token.isCancellationRequested());
 
-  @Test
-  public void testTokenCancelAfterDelayCancellation() throws Exception {
-    CancellationTokenSource cts = new CancellationTokenSource();
-    CancellationToken token = cts.getToken();
+        cts.cancelAfter(100);
 
-    assertFalse(token.isCancellationRequested());
+        assertFalse(token.isCancellationRequested());
+        assertFalse(cts.isCancellationRequested());
 
-    cts.cancelAfter(100);
+        cts.cancelAfter(-1);
 
-    assertFalse(token.isCancellationRequested());
-    assertFalse(cts.isCancellationRequested());
+        Thread.sleep(150);
+
+        assertFalse(token.isCancellationRequested());
+        assertFalse(cts.isCancellationRequested());
+    }
+
+    @Test
+    public void testTokenThrowsWhenCancelled() {
+        CancellationTokenSource cts = new CancellationTokenSource();
+        CancellationToken token = cts.getToken();
+
+        try {
+            token.throwIfCancellationRequested();
+        } catch (CancellationException e) {
+            fail("Token has not been cancelled yet, " + CancellationException.class.getSimpleName
+                    () + " should not be thrown");
+        }
+
+        cts.cancel();
+
+        try {
+            token.throwIfCancellationRequested();
+            fail(CancellationException.class.getSimpleName() + " should be thrown");
+        } catch (CancellationException e) {
+            // Do nothing
+        }
+    }
 
-    cts.cancelAfter(-1);
+    @Test
+    public void testTokenCallsRegisteredActionWhenCancelled() {
+        CancellationTokenSource cts = new CancellationTokenSource();
+        CancellationToken token = cts.getToken();
+        final Capture<Object> result = new Capture<>();
 
-    Thread.sleep(150);
+        token.register(new Runnable() {
+            @Override
+            public void run() {
+                result.set("Run!");
+            }
+        });
 
-    assertFalse(token.isCancellationRequested());
-    assertFalse(cts.isCancellationRequested());
-  }
+        assertNull(result.get());
 
-  @Test
-  public void testTokenThrowsWhenCancelled() {
-    CancellationTokenSource cts = new CancellationTokenSource();
-    CancellationToken token = cts.getToken();
+        cts.cancel();
 
-    try {
-      token.throwIfCancellationRequested();
-    } catch (CancellationException e) {
-      fail("Token has not been cancelled yet, " + CancellationException.class.getSimpleName()
-          + " should not be thrown");
+        assertNotNull(result.get());
     }
 
-    cts.cancel();
+    @Test
+    public void testCancelledTokenCallsRegisteredActionImmediately() {
+        CancellationTokenSource cts = new CancellationTokenSource();
+        CancellationToken token = cts.getToken();
+        final Capture<Object> result = new Capture<>();
+
+        cts.cancel();
+
+        token.register(new Runnable() {
+            @Override
+            public void run() {
+                result.set("Run!");
+            }
+        });
+
+        assertNotNull(result.get());
+    }
+
+    @Test
+    public void testTokenDoesNotCallUnregisteredAction() {
+        CancellationTokenSource cts = new CancellationTokenSource();
+        CancellationToken token = cts.getToken();
+        final Capture<Object> result1 = new Capture<>();
+        final Capture<Object> result2 = new Capture<>();
+
+        CancellationTokenRegistration registration1 = token.register(new Runnable() {
+            @Override
+            public void run() {
+                result1.set("Run!");
+            }
+        });
+        token.register(new Runnable() {
+            @Override
+            public void run() {
+                result2.set("Run!");
+            }
+        });
+
+        registration1.close();
+
+        cts.cancel();
+
+        assertNull(result1.get());
+        assertNotNull(result2.get());
+    }
+
+    @Test
+    public void testCloseCancellationTokenSource() {
+        CancellationTokenSource cts = new CancellationTokenSource();
+        CancellationToken token = cts.getToken();
+
+        token.register(new Runnable() {
+            @Override
+            public void run() {
+                // Do nothing
+            }
+        });
 
-    try {
-      token.throwIfCancellationRequested();
-      fail(CancellationException.class.getSimpleName() + " should be thrown");
-    } catch (CancellationException e) {
-      // Do nothing
+        cts.close();
     }
-  }
-
-  @Test
-  public void testTokenCallsRegisteredActionWhenCancelled() {
-    CancellationTokenSource cts = new CancellationTokenSource();
-    CancellationToken token = cts.getToken();
-    final Capture<Object> result = new Capture<>();
-
-    token.register(new Runnable() {
-      @Override
-      public void run() {
-        result.set("Run!");
-      }
-    });
-
-    assertNull(result.get());
-
-    cts.cancel();
-
-    assertNotNull(result.get());
-  }
-
-  @Test
-  public void testCancelledTokenCallsRegisteredActionImmediately() {
-    CancellationTokenSource cts = new CancellationTokenSource();
-    CancellationToken token = cts.getToken();
-    final Capture<Object> result = new Capture<>();
-
-    cts.cancel();
-
-    token.register(new Runnable() {
-      @Override
-      public void run() {
-        result.set("Run!");
-      }
-    });
-
-    assertNotNull(result.get());
-  }
-
-  @Test
-  public void testTokenDoesNotCallUnregisteredAction() {
-    CancellationTokenSource cts = new CancellationTokenSource();
-    CancellationToken token = cts.getToken();
-    final Capture<Object> result1 = new Capture<>();
-    final Capture<Object> result2 = new Capture<>();
-
-    CancellationTokenRegistration registration1 = token.register(new Runnable() {
-      @Override
-      public void run() {
-        result1.set("Run!");
-      }
-    });
-    token.register(new Runnable() {
-      @Override
-      public void run() {
-        result2.set("Run!");
-      }
-    });
-
-    registration1.close();
-
-    cts.cancel();
-
-    assertNull(result1.get());
-    assertNotNull(result2.get());
-  }
-
-  @Test
-  public void testCloseCancellationTokenSource() {
-    CancellationTokenSource cts = new CancellationTokenSource();
-    CancellationToken token = cts.getToken();
-
-    token.register(new Runnable() {
-      @Override
-      public void run() {
-        // Do nothing
-      }
-    });
-
-    cts.close();
-  }
 }
diff --git a/bolts-tasks/src/test/java/bolts/TaskTest.java b/bolts-tasks/src/test/java/bolts/TaskTest.java
index cea21dc..2402298 100644
--- a/bolts-tasks/src/test/java/bolts/TaskTest.java
+++ b/bolts-tasks/src/test/java/bolts/TaskTest.java
@@ -3,7 +3,7 @@
  *  All rights reserved.
  *
  *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant 
+ *  LICENSE file in the root directory of this source tree. An additional grant
  *  of patent rights can be found in the PATENTS file in the same directory.
  *
  */
@@ -18,8 +18,8 @@
 import java.util.List;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CancellationException;
-import java.util.concurrent.Executors;
 import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -31,1243 +31,1250 @@
 
 public class TaskTest {
 
-  @Rule
-  public ExpectedException thrown = ExpectedException.none();
-
-  private void runTaskTest(Callable<Task<?>> callable) {
-    try {
-      Task<?> task = callable.call();
-      task.waitForCompletion();
-      if (task.isFaulted()) {
-        Exception error = task.getError();
-        if (error instanceof RuntimeException) {
-          throw (RuntimeException) error;
+    @Rule
+    public ExpectedException thrown = ExpectedException.none();
+
+    private void runTaskTest(Callable<Task<?>> callable) {
+        try {
+            Task<?> task = callable.call();
+            task.waitForCompletion();
+            if (task.isFaulted()) {
+                Exception error = task.getError();
+                if (error instanceof RuntimeException) {
+                    throw (RuntimeException) error;
+                }
+                throw new RuntimeException(error);
+            } else if (task.isCancelled()) {
+                throw new RuntimeException(new CancellationException());
+            }
+        } catch (Exception e) {
+            throw new RuntimeException(e);
         }
-        throw new RuntimeException(error);
-      } else if (task.isCancelled()) {
-        throw new RuntimeException(new CancellationException());
-      }
-    } catch (Exception e) {
-      throw new RuntimeException(e);
     }
-  }
-
-  @Test
-  public void testCache() {
-    assertSame(Task.forResult(null), Task.forResult(null));
-    Task<Boolean> trueTask = Task.forResult(true);
-    assertTrue(trueTask.getResult());
-    assertSame(trueTask, Task.forResult(true));
-    Task<Boolean> falseTask = Task.forResult(false);
-    assertFalse(falseTask.getResult());
-    assertSame(falseTask, Task.forResult(false));
-    assertSame(Task.cancelled(), Task.cancelled());
-  }
-
-  @SuppressWarnings("ThrowableResultOfMethodCallIgnored")
-  @Test
-  public void testPrimitives() {
-    Task<Integer> complete = Task.forResult(5);
-    Task<Integer> error = Task.forError(new RuntimeException());
-    Task<Integer> cancelled = Task.cancelled();
-
-    assertTrue(complete.isCompleted());
-    assertEquals(5, complete.getResult().intValue());
-    assertFalse(complete.isFaulted());
-    assertFalse(complete.isCancelled());
-
-    assertTrue(error.isCompleted());
-    assertTrue(error.getError() instanceof RuntimeException);
-    assertTrue(error.isFaulted());
-    assertFalse(error.isCancelled());
-
-    assertTrue(cancelled.isCompleted());
-    assertFalse(cancelled.isFaulted());
-    assertTrue(cancelled.isCancelled());
-  }
-
-  @Test
-  public void testDelay() throws InterruptedException {
-    final Task<Void> delayed = Task.delay(200);
-    Thread.sleep(50);
-    assertFalse(delayed.isCompleted());
-    Thread.sleep(200);
-    assertTrue(delayed.isCompleted());
-    assertFalse(delayed.isFaulted());
-    assertFalse(delayed.isCancelled());
-  }
-
-  @Test
-  public void testDelayWithCancelledToken() throws InterruptedException {
-    CancellationTokenSource cts = new CancellationTokenSource();
-    cts.cancel();
-    final Task<Void> delayed = Task.delay(200, cts.getToken());
-    assertTrue(delayed.isCancelled());
-  }
-
-  @Test
-  public void testDelayWithToken() throws InterruptedException {
-    CancellationTokenSource cts = new CancellationTokenSource();
-    final Task<Void> delayed = Task.delay(200, cts.getToken());
-    assertFalse(delayed.isCancelled());
-    cts.cancel();
-    assertTrue(delayed.isCancelled());
-  }
-
-  @Test
-  public void testSynchronousContinuation() {
-    final Task<Integer> complete = Task.forResult(5);
-    final Task<Integer> error = Task.forError(new RuntimeException());
-    final Task<Integer> cancelled = Task.cancelled();
-
-    complete.continueWith(new Continuation<Integer, Void>() {
-      public Void then(Task<Integer> task) {
-        assertEquals(complete, task);
-        assertTrue(task.isCompleted());
-        assertEquals(5, task.getResult().intValue());
-        assertFalse(task.isFaulted());
-        assertFalse(task.isCancelled());
-        return null;
-      }
-    });
 
-    error.continueWith(new Continuation<Integer, Void>() {
-      public Void then(Task<Integer> task) {
-        assertEquals(error, task);
-        assertTrue(task.isCompleted());
-        assertTrue(task.getError() instanceof RuntimeException);
-        assertTrue(task.isFaulted());
-        assertFalse(task.isCancelled());
-        return null;
-      }
-    });
+    @Test
+    public void testCache() {
+        assertSame(Task.forResult(null), Task.forResult(null));
+        Task<Boolean> trueTask = Task.forResult(true);
+        assertTrue(trueTask.getResult());
+        assertSame(trueTask, Task.forResult(true));
+        Task<Boolean> falseTask = Task.forResult(false);
+        assertFalse(falseTask.getResult());
+        assertSame(falseTask, Task.forResult(false));
+        assertSame(Task.cancelled(), Task.cancelled());
+    }
+
+    @SuppressWarnings("ThrowableResultOfMethodCallIgnored")
+    @Test
+    public void testPrimitives() {
+        Task<Integer> complete = Task.forResult(5);
+        Task<Integer> error = Task.forError(new RuntimeException());
+        Task<Integer> cancelled = Task.cancelled();
+
+        assertTrue(complete.isCompleted());
+        assertEquals(5, complete.getResult().intValue());
+        assertFalse(complete.isFaulted());
+        assertFalse(complete.isCancelled());
+
+        assertTrue(error.isCompleted());
+        assertTrue(error.getError() instanceof RuntimeException);
+        assertTrue(error.isFaulted());
+        assertFalse(error.isCancelled());
 
-    cancelled.continueWith(new Continuation<Integer, Void>() {
-      public Void then(Task<Integer> task) {
-        assertEquals(cancelled, task);
         assertTrue(cancelled.isCompleted());
         assertFalse(cancelled.isFaulted());
         assertTrue(cancelled.isCancelled());
-        return null;
-      }
-    });
-  }
-
-  @Test
-  public void testSynchronousChaining() {
-    Task<Integer> first = Task.forResult(1);
-    Task<Integer> second = first.continueWith(new Continuation<Integer, Integer>() {
-      public Integer then(Task<Integer> task) {
-        return 2;
-      }
-    });
-    Task<Integer> third = second.continueWithTask(new Continuation<Integer, Task<Integer>>() {
-      public Task<Integer> then(Task<Integer> task) {
-        return Task.forResult(3);
-      }
-    });
-    assertTrue(first.isCompleted());
-    assertTrue(second.isCompleted());
-    assertTrue(third.isCompleted());
-    assertEquals(1, first.getResult().intValue());
-    assertEquals(2, second.getResult().intValue());
-    assertEquals(3, third.getResult().intValue());
-  }
-
-  @Test
-  public void testSynchronousCancellation() {
-    Task<Integer> first = Task.forResult(1);
-    Task<Integer> second = first.continueWith(new Continuation<Integer, Integer>() {
-      public Integer then(Task<Integer> task) {
-        throw new CancellationException();
-      }
-    });
-    assertTrue(first.isCompleted());
-    assertTrue(second.isCancelled());
-  }
-
-  @Test
-  public void testSynchronousContinuationTokenAlreadyCancelled() {
-    CancellationTokenSource cts = new CancellationTokenSource();
-    final Capture<Boolean> continuationRun = new Capture<>(false);
-    cts.cancel();
-    Task<Integer> first = Task.forResult(1);
-    Task<Integer> second = first.continueWith(new Continuation<Integer, Integer>() {
-      public Integer then(Task<Integer> task) {
-        continuationRun.set(true);
-        return 2;
-      }
-    }, cts.getToken());
-    assertTrue(first.isCompleted());
-    assertTrue(second.isCancelled());
-    assertFalse(continuationRun.get());
-  }
-
-  @Test
-  public void testSynchronousTaskCancellation() {
-    Task<Integer> first = Task.forResult(1);
-    Task<Integer> second = first.continueWithTask(new Continuation<Integer, Task<Integer>>() {
-      public Task<Integer> then(Task<Integer> task) {
-        throw new CancellationException();
-      }
-    });
-    assertTrue(first.isCompleted());
-    assertTrue(second.isCancelled());
-  }
-
-  @Test
-  public void testBackgroundCall() {
-    runTaskTest(new Callable<Task<?>>() {
-      public Task<?> call() throws Exception {
-        return Task.callInBackground(new Callable<Integer>() {
-          public Integer call() throws Exception {
-            Thread.sleep(100);
-            return 5;
-          }
-        }).continueWith(new Continuation<Integer, Void>() {
-          public Void then(Task<Integer> task) {
-            assertEquals(5, task.getResult().intValue());
-            return null;
-          }
-        });
-      }
-    });
-  }
-
-  @Test
-  public void testBackgroundCallTokenCancellation() {
-    final CancellationTokenSource cts = new CancellationTokenSource();
-    final CancellationToken ct = cts.getToken();
-    final Capture<Boolean> waitingToBeCancelled = new Capture<>(false);
-    final Object cancelLock = new Object();
-
-    Task<Integer> task = Task.callInBackground(new Callable<Integer>() {
-      @Override
-      public Integer call() throws Exception {
-        synchronized (cancelLock) {
-          waitingToBeCancelled.set(true);
-          cancelLock.wait();
-        }
-        ct.throwIfCancellationRequested();
-        return 5;
-      }
-    });
-
-    while (true) {
-      synchronized (cancelLock) {
-        if (waitingToBeCancelled.get()) {
-          cts.cancel();
-          cancelLock.notify();
-          break;
-        }
-      }
-      try {
-        Thread.sleep(5);
-      } catch (InterruptedException e) {
-        throw new RuntimeException(e);
-      }
     }
 
-    try {
-      task.waitForCompletion();
-    } catch (InterruptedException e) {
-      throw new RuntimeException(e);
+    @Test
+    public void testDelay() throws InterruptedException {
+        final Task<Void> delayed = Task.delay(200);
+        Thread.sleep(50);
+        assertFalse(delayed.isCompleted());
+        Thread.sleep(200);
+        assertTrue(delayed.isCompleted());
+        assertFalse(delayed.isFaulted());
+        assertFalse(delayed.isCancelled());
     }
 
-    assertTrue(task.isCancelled());
-  }
-
-  @Test
-  public void testBackgroundCallTokenAlreadyCancelled() {
-    final CancellationTokenSource cts = new CancellationTokenSource();
-
-    cts.cancel();
-    runTaskTest(new Callable<Task<?>>() {
-      public Task<?> call() throws Exception {
-        return Task.callInBackground(new Callable<Integer>() {
-          public Integer call() throws Exception {
-            Thread.sleep(100);
-            return 5;
-          }
-        }, cts.getToken()).continueWith(new Continuation<Integer, Void>() {
-          public Void then(Task<Integer> task) {
-            assertTrue(task.isCancelled());
-            return null;
-          }
-        });
-      }
-    });
-  }
-
-  @Test
-  public void testBackgroundCallWaiting() throws Exception {
-    Task<Integer> task = Task.callInBackground(new Callable<Integer>() {
-      public Integer call() throws Exception {
-        Thread.sleep(100);
-        return 5;
-      }
-    });
-    task.waitForCompletion();
-    assertTrue(task.isCompleted());
-    assertEquals(5, task.getResult().intValue());
-  }
-
-  @Test
-  public void testBackgroundCallWaitingWithTimeouts() throws Exception {
-    final Object sync = new Object();
-
-    Task<Integer> task = Task.callInBackground(new Callable<Integer>() {
-      public Integer call() throws Exception {
-        synchronized (sync) {
-          sync.wait();
-          Thread.sleep(100);
-        }
-        return 5;
-      }
-    });
-    // wait -> timeout
-    assertFalse(task.waitForCompletion(100, TimeUnit.MILLISECONDS));
-    synchronized (sync) {
-      sync.notify();
+    @Test
+    public void testDelayWithCancelledToken() throws InterruptedException {
+        CancellationTokenSource cts = new CancellationTokenSource();
+        cts.cancel();
+        final Task<Void> delayed = Task.delay(200, cts.getToken());
+        assertTrue(delayed.isCancelled());
     }
-    // wait -> completes
-    assertTrue(task.waitForCompletion(1000, TimeUnit.MILLISECONDS));
-    // wait -> already completed
-    assertTrue(task.waitForCompletion(100, TimeUnit.MILLISECONDS));
-    assertEquals(5, task.getResult().intValue());
-  }
-
-  @Test
-  public void testBackgroundCallWaitingOnError() throws Exception {
-    Task<Integer> task = Task.callInBackground(new Callable<Integer>() {
-      public Integer call() throws Exception {
-        Thread.sleep(100);
-        throw new RuntimeException();
-      }
-    });
-    task.waitForCompletion();
-    assertTrue(task.isCompleted());
-    assertTrue(task.isFaulted());
-  }
-
-  @Test
-  public void testBackgroundCallWaitOnCancellation() throws Exception {
-    Task<Integer> task = Task.callInBackground(new Callable<Integer>() {
-      public Integer call() throws Exception {
-        Thread.sleep(100);
-        return 5;
-      }
-    }).continueWithTask(new Continuation<Integer, Task<Integer>>() {
-
-      public Task<Integer> then(Task<Integer> task) {
-        return Task.cancelled();
-      }
-    });
-    task.waitForCompletion();
-    assertTrue(task.isCompleted());
-    assertTrue(task.isCancelled());
-  }
-
-  @Test
-  public void testBackgroundError() {
-    runTaskTest(new Callable<Task<?>>() {
-      public Task<?> call() throws Exception {
-        return Task.callInBackground(new Callable<Integer>() {
-          public Integer call() throws Exception {
-            throw new IllegalStateException();
-          }
-        }).continueWith(new Continuation<Integer, Void>() {
-          public Void then(Task<Integer> task) {
-            assertTrue(task.isFaulted());
-            assertTrue(task.getError() instanceof IllegalStateException);
-            return null;
-          }
-        });
-      }
-    });
-  }
-
-  @Test
-  public void testBackgroundCancellation() {
-    runTaskTest(new Callable<Task<?>>() {
-      public Task<?> call() throws Exception {
-        return Task.callInBackground(new Callable<Void>() {
-          public Void call() throws Exception {
-            throw new CancellationException();
-          }
-        }).continueWith(new Continuation<Void, Void>() {
-          public Void then(Task<Void> task) {
-            assertTrue(task.isCancelled());
-            return null;
-          }
+
+    @Test
+    public void testDelayWithToken() throws InterruptedException {
+        CancellationTokenSource cts = new CancellationTokenSource();
+        final Task<Void> delayed = Task.delay(200, cts.getToken());
+        assertFalse(delayed.isCancelled());
+        cts.cancel();
+        assertTrue(delayed.isCancelled());
+    }
+
+    @Test
+    public void testSynchronousContinuation() {
+        final Task<Integer> complete = Task.forResult(5);
+        final Task<Integer> error = Task.forError(new RuntimeException());
+        final Task<Integer> cancelled = Task.cancelled();
+
+        complete.continueWith(new Continuation<Integer, Void>() {
+            public Void then(Task<Integer> task) {
+                assertEquals(complete, task);
+                assertTrue(task.isCompleted());
+                assertEquals(5, task.getResult().intValue());
+                assertFalse(task.isFaulted());
+                assertFalse(task.isCancelled());
+                return null;
+            }
         });
-      }
-    });
-  }
-
-  @Test
-  public void testUnobservedError() throws InterruptedException {
-    try {
-      final Object sync = new Object();
-      Task.setUnobservedExceptionHandler(new Task.UnobservedExceptionHandler() {
-        @Override
-        public void unobservedException(Task<?> t, UnobservedTaskException e) {
-          synchronized (sync) {
-            sync.notify();
-          }
-        }
-      });
 
-      synchronized (sync) {
-        startFailedTask();
-        System.gc();
-        sync.wait();
-      }
+        error.continueWith(new Continuation<Integer, Void>() {
+            public Void then(Task<Integer> task) {
+                assertEquals(error, task);
+                assertTrue(task.isCompleted());
+                assertTrue(task.getError() instanceof RuntimeException);
+                assertTrue(task.isFaulted());
+                assertFalse(task.isCancelled());
+                return null;
+            }
+        });
 
-    } finally {
-      Task.setUnobservedExceptionHandler(null);
+        cancelled.continueWith(new Continuation<Integer, Void>() {
+            public Void then(Task<Integer> task) {
+                assertEquals(cancelled, task);
+                assertTrue(cancelled.isCompleted());
+                assertFalse(cancelled.isFaulted());
+                assertTrue(cancelled.isCancelled());
+                return null;
+            }
+        });
     }
-  }
-
-  // runs in a separate method to ensure it is out of scope.
-  private void startFailedTask() throws InterruptedException {
-    Task.call(new Callable<Object>() {
-      @Override
-      public Object call() throws Exception {
-        throw new RuntimeException();
-      }
-    }).waitForCompletion();
-  }
-
-  @Test
-  public void testWhenAllNoTasks() {
-    Task<Void> task = Task.whenAll(new ArrayList<Task<Void>>());
-
-    assertTrue(task.isCompleted());
-    assertFalse(task.isCancelled());
-    assertFalse(task.isFaulted());
-  }
-    
-  @Test
-  public void testWhenAnyResultFirstSuccess() {
-    runTaskTest(new Callable<Task<?>>() {
-      @Override
-      public Task<?> call() throws Exception {
-        final ArrayList<Task<Integer>> tasks = new ArrayList<>();
-        final Task<Integer> firstToCompleteSuccess = Task.callInBackground(new Callable<Integer>() {
-          @Override
-          public Integer call() throws Exception {
-            Thread.sleep(50);
-            return 10;
-          }
+
+    @Test
+    public void testSynchronousChaining() {
+        Task<Integer> first = Task.forResult(1);
+        Task<Integer> second = first.continueWith(new Continuation<Integer, Integer>() {
+            public Integer then(Task<Integer> task) {
+                return 2;
+            }
         });
-        tasks.addAll(launchTasksWithRandomCompletions(5));
-        tasks.add(firstToCompleteSuccess);
-        tasks.addAll(launchTasksWithRandomCompletions(5));
-        return Task.whenAnyResult(tasks).continueWith(new Continuation<Task<Integer>, Void>() {
-          @Override
-          public Void then(Task<Task<Integer>> task) throws Exception {
-            assertTrue(task.isCompleted());
-            assertFalse(task.isFaulted());
-            assertFalse(task.isCancelled());
-            assertEquals(firstToCompleteSuccess, task.getResult());
-            assertTrue(task.getResult().isCompleted());
-            assertFalse(task.getResult().isCancelled());
-            assertFalse(task.getResult().isFaulted());
-            assertEquals(10, (int) task.getResult().getResult());
-            return null;
-          }
+        Task<Integer> third = second.continueWithTask(new Continuation<Integer, Task<Integer>>() {
+            public Task<Integer> then(Task<Integer> task) {
+                return Task.forResult(3);
+            }
         });
-      }
-    });
-  }
-    
-  @Test
-  public void testWhenAnyFirstSuccess() {
-    runTaskTest(new Callable<Task<?>>() {
-      @Override
-      public Task<?> call() throws Exception {
-        final ArrayList<Task<?>> tasks = new ArrayList<>();
-        final Task<String> firstToCompleteSuccess = Task.callInBackground(new Callable<String>() {
-          @Override
-          public String call() throws Exception {
-            Thread.sleep(50);
-            return "SUCCESS";
-          }
+        assertTrue(first.isCompleted());
+        assertTrue(second.isCompleted());
+        assertTrue(third.isCompleted());
+        assertEquals(1, first.getResult().intValue());
+        assertEquals(2, second.getResult().intValue());
+        assertEquals(3, third.getResult().intValue());
+    }
+
+    @Test
+    public void testSynchronousCancellation() {
+        Task<Integer> first = Task.forResult(1);
+        Task<Integer> second = first.continueWith(new Continuation<Integer, Integer>() {
+            public Integer then(Task<Integer> task) {
+                throw new CancellationException();
+            }
         });
-        tasks.addAll(launchTasksWithRandomCompletions(5));
-        tasks.add(firstToCompleteSuccess);
-        tasks.addAll(launchTasksWithRandomCompletions(5));
-        return Task.whenAny(tasks).continueWith(new Continuation<Task<?>, Object>() {
-          @Override
-          public Object then(Task<Task<?>> task) throws Exception {
-            assertTrue(task.isCompleted());
-            assertFalse(task.isFaulted());
-            assertFalse(task.isCancelled());
-            assertEquals(firstToCompleteSuccess, task.getResult());
-            assertTrue(task.getResult().isCompleted());
-            assertFalse(task.getResult().isCancelled());
-            assertFalse(task.getResult().isFaulted());
-            assertEquals("SUCCESS", task.getResult().getResult());
-            return null;
-          }
+        assertTrue(first.isCompleted());
+        assertTrue(second.isCancelled());
+    }
+
+    @Test
+    public void testSynchronousContinuationTokenAlreadyCancelled() {
+        CancellationTokenSource cts = new CancellationTokenSource();
+        final Capture<Boolean> continuationRun = new Capture<>(false);
+        cts.cancel();
+        Task<Integer> first = Task.forResult(1);
+        Task<Integer> second = first.continueWith(new Continuation<Integer, Integer>() {
+            public Integer then(Task<Integer> task) {
+                continuationRun.set(true);
+                return 2;
+            }
+        }, cts.getToken());
+        assertTrue(first.isCompleted());
+        assertTrue(second.isCancelled());
+        assertFalse(continuationRun.get());
+    }
+
+    @Test
+    public void testSynchronousTaskCancellation() {
+        Task<Integer> first = Task.forResult(1);
+        Task<Integer> second = first.continueWithTask(new Continuation<Integer, Task<Integer>>() {
+            public Task<Integer> then(Task<Integer> task) {
+                throw new CancellationException();
+            }
         });
-      }
-    });
-  }
-
-  @Test
-  public void testWhenAnyResultFirstError() {
-    final Exception error = new RuntimeException("This task failed.");
-    runTaskTest(new Callable<Task<?>>() {
-      @Override
-      public Task<?> call() throws Exception {
-        final ArrayList<Task<Integer>> tasks = new ArrayList<>();
-        final Task<Integer> firstToCompleteError = Task.callInBackground(new Callable<Integer>() {
-          @Override
-          public Integer call() throws Exception {
-            Thread.sleep(50);
-            throw error;
-          }
+        assertTrue(first.isCompleted());
+        assertTrue(second.isCancelled());
+    }
+
+    @Test
+    public void testBackgroundCall() {
+        runTaskTest(new Callable<Task<?>>() {
+            public Task<?> call() throws Exception {
+                return Task.callInBackground(new Callable<Integer>() {
+                    public Integer call() throws Exception {
+                        Thread.sleep(100);
+                        return 5;
+                    }
+                }).continueWith(new Continuation<Integer, Void>() {
+                    public Void then(Task<Integer> task) {
+                        assertEquals(5, task.getResult().intValue());
+                        return null;
+                    }
+                });
+            }
         });
-        tasks.addAll(launchTasksWithRandomCompletions(5));
-        tasks.add(firstToCompleteError);
-        tasks.addAll(launchTasksWithRandomCompletions(5));
-        return Task.whenAnyResult(tasks).continueWith(new Continuation<Task<Integer>, Object>() {
-          @Override
-          public Object then(Task<Task<Integer>> task) throws Exception {
-            assertTrue(task.isCompleted());
-            assertFalse(task.isFaulted());
-            assertFalse(task.isCancelled());
-            assertEquals(firstToCompleteError, task.getResult());
-            assertTrue(task.getResult().isCompleted());
-            assertFalse(task.getResult().isCancelled());
-            assertTrue(task.getResult().isFaulted());
-            assertEquals(error, task.getResult().getError());
-            return null;
-          }
+    }
+
+    @Test
+    public void testBackgroundCallTokenCancellation() {
+        final CancellationTokenSource cts = new CancellationTokenSource();
+        final CancellationToken ct = cts.getToken();
+        final Capture<Boolean> waitingToBeCancelled = new Capture<>(false);
+        final Object cancelLock = new Object();
+
+        Task<Integer> task = Task.callInBackground(new Callable<Integer>() {
+            @Override
+            public Integer call() throws Exception {
+                synchronized (cancelLock) {
+                    waitingToBeCancelled.set(true);
+                    cancelLock.wait();
+                }
+                ct.throwIfCancellationRequested();
+                return 5;
+            }
         });
-      }
-    });
-  }
-
-  @Test
-  public void testWhenAnyFirstError() {
-    final Exception error = new RuntimeException("This task failed.");
-    runTaskTest(new Callable<Task<?>>() {
-      @Override
-      public Task<?> call() throws Exception {
-        final ArrayList<Task<?>> tasks = new ArrayList<>();
-        final Task<String> firstToCompleteError = Task.callInBackground(new Callable<String>() {
-          @Override
-          public String call() throws Exception {
-            Thread.sleep(50);
-            throw error;
-          }
+
+        while (true) {
+            synchronized (cancelLock) {
+                if (waitingToBeCancelled.get()) {
+                    cts.cancel();
+                    cancelLock.notify();
+                    break;
+                }
+            }
+            try {
+                Thread.sleep(5);
+            } catch (InterruptedException e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        try {
+            task.waitForCompletion();
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        }
+
+        assertTrue(task.isCancelled());
+    }
+
+    @Test
+    public void testBackgroundCallTokenAlreadyCancelled() {
+        final CancellationTokenSource cts = new CancellationTokenSource();
+
+        cts.cancel();
+        runTaskTest(new Callable<Task<?>>() {
+            public Task<?> call() throws Exception {
+                return Task.callInBackground(new Callable<Integer>() {
+                    public Integer call() throws Exception {
+                        Thread.sleep(100);
+                        return 5;
+                    }
+                }, cts.getToken()).continueWith(new Continuation<Integer, Void>() {
+                    public Void then(Task<Integer> task) {
+                        assertTrue(task.isCancelled());
+                        return null;
+                    }
+                });
+            }
         });
-        tasks.addAll(launchTasksWithRandomCompletions(5));
-        tasks.add(firstToCompleteError);
-        tasks.addAll(launchTasksWithRandomCompletions(5));
-        return Task.whenAny(tasks).continueWith(new Continuation<Task<?>, Object>() {
-          @Override
-          public Object then(Task<Task<?>> task) throws Exception {
-            assertTrue(task.isCompleted());
-            assertFalse(task.isFaulted());
-            assertFalse(task.isCancelled());
-            assertEquals(firstToCompleteError, task.getResult());
-            assertTrue(task.getResult().isCompleted());
-            assertFalse(task.getResult().isCancelled());
-            assertTrue(task.getResult().isFaulted());
-            assertEquals(error, task.getResult().getError());
-            return null;
-          }
+    }
+
+    @Test
+    public void testBackgroundCallWaiting() throws Exception {
+        Task<Integer> task = Task.callInBackground(new Callable<Integer>() {
+            public Integer call() throws Exception {
+                Thread.sleep(100);
+                return 5;
+            }
         });
-      }
-    });
-  }
-
-  @Test
-  public void testWhenAnyResultFirstCancelled() {
-    runTaskTest(new Callable<Task<?>>() {
-      @Override
-      public Task<?> call() throws Exception {
-        final ArrayList<Task<Integer>> tasks = new ArrayList<>();
-        final Task<Integer> firstToCompleteCancelled = Task.callInBackground(new Callable<Integer>() {
-          @Override
-          public Integer call() throws Exception {
-            Thread.sleep(50);
-            throw new CancellationException();
-          }
+        task.waitForCompletion();
+        assertTrue(task.isCompleted());
+        assertEquals(5, task.getResult().intValue());
+    }
+
+    @Test
+    public void testBackgroundCallWaitingWithTimeouts() throws Exception {
+        final Object sync = new Object();
+
+        Task<Integer> task = Task.callInBackground(new Callable<Integer>() {
+            public Integer call() throws Exception {
+                synchronized (sync) {
+                    sync.wait();
+                    Thread.sleep(100);
+                }
+                return 5;
+            }
+        });
+        // wait -> timeout
+        assertFalse(task.waitForCompletion(100, TimeUnit.MILLISECONDS));
+        synchronized (sync) {
+            sync.notify();
+        }
+        // wait -> completes
+        assertTrue(task.waitForCompletion(1000, TimeUnit.MILLISECONDS));
+        // wait -> already completed
+        assertTrue(task.waitForCompletion(100, TimeUnit.MILLISECONDS));
+        assertEquals(5, task.getResult().intValue());
+    }
+
+    @Test
+    public void testBackgroundCallWaitingOnError() throws Exception {
+        Task<Integer> task = Task.callInBackground(new Callable<Integer>() {
+            public Integer call() throws Exception {
+                Thread.sleep(100);
+                throw new RuntimeException();
+            }
         });
-         
-        tasks.addAll(launchTasksWithRandomCompletions(5));
-        tasks.add(firstToCompleteCancelled);
-        tasks.addAll(launchTasksWithRandomCompletions(5));
-        return Task.whenAnyResult(tasks).continueWith(new Continuation<Task<Integer>, Object>() {
-          @Override
-          public Object then(Task<Task<Integer>> task) throws Exception {
-            assertTrue(task.isCompleted());
-            assertFalse(task.isFaulted());
-            assertFalse(task.isCancelled());
-            assertEquals(firstToCompleteCancelled, task.getResult());
-            assertTrue(task.getResult().isCompleted());
-            assertTrue(task.getResult().isCancelled());
-            assertFalse(task.getResult().isFaulted());
-            return null;
-          }
+        task.waitForCompletion();
+        assertTrue(task.isCompleted());
+        assertTrue(task.isFaulted());
+    }
+
+    @Test
+    public void testBackgroundCallWaitOnCancellation() throws Exception {
+        Task<Integer> task = Task.callInBackground(new Callable<Integer>() {
+            public Integer call() throws Exception {
+                Thread.sleep(100);
+                return 5;
+            }
+        }).continueWithTask(new Continuation<Integer, Task<Integer>>() {
+
+            public Task<Integer> then(Task<Integer> task) {
+                return Task.cancelled();
+            }
         });
-      }
-    });
-  }
-    
-  @Test
-  public void testWhenAnyFirstCancelled() {
-    runTaskTest(new Callable<Task<?>>() {
-      @Override
-      public Task<?> call() throws Exception {
-        final ArrayList<Task<?>> tasks = new ArrayList<>();
-        final Task<String> firstToCompleteCancelled = Task.callInBackground(new Callable<String>() {
-          @Override
-          public String call() throws Exception {
-            Thread.sleep(50);
-            throw new CancellationException();
-          }
+        task.waitForCompletion();
+        assertTrue(task.isCompleted());
+        assertTrue(task.isCancelled());
+    }
+
+    @Test
+    public void testBackgroundError() {
+        runTaskTest(new Callable<Task<?>>() {
+            public Task<?> call() throws Exception {
+                return Task.callInBackground(new Callable<Integer>() {
+                    public Integer call() throws Exception {
+                        throw new IllegalStateException();
+                    }
+                }).continueWith(new Continuation<Integer, Void>() {
+                    public Void then(Task<Integer> task) {
+                        assertTrue(task.isFaulted());
+                        assertTrue(task.getError() instanceof IllegalStateException);
+                        return null;
+                    }
+                });
+            }
         });
-        tasks.addAll(launchTasksWithRandomCompletions(5));
-        tasks.add(firstToCompleteCancelled);
-        tasks.addAll(launchTasksWithRandomCompletions(5));
-        return Task.whenAny(tasks).continueWith(new Continuation<Task<?>, Object>() {
-          @Override
-          public Object then(Task<Task<?>> task) throws Exception {
-            assertTrue(task.isCompleted());
-            assertFalse(task.isFaulted());
-            assertFalse(task.isCancelled());
-            assertEquals(firstToCompleteCancelled, task.getResult());
-            assertTrue(task.getResult().isCompleted());
-            assertTrue(task.getResult().isCancelled());
-            assertFalse(task.getResult().isFaulted());
-            return null;
-          }
+    }
+
+    @Test
+    public void testBackgroundCancellation() {
+        runTaskTest(new Callable<Task<?>>() {
+            public Task<?> call() throws Exception {
+                return Task.callInBackground(new Callable<Void>() {
+                    public Void call() throws Exception {
+                        throw new CancellationException();
+                    }
+                }).continueWith(new Continuation<Void, Void>() {
+                    public Void then(Task<Void> task) {
+                        assertTrue(task.isCancelled());
+                        return null;
+                    }
+                });
+            }
         });
-      }
-    });
-  }
-
-  /**
-   * Launches a given number of tasks (of Integer) that will complete either in a completed, 
-   * cancelled or faulted state (random distribution).
-   * Each task will reach completion after a somehow random delay (between 500 and 600 ms).
-   * Each task reaching a success completion state will have its result set to a random Integer 
-   * (between 0 to 1000).
-   * @param numberOfTasksToLaunch The number of tasks to launch
-   * @return A collection containing all the tasks that have been launched
-   */
-  private Collection<Task<Integer>> launchTasksWithRandomCompletions(int numberOfTasksToLaunch ) {
-    final ArrayList<Task<Integer>> tasks = new ArrayList<>();
-    for (int i=0; i < numberOfTasksToLaunch; i++) {
-      Task<Integer> task = Task.callInBackground(new Callable<Integer>() {
-        @Override
-        public Integer call() throws Exception {
-          Thread.sleep((long) (500 + (Math.random() * 100)));
-          double rand = Math.random();
-          if (rand >= 0.7) {
-            throw new RuntimeException("This task failed.");
-          } else if (rand >= 0.4) {
-          throw new CancellationException();
-          }
-          return (int)(Math.random() * 1000);
+    }
+
+    @Test
+    public void testUnobservedError() throws InterruptedException {
+        try {
+            final Object sync = new Object();
+            Task.setUnobservedExceptionHandler(new Task.UnobservedExceptionHandler() {
+                @Override
+                public void unobservedException(Task<?> t, UnobservedTaskException e) {
+                    synchronized (sync) {
+                        sync.notify();
+                    }
+                }
+            });
+
+            synchronized (sync) {
+                startFailedTask();
+                System.gc();
+                sync.wait();
+            }
+
+        } finally {
+            Task.setUnobservedExceptionHandler(null);
         }
-      });
-      tasks.add(task);
     }
-    return tasks;
-  }
-
-  @Test
-  public void testWhenAllSuccess() {
-    runTaskTest(new Callable<Task<?>>() {
-      @Override
-      public Task<?> call() throws Exception {
-        final ArrayList<Task<Void>> tasks = new ArrayList<>();
-        for (int i = 0; i < 20; i++) {
-          Task<Void> task = Task.callInBackground(new Callable<Void>() {
+
+    // runs in a separate method to ensure it is out of scope.
+    private void startFailedTask() throws InterruptedException {
+        Task.call(new Callable<Object>() {
             @Override
-            public Void call() throws Exception {
-              Thread.sleep((long) (Math.random() * 100));
-              return null;
+            public Object call() throws Exception {
+                throw new RuntimeException();
             }
-          });
-          tasks.add(task);
-        }
-        return Task.whenAll(tasks).continueWith(new Continuation<Void, Void>() {
-          @Override
-          public Void then(Task<Void> task) {
-            assertTrue(task.isCompleted());
-            assertFalse(task.isFaulted());
-            assertFalse(task.isCancelled());
-
-            for (Task<Void> t : tasks) {
-              assertTrue(t.isCompleted());
+        }).waitForCompletion();
+    }
+
+    @Test
+    public void testWhenAllNoTasks() {
+        Task<Void> task = Task.whenAll(new ArrayList<Task<Void>>());
+
+        assertTrue(task.isCompleted());
+        assertFalse(task.isCancelled());
+        assertFalse(task.isFaulted());
+    }
+
+    @Test
+    public void testWhenAnyResultFirstSuccess() {
+        runTaskTest(new Callable<Task<?>>() {
+            @Override
+            public Task<?> call() throws Exception {
+                final ArrayList<Task<Integer>> tasks = new ArrayList<>();
+                final Task<Integer> firstToCompleteSuccess = Task.callInBackground(new Callable<Integer>() {
+                    @Override
+                    public Integer call() throws Exception {
+                        Thread.sleep(50);
+                        return 10;
+                    }
+                });
+                tasks.addAll(launchTasksWithRandomCompletions(5));
+                tasks.add(firstToCompleteSuccess);
+                tasks.addAll(launchTasksWithRandomCompletions(5));
+                return Task.whenAnyResult(tasks).continueWith(new Continuation<Task<Integer>,
+                        Void>() {
+                    @Override
+                    public Void then(Task<Task<Integer>> task) throws Exception {
+                        assertTrue(task.isCompleted());
+                        assertFalse(task.isFaulted());
+                        assertFalse(task.isCancelled());
+                        assertEquals(firstToCompleteSuccess, task.getResult());
+                        assertTrue(task.getResult().isCompleted());
+                        assertFalse(task.getResult().isCancelled());
+                        assertFalse(task.getResult().isFaulted());
+                        assertEquals(10, (int) task.getResult().getResult());
+                        return null;
+                    }
+                });
             }
-            return null;
-          }
         });
-      }
-    });
-  }
-
-  @Test
-  public void testWhenAllOneError() {
-    final Exception error = new RuntimeException("This task failed.");
-
-    runTaskTest(new Callable<Task<?>>() {
-      @Override
-      public Task<?> call() throws Exception {
-        final ArrayList<Task<Void>> tasks = new ArrayList<>();
-        for (int i = 0; i < 20; i++) {
-          final int number = i;
-          Task<Void> task = Task.callInBackground(new Callable<Void>() {
+    }
+
+    @Test
+    public void testWhenAnyFirstSuccess() {
+        runTaskTest(new Callable<Task<?>>() {
             @Override
-            public Void call() throws Exception {
-              Thread.sleep((long) (Math.random() * 100));
-              if (number == 10) {
-                throw error;
-              }
-              return null;
+            public Task<?> call() throws Exception {
+                final ArrayList<Task<?>> tasks = new ArrayList<>();
+                final Task<String> firstToCompleteSuccess = Task.callInBackground(new Callable<String>() {
+                    @Override
+                    public String call() throws Exception {
+                        Thread.sleep(50);
+                        return "SUCCESS";
+                    }
+                });
+                tasks.addAll(launchTasksWithRandomCompletions(5));
+                tasks.add(firstToCompleteSuccess);
+                tasks.addAll(launchTasksWithRandomCompletions(5));
+                return Task.whenAny(tasks).continueWith(new Continuation<Task<?>, Object>() {
+                    @Override
+                    public Object then(Task<Task<?>> task) throws Exception {
+                        assertTrue(task.isCompleted());
+                        assertFalse(task.isFaulted());
+                        assertFalse(task.isCancelled());
+                        assertEquals(firstToCompleteSuccess, task.getResult());
+                        assertTrue(task.getResult().isCompleted());
+                        assertFalse(task.getResult().isCancelled());
+                        assertFalse(task.getResult().isFaulted());
+                        assertEquals("SUCCESS", task.getResult().getResult());
+                        return null;
+                    }
+                });
             }
-          });
-          tasks.add(task);
-        }
-        return Task.whenAll(tasks).continueWith(new Continuation<Void, Void>() {
-          @Override
-          public Void then(Task<Void> task) {
-            assertTrue(task.isCompleted());
-            assertTrue(task.isFaulted());
-            assertFalse(task.isCancelled());
-
-            assertFalse(task.getError() instanceof AggregateException);
-            assertEquals(error, task.getError());
-
-            for (Task<Void> t : tasks) {
-              assertTrue(t.isCompleted());
+        });
+    }
+
+    @Test
+    public void testWhenAnyResultFirstError() {
+        final Exception error = new RuntimeException("This task failed.");
+        runTaskTest(new Callable<Task<?>>() {
+            @Override
+            public Task<?> call() throws Exception {
+                final ArrayList<Task<Integer>> tasks = new ArrayList<>();
+                final Task<Integer> firstToCompleteError = Task.callInBackground(new Callable<Integer>() {
+                    @Override
+                    public Integer call() throws Exception {
+                        Thread.sleep(50);
+                        throw error;
+                    }
+                });
+                tasks.addAll(launchTasksWithRandomCompletions(5));
+                tasks.add(firstToCompleteError);
+                tasks.addAll(launchTasksWithRandomCompletions(5));
+                return Task.whenAnyResult(tasks).continueWith(new Continuation<Task<Integer>,
+                        Object>() {
+                    @Override
+                    public Object then(Task<Task<Integer>> task) throws Exception {
+                        assertTrue(task.isCompleted());
+                        assertFalse(task.isFaulted());
+                        assertFalse(task.isCancelled());
+                        assertEquals(firstToCompleteError, task.getResult());
+                        assertTrue(task.getResult().isCompleted());
+                        assertFalse(task.getResult().isCancelled());
+                        assertTrue(task.getResult().isFaulted());
+                        assertEquals(error, task.getResult().getError());
+                        return null;
+                    }
+                });
             }
-            return null;
-          }
         });
-      }
-    });
-  }
-
-  @Test
-  public void testWhenAllTwoErrors() {
-    final Exception error0 = new RuntimeException("This task failed (0).");
-    final Exception error1 = new RuntimeException("This task failed (1).");
-
-    runTaskTest(new Callable<Task<?>>() {
-      @Override
-      public Task<?> call() throws Exception {
-        final ArrayList<Task<Void>> tasks = new ArrayList<>();
-        for (int i = 0; i < 20; i++) {
-          final int number = i;
-          Task<Void> task = Task.callInBackground(new Callable<Void>() {
+    }
+
+    @Test
+    public void testWhenAnyFirstError() {
+        final Exception error = new RuntimeException("This task failed.");
+        runTaskTest(new Callable<Task<?>>() {
             @Override
-            public Void call() throws Exception {
-              Thread.sleep((long) (number * 10));
-              if (number == 10) {
-                throw error0;
-              } else if (number == 11) {
-                throw error1;
-              }
-              return null;
+            public Task<?> call() throws Exception {
+                final ArrayList<Task<?>> tasks = new ArrayList<>();
+                final Task<String> firstToCompleteError = Task.callInBackground(new Callable<String>() {
+                    @Override
+                    public String call() throws Exception {
+                        Thread.sleep(50);
+                        throw error;
+                    }
+                });
+                tasks.addAll(launchTasksWithRandomCompletions(5));
+                tasks.add(firstToCompleteError);
+                tasks.addAll(launchTasksWithRandomCompletions(5));
+                return Task.whenAny(tasks).continueWith(new Continuation<Task<?>, Object>() {
+                    @Override
+                    public Object then(Task<Task<?>> task) throws Exception {
+                        assertTrue(task.isCompleted());
+                        assertFalse(task.isFaulted());
+                        assertFalse(task.isCancelled());
+                        assertEquals(firstToCompleteError, task.getResult());
+                        assertTrue(task.getResult().isCompleted());
+                        assertFalse(task.getResult().isCancelled());
+                        assertTrue(task.getResult().isFaulted());
+                        assertEquals(error, task.getResult().getError());
+                        return null;
+                    }
+                });
             }
-          });
-          tasks.add(task);
-        }
-        return Task.whenAll(tasks).continueWith(new Continuation<Void, Void>() {
-          @Override
-          public Void then(Task<Void> task) {
-            assertTrue(task.isCompleted());
-            assertTrue(task.isFaulted());
-            assertFalse(task.isCancelled());
-
-            assertTrue(task.getError() instanceof AggregateException);
-            assertEquals(2, ((AggregateException) task.getError()).getInnerThrowables().size());
-            assertEquals(error0, ((AggregateException) task.getError()).getInnerThrowables().get(0));
-            assertEquals(error1, ((AggregateException) task.getError()).getInnerThrowables().get(1));
-            assertEquals(error0, task.getError().getCause());
-
-            for (Task<Void> t : tasks) {
-              assertTrue(t.isCompleted());
+        });
+    }
+
+    @Test
+    public void testWhenAnyResultFirstCancelled() {
+        runTaskTest(new Callable<Task<?>>() {
+            @Override
+            public Task<?> call() throws Exception {
+                final ArrayList<Task<Integer>> tasks = new ArrayList<>();
+                final Task<Integer> firstToCompleteCancelled = Task.callInBackground(new Callable<Integer>() {
+                    @Override
+                    public Integer call() throws Exception {
+                        Thread.sleep(50);
+                        throw new CancellationException();
+                    }
+                });
+
+                tasks.addAll(launchTasksWithRandomCompletions(5));
+                tasks.add(firstToCompleteCancelled);
+                tasks.addAll(launchTasksWithRandomCompletions(5));
+                return Task.whenAnyResult(tasks).continueWith(new Continuation<Task<Integer>,
+                        Object>() {
+                    @Override
+                    public Object then(Task<Task<Integer>> task) throws Exception {
+                        assertTrue(task.isCompleted());
+                        assertFalse(task.isFaulted());
+                        assertFalse(task.isCancelled());
+                        assertEquals(firstToCompleteCancelled, task.getResult());
+                        assertTrue(task.getResult().isCompleted());
+                        assertTrue(task.getResult().isCancelled());
+                        assertFalse(task.getResult().isFaulted());
+                        return null;
+                    }
+                });
             }
-            return null;
-          }
         });
-      }
-    });
-  }
-
-  @Test
-  public void testWhenAllCancel() {
-    runTaskTest(new Callable<Task<?>>() {
-      @Override
-      public Task<?> call() throws Exception {
-        final ArrayList<Task<Void>> tasks = new ArrayList<>();
-        for (int i = 0; i < 20; i++) {
-          final TaskCompletionSource<Void> tcs = new TaskCompletionSource<>();
-
-          final int number = i;
-          Task.callInBackground(new Callable<Void>() {
+    }
+
+    @Test
+    public void testWhenAnyFirstCancelled() {
+        runTaskTest(new Callable<Task<?>>() {
             @Override
-            public Void call() throws Exception {
-              Thread.sleep((long) (Math.random() * 100));
-              if (number == 10) {
-                tcs.setCancelled();
-              } else {
-                tcs.setResult(null);
-              }
-              return null;
+            public Task<?> call() throws Exception {
+                final ArrayList<Task<?>> tasks = new ArrayList<>();
+                final Task<String> firstToCompleteCancelled = Task.callInBackground(new Callable<String>() {
+                    @Override
+                    public String call() throws Exception {
+                        Thread.sleep(50);
+                        throw new CancellationException();
+                    }
+                });
+                tasks.addAll(launchTasksWithRandomCompletions(5));
+                tasks.add(firstToCompleteCancelled);
+                tasks.addAll(launchTasksWithRandomCompletions(5));
+                return Task.whenAny(tasks).continueWith(new Continuation<Task<?>, Object>() {
+                    @Override
+                    public Object then(Task<Task<?>> task) throws Exception {
+                        assertTrue(task.isCompleted());
+                        assertFalse(task.isFaulted());
+                        assertFalse(task.isCancelled());
+                        assertEquals(firstToCompleteCancelled, task.getResult());
+                        assertTrue(task.getResult().isCompleted());
+                        assertTrue(task.getResult().isCancelled());
+                        assertFalse(task.getResult().isFaulted());
+                        return null;
+                    }
+                });
             }
-          });
+        });
+    }
 
-          tasks.add(tcs.getTask());
+    /**
+     * Launches a given number of tasks (of Integer) that will complete either in a completed,
+     * cancelled or faulted state (random distribution).
+     * Each task will reach completion after a somehow random delay (between 500 and 600 ms).
+     * Each task reaching a success completion state will have its result set to a random Integer
+     * (between 0 to 1000).
+     *
+     * @param numberOfTasksToLaunch The number of tasks to launch
+     * @return A collection containing all the tasks that have been launched
+     */
+    private Collection<Task<Integer>> launchTasksWithRandomCompletions(int numberOfTasksToLaunch) {
+        final ArrayList<Task<Integer>> tasks = new ArrayList<>();
+        for (int i = 0; i < numberOfTasksToLaunch; i++) {
+            Task<Integer> task = Task.callInBackground(new Callable<Integer>() {
+                @Override
+                public Integer call() throws Exception {
+                    Thread.sleep((long) (500 + (Math.random() * 100)));
+                    double rand = Math.random();
+                    if (rand >= 0.7) {
+                        throw new RuntimeException("This task failed.");
+                    } else if (rand >= 0.4) {
+                        throw new CancellationException();
+                    }
+                    return (int) (Math.random() * 1000);
+                }
+            });
+            tasks.add(task);
         }
-        return Task.whenAll(tasks).continueWith(new Continuation<Void, Void>() {
-          @Override
-          public Void then(Task<Void> task) {
-            assertTrue(task.isCompleted());
-            assertFalse(task.isFaulted());
-            assertTrue(task.isCancelled());
-
-            for (Task<Void> t : tasks) {
-              assertTrue(t.isCompleted());
+        return tasks;
+    }
+
+    @Test
+    public void testWhenAllSuccess() {
+        runTaskTest(new Callable<Task<?>>() {
+            @Override
+            public Task<?> call() throws Exception {
+                final ArrayList<Task<Void>> tasks = new ArrayList<>();
+                for (int i = 0; i < 20; i++) {
+                    Task<Void> task = Task.callInBackground(new Callable<Void>() {
+                        @Override
+                        public Void call() throws Exception {
+                            Thread.sleep((long) (Math.random() * 100));
+                            return null;
+                        }
+                    });
+                    tasks.add(task);
+                }
+                return Task.whenAll(tasks).continueWith(new Continuation<Void, Void>() {
+                    @Override
+                    public Void then(Task<Void> task) {
+                        assertTrue(task.isCompleted());
+                        assertFalse(task.isFaulted());
+                        assertFalse(task.isCancelled());
+
+                        for (Task<Void> t : tasks) {
+                            assertTrue(t.isCompleted());
+                        }
+                        return null;
+                    }
+                });
             }
-            return null;
-          }
         });
-      }
-    });
-  }
-
-  @Test
-  public void testWhenAllResultNoTasks() {
-    Task<List<Void>> task = Task.whenAllResult(new ArrayList<Task<Void>>());
-
-    assertTrue(task.isCompleted());
-    assertFalse(task.isCancelled());
-    assertFalse(task.isFaulted());
-    assertTrue(task.getResult().isEmpty());
-  }
-
-  @Test
-  public void testWhenAllResultSuccess() {
-    runTaskTest(new Callable<Task<?>>() {
-      @Override
-      public Task<?> call() throws Exception {
-        final List<Task<Integer>> tasks = new ArrayList<>();
-        for (int i = 0; i < 20; i++) {
-          final int number = (i + 1);
-          Task<Integer> task = Task.callInBackground(new Callable<Integer>() {
+    }
+
+    @Test
+    public void testWhenAllOneError() {
+        final Exception error = new RuntimeException("This task failed.");
+
+        runTaskTest(new Callable<Task<?>>() {
             @Override
-            public Integer call() throws Exception {
-              Thread.sleep((long) (Math.random() * 100));
-              return number;
+            public Task<?> call() throws Exception {
+                final ArrayList<Task<Void>> tasks = new ArrayList<>();
+                for (int i = 0; i < 20; i++) {
+                    final int number = i;
+                    Task<Void> task = Task.callInBackground(new Callable<Void>() {
+                        @Override
+                        public Void call() throws Exception {
+                            Thread.sleep((long) (Math.random() * 100));
+                            if (number == 10) {
+                                throw error;
+                            }
+                            return null;
+                        }
+                    });
+                    tasks.add(task);
+                }
+                return Task.whenAll(tasks).continueWith(new Continuation<Void, Void>() {
+                    @Override
+                    public Void then(Task<Void> task) {
+                        assertTrue(task.isCompleted());
+                        assertTrue(task.isFaulted());
+                        assertFalse(task.isCancelled());
+
+                        assertFalse(task.getError() instanceof AggregateException);
+                        assertEquals(error, task.getError());
+
+                        for (Task<Void> t : tasks) {
+                            assertTrue(t.isCompleted());
+                        }
+                        return null;
+                    }
+                });
             }
-          });
-          tasks.add(task);
-        }
-        return Task.whenAllResult(tasks).continueWith(new Continuation<List<Integer>, Void>() {
-          @Override
-          public Void then(Task<List<Integer>> task) {
-            assertTrue(task.isCompleted());
-            assertFalse(task.isFaulted());
-            assertFalse(task.isCancelled());
-            assertEquals(tasks.size(), task.getResult().size());
-
-            for (int i = 0; i < tasks.size(); i++) {
-              Task<Integer> t = tasks.get(i);
-              assertTrue(t.isCompleted());
-              assertEquals(t.getResult(), task.getResult().get(i));
+        });
+    }
+
+    @Test
+    public void testWhenAllTwoErrors() {
+        final Exception error0 = new RuntimeException("This task failed (0).");
+        final Exception error1 = new RuntimeException("This task failed (1).");
+
+        runTaskTest(new Callable<Task<?>>() {
+            @Override
+            public Task<?> call() throws Exception {
+                final ArrayList<Task<Void>> tasks = new ArrayList<>();
+                for (int i = 0; i < 20; i++) {
+                    final int number = i;
+                    Task<Void> task = Task.callInBackground(new Callable<Void>() {
+                        @Override
+                        public Void call() throws Exception {
+                            Thread.sleep((long) (number * 10));
+                            if (number == 10) {
+                                throw error0;
+                            } else if (number == 11) {
+                                throw error1;
+                            }
+                            return null;
+                        }
+                    });
+                    tasks.add(task);
+                }
+                return Task.whenAll(tasks).continueWith(new Continuation<Void, Void>() {
+                    @Override
+                    public Void then(Task<Void> task) {
+                        assertTrue(task.isCompleted());
+                        assertTrue(task.isFaulted());
+                        assertFalse(task.isCancelled());
+
+                        assertTrue(task.getError() instanceof AggregateException);
+                        assertEquals(2, ((AggregateException) task.getError()).getInnerThrowables
+                                ().size());
+                        assertEquals(error0, ((AggregateException) task.getError())
+                                .getInnerThrowables().get(0));
+                        assertEquals(error1, ((AggregateException) task.getError())
+                                .getInnerThrowables().get(1));
+                        assertEquals(error0, task.getError().getCause());
+
+                        for (Task<Void> t : tasks) {
+                            assertTrue(t.isCompleted());
+                        }
+                        return null;
+                    }
+                });
             }
+        });
+    }
 
-            return null;
-          }
+    @Test
+    public void testWhenAllCancel() {
+        runTaskTest(new Callable<Task<?>>() {
+            @Override
+            public Task<?> call() throws Exception {
+                final ArrayList<Task<Void>> tasks = new ArrayList<>();
+                for (int i = 0; i < 20; i++) {
+                    final TaskCompletionSource<Void> tcs = new TaskCompletionSource<>();
+
+                    final int number = i;
+                    Task.callInBackground(new Callable<Void>() {
+                        @Override
+                        public Void call() throws Exception {
+                            Thread.sleep((long) (Math.random() * 100));
+                            if (number == 10) {
+                                tcs.setCancelled();
+                            } else {
+                                tcs.setResult(null);
+                            }
+                            return null;
+                        }
+                    });
+
+                    tasks.add(tcs.getTask());
+                }
+                return Task.whenAll(tasks).continueWith(new Continuation<Void, Void>() {
+                    @Override
+                    public Void then(Task<Void> task) {
+                        assertTrue(task.isCompleted());
+                        assertFalse(task.isFaulted());
+                        assertTrue(task.isCancelled());
+
+                        for (Task<Void> t : tasks) {
+                            assertTrue(t.isCompleted());
+                        }
+                        return null;
+                    }
+                });
+            }
         });
-      }
-    });
-  }
-
-  @Test
-  public void testAsyncChaining() {
-    runTaskTest(new Callable<Task<?>>() {
-      public Task<?> call() throws Exception {
-        final ArrayList<Integer> sequence = new ArrayList<>();
-        Task<Void> result = Task.forResult(null);
-        for (int i = 0; i < 20; i++) {
-          final int taskNumber = i;
-          result = result.continueWithTask(new Continuation<Void, Task<Void>>() {
-            public Task<Void> then(Task<Void> task) {
-              return Task.callInBackground(new Callable<Void>() {
-                public Void call() throws Exception {
-                  sequence.add(taskNumber);
-                  return null;
+    }
+
+    @Test
+    public void testWhenAllResultNoTasks() {
+        Task<List<Void>> task = Task.whenAllResult(new ArrayList<Task<Void>>());
+
+        assertTrue(task.isCompleted());
+        assertFalse(task.isCancelled());
+        assertFalse(task.isFaulted());
+        assertTrue(task.getResult().isEmpty());
+    }
+
+    @Test
+    public void testWhenAllResultSuccess() {
+        runTaskTest(new Callable<Task<?>>() {
+            @Override
+            public Task<?> call() throws Exception {
+                final List<Task<Integer>> tasks = new ArrayList<>();
+                for (int i = 0; i < 20; i++) {
+                    final int number = (i + 1);
+                    Task<Integer> task = Task.callInBackground(new Callable<Integer>() {
+                        @Override
+                        public Integer call() throws Exception {
+                            Thread.sleep((long) (Math.random() * 100));
+                            return number;
+                        }
+                    });
+                    tasks.add(task);
                 }
-              });
+                return Task.whenAllResult(tasks).continueWith(new Continuation<List<Integer>,
+                        Void>() {
+                    @Override
+                    public Void then(Task<List<Integer>> task) {
+                        assertTrue(task.isCompleted());
+                        assertFalse(task.isFaulted());
+                        assertFalse(task.isCancelled());
+                        assertEquals(tasks.size(), task.getResult().size());
+
+                        for (int i = 0; i < tasks.size(); i++) {
+                            Task<Integer> t = tasks.get(i);
+                            assertTrue(t.isCompleted());
+                            assertEquals(t.getResult(), task.getResult().get(i));
+                        }
+
+                        return null;
+                    }
+                });
             }
-          });
-        }
-        result = result.continueWith(new Continuation<Void, Void>() {
-          public Void then(Task<Void> task) {
-            assertEquals(20, sequence.size());
-            for (int i = 0; i < 20; i++) {
-              assertEquals(i, sequence.get(i).intValue());
+        });
+    }
+
+    @Test
+    public void testAsyncChaining() {
+        runTaskTest(new Callable<Task<?>>() {
+            public Task<?> call() throws Exception {
+                final ArrayList<Integer> sequence = new ArrayList<>();
+                Task<Void> result = Task.forResult(null);
+                for (int i = 0; i < 20; i++) {
+                    final int taskNumber = i;
+                    result = result.continueWithTask(new Continuation<Void, Task<Void>>() {
+                        public Task<Void> then(Task<Void> task) {
+                            return Task.callInBackground(new Callable<Void>() {
+                                public Void call() throws Exception {
+                                    sequence.add(taskNumber);
+                                    return null;
+                                }
+                            });
+                        }
+                    });
+                }
+                result = result.continueWith(new Continuation<Void, Void>() {
+                    public Void then(Task<Void> task) {
+                        assertEquals(20, sequence.size());
+                        for (int i = 0; i < 20; i++) {
+                            assertEquals(i, sequence.get(i).intValue());
+                        }
+                        return null;
+                    }
+                });
+                return result;
             }
-            return null;
-          }
         });
-        return result;
-      }
-    });
-  }
-
-  @Test
-  public void testOnSuccess() {
-    Continuation<Integer, Integer> continuation = new Continuation<Integer, Integer>() {
-      public Integer then(Task<Integer> task) {
-        return task.getResult() + 1;
-      }
-    };
-    Task<Integer> complete = Task.forResult(5).onSuccess(continuation);
-    Task<Integer> error = Task.<Integer> forError(new IllegalStateException()).onSuccess(
-        continuation);
-    Task<Integer> cancelled = Task.<Integer> cancelled().onSuccess(continuation);
-
-    assertTrue(complete.isCompleted());
-    assertEquals(6, complete.getResult().intValue());
-    assertFalse(complete.isFaulted());
-    assertFalse(complete.isCancelled());
-
-    assertTrue(error.isCompleted());
-    assertTrue(error.getError() instanceof RuntimeException);
-    assertTrue(error.isFaulted());
-    assertFalse(error.isCancelled());
-
-    assertTrue(cancelled.isCompleted());
-    assertFalse(cancelled.isFaulted());
-    assertTrue(cancelled.isCancelled());
-  }
-
-  @Test
-  public void testOnSuccessTask() {
-    Continuation<Integer, Task<Integer>> continuation = new Continuation<Integer, Task<Integer>>() {
-      public Task<Integer> then(Task<Integer> task) {
-        return Task.forResult(task.getResult() + 1);
-      }
-    };
-    Task<Integer> complete = Task.forResult(5).onSuccessTask(continuation);
-    Task<Integer> error = Task.<Integer> forError(new IllegalStateException()).onSuccessTask(
-        continuation);
-    Task<Integer> cancelled = Task.<Integer> cancelled().onSuccessTask(continuation);
-
-    assertTrue(complete.isCompleted());
-    assertEquals(6, complete.getResult().intValue());
-    assertFalse(complete.isFaulted());
-    assertFalse(complete.isCancelled());
-
-    assertTrue(error.isCompleted());
-    assertTrue(error.getError() instanceof RuntimeException);
-    assertTrue(error.isFaulted());
-    assertFalse(error.isCancelled());
-
-    assertTrue(cancelled.isCompleted());
-    assertFalse(cancelled.isFaulted());
-    assertTrue(cancelled.isCancelled());
-  }
-
-  @Test
-  public void testContinueWhile() {
-    final AtomicInteger count = new AtomicInteger(0);
-    runTaskTest(new Callable<Task<?>>() {
-      public Task<?> call() throws Exception {
-        return Task.forResult(null).continueWhile(new Callable<Boolean>() {
-          public Boolean call() throws Exception {
-            return count.get() < 10;
-          }
-        }, new Continuation<Void, Task<Void>>() {
-          public Task<Void> then(Task<Void> task) throws Exception {
-            count.incrementAndGet();
-            return null;
-          }
-        }).continueWith(new Continuation<Void, Void>() {
-          public Void then(Task<Void> task) throws Exception {
-            assertEquals(10, count.get());
-            return null;
-          }
+    }
+
+    @Test
+    public void testOnSuccess() {
+        Continuation<Integer, Integer> continuation = new Continuation<Integer, Integer>() {
+            public Integer then(Task<Integer> task) {
+                return task.getResult() + 1;
+            }
+        };
+        Task<Integer> complete = Task.forResult(5).onSuccess(continuation);
+        Task<Integer> error = Task.<Integer>forError(new IllegalStateException()).onSuccess
+                (continuation);
+        Task<Integer> cancelled = Task.<Integer>cancelled().onSuccess(continuation);
+
+        assertTrue(complete.isCompleted());
+        assertEquals(6, complete.getResult().intValue());
+        assertFalse(complete.isFaulted());
+        assertFalse(complete.isCancelled());
+
+        assertTrue(error.isCompleted());
+        assertTrue(error.getError() instanceof RuntimeException);
+        assertTrue(error.isFaulted());
+        assertFalse(error.isCancelled());
+
+        assertTrue(cancelled.isCompleted());
+        assertFalse(cancelled.isFaulted());
+        assertTrue(cancelled.isCancelled());
+    }
+
+    @Test
+    public void testOnSuccessTask() {
+        Continuation<Integer, Task<Integer>> continuation = new Continuation<Integer,
+                Task<Integer>>() {
+            public Task<Integer> then(Task<Integer> task) {
+                return Task.forResult(task.getResult() + 1);
+            }
+        };
+        Task<Integer> complete = Task.forResult(5).onSuccessTask(continuation);
+        Task<Integer> error = Task.<Integer>forError(new IllegalStateException()).onSuccessTask
+                (continuation);
+        Task<Integer> cancelled = Task.<Integer>cancelled().onSuccessTask(continuation);
+
+        assertTrue(complete.isCompleted());
+        assertEquals(6, complete.getResult().intValue());
+        assertFalse(complete.isFaulted());
+        assertFalse(complete.isCancelled());
+
+        assertTrue(error.isCompleted());
+        assertTrue(error.getError() instanceof RuntimeException);
+        assertTrue(error.isFaulted());
+        assertFalse(error.isCancelled());
+
+        assertTrue(cancelled.isCompleted());
+        assertFalse(cancelled.isFaulted());
+        assertTrue(cancelled.isCancelled());
+    }
+
+    @Test
+    public void testContinueWhile() {
+        final AtomicInteger count = new AtomicInteger(0);
+        runTaskTest(new Callable<Task<?>>() {
+            public Task<?> call() throws Exception {
+                return Task.forResult(null).continueWhile(new Callable<Boolean>() {
+                    public Boolean call() throws Exception {
+                        return count.get() < 10;
+                    }
+                }, new Continuation<Void, Task<Void>>() {
+                    public Task<Void> then(Task<Void> task) throws Exception {
+                        count.incrementAndGet();
+                        return null;
+                    }
+                }).continueWith(new Continuation<Void, Void>() {
+                    public Void then(Task<Void> task) throws Exception {
+                        assertEquals(10, count.get());
+                        return null;
+                    }
+                });
+            }
         });
-      }
-    });
-  }
-
-  @Test
-  public void testContinueWhileAsync() {
-    final AtomicInteger count = new AtomicInteger(0);
-    runTaskTest(new Callable<Task<?>>() {
-      public Task<?> call() throws Exception {
-        return Task.forResult(null).continueWhile(new Callable<Boolean>() {
-          public Boolean call() throws Exception {
-            return count.get() < 10;
-          }
-        }, new Continuation<Void, Task<Void>>() {
-          public Task<Void> then(Task<Void> task) throws Exception {
-            count.incrementAndGet();
-            return null;
-          }
-        }, Executors.newCachedThreadPool()).continueWith(new Continuation<Void, Void>() {
-          public Void then(Task<Void> task) throws Exception {
-            assertEquals(10, count.get());
-            return null;
-          }
+    }
+
+    @Test
+    public void testContinueWhileAsync() {
+        final AtomicInteger count = new AtomicInteger(0);
+        runTaskTest(new Callable<Task<?>>() {
+            public Task<?> call() throws Exception {
+                return Task.forResult(null).continueWhile(new Callable<Boolean>() {
+                    public Boolean call() throws Exception {
+                        return count.get() < 10;
+                    }
+                }, new Continuation<Void, Task<Void>>() {
+                    public Task<Void> then(Task<Void> task) throws Exception {
+                        count.incrementAndGet();
+                        return null;
+                    }
+                }, Executors.newCachedThreadPool()).continueWith(new Continuation<Void, Void>() {
+                    public Void then(Task<Void> task) throws Exception {
+                        assertEquals(10, count.get());
+                        return null;
+                    }
+                });
+            }
         });
-      }
-    });
-  }
-
-  @Test
-  public void testContinueWhileAsyncCancellation() {
-    final AtomicInteger count = new AtomicInteger(0);
-    final CancellationTokenSource cts = new CancellationTokenSource();
-    runTaskTest(new Callable<Task<?>>() {
-      public Task<?> call() throws Exception {
-        return Task.forResult(null).continueWhile(new Callable<Boolean>() {
-                                                    public Boolean call() throws Exception {
-                                                      return count.get() < 10;
-                                                    }
-                                                  }, new Continuation<Void, Task<Void>>() {
-                                                    public Task<Void> then(Task<Void> task)
-                                                        throws Exception {
-                                                      if (count.incrementAndGet() == 5) {
-                                                        cts.cancel();
-                                                      }
-                                                      return null;
-                                                    }
-                                                  }, Executors.newCachedThreadPool(),
-            cts.getToken()).continueWith(new Continuation<Void, Void>() {
-          public Void then(Task<Void> task) throws Exception {
-            assertTrue(task.isCancelled());
-            assertEquals(5, count.get());
-            return null;
-          }
+    }
+
+    @Test
+    public void testContinueWhileAsyncCancellation() {
+        final AtomicInteger count = new AtomicInteger(0);
+        final CancellationTokenSource cts = new CancellationTokenSource();
+        runTaskTest(new Callable<Task<?>>() {
+            public Task<?> call() throws Exception {
+                return Task.forResult(null).continueWhile(new Callable<Boolean>() {
+                    public Boolean call() throws Exception {
+                        return count.get() < 10;
+                    }
+                }, new Continuation<Void, Task<Void>>() {
+                    public Task<Void> then(Task<Void> task) throws Exception {
+                        if (count.incrementAndGet() == 5) {
+                            cts.cancel();
+                        }
+                        return null;
+                    }
+                }, Executors.newCachedThreadPool(), cts.getToken()).continueWith(new Continuation<Void, Void>() {
+                    public Void then(Task<Void> task) throws Exception {
+                        assertTrue(task.isCancelled());
+                        assertEquals(5, count.get());
+                        return null;
+                    }
+                });
+            }
         });
-      }
-    });
-  }
-
-  @Test
-  public void testCallWithBadExecutor() {
-    final RuntimeException exception = new RuntimeException("BAD EXECUTORS");
-
-    Task.call(new Callable<Integer>() {
-      public Integer call() throws Exception {
-        return 1;
-      }
-    }, new Executor() {
-      @Override
-      public void execute(Runnable command) {
-        throw exception;
-      }
-    }).continueWith(new Continuation<Integer, Object>() {
-      @Override
-      public Object then(Task<Integer> task) throws Exception {
-        assertTrue(task.isFaulted());
-        assertTrue(task.getError() instanceof ExecutorException);
-        assertEquals(exception, task.getError().getCause());
-
-        return null;
-      }
-    });
-  }
-
-  @Test
-  public void testContinueWithBadExecutor() {
-    final RuntimeException exception = new RuntimeException("BAD EXECUTORS");
-
-    Task.call(new Callable<Integer>() {
-      public Integer call() throws Exception {
-        return 1;
-      }
-    }).continueWith(new Continuation<Integer, Integer>() {
-      @Override
-      public Integer then(Task<Integer> task) throws Exception {
-        return task.getResult();
-      }
-    }, new Executor() {
-      @Override
-      public void execute(Runnable command) {
-        throw exception;
-      }
-    }).continueWith(new Continuation<Integer, Object>() {
-      @Override
-      public Object then(Task<Integer> task) throws Exception {
-        assertTrue(task.isFaulted());
-        assertTrue(task.getError() instanceof ExecutorException);
-        assertEquals(exception, task.getError().getCause());
-
-        return null;
-      }
-    });
-  }
-
-  @Test
-  public void testContinueWithTaskAndBadExecutor() {
-    final RuntimeException exception = new RuntimeException("BAD EXECUTORS");
-
-    Task.call(new Callable<Integer>() {
-      public Integer call() throws Exception {
-        return 1;
-      }
-    }).continueWithTask(new Continuation<Integer, Task<Integer>>() {
-      @Override
-      public Task<Integer> then(Task<Integer> task) throws Exception {
-        return task;
-      }
-    }, new Executor() {
-      @Override
-      public void execute(Runnable command) {
-        throw exception;
-      }
-    }).continueWith(new Continuation<Integer, Object>() {
-      @Override
-      public Object then(Task<Integer> task) throws Exception {
-        assertTrue(task.isFaulted());
-        assertTrue(task.getError() instanceof ExecutorException);
-        assertEquals(exception, task.getError().getCause());
-
-        return null;
-      }
-    });
-  }
-
-  //region TaskCompletionSource
-
-  @Test
-  public void testTrySetResult() {
-    TaskCompletionSource<String> tcs = new TaskCompletionSource<>();
-    Task<String> task = tcs.getTask();
-    assertFalse(task.isCompleted());
-
-    boolean success = tcs.trySetResult("SHOW ME WHAT YOU GOT");
-    assertTrue(success);
-    assertTrue(task.isCompleted());
-    assertEquals("SHOW ME WHAT YOU GOT", task.getResult());
-  }
-
-  @Test
-  public void testTrySetError() {
-    TaskCompletionSource<Void> tcs = new TaskCompletionSource<>();
-    Task<Void> task = tcs.getTask();
-    assertFalse(task.isCompleted());
-
-    Exception exception = new RuntimeException("DISQUALIFIED");
-    boolean success = tcs.trySetError(exception);
-    assertTrue(success);
-    assertTrue(task.isCompleted());
-    assertEquals(exception, task.getError());
-  }
-
-  @Test
-  public void testTrySetCanceled() {
-    TaskCompletionSource<Void> tcs = new TaskCompletionSource<>();
-    Task<Void> task = tcs.getTask();
-    assertFalse(task.isCompleted());
-
-    boolean success = tcs.trySetCancelled();
-    assertTrue(success);
-    assertTrue(task.isCompleted());
-    assertTrue(task.isCancelled());
-  }
-
-  @Test
-  public void testTrySetOnCompletedTask() {
-    TaskCompletionSource<Void> tcs = new TaskCompletionSource<>();
-    tcs.setResult(null);
-
-    assertFalse(tcs.trySetResult(null));
-    assertFalse(tcs.trySetError(new RuntimeException()));
-    assertFalse(tcs.trySetCancelled());
-  }
-
-  @Test
-  public void testSetResultOnCompletedTask() {
-    TaskCompletionSource<Void> tcs = new TaskCompletionSource<>();
-    tcs.setResult(null);
-
-    thrown.expect(IllegalStateException.class);
-    tcs.setResult(null);
-  }
-
-  @Test
-  public void testSetErrorOnCompletedTask() {
-    TaskCompletionSource<Void> tcs = new TaskCompletionSource<>();
-    tcs.setResult(null);
-
-    thrown.expect(IllegalStateException.class);
-    tcs.setError(new RuntimeException());
-  }
-
-  @Test
-  public void testSetCancelledOnCompletedTask() {
-    TaskCompletionSource<Void> tcs = new TaskCompletionSource<>();
-    tcs.setResult(null);
-
-    thrown.expect(IllegalStateException.class);
-    tcs.setCancelled();
-  }
-
-  //endregion
-
-  //region deprecated
-
-  @SuppressWarnings("deprecation")
-  @Test
-  public void testDeprecatedTaskCompletionSource() {
-    Task<Void>.TaskCompletionSource tcsA = Task.create();
-    tcsA.setResult(null);
-    assertTrue(tcsA.getTask().isCompleted());
-
-    TaskCompletionSource<Void> tcsB = Task.create();
-    tcsB.setResult(null);
-    assertTrue(tcsA.getTask().isCompleted());
-  }
-
-  @SuppressWarnings("deprecation")
-  @Test
-  public void testDeprecatedAggregateExceptionMethods() {
-    final Exception error0 = new Exception("This is an exception (0).");
-    final Exception error1 = new Exception("This is an exception (1).");
-    final Error error2 = new Error("This is an error.");
-
-    List<Exception> exceptions = new ArrayList<>();
-    exceptions.add(error0);
-    exceptions.add(error1);
-
-    // Test old functionality
-    AggregateException aggregate = new AggregateException(exceptions);
-    assertEquals("There were multiple errors.", aggregate.getMessage());
-    assertEquals(2, aggregate.getErrors().size());
-    assertEquals(error0, aggregate.getErrors().get(0));
-    assertEquals(error1, aggregate.getErrors().get(1));
-    assertEquals(2, aggregate.getCauses().length);
-    assertEquals(error0, aggregate.getCauses()[0]);
-    assertEquals(error1, aggregate.getCauses()[1]);
-
-    // Test deprecated getErrors method returns sane results with non-Exceptions
-    aggregate = new AggregateException("message", new Throwable[]{ error0, error1, error2 });
-    assertEquals("message", aggregate.getMessage());
-    assertEquals(3, aggregate.getErrors().size());
-    assertEquals(error0, aggregate.getErrors().get(0));
-    assertEquals(error1, aggregate.getErrors().get(1));
-    assertNotSame(error2, aggregate.getErrors().get(2));
-    assertEquals(error2, aggregate.getErrors().get(2).getCause());
-  }
-
-  //endregion
+    }
+
+    @Test
+    public void testCallWithBadExecutor() {
+        final RuntimeException exception = new RuntimeException("BAD EXECUTORS");
+
+        Task.call(new Callable<Integer>() {
+            public Integer call() throws Exception {
+                return 1;
+            }
+        }, new Executor() {
+            @Override
+            public void execute(Runnable command) {
+                throw exception;
+            }
+        }).continueWith(new Continuation<Integer, Object>() {
+            @Override
+            public Object then(Task<Integer> task) throws Exception {
+                assertTrue(task.isFaulted());
+                assertTrue(task.getError() instanceof ExecutorException);
+                assertEquals(exception, task.getError().getCause());
+
+                return null;
+            }
+        });
+    }
+
+    @Test
+    public void testContinueWithBadExecutor() {
+        final RuntimeException exception = new RuntimeException("BAD EXECUTORS");
+
+        Task.call(new Callable<Integer>() {
+            public Integer call() throws Exception {
+                return 1;
+            }
+        }).continueWith(new Continuation<Integer, Integer>() {
+            @Override
+            public Integer then(Task<Integer> task) throws Exception {
+                return task.getResult();
+            }
+        }, new Executor() {
+            @Override
+            public void execute(Runnable command) {
+                throw exception;
+            }
+        }).continueWith(new Continuation<Integer, Object>() {
+            @Override
+            public Object then(Task<Integer> task) throws Exception {
+                assertTrue(task.isFaulted());
+                assertTrue(task.getError() instanceof ExecutorException);
+                assertEquals(exception, task.getError().getCause());
+
+                return null;
+            }
+        });
+    }
+
+    @Test
+    public void testContinueWithTaskAndBadExecutor() {
+        final RuntimeException exception = new RuntimeException("BAD EXECUTORS");
+
+        Task.call(new Callable<Integer>() {
+            public Integer call() throws Exception {
+                return 1;
+            }
+        }).continueWithTask(new Continuation<Integer, Task<Integer>>() {
+            @Override
+            public Task<Integer> then(Task<Integer> task) throws Exception {
+                return task;
+            }
+        }, new Executor() {
+            @Override
+            public void execute(Runnable command) {
+                throw exception;
+            }
+        }).continueWith(new Continuation<Integer, Object>() {
+            @Override
+            public Object then(Task<Integer> task) throws Exception {
+                assertTrue(task.isFaulted());
+                assertTrue(task.getError() instanceof ExecutorException);
+                assertEquals(exception, task.getError().getCause());
+
+                return null;
+            }
+        });
+    }
+
+    //region TaskCompletionSource
+
+    @Test
+    public void testTrySetResult() {
+        TaskCompletionSource<String> tcs = new TaskCompletionSource<>();
+        Task<String> task = tcs.getTask();
+        assertFalse(task.isCompleted());
+
+        boolean success = tcs.trySetResult("SHOW ME WHAT YOU GOT");
+        assertTrue(success);
+        assertTrue(task.isCompleted());
+        assertEquals("SHOW ME WHAT YOU GOT", task.getResult());
+    }
+
+    @Test
+    public void testTrySetError() {
+        TaskCompletionSource<Void> tcs = new TaskCompletionSource<>();
+        Task<Void> task = tcs.getTask();
+        assertFalse(task.isCompleted());
+
+        Exception exception = new RuntimeException("DISQUALIFIED");
+        boolean success = tcs.trySetError(exception);
+        assertTrue(success);
+        assertTrue(task.isCompleted());
+        assertEquals(exception, task.getError());
+    }
+
+    @Test
+    public void testTrySetCanceled() {
+        TaskCompletionSource<Void> tcs = new TaskCompletionSource<>();
+        Task<Void> task = tcs.getTask();
+        assertFalse(task.isCompleted());
+
+        boolean success = tcs.trySetCancelled();
+        assertTrue(success);
+        assertTrue(task.isCompleted());
+        assertTrue(task.isCancelled());
+    }
+
+    @Test
+    public void testTrySetOnCompletedTask() {
+        TaskCompletionSource<Void> tcs = new TaskCompletionSource<>();
+        tcs.setResult(null);
+
+        assertFalse(tcs.trySetResult(null));
+        assertFalse(tcs.trySetError(new RuntimeException()));
+        assertFalse(tcs.trySetCancelled());
+    }
+
+    @Test
+    public void testSetResultOnCompletedTask() {
+        TaskCompletionSource<Void> tcs = new TaskCompletionSource<>();
+        tcs.setResult(null);
+
+        thrown.expect(IllegalStateException.class);
+        tcs.setResult(null);
+    }
+
+    @Test
+    public void testSetErrorOnCompletedTask() {
+        TaskCompletionSource<Void> tcs = new TaskCompletionSource<>();
+        tcs.setResult(null);
+
+        thrown.expect(IllegalStateException.class);
+        tcs.setError(new RuntimeException());
+    }
+
+    @Test
+    public void testSetCancelledOnCompletedTask() {
+        TaskCompletionSource<Void> tcs = new TaskCompletionSource<>();
+        tcs.setResult(null);
+
+        thrown.expect(IllegalStateException.class);
+        tcs.setCancelled();
+    }
+
+    //endregion
+
+    //region deprecated
+
+    @SuppressWarnings("deprecation")
+    @Test
+    public void testDeprecatedTaskCompletionSource() {
+        Task<Void>.TaskCompletionSource tcsA = Task.create();
+        tcsA.setResult(null);
+        assertTrue(tcsA.getTask().isCompleted());
+
+        TaskCompletionSource<Void> tcsB = Task.create();
+        tcsB.setResult(null);
+        assertTrue(tcsA.getTask().isCompleted());
+    }
+
+    @SuppressWarnings("deprecation")
+    @Test
+    public void testDeprecatedAggregateExceptionMethods() {
+        final Exception error0 = new Exception("This is an exception (0).");
+        final Exception error1 = new Exception("This is an exception (1).");
+        final Error error2 = new Error("This is an error.");
+
+        List<Exception> exceptions = new ArrayList<>();
+        exceptions.add(error0);
+        exceptions.add(error1);
+
+        // Test old functionality
+        AggregateException aggregate = new AggregateException(exceptions);
+        assertEquals("There were multiple errors.", aggregate.getMessage());
+        assertEquals(2, aggregate.getErrors().size());
+        assertEquals(error0, aggregate.getErrors().get(0));
+        assertEquals(error1, aggregate.getErrors().get(1));
+        assertEquals(2, aggregate.getCauses().length);
+        assertEquals(error0, aggregate.getCauses()[0]);
+        assertEquals(error1, aggregate.getCauses()[1]);
+
+        // Test deprecated getErrors method returns sane results with non-Exceptions
+        aggregate = new AggregateException("message", new Throwable[]{error0, error1, error2});
+        assertEquals("message", aggregate.getMessage());
+        assertEquals(3, aggregate.getErrors().size());
+        assertEquals(error0, aggregate.getErrors().get(0));
+        assertEquals(error1, aggregate.getErrors().get(1));
+        assertNotSame(error2, aggregate.getErrors().get(2));
+        assertEquals(error2, aggregate.getErrors().get(2).getCause());
+    }
+
+    //endregion
 }
diff --git a/build.gradle b/build.gradle
index 6c9a99c..41bc22d 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,10 +1,23 @@
 // Top-level build file where you can add configuration options common to all sub-projects/modules.
 buildscript {
     repositories {
+        jcenter()
+        maven {
+            url "http://git.bytedance.com:8081/nexus/content/repositories/ugc_android/"
+            // for roboaspectj
+        }
+        maven {
+            url "https://plugins.gradle.org/m2/"
+        }
+        maven {
+            url 'https://maven.google.com/'
+        }
+        maven { url "https://dl.bintray.com/thelasterstar/maven/" }
+        maven { url "https://dl.bintray.com/c8682y/maven/"}
         mavenCentral()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.3.1'
+        classpath 'com.android.tools.build:gradle:2.3.2'
         classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.0.1x'
     }
 }
@@ -16,8 +29,8 @@ allprojects {
 }
 
 ext {
-    compileSdkVersion = 23
-    buildToolsVersion = "23.0.1"
+    compileSdkVersion = 26
+    buildToolsVersion = "25.0.2"
 
     minSdkVersion = 8
     targetSdkVersion = 23
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 12e13c1..c179408 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.2-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
diff --git a/settings.gradle b/settings.gradle
index d045909..4baab39 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,3 +1 @@
-include ':bolts-android',
-        ':bolts-tasks',
-        ':bolts-applinks'
+include ':bolts-tasks'
