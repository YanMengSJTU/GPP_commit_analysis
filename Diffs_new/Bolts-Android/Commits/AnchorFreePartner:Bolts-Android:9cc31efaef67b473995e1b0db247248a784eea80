diff --git a/bolts-applinks/build.gradle b/bolts-applinks/build.gradle
index ead606f..12d1203 100644
--- a/bolts-applinks/build.gradle
+++ b/bolts-applinks/build.gradle
@@ -28,7 +28,7 @@ dependencies {
 
     testCompile 'junit:junit:4.12'
 
-    androidTestCompile 'com.android.support:support-v4:23.0.1'
+    androidTestCompile 'com.android.support:support-v4:28.0.0'
 }
 
 android.libraryVariants.all { variant ->
diff --git a/bolts-tasks/build.gradle b/bolts-tasks/build.gradle
index ad08a1a..df94b49 100644
--- a/bolts-tasks/build.gradle
+++ b/bolts-tasks/build.gradle
@@ -9,7 +9,6 @@ configurations {
 
 android {
     compileSdkVersion rootProject.ext.compileSdkVersion
-    buildToolsVersion rootProject.ext.buildToolsVersion
 
     defaultConfig {
         minSdkVersion rootProject.ext.minSdkVersion
@@ -24,6 +23,7 @@ sourceSets {
 
 dependencies {
     testCompile 'junit:junit:4.12'
+    implementation 'com.android.support:support-annotations:28.0.0'
 }
 
 //region Maven
diff --git a/bolts-tasks/src/main/java/com/anchorfree/bolts/AggregateException.java b/bolts-tasks/src/main/java/com/anchorfree/bolts/AggregateException.java
index f8483a9..f1b7f42 100644
--- a/bolts-tasks/src/main/java/com/anchorfree/bolts/AggregateException.java
+++ b/bolts-tasks/src/main/java/com/anchorfree/bolts/AggregateException.java
@@ -9,6 +9,8 @@
  */
 package com.anchorfree.bolts;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import java.io.PrintStream;
 import java.io.PrintWriter;
 import java.util.ArrayList;
@@ -51,7 +53,7 @@ public AggregateException(String detailMessage, Throwable[] innerThrowables) {
    * @param innerThrowables
    *            The exceptions that are the cause of the current exception.
    */
-  public AggregateException(String detailMessage, List<? extends Throwable> innerThrowables) {
+  public AggregateException(String detailMessage, @Nullable List<? extends Throwable> innerThrowables) {
     super(detailMessage,
         innerThrowables != null && innerThrowables.size() > 0 ? innerThrowables.get(0) : null);
     this.innerThrowables = Collections.unmodifiableList(innerThrowables);
@@ -77,7 +79,7 @@ public AggregateException(List<? extends Throwable> innerThrowables) {
   }
 
   @Override
-  public void printStackTrace(PrintStream err) {
+  public void printStackTrace(@NonNull PrintStream err) {
     super.printStackTrace(err);
 
     int currentIndex = -1;
@@ -92,7 +94,7 @@ public void printStackTrace(PrintStream err) {
   }
 
   @Override
-  public void printStackTrace(PrintWriter err) {
+  public void printStackTrace(@NonNull PrintWriter err) {
     super.printStackTrace(err);
 
     int currentIndex = -1;
@@ -109,6 +111,7 @@ public void printStackTrace(PrintWriter err) {
   /**
    * @deprecated Please use {@link #getInnerThrowables()} instead.
    */
+  @NonNull
   @Deprecated
   public List<Exception> getErrors() {
     List<Exception> errors = new ArrayList<Exception>();
diff --git a/bolts-tasks/src/main/java/com/anchorfree/bolts/AndroidExecutors.java b/bolts-tasks/src/main/java/com/anchorfree/bolts/AndroidExecutors.java
index 4abdc5c..5742a4b 100644
--- a/bolts-tasks/src/main/java/com/anchorfree/bolts/AndroidExecutors.java
+++ b/bolts-tasks/src/main/java/com/anchorfree/bolts/AndroidExecutors.java
@@ -14,6 +14,7 @@
 import android.os.Handler;
 import android.os.Looper;
 
+import android.support.annotation.NonNull;
 import java.util.concurrent.Executor;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.LinkedBlockingQueue;
@@ -39,7 +40,7 @@
 
   private static final AndroidExecutors INSTANCE = new AndroidExecutors();
 
-  private final Executor uiThread;
+  @NonNull private final Executor uiThread;
 
   private AndroidExecutors() {
     uiThread = new UIThreadExecutor();
@@ -70,6 +71,7 @@ private AndroidExecutors() {
    *
    * @return the newly created thread pool
    */
+  @NonNull
   public static ExecutorService newCachedThreadPool() {
     ThreadPoolExecutor executor =  new ThreadPoolExecutor(
         CORE_POOL_SIZE,
@@ -93,6 +95,7 @@ public static ExecutorService newCachedThreadPool() {
    * @param threadFactory the factory to use when creating new threads
    * @return the newly created thread pool
    */
+  @NonNull
   public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
     ThreadPoolExecutor executor =  new ThreadPoolExecutor(
             CORE_POOL_SIZE,
@@ -116,7 +119,7 @@ public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
    * @param value true if should time out, else false
    */
   @SuppressLint("NewApi")
-  public static void allowCoreThreadTimeout(ThreadPoolExecutor executor, boolean value) {
+  public static void allowCoreThreadTimeout(@NonNull ThreadPoolExecutor executor, boolean value) {
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {
       executor.allowCoreThreadTimeOut(value);
     }
@@ -125,6 +128,7 @@ public static void allowCoreThreadTimeout(ThreadPoolExecutor executor, boolean v
   /**
    * An {@link java.util.concurrent.Executor} that executes tasks on the UI thread.
    */
+  @NonNull
   public static Executor uiThread() {
     return INSTANCE.uiThread;
   }
diff --git a/bolts-tasks/src/main/java/com/anchorfree/bolts/BoltsExecutors.java b/bolts-tasks/src/main/java/com/anchorfree/bolts/BoltsExecutors.java
index d600620..ae96c31 100644
--- a/bolts-tasks/src/main/java/com/anchorfree/bolts/BoltsExecutors.java
+++ b/bolts-tasks/src/main/java/com/anchorfree/bolts/BoltsExecutors.java
@@ -1,5 +1,6 @@
 package com.anchorfree.bolts;
 
+import android.support.annotation.NonNull;
 import java.util.Locale;
 import java.util.concurrent.Executor;
 import java.util.concurrent.ExecutorService;
@@ -21,9 +22,9 @@ private static boolean isAndroidRuntime() {
     return javaRuntimeName.toLowerCase(Locale.US).contains("android");
   }
 
-  private final ExecutorService background;
+  @NonNull private final ExecutorService background;
   private final ScheduledExecutorService scheduled;
-  private final Executor immediate;
+  @NonNull private final Executor immediate;
 
   private BoltsExecutors() {
     background = !isAndroidRuntime()
@@ -36,6 +37,7 @@ private BoltsExecutors() {
   /**
    * An {@link java.util.concurrent.Executor} that executes tasks in parallel.
    */
+  @NonNull
   public static ExecutorService background() {
     return INSTANCE.background;
   }
@@ -49,7 +51,8 @@ public static ExecutorService background() {
    * the stack runs too deep, at which point it will delegate to {@link BoltsExecutors#background}
    * in order to trim the stack.
    */
-  /* package */ static Executor immediate() {
+  /* package */ @NonNull
+  static Executor immediate() {
     return INSTANCE.immediate;
   }
 
@@ -61,7 +64,7 @@ public static ExecutorService background() {
    */
   private static class ImmediateExecutor implements Executor {
     private static final int MAX_DEPTH = 15;
-    private ThreadLocal<Integer> executionDepth = new ThreadLocal<>();
+    @NonNull private ThreadLocal<Integer> executionDepth = new ThreadLocal<>();
 
     /**
      * Increments the depth.
@@ -98,7 +101,7 @@ private int decrementDepth() {
     }
 
     @Override
-    public void execute(Runnable command) {
+    public void execute(@NonNull Runnable command) {
       int depth = incrementDepth();
       try {
         if (depth <= MAX_DEPTH) {
diff --git a/bolts-tasks/src/main/java/com/anchorfree/bolts/CancellationToken.java b/bolts-tasks/src/main/java/com/anchorfree/bolts/CancellationToken.java
index 9aa80af..c191f6f 100644
--- a/bolts-tasks/src/main/java/com/anchorfree/bolts/CancellationToken.java
+++ b/bolts-tasks/src/main/java/com/anchorfree/bolts/CancellationToken.java
@@ -9,6 +9,7 @@
  */
 package com.anchorfree.bolts;
 
+import android.support.annotation.NonNull;
 import java.util.Locale;
 import java.util.concurrent.CancellationException;
 
@@ -61,6 +62,7 @@ public void throwIfCancellationRequested() throws CancellationException {
     tokenSource.throwIfCancellationRequested();
   }
 
+  @NonNull
   @Override
   public String toString() {
     return String.format(Locale.US, "%s@%s[cancellationRequested=%s]",
diff --git a/bolts-tasks/src/main/java/com/anchorfree/bolts/CancellationTokenRegistration.java b/bolts-tasks/src/main/java/com/anchorfree/bolts/CancellationTokenRegistration.java
index e7bc3b2..a674bec 100644
--- a/bolts-tasks/src/main/java/com/anchorfree/bolts/CancellationTokenRegistration.java
+++ b/bolts-tasks/src/main/java/com/anchorfree/bolts/CancellationTokenRegistration.java
@@ -9,6 +9,7 @@
  */
 package com.anchorfree.bolts;
 
+import android.support.annotation.Nullable;
 import java.io.Closeable;
 
 /**
@@ -19,8 +20,8 @@
 public class CancellationTokenRegistration implements Closeable {
 
   private final Object lock = new Object();
-  private CancellationTokenSource tokenSource;
-  private Runnable action;
+  @Nullable private CancellationTokenSource tokenSource;
+  @Nullable private Runnable action;
   private boolean closed;
 
   /* package */ CancellationTokenRegistration(CancellationTokenSource tokenSource, Runnable action) {
diff --git a/bolts-tasks/src/main/java/com/anchorfree/bolts/CancellationTokenSource.java b/bolts-tasks/src/main/java/com/anchorfree/bolts/CancellationTokenSource.java
index ab15a02..034edbf 100644
--- a/bolts-tasks/src/main/java/com/anchorfree/bolts/CancellationTokenSource.java
+++ b/bolts-tasks/src/main/java/com/anchorfree/bolts/CancellationTokenSource.java
@@ -9,6 +9,8 @@
  */
 package com.anchorfree.bolts;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import java.io.Closeable;
 import java.util.ArrayList;
 import java.util.List;
@@ -31,7 +33,7 @@
   private final Object lock = new Object();
   private final List<CancellationTokenRegistration> registrations = new ArrayList<>();
   private final ScheduledExecutorService executor = BoltsExecutors.scheduled();
-  private ScheduledFuture<?> scheduledCancellation;
+  @Nullable private ScheduledFuture<?> scheduledCancellation;
   private boolean cancellationRequested;
   private boolean closed;
 
@@ -54,6 +56,7 @@ public boolean isCancellationRequested() {
   /**
    * @return the token that can be passed to asynchronous method to control cancellation.
    */
+  @NonNull
   public CancellationToken getToken() {
     synchronized (lock) {
       throwIfClosed();
@@ -184,6 +187,7 @@ private void notifyListeners(List<CancellationTokenRegistration> registrations)
     }
   }
 
+  @NonNull
   @Override
   public String toString() {
     return String.format(Locale.US, "%s@%s[cancellationRequested=%s]",
diff --git a/bolts-tasks/src/main/java/com/anchorfree/bolts/Continuation.java b/bolts-tasks/src/main/java/com/anchorfree/bolts/Continuation.java
index 159dba8..0391c49 100644
--- a/bolts-tasks/src/main/java/com/anchorfree/bolts/Continuation.java
+++ b/bolts-tasks/src/main/java/com/anchorfree/bolts/Continuation.java
@@ -9,6 +9,8 @@
  */
 package com.anchorfree.bolts;
 
+import android.support.annotation.Nullable;
+
 /**
  * A function to be called after a task completes.
  *
@@ -18,5 +20,6 @@
  * @see Task
  */
 public interface Continuation<TTaskResult, TContinuationResult> {
+  @Nullable
   TContinuationResult then(Task<TTaskResult> task) throws Exception;
 }
diff --git a/bolts-tasks/src/main/java/com/anchorfree/bolts/Task.java b/bolts-tasks/src/main/java/com/anchorfree/bolts/Task.java
index c9a4be2..1121f81 100644
--- a/bolts-tasks/src/main/java/com/anchorfree/bolts/Task.java
+++ b/bolts-tasks/src/main/java/com/anchorfree/bolts/Task.java
@@ -9,6 +9,8 @@
  */
 package com.anchorfree.bolts;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -91,11 +93,11 @@ public static void setUnobservedExceptionHandler(UnobservedExceptionHandler eh)
   private final Object lock = new Object();
   private boolean complete;
   private boolean cancelled;
-  private TResult result;
+  @Nullable private TResult result;
   private Exception error;
   private boolean errorHasBeenObserved;
-  private UnobservedErrorNotifier unobservedErrorNotifier;
-  private List<Continuation<TResult, Void>> continuations = new ArrayList<>();
+  @Nullable private UnobservedErrorNotifier unobservedErrorNotifier;
+  @Nullable private List<Continuation<TResult, Void>> continuations = new ArrayList<>();
 
   /* package */ Task() {
   }
@@ -151,6 +153,7 @@ public boolean isFaulted() {
   /**
    * @return The result of the task, if set. {@code null} otherwise.
    */
+  @Nullable
   public TResult getResult() {
     synchronized (lock) {
       return result;
@@ -189,7 +192,7 @@ public void waitForCompletion() throws InterruptedException {
    * @return {@code true} if the task completed (has a result, an error, or was cancelled).
    *         {@code false} otherwise.
    */
-  public boolean waitForCompletion(long duration, TimeUnit timeUnit) throws InterruptedException {
+  public boolean waitForCompletion(long duration, @NonNull TimeUnit timeUnit) throws InterruptedException {
     synchronized (lock) {
       if (!isCompleted()) {
         lock.wait(timeUnit.toMillis(duration));
@@ -201,8 +204,9 @@ public boolean waitForCompletion(long duration, TimeUnit timeUnit) throws Interr
   /**
    * Creates a completed task with the given value.
    */
+  @NonNull
   @SuppressWarnings("unchecked")
-  public static <TResult> Task<TResult> forResult(TResult value) {
+  public static <TResult> Task<TResult> forResult(@Nullable TResult value) {
     if (value == null) {
       return (Task<TResult>) TASK_NULL;
     }
@@ -217,6 +221,7 @@ public boolean waitForCompletion(long duration, TimeUnit timeUnit) throws Interr
   /**
    * Creates a faulted task with the given error.
    */
+  @NonNull
   public static <TResult> Task<TResult> forError(Exception error) {
     com.anchorfree.bolts.TaskCompletionSource<TResult> tcs = new com.anchorfree.bolts.TaskCompletionSource<>();
     tcs.setError(error);
@@ -226,6 +231,7 @@ public boolean waitForCompletion(long duration, TimeUnit timeUnit) throws Interr
   /**
    * Creates a cancelled task.
    */
+  @NonNull
   @SuppressWarnings("unchecked")
   public static <TResult> Task<TResult> cancelled() {
     return (Task<TResult>) TASK_CANCELLED;
@@ -237,6 +243,7 @@ public boolean waitForCompletion(long duration, TimeUnit timeUnit) throws Interr
    * @param delay The number of milliseconds to wait before completing the returned task. Zero and
    *              negative values are treated as requests for immediate execution.
    */
+  @NonNull
   public static Task<Void> delay(long delay) {
     return delay(delay, BoltsExecutors.scheduled(), null);
   }
@@ -249,11 +256,13 @@ public boolean waitForCompletion(long duration, TimeUnit timeUnit) throws Interr
    * @param cancellationToken The optional cancellation token that will be checked prior to
    *                          completing the returned task.
    */
+  @NonNull
   public static Task<Void> delay(long delay, CancellationToken cancellationToken) {
     return delay(delay, BoltsExecutors.scheduled(), cancellationToken);
   }
 
-  /* package */ static Task<Void> delay(long delay, ScheduledExecutorService executor, final CancellationToken cancellationToken) {
+  /* package */ @NonNull
+  static Task<Void> delay(long delay, @NonNull ScheduledExecutorService executor, @Nullable final CancellationToken cancellationToken) {
     if (cancellationToken != null && cancellationToken.isCancellationRequested()) {
       return Task.cancelled();
     }
@@ -287,6 +296,7 @@ public void run() {
    * Makes a fluent cast of a Task's result possible, avoiding an extra continuation just to cast
    * the type of the result.
    */
+  @NonNull
   public <TOut> Task<TOut> cast() {
     @SuppressWarnings("unchecked")
     Task<TOut> task = (Task<TOut>) this;
@@ -296,10 +306,12 @@ public void run() {
   /**
    * Turns a Task<T> into a Task<Void>, dropping any result.
    */
+  @NonNull
   public Task<Void> makeVoid() {
     return this.continueWithTask(new Continuation<TResult, Task<Void>>() {
+      @Nullable
       @Override
-      public Task<Void> then(Task<TResult> task) throws Exception {
+      public Task<Void> then(@NonNull Task<TResult> task) throws Exception {
         if (task.isCancelled()) {
           return Task.cancelled();
         }
@@ -317,14 +329,14 @@ public void run() {
    * If you want to cancel the resulting Task throw a {@link java.util.concurrent.CancellationException}
    * from the callable.
    */
-  public static <TResult> Task<TResult> callInBackground(Callable<TResult> callable) {
+  public static <TResult> Task<TResult> callInBackground(@NonNull Callable<TResult> callable) {
     return call(callable, BACKGROUND_EXECUTOR, null);
   }
 
   /**
    * Invokes the callable on a background thread, returning a Task to represent the operation.
    */
-  public static <TResult> Task<TResult> callInBackground(Callable<TResult> callable, CancellationToken ct) {
+  public static <TResult> Task<TResult> callInBackground(@NonNull Callable<TResult> callable, CancellationToken ct) {
     return call(callable, BACKGROUND_EXECUTOR, ct);
   }
 
@@ -334,15 +346,15 @@ public void run() {
    * If you want to cancel the resulting Task throw a {@link java.util.concurrent.CancellationException}
    * from the callable.
    */
-  public static <TResult> Task<TResult> call(final Callable<TResult> callable, Executor executor) {
+  public static <TResult> Task<TResult> call(@NonNull final Callable<TResult> callable, @NonNull Executor executor) {
     return call(callable, executor, null);
   }
 
   /**
    * Invokes the callable using the given executor, returning a Task to represent the operation.
    */
-  public static <TResult> Task<TResult> call(final Callable<TResult> callable, Executor executor,
-      final CancellationToken ct) {
+  public static <TResult> Task<TResult> call(@NonNull final Callable<TResult> callable, @NonNull Executor executor,
+      @Nullable final CancellationToken ct) {
     final com.anchorfree.bolts.TaskCompletionSource<TResult> tcs = new com.anchorfree.bolts.TaskCompletionSource<>();
     try {
       executor.execute(new Runnable() {
@@ -375,14 +387,14 @@ public void run() {
    * If you want to cancel the resulting Task throw a {@link java.util.concurrent.CancellationException}
    * from the callable.
    */
-  public static <TResult> Task<TResult> call(final Callable<TResult> callable) {
+  public static <TResult> Task<TResult> call(@NonNull final Callable<TResult> callable) {
     return call(callable, IMMEDIATE_EXECUTOR, null);
   }
 
   /**
    * Invokes the callable on the current thread, producing a Task.
    */
-  public static <TResult> Task<TResult> call(final Callable<TResult> callable, CancellationToken ct) {
+  public static <TResult> Task<TResult> call(@NonNull final Callable<TResult> callable, CancellationToken ct) {
     return call(callable, IMMEDIATE_EXECUTOR, ct);
   }
 
@@ -398,6 +410,7 @@ public void run() {
    * @return A task that represents the completion of one of the supplied tasks. 
    *         The return task's result is the task that completed.
    */
+  @Nullable
   public static <TResult> Task<Task<TResult>> whenAnyResult(Collection<? extends Task<TResult>> tasks) {
     if (tasks.size() == 0) {
       return Task.forResult(null);
@@ -408,8 +421,9 @@ public void run() {
 
     for (Task<TResult> task : tasks) {
       task.continueWith(new Continuation<TResult, Void>() {
+        @Nullable
         @Override
-        public Void then(Task<TResult> task) {
+        public Void then(@NonNull Task<TResult> task) {
           if (isAnyTaskComplete.compareAndSet(false, true)) {
             firstCompleted.setResult(task);
           } else {
@@ -434,6 +448,7 @@ public Void then(Task<TResult> task) {
    * @return A task that represents the completion of one of the supplied tasks. 
    *         The return task's Result is the task that completed.
    */
+  @Nullable
   @SuppressWarnings("unchecked")
   public static Task<Task<?>> whenAny(Collection<? extends Task<?>> tasks) {
     if (tasks.size() == 0) {
@@ -445,8 +460,9 @@ public Void then(Task<TResult> task) {
       
     for (Task<?> task : tasks) {
       ((Task<Object>) task).continueWith(new Continuation<Object, Void>() {
+        @Nullable
         @Override
-        public Void then(Task<Object> task) {
+        public Void then(@NonNull Task<Object> task) {
           if (isAnyTaskComplete.compareAndSet(false, true)) {
             firstCompleted.setResult(task);
           } else {
@@ -484,7 +500,8 @@ public Void then(Task<Object> task) {
    * @param tasks The tasks that the return value will wait for before completing.
    * @return A Task that will resolve to {@code List&lt;TResult&gt;} when all the tasks are resolved.
    */
-  public static <TResult> Task<List<TResult>> whenAllResult(final Collection<? extends Task<TResult>> tasks) {
+  @NonNull
+  public static <TResult> Task<List<TResult>> whenAllResult(@NonNull final Collection<? extends Task<TResult>> tasks) {
     return whenAll(tasks).onSuccess(new Continuation<Void, List<TResult>>() {
       @Override
       public List<TResult> then(Task<Void> task) throws Exception {
@@ -521,6 +538,7 @@ public Void then(Task<Object> task) {
    * @param tasks The tasks that the return value will wait for before completing.
    * @return A Task that will resolve to {@code Void} when all the tasks are resolved.
    */
+  @Nullable
   public static Task<Void> whenAll(Collection<? extends Task<?>> tasks) {
     if (tasks.size() == 0) {
       return Task.forResult(null);
@@ -536,8 +554,9 @@ public Void then(Task<Object> task) {
       @SuppressWarnings("unchecked")
       Task<Object> t = (Task<Object>) task;
       t.continueWith(new Continuation<Object, Void>() {
+        @Nullable
         @Override
-        public Void then(Task<Object> task) {
+        public Void then(@NonNull Task<Object> task) {
           if (task.isFaulted()) {
             synchronized (errorLock) {
               causes.add(task.getError());
@@ -576,8 +595,9 @@ public Void then(Task<Object> task) {
    * Continues a task with the equivalent of a Task-based while loop, where the body of the loop is
    * a task continuation.
    */
-  public Task<Void> continueWhile(Callable<Boolean> predicate,
-      Continuation<Void, Task<Void>> continuation) {
+  @NonNull
+  public Task<Void> continueWhile(@NonNull Callable<Boolean> predicate,
+      @NonNull Continuation<Void, Task<Void>> continuation) {
     return continueWhile(predicate, continuation, IMMEDIATE_EXECUTOR, null);
   }
 
@@ -585,8 +605,9 @@ public Void then(Task<Object> task) {
    * Continues a task with the equivalent of a Task-based while loop, where the body of the loop is
    * a task continuation.
    */
-  public Task<Void> continueWhile(Callable<Boolean> predicate,
-      Continuation<Void, Task<Void>> continuation, CancellationToken ct) {
+  @NonNull
+  public Task<Void> continueWhile(@NonNull Callable<Boolean> predicate,
+      @NonNull Continuation<Void, Task<Void>> continuation, CancellationToken ct) {
     return continueWhile(predicate, continuation, IMMEDIATE_EXECUTOR, ct);
   }
 
@@ -594,8 +615,9 @@ public Void then(Task<Object> task) {
    * Continues a task with the equivalent of a Task-based while loop, where the body of the loop is
    * a task continuation.
    */
-  public Task<Void> continueWhile(final Callable<Boolean> predicate,
-      final Continuation<Void, Task<Void>> continuation, final Executor executor) {
+  @NonNull
+  public Task<Void> continueWhile(@NonNull final Callable<Boolean> predicate,
+      @NonNull final Continuation<Void, Task<Void>> continuation, @NonNull final Executor executor) {
     return continueWhile(predicate, continuation, executor, null);
   }
 
@@ -603,12 +625,14 @@ public Void then(Task<Object> task) {
    * Continues a task with the equivalent of a Task-based while loop, where the body of the loop is
    * a task continuation.
    */
-  public Task<Void> continueWhile(final Callable<Boolean> predicate,
-      final Continuation<Void, Task<Void>> continuation, final Executor executor,
-      final CancellationToken ct) {
+  @NonNull
+  public Task<Void> continueWhile(@NonNull final Callable<Boolean> predicate,
+      @NonNull final Continuation<Void, Task<Void>> continuation, @NonNull final Executor executor,
+      @Nullable final CancellationToken ct) {
     final Capture<Continuation<Void, Task<Void>>> predicateContinuation =
         new Capture<>();
     predicateContinuation.set(new Continuation<Void, Task<Void>>() {
+      @Nullable
       @Override
       public Task<Void> then(Task<Void> task) throws Exception {
         if (ct != null && ct.isCancellationRequested()) {
@@ -630,8 +654,9 @@ public Void then(Task<Object> task) {
    * completes after the continuation has finished running. This allows the continuation to be
    * scheduled on different thread.
    */
+  @NonNull
   public <TContinuationResult> Task<TContinuationResult> continueWith(
-      final Continuation<TResult, TContinuationResult> continuation, final Executor executor) {
+      @NonNull final Continuation<TResult, TContinuationResult> continuation, @NonNull final Executor executor) {
     return continueWith(continuation, executor, null);
   }
 
@@ -640,8 +665,9 @@ public Void then(Task<Object> task) {
    * completes after the continuation has finished running. This allows the continuation to be
    * scheduled on different thread.
    */
+  @NonNull
   public <TContinuationResult> Task<TContinuationResult> continueWith(
-      final Continuation<TResult, TContinuationResult> continuation, final Executor executor,
+      @NonNull final Continuation<TResult, TContinuationResult> continuation, @NonNull final Executor executor,
       final CancellationToken ct) {
     boolean completed;
     final com.anchorfree.bolts.TaskCompletionSource<TContinuationResult> tcs = new com.anchorfree.bolts.TaskCompletionSource<>();
@@ -649,6 +675,7 @@ public Void then(Task<Object> task) {
       completed = this.isCompleted();
       if (!completed) {
         this.continuations.add(new Continuation<TResult, Void>() {
+          @Nullable
           @Override
           public Void then(Task<TResult> task) {
             completeImmediately(tcs, continuation, task, executor, ct);
@@ -667,8 +694,9 @@ public Void then(Task<TResult> task) {
    * Adds a synchronous continuation to this task, returning a new task that completes after the
    * continuation has finished running.
    */
+  @NonNull
   public <TContinuationResult> Task<TContinuationResult> continueWith(
-      Continuation<TResult, TContinuationResult> continuation) {
+      @NonNull Continuation<TResult, TContinuationResult> continuation) {
     return continueWith(continuation, IMMEDIATE_EXECUTOR, null);
   }
 
@@ -676,8 +704,9 @@ public Void then(Task<TResult> task) {
    * Adds a synchronous continuation to this task, returning a new task that completes after the
    * continuation has finished running.
    */
+  @NonNull
   public <TContinuationResult> Task<TContinuationResult> continueWith(
-      Continuation<TResult, TContinuationResult> continuation, CancellationToken ct) {
+      @NonNull Continuation<TResult, TContinuationResult> continuation, CancellationToken ct) {
     return continueWith(continuation, IMMEDIATE_EXECUTOR, ct);
   }
 
@@ -685,8 +714,9 @@ public Void then(Task<TResult> task) {
    * Adds an Task-based continuation to this task that will be scheduled using the executor,
    * returning a new task that completes after the task returned by the continuation has completed.
    */
+  @NonNull
   public <TContinuationResult> Task<TContinuationResult> continueWithTask(
-      final Continuation<TResult, Task<TContinuationResult>> continuation, final Executor executor) {
+      @NonNull final Continuation<TResult, Task<TContinuationResult>> continuation, @NonNull final Executor executor) {
     return continueWithTask(continuation, executor, null);
   }
 
@@ -694,8 +724,9 @@ public Void then(Task<TResult> task) {
    * Adds an Task-based continuation to this task that will be scheduled using the executor,
    * returning a new task that completes after the task returned by the continuation has completed.
    */
+  @NonNull
   public <TContinuationResult> Task<TContinuationResult> continueWithTask(
-      final Continuation<TResult, Task<TContinuationResult>> continuation, final Executor executor,
+      @NonNull final Continuation<TResult, Task<TContinuationResult>> continuation, @NonNull final Executor executor,
       final CancellationToken ct) {
     boolean completed;
     final com.anchorfree.bolts.TaskCompletionSource<TContinuationResult> tcs = new com.anchorfree.bolts.TaskCompletionSource<>();
@@ -703,6 +734,7 @@ public Void then(Task<TResult> task) {
       completed = this.isCompleted();
       if (!completed) {
         this.continuations.add(new Continuation<TResult, Void>() {
+          @Nullable
           @Override
           public Void then(Task<TResult> task) {
             completeAfterTask(tcs, continuation, task, executor, ct);
@@ -721,8 +753,9 @@ public Void then(Task<TResult> task) {
    * Adds an asynchronous continuation to this task, returning a new task that completes after the
    * task returned by the continuation has completed.
    */
+  @NonNull
   public <TContinuationResult> Task<TContinuationResult> continueWithTask(
-      Continuation<TResult, Task<TContinuationResult>> continuation) {
+      @NonNull Continuation<TResult, Task<TContinuationResult>> continuation) {
     return continueWithTask(continuation, IMMEDIATE_EXECUTOR, null);
   }
 
@@ -730,8 +763,9 @@ public Void then(Task<TResult> task) {
    * Adds an asynchronous continuation to this task, returning a new task that completes after the
    * task returned by the continuation has completed.
    */
+  @NonNull
   public <TContinuationResult> Task<TContinuationResult> continueWithTask(
-      Continuation<TResult, Task<TContinuationResult>> continuation, CancellationToken ct) {
+      @NonNull Continuation<TResult, Task<TContinuationResult>> continuation, CancellationToken ct) {
     return continueWithTask(continuation, IMMEDIATE_EXECUTOR, ct);
   }
 
@@ -739,8 +773,9 @@ public Void then(Task<TResult> task) {
    * Runs a continuation when a task completes successfully, forwarding along
    * {@link java.lang.Exception} or cancellation.
    */
+  @NonNull
   public <TContinuationResult> Task<TContinuationResult> onSuccess(
-      final Continuation<TResult, TContinuationResult> continuation, Executor executor) {
+      @NonNull final Continuation<TResult, TContinuationResult> continuation, @NonNull Executor executor) {
     return onSuccess(continuation, executor, null);
   }
 
@@ -748,12 +783,13 @@ public Void then(Task<TResult> task) {
    * Runs a continuation when a task completes successfully, forwarding along
    * {@link java.lang.Exception} or cancellation.
    */
+  @NonNull
   public <TContinuationResult> Task<TContinuationResult> onSuccess(
-      final Continuation<TResult, TContinuationResult> continuation, Executor executor,
-      final CancellationToken ct) {
+      @NonNull final Continuation<TResult, TContinuationResult> continuation, @NonNull Executor executor,
+      @Nullable final CancellationToken ct) {
     return continueWithTask(new Continuation<TResult, Task<TContinuationResult>>() {
       @Override
-      public Task<TContinuationResult> then(Task<TResult> task) {
+      public Task<TContinuationResult> then(@NonNull Task<TResult> task) {
         if (ct != null && ct.isCancellationRequested()) {
           return Task.cancelled();
         }
@@ -773,8 +809,9 @@ public Void then(Task<TResult> task) {
    * Runs a continuation when a task completes successfully, forwarding along
    * {@link java.lang.Exception}s or cancellation.
    */
+  @NonNull
   public <TContinuationResult> Task<TContinuationResult> onSuccess(
-      final Continuation<TResult, TContinuationResult> continuation) {
+      @NonNull final Continuation<TResult, TContinuationResult> continuation) {
     return onSuccess(continuation, IMMEDIATE_EXECUTOR, null);
   }
 
@@ -782,8 +819,9 @@ public Void then(Task<TResult> task) {
    * Runs a continuation when a task completes successfully, forwarding along
    * {@link java.lang.Exception}s or cancellation.
    */
+  @NonNull
   public <TContinuationResult> Task<TContinuationResult> onSuccess(
-      final Continuation<TResult, TContinuationResult> continuation, CancellationToken ct) {
+      @NonNull final Continuation<TResult, TContinuationResult> continuation, CancellationToken ct) {
     return onSuccess(continuation, IMMEDIATE_EXECUTOR, ct);
   }
 
@@ -791,8 +829,9 @@ public Void then(Task<TResult> task) {
    * Runs a continuation when a task completes successfully, forwarding along
    * {@link java.lang.Exception}s or cancellation.
    */
+  @NonNull
   public <TContinuationResult> Task<TContinuationResult> onSuccessTask(
-      final Continuation<TResult, Task<TContinuationResult>> continuation, Executor executor) {
+      @NonNull final Continuation<TResult, Task<TContinuationResult>> continuation, @NonNull Executor executor) {
     return onSuccessTask(continuation, executor, null);
   }
 
@@ -800,12 +839,13 @@ public Void then(Task<TResult> task) {
    * Runs a continuation when a task completes successfully, forwarding along
    * {@link java.lang.Exception}s or cancellation.
    */
+  @NonNull
   public <TContinuationResult> Task<TContinuationResult> onSuccessTask(
-      final Continuation<TResult, Task<TContinuationResult>> continuation, Executor executor,
-      final CancellationToken ct) {
+      @NonNull final Continuation<TResult, Task<TContinuationResult>> continuation, @NonNull Executor executor,
+      @Nullable final CancellationToken ct) {
     return continueWithTask(new Continuation<TResult, Task<TContinuationResult>>() {
       @Override
-      public Task<TContinuationResult> then(Task<TResult> task) {
+      public Task<TContinuationResult> then(@NonNull Task<TResult> task) {
         if (ct != null && ct.isCancellationRequested()) {
           return Task.cancelled();
         }
@@ -825,8 +865,9 @@ public Void then(Task<TResult> task) {
    * Runs a continuation when a task completes successfully, forwarding along
    * {@link java.lang.Exception}s or cancellation.
    */
+  @NonNull
   public <TContinuationResult> Task<TContinuationResult> onSuccessTask(
-      final Continuation<TResult, Task<TContinuationResult>> continuation) {
+      @NonNull final Continuation<TResult, Task<TContinuationResult>> continuation) {
     return onSuccessTask(continuation, IMMEDIATE_EXECUTOR);
   }
 
@@ -834,8 +875,9 @@ public Void then(Task<TResult> task) {
    * Runs a continuation when a task completes successfully, forwarding along
    * {@link java.lang.Exception}s or cancellation.
    */
+  @NonNull
   public <TContinuationResult> Task<TContinuationResult> onSuccessTask(
-      final Continuation<TResult, Task<TContinuationResult>> continuation,
+      @NonNull final Continuation<TResult, Task<TContinuationResult>> continuation,
       CancellationToken ct) {
     return onSuccessTask(continuation, IMMEDIATE_EXECUTOR, ct);
   }
@@ -856,9 +898,9 @@ public Void then(Task<TResult> task) {
    *          scheduled on a different thread).
    */
   private static <TContinuationResult, TResult> void completeImmediately(
-      final com.anchorfree.bolts.TaskCompletionSource<TContinuationResult> tcs,
-      final Continuation<TResult, TContinuationResult> continuation, final Task<TResult> task,
-      Executor executor, final CancellationToken ct) {
+      @NonNull final com.anchorfree.bolts.TaskCompletionSource<TContinuationResult> tcs,
+      @NonNull final Continuation<TResult, TContinuationResult> continuation, final Task<TResult> task,
+      @NonNull Executor executor, @Nullable final CancellationToken ct) {
     try {
       executor.execute(new Runnable() {
         @Override
@@ -900,10 +942,10 @@ public void run() {
    *          scheduled on a different thread).
    */
   private static <TContinuationResult, TResult> void completeAfterTask(
-      final com.anchorfree.bolts.TaskCompletionSource<TContinuationResult> tcs,
-      final Continuation<TResult, Task<TContinuationResult>> continuation,
-      final Task<TResult> task, final Executor executor,
-      final CancellationToken ct) {
+      @NonNull final com.anchorfree.bolts.TaskCompletionSource<TContinuationResult> tcs,
+      @NonNull final Continuation<TResult, Task<TContinuationResult>> continuation,
+      final Task<TResult> task, @NonNull final Executor executor,
+      @Nullable final CancellationToken ct) {
     try {
       executor.execute(new Runnable() {
         @Override
@@ -919,8 +961,9 @@ public void run() {
               tcs.setResult(null);
             } else {
               result.continueWith(new Continuation<TContinuationResult, Void>() {
+                @Nullable
                 @Override
-                public Void then(Task<TContinuationResult> task) {
+                public Void then(@NonNull Task<TContinuationResult> task) {
                   if (ct != null && ct.isCancellationRequested()) {
                     tcs.setCancelled();
                     return null;
@@ -983,7 +1026,7 @@ private void runContinuations() {
   /**
    * Sets the result on the Task if the Task hasn't already been completed.
    */
-  /* package */ boolean trySetResult(TResult result) {
+  /* package */ boolean trySetResult(@Nullable TResult result) {
     synchronized (lock) {
       if (complete) {
         return false;
@@ -1024,8 +1067,8 @@ private void runContinuations() {
     }
   }
 
-  private static Task<?> TASK_NULL = new Task<>(null);
-  private static Task<Boolean> TASK_TRUE = new Task<>((Boolean) true);
-  private static Task<Boolean> TASK_FALSE = new Task<>((Boolean) false);
-  private static Task<?> TASK_CANCELLED = new Task(true);
+  @NonNull private static Task<?> TASK_NULL = new Task<>(null);
+  @NonNull private static Task<Boolean> TASK_TRUE = new Task<>((Boolean) true);
+  @NonNull private static Task<Boolean> TASK_FALSE = new Task<>((Boolean) false);
+  @NonNull private static Task<?> TASK_CANCELLED = new Task(true);
 }
diff --git a/bolts-tasks/src/main/java/com/anchorfree/bolts/TaskCompletionSource.java b/bolts-tasks/src/main/java/com/anchorfree/bolts/TaskCompletionSource.java
index 0da5f83..615a509 100644
--- a/bolts-tasks/src/main/java/com/anchorfree/bolts/TaskCompletionSource.java
+++ b/bolts-tasks/src/main/java/com/anchorfree/bolts/TaskCompletionSource.java
@@ -1,5 +1,8 @@
 package com.anchorfree.bolts;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
 /**
  * Allows safe orchestration of a task's completion, preventing the consumer from prematurely
  * completing the task. Essentially, it represents the producer side of a Task<TResult>, providing
@@ -8,7 +11,7 @@
  */
 public class TaskCompletionSource<TResult> {
 
-  private final Task<TResult> task;
+  @NonNull private final Task<TResult> task;
 
   /**
    * Creates a TaskCompletionSource that orchestrates a Task. This allows the creator of a task to
@@ -21,6 +24,7 @@ public TaskCompletionSource() {
   /**
    * @return the Task associated with this TaskCompletionSource.
    */
+  @NonNull
   public Task<TResult> getTask() {
     return task;
   }
@@ -35,7 +39,7 @@ public boolean trySetCancelled() {
   /**
    * Sets the result on the Task if the Task hasn't already been completed.
    */
-  public boolean trySetResult(TResult result) {
+  public boolean trySetResult(@Nullable TResult result) {
     return task.trySetResult(result);
   }
 
@@ -58,7 +62,7 @@ public void setCancelled() {
   /**
    * Sets the result of the Task, throwing if the Task has already been completed.
    */
-  public void setResult(TResult result) {
+  public void setResult(@Nullable TResult result) {
     if (!trySetResult(result)) {
       throw new IllegalStateException("Cannot set the result of a completed task.");
     }
diff --git a/bolts-tasks/src/main/java/com/anchorfree/bolts/UnobservedErrorNotifier.java b/bolts-tasks/src/main/java/com/anchorfree/bolts/UnobservedErrorNotifier.java
index e5aa045..1813e01 100644
--- a/bolts-tasks/src/main/java/com/anchorfree/bolts/UnobservedErrorNotifier.java
+++ b/bolts-tasks/src/main/java/com/anchorfree/bolts/UnobservedErrorNotifier.java
@@ -1,12 +1,14 @@
 package com.anchorfree.bolts;
 
+import android.support.annotation.Nullable;
+
 /**
  * This class is used to retain a faulted task until either its error is observed or it is
  * finalized. If it is finalized with a task, then the uncaught exception handler is exected
  * with an UnobservedTaskException.
  */
 class UnobservedErrorNotifier {
-  private Task<?> task;
+  @Nullable private Task<?> task;
 
   public UnobservedErrorNotifier(Task<?> task) {
       this.task = task;
diff --git a/bolts-tasks/src/test/java/com/anchorfree/bolts/TaskTest.java b/bolts-tasks/src/test/java/com/anchorfree/bolts/TaskTest.java
index c71680c..f08b4e6 100644
--- a/bolts-tasks/src/test/java/com/anchorfree/bolts/TaskTest.java
+++ b/bolts-tasks/src/test/java/com/anchorfree/bolts/TaskTest.java
@@ -9,6 +9,8 @@
  */
 package com.anchorfree.bolts;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import com.anchorfree.bolts.AggregateException;
 import com.anchorfree.bolts.CancellationToken;
 import com.anchorfree.bolts.CancellationTokenSource;
@@ -40,10 +42,10 @@
 
 public class TaskTest {
 
-  @Rule
+  @NonNull @Rule
   public ExpectedException thrown = ExpectedException.none();
 
-  private void runTaskTest(Callable<Task<?>> callable) {
+  private void runTaskTest(@NonNull Callable<Task<?>> callable) {
     try {
       Task<?> task = callable.call();
       task.waitForCompletion();
@@ -130,7 +132,8 @@ public void testSynchronousContinuation() {
     final Task<Integer> cancelled = Task.cancelled();
 
     complete.continueWith(new Continuation<Integer, Void>() {
-      public Void then(Task<Integer> task) {
+      @Nullable
+      public Void then(@NonNull Task<Integer> task) {
         assertEquals(complete, task);
         assertTrue(task.isCompleted());
         assertEquals(5, task.getResult().intValue());
@@ -141,7 +144,8 @@ public Void then(Task<Integer> task) {
     });
 
     error.continueWith(new Continuation<Integer, Void>() {
-      public Void then(Task<Integer> task) {
+      @Nullable
+      public Void then(@NonNull Task<Integer> task) {
         assertEquals(error, task);
         assertTrue(task.isCompleted());
         assertTrue(task.getError() instanceof RuntimeException);
@@ -152,6 +156,7 @@ public Void then(Task<Integer> task) {
     });
 
     cancelled.continueWith(new Continuation<Integer, Void>() {
+      @Nullable
       public Void then(Task<Integer> task) {
         assertEquals(cancelled, task);
         assertTrue(cancelled.isCompleted());
@@ -166,11 +171,13 @@ public Void then(Task<Integer> task) {
   public void testSynchronousChaining() {
     Task<Integer> first = Task.forResult(1);
     Task<Integer> second = first.continueWith(new Continuation<Integer, Integer>() {
+      @NonNull
       public Integer then(Task<Integer> task) {
         return 2;
       }
     });
     Task<Integer> third = second.continueWithTask(new Continuation<Integer, Task<Integer>>() {
+      @Nullable
       public Task<Integer> then(Task<Integer> task) {
         return Task.forResult(3);
       }
@@ -187,6 +194,7 @@ public Integer then(Task<Integer> task) {
   public void testSynchronousCancellation() {
     Task<Integer> first = Task.forResult(1);
     Task<Integer> second = first.continueWith(new Continuation<Integer, Integer>() {
+      @NonNull
       public Integer then(Task<Integer> task) {
         throw new CancellationException();
       }
@@ -202,6 +210,7 @@ public void testSynchronousContinuationTokenAlreadyCancelled() {
     cts.cancel();
     Task<Integer> first = Task.forResult(1);
     Task<Integer> second = first.continueWith(new Continuation<Integer, Integer>() {
+      @NonNull
       public Integer then(Task<Integer> task) {
         continuationRun.set(true);
         return 2;
@@ -216,6 +225,7 @@ public Integer then(Task<Integer> task) {
   public void testSynchronousTaskCancellation() {
     Task<Integer> first = Task.forResult(1);
     Task<Integer> second = first.continueWithTask(new Continuation<Integer, Task<Integer>>() {
+      @NonNull
       public Task<Integer> then(Task<Integer> task) {
         throw new CancellationException();
       }
@@ -227,14 +237,17 @@ public void testSynchronousTaskCancellation() {
   @Test
   public void testBackgroundCall() {
     runTaskTest(new Callable<Task<?>>() {
+      @NonNull
       public Task<?> call() throws Exception {
         return Task.callInBackground(new Callable<Integer>() {
+          @NonNull
           public Integer call() throws Exception {
             Thread.sleep(100);
             return 5;
           }
         }).continueWith(new Continuation<Integer, Void>() {
-          public Void then(Task<Integer> task) {
+          @Nullable
+          public Void then(@NonNull Task<Integer> task) {
             assertEquals(5, task.getResult().intValue());
             return null;
           }
@@ -251,6 +264,7 @@ public void testBackgroundCallTokenCancellation() {
     final Object cancelLock = new Object();
 
     Task<Integer> task = Task.callInBackground(new Callable<Integer>() {
+      @NonNull
       @Override
       public Integer call() throws Exception {
         synchronized (cancelLock) {
@@ -292,14 +306,17 @@ public void testBackgroundCallTokenAlreadyCancelled() {
 
     cts.cancel();
     runTaskTest(new Callable<Task<?>>() {
+      @NonNull
       public Task<?> call() throws Exception {
         return Task.callInBackground(new Callable<Integer>() {
+          @NonNull
           public Integer call() throws Exception {
             Thread.sleep(100);
             return 5;
           }
         }, cts.getToken()).continueWith(new Continuation<Integer, Void>() {
-          public Void then(Task<Integer> task) {
+          @Nullable
+          public Void then(@NonNull Task<Integer> task) {
             assertTrue(task.isCancelled());
             return null;
           }
@@ -311,6 +328,7 @@ public Void then(Task<Integer> task) {
   @Test
   public void testBackgroundCallWaiting() throws Exception {
     Task<Integer> task = Task.callInBackground(new Callable<Integer>() {
+      @NonNull
       public Integer call() throws Exception {
         Thread.sleep(100);
         return 5;
@@ -326,6 +344,7 @@ public void testBackgroundCallWaitingWithTimeouts() throws Exception {
     final Object sync = new Object();
 
     Task<Integer> task = Task.callInBackground(new Callable<Integer>() {
+      @NonNull
       public Integer call() throws Exception {
         synchronized (sync) {
           sync.wait();
@@ -349,6 +368,7 @@ public Integer call() throws Exception {
   @Test
   public void testBackgroundCallWaitingOnError() throws Exception {
     Task<Integer> task = Task.callInBackground(new Callable<Integer>() {
+      @NonNull
       public Integer call() throws Exception {
         Thread.sleep(100);
         throw new RuntimeException();
@@ -362,12 +382,14 @@ public Integer call() throws Exception {
   @Test
   public void testBackgroundCallWaitOnCancellation() throws Exception {
     Task<Integer> task = Task.callInBackground(new Callable<Integer>() {
+      @NonNull
       public Integer call() throws Exception {
         Thread.sleep(100);
         return 5;
       }
     }).continueWithTask(new Continuation<Integer, Task<Integer>>() {
 
+      @NonNull
       public Task<Integer> then(Task<Integer> task) {
         return Task.cancelled();
       }
@@ -380,13 +402,16 @@ public Integer call() throws Exception {
   @Test
   public void testBackgroundError() {
     runTaskTest(new Callable<Task<?>>() {
+      @NonNull
       public Task<?> call() throws Exception {
         return Task.callInBackground(new Callable<Integer>() {
+          @NonNull
           public Integer call() throws Exception {
             throw new IllegalStateException();
           }
         }).continueWith(new Continuation<Integer, Void>() {
-          public Void then(Task<Integer> task) {
+          @Nullable
+          public Void then(@NonNull Task<Integer> task) {
             assertTrue(task.isFaulted());
             assertTrue(task.getError() instanceof IllegalStateException);
             return null;
@@ -399,13 +424,16 @@ public Void then(Task<Integer> task) {
   @Test
   public void testBackgroundCancellation() {
     runTaskTest(new Callable<Task<?>>() {
+      @NonNull
       public Task<?> call() throws Exception {
         return Task.callInBackground(new Callable<Void>() {
+          @NonNull
           public Void call() throws Exception {
             throw new CancellationException();
           }
         }).continueWith(new Continuation<Void, Void>() {
-          public Void then(Task<Void> task) {
+          @Nullable
+          public Void then(@NonNull Task<Void> task) {
             assertTrue(task.isCancelled());
             return null;
           }
@@ -441,6 +469,7 @@ public void unobservedException(Task<?> t, UnobservedTaskException e) {
   // runs in a separate method to ensure it is out of scope.
   private void startFailedTask() throws InterruptedException {
     Task.call(new Callable<Object>() {
+      @NonNull
       @Override
       public Object call() throws Exception {
         throw new RuntimeException();
@@ -460,10 +489,12 @@ public void testWhenAllNoTasks() {
   @Test
   public void testWhenAnyResultFirstSuccess() {
     runTaskTest(new Callable<Task<?>>() {
+      @NonNull
       @Override
       public Task<?> call() throws Exception {
         final ArrayList<Task<Integer>> tasks = new ArrayList<>();
         final Task<Integer> firstToCompleteSuccess = Task.callInBackground(new Callable<Integer>() {
+          @NonNull
           @Override
           public Integer call() throws Exception {
             Thread.sleep(50);
@@ -474,8 +505,9 @@ public Integer call() throws Exception {
         tasks.add(firstToCompleteSuccess);
         tasks.addAll(launchTasksWithRandomCompletions(5));
         return Task.whenAnyResult(tasks).continueWith(new Continuation<Task<Integer>, Void>() {
+          @Nullable
           @Override
-          public Void then(Task<Task<Integer>> task) throws Exception {
+          public Void then(@NonNull Task<Task<Integer>> task) throws Exception {
             assertTrue(task.isCompleted());
             assertFalse(task.isFaulted());
             assertFalse(task.isCancelled());
@@ -494,10 +526,12 @@ public Void then(Task<Task<Integer>> task) throws Exception {
   @Test
   public void testWhenAnyFirstSuccess() {
     runTaskTest(new Callable<Task<?>>() {
+      @NonNull
       @Override
       public Task<?> call() throws Exception {
         final ArrayList<Task<?>> tasks = new ArrayList<>();
         final Task<String> firstToCompleteSuccess = Task.callInBackground(new Callable<String>() {
+          @NonNull
           @Override
           public String call() throws Exception {
             Thread.sleep(50);
@@ -508,8 +542,9 @@ public String call() throws Exception {
         tasks.add(firstToCompleteSuccess);
         tasks.addAll(launchTasksWithRandomCompletions(5));
         return Task.whenAny(tasks).continueWith(new Continuation<Task<?>, Object>() {
+          @Nullable
           @Override
-          public Object then(Task<Task<?>> task) throws Exception {
+          public Object then(@NonNull Task<Task<?>> task) throws Exception {
             assertTrue(task.isCompleted());
             assertFalse(task.isFaulted());
             assertFalse(task.isCancelled());
@@ -529,10 +564,12 @@ public Object then(Task<Task<?>> task) throws Exception {
   public void testWhenAnyResultFirstError() {
     final Exception error = new RuntimeException("This task failed.");
     runTaskTest(new Callable<Task<?>>() {
+      @NonNull
       @Override
       public Task<?> call() throws Exception {
         final ArrayList<Task<Integer>> tasks = new ArrayList<>();
         final Task<Integer> firstToCompleteError = Task.callInBackground(new Callable<Integer>() {
+          @NonNull
           @Override
           public Integer call() throws Exception {
             Thread.sleep(50);
@@ -543,8 +580,9 @@ public Integer call() throws Exception {
         tasks.add(firstToCompleteError);
         tasks.addAll(launchTasksWithRandomCompletions(5));
         return Task.whenAnyResult(tasks).continueWith(new Continuation<Task<Integer>, Object>() {
+          @Nullable
           @Override
-          public Object then(Task<Task<Integer>> task) throws Exception {
+          public Object then(@NonNull Task<Task<Integer>> task) throws Exception {
             assertTrue(task.isCompleted());
             assertFalse(task.isFaulted());
             assertFalse(task.isCancelled());
@@ -564,10 +602,12 @@ public Object then(Task<Task<Integer>> task) throws Exception {
   public void testWhenAnyFirstError() {
     final Exception error = new RuntimeException("This task failed.");
     runTaskTest(new Callable<Task<?>>() {
+      @NonNull
       @Override
       public Task<?> call() throws Exception {
         final ArrayList<Task<?>> tasks = new ArrayList<>();
         final Task<String> firstToCompleteError = Task.callInBackground(new Callable<String>() {
+          @NonNull
           @Override
           public String call() throws Exception {
             Thread.sleep(50);
@@ -578,8 +618,9 @@ public String call() throws Exception {
         tasks.add(firstToCompleteError);
         tasks.addAll(launchTasksWithRandomCompletions(5));
         return Task.whenAny(tasks).continueWith(new Continuation<Task<?>, Object>() {
+          @Nullable
           @Override
-          public Object then(Task<Task<?>> task) throws Exception {
+          public Object then(@NonNull Task<Task<?>> task) throws Exception {
             assertTrue(task.isCompleted());
             assertFalse(task.isFaulted());
             assertFalse(task.isCancelled());
@@ -598,10 +639,12 @@ public Object then(Task<Task<?>> task) throws Exception {
   @Test
   public void testWhenAnyResultFirstCancelled() {
     runTaskTest(new Callable<Task<?>>() {
+      @NonNull
       @Override
       public Task<?> call() throws Exception {
         final ArrayList<Task<Integer>> tasks = new ArrayList<>();
         final Task<Integer> firstToCompleteCancelled = Task.callInBackground(new Callable<Integer>() {
+          @NonNull
           @Override
           public Integer call() throws Exception {
             Thread.sleep(50);
@@ -613,8 +656,9 @@ public Integer call() throws Exception {
         tasks.add(firstToCompleteCancelled);
         tasks.addAll(launchTasksWithRandomCompletions(5));
         return Task.whenAnyResult(tasks).continueWith(new Continuation<Task<Integer>, Object>() {
+          @Nullable
           @Override
-          public Object then(Task<Task<Integer>> task) throws Exception {
+          public Object then(@NonNull Task<Task<Integer>> task) throws Exception {
             assertTrue(task.isCompleted());
             assertFalse(task.isFaulted());
             assertFalse(task.isCancelled());
@@ -632,10 +676,12 @@ public Object then(Task<Task<Integer>> task) throws Exception {
   @Test
   public void testWhenAnyFirstCancelled() {
     runTaskTest(new Callable<Task<?>>() {
+      @NonNull
       @Override
       public Task<?> call() throws Exception {
         final ArrayList<Task<?>> tasks = new ArrayList<>();
         final Task<String> firstToCompleteCancelled = Task.callInBackground(new Callable<String>() {
+          @NonNull
           @Override
           public String call() throws Exception {
             Thread.sleep(50);
@@ -646,8 +692,9 @@ public String call() throws Exception {
         tasks.add(firstToCompleteCancelled);
         tasks.addAll(launchTasksWithRandomCompletions(5));
         return Task.whenAny(tasks).continueWith(new Continuation<Task<?>, Object>() {
+          @Nullable
           @Override
-          public Object then(Task<Task<?>> task) throws Exception {
+          public Object then(@NonNull Task<Task<?>> task) throws Exception {
             assertTrue(task.isCompleted());
             assertFalse(task.isFaulted());
             assertFalse(task.isCancelled());
@@ -671,10 +718,12 @@ public Object then(Task<Task<?>> task) throws Exception {
    * @param numberOfTasksToLaunch The number of tasks to launch
    * @return A collection containing all the tasks that have been launched
    */
+  @NonNull
   private Collection<Task<Integer>> launchTasksWithRandomCompletions(int numberOfTasksToLaunch ) {
     final ArrayList<Task<Integer>> tasks = new ArrayList<>();
     for (int i=0; i < numberOfTasksToLaunch; i++) {
       Task<Integer> task = Task.callInBackground(new Callable<Integer>() {
+        @NonNull
         @Override
         public Integer call() throws Exception {
           Thread.sleep((long) (500 + (Math.random() * 100)));
@@ -695,11 +744,13 @@ public Integer call() throws Exception {
   @Test
   public void testWhenAllSuccess() {
     runTaskTest(new Callable<Task<?>>() {
+      @NonNull
       @Override
       public Task<?> call() throws Exception {
         final ArrayList<Task<Void>> tasks = new ArrayList<>();
         for (int i = 0; i < 20; i++) {
           Task<Void> task = Task.callInBackground(new Callable<Void>() {
+            @Nullable
             @Override
             public Void call() throws Exception {
               Thread.sleep((long) (Math.random() * 100));
@@ -709,8 +760,9 @@ public Void call() throws Exception {
           tasks.add(task);
         }
         return Task.whenAll(tasks).continueWith(new Continuation<Void, Void>() {
+          @Nullable
           @Override
-          public Void then(Task<Void> task) {
+          public Void then(@NonNull Task<Void> task) {
             assertTrue(task.isCompleted());
             assertFalse(task.isFaulted());
             assertFalse(task.isCancelled());
@@ -730,12 +782,14 @@ public void testWhenAllOneError() {
     final Exception error = new RuntimeException("This task failed.");
 
     runTaskTest(new Callable<Task<?>>() {
+      @NonNull
       @Override
       public Task<?> call() throws Exception {
         final ArrayList<Task<Void>> tasks = new ArrayList<>();
         for (int i = 0; i < 20; i++) {
           final int number = i;
           Task<Void> task = Task.callInBackground(new Callable<Void>() {
+            @Nullable
             @Override
             public Void call() throws Exception {
               Thread.sleep((long) (Math.random() * 100));
@@ -748,8 +802,9 @@ public Void call() throws Exception {
           tasks.add(task);
         }
         return Task.whenAll(tasks).continueWith(new Continuation<Void, Void>() {
+          @Nullable
           @Override
-          public Void then(Task<Void> task) {
+          public Void then(@NonNull Task<Void> task) {
             assertTrue(task.isCompleted());
             assertTrue(task.isFaulted());
             assertFalse(task.isCancelled());
@@ -773,12 +828,14 @@ public void testWhenAllTwoErrors() {
     final Exception error1 = new RuntimeException("This task failed (1).");
 
     runTaskTest(new Callable<Task<?>>() {
+      @NonNull
       @Override
       public Task<?> call() throws Exception {
         final ArrayList<Task<Void>> tasks = new ArrayList<>();
         for (int i = 0; i < 20; i++) {
           final int number = i;
           Task<Void> task = Task.callInBackground(new Callable<Void>() {
+            @Nullable
             @Override
             public Void call() throws Exception {
               Thread.sleep((long) (number * 10));
@@ -793,8 +850,9 @@ public Void call() throws Exception {
           tasks.add(task);
         }
         return Task.whenAll(tasks).continueWith(new Continuation<Void, Void>() {
+          @Nullable
           @Override
-          public Void then(Task<Void> task) {
+          public Void then(@NonNull Task<Void> task) {
             assertTrue(task.isCompleted());
             assertTrue(task.isFaulted());
             assertFalse(task.isCancelled());
@@ -818,6 +876,7 @@ public Void then(Task<Void> task) {
   @Test
   public void testWhenAllCancel() {
     runTaskTest(new Callable<Task<?>>() {
+      @NonNull
       @Override
       public Task<?> call() throws Exception {
         final ArrayList<Task<Void>> tasks = new ArrayList<>();
@@ -826,6 +885,7 @@ public void testWhenAllCancel() {
 
           final int number = i;
           Task.callInBackground(new Callable<Void>() {
+            @Nullable
             @Override
             public Void call() throws Exception {
               Thread.sleep((long) (Math.random() * 100));
@@ -841,8 +901,9 @@ public Void call() throws Exception {
           tasks.add(tcs.getTask());
         }
         return Task.whenAll(tasks).continueWith(new Continuation<Void, Void>() {
+          @Nullable
           @Override
-          public Void then(Task<Void> task) {
+          public Void then(@NonNull Task<Void> task) {
             assertTrue(task.isCompleted());
             assertFalse(task.isFaulted());
             assertTrue(task.isCancelled());
@@ -870,6 +931,7 @@ public void testWhenAllResultNoTasks() {
   @Test
   public void testWhenAllResultSuccess() {
     runTaskTest(new Callable<Task<?>>() {
+      @NonNull
       @Override
       public Task<?> call() throws Exception {
         final List<Task<Integer>> tasks = new ArrayList<>();
@@ -885,8 +947,9 @@ public Integer call() throws Exception {
           tasks.add(task);
         }
         return Task.whenAllResult(tasks).continueWith(new Continuation<List<Integer>, Void>() {
+          @Nullable
           @Override
-          public Void then(Task<List<Integer>> task) {
+          public Void then(@NonNull Task<List<Integer>> task) {
             assertTrue(task.isCompleted());
             assertFalse(task.isFaulted());
             assertFalse(task.isCancelled());
@@ -908,6 +971,7 @@ public Void then(Task<List<Integer>> task) {
   @Test
   public void testAsyncChaining() {
     runTaskTest(new Callable<Task<?>>() {
+      @Nullable
       public Task<?> call() throws Exception {
         final ArrayList<Integer> sequence = new ArrayList<>();
         Task<Void> result = Task.forResult(null);
@@ -916,6 +980,7 @@ public void testAsyncChaining() {
           result = result.continueWithTask(new Continuation<Void, Task<Void>>() {
             public Task<Void> then(Task<Void> task) {
               return Task.callInBackground(new Callable<Void>() {
+                @Nullable
                 public Void call() throws Exception {
                   sequence.add(taskNumber);
                   return null;
@@ -925,6 +990,7 @@ public Void call() throws Exception {
           });
         }
         result = result.continueWith(new Continuation<Void, Void>() {
+          @Nullable
           public Void then(Task<Void> task) {
             assertEquals(20, sequence.size());
             for (int i = 0; i < 20; i++) {
@@ -968,6 +1034,7 @@ public Integer then(Task<Integer> task) {
   @Test
   public void testOnSuccessTask() {
     Continuation<Integer, Task<Integer>> continuation = new Continuation<Integer, Task<Integer>>() {
+      @Nullable
       public Task<Integer> then(Task<Integer> task) {
         return Task.forResult(task.getResult() + 1);
       }
@@ -996,17 +1063,21 @@ public void testOnSuccessTask() {
   public void testContinueWhile() {
     final AtomicInteger count = new AtomicInteger(0);
     runTaskTest(new Callable<Task<?>>() {
+      @NonNull
       public Task<?> call() throws Exception {
         return Task.forResult(null).continueWhile(new Callable<Boolean>() {
+          @NonNull
           public Boolean call() throws Exception {
             return count.get() < 10;
           }
         }, new Continuation<Void, Task<Void>>() {
+          @Nullable
           public Task<Void> then(Task<Void> task) throws Exception {
             count.incrementAndGet();
             return null;
           }
         }).continueWith(new Continuation<Void, Void>() {
+          @Nullable
           public Void then(Task<Void> task) throws Exception {
             assertEquals(10, count.get());
             return null;
@@ -1020,17 +1091,21 @@ public Void then(Task<Void> task) throws Exception {
   public void testContinueWhileAsync() {
     final AtomicInteger count = new AtomicInteger(0);
     runTaskTest(new Callable<Task<?>>() {
+      @NonNull
       public Task<?> call() throws Exception {
         return Task.forResult(null).continueWhile(new Callable<Boolean>() {
+          @NonNull
           public Boolean call() throws Exception {
             return count.get() < 10;
           }
         }, new Continuation<Void, Task<Void>>() {
+          @Nullable
           public Task<Void> then(Task<Void> task) throws Exception {
             count.incrementAndGet();
             return null;
           }
         }, Executors.newCachedThreadPool()).continueWith(new Continuation<Void, Void>() {
+          @Nullable
           public Void then(Task<Void> task) throws Exception {
             assertEquals(10, count.get());
             return null;
@@ -1045,12 +1120,15 @@ public void testContinueWhileAsyncCancellation() {
     final AtomicInteger count = new AtomicInteger(0);
     final CancellationTokenSource cts = new CancellationTokenSource();
     runTaskTest(new Callable<Task<?>>() {
+      @NonNull
       public Task<?> call() throws Exception {
         return Task.forResult(null).continueWhile(new Callable<Boolean>() {
+                                                    @NonNull
                                                     public Boolean call() throws Exception {
                                                       return count.get() < 10;
                                                     }
                                                   }, new Continuation<Void, Task<Void>>() {
+                                                    @Nullable
                                                     public Task<Void> then(Task<Void> task)
                                                         throws Exception {
                                                       if (count.incrementAndGet() == 5) {
@@ -1060,7 +1138,8 @@ public Boolean call() throws Exception {
                                                     }
                                                   }, Executors.newCachedThreadPool(),
             cts.getToken()).continueWith(new Continuation<Void, Void>() {
-          public Void then(Task<Void> task) throws Exception {
+          @Nullable
+          public Void then(@NonNull Task<Void> task) throws Exception {
             assertTrue(task.isCancelled());
             assertEquals(5, count.get());
             return null;
@@ -1075,6 +1154,7 @@ public void testCallWithBadExecutor() {
     final RuntimeException exception = new RuntimeException("BAD EXECUTORS");
 
     Task.call(new Callable<Integer>() {
+      @NonNull
       public Integer call() throws Exception {
         return 1;
       }
@@ -1084,8 +1164,9 @@ public void execute(Runnable command) {
         throw exception;
       }
     }).continueWith(new Continuation<Integer, Object>() {
+      @Nullable
       @Override
-      public Object then(Task<Integer> task) throws Exception {
+      public Object then(@NonNull Task<Integer> task) throws Exception {
         assertTrue(task.isFaulted());
         assertTrue(task.getError() instanceof ExecutorException);
         assertEquals(exception, task.getError().getCause());
@@ -1100,12 +1181,13 @@ public void testContinueWithBadExecutor() {
     final RuntimeException exception = new RuntimeException("BAD EXECUTORS");
 
     Task.call(new Callable<Integer>() {
+      @NonNull
       public Integer call() throws Exception {
         return 1;
       }
     }).continueWith(new Continuation<Integer, Integer>() {
       @Override
-      public Integer then(Task<Integer> task) throws Exception {
+      public Integer then(@NonNull Task<Integer> task) throws Exception {
         return task.getResult();
       }
     }, new Executor() {
@@ -1114,8 +1196,9 @@ public void execute(Runnable command) {
         throw exception;
       }
     }).continueWith(new Continuation<Integer, Object>() {
+      @Nullable
       @Override
-      public Object then(Task<Integer> task) throws Exception {
+      public Object then(@NonNull Task<Integer> task) throws Exception {
         assertTrue(task.isFaulted());
         assertTrue(task.getError() instanceof ExecutorException);
         assertEquals(exception, task.getError().getCause());
@@ -1130,6 +1213,7 @@ public void testContinueWithTaskAndBadExecutor() {
     final RuntimeException exception = new RuntimeException("BAD EXECUTORS");
 
     Task.call(new Callable<Integer>() {
+      @NonNull
       public Integer call() throws Exception {
         return 1;
       }
@@ -1144,8 +1228,9 @@ public void execute(Runnable command) {
         throw exception;
       }
     }).continueWith(new Continuation<Integer, Object>() {
+      @Nullable
       @Override
-      public Object then(Task<Integer> task) throws Exception {
+      public Object then(@NonNull Task<Integer> task) throws Exception {
         assertTrue(task.isFaulted());
         assertTrue(task.getError() instanceof ExecutorException);
         assertEquals(exception, task.getError().getCause());
diff --git a/build.gradle b/build.gradle
index 59d8a3b..e8bde74 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,23 +1,30 @@
 // Top-level build file where you can add configuration options common to all sub-projects/modules.
 buildscript {
     repositories {
+        google()
+        gradlePluginPortal()
+        maven { url 'https://jitpack.io' }
         mavenCentral()
+        jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.3.3'
+        classpath 'com.android.tools.build:gradle:3.4.0'
         classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.0.1x'
     }
 }
 
 allprojects {
     repositories {
+        google()
+        gradlePluginPortal()
+        maven { url 'https://jitpack.io' }
         mavenCentral()
+        jcenter()
     }
 }
 
 ext {
-    compileSdkVersion = 23
-    buildToolsVersion = "25.0.0"
+    compileSdkVersion = 28
 
     minSdkVersion = 8
     targetSdkVersion = 23
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index a9f4e54..3f211c3 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-5.1.1-all.zip
