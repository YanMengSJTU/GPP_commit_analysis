diff --git a/bolts-android/src/main/java/bolts/AndroidExecutors.java b/bolts-android/src/main/java/bolts/AndroidExecutors.java
new file mode 100644
index 0000000..e814616
--- /dev/null
+++ b/bolts-android/src/main/java/bolts/AndroidExecutors.java
@@ -0,0 +1,212 @@
+/*
+ *  Copyright (c) 2014, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+package bolts;
+
+import android.annotation.SuppressLint;
+import android.os.Build;
+import android.os.Handler;
+import android.os.Looper;
+
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * This was created because the helper methods in {@link java.util.concurrent.Executors} do not work
+ * as people would normally expect.
+ * Normally, you would think that a cached thread pool would create new threads when necessary,
+ * queue them when the pool is full, and kill threads when they've been inactive for a certain
+ * period of time. This is not how {@link java.util.concurrent.Executors#newCachedThreadPool()}
+ * works.
+ * Instead, {@link java.util.concurrent.Executors#newCachedThreadPool()} executes all tasks on
+ * a new or cached thread immediately because corePoolSize is 0, SynchronousQueue is a queue with
+ * size 0 and maxPoolSize is Integer.MAX_VALUE. This is dangerous because it can create an unchecked
+ * amount of threads.
+ */
+public final class AndroidExecutors implements BoltsExecutors {
+
+    /* package */ static final long KEEP_ALIVE_TIME = 1L;
+    private static final AndroidExecutors INSTANCE = new AndroidExecutors();
+    /**
+     * Nexus 5: Quad-Core
+     * Moto X: Dual-Core
+     * AsyncTask:
+     * CORE_POOL_SIZE = CPU_COUNT + 1
+     * MAX_POOL_SIZE = CPU_COUNT * 2 + 1
+     * https://github.com/android/platform_frameworks_base/commit/719c44e03b97e850a46136ba336d729f5fbd1f47
+     */
+    private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
+    /* package */ static final int CORE_POOL_SIZE = CPU_COUNT + 1;
+    /* package */ static final int MAX_POOL_SIZE = CPU_COUNT * 2 + 1;
+
+    private final Executor uiThread;
+    private final ExecutorService background;
+    private final ScheduledExecutorService scheduled;
+    private final Executor immediate;
+
+    private AndroidExecutors() {
+        uiThread = new UIThreadExecutor();
+        background = newCachedThreadPool();
+        scheduled = Executors.newSingleThreadScheduledExecutor();
+        immediate = new ImmediateExecutor(background);
+    }
+
+    /**
+     * Creates a proper Cached Thread Pool. Tasks will reuse cached threads if available
+     * or create new threads until the core pool is full. tasks will then be queued. If an
+     * task cannot be queued, a new thread will be created unless this would exceed max pool
+     * size, then the task will be rejected. Threads will time out after 1 second.
+     * Core thread timeout is only available on android-9+.
+     *
+     * @return the newly created thread pool
+     */
+    public static ExecutorService newCachedThreadPool() {
+        ThreadPoolExecutor executor = new ThreadPoolExecutor(
+                CORE_POOL_SIZE,
+                MAX_POOL_SIZE,
+                KEEP_ALIVE_TIME, TimeUnit.SECONDS,
+                new LinkedBlockingQueue<Runnable>());
+
+        allowCoreThreadTimeout(executor, true);
+
+        return executor;
+    }
+
+    /**
+     * Creates a proper Cached Thread Pool. Tasks will reuse cached threads if available
+     * or create new threads until the core pool is full. tasks will then be queued. If an
+     * task cannot be queued, a new thread will be created unless this would exceed max pool
+     * size, then the task will be rejected. Threads will time out after 1 second.
+     * Core thread timeout is only available on android-9+.
+     *
+     * @param threadFactory the factory to use when creating new threads
+     * @return the newly created thread pool
+     */
+    public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
+        ThreadPoolExecutor executor = new ThreadPoolExecutor(
+                CORE_POOL_SIZE,
+                MAX_POOL_SIZE,
+                KEEP_ALIVE_TIME, TimeUnit.SECONDS,
+                new LinkedBlockingQueue<Runnable>(),
+                threadFactory);
+
+        allowCoreThreadTimeout(executor, true);
+
+        return executor;
+    }
+
+    /**
+     * Compatibility helper function for
+     * {@link java.util.concurrent.ThreadPoolExecutor#allowCoreThreadTimeOut(boolean)}
+     * Only available on android-9+.
+     *
+     * @param executor the {@link java.util.concurrent.ThreadPoolExecutor}
+     * @param value    true if should time out, else false
+     */
+    @SuppressLint("NewApi")
+    public static void allowCoreThreadTimeout(ThreadPoolExecutor executor, boolean value) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {
+            executor.allowCoreThreadTimeOut(value);
+        }
+    }
+
+    @Override
+    public ScheduledExecutorService scheduled() {
+        return scheduled;
+    }
+
+    @Override
+    public Executor immediate() {
+        return immediate;
+    }
+
+    @Override
+    public Executor background() {
+        return background;
+    }
+
+    @Override
+    public Executor uiTread() {
+        return uiThread;
+    }
+
+    /**
+     * An {@link java.util.concurrent.Executor} that runs tasks on the UI thread.
+     */
+    private static class UIThreadExecutor implements Executor {
+        @Override
+        public void execute(Runnable command) {
+            new Handler(Looper.getMainLooper()).post(command);
+        }
+    }
+
+    private static class ImmediateExecutor implements Executor {
+        private static final int MAX_DEPTH = 15;
+        private ThreadLocal<Integer> executionDepth = new ThreadLocal<>();
+        private ExecutorService background;
+
+        public ImmediateExecutor(ExecutorService background) {
+            this.background = background;
+        }
+
+        /**
+         * Increments the depth.
+         *
+         * @return the new depth value.
+         */
+        private int incrementDepth() {
+            Integer oldDepth = executionDepth.get();
+            if (oldDepth == null) {
+                oldDepth = 0;
+            }
+            int newDepth = oldDepth + 1;
+            executionDepth.set(newDepth);
+            return newDepth;
+        }
+
+        /**
+         * Decrements the depth.
+         *
+         * @return the new depth value.
+         */
+        private int decrementDepth() {
+            Integer oldDepth = executionDepth.get();
+            if (oldDepth == null) {
+                oldDepth = 0;
+            }
+            int newDepth = oldDepth - 1;
+            if (newDepth == 0) {
+                executionDepth.remove();
+            } else {
+                executionDepth.set(newDepth);
+            }
+            return newDepth;
+        }
+
+        @Override
+        public void execute(Runnable command) {
+            int depth = incrementDepth();
+            try {
+                if (depth <= MAX_DEPTH) {
+                    command.run();
+                } else {
+                    background.execute(command);
+                }
+            } finally {
+                decrementDepth();
+            }
+        }
+    }
+}
diff --git a/bolts-tasks/src/main/java/bolts/AndroidExecutors.java b/bolts-tasks/src/main/java/bolts/AndroidExecutors.java
deleted file mode 100644
index 483776a..0000000
--- a/bolts-tasks/src/main/java/bolts/AndroidExecutors.java
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- *  Copyright (c) 2014, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- *
- */
-package bolts;
-
-import android.annotation.SuppressLint;
-import android.os.Build;
-import android.os.Handler;
-import android.os.Looper;
-
-import java.util.concurrent.Executor;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-
-/**
- * This was created because the helper methods in {@link java.util.concurrent.Executors} do not work
- * as people would normally expect.
- *
- * Normally, you would think that a cached thread pool would create new threads when necessary,
- * queue them when the pool is full, and kill threads when they've been inactive for a certain
- * period of time. This is not how {@link java.util.concurrent.Executors#newCachedThreadPool()}
- * works.
- *
- * Instead, {@link java.util.concurrent.Executors#newCachedThreadPool()} executes all tasks on
- * a new or cached thread immediately because corePoolSize is 0, SynchronousQueue is a queue with
- * size 0 and maxPoolSize is Integer.MAX_VALUE. This is dangerous because it can create an unchecked
- * amount of threads.
- */
-/* package */ final class AndroidExecutors {
-
-  private static final AndroidExecutors INSTANCE = new AndroidExecutors();
-
-  private final Executor uiThread;
-
-  private AndroidExecutors() {
-    uiThread = new UIThreadExecutor();
-  }
-
-  /**
-   * Nexus 5: Quad-Core
-   * Moto X: Dual-Core
-   *
-   * AsyncTask:
-   *   CORE_POOL_SIZE = CPU_COUNT + 1
-   *   MAX_POOL_SIZE = CPU_COUNT * 2 + 1
-   *
-   * https://github.com/android/platform_frameworks_base/commit/719c44e03b97e850a46136ba336d729f5fbd1f47
-   */
-  private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
-  /* package */ static final int CORE_POOL_SIZE = CPU_COUNT + 1;
-  /* package */ static final int MAX_POOL_SIZE = CPU_COUNT * 2 + 1;
-  /* package */ static final long KEEP_ALIVE_TIME = 1L;
-
-  /**
-   * Creates a proper Cached Thread Pool. Tasks will reuse cached threads if available
-   * or create new threads until the core pool is full. tasks will then be queued. If an
-   * task cannot be queued, a new thread will be created unless this would exceed max pool
-   * size, then the task will be rejected. Threads will time out after 1 second.
-   *
-   * Core thread timeout is only available on android-9+.
-   *
-   * @return the newly created thread pool
-   */
-  public static ExecutorService newCachedThreadPool() {
-    ThreadPoolExecutor executor =  new ThreadPoolExecutor(
-        CORE_POOL_SIZE,
-        MAX_POOL_SIZE,
-        KEEP_ALIVE_TIME, TimeUnit.SECONDS,
-        new LinkedBlockingQueue<Runnable>());
-
-    allowCoreThreadTimeout(executor, true);
-
-    return executor;
-  }
-
-  /**
-   * Creates a proper Cached Thread Pool. Tasks will reuse cached threads if available
-   * or create new threads until the core pool is full. tasks will then be queued. If an
-   * task cannot be queued, a new thread will be created unless this would exceed max pool
-   * size, then the task will be rejected. Threads will time out after 1 second.
-   *
-   * Core thread timeout is only available on android-9+.
-   *
-   * @param threadFactory the factory to use when creating new threads
-   * @return the newly created thread pool
-   */
-  public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
-    ThreadPoolExecutor executor =  new ThreadPoolExecutor(
-            CORE_POOL_SIZE,
-            MAX_POOL_SIZE,
-            KEEP_ALIVE_TIME, TimeUnit.SECONDS,
-            new LinkedBlockingQueue<Runnable>(),
-            threadFactory);
-
-    allowCoreThreadTimeout(executor, true);
-
-    return executor;
-  }
-
-  /**
-   * Compatibility helper function for
-   * {@link java.util.concurrent.ThreadPoolExecutor#allowCoreThreadTimeOut(boolean)}
-   *
-   * Only available on android-9+.
-   *
-   * @param executor the {@link java.util.concurrent.ThreadPoolExecutor}
-   * @param value true if should time out, else false
-   */
-  @SuppressLint("NewApi")
-  public static void allowCoreThreadTimeout(ThreadPoolExecutor executor, boolean value) {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {
-      executor.allowCoreThreadTimeOut(value);
-    }
-  }
-
-  /**
-   * An {@link java.util.concurrent.Executor} that executes tasks on the UI thread.
-   */
-  public static Executor uiThread() {
-    return INSTANCE.uiThread;
-  }
-
-  /**
-   * An {@link java.util.concurrent.Executor} that runs tasks on the UI thread.
-   */
-  private static class UIThreadExecutor implements Executor {
-    @Override
-    public void execute(Runnable command) {
-      new Handler(Looper.getMainLooper()).post(command);
-    }
-  }
-}
diff --git a/bolts-tasks/src/main/java/bolts/BoltsExecutors.java b/bolts-tasks/src/main/java/bolts/BoltsExecutors.java
index cbab41a..c351093 100644
--- a/bolts-tasks/src/main/java/bolts/BoltsExecutors.java
+++ b/bolts-tasks/src/main/java/bolts/BoltsExecutors.java
@@ -1,114 +1,11 @@
 package bolts;
 
-import java.util.Locale;
 import java.util.concurrent.Executor;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 
-/**
- * Collection of {@link Executor}s to use in conjunction with {@link Task}.
- */
-/* package */ final class BoltsExecutors {
-
-  private static final BoltsExecutors INSTANCE = new BoltsExecutors();
-
-  private static boolean isAndroidRuntime() {
-    String javaRuntimeName = System.getProperty("java.runtime.name");
-    if (javaRuntimeName == null) {
-      return false;
-    }
-    return javaRuntimeName.toLowerCase(Locale.US).contains("android");
-  }
-
-  private final ExecutorService background;
-  private final ScheduledExecutorService scheduled;
-  private final Executor immediate;
-
-  private BoltsExecutors() {
-    background = !isAndroidRuntime()
-        ? java.util.concurrent.Executors.newCachedThreadPool()
-        : AndroidExecutors.newCachedThreadPool();
-    scheduled = Executors.newSingleThreadScheduledExecutor();
-    immediate = new ImmediateExecutor();
-  }
-
-  /**
-   * An {@link java.util.concurrent.Executor} that executes tasks in parallel.
-   */
-  public static ExecutorService background() {
-    return INSTANCE.background;
-  }
-
-  /* package */ static ScheduledExecutorService scheduled() {
-    return INSTANCE.scheduled;
-  }
-
-  /**
-   * An {@link java.util.concurrent.Executor} that executes tasks in the current thread unless
-   * the stack runs too deep, at which point it will delegate to {@link BoltsExecutors#background}
-   * in order to trim the stack.
-   */
-  /* package */ static Executor immediate() {
-    return INSTANCE.immediate;
-  }
-
-  /**
-   * An {@link java.util.concurrent.Executor} that runs a runnable inline (rather than scheduling it
-   * on a thread pool) as long as the recursion depth is less than MAX_DEPTH. If the executor has
-   * recursed too deeply, it will instead delegate to the {@link Task#BACKGROUND_EXECUTOR} in order
-   * to trim the stack.
-   */
-  private static class ImmediateExecutor implements Executor {
-    private static final int MAX_DEPTH = 15;
-    private ThreadLocal<Integer> executionDepth = new ThreadLocal<>();
-
-    /**
-     * Increments the depth.
-     *
-     * @return the new depth value.
-     */
-    private int incrementDepth() {
-      Integer oldDepth = executionDepth.get();
-      if (oldDepth == null) {
-        oldDepth = 0;
-      }
-      int newDepth = oldDepth + 1;
-      executionDepth.set(newDepth);
-      return newDepth;
-    }
-
-    /**
-     * Decrements the depth.
-     *
-     * @return the new depth value.
-     */
-    private int decrementDepth() {
-      Integer oldDepth = executionDepth.get();
-      if (oldDepth == null) {
-        oldDepth = 0;
-      }
-      int newDepth = oldDepth - 1;
-      if (newDepth == 0) {
-        executionDepth.remove();
-      } else {
-        executionDepth.set(newDepth);
-      }
-      return newDepth;
-    }
-
-    @Override
-    public void execute(Runnable command) {
-      int depth = incrementDepth();
-      try {
-        if (depth <= MAX_DEPTH) {
-          command.run();
-        } else {
-          BoltsExecutors.background().execute(command);
-        }
-      } finally {
-        decrementDepth();
-      }
-    }
-  }
+public interface BoltsExecutors {
+    ScheduledExecutorService scheduled();
+    Executor immediate();
+    Executor background();
+    Executor uiTread();
 }
diff --git a/bolts-tasks/src/main/java/bolts/CancellationTokenSource.java b/bolts-tasks/src/main/java/bolts/CancellationTokenSource.java
index 4714362..fe2068f 100644
--- a/bolts-tasks/src/main/java/bolts/CancellationTokenSource.java
+++ b/bolts-tasks/src/main/java/bolts/CancellationTokenSource.java
@@ -30,7 +30,7 @@
 
   private final Object lock = new Object();
   private final List<CancellationTokenRegistration> registrations = new ArrayList<>();
-  private final ScheduledExecutorService executor = BoltsExecutors.scheduled();
+  private final ScheduledExecutorService executor = Task.SCHEDULED_EXECUTOR;
   private ScheduledFuture<?> scheduledCancellation;
   private boolean cancellationRequested;
   private boolean closed;
diff --git a/bolts-tasks/src/main/java/bolts/Task.java b/bolts-tasks/src/main/java/bolts/Task.java
index d6bf6a2..b46c22f 100644
--- a/bolts-tasks/src/main/java/bolts/Task.java
+++ b/bolts-tasks/src/main/java/bolts/Task.java
@@ -16,7 +16,6 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.Executor;
-import java.util.concurrent.ExecutorService;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
@@ -30,22 +29,25 @@
  *          The type of the result of the task.
  */
 public class Task<TResult> {
+  public static BoltsExecutors boltsExecutors;
   /**
    * An {@link java.util.concurrent.Executor} that executes tasks in parallel.
    */
-  public static final ExecutorService BACKGROUND_EXECUTOR = BoltsExecutors.background();
+  public static Executor BACKGROUND_EXECUTOR;
 
   /**
    * An {@link java.util.concurrent.Executor} that executes tasks in the current thread unless
    * the stack runs too deep, at which point it will delegate to {@link Task#BACKGROUND_EXECUTOR} in
    * order to trim the stack.
    */
-  private static final Executor IMMEDIATE_EXECUTOR = BoltsExecutors.immediate();
+  private static Executor IMMEDIATE_EXECUTOR;
 
   /**
    * An {@link java.util.concurrent.Executor} that executes tasks on the UI thread.
    */
-  public static final Executor UI_THREAD_EXECUTOR = AndroidExecutors.uiThread();
+  public static Executor UI_THREAD_EXECUTOR;
+
+  public static ScheduledExecutorService SCHEDULED_EXECUTOR;
 
   /**
    * Interface for handlers invoked when a failed {@code Task} is about to be
@@ -88,6 +90,14 @@ public static void setUnobservedExceptionHandler(UnobservedExceptionHandler eh)
     unobservedExceptionHandler = eh;
   }
 
+  public static void setBoltsExecutors(BoltsExecutors boltsExecutors) {
+    Task.boltsExecutors = boltsExecutors;
+    BACKGROUND_EXECUTOR = boltsExecutors.background();
+    IMMEDIATE_EXECUTOR = boltsExecutors.immediate();
+    UI_THREAD_EXECUTOR = boltsExecutors.uiTread();
+    SCHEDULED_EXECUTOR = boltsExecutors.scheduled();
+  }
+
   private final Object lock = new Object();
   private boolean complete;
   private boolean cancelled;
@@ -238,7 +248,7 @@ public boolean waitForCompletion(long duration, TimeUnit timeUnit) throws Interr
    *              negative values are treated as requests for immediate execution.
    */
   public static Task<Void> delay(long delay) {
-    return delay(delay, BoltsExecutors.scheduled(), null);
+    return delay(delay, SCHEDULED_EXECUTOR, null);
   }
 
   /**
@@ -250,7 +260,7 @@ public boolean waitForCompletion(long duration, TimeUnit timeUnit) throws Interr
    *                          completing the returned task.
    */
   public static Task<Void> delay(long delay, CancellationToken cancellationToken) {
-    return delay(delay, BoltsExecutors.scheduled(), cancellationToken);
+    return delay(delay, SCHEDULED_EXECUTOR, cancellationToken);
   }
 
   /* package */ static Task<Void> delay(long delay, ScheduledExecutorService executor, final CancellationToken cancellationToken) {
