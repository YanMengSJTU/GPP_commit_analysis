diff --git a/library/src/main/java/com/sixgreen/cube/Cube.java b/library/src/main/java/com/sixgreen/cube/Cube.java
index bb42e314..59564f57 100644
--- a/library/src/main/java/com/sixgreen/cube/Cube.java
+++ b/library/src/main/java/com/sixgreen/cube/Cube.java
@@ -2,29 +2,45 @@
 
 import android.content.Context;
 import android.database.sqlite.SQLiteDatabase;
+import android.net.Uri;
 import android.os.Build.VERSION;
 import android.os.Build.VERSION_CODES;
+import android.provider.BaseColumns;
 import android.util.Log;
 
+import com.sixgreen.cube.annotation.Table;
 import com.sixgreen.cube.support.CubeDataManager;
+import com.sixgreen.cube.util.NameUtil;
 
 /**
  * Created by bpappin on 16-08-11.
  */
-public class Cube {
+public class Cube implements BaseColumns {
     // XXX As a library, it is beneficial for the client to get log messages from a consistent tag.
     public static final String TAG = "Cube";
-    public static final String DEFAULT_ID_COLUMN = "_id";
+    //public static final String DEFAULT_ID_COLUMN = BaseColumns._ID"_id";
     private static Cube instance;
 
     private Context context;
     private CubeConfig config;
     private CubeDataManager cubeDataManager;
 
+    /**
+     * Initialize Cube.
+     *
+     * @param context
+     */
     public static void setup(Context context) {
         setup(context, CubeConfig.manifest(context));
     }
 
+    /**
+     * This init allows you to provide the configuration manually. CAuthion should be used however,
+     * because the ContentProvider will stop working.
+     *
+     * @param context
+     * @param config
+     */
     public static void setup(Context context, CubeConfig config) {
         if (instance == null) {
             instance = new Cube();
@@ -161,4 +177,22 @@ private static void finishTransaction(CubeDataManager manager) {
         sqLiteDatabase.setLockingEnabled(true);
     }
     
+    public static <T> Uri createUri(Class<T> type, Long id) {
+        final StringBuilder uri = new StringBuilder();
+        uri.append("content://");
+        uri.append(getConfig().getAuthority());
+        uri.append("/");
+        uri.append(NameUtil.toTableName(type).toLowerCase());
+
+        if (id != null) {
+            uri.append("/");
+            uri.append(id.toString());
+        }
+
+        return Uri.parse(uri.toString());
+    }
+
+    public static boolean isEntity(Class<?> fieldType) {
+        return fieldType.isAnnotationPresent(Table.class);
+    }
 }
diff --git a/library/src/main/java/com/sixgreen/cube/CubeConfig.java b/library/src/main/java/com/sixgreen/cube/CubeConfig.java
index 0c271aee..76514b0f 100644
--- a/library/src/main/java/com/sixgreen/cube/CubeConfig.java
+++ b/library/src/main/java/com/sixgreen/cube/CubeConfig.java
@@ -7,6 +7,7 @@
 import com.sixgreen.cube.support.CubeCursorFactory;
 import com.sixgreen.cube.support.CubeDataManager;
 import com.sixgreen.cube.support.CubeErrorHandler;
+import com.sixgreen.cube.support.CubeManifest;
 
 import java.lang.reflect.Field;
 import java.util.Collections;
@@ -28,10 +29,7 @@
     private final static Map<Class<?>, List<Field>> fieldCache = new HashMap<>();
 
     public static final CubeConfig manifest(Context context) {
-
-        
-
-        return null;
+        return CubeManifest.getConfig(context);
     }
 
     public boolean isDebug() {
diff --git a/library/src/main/java/com/sixgreen/cube/support/CubeDataManager.java b/library/src/main/java/com/sixgreen/cube/support/CubeDataManager.java
index 459ed4be..a1bb0945 100644
--- a/library/src/main/java/com/sixgreen/cube/support/CubeDataManager.java
+++ b/library/src/main/java/com/sixgreen/cube/support/CubeDataManager.java
@@ -1,18 +1,42 @@
 package com.sixgreen.cube.support;
 
+import android.content.ContentValues;
 import android.content.Context;
+import android.database.ContentObserver;
+import android.database.Cursor;
 import android.database.DatabaseErrorHandler;
 import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteException;
 import android.database.sqlite.SQLiteOpenHelper;
+import android.database.sqlite.SQLiteStatement;
+import android.net.Uri;
+import android.text.TextUtils;
+import android.util.Log;
 
+import com.orm.helper.NamingHelper;
+import com.sixgreen.cube.Cube;
 import com.sixgreen.cube.CubeConfig;
+import com.sixgreen.cube.annotation.Table;
+import com.sixgreen.cube.annotation.Unique;
+import com.sixgreen.cube.util.NameUtil;
+import com.sixgreen.cube.util.ReflectionUtil;
+
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.NoSuchElementException;
 
 /**
  * Created by bpappin on 16-08-23.
  */
 public class CubeDataManager extends SQLiteOpenHelper {
     private final CubeConfig config;
+    private final Map<Object, Long> entitiesMap = new HashMap<Object, Long>();
     private SQLiteDatabase database;
+    private Context context;
 
     ///**
     // * Create a helper object to create, open, and/or manage a database.
@@ -53,22 +77,9 @@ public CubeDataManager(Context context, CubeConfig config) {
         super(context, config.getDatabaseName(), config.getCursorFactory(), config
                 .getVersion(), config.getDatabaseErrorHandler());
         this.config = config;
+        this.context = context;
     }
 
-    public SQLiteDatabase getDatabase() {
-        if (database == null) {
-            database = getWritableDatabase();
-        }
-
-        return database;
-    }
-
-    //public void close() {
-    //    if (database != null) {
-    //        database.close();
-    //    }
-    //}
-
     /**
      * Called when the database is created for the first time. This is where the
      * creation of tables and the initial population of the tables should happen.
@@ -143,4 +154,451 @@ public void onReset() {
         schemaGenerator.doManualReset(getDatabase());
     }
 
+    //public void close() {
+    //    if (database != null) {
+    //        database.close();
+    //    }
+    //}
+
+    public SQLiteDatabase getDatabase() {
+        if (database == null) {
+            database = getWritableDatabase();
+        }
+
+        return database;
+    }
+
+    public Map<Object, Long> getEntitiesMap() {
+        return entitiesMap;
+    }
+
+    public CubeConfig getConfig() {
+        return config;
+    }
+
+    public Context getContext() {
+        return context;
+    }
+
+    public <T> Cursor getCursor(Class<T> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
+        Cursor raw = getDatabase()
+                .query(NameUtil.toTableName(type), null, whereClause, whereArgs,
+                        groupBy, null, orderBy, limit);
+        return raw;
+    }
+
+    private void inflate(Cursor cursor, Object entity, Map<Object, Long> entitiesMap) {
+        //if (DEBUG_CURSOR) {
+        //    Log.d(TAG, "Row Dump (inflate): " + DatabaseUtils.dumpCurrentRowToString(cursor));
+        //}
+        List<Field> columns = ReflectionUtil.getTableFields(getConfig(), entity.getClass());
+        if (!entitiesMap.containsKey(entity)) {
+            entitiesMap.put(entity, cursor.getLong(cursor.getColumnIndex(Cube._ID)));
+        }
+
+        for (Field field : columns) {
+            field.setAccessible(true);
+            Class<?> fieldType = field.getType();
+            if (Cube.isEntity(fieldType)) {
+                // This is a joined entity.
+                try {
+                    long id = cursor.getLong(cursor
+                            .getColumnIndex(Cube._ID/*NameUtil.toColumnName(field)*/));
+                    field.set(entity, (id > 0) ? load(fieldType, id) : null);
+                } catch (IllegalAccessException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                ReflectionUtil.setFieldValueFromCursor(getConfig(), cursor, field, entity);
+            }
+        }
+    }
+
+    public <T> List<T> getEntitiesFromCursor(Cursor cursor, Class<T> type) {
+        T entity;
+        List<T> result = new ArrayList<T>();
+        try {
+            while (cursor.moveToNext()) {
+                entity = type.getDeclaredConstructor().newInstance();
+                inflate(cursor, entity, getEntitiesMap());
+                result.add(entity);
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        } finally {
+            cursor.close();
+        }
+
+        return result;
+    }
+
+    public void executeQuery(String query, String... arguments) {
+        getDatabase().execSQL(query, arguments);
+    }
+
+    public <T> T first(Class<T> type) {
+        List<T> list = findWithQuery(type,
+                "SELECT * FROM " +
+                NameUtil.toTableName(type) + " ORDER BY " +
+                Cube._ID +
+                " ASC LIMIT 1");
+        if (list.isEmpty()) {
+            return null;
+        }
+        return list.get(0);
+    }
+
+    public <T> T last(Class<T> type) {
+        List<T> list = findWithQuery(type,
+                "SELECT * FROM " +
+                NameUtil.toTableName(type) + " ORDER BY " +
+                Cube._ID + " DESC LIMIT 1");
+        if (list.isEmpty()) {
+            return null;
+        }
+        return list.get(0);
+    }
+
+    public <T> T load(Class<T> type, long id) {
+        List<T> list = find(type, QueryBuilder
+                .id(), new String[]{String.valueOf(id)}, null, null, 1);
+        if (list.isEmpty()) {
+            return null;
+        }
+        return list.get(0);
+    }
+
+    public <T> List<T> load(Class<T> type, String[] ids) {
+        String whereClause =
+                Cube._ID + " IN (" + QueryBuilder.generatePlaceholders(ids.length) + ")";
+        return find(type, whereClause, ids);
+    }
+
+    public <T> List<T> find(Class<T> type, String whereClause, String... whereArgs) {
+        return find(type, whereClause, whereArgs, null, null, 0);
+    }
+
+    public <T> List<T> find(Class<T> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, int limit) {
+        Cursor cursor = null;
+        if (limit > 0) {
+            cursor = getDatabase()
+                    .query(NameUtil.toTableName(type), null, whereClause, whereArgs,
+                            groupBy, null, orderBy, Integer.toString(limit));
+            return getEntitiesFromCursor(cursor, type);
+        } else {
+            return find(type, whereClause, whereArgs, groupBy, orderBy);
+        }
+    }
+
+    public <T> List<T> find(Class<T> type, String whereClause, String[] whereArgs, String groupBy, String orderBy) {
+        Cursor cursor = getDatabase()
+                .query(NameUtil.toTableName(type), null, whereClause, whereArgs,
+                        groupBy, null, orderBy);
+
+        return getEntitiesFromCursor(cursor, type);
+    }
+
+    //public <T> T load(Class<T> type, Integer id) {
+    //    return findById(type, Long.valueOf(id));
+    //}
+
+    public long save(Object object) {
+        return save(getDatabase(), object);
+    }
+
+    long save(SQLiteDatabase db, Object object) {
+        Map<Object, Long> entitiesMap = getEntitiesMap();
+
+        List<Field> columns = ReflectionUtil.getTableFields(config, object.getClass());
+
+        ContentValues values = new ContentValues(columns.size());
+
+        Field idField = null;
+        for (Field column : columns) {
+            ReflectionUtil.addFieldValueToColumn(config, values, column, object, entitiesMap);
+            if (column.getName().equals("id")) {
+                idField = column;
+            }
+        }
+
+        boolean isSugarEntity = ReflectionUtil.isEntity(object.getClass());
+        if (isSugarEntity && entitiesMap.containsKey(object)) {
+            values.put("id", entitiesMap.get(object));
+        }
+
+        long id = db.insertWithOnConflict(NameUtil.toTableName(object.getClass()), null, values,
+                SQLiteDatabase.CONFLICT_REPLACE);
+
+        if (object.getClass().isAnnotationPresent(Table.class)) {
+            if (idField != null) {
+                idField.setAccessible(true);
+                try {
+                    idField.set(object, id);
+                } catch (IllegalAccessException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                entitiesMap.put(object, id);
+            }
+        }
+        //else if (SugarRecord.class.isAssignableFrom(object.getClass())) {
+        //    ((SugarRecord) object).setId(id);
+        //}
+
+        if (getConfig().isDebug()) {
+            Log.i(Cube.TAG, object.getClass().getSimpleName() + " saved : " + id);
+        }
+
+        return id;
+    }
+
+
+    /**
+     * Update does not automatically create a new object of the update object does not match.
+     *
+     * @param object
+     * @return long the number of records changed by this update.
+     */
+    public long update(Object object) {
+        return update(getDatabase(), object);
+    }
+
+    long update(SQLiteDatabase db, Object object) {
+        Map<Object, Long> entitiesMap = getEntitiesMap();
+        List<Field> fields = ReflectionUtil.getTableFields(getConfig(), object.getClass());
+        ContentValues values = new ContentValues(fields.size());
+
+        StringBuilder whereClause = new StringBuilder();
+        List<String> whereArgs = new ArrayList<>();
+
+        for (Field field : fields) {
+            if (field.isAnnotationPresent(Unique.class)) {
+                try {
+                    field.setAccessible(true);
+                    String columnName = NameUtil.toColumnName(field);
+                    Object columnValue = field.get(object);
+
+                    whereClause.append(QueryBuilder.column(columnName));
+                    whereArgs.add(String.valueOf(columnValue));
+                } catch (IllegalAccessException e) {
+                    //e.printStackTrace();
+                    Log.w(Cube.TAG, "Could not access field: " + field.getName(), e);
+                }
+            } else {
+                if (!field.getName().equals("id")) {
+                    ReflectionUtil
+                            .addFieldValueToColumn(getConfig(), values, field, object, entitiesMap);
+                }
+            }
+        }
+
+        String[] whereArgsArray = whereArgs.toArray(new String[whereArgs.size()]);
+        // Get SugarRecord based on Unique values
+        long rowsEffected = db.update(NameUtil.toTableName(object
+                .getClass()), values, whereClause
+                .toString(), whereArgsArray);
+
+        //if (rowsEffected == 0) {
+        //    // FIXME This is WRONG. The save method returns an ID, but this update method should
+        //    // FIXME return a count. I am not sure of the implications of changing the count to 1
+        //    // FIXME at this moment, so I'll have to come back to it. -bpappin
+        //    final long recordId = save(db, object);
+        //    return recordId;
+        //} else {
+        if (rowsEffected > 0) {
+            notifyChange(object.getClass());
+        }
+        return rowsEffected;
+        //}
+    }
+
+    public <T> void notifyChange(Class<T> type) {
+        notifyChange(Cube.createUri(type, null), null, false);
+    }
+
+    /**
+     * Shortcut to ContentResolver.notifyChange(Uri uri, ContentObserver observer, boolean
+     * syncToNetwork)
+     *
+     * @param uri
+     * @param observer
+     * @param syncToNetwork
+     */
+    public void notifyChange(Uri uri, ContentObserver observer, boolean syncToNetwork) {
+        if (getContext() != null) {
+            if (getConfig().isDebug()) {
+                Log.d(Cube.TAG, "Notify of data change: " + uri);
+            }
+            getContext().getApplicationContext().getContentResolver()
+                        .notifyChange(uri, observer, syncToNetwork);
+        } else {
+            Log.w(Cube.TAG, "Context not set. Unable to notify of data change: " + uri);
+        }
+    }
+
+
+    public boolean delete(Object object) {
+        Class<?> type = object.getClass();
+        if (type.isAnnotationPresent(Table.class)) {
+            try {
+                Field field = type.getDeclaredField("id");
+                field.setAccessible(true);
+                Long id = (Long) field.get(object);
+                if (id != null && id > 0L) {
+
+                    boolean deleted = getDatabase().delete(NameUtil.toTableName(type), QueryBuilder
+                            .id(), new String[]{
+                            id.toString()
+                    }) == 1;
+                    if (deleted) {
+                        Log.d(Cube.TAG, type.getSimpleName() + " deleted : " + id);
+                        notifyChange(type, id);
+
+                    } else {
+                        Log.w(Cube.TAG, type.getSimpleName() + " was not deleted : " + id);
+                    }
+                    return deleted;
+                } else {
+                    Log.i(Cube.TAG, "Cannot delete object: " + object.getClass().getSimpleName() +
+                                    " - object has not been saved");
+                    return false;
+                }
+            } catch (NoSuchFieldException e) {
+                Log.i(Cube.TAG, "Cannot delete object: " + object.getClass().getSimpleName() +
+                                " - annotated object has no id");
+                return false;
+            } catch (IllegalAccessException e) {
+                Log.i(Cube.TAG, "Cannot delete object: " + object.getClass().getSimpleName() +
+                                " - can't access id");
+                return false;
+            }
+            //} else if (SugarRecord.class.isAssignableFrom(type)) {
+            //    return ((SugarRecord) object).delete();
+        } else {
+            Log.i(Cube.TAG, "Cannot delete object: " + object.getClass().getSimpleName() +
+                            " - not an entity");
+            return false;
+        }
+    }
+
+    public <T> void notifyChange(Class<T> type, Long id) {
+        notifyChange(Cube.createUri(type, id), null, false);
+    }
+
+    public <T> long count(Class<?> type) {
+        return count(type, null, null, null, null, null);
+    }
+
+    public <T> long count(Class<?> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
+        long result = -1;
+        String filter = (!TextUtils.isEmpty(whereClause)) ? " where " + whereClause : "";
+        SQLiteStatement sqliteStatement;
+        try {
+            sqliteStatement = getDatabase().compileStatement(
+                    "SELECT count(*) FROM " +
+                    NameUtil.toTableName(type) + filter);
+        } catch (SQLiteException e) {
+            //e.printStackTrace();
+            Log.w(Cube.TAG, "Could not get entity count.", e);
+            return result;
+        }
+
+        if (whereArgs != null) {
+            for (int i = whereArgs.length; i != 0; i--) {
+                sqliteStatement.bindString(i, whereArgs[i - 1]);
+            }
+        }
+
+        try {
+            result = sqliteStatement.simpleQueryForLong();
+        } finally {
+            sqliteStatement.close();
+        }
+
+        return result;
+    }
+
+    public <T> long count(Class<?> type, String whereClause, String[] whereArgs) {
+        return count(type, whereClause, whereArgs, null, null, null);
+    }
+
+    public <T> void notifyChange(Class<T> type, ContentObserver observer, boolean syncToNetwork) {
+        notifyChange(Cube.createUri(type, null), observer, syncToNetwork);
+    }
+
+    public <T> void notifyChange(Class<T> type, Long id, ContentObserver observer, boolean syncToNetwork) {
+        notifyChange(Cube.createUri(type, id), observer, syncToNetwork);
+    }
+
+    public <T> List<T> findWithQuery(Class<T> type, String query, String... arguments) {
+        Cursor cursor = getDatabase().rawQuery(query, arguments);
+
+        return getEntitiesFromCursor(cursor, type);
+    }
+
+    public <T> Iterator<T> findAll(Class<T> type) {
+        return findAsIterator(type, null, null, null, null, null);
+    }
+
+    public <T> Iterator<T> findAsIterator(Class<T> type, String whereClause, String... whereArgs) {
+        return findAsIterator(type, whereClause, whereArgs, null, null, null);
+    }
+
+    public <T> Iterator<T> findWithQueryAsIterator(Class<T> type, String query, String... arguments) {
+        Cursor cursor = getDatabase().rawQuery(query, arguments);
+        return new CursorIterator<>(type, cursor);
+    }
+
+    public <T> Iterator<T> findAsIterator(Class<T> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
+        Cursor cursor = getDatabase()
+                .query(NamingHelper.toTableName(type), null, whereClause, whereArgs,
+                        groupBy, null, orderBy, limit);
+        return new CursorIterator<>(type, cursor);
+    }
+
+    class CursorIterator<E> implements Iterator<E> {
+        Class<E> type;
+        Cursor cursor;
+
+        public CursorIterator(Class<E> type, Cursor cursor) {
+            this.type = type;
+            this.cursor = cursor;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return cursor != null && !cursor.isClosed() && !cursor.isAfterLast();
+        }
+
+        @Override
+        public E next() {
+            E entity = null;
+            if (cursor == null || cursor.isAfterLast()) {
+                throw new NoSuchElementException();
+            }
+
+            if (cursor.isBeforeFirst()) {
+                cursor.moveToFirst();
+            }
+
+            try {
+                entity = type.getDeclaredConstructor().newInstance();
+                inflate(cursor, entity, getEntitiesMap());
+            } catch (Exception e) {
+                e.printStackTrace();
+            } finally {
+                cursor.moveToNext();
+                if (cursor.isAfterLast()) {
+                    cursor.close();
+                }
+            }
+
+            return entity;
+        }
+
+        @Override
+        public void remove() {
+            throw new UnsupportedOperationException();
+        }
+    }
 }
diff --git a/library/src/main/java/com/sixgreen/cube/support/CubeManifest.java b/library/src/main/java/com/sixgreen/cube/support/CubeManifest.java
index bfd24bdf..548c617c 100644
--- a/library/src/main/java/com/sixgreen/cube/support/CubeManifest.java
+++ b/library/src/main/java/com/sixgreen/cube/support/CubeManifest.java
@@ -1,15 +1,13 @@
 package com.sixgreen.cube.support;
 
+import android.content.Context;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 import android.util.Log;
 
-import com.orm.util.ContextUtil;
 import com.sixgreen.cube.Cube;
 import com.sixgreen.cube.CubeConfig;
 
-import static com.orm.util.ContextUtil.getPackageManager;
-import static com.orm.util.ContextUtil.getPackageName;
 
 /**
  * Helper class for accessing properties in the AndroidManifest
@@ -20,18 +18,24 @@
     private static boolean queryLogEnabled;
     private static boolean debugEnabled;
 
+    //<meta-data android:name="DATABASE" android:value="sugar_example.db" />
+    //<meta-data android:name="VERSION" android:value="2" />
+    //<meta-data android:name="QUERY_LOG" android:value="true" />
+
     /**
      * Key for the database name meta data.
      */
-    public final static String METADATA_DATABASE = "DATABASE";
+    public final static String METADATA_DATABASE = "CUBE_DATABASE";
 
     /**
      * Key for the database version meta data.
      */
-    public final static String METADATA_VERSION = "VERSION";
-    public final static String METADATA_DOMAIN_PACKAGE_NAME = "DOMAIN_PACKAGE_NAME";
-    public final static String METADATA_QUERY_LOG = "QUERY_LOG";
-    private static final String METADATA_DEBUG = "DEBUG_CUBE";
+    public final static String METADATA_VERSION = "CUBE_VERSION";
+    public final static String METADATA_QUERY_LOG = "CUBE_QUERY_LOG";
+    private static final String METADATA_DEBUG = "CUBE_DEBUG";
+    private static final String METADATA_AUTHORITY = "CUBE_AUTHORITY";
+    private static final String METADATA_MODEL_RESID = "CUBE_MODEL_RESID";
+    private static final String METADATA_CONFIG_CLASS = "CUBE_CONFIG_CLASS";
 
     /**
      * The default name for the database unless specified in the AndroidManifest.
@@ -43,12 +47,29 @@
     private CubeManifest() {
     }
 
-    public static CubeConfig get() {
-        final CubeManifestConfig cubeConfig = new CubeManifestConfig();
-        cubeConfig.setDebug(isDebugEnabled());
-        cubeConfig.setLogQueries(isLogQueriesEnabled());
-        cubeConfig.setDatabaseName(getDatabaseName());
-        cubeConfig.setVersion(getDatabaseVersion());
+    public static CubeConfig getConfig(Context context) {
+        Class<? extends CubeConfig> cfg = getConfigurationClass(context);
+        if(cfg != null){
+            try {
+                return cfg.newInstance();
+            } catch (Exception e) {
+                //e.printStackTrace();
+                Log.e(Cube.TAG, "Could not create new Cube Config class.", e);
+                throw new RuntimeException(e);
+            }
+        }else {
+            return getCubeConfigFromManifest(context);
+        }
+    }
+
+    private static CubeConfig getCubeConfigFromManifest(Context context) {
+        final CubeManifestConfig cubeConfig = new CubeManifestConfig(
+                getAuthority(context),
+                getDatabaseName(context),
+                getModels(context),
+                getDatabaseVersion(context));
+        cubeConfig.setDebug(isDebugEnabled(context));
+        cubeConfig.setLogQueries(isLogQueriesEnabled(context));
         return cubeConfig;
     }
 
@@ -58,8 +79,8 @@ public static CubeConfig get() {
      * @return the database version as specified by the {@link #METADATA_VERSION} version or 1 of
      * not present
      */
-    public static int getDatabaseVersion() {
-        Integer databaseVersion = getMetaDataInteger(METADATA_VERSION);
+    public static int getDatabaseVersion(Context context) {
+        Integer databaseVersion = getMetaDataInteger(context, METADATA_VERSION);
 
         if ((databaseVersion == null) || (databaseVersion == 0)) {
             databaseVersion = 1;
@@ -69,31 +90,47 @@ public static int getDatabaseVersion() {
     }
 
     /**
-     * Grabs the domain name of the model classes from the manifest.
+     * Grabs the database ContentProvider authority from the manifest.
      *
-     * @return the package String that Sugar uses to search for model classes
+     * @return the database version as specified by the {@link #METADATA_VERSION} version or 1 of
+     * not present
      */
-    public static String getDomainPackageName() {
-        String domainPackageName = getMetaDataString(METADATA_DOMAIN_PACKAGE_NAME);
+    public static String getAuthority(Context context) {
+        String authority = getMetaDataString(context, METADATA_AUTHORITY);
 
-        if (domainPackageName == null) {
-            domainPackageName = "";
-        }
+        //if ((authority == null) || (databaseVersion == 0)) {
+        //    databaseVersion = 1;
+        //}
 
-        return domainPackageName;
+        return authority;
     }
 
+    ///**
+    // * Grabs the domain name of the model classes from the manifest.
+    // *
+    // * @return the package String that Sugar uses to search for model classes
+    // */
+    //public static String getDomainPackageName(Context context) {
+    //    String domainPackageName = getMetaDataString(context, METADATA_DOMAIN_PACKAGE_NAME);
+    //
+    //    if (domainPackageName == null) {
+    //        domainPackageName = "";
+    //    }
+    //
+    //    return domainPackageName;
+    //}
+
     /**
      * Grabs the name of the database file specified in the manifest.
      *
      * @return the value for the {@value #METADATA_DATABASE} meta data in the AndroidManifest or
      * {@link #DATABASE_DEFAULT_NAME_SUFFIX} if not present
      */
-    public static String getDatabaseName() {
-        String databaseName = getMetaDataString(METADATA_DATABASE);
+    public static String getDatabaseName(Context context) {
+        String databaseName = getMetaDataString(context, METADATA_DATABASE);
 
         if (databaseName == null) {
-            databaseName = ContextUtil.getPackageName() + DATABASE_DEFAULT_NAME_SUFFIX;
+            databaseName = context.getPackageName() + DATABASE_DEFAULT_NAME_SUFFIX;
         }
 
         return databaseName;
@@ -106,61 +143,125 @@ public static String getDatabaseName() {
     /**
      * @return true if the query log flag is enabled
      */
-    public static boolean isLogQueriesEnabled() {
-        return getMetaDataBoolean(METADATA_QUERY_LOG);
+    public static boolean isLogQueriesEnabled(Context context) {
+        return getMetaDataBoolean(context, METADATA_QUERY_LOG);
     }
 
     /**
      * @return true if the debug flag is enabled
      */
-    public static boolean isDebugEnabled() {
-        return getMetaDataBoolean(METADATA_DEBUG);
+    public static boolean isDebugEnabled(Context context) {
+        return getMetaDataBoolean(context, METADATA_DEBUG);
     }
 
-    private static String getMetaDataString(String name) {
-        PackageManager pm = getPackageManager();
+    /**
+     * Returns the list of classes defined in the StringArray resource specified with
+     * CUBE_MODEL_RESID.
+     *
+     * @param context
+     * @return
+     */
+    public static Class<?>[] getModels(Context context) {
+        boolean debug = isDebugEnabled(context);
+
+
+        Integer resId = getMetaDataInteger(context, METADATA_MODEL_RESID);
+        if (debug) {
+            Log.d(Cube.TAG, "Model data resource id: " + resId);
+        }
+
+        if (resId == null || resId == 0) {
+            return new Class<?>[0];
+        }
+
+        String[] classNames = context.getResources().getStringArray(resId);
+
+
+        if (classNames == null) {
+            if (debug) {
+                Log.d(Cube.TAG, "Model resource array not found, creating zero length array.");
+            }
+            classNames = new String[0];
+        }
+
+        if (debug) {
+            Log.d(Cube.TAG, "Model resource array length: " + classNames.length);
+        }
+
+        Class<?>[] modelTypes = new Class<?>[classNames.length];
+        for (int i = 0; i < classNames.length; i++) {
+            if (debug) {
+                Log.d(Cube.TAG, "Model resource processing: " + classNames[i]);
+            }
+            try {
+                modelTypes[i] = Class
+                        .forName(classNames[i], true, context.getClass().getClassLoader());
+            } catch (Throwable e) {
+                Log.e(Cube.TAG, "Can't create class: " + classNames[i], e);
+            }
+        }
+
+        return modelTypes;
+    }
+
+    public static Class<? extends CubeConfig> getConfigurationClass(Context context) {
+        String className = getMetaDataString(context, METADATA_CONFIG_CLASS);
+        try {
+            if (className != null) {
+                Class<?> c = Class.forName(className);
+                if (CubeConfig.class.isAssignableFrom(c)) {
+                    return (Class<? extends CubeConfig>) c;
+                }
+            }
+        } catch (ClassNotFoundException e) {
+            //throw new RuntimeException(e);
+            Log.e(Cube.TAG, "Cube Config class was not found.", e);
+        }
+
+        return null;
+
+    }
+
+    private static String getMetaDataString(Context context, String name) {
+        PackageManager pm = context.getPackageManager();
         String value = null;
 
         try {
             ApplicationInfo ai = pm
-                    .getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA);
+                    .getApplicationInfo(context.getPackageName(), PackageManager.GET_META_DATA);
             value = ai.metaData.getString(name);
         } catch (Exception e) {
-            if (CubeManifest.isLogQueriesEnabled()) {
-                Log.d(Cube.TAG, "Couldn't find manifest config value: " + name);
-            }
+            Log.d(Cube.TAG, "Couldn't find Cube manifest config value: " + name);
         }
 
         return value;
     }
 
-    private static int getMetaDataInteger(String name) {
-        PackageManager pm = getPackageManager();
+    private static int getMetaDataInteger(Context context, String name) {
+        PackageManager pm = context.getPackageManager();
         int value = 0;
 
         try {
             ApplicationInfo ai = pm
-                    .getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA);
+                    .getApplicationInfo(context.getPackageName(), PackageManager.GET_META_DATA);
             value = ai.metaData.getInt(name);
         } catch (Exception e) {
-            if (CubeManifest.isLogQueriesEnabled()) {
-                Log.d(Cube.TAG, "Couldn't find config value: " + name);
-            }
+            Log.d(Cube.TAG, "Couldn't find Cube manifest config value: " + name);
         }
 
         return value;
     }
 
-    private static boolean getMetaDataBoolean(String name) {
-        PackageManager pm = getPackageManager();
+    private static boolean getMetaDataBoolean(Context context, String name) {
+        PackageManager pm = context.getPackageManager();
         boolean value = false;
 
         try {
             ApplicationInfo ai = pm
-                    .getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA);
+                    .getApplicationInfo(context.getPackageName(), PackageManager.GET_META_DATA);
             value = ai.metaData.getBoolean(name);
         } catch (Exception e) {
-            Log.d(Cube.TAG, "Couldn't find manifest config value: " + name);
+            Log.d(Cube.TAG, "Couldn't find Cube manifest config value: " + name);
         }
 
         return value;
diff --git a/library/src/main/java/com/sixgreen/cube/support/CubeManifestConfig.java b/library/src/main/java/com/sixgreen/cube/support/CubeManifestConfig.java
index 46f13216..4c5c96da 100644
--- a/library/src/main/java/com/sixgreen/cube/support/CubeManifestConfig.java
+++ b/library/src/main/java/com/sixgreen/cube/support/CubeManifestConfig.java
@@ -9,6 +9,14 @@
     private String databaseName;
     private int version;
     private String authority;
+    private Class<?>[] entities;
+
+    public CubeManifestConfig(String authority, String databaseName, Class<?>[] entities, int version) {
+        this.authority = authority;
+        this.databaseName = databaseName;
+        this.entities = entities;
+        this.version = version;
+    }
 
     @Override
     public String getDatabaseName() {
@@ -20,7 +28,7 @@ public String getDatabaseName() {
      */
     @Override
     public Class<?>[] getEntityClasses() {
-        return new Class<?>[0];
+        return entities;
     }
 
     /**
@@ -33,18 +41,12 @@ public String getAuthority() {
         return authority;
     }
 
-    public void setDatabaseName(String databaseName) {
-        this.databaseName = databaseName;
-    }
 
     @Override
     public int getVersion() {
         return version;
     }
 
-    public void setVersion(int version) {
-        this.version = version;
-    }
 
     ///**
     // * Key for the database name meta data.
diff --git a/library/src/main/java/com/sixgreen/cube/support/QueryBuilder.java b/library/src/main/java/com/sixgreen/cube/support/QueryBuilder.java
index 277bd310..bc44d03a 100644
--- a/library/src/main/java/com/sixgreen/cube/support/QueryBuilder.java
+++ b/library/src/main/java/com/sixgreen/cube/support/QueryBuilder.java
@@ -1,5 +1,6 @@
 package com.sixgreen.cube.support;
 
+import com.sixgreen.cube.Cube;
 import com.sixgreen.cube.util.ReflectionUtil;
 
 import java.math.BigDecimal;
@@ -52,4 +53,12 @@ public static String generatePlaceholders(int numberOfArgs) {
         }
         return stringBuilder.toString();
     }
+    
+    public static String id() {
+        return Cube._ID + " = ?";
+    }
+
+    public static String column(String name) {
+        return name + " = ?";
+    }
 }
diff --git a/library/src/main/java/com/sixgreen/cube/support/SqlBuilder.java b/library/src/main/java/com/sixgreen/cube/support/SqlBuilder.java
index 21336937..e2cd9f15 100644
--- a/library/src/main/java/com/sixgreen/cube/support/SqlBuilder.java
+++ b/library/src/main/java/com/sixgreen/cube/support/SqlBuilder.java
@@ -42,14 +42,14 @@ public static String createTableSQL(CubeConfig config, Class<?> table) {
         }
 
         StringBuilder sb = new StringBuilder("CREATE TABLE IF NOT EXISTS ");
-        sb.append(tableName).append(" ( "+Cube.DEFAULT_ID_COLUMN+" INTEGER PRIMARY KEY AUTOINCREMENT ");
+        sb.append(tableName).append(" ( "+Cube._ID+" INTEGER PRIMARY KEY AUTOINCREMENT ");
 
         for (Field column : fields) {
             String columnName = NameUtil.toColumnName(column);
             String columnType = QueryBuilder.getColumnType(column.getType());
 
             if (columnType != null) {
-                if (columnName.equalsIgnoreCase(Cube.DEFAULT_ID_COLUMN)) {
+                if (columnName.equalsIgnoreCase(Cube._ID)) {
                     continue;
                 }
 
diff --git a/library/src/main/java/com/sixgreen/cube/util/NameUtil.java b/library/src/main/java/com/sixgreen/cube/util/NameUtil.java
index 859a3c2e..95e06e50 100644
--- a/library/src/main/java/com/sixgreen/cube/util/NameUtil.java
+++ b/library/src/main/java/com/sixgreen/cube/util/NameUtil.java
@@ -22,8 +22,8 @@ private NameUtil() {
      * "_id" (not case sensitive) in which case "_id" is returned
      */
     public static String toSQLNameDefault(String camelCased) {
-        if (camelCased.equalsIgnoreCase(Cube.DEFAULT_ID_COLUMN)) {
-            return Cube.DEFAULT_ID_COLUMN;
+        if (camelCased.equalsIgnoreCase(Cube._ID)) {
+            return Cube._ID;
         }
 
         StringBuilder sb = new StringBuilder();
@@ -68,7 +68,7 @@ public static String toSQLNameDefault(String camelCased) {
      */
     public static String toColumnName(Field field) {
         if (field.isAnnotationPresent(Id.class)) {
-            return Cube.DEFAULT_ID_COLUMN;
+            return Cube._ID;
         } else if (field.isAnnotationPresent(Column.class)) {
             Column annotation = field.getAnnotation(Column.class);
             return annotation.name();
diff --git a/library/src/main/java/com/sixgreen/cube/util/ReflectionUtil.java b/library/src/main/java/com/sixgreen/cube/util/ReflectionUtil.java
index f299a99d..e4f5b8f6 100644
--- a/library/src/main/java/com/sixgreen/cube/util/ReflectionUtil.java
+++ b/library/src/main/java/com/sixgreen/cube/util/ReflectionUtil.java
@@ -197,7 +197,7 @@ public static void setFieldValueFromCursor(CubeConfig config, Cursor cursor, Fie
                 return;
             }
 
-            if (colName.equalsIgnoreCase(Cube.DEFAULT_ID_COLUMN)) {
+            if (colName.equalsIgnoreCase(Cube._ID)) {
                 long cid = cursor.getLong(columnIndex);
                 field.set(object, cid);
             } else if (fieldType.equals(long.class) || fieldType.equals(Long.class)) {
@@ -285,7 +285,7 @@ private static Field getDeepField(String fieldName, Class<?> type) throws
 
     public static void setFieldValueForId(Object object, Long value) {
         try {
-            Field field = getDeepField(Cube.DEFAULT_ID_COLUMN, object.getClass());
+            Field field = getDeepField(Cube._ID, object.getClass());
             field.setAccessible(true);
             field.set(object, value);
         } catch (Exception e) {
