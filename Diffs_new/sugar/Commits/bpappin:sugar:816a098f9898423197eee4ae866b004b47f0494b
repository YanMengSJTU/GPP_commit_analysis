diff --git a/build.gradle b/build.gradle
index 030e1cb3..4c9426c7 100644
--- a/build.gradle
+++ b/build.gradle
@@ -7,7 +7,7 @@ buildscript {
         mavenCentral()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.0.0'
+        classpath 'com.android.tools.build:gradle:2.1.2'
         classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.3.1'
     }
 }
diff --git a/example/build.gradle b/example/build.gradle
index a8b90f05..056d6ca2 100644
--- a/example/build.gradle
+++ b/example/build.gradle
@@ -3,10 +3,9 @@ apply plugin: 'com.android.application'
 android {
     compileSdkVersion 23
     buildToolsVersion "23.0.3"
-
     defaultConfig {
         applicationId "com.example"
-        minSdkVersion 9
+        minSdkVersion 11
         targetSdkVersion 23
     }
     buildTypes {
@@ -17,9 +16,11 @@ android {
     lintOptions {
         abortOnError false
     }
+    productFlavors {
+    }
 }
 
 dependencies {
-    compile project (':library')
+    compile project(':library')
     compile 'com.android.support:appcompat-v7:23.3.0'
 }
diff --git a/library/build.gradle b/library/build.gradle
index 907162ee..a64c3608 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,12 +1,22 @@
+buildscript {
+    repositories {
+        mavenCentral()
+    }
+
+    dependencies {
+        classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'
+    }
+}
+
 apply plugin: 'com.android.library'
 apply from: '../maven_push.gradle'
+apply plugin: 'com.github.dcendents.android-maven'
 
 android {
     compileSdkVersion 23
     buildToolsVersion "23.0.3"
-
     defaultConfig {
-        minSdkVersion 9
+        minSdkVersion 11
         targetSdkVersion 23
     }
     buildTypes {
@@ -20,6 +30,8 @@ android {
     lintOptions {
         abortOnError false
     }
+    productFlavors {
+    }
 }
 
 dependencies {
diff --git a/library/src/main/java/com/sixgreen/cube/Cube.java b/library/src/main/java/com/sixgreen/cube/Cube.java
new file mode 100644
index 00000000..bb42e314
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/Cube.java
@@ -0,0 +1,164 @@
+package com.sixgreen.cube;
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.os.Build.VERSION;
+import android.os.Build.VERSION_CODES;
+import android.util.Log;
+
+import com.sixgreen.cube.support.CubeDataManager;
+
+/**
+ * Created by bpappin on 16-08-11.
+ */
+public class Cube {
+    // XXX As a library, it is beneficial for the client to get log messages from a consistent tag.
+    public static final String TAG = "Cube";
+    public static final String DEFAULT_ID_COLUMN = "_id";
+    private static Cube instance;
+
+    private Context context;
+    private CubeConfig config;
+    private CubeDataManager cubeDataManager;
+
+    public static void setup(Context context) {
+        setup(context, CubeConfig.manifest(context));
+    }
+
+    public static void setup(Context context, CubeConfig config) {
+        if (instance == null) {
+            instance = new Cube();
+            instance.config = config;
+            instance.cubeDataManager = new CubeDataManager(context, config);
+        }
+    }
+
+    // XXX We don't appear to need this.
+    //public static void teardown(Context context) {
+    //    if (instance != null) {
+    //        //instance = new Cube();
+    //    }
+    //
+    //    // Once this is called, setup must be called again.
+    //    instance = null;
+    //}
+
+    /**
+     * Wipes a database, for cases where the current users needs the data to be reset.
+     */
+    public static void wipe() {
+        if (get().cubeDataManager != null) {
+            get().cubeDataManager.onReset();
+        }
+    }
+
+    public static Cube get() {
+        if (instance == null) {
+            Log.w(TAG, "Cube has not been initialized.");
+        }
+        return instance;
+    }
+
+    public static CubeConfig getConfig() {
+        return get().config;
+    }
+    
+    public static CubeDataManager getCubeDataManager() {
+        return get().cubeDataManager;
+    }
+
+
+    public static <T> T executeLoader(final Loader<T> loader) throws Exception {
+        T result = null;
+        CubeDataManager manager = null;
+        try {
+            manager = getCubeDataManager();
+            beginTransaction(manager);
+            result = loader.load(manager);
+        } catch (final Exception e) {
+            Log.e(TAG, "Unable to execute loader: "
+                       + loader.getClass().getSimpleName(), e);
+            throw e;
+        } finally {
+            finishTransaction(manager);
+        }
+        return result;
+    }
+
+    public static void executeDeleter(final Deleter deleter) throws Exception {
+        CubeDataManager manager = null;
+        try {
+            manager = getCubeDataManager();
+            beginTransaction(manager);
+            deleter.delete(manager);
+        } catch (final Exception e) {
+            Log.e(TAG, "Unable to execute deleter: "
+                       + deleter.getClass().getSimpleName(), e);
+            throw e;
+        } finally {
+            finishTransaction(manager);
+        }
+    }
+
+    public static void executeSaver(final Saver saver) throws Exception {
+        //EntityTransaction transaction = null;
+        CubeDataManager manager = null;
+        try {
+            manager = getCubeDataManager();
+            beginTransaction(manager);
+            saver.save(manager);
+        } catch (final Exception e) {
+            Log.e(TAG, "Unable to execute saver: "
+                       + saver.getClass().getSimpleName(), e);
+            throw e;
+        } finally {
+            finishTransaction(manager);
+        }
+    }
+    
+
+    public static void executeUpdater(final Updater updater) throws Exception {
+        CubeDataManager manager = null;
+        try {
+            manager = getCubeDataManager();
+            beginTransaction(manager);
+            updater.update(manager);
+            successfulTransaction(manager);
+        } catch (final Exception e) {
+            Log.e(TAG, "Unable to execute updater: "
+                       + updater.getClass().getSimpleName(), e);
+            throw e;
+        } finally {
+            finishTransaction(manager);
+        }
+    }
+    
+    private static void successfulTransaction(CubeDataManager manager) throws
+                                                                       IllegalStateException {
+        SQLiteDatabase sqLiteDatabase = manager.getDatabase();
+        sqLiteDatabase.setTransactionSuccessful();
+    }
+    
+    private static void beginTransaction(CubeDataManager manager) {
+        SQLiteDatabase sqLiteDatabase = manager.getDatabase();
+        if (VERSION.SDK_INT >= VERSION_CODES.JELLY_BEAN) {
+            if (sqLiteDatabase.isWriteAheadLoggingEnabled()) {
+                sqLiteDatabase.beginTransactionNonExclusive();
+            } else {
+                sqLiteDatabase.beginTransaction();
+            }
+        } else {
+            sqLiteDatabase.beginTransaction();
+            sqLiteDatabase.setLockingEnabled(false);
+        }
+    }
+
+
+    private static void finishTransaction(CubeDataManager manager) {
+        SQLiteDatabase sqLiteDatabase = manager.getDatabase();
+        //sqLiteDatabase.yieldIfContendedSafely()
+        sqLiteDatabase.endTransaction();
+        sqLiteDatabase.setLockingEnabled(true);
+    }
+    
+}
diff --git a/library/src/main/java/com/sixgreen/cube/CubeConfig.java b/library/src/main/java/com/sixgreen/cube/CubeConfig.java
new file mode 100644
index 00000000..0c271aee
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/CubeConfig.java
@@ -0,0 +1,163 @@
+package com.sixgreen.cube;
+
+import android.content.Context;
+import android.database.DatabaseErrorHandler;
+import android.database.sqlite.SQLiteDatabase.CursorFactory;
+
+import com.sixgreen.cube.support.CubeCursorFactory;
+import com.sixgreen.cube.support.CubeDataManager;
+import com.sixgreen.cube.support.CubeErrorHandler;
+
+import java.lang.reflect.Field;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Created by bpappin on 16-08-11.
+ */
+public abstract class CubeConfig {
+    private boolean debug;
+    private boolean logQueries;
+    private int version;
+    private boolean writeAheadLoggingEnabled = true;
+    private DatabaseErrorHandler databaseErrorHandler = new CubeErrorHandler();
+    private CursorFactory cursorFactory;
+
+    private final static Map<Class<?>, List<Field>> fieldCache = new HashMap<>();
+
+    public static final CubeConfig manifest(Context context) {
+
+        
+
+        return null;
+    }
+
+    public boolean isDebug() {
+        return debug;
+    }
+
+    public void setDebug(boolean debug) {
+        this.debug = debug;
+    }
+
+    public boolean isLogQueries() {
+        return logQueries;
+    }
+
+    public void setLogQueries(boolean logQueries) {
+        this.logQueries = logQueries;
+    }
+
+    /**
+     * @return
+     * @see {https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html#enableWriteAheadLogging()}
+     */
+    public boolean isWriteAheadLoggingEnabled() {
+        return writeAheadLoggingEnabled;
+    }
+
+    /**
+     * @param writeAheadLoggingEnabled
+     * @see {https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html#enableWriteAheadLogging()}
+     */
+    public void setWriteAheadLoggingEnabled(boolean writeAheadLoggingEnabled) {
+        this.writeAheadLoggingEnabled = writeAheadLoggingEnabled;
+    }
+
+    /**
+     * the {@link DatabaseErrorHandler} to be used when sqlite reports database
+     */
+    public DatabaseErrorHandler getDatabaseErrorHandler() {
+        return databaseErrorHandler;
+    }
+
+    /**
+     * the {@link DatabaseErrorHandler} to be used when sqlite reports database
+     */
+    public void setDatabaseErrorHandler(DatabaseErrorHandler databaseErrorHandler) {
+        this.databaseErrorHandler = databaseErrorHandler;
+    }
+
+    /**
+     * The class to use for creating cursor objects, or null for the default
+     *
+     * @return CursorFactory
+     */
+    public CursorFactory getCursorFactory() {
+        if (this.cursorFactory != null) {
+            return this.cursorFactory;
+        }
+        return new CubeCursorFactory(isLogQueries());
+    }
+
+    /**
+     * The class to use for creating cursor objects, or null for the default
+     *
+     * @param cursorFactory
+     *         CursorFactory
+     */
+    public void setCursorFactory(CursorFactory cursorFactory) {
+        this.cursorFactory = cursorFactory;
+    }
+
+    public static List<Field> getFieldCache(Class<?> clazz) {
+        if (fieldCache.containsKey(clazz)) {
+            List<Field> list = fieldCache.get(clazz);
+            return Collections.synchronizedList(list);
+        }
+
+        return null;
+    }
+
+    public void setFieldCache(Class<?> table, List<Field> toStore) {
+        fieldCache.put(table, toStore);
+    }
+
+    /**
+     * The version number of the database (starting at 1); if the database is older,
+     * {@link CubeDataManager#onUpgrade} will be used to upgrade the database; if the database is
+     * newer, {@link CubeDataManager#onDowngrade} will be used to downgrade the database
+     *
+     * @return int the version of this database
+     */
+    public abstract int getVersion();
+
+    /**
+     * The name of the database file, or null for an in-memory database.
+     *
+     * @return String the name of this database
+     */
+    public abstract String getDatabaseName();
+
+    /**
+     * @return Class<?>[] an array of the entity classes for the schema.
+     */
+    public abstract Class<?>[] getEntityClasses();
+
+    /**
+     * The content provider authority.
+     *
+     * @return String
+     */
+    public abstract String getAuthority();
+
+    ///**
+    // * Key for the database name meta data.
+    // */
+    //public final static String METADATA_DATABASE = "DATABASE";
+    //
+    ///**
+    // * Key for the database version meta data.
+    // */
+    //public final static String METADATA_VERSION = "VERSION";
+    //public final static String METADATA_DOMAIN_PACKAGE_NAME = "DOMAIN_PACKAGE_NAME";
+    //public final static String METADATA_QUERY_LOG = "QUERY_LOG";
+    //
+    ///**
+    // * The default name for the database unless specified in the AndroidManifest.
+    // */
+    //public final static String DATABASE_DEFAULT_NAME = "Sugar.db";
+
+}
diff --git a/library/src/main/java/com/sixgreen/cube/Deleter.java b/library/src/main/java/com/sixgreen/cube/Deleter.java
new file mode 100644
index 00000000..44045c39
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/Deleter.java
@@ -0,0 +1,15 @@
+package com.sixgreen.cube;
+
+import com.sixgreen.cube.support.CubeDataManager;
+
+/**
+ * Created by bpappin on 16-08-23.
+ */
+public abstract class Deleter {
+
+    public void delete() throws Exception {
+        Cube.executeDeleter(this);
+    }
+
+    public abstract void delete(CubeDataManager manager);
+}
diff --git a/library/src/main/java/com/sixgreen/cube/Loader.java b/library/src/main/java/com/sixgreen/cube/Loader.java
new file mode 100644
index 00000000..abfda7c3
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/Loader.java
@@ -0,0 +1,14 @@
+package com.sixgreen.cube;
+
+import com.sixgreen.cube.support.CubeDataManager;
+
+/**
+ * Created by bpappin on 16-08-23.
+ */
+public abstract class Loader<T> {
+    public abstract T load(CubeDataManager manager);
+
+    public T load() throws Exception {
+        return Cube.executeLoader(this);
+    }
+}
diff --git a/library/src/main/java/com/sixgreen/cube/Saver.java b/library/src/main/java/com/sixgreen/cube/Saver.java
new file mode 100644
index 00000000..01524a30
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/Saver.java
@@ -0,0 +1,30 @@
+package com.sixgreen.cube;
+
+import com.sixgreen.cube.support.CubeDataManager;
+
+/**
+ * Convenience base class for objects that need to be able to save themselves.
+ * There is no requirement for persistent objects to extend this
+ * class; it just provides a save() method.
+ *
+ * <p>
+ * There are two versions of the save() method. The no-args version does the
+ * save operation inside its own transaction - it's the simplest way of saving
+ * an object. The other version takes a Session object (see HibernateManager for
+ * ways of acquiring one) and adds the save operation to the session's
+ * transaction.
+ *
+ * Created by bpappin on 16-08-23.
+ */
+public abstract class Saver {
+
+    public Saver() {
+        super();
+    }
+
+    public void save() throws Exception {
+        Cube.executeSaver(this);
+    }
+
+    public abstract void save(CubeDataManager manager);
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/sixgreen/cube/Updater.java b/library/src/main/java/com/sixgreen/cube/Updater.java
new file mode 100644
index 00000000..4a989427
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/Updater.java
@@ -0,0 +1,40 @@
+package com.sixgreen.cube;
+
+import com.sixgreen.cube.support.CubeDataManager;
+
+/**
+ * Convenience base class for objects that need to be able to save themselves.
+ * There is no requirement for persistent objects to extend this
+ * class; it just provides a update() method.
+ *
+ * <p>
+ * There are two versions of the update() method. The no-args version does the
+ * save operation inside its own transaction - it's the simplest way of saving
+ * an object. The other version takes a Session object (see HibernateManager for
+ * ways of acquiring one) and adds the save operation to the session's
+ * transaction.
+ *
+ * Created by bpappin on 16-08-23.
+ */
+public abstract class Updater {
+
+    /**
+     * Save the object using a new Hibernate session. The session will be
+     * created, committed and closed during the lifetime of this call.
+     *
+     * @throws Exception
+     *
+     * @throws Exception
+     */
+    public void update() throws Exception {
+        Cube.executeUpdater(this);
+    }
+
+    /**
+     * Save the object in an existing session.
+     *
+     * @param manager
+     *            JPA EntityManager manager.
+     */
+    public abstract void update(CubeDataManager manager);
+}
diff --git a/library/src/main/java/com/sixgreen/cube/annotation/Column.java b/library/src/main/java/com/sixgreen/cube/annotation/Column.java
new file mode 100644
index 00000000..cc31955e
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/annotation/Column.java
@@ -0,0 +1,14 @@
+package com.sixgreen.cube.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface Column {
+    String name();
+    boolean unique() default false;
+    boolean notNull() default false;
+}
diff --git a/library/src/main/java/com/sixgreen/cube/annotation/Id.java b/library/src/main/java/com/sixgreen/cube/annotation/Id.java
new file mode 100644
index 00000000..27db5f08
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/annotation/Id.java
@@ -0,0 +1,15 @@
+package com.sixgreen.cube.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Marks the ID member of an entity.
+ * The member must be a long value.
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface Id {
+}
diff --git a/library/src/main/java/com/sixgreen/cube/annotation/Ignore.java b/library/src/main/java/com/sixgreen/cube/annotation/Ignore.java
new file mode 100644
index 00000000..4d0b8b05
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/annotation/Ignore.java
@@ -0,0 +1,11 @@
+package com.sixgreen.cube.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface Ignore {
+}
diff --git a/library/src/main/java/com/sixgreen/cube/annotation/MultiUnique.java b/library/src/main/java/com/sixgreen/cube/annotation/MultiUnique.java
new file mode 100644
index 00000000..ebb54d1d
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/annotation/MultiUnique.java
@@ -0,0 +1,12 @@
+package com.sixgreen.cube.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
+public @interface MultiUnique {
+    String value();
+}
diff --git a/library/src/main/java/com/sixgreen/cube/annotation/NotNull.java b/library/src/main/java/com/sixgreen/cube/annotation/NotNull.java
new file mode 100644
index 00000000..bb4f4307
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/annotation/NotNull.java
@@ -0,0 +1,11 @@
+package com.sixgreen.cube.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface NotNull {
+}
diff --git a/library/src/main/java/com/sixgreen/cube/annotation/Table.java b/library/src/main/java/com/sixgreen/cube/annotation/Table.java
new file mode 100644
index 00000000..2622d33d
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/annotation/Table.java
@@ -0,0 +1,12 @@
+package com.sixgreen.cube.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
+public @interface Table {
+    String name() default "";
+}
diff --git a/library/src/main/java/com/sixgreen/cube/annotation/Unique.java b/library/src/main/java/com/sixgreen/cube/annotation/Unique.java
new file mode 100644
index 00000000..9862c55d
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/annotation/Unique.java
@@ -0,0 +1,11 @@
+package com.sixgreen.cube.annotation;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface Unique {
+}
diff --git a/library/src/main/java/com/sixgreen/cube/provider/CubeContentProvider.java b/library/src/main/java/com/sixgreen/cube/provider/CubeContentProvider.java
new file mode 100644
index 00000000..0dd7dd54
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/provider/CubeContentProvider.java
@@ -0,0 +1,233 @@
+package com.sixgreen.cube.provider;
+
+import android.content.ContentValues;
+import android.content.UriMatcher;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.net.Uri;
+import android.util.Log;
+import android.util.SparseArray;
+
+import com.sixgreen.cube.Cube;
+import com.sixgreen.cube.CubeConfig;
+import com.sixgreen.cube.util.NameUtil;
+
+/**
+ * To use this class, you must use the manifest version for configuration, because the content
+ * provider may be created before the application.
+ * <p/>
+ * Created by bpappin on 16-03-29.
+ */
+public class CubeContentProvider extends android.content.ContentProvider {
+    private static final String TAG = "Cube.ContentProvider";
+    //private static boolean DEBUG;
+
+    private static final UriMatcher uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
+    private static final SparseArray<Class<?>> typeCodes = new SparseArray<Class<?>>();
+    private static SparseArray<String> mimeTypeCache = new SparseArray<String>();
+    //private CubeConfig config;
+
+    @Override
+    public boolean onCreate() {
+//config = CubeConfig.manifest(getContext());
+        // XXX This must always happen first.
+        //Cube.setup(getContext(),CubeConfig.manifest(getContext()));
+        Cube.setup(getContext());
+        //SugarContext.init(CubeConfig.manifest(getContext()));
+
+        //final SugarConfiguration configuration = SugarContext.getSugarContext().getConfiguration();
+        //DEBUG = configuration.isDebug();
+
+        Log.d(TAG, "Debug mode enabled: " + Cube.getConfig().isDebug());
+
+        final String authority = Cube.getConfig()
+                .getAuthority();
+
+        if(Cube.getConfig().isDebug()) {
+            Log.d(TAG, "Content provider authority: " + authority);
+        }
+
+        Class<?>[] classList = Cube.getConfig().getEntityClasses();
+
+        if(Cube.getConfig().isDebug()) {
+            Log.d(TAG, "Entity classes found: " + classList.length);
+        }
+
+        //final int size = classList.size();
+        for (int i = 0; i < classList.length; i++) {
+            Class<?> tableClass = classList[i];
+            if (Cube.getConfig().isDebug()) {
+                Log.d(TAG, "Registering table for: " + tableClass.getSimpleName());
+            }
+            final int tableKey = (i * 2) + 1;
+            final int itemKey = (i * 2) + 2;
+
+            // content://<authority>/<table>
+            uriMatcher
+                    .addURI(authority, NameUtil.toTableName(tableClass)
+                                               .toLowerCase(), tableKey);
+            typeCodes.put(tableKey, tableClass);
+            if (Cube.getConfig().isDebug()) {
+                Log.d(TAG, "Registering table key: " + tableKey + " for class " +
+                           tableClass.getSimpleName());
+            }
+
+            // content://<authority>/<table>/<id>
+            uriMatcher.addURI(authority,
+                    NameUtil.toTableName(tableClass).toLowerCase() +
+                    "/#", itemKey);
+            typeCodes.put(itemKey, tableClass);
+            if (Cube.getConfig().isDebug()) {
+                Log.d(TAG, "Registering item key: " + itemKey + " for class " +
+                           tableClass.getSimpleName());
+            }
+        }
+
+        return true;
+    }
+
+    @Override
+    public String getType(Uri uri) {
+        final int match = uriMatcher.match(uri);
+
+        String cachedMimeType = mimeTypeCache.get(match);
+        if (cachedMimeType != null) {
+            return cachedMimeType;
+        }
+
+        final Class<?> type = getModelType(uri);
+        final boolean single = ((match % 2) == 0);
+
+        String mimeType = getMimeType(type, single);
+
+        mimeTypeCache.append(match, mimeType);
+
+        return mimeType;
+    }
+
+    private String getMimeType(Class<?> type, boolean single) {
+        StringBuilder mimeTypeBufer = new StringBuilder();
+        mimeTypeBufer.append("vnd");
+        mimeTypeBufer.append(".");
+        mimeTypeBufer.append(Cube.getConfig().getAuthority());
+        mimeTypeBufer.append(".");
+        mimeTypeBufer.append(single ? "item" : "dir");
+        mimeTypeBufer.append("/");
+        mimeTypeBufer.append("vnd");
+        mimeTypeBufer.append(".");
+        mimeTypeBufer.append(Cube.getConfig().getAuthority());
+        mimeTypeBufer.append(".");
+        mimeTypeBufer.append(NameUtil.toTableName(type));
+        return mimeTypeBufer.toString();
+    }
+
+
+    @Override
+    public Uri insert(Uri uri, ContentValues values) {
+        final Class<?> type = getModelType(uri);
+        final Long id = Cube.getCubeDataManager().getWritableDatabase()
+                .insert(NameUtil.toTableName(type), null, values);
+
+        if (id != null && id > 0) {
+            Uri retUri = createUri(type, id);
+            notifyChange(retUri);
+
+            return retUri;
+        }
+
+        return null;
+    }
+
+    @Override
+    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
+        final Class<?> type = getModelType(uri);
+        final int count = Cube.getCubeDataManager().getWritableDatabase()
+                .update(NameUtil.toTableName(type), values, selection, selectionArgs);
+
+        notifyChange(uri);
+
+        return count;
+    }
+
+    @Override
+    public int delete(Uri uri, String selection, String[] selectionArgs) {
+        final Class<?> type = getModelType(uri);
+        final int count = Cube.getCubeDataManager().getWritableDatabase()
+                .delete(NameUtil.toTableName(type), selection, selectionArgs);
+
+        notifyChange(uri);
+
+        return count;
+    }
+
+    @Override
+    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
+
+        final Class<?> type = getModelType(uri);
+
+        final Cursor cursor = Cube.getCubeDataManager().getReadableDatabase().query(
+                NameUtil.toTableName(type),
+                projection,
+                selection,
+                selectionArgs,
+                null,
+                null,
+                sortOrder);
+
+        cursor.setNotificationUri(getContext().getContentResolver(), uri);
+
+        return cursor;
+    }
+
+
+    public static Uri createUri(Class<?> type, Long id) {
+        final StringBuilder uri = new StringBuilder();
+        uri.append("content://");
+        //final SugarConfiguration configuration = SugarContext.getSugarContext().getConfiguration();
+        uri.append(Cube.getConfig().getAuthority());
+        uri.append("/");
+        uri.append(NameUtil.toTableName(type).toLowerCase());
+
+        if (id != null) {
+            uri.append("/");
+            uri.append(id.toString());
+        }
+
+        return Uri.parse(uri.toString());
+    }
+
+
+    private Class<?> getModelType(Uri uri) {
+        if (Cube.getConfig().isDebug()) {
+            Log.d(TAG, "Getting model type for URI: " + uri);
+        }
+        final int code = uriMatcher.match(uri);
+        if (Cube.getConfig().isDebug()) {
+            Log.d(TAG, "\tGot matcher type code: " + code);
+        }
+        if (code != UriMatcher.NO_MATCH) {
+            if (Cube.getConfig().isDebug()) {
+                Log.d(TAG, "\tType code found...");
+            }
+            return typeCodes.get(code);
+        }
+        if (Cube.getConfig().isDebug()) {
+            Log.d(TAG, "\tType code NO_MATCH.");
+        }
+        return null;
+    }
+
+    private void notifyChange(Uri uri) {
+        getContext().getContentResolver().notifyChange(uri, null);
+    }
+
+
+    //public SQLiteDatabase getDatabase() {
+    //    return Cube.getCubeDataManager().getDatabase();
+    //    //return SugarContext.getSugarContext().getSugarDb().getDB();
+    //}
+
+    public CubeConfig getConfig() {
+        return Cube.getConfig();
+    }
+}
\ No newline at end of file
diff --git a/library/src/main/java/com/sixgreen/cube/support/CubeCursorFactory.java b/library/src/main/java/com/sixgreen/cube/support/CubeCursorFactory.java
new file mode 100644
index 00000000..d75fd1d9
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/support/CubeCursorFactory.java
@@ -0,0 +1,40 @@
+package com.sixgreen.cube.support;
+
+import android.database.Cursor;
+import android.database.sqlite.SQLiteCursor;
+import android.database.sqlite.SQLiteCursorDriver;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteQuery;
+import android.util.Log;
+
+import com.sixgreen.cube.Cube;
+
+public class CubeCursorFactory implements SQLiteDatabase.CursorFactory {
+
+    private boolean debugEnabled;
+
+    public CubeCursorFactory() {
+        this.debugEnabled = false;
+    }
+
+    public CubeCursorFactory(boolean debugEnabled) {
+        this.debugEnabled = debugEnabled;
+    }
+
+    /**
+     * See {@link SQLiteCursor#SQLiteCursor(SQLiteCursorDriver, String, SQLiteQuery)}.
+     *
+     * @param db
+     * @param masterQuery
+     * @param editTable
+     * @param query
+     */
+    @Override
+    public Cursor newCursor(SQLiteDatabase db, SQLiteCursorDriver masterQuery, String editTable, SQLiteQuery query) {
+        if (debugEnabled) {
+            Log.d(Cube.TAG, query.toString());
+        }
+
+        return new SQLiteCursor(masterQuery, editTable, query);
+    }
+}
diff --git a/library/src/main/java/com/sixgreen/cube/support/CubeDataManager.java b/library/src/main/java/com/sixgreen/cube/support/CubeDataManager.java
new file mode 100644
index 00000000..459ed4be
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/support/CubeDataManager.java
@@ -0,0 +1,146 @@
+package com.sixgreen.cube.support;
+
+import android.content.Context;
+import android.database.DatabaseErrorHandler;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+
+import com.sixgreen.cube.CubeConfig;
+
+/**
+ * Created by bpappin on 16-08-23.
+ */
+public class CubeDataManager extends SQLiteOpenHelper {
+    private final CubeConfig config;
+    private SQLiteDatabase database;
+
+    ///**
+    // * Create a helper object to create, open, and/or manage a database.
+    // * This method always returns very quickly.  The database is not actually
+    // * created or opened until one of {@link #getWritableDatabase} or
+    // * {@link #getReadableDatabase} is called.
+    // *
+    // * @param context
+    // *         to use to open or create the database
+    // * @param name
+    // *         of the database file, or null for an in-memory database
+    // * @param factory
+    // *         to use for creating cursor objects, or null for the default
+    // * @param version
+    // *         number of the database (starting at 1); if the database is older,
+    // *         {@link #onUpgrade} will be used to upgrade the database; if the database is
+    // *         newer, {@link #onDowngrade} will be used to downgrade the database
+    // */
+    //public CubeDataManager(Context context, String name, CursorFactory factory, int version) {
+    //    super(context, name, factory, version);
+    //}
+
+    /**
+     * Create a helper object to create, open, and/or manage a database.
+     * The database is not actually created or opened until one of
+     * {@link #getWritableDatabase} or {@link #getReadableDatabase} is called.
+     * <p/>
+     * <p>Accepts input param: a concrete instance of {@link DatabaseErrorHandler} to be
+     * used to handle corruption when sqlite reports database corruption.</p>
+     *
+     * @param context
+     *         to use to open or create the database
+     * @param config
+     *         the configuration of the Cube framework that contains the information for opening
+     *         the database and setting up its parameters.
+     */
+    public CubeDataManager(Context context, CubeConfig config) {
+        super(context, config.getDatabaseName(), config.getCursorFactory(), config
+                .getVersion(), config.getDatabaseErrorHandler());
+        this.config = config;
+    }
+
+    public SQLiteDatabase getDatabase() {
+        if (database == null) {
+            database = getWritableDatabase();
+        }
+
+        return database;
+    }
+
+    //public void close() {
+    //    if (database != null) {
+    //        database.close();
+    //    }
+    //}
+
+    /**
+     * Called when the database is created for the first time. This is where the
+     * creation of tables and the initial population of the tables should happen.
+     *
+     * @param db
+     *         The database.
+     */
+    @Override
+    public void onCreate(SQLiteDatabase db) {
+        SchemaGenerator schemaGenerator = SchemaGenerator.get(config);
+        schemaGenerator.doCreate(db);
+    }
+
+    /**
+     * Called when the database needs to be upgraded. The implementation
+     * should use this method to drop tables, add tables, or do anything else it
+     * needs to upgrade to the new schema version.
+     * <p/>
+     * <p>
+     * The SQLite ALTER TABLE documentation can be found
+     * <a href="http://sqlite.org/lang_altertable.html">here</a>. If you add new columns
+     * you can use ALTER TABLE to insert them into a live table. If you rename or remove columns
+     * you can use ALTER TABLE to rename the old table, then create the new table and then
+     * populate the new table with the contents of the old table.
+     * </p><p>
+     * This method executes within a transaction.  If an exception is thrown, all changes
+     * will automatically be rolled back.
+     * </p>
+     *
+     * @param db
+     *         The database.
+     * @param oldVersion
+     *         The old database version.
+     * @param newVersion
+     *         The new database version.
+     */
+    @Override
+    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        SchemaGenerator schemaGenerator = SchemaGenerator.get(config);
+        schemaGenerator.doUpgrade(db, oldVersion, newVersion);
+    }
+
+    /**
+     * Called when the database needs to be downgraded. This is strictly similar to
+     * {@link #onUpgrade} method, but is called whenever current version is newer than requested
+     * one.
+     * However, this method is not abstract, so it is not mandatory for a customer to
+     * implement it. If not overridden, default implementation will reject downgrade and
+     * throws SQLiteException
+     * <p/>
+     * <p>
+     * This method executes within a transaction.  If an exception is thrown, all changes
+     * will automatically be rolled back.
+     * </p>
+     *
+     * @param db
+     *         The database.
+     * @param oldVersion
+     *         The old database version.
+     * @param newVersion
+     *         The new database version.
+     */
+    @Override
+    public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        //super.onDowngrade(db, oldVersion, newVersion);
+        SchemaGenerator schemaGenerator = SchemaGenerator.get(config);
+        schemaGenerator.doDowngrade(db, oldVersion, newVersion);
+    }
+
+    public void onReset() {
+        SchemaGenerator schemaGenerator = SchemaGenerator.get(config);
+        schemaGenerator.doManualReset(getDatabase());
+    }
+
+}
diff --git a/library/src/main/java/com/sixgreen/cube/support/CubeErrorHandler.java b/library/src/main/java/com/sixgreen/cube/support/CubeErrorHandler.java
new file mode 100644
index 00000000..ec71d5e4
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/support/CubeErrorHandler.java
@@ -0,0 +1,25 @@
+package com.sixgreen.cube.support;
+
+import android.database.DatabaseErrorHandler;
+import android.database.sqlite.SQLiteDatabase;
+import android.util.Log;
+
+import com.sixgreen.cube.Cube;
+
+/**
+ * Created by bpappin on 16-08-23.
+ */
+public class CubeErrorHandler implements DatabaseErrorHandler {
+
+    /**
+     * The method invoked when database corruption is detected.
+     *
+     * @param dbObj
+     *         the {@link SQLiteDatabase} object representing the database on which corruption
+     *         is detected.
+     */
+    @Override
+    public void onCorruption(SQLiteDatabase dbObj) {
+        Log.e(Cube.TAG, "Database corruption has been detected at: " + dbObj.getPath());
+    }
+}
diff --git a/library/src/main/java/com/sixgreen/cube/support/CubeManifest.java b/library/src/main/java/com/sixgreen/cube/support/CubeManifest.java
new file mode 100644
index 00000000..bfd24bdf
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/support/CubeManifest.java
@@ -0,0 +1,168 @@
+package com.sixgreen.cube.support;
+
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.util.Log;
+
+import com.orm.util.ContextUtil;
+import com.sixgreen.cube.Cube;
+import com.sixgreen.cube.CubeConfig;
+
+import static com.orm.util.ContextUtil.getPackageManager;
+import static com.orm.util.ContextUtil.getPackageName;
+
+/**
+ * Helper class for accessing properties in the AndroidManifest
+ */
+public final class CubeManifest {
+    //private static final String LOG_TAG = "CubeManifest";
+
+    private static boolean queryLogEnabled;
+    private static boolean debugEnabled;
+
+    /**
+     * Key for the database name meta data.
+     */
+    public final static String METADATA_DATABASE = "DATABASE";
+
+    /**
+     * Key for the database version meta data.
+     */
+    public final static String METADATA_VERSION = "VERSION";
+    public final static String METADATA_DOMAIN_PACKAGE_NAME = "DOMAIN_PACKAGE_NAME";
+    public final static String METADATA_QUERY_LOG = "QUERY_LOG";
+    private static final String METADATA_DEBUG = "DEBUG_CUBE";
+
+    /**
+     * The default name for the database unless specified in the AndroidManifest.
+     */
+    public final static String DATABASE_DEFAULT_NAME_SUFFIX = "_cube.db";
+
+
+    //Prevent instantiation
+    private CubeManifest() {
+    }
+
+    public static CubeConfig get() {
+        final CubeManifestConfig cubeConfig = new CubeManifestConfig();
+        cubeConfig.setDebug(isDebugEnabled());
+        cubeConfig.setLogQueries(isLogQueriesEnabled());
+        cubeConfig.setDatabaseName(getDatabaseName());
+        cubeConfig.setVersion(getDatabaseVersion());
+        return cubeConfig;
+    }
+
+    /**
+     * Grabs the database version from the manifest.
+     *
+     * @return the database version as specified by the {@link #METADATA_VERSION} version or 1 of
+     * not present
+     */
+    public static int getDatabaseVersion() {
+        Integer databaseVersion = getMetaDataInteger(METADATA_VERSION);
+
+        if ((databaseVersion == null) || (databaseVersion == 0)) {
+            databaseVersion = 1;
+        }
+
+        return databaseVersion;
+    }
+
+    /**
+     * Grabs the domain name of the model classes from the manifest.
+     *
+     * @return the package String that Sugar uses to search for model classes
+     */
+    public static String getDomainPackageName() {
+        String domainPackageName = getMetaDataString(METADATA_DOMAIN_PACKAGE_NAME);
+
+        if (domainPackageName == null) {
+            domainPackageName = "";
+        }
+
+        return domainPackageName;
+    }
+
+    /**
+     * Grabs the name of the database file specified in the manifest.
+     *
+     * @return the value for the {@value #METADATA_DATABASE} meta data in the AndroidManifest or
+     * {@link #DATABASE_DEFAULT_NAME_SUFFIX} if not present
+     */
+    public static String getDatabaseName() {
+        String databaseName = getMetaDataString(METADATA_DATABASE);
+
+        if (databaseName == null) {
+            databaseName = ContextUtil.getPackageName() + DATABASE_DEFAULT_NAME_SUFFIX;
+        }
+
+        return databaseName;
+    }
+
+    //public static String getDbName() {
+    //    return getDatabaseName();
+    //}
+
+    /**
+     * @return true if the query log flag is enabled
+     */
+    public static boolean isLogQueriesEnabled() {
+        return getMetaDataBoolean(METADATA_QUERY_LOG);
+    }
+
+    /**
+     * @return true if the debug flag is enabled
+     */
+    public static boolean isDebugEnabled() {
+        return getMetaDataBoolean(METADATA_DEBUG);
+    }
+
+    private static String getMetaDataString(String name) {
+        PackageManager pm = getPackageManager();
+        String value = null;
+
+        try {
+            ApplicationInfo ai = pm
+                    .getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA);
+            value = ai.metaData.getString(name);
+        } catch (Exception e) {
+            if (CubeManifest.isLogQueriesEnabled()) {
+                Log.d(Cube.TAG, "Couldn't find manifest config value: " + name);
+            }
+        }
+
+        return value;
+    }
+
+    private static int getMetaDataInteger(String name) {
+        PackageManager pm = getPackageManager();
+        int value = 0;
+
+        try {
+            ApplicationInfo ai = pm
+                    .getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA);
+            value = ai.metaData.getInt(name);
+        } catch (Exception e) {
+            if (CubeManifest.isLogQueriesEnabled()) {
+                Log.d(Cube.TAG, "Couldn't find config value: " + name);
+            }
+        }
+
+        return value;
+    }
+
+    private static boolean getMetaDataBoolean(String name) {
+        PackageManager pm = getPackageManager();
+        boolean value = false;
+
+        try {
+            ApplicationInfo ai = pm
+                    .getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA);
+            value = ai.metaData.getBoolean(name);
+        } catch (Exception e) {
+            Log.d(Cube.TAG, "Couldn't find manifest config value: " + name);
+        }
+
+        return value;
+    }
+}
diff --git a/library/src/main/java/com/sixgreen/cube/support/CubeManifestConfig.java b/library/src/main/java/com/sixgreen/cube/support/CubeManifestConfig.java
new file mode 100644
index 00000000..46f13216
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/support/CubeManifestConfig.java
@@ -0,0 +1,66 @@
+package com.sixgreen.cube.support;
+
+import com.sixgreen.cube.CubeConfig;
+
+/**
+ * Created by bpappin on 16-08-11.
+ */
+public class CubeManifestConfig extends CubeConfig {
+    private String databaseName;
+    private int version;
+    private String authority;
+
+    @Override
+    public String getDatabaseName() {
+        return databaseName;
+    }
+
+    /**
+     * @return Class<?>[] an array of the entity classes for the schema.
+     */
+    @Override
+    public Class<?>[] getEntityClasses() {
+        return new Class<?>[0];
+    }
+
+    /**
+     * The content provider authority.
+     *
+     * @return String
+     */
+    @Override
+    public String getAuthority() {
+        return authority;
+    }
+
+    public void setDatabaseName(String databaseName) {
+        this.databaseName = databaseName;
+    }
+
+    @Override
+    public int getVersion() {
+        return version;
+    }
+
+    public void setVersion(int version) {
+        this.version = version;
+    }
+
+    ///**
+    // * Key for the database name meta data.
+    // */
+    //public final static String METADATA_DATABASE = "DATABASE";
+    //
+    ///**
+    // * Key for the database version meta data.
+    // */
+    //public final static String METADATA_VERSION = "VERSION";
+    //public final static String METADATA_DOMAIN_PACKAGE_NAME = "DOMAIN_PACKAGE_NAME";
+    //public final static String METADATA_QUERY_LOG = "QUERY_LOG";
+    //
+    ///**
+    // * The default name for the database unless specified in the AndroidManifest.
+    // */
+    //public final static String DATABASE_DEFAULT_NAME = "Sugar.db";
+
+}
diff --git a/library/src/main/java/com/sixgreen/cube/support/QueryBuilder.java b/library/src/main/java/com/sixgreen/cube/support/QueryBuilder.java
new file mode 100644
index 00000000..277bd310
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/support/QueryBuilder.java
@@ -0,0 +1,55 @@
+package com.sixgreen.cube.support;
+
+import com.sixgreen.cube.util.ReflectionUtil;
+
+import java.math.BigDecimal;
+
+public class QueryBuilder {
+
+    public static String getColumnType(Class<?> type) {
+        if ((type.equals(Boolean.class)) ||
+            (type.equals(Boolean.TYPE)) ||
+            (type.equals(Integer.class)) ||
+            (type.equals(Integer.TYPE)) ||
+            (type.equals(Long.class)) ||
+            (type.equals(Long.TYPE)) || ReflectionUtil.isEntity(type)) {
+            return "INTEGER";
+        }
+
+        if ((type.equals(java.util.Date.class)) ||
+            (type.equals(java.sql.Date.class)) ||
+            (type.equals(java.util.Calendar.class))) {
+            return "INTEGER NULL";
+        }
+
+        if (type.getName().equals("[B")) {
+            return "BLOB";
+        }
+
+        if ((type.equals(Double.class)) || (type.equals(Double.TYPE)) ||
+            (type.equals(Float.class)) ||
+            (type.equals(Float.TYPE))) {
+            return "FLOAT";
+        }
+
+        if ((type.equals(String.class)) || (type.equals(Character.TYPE)) ||
+            (type.equals(BigDecimal.class))) {
+            return "TEXT";
+        }
+
+        return "";
+    }
+
+    public static String generatePlaceholders(int numberOfArgs) {
+        if (numberOfArgs < 1) {
+            throw new RuntimeException("The number of arguments must be greater than or equal to 1.");
+        }
+
+        StringBuilder stringBuilder = new StringBuilder(numberOfArgs * 2 - 1);
+        stringBuilder.append("?");
+        for (int i = 1; i < numberOfArgs; i++) {
+            stringBuilder.append(",?");
+        }
+        return stringBuilder.toString();
+    }
+}
diff --git a/library/src/main/java/com/sixgreen/cube/support/SchemaGenerator.java b/library/src/main/java/com/sixgreen/cube/support/SchemaGenerator.java
new file mode 100644
index 00000000..8497a21c
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/support/SchemaGenerator.java
@@ -0,0 +1,99 @@
+package com.sixgreen.cube.support;
+
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.util.Log;
+
+import com.sixgreen.cube.Cube;
+import com.sixgreen.cube.CubeConfig;
+import com.sixgreen.cube.util.NameUtil;
+
+/**
+ * Based on the SchemaGenerator from Sugar ORM.
+ * <p/>
+ * Created by bpappin on 16-08-23.
+ */
+public class SchemaGenerator {
+
+    private CubeConfig config;
+
+    public SchemaGenerator(CubeConfig config) {
+        super();
+        this.config = config;
+    }
+
+    public static SchemaGenerator get(CubeConfig config) {
+        final SchemaGenerator schemaGenerator = new SchemaGenerator(config);
+        return schemaGenerator;
+    }
+
+    public void doCreate(SQLiteDatabase db) {
+        if (config.isDebug()) {
+            Log.i(Cube.TAG, "Creating database tables from entities...");
+        }
+        Class<?>[] entityClasses = config.getEntityClasses();
+        for (Class<?> entity : entityClasses) {
+            createTable(entity, db);
+            //afterTableCreated(domain,sqLiteDatabase);
+        }
+    }
+    
+
+    public void doUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        if (config.isDebug()) {
+            Log.i(Cube.TAG, "Upgrading database from " + oldVersion + " to " + newVersion + "...");
+        }
+        dropAllTables(db);
+        doCreate(db);
+    }
+
+
+    public void doDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        if (config.isDebug()) {
+            Log.i(Cube.TAG,
+                    "Downgrading database from " + oldVersion + " to " + newVersion + "...");
+        }
+        dropAllTables(db);
+        doCreate(db);
+    }
+
+    public void doManualReset(SQLiteDatabase db) {
+        if (config.isDebug()) {
+            Log.i(Cube.TAG, "Resetting database manually...");
+        }
+        dropAllTables(db);
+        doCreate(db);
+    }
+
+    public void dropAllTables(SQLiteDatabase db) {
+        if (config.isDebug()) {
+            Log.i(Cube.TAG, "Dropping all database tables...");
+        }
+        Class<?>[] entityClasses = config.getEntityClasses();
+        for (Class<?> entity : entityClasses) {
+            final String sql = "DROP TABLE IF EXISTS " + NameUtil.toTableName(entity);
+            if (config.isLogQueries()) {
+                Log.d(Cube.TAG, sql);
+            }
+            db.execSQL(sql);
+        }
+    }
+
+    private void createTable(Class<?> entity, SQLiteDatabase db) {
+        String createSQL = SqlBuilder.createTableSQL(config, entity);
+
+        if (!createSQL.isEmpty()) {
+            try {
+                if (config.isLogQueries()) {
+                    Log.d(Cube.TAG, createSQL);
+                }
+                db.execSQL(createSQL);
+            } catch (SQLException e) {
+                Log.e(Cube.TAG, "Unable to create table from entity.", e);
+                //e.printStackTrace();
+            }
+        }
+    }
+    
+
+}
diff --git a/library/src/main/java/com/sixgreen/cube/support/SqlBuilder.java b/library/src/main/java/com/sixgreen/cube/support/SqlBuilder.java
new file mode 100644
index 00000000..21336937
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/support/SqlBuilder.java
@@ -0,0 +1,115 @@
+package com.sixgreen.cube.support;
+
+import android.util.Log;
+
+//import com.orm.helper.ManifestHelper;
+//import com.orm.helper.NamingHelper;
+//import com.orm.util.KeyWordUtil;
+//import com.orm.util.QueryBuilder;
+//import com.orm.util.ReflectionUtil;
+import com.sixgreen.cube.Cube;
+import com.sixgreen.cube.CubeConfig;
+import com.sixgreen.cube.annotation.Column;
+import com.sixgreen.cube.annotation.MultiUnique;
+import com.sixgreen.cube.annotation.NotNull;
+import com.sixgreen.cube.annotation.Unique;
+import com.sixgreen.cube.util.KeyWordUtil;
+import com.sixgreen.cube.util.NameUtil;
+import com.sixgreen.cube.util.ReflectionUtil;
+
+import java.lang.reflect.Field;
+import java.util.List;
+
+/**
+ * Created by bpappin on 16-08-23.
+ */
+public class SqlBuilder {
+    public static final String NULL = " NULL";
+    public static final String NOT_NULL = " NOT NULL";
+    public static final String UNIQUE = " UNIQUE";
+
+    public static String createTableSQL(CubeConfig config, Class<?> table) {
+        if (config.isDebug()) {
+            Log.i(Cube.TAG, "Create table if not exists");
+        }
+        List<Field> fields = ReflectionUtil.getTableFields(config, table);
+        String tableName = NameUtil.toTableName(table);
+
+        if (KeyWordUtil.isKeyword(tableName)) {
+            //if (config.isDebug()) {
+                Log.e(Cube.TAG, "SQLITE RESERVED WORD USED IN " + tableName);
+            //}
+        }
+
+        StringBuilder sb = new StringBuilder("CREATE TABLE IF NOT EXISTS ");
+        sb.append(tableName).append(" ( "+Cube.DEFAULT_ID_COLUMN+" INTEGER PRIMARY KEY AUTOINCREMENT ");
+
+        for (Field column : fields) {
+            String columnName = NameUtil.toColumnName(column);
+            String columnType = QueryBuilder.getColumnType(column.getType());
+
+            if (columnType != null) {
+                if (columnName.equalsIgnoreCase(Cube.DEFAULT_ID_COLUMN)) {
+                    continue;
+                }
+
+                if (column.isAnnotationPresent(Column.class)) {
+                    Column columnAnnotation = column.getAnnotation(Column.class);
+                    columnName = columnAnnotation.name();
+
+                    sb.append(", ").append(columnName).append(" ").append(columnType);
+
+                    if (columnAnnotation.notNull()) {
+                        if (columnType.endsWith(NULL)) {
+                            sb.delete(sb.length() - 5, sb.length());
+                        }
+                        sb.append(NOT_NULL);
+                    }
+
+                    if (columnAnnotation.unique()) {
+                        sb.append(UNIQUE);
+                    }
+
+                } else {
+                    sb.append(", ").append(columnName).append(" ").append(columnType);
+
+                    if (column.isAnnotationPresent(NotNull.class)) {
+                        if (columnType.endsWith(NULL)) {
+                            sb.delete(sb.length() - 5, sb.length());
+                        }
+                        sb.append(NOT_NULL);
+                    }
+
+                    if (column.isAnnotationPresent(Unique.class)) {
+                        sb.append(UNIQUE);
+                    }
+                }
+            }
+        }
+
+        if (table.isAnnotationPresent(MultiUnique.class)) {
+            String constraint = table.getAnnotation(MultiUnique.class).value();
+
+            sb.append(", UNIQUE(");
+
+            String[] constraintFields = constraint.split(",");
+            for (int i = 0; i < constraintFields.length; i++) {
+                String columnName = NameUtil.toSQLNameDefault(constraintFields[i]);
+                sb.append(columnName);
+
+                if (i < (constraintFields.length - 1)) {
+                    sb.append(",");
+                }
+            }
+
+            sb.append(") ON CONFLICT REPLACE");
+        }
+
+        sb.append(" ) ");
+        if (config.isDebug()) {
+            Log.i(Cube.TAG, "Creating table " + tableName);
+        }
+
+        return sb.toString();
+    }
+}
diff --git a/library/src/main/java/com/sixgreen/cube/util/KeyWordUtil.java b/library/src/main/java/com/sixgreen/cube/util/KeyWordUtil.java
new file mode 100644
index 00000000..35ec4bf3
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/util/KeyWordUtil.java
@@ -0,0 +1,41 @@
+package com.sixgreen.cube.util;
+
+/**
+ * @author jonatan.salas
+ */
+public final class KeyWordUtil {
+
+    private static final String[] KEY_WORDS = new String[] {
+            "", "ABORT", "ACTION", "ADD", "AFTER", "ALTER", "ANALYZE", "AND", "AS", "ASC", "ATTACH",
+            "AUTOINCREMENT", "BEFORE", "BEGIN", "BETWEEN", "BY", "CASCADE", "CASE", "CAST", "CHECK",
+            "COLLATE", "COLUMN", "COMMIT", "CONFLICT", "CONSTRAINT", "CREATE", "CROSS", "CURRENT_DATE",
+            "CURRENT_TIME", "CURRENT_TIMESTAMP", "DATABASE", "DEFAULT", "DEFERRABLE", "DEFERRED", "DELETE",
+            "DESC", "DETACH", "DISTINCT", "DROP", "EACH", "ELSE", "END", "ESCAPE", "EXCEPT", "EXCLUSIVE",
+            "EXISTS", "EXPLAIN", "FAIL", "FOR", "FOREIGN", "FROM", "FULL", "GLOB", "GROUP", "HAVING",
+            "IF", "IGNORE", "IMMEDIATE", "IN", "INDEX", "INDEXED", "INITIALLY", "INNER", "INSERT", "INSTEAD",
+            "INTERSECT", "INTO", "IS", "ISNULL", "JOIN", "KEY", "LEFT", "LIKE", "LIMIT", "MATCH", "NATURAL",
+            "NO", "NOT", "NOTNULL", "NULL", "OF", "OFFSET", "ON", "OR", "ORDER", "OUTER", "PLAN", "PRAGMA",
+            "PRIMARY", "QUERY", "RAISE", "RECURSIVE", "REFERENCES", "REGEXP", "REINDEX", "RELEASE", "RENAME",
+            "REPLACE", "RESTRICT", "RIGHT", "ROLLBACK", "ROW", "SAVEPOINT", "SELECT", "SET", "TABLE", "TEMP",
+            "TEMPORARY", "THEN", "TO", "TRANSACTION", "TRIGGER", "UNION", "UNIQUE", "UPDATE", "USING", "VACUUM",
+            "VALUES", "VIEW", "VIRTUAL", "WHEN", "WHERE", "WITH", "WITHOUT"
+    };
+
+    //Prevent instantiation
+    private KeyWordUtil() { }
+
+    public static boolean isKeyword(String word) {
+        if (null == word) {
+            return false;
+        }
+
+        for (String keyWord: KEY_WORDS) {
+            if (keyWord.equals(word)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
+
diff --git a/library/src/main/java/com/sixgreen/cube/util/NameUtil.java b/library/src/main/java/com/sixgreen/cube/util/NameUtil.java
new file mode 100644
index 00000000..859a3c2e
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/util/NameUtil.java
@@ -0,0 +1,101 @@
+package com.sixgreen.cube.util;
+
+import com.orm.annotation.Column;
+import com.orm.annotation.Table;
+import com.sixgreen.cube.Cube;
+import com.sixgreen.cube.annotation.Id;
+
+import java.lang.reflect.Field;
+
+public final class NameUtil {
+
+    //Prevent instantiation
+    private NameUtil() {
+    }
+
+    /**
+     * Converts a given CamelCasedString to UPPER_CASE_UNDER_SCORE.
+     *
+     * @param camelCased
+     *         a non empty camelCased string
+     * @return the equivalent string converted to UPPER_CASE_UNDER_SCORE unless camelCased equals
+     * "_id" (not case sensitive) in which case "_id" is returned
+     */
+    public static String toSQLNameDefault(String camelCased) {
+        if (camelCased.equalsIgnoreCase(Cube.DEFAULT_ID_COLUMN)) {
+            return Cube.DEFAULT_ID_COLUMN;
+        }
+
+        StringBuilder sb = new StringBuilder();
+        char[] buf = camelCased.toCharArray();
+
+        for (int i = 0; i < buf.length; i++) {
+            char prevChar = (i > 0) ? buf[i - 1] : 0;
+            char c = buf[i];
+            char nextChar = (i < buf.length - 1) ? buf[i + 1] : 0;
+            boolean isFirstChar = (i == 0);
+
+            if (isFirstChar || Character.isLowerCase(c) || Character.isDigit(c)) {
+                sb.append(Character.toUpperCase(c));
+            } else if (Character.isUpperCase(c)) {
+                if (Character.isLetterOrDigit(prevChar)) {
+                    if (Character.isLowerCase(prevChar)) {
+                        sb.append('_').append(c);
+                    } else if (nextChar > 0 && Character.isLowerCase(nextChar)) {
+                        sb.append('_').append(c);
+                    } else {
+                        sb.append(c);
+                    }
+                } else {
+                    sb.append(c);
+                }
+            }
+        }
+
+        return sb.toString();
+    }
+
+    /**
+     * Maps a Java Field object to the database's column name.
+     *
+     * @param field
+     *         the {@link Field} that will be mapped
+     * @return the name of the given Field as represented in the database. If the Field is annotated
+     * with {@link Column} then the {@link Column#name()} will be
+     * returned. If the Feild is annotated with {@link Id}, then "_id" will be returned. Else, the
+     * Field's {@link Field#getName()} will be
+     * converted from CamelCase to UNDER_SCORE notation
+     */
+    public static String toColumnName(Field field) {
+        if (field.isAnnotationPresent(Id.class)) {
+            return Cube.DEFAULT_ID_COLUMN;
+        } else if (field.isAnnotationPresent(Column.class)) {
+            Column annotation = field.getAnnotation(Column.class);
+            return annotation.name();
+        }
+
+        return toSQLNameDefault(field.getName());
+    }
+
+    /**
+     * Maps a Java Class to the name of the class.
+     *
+     * @param table
+     *         the generic {@link Class} that defines a database table
+     * @return if the given class is annotated with {@link Table} then the value for
+     * {@link Table#name()} will be returned. Else, the class' simple name will
+     * be converted from CamelCase to UNDER_SCORE notation
+     */
+    public static String toTableName(Class<?> table) {
+        if (table.isAnnotationPresent(Table.class)) {
+            Table annotation = table.getAnnotation(Table.class);
+            if ("".equals(annotation.name())) {
+                return NameUtil.toSQLNameDefault(table.getSimpleName());
+            }
+            return annotation.name();
+        }
+
+        return NameUtil.toSQLNameDefault(table.getSimpleName());
+    }
+
+}
diff --git a/library/src/main/java/com/sixgreen/cube/util/ReflectionUtil.java b/library/src/main/java/com/sixgreen/cube/util/ReflectionUtil.java
new file mode 100644
index 00000000..f299a99d
--- /dev/null
+++ b/library/src/main/java/com/sixgreen/cube/util/ReflectionUtil.java
@@ -0,0 +1,412 @@
+package com.sixgreen.cube.util;
+
+import android.content.ContentValues;
+import android.content.pm.PackageManager;
+import android.database.Cursor;
+import android.util.Log;
+
+import com.sixgreen.cube.Cube;
+import com.sixgreen.cube.CubeConfig;
+import com.sixgreen.cube.annotation.Ignore;
+import com.sixgreen.cube.annotation.Table;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.math.BigDecimal;
+import java.net.URL;
+import java.sql.Timestamp;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Collections;
+import java.util.Date;
+import java.util.Enumeration;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+//import com.orm.SugarRecord;
+//import com.orm.annotation.Ignore;
+//import com.orm.annotation.Table;
+//import com.orm.helper.ManifestHelper;
+//import com.orm.helper.MultiDexHelper;
+//import com.orm.helper.NamingHelper;
+//import com.orm.util.ContextUtil;
+//import com.orm.util.SugarConfig;
+
+public final class ReflectionUtil {
+
+    //Prevent instantiation..
+    private ReflectionUtil() {
+    }
+    public static boolean isEntity(Class<?> type) {
+        return !type.isPrimitive() &&
+               type.isAnnotationPresent(Table.class);
+    }
+    public static List<Field> getTableFields(CubeConfig config, Class<?> table) {
+        List<Field> fieldList = config.getFieldCache(table);
+        if (fieldList != null) {
+            return fieldList;
+        }
+
+        if (config.isDebug()) {
+            Log.d(Cube.TAG, "Fetching entity fields");
+        }
+
+        List<Field> typeFields = new ArrayList<>();
+        getAllFields(typeFields, table);
+
+        for (Iterator<Field> fieldsIterator = typeFields.iterator(); fieldsIterator.hasNext(); ) {
+            Field field = fieldsIterator.next();
+            if (field.isAnnotationPresent(Ignore.class) ||
+                !Modifier.isStatic(field.getModifiers()) ||
+                !Modifier.isTransient(field.getModifiers())) {
+                fieldsIterator.remove();
+            }
+        }
+
+
+        config.setFieldCache(table, typeFields);
+        return typeFields;
+    }
+
+    /**
+     * Collect all fields from this class and any super classes.
+     *
+     * @param fields
+     * @param type
+     * @return
+     */
+    private static List<Field> getAllFields(List<Field> fields, Class<?> type) {
+        Collections.addAll(fields, type.getDeclaredFields());
+
+        if (type.getSuperclass() != null) {
+            fields = getAllFields(fields, type.getSuperclass());
+        }
+
+        return fields;
+    }
+
+    public static void addFieldValueToColumn(CubeConfig config, ContentValues values, Field column, Object object,
+                                             Map<Object, Long> entitiesMap) {
+        column.setAccessible(true);
+        Class<?> columnType = column.getType();
+        try {
+            String columnName = NameUtil.toColumnName(column);
+            Object columnValue = column.get(object);
+
+            if (columnType.isAnnotationPresent(Table.class)) {
+                Field field;
+                try {
+                    field = columnType.getDeclaredField("id");
+                    field.setAccessible(true);
+                    values.put(columnName,
+                            (field != null)
+                            ? String.valueOf(field.get(columnValue)) : "0");
+                } catch (NoSuchFieldException e) {
+                    if (entitiesMap.containsKey(columnValue)) {
+                        values.put(columnName, entitiesMap.get(columnValue));
+                    }
+                }
+                // XXX This might be revived as a base class for entities, but remove it for now.
+                //} else if (SugarRecord.class.isAssignableFrom(columnType)) {
+                //    values.put(columnName,
+                //            (columnValue != null)
+                //            ? String.valueOf(((SugarRecord) columnValue).getId())
+                //            : "0");
+            } else {
+                if (columnType.equals(Short.class) || columnType.equals(short.class)) {
+                    values.put(columnName, (Short) columnValue);
+                } else if (columnType.equals(Integer.class) || columnType.equals(int.class)) {
+                    values.put(columnName, (Integer) columnValue);
+                } else if (columnType.equals(Long.class) || columnType.equals(long.class)) {
+                    values.put(columnName, (Long) columnValue);
+                } else if (columnType.equals(Float.class) || columnType.equals(float.class)) {
+                    values.put(columnName, (Float) columnValue);
+                } else if (columnType.equals(Double.class) || columnType.equals(double.class)) {
+                    values.put(columnName, (Double) columnValue);
+                } else if (columnType.equals(Boolean.class) || columnType.equals(boolean.class)) {
+                    values.put(columnName, (Boolean) columnValue);
+                } else if (columnType.equals(BigDecimal.class)) {
+                    try {
+                        values.put(columnName, column.get(object).toString());
+                    } catch (NullPointerException e) {
+                        values.putNull(columnName);
+                    }
+                } else if (Timestamp.class.equals(columnType)) {
+                    try {
+                        values.put(columnName, ((Timestamp) column.get(object)).getTime());
+                    } catch (NullPointerException e) {
+                        values.put(columnName, (Long) null);
+                    }
+                } else if (Date.class.equals(columnType)) {
+                    try {
+                        values.put(columnName, ((Date) column.get(object)).getTime());
+                    } catch (NullPointerException e) {
+                        values.put(columnName, (Long) null);
+                    }
+                } else if (Calendar.class.equals(columnType)) {
+                    try {
+                        values.put(columnName, ((Calendar) column.get(object)).getTimeInMillis());
+                    } catch (NullPointerException e) {
+                        values.put(columnName, (Long) null);
+                    }
+                } else if (columnType.equals(byte[].class)) {
+                    if (columnValue == null) {
+                        values.put(columnName, "".getBytes());
+                    } else {
+                        values.put(columnName, (byte[]) columnValue);
+                    }
+                } else {
+                    if (columnValue == null) {
+                        values.putNull(columnName);
+                    } else if (columnType.isEnum()) {
+                        values.put(columnName, ((Enum) columnValue).name());
+                    } else {
+                        values.put(columnName, String.valueOf(columnValue));
+                    }
+                }
+            }
+
+        } catch (IllegalAccessException e) {
+            if (config.isDebug()) {
+                Log.e(Cube.TAG, "Could not collect column values from entity.", e);
+            }
+        }
+    }
+
+    public static void setFieldValueFromCursor(CubeConfig config, Cursor cursor, Field field, Object object) {
+        field.setAccessible(true);
+        try {
+            Class fieldType = field.getType();
+            String colName = NameUtil.toColumnName(field);
+
+            int columnIndex = cursor.getColumnIndex(colName);
+
+            //TODO auto upgrade to add new columns
+            if (columnIndex < 0) {
+                if (config.isDebug()) {
+                    Log.e(Cube.TAG, "Invalid colName, you should upgrade database");
+                }
+                return;
+            }
+
+            if (cursor.isNull(columnIndex)) {
+                return;
+            }
+
+            if (colName.equalsIgnoreCase(Cube.DEFAULT_ID_COLUMN)) {
+                long cid = cursor.getLong(columnIndex);
+                field.set(object, cid);
+            } else if (fieldType.equals(long.class) || fieldType.equals(Long.class)) {
+                field.set(object,
+                        cursor.getLong(columnIndex));
+            } else if (fieldType.equals(String.class)) {
+                String val = cursor.getString(columnIndex);
+                field.set(object, val != null && val.equals("null") ? null : val);
+            } else if (fieldType.equals(double.class) || fieldType.equals(Double.class)) {
+                field.set(object,
+                        cursor.getDouble(columnIndex));
+            } else if (fieldType.equals(boolean.class) || fieldType.equals(Boolean.class)) {
+                field.set(object,
+                        cursor.getString(columnIndex).equals("1"));
+            } else if (fieldType.equals(int.class) || fieldType.equals(Integer.class)) {
+                field.set(object,
+                        cursor.getInt(columnIndex));
+            } else if (fieldType.equals(float.class) || fieldType.equals(Float.class)) {
+                field.set(object,
+                        cursor.getFloat(columnIndex));
+            } else if (fieldType.equals(short.class) || fieldType.equals(Short.class)) {
+                field.set(object,
+                        cursor.getShort(columnIndex));
+            } else if (fieldType.equals(BigDecimal.class)) {
+                String val = cursor.getString(columnIndex);
+                field.set(object, val != null && val.equals("null") ? null : new BigDecimal(val));
+            } else if (fieldType.equals(Timestamp.class)) {
+                long l = cursor.getLong(columnIndex);
+                field.set(object, new Timestamp(l));
+            } else if (fieldType.equals(Date.class)) {
+                long l = cursor.getLong(columnIndex);
+                field.set(object, new Date(l));
+            } else if (fieldType.equals(Calendar.class)) {
+                long l = cursor.getLong(columnIndex);
+                Calendar c = Calendar.getInstance();
+                c.setTimeInMillis(l);
+                field.set(object, c);
+            } else if (fieldType.equals(byte[].class)) {
+                byte[] bytes = cursor.getBlob(columnIndex);
+                if (bytes == null) {
+                    field.set(object, "".getBytes());
+                } else {
+                    field.set(object, cursor.getBlob(columnIndex));
+                }
+            } else if (Enum.class.isAssignableFrom(fieldType)) {
+                try {
+                    Method valueOf = field.getType().getMethod("valueOf", String.class);
+                    String strVal = cursor.getString(columnIndex);
+                    Object enumVal = valueOf.invoke(field.getType(), strVal);
+                    field.set(object, enumVal);
+                } catch (Exception e) {
+                    if (config.isDebug()) {
+                        Log.e(Cube.TAG,
+                                "Enum cannot be read from Sqlite3 database. Please check the type of field " +
+                                field.getName(), e);
+                    }
+                }
+            } else {
+                if (config.isDebug()) {
+                    Log.e(Cube.TAG,
+                            "Class cannot be read from Sqlite3 database. Please check the type of field " +
+                            field.getName() + "(" + field.getType().getName() + ")");
+                }
+            }
+        } catch (IllegalArgumentException | IllegalAccessException e) {
+            if (config.isDebug()) {
+                Log.e(Cube.TAG, "field set error", e);
+            }
+        }
+    }
+
+    private static Field getDeepField(String fieldName, Class<?> type) throws
+                                                                                          NoSuchFieldException {
+        try {
+            return type.getDeclaredField(fieldName);
+        } catch (NoSuchFieldException e) {
+            Class superclass = type.getSuperclass();
+            if (superclass != null) {
+                return getDeepField(fieldName, superclass);
+            } else {
+                throw e;
+            }
+        }
+    }
+
+    public static void setFieldValueForId(Object object, Long value) {
+        try {
+            Field field = getDeepField(Cube.DEFAULT_ID_COLUMN, object.getClass());
+            field.setAccessible(true);
+            field.set(object, value);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    // XXX All the stuff below this is for class scanning, which we don't need at this point.
+
+    //public static List<Class> getDomainClasses(CubeConfig config) {
+    //    List<Class> domainClasses = new ArrayList<>();
+    //    try {
+    //        for (String className : getAllClasses(config)) {
+    //            Class domainClass = getDomainClass(className);
+    //            if (domainClass != null) {
+    //                domainClasses.add(domainClass);
+    //            }
+    //        }
+    //    } catch (IOException | PackageManager.NameNotFoundException e) {
+    //        if (config.isDebug()) {
+    //            Log.e(Cube.TAG, e.getMessage());
+    //        }
+    //    }
+    //
+    //    return domainClasses;
+    //}
+    //
+    //private static Class getDomainClass(CubeConfig config, String className) {
+    //    Class<?> discoveredClass = null;
+    //    try {
+    //        discoveredClass = Class
+    //                .forName(className, true, Thread.currentThread().getContextClassLoader());
+    //    } catch (Throwable e) {
+    //        String error = (e.getMessage() == null) ? "getDomainClass " + className + " error"
+    //                                                : e.getMessage();
+    //        if (config.isDebug()) {
+    //            Log.e(Cube.TAG, error, e);
+    //        }
+    //    }
+    //
+    //    if ((discoveredClass != null) &&
+    //        ((SugarRecord.class.isAssignableFrom(discoveredClass) &&
+    //          !SugarRecord.class.equals(discoveredClass)) ||
+    //         discoveredClass.isAnnotationPresent(Table.class)) &&
+    //        !Modifier.isAbstract(discoveredClass.getModifiers())) {
+    //
+    //        if (config.isDebug()) {
+    //            Log.i(Cube.TAG, "domain class : " + discoveredClass.getSimpleName());
+    //        }
+    //        return discoveredClass;
+    //
+    //    } else {
+    //        return null;
+    //    }
+    //}
+    //
+    //
+    //private static List<String> getAllClasses(CubeConfig config) throws
+    //                                                             PackageManager.NameNotFoundException,
+    //                                                             IOException {
+    //    String packageName = ManifestHelper.getDomainPackageName();
+    //    List<String> classNames = new ArrayList<>();
+    //    try {
+    //        List<String> allClasses = MultiDexHelper.getAllClasses();
+    //        for (String classString : allClasses) {
+    //            if (classString.startsWith(packageName)) {
+    //                classNames.add(classString);
+    //            }
+    //        }
+    //    } catch (NullPointerException e) {
+    //        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
+    //        Enumeration<URL> urls = classLoader.getResources("");
+    //        while (urls.hasMoreElements()) {
+    //            List<String> fileNames = new ArrayList<>();
+    //            String classDirectoryName = urls.nextElement().getFile();
+    //            if (classDirectoryName.contains("bin") || classDirectoryName.contains("classes")
+    //                || classDirectoryName.contains("retrolambda")) {
+    //                File classDirectory = new File(classDirectoryName);
+    //                for (File filePath : classDirectory.listFiles()) {
+    //                    populateFiles(filePath, fileNames, "");
+    //                }
+    //                for (String fileName : fileNames) {
+    //                    if (fileName.startsWith(packageName)) {
+    //                        classNames.add(fileName);
+    //                    }
+    //                }
+    //            }
+    //        }
+    //    }
+    //    //        } finally {
+    //    //            if (null != dexfile) dexfile.close();
+    //    //        }
+    //
+    //    return classNames;
+    //}
+    //
+    //private static void populateFiles(CubeConfig config, File path, List<String> fileNames, String parent) {
+    //    if (path.isDirectory()) {
+    //        for (File newPath : path.listFiles()) {
+    //            if ("".equals(parent)) {
+    //                populateFiles(config, newPath, fileNames, path.getName());
+    //            } else {
+    //                populateFiles(config, newPath, fileNames, parent + "." + path.getName());
+    //            }
+    //        }
+    //    } else {
+    //        String pathName = path.getName();
+    //        String classSuffix = ".class";
+    //        pathName = pathName.endsWith(classSuffix) ?
+    //                   pathName.substring(0, pathName.length() - classSuffix.length()) : pathName;
+    //        if ("".equals(parent)) {
+    //            fileNames.add(pathName);
+    //        } else {
+    //            fileNames.add(parent + "." + pathName);
+    //        }
+    //    }
+    //}
+    //
+    //private static String getSourcePath(CubeConfig config) throws
+    //                                                       PackageManager.NameNotFoundException {
+    //    return ContextUtil.getPackageManager()
+    //                      .getApplicationInfo(ContextUtil.getPackageName(), 0).sourceDir;
+    //}
+}
