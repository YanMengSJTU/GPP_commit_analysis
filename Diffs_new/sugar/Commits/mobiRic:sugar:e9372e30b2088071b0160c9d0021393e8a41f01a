diff --git a/library/src/com/orm/SugarDb.java b/library/src/com/orm/SugarDb.java
index 15bef1f7..360c9113 100644
--- a/library/src/com/orm/SugarDb.java
+++ b/library/src/com/orm/SugarDb.java
@@ -19,176 +19,233 @@
 import static com.orm.SugarConfig.getDatabaseVersion;
 import static com.orm.SugarConfig.getDebugEnabled;
 
-public class SugarDb extends SQLiteOpenHelper {
-    private Context context;
-
-    public SugarDb(Context context) {
-        super(context, SugarConfig.getDatabaseName(context), new SugarCursorFactory(getDebugEnabled(context)), getDatabaseVersion(context));
-        this.context = context;
-
-    }
-
-    private <T extends SugarRecord> List<T> getDomainClasses(Context context) {
-        List<T> domainClasses = new ArrayList<T>();
-        try {
-            Enumeration allClasses = getAllClasses(context);
-
-            while (allClasses.hasMoreElements()) {
-                String className = (String) allClasses.nextElement();
-
-                if (className.startsWith(SugarConfig.getDomainPackageName(context))) {
-                    T domainClass = getDomainClass(className, context);
-                    if (domainClass != null) domainClasses.add(domainClass);
-                }
-            }
-
-        } catch (IOException e) {
-            Log.e("Sugar", e.getMessage());
-        } catch (PackageManager.NameNotFoundException e) {
-            Log.e("Sugar", e.getMessage());
-        }
-
-        return domainClasses;
-    }
-
-    private <T extends SugarRecord> T getDomainClass(String className, Context context) {
-        Log.i("Sugar", "domain class");
-        Class discoveredClass = null;
-        try {
-            discoveredClass = Class.forName(className, true, context.getClass().getClassLoader());
-        } catch (ClassNotFoundException e) {
-            Log.e("Sugar", e.getMessage());
-        }
-
-        if ((discoveredClass == null) ||
-                (!SugarRecord.class.isAssignableFrom(discoveredClass)) ||
-                Modifier.isAbstract(discoveredClass.getModifiers())) {
-            return null;
-        } else {
-            try {
-                return (T) discoveredClass.getDeclaredConstructor(Context.class).newInstance(context);
-            } catch (InstantiationException e) {
-                Log.e("Sugar", e.getMessage());
-            } catch (IllegalAccessException e) {
-                Log.e("Sugar", e.getMessage());
-            } catch (NoSuchMethodException e) {
-                Log.e("Sugar", e.getMessage());
-            } catch (InvocationTargetException e) {
-                Log.e("Sugar", e.getMessage());
-            }
-        }
-
-        return null;
-
-    }
-
-    private Enumeration getAllClasses(Context context) throws PackageManager.NameNotFoundException, IOException {
-        String path = getSourcePath(context);
-        DexFile dexfile = new DexFile(path);
-        return dexfile.entries();
-    }
-
-    private String getSourcePath(Context context) throws PackageManager.NameNotFoundException {
-        return context.getPackageManager().getApplicationInfo(context.getPackageName(), 0).sourceDir;
-    }
-
-    @Override
-    public void onCreate(SQLiteDatabase sqLiteDatabase) {
-        Log.i("Sugar", "on create");
-        createDatabase(sqLiteDatabase);
-    }
-
-    private <T extends SugarRecord> void createDatabase(SQLiteDatabase sqLiteDatabase) {
-        List<T> domainClasses = getDomainClasses(context);
-        for (T domain : domainClasses) {
-            createTable(domain, sqLiteDatabase);
-        }
-    }
-
-    private <T extends SugarRecord> void createTable(T table, SQLiteDatabase sqLiteDatabase) {
-        Log.i("Sugar", "create table");
-        List<Field> fields = table.getTableFields();
-        StringBuilder sb = new StringBuilder("CREATE TABLE ").append(table.getSqlName()).append(
-                " ( ID INTEGER PRIMARY KEY AUTOINCREMENT ");
-
-        for (Field column : fields) {
-            String columnName = StringUtil.toSQLName(column.getName());
-            String columnType = QueryBuilder.getColumnType(column.getType());
-
-            if (columnType != null) {
-
-                if (columnName.equalsIgnoreCase("Id")) {
-                    continue;
-                }
-                sb.append(", ").append(columnName).append(" ").append(columnType);
-            }
-        }
-        sb.append(" ) ");
-
-        Log.i("Sugar", "creating table " + table.getSqlName());
-
-        if (!"".equals(sb.toString()))
-            sqLiteDatabase.execSQL(sb.toString());
-    }
-
-    @Override
-    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {
-        Log.i("Sugar", "upgrading sugar");
-        if (!executeSugarUpgrade(sqLiteDatabase, oldVersion, newVersion)) {
-            deleteTables(sqLiteDatabase);
-            onCreate(sqLiteDatabase);
-        }
-    }
-
-    private <T extends SugarRecord> void deleteTables(SQLiteDatabase sqLiteDatabase) {
-        List<T> tables = getDomainClasses(this.context);
-        for (T table : tables) {
-            sqLiteDatabase.execSQL("DROP TABLE IF EXISTS " + table.getSqlName());
-        }
-    }
-
-    private boolean executeSugarUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-
-        boolean isSuccess = false;
-        try {
-            List<String> files = Arrays.asList(this.context.getAssets().list("sugar_upgrades"));
-            Collections.sort(files, new NumberComparator());
-
-            for (String file : files){
-                Log.i("Sugar", "filename : " + file);
-                try {
-                    int version = Integer.valueOf(file.replace(".sql", ""));
-
-                    if ((version > oldVersion) && (version <= newVersion)) {
-                        executeScript(db, file);
-                        isSuccess = true;
-                    }
-                } catch (NumberFormatException e) {
-                    Log.i("Sugar", "not a sugar script. ignored." + file);
-                }
-            }
-        } catch (IOException e) {
-            Log.e("Sugar", e.getMessage());
-        }
-
-        return isSuccess;
-    }
-
-    private void executeScript(SQLiteDatabase db, String file) {
-        StringBuilder text = new StringBuilder();
-        try {
-            InputStream is = this.context.getAssets().open("sugar_upgrades/" + file);
-            BufferedReader reader = new BufferedReader(new InputStreamReader(is));
-            String line;
-            while ((line = reader.readLine()) != null) {
-                text.append(line);
-                text.append("\n");
-            }
-        } catch (IOException e) {
-            Log.e("Sugar", e.getMessage());
-        }
-
-        Log.i("Sugar", "script : " + text.toString());
-        db.execSQL(text.toString());
-    }
+public class SugarDb extends SQLiteOpenHelper
+{
+	private Context context;
+
+	public SugarDb(Context context)
+	{
+		super(context, SugarConfig.getDatabaseName(context), new SugarCursorFactory(
+				getDebugEnabled(context)), getDatabaseVersion(context));
+		this.context = context;
+
+	}
+
+	private <T extends SugarRecord> List<T> getDomainClasses(Context context)
+	{
+		List<T> domainClasses = new ArrayList<T>();
+		try
+		{
+			Enumeration allClasses = getAllClasses(context);
+
+			while (allClasses.hasMoreElements())
+			{
+				String className = (String) allClasses.nextElement();
+
+				if (className.startsWith(SugarConfig.getDomainPackageName(context)))
+				{
+					T domainClass = getDomainClass(className, context);
+					if (domainClass != null)
+						domainClasses.add(domainClass);
+				}
+			}
+
+		}
+		catch (IOException e)
+		{
+			Log.e("Sugar", e.getMessage());
+		}
+		catch (PackageManager.NameNotFoundException e)
+		{
+			Log.e("Sugar", e.getMessage());
+		}
+
+		return domainClasses;
+	}
+
+	private <T extends SugarRecord> T getDomainClass(String className, Context context)
+	{
+		Log.i("Sugar", "domain class");
+		Class discoveredClass = null;
+		try
+		{
+			discoveredClass = Class.forName(className, true, context.getClass().getClassLoader());
+		}
+		catch (ClassNotFoundException e)
+		{
+			Log.e("Sugar", e.getMessage());
+		}
+
+		if ((discoveredClass == null) || (!SugarRecord.class.isAssignableFrom(discoveredClass))
+				|| Modifier.isAbstract(discoveredClass.getModifiers()))
+		{
+			return null;
+		}
+		else
+		{
+			try
+			{
+				return (T) discoveredClass.getDeclaredConstructor(Context.class).newInstance(
+						context);
+			}
+			catch (InstantiationException e)
+			{
+				Log.e("Sugar", e.getMessage());
+			}
+			catch (IllegalAccessException e)
+			{
+				Log.e("Sugar", e.getMessage());
+			}
+			catch (NoSuchMethodException e)
+			{
+				Log.e("Sugar", e.getMessage());
+			}
+			catch (InvocationTargetException e)
+			{
+				Log.e("Sugar", e.getMessage());
+			}
+		}
+
+		return null;
+
+	}
+
+	private Enumeration getAllClasses(Context context)
+			throws PackageManager.NameNotFoundException, IOException
+	{
+		String path = getSourcePath(context);
+		DexFile dexfile = new DexFile(path);
+		return dexfile.entries();
+	}
+
+	private String getSourcePath(Context context) throws PackageManager.NameNotFoundException
+	{
+		return context.getPackageManager().getApplicationInfo(context.getPackageName(), 0).sourceDir;
+	}
+
+	@Override
+	public void onCreate(SQLiteDatabase sqLiteDatabase)
+	{
+		Log.i("Sugar", "on create");
+		createDatabase(sqLiteDatabase);
+	}
+
+	private <T extends SugarRecord> void createDatabase(SQLiteDatabase sqLiteDatabase)
+	{
+		List<T> domainClasses = getDomainClasses(context);
+		for (T domain : domainClasses)
+		{
+			createTable(domain, sqLiteDatabase);
+		}
+	}
+
+	private <T extends SugarRecord> void createTable(T table, SQLiteDatabase sqLiteDatabase)
+	{
+		Log.i("Sugar", "create table");
+		List<Field> fields = table.getTableFields();
+		StringBuilder sb =
+				new StringBuilder("CREATE TABLE ").append(table.getSqlName()).append(
+						" ( _id INTEGER PRIMARY KEY AUTOINCREMENT ");
+
+		for (Field column : fields)
+		{
+			String columnName = StringUtil.toSQLName(column.getName());
+			String columnType = QueryBuilder.getColumnType(column.getType());
+
+			if (columnType != null)
+			{
+
+				if (columnName.equalsIgnoreCase("_id"))
+				{
+					continue;
+				}
+				sb.append(", ").append(columnName).append(" ").append(columnType);
+			}
+		}
+		sb.append(" ) ");
+
+		Log.i("Sugar", "creating table " + table.getSqlName());
+
+		if (!"".equals(sb.toString()))
+			sqLiteDatabase.execSQL(sb.toString());
+	}
+
+	@Override
+	public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion)
+	{
+		Log.i("Sugar", "upgrading sugar");
+		if (!executeSugarUpgrade(sqLiteDatabase, oldVersion, newVersion))
+		{
+			deleteTables(sqLiteDatabase);
+			onCreate(sqLiteDatabase);
+		}
+	}
+
+	private <T extends SugarRecord> void deleteTables(SQLiteDatabase sqLiteDatabase)
+	{
+		List<T> tables = getDomainClasses(this.context);
+		for (T table : tables)
+		{
+			sqLiteDatabase.execSQL("DROP TABLE IF EXISTS " + table.getSqlName());
+		}
+	}
+
+	private boolean executeSugarUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)
+	{
+
+		boolean isSuccess = false;
+		try
+		{
+			List<String> files = Arrays.asList(this.context.getAssets().list("sugar_upgrades"));
+			Collections.sort(files, new NumberComparator());
+
+			for (String file : files)
+			{
+				Log.i("Sugar", "filename : " + file);
+				try
+				{
+					int version = Integer.valueOf(file.replace(".sql", ""));
+
+					if ((version > oldVersion) && (version <= newVersion))
+					{
+						executeScript(db, file);
+						isSuccess = true;
+					}
+				}
+				catch (NumberFormatException e)
+				{
+					Log.i("Sugar", "not a sugar script. ignored." + file);
+				}
+			}
+		}
+		catch (IOException e)
+		{
+			Log.e("Sugar", e.getMessage());
+		}
+
+		return isSuccess;
+	}
+
+	private void executeScript(SQLiteDatabase db, String file)
+	{
+		StringBuilder text = new StringBuilder();
+		try
+		{
+			InputStream is = this.context.getAssets().open("sugar_upgrades/" + file);
+			BufferedReader reader = new BufferedReader(new InputStreamReader(is));
+			String line;
+			while ((line = reader.readLine()) != null)
+			{
+				text.append(line);
+				text.append("\n");
+			}
+		}
+		catch (IOException e)
+		{
+			Log.e("Sugar", e.getMessage());
+		}
+
+		Log.i("Sugar", "script : " + text.toString());
+		db.execSQL(text.toString());
+	}
 }
diff --git a/library/src/com/orm/SugarRecord.java b/library/src/com/orm/SugarRecord.java
index 24e678a3..45e3aaf2 100644
--- a/library/src/com/orm/SugarRecord.java
+++ b/library/src/com/orm/SugarRecord.java
@@ -1,266 +1,367 @@
 package com.orm;
 
+import static com.orm.SugarApp.getSugarContext;
+
+import java.lang.reflect.Field;
+import java.sql.Timestamp;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
 import android.content.ContentValues;
 import android.content.Context;
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteException;
 import android.util.Log;
-import com.orm.dsl.Ignore;
 
-import java.lang.reflect.Field;
-import java.sql.Timestamp;
-import java.util.*;
-
-import static com.orm.SugarApp.getSugarContext;
+import com.orm.dsl.Ignore;
 
-public class SugarRecord<T> {
-
-    @Ignore
-    private Context context;
-    @Ignore
-    private SugarApp application;
-    @Ignore
-    private Database database;
-    @Ignore
-    String tableName = getSqlName();
-    
-    protected Long id = null;
-    
-    public SugarRecord(Context context) {
-        this.context = context;
-        this.application = (SugarApp) context.getApplicationContext();
-        this.database = application.database;
-    }
-
-    public void delete() {
-        SQLiteDatabase db = this.database.openDB();
-        db.delete(this.tableName, "Id=?", new String[]{getId().toString()});
-        this.database.closeDB();
-
-    }
-
-    public static <T extends SugarRecord> void deleteAll(Class<T> type) {
-        Database db = getSugarContext().database;
-        SQLiteDatabase sqLiteDatabase = db.openDB();
-        sqLiteDatabase.delete(getTableName(type), null, null);
-    }
-
-    public static <T extends SugarRecord> void deleteAll(Class<T> type, String whereClause, String... whereArgs ) {
-        Database db = getSugarContext().database;
-        SQLiteDatabase sqLiteDatabase = db.openDB();
-        sqLiteDatabase.delete(getTableName(type), whereClause, whereArgs);
-    }
-
-    public void save() {
-        SQLiteDatabase sqLiteDatabase = database.openDB();
-        List<Field> columns = getTableFields();
-        ContentValues values = new ContentValues(columns.size());
-        for (Field column : columns) {
-            column.setAccessible(true);
-            try {
-                if (SugarRecord.class.isAssignableFrom(column.getType())) {
-                    values.put(StringUtil.toSQLName(column.getName()),
-                            (column.get(this) != null)
-                                    ? String.valueOf(((SugarRecord) column.get(this)).id)
-                                    : "0");
-                } else {
-                    if (!"id".equalsIgnoreCase(column.getName())) {
-                        values.put(StringUtil.toSQLName(column.getName()),
-                                String.valueOf(column.get(this)));
-                    }
-                }
-
-            } catch (IllegalAccessException e) {
-                Log.e("Sugar", e.getMessage());
-            }
-        }
-
-        if (id == null)
-                id = sqLiteDatabase.insert(getSqlName(), null, values);
-        else
-                sqLiteDatabase.update(getSqlName(), values, "ID = ?", new String[]{String.valueOf(id)});
-
-        Log.i("Sugar", getClass().getSimpleName() + " saved : " + id);
-        database.closeDB();
-    }
-
-    public static <T extends SugarRecord> List<T> listAll(Class<T> type) {
-        return find(type, null, null, null, null, null);
-    }
-
-    public static <T extends SugarRecord> T findById(Class<T> type, Long id) {
-        List<T> list = find( type, "id=?", new String[]{String.valueOf(id)}, null, null, "1");
-        if (list.isEmpty()) return null;
-        return list.get(0);
-    }
-
-    public static <T extends SugarRecord> List<T> find(Class<T> type,
-                                                       String whereClause, String... whereArgs) {
-        return find(type, whereClause, whereArgs, null, null, null);
-    }
-
-    public static <T extends SugarRecord> List<T> findWithQuery(Class<T> type, String query, String... arguments){
-
-        Database db = getSugarContext().database;
-        SQLiteDatabase sqLiteDatabase = db.openDB();
-        T entity;
-        List<T> toRet = new ArrayList<T>();
-        Cursor c = sqLiteDatabase.rawQuery(query, arguments);
-
-        try {
-            while (c.moveToNext()) {
-                entity = type.getDeclaredConstructor(Context.class).newInstance(getSugarContext());
-                entity.inflate(c);
-                toRet.add(entity);
-            }
-        } catch (Exception e) {
-            e.printStackTrace();
-        } finally {
-            c.close();
-        }
-        return toRet;
-    }
-
-    public static void executeQuery(String query, String... arguments){
-        getSugarContext().database.openDB().execSQL(query, arguments);
-    }
-
-    public static <T extends SugarRecord> List<T> find(Class<T> type,
-                                                       String whereClause, String[] whereArgs,
-                                                       String groupBy, String orderBy, String limit) {
-        Database db = getSugarContext().database;
-        SQLiteDatabase sqLiteDatabase = db.openDB();
-        T entity;
-        List<T> toRet = new ArrayList<T>();
-        Cursor c = sqLiteDatabase.query(getTableName(type), null,
-                whereClause, whereArgs, groupBy, null, orderBy, limit);
-        try {
-            while (c.moveToNext()) {
-                entity = type.getDeclaredConstructor(Context.class).newInstance(getSugarContext());
-                entity.inflate(c);
-                toRet.add(entity);
-            }
-        } catch (Exception e) {
-            e.printStackTrace();
-        } finally {
-            c.close();
-        }
-        return toRet;
-    }
-
-    void inflate(Cursor cursor) {
-        Map<Field, Long> entities = new HashMap<Field, Long>();
-        List<Field> columns = getTableFields();
-        for (Field field : columns) {
-            field.setAccessible(true);
-            try {
-                String typeString = field.getType().getName();
-                String colName = StringUtil.toSQLName(field.getName());
-
-                if(colName.equalsIgnoreCase("id")){
-                    long cid = cursor.getLong(cursor.getColumnIndex(colName));
-                    field.set(this, Long.valueOf(cid));
-                }else if (typeString.equals("long")) {
-                    field.setLong(this,
-                            cursor.getLong(cursor.getColumnIndex(colName)));
-                } else if (typeString.equals("java.lang.String")) {
-                    String val = cursor.getString(cursor
-                            .getColumnIndex(colName));
-                    field.set(this, val.equals("null") ? null : val);
-                } else if (typeString.equals("double")) {
-                    field.setDouble(this,
-                            cursor.getDouble(cursor.getColumnIndex(colName)));
-                } else if (typeString.equals("boolean")) {
-                    field.setBoolean(this,
-                            cursor.getString(cursor.getColumnIndex(colName))
-                                    .equals("true"));
-                } else if (typeString.equals("[B")) {
-                    field.set(this,
-                            cursor.getBlob(cursor.getColumnIndex(colName)));
-                } else if (typeString.equals("int")) {
-                    field.setInt(this,
-                            cursor.getInt(cursor.getColumnIndex(colName)));
-                } else if (typeString.equals("float")) {
-                    field.setFloat(this,
-                            cursor.getFloat(cursor.getColumnIndex(colName)));
-                } else if (typeString.equals("short")) {
-                    field.setShort(this,
-                            cursor.getShort(cursor.getColumnIndex(colName)));
-                } else if (typeString.equals("java.sql.Timestamp")) {
-                    long l = cursor.getLong(cursor.getColumnIndex(colName));
-                    field.set(this, new Timestamp(l));
-                } else if (SugarRecord.class.isAssignableFrom(field.getType())) {
-                    long id = cursor.getLong(cursor.getColumnIndex(colName));
-                    if (id > 0)
-                        entities.put(field, id);
-                    else
-                        field.set(this, null);
-                } else
-                    Log.e("Sugar", "Class cannot be read from Sqlite3 database.");
-            } catch (IllegalArgumentException e) {
-                Log.e("field set error", e.getMessage());
-            } catch (IllegalAccessException e) {
-                Log.e("field set error", e.getMessage());
-            }
-
-        }
-
-        for (Field f : entities.keySet()) {
-            try {
-                f.set(this, findById((Class<? extends SugarRecord>) f.getType(),
-                        entities.get(f)));
-            } catch (SQLiteException e) {
-            } catch (IllegalArgumentException e) {
-            } catch (IllegalAccessException e) {
-            }
-        }
-    }
-
-    public List<Field> getTableFields() {
-        List<Field> fieldList = SugarConfig.getFields(getClass());
-        if(fieldList != null) return fieldList;
-
-        Log.d("Sugar", "Fetching properties");
-        List<Field> typeFields = new ArrayList<Field>();
-        
-        getAllFields(typeFields, getClass());
-        
-        List<Field> toStore = new ArrayList<Field>();
-        for (Field field : typeFields) {
-            if (!field.isAnnotationPresent(Ignore.class)) {
-                toStore.add(field);
-            }
-        }
-
-        SugarConfig.setFields(getClass(), toStore);
-        return toStore;
-    }
-    
-    private static List<Field> getAllFields(List<Field> fields, Class<?> type) {
-        Collections.addAll(fields, type.getDeclaredFields());
-
-        if (type.getSuperclass() != null) {
-            fields = getAllFields(fields, type.getSuperclass());
-        }
-
-        return fields;
-    }
-
-    public String getSqlName() {
-        return getTableName(getClass());
-    }
-
-
-    public static String getTableName(Class<?> type) {
-        return StringUtil.toSQLName(type.getSimpleName());
-    }
-
-    public Long getId() {
-        return id;
-    }
-
-    public void setId(Long id) {
-        this.id = id;
-    }
+public class SugarRecord<T>
+{
+
+	@Ignore
+	static ExecutorService threadExecutor = Executors.newCachedThreadPool();
+
+	@Ignore
+	private Context context;
+	@Ignore
+	private SugarApp application;
+	@Ignore
+	private Database database;
+	@Ignore
+	String tableName = getSqlName();
+
+	protected Long id = null;
+
+	public SugarRecord(Context context)
+	{
+		this.context = context;
+		this.application = (SugarApp) context.getApplicationContext();
+		this.database = application.database;
+	}
+
+	public void delete()
+	{
+		SQLiteDatabase db = this.database.openDB();
+		db.delete(this.tableName, "_id=?", new String[]
+			{ getId().toString() });
+		// this.database.closeDB();
+
+	}
+
+	public static <T extends SugarRecord> void deleteAll(Class<T> type)
+	{
+		Database db = getSugarContext().database;
+		SQLiteDatabase sqLiteDatabase = db.openDB();
+		sqLiteDatabase.delete(getTableName(type), null, null);
+	}
+
+	public static <T extends SugarRecord> void deleteAll(Class<T> type, String whereClause,
+			String... whereArgs)
+	{
+		Database db = getSugarContext().database;
+		SQLiteDatabase sqLiteDatabase = db.openDB();
+		sqLiteDatabase.delete(getTableName(type), whereClause, whereArgs);
+	}
+
+	public void save()
+	{
+		final SQLiteDatabase sqLiteDatabase = database.openDB();
+		threadExecutor.execute(new Runnable()
+		{
+
+			@Override
+			public void run()
+			{
+				List<Field> columns = getTableFields();
+				ContentValues values = new ContentValues(columns.size());
+				for (Field column : columns)
+				{
+					column.setAccessible(true);
+					try
+					{
+						if (SugarRecord.class.isAssignableFrom(column.getType()))
+						{
+							values.put(
+									StringUtil.toSQLName(column.getName()),
+									(column.get(this) != null) ? String
+											.valueOf(((SugarRecord) column.get(this)).id) : "0");
+						}
+						else
+						{
+							if (!"_id".equalsIgnoreCase(column.getName()))
+							{
+								values.put(StringUtil.toSQLName(column.getName()),
+										String.valueOf(column.get(SugarRecord.this)));
+							}
+						}
+
+					}
+					catch (IllegalAccessException e)
+					{
+						Log.e("Sugar", e.getMessage());
+					}
+				}
+
+				if (id == null)
+					id = sqLiteDatabase.insert(getSqlName(), null, values);
+				else
+					sqLiteDatabase.update(getSqlName(), values, "_id = ?", new String[]
+						{ String.valueOf(id) });
+
+				Log.i("Sugar", getClass().getSimpleName() + " saved : " + id);
+				// database.closeDB();
+			}
+		});
+	}
+
+	public static <T extends SugarRecord> List<T> listAll(Class<T> type)
+	{
+		return find(type, null, null, null, null, null);
+	}
+
+	public static <T extends SugarRecord> T findById(Class<T> type, Long id)
+	{
+		List<T> list = find(type, "_id=?", new String[]
+			{ String.valueOf(id) }, null, null, "1");
+		if (list.isEmpty())
+			return null;
+		return list.get(0);
+	}
+
+	public static <T extends SugarRecord> List<T> find(Class<T> type, String whereClause,
+			String... whereArgs)
+	{
+		return find(type, whereClause, whereArgs, null, null, null);
+	}
+
+	public static <T extends SugarRecord> List<T> findWithQuery(Class<T> type, String query,
+			String... arguments)
+	{
+
+		Database db = getSugarContext().database;
+		SQLiteDatabase sqLiteDatabase = db.openDB();
+		T entity;
+		List<T> toRet = new ArrayList<T>();
+		Cursor c = sqLiteDatabase.rawQuery(query, arguments);
+
+		try
+		{
+			while (c.moveToNext())
+			{
+				entity = type.getDeclaredConstructor(Context.class).newInstance(getSugarContext());
+				entity.inflate(c);
+				toRet.add(entity);
+			}
+		}
+		catch (Exception e)
+		{
+			e.printStackTrace();
+		}
+		finally
+		{
+			c.close();
+		}
+		return toRet;
+	}
+
+	public static void executeQuery(String query, String... arguments)
+	{
+		getSugarContext().database.openDB().execSQL(query, arguments);
+	}
+
+	public static <T extends SugarRecord> List<T> find(Class<T> type, String whereClause,
+			String[] whereArgs, String groupBy, String orderBy, String limit)
+	{
+		Cursor c = findCursor(type, whereClause, whereArgs, groupBy, orderBy, limit);
+		T entity;
+		List<T> toRet = new ArrayList<T>();
+		try
+		{
+			while (c.moveToNext())
+			{
+				entity = type.getDeclaredConstructor(Context.class).newInstance(getSugarContext());
+				entity.inflate(c);
+				toRet.add(entity);
+			}
+		}
+		catch (Exception e)
+		{
+			e.printStackTrace();
+		}
+		finally
+		{
+			c.close();
+		}
+		return toRet;
+	}
+
+	public static <T extends SugarRecord> Cursor findCursor(Class<T> type, String whereClause,
+			String[] whereArgs, String groupBy, String orderBy, String limit)
+	{
+		Database db = getSugarContext().database;
+		SQLiteDatabase sqLiteDatabase = db.openDB();
+		Cursor c =
+				sqLiteDatabase.query(getTableName(type), null, whereClause, whereArgs, groupBy,
+						null, orderBy, limit);
+		return c;
+	}
+
+	void inflate(Cursor cursor)
+	{
+		Map<Field, Long> entities = new HashMap<Field, Long>();
+		List<Field> columns = getTableFields();
+		for (Field field : columns)
+		{
+			field.setAccessible(true);
+			try
+			{
+				String typeString = field.getType().getName();
+				String colName = StringUtil.toSQLName(field.getName());
+
+				if (colName.equalsIgnoreCase("_id"))
+				{
+					long cid = cursor.getLong(cursor.getColumnIndex(colName));
+					field.set(this, Long.valueOf(cid));
+				}
+				else if (typeString.equals("long"))
+				{
+					field.setLong(this, cursor.getLong(cursor.getColumnIndex(colName)));
+				}
+				else if (typeString.equals("java.lang.String"))
+				{
+					String val = cursor.getString(cursor.getColumnIndex(colName));
+					field.set(this, val.equals("null") ? null : val);
+				}
+				else if (typeString.equals("double"))
+				{
+					field.setDouble(this, cursor.getDouble(cursor.getColumnIndex(colName)));
+				}
+				else if (typeString.equals("boolean"))
+				{
+					field.setBoolean(this,
+							cursor.getString(cursor.getColumnIndex(colName)).equals("true"));
+				}
+				else if (typeString.equals("[B"))
+				{
+					field.set(this, cursor.getBlob(cursor.getColumnIndex(colName)));
+				}
+				else if (typeString.equals("int"))
+				{
+					field.setInt(this, cursor.getInt(cursor.getColumnIndex(colName)));
+				}
+				else if (typeString.equals("float"))
+				{
+					field.setFloat(this, cursor.getFloat(cursor.getColumnIndex(colName)));
+				}
+				else if (typeString.equals("short"))
+				{
+					field.setShort(this, cursor.getShort(cursor.getColumnIndex(colName)));
+				}
+				else if (typeString.equals("java.sql.Timestamp"))
+				{
+					long l = cursor.getLong(cursor.getColumnIndex(colName));
+					field.set(this, new Timestamp(l));
+				}
+				else if (SugarRecord.class.isAssignableFrom(field.getType()))
+				{
+					long id = cursor.getLong(cursor.getColumnIndex(colName));
+					if (id > 0)
+						entities.put(field, id);
+					else
+						field.set(this, null);
+				}
+				else
+					Log.e("Sugar", "Class cannot be read from Sqlite3 database.");
+			}
+			catch (IllegalArgumentException e)
+			{
+				Log.e("field set error", e.getMessage());
+			}
+			catch (IllegalAccessException e)
+			{
+				Log.e("field set error", e.getMessage());
+			}
+
+		}
+
+		for (Field f : entities.keySet())
+		{
+			try
+			{
+				f.set(this, findById((Class<? extends SugarRecord>) f.getType(), entities.get(f)));
+			}
+			catch (SQLiteException e)
+			{
+			}
+			catch (IllegalArgumentException e)
+			{
+			}
+			catch (IllegalAccessException e)
+			{
+			}
+		}
+	}
+
+	public List<Field> getTableFields()
+	{
+		List<Field> fieldList = SugarConfig.getFields(getClass());
+		if (fieldList != null)
+			return fieldList;
+
+		Log.d("Sugar", "Fetching properties");
+		List<Field> typeFields = new ArrayList<Field>();
+
+		getAllFields(typeFields, getClass());
+
+		List<Field> toStore = new ArrayList<Field>();
+		for (Field field : typeFields)
+		{
+			if (!field.isAnnotationPresent(Ignore.class))
+			{
+				toStore.add(field);
+			}
+		}
+
+		SugarConfig.setFields(getClass(), toStore);
+		return toStore;
+	}
+
+	private static List<Field> getAllFields(List<Field> fields, Class<?> type)
+	{
+		Collections.addAll(fields, type.getDeclaredFields());
+
+		if (type.getSuperclass() != null)
+		{
+			fields = getAllFields(fields, type.getSuperclass());
+		}
+
+		return fields;
+	}
+
+	public String getSqlName()
+	{
+		return getTableName(getClass());
+	}
+
+
+	public static String getTableName(Class<?> type)
+	{
+		return StringUtil.toSQLName(type.getSimpleName());
+	}
+
+	public Long getId()
+	{
+		return id;
+	}
+
+	public void setId(Long id)
+	{
+		this.id = id;
+	}
 }
