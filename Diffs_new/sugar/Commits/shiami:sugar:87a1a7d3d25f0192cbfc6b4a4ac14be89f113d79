diff --git a/example/.classpath b/example/.classpath
new file mode 100644
index 00000000..7bc01d9a
--- /dev/null
+++ b/example/.classpath
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/example/.project b/example/.project
new file mode 100644
index 00000000..8687ca72
--- /dev/null
+++ b/example/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>SugarActivity</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/example/bin/AndroidManifest.xml b/example/bin/AndroidManifest.xml
new file mode 100644
index 00000000..e03f036a
--- /dev/null
+++ b/example/bin/AndroidManifest.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+      package="com.example"
+      android:versionCode="1"
+      android:versionName="1.0">
+    <application android:label="@string/app_name" android:icon="@drawable/icon" android:name="ClientApp">
+        <activity android:name="SugarActivity"
+                  android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+        <activity android:name=".NoteListActivity"/>
+        <activity android:name=".AddNoteActivity"/>
+
+        <meta-data android:name="DATABASE" android:value="sugar_example.db" />
+        <meta-data android:name="VERSION" android:value="3" />
+        <meta-data android:name="QUERY_LOG" android:value="true" />
+    </application>
+</manifest> 
diff --git a/example/bin/R.txt b/example/bin/R.txt
new file mode 100644
index 00000000..86a6ff05
--- /dev/null
+++ b/example/bin/R.txt
@@ -0,0 +1,7 @@
+int drawable icon 0x7f020000
+int id Button01 0x7f050002
+int id LinearLayout01 0x7f050001
+int id layout 0x7f050000
+int layout main 0x7f030000
+int layout notelist 0x7f030001
+int string app_name 0x7f040000
diff --git a/example/bin/jarlist.cache b/example/bin/jarlist.cache
new file mode 100644
index 00000000..0565465f
--- /dev/null
+++ b/example/bin/jarlist.cache
@@ -0,0 +1,3 @@
+# cache for current jar dependency. DO NOT EDIT.
+# format is <lastModified> <length> <SHA-1> <path>
+# Encoding is UTF-8
diff --git a/example/gen/com/example/BuildConfig.java b/example/gen/com/example/BuildConfig.java
new file mode 100644
index 00000000..24dc7a0d
--- /dev/null
+++ b/example/gen/com/example/BuildConfig.java
@@ -0,0 +1,6 @@
+/** Automatically generated file. DO NOT MODIFY */
+package com.example;
+
+public final class BuildConfig {
+    public final static boolean DEBUG = true;
+}
\ No newline at end of file
diff --git a/example/gen/com/example/R.java b/example/gen/com/example/R.java
new file mode 100644
index 00000000..b971424d
--- /dev/null
+++ b/example/gen/com/example/R.java
@@ -0,0 +1,28 @@
+/* AUTO-GENERATED FILE.  DO NOT MODIFY.
+ *
+ * This class was automatically generated by the
+ * aapt tool from the resource data it found.  It
+ * should not be modified by hand.
+ */
+
+package com.example;
+
+public final class R {
+    public static final class attr {
+    }
+    public static final class drawable {
+        public static final int icon=0x7f020000;
+    }
+    public static final class id {
+        public static final int Button01=0x7f050002;
+        public static final int LinearLayout01=0x7f050001;
+        public static final int layout=0x7f050000;
+    }
+    public static final class layout {
+        public static final int main=0x7f030000;
+        public static final int notelist=0x7f030001;
+    }
+    public static final class string {
+        public static final int app_name=0x7f040000;
+    }
+}
diff --git a/example/project.properties b/example/project.properties
new file mode 100644
index 00000000..5815cb00
--- /dev/null
+++ b/example/project.properties
@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-15
+android.library.reference.1=../library
diff --git a/example/src/com/example/Note.java b/example/src/com/example/Note.java
index b83f730f..7ad0e977 100755
--- a/example/src/com/example/Note.java
+++ b/example/src/com/example/Note.java
@@ -6,64 +6,64 @@
 @Table(name = "Note")
 public class Note {
 
-    private long id;
-
-    @Column(name = "noteId", unique = true, notNull = true)
-    private int noteId;
-
-    private String title;
-    private String description;
-   private String name;
-    private Integer noteNumber = 2;
-    private Float tagNumber = 4.0f;
-    private float tagNo = 5.0f;
-    private Boolean isTag = true;
-    private boolean isTagged = false;
-    private Double noteTagNo = 40.5;
-    private double noteTagNumber = 24.4;
-    private Tag tag;
-
-    public Note(){
-    }
-
-    public Note(int noteId, String title, String description, Tag tag) {
-        this.noteId = noteId;
-        this.title = title;
-        this.description = description;
-        this.tag = tag;
-    }
-
-    public int getNoteId() {
-        return noteId;
-    }
-
-    public void setNoteId(int noteId) {
-        this.noteId = noteId;
-    }
-
-    public String getTitle() {
-        return title;
-    }
-
-    public void setTitle(String title) {
-        this.title = title;
-    }
-
-    public String getDescription() {
-        return description;
-    }
-
-    public void setDescription(String description){
-        this.description = description;
-    }
-
-    public Tag getTag() {
-        return tag;
-    }
-
-    @Override
-    public String toString() {
-        return title + "id: " + noteId;
-
-    }
+	private long id;
+
+	@Column(name = "noteId", unique = true, notNull = true)
+	private int noteId;
+
+	private String title;
+	private String description;
+	private String name;
+	private Integer noteNumber = 2;
+	private Float tagNumber = 4.0f;
+	private float tagNo = 5.0f;
+	private Boolean isTag = true;
+	private boolean isTagged = false;
+	private Double noteTagNo = 40.5;
+	private double noteTagNumber = 24.4;
+	private Tag tag;
+
+	public Note() {
+	}
+
+	public Note(int noteId, String title, String description, Tag tag) {
+		this.noteId = noteId;
+		this.title = title;
+		this.description = description;
+		this.tag = tag;
+	}
+
+	public int getNoteId() {
+		return noteId;
+	}
+
+	public void setNoteId(int noteId) {
+		this.noteId = noteId;
+	}
+
+	public String getTitle() {
+		return title;
+	}
+
+	public void setTitle(String title) {
+		this.title = title;
+	}
+
+	public String getDescription() {
+		return description;
+	}
+
+	public void setDescription(String description) {
+		this.description = description;
+	}
+
+	public Tag getTag() {
+		return tag;
+	}
+
+	@Override
+	public String toString() {
+		return title + "id: " + noteId;
+
+	}
 }
diff --git a/library/src/com/orm/SugarRecord.java b/library/src/com/orm/SugarRecord.java
index d3a5e8fc..270c44d0 100644
--- a/library/src/com/orm/SugarRecord.java
+++ b/library/src/com/orm/SugarRecord.java
@@ -1,286 +1,321 @@
 package com.orm;
 
+import static com.orm.SugarContext.getSugarContext;
+
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.NoSuchElementException;
+
 import android.content.ContentValues;
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteStatement;
 import android.text.TextUtils;
 import android.util.Log;
+
 import com.orm.dsl.Table;
 import com.orm.util.NamingHelper;
 import com.orm.util.ReflectionUtil;
 
-import java.lang.reflect.Field;
-import java.util.*;
-
-import static com.orm.SugarContext.getSugarContext;
-
 public class SugarRecord {
 
-    protected Long id = null;
-
-    public static <T> void deleteAll(Class<T> type) {
-        SugarDb db = getSugarContext().getSugarDb();
-        SQLiteDatabase sqLiteDatabase = db.getDB();
-        sqLiteDatabase.delete(NamingHelper.toSQLName(type), null, null);
-    }
-
-    public static <T> void deleteAll(Class<T> type, String whereClause, String... whereArgs) {
-        SugarDb db = getSugarContext().getSugarDb();
-        SQLiteDatabase sqLiteDatabase = db.getDB();
-        sqLiteDatabase.delete(NamingHelper.toSQLName(type), whereClause, whereArgs);
-    }
-
-    @SuppressWarnings("deprecation")
-    public static <T> void saveInTx(T... objects) {
-        saveInTx(Arrays.asList(objects));
-    }
-
-    @SuppressWarnings("deprecation")
-    public static <T> void saveInTx(Collection<T> objects) {
-        SQLiteDatabase sqLiteDatabase = getSugarContext().getSugarDb().getDB();
-        try {
-            sqLiteDatabase.beginTransaction();
-            sqLiteDatabase.setLockingEnabled(false);
-            for (T object: objects) {
-                SugarRecord.save(object);
-            }
-            sqLiteDatabase.setTransactionSuccessful();
-        } catch (Exception e) {
-            Log.i("Sugar", "Error in saving in transaction " + e.getMessage());
-        } finally {
-            sqLiteDatabase.endTransaction();
-            sqLiteDatabase.setLockingEnabled(true);
-        }
-    }
-
-    public static <T> List<T> listAll(Class<T> type) {
-        return find(type, null, null, null, null, null);
-    }
-
-    public static <T> T findById(Class<T> type, Long id) {
-        List<T> list = find(type, "id=?", new String[]{String.valueOf(id)}, null, null, "1");
-        if (list.isEmpty()) return null;
-        return list.get(0);
-    }
-
-    public static <T> T findById(Class<T> type, Integer id) {
-        return findById(type, Long.valueOf(id));
-    }
-
-    public static <T> Iterator<T> findAll(Class<T> type) {
-        return findAsIterator(type, null, null, null, null, null);
-    }
-
-    public static <T> Iterator<T> findAsIterator(Class<T> type, String whereClause, String... whereArgs) {
-        return findAsIterator(type, whereClause, whereArgs, null, null, null);
-    }
-
-    public static <T> Iterator<T> findWithQueryAsIterator(Class<T> type, String query, String... arguments) {
-        SugarDb db = getSugarContext().getSugarDb();
-        SQLiteDatabase sqLiteDatabase = db.getDB();
-        Cursor c = sqLiteDatabase.rawQuery(query, arguments);
-        return new CursorIterator<T>(type, c);
-    }
-
-    public static <T> Iterator<T> findAsIterator(Class<T> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
-        SugarDb db = getSugarContext().getSugarDb();
-        SQLiteDatabase sqLiteDatabase = db.getDB();
-        Cursor c = sqLiteDatabase.query(NamingHelper.toSQLName(type), null, whereClause, whereArgs,
-                groupBy, null, orderBy, limit);
-        return new CursorIterator<T>(type, c);
-    }
-
-    public static <T> List<T> find(Class<T> type, String whereClause, String... whereArgs) {
-        return find(type, whereClause, whereArgs, null, null, null);
-    }
-
-    public static <T> List<T> findWithQuery(Class<T> type, String query, String... arguments) {
-        SugarDb db = getSugarContext().getSugarDb();
-        SQLiteDatabase sqLiteDatabase = db.getDB();
-        T entity;
-        List<T> toRet = new ArrayList<T>();
-        Cursor c = sqLiteDatabase.rawQuery(query, arguments);
-
-        try {
-            while (c.moveToNext()) {
-                entity = type.getDeclaredConstructor().newInstance();
-                SugarRecord.inflate(c, entity);
-                toRet.add(entity);
-            }
-        } catch (Exception e) {
-            e.printStackTrace();
-        } finally {
-            c.close();
-        }
-
-        return toRet;
-    }
-
-    public static void executeQuery(String query, String... arguments) {
-        getSugarContext().getSugarDb().getDB().execSQL(query, arguments);
-    }
-
-    public static <T> List<T> find(Class<T> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
-        SugarDb db = getSugarContext().getSugarDb();
-        SQLiteDatabase sqLiteDatabase = db.getDB();
-        T entity;
-        List<T> toRet = new ArrayList<T>();
-        Cursor c = sqLiteDatabase.query(NamingHelper.toSQLName(type), null, whereClause, whereArgs,
-                groupBy, null, orderBy, limit);
-        try {
-            while (c.moveToNext()) {
-                entity = type.getDeclaredConstructor().newInstance();
-                SugarRecord.inflate(c, entity);
-                toRet.add(entity);
-            }
-        } catch (Exception e) {
-            e.printStackTrace();
-        } finally {
-            c.close();
-        }
-        return toRet;
-    }
-
-    public static <T> long count(Class<?> type) {
-        return count(type, null, null, null, null, null);
-    }
-
-    public static <T> long count(Class<?> type, String whereClause, String[] whereArgs) {
-    	return count(type, whereClause, whereArgs, null, null, null);
-    }
-
-    public static <T> long count(Class<?> type, String whereClause, String[] whereArgs, String groupBy, String orderBy, String limit) {
-        SugarDb db = getSugarContext().getSugarDb();
-        SQLiteDatabase sqLiteDatabase = db.getDB();
-
-        long toRet = -1;
-        String filter = (!TextUtils.isEmpty(whereClause)) ? " where "  + whereClause : "";
-        SQLiteStatement sqLiteStatament = sqLiteDatabase.compileStatement("SELECT count(*) FROM " + NamingHelper.toSQLName(type) + filter);
-
-        if (whereArgs != null) {
-            for (int i = whereArgs.length; i != 0; i--) {
-                sqLiteStatament.bindString(i, whereArgs[i - 1]);
-            }
-        }
-
-        try {
-            toRet = sqLiteStatament.simpleQueryForLong();
-        } catch (Exception e) {
-            e.printStackTrace();
-        } finally {
-            sqLiteStatament.close();
-        }
-
-        return toRet;
-    }
-
-    public static long save(Object object) {
-        return save(getSugarContext().getSugarDb().getDB(), object);
-    }
-
-    static long save(SQLiteDatabase db, Object object) {
-        List<Field> columns = ReflectionUtil.getTableFields(object.getClass());
-        ContentValues values = new ContentValues(columns.size());
-        for (Field column : columns) {
-            ReflectionUtil.addFieldValueToColumn(values, column, object);
-        }
-
-        long id = db.insertWithOnConflict(NamingHelper.toSQLName(object.getClass()), null, values,
-                SQLiteDatabase.CONFLICT_REPLACE);
-
-        if (SugarRecord.class.isAssignableFrom(object.getClass())) {
-            ReflectionUtil.setFieldValueForId(object, id);
-        }
-        Log.i("Sugar", object.getClass().getSimpleName() + " saved : " + id);
-
-        return id;
-    }
-
-    private static void inflate(Cursor cursor, Object object) {
-        List<Field> columns = ReflectionUtil.getTableFields(object.getClass());
-
-        for (Field field : columns) {
-            if (field.getClass().isAnnotationPresent(Table.class)) {
-                try {
-                    long id = cursor.getLong(cursor.getColumnIndex(NamingHelper.toSQLName(field)));
-                    field.set(object, (id > 0) ? findById(field.getType(), id) : null);
-                } catch (IllegalAccessException e) {
-                    e.printStackTrace();
-                }
-            } else {
-                ReflectionUtil.setFieldValueFromCursor(cursor, field, object);
-            }
-        }
-    }
-
-    public void delete() {
-        SQLiteDatabase db = getSugarContext().getSugarDb().getDB();
-        db.delete(NamingHelper.toSQLName(getClass()), "Id=?", new String[]{getId().toString()});
-        Log.i("Sugar", getClass().getSimpleName() + " deleted : " + getId().toString());
-    }
-
-    public long save() {
-        return save(getSugarContext().getSugarDb().getDB(), this);
-    }
-
-    @SuppressWarnings("unchecked")
-    void inflate(Cursor cursor) {
-        inflate(cursor, this);
-    }
-
-    public Long getId() {
-        return id;
-    }
-
-    public void setId(Long id) {
-        this.id = id;
-    }
-
-    static class CursorIterator<E> implements Iterator<E> {
-        Class<E> type;
-        Cursor cursor;
-
-        public CursorIterator(Class<E> type, Cursor cursor) {
-            this.type = type;
-            this.cursor = cursor;
-        }
-
-        @Override
-        public boolean hasNext() {
-            return cursor != null && !cursor.isClosed() && !cursor.isAfterLast();
-        }
-
-        @Override
-        public E next() {
-            E entity = null;
-            if (cursor == null || cursor.isAfterLast()) {
-                throw new NoSuchElementException();
-            }
-
-            if (cursor.isBeforeFirst()) {
-                cursor.moveToFirst();
-            }
-
-            try {
-                entity = type.getDeclaredConstructor().newInstance();
-                SugarRecord.inflate(cursor, entity);
-            } catch (Exception e) {
-                e.printStackTrace();
-            } finally {
-                cursor.moveToNext();
-                if (cursor.isAfterLast()) {
-                    cursor.close();
-                }
-            }
-
-            return entity;
-        }
-
-        @Override
-        public void remove() {
-            throw new UnsupportedOperationException();
-        }
-    }
+	protected Long id = null;
+
+	public static <T> void deleteAll(Class<T> type) {
+		SugarDb db = getSugarContext().getSugarDb();
+		SQLiteDatabase sqLiteDatabase = db.getDB();
+		sqLiteDatabase.delete(NamingHelper.toSQLName(type), null, null);
+	}
+
+	public static <T> void deleteAll(Class<T> type, String whereClause,
+			String... whereArgs) {
+		SugarDb db = getSugarContext().getSugarDb();
+		SQLiteDatabase sqLiteDatabase = db.getDB();
+		sqLiteDatabase.delete(NamingHelper.toSQLName(type), whereClause,
+				whereArgs);
+	}
+
+	public static <T> void deleteById(Class<T> type, Long id) {
+		SQLiteDatabase db = getSugarContext().getSugarDb().getDB();
+		db.delete(NamingHelper.toSQLName(type), "Id=?",
+				new String[] { id.toString() });
+		Log.i("Sugar", type.getSimpleName() + " deleted : " + id.toString());
+	}
+
+	@SuppressWarnings("deprecation")
+	public static <T> void saveInTx(T... objects) {
+		saveInTx(Arrays.asList(objects));
+	}
+
+	@SuppressWarnings("deprecation")
+	public static <T> void saveInTx(Collection<T> objects) {
+		SQLiteDatabase sqLiteDatabase = getSugarContext().getSugarDb().getDB();
+		try {
+			sqLiteDatabase.beginTransaction();
+			sqLiteDatabase.setLockingEnabled(false);
+			for (T object : objects) {
+				SugarRecord.save(object);
+			}
+			sqLiteDatabase.setTransactionSuccessful();
+		} catch (Exception e) {
+			Log.i("Sugar", "Error in saving in transaction " + e.getMessage());
+		} finally {
+			sqLiteDatabase.endTransaction();
+			sqLiteDatabase.setLockingEnabled(true);
+		}
+	}
+
+	public static <T> List<T> listAll(Class<T> type) {
+		return find(type, null, null, null, null, null);
+	}
+
+	public static <T> T findById(Class<T> type, Long id) {
+		List<T> list = find(type, "id=?", new String[] { String.valueOf(id) },
+				null, null, "1");
+		if (list.isEmpty())
+			return null;
+		return list.get(0);
+	}
+
+	public static <T> T findById(Class<T> type, Integer id) {
+		return findById(type, Long.valueOf(id));
+	}
+
+	public static <T> Iterator<T> findAll(Class<T> type) {
+		return findAsIterator(type, null, null, null, null, null);
+	}
+
+	public static <T> Iterator<T> findAsIterator(Class<T> type,
+			String whereClause, String... whereArgs) {
+		return findAsIterator(type, whereClause, whereArgs, null, null, null);
+	}
+
+	public static <T> Iterator<T> findWithQueryAsIterator(Class<T> type,
+			String query, String... arguments) {
+		SugarDb db = getSugarContext().getSugarDb();
+		SQLiteDatabase sqLiteDatabase = db.getDB();
+		Cursor c = sqLiteDatabase.rawQuery(query, arguments);
+		return new CursorIterator<T>(type, c);
+	}
+
+	public static <T> Iterator<T> findAsIterator(Class<T> type,
+			String whereClause, String[] whereArgs, String groupBy,
+			String orderBy, String limit) {
+		SugarDb db = getSugarContext().getSugarDb();
+		SQLiteDatabase sqLiteDatabase = db.getDB();
+		Cursor c = sqLiteDatabase.query(NamingHelper.toSQLName(type), null,
+				whereClause, whereArgs, groupBy, null, orderBy, limit);
+		return new CursorIterator<T>(type, c);
+	}
+
+	public static <T> List<T> find(Class<T> type, String whereClause,
+			String... whereArgs) {
+		return find(type, whereClause, whereArgs, null, null, null);
+	}
+
+	public static <T> List<T> findWithQuery(Class<T> type, String query,
+			String... arguments) {
+		SugarDb db = getSugarContext().getSugarDb();
+		SQLiteDatabase sqLiteDatabase = db.getDB();
+		T entity;
+		List<T> toRet = new ArrayList<T>();
+		Cursor c = sqLiteDatabase.rawQuery(query, arguments);
+
+		try {
+			while (c.moveToNext()) {
+				entity = type.getDeclaredConstructor().newInstance();
+				SugarRecord.inflate(c, entity);
+				toRet.add(entity);
+			}
+		} catch (Exception e) {
+			e.printStackTrace();
+		} finally {
+			c.close();
+		}
+
+		return toRet;
+	}
+
+	public static void executeQuery(String query, String... arguments) {
+		getSugarContext().getSugarDb().getDB().execSQL(query, arguments);
+	}
+
+	public static <T> List<T> find(Class<T> type, String whereClause,
+			String[] whereArgs, String groupBy, String orderBy, String limit) {
+		SugarDb db = getSugarContext().getSugarDb();
+		SQLiteDatabase sqLiteDatabase = db.getDB();
+		T entity;
+		List<T> toRet = new ArrayList<T>();
+		Cursor c = sqLiteDatabase.query(NamingHelper.toSQLName(type), null,
+				whereClause, whereArgs, groupBy, null, orderBy, limit);
+		try {
+			while (c.moveToNext()) {
+				entity = type.getDeclaredConstructor().newInstance();
+				SugarRecord.inflate(c, entity);
+				toRet.add(entity);
+			}
+		} catch (Exception e) {
+			e.printStackTrace();
+		} finally {
+			c.close();
+		}
+		return toRet;
+	}
+
+	public static <T> long count(Class<?> type) {
+		return count(type, null, null, null, null, null);
+	}
+
+	public static <T> long count(Class<?> type, String whereClause,
+			String[] whereArgs) {
+		return count(type, whereClause, whereArgs, null, null, null);
+	}
+
+	public static <T> long count(Class<?> type, String whereClause,
+			String[] whereArgs, String groupBy, String orderBy, String limit) {
+		SugarDb db = getSugarContext().getSugarDb();
+		SQLiteDatabase sqLiteDatabase = db.getDB();
+
+		long toRet = -1;
+		String filter = (!TextUtils.isEmpty(whereClause)) ? " where "
+				+ whereClause : "";
+		SQLiteStatement sqLiteStatament = sqLiteDatabase
+				.compileStatement("SELECT count(*) FROM "
+						+ NamingHelper.toSQLName(type) + filter);
+
+		if (whereArgs != null) {
+			for (int i = whereArgs.length; i != 0; i--) {
+				sqLiteStatament.bindString(i, whereArgs[i - 1]);
+			}
+		}
+
+		try {
+			toRet = sqLiteStatament.simpleQueryForLong();
+		} catch (Exception e) {
+			e.printStackTrace();
+		} finally {
+			sqLiteStatament.close();
+		}
+
+		return toRet;
+	}
+
+	public static long save(Object object) {
+		return save(getSugarContext().getSugarDb().getDB(), object);
+	}
+
+	static long save(SQLiteDatabase db, Object object) {
+		List<Field> columns = ReflectionUtil.getTableFields(object.getClass());
+		ContentValues values = new ContentValues(columns.size());
+		for (Field column : columns) {
+			ReflectionUtil.addFieldValueToColumn(values, column, object);
+		}
+
+		long id = db.insertWithOnConflict(
+				NamingHelper.toSQLName(object.getClass()), null, values,
+				SQLiteDatabase.CONFLICT_REPLACE);
+
+		if (SugarRecord.class.isAssignableFrom(object.getClass())) {
+			ReflectionUtil.setFieldValueForId(object, id);
+		}
+		Log.i("Sugar", object.getClass().getSimpleName() + " saved : " + id);
+
+		return id;
+	}
+
+	private static void inflate(Cursor cursor, Object object) {
+		List<Field> columns = ReflectionUtil.getTableFields(object.getClass());
+
+		for (Field field : columns) {
+			if (field.getClass().isAnnotationPresent(Table.class)) {
+				try {
+					long id = cursor.getLong(cursor.getColumnIndex(NamingHelper
+							.toSQLName(field)));
+					field.set(object, (id > 0) ? findById(field.getType(), id)
+							: null);
+				} catch (IllegalAccessException e) {
+					e.printStackTrace();
+				}
+			} else {
+				ReflectionUtil.setFieldValueFromCursor(cursor, field, object);
+			}
+		}
+	}
+
+	public void delete() {
+		SQLiteDatabase db = getSugarContext().getSugarDb().getDB();
+		db.delete(NamingHelper.toSQLName(getClass()), "Id=?",
+				new String[] { getId().toString() });
+		Log.i("Sugar", getClass().getSimpleName() + " deleted : "
+				+ getId().toString());
+	}
+
+	public long save() {
+		return save(getSugarContext().getSugarDb().getDB(), this);
+	}
+
+	@SuppressWarnings("unchecked")
+	void inflate(Cursor cursor) {
+		inflate(cursor, this);
+	}
+
+	public Long getId() {
+		return id;
+	}
+
+	public void setId(Long id) {
+		this.id = id;
+	}
+
+	static class CursorIterator<E> implements Iterator<E> {
+		Class<E> type;
+		Cursor cursor;
+
+		public CursorIterator(Class<E> type, Cursor cursor) {
+			this.type = type;
+			this.cursor = cursor;
+		}
+
+		@Override
+		public boolean hasNext() {
+			return cursor != null && !cursor.isClosed()
+					&& !cursor.isAfterLast();
+		}
+
+		@Override
+		public E next() {
+			E entity = null;
+			if (cursor == null || cursor.isAfterLast()) {
+				throw new NoSuchElementException();
+			}
+
+			if (cursor.isBeforeFirst()) {
+				cursor.moveToFirst();
+			}
+
+			try {
+				entity = type.getDeclaredConstructor().newInstance();
+				SugarRecord.inflate(cursor, entity);
+			} catch (Exception e) {
+				e.printStackTrace();
+			} finally {
+				cursor.moveToNext();
+				if (cursor.isAfterLast()) {
+					cursor.close();
+				}
+			}
+
+			return entity;
+		}
+
+		@Override
+		public void remove() {
+			throw new UnsupportedOperationException();
+		}
+	}
 
 }
diff --git a/library/src/com/orm/util/ReflectionUtil.java b/library/src/com/orm/util/ReflectionUtil.java
index 3dc2b59d..fecee4bd 100644
--- a/library/src/com/orm/util/ReflectionUtil.java
+++ b/library/src/com/orm/util/ReflectionUtil.java
@@ -1,287 +1,329 @@
 package com.orm.util;
 
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.net.URL;
+import java.sql.Timestamp;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Collections;
+import java.util.Date;
+import java.util.Enumeration;
+import java.util.List;
+
 import android.content.ContentValues;
 import android.content.Context;
 import android.content.pm.PackageManager;
 import android.database.Cursor;
 import android.util.Log;
+
 import com.orm.SugarRecord;
 import com.orm.dsl.Ignore;
 import com.orm.dsl.Table;
-import dalvik.system.DexFile;
 
-import java.io.File;
-import java.io.IOException;
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.net.URL;
-import java.sql.Timestamp;
-import java.util.*;
+import dalvik.system.DexFile;
 
 public class ReflectionUtil {
 
-    public static List<Field> getTableFields(Class table) {
-        List<Field> fieldList = SugarConfig.getFields(table);
-        if (fieldList != null) return fieldList;
-
-        Log.d("Sugar", "Fetching properties");
-        List<Field> typeFields = new ArrayList<Field>();
-
-        getAllFields(typeFields, table);
-
-        List<Field> toStore = new ArrayList<Field>();
-        for (Field field : typeFields) {
-            if (!field.isAnnotationPresent(Ignore.class) && !Modifier.isStatic(field.getModifiers()) && !Modifier.isTransient(field.getModifiers())) {
-                toStore.add(field);
-            }
-        }
-
-        SugarConfig.setFields(table, toStore);
-        return toStore;
-    }
-
-    private static List<Field> getAllFields(List<Field> fields, Class<?> type) {
-        Collections.addAll(fields, type.getDeclaredFields());
-
-        if (type.getSuperclass() != null) {
-            fields = getAllFields(fields, type.getSuperclass());
-        }
-
-        return fields;
-    }
-
-    public static void addFieldValueToColumn(ContentValues values, Field column, Object object) {
-        column.setAccessible(true);
-        Class<?> columnType = column.getType();
-        try {
-            String columnName = NamingHelper.toSQLName(column);
-            Object columnValue = column.get(object);
-
-            if (SugarRecord.class.isAssignableFrom(columnType)) {
-                values.put(columnName,
-                        (columnValue != null)
-                                ? String.valueOf(((SugarRecord) columnValue).getId())
-                                : "0");
-            } else {
-                if (columnType.equals(Short.class) || columnType.equals(short.class)) {
-                    values.put(columnName, (Short) columnValue);
-                } else if (columnType.equals(Integer.class) || columnType.equals(int.class)) {
-                    values.put(columnName, (Integer) columnValue);
-                } else if (columnType.equals(Long.class) || columnType.equals(long.class)) {
-                    values.put(columnName, (Long) columnValue);
-                } else if (columnType.equals(Float.class) || columnType.equals(float.class)) {
-                    values.put(columnName, (Float) columnValue);
-                } else if (columnType.equals(Double.class) || columnType.equals(double.class)) {
-                    values.put(columnName, (Double) columnValue);
-                } else if (columnType.equals(Boolean.class) || columnType.equals(boolean.class)) {
-                    values.put(columnName, (Boolean) columnValue);
-                } else if (Timestamp.class.equals(columnType)) {
-                    try {
-                        values.put(columnName, ((Timestamp) column.get(object)).getTime());
-                    } catch (NullPointerException e) {
-                        values.put(columnName, (Long) null);
-                    }
-                } else if (Date.class.equals(columnType)) {
-                    try {
-                        values.put(columnName, ((Date) column.get(object)).getTime());
-                    } catch (NullPointerException e) {
-                        values.put(columnName, (Long) null);
-                    }
-                } else if (Calendar.class.equals(columnType)) {
-                    try {
-                        values.put(columnName, ((Calendar) column.get(object)).getTimeInMillis());
-                    } catch (NullPointerException e) {
-                        values.put(columnName, (Long) null);
-                    }
-                } else {
-                    if (columnValue == null) {
-                        values.putNull(columnName);
-                    } else {
-                        values.put(columnName, String.valueOf(columnValue));
-                    }
-                }
-            }
-
-        } catch (IllegalAccessException e) {
-            Log.e("Sugar", e.getMessage());
-        }
-    }
-
-    public static void setFieldValueFromCursor(Cursor cursor, Field field, Object object) {
-        field.setAccessible(true);
-        try {
-            Class fieldType = field.getType();
-            String colName = NamingHelper.toSQLName(field);
-
-            int columnIndex = cursor.getColumnIndex(colName);
-
-            if (cursor.isNull(columnIndex)) {
-                return;
-            }
-
-            if (colName.equalsIgnoreCase("id")) {
-                long cid = cursor.getLong(columnIndex);
-                field.set(object, Long.valueOf(cid));
-            } else if (fieldType.equals(long.class) || fieldType.equals(Long.class)) {
-                field.set(object,
-                        cursor.getLong(columnIndex));
-            } else if (fieldType.equals(String.class)) {
-                String val = cursor.getString(columnIndex);
-                field.set(object, val != null && val.equals("null") ? null : val);
-            } else if (fieldType.equals(double.class) || fieldType.equals(Double.class)) {
-                field.set(object,
-                        cursor.getDouble(columnIndex));
-            } else if (fieldType.equals(boolean.class) || fieldType.equals(Boolean.class)) {
-                field.set(object,
-                        cursor.getString(columnIndex).equals("1"));
-            } else if (field.getType().getName().equals("[B")) {
-                field.set(object,
-                        cursor.getBlob(columnIndex));
-            } else if (fieldType.equals(int.class) || fieldType.equals(Integer.class)) {
-                field.set(object,
-                        cursor.getInt(columnIndex));
-            } else if (fieldType.equals(float.class) || fieldType.equals(Float.class)) {
-                field.set(object,
-                        cursor.getFloat(columnIndex));
-            } else if (fieldType.equals(short.class) || fieldType.equals(Short.class)) {
-                field.set(object,
-                        cursor.getShort(columnIndex));
-            } else if (fieldType.equals(Timestamp.class)) {
-                long l = cursor.getLong(columnIndex);
-                field.set(object, new Timestamp(l));
-            } else if (fieldType.equals(Date.class)) {
-                long l = cursor.getLong(columnIndex);
-                field.set(object, new Date(l));
-            } else if (fieldType.equals(Calendar.class)) {
-                long l = cursor.getLong(columnIndex);
-                Calendar c = Calendar.getInstance();
-                c.setTimeInMillis(l);
-                field.set(object, c);
-            } else if (Enum.class.isAssignableFrom(fieldType)) {
-                try {
-                    Method valueOf = field.getType().getMethod("valueOf", String.class);
-                    String strVal = cursor.getString(columnIndex);
-                    Object enumVal = valueOf.invoke(field.getType(), strVal);
-                    field.set(object, enumVal);
-                } catch (Exception e) {
-                    Log.e("Sugar", "Enum cannot be read from Sqlite3 database. Please check the type of field " + field.getName());
-                }
-            } else
-                Log.e("Sugar", "Class cannot be read from Sqlite3 database. Please check the type of field " + field.getName() + "(" + field.getType().getName() + ")");
-        } catch (IllegalArgumentException e) {
-            Log.e("field set error", e.getMessage());
-        } catch (IllegalAccessException e) {
-            Log.e("field set error", e.getMessage());
-        }
-    }
-
-    public static void setFieldValueForId(Object object, Long value) {
-
-        try {
-            Field field = object.getClass().getField("id");
-
-            field.setAccessible(true);
-            field.set(object, value);
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        } catch (NoSuchFieldException e) {
-            e.printStackTrace();
-        }
-    }
-
-    public static List<Class> getDomainClasses(Context context) {
-        List<Class> domainClasses = new ArrayList<Class>();
-        try {
-            for (String className : getAllClasses(context)) {
-                if (className.startsWith(ManifestHelper.getDomainPackageName(context))) {
-                    Class domainClass = getDomainClass(className, context);
-                    if (domainClass != null) domainClasses.add(domainClass);
-                }
-            }
-        } catch (IOException e) {
-            Log.e("Sugar", e.getMessage());
-        } catch (PackageManager.NameNotFoundException e) {
-            Log.e("Sugar", e.getMessage());
-        }
-
-        return domainClasses;
-    }
-
-
-    private static Class getDomainClass(String className, Context context) {
-        Class<?> discoveredClass = null;
-        try {
-            discoveredClass = Class.forName(className, true, context.getClass().getClassLoader());
-        } catch (ClassNotFoundException e) {
-            Log.e("Sugar", e.getMessage());
-        }
-
-        if ((discoveredClass != null) &&
-                ((SugarRecord.class.isAssignableFrom(discoveredClass) &&
-                        !SugarRecord.class.equals(discoveredClass)) ||
-                        discoveredClass.isAnnotationPresent(Table.class)) &&
-                !Modifier.isAbstract(discoveredClass.getModifiers())) {
-
-            Log.i("Sugar", "domain class : " + discoveredClass.getSimpleName());
-            return discoveredClass;
-
-        } else {
-            return null;
-        }
-    }
-
-
-    private static List<String> getAllClasses(Context context) throws PackageManager.NameNotFoundException, IOException {
-        String path = getSourcePath(context);
-        List<String> classNames = new ArrayList<String>();
-        try {
-            DexFile dexfile = new DexFile(path);
-            Enumeration<String> dexEntries = dexfile.entries();
-            while (dexEntries.hasMoreElements()) {
-                classNames.add(dexEntries.nextElement());
-            }
-        } catch (NullPointerException e) {
-            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
-            Enumeration<URL> urls = classLoader.getResources("");
-            List<String> fileNames = new ArrayList<String>();
-            while (urls.hasMoreElements()) {
-                String classDirectoryName = urls.nextElement().getFile();
-                if (classDirectoryName.contains("bin") || classDirectoryName.contains("classes")) {
-                    File classDirectory = new File(classDirectoryName);
-                    for (File filePath : classDirectory.listFiles()) {
-                        populateFiles(filePath, fileNames, "");
-                    }
-                    classNames.addAll(fileNames);
-                }
-            }
-        }
-        return classNames;
-    }
-
-    private static void populateFiles(File path, List<String> fileNames, String parent) {
-        if (path.isDirectory()) {
-            for (File newPath : path.listFiles()) {
-                if ("".equals(parent)) {
-                    populateFiles(newPath, fileNames, path.getName());
-                } else {
-                    populateFiles(newPath, fileNames, parent + "." + path.getName());
-                }
-            }
-        } else {
-            String pathName = path.getName();
-            String classSuffix = ".class";
-            pathName = pathName.endsWith(classSuffix) ?
-                    pathName.substring(0, pathName.length() - classSuffix.length()) : pathName;
-            if ("".equals(parent)) {
-                fileNames.add(pathName);
-            } else {
-                fileNames.add(parent + "." + pathName);
-            }
-        }
-    }
-
-    private static String getSourcePath(Context context) throws PackageManager.NameNotFoundException {
-        return context.getPackageManager().getApplicationInfo(context.getPackageName(), 0).sourceDir;
-    }
+	public static List<Field> getTableFields(Class table) {
+		List<Field> fieldList = SugarConfig.getFields(table);
+		if (fieldList != null)
+			return fieldList;
+
+		Log.d("Sugar", "Fetching properties");
+		List<Field> typeFields = new ArrayList<Field>();
+
+		getAllFields(typeFields, table);
+
+		List<Field> toStore = new ArrayList<Field>();
+		for (Field field : typeFields) {
+			if (!field.isAnnotationPresent(Ignore.class)
+					&& !Modifier.isStatic(field.getModifiers())
+					&& !Modifier.isTransient(field.getModifiers())) {
+				toStore.add(field);
+			}
+		}
+
+		SugarConfig.setFields(table, toStore);
+		return toStore;
+	}
+
+	private static List<Field> getAllFields(List<Field> fields, Class<?> type) {
+		Collections.addAll(fields, type.getDeclaredFields());
+
+		if (type.getSuperclass() != null) {
+			fields = getAllFields(fields, type.getSuperclass());
+		}
+
+		return fields;
+	}
+
+	public static void addFieldValueToColumn(ContentValues values,
+			Field column, Object object) {
+		column.setAccessible(true);
+		Class<?> columnType = column.getType();
+		try {
+			String columnName = NamingHelper.toSQLName(column);
+			Object columnValue = column.get(object);
+
+			if (SugarRecord.class.isAssignableFrom(columnType)) {
+				values.put(
+						columnName,
+						(columnValue != null) ? String
+								.valueOf(((SugarRecord) columnValue).getId())
+								: "0");
+			} else {
+				if (columnType.equals(Short.class)
+						|| columnType.equals(short.class)) {
+					values.put(columnName, (Short) columnValue);
+				} else if (columnType.equals(Integer.class)
+						|| columnType.equals(int.class)) {
+					values.put(columnName, (Integer) columnValue);
+				} else if (columnType.equals(Long.class)
+						|| columnType.equals(long.class)) {
+					values.put(columnName, (Long) columnValue);
+				} else if (columnType.equals(Float.class)
+						|| columnType.equals(float.class)) {
+					values.put(columnName, (Float) columnValue);
+				} else if (columnType.equals(Double.class)
+						|| columnType.equals(double.class)) {
+					values.put(columnName, (Double) columnValue);
+				} else if (columnType.equals(Boolean.class)
+						|| columnType.equals(boolean.class)) {
+					values.put(columnName, (Boolean) columnValue);
+				} else if (Timestamp.class.equals(columnType)) {
+					try {
+						values.put(columnName,
+								((Timestamp) column.get(object)).getTime());
+					} catch (NullPointerException e) {
+						values.put(columnName, (Long) null);
+					}
+				} else if (Date.class.equals(columnType)) {
+					try {
+						values.put(columnName,
+								((Date) column.get(object)).getTime());
+					} catch (NullPointerException e) {
+						values.put(columnName, (Long) null);
+					}
+				} else if (Calendar.class.equals(columnType)) {
+					try {
+						values.put(columnName, ((Calendar) column.get(object))
+								.getTimeInMillis());
+					} catch (NullPointerException e) {
+						values.put(columnName, (Long) null);
+					}
+				} else {
+					if (columnValue == null) {
+						values.putNull(columnName);
+					} else {
+						values.put(columnName, String.valueOf(columnValue));
+					}
+				}
+			}
+
+		} catch (IllegalAccessException e) {
+			Log.e("Sugar", e.getMessage());
+		}
+	}
+
+	public static void setFieldValueFromCursor(Cursor cursor, Field field,
+			Object object) {
+		field.setAccessible(true);
+		try {
+			Class fieldType = field.getType();
+			String colName = NamingHelper.toSQLName(field);
+
+			int columnIndex = cursor.getColumnIndex(colName);
+
+			if (cursor.isNull(columnIndex)) {
+				return;
+			}
+
+			if (colName.equalsIgnoreCase("id")) {
+				long cid = cursor.getLong(columnIndex);
+				field.set(object, Long.valueOf(cid));
+			} else if (fieldType.equals(long.class)
+					|| fieldType.equals(Long.class)) {
+				field.set(object, cursor.getLong(columnIndex));
+			} else if (fieldType.equals(String.class)) {
+				String val = cursor.getString(columnIndex);
+				field.set(object, val != null && val.equals("null") ? null
+						: val);
+			} else if (fieldType.equals(double.class)
+					|| fieldType.equals(Double.class)) {
+				field.set(object, cursor.getDouble(columnIndex));
+			} else if (fieldType.equals(boolean.class)
+					|| fieldType.equals(Boolean.class)) {
+				field.set(object, cursor.getString(columnIndex).equals("1"));
+			} else if (field.getType().getName().equals("[B")) {
+				field.set(object, cursor.getBlob(columnIndex));
+			} else if (fieldType.equals(int.class)
+					|| fieldType.equals(Integer.class)) {
+				field.set(object, cursor.getInt(columnIndex));
+			} else if (fieldType.equals(float.class)
+					|| fieldType.equals(Float.class)) {
+				field.set(object, cursor.getFloat(columnIndex));
+			} else if (fieldType.equals(short.class)
+					|| fieldType.equals(Short.class)) {
+				field.set(object, cursor.getShort(columnIndex));
+			} else if (fieldType.equals(Timestamp.class)) {
+				long l = cursor.getLong(columnIndex);
+				field.set(object, new Timestamp(l));
+			} else if (fieldType.equals(Date.class)) {
+				long l = cursor.getLong(columnIndex);
+				field.set(object, new Date(l));
+			} else if (fieldType.equals(Calendar.class)) {
+				long l = cursor.getLong(columnIndex);
+				Calendar c = Calendar.getInstance();
+				c.setTimeInMillis(l);
+				field.set(object, c);
+			} else if (Enum.class.isAssignableFrom(fieldType)) {
+				try {
+					Method valueOf = field.getType().getMethod("valueOf",
+							String.class);
+					String strVal = cursor.getString(columnIndex);
+					Object enumVal = valueOf.invoke(field.getType(), strVal);
+					field.set(object, enumVal);
+				} catch (Exception e) {
+					Log.e("Sugar",
+							"Enum cannot be read from Sqlite3 database. Please check the type of field "
+									+ field.getName());
+				}
+			} else
+				Log.e("Sugar",
+						"Class cannot be read from Sqlite3 database. Please check the type of field "
+								+ field.getName() + "("
+								+ field.getType().getName() + ")");
+		} catch (IllegalArgumentException e) {
+			Log.e("field set error", e.getMessage());
+		} catch (IllegalAccessException e) {
+			Log.e("field set error", e.getMessage());
+		}
+	}
+
+	public static void setFieldValueForId(Object object, Long value) {
+
+		try {
+			Field field = null;
+
+			try {
+				field = object.getClass().getField("id");
+			} catch (NoSuchFieldException e) {
+				field = object.getClass().getSuperclass().getField("id");
+			}
+
+			field.setAccessible(true);
+			field.set(object, value);
+		} catch (IllegalAccessException e) {
+			e.printStackTrace();
+		} catch (NoSuchFieldException e) {
+			e.printStackTrace();
+		}
+	}
+
+	public static List<Class> getDomainClasses(Context context) {
+		List<Class> domainClasses = new ArrayList<Class>();
+		try {
+			for (String className : getAllClasses(context)) {
+				if (className.startsWith(ManifestHelper
+						.getDomainPackageName(context))) {
+					Class domainClass = getDomainClass(className, context);
+					if (domainClass != null)
+						domainClasses.add(domainClass);
+				}
+			}
+		} catch (IOException e) {
+			Log.e("Sugar", e.getMessage());
+		} catch (PackageManager.NameNotFoundException e) {
+			Log.e("Sugar", e.getMessage());
+		}
+
+		return domainClasses;
+	}
+
+	private static Class getDomainClass(String className, Context context) {
+		Class<?> discoveredClass = null;
+		try {
+			discoveredClass = Class.forName(className, true, context.getClass()
+					.getClassLoader());
+		} catch (ClassNotFoundException e) {
+			Log.e("Sugar", e.getMessage());
+		}
+
+		if ((discoveredClass != null)
+				&& ((SugarRecord.class.isAssignableFrom(discoveredClass) && !SugarRecord.class
+						.equals(discoveredClass)) || discoveredClass
+						.isAnnotationPresent(Table.class))
+				&& !Modifier.isAbstract(discoveredClass.getModifiers())) {
+
+			Log.i("Sugar", "domain class : " + discoveredClass.getSimpleName());
+			return discoveredClass;
+
+		} else {
+			return null;
+		}
+	}
+
+	private static List<String> getAllClasses(Context context)
+			throws PackageManager.NameNotFoundException, IOException {
+		String path = getSourcePath(context);
+		List<String> classNames = new ArrayList<String>();
+		try {
+			DexFile dexfile = new DexFile(path);
+			Enumeration<String> dexEntries = dexfile.entries();
+			while (dexEntries.hasMoreElements()) {
+				classNames.add(dexEntries.nextElement());
+			}
+		} catch (NullPointerException e) {
+			ClassLoader classLoader = Thread.currentThread()
+					.getContextClassLoader();
+			Enumeration<URL> urls = classLoader.getResources("");
+			List<String> fileNames = new ArrayList<String>();
+			while (urls.hasMoreElements()) {
+				String classDirectoryName = urls.nextElement().getFile();
+				if (classDirectoryName.contains("bin")
+						|| classDirectoryName.contains("classes")) {
+					File classDirectory = new File(classDirectoryName);
+					for (File filePath : classDirectory.listFiles()) {
+						populateFiles(filePath, fileNames, "");
+					}
+					classNames.addAll(fileNames);
+				}
+			}
+		}
+		return classNames;
+	}
+
+	private static void populateFiles(File path, List<String> fileNames,
+			String parent) {
+		if (path.isDirectory()) {
+			for (File newPath : path.listFiles()) {
+				if ("".equals(parent)) {
+					populateFiles(newPath, fileNames, path.getName());
+				} else {
+					populateFiles(newPath, fileNames,
+							parent + "." + path.getName());
+				}
+			}
+		} else {
+			String pathName = path.getName();
+			String classSuffix = ".class";
+			pathName = pathName.endsWith(classSuffix) ? pathName.substring(0,
+					pathName.length() - classSuffix.length()) : pathName;
+			if ("".equals(parent)) {
+				fileNames.add(pathName);
+			} else {
+				fileNames.add(parent + "." + pathName);
+			}
+		}
+	}
+
+	private static String getSourcePath(Context context)
+			throws PackageManager.NameNotFoundException {
+		return context.getPackageManager().getApplicationInfo(
+				context.getPackageName(), 0).sourceDir;
+	}
 }
