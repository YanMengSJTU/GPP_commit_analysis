diff --git a/src/com/mobsandgeeks/saripaar/Rules.java b/src/com/mobsandgeeks/saripaar/Rules.java
index 65e3f81..b05e54c 100644
--- a/src/com/mobsandgeeks/saripaar/Rules.java
+++ b/src/com/mobsandgeeks/saripaar/Rules.java
@@ -17,16 +17,7 @@
 import android.inputmethodservice.ExtractEditText;
 import android.text.TextUtils;
 import android.view.View;
-import android.widget.AutoCompleteTextView;
-import android.widget.CheckBox;
-import android.widget.Checkable;
-import android.widget.CheckedTextView;
-import android.widget.EditText;
-import android.widget.MultiAutoCompleteTextView;
-import android.widget.RadioButton;
-import android.widget.Spinner;
-import android.widget.TextView;
-import android.widget.ToggleButton;
+import android.widget.*;
 
 import java.util.LinkedHashMap;
 import java.util.Set;
@@ -37,756 +28,795 @@
  * {@link AutoCompleteTextView}, {@link ExtractEditText} and {@link MultiAutoCompleteTextView}.
  * {@link Checkable} references notable implementing classes but not limited to {@link CheckBox},
  * {@link CheckedTextView}, {@link RadioButton} and {@link ToggleButton}.
- *
+ * <p/>
  * You may use it with any custom {@link View}s you may define that extends or implements the above
  * mentioned classes and interfaces.
  *
  * @author Ragunath Jawahar <rj@mobsandgeeks.com>
  */
 public final class Rules {
-    // Constants
-    public static final String EMPTY_STRING = "";
-
-    // Regular Expressions
-    private static final String GOOD_IRI_CHAR =
-            "a-zA-Z0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF"; // android.util.Patterns.java
-    private static final String TOP_LEVEL_DOMAIN_STR_FOR_WEB_URL =
-            "(?:"
-            + "(?:aero|arpa|asia|a[cdefgilmnoqrstuwxz])"
-            + "|(?:biz|b[abdefghijmnorstvwyz])"
-            + "|(?:cat|com|coop|c[acdfghiklmnoruvxyz])"
-            + "|d[ejkmoz]"
-            + "|(?:edu|e[cegrstu])"
-            + "|f[ijkmor]"
-            + "|(?:gov|g[abdefghilmnpqrstuwy])"
-            + "|h[kmnrtu]"
-            + "|(?:info|int|i[delmnoqrst])"
-            + "|(?:jobs|j[emop])"
-            + "|k[eghimnprwyz]"
-            + "|l[abcikrstuvy]"
-            + "|(?:mil|mobi|museum|m[acdeghklmnopqrstuvwxyz])"
-            + "|(?:name|net|n[acefgilopruz])"
-            + "|(?:org|om)"
-            + "|(?:pro|p[aefghklmnrstwy])"
-            + "|qa"
-            + "|r[eosuw]"
-            + "|s[abcdeghijklmnortuvyz]"
-            + "|(?:tel|travel|t[cdfghjklmnoprtvwz])"
-            + "|u[agksyz]"
-            + "|v[aceginu]"
-            + "|w[fs]"
-            + "|(?:xn\\-\\-0zwm56d|xn\\-\\-11b5bs3a9aj6g|xn\\-\\-80akhbyknj4f|xn\\-\\-9t4b11yi5a|xn\\-\\-deba0ad|xn\\-\\-g6w251d|xn\\-\\-hgbk6aj7f53bba|xn\\-\\-hlcj6aya9esc7a|xn\\-\\-jxalpdlp|xn\\-\\-kgbechtv|xn\\-\\-zckzah)"
-            + "|y[etu]"
-            + "|z[amw]))"; // android.util.Patterns.java
-
-    public static final String REGEX_INTEGER = "\\d+";
-
-    public static final String REGEX_DECIMAL = "[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?";
-
-    public static final String REGEX_EMAIL =
-            "[a-zA-Z0-9\\+\\.\\_\\%\\-\\+]{1,256}"
-            + "\\@[a-zA-Z0-9][a-zA-Z0-9\\-]{0,64}"
-            + "(\\.[a-zA-Z0-9][a-zA-Z0-9\\-]{0,25})+"; // android.util.Patterns.java
-
-    public static final String REGEX_IP_ADDRESS =
-            "((25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9])\\.(25[0-5]|2[0-4]"
-            + "[0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]"
-            + "[0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}"
-            + "|[1-9][0-9]|[0-9]))"; // android.util.Patterns.java
-
-    public static final String REGEX_WEB_URL =
-            "((?:(http|https|Http|Https|rtsp|Rtsp):\\/\\/(?:(?:[a-zA-Z0-9\\$\\-\\_\\.\\+\\!\\*\\'\\(\\)"
-            + "\\,\\;\\?\\&\\=]|(?:\\%[a-fA-F0-9]{2})){1,64}(?:\\:(?:[a-zA-Z0-9\\$\\-\\_"
-            + "\\.\\+\\!\\*\\'\\(\\)\\,\\;\\?\\&\\=]|(?:\\%[a-fA-F0-9]{2})){1,25})?\\@)?)?"
-            + "((?:(?:[" + GOOD_IRI_CHAR + "][" + GOOD_IRI_CHAR + "\\-]{0,64}\\.)+"   // named host
-            + TOP_LEVEL_DOMAIN_STR_FOR_WEB_URL
-            + "|(?:(?:25[0-5]|2[0-4]" // or ip address
-            + "[0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9])\\.(?:25[0-5]|2[0-4][0-9]"
-            + "|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1]"
-            + "[0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}"
-            + "|[1-9][0-9]|[0-9])))"
-            + "(?:\\:\\d{1,5})?)" // plus option port number
-            + "(\\/(?:(?:[" + GOOD_IRI_CHAR + "\\;\\/\\?\\:\\@\\&\\=\\#\\~"  // plus option query params
-            + "\\-\\.\\+\\!\\*\\'\\(\\)\\,\\_])|(?:\\%[a-fA-F0-9]{2}))*)?"
-            + "(?:\\b|$)"; // android.util.Patterns.java
-
-    /**
-     * The classical required {@link Rule}. Checks if the {@link TextView} or its subclass
-     * {@link View}'s displayed text is not empty.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param trimInput Specifies whether to trim the text returned by {@code getText()}.
-     *
-     * @return True if the {@link View} is not empty, false otherwise. The return value is affected
-     * by the {@code trimInput} parameter.
-     */
-    public static Rule<TextView> required(final String failureMessage, final boolean trimInput) {
-        return new Rule<TextView>(failureMessage) {
-
-            @Override
-            public boolean isValid(TextView textView) {
-                return !TextUtils.isEmpty(getText(textView, trimInput));
-            }
-        };
-    }
-
-    /**
-     * Checks if the {@link TextView} or its subclass {@link View}'s displayed text matches the
-     * given regular expression.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param regex Regular expression pattern to be matched against the text returned by
-     *          {@code getText()}.
-     * @param trimInput Specifies whether to trim the text returned by {@code getText()}.
-     *
-     * @throws IllegalArgumentException If {@code regex} is {@code null}.
-     *
-     * @return True if the text matches the regular expression. The return value is affected
-     * by the {@code trimInput} parameter.
-     */
-    public static Rule<TextView> regex(final String failureMessage, final String regex, 
-            final boolean trimInput) {
-        if (regex == null) {
-            throw new IllegalArgumentException("\'regex\' cannot be null");
-        }
-
-        return new Rule<TextView>(failureMessage) {
-
-            @Override
-            public boolean isValid(TextView textView) {
-                String text = getText(textView, trimInput);
-                return text != null ? text.matches(regex) : false;
-            }
-        };
-    }
-
-    /**
-     * Checks if the {@link TextView} or its subclass {@link View}'s displayed text has at least the
-     * minimum number of characters specified by this {@link Rule}.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param minLength Minimum number of characters required in the text returned by
-     *          {@code getText()}. The returned text is affected by the {@code trimInput}
-     *          parameter.
-     * @param trimInput Specifies whether to trim the text returned by {@code getText()}.
-     *
-     * @return True if the text has the minimum number of characters specified, false otherwise.
-     */
-    public static Rule<TextView> minLength(final String failureMessage, final int minLength,
-            final boolean trimInput) {
-
-        return new Rule<TextView>(failureMessage) {
-
-            @Override
-            public boolean isValid(TextView view) {
-                String text = getText(view, trimInput);
-                return text != null ? text.length() >= minLength : false;
-            }
-        };
-    }
-
-    /**
-     * Checks if the {@link TextView} or its subclass {@link View}'s displayed text's length is less
-     * than or equal to the maximum number of characters specified by this {@link Rule}.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param maxLength Maximum number of characters allowed in the text returned by
-     *          {@code getText()}. The returned text is affected by the {@code trimInput}
-     *          parameter.
-     * @param trimInput Specifies whether to trim the text returned by {@code getText()}.
-     *
-     * @return True if the text length is less than or equal to the maximum number of characters
-     *          specified, false otherwise.
-     */
-    public static Rule<TextView> maxLength(final String failureMessage, final int maxLength,
-            final boolean trimInput) {
-
-        return new Rule<TextView>(failureMessage) {
-
-            @Override
-            public boolean isValid(TextView view) {
-                String text = getText(view, trimInput);
-                return text != null ? text.length() <= maxLength : false;
-            }
-        };
-    }
-
-    /**
-     * Checks if the contents of two {@link TextView}s are equal. Ideal for password and confirm
-     * password.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param anotherTextView The {@link TextView} whose contents have to be checked against the
-     *          {@link TextView} that is being validated.
-     *
-     * @throws IllegalArgumentException If {@code anotherTextView} is {@code null}.
-     *
-     * @return True if both the {@link TextView} contents are equal.
-     */
-    public static Rule<TextView> eq(final String failureMessage, final TextView anotherTextView) {
-        if (anotherTextView == null) {
-            throw new IllegalArgumentException("\'anotherTextView\' cannot be null");
-        }
-
-        return new Rule<TextView>(failureMessage) {
-
-            @Override
-            public boolean isValid(TextView view) {
-                return view.getText().toString().equals(anotherTextView.getText().toString());
-            }
-        };
-    }
-
-    /**
-     * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value equals
-     * the given {@link String} value.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param expectedString {@link String} value to be compared with the text returned by
-     *          {@code getText()}. {@code null} is treated as empty {@link String}.
-     *
-     * @return True if the text matches the {@code expectedString} value, false otherwise.
-     */
-    public static Rule<TextView> eq(final String failureMessage, final String expectedString) {
-        return eq(failureMessage, expectedString, false, false);
-    }
-
-    /**
-     * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value equals
-     * the given {@link String} value.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param expectedString {@link String} value to be compared with the text returned by
-     *          {@code getText()}. {@code null} is treated as empty {@link String}.
-     * @param ignoreCase Specifies whether the text's case differences should be ignored.
-     * @param trimInput Specifies whether to trim the text returned by {@code getText()}.
-     *
-     * @return True if the text matches the {@code expectedString} value, false otherwise. The
-     *          return value is affected by {@code ignoreCase} and {@code trimInput}
-     *          parameters.
-     */
-    public static Rule<TextView> eq(final String failureMessage, final String expectedString,
-            final boolean ignoreCase, final boolean trimInput) {
-        final String cleanString = expectedString == null ? EMPTY_STRING : expectedString;
-
-        return new Rule<TextView>(failureMessage) {
-
-            @Override
-            public boolean isValid(TextView textView) {
-                boolean valid = false;
-                String actualString = getText(textView, trimInput);
-                if (actualString != null) {
-                    valid = ignoreCase ?
-                            actualString.equalsIgnoreCase(cleanString) :
-                                actualString.equals(cleanString);
-                }
-
-                return valid;
-            }
-        };
-    }
-
-    /**
-     * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value equals
-     * the specified {@code int} value.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param expectedInt {@code int} value to be compared with the text returned by
-     *          {@code getText()}.
-     *
-     * @return True if the input text is equal to the {@code expectedInt} value.
-     */
-    public static Rule<TextView> eq(final String failureMessage, final int expectedInt) {
-        return eq(failureMessage, (long) expectedInt);
-    }
-
-    /**
-     * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value is
-     * greater than the specified {@code int} value.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param lesserInt {@code int} value to be compared with the text returned by
-     *          {@code getText()}.
-     *
-     * @return True if the input text is greater to the {@code expectedInt} value.
-     */
-    public static Rule<TextView> gt(final String failureMessage, final int lesserInt) {
-        return gt(failureMessage, (long) lesserInt);
-    }
-
-    /**
-     * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value is less 
-     * than the specified {@code int} value.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param greaterInt {@code int} value to be compared with the text returned by
-     *          {@code getText()}.
-     *
-     * @return True if the input text is less than the {@code expectedInt} value.
-     */
-    public static Rule<TextView> lt(final String failureMessage, final int greaterInt) {
-        return lt(failureMessage, (long) greaterInt);
-    }
-
-    /**
-     * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value equals
-     * the specified {@code long} value.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param expectedLong {@code long} value to be compared with the text returned by
-     *          {@code getText()}.
-     *
-     * @return True if the input text is equal to the {@code expectedLong} value.
-     */
-    public static Rule<TextView> eq(final String failureMessage, final long expectedLong) {
-        return new Rule<TextView>(failureMessage) {
-
-            @Override
-            public boolean isValid(TextView textView) {
-                boolean valid = false;
-                String actualLong = getText(textView, true);
-                if (actualLong != null) {
-                    valid = actualLong.matches(REGEX_INTEGER) ?
-                            Long.parseLong(actualLong) == expectedLong : false;
-                }
-
-                return valid;
-            }
-        };
-    }
-
-    /**
-     * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value is
-     * greater than the specified {@code long} value.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param lesserLong {@code long} value to be compared with the text returned by
-     *          {@code getText()}.
-     *
-     * @return True if the input text is greater than the {@code expectedLong} value.
-     */
-    public static Rule<TextView> gt(final String failureMessage, final long lesserLong) {
-        return new Rule<TextView>(failureMessage) {
-
-            @Override
-            public boolean isValid(TextView textView) {
-                boolean valid = false;
-                String actualLong = getText(textView, true);
-                if (actualLong != null) {
-                    valid = actualLong.matches(REGEX_INTEGER) ?
-                            Long.parseLong(actualLong) > lesserLong : false;
-                }
-
-                return valid;
-            }
-        };
-    }
-
-    /**
-     * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value is less
-     * than the specified {@code long} value.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param greaterLong {@code long} value to be compared with the text returned by
-     *          {@code getText()}.
-     *
-     * @return True if the input text is less than the {@code expectedLong} value.
-     */
-    public static Rule<TextView> lt(final String failureMessage, final long greaterLong) {
-        return new Rule<TextView>(failureMessage) {
-
-            @Override
-            public boolean isValid(TextView textView) {
-                boolean valid = false;
-                String actualLong = getText(textView, true);
-                if (actualLong != null) {
-                    valid = actualLong.matches(REGEX_INTEGER) ?
-                            Long.parseLong(actualLong) < greaterLong : false;
-                }
-
-                return valid;
-            }
-        };
-    }
-
-    /**
-     * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value equals
-     * the specified {@code float} value.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param expectedFloat {@code float} value to be compared with the text returned by
-     *          {@code getText()}.
-     *
-     * @return True if the input text is equal to the {@code expectedFloat} value.
-     */
-    public static Rule<TextView> eq(final String failureMessage, final float expectedFloat) {
-        return new Rule<TextView>(failureMessage) {
-
-            @Override
-            public boolean isValid(TextView view) {
-                boolean valid = false;
-                String actualFloat = getText(view, true);
-                if (actualFloat != null) {
-                    valid = actualFloat.matches(REGEX_DECIMAL) ?
-                            Float.parseFloat(actualFloat) == expectedFloat : false;
-                }
-
-                return valid;
-            }
-        };
-    }
-
-    /**
-     * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value is
-     * greater than the specified {@code float} value.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param lesserFloat {@code float} value to be compared with the text returned by
-     *          {@code getText()}.
-     *
-     * @return True if the input text is equal to the {@code expectedFloat} value.
-     */
-    public static Rule<TextView> gt(final String failureMessage, final float lesserFloat) {
-        return new Rule<TextView>(failureMessage) {
-
-            @Override
-            public boolean isValid(TextView view) {
-                boolean valid = false;
-                String actualFloat = getText(view, true);
-                if (actualFloat != null) {
-                    valid = actualFloat.matches(REGEX_DECIMAL) ?
-                            Float.parseFloat(actualFloat) > lesserFloat : false;
-                }
-
-                return valid;
-            }
-        };
-    }
-
-    /**
-     * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value is
-     * less than the specified {@code float} value.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param greaterFloat {@code float} value to be compared with the text returned by
-     *          {@code getText()}.
-     *
-     * @return True if the input text is less than the {@code expectedFloat} value.
-     */
-    public static Rule<TextView> lt(final String failureMessage, final float greaterFloat) {
-        return new Rule<TextView>(failureMessage) {
-
-            @Override
-            public boolean isValid(TextView view) {
-                boolean valid = false;
-                String actualFloat = getText(view, true);
-                if (actualFloat != null) {
-                    valid = actualFloat.matches(REGEX_DECIMAL) ?
-                            Float.parseFloat(actualFloat) < greaterFloat : false;
-                }
-
-                return valid;
-            }
-        };
-    }
-
-    /**
-     * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value equals
-     * the specified {@code double} value.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param expectedDouble {@code double} value to be compared with the text returned by
-     *          {@code getText()}.
-     *
-     * @return True if the input text is equal to the {@code expectedDouble} value.
-     */
-    public static Rule<TextView> eq(final String failureMessage, final double expectedDouble) {
-        return new Rule<TextView>(failureMessage) {
-
-            @Override
-            public boolean isValid(TextView view) {
-                boolean valid = false;
-                String actualDouble = getText(view, true);
-                if (actualDouble != null) {
-                    valid = actualDouble.matches(REGEX_DECIMAL) ?
-                            Double.parseDouble(actualDouble) == expectedDouble : false;
-                }
-
-                return valid;
-            }
-        };
-    }
-
-    /**
-     * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value is
-     * greater than the specified {@code double} value.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param lesserDouble {@code double} value to be compared with the text returned by
-     *          {@code getText()}.
-     *
-     * @return True if the input text is greater than the {@code expectedDouble} value.
-     */
-    public static Rule<TextView> gt(final String failureMessage, final double lesserDouble) {
-        return new Rule<TextView>(failureMessage) {
-
-            @Override
-            public boolean isValid(TextView view) {
-                boolean valid = false;
-                String actualDouble = getText(view, true);
-                if (actualDouble != null) {
-                    valid = actualDouble.matches(REGEX_DECIMAL) ?
-                            Double.parseDouble(actualDouble) > lesserDouble : false;
-                }
-
-                return valid;
-            }
-        };
-    }
-
-    /**
-     * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value is
-     * less than the specified {@code double} value.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param greaterDouble {@code double} value to be compared with the text returned by
-     *          {@code getText()}.
-     *
-     * @return True if the input text is less than the {@code expectedDouble} value.
-     */
-    public static Rule<TextView> lt(final String failureMessage, final double greaterDouble) {
-        return new Rule<TextView>(failureMessage) {
-
-            @Override
-            public boolean isValid(TextView view) {
-                boolean valid = false;
-                String actualDouble = getText(view, true);
-                if (actualDouble != null) {
-                    valid = actualDouble.matches(REGEX_DECIMAL) ?
-                            Double.parseDouble(actualDouble) < greaterDouble : false;
-                }
-
-                return valid;
-            }
-        };
-    }
-
-    /**
-     * Checks if the {@link Checkable} or its subclass {@link View}'s state is same as the state
-     * specified.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param checked The expected state of the {@link Checkable} widget.
-     *
-     * @return True if the state is same as {@code checked}.
-     */
-    public static Rule<Checkable> checked(final String failureMessage,
-            final boolean checked) {
-        return new Rule<Checkable>(failureMessage) {
-
-            @Override
-            public boolean isValid(Checkable view) {
-                return view.isChecked() == checked;
-            }
-        };
-    }
-
-    /**
-     * Checks if the {@link Spinner}'s selected item's {@link String} value (obtained by calling
-     * {@code toString()} on the selected item) equals the expected {@link String} value.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param expectedString {@link String} value to be compared with the text returned by
-     *          calling {@code toString()} on the selected {@link Spinner} item.
-     * @param ignoreCase Specifies whether the text's case differences should be ignored.
-     * @param trimInput Specifies whether to trim the String returned by {@code toString()}
-     *          on the selected item.
-     *
-     * @return True if both the {@link String} values are equal.
-     */
-    public static Rule<Spinner> spinnerEq(final String failureMessage,
-            final String expectedString, final boolean ignoreCase, final boolean trimInput) {
-
-        return new Rule<Spinner>(failureMessage) {
-
-            @Override
-            public boolean isValid(Spinner spinner) {
-                boolean equals = false;
-                Object selectedItem = spinner.getSelectedItem();
-                if (expectedString == null && selectedItem == null) {
-                    equals = true;
-                } else if (expectedString != null && selectedItem != null) {
-                    String selectedItemString = selectedItem.toString();
-                    selectedItemString = trimInput ? selectedItemString.trim() : selectedItemString;
-
-                    equals = ignoreCase ?
-                            selectedItemString.equalsIgnoreCase(expectedString) :
-                                selectedItemString.equals(expectedString);
-                }
-
-                return equals;
-            }
-        };
-    }
-
-    /**
-     * Checks if the {@link Spinner}'s selected item's position (obtained by calling
-     * {@code getSelectionItemPosition()}) equals the expected selection index.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param expectedPosition The position to be compared with the position returned by
-     *          calling {@code getSelectedItemPosition()} on the {@link Spinner}.
-     *
-     * @return True if both the {@link String} values are equal.
-     */
-    public static Rule<Spinner> spinnerEq(final String failureMessage, final int expectedPosition) {
-
-        return new Rule<Spinner>(failureMessage) {
-
-            @Override
-            public boolean isValid(Spinner spinner) {
-                return spinner.getSelectedItemPosition() == expectedPosition;
-            }
-        };
-    }
-
-    /**
-     * Checks if the {@link Spinner}'s item selection (obtained by calling
-     * {@code getSelectionItemPosition()}) is not equal to the specified selection.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param selection The unexpected selection on the {@link Spinner}.
-     *
-     * @return {@code true} if the selection is not equal to the given position, 
-     *         {@code false} otherwise. 
-     */
-    public static Rule<Spinner> spinnerNotEq(final String failureMessage, final int selection) {
-
-        return new Rule<Spinner>(failureMessage) {
-
-            @Override
-            public boolean isValid(Spinner spinner) {
-                return spinner.getSelectedItemPosition() != selection;
-            }
-        };
-    }
-
-    /**
-     * Performs an '&&' (and) operation on the given array of {@link Rules}.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param rules An array of {@link Rule}s on which the '&&' (and) operation is to be performed.
-     *
-     * @return True if all {@link Rule}s are valid.
-     */
-    public static Rule<View> and(final String failureMessage, final Rule<?>... rules) {
-        return new Rule<View>(failureMessage) {
-
-            @Override
-            public boolean isValid(View view) {
-                boolean valid = true;
-                for(Rule rule : rules) {
-                    if (rule != null) valid &= rule.isValid(view);
-                    if (!valid) break;
-                }
-
-                return valid;
-            }
-        };
-    }
-
-    /**
-     * Performs a '||' (or) operation on the given array of {@link Rules}.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param rules An array of {@link Rule}s on which the '||' (or) operation is to be performed.
-     *
-     * @return True if at least one of the {@link Rule}s is valid.
-     */
-    public static Rule<View> or(final String failureMessage, final Rule<?>... rules) {
-        return new Rule<View>(failureMessage) {
-
-            @Override
-            public boolean isValid(View view) {
-                boolean valid = false;
-                for(Rule rule : rules) {
-                    if (rule != null) valid |= rule.isValid(view);
-                    if (valid) break;
-                }
-
-                return valid;
-            }
-        };
-    }
-
-    /**
-     * Unlike the other rules, this one performs an '&&' (and) operation on several
-     * {@link View}s.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param viewsAndRules A {@link LinkedHashMap} containing rules for different {@link View}s.
-     *
-     * @return True if all {@link Rule}s are valid.
-     */
-    public static Rule<View> compositeAnd(final String failureMessage,
-            final LinkedHashMap<View, Rule<?>> viewsAndRules) {
-
-        return new Rule<View>(failureMessage) {
-
-            @Override
-            public boolean isValid(View view) {
-                boolean valid = true;
-
-                Set<View> keySet = viewsAndRules.keySet();
-                for (View viewKey : keySet) {
-                    Rule rule = viewsAndRules.get(viewKey);
-                    valid &= rule.isValid(view);
-                    if (!valid) break;
-                }
-
-                return valid;
-            }
-        };
-    }
-
-    /**
-     * Unlike the other rules, this one performs a '||' (or) operation on several
-     * {@link View}s.
-     *
-     * @param failureMessage The failure message for this {@link Rule}.
-     * @param viewsAndRules A {@link LinkedHashMap} containing rules for different {@link View}s.
-     *
-     * @return True if at least one of the {@link Rule}s is valid.
-     */
-    public static Rule<View> compositeOr(final String failureMessage,
-            final LinkedHashMap<View, Rule<?>> viewsAndRules) {
-
-        return new Rule<View>(failureMessage) {
-
-            @Override
-            public boolean isValid(View view) {
-                boolean valid = false;
-
-                Set<View> keySet = viewsAndRules.keySet();
-                for (View viewKey : keySet) {
-                    Rule rule = viewsAndRules.get(viewKey);
-                    valid |= rule.isValid(viewKey);
-                    if (valid) break;
-                }
-
-                return valid;
-            }
-        };
-    }
-
-    private static String getText(final TextView textView, final boolean trim) {
-        CharSequence text = null;
-        if (textView != null) {
-            text = textView.getText();
-            text = trim ? text.toString().trim() : text;
-        }
-
-        return text != null ? text.toString() : null;
-    }
+	// Constants
+	public static final String EMPTY_STRING = "";
+
+	// Regular Expressions
+	private static final String GOOD_IRI_CHAR                    =
+			"a-zA-Z0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF"; // android.util.Patterns.java
+	private static final String TOP_LEVEL_DOMAIN_STR_FOR_WEB_URL =
+			"(?:"
+					+ "(?:aero|arpa|asia|a[cdefgilmnoqrstuwxz])"
+					+ "|(?:biz|b[abdefghijmnorstvwyz])"
+					+ "|(?:cat|com|coop|c[acdfghiklmnoruvxyz])"
+					+ "|d[ejkmoz]"
+					+ "|(?:edu|e[cegrstu])"
+					+ "|f[ijkmor]"
+					+ "|(?:gov|g[abdefghilmnpqrstuwy])"
+					+ "|h[kmnrtu]"
+					+ "|(?:info|int|i[delmnoqrst])"
+					+ "|(?:jobs|j[emop])"
+					+ "|k[eghimnprwyz]"
+					+ "|l[abcikrstuvy]"
+					+ "|(?:mil|mobi|museum|m[acdeghklmnopqrstuvwxyz])"
+					+ "|(?:name|net|n[acefgilopruz])"
+					+ "|(?:org|om)"
+					+ "|(?:pro|p[aefghklmnrstwy])"
+					+ "|qa"
+					+ "|r[eosuw]"
+					+ "|s[abcdeghijklmnortuvyz]"
+					+ "|(?:tel|travel|t[cdfghjklmnoprtvwz])"
+					+ "|u[agksyz]"
+					+ "|v[aceginu]"
+					+ "|w[fs]"
+					+ "|(?:xn\\-\\-0zwm56d|xn\\-\\-11b5bs3a9aj6g|xn\\-\\-80akhbyknj4f|xn\\-\\-9t4b11yi5a|xn\\-\\-deba0ad|xn\\-\\-g6w251d|xn\\-\\-hgbk6aj7f53bba|xn\\-\\-hlcj6aya9esc7a|xn\\-\\-jxalpdlp|xn\\-\\-kgbechtv|xn\\-\\-zckzah)"
+					+ "|y[etu]"
+					+ "|z[amw]))"; // android.util.Patterns.java
+
+	public static final String REGEX_INTEGER = "\\d+";
+
+	public static final String REGEX_DECIMAL = "[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?";
+
+	public static final String REGEX_EMAIL =
+			"[a-zA-Z0-9\\+\\.\\_\\%\\-\\+]{1,256}"
+					+ "\\@[a-zA-Z0-9][a-zA-Z0-9\\-]{0,64}"
+					+ "(\\.[a-zA-Z0-9][a-zA-Z0-9\\-]{0,25})+"; // android.util.Patterns.java
+
+	public static final String REGEX_IP_ADDRESS =
+			"((25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9])\\.(25[0-5]|2[0-4]"
+					+ "[0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]"
+					+ "[0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}"
+					+ "|[1-9][0-9]|[0-9]))"; // android.util.Patterns.java
+
+	public static final String REGEX_WEB_URL =
+			"((?:(http|https|Http|Https|rtsp|Rtsp):\\/\\/(?:(?:[a-zA-Z0-9\\$\\-\\_\\.\\+\\!\\*\\'\\(\\)"
+					+ "\\,\\;\\?\\&\\=]|(?:\\%[a-fA-F0-9]{2})){1,64}(?:\\:(?:[a-zA-Z0-9\\$\\-\\_"
+					+ "\\.\\+\\!\\*\\'\\(\\)\\,\\;\\?\\&\\=]|(?:\\%[a-fA-F0-9]{2})){1,25})?\\@)?)?"
+					+ "((?:(?:[" + GOOD_IRI_CHAR + "][" + GOOD_IRI_CHAR + "\\-]{0,64}\\.)+"   // named host
+					+ TOP_LEVEL_DOMAIN_STR_FOR_WEB_URL
+					+ "|(?:(?:25[0-5]|2[0-4]" // or ip address
+					+ "[0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9])\\.(?:25[0-5]|2[0-4][0-9]"
+					+ "|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1]"
+					+ "[0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}"
+					+ "|[1-9][0-9]|[0-9])))"
+					+ "(?:\\:\\d{1,5})?)" // plus option port number
+					+ "(\\/(?:(?:[" + GOOD_IRI_CHAR + "\\;\\/\\?\\:\\@\\&\\=\\#\\~"  // plus option query params
+					+ "\\-\\.\\+\\!\\*\\'\\(\\)\\,\\_])|(?:\\%[a-fA-F0-9]{2}))*)?"
+					+ "(?:\\b|$)"; // android.util.Patterns.java
+
+	/**
+	 * The classical required {@link Rule}. Checks if the {@link TextView} or its subclass
+	 * {@link View}'s displayed text is not empty.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param trimInput
+	 * 		Specifies whether to trim the text returned by {@code getText()}.
+	 * @return True if the {@link View} is not empty, false otherwise. The return value is affected
+	 * by the {@code trimInput} parameter.
+	 */
+	public static Rule<TextView> required(final String failureMessage, final boolean trimInput) {
+		return new Rule<TextView>(failureMessage) {
+
+			@Override
+			public boolean isValid(TextView textView) {
+				return !TextUtils.isEmpty(getText(textView, trimInput));
+			}
+		};
+	}
+
+	/**
+	 * Checks if the {@link TextView} or its subclass {@link View}'s displayed text matches the
+	 * given regular expression.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param regex
+	 * 		Regular expression pattern to be matched against the text returned by
+	 * 		{@code getText()}.
+	 * @param trimInput
+	 * 		Specifies whether to trim the text returned by {@code getText()}.
+	 * @return True if the text matches the regular expression. The return value is affected
+	 * by the {@code trimInput} parameter.
+	 *
+	 * @throws IllegalArgumentException
+	 * 		If {@code regex} is {@code null}.
+	 */
+	public static Rule<TextView> regex(final String failureMessage, final String regex,
+	                                   final boolean trimInput) {
+		if (regex == null) {
+			throw new IllegalArgumentException("\'regex\' cannot be null");
+		}
+
+		return new Rule<TextView>(failureMessage) {
+
+			@Override
+			public boolean isValid(TextView textView) {
+				String text = getText(textView, trimInput);
+				return text != null ? text.matches(regex) : false;
+			}
+		};
+	}
+
+	/**
+	 * Checks if the {@link TextView} or its subclass {@link View}'s displayed text has at least the
+	 * minimum number of characters specified by this {@link Rule}.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param minLength
+	 * 		Minimum number of characters required in the text returned by
+	 * 		{@code getText()}. The returned text is affected by the {@code trimInput}
+	 * 		parameter.
+	 * @param trimInput
+	 * 		Specifies whether to trim the text returned by {@code getText()}.
+	 * @return True if the text has the minimum number of characters specified, false otherwise.
+	 */
+	public static Rule<TextView> minLength(final String failureMessage, final int minLength,
+	                                       final boolean trimInput) {
+
+		return new Rule<TextView>(failureMessage) {
+
+			@Override
+			public boolean isValid(TextView view) {
+				String text = getText(view, trimInput);
+				return text != null ? text.length() >= minLength : false;
+			}
+		};
+	}
+
+	/**
+	 * Checks if the {@link TextView} or its subclass {@link View}'s displayed text's length is less
+	 * than or equal to the maximum number of characters specified by this {@link Rule}.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param maxLength
+	 * 		Maximum number of characters allowed in the text returned by
+	 * 		{@code getText()}. The returned text is affected by the {@code trimInput}
+	 * 		parameter.
+	 * @param trimInput
+	 * 		Specifies whether to trim the text returned by {@code getText()}.
+	 * @return True if the text length is less than or equal to the maximum number of characters
+	 * specified, false otherwise.
+	 */
+	public static Rule<TextView> maxLength(final String failureMessage, final int maxLength,
+	                                       final boolean trimInput) {
+
+		return new Rule<TextView>(failureMessage) {
+
+			@Override
+			public boolean isValid(TextView view) {
+				String text = getText(view, trimInput);
+				return text != null ? text.length() <= maxLength : false;
+			}
+		};
+	}
+
+	/**
+	 * Checks if the contents of two {@link TextView}s are equal. Ideal for password and confirm
+	 * password.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param anotherTextView
+	 * 		The {@link TextView} whose contents have to be checked against the
+	 * 		{@link TextView} that is being validated.
+	 * @return True if both the {@link TextView} contents are equal.
+	 *
+	 * @throws IllegalArgumentException
+	 * 		If {@code anotherTextView} is {@code null}.
+	 */
+	public static Rule<TextView> eq(final String failureMessage, final TextView anotherTextView) {
+		if (anotherTextView == null) {
+			throw new IllegalArgumentException("\'anotherTextView\' cannot be null");
+		}
+
+		return new Rule<TextView>(failureMessage) {
+
+			@Override
+			public boolean isValid(TextView view) {
+				return view.getText().toString().equals(anotherTextView.getText().toString());
+			}
+		};
+	}
+
+	/**
+	 * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value equals
+	 * the given {@link String} value.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param expectedString
+	 * 		{@link String} value to be compared with the text returned by
+	 * 		{@code getText()}. {@code null} is treated as empty {@link String}.
+	 * @return True if the text matches the {@code expectedString} value, false otherwise.
+	 */
+	public static Rule<TextView> eq(final String failureMessage, final String expectedString) {
+		return eq(failureMessage, expectedString, false, false);
+	}
+
+	/**
+	 * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value equals
+	 * the given {@link String} value.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param expectedString
+	 * 		{@link String} value to be compared with the text returned by
+	 * 		{@code getText()}. {@code null} is treated as empty {@link String}.
+	 * @param ignoreCase
+	 * 		Specifies whether the text's case differences should be ignored.
+	 * @param trimInput
+	 * 		Specifies whether to trim the text returned by {@code getText()}.
+	 * @return True if the text matches the {@code expectedString} value, false otherwise. The
+	 * return value is affected by {@code ignoreCase} and {@code trimInput}
+	 * parameters.
+	 */
+	public static Rule<TextView> eq(final String failureMessage, final String expectedString,
+	                                final boolean ignoreCase, final boolean trimInput) {
+		final String cleanString = expectedString == null ? EMPTY_STRING : expectedString;
+
+		return new Rule<TextView>(failureMessage) {
+
+			@Override
+			public boolean isValid(TextView textView) {
+				boolean valid = false;
+				String actualString = getText(textView, trimInput);
+				if (actualString != null) {
+					valid = ignoreCase ?
+							actualString.equalsIgnoreCase(cleanString) :
+							actualString.equals(cleanString);
+				}
+
+				return valid;
+			}
+		};
+	}
+
+	/**
+	 * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value equals
+	 * the specified {@code int} value.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param expectedInt
+	 * 		{@code int} value to be compared with the text returned by
+	 * 		{@code getText()}.
+	 * @return True if the input text is equal to the {@code expectedInt} value.
+	 */
+	public static Rule<TextView> eq(final String failureMessage, final int expectedInt) {
+		return eq(failureMessage, (long) expectedInt);
+	}
+
+	/**
+	 * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value is
+	 * greater than the specified {@code int} value.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param lesserInt
+	 * 		{@code int} value to be compared with the text returned by
+	 * 		{@code getText()}.
+	 * @return True if the input text is greater to the {@code expectedInt} value.
+	 */
+	public static Rule<TextView> gt(final String failureMessage, final int lesserInt) {
+		return gt(failureMessage, (long) lesserInt);
+	}
+
+	/**
+	 * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value is less
+	 * than the specified {@code int} value.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param greaterInt
+	 * 		{@code int} value to be compared with the text returned by
+	 * 		{@code getText()}.
+	 * @return True if the input text is less than the {@code expectedInt} value.
+	 */
+	public static Rule<TextView> lt(final String failureMessage, final int greaterInt) {
+		return lt(failureMessage, (long) greaterInt);
+	}
+
+	/**
+	 * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value equals
+	 * the specified {@code long} value.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param expectedLong
+	 * 		{@code long} value to be compared with the text returned by
+	 * 		{@code getText()}.
+	 * @return True if the input text is equal to the {@code expectedLong} value.
+	 */
+	public static Rule<TextView> eq(final String failureMessage, final long expectedLong) {
+		return new Rule<TextView>(failureMessage) {
+
+			@Override
+			public boolean isValid(TextView textView) {
+				boolean valid = false;
+				String actualLong = getText(textView, true);
+				if (actualLong != null) {
+					valid = actualLong.matches(REGEX_INTEGER) ?
+							Long.parseLong(actualLong) == expectedLong : false;
+				}
+
+				return valid;
+			}
+		};
+	}
+
+	/**
+	 * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value is
+	 * greater than the specified {@code long} value.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param lesserLong
+	 * 		{@code long} value to be compared with the text returned by
+	 * 		{@code getText()}.
+	 * @return True if the input text is greater than the {@code expectedLong} value.
+	 */
+	public static Rule<TextView> gt(final String failureMessage, final long lesserLong) {
+		return new Rule<TextView>(failureMessage) {
+
+			@Override
+			public boolean isValid(TextView textView) {
+				boolean valid = false;
+				String actualLong = getText(textView, true);
+				if (actualLong != null) {
+					valid = actualLong.matches(REGEX_INTEGER) ?
+							Long.parseLong(actualLong) > lesserLong : false;
+				}
+
+				return valid;
+			}
+		};
+	}
+
+	/**
+	 * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value is less
+	 * than the specified {@code long} value.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param greaterLong
+	 * 		{@code long} value to be compared with the text returned by
+	 * 		{@code getText()}.
+	 * @return True if the input text is less than the {@code expectedLong} value.
+	 */
+	public static Rule<TextView> lt(final String failureMessage, final long greaterLong) {
+		return new Rule<TextView>(failureMessage) {
+
+			@Override
+			public boolean isValid(TextView textView) {
+				boolean valid = false;
+				String actualLong = getText(textView, true);
+				if (actualLong != null) {
+					valid = actualLong.matches(REGEX_INTEGER) ?
+							Long.parseLong(actualLong) < greaterLong : false;
+				}
+
+				return valid;
+			}
+		};
+	}
+
+	/**
+	 * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value equals
+	 * the specified {@code float} value.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param expectedFloat
+	 * 		{@code float} value to be compared with the text returned by
+	 * 		{@code getText()}.
+	 * @return True if the input text is equal to the {@code expectedFloat} value.
+	 */
+	public static Rule<TextView> eq(final String failureMessage, final float expectedFloat) {
+		return new Rule<TextView>(failureMessage) {
+
+			@Override
+			public boolean isValid(TextView view) {
+				boolean valid = false;
+				String actualFloat = getText(view, true);
+				if (actualFloat != null) {
+					valid = actualFloat.matches(REGEX_DECIMAL) ?
+							Float.parseFloat(actualFloat) == expectedFloat : false;
+				}
+
+				return valid;
+			}
+		};
+	}
+
+	/**
+	 * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value is
+	 * greater than the specified {@code float} value.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param lesserFloat
+	 * 		{@code float} value to be compared with the text returned by
+	 * 		{@code getText()}.
+	 * @return True if the input text is equal to the {@code expectedFloat} value.
+	 */
+	public static Rule<TextView> gt(final String failureMessage, final float lesserFloat) {
+		return new Rule<TextView>(failureMessage) {
+
+			@Override
+			public boolean isValid(TextView view) {
+				boolean valid = false;
+				String actualFloat = getText(view, true);
+				if (actualFloat != null) {
+					valid = actualFloat.matches(REGEX_DECIMAL) ?
+							Float.parseFloat(actualFloat) > lesserFloat : false;
+				}
+
+				return valid;
+			}
+		};
+	}
+
+	/**
+	 * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value is
+	 * less than the specified {@code float} value.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param greaterFloat
+	 * 		{@code float} value to be compared with the text returned by
+	 * 		{@code getText()}.
+	 * @return True if the input text is less than the {@code expectedFloat} value.
+	 */
+	public static Rule<TextView> lt(final String failureMessage, final float greaterFloat) {
+		return new Rule<TextView>(failureMessage) {
+
+			@Override
+			public boolean isValid(TextView view) {
+				boolean valid = false;
+				String actualFloat = getText(view, true);
+				if (actualFloat != null) {
+					valid = actualFloat.matches(REGEX_DECIMAL) ?
+							Float.parseFloat(actualFloat) < greaterFloat : false;
+				}
+
+				return valid;
+			}
+		};
+	}
+
+	/**
+	 * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value equals
+	 * the specified {@code double} value.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param expectedDouble
+	 * 		{@code double} value to be compared with the text returned by
+	 * 		{@code getText()}.
+	 * @return True if the input text is equal to the {@code expectedDouble} value.
+	 */
+	public static Rule<TextView> eq(final String failureMessage, final double expectedDouble) {
+		return new Rule<TextView>(failureMessage) {
+
+			@Override
+			public boolean isValid(TextView view) {
+				boolean valid = false;
+				String actualDouble = getText(view, true);
+				if (actualDouble != null) {
+					valid = actualDouble.matches(REGEX_DECIMAL) ?
+							Double.parseDouble(actualDouble) == expectedDouble : false;
+				}
+
+				return valid;
+			}
+		};
+	}
+
+	/**
+	 * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value is
+	 * greater than the specified {@code double} value.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param lesserDouble
+	 * 		{@code double} value to be compared with the text returned by
+	 * 		{@code getText()}.
+	 * @return True if the input text is greater than the {@code expectedDouble} value.
+	 */
+	public static Rule<TextView> gt(final String failureMessage, final double lesserDouble) {
+		return new Rule<TextView>(failureMessage) {
+
+			@Override
+			public boolean isValid(TextView view) {
+				boolean valid = false;
+				String actualDouble = getText(view, true);
+				if (actualDouble != null) {
+					valid = actualDouble.matches(REGEX_DECIMAL) ?
+							Double.parseDouble(actualDouble) > lesserDouble : false;
+				}
+
+				return valid;
+			}
+		};
+	}
+
+	/**
+	 * Checks if the {@link TextView} or its subclass {@link View}'s displayed text value is
+	 * less than the specified {@code double} value.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param greaterDouble
+	 * 		{@code double} value to be compared with the text returned by
+	 * 		{@code getText()}.
+	 * @return True if the input text is less than the {@code expectedDouble} value.
+	 */
+	public static Rule<TextView> lt(final String failureMessage, final double greaterDouble) {
+		return new Rule<TextView>(failureMessage) {
+
+			@Override
+			public boolean isValid(TextView view) {
+				boolean valid = false;
+				String actualDouble = getText(view, true);
+				if (actualDouble != null) {
+					valid = actualDouble.matches(REGEX_DECIMAL) ?
+							Double.parseDouble(actualDouble) < greaterDouble : false;
+				}
+
+				return valid;
+			}
+		};
+	}
+
+	/**
+	 * Checks if the {@link Checkable} or its subclass {@link View}'s state is same as the state
+	 * specified.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param checked
+	 * 		The expected state of the {@link Checkable} widget.
+	 * @return True if the state is same as {@code checked}.
+	 */
+	public static Rule<Checkable> checked(final String failureMessage,
+	                                      final boolean checked) {
+		return new Rule<Checkable>(failureMessage) {
+
+			@Override
+			public boolean isValid(Checkable view) {
+				return view.isChecked() == checked;
+			}
+		};
+	}
+
+	/**
+	 * Checks if the {@link Spinner}'s selected item's {@link String} value (obtained by calling
+	 * {@code toString()} on the selected item) equals the expected {@link String} value.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param expectedString
+	 * 		{@link String} value to be compared with the text returned by
+	 * 		calling {@code toString()} on the selected {@link Spinner} item.
+	 * @param ignoreCase
+	 * 		Specifies whether the text's case differences should be ignored.
+	 * @param trimInput
+	 * 		Specifies whether to trim the String returned by {@code toString()}
+	 * 		on the selected item.
+	 * @return True if both the {@link String} values are equal.
+	 */
+	public static Rule<Spinner> spinnerEq(final String failureMessage,
+	                                      final String expectedString, final boolean ignoreCase, final boolean trimInput) {
+
+		return new Rule<Spinner>(failureMessage) {
+
+			@Override
+			public boolean isValid(Spinner spinner) {
+				boolean equals = false;
+				Object selectedItem = spinner.getSelectedItem();
+				if (expectedString == null && selectedItem == null) {
+					equals = true;
+				} else if (expectedString != null && selectedItem != null) {
+					String selectedItemString = selectedItem.toString();
+					selectedItemString = trimInput ? selectedItemString.trim() : selectedItemString;
+
+					equals = ignoreCase ?
+							selectedItemString.equalsIgnoreCase(expectedString) :
+							selectedItemString.equals(expectedString);
+				}
+
+				return equals;
+			}
+		};
+	}
+
+	/**
+	 * Checks if the {@link Spinner}'s selected item's position (obtained by calling
+	 * {@code getSelectionItemPosition()}) equals the expected selection index.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param expectedPosition
+	 * 		The position to be compared with the position returned by
+	 * 		calling {@code getSelectedItemPosition()} on the {@link Spinner}.
+	 * @return True if both the {@link String} values are equal.
+	 */
+	public static Rule<Spinner> spinnerEq(final String failureMessage, final int expectedPosition) {
+
+		return new Rule<Spinner>(failureMessage) {
+
+			@Override
+			public boolean isValid(Spinner spinner) {
+				return spinner.getSelectedItemPosition() == expectedPosition;
+			}
+		};
+	}
+
+	/**
+	 * Checks if the {@link Spinner}'s item selection (obtained by calling
+	 * {@code getSelectionItemPosition()}) is not equal to the specified selection.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param selection
+	 * 		The unexpected selection on the {@link Spinner}.
+	 * @return {@code true} if the selection is not equal to the given position,
+	 * {@code false} otherwise.
+	 */
+	public static Rule<Spinner> spinnerNotEq(final String failureMessage, final int selection) {
+
+		return new Rule<Spinner>(failureMessage) {
+
+			@Override
+			public boolean isValid(Spinner spinner) {
+				return spinner.getSelectedItemPosition() != selection;
+			}
+		};
+	}
+
+	/**
+	 * Performs an '&&' (and) operation on the given array of {@link Rules}.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param rules
+	 * 		An array of {@link Rule}s on which the '&&' (and) operation is to be performed.
+	 * @return True if all {@link Rule}s are valid.
+	 */
+	public static Rule<View> and(final String failureMessage, final Rule<?>... rules) {
+		return new Rule<View>(failureMessage) {
+
+			@Override
+			public boolean isValid(View view) {
+				boolean valid = true;
+				for (Rule rule : rules) {
+					if (rule != null) valid &= rule.isValid(view);
+					if (!valid) {
+						setFailureMessage(rule.getFailureMessage());
+						break;
+					}
+				}
+
+				return valid;
+			}
+		};
+	}
+
+	/**
+	 * Performs a '||' (or) operation on the given array of {@link Rules}.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param rules
+	 * 		An array of {@link Rule}s on which the '||' (or) operation is to be performed.
+	 * @return True if at least one of the {@link Rule}s is valid.
+	 */
+	public static Rule<View> or(final String failureMessage, final Rule<?>... rules) {
+		return new Rule<View>(failureMessage) {
+
+			@Override
+			public boolean isValid(View view) {
+				boolean valid = false;
+				for (Rule rule : rules) {
+					if (rule != null) valid |= rule.isValid(view);
+					if (valid) break;
+				}
+
+				return valid;
+			}
+		};
+	}
+
+	/**
+	 * Unlike the other rules, this one performs an '&&' (and) operation on several
+	 * {@link View}s.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param viewsAndRules
+	 * 		A {@link LinkedHashMap} containing rules for different {@link View}s.
+	 * @return True if all {@link Rule}s are valid.
+	 */
+	public static Rule<View> compositeAnd(final String failureMessage,
+	                                      final LinkedHashMap<View, Rule<?>> viewsAndRules) {
+
+		return new Rule<View>(failureMessage) {
+
+			@Override
+			public boolean isValid(View view) {
+				boolean valid = true;
+
+				Set<View> keySet = viewsAndRules.keySet();
+				for (View viewKey : keySet) {
+					Rule rule = viewsAndRules.get(viewKey);
+					valid &= rule.isValid(view);
+					if (!valid) break;
+				}
+
+				return valid;
+			}
+		};
+	}
+
+	/**
+	 * Unlike the other rules, this one performs a '||' (or) operation on several
+	 * {@link View}s.
+	 *
+	 * @param failureMessage
+	 * 		The failure message for this {@link Rule}.
+	 * @param viewsAndRules
+	 * 		A {@link LinkedHashMap} containing rules for different {@link View}s.
+	 * @return True if at least one of the {@link Rule}s is valid.
+	 */
+	public static Rule<View> compositeOr(final String failureMessage,
+	                                     final LinkedHashMap<View, Rule<?>> viewsAndRules) {
+
+		return new Rule<View>(failureMessage) {
+
+			@Override
+			public boolean isValid(View view) {
+				boolean valid = false;
+
+				Set<View> keySet = viewsAndRules.keySet();
+				for (View viewKey : keySet) {
+					Rule rule = viewsAndRules.get(viewKey);
+					valid |= rule.isValid(viewKey);
+					if (valid) break;
+				}
+
+				return valid;
+			}
+		};
+	}
+
+	private static String getText(final TextView textView, final boolean trim) {
+		CharSequence text = null;
+		if (textView != null) {
+			text = textView.getText();
+			text = trim ? text.toString().trim() : text;
+		}
+
+		return text != null ? text.toString() : null;
+	}
 
 }
diff --git a/src/com/mobsandgeeks/saripaar/Validator.java b/src/com/mobsandgeeks/saripaar/Validator.java
index faadbb8..5e72f98 100644
--- a/src/com/mobsandgeeks/saripaar/Validator.java
+++ b/src/com/mobsandgeeks/saripaar/Validator.java
@@ -18,26 +18,11 @@
 import android.util.Log;
 import android.view.View;
 import android.widget.TextView;
-
-import com.mobsandgeeks.saripaar.annotation.Checked;
-import com.mobsandgeeks.saripaar.annotation.ConfirmPassword;
-import com.mobsandgeeks.saripaar.annotation.Email;
-import com.mobsandgeeks.saripaar.annotation.IpAddress;
-import com.mobsandgeeks.saripaar.annotation.NumberRule;
-import com.mobsandgeeks.saripaar.annotation.Password;
-import com.mobsandgeeks.saripaar.annotation.Regex;
-import com.mobsandgeeks.saripaar.annotation.Required;
-import com.mobsandgeeks.saripaar.annotation.Select;
-import com.mobsandgeeks.saripaar.annotation.TextRule;
+import com.mobsandgeeks.saripaar.annotation.*;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
+import java.util.*;
 
 /**
  * A processor that checks all the {@link Rule}s against their {@link View}s.
@@ -45,558 +30,620 @@
  * @author Ragunath Jawahar <rj@mobsandgeeks.com>
  */
 public class Validator {
-    // Debug
-    static final String TAG = "Validator";
-    static final boolean DEBUG = false;
-
-    private Object mController;
-    private boolean mAnnotationsProcessed;
-    private List<ViewRulePair> mViewsAndRules;
-    private Map<String, Object> mProperties;
-    private AsyncTask<Void, Void, ViewRulePair> mAsyncValidationTask;
-    private ValidationListener mValidationListener;
-
-    /**
-     * Private constructor. Cannot be instantiated.
-     */
-    private Validator() {
-        mAnnotationsProcessed = false;
-        mViewsAndRules = new ArrayList<Validator.ViewRulePair>();
-        mProperties = new HashMap<String, Object>();
-    }
-
-    /**
-     * Creates a new {@link Validator}.
-     *
-     * @param controller The instance that holds references to the Views that are
-     * being validated. Usually an {@code Activity} or a {@code Fragment}. Also accepts
-     * controller instances that have annotated {@code View} references.
-     */
-    public Validator(Object controller) {
-        this();
-        if (controller == null) {
-            throw new IllegalArgumentException("'controller' cannot be null");
-        }
-        mController = controller;
-    }
-
-    /**
-     * Interface definition for a callback to be invoked when {@code validate()} is called.
-     */
-    public interface ValidationListener {
-
-        /**
-         * Called when all the {@link Rule}s added to this Validator are valid.
-         */
-        public void onValidationSucceeded();
-
-        /**
-         * Called if any of the {@link Rule}s fail.
-         *
-         * @param failedView The {@link View} that did not pass validation.
-         * @param failedRule The failed {@link Rule} associated with the {@link View}.
-         */
-        public void onValidationFailed(View failedView, Rule<?> failedRule);
-    }
-
-    /**
-     * Add a {@link View} and it's associated {@link Rule} to the Validator.
-     *
-     * @param view The {@link View} to be validated.
-     * @param rule The {@link Rule} associated with the view.
-     *
-     * @throws IllegalArgumentException If {@code rule} is {@code null}.
-     */
-    public void put(View view, Rule<?> rule) {
-        if (rule == null) {
-            throw new IllegalArgumentException("'rule' cannot be null");
-        }
-
-        mViewsAndRules.add(new ViewRulePair(view, rule));
-    }
-
-    /**
-     * Convenience method for adding multiple {@link Rule}s for a single {@link View}.
-     *
-     * @param view The {@link View} to be validated.
-     * @param rules {@link List} of {@link Rule}s associated with the view.
-     *
-     * @throws IllegalArgumentException If {@code rules} is {@code null}.
-     */
-    public void put(View view, List<Rule<?>> rules) {
-        if (rules == null) {
-            throw new IllegalArgumentException("\'rules\' cannot be null");
-        }
-
-        for (Rule<?> rule : rules) {
-            put(view, rule);
-        }
-    }
-
-    /**
-     * Convenience method for adding just {@link Rule}s to the Validator.
-     *
-     * @param rule A {@link Rule}, usually composite or custom.
-     */
-    public void put(Rule<?> rule) {
-        put(null, rule);
-    }
-
-    /**
-     * Validate all the {@link Rule}s against their {@link View}s.
-     *
-     * @throws IllegalStateException If a {@link ValidationListener} is not registered.
-     */
-    public synchronized void validate() {
-        if (mValidationListener == null) {
-            throw new IllegalStateException("Set a " + ValidationListener.class.getSimpleName() +
-                    " before attempting to validate.");
-        }
-
-        ViewRulePair failedViewRulePair = validateAllRules();
-        if (failedViewRulePair == null) {
-            mValidationListener.onValidationSucceeded();
-        } else {
-            mValidationListener.onValidationFailed(failedViewRulePair.view, failedViewRulePair.rule);
-        }
-    }
-
-    /**
-     * Asynchronously validates all the {@link Rule}s against their {@link View}s. Subsequent calls
-     * to this method will cancel any pending asynchronous validations and start a new one.
-     *
-     * @throws IllegalStateException If a {@link ValidationListener} is not registered.
-     */
-    public void validateAsync() {
-        if (mValidationListener == null) {
-            throw new IllegalStateException("Set a " + ValidationListener.class.getSimpleName() +
-                    " before attempting to validate.");
-        }
-
-        // Cancel the existing task
-        if (mAsyncValidationTask != null) {
-            mAsyncValidationTask.cancel(true);
-            mAsyncValidationTask = null;
-        }
-
-        // Start a new one ;)
-        mAsyncValidationTask = new AsyncTask<Void, Void, ViewRulePair>() {
-
-            @Override
-            protected ViewRulePair doInBackground(Void... params) {
-                return validateAllRules();
-            }
-
-            @Override
-            protected void onPostExecute(ViewRulePair pair) {
-                if (pair == null) {
-                    mValidationListener.onValidationSucceeded();
-                } else {
-                    mValidationListener.onValidationFailed(pair.view, pair.rule);
-                }
-
-                mAsyncValidationTask = null;
-            }
-
-            @Override
-            protected void onCancelled() {
-                mAsyncValidationTask = null;
-            }
-        };
-
-        mAsyncValidationTask.execute((Void[]) null);
-    }
-
-    /**
-     * Used to find if the asynchronous validation task is running, useful only when you run the
-     * Validator in asynchronous mode using the {@code validateAsync} method.
-     *
-     * @return True if the asynchronous task is running, false otherwise.
-     */
-    public boolean isValidating() {
-        return mAsyncValidationTask != null &&
-                mAsyncValidationTask.getStatus() != AsyncTask.Status.FINISHED;
-    }
-
-    /**
-     * Cancels the asynchronous validation task if running, useful only when you run the
-     * Validator in asynchronous mode using the {@code validateAsync} method.
-     *
-     * @return True if the asynchronous task was cancelled.
-     */
-    public boolean cancelAsync() {
-        boolean cancelled = false;
-        if (mAsyncValidationTask != null) {
-            cancelled = mAsyncValidationTask.cancel(true);
-            mAsyncValidationTask = null;
-        }
-
-        return cancelled;
-    }
-
-    /**
-     * Returns the callback registered for this Validator.
-     *
-     * @return The callback, or null if one is not registered.
-     */
-    public ValidationListener getValidationListener() {
-        return mValidationListener;
-    }
-
-    /**
-     * Register a callback to be invoked when {@code validate()} is called.
-     *
-     * @param validationListener The callback that will run.
-     */
-    public void setValidationListener(ValidationListener validationListener) {
-        this.mValidationListener = validationListener;
-    }
-
-    /**
-     * Updates a property value if it exists, else creates a new one.
-     *
-     * @param name The property name.
-     * @param value Value of the property.
-     *
-     * @throws IllegalArgumentException If {@code name} is {@code null}.
-     */
-    public void setProperty(String name, Object value) {
-        if (name == null) {
-            throw new IllegalArgumentException("\'name\' cannot be null");
-        }
-
-        mProperties.put(name, value);
-    }
-
-    /**
-     * Retrieves the value of the given property.
-     *
-     * @param name The property name.
-     *
-     * @throws IllegalArgumentException If {@code name} is {@code null}.
-     *
-     * @return Value of the property or {@code null} if the property does not exist.
-     */
-    public Object getProperty(String name) {
-        if (name == null) {
-            throw new IllegalArgumentException("\'name\' cannot be null");
-        }
-
-        return mProperties.get(name);
-    }
-
-    /**
-     * Removes the property from this Validator.
-     *
-     * @param name The property name.
-     *
-     * @return The value of the removed property or {@code null} if the property was not found.
-     */
-    public Object removeProperty(String name) {
-        return name != null ? mProperties.remove(name) : null;
-    }
-
-    /**
-     * Checks if the specified property exists in this Validator.
-     *
-     * @param name The property name.
-     *
-     * @return True if the property exists.
-     */
-    public boolean containsProperty(String name) {
-        return name != null ? mProperties.containsKey(name) : false;
-    }
-
-    /**
-     * Removes all properties from this Validator.
-     */
-    public void removeAllProperties() {
-        mProperties.clear();
-    }
-
-    /**
-     * Removes all the rules for the matching {@link View}
-     * @param view The {@code View} whose rules must be removed.
-     */
-    public void removeRulesFor(View view) {
-        if (view == null) {
-            throw new IllegalArgumentException("'view' cannot be null");
-        }
-
-        int index = 0;
-        while (index < mViewsAndRules.size()) {
-            ViewRulePair pair = mViewsAndRules.get(index);
-            if (pair.view == view) {
-                mViewsAndRules.remove(index);
-                continue;
-            }
-
-            index++;
-        }
-    }
-
-    /**
-     * Validates all rules added to this Validator.
-     *
-     * @return {@code null} if all {@code Rule}s are valid, else returns the failed
-     *          {@code ViewRulePair}.
-     */
-    private ViewRulePair validateAllRules() {
-        if (!mAnnotationsProcessed) {
-            createRulesFromAnnotations(getSaripaarAnnotatedFields());
-            mAnnotationsProcessed = true;
-        }
-
-        if (mViewsAndRules.size() == 0) {
-            Log.i(TAG, "No rules found. Passing validation by default.");
-            return null;
-        }
-
-        ViewRulePair failedViewRulePair = null;
-        for (ViewRulePair pair : mViewsAndRules) {
-            if (pair == null) continue;
-
-            // Validate views only if they are visible and enabled
-            if (pair.view != null) {
-                if (!pair.view.isShown() || !pair.view.isEnabled()) continue;
-            }
-
-            if (!pair.rule.isValid(pair.view)) {
-                failedViewRulePair = pair;
-                break;
-            }
-        }
-
-        return failedViewRulePair;
-    }
-
-    private void createRulesFromAnnotations(List<AnnotationFieldPair> annotationFieldPairs) {
-        TextView passwordTextView = null;
-        TextView confirmPasswordTextView = null;
-
-        for (AnnotationFieldPair pair : annotationFieldPairs) {
-            // Password
-            if (pair.annotation.annotationType().equals(Password.class)) {
-                if (passwordTextView == null) {
-                    passwordTextView = (TextView) getView(pair.field);
-                } else {
-                    throw new IllegalStateException("You cannot annotate " +
-                            "two fields in the same Activity with @Password.");
-                }
-            }
-
-            // Confirm password
-            if (pair.annotation.annotationType().equals(ConfirmPassword.class)) {
-                if (passwordTextView == null) {
-                    throw new IllegalStateException("A @Password annotated field is required " +
-                            "before you can use @ConfirmPassword.");
-                } else if (confirmPasswordTextView != null) {
-                    throw new IllegalStateException("You cannot annotate " +
-                            "two fields in the same Activity with @ConfirmPassword.");
-                } else if (confirmPasswordTextView == null) {
-                    confirmPasswordTextView = (TextView) getView(pair.field);
-                }
-            }
-
-            // Others
-            ViewRulePair viewRulePair = null;
-            if (pair.annotation.annotationType().equals(ConfirmPassword.class)) {
-                viewRulePair = getViewAndRule(pair.field, pair.annotation, passwordTextView);
-            } else {
-                viewRulePair = getViewAndRule(pair.field, pair.annotation);
-            }
-            if (viewRulePair != null) {
-                if (DEBUG) {
-                    Log.d(TAG, String.format("Added @%s rule for %s.",
-                            pair.annotation.annotationType().getSimpleName(),
-                            pair.field.getName()));
-                }
-                mViewsAndRules.add(viewRulePair);
-            }
-        }
-    }
-
-    private ViewRulePair getViewAndRule(Field field, Annotation annotation, Object... params) {
-        View view = getView(field);
-        if (view == null) {
-            Log.w(TAG, String.format("Your %s - %s is null. Please check your field assignment(s).",
-                    field.getType().getSimpleName(), field.getName()));
-            return null;
-        }
-
-        Rule<?> rule = null;
-        if (params != null && params.length > 0) {
-            rule = AnnotationRuleFactory.getRule(field, view, annotation, params);
-        } else {
-            rule = AnnotationRuleFactory.getRule(field, view, annotation);
-        }
-
-        return rule != null ? new ViewRulePair(view, rule) : null;
-    }
-
-    private View getView(Field field) {
-        try {
-            field.setAccessible(true);
-            Object instance = mController;
-
-            return (View) field.get(instance);
-        } catch (IllegalArgumentException e) {
-            e.printStackTrace();
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        }
-        return null;
-    }
-
-    private List<AnnotationFieldPair> getSaripaarAnnotatedFields() {
-        List<AnnotationFieldPair> annotationFieldPairs = new ArrayList<AnnotationFieldPair>();
-        List<Field> fieldsWithAnnotations = getViewFieldsWithAnnotations();
-
-        for (Field field : fieldsWithAnnotations) {
-            Annotation[] annotations = field.getAnnotations();
-            for (Annotation annotation : annotations) {
-                if (isSaripaarAnnotation(annotation)) {
-                    if (DEBUG) {
-                        Log.d(TAG, String.format("%s %s is annotated with @%s",
-                                field.getType().getSimpleName(), field.getName(),
-                                annotation.annotationType().getSimpleName()));
-                    }
-                    annotationFieldPairs.add(new AnnotationFieldPair(annotation, field));
-                }
-            }
-        }
-
-        Collections.sort(annotationFieldPairs, new AnnotationFieldPairCompartor());
-
-        return annotationFieldPairs;
-    }
-
-    private List<Field> getViewFieldsWithAnnotations() {
-        List<Field> fieldsWithAnnotations = new ArrayList<Field>();
-        List<Field> viewFields = getAllViewFields();
-        for (Field field : viewFields) {
-            Annotation[] annotations = field.getAnnotations();
-            if (annotations == null || annotations.length == 0) {
-                continue;
-            }
-            fieldsWithAnnotations.add(field);
-        }
-        return fieldsWithAnnotations;
-    }
-
-    private List<Field> getAllViewFields() {
-        List<Field> viewFields = new ArrayList<Field>();
-
-        // Declared fields
-        Class<?> superClass = null;
-        if (mController != null) {
-            viewFields.addAll(getDeclaredViewFields(mController.getClass()));
-            superClass = mController.getClass().getSuperclass();
-        }
-
-        // Inherited fields
-        while (superClass != null && !superClass.equals(Object.class)) {
-            List<Field> declaredViewFields = getDeclaredViewFields(superClass);
-            if (declaredViewFields.size() > 0) {
-                viewFields.addAll(declaredViewFields);
-            }
-            superClass = superClass.getSuperclass();
-        }
-
-        return viewFields;
-    }
-
-    private List<Field> getDeclaredViewFields(Class<?> clazz) {
-        List<Field> viewFields = new ArrayList<Field>();
-        Field[] declaredFields = clazz.getDeclaredFields();
-        for (Field f : declaredFields) {
-            if (View.class.isAssignableFrom(f.getType())) {
-                viewFields.add(f);
-            }
-        }
-        return viewFields;
-    }
-
-    private boolean isSaripaarAnnotation(Annotation annotation) {
-        Class<?> annotationType = annotation.annotationType();
-        return annotationType.equals(Checked.class) ||
-                annotationType.equals(ConfirmPassword.class) ||
-                annotationType.equals(Email.class) ||
-                annotationType.equals(IpAddress.class) ||
-                annotationType.equals(NumberRule.class) ||
-                annotationType.equals(Password.class) ||
-                annotationType.equals(Regex.class) ||
-                annotationType.equals(Required.class) ||
-                annotationType.equals(Select.class) ||
-                annotationType.equals(TextRule.class);
-    }
-
-    private class ViewRulePair {
-        public View view;
-        public Rule rule;
-
-        public ViewRulePair(View view, Rule<?> rule) {
-            this.view = view;
-            this.rule = rule;
-        }
-    }
-
-    private class AnnotationFieldPair {
-        public Annotation annotation;
-        public Field field;
-
-        public AnnotationFieldPair(Annotation annotation, Field field) {
-            this.annotation = annotation;
-            this.field = field;
-        }
-    }
-
-    private class AnnotationFieldPairCompartor implements Comparator<AnnotationFieldPair> {
-
-        @Override
-        public int compare(AnnotationFieldPair lhs, AnnotationFieldPair rhs) {
-            int lhsOrder = getAnnotationOrder(lhs.annotation);
-            int rhsOrder = getAnnotationOrder(rhs.annotation);
-            return lhsOrder < rhsOrder ? -1 : lhsOrder == rhsOrder ? 0 : 1;
-        }
-
-        private int getAnnotationOrder(Annotation annotation) {
-            Class<?> annotatedClass = annotation.annotationType();
-            if (annotatedClass.equals(Checked.class)) {
-                return ((Checked) annotation).order();
-
-            } else if (annotatedClass.equals(ConfirmPassword.class)) {
-                return ((ConfirmPassword) annotation).order();
-
-            } else if (annotatedClass.equals(Email.class)) {
-                return ((Email) annotation).order();
-
-            } else if (annotatedClass.equals(IpAddress.class)) {
-                return ((IpAddress) annotation).order();
-
-            } else if (annotatedClass.equals(NumberRule.class)) {
-                return ((NumberRule) annotation).order();
-
-            } else if (annotatedClass.equals(Password.class)) {
-                return ((Password) annotation).order();
-
-            } else if (annotatedClass.equals(Regex.class)) {
-                return ((Regex) annotation).order();
-
-            } else if (annotatedClass.equals(Required.class)) {
-                return ((Required) annotation).order();
-
-            } else if (annotatedClass.equals(Select.class)) {
-                return ((Select) annotation).order();
-
-            } else if (annotatedClass.equals(TextRule.class)) {
-                return ((TextRule) annotation).order();
-
-            } else {
-                throw new IllegalArgumentException(String.format("%s is not a Saripaar annotation",
-                        annotatedClass.getName()));
-            }
-        }
-    }
+	// Debug
+	static final String  TAG   = "Validator";
+	static final boolean DEBUG = false;
+
+	private Object                              mController;
+	private boolean                             mAnnotationsProcessed;
+	private List<ViewRulePair>                  mViewsAndRules;
+	private Map<String, Object>                 mProperties;
+	private AsyncTask<Void, Void, ViewRulePair> mAsyncValidationTask;
+	private ValidationListener                  mValidationListener;
+
+	/**
+	 * Private constructor. Cannot be instantiated.
+	 */
+	private Validator() {
+		mAnnotationsProcessed = false;
+		mViewsAndRules = new ArrayList<Validator.ViewRulePair>();
+		mProperties = new HashMap<String, Object>();
+	}
+
+	/**
+	 * Creates a new {@link Validator}.
+	 *
+	 * @param controller
+	 * 		The instance that holds references to the Views that are
+	 * 		being validated. Usually an {@code Activity} or a {@code Fragment}. Also accepts
+	 * 		controller instances that have annotated {@code View} references.
+	 */
+	public Validator(Object controller) {
+		this();
+		if (controller == null) {
+			throw new IllegalArgumentException("'controller' cannot be null");
+		}
+		mController = controller;
+	}
+
+	/**
+	 * Interface definition for a callback to be invoked when {@code validate()} is called.
+	 */
+	public interface ValidationListener {
+
+		/**
+		 * Called when all the {@link Rule}s added to this Validator are valid.
+		 */
+		public void onValidationSucceeded();
+
+		/**
+		 * Called if any of the {@link Rule}s fail.
+		 *
+		 * @param failedView
+		 * 		The {@link View} that did not pass validation.
+		 * @param failedRule
+		 * 		The failed {@link Rule} associated with the {@link View}.
+		 */
+		public void onValidationFailed(View failedView, Rule<?> failedRule);
+	}
+
+	/**
+	 * Add a {@link View} and it's associated {@link Rule} to the Validator.
+	 *
+	 * @param view
+	 * 		The {@link View} to be validated.
+	 * @param rule
+	 * 		The {@link Rule} associated with the view.
+	 * @throws IllegalArgumentException
+	 * 		If {@code rule} is {@code null}.
+	 */
+	public void put(View view, Rule<?> rule) {
+		if (rule == null) {
+			throw new IllegalArgumentException("'rule' cannot be null");
+		}
+
+		mViewsAndRules.add(new ViewRulePair(view, rule));
+	}
+
+	/**
+	 * Convenience method for adding multiple {@link Rule}s for a single {@link View}.
+	 *
+	 * @param view
+	 * 		The {@link View} to be validated.
+	 * @param rules
+	 * 		{@link List} of {@link Rule}s associated with the view.
+	 * @throws IllegalArgumentException
+	 * 		If {@code rules} is {@code null}.
+	 */
+	public void put(View view, List<Rule<?>> rules) {
+		if (rules == null) {
+			throw new IllegalArgumentException("\'rules\' cannot be null");
+		}
+
+		for (Rule<?> rule : rules) {
+			put(view, rule);
+		}
+	}
+
+	/**
+	 * Convenience method for adding just {@link Rule}s to the Validator.
+	 *
+	 * @param rule
+	 * 		A {@link Rule}, usually composite or custom.
+	 */
+	public void put(Rule<?> rule) {
+		put(null, rule);
+	}
+
+	/**
+	 * Validate all the {@link Rule}s against their {@link View}s.
+	 *
+	 * @throws IllegalStateException
+	 * 		If a {@link ValidationListener} is not registered.
+	 */
+	public synchronized void validate() {
+		if (mValidationListener == null) {
+			throw new IllegalStateException("Set a " + ValidationListener.class.getSimpleName() +
+					                                " before attempting to validate.");
+		}
+
+		ViewRulePair failedViewRulePair = validateAllRules();
+		if (failedViewRulePair == null) {
+			mValidationListener.onValidationSucceeded();
+		} else {
+			mValidationListener.onValidationFailed(failedViewRulePair.view, failedViewRulePair.rule);
+		}
+	}
+
+	public synchronized void valideAllAtOnce() {
+		if (mValidationListener == null) {
+			throw new IllegalStateException("Set a " + ValidationListener.class.getSimpleName() +
+					                                " before attempting to validate.");
+		}
+
+		ArrayList<ViewRulePair> failedViewRulePair = validateAllRulesAtOnce();
+		if (failedViewRulePair != null && failedViewRulePair.size() == 0) {
+			mValidationListener.onValidationSucceeded();
+		} else {
+			for (ViewRulePair _T_rulePair : failedViewRulePair) {
+				mValidationListener.onValidationFailed(_T_rulePair.view, _T_rulePair.rule);
+			}
+		}
+	}
+
+	/**
+	 * Asynchronously validates all the {@link Rule}s against their {@link View}s. Subsequent calls
+	 * to this method will cancel any pending asynchronous validations and start a new one.
+	 *
+	 * @throws IllegalStateException
+	 * 		If a {@link ValidationListener} is not registered.
+	 */
+	public void validateAsync() {
+		if (mValidationListener == null) {
+			throw new IllegalStateException("Set a " + ValidationListener.class.getSimpleName() +
+					                                " before attempting to validate.");
+		}
+
+		// Cancel the existing task
+		if (mAsyncValidationTask != null) {
+			mAsyncValidationTask.cancel(true);
+			mAsyncValidationTask = null;
+		}
+
+		// Start a new one ;)
+		mAsyncValidationTask = new AsyncTask<Void, Void, ViewRulePair>() {
+
+			@Override
+			protected ViewRulePair doInBackground(Void... params) {
+				return validateAllRules();
+			}
+
+			@Override
+			protected void onPostExecute(ViewRulePair pair) {
+				if (pair == null) {
+					mValidationListener.onValidationSucceeded();
+				} else {
+					mValidationListener.onValidationFailed(pair.view, pair.rule);
+				}
+
+				mAsyncValidationTask = null;
+			}
+
+			@Override
+			protected void onCancelled() {
+				mAsyncValidationTask = null;
+			}
+		};
+
+		mAsyncValidationTask.execute((Void[]) null);
+	}
+
+	/**
+	 * Used to find if the asynchronous validation task is running, useful only when you run the
+	 * Validator in asynchronous mode using the {@code validateAsync} method.
+	 *
+	 * @return True if the asynchronous task is running, false otherwise.
+	 */
+	public boolean isValidating() {
+		return mAsyncValidationTask != null &&
+				mAsyncValidationTask.getStatus() != AsyncTask.Status.FINISHED;
+	}
+
+	/**
+	 * Cancels the asynchronous validation task if running, useful only when you run the
+	 * Validator in asynchronous mode using the {@code validateAsync} method.
+	 *
+	 * @return True if the asynchronous task was cancelled.
+	 */
+	public boolean cancelAsync() {
+		boolean cancelled = false;
+		if (mAsyncValidationTask != null) {
+			cancelled = mAsyncValidationTask.cancel(true);
+			mAsyncValidationTask = null;
+		}
+
+		return cancelled;
+	}
+
+	/**
+	 * Returns the callback registered for this Validator.
+	 *
+	 * @return The callback, or null if one is not registered.
+	 */
+	public ValidationListener getValidationListener() {
+		return mValidationListener;
+	}
+
+	/**
+	 * Register a callback to be invoked when {@code validate()} is called.
+	 *
+	 * @param validationListener
+	 * 		The callback that will run.
+	 */
+	public void setValidationListener(ValidationListener validationListener) {
+		this.mValidationListener = validationListener;
+	}
+
+	/**
+	 * Updates a property value if it exists, else creates a new one.
+	 *
+	 * @param name
+	 * 		The property name.
+	 * @param value
+	 * 		Value of the property.
+	 * @throws IllegalArgumentException
+	 * 		If {@code name} is {@code null}.
+	 */
+	public void setProperty(String name, Object value) {
+		if (name == null) {
+			throw new IllegalArgumentException("\'name\' cannot be null");
+		}
+
+		mProperties.put(name, value);
+	}
+
+	/**
+	 * Retrieves the value of the given property.
+	 *
+	 * @param name
+	 * 		The property name.
+	 * @return Value of the property or {@code null} if the property does not exist.
+	 *
+	 * @throws IllegalArgumentException
+	 * 		If {@code name} is {@code null}.
+	 */
+	public Object getProperty(String name) {
+		if (name == null) {
+			throw new IllegalArgumentException("\'name\' cannot be null");
+		}
+
+		return mProperties.get(name);
+	}
+
+	/**
+	 * Removes the property from this Validator.
+	 *
+	 * @param name
+	 * 		The property name.
+	 * @return The value of the removed property or {@code null} if the property was not found.
+	 */
+	public Object removeProperty(String name) {
+		return name != null ? mProperties.remove(name) : null;
+	}
+
+	/**
+	 * Checks if the specified property exists in this Validator.
+	 *
+	 * @param name
+	 * 		The property name.
+	 * @return True if the property exists.
+	 */
+	public boolean containsProperty(String name) {
+		return name != null ? mProperties.containsKey(name) : false;
+	}
+
+	/**
+	 * Removes all properties from this Validator.
+	 */
+	public void removeAllProperties() {
+		mProperties.clear();
+	}
+
+	/**
+	 * Removes all the rules for the matching {@link View}
+	 *
+	 * @param view
+	 * 		The {@code View} whose rules must be removed.
+	 */
+	public void removeRulesFor(View view) {
+		if (view == null) {
+			throw new IllegalArgumentException("'view' cannot be null");
+		}
+
+		int index = 0;
+		while (index < mViewsAndRules.size()) {
+			ViewRulePair pair = mViewsAndRules.get(index);
+			if (pair.view == view) {
+				mViewsAndRules.remove(index);
+				continue;
+			}
+
+			index++;
+		}
+	}
+
+	/**
+	 * Validates all rules added to this Validator.
+	 *
+	 * @return {@code null} if all {@code Rule}s are valid, else returns the failed
+	 * {@code ViewRulePair}.
+	 */
+	private ViewRulePair validateAllRules() {
+		if (!mAnnotationsProcessed) {
+			createRulesFromAnnotations(getSaripaarAnnotatedFields());
+			mAnnotationsProcessed = true;
+		}
+
+		if (mViewsAndRules.size() == 0) {
+			Log.i(TAG, "No rules found. Passing validation by default.");
+			return null;
+		}
+
+		ViewRulePair failedViewRulePair = null;
+		for (ViewRulePair pair : mViewsAndRules) {
+			if (pair == null) continue;
+
+			// Validate views only if they are visible and enabled
+			if (pair.view != null) {
+				if (!pair.view.isShown() || !pair.view.isEnabled()) continue;
+			}
+
+			if (!pair.rule.isValid(pair.view)) {
+				failedViewRulePair = pair;
+				break;
+			}
+		}
+
+		return failedViewRulePair;
+	}
+
+	private ArrayList<ViewRulePair> validateAllRulesAtOnce() {
+		ArrayList<ViewRulePair> failedListViewRulePair = new ArrayList<ViewRulePair>();
+
+		if (!mAnnotationsProcessed) {
+			createRulesFromAnnotations(getSaripaarAnnotatedFields());
+			mAnnotationsProcessed = true;
+		}
+
+		if (mViewsAndRules.size() == 0) {
+			Log.i(TAG, "No rules found. Passing validation by default.");
+			return null;
+		}
+
+		ViewRulePair failedViewRulePair = null;
+		for (ViewRulePair pair : mViewsAndRules) {
+			if (pair == null) continue;
+
+			// Validate views only if they are visible and enabled
+			if (pair.view != null) {
+				if (!pair.view.isShown() || !pair.view.isEnabled()) continue;
+			}
+
+			if (!pair.rule.isValid(pair.view)) {
+				failedListViewRulePair.add(pair);
+			}
+		}
+
+		return failedListViewRulePair;
+	}
+
+	private void createRulesFromAnnotations(List<AnnotationFieldPair> annotationFieldPairs) {
+		TextView passwordTextView = null;
+		TextView confirmPasswordTextView = null;
+
+		for (AnnotationFieldPair pair : annotationFieldPairs) {
+			// Password
+			if (pair.annotation.annotationType().equals(Password.class)) {
+				if (passwordTextView == null) {
+					passwordTextView = (TextView) getView(pair.field);
+				} else {
+					throw new IllegalStateException("You cannot annotate " +
+							                                "two fields in the same Activity with @Password.");
+				}
+			}
+
+			// Confirm password
+			if (pair.annotation.annotationType().equals(ConfirmPassword.class)) {
+				if (passwordTextView == null) {
+					throw new IllegalStateException("A @Password annotated field is required " +
+							                                "before you can use @ConfirmPassword.");
+				} else if (confirmPasswordTextView != null) {
+					throw new IllegalStateException("You cannot annotate " +
+							                                "two fields in the same Activity with @ConfirmPassword.");
+				} else if (confirmPasswordTextView == null) {
+					confirmPasswordTextView = (TextView) getView(pair.field);
+				}
+			}
+
+			// Others
+			ViewRulePair viewRulePair = null;
+			if (pair.annotation.annotationType().equals(ConfirmPassword.class)) {
+				viewRulePair = getViewAndRule(pair.field, pair.annotation, passwordTextView);
+			} else {
+				viewRulePair = getViewAndRule(pair.field, pair.annotation);
+			}
+			if (viewRulePair != null) {
+				if (DEBUG) {
+					Log.d(TAG, String.format("Added @%s rule for %s.",
+					                         pair.annotation.annotationType().getSimpleName(),
+					                         pair.field.getName()));
+				}
+				mViewsAndRules.add(viewRulePair);
+			}
+		}
+	}
+
+	private ViewRulePair getViewAndRule(Field field, Annotation annotation, Object... params) {
+		View view = getView(field);
+		if (view == null) {
+			Log.w(TAG, String.format("Your %s - %s is null. Please check your field assignment(s).",
+			                         field.getType().getSimpleName(), field.getName()));
+			return null;
+		}
+
+		Rule<?> rule = null;
+		if (params != null && params.length > 0) {
+			rule = AnnotationRuleFactory.getRule(field, view, annotation, params);
+		} else {
+			rule = AnnotationRuleFactory.getRule(field, view, annotation);
+		}
+
+		return rule != null ? new ViewRulePair(view, rule) : null;
+	}
+
+	private View getView(Field field) {
+		try {
+			field.setAccessible(true);
+			Object instance = mController;
+
+			return (View) field.get(instance);
+		} catch (IllegalArgumentException e) {
+			e.printStackTrace();
+		} catch (IllegalAccessException e) {
+			e.printStackTrace();
+		}
+		return null;
+	}
+
+	private List<AnnotationFieldPair> getSaripaarAnnotatedFields() {
+		List<AnnotationFieldPair> annotationFieldPairs = new ArrayList<AnnotationFieldPair>();
+		List<Field> fieldsWithAnnotations = getViewFieldsWithAnnotations();
+
+		for (Field field : fieldsWithAnnotations) {
+			Annotation[] annotations = field.getAnnotations();
+			for (Annotation annotation : annotations) {
+				if (isSaripaarAnnotation(annotation)) {
+					if (DEBUG) {
+						Log.d(TAG, String.format("%s %s is annotated with @%s",
+						                         field.getType().getSimpleName(), field.getName(),
+						                         annotation.annotationType().getSimpleName()));
+					}
+					annotationFieldPairs.add(new AnnotationFieldPair(annotation, field));
+				}
+			}
+		}
+
+		Collections.sort(annotationFieldPairs, new AnnotationFieldPairCompartor());
+
+		return annotationFieldPairs;
+	}
+
+	private List<Field> getViewFieldsWithAnnotations() {
+		List<Field> fieldsWithAnnotations = new ArrayList<Field>();
+		List<Field> viewFields = getAllViewFields();
+		for (Field field : viewFields) {
+			Annotation[] annotations = field.getAnnotations();
+			if (annotations == null || annotations.length == 0) {
+				continue;
+			}
+			fieldsWithAnnotations.add(field);
+		}
+		return fieldsWithAnnotations;
+	}
+
+	private List<Field> getAllViewFields() {
+		List<Field> viewFields = new ArrayList<Field>();
+
+		// Declared fields
+		Class<?> superClass = null;
+		if (mController != null) {
+			viewFields.addAll(getDeclaredViewFields(mController.getClass()));
+			superClass = mController.getClass().getSuperclass();
+		}
+
+		// Inherited fields
+		while (superClass != null && !superClass.equals(Object.class)) {
+			List<Field> declaredViewFields = getDeclaredViewFields(superClass);
+			if (declaredViewFields.size() > 0) {
+				viewFields.addAll(declaredViewFields);
+			}
+			superClass = superClass.getSuperclass();
+		}
+
+		return viewFields;
+	}
+
+	private List<Field> getDeclaredViewFields(Class<?> clazz) {
+		List<Field> viewFields = new ArrayList<Field>();
+		Field[] declaredFields = clazz.getDeclaredFields();
+		for (Field f : declaredFields) {
+			if (View.class.isAssignableFrom(f.getType())) {
+				viewFields.add(f);
+			}
+		}
+		return viewFields;
+	}
+
+	private boolean isSaripaarAnnotation(Annotation annotation) {
+		Class<?> annotationType = annotation.annotationType();
+		return annotationType.equals(Checked.class) ||
+				annotationType.equals(ConfirmPassword.class) ||
+				annotationType.equals(Email.class) ||
+				annotationType.equals(IpAddress.class) ||
+				annotationType.equals(NumberRule.class) ||
+				annotationType.equals(Password.class) ||
+				annotationType.equals(Regex.class) ||
+				annotationType.equals(Required.class) ||
+				annotationType.equals(Select.class) ||
+				annotationType.equals(TextRule.class);
+	}
+
+	private class ViewRulePair {
+		public View view;
+		public Rule rule;
+
+		public ViewRulePair(View view, Rule<?> rule) {
+			this.view = view;
+			this.rule = rule;
+		}
+	}
+
+	private class AnnotationFieldPair {
+		public Annotation annotation;
+		public Field      field;
+
+		public AnnotationFieldPair(Annotation annotation, Field field) {
+			this.annotation = annotation;
+			this.field = field;
+		}
+	}
+
+	private class AnnotationFieldPairCompartor implements Comparator<AnnotationFieldPair> {
+
+		@Override
+		public int compare(AnnotationFieldPair lhs, AnnotationFieldPair rhs) {
+			int lhsOrder = getAnnotationOrder(lhs.annotation);
+			int rhsOrder = getAnnotationOrder(rhs.annotation);
+			return lhsOrder < rhsOrder ? -1 : lhsOrder == rhsOrder ? 0 : 1;
+		}
+
+		private int getAnnotationOrder(Annotation annotation) {
+			Class<?> annotatedClass = annotation.annotationType();
+			if (annotatedClass.equals(Checked.class)) {
+				return ( (Checked) annotation ).order();
+
+			} else if (annotatedClass.equals(ConfirmPassword.class)) {
+				return ( (ConfirmPassword) annotation ).order();
+
+			} else if (annotatedClass.equals(Email.class)) {
+				return ( (Email) annotation ).order();
+
+			} else if (annotatedClass.equals(IpAddress.class)) {
+				return ( (IpAddress) annotation ).order();
+
+			} else if (annotatedClass.equals(NumberRule.class)) {
+				return ( (NumberRule) annotation ).order();
+
+			} else if (annotatedClass.equals(Password.class)) {
+				return ( (Password) annotation ).order();
+
+			} else if (annotatedClass.equals(Regex.class)) {
+				return ( (Regex) annotation ).order();
+
+			} else if (annotatedClass.equals(Required.class)) {
+				return ( (Required) annotation ).order();
+
+			} else if (annotatedClass.equals(Select.class)) {
+				return ( (Select) annotation ).order();
+
+			} else if (annotatedClass.equals(TextRule.class)) {
+				return ( (TextRule) annotation ).order();
+
+			} else {
+				throw new IllegalArgumentException(String.format("%s is not a Saripaar annotation",
+				                                                 annotatedClass.getName()));
+			}
+		}
+	}
 
 }
