diff --git a/demo/src/main/java/com/evernote/android/job/demo/MainActivity.java b/demo/src/main/java/com/evernote/android/job/demo/MainActivity.java
index 4724bbe..20d62bd 100644
--- a/demo/src/main/java/com/evernote/android/job/demo/MainActivity.java
+++ b/demo/src/main/java/com/evernote/android/job/demo/MainActivity.java
@@ -14,7 +14,6 @@
 import com.evernote.android.job.JobManager;
 import com.evernote.android.job.JobRequest;
 import com.evernote.android.job.util.JobApi;
-import com.evernote.android.job.util.support.PersistableBundleCompat;
 
 import net.vrallev.android.cat.Cat;
 
@@ -174,8 +173,7 @@ public void onClick(View view) {
     }
 
     private void testSimple() {
-        PersistableBundleCompat extras = new PersistableBundleCompat();
-        extras.putString("key", "Hello world");
+        String data = "Hello World";
 
         mLastJobId = new JobRequest.Builder(DemoSyncJob.TAG)
                 .setExecutionWindow(3_000L, 4_000L)
@@ -183,7 +181,7 @@ private void testSimple() {
                 .setRequiresCharging(mRequiresCharging.isChecked())
                 .setRequiresDeviceIdle(mRequiresDeviceIdle.isChecked())
                 .setRequiredNetworkType(JobRequest.NetworkType.values()[mNetworkTypeSpinner.getSelectedItemPosition()])
-                .setExtras(extras)
+                .setData(data)
                 .setRequirementsEnforced(true)
                 .setPersisted(true)
                 .build()
@@ -217,12 +215,11 @@ private void testPeriodic() {
     }
 
     private void testExact() {
-        PersistableBundleCompat extras = new PersistableBundleCompat();
-        extras.putString("key", "Hello world");
+        String data = "Hello World";
 
         mLastJobId = new JobRequest.Builder(DemoSyncJob.TAG)
                 .setBackoffCriteria(5_000L, JobRequest.BackoffPolicy.EXPONENTIAL)
-                .setExtras(extras)
+                .setData(data)
                 .setExact(20_000L)
                 .setPersisted(true)
                 .setUpdateCurrent(true)
diff --git a/demo/src/main/java/com/evernote/android/job/demo/UnitTestDatabaseCreator.java b/demo/src/main/java/com/evernote/android/job/demo/UnitTestDatabaseCreator.java
index b6fe215..a3a16a6 100644
--- a/demo/src/main/java/com/evernote/android/job/demo/UnitTestDatabaseCreator.java
+++ b/demo/src/main/java/com/evernote/android/job/demo/UnitTestDatabaseCreator.java
@@ -1,7 +1,6 @@
 package com.evernote.android.job.demo;
 
 import com.evernote.android.job.JobRequest;
-import com.evernote.android.job.util.support.PersistableBundleCompat;
 
 import java.util.concurrent.TimeUnit;
 
@@ -58,9 +57,8 @@ public void createOneOff() {
                         .setPersisted(random());
 
                 if (random()) {
-                    PersistableBundleCompat extras = new PersistableBundleCompat();
-                    extras.putString("key", "Hello world");
-                    builder.setExtras(extras);
+                    String extras = "Hello world";
+                    builder.setData(extras);
                 }
 
                 builder.build().schedule();
@@ -77,9 +75,8 @@ public void createExact() {
                         .setPersisted(random());
 
                 if (random()) {
-                    PersistableBundleCompat extras = new PersistableBundleCompat();
-                    extras.putString("key", "Hello world");
-                    builder.setExtras(extras);
+                    String extras = "Hello world";
+                    builder.setData(extras);
                 }
 
                 builder.build().schedule();
@@ -99,9 +96,8 @@ public void createPeriodic() {
                         .setPersisted(random());
 
                 if (random()) {
-                    PersistableBundleCompat extras = new PersistableBundleCompat();
-                    extras.putString("key", "Hello world");
-                    builder.setExtras(extras);
+                    String extras = "Hello world";
+                    builder.setData(extras);
                 }
 
                 builder.build().schedule();
@@ -121,9 +117,8 @@ public void createPeriodic() {
                         .setPersisted(random());
 
                 if (random()) {
-                    PersistableBundleCompat extras = new PersistableBundleCompat();
-                    extras.putString("key", "Hello world");
-                    builder.setExtras(extras);
+                    String extras = "Hello world";
+                    builder.setData(extras);
                 }
                 if (random()) {
                     builder.setPeriodic(JobRequest.MIN_INTERVAL);
diff --git a/library/src/main/java/com/evernote/android/job/Job.java b/library/src/main/java/com/evernote/android/job/Job.java
index 751d070..cc7e360 100644
--- a/library/src/main/java/com/evernote/android/job/Job.java
+++ b/library/src/main/java/com/evernote/android/job/Job.java
@@ -36,7 +36,6 @@
 
 import com.evernote.android.job.util.Device;
 import com.evernote.android.job.util.JobCat;
-import com.evernote.android.job.util.support.PersistableBundleCompat;
 
 import net.vrallev.android.cat.CatLog;
 
@@ -360,7 +359,7 @@ public String toString() {
     public static final class Params {
 
         private final JobRequest mRequest;
-        private PersistableBundleCompat mExtras;
+        private String mData;
 
         private Params(@NonNull JobRequest request) {
             mRequest = request;
@@ -548,14 +547,8 @@ public long getLastRun() {
          * @return Extra arguments for this {@link Job}. Never returns {@code null}.
          */
         @NonNull
-        public PersistableBundleCompat getExtras() {
-            if (mExtras == null) {
-                mExtras = mRequest.getExtras();
-                if (mExtras == null) {
-                    mExtras = new PersistableBundleCompat();
-                }
-            }
-            return mExtras;
+        public String getData() {
+            return mRequest.getData();
         }
 
         /*package*/ JobRequest getRequest() {
diff --git a/library/src/main/java/com/evernote/android/job/JobRequest.java b/library/src/main/java/com/evernote/android/job/JobRequest.java
index 6b4b186..7e07f87 100644
--- a/library/src/main/java/com/evernote/android/job/JobRequest.java
+++ b/library/src/main/java/com/evernote/android/job/JobRequest.java
@@ -30,13 +30,11 @@
 import android.database.Cursor;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-import android.text.TextUtils;
 
 import com.evernote.android.job.util.JobApi;
 import com.evernote.android.job.util.JobCat;
 import com.evernote.android.job.util.JobPreconditions;
 import com.evernote.android.job.util.JobUtil;
-import com.evernote.android.job.util.support.PersistableBundleCompat;
 
 import net.vrallev.android.cat.CatLog;
 
@@ -235,13 +233,10 @@ public NetworkType requiredNetworkType() {
     }
 
     /**
-     * @return The extras for this job.
+     * @return The data for this job.
      */
-    public PersistableBundleCompat getExtras() {
-        if (mBuilder.mExtras == null && !TextUtils.isEmpty(mBuilder.mExtrasXml)) {
-            mBuilder.mExtras = PersistableBundleCompat.fromXml(mBuilder.mExtrasXml);
-        }
-        return mBuilder.mExtras;
+    public String getData() {
+        return mBuilder.mData;
     }
 
     /**
@@ -493,8 +488,7 @@ public String toString() {
         private boolean mExact;
         private NetworkType mNetworkType;
 
-        private PersistableBundleCompat mExtras;
-        private String mExtrasXml;
+        private String mData;
 
         private boolean mPersisted;
 
@@ -556,7 +550,7 @@ private Builder(Cursor cursor) throws Exception {
                 mNetworkType = DEFAULT_NETWORK_TYPE;
             }
 
-            mExtrasXml = cursor.getString(cursor.getColumnIndex(JobStorage.COLUMN_EXTRAS));
+            mData = cursor.getString(cursor.getColumnIndex(JobStorage.COLUMN_EXTRAS));
 
             mPersisted = cursor.getInt(cursor.getColumnIndex(JobStorage.COLUMN_PERSISTED)) > 0;
         }
@@ -585,8 +579,7 @@ private Builder(@NonNull Builder builder, boolean createId) {
             mExact = builder.mExact;
             mNetworkType = builder.mNetworkType;
 
-            mExtras = builder.mExtras;
-            mExtrasXml = builder.mExtrasXml;
+            mData = builder.mData;
 
             mPersisted = builder.mPersisted;
 
@@ -612,11 +605,7 @@ private void fillContentValues(ContentValues contentValues) {
             contentValues.put(JobStorage.COLUMN_EXACT, mExact);
             contentValues.put(JobStorage.COLUMN_NETWORK_TYPE, mNetworkType.toString());
 
-            if (mExtras != null) {
-                contentValues.put(JobStorage.COLUMN_EXTRAS, mExtras.saveToXml());
-            } else if (!TextUtils.isEmpty(mExtrasXml)) {
-                contentValues.put(JobStorage.COLUMN_EXTRAS, mExtrasXml);
-            }
+            contentValues.put(JobStorage.COLUMN_EXTRAS, mData);
             contentValues.put(JobStorage.COLUMN_PERSISTED, mPersisted);
         }
 
@@ -668,17 +657,12 @@ public Builder setExecutionWindow(long startInMs, long endInMs) {
         }
 
         /**
-         * Set optional extras. This is persisted, so only primitive types are allowed.
+         * Set optional data.
          *
-         * @param extras Bundle containing extras which you can retrieve with {@link Job.Params#getExtras()}.
+         * @param data String
          */
-        public Builder setExtras(@Nullable PersistableBundleCompat extras) {
-            if (extras == null) {
-                mExtras = null;
-                mExtrasXml = null;
-            } else {
-                mExtras = new PersistableBundleCompat(extras);
-            }
+        public Builder setData(@Nullable String data) {
+            mData = data;
             return this;
         }
 
diff --git a/library/src/main/java/com/evernote/android/job/util/support/FastXmlSerializer.java b/library/src/main/java/com/evernote/android/job/util/support/FastXmlSerializer.java
deleted file mode 100644
index 87f0fd1..0000000
--- a/library/src/main/java/com/evernote/android/job/util/support/FastXmlSerializer.java
+++ /dev/null
@@ -1,400 +0,0 @@
-/*
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.evernote.android.job.util.support;
-
-import org.xmlpull.v1.XmlSerializer;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.io.OutputStreamWriter;
-import java.io.UnsupportedEncodingException;
-import java.io.Writer;
-import java.nio.ByteBuffer;
-import java.nio.CharBuffer;
-import java.nio.charset.Charset;
-import java.nio.charset.CharsetEncoder;
-import java.nio.charset.CoderResult;
-import java.nio.charset.IllegalCharsetNameException;
-import java.nio.charset.UnsupportedCharsetException;
-
-/**
- * This is a quick and dirty implementation of XmlSerializer that isn't horribly
- * painfully slow like the normal one.  It only does what is needed for the
- * specific XML files being written with it.
- */
-/*package*/
-@SuppressWarnings({"TryWithIdenticalCatches", "FieldCanBeLocal", "ConstantIfStatement", "ConstantConditions"})
-class FastXmlSerializer implements XmlSerializer {
-    private static final String[] ESCAPE_TABLE = new String[] {
-            null,     null,     null,     null,     null,     null,     null,     null,  // 0-7
-            null,     null,     null,     null,     null,     null,     null,     null,  // 8-15
-            null,     null,     null,     null,     null,     null,     null,     null,  // 16-23
-            null,     null,     null,     null,     null,     null,     null,     null,  // 24-31
-            null,     null,     "&quot;", null,     null,     null,     "&amp;",  null,  // 32-39
-            null,     null,     null,     null,     null,     null,     null,     null,  // 40-47
-            null,     null,     null,     null,     null,     null,     null,     null,  // 48-55
-            null,     null,     null,     null,     "&lt;",   null,     "&gt;",   null,  // 56-63
-    };
-
-    private static final int BUFFER_LEN = 8192;
-
-    private static String sSpace = "                                                              ";
-
-    private final char[] mText = new char[BUFFER_LEN];
-    private int mPos;
-
-    private Writer mWriter;
-
-    private OutputStream mOutputStream;
-    private CharsetEncoder mCharset;
-    private ByteBuffer mBytes = ByteBuffer.allocate(BUFFER_LEN);
-
-    private boolean mIndent = false;
-    private boolean mInTag;
-
-    private int mNesting = 0;
-    private boolean mLineStart = true;
-
-    private void append(char c) throws IOException {
-        int pos = mPos;
-        if (pos >= (BUFFER_LEN-1)) {
-            flush();
-            pos = mPos;
-        }
-        mText[pos] = c;
-        mPos = pos+1;
-    }
-
-    private void append(String str, int i, final int length) throws IOException {
-        if (length > BUFFER_LEN) {
-            final int end = i + length;
-            while (i < end) {
-                int next = i + BUFFER_LEN;
-                append(str, i, next<end ? BUFFER_LEN : (end-i));
-                i = next;
-            }
-            return;
-        }
-        int pos = mPos;
-        if ((pos+length) > BUFFER_LEN) {
-            flush();
-            pos = mPos;
-        }
-        str.getChars(i, i+length, mText, pos);
-        mPos = pos + length;
-    }
-
-    private void append(char[] buf, int i, final int length) throws IOException {
-        if (length > BUFFER_LEN) {
-            final int end = i + length;
-            while (i < end) {
-                int next = i + BUFFER_LEN;
-                append(buf, i, next<end ? BUFFER_LEN : (end-i));
-                i = next;
-            }
-            return;
-        }
-        int pos = mPos;
-        if ((pos+length) > BUFFER_LEN) {
-            flush();
-            pos = mPos;
-        }
-        System.arraycopy(buf, i, mText, pos, length);
-        mPos = pos + length;
-    }
-
-    private void append(String str) throws IOException {
-        append(str, 0, str.length());
-    }
-
-    private void appendIndent(int indent) throws IOException {
-        indent *= 4;
-        if (indent > sSpace.length()) {
-            indent = sSpace.length();
-        }
-        append(sSpace, 0, indent);
-    }
-
-    private void escapeAndAppendString(final String string) throws IOException {
-        final int n = string.length();
-        final char ne = (char) ESCAPE_TABLE.length;
-        final String[] escapes = ESCAPE_TABLE;
-        int lastPos = 0;
-        int pos;
-        for (pos=0; pos<n; pos++) {
-            char c = string.charAt(pos);
-            if (c >= ne) continue;
-            String escape = escapes[c];
-            if (escape == null) continue;
-            if (lastPos < pos) append(string, lastPos, pos-lastPos);
-            lastPos = pos + 1;
-            append(escape);
-        }
-        if (lastPos < pos) append(string, lastPos, pos-lastPos);
-    }
-
-    private void escapeAndAppendString(char[] buf, int start, int len) throws IOException {
-        final char ne = (char) ESCAPE_TABLE.length;
-        final String[] escapes = ESCAPE_TABLE;
-        int end = start+len;
-        int lastPos = start;
-        int pos;
-        for (pos=start; pos<end; pos++) {
-            char c = buf[pos];
-            if (c >= ne) continue;
-            String escape = escapes[c];
-            if (escape == null) continue;
-            if (lastPos < pos) append(buf, lastPos, pos-lastPos);
-            lastPos = pos + 1;
-            append(escape);
-        }
-        if (lastPos < pos) append(buf, lastPos, pos-lastPos);
-    }
-
-    public XmlSerializer attribute(String namespace, String name, String value) throws IOException,
-            IllegalArgumentException, IllegalStateException {
-        append(' ');
-        if (namespace != null) {
-            append(namespace);
-            append(':');
-        }
-        append(name);
-        append("=\"");
-
-        escapeAndAppendString(value);
-        append('"');
-        mLineStart = false;
-        return this;
-    }
-
-    public void cdsect(String text) throws IOException, IllegalArgumentException,
-            IllegalStateException {
-        throw new UnsupportedOperationException();
-    }
-
-    public void comment(String text) throws IOException, IllegalArgumentException,
-            IllegalStateException {
-        throw new UnsupportedOperationException();
-    }
-
-    public void docdecl(String text) throws IOException, IllegalArgumentException,
-            IllegalStateException {
-        throw new UnsupportedOperationException();
-    }
-
-    public void endDocument() throws IOException, IllegalArgumentException, IllegalStateException {
-        flush();
-    }
-
-    public XmlSerializer endTag(String namespace, String name) throws IOException,
-            IllegalArgumentException, IllegalStateException {
-        mNesting--;
-        if (mInTag) {
-            append(" />\n");
-        } else {
-            if (mIndent && mLineStart) {
-                appendIndent(mNesting);
-            }
-            append("</");
-            if (namespace != null) {
-                append(namespace);
-                append(':');
-            }
-            append(name);
-            append(">\n");
-        }
-        mLineStart = true;
-        mInTag = false;
-        return this;
-    }
-
-    public void entityRef(String text) throws IOException, IllegalArgumentException,
-            IllegalStateException {
-        throw new UnsupportedOperationException();
-    }
-
-    private void flushBytes() throws IOException {
-        int position;
-        if ((position = mBytes.position()) > 0) {
-            mBytes.flip();
-            mOutputStream.write(mBytes.array(), 0, position);
-            mBytes.clear();
-        }
-    }
-
-    public void flush() throws IOException {
-        //Log.i("PackageManager", "flush mPos=" + mPos);
-        if (mPos > 0) {
-            if (mOutputStream != null) {
-                CharBuffer charBuffer = CharBuffer.wrap(mText, 0, mPos);
-                CoderResult result = mCharset.encode(charBuffer, mBytes, true);
-                while (true) {
-                    if (result.isError()) {
-                        throw new IOException(result.toString());
-                    } else if (result.isOverflow()) {
-                        flushBytes();
-                        result = mCharset.encode(charBuffer, mBytes, true);
-                        continue;
-                    }
-                    break;
-                }
-                flushBytes();
-                mOutputStream.flush();
-            } else {
-                mWriter.write(mText, 0, mPos);
-                mWriter.flush();
-            }
-            mPos = 0;
-        }
-    }
-
-    public int getDepth() {
-        throw new UnsupportedOperationException();
-    }
-
-    public boolean getFeature(String name) {
-        throw new UnsupportedOperationException();
-    }
-
-    public String getName() {
-        throw new UnsupportedOperationException();
-    }
-
-    public String getNamespace() {
-        throw new UnsupportedOperationException();
-    }
-
-    public String getPrefix(String namespace, boolean generatePrefix)
-            throws IllegalArgumentException {
-        throw new UnsupportedOperationException();
-    }
-
-    public Object getProperty(String name) {
-        throw new UnsupportedOperationException();
-    }
-
-    public void ignorableWhitespace(String text) throws IOException, IllegalArgumentException,
-            IllegalStateException {
-        throw new UnsupportedOperationException();
-    }
-
-    public void processingInstruction(String text) throws IOException, IllegalArgumentException,
-            IllegalStateException {
-        throw new UnsupportedOperationException();
-    }
-
-    public void setFeature(String name, boolean state) throws IllegalArgumentException,
-            IllegalStateException {
-        if (name.equals("http://xmlpull.org/v1/doc/features.html#indent-output")) {
-            mIndent = true;
-            return;
-        }
-        throw new UnsupportedOperationException();
-    }
-
-    public void setOutput(OutputStream os, String encoding) throws IOException,
-            IllegalArgumentException, IllegalStateException {
-        if (os == null)
-            throw new IllegalArgumentException();
-        if (true) {
-            try {
-                mCharset = Charset.forName(encoding).newEncoder();
-            } catch (IllegalCharsetNameException e) {
-                throw (UnsupportedEncodingException) (new UnsupportedEncodingException(
-                        encoding).initCause(e));
-            } catch (UnsupportedCharsetException e) {
-                throw (UnsupportedEncodingException) (new UnsupportedEncodingException(
-                        encoding).initCause(e));
-            }
-            mOutputStream = os;
-        } else {
-            setOutput(
-                    encoding == null
-                            ? new OutputStreamWriter(os)
-                            : new OutputStreamWriter(os, encoding));
-        }
-    }
-
-    public void setOutput(Writer writer) throws IOException, IllegalArgumentException,
-            IllegalStateException {
-        mWriter = writer;
-    }
-
-    public void setPrefix(String prefix, String namespace) throws IOException,
-            IllegalArgumentException, IllegalStateException {
-        throw new UnsupportedOperationException();
-    }
-
-    public void setProperty(String name, Object value) throws IllegalArgumentException,
-            IllegalStateException {
-        throw new UnsupportedOperationException();
-    }
-
-    public void startDocument(String encoding, Boolean standalone) throws IOException,
-            IllegalArgumentException, IllegalStateException {
-        append("<?xml version='1.0' encoding='utf-8' standalone='"
-                + (standalone ? "yes" : "no") + "' ?>\n");
-        mLineStart = true;
-    }
-
-    public XmlSerializer startTag(String namespace, String name) throws IOException,
-            IllegalArgumentException, IllegalStateException {
-        if (mInTag) {
-            append(">\n");
-        }
-        if (mIndent) {
-            appendIndent(mNesting);
-        }
-        mNesting++;
-        append('<');
-        if (namespace != null) {
-            append(namespace);
-            append(':');
-        }
-        append(name);
-        mInTag = true;
-        mLineStart = false;
-        return this;
-    }
-
-    public XmlSerializer text(char[] buf, int start, int len) throws IOException,
-            IllegalArgumentException, IllegalStateException {
-        if (mInTag) {
-            append(">");
-            mInTag = false;
-        }
-        escapeAndAppendString(buf, start, len);
-        if (mIndent) {
-            mLineStart = buf[start+len-1] == '\n';
-        }
-        return this;
-    }
-
-    public XmlSerializer text(String text) throws IOException, IllegalArgumentException,
-            IllegalStateException {
-        if (mInTag) {
-            append(">");
-            mInTag = false;
-        }
-        escapeAndAppendString(text);
-        if (mIndent) {
-            mLineStart = text.length() > 0 && (text.charAt(text.length()-1) == '\n');
-        }
-        return this;
-    }
-
-}
diff --git a/library/src/main/java/com/evernote/android/job/util/support/PersistableBundleCompat.java b/library/src/main/java/com/evernote/android/job/util/support/PersistableBundleCompat.java
deleted file mode 100644
index 86889b1..0000000
--- a/library/src/main/java/com/evernote/android/job/util/support/PersistableBundleCompat.java
+++ /dev/null
@@ -1,285 +0,0 @@
-/*
- * Copyright 2007-present Evernote Corporation.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-package com.evernote.android.job.util.support;
-
-import android.os.PersistableBundle;
-import android.support.annotation.NonNull;
-
-import com.evernote.android.job.util.JobCat;
-
-import net.vrallev.android.cat.CatLog;
-
-import org.xmlpull.v1.XmlPullParserException;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * Compat class which provides similar features like {@link PersistableBundle}. Besides a boolean array
- * all methods are available.
- *
- * @author rwondratschek
- */
-@SuppressWarnings("unused")
-public final class PersistableBundleCompat {
-
-    private static final CatLog CAT = new JobCat("PersistableBundleCompat");
-    private static final String UTF_8 = "UTF-8";
-
-    private final Map<String, Object> mValues;
-
-    public PersistableBundleCompat() {
-        this(new HashMap<String, Object>());
-    }
-
-    public PersistableBundleCompat(PersistableBundleCompat bundle) {
-        this(new HashMap<>(bundle.mValues));
-    }
-
-    private PersistableBundleCompat(Map<String, Object> values) {
-        mValues = values;
-    }
-
-    public void putBoolean(String key, boolean value) {
-        mValues.put(key, value);
-    }
-
-    public boolean getBoolean(String key, boolean defaultValue) {
-        Object value = mValues.get(key);
-        if (value instanceof Boolean) {
-            return (Boolean) value;
-        } else {
-            return defaultValue;
-        }
-    }
-
-    public void putInt(String key, int value) {
-        mValues.put(key, value);
-    }
-
-    public int getInt(String key, int defaultValue) {
-        Object value = mValues.get(key);
-        if (value instanceof Integer) {
-            return (Integer) value;
-        } else {
-            return defaultValue;
-        }
-    }
-
-    public void putIntArray(String key, int[] value) {
-        mValues.put(key, value);
-    }
-
-    public int[] getIntArray(String key) {
-        Object value = mValues.get(key);
-        if (value instanceof int[]) {
-            return (int[]) value;
-        } else {
-            return null;
-        }
-    }
-
-    public void putLong(String key, long value) {
-        mValues.put(key, value);
-    }
-
-    public long getLong(String key, long defaultValue) {
-        Object value = mValues.get(key);
-        if (value instanceof Long) {
-            return (Long) value;
-        } else {
-            return defaultValue;
-        }
-    }
-
-    public void putLongArray(String key, long[] value) {
-        mValues.put(key, value);
-    }
-
-    public long[] getLongArray(String key) {
-        Object value = mValues.get(key);
-        if (value instanceof long[]) {
-            return (long[]) value;
-        } else {
-            return null;
-        }
-    }
-
-    public void putDouble(String key, double value) {
-        mValues.put(key, value);
-    }
-
-    public double getDouble(String key, double defaultValue) {
-        Object value = mValues.get(key);
-        if (value instanceof Double) {
-            return (Double) value;
-        } else {
-            return defaultValue;
-        }
-    }
-
-    public void putDoubleArray(String key, double[] value) {
-        mValues.put(key, value);
-    }
-
-    public double[] getDoubleArray(String key) {
-        Object value = mValues.get(key);
-        if (value instanceof double[]) {
-            return (double[]) value;
-        } else {
-            return null;
-        }
-    }
-
-    public void putString(String key, String value) {
-        mValues.put(key, value);
-    }
-
-    public String getString(String key, String defaultValue) {
-        Object value = mValues.get(key);
-        if (value instanceof String) {
-            return (String) value;
-        } else {
-            return defaultValue;
-        }
-    }
-
-    public void putStringArray(String key, String[] value) {
-        mValues.put(key, value);
-    }
-
-    public String[] getStringArray(String key) {
-        Object value = mValues.get(key);
-        if (value instanceof String[]) {
-            return (String[]) value;
-        } else {
-            return null;
-        }
-    }
-
-    public void putPersistableBundleCompat(String key, PersistableBundleCompat value) {
-        mValues.put(key, value == null ? null : value.mValues);
-    }
-
-    @SuppressWarnings("unchecked")
-    public PersistableBundleCompat getPersistableBundleCompat(String key) {
-        Object value = mValues.get(key);
-        if (value instanceof Map) {
-            return new PersistableBundleCompat((Map<String, Object>) value);
-        } else {
-            return null;
-        }
-    }
-
-    public void clear() {
-        mValues.clear();
-    }
-
-    public boolean containsKey(String key) {
-        return mValues.containsKey(key);
-    }
-
-    public Object get(String key) {
-        return mValues.get(key);
-    }
-
-    public boolean isEmpty() {
-        return mValues.isEmpty();
-    }
-
-    public Set<String> keySet() {
-        return mValues.keySet();
-    }
-
-    public void putAll(PersistableBundleCompat bundle) {
-        mValues.putAll(bundle.mValues);
-    }
-
-    public void remove(String key) {
-        mValues.remove(key);
-    }
-
-    public int size() {
-        return mValues.size();
-    }
-
-    @NonNull
-    public String saveToXml() {
-        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
-        try {
-            XmlUtils.writeMapXml(mValues, outputStream);
-            return outputStream.toString(UTF_8);
-
-        } catch (XmlPullParserException | IOException e) {
-            CAT.e(e);
-            // shouldn't happen
-            return "";
-
-        } catch (Error e) {
-            // https://gist.github.com/vRallev/9444359f05259e4b6317 and other crashes on rooted devices
-            CAT.e(e);
-            return "";
-
-        } finally {
-            try {
-                outputStream.close();
-            } catch (IOException ignored) {
-            }
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    @NonNull
-    public static PersistableBundleCompat fromXml(@NonNull String xml) {
-        ByteArrayInputStream inputStream = null;
-        try {
-            inputStream = new ByteArrayInputStream(xml.getBytes(UTF_8));
-            HashMap<String, ?> map = XmlUtils.readMapXml(inputStream);
-            return new PersistableBundleCompat((Map<String, Object>) map);
-
-        } catch (XmlPullParserException | IOException e) {
-            CAT.e(e);
-            return new PersistableBundleCompat();
-
-        } catch (VerifyError e) {
-            // https://gist.github.com/vRallev/9444359f05259e4b6317
-            CAT.e(e);
-            return new PersistableBundleCompat();
-
-        } finally {
-            if (inputStream != null) {
-                try {
-                    inputStream.close();
-                } catch (IOException ignored) {
-                }
-            }
-        }
-    }
-}
diff --git a/library/src/main/java/com/evernote/android/job/util/support/XmlUtils.java b/library/src/main/java/com/evernote/android/job/util/support/XmlUtils.java
deleted file mode 100644
index 535a985..0000000
--- a/library/src/main/java/com/evernote/android/job/util/support/XmlUtils.java
+++ /dev/null
@@ -1,1533 +0,0 @@
-/*
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.evernote.android.job.util.support;
-
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.graphics.Bitmap.CompressFormat;
-import android.net.Uri;
-import android.util.Base64;
-import android.util.Xml;
-
-import org.xmlpull.v1.XmlPullParser;
-import org.xmlpull.v1.XmlPullParserException;
-import org.xmlpull.v1.XmlSerializer;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.ProtocolException;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-/*package*/ @SuppressWarnings({"unused", "StatementWithEmptyBody", "FinalStaticMethod", "WhileLoopReplaceableByForEach",
-        "ForLoopReplaceableByForEach", "FinalPrivateMethod", "AccessStaticViaInstance", "unchecked", "IfCanBeSwitch"})
-final class XmlUtils {
-
-    private XmlUtils() {
-        // no op
-    }
-
-    public static void skipCurrentTag(XmlPullParser parser)
-            throws XmlPullParserException, IOException {
-        int outerDepth = parser.getDepth();
-        int type;
-        while ((type=parser.next()) != XmlPullParser.END_DOCUMENT
-                && (type != XmlPullParser.END_TAG
-                || parser.getDepth() > outerDepth)) {
-        }
-    }
-
-    public static final int convertValueToList(CharSequence value, String[] options, int defaultValue) {
-        if (null != value) {
-            for (int i = 0; i < options.length; i++) {
-                if (value.equals(options[i]))
-                    return i;
-            }
-        }
-
-        return defaultValue;
-    }
-
-    public static final boolean convertValueToBoolean(CharSequence value, boolean defaultValue) {
-        boolean result = false;
-
-        if (null == value)
-            return defaultValue;
-
-        if (value.equals("1")
-                ||  value.equals("true")
-                ||  value.equals("TRUE"))
-            result = true;
-
-        return result;
-    }
-
-    public static final int convertValueToInt(CharSequence charSeq, int defaultValue) {
-        if (null == charSeq)
-            return defaultValue;
-
-        String nm = charSeq.toString();
-
-        // XXX This code is copied from Integer.decode() so we don't
-        // have to instantiate an Integer!
-
-        int value;
-        int sign = 1;
-        int index = 0;
-        int len = nm.length();
-        int base = 10;
-
-        if ('-' == nm.charAt(0)) {
-            sign = -1;
-            index++;
-        }
-
-        if ('0' == nm.charAt(index)) {
-            //  Quick check for a zero by itself
-            if (index == (len - 1))
-                return 0;
-
-            char    c = nm.charAt(index + 1);
-
-            if ('x' == c || 'X' == c) {
-                index += 2;
-                base = 16;
-            } else {
-                index++;
-                base = 8;
-            }
-        } else if ('#' == nm.charAt(index)) {
-            index++;
-            base = 16;
-        }
-
-        return Integer.parseInt(nm.substring(index), base) * sign;
-    }
-
-    public static int convertValueToUnsignedInt(String value, int defaultValue) {
-        if (null == value) {
-            return defaultValue;
-        }
-
-        return parseUnsignedIntAttribute(value);
-    }
-
-    public static int parseUnsignedIntAttribute(CharSequence charSeq) {
-        String  value = charSeq.toString();
-
-        long    bits;
-        int     index = 0;
-        int     len = value.length();
-        int     base = 10;
-
-        if ('0' == value.charAt(index)) {
-            //  Quick check for zero by itself
-            if (index == (len - 1))
-                return 0;
-
-            char    c = value.charAt(index + 1);
-
-            if ('x' == c || 'X' == c) {     //  check for hex
-                index += 2;
-                base = 16;
-            } else {                        //  check for octal
-                index++;
-                base = 8;
-            }
-        } else if ('#' == value.charAt(index)) {
-            index++;
-            base = 16;
-        }
-
-        return (int) Long.parseLong(value.substring(index), base);
-    }
-
-    /**
-     * Flatten a Map into an output stream as XML.  The map can later be
-     * read back with readMapXml().
-     *
-     * @param val The map to be flattened.
-     * @param out Where to write the XML data.
-     *
-     * @see #writeMapXml(Map, String, XmlSerializer)
-     * @see #writeListXml
-     * @see #writeValueXml
-     * @see #readMapXml
-     */
-    public static final void writeMapXml(Map val, OutputStream out)
-            throws XmlPullParserException, java.io.IOException {
-        XmlSerializer serializer = new FastXmlSerializer();
-        serializer.setOutput(out, "utf-8");
-        serializer.startDocument(null, true);
-        serializer.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output", true);
-        writeMapXml(val, null, serializer);
-        serializer.endDocument();
-    }
-
-    /**
-     * Flatten a List into an output stream as XML.  The list can later be
-     * read back with readListXml().
-     *
-     * @param val The list to be flattened.
-     * @param out Where to write the XML data.
-     *
-     * @see #writeListXml(List, String, XmlSerializer)
-     * @see #writeMapXml
-     * @see #writeValueXml
-     * @see #readListXml
-     */
-    public static final void writeListXml(List val, OutputStream out)
-            throws XmlPullParserException, java.io.IOException {
-        XmlSerializer serializer = Xml.newSerializer();
-        serializer.setOutput(out, "utf-8");
-        serializer.startDocument(null, true);
-        serializer.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output", true);
-        writeListXml(val, null, serializer);
-        serializer.endDocument();
-    }
-
-    /**
-     * Flatten a Map into an XmlSerializer.  The map can later be read back
-     * with readThisMapXml().
-     *
-     * @param val The map to be flattened.
-     * @param name Name attribute to include with this list's tag, or null for
-     *             none.
-     * @param out XmlSerializer to write the map into.
-     *
-     * @see #writeMapXml(Map, OutputStream)
-     * @see #writeListXml
-     * @see #writeValueXml
-     * @see #readMapXml
-     */
-    public static final void writeMapXml(Map val, String name, XmlSerializer out)
-            throws XmlPullParserException, java.io.IOException {
-        writeMapXml(val, name, out, null);
-    }
-
-    /**
-     * Flatten a Map into an XmlSerializer.  The map can later be read back
-     * with readThisMapXml().
-     *
-     * @param val The map to be flattened.
-     * @param name Name attribute to include with this list's tag, or null for
-     *             none.
-     * @param out XmlSerializer to write the map into.
-     * @param callback Method to call when an Object type is not recognized.
-     *
-     * @see #writeMapXml(Map, OutputStream)
-     * @see #writeListXml
-     * @see #writeValueXml
-     * @see #readMapXml
-     */
-    public static final void writeMapXml(Map val, String name, XmlSerializer out,
-                                         WriteMapCallback callback) throws XmlPullParserException, java.io.IOException {
-
-        if (val == null) {
-            out.startTag(null, "null");
-            out.endTag(null, "null");
-            return;
-        }
-
-        out.startTag(null, "map");
-        if (name != null) {
-            out.attribute(null, "name", name);
-        }
-
-        writeMapXml(val, out, callback);
-
-        out.endTag(null, "map");
-    }
-
-    /**
-     * Flatten a Map into an XmlSerializer.  The map can later be read back
-     * with readThisMapXml(). This method presumes that the start tag and
-     * name attribute have already been written and does not write an end tag.
-     *
-     * @param val The map to be flattened.
-     * @param out XmlSerializer to write the map into.
-     *
-     * @see #writeMapXml(Map, OutputStream)
-     * @see #writeListXml
-     * @see #writeValueXml
-     * @see #readMapXml
-     */
-    public static final void writeMapXml(Map val, XmlSerializer out,
-                                         WriteMapCallback callback) throws XmlPullParserException, java.io.IOException {
-        if (val == null) {
-            return;
-        }
-
-        Set s = val.entrySet();
-        Iterator i = s.iterator();
-
-        while (i.hasNext()) {
-            Map.Entry e = (Map.Entry) i.next();
-            writeValueXml(e.getValue(), (String) e.getKey(), out, callback);
-        }
-    }
-
-    /**
-     * Flatten a List into an XmlSerializer.  The list can later be read back
-     * with readThisListXml().
-     *
-     * @param val The list to be flattened.
-     * @param name Name attribute to include with this list's tag, or null for
-     *             none.
-     * @param out XmlSerializer to write the list into.
-     *
-     * @see #writeListXml(List, OutputStream)
-     * @see #writeMapXml
-     * @see #writeValueXml
-     * @see #readListXml
-     */
-    public static final void writeListXml(List val, String name, XmlSerializer out)
-            throws XmlPullParserException, java.io.IOException {
-        if (val == null) {
-            out.startTag(null, "null");
-            out.endTag(null, "null");
-            return;
-        }
-
-        out.startTag(null, "list");
-        if (name != null) {
-            out.attribute(null, "name", name);
-        }
-
-        int n = val.size();
-        int i=0;
-        while (i < n) {
-            writeValueXml(val.get(i), null, out);
-            i++;
-        }
-
-        out.endTag(null, "list");
-    }
-
-    public static final void writeSetXml(Set val, String name, XmlSerializer out)
-            throws XmlPullParserException, java.io.IOException {
-        if (val == null) {
-            out.startTag(null, "null");
-            out.endTag(null, "null");
-            return;
-        }
-
-        out.startTag(null, "set");
-        if (name != null) {
-            out.attribute(null, "name", name);
-        }
-
-        for (Object v : val) {
-            writeValueXml(v, null, out);
-        }
-
-        out.endTag(null, "set");
-    }
-
-    /**
-     * Flatten a byte[] into an XmlSerializer.  The list can later be read back
-     * with readThisByteArrayXml().
-     *
-     * @param val The byte array to be flattened.
-     * @param name Name attribute to include with this array's tag, or null for
-     *             none.
-     * @param out XmlSerializer to write the array into.
-     *
-     * @see #writeMapXml
-     * @see #writeValueXml
-     */
-    public static final void writeByteArrayXml(byte[] val, String name,
-                                               XmlSerializer out)
-            throws XmlPullParserException, java.io.IOException {
-
-        if (val == null) {
-            out.startTag(null, "null");
-            out.endTag(null, "null");
-            return;
-        }
-
-        out.startTag(null, "byte-array");
-        if (name != null) {
-            out.attribute(null, "name", name);
-        }
-
-        final int n = val.length;
-        out.attribute(null, "num", Integer.toString(n));
-
-        StringBuilder sb = new StringBuilder(val.length*2);
-        for (int i=0; i<n; i++) {
-            int b = val[i];
-            int h = b>>4;
-            sb.append(h >= 10 ? ('a'+h-10) : ('0'+h));
-            h = b&0xff;
-            sb.append(h >= 10 ? ('a'+h-10) : ('0'+h));
-        }
-
-        out.text(sb.toString());
-
-        out.endTag(null, "byte-array");
-    }
-
-    /**
-     * Flatten an int[] into an XmlSerializer.  The list can later be read back
-     * with readThisIntArrayXml().
-     *
-     * @param val The int array to be flattened.
-     * @param name Name attribute to include with this array's tag, or null for
-     *             none.
-     * @param out XmlSerializer to write the array into.
-     *
-     * @see #writeMapXml
-     * @see #writeValueXml
-     * @see #readThisIntArrayXml
-     */
-    public static final void writeIntArrayXml(int[] val, String name,
-                                              XmlSerializer out)
-            throws XmlPullParserException, java.io.IOException {
-
-        if (val == null) {
-            out.startTag(null, "null");
-            out.endTag(null, "null");
-            return;
-        }
-
-        out.startTag(null, "int-array");
-        if (name != null) {
-            out.attribute(null, "name", name);
-        }
-
-        final int n = val.length;
-        out.attribute(null, "num", Integer.toString(n));
-
-        for (int i=0; i<n; i++) {
-            out.startTag(null, "item");
-            out.attribute(null, "value", Integer.toString(val[i]));
-            out.endTag(null, "item");
-        }
-
-        out.endTag(null, "int-array");
-    }
-
-    /**
-     * Flatten a long[] into an XmlSerializer.  The list can later be read back
-     * with readThisLongArrayXml().
-     *
-     * @param val The long array to be flattened.
-     * @param name Name attribute to include with this array's tag, or null for
-     *             none.
-     * @param out XmlSerializer to write the array into.
-     *
-     * @see #writeMapXml
-     * @see #writeValueXml
-     * @see #readThisIntArrayXml
-     */
-    public static final void writeLongArrayXml(long[] val, String name, XmlSerializer out)
-            throws XmlPullParserException, java.io.IOException {
-
-        if (val == null) {
-            out.startTag(null, "null");
-            out.endTag(null, "null");
-            return;
-        }
-
-        out.startTag(null, "long-array");
-        if (name != null) {
-            out.attribute(null, "name", name);
-        }
-
-        final int n = val.length;
-        out.attribute(null, "num", Integer.toString(n));
-
-        for (int i=0; i<n; i++) {
-            out.startTag(null, "item");
-            out.attribute(null, "value", Long.toString(val[i]));
-            out.endTag(null, "item");
-        }
-
-        out.endTag(null, "long-array");
-    }
-
-    /**
-     * Flatten a double[] into an XmlSerializer.  The list can later be read back
-     * with readThisDoubleArrayXml().
-     *
-     * @param val The double array to be flattened.
-     * @param name Name attribute to include with this array's tag, or null for
-     *             none.
-     * @param out XmlSerializer to write the array into.
-     *
-     * @see #writeMapXml
-     * @see #writeValueXml
-     * @see #readThisIntArrayXml
-     */
-    public static final void writeDoubleArrayXml(double[] val, String name, XmlSerializer out)
-            throws XmlPullParserException, java.io.IOException {
-
-        if (val == null) {
-            out.startTag(null, "null");
-            out.endTag(null, "null");
-            return;
-        }
-
-        out.startTag(null, "double-array");
-        if (name != null) {
-            out.attribute(null, "name", name);
-        }
-
-        final int n = val.length;
-        out.attribute(null, "num", Integer.toString(n));
-
-        for (int i=0; i<n; i++) {
-            out.startTag(null, "item");
-            out.attribute(null, "value", Double.toString(val[i]));
-            out.endTag(null, "item");
-        }
-
-        out.endTag(null, "double-array");
-    }
-
-    /**
-     * Flatten a String[] into an XmlSerializer.  The list can later be read back
-     * with readThisStringArrayXml().
-     *
-     * @param val The long array to be flattened.
-     * @param name Name attribute to include with this array's tag, or null for
-     *             none.
-     * @param out XmlSerializer to write the array into.
-     *
-     * @see #writeMapXml
-     * @see #writeValueXml
-     * @see #readThisIntArrayXml
-     */
-    public static final void writeStringArrayXml(String[] val, String name, XmlSerializer out)
-            throws XmlPullParserException, java.io.IOException {
-
-        if (val == null) {
-            out.startTag(null, "null");
-            out.endTag(null, "null");
-            return;
-        }
-
-        out.startTag(null, "string-array");
-        if (name != null) {
-            out.attribute(null, "name", name);
-        }
-
-        final int n = val.length;
-        out.attribute(null, "num", Integer.toString(n));
-
-        for (int i=0; i<n; i++) {
-            if (val[i] == null) {
-                out.startTag(null, "null");
-                out.endTag(null, "null");
-            } else {
-                out.startTag(null, "item");
-                out.attribute(null, "value", val[i]);
-                out.endTag(null, "item");
-            }
-        }
-
-        out.endTag(null, "string-array");
-    }
-
-    /**
-     * Flatten an object's value into an XmlSerializer.  The value can later
-     * be read back with readThisValueXml().
-     *
-     * Currently supported value types are: null, String, Integer, Long,
-     * Float, Double Boolean, Map, List.
-     *
-     * @param v The object to be flattened.
-     * @param name Name attribute to include with this value's tag, or null
-     *             for none.
-     * @param out XmlSerializer to write the object into.
-     *
-     * @see #writeMapXml
-     * @see #writeListXml
-     * @see #readValueXml
-     */
-    public static final void writeValueXml(Object v, String name, XmlSerializer out)
-            throws XmlPullParserException, java.io.IOException {
-        writeValueXml(v, name, out, null);
-    }
-
-    /**
-     * Flatten an object's value into an XmlSerializer.  The value can later
-     * be read back with readThisValueXml().
-     *
-     * Currently supported value types are: null, String, Integer, Long,
-     * Float, Double Boolean, Map, List.
-     *
-     * @param v The object to be flattened.
-     * @param name Name attribute to include with this value's tag, or null
-     *             for none.
-     * @param out XmlSerializer to write the object into.
-     * @param callback Handler for Object types not recognized.
-     *
-     * @see #writeMapXml
-     * @see #writeListXml
-     * @see #readValueXml
-     */
-    private static final void writeValueXml(Object v, String name, XmlSerializer out,
-                                            WriteMapCallback callback)  throws XmlPullParserException, java.io.IOException {
-        String typeStr;
-        if (v == null) {
-            out.startTag(null, "null");
-            if (name != null) {
-                out.attribute(null, "name", name);
-            }
-            out.endTag(null, "null");
-            return;
-        } else if (v instanceof String) {
-            out.startTag(null, "string");
-            if (name != null) {
-                out.attribute(null, "name", name);
-            }
-            out.text(v.toString());
-            out.endTag(null, "string");
-            return;
-        } else if (v instanceof Integer) {
-            typeStr = "int";
-        } else if (v instanceof Long) {
-            typeStr = "long";
-        } else if (v instanceof Float) {
-            typeStr = "float";
-        } else if (v instanceof Double) {
-            typeStr = "double";
-        } else if (v instanceof Boolean) {
-            typeStr = "boolean";
-        } else if (v instanceof byte[]) {
-            writeByteArrayXml((byte[]) v, name, out);
-            return;
-        } else if (v instanceof int[]) {
-            writeIntArrayXml((int[]) v, name, out);
-            return;
-        } else if (v instanceof long[]) {
-            writeLongArrayXml((long[]) v, name, out);
-            return;
-        } else if (v instanceof double[]) {
-            writeDoubleArrayXml((double[]) v, name, out);
-            return;
-        } else if (v instanceof String[]) {
-            writeStringArrayXml((String[]) v, name, out);
-            return;
-        } else if (v instanceof Map) {
-            writeMapXml((Map) v, name, out);
-            return;
-        } else if (v instanceof List) {
-            writeListXml((List) v, name, out);
-            return;
-        } else if (v instanceof Set) {
-            writeSetXml((Set) v, name, out);
-            return;
-        } else if (v instanceof CharSequence) {
-            // XXX This is to allow us to at least write something if
-            // we encounter styled text...  but it means we will drop all
-            // of the styling information. :(
-            out.startTag(null, "string");
-            if (name != null) {
-                out.attribute(null, "name", name);
-            }
-            out.text(v.toString());
-            out.endTag(null, "string");
-            return;
-        } else if (callback != null) {
-            callback.writeUnknownObject(v, name, out);
-            return;
-        } else {
-            throw new RuntimeException("writeValueXml: unable to write value " + v);
-        }
-
-        out.startTag(null, typeStr);
-        if (name != null) {
-            out.attribute(null, "name", name);
-        }
-        out.attribute(null, "value", v.toString());
-        out.endTag(null, typeStr);
-    }
-
-    /**
-     * Read a HashMap from an InputStream containing XML.  The stream can
-     * previously have been written by writeMapXml().
-     *
-     * @param in The InputStream from which to read.
-     *
-     * @return HashMap The resulting map.
-     *
-     * @see #readListXml
-     * @see #readValueXml
-     * @see #readThisMapXml
-     * #see #writeMapXml
-     */
-    @SuppressWarnings("unchecked")
-    public static final HashMap<String, ?> readMapXml(InputStream in)
-            throws XmlPullParserException, java.io.IOException {
-        XmlPullParser   parser = Xml.newPullParser();
-        parser.setInput(in, null);
-        return (HashMap<String, ?>) readValueXml(parser, new String[1]);
-    }
-
-    /**
-     * Read an ArrayList from an InputStream containing XML.  The stream can
-     * previously have been written by writeListXml().
-     *
-     * @param in The InputStream from which to read.
-     *
-     * @return ArrayList The resulting list.
-     *
-     * @see #readMapXml
-     * @see #readValueXml
-     * @see #readThisListXml
-     * @see #writeListXml
-     */
-    public static final ArrayList readListXml(InputStream in)
-            throws XmlPullParserException, java.io.IOException {
-        XmlPullParser   parser = Xml.newPullParser();
-        parser.setInput(in, null);
-        return (ArrayList) readValueXml(parser, new String[1]);
-    }
-
-
-    /**
-     * Read a HashSet from an InputStream containing XML. The stream can
-     * previously have been written by writeSetXml().
-     *
-     * @param in The InputStream from which to read.
-     *
-     * @return HashSet The resulting set.
-     *
-     * @throws XmlPullParserException
-     * @throws java.io.IOException
-     *
-     * @see #readValueXml
-     * @see #readThisSetXml
-     * @see #writeSetXml
-     */
-    public static final HashSet readSetXml(InputStream in)
-            throws XmlPullParserException, java.io.IOException {
-        XmlPullParser parser = Xml.newPullParser();
-        parser.setInput(in, null);
-        return (HashSet) readValueXml(parser, new String[1]);
-    }
-
-    /**
-     * Read a HashMap object from an XmlPullParser.  The XML data could
-     * previously have been generated by writeMapXml().  The XmlPullParser
-     * must be positioned <em>after</em> the tag that begins the map.
-     *
-     * @param parser The XmlPullParser from which to read the map data.
-     * @param endTag Name of the tag that will end the map, usually "map".
-     * @param name An array of one string, used to return the name attribute
-     *             of the map's tag.
-     *
-     * @return HashMap The newly generated map.
-     *
-     * @see #readMapXml
-     */
-    public static final HashMap<String, ?> readThisMapXml(XmlPullParser parser, String endTag,
-                                                          String[] name) throws XmlPullParserException, java.io.IOException {
-        return readThisMapXml(parser, endTag, name, null);
-    }
-
-    /**
-     * Read a HashMap object from an XmlPullParser.  The XML data could
-     * previously have been generated by writeMapXml().  The XmlPullParser
-     * must be positioned <em>after</em> the tag that begins the map.
-     *
-     * @param parser The XmlPullParser from which to read the map data.
-     * @param endTag Name of the tag that will end the map, usually "map".
-     * @param name An array of one string, used to return the name attribute
-     *             of the map's tag.
-     *
-     * @return HashMap The newly generated map.
-     *
-     * @see #readMapXml
-     */
-    public static final HashMap<String, ?> readThisMapXml(XmlPullParser parser, String endTag,
-                                                          String[] name, ReadMapCallback callback)
-            throws XmlPullParserException, java.io.IOException {
-        HashMap<String, Object> map = new HashMap<>();
-
-        int eventType = parser.getEventType();
-        do {
-            if (eventType == parser.START_TAG) {
-                Object val = readThisValueXml(parser, name, callback);
-                map.put(name[0], val);
-            } else if (eventType == parser.END_TAG) {
-                if (parser.getName().equals(endTag)) {
-                    return map;
-                }
-                throw new XmlPullParserException(
-                        "Expected " + endTag + " end tag at: " + parser.getName());
-            }
-            eventType = parser.next();
-        } while (eventType != parser.END_DOCUMENT);
-
-        throw new XmlPullParserException(
-                "Document ended before " + endTag + " end tag");
-    }
-
-    /**
-     * Read an ArrayList object from an XmlPullParser.  The XML data could
-     * previously have been generated by writeListXml().  The XmlPullParser
-     * must be positioned <em>after</em> the tag that begins the list.
-     *
-     * @param parser The XmlPullParser from which to read the list data.
-     * @param endTag Name of the tag that will end the list, usually "list".
-     * @param name An array of one string, used to return the name attribute
-     *             of the list's tag.
-     *
-     * @return HashMap The newly generated list.
-     *
-     * @see #readListXml
-     */
-    public static final ArrayList readThisListXml(XmlPullParser parser, String endTag,
-                                                  String[] name) throws XmlPullParserException, java.io.IOException {
-        return readThisListXml(parser, endTag, name, null);
-    }
-
-    /**
-     * Read an ArrayList object from an XmlPullParser.  The XML data could
-     * previously have been generated by writeListXml().  The XmlPullParser
-     * must be positioned <em>after</em> the tag that begins the list.
-     *
-     * @param parser The XmlPullParser from which to read the list data.
-     * @param endTag Name of the tag that will end the list, usually "list".
-     * @param name An array of one string, used to return the name attribute
-     *             of the list's tag.
-     *
-     * @return HashMap The newly generated list.
-     *
-     * @see #readListXml
-     */
-    private static final ArrayList readThisListXml(XmlPullParser parser, String endTag,
-                                                   String[] name, ReadMapCallback callback)
-            throws XmlPullParserException, java.io.IOException {
-        ArrayList list = new ArrayList();
-
-        int eventType = parser.getEventType();
-        do {
-            if (eventType == parser.START_TAG) {
-                Object val = readThisValueXml(parser, name, callback);
-                list.add(val);
-                //System.out.println("Adding to list: " + val);
-            } else if (eventType == parser.END_TAG) {
-                if (parser.getName().equals(endTag)) {
-                    return list;
-                }
-                throw new XmlPullParserException(
-                        "Expected " + endTag + " end tag at: " + parser.getName());
-            }
-            eventType = parser.next();
-        } while (eventType != parser.END_DOCUMENT);
-
-        throw new XmlPullParserException(
-                "Document ended before " + endTag + " end tag");
-    }
-
-    /**
-     * Read a HashSet object from an XmlPullParser. The XML data could previously
-     * have been generated by writeSetXml(). The XmlPullParser must be positioned
-     * <em>after</em> the tag that begins the set.
-     *
-     * @param parser The XmlPullParser from which to read the set data.
-     * @param endTag Name of the tag that will end the set, usually "set".
-     * @param name An array of one string, used to return the name attribute
-     *             of the set's tag.
-     *
-     * @return HashSet The newly generated set.
-     *
-     * @throws XmlPullParserException
-     * @throws java.io.IOException
-     *
-     * @see #readSetXml
-     */
-    public static final HashSet readThisSetXml(XmlPullParser parser, String endTag, String[] name)
-            throws XmlPullParserException, java.io.IOException {
-        return readThisSetXml(parser, endTag, name, null);
-    }
-
-    /**
-     * Read a HashSet object from an XmlPullParser. The XML data could previously
-     * have been generated by writeSetXml(). The XmlPullParser must be positioned
-     * <em>after</em> the tag that begins the set.
-     *
-     * @param parser The XmlPullParser from which to read the set data.
-     * @param endTag Name of the tag that will end the set, usually "set".
-     * @param name An array of one string, used to return the name attribute
-     *             of the set's tag.
-     *
-     * @return HashSet The newly generated set.
-     *
-     * @throws XmlPullParserException
-     * @throws java.io.IOException
-     *
-     * @see #readSetXml
-     */
-    private static final HashSet readThisSetXml(XmlPullParser parser, String endTag, String[] name,
-                                                ReadMapCallback callback) throws XmlPullParserException, java.io.IOException {
-        HashSet set = new HashSet();
-
-        int eventType = parser.getEventType();
-        do {
-            if (eventType == parser.START_TAG) {
-                Object val = readThisValueXml(parser, name, callback);
-                set.add(val);
-                //System.out.println("Adding to set: " + val);
-            } else if (eventType == parser.END_TAG) {
-                if (parser.getName().equals(endTag)) {
-                    return set;
-                }
-                throw new XmlPullParserException(
-                        "Expected " + endTag + " end tag at: " + parser.getName());
-            }
-            eventType = parser.next();
-        } while (eventType != parser.END_DOCUMENT);
-
-        throw new XmlPullParserException(
-                "Document ended before " + endTag + " end tag");
-    }
-
-    /**
-     * Read an int[] object from an XmlPullParser.  The XML data could
-     * previously have been generated by writeIntArrayXml().  The XmlPullParser
-     * must be positioned <em>after</em> the tag that begins the list.
-     *
-     * @param parser The XmlPullParser from which to read the list data.
-     * @param endTag Name of the tag that will end the list, usually "list".
-     * @param name An array of one string, used to return the name attribute
-     *             of the list's tag.
-     *
-     * @return Returns a newly generated int[].
-     *
-     * @see #readListXml
-     */
-    public static final int[] readThisIntArrayXml(XmlPullParser parser,
-                                                  String endTag, String[] name)
-            throws XmlPullParserException, java.io.IOException {
-
-        int num;
-        try {
-            num = Integer.parseInt(parser.getAttributeValue(null, "num"));
-        } catch (NullPointerException e) {
-            throw new XmlPullParserException(
-                    "Need num attribute in byte-array");
-        } catch (NumberFormatException e) {
-            throw new XmlPullParserException(
-                    "Not a number in num attribute in byte-array");
-        }
-        parser.next();
-
-        int[] array = new int[num];
-        int i = 0;
-
-        int eventType = parser.getEventType();
-        do {
-            if (eventType == parser.START_TAG) {
-                if (parser.getName().equals("item")) {
-                    try {
-                        array[i] = Integer.parseInt(
-                                parser.getAttributeValue(null, "value"));
-                    } catch (NullPointerException e) {
-                        throw new XmlPullParserException(
-                                "Need value attribute in item");
-                    } catch (NumberFormatException e) {
-                        throw new XmlPullParserException(
-                                "Not a number in value attribute in item");
-                    }
-                } else {
-                    throw new XmlPullParserException(
-                            "Expected item tag at: " + parser.getName());
-                }
-            } else if (eventType == parser.END_TAG) {
-                if (parser.getName().equals(endTag)) {
-                    return array;
-                } else if (parser.getName().equals("item")) {
-                    i++;
-                } else {
-                    throw new XmlPullParserException(
-                            "Expected " + endTag + " end tag at: "
-                                    + parser.getName());
-                }
-            }
-            eventType = parser.next();
-        } while (eventType != parser.END_DOCUMENT);
-
-        throw new XmlPullParserException(
-                "Document ended before " + endTag + " end tag");
-    }
-
-    /**
-     * Read a long[] object from an XmlPullParser.  The XML data could
-     * previously have been generated by writeLongArrayXml().  The XmlPullParser
-     * must be positioned <em>after</em> the tag that begins the list.
-     *
-     * @param parser The XmlPullParser from which to read the list data.
-     * @param endTag Name of the tag that will end the list, usually "list".
-     * @param name An array of one string, used to return the name attribute
-     *             of the list's tag.
-     *
-     * @return Returns a newly generated long[].
-     *
-     * @see #readListXml
-     */
-    public static final long[] readThisLongArrayXml(XmlPullParser parser,
-                                                    String endTag, String[] name)
-            throws XmlPullParserException, java.io.IOException {
-
-        int num;
-        try {
-            num = Integer.parseInt(parser.getAttributeValue(null, "num"));
-        } catch (NullPointerException e) {
-            throw new XmlPullParserException("Need num attribute in long-array");
-        } catch (NumberFormatException e) {
-            throw new XmlPullParserException("Not a number in num attribute in long-array");
-        }
-        parser.next();
-
-        long[] array = new long[num];
-        int i = 0;
-
-        int eventType = parser.getEventType();
-        do {
-            if (eventType == parser.START_TAG) {
-                if (parser.getName().equals("item")) {
-                    try {
-                        array[i] = Long.parseLong(parser.getAttributeValue(null, "value"));
-                    } catch (NullPointerException e) {
-                        throw new XmlPullParserException("Need value attribute in item");
-                    } catch (NumberFormatException e) {
-                        throw new XmlPullParserException("Not a number in value attribute in item");
-                    }
-                } else {
-                    throw new XmlPullParserException("Expected item tag at: " + parser.getName());
-                }
-            } else if (eventType == parser.END_TAG) {
-                if (parser.getName().equals(endTag)) {
-                    return array;
-                } else if (parser.getName().equals("item")) {
-                    i++;
-                } else {
-                    throw new XmlPullParserException("Expected " + endTag + " end tag at: " + parser.getName());
-                }
-            }
-            eventType = parser.next();
-        } while (eventType != parser.END_DOCUMENT);
-
-        throw new XmlPullParserException("Document ended before " + endTag + " end tag");
-    }
-
-    /**
-     * Read a double[] object from an XmlPullParser.  The XML data could
-     * previously have been generated by writeDoubleArrayXml().  The XmlPullParser
-     * must be positioned <em>after</em> the tag that begins the list.
-     *
-     * @param parser The XmlPullParser from which to read the list data.
-     * @param endTag Name of the tag that will end the list, usually "double-array".
-     * @param name An array of one string, used to return the name attribute
-     *             of the list's tag.
-     *
-     * @return Returns a newly generated double[].
-     *
-     * @see #readListXml
-     */
-    public static final double[] readThisDoubleArrayXml(XmlPullParser parser, String endTag,
-                                                        String[] name) throws XmlPullParserException, java.io.IOException {
-
-        int num;
-        try {
-            num = Integer.parseInt(parser.getAttributeValue(null, "num"));
-        } catch (NullPointerException e) {
-            throw new XmlPullParserException("Need num attribute in double-array");
-        } catch (NumberFormatException e) {
-            throw new XmlPullParserException("Not a number in num attribute in double-array");
-        }
-        parser.next();
-
-        double[] array = new double[num];
-        int i = 0;
-
-        int eventType = parser.getEventType();
-        do {
-            if (eventType == parser.START_TAG) {
-                if (parser.getName().equals("item")) {
-                    try {
-                        array[i] = Double.parseDouble(parser.getAttributeValue(null, "value"));
-                    } catch (NullPointerException e) {
-                        throw new XmlPullParserException("Need value attribute in item");
-                    } catch (NumberFormatException e) {
-                        throw new XmlPullParserException("Not a number in value attribute in item");
-                    }
-                } else {
-                    throw new XmlPullParserException("Expected item tag at: " + parser.getName());
-                }
-            } else if (eventType == parser.END_TAG) {
-                if (parser.getName().equals(endTag)) {
-                    return array;
-                } else if (parser.getName().equals("item")) {
-                    i++;
-                } else {
-                    throw new XmlPullParserException("Expected " + endTag + " end tag at: " + parser.getName());
-                }
-            }
-            eventType = parser.next();
-        } while (eventType != parser.END_DOCUMENT);
-
-        throw new XmlPullParserException("Document ended before " + endTag + " end tag");
-    }
-
-    /**
-     * Read a String[] object from an XmlPullParser.  The XML data could
-     * previously have been generated by writeStringArrayXml().  The XmlPullParser
-     * must be positioned <em>after</em> the tag that begins the list.
-     *
-     * @param parser The XmlPullParser from which to read the list data.
-     * @param endTag Name of the tag that will end the list, usually "string-array".
-     * @param name An array of one string, used to return the name attribute
-     *             of the list's tag.
-     *
-     * @return Returns a newly generated String[].
-     *
-     * @see #readListXml
-     */
-    public static final String[] readThisStringArrayXml(XmlPullParser parser, String endTag,
-                                                        String[] name) throws XmlPullParserException, java.io.IOException {
-
-        int num;
-        try {
-            num = Integer.parseInt(parser.getAttributeValue(null, "num"));
-        } catch (NullPointerException e) {
-            throw new XmlPullParserException("Need num attribute in string-array");
-        } catch (NumberFormatException e) {
-            throw new XmlPullParserException("Not a number in num attribute in string-array");
-        }
-        parser.next();
-
-        String[] array = new String[num];
-        int i = 0;
-
-        int eventType = parser.getEventType();
-        do {
-            if (eventType == parser.START_TAG) {
-                if (parser.getName().equals("item")) {
-                    try {
-                        array[i] = parser.getAttributeValue(null, "value");
-                    } catch (NullPointerException e) {
-                        throw new XmlPullParserException("Need value attribute in item");
-                    } catch (NumberFormatException e) {
-                        throw new XmlPullParserException("Not a number in value attribute in item");
-                    }
-                } else if (parser.getName().equals("null")) {
-                    array[i] = null;
-                } else {
-                    throw new XmlPullParserException("Expected item tag at: " + parser.getName());
-                }
-            } else if (eventType == parser.END_TAG) {
-                if (parser.getName().equals(endTag)) {
-                    return array;
-                } else if (parser.getName().equals("item") || parser.getName().equals("null")) {
-                    i++;
-                } else {
-                    throw new XmlPullParserException("Expected " + endTag + " end tag at: " + parser.getName());
-                }
-            }
-            eventType = parser.next();
-        } while (eventType != parser.END_DOCUMENT);
-
-        throw new XmlPullParserException("Document ended before " + endTag + " end tag");
-    }
-
-    /**
-     * Read a flattened object from an XmlPullParser.  The XML data could
-     * previously have been written with writeMapXml(), writeListXml(), or
-     * writeValueXml().  The XmlPullParser must be positioned <em>at</em> the
-     * tag that defines the value.
-     *
-     * @param parser The XmlPullParser from which to read the object.
-     * @param name An array of one string, used to return the name attribute
-     *             of the value's tag.
-     *
-     * @return Object The newly generated value object.
-     *
-     * @see #readMapXml
-     * @see #readListXml
-     * @see #writeValueXml
-     */
-    public static final Object readValueXml(XmlPullParser parser, String[] name)
-            throws XmlPullParserException, java.io.IOException {
-        int eventType = parser.getEventType();
-        do {
-            if (eventType == parser.START_TAG) {
-                return readThisValueXml(parser, name, null);
-            } else if (eventType == parser.END_TAG) {
-                throw new XmlPullParserException(
-                        "Unexpected end tag at: " + parser.getName());
-            } else if (eventType == parser.TEXT) {
-                throw new XmlPullParserException(
-                        "Unexpected text: " + parser.getText());
-            }
-            eventType = parser.next();
-        } while (eventType != parser.END_DOCUMENT);
-
-        throw new XmlPullParserException(
-                "Unexpected end of document");
-    }
-
-    private static final Object readThisValueXml(XmlPullParser parser, String[] name,
-                                                 ReadMapCallback callback)  throws XmlPullParserException, java.io.IOException {
-        final String valueName = parser.getAttributeValue(null, "name");
-        final String tagName = parser.getName();
-
-        //System.out.println("Reading this value tag: " + tagName + ", name=" + valueName);
-
-        Object res;
-
-        if (tagName.equals("null")) {
-            res = null;
-        } else if (tagName.equals("string")) {
-            String value = "";
-            int eventType;
-            while ((eventType = parser.next()) != parser.END_DOCUMENT) {
-                if (eventType == parser.END_TAG) {
-                    if (parser.getName().equals("string")) {
-                        name[0] = valueName;
-                        //System.out.println("Returning value for " + valueName + ": " + value);
-                        return value;
-                    }
-                    throw new XmlPullParserException(
-                            "Unexpected end tag in <string>: " + parser.getName());
-                } else if (eventType == parser.TEXT) {
-                    value += parser.getText();
-                } else if (eventType == parser.START_TAG) {
-                    throw new XmlPullParserException(
-                            "Unexpected start tag in <string>: " + parser.getName());
-                }
-            }
-            throw new XmlPullParserException(
-                    "Unexpected end of document in <string>");
-        } else if ((res = readThisPrimitiveValueXml(parser, tagName)) != null) {
-            // all work already done by readThisPrimitiveValueXml
-        } else if (tagName.equals("int-array")) {
-            res = readThisIntArrayXml(parser, "int-array", name);
-            name[0] = valueName;
-            //System.out.println("Returning value for " + valueName + ": " + res);
-            return res;
-        } else if (tagName.equals("long-array")) {
-            res = readThisLongArrayXml(parser, "long-array", name);
-            name[0] = valueName;
-            //System.out.println("Returning value for " + valueName + ": " + res);
-            return res;
-        } else if (tagName.equals("double-array")) {
-            res = readThisDoubleArrayXml(parser, "double-array", name);
-            name[0] = valueName;
-            //System.out.println("Returning value for " + valueName + ": " + res);
-            return res;
-        } else if (tagName.equals("string-array")) {
-            res = readThisStringArrayXml(parser, "string-array", name);
-            name[0] = valueName;
-            //System.out.println("Returning value for " + valueName + ": " + res);
-            return res;
-        } else if (tagName.equals("map")) {
-            parser.next();
-            res = readThisMapXml(parser, "map", name);
-            name[0] = valueName;
-            //System.out.println("Returning value for " + valueName + ": " + res);
-            return res;
-        } else if (tagName.equals("list")) {
-            parser.next();
-            res = readThisListXml(parser, "list", name);
-            name[0] = valueName;
-            //System.out.println("Returning value for " + valueName + ": " + res);
-            return res;
-        } else if (tagName.equals("set")) {
-            parser.next();
-            res = readThisSetXml(parser, "set", name);
-            name[0] = valueName;
-            //System.out.println("Returning value for " + valueName + ": " + res);
-            return res;
-        } else if (callback != null) {
-            res = callback.readThisUnknownObjectXml(parser, tagName);
-            name[0] = valueName;
-            return res;
-        } else {
-            throw new XmlPullParserException("Unknown tag: " + tagName);
-        }
-
-        // Skip through to end tag.
-        int eventType;
-        while ((eventType = parser.next()) != parser.END_DOCUMENT) {
-            if (eventType == parser.END_TAG) {
-                if (parser.getName().equals(tagName)) {
-                    name[0] = valueName;
-                    //System.out.println("Returning value for " + valueName + ": " + res);
-                    return res;
-                }
-                throw new XmlPullParserException(
-                        "Unexpected end tag in <" + tagName + ">: " + parser.getName());
-            } else if (eventType == parser.TEXT) {
-                throw new XmlPullParserException(
-                        "Unexpected text in <" + tagName + ">: " + parser.getName());
-            } else if (eventType == parser.START_TAG) {
-                throw new XmlPullParserException(
-                        "Unexpected start tag in <" + tagName + ">: " + parser.getName());
-            }
-        }
-        throw new XmlPullParserException(
-                "Unexpected end of document in <" + tagName + ">");
-    }
-
-    private static final Object readThisPrimitiveValueXml(XmlPullParser parser, String tagName)
-            throws XmlPullParserException, java.io.IOException {
-        try {
-            if (tagName.equals("int")) {
-                return Integer.parseInt(parser.getAttributeValue(null, "value"));
-            } else if (tagName.equals("long")) {
-                return Long.valueOf(parser.getAttributeValue(null, "value"));
-            } else if (tagName.equals("float")) {
-                return Float.valueOf(parser.getAttributeValue(null, "value"));
-            } else if (tagName.equals("double")) {
-                return Double.valueOf(parser.getAttributeValue(null, "value"));
-            } else if (tagName.equals("boolean")) {
-                return Boolean.valueOf(parser.getAttributeValue(null, "value"));
-            } else {
-                return null;
-            }
-        } catch (NullPointerException e) {
-            throw new XmlPullParserException("Need value attribute in <" + tagName + ">");
-        } catch (NumberFormatException e) {
-            throw new XmlPullParserException(
-                    "Not a number in value attribute in <" + tagName + ">");
-        }
-    }
-
-    public static final void beginDocument(XmlPullParser parser, String firstElementName) throws XmlPullParserException, IOException
-    {
-        int type;
-        while ((type=parser.next()) != parser.START_TAG
-                && type != parser.END_DOCUMENT) {
-        }
-
-        if (type != parser.START_TAG) {
-            throw new XmlPullParserException("No start tag found");
-        }
-
-        if (!parser.getName().equals(firstElementName)) {
-            throw new XmlPullParserException("Unexpected start tag: found " + parser.getName() + ", expected " + firstElementName);
-        }
-    }
-
-    public static final void nextElement(XmlPullParser parser) throws XmlPullParserException, IOException
-    {
-        int type;
-        while ((type=parser.next()) != parser.START_TAG
-                && type != parser.END_DOCUMENT) {
-        }
-    }
-
-    public static boolean nextElementWithin(XmlPullParser parser, int outerDepth)
-            throws IOException, XmlPullParserException {
-        for (;;) {
-            int type = parser.next();
-            if (type == XmlPullParser.END_DOCUMENT
-                    || (type == XmlPullParser.END_TAG && parser.getDepth() == outerDepth)) {
-                return false;
-            }
-            if (type == XmlPullParser.START_TAG
-                    && parser.getDepth() == outerDepth + 1) {
-                return true;
-            }
-        }
-    }
-
-    public static int readIntAttribute(XmlPullParser in, String name, int defaultValue) {
-        final String value = in.getAttributeValue(null, name);
-        try {
-            return Integer.parseInt(value);
-        } catch (NumberFormatException e) {
-            return defaultValue;
-        }
-    }
-
-    public static int readIntAttribute(XmlPullParser in, String name) throws IOException {
-        final String value = in.getAttributeValue(null, name);
-        try {
-            return Integer.parseInt(value);
-        } catch (NumberFormatException e) {
-            throw new ProtocolException("problem parsing " + name + "=" + value + " as int");
-        }
-    }
-
-    public static void writeIntAttribute(XmlSerializer out, String name, int value)
-            throws IOException {
-        out.attribute(null, name, Integer.toString(value));
-    }
-
-    public static long readLongAttribute(XmlPullParser in, String name, long defaultValue) {
-        final String value = in.getAttributeValue(null, name);
-        try {
-            return Long.parseLong(value);
-        } catch (NumberFormatException e) {
-            return defaultValue;
-        }
-    }
-
-    public static long readLongAttribute(XmlPullParser in, String name) throws IOException {
-        final String value = in.getAttributeValue(null, name);
-        try {
-            return Long.parseLong(value);
-        } catch (NumberFormatException e) {
-            throw new ProtocolException("problem parsing " + name + "=" + value + " as long");
-        }
-    }
-
-    public static void writeLongAttribute(XmlSerializer out, String name, long value)
-            throws IOException {
-        out.attribute(null, name, Long.toString(value));
-    }
-
-    public static float readFloatAttribute(XmlPullParser in, String name) throws IOException {
-        final String value = in.getAttributeValue(null, name);
-        try {
-            return Float.parseFloat(value);
-        } catch (NumberFormatException e) {
-            throw new ProtocolException("problem parsing " + name + "=" + value + " as long");
-        }
-    }
-
-    public static void writeFloatAttribute(XmlSerializer out, String name, float value)
-            throws IOException {
-        out.attribute(null, name, Float.toString(value));
-    }
-
-    public static boolean readBooleanAttribute(XmlPullParser in, String name) {
-        final String value = in.getAttributeValue(null, name);
-        return Boolean.parseBoolean(value);
-    }
-
-    public static boolean readBooleanAttribute(XmlPullParser in, String name,
-                                               boolean defaultValue) {
-        final String value = in.getAttributeValue(null, name);
-        if (value == null) {
-            return defaultValue;
-        } else {
-            return Boolean.parseBoolean(value);
-        }
-    }
-
-    public static void writeBooleanAttribute(XmlSerializer out, String name, boolean value)
-            throws IOException {
-        out.attribute(null, name, Boolean.toString(value));
-    }
-
-    public static Uri readUriAttribute(XmlPullParser in, String name) {
-        final String value = in.getAttributeValue(null, name);
-        return (value != null) ? Uri.parse(value) : null;
-    }
-
-    public static void writeUriAttribute(XmlSerializer out, String name, Uri value)
-            throws IOException {
-        if (value != null) {
-            out.attribute(null, name, value.toString());
-        }
-    }
-
-    public static String readStringAttribute(XmlPullParser in, String name) {
-        return in.getAttributeValue(null, name);
-    }
-
-    public static void writeStringAttribute(XmlSerializer out, String name, String value)
-            throws IOException {
-        if (value != null) {
-            out.attribute(null, name, value);
-        }
-    }
-
-    public static byte[] readByteArrayAttribute(XmlPullParser in, String name) {
-        final String value = in.getAttributeValue(null, name);
-        if (value != null) {
-            return Base64.decode(value, Base64.DEFAULT);
-        } else {
-            return null;
-        }
-    }
-
-    public static void writeByteArrayAttribute(XmlSerializer out, String name, byte[] value)
-            throws IOException {
-        if (value != null) {
-            out.attribute(null, name, Base64.encodeToString(value, Base64.DEFAULT));
-        }
-    }
-
-    public static Bitmap readBitmapAttribute(XmlPullParser in, String name) {
-        final byte[] value = readByteArrayAttribute(in, name);
-        if (value != null) {
-            return BitmapFactory.decodeByteArray(value, 0, value.length);
-        } else {
-            return null;
-        }
-    }
-
-    @Deprecated
-    public static void writeBitmapAttribute(XmlSerializer out, String name, Bitmap value)
-            throws IOException {
-        if (value != null) {
-            final ByteArrayOutputStream os = new ByteArrayOutputStream();
-            value.compress(CompressFormat.PNG, 90, os);
-            writeByteArrayAttribute(out, name, os.toByteArray());
-        }
-    }
-
-    @SuppressWarnings("UnnecessaryInterfaceModifier")
-    public interface WriteMapCallback {
-        /**
-         * Called from writeMapXml when an Object type is not recognized. The implementer
-         * must write out the entire element including start and end tags.
-         *
-         * @param v The object to be written out
-         * @param name The mapping key for v. Must be written into the "name" attribute of the
-         *             start tag.
-         * @param out The XML output stream.
-         * @throws XmlPullParserException on unrecognized Object type.
-         * @throws IOException on XmlSerializer serialization errors.
-         */
-        public void writeUnknownObject(Object v, String name, XmlSerializer out)
-                throws XmlPullParserException, IOException;
-    }
-
-    @SuppressWarnings("UnnecessaryInterfaceModifier")
-    public interface ReadMapCallback {
-        /**
-         * Called from readThisMapXml when a START_TAG is not recognized. The input stream
-         * is positioned within the start tag so that attributes can be read using in.getAttribute.
-         *
-         * @param in the XML input stream
-         * @param tag the START_TAG that was not recognized.
-         * @return the Object parsed from the stream which will be put into the map.
-         * @throws XmlPullParserException if the START_TAG is not recognized.
-         * @throws IOException on XmlPullParser serialization errors.
-         */
-        public Object readThisUnknownObjectXml(XmlPullParser in, String tag)
-                throws XmlPullParserException, IOException;
-    }
-}
diff --git a/library/src/test/java/com/evernote/android/job/DatabaseManualUpgradeTest.java b/library/src/test/java/com/evernote/android/job/DatabaseManualUpgradeTest.java
index 449e9e6..e955c07 100644
--- a/library/src/test/java/com/evernote/android/job/DatabaseManualUpgradeTest.java
+++ b/library/src/test/java/com/evernote/android/job/DatabaseManualUpgradeTest.java
@@ -6,7 +6,6 @@
 import android.database.sqlite.SQLiteOpenHelper;
 
 import com.evernote.android.job.test.JobRobolectricTestRunner;
-import com.evernote.android.job.util.support.PersistableBundleCompat;
 
 import org.junit.FixMethodOrder;
 import org.junit.Test;
@@ -233,7 +232,7 @@ protected ContentValues createBaseContentValues(int id) {
             contentValues.put(JobStorage.COLUMN_EXACT, false);
             contentValues.put(JobStorage.COLUMN_NETWORK_TYPE, JobRequest.DEFAULT_NETWORK_TYPE.toString());
 
-            contentValues.put(JobStorage.COLUMN_EXTRAS, new PersistableBundleCompat().saveToXml());
+            contentValues.put(JobStorage.COLUMN_EXTRAS, "");
             contentValues.put(JobStorage.COLUMN_PERSISTED, false);
 
             contentValues.put(JobStorage.COLUMN_NUM_FAILURES, 0);
diff --git a/library/src/test/java/com/evernote/android/job/JobRequestTest.java b/library/src/test/java/com/evernote/android/job/JobRequestTest.java
index 9129934..2c3912c 100644
--- a/library/src/test/java/com/evernote/android/job/JobRequestTest.java
+++ b/library/src/test/java/com/evernote/android/job/JobRequestTest.java
@@ -7,7 +7,6 @@
 import com.evernote.android.job.test.JobRobolectricTestRunner;
 import com.evernote.android.job.util.JobApi;
 import com.evernote.android.job.util.JobCat;
-import com.evernote.android.job.util.support.PersistableBundleCompat;
 
 import net.vrallev.android.cat.print.CatPrinter;
 
@@ -34,7 +33,7 @@ public void testSimpleJob() {
         JobRequest request = getBuilder()
                 .setExecutionWindow(2_000L, 3_000L)
                 .setBackoffCriteria(4_000, JobRequest.BackoffPolicy.LINEAR)
-                .setExtras(new PersistableBundleCompat())
+                .setData("Test")
                 .setPersisted(true)
                 .build();
 
@@ -45,7 +44,7 @@ public void testSimpleJob() {
         assertThat(request.getBackoffMs()).isEqualTo(4_000L);
         assertThat(request.getBackoffPolicy()).isEqualTo(JobRequest.BackoffPolicy.LINEAR);
         assertThat(request.isPersisted()).isTrue();
-        assertThat(request.getExtras()).isNotNull();
+        assertThat(request.getData()).isNotNull();
 
         assertThat(request.getIntervalMs()).isZero();
         assertThat(request.isExact()).isFalse();
@@ -61,7 +60,7 @@ public void testPeriodic() {
         long interval = JobRequest.MIN_INTERVAL * 5;
         JobRequest request = getBuilder()
                 .setPeriodic(interval)
-                .setExtras(new PersistableBundleCompat())
+                .setData("Test")
                 .setPersisted(true)
                 .build();
 
@@ -77,7 +76,7 @@ public void testPeriodic() {
         assertThat(request.getEndMs()).isNegative();
         assertThat(request.getBackoffMs()).isEqualTo(JobRequest.DEFAULT_BACKOFF_MS);
         assertThat(request.getBackoffPolicy()).isEqualTo(JobRequest.DEFAULT_BACKOFF_POLICY);
-        assertThat(request.getExtras()).isNotNull();
+        assertThat(request.getData()).isNotNull();
         assertThat(request.isExact()).isFalse();
         assertThat(request.requiredNetworkType()).isEqualTo(JobRequest.DEFAULT_NETWORK_TYPE);
         assertThat(request.requirementsEnforced()).isFalse();
@@ -109,7 +108,7 @@ public void testFlex() {
     public void testExact() {
         JobRequest request = getBuilder()
                 .setBackoffCriteria(4_000, JobRequest.BackoffPolicy.LINEAR)
-                .setExtras(new PersistableBundleCompat())
+                .setData("Test")
                 .setPersisted(true)
                 .setExact(2_000L)
                 .build();
@@ -121,7 +120,7 @@ public void testExact() {
         assertThat(request.getBackoffMs()).isEqualTo(4_000L);
         assertThat(request.getBackoffPolicy()).isEqualTo(JobRequest.BackoffPolicy.LINEAR);
         assertThat(request.isPersisted()).isTrue();
-        assertThat(request.getExtras()).isNotNull();
+        assertThat(request.getData()).isNotNull();
         assertThat(request.isExact()).isTrue();
 
         assertThat(request.getIntervalMs()).isZero();
diff --git a/library/src/test/java/com/evernote/android/job/util/support/PersistableBundleCompatTest.java b/library/src/test/java/com/evernote/android/job/util/support/PersistableBundleCompatTest.java
deleted file mode 100644
index 630f28b..0000000
--- a/library/src/test/java/com/evernote/android/job/util/support/PersistableBundleCompatTest.java
+++ /dev/null
@@ -1,70 +0,0 @@
-package com.evernote.android.job.util.support;
-
-import com.evernote.android.job.test.JobRobolectricTestRunner;
-
-import org.junit.FixMethodOrder;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.MethodSorters;
-
-import static org.assertj.core.api.Java6Assertions.assertThat;
-
-/**
- * @author rwondratschek
- */
-@RunWith(JobRobolectricTestRunner.class)
-@FixMethodOrder(MethodSorters.JVM)
-public class PersistableBundleCompatTest {
-
-    @Test
-    public void testBundle() {
-        PersistableBundleCompat bundle = new PersistableBundleCompat();
-        bundle.putBoolean("bool1", true);
-        bundle.putInt("int1", 1);
-        bundle.putLong("long1", 1L);
-        bundle.putDouble("double1", 1.0);
-        bundle.putString("string1", "hello");
-        bundle.putIntArray("intArr", new int[]{1, 2, 3});
-        bundle.putLongArray("longArr", new long[]{4L, 5L, 6L});
-        bundle.putDoubleArray("doubleArr", new double[]{7.0, 8.0, 9.0});
-        bundle.putStringArray("stringArr", new String[]{"Hello", "world"});
-
-        PersistableBundleCompat other = new PersistableBundleCompat();
-        other.putString("string2", "world");
-        bundle.putPersistableBundleCompat("bundle1", other);
-
-        String xml = bundle.saveToXml();
-        PersistableBundleCompat inflated = PersistableBundleCompat.fromXml(xml);
-
-        assertThat(xml).isNotEmpty();
-        assertThat(inflated).isNotNull();
-
-        assertThat(inflated.getBoolean("bool1", false)).isTrue();
-        assertThat(inflated.getInt("int1", 0)).isEqualTo(1);
-        assertThat(inflated.getLong("long1", 0L)).isEqualTo(1L);
-        assertThat(inflated.getDouble("double1", 0.0)).isEqualTo(1.0);
-        assertThat(inflated.getString("string1", null)).isEqualTo("hello");
-        assertThat(inflated.getIntArray("intArr")).isNotEmpty().containsExactly(1, 2, 3);
-        assertThat(inflated.getLongArray("longArr")).isNotEmpty().containsExactly(4L, 5L, 6L);
-        assertThat(inflated.getDoubleArray("doubleArr")).isNotEmpty().containsExactly(7.0, 8.0, 9.0);
-        assertThat(inflated.getStringArray("stringArr")).isNotEmpty().containsExactly("Hello", "world");
-
-
-        PersistableBundleCompat inflatedInner = inflated.getPersistableBundleCompat("bundle1");
-        assertThat(inflatedInner).isNotNull();
-        assertThat(inflatedInner.getString("string2", null)).isEqualTo("world");
-    }
-
-    @Test
-    public void testNullInStringArray() {
-        PersistableBundleCompat bundle = new PersistableBundleCompat();
-
-        String[] array = {"111", null, "333"};
-        bundle.putStringArray("array", array);
-
-        bundle = PersistableBundleCompat.fromXml(bundle.saveToXml());
-
-        String[] inflated = bundle.getStringArray("array");
-        assertThat(inflated).isNotNull().hasSize(3).containsExactly("111", null, "333");
-    }
-}
