diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocket.java b/Autobahn/src/de/tavendo/autobahn/WebSocket.java
index d6ceec4..a8b43bc 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocket.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocket.java
@@ -28,10 +28,20 @@
        */
       public static final int CLOSE_PROTOCOL_ERROR = 4;
 
-      /**
-       * Internal error.
-       */
-      public static final int CLOSE_INTERNAL_ERROR = 5;
+	   /**
+	    * Internal error.
+	    */
+	   public static final int CLOSE_INTERNAL_ERROR = 5;
+	   
+	   /**
+	    * Server returned error while connecting
+	    */
+	   public static final int CLOSE_SERVER_ERROR = 6;
+	   
+	   /**
+	    * Server connection lost, scheduled reconnect
+	    */
+	   public static final int CLOSE_RECONNECT = 7;
 
       /**
        * Fired when the WebSockets connection has been established.
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java b/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java
index 9ebe749..00ad709 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java
@@ -66,7 +66,9 @@
    private WebSocket.ConnectionHandler mWsHandler;
 
    protected WebSocketOptions mOptions;
-
+   
+   private boolean mActive;
+   private boolean mPrevConnected;
 
    /**
     * Asynch socket connector.
@@ -151,15 +153,12 @@ protected void onPostExecute(String reason) {
 
          if (reason != null) {
 
-            mWsHandler.onClose(WebSocketConnectionHandler.CLOSE_CANNOT_CONNECT, reason);
+            onClose(WebSocketConnectionHandler.CLOSE_CANNOT_CONNECT, reason);
 
          } else if (isConnected()) {
 
             try {
 
-               // create WebSocket master handler
-               createHandler();
-
                // create & start WebSocket reader
                createReader();
 
@@ -172,16 +171,18 @@ protected void onPostExecute(String reason) {
                hs.mQuery = mWsQuery;
                hs.mSubprotocols = mWsSubprotocols;
                mWriter.forward(hs);
+               
+               mPrevConnected = true;
 
             } catch (Exception e) {
 
-               mWsHandler.onClose(WebSocketConnectionHandler.CLOSE_INTERNAL_ERROR, e.getMessage());
+               onClose(WebSocketConnectionHandler.CLOSE_INTERNAL_ERROR, e.getMessage());
 
             }
 
          } else {
 
-            mWsHandler.onClose(WebSocketConnectionHandler.CLOSE_CANNOT_CONNECT, "could not connect to WebSockets server");
+            onClose(WebSocketConnectionHandler.CLOSE_CANNOT_CONNECT, "could not connect to WebSockets server");
          }
       }
 
@@ -190,6 +191,13 @@ protected void onPostExecute(String reason) {
 
    public WebSocketConnection() {
       if (DEBUG) Log.d(TAG, "created");
+      
+      // create WebSocket master handler
+      createHandler();
+      
+      // set initial values
+      mActive = false;
+      mPrevConnected = false;
    }
 
 
@@ -261,6 +269,7 @@ private void failConnection(int code, String reason) {
          if (DEBUG) Log.d(TAG, "mTransportChannel already NULL");
       }
 
+/*
       if (mWsHandler != null) {
          try {
             mWsHandler.onClose(code, reason);
@@ -271,6 +280,8 @@ private void failConnection(int code, String reason) {
       } else {
          if (DEBUG) Log.d(TAG, "mWsHandler already NULL");
       }
+*/
+      onClose(code, reason);
 
       if (DEBUG) Log.d(TAG, "worker threads stopped");
    }
@@ -344,6 +355,9 @@ public void connect(String wsUri, String[] wsSubprotocols, WebSocket.ConnectionH
 
       // make copy of options!
       mOptions = new WebSocketOptions(options);
+      
+      // set connection active
+      mActive = true;
 
       // use asynch connector on short-lived background thread
       new WebSocketConnector().execute();
@@ -356,6 +370,78 @@ public void disconnect() {
       } else {
          if (DEBUG) Log.d(TAG, "could not send Close .. writer already NULL");
       }
+      mActive = false;
+      mPrevConnected = false;
+   }
+   
+   /**
+    * Reconnect to the server with the latest options 
+    * @return true if reconnection performed
+    */
+   public boolean reconnect() {
+	   if (!isConnected() && (mWsUri != null)) {
+		   new WebSocketConnector().execute();
+		   return true;
+	   }
+	   return false;
+   }
+   
+   /**
+    * Perform reconnection
+    * 
+    * @return true if reconnection was scheduled
+    */
+   protected boolean scheduleReconnect() {
+	   /**
+	    * Reconnect only if:
+	    *  - connection active (connected but not disconnected)
+	    *  - has previous success connections
+	    *  - reconnect interval is set
+	    */
+	   int interval = mOptions.getReconnectInterval();
+	   boolean need = mActive && mPrevConnected && (interval > 0);
+	   if (need) {
+		   if (DEBUG) Log.d(TAG, "Reconnection scheduled");
+		   mMasterHandler.postDelayed(new Runnable() {
+			
+			public void run() {
+				if (DEBUG) Log.d(TAG, "Reconnecting...");
+				reconnect();
+			}
+		}, interval);
+	   }
+	   return need;
+   }
+   
+   /**
+    * Common close handler
+    * 
+    * @param code       Close code.
+	* @param reason     Close reason (human-readable).
+    */
+   private void onClose(int code, String reason) {
+	   boolean reconnecting = false;
+	   
+	   if ((code == WebSocket.ConnectionHandler.CLOSE_CANNOT_CONNECT) ||
+			   (code == WebSocket.ConnectionHandler.CLOSE_CONNECTION_LOST)) {
+		   reconnecting = scheduleReconnect();
+	   }
+	   
+	   
+	   if (mWsHandler != null) {
+		   try {
+			   if (reconnecting) {
+				   mWsHandler.onClose(WebSocket.ConnectionHandler.CLOSE_RECONNECT, reason);
+			   } else {
+				   mWsHandler.onClose(code, reason);
+			   }
+		   } catch (Exception e) {
+			   if (DEBUG) e.printStackTrace();
+		   }
+		   //mWsHandler = null;
+	   } else {
+		   if (DEBUG) Log.d(TAG, "mWsHandler already NULL");
+	   }
    }
 
 
@@ -425,15 +511,16 @@ public void handleMessage(Message msg) {
 
             } else if (msg.obj instanceof WebSocketMessage.ServerHandshake) {
 
-               @SuppressWarnings("unused")
                WebSocketMessage.ServerHandshake serverHandshake = (WebSocketMessage.ServerHandshake) msg.obj;
 
                if (DEBUG) Log.d(TAG, "opening handshake received");
-
-               if (mWsHandler != null) {
-                  mWsHandler.onOpen();
-               } else {
-                  if (DEBUG) Log.d(TAG, "could not call onOpen() .. handler already NULL");
+               
+               if (serverHandshake.mSuccess) {
+            	   if (mWsHandler != null) {
+                       mWsHandler.onOpen();
+                    } else {
+                       if (DEBUG) Log.d(TAG, "could not call onOpen() .. handler already NULL");
+                    }
                }
 
             } else if (msg.obj instanceof WebSocketMessage.ConnectionLost) {
@@ -452,6 +539,11 @@ public void handleMessage(Message msg) {
 
                WebSocketMessage.Error error = (WebSocketMessage.Error) msg.obj;
                failConnection(WebSocketConnectionHandler.CLOSE_INTERNAL_ERROR, "WebSockets internal error (" + error.mException.toString() + ")");
+               
+            } else if (msg.obj instanceof WebSocketMessage.ServerError) {
+            	
+            	WebSocketMessage.ServerError error = (WebSocketMessage.ServerError) msg.obj;
+            	failConnection(WebSocketConnectionHandler.CLOSE_SERVER_ERROR, "Server error " + error.mStatusCode + " (" + error.mStatusMessage + ")");
 
             } else {
 
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketMessage.java b/Autobahn/src/de/tavendo/autobahn/WebSocketMessage.java
index ba17d1a..6825f5b 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketMessage.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketMessage.java
@@ -66,11 +66,27 @@
 
    /// Initial WebSockets handshake (server response).
    public static class ServerHandshake extends Message {
+	   public boolean mSuccess;
+	   
+	   public ServerHandshake(boolean success) {
+		   mSuccess = success;
+	   }
    }
 
    /// WebSockets connection lost
    public static class ConnectionLost extends Message {
    }
+   
+   public static class ServerError extends Message {
+	   public int mStatusCode;
+	   public String mStatusMessage;
+	   
+	   public ServerError(int statusCode, String statusMessage) {
+		   mStatusCode = statusCode;
+		   mStatusMessage = statusMessage;
+	   }
+	   
+   }
 
    /// WebSockets reader detected WS protocol violation.
    public static class ProtocolViolation extends Message {
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketOptions.java b/Autobahn/src/de/tavendo/autobahn/WebSocketOptions.java
index 9226a5e..a3a4d8a 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketOptions.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketOptions.java
@@ -38,6 +38,7 @@
    private boolean mValidateIncomingUtf8;
    private boolean mMaskClientFrames;
    private boolean mVerifyCertificateAuthority;
+   private int mReconnectInterval;
 
 
    /**
@@ -53,6 +54,7 @@ public WebSocketOptions() {
       mSocketConnectTimeout = 6000;
       mValidateIncomingUtf8 = true;
       mMaskClientFrames = true;
+      mReconnectInterval = 0;  // no reconnection by default
       
       // trusting everything run from a emulator      
       if (Build.PRODUCT.contains("sdk")) {
@@ -77,6 +79,7 @@ public WebSocketOptions(WebSocketOptions other) {
       mSocketConnectTimeout = other.mSocketConnectTimeout;
       mValidateIncomingUtf8 = other.mValidateIncomingUtf8;
       mMaskClientFrames = other.mMaskClientFrames;
+      mReconnectInterval = other.mReconnectInterval;
       mVerifyCertificateAuthority = other.mVerifyCertificateAuthority;
    }
 
@@ -266,6 +269,24 @@ public boolean getMaskClientFrames() {
       return mMaskClientFrames;
    }
    
+   /**
+    * Set interval for automatic reconnect.
+    * 
+    * @param reconnectInterval   Interval in ms, 0 - no automatic reconnect.
+    */
+   public void setReconnectInterval(int reconnectInterval) {
+      mReconnectInterval = reconnectInterval;
+   }
+   
+   /**
+    * Get interval for automatic reconnect.
+    *
+    * @return        Interval in ms, 0 - no automatic reconnect.
+    */
+   public int getReconnectInterval() {
+      return mReconnectInterval;
+   }
+
    /**
     * Get Verify CA option
     * @return        True, iff CA has to be verified.
@@ -282,5 +303,5 @@ public boolean getVerifyCertificateAuthority() {
     */
    public void setVerifyCertificateAuthority(boolean verify) {
       mVerifyCertificateAuthority = verify;
-   }
+   }  
 }
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketReader.java b/Autobahn/src/de/tavendo/autobahn/WebSocketReader.java
index 893f199..1969f89 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketReader.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketReader.java
@@ -21,9 +21,13 @@
 import java.io.UnsupportedEncodingException;
 import java.net.Socket;
 import java.nio.ByteBuffer;
+import java.net.SocketException;
+import java.util.HashMap;
+import java.util.Map;
 import android.os.Handler;
 import android.os.Message;
 import android.util.Log;
+import android.util.Pair;
 
 /**
  * WebSocket reader, the receiving leg of a WebSockets connection.
@@ -423,10 +427,12 @@ private boolean processData() throws Exception {
 
    /**
     * WebSockets handshake reply from server received, default notifies master.
+    * 
+    * @param success	Success handshake flag
     */
-   protected void onHandshake() {
+   protected void onHandshake(boolean success) {
 
-      notify(new WebSocketMessage.ServerHandshake());
+      notify(new WebSocketMessage.ServerHandshake(success));
    }
 
 
@@ -514,22 +520,98 @@ private boolean processHandshake() throws UnsupportedEncodingException {
 
             /// \todo process & verify handshake from server
             /// \todo forward subprotocol, if any
-            onHandshake();
 
             int oldPosition = mFrameBuffer.position();
+            
+            // Check HTTP status code
+            boolean serverError = false;
+            if (mFrameBuffer.get(0) == 'H' &&
+            	mFrameBuffer.get(1) == 'T' &&
+            	mFrameBuffer.get(2) == 'T' &&
+            	mFrameBuffer.get(3) == 'P') {
+            	
+            	Pair<Integer, String> status = parseHttpStatus();
+            	if (status.first >= 300) {
+            		// Invalid status code for success connection
+            		notify(new WebSocketMessage.ServerError(status.first, status.second));
+            		serverError = true;
+            	}
+            }
+            
             mFrameBuffer.position(pos + 4);
             mFrameBuffer.limit(oldPosition);
             mFrameBuffer.compact();
 
-            // process further when data after HTTP headers left in buffer
-            res = mFrameBuffer.position() > 0;
+            if (!serverError) {
+            	// process further when data after HTTP headers left in buffer
+                res = mFrameBuffer.position() > 0;
 
-            mState = STATE_OPEN;
+                mState = STATE_OPEN;
+            } else {
+            	res = true;
+            	mState = STATE_CLOSED;
+            	mStopped = true;
+            }
+            
+            onHandshake(!serverError);
             break;
          }
       }
       return res;
    }
+   
+   @SuppressWarnings("unused")
+   private Map<String, String> parseHttpHeaders(byte[] buffer) throws UnsupportedEncodingException {
+	   // TODO: use utf-8 validator?
+	   String s = new String(buffer, "UTF-8");
+	   Map<String, String> headers = new HashMap<String, String>();
+	   
+	   String[] lines = s.split("\r\n");
+	   for (String line : lines) {
+		   if (line.length() > 0) {
+			   String[] h = line.split(": ");
+			   if (h.length == 2) {
+				   headers.put(h[0], h[1]);
+				   Log.w(TAG, String.format("'%s'='%s'", h[0], h[1]));
+			   }
+		   }
+	   }
+	   
+	   return headers;
+   }
+   
+   private Pair<Integer, String> parseHttpStatus() throws UnsupportedEncodingException {
+	   int beg, end;
+		// Find first space
+		for (beg = 4; beg < mFrameBuffer.position(); ++beg) {
+			if (mFrameBuffer.get(beg) == ' ') break;
+		}
+		// Find second space
+		for (end = beg + 1; end < mFrameBuffer.position(); ++end) {
+			if (mFrameBuffer.get(end) == ' ') break;
+		}
+		// Parse status code between them
+		++beg;
+		int statusCode = 0;
+		for (int i = 0; beg + i < end; ++i) {
+			int digit = (mFrameBuffer.get(beg + i) - 0x30);
+			statusCode *= 10;
+			statusCode += digit;
+		}
+		// Find end of line to extract error message
+		++end;
+		int eol;
+		for (eol = end; eol < mFrameBuffer.position(); ++eol) {
+			if (mFrameBuffer.get(eol) == 0x0d) break;
+		}
+		int statusMessageLength = eol - end;
+		byte[] statusBuf = new byte[statusMessageLength];
+		mFrameBuffer.position(end);
+		mFrameBuffer.get(statusBuf, 0, statusMessageLength);
+		String statusMessage = new String(statusBuf, "UTF-8");
+		if (DEBUG) Log.w(TAG, String.format("Status: %d (%s)", statusCode, statusMessage));
+		return new Pair<Integer, String>(statusCode, statusMessage);
+   }
 
 
    /**
@@ -594,6 +676,13 @@ public void run() {
          // wrap the exception and notify master
          notify(new WebSocketMessage.ProtocolViolation(e));
 
+      } catch (SocketException e) {
+    	  
+    	  if (DEBUG) Log.d(TAG, "run() : SocketException (" + e.toString() + ")");
+    	  
+    	  // wrap the exception and notify master
+    	  notify(new WebSocketMessage.ConnectionLost());;
+    	  
       } catch (Exception e) {
 
          if (DEBUG) Log.wtf(TAG, "run() : Exception (" + e.toString() + ")", e);
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java b/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java
index b5d1c1c..873f5f5 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java
@@ -20,8 +20,8 @@
 
 import java.io.IOException;
 import java.net.Socket;
+import java.net.SocketException;
 import java.util.Random;
-
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
@@ -393,6 +393,12 @@ public void handleMessage(Message msg) {
             mSocket.getOutputStream().write(arr);
          }
 
+      } catch (SocketException e) {
+    	  
+    	  if (DEBUG) Log.d(TAG, "run() : SocketException (" + e.toString() + ")");
+    	  
+    	  // wrap the exception and notify master
+    	  notify(new WebSocketMessage.ConnectionLost());
       } catch (Exception e) {
 
          if (DEBUG) e.printStackTrace();
diff --git a/Demo/TestSuiteClient/src/de/tavendo/autobahn/testsuiteclient/MainActivity.java b/Demo/TestSuiteClient/src/de/tavendo/autobahn/testsuiteclient/MainActivity.java
index c6f8586..9ef5a61 100644
--- a/Demo/TestSuiteClient/src/de/tavendo/autobahn/testsuiteclient/MainActivity.java
+++ b/Demo/TestSuiteClient/src/de/tavendo/autobahn/testsuiteclient/MainActivity.java
@@ -100,8 +100,8 @@ public void onClose(int code, String reason) {
                testOptions.setReceiveTextMessagesRaw(true);
                //testOptions.setValidateIncomingUtf8(false);
                //testOptions.setMaskClientFrames(false);
-               testOptions.setMaxMessagePayloadSize(4*1024*1024);
-               testOptions.setMaxFramePayloadSize(4*1024*1024);
+               //testOptions.setMaxMessagePayloadSize(4*1024*1024);
+               //testOptions.setMaxFramePayloadSize(4*1024*1024);
                //testOptions.setTcpNoDelay(false);
 
                sess.connect(mWsUri.getText() + "/runCase?case=" + currCase + "&agent=" + mAgent.getText(),
