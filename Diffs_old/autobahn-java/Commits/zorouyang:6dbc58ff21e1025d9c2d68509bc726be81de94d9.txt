diff --git a/.travis-deploy.sh b/.travis-deploy.sh
new file mode 100755
index 0000000..dc51173
--- /dev/null
+++ b/.travis-deploy.sh
@@ -0,0 +1,58 @@
+#!/bin/bash
+
+export AWS_DEFAULT_REGION=eu-central-1
+export AWS_S3_BUCKET_NAME=crossbarbuilder
+# AWS_ACCESS_KEY_ID         : must be set in Travis CI build context
+# AWS_SECRET_ACCESS_KEY     : must be set in Travis CI build context
+# WAMP_PRIVATE_KEY          : must be set in Travis CI build context
+
+set -ev
+
+# TRAVIS_BRANCH, TRAVIS_PULL_REQUEST, TRAVIS_TAG
+
+# PR => don't deploy and exit
+if [ "$TRAVIS_PULL_REQUEST" = "true" ]; then
+    echo '[1] deploy script called for PR - exiting ..';
+    exit 0;
+
+# direct push to master => deploy
+elif [ "$TRAVIS_BRANCH" = "master" -a "$TRAVIS_PULL_REQUEST" = "false" ]; then
+    echo '[2] deploy script called for direct push to master: continuing to deploy!';
+
+# tagged release => deploy
+elif [ -n "$TRAVIS_TAG" ]; then
+    echo '[3] deploy script called for tagged release: continuing to deploy!';
+
+# outside travis? => deploy
+else
+    echo '[?] deploy script called outside Travis? continuing to deploy!';
+
+fi
+
+# only show number of env vars .. should be 4 on master branch!
+# https://docs.travis-ci.com/user/pull-requests/#Pull-Requests-and-Security-Restrictions
+# Travis CI makes encrypted variables and data available only to pull requests coming from the same repository.
+echo 'aws env vars (should be 4 - but only on master branch!):'
+env | grep AWS | wc -l
+
+# set up awscli package
+echo 'installing aws tools ..'
+pip install awscli
+which aws
+aws --version
+aws s3 ls ${AWS_S3_BUCKET_NAME}
+
+# upload to S3: https://s3.eu-central-1.amazonaws.com/crossbarbuilder/wheels/
+# echo 'uploading package ..'
+# aws s3 cp --recursive ./dist s3://${AWS_S3_BUCKET_NAME}/wheels
+
+# tell crossbar-builder about this new wheel push
+# get 'wamp' command, always with latest autobahn master
+
+pip install https://github.com/crossbario/autobahn-python/archive/master.zip#egg=autobahn[twisted,serialization,encryption]
+wamp --max-failures 3 --authid wheel_pusher --url ws://office2dmz.crossbario.com:8008/ --realm webhook call builder.wheel_pushed --keyword name autobahn-java --keyword publish true
+
+# build and deploy latest docs
+#echo 'building and uploading docs ..'
+#tox -c tox.ini -e sphinx
+#aws s3 cp --recursive --acl public-read ${HOME}/crossbar-docs s3://${AWS_S3_BUCKET_NAME}/docs-latest
diff --git a/README.md b/README.md
index 5b05cea..07560e0 100644
--- a/README.md
+++ b/README.md
@@ -220,7 +220,7 @@ Autobahn also supports POJOs
 Here is how to call a remote procedure that returns a list of Person POJOs
 
 ```java
-// Call a remote proedure that returns a Person with id 1
+// Call a remote procedure that returns a Person with id 1
 CompletableFuture<Person> callFuture = mSession.call("com.example.get_person", 1);
 callFuture.whenCompleteAsync((person, throwable) -> {
     if (throwable != null) {
@@ -276,10 +276,35 @@ private void main() {
 
 ### WebSocket on Android
 
-TBD
+Echo example
+
+```java
+WebSocketConnection connection = new WebSocketConnection();
+connection.connect("wss://echo.websocket.org", new WebSocketConnectionHandler() {
+    @Override
+    public void onConnect(ConnectionResponse response) {
+        System.out.println("Connected to server");
+    }
+
+    @Override
+    public void onOpen() {
+        connection.sendMessage("Echo with Autobahn");
+    }
+
+    @Override
+    public void onClose(int code, String reason) {
+        System.out.println("Connection closed");
+    }
+
+    @Override
+    public void onMessage(String payload) {
+        System.out.println("Received message: " + payload);
+        connection.sendMessage(payload);
+    }
+});
+```
 
 ---
---
 
 ### Building from source
 
@@ -305,7 +330,7 @@ and that will output the jar file in `autobahn/build/libs/`.
 
 ## Get in touch
 
-Get in touch on IRC #autobahn on chat.freenode.net or join the [mailing list](http://groups.google.com/group/autobahnws).
+Get in touch by joining our [forum](https://forum.crossbar.io).
 
 ---
 
diff --git a/autobahn/build.gradle b/autobahn/build.gradle
index 46f56b3..50da4dc 100644
--- a/autobahn/build.gradle
+++ b/autobahn/build.gradle
@@ -16,16 +16,20 @@ def siteUrl = 'https://github.com/crossbario/autobahn-java'
 
 dependencies {
     api 'com.fasterxml.jackson.core:jackson-core:2.9.8'
-    //api 'net.sourceforge.streamsupport:streamsupport-cfuture:1.6.2'
+    // api 'net.sourceforge.streamsupport:streamsupport-cfuture:1.6.2'
     implementation 'com.fasterxml.jackson.core:jackson-databind:2.9.8'
     implementation 'com.fasterxml.jackson.dataformat:jackson-dataformat-cbor:2.9.8'
     implementation 'org.msgpack:jackson-dataformat-msgpack:0.8.16'
     if (project.IS_ANDROID) {
         implementation 'com.github.joshjdevl.libsodiumjni:libsodium-jni-aar:2.0.1'
+        implementation ('org.ethereum:ethereumj-core:1.11.0-RELEASE') {
+            exclude group: 'org.iq80.leveldb'
+        }
     } else {
         implementation 'com.github.joshjdevl.libsodiumjni:libsodium-jni:2.0.1'
         implementation 'io.netty:netty-codec-http:4.1.34.Final'
         implementation 'io.netty:netty-handler:4.1.34.Final'
+        implementation 'org.ethereum:ethereumj-core:1.11.0-RELEASE'
     }
 }
 
@@ -90,6 +94,13 @@ if (project.IS_ANDROID) {
         lintOptions {
             abortOnError false
         }
+        packagingOptions {
+            exclude 'META-INF/spring.tooling'
+            exclude 'META-INF/spring.handlers'
+            exclude 'META-INF/spring.schemas'
+            exclude 'META-INF/license.txt'
+            exclude 'META-INF/notice.txt'
+        }
     }
     task sourcesJar(type: Jar) {
         classifier = 'sources'
diff --git a/autobahn/src/main/java/io/crossbar/autobahn/wamp/Client.java b/autobahn/src/main/java/io/crossbar/autobahn/wamp/Client.java
index dede831..9b7c822 100644
--- a/autobahn/src/main/java/io/crossbar/autobahn/wamp/Client.java
+++ b/autobahn/src/main/java/io/crossbar/autobahn/wamp/Client.java
@@ -121,8 +121,16 @@ public void add(Session session, String realm) {
                 mSession.join(mRealm, mAuthenticators).thenAccept(details ->
                         LOGGER.i(String.format("JOINED session=%s realm=%s", details.sessionID,
                                 details.realm))));
-        mSession.addOnDisconnectListener((session, wasClean) ->
-                exitFuture.complete(new ExitInfo(wasClean)));
+        mSession.addOnDisconnectListener((session, wasClean) -> {
+            for (ITransport transport: mTransports) {
+                try {
+                    transport.close();
+                } catch (Exception ignore) {
+
+                }
+            }
+            exitFuture.complete(new ExitInfo(wasClean));
+        });
         CompletableFuture.runAsync(() -> {
             try {
                 mTransports.get(0).connect(mSession, options);
diff --git a/autobahn/src/main/java/io/crossbar/autobahn/wamp/Session.java b/autobahn/src/main/java/io/crossbar/autobahn/wamp/Session.java
index a607bc4..05aff09 100644
--- a/autobahn/src/main/java/io/crossbar/autobahn/wamp/Session.java
+++ b/autobahn/src/main/java/io/crossbar/autobahn/wamp/Session.java
@@ -445,8 +445,12 @@ private void onMessage(IMessage message) throws Exception {
                         msg.registration));
             }
 
+            long callerSessionID = getOrDefault(msg.details, "caller", -1L);
+            String callerAuthID = getOrDefault(msg.details, "caller_authid", null);
+            String callerAuthRole = getOrDefault(msg.details, "caller_authrole", null);
+            
             InvocationDetails details = new InvocationDetails(
-                    registration, registration.procedure, -1, null, null, this);
+                    registration, registration.procedure, callerSessionID, callerAuthID, callerAuthRole, this);
 
             runAsync(() -> {
                 Object result;
@@ -1246,6 +1250,14 @@ private CompletableFuture combineFutures(List<CompletableFuture<?>> futures) {
         return reallyCall(procedure, Arrays.asList(args), null, options, resultType, null);
     }
 
+    @Override
+    public <T> CompletableFuture<T> call(
+            String procedure,
+            TypeReference<T> resultType,
+            Object... args) {
+        return reallyCall(procedure, Arrays.asList(args), null, null, resultType, null);
+    }
+
     private CompletableFuture<SessionDetails> reallyJoin(
             String realm,
             List<IAuthenticator> authenticators) {
diff --git a/autobahn/src/main/java/io/crossbar/autobahn/wamp/interfaces/ISession.java b/autobahn/src/main/java/io/crossbar/autobahn/wamp/interfaces/ISession.java
index 51af4ce..2e6134c 100644
--- a/autobahn/src/main/java/io/crossbar/autobahn/wamp/interfaces/ISession.java
+++ b/autobahn/src/main/java/io/crossbar/autobahn/wamp/interfaces/ISession.java
@@ -702,6 +702,10 @@
                                   CallOptions options,
                                   Object... args);
 
+    <T> CompletableFuture<T> call(String procedure,
+                                  TypeReference<T> resultType,
+                                  Object... args);
+
     /**
      * Joins a realm on the WAMP router
      * @param realm name of the realm to join
diff --git a/autobahn/src/main/java/io/crossbar/autobahn/wamp/messages/Invocation.java b/autobahn/src/main/java/io/crossbar/autobahn/wamp/messages/Invocation.java
index 05c36c0..ecefb712 100644
--- a/autobahn/src/main/java/io/crossbar/autobahn/wamp/messages/Invocation.java
+++ b/autobahn/src/main/java/io/crossbar/autobahn/wamp/messages/Invocation.java
@@ -13,7 +13,6 @@
 
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
@@ -27,22 +26,26 @@
 
     public final long request;
     public final long registration;
+    public final Map<String, Object> details;
     public final List<Object> args;
     public final Map<String, Object> kwargs;
 
-    public Invocation(long request, long registration, List<Object> args, Map<String, Object> kwargs) {
+    public Invocation(long request, long registration, Map<String, Object> details, List<Object> args,
+            Map<String, Object> kwargs) {
         this.request = request;
         this.registration = registration;
+        this.details = details;
         this.args = args;
         this.kwargs = kwargs;
     }
 
     public static Invocation parse(List<Object> wmsg) {
-        MessageUtil.validateMessage(wmsg, MESSAGE_TYPE, "INNVOCATION", 3, 6);
+        MessageUtil.validateMessage(wmsg, MESSAGE_TYPE, "INVOCATION", 4, 6);
 
         long request = MessageUtil.parseLong(wmsg.get(1));
         long registration = MessageUtil.parseLong(wmsg.get(2));
         Map<String, Object> details = (Map<String, Object>) wmsg.get(3);
+
         List<Object> args = null;
         if (wmsg.size() > 4) {
             if (wmsg.get(4) instanceof byte[]) {
@@ -54,7 +57,7 @@ public static Invocation parse(List<Object> wmsg) {
         if (wmsg.size() > 5) {
             kwargs = (Map<String, Object>) wmsg.get(5);
         }
-        return new Invocation(request, registration, args, kwargs);
+        return new Invocation(request, registration, details, args, kwargs);
     }
 
     @Override
@@ -63,8 +66,12 @@ public static Invocation parse(List<Object> wmsg) {
         marshaled.add(MESSAGE_TYPE);
         marshaled.add(request);
         marshaled.add(registration);
-        // Empty options.
-        marshaled.add(Collections.emptyMap());
+        if (details == null) {
+            // Empty details.
+            marshaled.add(Collections.emptyMap());
+        } else {
+            marshaled.add(details);
+        }
         if (kwargs != null) {
             if (args == null) {
                 // Empty args.
diff --git a/autobahn/src/main/java/io/crossbar/autobahn/wamp/transports/NettyWebSocket.java b/autobahn/src/main/java/io/crossbar/autobahn/wamp/transports/NettyWebSocket.java
index 1a5fd35..98c72f8 100644
--- a/autobahn/src/main/java/io/crossbar/autobahn/wamp/transports/NettyWebSocket.java
+++ b/autobahn/src/main/java/io/crossbar/autobahn/wamp/transports/NettyWebSocket.java
@@ -64,6 +64,7 @@
 
     private Channel mChannel;
     private NettyWebSocketClientHandler mHandler;
+    private NioEventLoopGroup mGroup;
     private final String mUri;
 
     private WebSocketOptions mOptions;
@@ -157,9 +158,9 @@ public void connect(ITransportHandler transportHandler, TransportOptions options
                 new DefaultHttpHeaders(), options.getMaxFramePayloadSize());
         mHandler = new NettyWebSocketClientHandler(handshaker, this, transportHandler);
 
-        EventLoopGroup group = new NioEventLoopGroup();
+        mGroup = new NioEventLoopGroup();
         Bootstrap bootstrap = new Bootstrap();
-        bootstrap.group(group);
+        bootstrap.group(mGroup);
         bootstrap.channel(NioSocketChannel.class);
 
         TransportOptions opt = options;
@@ -213,6 +214,10 @@ public void close() throws Exception {
         if (mHandler != null && mChannel != null) {
             mHandler.close(mChannel, true, new CloseDetails(CloseDetails.REASON_DEFAULT, null));
         }
+        if (mGroup != null) {
+            mGroup.shutdownGracefully().sync();
+            mGroup = null;
+        }
     }
 
     @Override
diff --git a/autobahn/src/main/java/io/crossbar/autobahn/websocket/Connection.java b/autobahn/src/main/java/io/crossbar/autobahn/websocket/Connection.java
new file mode 100644
index 0000000..e81ea85
--- /dev/null
+++ b/autobahn/src/main/java/io/crossbar/autobahn/websocket/Connection.java
@@ -0,0 +1,65 @@
+package io.crossbar.autobahn.websocket;
+
+import java.io.UnsupportedEncodingException;
+
+import io.crossbar.autobahn.websocket.exceptions.ParseFailed;
+import io.crossbar.autobahn.websocket.messages.BinaryMessage;
+import io.crossbar.autobahn.websocket.messages.ClientHandshake;
+import io.crossbar.autobahn.websocket.messages.Close;
+import io.crossbar.autobahn.websocket.messages.Message;
+import io.crossbar.autobahn.websocket.messages.Ping;
+import io.crossbar.autobahn.websocket.messages.Pong;
+import io.crossbar.autobahn.websocket.messages.RawTextMessage;
+import io.crossbar.autobahn.websocket.messages.TextMessage;
+import io.crossbar.autobahn.websocket.types.WebSocketOptions;
+
+public class Connection {
+
+    private FrameProtocol mProtocol;
+    private WebSocketOptions mOptions;
+
+    public Connection(WebSocketOptions options) {
+        mOptions = options;
+        mProtocol = new FrameProtocol();
+    }
+
+    private byte[] sendText(String payload) throws ParseFailed {
+        byte[] payloadBytes;
+        try {
+            payloadBytes = payload.getBytes("UTF-8");
+        } catch (UnsupportedEncodingException e) {
+            throw new ParseFailed("payload is an invalid utf-8 string");
+        }
+        return sendText(payloadBytes);
+    }
+
+    private byte[] sendText(byte[] payload) throws ParseFailed {
+        if (payload.length > mOptions.getMaxMessagePayloadSize()) {
+            throw new ParseFailed("message payload exceeds payload limit");
+        }
+        return mProtocol.sendText(payload);
+    }
+
+    public byte[] send(Message msg) throws ParseFailed {
+        if (msg instanceof TextMessage) {
+            return sendText(((TextMessage) msg).mPayload);
+        } else if (msg instanceof RawTextMessage) {
+            return sendText(((RawTextMessage) msg).mPayload);
+        } else if (msg instanceof BinaryMessage) {
+            if (((BinaryMessage) msg).mPayload.length > mOptions.getMaxMessagePayloadSize()) {
+                throw new ParseFailed("message payload exceeds payload limit");
+            }
+            return mProtocol.sendBinary(((BinaryMessage) msg).mPayload);
+        } else if (msg instanceof Ping) {
+            return mProtocol.ping(((Ping) msg).mPayload);
+        } else if (msg instanceof Pong) {
+            return mProtocol.pong(((Pong) msg).mPayload);
+        } else if (msg instanceof Close) {
+            return mProtocol.close(((Close) msg).mCode, ((Close) msg).mReason);
+        } else if (msg instanceof ClientHandshake) {
+            return Handshake.handshake((ClientHandshake) msg);
+        } else {
+            throw new ParseFailed("unknown message received by WebSocketWriter");
+        }
+    }
+}
diff --git a/autobahn/src/main/java/io/crossbar/autobahn/websocket/FrameProtocol.java b/autobahn/src/main/java/io/crossbar/autobahn/websocket/FrameProtocol.java
new file mode 100644
index 0000000..2bbc356
--- /dev/null
+++ b/autobahn/src/main/java/io/crossbar/autobahn/websocket/FrameProtocol.java
@@ -0,0 +1,135 @@
+package io.crossbar.autobahn.websocket;
+
+import java.io.ByteArrayOutputStream;
+import java.io.UnsupportedEncodingException;
+import java.util.Random;
+
+import io.crossbar.autobahn.websocket.exceptions.ParseFailed;
+
+public class FrameProtocol {
+
+    private static final int MAX_PAYLOAD_NORMAL = 125;
+    private static final int MAX_PAYLOAD_TWO_BYTE = 0xffff; // 2^16 - 1;
+
+    private final Random mRng = new Random();
+
+    public byte[] ping(byte[] payload) throws ParseFailed {
+        if (payload != null && payload.length > 125) {
+            throw new ParseFailed("ping payload exceeds 125 octets");
+        }
+        return serializeFrame(9, payload, true, true);
+    }
+
+    public byte[] pong(byte[] payload) throws ParseFailed {
+        if (payload != null && payload.length > 125) {
+            throw new ParseFailed("ping payload exceeds 125 octets");
+        }
+        return serializeFrame(10, payload, true, true);
+    }
+
+    public byte[] close(int code, String reason) throws ParseFailed {
+        if (code > 0) {
+            byte[] payload;
+
+            if (reason != null && !reason.equals("")) {
+                try {
+                    byte[] pReason = reason.getBytes("UTF-8");
+                    payload = new byte[2 + pReason.length];
+                    System.arraycopy(pReason, 0, payload, 2, pReason.length);
+                } catch (UnsupportedEncodingException e) {
+                    throw new ParseFailed("reason is an invalid utf-8 string");
+                }
+            } else {
+                payload = new byte[2];
+            }
+
+            payload[0] = (byte) ((code >> 8) & 0xff);
+            payload[1] = (byte) (code & 0xff);
+            return serializeFrame(8, payload, true, true);
+        } else {
+            return serializeFrame(8, null, true, true);
+        }
+    }
+
+    public byte[] sendBinary(byte[] payload) {
+        return serializeFrame(2, payload, true, true);
+    }
+
+    public byte[] sendText(byte[] payload) {
+        return serializeFrame(1, payload, true, true);
+    }
+
+    private byte[] serializeFrame(int opcode, byte[] payload, boolean fin, boolean maskFrames) {
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+        // first octet
+        byte b0 = 0;
+        if (fin) {
+            b0 |= (byte) (1 << 7);
+        }
+        b0 |= (byte) opcode;
+        buffer.write(b0);
+
+        // second octet
+        byte b1 = 0;
+        if (maskFrames) {
+            b1 = (byte) (1 << 7);
+        }
+
+        long len = 0;
+        if (payload != null) {
+            len = payload.length;
+        }
+
+        // extended payload length
+        if (len <= MAX_PAYLOAD_NORMAL) {
+            b1 |= (byte) len;
+            buffer.write(b1);
+        } else if (len <= MAX_PAYLOAD_TWO_BYTE) {
+            b1 |= (byte) (126 & 0xff);
+            buffer.write(b1);
+            byte[] payloadLength = new byte[]{(byte) ((len >> 8) & 0xff), (byte) (len & 0xff)};
+            buffer.write(payloadLength, 0, payloadLength.length);
+        } else {
+            b1 |= (byte) (127 & 0xff);
+            buffer.write(b1);
+            byte[] payloadLength = new byte[]{
+                    (byte) ((len >> 56) & 0xff),
+                    (byte) ((len >> 48) & 0xff),
+                    (byte) ((len >> 40) & 0xff),
+                    (byte) ((len >> 32) & 0xff),
+                    (byte) ((len >> 24) & 0xff),
+                    (byte) ((len >> 16) & 0xff),
+                    (byte) ((len >> 8) & 0xff),
+                    (byte) (len & 0xff)};
+            buffer.write(payloadLength, 0, payloadLength.length);
+        }
+
+        byte[] mask = null;
+        if (maskFrames) {
+            // a mask is always needed, even without payload
+            mask = newFrameMask();
+            buffer.write(mask[0]);
+            buffer.write(mask[1]);
+            buffer.write(mask[2]);
+            buffer.write(mask[3]);
+        }
+
+        if (len > 0) {
+            if (maskFrames) {
+                /// \todo optimize masking
+                /// \todo masking within buffer of output stream
+                for (int i = 0; i < len; ++i) {
+                    payload[i] ^= mask[i % 4];
+                }
+            }
+            buffer.write(payload, 0, payload.length);
+        }
+        return buffer.toByteArray();
+    }
+
+    private byte[] newFrameMask() {
+        final byte[] ba = new byte[4];
+        mRng.nextBytes(ba);
+        return ba;
+    }
+}
diff --git a/autobahn/src/main/java/io/crossbar/autobahn/websocket/Handshake.java b/autobahn/src/main/java/io/crossbar/autobahn/websocket/Handshake.java
new file mode 100644
index 0000000..c2caafd
--- /dev/null
+++ b/autobahn/src/main/java/io/crossbar/autobahn/websocket/Handshake.java
@@ -0,0 +1,79 @@
+package io.crossbar.autobahn.websocket;
+
+import android.util.Base64;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.Random;
+
+import io.crossbar.autobahn.websocket.exceptions.ParseFailed;
+import io.crossbar.autobahn.websocket.messages.ClientHandshake;
+
+public class Handshake {
+
+    private final static String CRLF = "\r\n";
+
+    private static byte[] bytes(String text) throws IOException {
+        return text.getBytes("UTF-8");
+    }
+
+    private static String newHandshakeKey() {
+        final byte[] ba = new byte[16];
+        new Random().nextBytes(ba);
+        return Base64.encodeToString(ba, Base64.NO_WRAP);
+    }
+
+    public static byte[] handshake(ClientHandshake message) throws ParseFailed {
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+        // write HTTP header with handshake
+        String path;
+        if (message.mQuery != null) {
+            path = message.mPath + "?" + message.mQuery;
+        } else {
+            path = message.mPath;
+        }
+        try {
+            buffer.write(bytes(String.format("GET %s HTTP/1.1", path)));
+            buffer.write(bytes(CRLF));
+            buffer.write(bytes("Host: " + message.mHost));
+            buffer.write(bytes(CRLF));
+            buffer.write(bytes("Upgrade: WebSocket"));
+            buffer.write(bytes(CRLF));
+            buffer.write(bytes("Connection: Upgrade"));
+            buffer.write(bytes(CRLF));
+            buffer.write(bytes("Sec-WebSocket-Key: " + newHandshakeKey()));
+            buffer.write(bytes(CRLF));
+            if (message.mOrigin != null && !message.mOrigin.equals("")) {
+                buffer.write(bytes("Origin: " + message.mOrigin));
+                buffer.write(bytes(CRLF));
+            }
+
+            if (message.mSubprotocols != null && message.mSubprotocols.length > 0) {
+                buffer.write(bytes("Sec-WebSocket-Protocol: "));
+                for (int i = 0; i < message.mSubprotocols.length; ++i) {
+                    buffer.write(bytes(message.mSubprotocols[i]));
+                    if (i != message.mSubprotocols.length - 1) {
+                        buffer.write(bytes(", "));
+                    }
+                }
+                buffer.write(bytes(CRLF));
+            }
+
+            buffer.write(bytes("Sec-WebSocket-Version: 13"));
+            buffer.write(bytes(CRLF));
+
+            // Header injection
+            if (message.mHeaderList != null) {
+                for (String key : message.mHeaderList.keySet()) {
+                    buffer.write(bytes(key + ":" + message.mHeaderList.get(key)));
+                    buffer.write(bytes(CRLF));
+                }
+            }
+            buffer.write(bytes(CRLF));
+        } catch (IOException e) {
+            e.printStackTrace();
+            throw new ParseFailed(e.getMessage());
+        }
+        return buffer.toByteArray();
+    }
+}
diff --git a/autobahn/src/main/java/io/crossbar/autobahn/websocket/WebSocketConnection.java b/autobahn/src/main/java/io/crossbar/autobahn/websocket/WebSocketConnection.java
index 9687514..de27975 100644
--- a/autobahn/src/main/java/io/crossbar/autobahn/websocket/WebSocketConnection.java
+++ b/autobahn/src/main/java/io/crossbar/autobahn/websocket/WebSocketConnection.java
@@ -13,16 +13,18 @@
 
 
 import android.os.Handler;
-import android.os.HandlerThread;
 import android.os.Looper;
 import android.os.Message;
 
+import java.io.BufferedOutputStream;
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.net.Socket;
+import java.net.SocketException;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.util.Map;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ScheduledFuture;
@@ -34,6 +36,7 @@
 
 import io.crossbar.autobahn.utils.ABLogger;
 import io.crossbar.autobahn.utils.IABLogger;
+import io.crossbar.autobahn.websocket.exceptions.ParseFailed;
 import io.crossbar.autobahn.websocket.exceptions.WebSocketException;
 import io.crossbar.autobahn.websocket.interfaces.IWebSocket;
 import io.crossbar.autobahn.websocket.interfaces.IWebSocketConnectionHandler;
@@ -46,7 +49,6 @@
 import io.crossbar.autobahn.websocket.messages.Ping;
 import io.crossbar.autobahn.websocket.messages.Pong;
 import io.crossbar.autobahn.websocket.messages.ProtocolViolation;
-import io.crossbar.autobahn.websocket.messages.Quit;
 import io.crossbar.autobahn.websocket.messages.RawTextMessage;
 import io.crossbar.autobahn.websocket.messages.ServerError;
 import io.crossbar.autobahn.websocket.messages.ServerHandshake;
@@ -62,8 +64,9 @@
     private Handler mMasterHandler;
 
     private WebSocketReader mReader;
-    private WebSocketWriter mWriter;
-    private HandlerThread mWriterThread;
+    private ExecutorService mWriterThread;
+    private Connection mWebSocket;
+    private BufferedOutputStream mBufferedOutputStream;
 
     private Socket mSocket;
     private URI mWsUri;
@@ -165,7 +168,7 @@ public void run() {
                     hs.mQuery = mWsQuery;
                     hs.mSubprotocols = mWsSubprotocols;
                     hs.mHeaderList = mWsHeaders;
-                    mWriter.forward(hs);
+                    sendMessage(hs);
                     mPrevConnected = true;
 
                 } catch (Exception e) {
@@ -190,36 +193,36 @@ public WebSocketConnection() {
 
     @Override
     public void sendMessage(String payload) {
-        mWriter.forward(new TextMessage(payload));
+        sendMessage(new TextMessage(payload));
     }
 
     @Override
     public void sendMessage(byte[] payload, boolean isBinary) {
         if (isBinary) {
-            mWriter.forward(new BinaryMessage(payload));
+            sendMessage(new BinaryMessage(payload));
         } else {
-            mWriter.forward(new RawTextMessage(payload));
+            sendMessage(new RawTextMessage(payload));
         }
     }
 
     @Override
     public void sendPing() {
-        mWriter.forward(new Ping());
+        sendMessage(new Ping());
     }
 
     @Override
     public void sendPing(byte[] payload) {
-        mWriter.forward(new Ping(payload));
+        sendMessage(new Ping(payload));
     }
 
     @Override
     public void sendPong() {
-        mWriter.forward(new Pong());
+        sendMessage(new Pong());
     }
 
     @Override
     public void sendPong(byte[] payload) {
-        mWriter.forward(new Pong(payload));
+        sendMessage(new Pong(payload));
     }
 
     @Override
@@ -257,15 +260,11 @@ private void closeUnderlyingSocket() throws IOException, InterruptedException {
     }
 
     private void closeWriterThread() {
-        if (mWriter != null) {
-            mWriter.forward(new Quit());
-            try {
-                mWriterThread.join();
-            } catch (InterruptedException e) {
-                LOGGER.v(e.getMessage(), e);
-            }
-        } else {
-            LOGGER.d("mWriter already NULL");
+        try {
+            mWriterThread.shutdown();
+            mWriterThread.awaitTermination(5, TimeUnit.SECONDS);
+        } catch (InterruptedException e) {
+            LOGGER.v(e.getMessage(), e);
         }
     }
 
@@ -408,11 +407,7 @@ public void sendClose(int code, String reason) {
         // Close the writer thread here but delay the closing of reader thread
         // as we need to have active connection to be able to process the response
         // of this close request.
-        if (mWriter != null) {
-            mWriter.forward(new Close(code, reason));
-        } else {
-            LOGGER.d("could not send Close .. writer already NULL");
-        }
+        sendMessage(new Close(code, reason));
         onCloseCalled = false;
         mActive = false;
         mPrevConnected = false;
@@ -596,6 +591,7 @@ public void handleMessage(Message msg) {
                     } else {
                         mWsHandler.onPing(ping.mPayload);
                     }
+                    LOGGER.d("WebSockets Pong sent");
 
                 } else if (msg.obj instanceof Pong) {
                     Pong pong = (Pong) msg.obj;
@@ -620,7 +616,7 @@ public void handleMessage(Message msg) {
                     } else if (mActive) {
                         // We have received a close frame, lets clean.
                         closeReaderThread(false);
-                        mWriter.forward(new Close(1000, true));
+                        WebSocketConnection.this.sendMessage(new Close(1000, true));
                         mActive = false;
                     } else {
                         LOGGER.d("WebSockets Close received (" + close.mCode + " - " + close.mReason + ")");
@@ -655,28 +651,33 @@ public void handleMessage(Message msg) {
                 } else if (msg.obj instanceof CannotConnect) {
 
                     CannotConnect cannotConnect = (CannotConnect) msg.obj;
-                    failConnection(IWebSocketConnectionHandler.CLOSE_CANNOT_CONNECT, cannotConnect.reason);
+                    failConnection(IWebSocketConnectionHandler.CLOSE_CANNOT_CONNECT,
+                            cannotConnect.reason);
 
                 } else if (msg.obj instanceof ConnectionLost) {
 
                     ConnectionLost connnectionLost = (ConnectionLost) msg.obj;
-                    failConnection(IWebSocketConnectionHandler.CLOSE_CONNECTION_LOST, connnectionLost.reason);
+                    failConnection(IWebSocketConnectionHandler.CLOSE_CONNECTION_LOST,
+                            connnectionLost.reason);
 
                 } else if (msg.obj instanceof ProtocolViolation) {
 
                     @SuppressWarnings("unused")
                     ProtocolViolation protocolViolation = (ProtocolViolation) msg.obj;
-                    failConnection(IWebSocketConnectionHandler.CLOSE_PROTOCOL_ERROR, "WebSockets protocol violation");
+                    failConnection(IWebSocketConnectionHandler.CLOSE_PROTOCOL_ERROR,
+                            "WebSockets protocol violation");
 
                 } else if (msg.obj instanceof Error) {
 
                     Error error = (Error) msg.obj;
-                    failConnection(IWebSocketConnectionHandler.CLOSE_INTERNAL_ERROR, "WebSockets internal error (" + error.mException.toString() + ")");
+                    failConnection(IWebSocketConnectionHandler.CLOSE_INTERNAL_ERROR,
+                            "WebSockets internal error (" + error.mException.toString() + ")");
 
                 } else if (msg.obj instanceof ServerError) {
 
                     ServerError error = (ServerError) msg.obj;
-                    failConnection(IWebSocketConnectionHandler.CLOSE_SERVER_ERROR, "Server error " + error.mStatusCode + " (" + error.mStatusMessage + ")");
+                    failConnection(IWebSocketConnectionHandler.CLOSE_SERVER_ERROR,
+                            "Server error " + error.mStatusCode + " (" + error.mStatusMessage + ")");
 
                 } else {
 
@@ -696,14 +697,40 @@ private void processAppMessage(Object message) {
      * Create WebSockets background writer.
      */
     private void createWriter() throws IOException {
-
-        mWriterThread = new HandlerThread("WebSocketWriter");
-        mWriterThread.start();
-        mWriter = new WebSocketWriter(mWriterThread.getLooper(), mMasterHandler, mSocket, mOptions);
-
+        mWriterThread = Executors.newSingleThreadExecutor();
+        mBufferedOutputStream = new BufferedOutputStream(mSocket.getOutputStream(),
+                mOptions.getMaxFramePayloadSize() + 14);
+        mWebSocket = new Connection(mOptions);
         LOGGER.d("WS writer created and started");
     }
 
+    private void sendMessage(io.crossbar.autobahn.websocket.messages.Message message) {
+        if (mWriterThread == null || mWriterThread.isShutdown()) {
+            return;
+        }
+        mWriterThread.submit(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    mBufferedOutputStream.write(mWebSocket.send(message));
+                    mBufferedOutputStream.flush();
+                    if (message instanceof Close) {
+                        Close msg = (Close) message;
+                        if (msg.mIsReply) {
+                            forward(message);
+                        }
+                    }
+                } catch (SocketException e) {
+                    LOGGER.d("run() : SocketException (" + e.toString() + ")");
+                    forward(new ConnectionLost(null));
+                } catch (ParseFailed | IOException e) {
+                    LOGGER.w(e.getMessage(), e);
+                    forward(new Error(e));
+                }
+            }
+        });
+    }
+
 
     /**
      * Create WebSockets background reader.
diff --git a/autobahn/src/main/java/io/crossbar/autobahn/websocket/WebSocketWriter.java b/autobahn/src/main/java/io/crossbar/autobahn/websocket/WebSocketWriter.java
deleted file mode 100644
index 65372b3..0000000
--- a/autobahn/src/main/java/io/crossbar/autobahn/websocket/WebSocketWriter.java
+++ /dev/null
@@ -1,528 +0,0 @@
-///////////////////////////////////////////////////////////////////////////////
-//
-//   AutobahnJava - http://crossbar.io/autobahn
-//
-//   Copyright (c) Crossbar.io Technologies GmbH and contributors
-//
-//   Licensed under the MIT License.
-//   http://www.opensource.org/licenses/mit-license.php
-//
-///////////////////////////////////////////////////////////////////////////////
-
-package io.crossbar.autobahn.websocket;
-
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
-import android.util.Base64;
-import android.util.Log;
-
-import java.io.BufferedOutputStream;
-import java.io.IOException;
-import java.net.Socket;
-import java.net.SocketException;
-import java.util.Random;
-
-import io.crossbar.autobahn.utils.ABLogger;
-import io.crossbar.autobahn.utils.IABLogger;
-import io.crossbar.autobahn.websocket.exceptions.WebSocketException;
-import io.crossbar.autobahn.websocket.messages.BinaryMessage;
-import io.crossbar.autobahn.websocket.messages.ClientHandshake;
-import io.crossbar.autobahn.websocket.messages.Close;
-import io.crossbar.autobahn.websocket.messages.ConnectionLost;
-import io.crossbar.autobahn.websocket.messages.Error;
-import io.crossbar.autobahn.websocket.messages.Ping;
-import io.crossbar.autobahn.websocket.messages.Pong;
-import io.crossbar.autobahn.websocket.messages.Quit;
-import io.crossbar.autobahn.websocket.messages.RawTextMessage;
-import io.crossbar.autobahn.websocket.messages.TextMessage;
-import io.crossbar.autobahn.websocket.types.WebSocketOptions;
-
-
-/**
- * WebSocket writer, the sending leg of a WebSockets connection.
- * This is run on it's background thread with it's own message loop.
- * The only method that needs to be called (from foreground thread) is forward(),
- * which is used to forward a WebSockets message to this object (running on
- * background thread) so that it can be formatted and sent out on the
- * underlying TCP socket.
- */
-class WebSocketWriter extends Handler {
-
-    private static final IABLogger LOGGER = ABLogger.getLogger(WebSocketWriter.class.getName());
-    private final static String CRLF = "\r\n";
-
-    /// Random number generator for handshake key and frame mask generation.
-    private final Random mRng = new Random();
-
-    /// Connection master.
-    private final Handler mMaster;
-
-    /// Message looper this object is running on.
-    private final Looper mLooper;
-
-    /// WebSockets options.
-    private final WebSocketOptions mOptions;
-
-    /// The send buffer that holds data to send on socket.
-    private BufferedOutputStream mBufferedOutputStream;
-
-    /// The tcp socket
-    private Socket mSocket;
-
-    /// Is Active.
-    private boolean mActive;
-
-
-    /**
-     * Create new WebSockets background writer.
-     *
-     * @param looper  The message looper of the background thread on which
-     *                this object is running.
-     * @param master  The message handler of master (foreground thread).
-     * @param socket  The socket channel created on foreground thread.
-     * @param options WebSockets connection options.
-     */
-    public WebSocketWriter(Looper looper, Handler master, Socket socket, WebSocketOptions options) throws IOException {
-
-        super(looper);
-
-        mLooper = looper;
-        mMaster = master;
-        mOptions = options;
-        mSocket = socket;
-        mBufferedOutputStream = new BufferedOutputStream(socket.getOutputStream(), options.getMaxFramePayloadSize() + 14);
-        mActive = true;
-
-        LOGGER.d("Created");
-    }
-
-    private void write(String stringToWrite) {
-        try {
-            mBufferedOutputStream.write(stringToWrite.getBytes("UTF-8"));
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-    }
-
-    private void write(byte byteToWrite) {
-        try {
-            mBufferedOutputStream.write(byteToWrite);
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-    }
-
-    private void write(byte[] bytesToWrite) {
-        try {
-            mBufferedOutputStream.write(bytesToWrite);
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-    }
-
-    /**
-     * Call this from the foreground (UI) thread to make the writer
-     * (running on background thread) send a WebSocket message on the
-     * underlying TCP.
-     *
-     * @param message Message to send to WebSockets writer. An instance of a subclass of
-     *                Message  or another type which then needs to be handled within
-     *                processAppMessage() (in a class derived from this class).
-     */
-    public void forward(Object message) {
-        // We have already quit, we are no longer sending messages.
-        if (!mActive) {
-            LOGGER.d("We have already quit, not processing further messages");
-            return;
-        }
-        Message msg = obtainMessage();
-        msg.obj = message;
-        sendMessage(msg);
-    }
-
-
-    /**
-     * Notify the master (foreground thread).
-     *
-     * @param message Message to send to master.
-     */
-    private void notify(Object message) {
-
-        Message msg = mMaster.obtainMessage();
-        msg.obj = message;
-        mMaster.sendMessage(msg);
-    }
-
-
-    /**
-     * Create new key for WebSockets handshake.
-     *
-     * @return WebSockets handshake key (Base64 encoded).
-     */
-    private String newHandshakeKey() {
-        final byte[] ba = new byte[16];
-        mRng.nextBytes(ba);
-        return Base64.encodeToString(ba, Base64.NO_WRAP);
-    }
-
-
-    /**
-     * Create new (random) frame mask.
-     *
-     * @return Frame mask (4 octets).
-     */
-    private byte[] newFrameMask() {
-        final byte[] ba = new byte[4];
-        mRng.nextBytes(ba);
-        return ba;
-    }
-
-
-    /**
-     * Send WebSocket client handshake.
-     */
-    private void sendClientHandshake(ClientHandshake message) throws IOException {
-
-        // write HTTP header with handshake
-        String path;
-        if (message.mQuery != null) {
-            path = message.mPath + "?" + message.mQuery;
-        } else {
-            path = message.mPath;
-        }
-        write("GET " + path + " HTTP/1.1");
-        write(CRLF);
-        write("Host: " + message.mHost);
-        write(CRLF);
-        write("Upgrade: WebSocket");
-        write(CRLF);
-        write("Connection: Upgrade");
-        write(CRLF);
-
-        write("Sec-WebSocket-Key: " + newHandshakeKey());
-        write(CRLF);
-
-        if (message.mOrigin != null && !message.mOrigin.equals("")) {
-            write("Origin: " + message.mOrigin);
-            write(CRLF);
-        }
-
-        if (message.mSubprotocols != null && message.mSubprotocols.length > 0) {
-            write("Sec-WebSocket-Protocol: ");
-            for (int i = 0; i < message.mSubprotocols.length; ++i) {
-                write(message.mSubprotocols[i]);
-                if (i != message.mSubprotocols.length - 1) {
-                    write(", ");
-                }
-            }
-            write(CRLF);
-        }
-
-        write("Sec-WebSocket-Version: 13");
-        write(CRLF);
-
-        // Header injection
-        if (message.mHeaderList != null) {
-            for (String key : message.mHeaderList.keySet()) {
-                write(key + ":" + message.mHeaderList.get(key));
-                write(CRLF);
-            }
-        }
-        write(CRLF);
-    }
-
-
-    /**
-     * Send WebSockets close.
-     */
-    private void sendClose(Close message) throws IOException, WebSocketException {
-
-        if (message.mCode > 0) {
-
-            byte[] payload;
-
-            if (message.mReason != null && !message.mReason.equals("")) {
-                byte[] pReason = message.mReason.getBytes("UTF-8");
-                payload = new byte[2 + pReason.length];
-                for (int i = 0; i < pReason.length; ++i) {
-                    payload[i + 2] = pReason[i];
-                }
-            } else {
-                payload = new byte[2];
-            }
-
-            if (payload != null && payload.length > 125) {
-                throw new WebSocketException("close payload exceeds 125 octets");
-            }
-
-            payload[0] = (byte) ((message.mCode >> 8) & 0xff);
-            payload[1] = (byte) (message.mCode & 0xff);
-
-            sendFrame(8, true, payload);
-
-        } else {
-
-            sendFrame(8, true, null);
-        }
-    }
-
-
-    /**
-     * Send WebSockets ping.
-     */
-    private void sendPing(Ping message) throws IOException, WebSocketException {
-        if (message.mPayload != null && message.mPayload.length > 125) {
-            throw new WebSocketException("ping payload exceeds 125 octets");
-        }
-        sendFrame(9, true, message.mPayload);
-    }
-
-
-    /**
-     * Send WebSockets pong. Normally, unsolicited Pongs are not used,
-     * but Pongs are only send in response to a Ping from the peer.
-     */
-    private void sendPong(Pong message) throws IOException, WebSocketException {
-        if (message.mPayload != null && message.mPayload.length > 125) {
-            throw new WebSocketException("pong payload exceeds 125 octets");
-        }
-        sendFrame(10, true, message.mPayload);
-        LOGGER.d("WebSockets Pong Sent");
-    }
-
-
-    /**
-     * Send WebSockets binary message.
-     */
-    private void sendBinaryMessage(BinaryMessage message) throws IOException, WebSocketException {
-        if (message.mPayload.length > mOptions.getMaxMessagePayloadSize()) {
-            throw new WebSocketException("message payload exceeds payload limit");
-        }
-        sendFrame(2, true, message.mPayload);
-    }
-
-
-    /**
-     * Send WebSockets text message.
-     */
-    private void sendTextMessage(TextMessage message) throws IOException, WebSocketException {
-        byte[] payload = message.mPayload.getBytes("UTF-8");
-        if (payload.length > mOptions.getMaxMessagePayloadSize()) {
-            throw new WebSocketException("message payload exceeds payload limit");
-        }
-        sendFrame(1, true, payload);
-    }
-
-
-    /**
-     * Send WebSockets binary message.
-     */
-    private void sendRawTextMessage(RawTextMessage message) throws IOException, WebSocketException {
-        if (message.mPayload.length > mOptions.getMaxMessagePayloadSize()) {
-            throw new WebSocketException("message payload exceeds payload limit");
-        }
-        sendFrame(1, true, message.mPayload);
-    }
-
-
-    /**
-     * Sends a WebSockets frame. Only need to use this method in derived classes which implement
-     * more message types in processAppMessage(). You need to know what you are doing!
-     *
-     * @param opcode  The WebSocket frame opcode.
-     * @param fin     FIN flag for WebSocket frame.
-     * @param payload Frame payload or null.
-     */
-    protected void sendFrame(int opcode, boolean fin, byte[] payload) throws IOException {
-        if (payload != null) {
-            sendFrame(opcode, fin, payload, 0, payload.length);
-        } else {
-            sendFrame(opcode, fin, null, 0, 0);
-        }
-    }
-
-
-    /**
-     * Sends a WebSockets frame. Only need to use this method in derived classes which implement
-     * more message types in processAppMessage(). You need to know what you are doing!
-     *
-     * @param opcode  The WebSocket frame opcode.
-     * @param fin     FIN flag for WebSocket frame.
-     * @param payload Frame payload or null.
-     * @param offset  Offset within payload of the chunk to send.
-     * @param length  Length of the chunk within payload to send.
-     */
-    protected void sendFrame(int opcode, boolean fin, byte[] payload, int offset, int length) throws IOException {
-
-        // first octet
-        byte b0 = 0;
-        if (fin) {
-            b0 |= (byte) (1 << 7);
-        }
-        b0 |= (byte) opcode;
-        write(b0);
-
-        // second octet
-        byte b1 = 0;
-        if (mOptions.getMaskClientFrames()) {
-            b1 = (byte) (1 << 7);
-        }
-
-        long len = length;
-
-        // extended payload length
-        if (len <= 125) {
-            b1 |= (byte) len;
-            write(b1);
-        } else if (len <= 0xffff) {
-            b1 |= (byte) (126 & 0xff);
-            write(b1);
-            write(new byte[]{(byte) ((len >> 8) & 0xff),
-                    (byte) (len & 0xff)});
-        } else {
-            b1 |= (byte) (127 & 0xff);
-            write(b1);
-            write(new byte[]{(byte) ((len >> 56) & 0xff),
-                    (byte) ((len >> 48) & 0xff),
-                    (byte) ((len >> 40) & 0xff),
-                    (byte) ((len >> 32) & 0xff),
-                    (byte) ((len >> 24) & 0xff),
-                    (byte) ((len >> 16) & 0xff),
-                    (byte) ((len >> 8) & 0xff),
-                    (byte) (len & 0xff)});
-        }
-
-        byte mask[] = null;
-        if (mOptions.getMaskClientFrames()) {
-            // a mask is always needed, even without payload
-            mask = newFrameMask();
-            write(mask[0]);
-            write(mask[1]);
-            write(mask[2]);
-            write(mask[3]);
-        }
-
-        if (len > 0) {
-            if (mOptions.getMaskClientFrames()) {
-                /// \todo optimize masking
-                /// \todo masking within buffer of output stream
-                for (int i = 0; i < len; ++i) {
-                    payload[i + offset] ^= mask[i % 4];
-                }
-            }
-            mBufferedOutputStream.write(payload, offset, length);
-        }
-    }
-
-
-    /**
-     * Process message received from foreground thread. This is called from
-     * the message looper set up for the background thread running this writer.
-     *
-     * @param msg Message from thread message queue.
-     */
-    @Override
-    public void handleMessage(Message msg) {
-
-        try {
-
-            // process message from master
-            processMessage(msg.obj);
-
-            // send out buffered data
-
-            if (mActive && mSocket.isConnected() && !mSocket.isClosed()) {
-                mBufferedOutputStream.flush();
-            }
-
-            // Check if the message that we sent was a close frame and was a reply
-            // to a closing handshake, if so, then notify master to close the socket.
-            if (msg.obj instanceof Close) {
-                Close closeMessage = (Close) msg.obj;
-                if (closeMessage.mIsReply) {
-                    notify(new Close(closeMessage.mCode, closeMessage.mReason, true));
-                }
-            }
-
-
-        } catch (SocketException e) {
-
-            LOGGER.d("run() : SocketException (" + e.toString() + ")");
-
-            // wrap the exception and notify master
-            notify(new ConnectionLost(null));
-        } catch (Exception e) {
-
-            LOGGER.w(e.getMessage(), e);
-
-            // wrap the exception and notify master
-            notify(new Error(e));
-        }
-    }
-
-
-    /**
-     * Process WebSockets or control message from master. Normally,
-     * there should be no reason to override this. If you do, you
-     * need to know what you are doing.
-     *
-     * @param msg An instance of the Message subclass or a message
-     *            that is handled in processAppMessage().
-     */
-    protected void processMessage(Object msg) throws IOException, WebSocketException {
-
-        if (msg instanceof TextMessage) {
-
-            sendTextMessage((TextMessage) msg);
-
-        } else if (msg instanceof RawTextMessage) {
-
-            sendRawTextMessage((RawTextMessage) msg);
-
-        } else if (msg instanceof BinaryMessage) {
-
-            sendBinaryMessage((BinaryMessage) msg);
-
-        } else if (msg instanceof Ping) {
-
-            sendPing((Ping) msg);
-
-        } else if (msg instanceof Pong) {
-
-            sendPong((Pong) msg);
-
-        } else if (msg instanceof Close) {
-
-            sendClose((Close) msg);
-
-        } else if (msg instanceof ClientHandshake) {
-            sendClientHandshake((ClientHandshake) msg);
-
-        } else if (msg instanceof Quit) {
-
-            mLooper.quit();
-            mActive = false;
-
-            LOGGER.d("Ended");
-
-        } else {
-
-            // call hook which may be overridden in derived class to process
-            // messages we don't understand in this class
-            processAppMessage(msg);
-        }
-    }
-
-
-    /**
-     * Process message other than plain WebSockets or control message.
-     * This is intended to be overridden in derived classes.
-     *
-     * @param msg Message from foreground thread to process.
-     */
-    protected void processAppMessage(Object msg) throws WebSocketException, IOException {
-
-        throw new WebSocketException("unknown message received by WebSocketWriter");
-    }
-}
diff --git a/autobahn/src/main/java/io/crossbar/autobahn/websocket/exceptions/ParseFailed.java b/autobahn/src/main/java/io/crossbar/autobahn/websocket/exceptions/ParseFailed.java
new file mode 100644
index 0000000..be9a45a
--- /dev/null
+++ b/autobahn/src/main/java/io/crossbar/autobahn/websocket/exceptions/ParseFailed.java
@@ -0,0 +1,19 @@
+///////////////////////////////////////////////////////////////////////////////
+//
+//   AutobahnJava - http://crossbar.io/autobahn
+//
+//   Copyright (c) Crossbar.io Technologies GmbH and contributors
+//
+//   Licensed under the MIT License.
+//   http://www.opensource.org/licenses/mit-license.php
+//
+///////////////////////////////////////////////////////////////////////////////
+
+package io.crossbar.autobahn.websocket.exceptions;
+
+public class ParseFailed extends Exception {
+
+    public ParseFailed(String message) {
+        super(message);
+    }
+}
diff --git a/autobahn/src/main/java/xbr/network/KeySeries.java b/autobahn/src/main/java/xbr/network/KeySeries.java
new file mode 100644
index 0000000..c245a60
--- /dev/null
+++ b/autobahn/src/main/java/xbr/network/KeySeries.java
@@ -0,0 +1,4 @@
+package xbr.network;
+
+public class KeySeries {
+}
diff --git a/autobahn/src/main/java/xbr/network/SealedBox.java b/autobahn/src/main/java/xbr/network/SealedBox.java
new file mode 100644
index 0000000..73cbd43
--- /dev/null
+++ b/autobahn/src/main/java/xbr/network/SealedBox.java
@@ -0,0 +1,59 @@
+package xbr.network;
+
+import org.libsodium.jni.encoders.Encoder;
+
+import static org.libsodium.jni.NaCl.sodium;
+import static org.libsodium.jni.SodiumConstants.PUBLICKEY_BYTES;
+import static org.libsodium.jni.crypto.Util.isValid;
+
+public class SealedBox {
+
+    private static final int MAC_BYTES = 16;
+    private static final int SEAL_BYTES = PUBLICKEY_BYTES + MAC_BYTES;
+
+    private byte[] publicKey;
+    private byte[] privateKey;
+
+    public SealedBox(byte[] publicKey) {
+        if (publicKey == null) {
+            throw new IllegalArgumentException("Public key must not be null");
+        }
+        this.publicKey = publicKey;
+        this.privateKey = null;
+    }
+
+    public SealedBox(String publicKey, Encoder encoder) {
+        this(encoder.decode(publicKey));
+    }
+
+    public SealedBox(byte[] publicKey, byte[] privateKey) {
+        if (publicKey == null) {
+            throw new IllegalArgumentException("Public key must not be null");
+        }
+        if (privateKey == null) {
+            throw new IllegalArgumentException("Private key must not be null");
+        }
+        this.publicKey = publicKey;
+        this.privateKey = privateKey;
+    }
+
+    public SealedBox(String publicKey, String privateKey, Encoder encoder) {
+        this(encoder.decode(publicKey), encoder.decode(privateKey));
+    }
+
+    public byte[] encrypt(byte[] message) {
+        byte[] ct = new byte[message.length + SEAL_BYTES];
+        isValid(sodium().crypto_box_seal(
+                ct, message, message.length, publicKey),
+                "Encryption failed");
+        return ct;
+    }
+
+    public byte[] decrypt(byte[] ciphertext) {
+        byte[] message = new byte[ciphertext.length - SEAL_BYTES];
+        isValid(sodium().crypto_box_seal_open(
+                message, ciphertext, ciphertext.length, publicKey, privateKey),
+                "Decryption failed. Ciphertext failed verification");
+        return message;
+    }
+}
diff --git a/autobahn/src/main/java/xbr/network/SimpleBuyer.java b/autobahn/src/main/java/xbr/network/SimpleBuyer.java
new file mode 100644
index 0000000..576af71
--- /dev/null
+++ b/autobahn/src/main/java/xbr/network/SimpleBuyer.java
@@ -0,0 +1,167 @@
+package xbr.network;
+
+
+import com.fasterxml.jackson.core.type.TypeReference;
+
+import org.ethereum.crypto.ECKey;
+import org.ethereum.crypto.HashUtil;
+import org.libsodium.jni.SodiumConstants;
+import org.spongycastle.util.encoders.Hex;
+
+import java.security.SecureRandom;
+import java.util.HashMap;
+import java.util.concurrent.CompletableFuture;
+
+import io.crossbar.autobahn.wamp.Session;
+
+import static org.libsodium.jni.NaCl.sodium;
+
+public class SimpleBuyer {
+
+    private final String mEthPrivateKey;
+    private final String mEthPublicKey;
+    private final int mMaxPrice;
+    private final byte[] mPrivateKey;
+    private final byte[] mPublicKey;
+    private final ECKey mECKey;
+
+    private HashMap<String, String> mKeys;
+    private Session mSession;
+    private boolean mRunning;
+
+    private long mRemainingBalance;
+    private HashMap<String, Object> mChannel;
+
+    public SimpleBuyer(String buyerKey, int maxPrice) {
+        byte[] privatekey = Hex.decode(buyerKey);
+        mECKey = ECKey.fromPrivate(privatekey);
+        mEthPrivateKey = Hex.toHexString(mECKey.getPrivKeyBytes());
+        mEthPublicKey = Hex.toHexString(ECKey.publicKeyFromPrivate(mECKey.getPrivKey(), false));
+        mMaxPrice = maxPrice;
+        mKeys = new HashMap<>();
+
+        mPrivateKey = new byte[SodiumConstants.SECRETKEY_BYTES];
+        mPublicKey = new byte[SodiumConstants.PUBLICKEY_BYTES];
+        sodium().crypto_box_keypair(mPublicKey, mPrivateKey);
+    }
+
+    public CompletableFuture<Long> start(Session session, long consumerID) {
+        CompletableFuture<Long> future = new CompletableFuture<>();
+        if (mRunning) {
+            throw new IllegalStateException("Already running...");
+        }
+
+        mSession = session;
+        mRunning = true;
+
+        CompletableFuture<HashMap<String, Object>> callFuture = session.call(
+                "xbr.marketmaker.get_payment_channel",
+                new TypeReference<HashMap<String, Object>>() {},
+                mECKey.getAddress());
+        callFuture.whenComplete((result, throwable) -> {
+            if (throwable != null) {
+                throwable.printStackTrace();
+            } else {
+                mChannel = result;
+                mRemainingBalance = (int) result.get("remaining");
+                future.complete(mRemainingBalance);
+            }
+        });
+        return future;
+    }
+
+    public void stop() {
+        if (!mRunning) {
+            throw new IllegalStateException("Already stopped...");
+        }
+        mRunning = false;
+    }
+
+    public CompletableFuture<HashMap<String, Object>> balance() {
+        CompletableFuture<HashMap<String, Object>> future = new CompletableFuture<>();
+
+        if (mSession == null || !mSession.isConnected()) {
+            throw new IllegalStateException("Session not connected");
+        }
+
+        CompletableFuture<HashMap<String, Object>> callFuture = mSession.call(
+                "xbr.marketmaker.get_payment_channel",
+                new TypeReference<HashMap<String, Object>>() {},
+                mECKey.getAddress());
+        callFuture.whenComplete((result, throwable) -> {
+            if (throwable != null) {
+                throwable.printStackTrace();
+            } else {
+                HashMap<String, Object> res = new HashMap<>();
+                res.put("amount", result.get("amount"));
+                res.put("remaining", result.get("remaining"));
+                res.put("inflight", result.get("inflight"));
+                future.complete(res);
+            }
+        });
+
+        return future;
+    }
+
+    public CompletableFuture<HashMap<String, Object>> openChannel(byte[] buyerAddr, long amount) {
+        CompletableFuture<HashMap<String, Object>> future = new CompletableFuture<>();
+
+        if (mSession == null || !mSession.isConnected()) {
+            throw new IllegalStateException("Session not connected");
+        }
+
+        CompletableFuture<HashMap<String, Object>> callFuture = mSession.call(
+                "xbr.marketmaker.open_payment_channel",
+                new TypeReference<HashMap<String, Object>>() {},
+                buyerAddr,
+                mECKey.getAddress(),
+                amount,
+                new SecureRandom(new byte[64]));
+        callFuture.whenComplete((result, throwable) -> {
+            if (throwable != null) {
+                throwable.printStackTrace();
+            } else {
+                HashMap<String, Object> res = new HashMap<>();
+                res.put("amount", result.get("amount"));
+                res.put("remaining", result.get("remaining"));
+                res.put("inflight", result.get("inflight"));
+                future.complete(res);
+            }
+        });
+
+
+        return future;
+    }
+
+    public void closeChannel() {
+
+    }
+
+    public CompletableFuture<String> unwrap(byte[] keyID, String encSerializer, String ciphertext) {
+        CompletableFuture<String> future = new CompletableFuture<>();
+        if (!mKeys.containsKey(keyID)) {
+            int amount = mMaxPrice;
+            byte[] signature = new byte[64];
+            HashUtil.sha256(signature);
+            byte[] key = new byte[16];
+            sodium().randombytes(key, 16);
+
+            CompletableFuture<HashMap<String, Object>> callFuture = mSession.call(
+                    "xbr.marketmaker.buy_key",
+                    new TypeReference<HashMap<String, Object>>() {},
+                    mECKey.getAddress(),
+                    mPublicKey,
+                    key,
+                    amount,
+                    signature);
+            callFuture.whenComplete((stringObjectHashMap, throwable) -> {
+                if (throwable != null) {
+                    throwable.printStackTrace();
+                } else {
+                    System.out.println(stringObjectHashMap);
+                }
+            });
+        }
+        return future;
+    }
+}
diff --git a/autobahn/src/main/java/xbr/network/SimpleSeller.java b/autobahn/src/main/java/xbr/network/SimpleSeller.java
new file mode 100644
index 0000000..d0bc6e0
--- /dev/null
+++ b/autobahn/src/main/java/xbr/network/SimpleSeller.java
@@ -0,0 +1,43 @@
+package xbr.network;
+
+import org.ethereum.crypto.ECKey;
+import org.spongycastle.util.encoders.Hex;
+
+import java.util.HashMap;
+
+import io.crossbar.autobahn.wamp.Session;
+import io.crossbar.autobahn.wamp.exceptions.ApplicationError;
+
+import static org.libsodium.jni.encoders.Encoder.HEX;
+
+public class SimpleSeller {
+    private final String mEthPrivateKey;
+    private final String mEthPublicKey;
+    private final ECKey mECKey;
+
+    private HashMap<String, String> mKeys;
+    private HashMap<byte[], byte[]> mKeysMap;
+    private Session mSession;
+    private boolean mRunning;
+
+    private long mRemainingBalance;
+    private HashMap<String, Object> mChannel;
+
+    public SimpleSeller(String sellerKey) {
+        byte[] privatekey = Hex.decode(sellerKey);
+        mECKey = ECKey.fromPrivate(privatekey);
+        mEthPrivateKey = Hex.toHexString(mECKey.getPrivKeyBytes());
+        mEthPublicKey = Hex.toHexString(ECKey.publicKeyFromPrivate(mECKey.getPrivKey(), false));
+
+        mKeys = new HashMap<>();
+        mKeysMap = new HashMap<>();
+    }
+
+    public String sell(byte[] keyID, byte[] buyerPubKey) {
+        if (!mKeysMap.containsKey(keyID)) {
+            throw new ApplicationError("crossbar.error.no_such_object", null, null);
+        }
+        SealedBox box = new SealedBox(buyerPubKey);
+        return HEX.encode(box.encrypt(mKeysMap.get(keyID)));
+    }
+}
diff --git a/build.gradle b/build.gradle
index b3283fe..0549bf1 100644
--- a/build.gradle
+++ b/build.gradle
@@ -32,5 +32,6 @@ allprojects {
     repositories {
         google()
         jcenter()
+        maven { url "https://dl.bintray.com/ethereum/maven/" }
     }
 }
diff --git a/demo-gallery/build.gradle b/demo-gallery/build.gradle
index adf0de3..2ab6345 100644
--- a/demo-gallery/build.gradle
+++ b/demo-gallery/build.gradle
@@ -28,6 +28,13 @@ if (plugins.hasPlugin(project.PLUGIN_ANDROID_APP)) {
                 }
             }
         }
+        packagingOptions {
+            exclude 'META-INF/spring.tooling'
+            exclude 'META-INF/spring.handlers'
+            exclude 'META-INF/spring.schemas'
+            exclude 'META-INF/license.txt'
+            exclude 'META-INF/notice.txt'
+        }
     }
 
     dependencies {
