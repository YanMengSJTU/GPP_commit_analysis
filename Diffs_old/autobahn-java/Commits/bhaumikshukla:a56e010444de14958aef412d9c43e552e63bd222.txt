diff --git a/Autobahn/src/de/tavendo/autobahn/Wamp.java b/Autobahn/src/de/tavendo/autobahn/Wamp.java
index 4e091ab..55a65e1 100644
--- a/Autobahn/src/de/tavendo/autobahn/Wamp.java
+++ b/Autobahn/src/de/tavendo/autobahn/Wamp.java
@@ -20,7 +20,6 @@
 
 
 import java.util.List;
-
 import org.apache.http.message.BasicNameValuePair;
 import org.codehaus.jackson.type.TypeReference;
 
@@ -79,7 +78,6 @@
     */
    public void connect(String wsUri, ConnectionHandler sessionHandler, List<BasicNameValuePair> headers);
 
-   
 
    /**
     * Connect to WAMP server.
diff --git a/Autobahn/src/de/tavendo/autobahn/WampConnection.java b/Autobahn/src/de/tavendo/autobahn/WampConnection.java
index 8361751..487006c 100644
--- a/Autobahn/src/de/tavendo/autobahn/WampConnection.java
+++ b/Autobahn/src/de/tavendo/autobahn/WampConnection.java
@@ -30,420 +30,423 @@
 
 public class WampConnection extends WebSocketConnection implements Wamp {
 
-	private static final boolean DEBUG = true;
-	private static final String TAG = WampConnection.class.getName();
+   private static final boolean DEBUG = true;
+   private static final String TAG = WampConnection.class.getName();
 
 
-	/// The message handler of the background writer.
-	protected WampWriter mWriterHandler;
+   /// The message handler of the background writer.
+   protected WampWriter mWriterHandler;
 
-	/// Prefix map for outgoing messages.
-	private final PrefixMap mOutgoingPrefixes = new PrefixMap();
+   /// Prefix map for outgoing messages.
+   private final PrefixMap mOutgoingPrefixes = new PrefixMap();
 
-	/// RNG for IDs.
-	private final Random mRng = new Random();
+   /// RNG for IDs.
+   private final Random mRng = new Random();
 
-	/// Set of chars to be used for IDs.
-	private static final char[] mBase64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
-			.toCharArray();
+   /// Set of chars to be used for IDs.
+   private static final char[] mBase64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
+         .toCharArray();
 
-	/**
-	 * RPC metadata.
-	 */
-	public static class CallMeta {
+   /**
+    * RPC metadata.
+    */
+   public static class CallMeta {
 
-		CallMeta(CallHandler handler, Class<?> resultClass) {
-			this.mResultHandler = handler;
-			this.mResultClass = resultClass;
-			this.mResultTypeRef = null;
-		}
-
-		CallMeta(CallHandler handler, TypeReference<?> resultTypeReference) {
-			this.mResultHandler = handler;
-			this.mResultClass = null;
-			this.mResultTypeRef = resultTypeReference;
-		}
+      CallMeta(CallHandler handler, Class<?> resultClass) {
+         this.mResultHandler = handler;
+         this.mResultClass = resultClass;
+         this.mResultTypeRef = null;
+      }
+
+      CallMeta(CallHandler handler, TypeReference<?> resultTypeReference) {
+         this.mResultHandler = handler;
+         this.mResultClass = null;
+         this.mResultTypeRef = resultTypeReference;
+      }
 
-		/// Call handler to be fired on.
-		public CallHandler mResultHandler;
+      /// Call handler to be fired on.
+      public CallHandler mResultHandler;
 
-		/// Desired call result type or null.
-		public Class<?> mResultClass;
+      /// Desired call result type or null.
+      public Class<?> mResultClass;
 
-		/// Desired call result type or null.
-		public TypeReference<?> mResultTypeRef;
-	}
+      /// Desired call result type or null.
+      public TypeReference<?> mResultTypeRef;
+   }
 
-	/// Metadata about issued, but not yet returned RPCs.
-	private final ConcurrentHashMap<String, CallMeta> mCalls = new ConcurrentHashMap<String, CallMeta>();
+   /// Metadata about issued, but not yet returned RPCs.
+   private final ConcurrentHashMap<String, CallMeta> mCalls = new ConcurrentHashMap<String, CallMeta>();
 
-	/**
-	 * Event subscription metadata.
-	 */
-	public static class SubMeta {
+   /**
+    * Event subscription metadata.
+    */
+   public static class SubMeta {
 
-		SubMeta(EventHandler handler, Class<?> resultClass) {
-			this.mEventHandler = handler;
-			this.mEventClass = resultClass;
-			this.mEventTypeRef = null;
-		}
+      SubMeta(EventHandler handler, Class<?> resultClass) {
+         this.mEventHandler = handler;
+         this.mEventClass = resultClass;
+         this.mEventTypeRef = null;
+      }
 
-		SubMeta(EventHandler handler, TypeReference<?> resultTypeReference) {
-			this.mEventHandler = handler;
-			this.mEventClass = null;
-			this.mEventTypeRef = resultTypeReference;
-		}
+      SubMeta(EventHandler handler, TypeReference<?> resultTypeReference) {
+         this.mEventHandler = handler;
+         this.mEventClass = null;
+         this.mEventTypeRef = resultTypeReference;
+      }
 
-		/// Event handler to be fired on.
-		public EventHandler mEventHandler;
+      /// Event handler to be fired on.
+      public EventHandler mEventHandler;
 
-		/// Desired event type or null.
-		public Class<?> mEventClass;
+      /// Desired event type or null.
+      public Class<?> mEventClass;
 
-		/// Desired event type or null.
-		public TypeReference<?> mEventTypeRef;
-	}
+      /// Desired event type or null.
+      public TypeReference<?> mEventTypeRef;
+   }
+
+   /// Metadata about active event subscriptions.
+   private final ConcurrentHashMap<String, SubMeta> mSubs = new ConcurrentHashMap<String, SubMeta>();
+
+   /// The session handler provided to connect().
+   private Wamp.ConnectionHandler mSessionHandler;
+
+
+   /**
+    * Create the connection transmitting leg writer.
+    */
+   protected void createWriter() {
+
+      mWriterThread = new HandlerThread("AutobahnWriter");
+      mWriterThread.start();
+      mWriter = new WampWriter(mWriterThread.getLooper(), mMasterHandler, mTransportChannel, mOptions);
+
+      if (DEBUG) Log.d(TAG, "writer created and started");
+   }
+
+
+   /**
+    * Create the connection receiving leg reader.
+    */
+   protected void createReader() {
+      mReader = new WampReader(mCalls, mSubs, mMasterHandler, mTransportChannel, mOptions, "AutobahnReader");
+      mReader.start();
+
+      if (DEBUG) Log.d(TAG, "reader created and started");
+   }
+
+
+   /**
+    * Create new random ID. This is used, i.e. for use in RPC calls to correlate
+    * call message with result message.
+    *
+    * @param len    Length of ID.
+    * @return       New random ID of given length.
+    */
+   private String newId(int len) {
+      char[] buffer = new char[len];
+      for (int i = 0; i < len; i++) {
+         buffer[i] = mBase64Chars[mRng.nextInt(mBase64Chars.length)];
+      }
+      return new String(buffer);
+   }
+
+
+   /**
+    * Create new random ID of default length.
+    *
+    * @return    New random ID of default length.
+    */
+   private String newId() {
+      return newId(8);
+   }
 
-	/// Metadata about active event subscriptions.
-	private final ConcurrentHashMap<String, SubMeta> mSubs = new ConcurrentHashMap<String, SubMeta>();
 
-	/// The session handler provided to connect().
-	private Wamp.ConnectionHandler mSessionHandler;
+   public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler) {
 
+      WampOptions options = new WampOptions();
+      options.setReceiveTextMessagesRaw(true);
+      options.setMaxMessagePayloadSize(64*1024);
+      options.setMaxFramePayloadSize(64*1024);
+      options.setTcpNoDelay(true);
+
+      connect(wsUri, sessionHandler, options, null);
+   }
+
+
+   /**
+    * Connect to server.
+    *
+    * @param wsUri            WebSockets server URI.
+    * @param sessionHandler   The session handler to fire callbacks on.
+    * @param headers		   The headers for connection
+    */
+   public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler, WampOptions options, List<BasicNameValuePair> headers) {
+
+      mSessionHandler = sessionHandler;
+
+      mCalls.clear();
+      mSubs.clear();
+      mOutgoingPrefixes.clear();
 
-	/**
-	 * Create the connection transmitting leg writer.
-	 */
-	protected void createWriter() {
+      try {
+         connect(wsUri, new String[] {"wamp"}, new WebSocketConnectionHandler() {
 
-		mWriterThread = new HandlerThread("AutobahnWriter");
-		mWriterThread.start();
-		mWriter = new WampWriter(mWriterThread.getLooper(), mMasterHandler, mTransportChannel, mOptions);
-
-		if (DEBUG) Log.d(TAG, "writer created and started");
-	}
-
-
-	/**
-	 * Create the connection receiving leg reader.
-	 */
-	protected void createReader() {
-		mReader = new WampReader(mCalls, mSubs, mMasterHandler, mTransportChannel, mOptions, "AutobahnReader");
-		mReader.start();
-
-		if (DEBUG) Log.d(TAG, "reader created and started");
-	}
-
-
-	/**
-	 * Create new random ID. This is used, i.e. for use in RPC calls to correlate
-	 * call message with result message.
-	 *
-	 * @param len    Length of ID.
-	 * @return       New random ID of given length.
-	 */
-	private String newId(int len) {
-		char[] buffer = new char[len];
-		for (int i = 0; i < len; i++) {
-			buffer[i] = mBase64Chars[mRng.nextInt(mBase64Chars.length)];
-		}
-		return new String(buffer);
-	}
-
-
-	/**
-	 * Create new random ID of default length.
-	 *
-	 * @return    New random ID of default length.
-	 */
-	private String newId() {
-		return newId(8);
-	}
+            @Override
+            public void onOpen() {
+               if (mSessionHandler != null) {
+                  mSessionHandler.onOpen();
+               } else {
+                  if (DEBUG) Log.d(TAG, "could not call onOpen() .. handler already NULL");
+               }
+            }
 
+            @Override
+            public void onClose(int code, String reason) {
+               if (mSessionHandler != null) {
+                  mSessionHandler.onClose(code, reason);
+               } else {
+                  if (DEBUG) Log.d(TAG, "could not call onClose() .. handler already NULL");
+               }
+            }
+
+         }, options, headers);
+
+      } catch (WebSocketException e) {
+
+         if (mSessionHandler != null) {
+            mSessionHandler.onClose(WebSocketConnectionHandler.CLOSE_CANNOT_CONNECT, "cannot connect (" + e.toString() + ")");
+         } else {
+            if (DEBUG) Log.d(TAG, "could not call onClose() .. handler already NULL");
+         }
+      }
+
+   }
+	
+   public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler, List<BasicNameValuePair> headers) {
+
+	   WampOptions options = new WampOptions();
+	   options.setReceiveTextMessagesRaw(true);
+	   options.setMaxMessagePayloadSize(64*1024);
+	   options.setMaxFramePayloadSize(64*1024);
+	   options.setTcpNoDelay(true);
+
+	   connect(wsUri, sessionHandler, options, headers);
+   }
+
+   public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler, WampOptions options) {	
+
+	   connect(wsUri, sessionHandler, options, null);
+   }
+
+
+   /**
+    * Process WAMP messages coming from the background reader.
+    */
+   protected void processAppMessage(Object message) {
+
+      if (message instanceof WampMessage.CallResult) {
+
+         WampMessage.CallResult callresult = (WampMessage.CallResult) message;
+
+         if (mCalls.containsKey(callresult.mCallId)) {
+            CallMeta meta = mCalls.get(callresult.mCallId);
+            if (meta.mResultHandler != null) {
+               meta.mResultHandler.onResult(callresult.mResult);
+            }
+            mCalls.remove(callresult.mCallId);
+         }
+
+      } else if (message instanceof WampMessage.CallError) {
+
+         WampMessage.CallError callerror = (WampMessage.CallError) message;
+
+         if (mCalls.containsKey(callerror.mCallId)) {
+            CallMeta meta = mCalls.get(callerror.mCallId);
+            if (meta.mResultHandler != null) {
+               meta.mResultHandler.onError(callerror.mErrorUri, callerror.mErrorDesc);
+            }
+            mCalls.remove(callerror.mCallId);
+         }
+      } else if (message instanceof WampMessage.Event) {
+
+         WampMessage.Event event = (WampMessage.Event) message;
+
+         if (mSubs.containsKey(event.mTopicUri)) {
+            SubMeta meta = mSubs.get(event.mTopicUri);
+            if (meta != null && meta.mEventHandler != null) {
+               meta.mEventHandler.onEvent(event.mTopicUri, event.mEvent);
+            }
+         }
+      } else if (message instanceof WampMessage.Welcome) {
+
+         WampMessage.Welcome welcome = (WampMessage.Welcome) message;
+
+         // FIXME: safe session ID / fire session opened hook
+         if (DEBUG) Log.d(TAG, "WAMP session " + welcome.mSessionId + " established (protocol version " + welcome.mProtocolVersion + ", server " + welcome.mServerIdent + ")");
+
+      } else {
+
+         if (DEBUG) Log.d(TAG, "unknown WAMP message in AutobahnConnection.processAppMessage");
+      }
+   }
+
+
+   /**
+    * Issue a remote procedure call (RPC).
+    *
+    * @param procUri       URI or CURIE of procedure to call.
+    * @param resultMeta    Call result metadata.
+    * @param arguments     Call arguments.
+    */
+   private void call(String procUri, CallMeta resultMeta, Object... arguments) {
+
+      WampMessage.Call call = new WampMessage.Call(newId(), procUri, arguments.length);
+      for (int i = 0; i < arguments.length; ++i) {
+         call.mArgs[i] = arguments[i];
+      }
+      mCalls.put(call.mCallId, resultMeta);
+      mWriter.forward(call);
+   }
 
-	public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler) {
 
-		WampOptions options = new WampOptions();
-		options.setReceiveTextMessagesRaw(true);
-		options.setMaxMessagePayloadSize(64*1024);
-		options.setMaxFramePayloadSize(64*1024);
-		options.setTcpNoDelay(true);
-
-		connect(wsUri, sessionHandler, options, null);
-	}
-
-	public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler, List<BasicNameValuePair> headers) {
-
-		WampOptions options = new WampOptions();
-		options.setReceiveTextMessagesRaw(true);
-		options.setMaxMessagePayloadSize(64*1024);
-		options.setMaxFramePayloadSize(64*1024);
-		options.setTcpNoDelay(true);
-
-		connect(wsUri, sessionHandler, options, headers);
-	}
-
-	public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler, WampOptions options) {	
+   /**
+    * Issue a remote procedure call (RPC). This version should be used with
+    * primitive Java types and simple composite (class) types.
+    *
+    * @param procUri          URI or CURIE of procedure to call.
+    * @param resultType       Type we want the call result to be converted to.
+    * @param resultHandler    Call handler to process call result or error.
+    * @param arguments        Call arguments.
+    */
+   public void call(String procUri, Class<?> resultType, CallHandler resultHandler, Object... arguments) {
 
-		connect(wsUri, sessionHandler, options, null);
-	}
+      call(procUri, new CallMeta(resultHandler, resultType), arguments);
+   }
+
+
+   /**
+    * Issue a remote procedure call (RPC). This version should be used with
+    * result types which are containers, i.e. List<> or Map<>.
+    *
+    * @param procUri          URI or CURIE of procedure to call.
+    * @param resultType       Type we want the call result to be converted to.
+    * @param resultHandler    Call handler to process call result or error.
+    * @param arguments        Call arguments.
+    */
+   public void call(String procUri, TypeReference<?> resultType, CallHandler resultHandler, Object... arguments) {
 
-	/**
-	 * Connect to server.
-	 *
-	 * @param wsUri            WebSockets server URI.
-	 * @param sessionHandler   The session handler to fire callbacks on.
-	 * @param headers		   The headers for connection
-	 */
-	public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler, WampOptions options, List<BasicNameValuePair> headers) {
+      call(procUri, new CallMeta(resultHandler, resultType), arguments);
+   }
 
-		mSessionHandler = sessionHandler;
 
-		mCalls.clear();
-		mSubs.clear();
-		mOutgoingPrefixes.clear();
-
-		try {
-			connect(wsUri, new String[] {"wamp"}, new WebSocketConnectionHandler() {
-
-				@Override
-				public void onOpen() {
-					if (mSessionHandler != null) {
-						mSessionHandler.onOpen();
-					} else {
-						if (DEBUG) Log.d(TAG, "could not call onOpen() .. handler already NULL");
-					}
-				}
-
-				@Override
-				public void onClose(int code, String reason) {
-					if (mSessionHandler != null) {
-						mSessionHandler.onClose(code, reason);
-					} else {
-						if (DEBUG) Log.d(TAG, "could not call onClose() .. handler already NULL");
-					}
-				}
-
-			}, options , headers);
-
-		} catch (WebSocketException e) {
-
-			if (mSessionHandler != null) {
-				mSessionHandler.onClose(WebSocketConnectionHandler.CLOSE_CANNOT_CONNECT, "cannot connect (" + e.toString() + ")");
-			} else {
-				if (DEBUG) Log.d(TAG, "could not call onClose() .. handler already NULL");
-			}
-		}
-
-	}
-
-
-	/**
-	 * Process WAMP messages coming from the background reader.
-	 */
-	protected void processAppMessage(Object message) {
-
-		if (message instanceof WampMessage.CallResult) {
-
-			WampMessage.CallResult callresult = (WampMessage.CallResult) message;
-
-			if (mCalls.containsKey(callresult.mCallId)) {
-				CallMeta meta = mCalls.get(callresult.mCallId);
-				if (meta.mResultHandler != null) {
-					meta.mResultHandler.onResult(callresult.mResult);
-				}
-				mCalls.remove(callresult.mCallId);
-			}
-
-		} else if (message instanceof WampMessage.CallError) {
-
-			WampMessage.CallError callerror = (WampMessage.CallError) message;
-
-			if (mCalls.containsKey(callerror.mCallId)) {
-				CallMeta meta = mCalls.get(callerror.mCallId);
-				if (meta.mResultHandler != null) {
-					meta.mResultHandler.onError(callerror.mErrorUri, callerror.mErrorDesc);
-				}
-				mCalls.remove(callerror.mCallId);
-			}
-		} else if (message instanceof WampMessage.Event) {
-
-			WampMessage.Event event = (WampMessage.Event) message;
-
-			if (mSubs.containsKey(event.mTopicUri)) {
-				SubMeta meta = mSubs.get(event.mTopicUri);
-				if (meta != null && meta.mEventHandler != null) {
-					meta.mEventHandler.onEvent(event.mTopicUri, event.mEvent);
-				}
-			}
-		} else if (message instanceof WampMessage.Welcome) {
-
-			WampMessage.Welcome welcome = (WampMessage.Welcome) message;
-
-			// FIXME: safe session ID / fire session opened hook
-			if (DEBUG) Log.d(TAG, "WAMP session " + welcome.mSessionId + " established (protocol version " + welcome.mProtocolVersion + ", server " + welcome.mServerIdent + ")");
-
-		} else {
-
-			if (DEBUG) Log.d(TAG, "unknown WAMP message in AutobahnConnection.processAppMessage");
-		}
-	}
-
-
-	/**
-	 * Issue a remote procedure call (RPC).
-	 *
-	 * @param procUri       URI or CURIE of procedure to call.
-	 * @param resultMeta    Call result metadata.
-	 * @param arguments     Call arguments.
-	 */
-	private void call(String procUri, CallMeta resultMeta, Object... arguments) {
-
-		WampMessage.Call call = new WampMessage.Call(newId(), procUri, arguments.length);
-		for (int i = 0; i < arguments.length; ++i) {
-			call.mArgs[i] = arguments[i];
-		}
-		mWriter.forward(call);
-		mCalls.put(call.mCallId, resultMeta);
-	}
-
-
-	/**
-	 * Issue a remote procedure call (RPC). This version should be used with
-	 * primitive Java types and simple composite (class) types.
-	 *
-	 * @param procUri          URI or CURIE of procedure to call.
-	 * @param resultType       Type we want the call result to be converted to.
-	 * @param resultHandler    Call handler to process call result or error.
-	 * @param arguments        Call arguments.
-	 */
-	public void call(String procUri, Class<?> resultType, CallHandler resultHandler, Object... arguments) {
-
-		call(procUri, new CallMeta(resultHandler, resultType), arguments);
-	}
+   /**
+    * Subscribe to topic to receive events for.
+    *
+    * @param topicUri         URI or CURIE of topic to subscribe to.
+    * @param meta             Subscription metadata.
+    */
+   private void subscribe(String topicUri, SubMeta meta) {
+
+      String uri = mOutgoingPrefixes.resolveOrPass(topicUri);
+
+      if (!mSubs.containsKey(uri)) {
+
+         mSubs.put(uri, meta);
+
+         WampMessage.Subscribe msg = new WampMessage.Subscribe(mOutgoingPrefixes.shrink(topicUri));
+         mWriter.forward(msg);
+      }
+   }
+
+
+   /**
+    * Subscribe to topic to receive events for. This version should be used with
+    * result types which are containers, i.e. List<> or Map<>.
+    *
+    * @param topicUri         URI or CURIE of topic to subscribe to.
+    * @param eventType        The type we want events to be converted to.
+    * @param eventHandler     The event handler to process received events.
+    */
+   public void subscribe(String topicUri, Class<?> eventType, EventHandler eventHandler) {
+
+      subscribe(topicUri, new SubMeta(eventHandler, eventType));
+   }
+
+
+   /**
+    * Subscribe to topic to receive events for.  This version should be used with
+    * primitive Java types and simple composite (class) types.
+    *
+    * @param topicUri         URI or CURIE of topic to subscribe to.
+    * @param eventType        The type we want events to be converted to.
+    * @param eventHandler     The event handler to process received events.
+    */
+   public void subscribe(String topicUri, TypeReference<?> eventType, EventHandler eventHandler) {
+
+      subscribe(topicUri, new SubMeta(eventHandler, eventType));
+   }
+
+
+   /**
+    * Unsubscribe from topic.
+    *
+    * @param topicUri      URI or CURIE of topic to unsubscribe from.
+    */
+   public void unsubscribe(String topicUri) {
+
+      if (mSubs.containsKey(topicUri)) {
+
+         WampMessage.Unsubscribe msg = new WampMessage.Unsubscribe(topicUri);
+         mWriter.forward(msg);
+         
+         mSubs.remove(topicUri);
+      }
+   }
+
+
+   /**
+    * Unsubscribe from any subscribed topic.
+    */
+   public void unsubscribe() {
+
+      for (String topicUri : mSubs.keySet()) {
+
+         WampMessage.Unsubscribe msg = new WampMessage.Unsubscribe(topicUri);
+         mWriter.forward(msg);
+      }
+      mSubs.clear();
+   }
 
 
-	/**
-	 * Issue a remote procedure call (RPC). This version should be used with
-	 * result types which are containers, i.e. List<> or Map<>.
-	 *
-	 * @param procUri          URI or CURIE of procedure to call.
-	 * @param resultType       Type we want the call result to be converted to.
-	 * @param resultHandler    Call handler to process call result or error.
-	 * @param arguments        Call arguments.
-	 */
-	public void call(String procUri, TypeReference<?> resultType, CallHandler resultHandler, Object... arguments) {
+   /**
+    * Establish a prefix to be used in CURIEs.
+    *
+    * @param prefix     The prefix to be used in CURIEs.
+    * @param uri        The full URI this prefix shall resolve to.
+    */
+   public void prefix(String prefix, String uri) {
+
+      String currUri = mOutgoingPrefixes.get(prefix);
 
-		call(procUri, new CallMeta(resultHandler, resultType), arguments);
-	}
+      if (currUri == null || !currUri.equals(uri)) {
 
+         mOutgoingPrefixes.set(prefix, uri);
 
-	/**
-	 * Subscribe to topic to receive events for.
-	 *
-	 * @param topicUri         URI or CURIE of topic to subscribe to.
-	 * @param meta             Subscription metadata.
-	 */
-	private void subscribe(String topicUri, SubMeta meta) {
-
-		String uri = mOutgoingPrefixes.resolveOrPass(topicUri);
-
-		if (!mSubs.containsKey(uri)) {
-
-			WampMessage.Subscribe msg = new WampMessage.Subscribe(mOutgoingPrefixes.shrink(topicUri));
-			mWriter.forward(msg);
-		}
-
-		System.out.println("mSubs.put >> " + uri);
-		mSubs.put(uri, meta);
-	}
-
-
-	/**
-	 * Subscribe to topic to receive events for. This version should be used with
-	 * result types which are containers, i.e. List<> or Map<>.
-	 *
-	 * @param topicUri         URI or CURIE of topic to subscribe to.
-	 * @param eventType        The type we want events to be converted to.
-	 * @param eventHandler     The event handler to process received events.
-	 */
-	public void subscribe(String topicUri, Class<?> eventType, EventHandler eventHandler) {
-
-		subscribe(topicUri, new SubMeta(eventHandler, eventType));
-	}
-
-
-	/**
-	 * Subscribe to topic to receive events for.  This version should be used with
-	 * primitive Java types and simple composite (class) types.
-	 *
-	 * @param topicUri         URI or CURIE of topic to subscribe to.
-	 * @param eventType        The type we want events to be converted to.
-	 * @param eventHandler     The event handler to process received events.
-	 */
-	public void subscribe(String topicUri, TypeReference<?> eventType, EventHandler eventHandler) {
-
-		subscribe(topicUri, new SubMeta(eventHandler, eventType));
-	}
-
-
-	/**
-	 * Unsubscribe from topic.
-	 *
-	 * @param topicUri      URI or CURIE of topic to unsubscribe from.
-	 */
-	public void unsubscribe(String topicUri) {
-
-		if (mSubs.containsKey(topicUri)) {
-
-			WampMessage.Unsubscribe msg = new WampMessage.Unsubscribe(topicUri);
-			mWriter.forward(msg);
-		}
-	}
-
-
-	/**
-	 * Unsubscribe from any subscribed topic.
-	 */
-	public void unsubscribe() {
+         WampMessage.Prefix msg = new WampMessage.Prefix(prefix, uri);
+         mWriter.forward(msg);
+      }
+   }
 
-		for (String topicUri : mSubs.keySet()) {
-
-			WampMessage.Unsubscribe msg = new WampMessage.Unsubscribe(topicUri);
-			mWriter.forward(msg);
-		}
-	}
 
+   /**
+    * Publish an event to a topic.
+    *
+    * @param topicUri   URI or CURIE of topic to publish event on.
+    * @param event      Event to be published.
+    */
+   public void publish(String topicUri, Object event) {
 
-	/**
-	 * Establish a prefix to be used in CURIEs.
-	 *
-	 * @param prefix     The prefix to be used in CURIEs.
-	 * @param uri        The full URI this prefix shall resolve to.
-	 */
-	public void prefix(String prefix, String uri) {
-
-		String currUri = mOutgoingPrefixes.get(prefix);
-
-		if (currUri == null || !currUri.equals(uri)) {
-
-			mOutgoingPrefixes.set(prefix, uri);
-
-			WampMessage.Prefix msg = new WampMessage.Prefix(prefix, uri);
-			mWriter.forward(msg);
-		}
-	}
-
-
-	/**
-	 * Publish an event to a topic.
-	 *
-	 * @param topicUri   URI or CURIE of topic to publish event on.
-	 * @param event      Event to be published.
-	 */
-	public void publish(String topicUri, Object event) {
-
-		WampMessage.Publish msg = new WampMessage.Publish(mOutgoingPrefixes.shrink(topicUri), event);
-		mWriter.forward(msg);
-	}
+      WampMessage.Publish msg = new WampMessage.Publish(mOutgoingPrefixes.shrink(topicUri), event);
+      mWriter.forward(msg);
+   }
 }
diff --git a/Autobahn/src/de/tavendo/autobahn/WampReader.java b/Autobahn/src/de/tavendo/autobahn/WampReader.java
index caac491..0f3f656 100644
--- a/Autobahn/src/de/tavendo/autobahn/WampReader.java
+++ b/Autobahn/src/de/tavendo/autobahn/WampReader.java
@@ -19,18 +19,15 @@
 package de.tavendo.autobahn;
 
 import java.io.IOException;
-import java.nio.ByteBuffer;
 import java.nio.channels.SocketChannel;
 import java.util.concurrent.ConcurrentHashMap;
 
-import org.apache.http.util.ByteArrayBuffer;
 import org.codehaus.jackson.JsonFactory;
 import org.codehaus.jackson.JsonParseException;
 import org.codehaus.jackson.JsonParser;
 import org.codehaus.jackson.JsonToken;
 import org.codehaus.jackson.map.DeserializationConfig;
 import org.codehaus.jackson.map.ObjectMapper;
-import org.json.JSONArray;
 
 import android.os.Handler;
 import android.util.Log;
@@ -107,21 +104,7 @@ protected void onRawTextMessage(byte[] payload) {
       try {
 
          // create parser on top of raw UTF-8 payload
-    	/* JSONArray jArray =  new JSONArray();
-    	 jArray.put(8);
-    	 jArray.put("http://example.com/simple");
-    	 jArray.put(new String(payload));
-    	 
-    	 System.out.println(jArray.toString());
-    	 
-    	 JsonParser parser = mJsonFactory.createJsonParser(jArray.toString().getBytes());*/
-    	  
          JsonParser parser = mJsonFactory.createJsonParser(payload);
-/*         
-         String str= new String(payload);
-         
-         System.out.println("Parser info: " + str);
-         System.out.println("Parser next token: " + parser.nextToken().toString());*/
 
          // all Autobahn messages are JSON arrays
          if (parser.nextToken() == JsonToken.START_ARRAY) {
@@ -185,7 +168,6 @@ protected void onRawTextMessage(byte[] payload) {
                   // topic URI
                   parser.nextToken();
                   String topicUri = parser.getText();
-                  System.out.println("TOPIC URI>>>>" +  topicUri);   
 
                   // event
                   parser.nextToken();
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java b/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java
index bbf13de..876d388 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java
@@ -24,10 +24,8 @@
 import java.net.URISyntaxException;
 import java.nio.channels.SocketChannel;
 import java.util.List;
-
 import org.apache.http.message.BasicNameValuePair;
 
-import android.os.AsyncTask;
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Message;
@@ -62,78 +60,73 @@
    private boolean mActive;
    private boolean mPrevConnected;
 
-   /**
-    * Asynch socket connector.
-    */
-   private class WebSocketConnector extends AsyncTask<Void, Void, String> {
-
-      @Override
-      protected String doInBackground(Void... params) {
-
-         Thread.currentThread().setName("WebSocketConnector");
-
-         // connect TCP socket
-         // http://developer.android.com/reference/java/nio/channels/SocketChannel.html
-         //
-         try {
-            mTransportChannel = SocketChannel.open();
-
-            // the following will block until connection was established or an error occurred!
-            mTransportChannel.socket().connect(new InetSocketAddress(mWsHost, mWsPort), mOptions.getSocketConnectTimeout());
-
-            // before doing any data transfer on the socket, set socket options
-            mTransportChannel.socket().setSoTimeout(mOptions.getSocketReceiveTimeout());
-            mTransportChannel.socket().setTcpNoDelay(mOptions.getTcpNoDelay());
-
-            return null;
-
-         } catch (IOException e) {
-
-            return e.getMessage();
-         }
-      }
-
-      @Override
-      protected void onPostExecute(String reason) {
-
-         if (reason != null) {
-
-            onClose(WebSocketConnectionHandler.CLOSE_CANNOT_CONNECT, reason);
-
-         } else if (mTransportChannel.isConnected()) {
-
-            try {
+	/**
+	 * Asynchronous socket connector.
+	 */
+	private class WebSocketConnector extends Thread {
+
+		public void run() {
+			Thread.currentThread().setName("WebSocketConnector");
+
+			/*
+			 * connect TCP socket
+			 */
+			try {
+				mTransportChannel = SocketChannel.open();
+
+				// the following will block until connection was established or
+				// an error occurred!
+				mTransportChannel.socket().connect(
+						new InetSocketAddress(mWsHost, mWsPort),
+						mOptions.getSocketConnectTimeout());
+
+				// before doing any data transfer on the socket, set socket
+				// options
+				mTransportChannel.socket().setSoTimeout(
+						mOptions.getSocketReceiveTimeout());
+				mTransportChannel.socket().setTcpNoDelay(
+						mOptions.getTcpNoDelay());
+
+			} catch (IOException e) {
+				onClose(WebSocketConnectionHandler.CLOSE_CANNOT_CONNECT,
+						e.getMessage());
+				return;
+			}
 
-               // create & start WebSocket reader
-               createReader();
+			if (mTransportChannel.isConnected()) {
 
-               // create & start WebSocket writer
-               createWriter();
+				try {
 
-               // start WebSockets handshake
-               WebSocketMessage.ClientHandshake hs = new WebSocketMessage.ClientHandshake(mWsHost + ":" + mWsPort);
-               hs.mPath = mWsPath;
-               hs.mQuery = mWsQuery;
-               hs.mSubprotocols = mWsSubprotocols;
-               hs.mHeaderList = mWsHeaders;
-               mWriter.forward(hs);
-               
-               mPrevConnected = true;
+					// create & start WebSocket reader
+					createReader();
 
-            } catch (Exception e) {
+					// create & start WebSocket writer
+					createWriter();
 
-               onClose(WebSocketConnectionHandler.CLOSE_INTERNAL_ERROR, e.getMessage());
+					// start WebSockets handshake
+					WebSocketMessage.ClientHandshake hs = new WebSocketMessage.ClientHandshake(
+							mWsHost + ":" + mWsPort);
+					hs.mPath = mWsPath;
+					hs.mQuery = mWsQuery;
+					hs.mSubprotocols = mWsSubprotocols;
+					hs.mHeaderList = mWsHeaders;
+					mWriter.forward(hs);
 
-            }
+					mPrevConnected = true;
 
-         } else {
-
-            onClose(WebSocketConnectionHandler.CLOSE_CANNOT_CONNECT, "could not connect to WebSockets server");
-         }
-      }
-
-   }
+				} catch (Exception e) {
+					onClose(WebSocketConnectionHandler.CLOSE_INTERNAL_ERROR,
+							e.getMessage());
+					return;
+				}
+			} else {
+				onClose(WebSocketConnectionHandler.CLOSE_CANNOT_CONNECT,
+						"Could not connect to WebSocket server");
+				return;
+			}
+		}
 
+	}
 
    public WebSocketConnection() {
       if (DEBUG) Log.d(TAG, "created");
@@ -290,7 +283,7 @@ public void connect(String wsUri, String[] wsSubprotocols, WebSocket.ConnectionH
       mActive = true;
 
       // use asynch connector on short-lived background thread
-      new WebSocketConnector().execute();
+      new WebSocketConnector().start();
    }
 
 
@@ -310,7 +303,7 @@ public void disconnect() {
     */
    public boolean reconnect() {
 	   if (!isConnected() && (mWsUri != null)) {
-		   new WebSocketConnector().execute();
+		   new WebSocketConnector().start();
 		   return true;
 	   }
 	   return false;
@@ -383,7 +376,7 @@ protected void createHandler() {
       mMasterHandler = new Handler() {
 
          public void handleMessage(Message msg) {
-        	 
+
             if (msg.obj instanceof WebSocketMessage.TextMessage) {
 
                WebSocketMessage.TextMessage textMessage = (WebSocketMessage.TextMessage) msg.obj;
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketMessage.java b/Autobahn/src/de/tavendo/autobahn/WebSocketMessage.java
index a34d35a..393d2a6 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketMessage.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketMessage.java
@@ -19,7 +19,6 @@
 package de.tavendo.autobahn;
 
 import java.util.List;
-
 import org.apache.http.message.BasicNameValuePair;
 
 /**
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java b/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java
index 8836c79..301679f 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java
@@ -24,7 +24,6 @@
 import java.util.Random;
 
 import org.apache.http.NameValuePair;
-
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
@@ -182,15 +181,13 @@ private void sendClientHandshake(WebSocketMessage.ClientHandshake message) throw
       mBuffer.write("Sec-WebSocket-Version: 13");
       mBuffer.crlf();
 
-      // Header injection
-      
+      // Header injection      
       if (message.mHeaderList != null) {
           for (NameValuePair pair : message.mHeaderList) {
         	  mBuffer.write( pair.getName() + ":" + pair.getValue() );
         	  mBuffer.crlf();
           }
-      }     
-      
+      }           
       mBuffer.crlf();
    }
 
diff --git a/Demo/SimplePubSub/src/de/tavendo/autobahn/simplepubsub/SimplePubSubActivity.java b/Demo/SimplePubSub/src/de/tavendo/autobahn/simplepubsub/SimplePubSubActivity.java
index d820d5a..cc7420d 100644
--- a/Demo/SimplePubSub/src/de/tavendo/autobahn/simplepubsub/SimplePubSubActivity.java
+++ b/Demo/SimplePubSub/src/de/tavendo/autobahn/simplepubsub/SimplePubSubActivity.java
@@ -18,11 +18,7 @@
 
 package de.tavendo.autobahn.simplepubsub;
 
-import java.util.Arrays;
 import java.util.Date;
-import java.util.List;
-
-import org.apache.http.message.BasicNameValuePair;
 
 import android.app.Activity;
 import android.content.SharedPreferences;
@@ -37,148 +33,142 @@
 
 public class SimplePubSubActivity extends Activity {
 
-	@SuppressWarnings("unused")
-	private static final String TAG = "de.tavendo.autobahn.simplepubsub";
-
-	private static final String PREFS_NAME = "AutobahnAndroidSimplePubSub";
-
-	private SharedPreferences mSettings;
-
-	private static EditText mHostname;
-	private static EditText mPort;
-	private static TextView mStatusline;
-	private static Button mStart;
-
-	private List<BasicNameValuePair> headers = null;
-
-	private final Wamp mConnection = new WampConnection();
-
-	private void alert(String message) {
-		Toast.makeText(getApplicationContext(), message, Toast.LENGTH_SHORT).show();
-	}
-
-	private void loadPrefs() {
-
-		mHostname.setText(mSettings.getString("hostname", ""));
-		mPort.setText(mSettings.getString("port", "9000"));
-	}
-
-	private void savePrefs() {
-
-		SharedPreferences.Editor editor = mSettings.edit();
-		editor.putString("hostname", mHostname.getText().toString());
-		editor.putString("port", mPort.getText().toString());
-		editor.commit();
-	}
-
-	private void setButtonConnect() {
-		mStart.setText("Connect");
-		mStart.setOnClickListener(new Button.OnClickListener() {
-			public void onClick(View v) {
-				test();
-			}
-		});
-	}
-
-	private void setButtonDisconnect() {
-		mStart.setText("Disconnect");
-		mStart.setOnClickListener(new Button.OnClickListener() {
-			public void onClick(View v) {
-				mConnection.disconnect();
-			}
-		});
-	}
-
-	/**
-	 * We want PubSub events delivered to us in JSON payload to be automatically
-	 * converted to this domain POJO. We specify this class later when we subscribe.
-	 */
-	private static class MyEvent1 {
-
-		public int num;
-		public String name;
-		public boolean flag;
-		public Date created;
-		public double rand;
-
-		@Override
-		public String toString() {
-			return "{name: " + name +
-					", created: " + created +
-					", num: " + num +
-					", rand: " + rand +
-					", flag:" + flag + "}";
-		}
-	}
-
-	private void test() {
-
-		final String wsuri = "ws://" + mHostname.getText();// + ":" + mPort.getText();
+   @SuppressWarnings("unused")
+   private static final String TAG = "de.tavendo.autobahn.simplepubsub";
 
-		mStatusline.setText("Connecting to\n" + wsuri + " ..");
+   private static final String PREFS_NAME = "AutobahnAndroidSimplePubSub";
 
-		setButtonDisconnect();
+   private SharedPreferences mSettings;
 
-		// we establish a connection by giving the WebSockets URL of the server
-		// and the handler for open/close events
-		mConnection.connect(wsuri, new Wamp.ConnectionHandler() {
+   private static EditText mHostname;
+   private static EditText mPort;
+   private static TextView mStatusline;
+   private static Button mStart;
 
-			@Override
-			public void onOpen() {
+   private final Wamp mConnection = new WampConnection();
 
-				// The connection was successfully established. we set the status
-				// and save the host/port as Android application preference for next time.
-				mStatusline.setText("Connected to\n" + wsuri);
-				savePrefs();
+   private void alert(String message) {
+      Toast.makeText(getApplicationContext(), message, Toast.LENGTH_SHORT).show();
+   }
 
-				// We establish a prefix to use for writing URIs using shorthand CURIE notation.
-				mConnection.prefix("event", "http://example.com/event#");
+   private void loadPrefs() {
+
+      mHostname.setText(mSettings.getString("hostname", ""));
+      mPort.setText(mSettings.getString("port", "9000"));
+   }
+
+   private void savePrefs() {
 
-				// We subscribe to a topic by giving the topic URI, the type we want events
-				// to be converted to, and the event handler we want to have fired.
-				mConnection.subscribe("event:myevent1", MyEvent1.class, new Wamp.EventHandler() {
-
-					@Override
-					public void onEvent(String topicUri, Object event) {
-
-						// when we get an event, we safely can cast to the type we specified previously
-						MyEvent1 evt = (MyEvent1) event;
-
-						alert("Event received : " + evt.toString());
-					}
-				});
-			}
-
-			@Override
-			public void onClose(int code, String reason) {
-
-				// The connection was closed. Set the status line, show a message box,
-				// and set the button to allow to connect again.
-				mStatusline.setText("Connection closed.");
-				alert(reason);
-				setButtonConnect();
-			}
-		}, headers);
-	}
-
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-
-		super.onCreate(savedInstanceState);
-		setContentView(R.layout.main);
-
-		mHostname = (EditText) findViewById(R.id.hostname);
-		mPort = (EditText) findViewById(R.id.port);
-		mStatusline = (TextView) findViewById(R.id.statusline);
-		mStart = (Button) findViewById(R.id.start);
-
-		headers = Arrays.asList(
-				new BasicNameValuePair("X-sessionid", "1f45debd-2ced-62b7-07d0-c4b50a1237fe")
-				);
-
-		mSettings = getSharedPreferences(PREFS_NAME, 0);
-		loadPrefs();
-
-		setButtonConnect();
-	}
-}
\ No newline at end of file
+      SharedPreferences.Editor editor = mSettings.edit();
+      editor.putString("hostname", mHostname.getText().toString());
+      editor.putString("port", mPort.getText().toString());
+      editor.commit();
+   }
+
+   private void setButtonConnect() {
+      mStart.setText("Connect");
+      mStart.setOnClickListener(new Button.OnClickListener() {
+         public void onClick(View v) {
+            test();
+         }
+      });
+   }
+
+   private void setButtonDisconnect() {
+      mStart.setText("Disconnect");
+      mStart.setOnClickListener(new Button.OnClickListener() {
+         public void onClick(View v) {
+            mConnection.disconnect();
+         }
+      });
+   }
+
+   /**
+    * We want PubSub events delivered to us in JSON payload to be automatically
+    * converted to this domain POJO. We specify this class later when we subscribe.
+    */
+   private static class MyEvent1 {
+
+      public int num;
+      public String name;
+      public boolean flag;
+      public Date created;
+      public double rand;
+
+      @Override
+      public String toString() {
+         return "{name: " + name +
+                ", created: " + created +
+                ", num: " + num +
+                ", rand: " + rand +
+                ", flag:" + flag + "}";
+      }
+   }
+
+   private void test() {
+
+      final String wsuri = "ws://" + mHostname.getText() + ":" + mPort.getText();
+
+      mStatusline.setText("Connecting to\n" + wsuri + " ..");
+
+      setButtonDisconnect();
+
+      // we establish a connection by giving the WebSockets URL of the server
+      // and the handler for open/close events
+      mConnection.connect(wsuri, new Wamp.ConnectionHandler() {
+
+         @Override
+         public void onOpen() {
+
+            // The connection was successfully established. we set the status
+            // and save the host/port as Android application preference for next time.
+            mStatusline.setText("Connected to\n" + wsuri);
+            savePrefs();
+
+            // We establish a prefix to use for writing URIs using shorthand CURIE notation.
+            mConnection.prefix("event", "http://example.com/event#");
+
+            // We subscribe to a topic by giving the topic URI, the type we want events
+            // to be converted to, and the event handler we want to have fired.
+            mConnection.subscribe("event:myevent1", MyEvent1.class, new Wamp.EventHandler() {
+
+               @Override
+               public void onEvent(String topicUri, Object event) {
+
+                  // when we get an event, we safely can cast to the type we specified previously
+                  MyEvent1 evt = (MyEvent1) event;
+
+                  alert("Event received : " + evt.toString());
+               }
+            });
+         }
+
+         @Override
+         public void onClose(int code, String reason) {
+
+            // The connection was closed. Set the status line, show a message box,
+            // and set the button to allow to connect again.
+            mStatusline.setText("Connection closed.");
+            alert(reason);
+            setButtonConnect();
+         }
+      });
+   }
+
+   @Override
+   public void onCreate(Bundle savedInstanceState) {
+
+      super.onCreate(savedInstanceState);
+      setContentView(R.layout.main);
+
+      mHostname = (EditText) findViewById(R.id.hostname);
+      mPort = (EditText) findViewById(R.id.port);
+      mStatusline = (TextView) findViewById(R.id.statusline);
+      mStart = (Button) findViewById(R.id.start);
+
+      mSettings = getSharedPreferences(PREFS_NAME, 0);
+      loadPrefs();
+
+      setButtonConnect();
+   }
+}
diff --git a/Demo/SimplePubSub/src/de/tavendo/autobahn/simplepubsub/SimplePubSubActivity.java~ b/Demo/SimplePubSub/src/de/tavendo/autobahn/simplepubsub/SimplePubSubActivity.java~
new file mode 100644
index 0000000..cc7420d
--- /dev/null
+++ b/Demo/SimplePubSub/src/de/tavendo/autobahn/simplepubsub/SimplePubSubActivity.java~
@@ -0,0 +1,174 @@
+/******************************************************************************
+ *
+ *  Copyright 2011 Tavendo GmbH
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+package de.tavendo.autobahn.simplepubsub;
+
+import java.util.Date;
+
+import android.app.Activity;
+import android.content.SharedPreferences;
+import android.os.Bundle;
+import android.view.View;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.TextView;
+import android.widget.Toast;
+import de.tavendo.autobahn.Wamp;
+import de.tavendo.autobahn.WampConnection;
+
+public class SimplePubSubActivity extends Activity {
+
+   @SuppressWarnings("unused")
+   private static final String TAG = "de.tavendo.autobahn.simplepubsub";
+
+   private static final String PREFS_NAME = "AutobahnAndroidSimplePubSub";
+
+   private SharedPreferences mSettings;
+
+   private static EditText mHostname;
+   private static EditText mPort;
+   private static TextView mStatusline;
+   private static Button mStart;
+
+   private final Wamp mConnection = new WampConnection();
+
+   private void alert(String message) {
+      Toast.makeText(getApplicationContext(), message, Toast.LENGTH_SHORT).show();
+   }
+
+   private void loadPrefs() {
+
+      mHostname.setText(mSettings.getString("hostname", ""));
+      mPort.setText(mSettings.getString("port", "9000"));
+   }
+
+   private void savePrefs() {
+
+      SharedPreferences.Editor editor = mSettings.edit();
+      editor.putString("hostname", mHostname.getText().toString());
+      editor.putString("port", mPort.getText().toString());
+      editor.commit();
+   }
+
+   private void setButtonConnect() {
+      mStart.setText("Connect");
+      mStart.setOnClickListener(new Button.OnClickListener() {
+         public void onClick(View v) {
+            test();
+         }
+      });
+   }
+
+   private void setButtonDisconnect() {
+      mStart.setText("Disconnect");
+      mStart.setOnClickListener(new Button.OnClickListener() {
+         public void onClick(View v) {
+            mConnection.disconnect();
+         }
+      });
+   }
+
+   /**
+    * We want PubSub events delivered to us in JSON payload to be automatically
+    * converted to this domain POJO. We specify this class later when we subscribe.
+    */
+   private static class MyEvent1 {
+
+      public int num;
+      public String name;
+      public boolean flag;
+      public Date created;
+      public double rand;
+
+      @Override
+      public String toString() {
+         return "{name: " + name +
+                ", created: " + created +
+                ", num: " + num +
+                ", rand: " + rand +
+                ", flag:" + flag + "}";
+      }
+   }
+
+   private void test() {
+
+      final String wsuri = "ws://" + mHostname.getText() + ":" + mPort.getText();
+
+      mStatusline.setText("Connecting to\n" + wsuri + " ..");
+
+      setButtonDisconnect();
+
+      // we establish a connection by giving the WebSockets URL of the server
+      // and the handler for open/close events
+      mConnection.connect(wsuri, new Wamp.ConnectionHandler() {
+
+         @Override
+         public void onOpen() {
+
+            // The connection was successfully established. we set the status
+            // and save the host/port as Android application preference for next time.
+            mStatusline.setText("Connected to\n" + wsuri);
+            savePrefs();
+
+            // We establish a prefix to use for writing URIs using shorthand CURIE notation.
+            mConnection.prefix("event", "http://example.com/event#");
+
+            // We subscribe to a topic by giving the topic URI, the type we want events
+            // to be converted to, and the event handler we want to have fired.
+            mConnection.subscribe("event:myevent1", MyEvent1.class, new Wamp.EventHandler() {
+
+               @Override
+               public void onEvent(String topicUri, Object event) {
+
+                  // when we get an event, we safely can cast to the type we specified previously
+                  MyEvent1 evt = (MyEvent1) event;
+
+                  alert("Event received : " + evt.toString());
+               }
+            });
+         }
+
+         @Override
+         public void onClose(int code, String reason) {
+
+            // The connection was closed. Set the status line, show a message box,
+            // and set the button to allow to connect again.
+            mStatusline.setText("Connection closed.");
+            alert(reason);
+            setButtonConnect();
+         }
+      });
+   }
+
+   @Override
+   public void onCreate(Bundle savedInstanceState) {
+
+      super.onCreate(savedInstanceState);
+      setContentView(R.layout.main);
+
+      mHostname = (EditText) findViewById(R.id.hostname);
+      mPort = (EditText) findViewById(R.id.port);
+      mStatusline = (TextView) findViewById(R.id.statusline);
+      mStart = (Button) findViewById(R.id.start);
+
+      mSettings = getSharedPreferences(PREFS_NAME, 0);
+      loadPrefs();
+
+      setButtonConnect();
+   }
+}
