diff --git a/Autobahn/AndroidManifest.xml b/Autobahn/AndroidManifest.xml
index 322146a..3cdd78e 100644
--- a/Autobahn/AndroidManifest.xml
+++ b/Autobahn/AndroidManifest.xml
@@ -3,5 +3,4 @@
       package="de.tavendo.autobahn"
       android:versionCode="1" android:versionName="0.1">
     <uses-sdk android:minSdkVersion="8" />
-    <application android:label="Autobahn"></application>
 </manifest>
\ No newline at end of file
diff --git a/Autobahn/build.gradle b/Autobahn/build.gradle
index a25dbb5..539b661 100644
--- a/Autobahn/build.gradle
+++ b/Autobahn/build.gradle
@@ -4,9 +4,6 @@ buildscript {
     }
     dependencies {
         classpath 'com.android.tools.build:gradle:1.3.1'
-        // NOTE: Do not place your application dependencies here; they belong
-        // in the individual module build.gradle files
-
     }
 }
 
@@ -19,12 +16,12 @@ android {
 
             jniLibs.srcDirs = ['libs/']
 
-            java.srcDirs=['src/'
+            java.srcDirs = ['src/'
             ]
         }
-        androidTest.java.srcDirs=['test/src/']
-        androidTest.res.srcDirs=['test/res/']
-        androidTest.assets.srcDirs=['test/assets/']
+        androidTest.java.srcDirs = ['test/src/']
+        androidTest.res.srcDirs = ['test/res/']
+        androidTest.assets.srcDirs = ['test/assets/']
     }
 
     lintOptions {
@@ -36,6 +33,12 @@ android {
         minSdkVersion 19
     }
 
+    packagingOptions {
+        exclude 'META-INF/ASL2.0'
+        exclude 'META-INF/LICENSE'
+        exclude 'META-INF/NOTICE'
+    }
+
     compileSdkVersion 23
     buildToolsVersion '23.0.1'
 }
@@ -44,9 +47,7 @@ repositories {
     jcenter()
 }
 
-dependencies{
+dependencies {
     compile 'com.android.support:support-v4:23.1.1'
-    compile 'org.codehaus.jackson:jackson-mapper-asl:1.9.13'
-    compile 'com.squareup.okhttp3:okhttp:3.1.1'
 }
 
diff --git a/Autobahn/src/de/tavendo/autobahn/ByteBufferInputStream.java b/Autobahn/src/de/tavendo/autobahn/ByteBufferInputStream.java
index 780293d..a44ee1c 100644
--- a/Autobahn/src/de/tavendo/autobahn/ByteBufferInputStream.java
+++ b/Autobahn/src/de/tavendo/autobahn/ByteBufferInputStream.java
@@ -87,4 +87,8 @@ public synchronized int read(byte[] bytes, int off, int len)
       return length;
    }
 
+   public ByteBuffer getByteBuffer() {
+      return mBuffer;
+   }
+
 }
diff --git a/Autobahn/src/de/tavendo/autobahn/Wamp.java b/Autobahn/src/de/tavendo/autobahn/Wamp.java
deleted file mode 100644
index dbcdfb7..0000000
--- a/Autobahn/src/de/tavendo/autobahn/Wamp.java
+++ /dev/null
@@ -1,215 +0,0 @@
-/******************************************************************************
- * Copyright 2011-2012 Tavendo GmbH
- * <p/>
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * <p/>
- * http://www.apache.org/licenses/LICENSE-2.0
- * <p/>
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-package de.tavendo.autobahn;
-
-
-import android.support.v4.util.Pair;
-
-import org.codehaus.jackson.type.TypeReference;
-
-import java.util.List;
-
-/**
- * WAMP interface.
- */
-public interface Wamp {
-
-    public static final String URI_WAMP_BASE = "http://api.wamp.ws/";
-
-    public static final String URI_WAMP_ERROR = URI_WAMP_BASE + "error#";
-
-    public static final String URI_WAMP_PROCEDURE = URI_WAMP_BASE + "procedure#";
-
-    public static final String URI_WAMP_TOPIC = URI_WAMP_BASE + "topic#";
-
-    public static final String URI_WAMP_ERROR_GENERIC = URI_WAMP_ERROR + "generic";
-
-    public static final String DESC_WAMP_ERROR_GENERIC = "generic error";
-
-    public static final String URI_WAMP_ERROR_INTERNAL = URI_WAMP_ERROR + "internal";
-
-    /**
-     * Session handler for WAMP sessions.
-     */
-    public interface ConnectionHandler {
-
-        /**
-         * Fired upon successful establishment of connection to WAMP server.
-         */
-        public void onOpen();
-
-        /**
-         * Firex upon unsuccessful connection attempt or when connection
-         * was closed normally, or abnormally.
-         *
-         * @param code       The close code, which provides information about why the connection was closed.
-         * @param reason     A humand readable description of the reason of connection close.
-         */
-        public void onClose(int code, String reason);
-    }
-
-    /**
-     * Connect to WAMP server.
-     *
-     * @param wsUri            The WebSockets URI of the server.
-     * @param sessionHandler   The handler for the session.
-     */
-    public void connect(String wsUri, ConnectionHandler sessionHandler);
-
-    /**
-     *
-     * @param wsUri            The WebSockets URI of the server.
-     * @param sessionHandler   The handler for the session.
-     * @param headers          The headers with the connection
-     */
-    public void connect(String wsUri, ConnectionHandler sessionHandler, List<Pair> headers);
-
-
-    /**
-     * Connect to WAMP server.
-     *
-     * @param wsUri            The WebSockets URI of the server.
-     * @param sessionHandler   The handler for the session.
-     * @param options          WebSockets and Autobahn option.s
-     * @param headers          Headers for connection
-     */
-    public void connect(String wsUri, ConnectionHandler sessionHandler, WampOptions options, List<Pair> headers);
-
-    /**
-     * Connect to WAMP server.
-     *
-     * @param wsUri            The WebSockets URI of the server.
-     * @param sessionHandler   The handler for the session.
-     * @param options          WebSockets and Autobahn option.s
-     */
-    public void connect(String wsUri, ConnectionHandler sessionHandler, WampOptions options);
-
-    /**
-     * Disconnect from WAMP server.
-     */
-    public void disconnect();
-
-    /**
-     * Check if currently connected to server.
-     *
-     * @return True, iff connected.
-     */
-    public boolean isConnected();
-
-
-    /**
-     * Establish a prefix to be used in CURIEs to shorten URIs.
-     *
-     * @param prefix           The prefix to be used in CURIEs.
-     * @param uri              The full URI this prefix shall resolve to.
-     */
-    public void prefix(String prefix, String uri);
-
-    /**
-     * Call handler.
-     */
-    public interface CallHandler {
-
-        /**
-         * Fired on successful completion of call.
-         *
-         * @param result     The RPC result transformed into the type that was specified in call.
-         */
-        public void onResult(Object result);
-
-        /**
-         * Fired on call failure.
-         *
-         * @param errorUri   The URI or CURIE of the error that occurred.
-         * @param errorDesc  A human readable description of the error.
-         */
-        public void onError(String errorUri, String errorDesc);
-    }
-
-    /**
-     * Call a remote procedure (RPC).
-     *
-     * @param procUri       The URI or CURIE of the remote procedure to call.
-     * @param resultType    The type the call result gets transformed into.
-     * @param callHandler   The handler to be invoked upon call completion.
-     * @param arguments     Zero, one or more arguments for the call.
-     */
-    public void call(String procUri, Class<?> resultType, CallHandler callHandler, Object... arguments);
-
-    /**
-     * Call a remote procedure (RPC).
-     *
-     * @param procUri       The URI or CURIE of the remote procedure to call.
-     * @param resultType    The type the call result gets transformed into.
-     * @param callHandler   The handler to be invoked upon call completion.
-     * @param arguments     Zero, one or more arguments for the call.
-     */
-    public void call(String procUri, TypeReference<?> resultType, CallHandler callHandler, Object... arguments);
-
-    /**
-     * Handler for PubSub events.
-     */
-    public interface EventHandler {
-
-        /**
-         * Fired when an event for the PubSub subscription is received.
-         *
-         * @param topicUri   The URI or CURIE of the topic the event was published to.
-         * @param event      The event, transformed into the type that was specified when subscribing.
-         */
-        public void onEvent(String topicUri, Object event);
-    }
-
-    /**
-     * Subscribe to a topic. When already subscribed, overwrite the event handler.
-     *
-     * @param topicUri      The URI or CURIE of the topic to subscribe to.
-     * @param eventType     The type that event get transformed into.
-     * @param eventHandler  The event handler.
-     */
-    public void subscribe(String topicUri, Class<?> eventType, EventHandler eventHandler);
-
-    /**
-     * Subscribe to a topic. When already subscribed, overwrite the event handler.
-     *
-     * @param topicUri      The URI or CURIE of the topic to subscribe to.
-     * @param eventType     The type that event get transformed into.
-     * @param eventHandler  The event handler.
-     */
-    public void subscribe(String topicUri, TypeReference<?> eventType, EventHandler eventHandler);
-
-    /**
-     * Unsubscribe from given topic.
-     *
-     * @param topicUri      The URI or CURIE of the topic to unsubscribe from.
-     */
-    public void unsubscribe(String topicUri);
-
-    /**
-     * Unsubscribe from any topics subscribed.
-     */
-    public void unsubscribe();
-
-    /**
-     * Publish an event to the specified topic.
-     *
-     * @param topicUri      The URI or CURIE of the topic the event is to be published for.
-     * @param event         The event to be published.
-     */
-    public void publish(String topicUri, Object event);
-
-}
diff --git a/Autobahn/src/de/tavendo/autobahn/WampConnection.java b/Autobahn/src/de/tavendo/autobahn/WampConnection.java
deleted file mode 100644
index 68caf43..0000000
--- a/Autobahn/src/de/tavendo/autobahn/WampConnection.java
+++ /dev/null
@@ -1,452 +0,0 @@
-/******************************************************************************
- *
- *  Copyright 2011-2012 Tavendo GmbH
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-package de.tavendo.autobahn;
-
-import java.util.List;
-import java.util.Random;
-import java.util.concurrent.ConcurrentHashMap;
-
-import org.codehaus.jackson.type.TypeReference;
-
-import android.os.HandlerThread;
-import android.support.v4.util.Pair;
-import android.util.Log;
-
-public class WampConnection extends WebSocketConnection implements Wamp {
-
-   private static final boolean DEBUG = true;
-   private static final String TAG = WampConnection.class.getName();
-
-
-   /// The message handler of the background writer.
-   protected WampWriter mWriterHandler;
-
-   /// Prefix map for outgoing messages.
-   private final PrefixMap mOutgoingPrefixes = new PrefixMap();
-
-   /// RNG for IDs.
-   private final Random mRng = new Random();
-
-   /// Set of chars to be used for IDs.
-   private static final char[] mBase64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
-         .toCharArray();
-
-   /**
-    * RPC metadata.
-    */
-   public static class CallMeta {
-
-      CallMeta(CallHandler handler, Class<?> resultClass) {
-         this.mResultHandler = handler;
-         this.mResultClass = resultClass;
-         this.mResultTypeRef = null;
-      }
-
-      CallMeta(CallHandler handler, TypeReference<?> resultTypeReference) {
-         this.mResultHandler = handler;
-         this.mResultClass = null;
-         this.mResultTypeRef = resultTypeReference;
-      }
-
-      /// Call handler to be fired on.
-      public CallHandler mResultHandler;
-
-      /// Desired call result type or null.
-      public Class<?> mResultClass;
-
-      /// Desired call result type or null.
-      public TypeReference<?> mResultTypeRef;
-   }
-
-   /// Metadata about issued, but not yet returned RPCs.
-   private final ConcurrentHashMap<String, CallMeta> mCalls = new ConcurrentHashMap<String, CallMeta>();
-
-   /**
-    * Event subscription metadata.
-    */
-   public static class SubMeta {
-
-      SubMeta(EventHandler handler, Class<?> resultClass) {
-         this.mEventHandler = handler;
-         this.mEventClass = resultClass;
-         this.mEventTypeRef = null;
-      }
-
-      SubMeta(EventHandler handler, TypeReference<?> resultTypeReference) {
-         this.mEventHandler = handler;
-         this.mEventClass = null;
-         this.mEventTypeRef = resultTypeReference;
-      }
-
-      /// Event handler to be fired on.
-      public EventHandler mEventHandler;
-
-      /// Desired event type or null.
-      public Class<?> mEventClass;
-
-      /// Desired event type or null.
-      public TypeReference<?> mEventTypeRef;
-   }
-
-   /// Metadata about active event subscriptions.
-   private final ConcurrentHashMap<String, SubMeta> mSubs = new ConcurrentHashMap<String, SubMeta>();
-
-   /// The session handler provided to connect().
-   private Wamp.ConnectionHandler mSessionHandler;
-
-
-   /**
-    * Create the connection transmitting leg writer.
-    */
-   protected void createWriter() {
-
-      mWriterThread = new HandlerThread("AutobahnWriter");
-      mWriterThread.start();
-      mWriter = new WampWriter(mWriterThread.getLooper(), mMasterHandler, mTransportChannel, mOptions);
-
-      if (DEBUG) Log.d(TAG, "writer created and started");
-   }
-
-
-   /**
-    * Create the connection receiving leg reader.
-    */
-   protected void createReader() {
-      mReader = new WampReader(mCalls, mSubs, mMasterHandler, mTransportChannel, mOptions, "AutobahnReader");
-      mReader.start();
-
-      if (DEBUG) Log.d(TAG, "reader created and started");
-   }
-
-
-   /**
-    * Create new random ID. This is used, i.e. for use in RPC calls to correlate
-    * call message with result message.
-    *
-    * @param len    Length of ID.
-    * @return       New random ID of given length.
-    */
-   private String newId(int len) {
-      char[] buffer = new char[len];
-      for (int i = 0; i < len; i++) {
-         buffer[i] = mBase64Chars[mRng.nextInt(mBase64Chars.length)];
-      }
-      return new String(buffer);
-   }
-
-
-   /**
-    * Create new random ID of default length.
-    *
-    * @return    New random ID of default length.
-    */
-   private String newId() {
-      return newId(8);
-   }
-
-
-   public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler) {
-
-      WampOptions options = new WampOptions();
-      options.setReceiveTextMessagesRaw(true);
-      options.setMaxMessagePayloadSize(64*1024);
-      options.setMaxFramePayloadSize(64*1024);
-      options.setTcpNoDelay(true);
-
-      connect(wsUri, sessionHandler, options, null);
-   }
-
-
-   /**
-    * Connect to server.
-    *
-    * @param wsUri            WebSockets server URI.
-    * @param sessionHandler   The session handler to fire callbacks on.
-    * @param headers		   The headers for connection
-    */
-   public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler, WampOptions options, List<Pair> headers) {
-
-      mSessionHandler = sessionHandler;
-
-      mCalls.clear();
-      mSubs.clear();
-      mOutgoingPrefixes.clear();
-
-      try {
-         connect(wsUri, new String[] {"wamp"}, new WebSocketConnectionHandler() {
-
-            @Override
-            public void onOpen() {
-               if (mSessionHandler != null) {
-                  mSessionHandler.onOpen();
-               } else {
-                  if (DEBUG) Log.d(TAG, "could not call onOpen() .. handler already NULL");
-               }
-            }
-
-            @Override
-            public void onClose(int code, String reason) {
-               if (mSessionHandler != null) {
-                  mSessionHandler.onClose(code, reason);
-               } else {
-                  if (DEBUG) Log.d(TAG, "could not call onClose() .. handler already NULL");
-               }
-            }
-
-         }, options, headers);
-
-      } catch (WebSocketException e) {
-
-         if (mSessionHandler != null) {
-            mSessionHandler.onClose(WebSocketConnectionHandler.CLOSE_CANNOT_CONNECT, "cannot connect (" + e.toString() + ")");
-         } else {
-            if (DEBUG) Log.d(TAG, "could not call onClose() .. handler already NULL");
-         }
-      }
-
-   }
-	
-   public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler, List<Pair> headers) {
-
-	   WampOptions options = new WampOptions();
-	   options.setReceiveTextMessagesRaw(true);
-	   options.setMaxMessagePayloadSize(64*1024);
-	   options.setMaxFramePayloadSize(64*1024);
-	   options.setTcpNoDelay(true);
-
-	   connect(wsUri, sessionHandler, options, headers);
-   }
-
-   public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler, WampOptions options) {	
-
-	   connect(wsUri, sessionHandler, options, null);
-   }
-
-
-   /**
-    * Process WAMP messages coming from the background reader.
-    */
-   protected void processAppMessage(Object message) {
-
-      if (message instanceof WampMessage.CallResult) {
-
-         WampMessage.CallResult callresult = (WampMessage.CallResult) message;
-
-         if (mCalls.containsKey(callresult.mCallId)) {
-            CallMeta meta = mCalls.get(callresult.mCallId);
-            if (meta.mResultHandler != null) {
-               meta.mResultHandler.onResult(callresult.mResult);
-            }
-            mCalls.remove(callresult.mCallId);
-         }
-
-      } else if (message instanceof WampMessage.CallError) {
-
-         WampMessage.CallError callerror = (WampMessage.CallError) message;
-
-         if (mCalls.containsKey(callerror.mCallId)) {
-            CallMeta meta = mCalls.get(callerror.mCallId);
-            if (meta.mResultHandler != null) {
-               meta.mResultHandler.onError(callerror.mErrorUri, callerror.mErrorDesc);
-            }
-            mCalls.remove(callerror.mCallId);
-         }
-      } else if (message instanceof WampMessage.Event) {
-
-         WampMessage.Event event = (WampMessage.Event) message;
-
-         if (mSubs.containsKey(event.mTopicUri)) {
-            SubMeta meta = mSubs.get(event.mTopicUri);
-            if (meta != null && meta.mEventHandler != null) {
-               meta.mEventHandler.onEvent(event.mTopicUri, event.mEvent);
-            }
-         }
-      } else if (message instanceof WampMessage.Welcome) {
-
-         WampMessage.Welcome welcome = (WampMessage.Welcome) message;
-
-         // FIXME: safe session ID / fire session opened hook
-         if (DEBUG) Log.d(TAG, "WAMP session " + welcome.mSessionId + " established (protocol version " + welcome.mProtocolVersion + ", server " + welcome.mServerIdent + ")");
-
-      } else {
-
-         if (DEBUG) Log.d(TAG, "unknown WAMP message in AutobahnConnection.processAppMessage");
-      }
-   }
-
-
-   /**
-    * Issue a remote procedure call (RPC).
-    *
-    * @param procUri       URI or CURIE of procedure to call.
-    * @param resultMeta    Call result metadata.
-    * @param arguments     Call arguments.
-    */
-   private void call(String procUri, CallMeta resultMeta, Object... arguments) {
-
-      WampMessage.Call call = new WampMessage.Call(newId(), procUri, arguments.length);
-      for (int i = 0; i < arguments.length; ++i) {
-         call.mArgs[i] = arguments[i];
-      }
-      mCalls.put(call.mCallId, resultMeta);
-      mWriter.forward(call);
-   }
-
-
-   /**
-    * Issue a remote procedure call (RPC). This version should be used with
-    * primitive Java types and simple composite (class) types.
-    *
-    * @param procUri          URI or CURIE of procedure to call.
-    * @param resultType       Type we want the call result to be converted to.
-    * @param resultHandler    Call handler to process call result or error.
-    * @param arguments        Call arguments.
-    */
-   public void call(String procUri, Class<?> resultType, CallHandler resultHandler, Object... arguments) {
-
-      call(procUri, new CallMeta(resultHandler, resultType), arguments);
-   }
-
-
-   /**
-    * Issue a remote procedure call (RPC). This version should be used with
-    * result types which are containers, i.e. List<> or Map<>.
-    *
-    * @param procUri          URI or CURIE of procedure to call.
-    * @param resultType       Type we want the call result to be converted to.
-    * @param resultHandler    Call handler to process call result or error.
-    * @param arguments        Call arguments.
-    */
-   public void call(String procUri, TypeReference<?> resultType, CallHandler resultHandler, Object... arguments) {
-
-      call(procUri, new CallMeta(resultHandler, resultType), arguments);
-   }
-
-
-   /**
-    * Subscribe to topic to receive events for.
-    *
-    * @param topicUri         URI or CURIE of topic to subscribe to.
-    * @param meta             Subscription metadata.
-    */
-   private void subscribe(String topicUri, SubMeta meta) {
-
-      String uri = mOutgoingPrefixes.resolveOrPass(topicUri);
-
-      if (!mSubs.containsKey(uri)) {
-
-         mSubs.put(uri, meta);
-
-         WampMessage.Subscribe msg = new WampMessage.Subscribe(mOutgoingPrefixes.shrink(topicUri));
-         mWriter.forward(msg);
-      }
-   }
-
-
-   /**
-    * Subscribe to topic to receive events for. This version should be used with
-    * result types which are containers, i.e. List<> or Map<>.
-    *
-    * @param topicUri         URI or CURIE of topic to subscribe to.
-    * @param eventType        The type we want events to be converted to.
-    * @param eventHandler     The event handler to process received events.
-    */
-   public void subscribe(String topicUri, Class<?> eventType, EventHandler eventHandler) {
-
-      subscribe(topicUri, new SubMeta(eventHandler, eventType));
-   }
-
-
-   /**
-    * Subscribe to topic to receive events for.  This version should be used with
-    * primitive Java types and simple composite (class) types.
-    *
-    * @param topicUri         URI or CURIE of topic to subscribe to.
-    * @param eventType        The type we want events to be converted to.
-    * @param eventHandler     The event handler to process received events.
-    */
-   public void subscribe(String topicUri, TypeReference<?> eventType, EventHandler eventHandler) {
-
-      subscribe(topicUri, new SubMeta(eventHandler, eventType));
-   }
-
-
-   /**
-    * Unsubscribe from topic.
-    *
-    * @param topicUri      URI or CURIE of topic to unsubscribe from.
-    */
-   public void unsubscribe(String topicUri) {
-
-      if (mSubs.containsKey(topicUri)) {
-
-         WampMessage.Unsubscribe msg = new WampMessage.Unsubscribe(topicUri);
-         mWriter.forward(msg);
-         
-         mSubs.remove(topicUri);
-      }
-   }
-
-
-   /**
-    * Unsubscribe from any subscribed topic.
-    */
-   public void unsubscribe() {
-
-      for (String topicUri : mSubs.keySet()) {
-
-         WampMessage.Unsubscribe msg = new WampMessage.Unsubscribe(topicUri);
-         mWriter.forward(msg);
-      }
-      mSubs.clear();
-   }
-
-
-   /**
-    * Establish a prefix to be used in CURIEs.
-    *
-    * @param prefix     The prefix to be used in CURIEs.
-    * @param uri        The full URI this prefix shall resolve to.
-    */
-   public void prefix(String prefix, String uri) {
-
-      String currUri = mOutgoingPrefixes.get(prefix);
-
-      if (currUri == null || !currUri.equals(uri)) {
-
-         mOutgoingPrefixes.set(prefix, uri);
-
-         WampMessage.Prefix msg = new WampMessage.Prefix(prefix, uri);
-         mWriter.forward(msg);
-      }
-   }
-
-
-   /**
-    * Publish an event to a topic.
-    *
-    * @param topicUri   URI or CURIE of topic to publish event on.
-    * @param event      Event to be published.
-    */
-   public void publish(String topicUri, Object event) {
-
-      WampMessage.Publish msg = new WampMessage.Publish(mOutgoingPrefixes.shrink(topicUri), event);
-      mWriter.forward(msg);
-   }
-}
diff --git a/Autobahn/src/de/tavendo/autobahn/WampConnectionHandler.java b/Autobahn/src/de/tavendo/autobahn/WampConnectionHandler.java
deleted file mode 100644
index de1e1fc..0000000
--- a/Autobahn/src/de/tavendo/autobahn/WampConnectionHandler.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package de.tavendo.autobahn;
-
-public class WampConnectionHandler implements Wamp.ConnectionHandler {
-
-	public void onOpen() {
-		// TODO Auto-generated method stub
-		
-	}
-
-	public void onClose(int code, String reason) {
-		// TODO Auto-generated method stub
-		
-	}
-
-}
diff --git a/Autobahn/src/de/tavendo/autobahn/WampCra.java b/Autobahn/src/de/tavendo/autobahn/WampCra.java
deleted file mode 100644
index 32e0253..0000000
--- a/Autobahn/src/de/tavendo/autobahn/WampCra.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/******************************************************************************
- *
- *  Copyright 2012 Alejandro Hernandez
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-package de.tavendo.autobahn;
-
-public interface WampCra extends Wamp {
-    
-    /**
-     * Auth handler.
-     */
-    public interface AuthHandler {
-
-       /**
-        * Fired on successful completion of authentication.
-        *
-        * @param permissions    The permissions obtained on successful authentication.
-        */
-       public void onAuthSuccess(Object permissions);
-
-       /**
-        * Fired on authentication failure.
-        *
-        * @param errorUri   The URI or CURIE of the error that occurred.
-        * @param errorDesc  A human readable description of the error.
-        */
-       public void onAuthError(String errorUri, String errorDesc);
-    }
-    
-    
-    /**
-     * Authenticate the WAMP Session.
-     *
-     * @param authHandler   The handler to be invoked upon authentication completion.
-     * @param authKey       The user Key for authentication.
-     * @param authSecret    The user Secret for authentication.
-     */
-    public void authenticate(AuthHandler authHandler, String authKey, String authSecret);
-    
-    /**
-     * Authenticate the WAMP Session.
-     *
-     * @param authHandler   The handler to be invoked upon authentication completion.
-     * @param authKey       The user Key for authentication.
-     * @param authSecret    The user Secret for authentication.
-     * @param authExtra     Zero, one or more extra arguments for the authentication.
-     */
-    public void authenticate(AuthHandler authHandler, String authKey, String authSecret, Object authExtra);
-    
-    
-}
diff --git a/Autobahn/src/de/tavendo/autobahn/WampCraConnection.java b/Autobahn/src/de/tavendo/autobahn/WampCraConnection.java
deleted file mode 100644
index 3a999c9..0000000
--- a/Autobahn/src/de/tavendo/autobahn/WampCraConnection.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/******************************************************************************
- *
- *  Copyright 2012 Alejandro Hernandez
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-package de.tavendo.autobahn;
-
-import java.security.InvalidKeyException;
-import java.security.Key;
-import java.security.NoSuchAlgorithmException;
-import java.security.SignatureException;
-
-import javax.crypto.Mac;
-import javax.crypto.spec.SecretKeySpec;
-
-import android.util.Base64;
-import android.util.Log;
-
-public class WampCraConnection extends WampConnection implements WampCra {
-
-    public void authenticate(final AuthHandler authHandler, final String authKey, final String authSecret){
-        authenticate(authHandler, authKey, authSecret, null);
-    }
-    
-    public void authenticate(final AuthHandler authHandler, final String authKey, final String authSecret, Object authExtra) {
-        CallHandler callHandler = new CallHandler(){
-
-            public void onResult(Object challenge) {
-                
-                String sig = null;
-                try {
-                    sig = authSignature((String)challenge, authSecret);
-                } catch (SignatureException e) {
-                    Log.e("WampCraConnection:authenicate",e.toString());
-                }
-                
-                call(Wamp.URI_WAMP_PROCEDURE + "auth", WampCraPermissions.class, new CallHandler(){
-
-                    public void onResult(Object result) {
-                        authHandler.onAuthSuccess(result);
-                    }
-
-                    public void onError(String errorUri, String errorDesc) {
-                        authHandler.onAuthError(errorUri,errorDesc);                
-                    }
-                    
-                }, sig);
-                
-                
-            }
-
-            public void onError(String errorUri, String errorDesc) {
-                authHandler.onAuthError(errorUri,errorDesc);                
-            }
-            
-        };
-        if (authExtra != null)
-            call(Wamp.URI_WAMP_PROCEDURE + "authreq", String.class, callHandler, authKey, authExtra);
-        else
-            call(Wamp.URI_WAMP_PROCEDURE + "authreq", String.class, callHandler, authKey);
-    }
-
-    public String authSignature(String authChallenge, String authSecret) throws SignatureException{
-        try {
-            Key sk = new SecretKeySpec(authSecret.getBytes(), HASH_ALGORITHM);
-            Mac mac = Mac.getInstance(sk.getAlgorithm());
-            mac.init(sk);
-            final byte[] hmac = mac.doFinal(authChallenge.getBytes());
-            return Base64.encodeToString(hmac,Base64.NO_WRAP);
-        } catch (NoSuchAlgorithmException e1) {
-            throw new SignatureException("error building signature, no such algorithm in device " + HASH_ALGORITHM);
-        } catch (InvalidKeyException e) {
-            throw new SignatureException("error building signature, invalid key " + HASH_ALGORITHM);
-        }
-    }
-
-    private static final String HASH_ALGORITHM = "HmacSHA256";
-    
-}
diff --git a/Autobahn/src/de/tavendo/autobahn/WampCraPermissions.java b/Autobahn/src/de/tavendo/autobahn/WampCraPermissions.java
deleted file mode 100644
index 9ae93e1..0000000
--- a/Autobahn/src/de/tavendo/autobahn/WampCraPermissions.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/******************************************************************************
- *
- *  Copyright 2012 Alejandro Hernandez
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-package de.tavendo.autobahn;
-
-public class WampCraPermissions {
-    
-    public WampCraRpcPermission[] rpc;
-    public WampCraPubSubPermission[] pubsub;
-    
-    public WampCraPermissions() {
-    }
-
-    public WampCraPermissions(WampCraRpcPermission[] rpc, WampCraPubSubPermission[] pubsub) {
-        this.rpc = rpc;
-        this.pubsub = pubsub;
-    }
-
-    public WampCraRpcPermission[] getRpc() {
-        return rpc;
-    }
-
-    public void setRpc(WampCraRpcPermission[] rpc) {
-        this.rpc = rpc;
-    }
-
-    public WampCraPubSubPermission[] getPubsub() {
-        return pubsub;
-    }
-
-    public void setPubsub(WampCraPubSubPermission[] pubsub) {
-        this.pubsub = pubsub;
-    }
-    
-    
-    
-}
diff --git a/Autobahn/src/de/tavendo/autobahn/WampCraPubSubPermission.java b/Autobahn/src/de/tavendo/autobahn/WampCraPubSubPermission.java
deleted file mode 100644
index c545cd2..0000000
--- a/Autobahn/src/de/tavendo/autobahn/WampCraPubSubPermission.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/******************************************************************************
- *
- *  Copyright 2012 Alejandro Hernandez
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-package de.tavendo.autobahn;
-
-public class WampCraPubSubPermission{
-    
-    boolean prefix;
-    String uri;
-    boolean pub;
-    boolean sub;
-    
-    public WampCraPubSubPermission() {
-    }
-       
-    public WampCraPubSubPermission(boolean prefix, String uri, boolean pub, boolean sub) {
-        this.prefix = prefix;
-        this.uri = uri;
-        this.pub = pub;
-        this.sub = sub;
-    }
-    
-    public boolean isPrefix() {
-        return prefix;
-    }
-    public void setPrefix(boolean prefix) {
-        this.prefix = prefix;
-    }
-    public String getUri() {
-        return uri;
-    }
-    public void setUri(String uri) {
-        this.uri = uri;
-    }
-    public boolean isPub() {
-        return pub;
-    }
-    public void setPub(boolean pub) {
-        this.pub = pub;
-    }
-    public boolean isSub() {
-        return sub;
-    }
-    public void setSub(boolean sub) {
-        this.sub = sub;
-    }
-    
-    
-}   
diff --git a/Autobahn/src/de/tavendo/autobahn/WampCraRpcPermission.java b/Autobahn/src/de/tavendo/autobahn/WampCraRpcPermission.java
deleted file mode 100644
index f569d7b..0000000
--- a/Autobahn/src/de/tavendo/autobahn/WampCraRpcPermission.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/******************************************************************************
- *
- *  Copyright 2012 Alejandro Hernandez
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-package de.tavendo.autobahn;
-
-public class WampCraRpcPermission{
-    
-    boolean call;
-    String uri;
-    
-    public WampCraRpcPermission() {
-    }
-    
-    public WampCraRpcPermission(boolean call, String uri) {
-        this.call = call;
-        this.uri = uri;
-    }
-    public boolean isCall() {
-        return call;
-    }
-    public void setCall(boolean call) {
-        this.call = call;
-    }
-    public String getUri() {
-        return uri;
-    }
-    public void setUri(String uri) {
-        this.uri = uri;
-    }
-    
-    
-    
-}
diff --git a/Autobahn/src/de/tavendo/autobahn/WampMessage.java b/Autobahn/src/de/tavendo/autobahn/WampMessage.java
deleted file mode 100644
index b2d7f3a..0000000
--- a/Autobahn/src/de/tavendo/autobahn/WampMessage.java
+++ /dev/null
@@ -1,171 +0,0 @@
-/******************************************************************************
- *
- *  Copyright 2011-2012 Tavendo GmbH
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-package de.tavendo.autobahn;
-
-
-/**
- * The master thread and the background reader/writer threads communicate
- * using these messages for Autobahn WAMP connections.
- */
-public class WampMessage {
-
-   public static final int MESSAGE_TYPE_WELCOME = 0;
-   public static final int MESSAGE_TYPE_PREFIX = 1;
-   public static final int MESSAGE_TYPE_CALL = 2;
-   public static final int MESSAGE_TYPE_CALL_RESULT = 3;
-   public static final int MESSAGE_TYPE_CALL_ERROR = 4;
-   public static final int MESSAGE_TYPE_SUBSCRIBE = 5;
-   public static final int MESSAGE_TYPE_UNSUBSCRIBE = 6;
-   public static final int MESSAGE_TYPE_PUBLISH = 7;
-   public static final int MESSAGE_TYPE_EVENT = 8;
-
-
-   /// Base message class.
-   public static class Message extends WebSocketMessage.Message {
-
-   }
-
-   /**
-    * RPC request message.
-    * Client-to-server message.
-    */
-   public static class Call extends Message {
-      public String mCallId;
-      public String mProcUri;
-      public Object[] mArgs;
-
-      public Call(String callId, String procUri, int argCount) {
-         mCallId = callId;
-         mProcUri = procUri;
-         mArgs = new Object[argCount];
-      }
-   }
-
-   /**
-    * RPC success response message.
-    * Server-to-client message.
-    */
-   public static class CallResult extends Message {
-      public String mCallId;
-      public Object mResult;
-
-      public CallResult(String callId, Object result) {
-         mCallId = callId;
-         mResult = result;
-      }
-   }
-
-   /**
-    * RPC failure response message.
-    * Server-to-client message.
-    */
-   public static class CallError extends Message {
-      public String mCallId;
-      public String mErrorUri;
-      public String mErrorDesc;
-
-      public CallError(String callId, String errorUri, String errorDesc) {
-         mCallId = callId;
-         mErrorUri = errorUri;
-         mErrorDesc = errorDesc;
-      }
-   }
-
-   /**
-    * Define Welcome message.
-    * Server-to-client message.
-    */
-   public static class Welcome extends Message {
-      public String mSessionId;
-      public int mProtocolVersion;
-      public String mServerIdent;
-
-      public Welcome(String sessionId, int protocolVersion, String serverIdent) {
-         mSessionId = sessionId;
-         mProtocolVersion = protocolVersion;
-         mServerIdent = serverIdent;
-      }
-   }
-
-   /**
-    * Define CURIE message.
-    * Server-to-client and client-to-server message.
-    */
-   public static class Prefix extends Message {
-      public String mPrefix;
-      public String mUri;
-
-      public Prefix(String prefix, String uri) {
-         mPrefix = prefix;
-         mUri = uri;
-      }
-   }
-
-   /**
-    * Publish to topic URI request message.
-    * Client-to-server message.
-    */
-   public static class Publish extends Message {
-      public String mTopicUri;
-      public Object mEvent;
-
-      public Publish(String topicUri, Object event) {
-         mTopicUri = topicUri;
-         mEvent = event;
-      }
-   }
-
-   /**
-    * Subscribe to topic URI request message.
-    * Client-to-server message.
-    */
-   public static class Subscribe extends Message {
-      public String mTopicUri;
-
-      public Subscribe(String topicUri) {
-         mTopicUri = topicUri;
-      }
-   }
-
-   /**
-    * Unsubscribe from topic URI request message.
-    * Client-to-server message.
-    */
-   public static class Unsubscribe extends Message {
-      public String mTopicUri;
-
-      public Unsubscribe(String topicUri) {
-         mTopicUri = topicUri;
-      }
-   }
-
-   /**
-    * Event on topic URI message.
-    * Server-to-client message.
-    */
-   public static class Event extends Message {
-      public String mTopicUri;
-      public Object mEvent;
-
-      public Event(String topicUri, Object event) {
-         mTopicUri = topicUri;
-         mEvent = event;
-      }
-   }
-}
diff --git a/Autobahn/src/de/tavendo/autobahn/WampOptions.java b/Autobahn/src/de/tavendo/autobahn/WampOptions.java
deleted file mode 100644
index e7e7497..0000000
--- a/Autobahn/src/de/tavendo/autobahn/WampOptions.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/******************************************************************************
- *
- *  Copyright 2011-2012 Tavendo GmbH
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-package de.tavendo.autobahn;
-
-public class WampOptions extends WebSocketOptions {
-
-}
diff --git a/Autobahn/src/de/tavendo/autobahn/WampReader.java b/Autobahn/src/de/tavendo/autobahn/WampReader.java
deleted file mode 100644
index 0f3f656..0000000
--- a/Autobahn/src/de/tavendo/autobahn/WampReader.java
+++ /dev/null
@@ -1,257 +0,0 @@
-/******************************************************************************
- *
- *  Copyright 2011-2012 Tavendo GmbH
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-package de.tavendo.autobahn;
-
-import java.io.IOException;
-import java.nio.channels.SocketChannel;
-import java.util.concurrent.ConcurrentHashMap;
-
-import org.codehaus.jackson.JsonFactory;
-import org.codehaus.jackson.JsonParseException;
-import org.codehaus.jackson.JsonParser;
-import org.codehaus.jackson.JsonToken;
-import org.codehaus.jackson.map.DeserializationConfig;
-import org.codehaus.jackson.map.ObjectMapper;
-
-import android.os.Handler;
-import android.util.Log;
-import de.tavendo.autobahn.WampConnection.CallMeta;
-import de.tavendo.autobahn.WampConnection.SubMeta;
-
-/**
- * Autobahn WAMP reader, the receiving leg of a WAMP connection.
- */
-public class WampReader extends WebSocketReader {
-
-   private static final boolean DEBUG = true;
-   private static final String TAG = WampReader.class.getName();
-
-   /// Jackson JSON-to-object mapper.
-   private final ObjectMapper mJsonMapper;
-
-   /// Jackson JSON factory from which we create JSON parsers.
-   private final JsonFactory mJsonFactory;
-
-   /// Holds reference to call map created on master.
-   private final ConcurrentHashMap<String, CallMeta> mCalls;
-
-   /// Holds reference to event subscription map created on master.
-   private final ConcurrentHashMap<String, SubMeta> mSubs;
-
-   /**
-    * A reader object is created in AutobahnConnection.
-    *
-    * @param calls         The call map created on master.
-    * @param subs          The event subscription map created on master.
-    * @param master        Message handler of master (used by us to notify the master).
-    * @param socket        The TCP socket.
-    * @param options       WebSockets connection options.
-    * @param threadName    The thread name we announce.
-    */
-   public WampReader(ConcurrentHashMap<String, CallMeta> calls,
-                         ConcurrentHashMap<String, SubMeta> subs,
-                         Handler master,
-                         SocketChannel socket,
-                         WebSocketOptions options,
-                         String threadName) {
-
-      super(master, socket, options, threadName);
-
-      mCalls = calls;
-      mSubs = subs;
-
-      mJsonMapper = new ObjectMapper();
-      mJsonMapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false);
-      mJsonFactory = mJsonMapper.getJsonFactory();
-
-      if (DEBUG) Log.d(TAG, "created");
-   }
-
-   protected void onTextMessage(String payload) {
-
-      /// \todo make error propagation consistent
-      notify(new WebSocketMessage.Error(new WebSocketException("non-raw receive of text message")));
-   }
-
-   protected void onBinaryMessage(byte[] payload) {
-
-      /// \todo make error propagation consistent
-      notify(new WebSocketMessage.Error(new WebSocketException("received binary message")));
-   }
-
-   /**
-    * Unwraps a WAMP message which is a WebSockets text message with JSON
-    * payload conforming to WAMP.
-    */
-   protected void onRawTextMessage(byte[] payload) {
-
-      try {
-
-         // create parser on top of raw UTF-8 payload
-         JsonParser parser = mJsonFactory.createJsonParser(payload);
-
-         // all Autobahn messages are JSON arrays
-         if (parser.nextToken() == JsonToken.START_ARRAY) {
-
-            // message type
-            if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {
-
-               int msgType = parser.getIntValue();
-
-               if (msgType == WampMessage.MESSAGE_TYPE_CALL_RESULT) {
-
-                  // call ID
-                  parser.nextToken();
-                  String callId = parser.getText();
-
-                  // result
-                  parser.nextToken();
-                  Object result = null;
-
-                  if (mCalls.containsKey(callId)) {
-
-                     CallMeta meta = mCalls.get(callId);
-                     if (meta.mResultClass != null) {
-                        result = parser.readValueAs(meta.mResultClass);
-                     } else if (meta.mResultTypeRef != null) {
-                        result = parser.readValueAs(meta.mResultTypeRef);
-                     } else {
-                     }
-                     notify(new WampMessage.CallResult(callId, result));
-
-                  } else {
-
-                     if (DEBUG) Log.d(TAG, "WAMP RPC success return for unknown call ID received");
-                  }
-
-               } else if (msgType == WampMessage.MESSAGE_TYPE_CALL_ERROR) {
-
-                  // call ID
-                  parser.nextToken();
-                  String callId = parser.getText();
-
-                  // error URI
-                  parser.nextToken();
-                  String errorUri = parser.getText();
-
-                  // error description
-                  parser.nextToken();
-                  String errorDesc = parser.getText();
-
-                  if (mCalls.containsKey(callId)) {
-
-                     notify(new WampMessage.CallError(callId, errorUri, errorDesc));
-
-                  } else {
-
-                     if (DEBUG) Log.d(TAG, "WAMP RPC error return for unknown call ID received");
-                  }
-
-               } else if (msgType == WampMessage.MESSAGE_TYPE_EVENT) {
-
-                  // topic URI
-                  parser.nextToken();
-                  String topicUri = parser.getText();
-
-                  // event
-                  parser.nextToken();
-                  Object event = null;
-
-                  if (mSubs.containsKey(topicUri)) {
-
-                     SubMeta meta = mSubs.get(topicUri);
-                     if (meta.mEventClass != null) {
-                        event = parser.readValueAs(meta.mEventClass);
-                     } else if (meta.mEventTypeRef != null) {
-                        event = parser.readValueAs(meta.mEventTypeRef);
-                     } else {
-                     }
-                     notify(new WampMessage.Event(topicUri, event));
-
-                  } else {
-
-                     if (DEBUG) Log.d(TAG, "WAMP event for not-subscribed topic received");
-                  }
-
-               } else if (msgType == WampMessage.MESSAGE_TYPE_PREFIX) {
-
-                  // prefix
-                  parser.nextToken();
-                  String prefix = parser.getText();
-
-                  // URI
-                  parser.nextToken();
-                  String uri = parser.getText();
-
-                  notify(new WampMessage.Prefix(prefix, uri));
-
-               } else if (msgType == WampMessage.MESSAGE_TYPE_WELCOME) {
-
-                  // session ID
-                  parser.nextToken();
-                  String sessionId = parser.getText();
-
-                  // protocol version
-                  parser.nextToken();
-                  int protocolVersion = parser.getIntValue();
-
-                  // server ident
-                  parser.nextToken();
-                  String serverIdent = parser.getText();
-
-                  notify(new WampMessage.Welcome(sessionId, protocolVersion, serverIdent));
-
-               } else {
-
-                  // FIXME: invalid WAMP message
-                  if (DEBUG) Log.d(TAG, "invalid WAMP message: unrecognized message type");
-
-               }
-            } else {
-
-               if (DEBUG) Log.d(TAG, "invalid WAMP message: missing message type or message type not an integer");
-            }
-
-            if (parser.nextToken() == JsonToken.END_ARRAY) {
-
-               // nothing to do here
-
-            } else {
-
-               if (DEBUG) Log.d(TAG, "invalid WAMP message: missing array close or invalid additional args");
-            }
-
-         } else {
-
-            if (DEBUG) Log.d(TAG, "invalid WAMP message: not an array");
-         }
-         parser.close();
-
-
-      } catch (JsonParseException e) {
-
-         if (DEBUG) e.printStackTrace();
-
-      } catch (IOException e) {
-
-         if (DEBUG) e.printStackTrace();
-
-      }
-   }
-}
diff --git a/Autobahn/src/de/tavendo/autobahn/WampWriter.java b/Autobahn/src/de/tavendo/autobahn/WampWriter.java
deleted file mode 100644
index 29f5da4..0000000
--- a/Autobahn/src/de/tavendo/autobahn/WampWriter.java
+++ /dev/null
@@ -1,167 +0,0 @@
-/******************************************************************************
- *
- *  Copyright 2011-2012 Tavendo GmbH
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-package de.tavendo.autobahn;
-
-import java.io.IOException;
-import java.nio.channels.SocketChannel;
-
-import org.codehaus.jackson.JsonFactory;
-import org.codehaus.jackson.JsonGenerationException;
-import org.codehaus.jackson.JsonGenerator;
-import org.codehaus.jackson.map.JsonMappingException;
-import org.codehaus.jackson.map.MappingJsonFactory;
-
-import android.os.Handler;
-import android.os.Looper;
-import android.util.Log;
-
-/**
- * Autobahn WAMP writer, the transmitting leg of a WAMP connection.
- * This writer serializes WAMP messages forwarded from the foreground thread
- * (the master) to this object running on the writer thread. WAMP messages are
- * serialized to JSON, and then sent via WebSockets.
- */
-public class WampWriter extends WebSocketWriter {
-
-   private static final boolean DEBUG = true;
-   private static final String TAG = WampWriter.class.getName();
-
-   /**
-    * This is the Jackson JSON factory we use to create JSON generators.
-    */
-   private final JsonFactory mJsonFactory;
-
-   /**
-    * This is where we buffer the JSON serialization of WAMP messages.
-    */
-   private final NoCopyByteArrayOutputStream mPayload;
-
-   /**
-    * A writer object is created in AutobahnConnection.
-    *
-    * @param looper     The message looper associated with the thread running this object.
-    * @param master     The message handler associated with the master thread (running AutobahnConnection).
-    * @param socket     The TCP socket (channel) the WebSocket connection runs over.
-    * @param options    WebSockets options for the underlying WebSockets connection.
-    */
-   public WampWriter(Looper looper, Handler master, SocketChannel socket,
-         WebSocketOptions options) {
-
-      super(looper, master, socket, options);
-
-      mJsonFactory = new MappingJsonFactory();
-      mPayload = new NoCopyByteArrayOutputStream();
-
-      if (DEBUG) Log.d(TAG, "created");
-   }
-
-   /**
-    * Called from WebSocketWriter when it receives a message in it's
-    * message loop it does not recognize.
-    */
-   protected void processAppMessage(Object msg) throws WebSocketException, IOException {
-
-      mPayload.reset();
-
-      // creating a JSON generator is supposed to be a light-weight operation
-      JsonGenerator generator = mJsonFactory.createJsonGenerator(mPayload);
-
-      try {
-
-         // serialize WAMP messages to JSON: the code here needs to understand
-         // any client-to-server WAMP messages forward from the foreground thread
-
-         if (msg instanceof WampMessage.Call) {
-
-            WampMessage.Call call = (WampMessage.Call) msg;
-
-            generator.writeStartArray();
-            generator.writeNumber(WampMessage.MESSAGE_TYPE_CALL);
-            generator.writeString(call.mCallId);
-            generator.writeString(call.mProcUri);
-            for (Object arg : call.mArgs) {
-               generator.writeObject(arg);
-            }
-            generator.writeEndArray();
-
-         } else if (msg instanceof WampMessage.Prefix) {
-
-            WampMessage.Prefix prefix = (WampMessage.Prefix) msg;
-
-            generator.writeStartArray();
-            generator.writeNumber(WampMessage.MESSAGE_TYPE_PREFIX);
-            generator.writeString(prefix.mPrefix);
-            generator.writeString(prefix.mUri);
-            generator.writeEndArray();
-
-         } else if (msg instanceof WampMessage.Subscribe) {
-
-            WampMessage.Subscribe subscribe = (WampMessage.Subscribe) msg;
-
-            generator.writeStartArray();
-            generator.writeNumber(WampMessage.MESSAGE_TYPE_SUBSCRIBE);
-            generator.writeString(subscribe.mTopicUri);
-            generator.writeEndArray();
-
-         } else if (msg instanceof WampMessage.Unsubscribe) {
-
-            WampMessage.Unsubscribe unsubscribe = (WampMessage.Unsubscribe) msg;
-
-            generator.writeStartArray();
-            generator.writeNumber(WampMessage.MESSAGE_TYPE_UNSUBSCRIBE);
-            generator.writeString(unsubscribe.mTopicUri);
-            generator.writeEndArray();
-
-         } else if (msg instanceof WampMessage.Publish) {
-
-            WampMessage.Publish publish = (WampMessage.Publish) msg;
-
-            generator.writeStartArray();
-            generator.writeNumber(WampMessage.MESSAGE_TYPE_PUBLISH);
-            generator.writeString(publish.mTopicUri);
-            generator.writeObject(publish.mEvent);
-            generator.writeEndArray();
-
-         } else {
-
-            // this should not happen, but to be sure
-            throw new WebSocketException("invalid message received by AutobahnWriter");
-         }
-      } catch (JsonGenerationException e) {
-
-         // this may happen, and we need to wrap the error
-         throw new WebSocketException("JSON serialization error (" + e.toString() + ")");
-
-      } catch (JsonMappingException e) {
-
-         // this may happen, and we need to wrap the error
-         throw new WebSocketException("JSON serialization error (" + e.toString() + ")");
-      }
-
-      // make sure the JSON generator has spit out everything
-      generator.flush();
-
-      // Jackson's JSON generator produces UTF-8 directly, so we send
-      // a text message frame using the raw sendFrame() method
-      sendFrame(1, true, mPayload.getByteArray(), 0, mPayload.size());
-
-      // cleanup generators resources
-      generator.close();
-   }
-}
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java b/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java
index 018e282..a61b241 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java
@@ -1,19 +1,17 @@
 /******************************************************************************
- *
- *  Copyright 2011-2012 Tavendo GmbH
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
+ * Copyright 2011-2012 Tavendo GmbH
+ * <p/>
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * <p/>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p/>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ******************************************************************************/
 
 package de.tavendo.autobahn;
@@ -30,498 +28,544 @@
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.nio.channels.SocketChannel;
+import java.security.KeyManagementException;
+import java.security.NoSuchAlgorithmException;
 import java.util.List;
 
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+
 public class WebSocketConnection implements WebSocket {
 
-   private static final boolean DEBUG = true;
-   private static final String TAG = WebSocketConnection.class.getName();
+    private static final boolean DEBUG = true;
+    private static final String TAG = WebSocketConnection.class.getName();
+
+    protected Handler mMasterHandler;
+
+    protected WebSocketReader mReader;
+    protected WebSocketWriter mWriter;
+    protected HandlerThread mWriterThread;
 
-   protected Handler mMasterHandler;
+    protected SocketChannel mTransportChannel;
 
-   protected WebSocketReader mReader;
-   protected WebSocketWriter mWriter;
-   protected HandlerThread mWriterThread;
+    private URI mWsUri;
+    private String mWsScheme;
+    private String mWsHost;
+    private int mWsPort;
+    private String mWsPath;
+    private String mWsQuery;
+    private String[] mWsSubprotocols;
+    private List<Pair> mWsHeaders;
 
-   protected SocketChannel mTransportChannel;
+    private WebSocket.ConnectionHandler mWsHandler;
 
-   private URI mWsUri;
-   private String mWsScheme;
-   private String mWsHost;
-   private int mWsPort;
-   private String mWsPath;
-   private String mWsQuery;
-   private String[] mWsSubprotocols;
-   private List<Pair> mWsHeaders;
+    protected WebSocketOptions mOptions;
 
-   private WebSocket.ConnectionHandler mWsHandler;
+    private boolean mActive;
+    private boolean mPrevConnected;
 
-   protected WebSocketOptions mOptions;
-   
-   private boolean mActive;
-   private boolean mPrevConnected;
+    private SSLContext mSSLContext;
+    private SSLEngine mSSLEngine = null;
 
-	/**
-	 * Asynchronous socket connector.
-	 */
-	private class WebSocketConnector extends Thread {
 
-		public void run() {
-			Thread.currentThread().setName("WebSocketConnector");
+    /**
+     * Asynchronous socket connector.
+     */
+    private class WebSocketConnector extends Thread {
+
+        public void run() {
+            Thread.currentThread().setName("WebSocketConnector");
 
 			/*
-			 * connect TCP socket
+             * connect TCP socket
 			 */
-			try {
-				mTransportChannel = SocketChannel.open();
-
-				// the following will block until connection was established or
-				// an error occurred!
-				mTransportChannel.socket().connect(
-						new InetSocketAddress(mWsHost, mWsPort),
-						mOptions.getSocketConnectTimeout());
-
-				// before doing any data transfer on the socket, set socket
-				// options
-				mTransportChannel.socket().setSoTimeout(
-						mOptions.getSocketReceiveTimeout());
-				mTransportChannel.socket().setTcpNoDelay(
-						mOptions.getTcpNoDelay());
-
-			} catch (IOException e) {
-				onClose(WebSocketConnectionHandler.CLOSE_CANNOT_CONNECT,
-						e.getMessage());
-				return;
-			}
-
-			if (mTransportChannel.isConnected()) {
-
-				try {
-
-					// create & start WebSocket reader
-					createReader();
-
-					// create & start WebSocket writer
-					createWriter();
-
-					// start WebSockets handshake
-					WebSocketMessage.ClientHandshake hs = new WebSocketMessage.ClientHandshake(
-							mWsHost + ":" + mWsPort);
-					hs.mPath = mWsPath;
-					hs.mQuery = mWsQuery;
-					hs.mSubprotocols = mWsSubprotocols;
-					hs.mHeaderList = mWsHeaders;
-					mWriter.forward(hs);
-
-					mPrevConnected = true;
-
-				} catch (Exception e) {
-					onClose(WebSocketConnectionHandler.CLOSE_INTERNAL_ERROR,
-							e.getMessage());
-					return;
-				}
-			} else {
-				onClose(WebSocketConnectionHandler.CLOSE_CANNOT_CONNECT,
-						"Could not connect to WebSocket server");
-				return;
-			}
-		}
-
-	}
-
-   public WebSocketConnection() {
-      if (DEBUG) Log.d(TAG, "created");
-      
-      // create WebSocket master handler
-      createHandler();
-      
-      // set initial values
-      mActive = false;
-      mPrevConnected = false;
-   }
-
-
-   public void sendTextMessage(String payload) {
-      mWriter.forward(new WebSocketMessage.TextMessage(payload));
-   }
-
-
-   public void sendRawTextMessage(byte[] payload) {
-      mWriter.forward(new WebSocketMessage.RawTextMessage(payload));
-   }
-
-
-   public void sendBinaryMessage(byte[] payload) {
-      mWriter.forward(new WebSocketMessage.BinaryMessage(payload));
-   }
-
-
-   public boolean isConnected() {
-      return mTransportChannel != null && mTransportChannel.isConnected();
-   }
-
-
-   private void failConnection(int code, String reason) {
-
-      if (DEBUG) Log.d(TAG, "fail connection [code = " + code + ", reason = " + reason);
-
-      if (mReader != null) {
-         mReader.quit();
-         try {
-            mReader.join();
-         } catch (InterruptedException e) {
-            if (DEBUG) e.printStackTrace();
-         }
-         //mReader = null;
-      } else {
-         if (DEBUG) Log.d(TAG, "mReader already NULL");
-      }
-
-      if (mWriter != null) {
-         //mWriterThread.getLooper().quit();
-         mWriter.forward(new WebSocketMessage.Quit());
-         try {
-            mWriterThread.join();
-         } catch (InterruptedException e) {
-            if (DEBUG) e.printStackTrace();
-         }
-         //mWriterThread = null;
-      } else {
-         if (DEBUG) Log.d(TAG, "mWriter already NULL");
-      }
-
-      if (mTransportChannel != null) {
-         try {
-            mTransportChannel.close();
-         } catch (IOException e) {
-            if (DEBUG) e.printStackTrace();
-         }
-         //mTransportChannel = null;
-      } else {
-         if (DEBUG) Log.d(TAG, "mTransportChannel already NULL");
-      }
-
-      onClose(code, reason);
-
-      if (DEBUG) Log.d(TAG, "worker threads stopped");
-   }
-
-
-   public void connect(String wsUri, WebSocket.ConnectionHandler wsHandler) throws WebSocketException {
-      connect(wsUri, null, wsHandler, new WebSocketOptions(), null);
-   }
-
-
-   public void connect(String wsUri, WebSocket.ConnectionHandler wsHandler, WebSocketOptions options) throws WebSocketException {
-      connect(wsUri, null, wsHandler, options, null);
-   }
-
-
-   public void connect(String wsUri, String[] wsSubprotocols, WebSocket.ConnectionHandler wsHandler, WebSocketOptions options, List<Pair> headers) throws WebSocketException {
-
-      // don't connect if already connected .. user needs to disconnect first
-      //
-      if (mTransportChannel != null && mTransportChannel.isConnected()) {
-         throw new WebSocketException("already connected");
-      }
+            try {
+                mTransportChannel = SocketChannel.open();
+
+                // the following will block until connection was established or
+                // an error occurred!
+                mTransportChannel.socket().connect(
+                        new InetSocketAddress(mWsHost, mWsPort),
+                        mOptions.getSocketConnectTimeout());
+
+                if (mWsScheme.equals("wss")) {
+                    try {
+                        initializeSSL();
+                    } catch (NoSuchAlgorithmException | IOException | KeyManagementException e) {
+                        e.printStackTrace();
+                    }
+                }
+
+                // before doing any data transfer on the socket, set socket
+                // options
+                mTransportChannel.socket().setSoTimeout(
+                        mOptions.getSocketReceiveTimeout());
+                mTransportChannel.socket().setTcpNoDelay(
+                        mOptions.getTcpNoDelay());
+
+            } catch (IOException e) {
+                onClose(WebSocketConnectionHandler.CLOSE_CANNOT_CONNECT,
+                        e.getMessage());
+                return;
+            }
+
+            try {
+                if (mTransportChannel.finishConnect()) {
+
+                    try {
+
+                        if (null != mSSLContext) {
+                            mSSLContext.init(null, null, null);
+                            mSSLEngine = mSSLContext.createSSLEngine(mTransportChannel
+                                            .socket()
+                                            .getInetAddress()
+                                            .getHostName(),
+                                    mTransportChannel
+                                            .socket()
+                                            .getPort());
+
+                            mSSLEngine.setUseClientMode(true);
+                            mSSLEngine.beginHandshake();
+
+                        }
+
+                        // create & start WebSocket reader
+                        createReader();
+
+                        // create & start WebSocket writer
+                        createWriter();
+
+                        // start WebSockets handshake
+                        WebSocketMessage.ClientHandshake hs = new WebSocketMessage.ClientHandshake(
+                                mWsHost + ":" + mWsPort);
+                        hs.mPath = mWsPath;
+                        hs.mQuery = mWsQuery;
+                        hs.mSubprotocols = mWsSubprotocols;
+                        hs.mHeaderList = mWsHeaders;
+                        mWriter.forward(hs);
+
+                        mPrevConnected = true;
+
+                    } catch (Exception e) {
+                        onClose(WebSocketConnectionHandler.CLOSE_INTERNAL_ERROR,
+                                e.getMessage());
+                        return;
+                    }
+                } else {
+                    onClose(WebSocketConnectionHandler.CLOSE_CANNOT_CONNECT,
+                            "Could not connect to WebSocket server");
+                    return;
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+
+    }
+
+    public WebSocketConnection() {
+        if (DEBUG) Log.d(TAG, "created");
+
+        // create WebSocket master handler
+        createHandler();
+
+        // set initial values
+        mActive = false;
+        mPrevConnected = false;
+    }
+
+
+    public void sendTextMessage(String payload) {
+        mWriter.forward(new WebSocketMessage.TextMessage(payload));
+    }
+
+
+    public void sendRawTextMessage(byte[] payload) {
+        mWriter.forward(new WebSocketMessage.RawTextMessage(payload));
+    }
 
-      // parse WebSockets URI
-      //
-      try {
-         mWsUri = new URI(wsUri);
 
-         if (!mWsUri.getScheme().equals("ws") && !mWsUri.getScheme().equals("wss")) {
-            throw new WebSocketException("unsupported scheme for WebSockets URI");
-         }
+    public void sendBinaryMessage(byte[] payload) {
+        mWriter.forward(new WebSocketMessage.BinaryMessage(payload));
+    }
 
-         if (mWsUri.getScheme().equals("wss")) {
-            throw new WebSocketException("secure WebSockets not implemented");
-         }
 
-         mWsScheme = mWsUri.getScheme();
+    public boolean isConnected() {
+        return mTransportChannel != null && mTransportChannel.isConnected();
+    }
 
-         if (mWsUri.getPort() == -1) {
-            if (mWsScheme.equals("ws")) {
-               mWsPort = 80;
+
+    private void failConnection(int code, String reason) {
+
+        if (DEBUG) Log.d(TAG, "fail connection [code = " + code + ", reason = " + reason);
+
+        if (mReader != null) {
+            mReader.quit();
+            try {
+                mReader.join();
+            } catch (InterruptedException e) {
+                if (DEBUG) e.printStackTrace();
+            }
+            //mReader = null;
+        } else {
+            if (DEBUG) Log.d(TAG, "mReader already NULL");
+        }
+
+        if (mWriter != null) {
+            //mWriterThread.getLooper().quit();
+            mWriter.forward(new WebSocketMessage.Quit());
+            try {
+                mWriterThread.join();
+            } catch (InterruptedException e) {
+                if (DEBUG) e.printStackTrace();
+            }
+            //mWriterThread = null;
+        } else {
+            if (DEBUG) Log.d(TAG, "mWriter already NULL");
+        }
+
+        if (mTransportChannel != null) {
+            try {
+                mTransportChannel.close();
+            } catch (IOException e) {
+                if (DEBUG) e.printStackTrace();
+            }
+            //mTransportChannel = null;
+        } else {
+            if (DEBUG) Log.d(TAG, "mTransportChannel already NULL");
+        }
+
+        onClose(code, reason);
+
+        if (DEBUG) Log.d(TAG, "worker threads stopped");
+    }
+
+
+    public void connect(String wsUri, WebSocket.ConnectionHandler wsHandler) throws WebSocketException {
+        connect(wsUri, null, wsHandler, new WebSocketOptions(), null);
+    }
+
+
+    public void connect(String wsUri, WebSocket.ConnectionHandler wsHandler, WebSocketOptions options) throws WebSocketException {
+        connect(wsUri, null, wsHandler, options, null);
+    }
+
+
+    public void connect(String wsUri, String[] wsSubprotocols, WebSocket.ConnectionHandler wsHandler, WebSocketOptions options, List<Pair> headers) throws WebSocketException {
+
+        // don't connect if already connected .. user needs to disconnect first
+        //
+        if (mTransportChannel != null && mTransportChannel.isConnected()) {
+            throw new WebSocketException("already connected");
+        }
+
+        // parse WebSockets URI
+        //
+        try {
+            mWsUri = new URI(wsUri);
+
+            if (!mWsUri.getScheme().equals("ws") && !mWsUri.getScheme().equals("wss")) {
+                throw new WebSocketException("unsupported scheme for WebSockets URI");
+            }
+
+            mWsScheme = mWsUri.getScheme();
+
+            if (mWsUri.getPort() == -1) {
+                if (mWsScheme.equals("ws")) {
+                    mWsPort = 80;
+                } else {
+                    mWsPort = 443;
+                }
             } else {
-               mWsPort = 443;
+                mWsPort = mWsUri.getPort();
             }
-         } else {
-            mWsPort = mWsUri.getPort();
-         }
-
-         if (mWsUri.getHost() == null) {
-            throw new WebSocketException("no host specified in WebSockets URI");
-         } else {
-            mWsHost = mWsUri.getHost();
-         }
-
-         if (mWsUri.getRawPath() == null || mWsUri.getRawPath().equals("")) {
-            mWsPath = "/";
-         } else {
-            mWsPath = mWsUri.getRawPath();
-         }
-
-         if (mWsUri.getRawQuery() == null || mWsUri.getRawQuery().equals("")) {
-            mWsQuery = null;
-         } else {
-            mWsQuery = mWsUri.getRawQuery();
-         }
-
-      } catch (URISyntaxException e) {
-
-         throw new WebSocketException("invalid WebSockets URI");
-      }
-
-      mWsSubprotocols = wsSubprotocols;
-      mWsHeaders = headers;
-      mWsHandler = wsHandler;
-
-      // make copy of options!
-      mOptions = new WebSocketOptions(options);
-      
-      // set connection active
-      mActive = true;
-
-      // use asynch connector on short-lived background thread
-      new WebSocketConnector().start();
-   }
-
-
-   public void disconnect() {
-      if (mWriter != null) {
-         mWriter.forward(new WebSocketMessage.Close(1000));
-      } else {
-         if (DEBUG) Log.d(TAG, "could not send Close .. writer already NULL");
-      }
-      if (mReader != null) {
-         mReader.quit();
-      } else {
-         if (DEBUG) Log.d(TAG, "could not send Close .. reader already NULL");
-      }
-      mActive = false;
-      mPrevConnected = false;
-   }
-   
-   /**
-    * Reconnect to the server with the latest options 
-    * @return true if reconnection performed
-    */
-   public boolean reconnect() {
-	   if (!isConnected() && (mWsUri != null)) {
-		   new WebSocketConnector().start();
-		   return true;
-	   }
-	   return false;
-   }
-   
-   /**
-    * Perform reconnection
-    * 
-    * @return true if reconnection was scheduled
-    */
-   protected boolean scheduleReconnect() {
-	   /**
-	    * Reconnect only if:
-	    *  - connection active (connected but not disconnected)
-	    *  - has previous success connections
-	    *  - reconnect interval is set
-	    */
-	   int interval = mOptions.getReconnectInterval();
-	   boolean need = mActive && mPrevConnected && (interval > 0);
-	   if (need) {
-		   if (DEBUG) Log.d(TAG, "Reconnection scheduled");
-		   mMasterHandler.postDelayed(new Runnable() {
-			
-			public void run() {
-				if (DEBUG) Log.d(TAG, "Reconnecting...");
-				reconnect();
-			}
-		}, interval);
-	   }
-	   return need;
-   }
-   
-   /**
-    * Common close handler
-    * 
-    * @param code       Close code.
-	* @param reason     Close reason (human-readable).
-    */
-   private void onClose(int code, String reason) {
-	   boolean reconnecting = false;
-	   
-	   if ((code == ConnectionHandler.CLOSE_CANNOT_CONNECT) ||
-			   (code == ConnectionHandler.CLOSE_CONNECTION_LOST)) {
-		   reconnecting = scheduleReconnect();
-	   }
-	   
-	   
-	   if (mWsHandler != null) {
-		   try {
-			   if (reconnecting) {
-				   mWsHandler.onClose(ConnectionHandler.CLOSE_RECONNECT, reason);
-			   } else {
-				   mWsHandler.onClose(code, reason);
-			   }
-		   } catch (Exception e) {
-			   if (DEBUG) e.printStackTrace();
-		   }
-		   //mWsHandler = null;
-	   } else {
-		   if (DEBUG) Log.d(TAG, "mWsHandler already NULL");
-	   }
-   }
-
-
-   /**
-    * Create master message handler.
-    */
-   protected void createHandler() {
-
-      mMasterHandler = new Handler(Looper.getMainLooper()) {
-
-         public void handleMessage(Message msg) {
-
-            if (msg.obj instanceof WebSocketMessage.TextMessage) {
-
-               WebSocketMessage.TextMessage textMessage = (WebSocketMessage.TextMessage) msg.obj;
-
-               if (mWsHandler != null) {
-                  mWsHandler.onTextMessage(textMessage.mPayload);
-               } else {
-                  if (DEBUG) Log.d(TAG, "could not call onTextMessage() .. handler already NULL");
-               }
-
-            } else if (msg.obj instanceof WebSocketMessage.RawTextMessage) {
-
-               WebSocketMessage.RawTextMessage rawTextMessage = (WebSocketMessage.RawTextMessage) msg.obj;
-
-               if (mWsHandler != null) {
-                  mWsHandler.onRawTextMessage(rawTextMessage.mPayload);
-               } else {
-                  if (DEBUG) Log.d(TAG, "could not call onRawTextMessage() .. handler already NULL");
-               }
-
-            } else if (msg.obj instanceof WebSocketMessage.BinaryMessage) {
-
-               WebSocketMessage.BinaryMessage binaryMessage = (WebSocketMessage.BinaryMessage) msg.obj;
-
-               if (mWsHandler != null) {
-                  mWsHandler.onBinaryMessage(binaryMessage.mPayload);
-               } else {
-                  if (DEBUG) Log.d(TAG, "could not call onBinaryMessage() .. handler already NULL");
-               }
-
-            } else if (msg.obj instanceof WebSocketMessage.Ping) {
-
-               WebSocketMessage.Ping ping = (WebSocketMessage.Ping) msg.obj;
-               if (DEBUG) Log.d(TAG, "WebSockets Ping received");
-
-               // reply with Pong
-               WebSocketMessage.Pong pong = new WebSocketMessage.Pong();
-               pong.mPayload = ping.mPayload;
-               mWriter.forward(pong);
-
-            } else if (msg.obj instanceof WebSocketMessage.Pong) {
-
-               @SuppressWarnings("unused")
-               WebSocketMessage.Pong pong = (WebSocketMessage.Pong) msg.obj;
-
-               if (DEBUG) Log.d(TAG, "WebSockets Pong received");
-
-            } else if (msg.obj instanceof WebSocketMessage.Close) {
-
-               WebSocketMessage.Close close = (WebSocketMessage.Close) msg.obj;
-
-               if (DEBUG) Log.d(TAG, "WebSockets Close received (" + close.mCode + " - " + close.mReason + ")");
-
-               final int tavendoCloseCode = (close.mCode == 1000) ? ConnectionHandler.CLOSE_NORMAL : ConnectionHandler.CLOSE_CONNECTION_LOST;
-
-               if (mActive) {
-                   mWriter.forward(new WebSocketMessage.Close(1000));        
-               } else {
-                   // we've initiated disconnect, so ready to close the channel
-                    try {
-                        mTransportChannel.close();
-                    } catch (IOException e) {
-                        if (DEBUG) e.printStackTrace();
+
+            if (mWsUri.getHost() == null) {
+                throw new WebSocketException("no host specified in WebSockets URI");
+            } else {
+                mWsHost = mWsUri.getHost();
+            }
+
+            if (mWsUri.getRawPath() == null || mWsUri.getRawPath().equals("")) {
+                mWsPath = "/";
+            } else {
+                mWsPath = mWsUri.getRawPath();
+            }
+
+            if (mWsUri.getRawQuery() == null || mWsUri.getRawQuery().equals("")) {
+                mWsQuery = null;
+            } else {
+                mWsQuery = mWsUri.getRawQuery();
+            }
+
+        } catch (URISyntaxException e) {
+
+            throw new WebSocketException("invalid WebSockets URI");
+        }
+
+        mWsSubprotocols = wsSubprotocols;
+        mWsHeaders = headers;
+        mWsHandler = wsHandler;
+
+        // make copy of options!
+        mOptions = new WebSocketOptions(options);
+
+        // set connection active
+        mActive = true;
+
+        // use asynch connector on short-lived background thread
+        new WebSocketConnector().start();
+    }
+
+
+    public void disconnect() {
+        if (mWriter != null) {
+            mWriter.forward(new WebSocketMessage.Close(1000));
+        } else {
+            if (DEBUG) Log.d(TAG, "could not send Close .. writer already NULL");
+        }
+        if (mReader != null) {
+            mReader.quit();
+        } else {
+            if (DEBUG) Log.d(TAG, "could not send Close .. reader already NULL");
+        }
+        mActive = false;
+        mPrevConnected = false;
+    }
+
+    /**
+     * Reconnect to the server with the latest options
+     *
+     * @return true if reconnection performed
+     */
+    public boolean reconnect() {
+        if (!isConnected() && (mWsUri != null)) {
+            new WebSocketConnector().start();
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Perform reconnection
+     *
+     * @return true if reconnection was scheduled
+     */
+    protected boolean scheduleReconnect() {
+        /**
+         * Reconnect only if:
+         *  - connection active (connected but not disconnected)
+         *  - has previous success connections
+         *  - reconnect interval is set
+         */
+        int interval = mOptions.getReconnectInterval();
+        boolean need = mActive && mPrevConnected && (interval > 0);
+        if (need) {
+            if (DEBUG) Log.d(TAG, "Reconnection scheduled");
+            mMasterHandler.postDelayed(new Runnable() {
+
+                public void run() {
+                    if (DEBUG) Log.d(TAG, "Reconnecting...");
+                    reconnect();
+                }
+            }, interval);
+        }
+        return need;
+    }
+
+    /**
+     * Common close handler
+     *
+     * @param code   Close code.
+     * @param reason Close reason (human-readable).
+     */
+    private void onClose(int code, String reason) {
+        boolean reconnecting = false;
+
+        if ((code == ConnectionHandler.CLOSE_CANNOT_CONNECT) ||
+                (code == ConnectionHandler.CLOSE_CONNECTION_LOST)) {
+            reconnecting = scheduleReconnect();
+        }
+
+
+        if (mWsHandler != null) {
+            try {
+                if (reconnecting) {
+                    mWsHandler.onClose(ConnectionHandler.CLOSE_RECONNECT, reason);
+                } else {
+                    mWsHandler.onClose(code, reason);
+                }
+            } catch (Exception e) {
+                if (DEBUG) e.printStackTrace();
+            }
+            //mWsHandler = null;
+        } else {
+            if (DEBUG) Log.d(TAG, "mWsHandler already NULL");
+        }
+    }
+
+
+    /**
+     * Create master message handler.
+     */
+    protected void createHandler() {
+
+        mMasterHandler = new Handler(Looper.getMainLooper()) {
+
+            public void handleMessage(Message msg) {
+
+                if (msg.obj instanceof WebSocketMessage.TextMessage) {
+
+                    WebSocketMessage.TextMessage textMessage = (WebSocketMessage.TextMessage) msg.obj;
+
+                    if (mWsHandler != null) {
+                        mWsHandler.onTextMessage(textMessage.mPayload);
+                    } else {
+                        if (DEBUG)
+                            Log.d(TAG, "could not call onTextMessage() .. handler already NULL");
                     }
-               }
-               
-               onClose(tavendoCloseCode, close.mReason);
 
-            } else if (msg.obj instanceof WebSocketMessage.ServerHandshake) {
+                } else if (msg.obj instanceof WebSocketMessage.RawTextMessage) {
 
-               WebSocketMessage.ServerHandshake serverHandshake = (WebSocketMessage.ServerHandshake) msg.obj;
+                    WebSocketMessage.RawTextMessage rawTextMessage = (WebSocketMessage.RawTextMessage) msg.obj;
 
-               if (DEBUG) Log.d(TAG, "opening handshake received");
-               
-               if (serverHandshake.mSuccess) {
-            	   if (mWsHandler != null) {
-                       mWsHandler.onOpen();
+                    if (mWsHandler != null) {
+                        mWsHandler.onRawTextMessage(rawTextMessage.mPayload);
                     } else {
-                       if (DEBUG) Log.d(TAG, "could not call onOpen() .. handler already NULL");
+                        if (DEBUG)
+                            Log.d(TAG, "could not call onRawTextMessage() .. handler already NULL");
                     }
-               }
 
-            } else if (msg.obj instanceof WebSocketMessage.ConnectionLost) {
+                } else if (msg.obj instanceof WebSocketMessage.BinaryMessage) {
 
-               @SuppressWarnings("unused")
-               WebSocketMessage.ConnectionLost connnectionLost = (WebSocketMessage.ConnectionLost) msg.obj;
-               failConnection(WebSocketConnectionHandler.CLOSE_CONNECTION_LOST, "WebSockets connection lost");
+                    WebSocketMessage.BinaryMessage binaryMessage = (WebSocketMessage.BinaryMessage) msg.obj;
 
-            } else if (msg.obj instanceof WebSocketMessage.ProtocolViolation) {
+                    if (mWsHandler != null) {
+                        mWsHandler.onBinaryMessage(binaryMessage.mPayload);
+                    } else {
+                        if (DEBUG)
+                            Log.d(TAG, "could not call onBinaryMessage() .. handler already NULL");
+                    }
 
-               @SuppressWarnings("unused")
-               WebSocketMessage.ProtocolViolation protocolViolation = (WebSocketMessage.ProtocolViolation) msg.obj;
-               failConnection(WebSocketConnectionHandler.CLOSE_PROTOCOL_ERROR, "WebSockets protocol violation");
+                } else if (msg.obj instanceof WebSocketMessage.Ping) {
 
-            } else if (msg.obj instanceof WebSocketMessage.Error) {
+                    WebSocketMessage.Ping ping = (WebSocketMessage.Ping) msg.obj;
+                    if (DEBUG) Log.d(TAG, "WebSockets Ping received");
 
-               WebSocketMessage.Error error = (WebSocketMessage.Error) msg.obj;
-               failConnection(WebSocketConnectionHandler.CLOSE_INTERNAL_ERROR, "WebSockets internal error (" + error.mException.toString() + ")");
-               
-            } else if (msg.obj instanceof WebSocketMessage.ServerError) {
-            	
-            	WebSocketMessage.ServerError error = (WebSocketMessage.ServerError) msg.obj;
-            	failConnection(WebSocketConnectionHandler.CLOSE_SERVER_ERROR, "Server error " + error.mStatusCode + " (" + error.mStatusMessage + ")");
+                    // reply with Pong
+                    WebSocketMessage.Pong pong = new WebSocketMessage.Pong();
+                    pong.mPayload = ping.mPayload;
+                    mWriter.forward(pong);
 
-            } else {
+                } else if (msg.obj instanceof WebSocketMessage.Pong) {
+
+                    @SuppressWarnings("unused")
+                    WebSocketMessage.Pong pong = (WebSocketMessage.Pong) msg.obj;
+
+                    if (DEBUG) Log.d(TAG, "WebSockets Pong received");
+
+                } else if (msg.obj instanceof WebSocketMessage.Close) {
 
-               processAppMessage(msg.obj);
+                    WebSocketMessage.Close close = (WebSocketMessage.Close) msg.obj;
 
+                    if (DEBUG)
+                        Log.d(TAG, "WebSockets Close received (" + close.mCode + " - " + close.mReason + ")");
+
+                    final int tavendoCloseCode = (close.mCode == 1000) ? ConnectionHandler.CLOSE_NORMAL : ConnectionHandler.CLOSE_CONNECTION_LOST;
+
+                    if (mActive) {
+                        mWriter.forward(new WebSocketMessage.Close(1000));
+                    } else {
+                        // we've initiated disconnect, so ready to close the channel
+                        try {
+                            mTransportChannel.close();
+                        } catch (IOException e) {
+                            if (DEBUG) e.printStackTrace();
+                        }
+                    }
+
+                    onClose(tavendoCloseCode, close.mReason);
+
+                } else if (msg.obj instanceof WebSocketMessage.ServerHandshake) {
+
+                    WebSocketMessage.ServerHandshake serverHandshake = (WebSocketMessage.ServerHandshake) msg.obj;
+
+                    if (DEBUG) Log.d(TAG, "opening handshake received");
+
+                    if (serverHandshake.mSuccess) {
+                        if (mWsHandler != null) {
+                            mWsHandler.onOpen();
+                        } else {
+                            if (DEBUG)
+                                Log.d(TAG, "could not call onOpen() .. handler already NULL");
+                        }
+                    }
+
+                } else if (msg.obj instanceof WebSocketMessage.ConnectionLost) {
+
+                    @SuppressWarnings("unused")
+                    WebSocketMessage.ConnectionLost connnectionLost = (WebSocketMessage.ConnectionLost) msg.obj;
+                    failConnection(WebSocketConnectionHandler.CLOSE_CONNECTION_LOST, "WebSockets connection lost");
+
+                } else if (msg.obj instanceof WebSocketMessage.ProtocolViolation) {
+
+                    @SuppressWarnings("unused")
+                    WebSocketMessage.ProtocolViolation protocolViolation = (WebSocketMessage.ProtocolViolation) msg.obj;
+                    failConnection(WebSocketConnectionHandler.CLOSE_PROTOCOL_ERROR, "WebSockets protocol violation");
+
+                } else if (msg.obj instanceof WebSocketMessage.Error) {
+
+                    WebSocketMessage.Error error = (WebSocketMessage.Error) msg.obj;
+                    failConnection(WebSocketConnectionHandler.CLOSE_INTERNAL_ERROR, "WebSockets internal error (" + error.mException.toString() + ")");
+
+                } else if (msg.obj instanceof WebSocketMessage.ServerError) {
+
+                    WebSocketMessage.ServerError error = (WebSocketMessage.ServerError) msg.obj;
+                    failConnection(WebSocketConnectionHandler.CLOSE_SERVER_ERROR, "Server error " + error.mStatusCode + " (" + error.mStatusMessage + ")");
+
+                } else {
+
+                    processAppMessage(msg.obj);
+
+                }
             }
-         }
-      };
-   }
+        };
+    }
+
+
+    protected void processAppMessage(Object message) {
+    }
 
 
-   protected void processAppMessage(Object message) {
-   }
+    /**
+     * Create WebSockets background writer.
+     */
+    protected void createWriter() {
 
+        mWriterThread = new HandlerThread("WebSocketWriter");
+        mWriterThread.start();
+        mWriter = new WebSocketWriter(mWriterThread.getLooper(), mMasterHandler, mTransportChannel, mSSLEngine, mOptions);
 
-   /**
-    * Create WebSockets background writer.
-    */
-   protected void createWriter() {
+        if (DEBUG) Log.d(TAG, "WS writer created and started");
+    }
 
-      mWriterThread = new HandlerThread("WebSocketWriter");
-      mWriterThread.start();
-      mWriter = new WebSocketWriter(mWriterThread.getLooper(), mMasterHandler, mTransportChannel, mOptions);
 
-      if (DEBUG) Log.d(TAG, "WS writer created and started");
-   }
+    /**
+     * Create WebSockets background reader.
+     */
+    protected void createReader() {
 
+        mReader = new WebSocketReader(mMasterHandler, mTransportChannel, mSSLEngine, mOptions, "WebSocketReader");
+        mReader.start();
 
-   /**
-    * Create WebSockets background reader.
-    */
-   protected void createReader() {
+        if (DEBUG) Log.d(TAG, "WS reader created and started");
+    }
 
-      mReader = new WebSocketReader(mMasterHandler, mTransportChannel, mOptions, "WebSocketReader");
-      mReader.start();
+    public void setSSLContext(SSLContext context) {
+        this.mSSLContext = context;
+    }
 
-      if (DEBUG) Log.d(TAG, "WS reader created and started");
-   }
+    public void initializeSSL() throws NoSuchAlgorithmException, IOException, KeyManagementException {
+        mSSLContext = SSLContext.getInstance("TLSv1.2");
+    }
 }
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketReader.java b/Autobahn/src/de/tavendo/autobahn/WebSocketReader.java
index 8683df7..4034a50 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketReader.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketReader.java
@@ -1,23 +1,26 @@
 /******************************************************************************
- *
- *  Copyright 2011-2012 Tavendo GmbH
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
+ * Copyright 2011-2012 Tavendo GmbH
+ * <p/>
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * <p/>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p/>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ******************************************************************************/
 
 package de.tavendo.autobahn;
 
+import android.os.Handler;
+import android.os.Message;
+import android.util.Log;
+import android.util.Pair;
+
 import java.io.UnsupportedEncodingException;
 import java.net.SocketException;
 import java.nio.ByteBuffer;
@@ -25,10 +28,7 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import android.os.Handler;
-import android.os.Message;
-import android.util.Log;
-import android.util.Pair;
+import javax.net.ssl.SSLEngine;
 
 /**
  * WebSocket reader, the receiving leg of a WebSockets connection.
@@ -39,661 +39,677 @@
  */
 public class WebSocketReader extends Thread {
 
-   private static final boolean DEBUG = true;
-   private static final String TAG = WebSocketReader.class.getName();
-
-   private final Handler mMaster;
-   private final SocketChannel mSocket;
-   private final WebSocketOptions mOptions;
+    private static final boolean DEBUG = true;
+    private static final String TAG = WebSocketReader.class.getName();
 
-   private final ByteBuffer mFrameBuffer;
-   private NoCopyByteArrayOutputStream mMessagePayload;
+    private final Handler mMaster;
+    private final SocketChannel mSocket;
+    private final WebSocketOptions mOptions;
 
-   private final static int STATE_CLOSED = 0;
-   private final static int STATE_CONNECTING = 1;
-   private final static int STATE_CLOSING = 2;
-   private final static int STATE_OPEN = 3;
+    private final ByteBuffer mFrameBuffer;
+    private NoCopyByteArrayOutputStream mMessagePayload;
 
-   private boolean mStopped = false;
-   private int mState;
+    private final static int STATE_CLOSED = 0;
+    private final static int STATE_CONNECTING = 1;
+    private final static int STATE_CLOSING = 2;
+    private final static int STATE_OPEN = 3;
 
-   private boolean mInsideMessage = false;
-   private int mMessageOpcode;
+    private boolean mStopped = false;
+    private int mState;
 
-   /// Frame currently being received.
-   private FrameHeader mFrameHeader;
+    private boolean mInsideMessage = false;
+    private int mMessageOpcode;
 
-   private Utf8Validator mUtf8Validator = new Utf8Validator();
+    /// Frame currently being received.
+    private FrameHeader mFrameHeader;
 
+    private Utf8Validator mUtf8Validator = new Utf8Validator();
 
-   /**
-    * WebSockets frame metadata.
-    */
-   private static class FrameHeader {
-      public int mOpcode;
-      public boolean mFin;
-      @SuppressWarnings("unused")
-      public int mReserved;
-      public int mHeaderLen;
-      public int mPayloadLen;
-      public int mTotalLen;
-      public byte[] mMask;
-   }
 
+    /**
+     * WebSockets frame metadata.
+     */
+    private static class FrameHeader {
+        public int mOpcode;
+        public boolean mFin;
+        @SuppressWarnings("unused")
+        public int mReserved;
+        public int mHeaderLen;
+        public int mPayloadLen;
+        public int mTotalLen;
+        public byte[] mMask;
+    }
+
+    protected NioSslPeer nioSslPeer;
+    protected SSLEngine mSSLEngine;
+
+    /**
+     * Create new WebSockets background reader.
+     *
+     * @param master The message handler of master (foreground thread).
+     * @param socket The socket channel created on foreground thread.
+     */
+    public WebSocketReader(Handler master, SocketChannel socket, SSLEngine sslEngine, WebSocketOptions options, String threadName) {
+
+        super(threadName);
+
+        mSSLEngine = sslEngine;
+        mMaster = master;
+        mSocket = socket;
+        mOptions = options;
+
+        mFrameBuffer = ByteBuffer.allocateDirect(options.getMaxFramePayloadSize() + 14);
+        mMessagePayload = new NoCopyByteArrayOutputStream(options.getMaxMessagePayloadSize());
+
+        if (null != mSSLEngine) {
+            nioSslPeer = new NioSslPeer(mMaster.getLooper());
+            nioSslPeer.peerNetData = ByteBuffer.allocate(mSSLEngine.getSession().getPacketBufferSize());
+            nioSslPeer.myNetData = ByteBuffer.allocate(mSSLEngine.getSession().getPacketBufferSize());
+        }
+
+        mFrameHeader = null;
+        mState = STATE_CONNECTING;
+
+        if (DEBUG) Log.d(TAG, "created");
+    }
+
+
+    /**
+     * Graceful shutdown of background reader thread (called from master).
+     */
+    public void quit() {
+        mState = STATE_CLOSED;
+        if (DEBUG) Log.d(TAG, "quit");
+    }
+
+
+    /**
+     * Notify the master (foreground thread) of WebSockets message received
+     * and unwrapped.
+     *
+     * @param message Message to send to master.
+     */
+    protected void notify(Object message) {
+
+        Message msg = mMaster.obtainMessage();
+        msg.obj = message;
+        mMaster.sendMessage(msg);
+
+    }
+
+
+    /**
+     * Process incoming WebSockets data (after handshake).
+     */
+    private boolean processData() throws Exception {
+
+        // outside frame?
+        if (mFrameHeader == null) {
+
+            // need at least 2 bytes from WS frame header to start processing
+            if (mFrameBuffer.position() >= 2) {
+
+                byte b0 = mFrameBuffer.get(0);
+                boolean fin = (b0 & 0x80) != 0;
+                int rsv = (b0 & 0x70) >> 4;
+                int opcode = b0 & 0x0f;
+
+                byte b1 = mFrameBuffer.get(1);
+                boolean masked = (b1 & 0x80) != 0;
+                int payload_len1 = b1 & 0x7f;
+
+                // now check protocol compliance
+
+                if (rsv != 0) {
+                    throw new WebSocketException("RSV != 0 and no extension negotiated");
+                }
+
+                if (masked) {
+                    // currently, we don't allow this. need to see whats the final spec.
+                    throw new WebSocketException("masked server frame");
+                }
+
+                if (opcode > 7) {
+                    // control frame
+                    if (!fin) {
+                        throw new WebSocketException("fragmented control frame");
+                    }
+                    if (payload_len1 > 125) {
+                        throw new WebSocketException("control frame with payload length > 125 octets");
+                    }
+                    if (opcode != 8 && opcode != 9 && opcode != 10) {
+                        throw new WebSocketException("control frame using reserved opcode " + opcode);
+                    }
+                    if (opcode == 8 && payload_len1 == 1) {
+                        throw new WebSocketException("received close control frame with payload len 1");
+                    }
+                } else {
+                    // message frame
+                    if (opcode != 0 && opcode != 1 && opcode != 2) {
+                        throw new WebSocketException("data frame using reserved opcode " + opcode);
+                    }
+                    if (!mInsideMessage && opcode == 0) {
+                        throw new WebSocketException("received continuation data frame outside fragmented message");
+                    }
+                    if (mInsideMessage && opcode != 0) {
+                        throw new WebSocketException("received non-continuation data frame while inside fragmented message");
+                    }
+                }
+
+                int mask_len = masked ? 4 : 0;
+                int header_len = 0;
+
+                if (payload_len1 < 126) {
+                    header_len = 2 + mask_len;
+                } else if (payload_len1 == 126) {
+                    header_len = 2 + 2 + mask_len;
+                } else if (payload_len1 == 127) {
+                    header_len = 2 + 8 + mask_len;
+                } else {
+                    // should not arrive here
+                    throw new Exception("logic error");
+                }
+
+                // continue when complete frame header is available
+                if (mFrameBuffer.position() >= header_len) {
+
+                    // determine frame payload length
+                    int i = 2;
+                    long payload_len = 0;
+                    if (payload_len1 == 126) {
+                        payload_len = ((0xff & mFrameBuffer.get(i)) << 8) | (0xff & mFrameBuffer.get(i + 1));
+                        if (payload_len < 126) {
+                            throw new WebSocketException("invalid data frame length (not using minimal length encoding)");
+                        }
+                        i += 2;
+                    } else if (payload_len1 == 127) {
+                        if ((0x80 & mFrameBuffer.get(i + 0)) != 0) {
+                            throw new WebSocketException("invalid data frame length (> 2^63)");
+                        }
+                        payload_len = ((long) (0xff & mFrameBuffer.get(i + 0)) << 56) |
+                                ((long) (0xff & mFrameBuffer.get(i + 1)) << 48) |
+                                ((long) (0xff & mFrameBuffer.get(i + 2)) << 40) |
+                                ((long) (0xff & mFrameBuffer.get(i + 3)) << 32) |
+                                ((long) (0xff & mFrameBuffer.get(i + 4)) << 24) |
+                                ((long) (0xff & mFrameBuffer.get(i + 5)) << 16) |
+                                ((long) (0xff & mFrameBuffer.get(i + 6)) << 8) |
+                                ((long) (0xff & mFrameBuffer.get(i + 7)));
+                        if (payload_len < 65536) {
+                            throw new WebSocketException("invalid data frame length (not using minimal length encoding)");
+                        }
+                        i += 8;
+                    } else {
+                        payload_len = payload_len1;
+                    }
+
+                    // immediately bail out on frame too large
+                    if (payload_len > mOptions.getMaxFramePayloadSize()) {
+                        throw new WebSocketException("frame payload too large");
+                    }
+
+                    // save frame header metadata
+                    mFrameHeader = new FrameHeader();
+                    mFrameHeader.mOpcode = opcode;
+                    mFrameHeader.mFin = fin;
+                    mFrameHeader.mReserved = rsv;
+                    mFrameHeader.mPayloadLen = (int) payload_len;
+                    mFrameHeader.mHeaderLen = header_len;
+                    mFrameHeader.mTotalLen = mFrameHeader.mHeaderLen + mFrameHeader.mPayloadLen;
+                    if (masked) {
+                        mFrameHeader.mMask = new byte[4];
+                        for (int j = 0; j < 4; ++j) {
+                            mFrameHeader.mMask[i] = (byte) (0xff & mFrameBuffer.get(i + j));
+                        }
+                        i += 4;
+                    } else {
+                        mFrameHeader.mMask = null;
+                    }
 
-   /**
-    * Create new WebSockets background reader.
-    *
-    * @param master    The message handler of master (foreground thread).
-    * @param socket    The socket channel created on foreground thread.
-    */
-   public WebSocketReader(Handler master, SocketChannel socket, WebSocketOptions options, String threadName) {
-
-      super(threadName);
-
-      mMaster = master;
-      mSocket = socket;
-      mOptions = options;
+                    // continue processing when payload empty or completely buffered
+                    return mFrameHeader.mPayloadLen == 0 || mFrameBuffer.position() >= mFrameHeader.mTotalLen;
 
-      mFrameBuffer = ByteBuffer.allocateDirect(options.getMaxFramePayloadSize() + 14);
-      mMessagePayload = new NoCopyByteArrayOutputStream(options.getMaxMessagePayloadSize());
+                } else {
 
-      mFrameHeader = null;
-      mState = STATE_CONNECTING;
+                    // need more data
+                    return false;
+                }
+            } else {
 
-      if (DEBUG) Log.d(TAG, "created");
-   }
+                // need more data
+                return false;
+            }
 
+        } else {
 
-   /**
-    * Graceful shutdown of background reader thread (called from master).
-    */
-   public void quit() {
-      mState = STATE_CLOSED;
-      if (DEBUG) Log.d(TAG, "quit");
-   }
+            /// \todo refactor this for streaming processing, incl. fail fast on invalid UTF-8 within frame already
 
+            // within frame
 
-   /**
-    * Notify the master (foreground thread) of WebSockets message received
-    * and unwrapped.
-    *
-    * @param message       Message to send to master.
-    */
-   protected void notify(Object message) {
+            // see if we buffered complete frame
+            if (mFrameBuffer.position() >= mFrameHeader.mTotalLen) {
 
-      Message msg = mMaster.obtainMessage();
-      msg.obj = message;
-      mMaster.sendMessage(msg);
-   }
+                // cut out frame payload
+                byte[] framePayload = null;
+                int oldPosition = mFrameBuffer.position();
+                if (mFrameHeader.mPayloadLen > 0) {
+                    framePayload = new byte[mFrameHeader.mPayloadLen];
+                    mFrameBuffer.position(mFrameHeader.mHeaderLen);
+                    mFrameBuffer.get(framePayload, 0, (int) mFrameHeader.mPayloadLen);
+                }
+                mFrameBuffer.position(mFrameHeader.mTotalLen);
+                mFrameBuffer.limit(oldPosition);
+                mFrameBuffer.compact();
 
+                if (mFrameHeader.mOpcode > 7) {
+                    // control frame
 
-   /**
-    * Process incoming WebSockets data (after handshake).
-    */
-   private boolean processData() throws Exception {
+                    if (mFrameHeader.mOpcode == 8) {
 
-      // outside frame?
-      if (mFrameHeader == null) {
+                        int code = 1005; // CLOSE_STATUS_CODE_NULL : no status code received
+                        String reason = null;
 
-         // need at least 2 bytes from WS frame header to start processing
-         if (mFrameBuffer.position() >= 2) {
+                        if (mFrameHeader.mPayloadLen >= 2) {
 
-            byte b0 = mFrameBuffer.get(0);
-            boolean fin = (b0 & 0x80) != 0;
-            int rsv = (b0 & 0x70) >> 4;
-            int opcode = b0 & 0x0f;
+                            // parse and check close code - see http://tools.ietf.org/html/rfc6455#section-7.4
+                            code = (framePayload[0] & 0xff) * 256 + (framePayload[1] & 0xff);
+                            if (code < 1000
+                                    || (code >= 1000 && code <= 2999 &&
+                                    code != 1000 && code != 1001 && code != 1002 && code != 1003 && code != 1007 && code != 1008 && code != 1009 && code != 1010 && code != 1011)
+                                    || code >= 5000) {
 
-            byte b1 = mFrameBuffer.get(1);
-            boolean masked = (b1 & 0x80) != 0;
-            int payload_len1 = b1 & 0x7f;
+                                throw new WebSocketException("invalid close code " + code);
+                            }
 
-            // now check protocol compliance
+                            // parse and check close reason
+                            if (mFrameHeader.mPayloadLen > 2) {
 
-            if (rsv != 0) {
-               throw new WebSocketException("RSV != 0 and no extension negotiated");
-            }
+                                byte[] ra = new byte[mFrameHeader.mPayloadLen - 2];
+                                System.arraycopy(framePayload, 2, ra, 0, mFrameHeader.mPayloadLen - 2);
 
-            if (masked) {
-               // currently, we don't allow this. need to see whats the final spec.
-               throw new WebSocketException("masked server frame");
-            }
+                                Utf8Validator val = new Utf8Validator();
+                                val.validate(ra);
+                                if (!val.isValid()) {
+                                    throw new WebSocketException("invalid close reasons (not UTF-8)");
+                                } else {
+                                    reason = new String(ra, "UTF-8");
+                                }
+                            }
+                        }
+                        onClose(code, reason);
 
-            if (opcode > 7) {
-               // control frame
-               if (!fin) {
-                  throw new WebSocketException("fragmented control frame");
-               }
-               if (payload_len1 > 125) {
-                  throw new WebSocketException("control frame with payload length > 125 octets");
-               }
-               if (opcode != 8 && opcode != 9 && opcode != 10) {
-                  throw new WebSocketException("control frame using reserved opcode " + opcode);
-               }
-               if (opcode == 8 && payload_len1 == 1) {
-                  throw new WebSocketException("received close control frame with payload len 1");
-               }
-            } else {
-               // message frame
-               if (opcode != 0 && opcode != 1 && opcode != 2) {
-                  throw new WebSocketException("data frame using reserved opcode " + opcode);
-               }
-               if (!mInsideMessage && opcode == 0) {
-                  throw new WebSocketException("received continuation data frame outside fragmented message");
-               }
-               if (mInsideMessage && opcode != 0) {
-                  throw new WebSocketException("received non-continuation data frame while inside fragmented message");
-               }
-            }
+                    } else if (mFrameHeader.mOpcode == 9) {
+                        // dispatch WS ping
+                        onPing(framePayload);
 
-            int mask_len = masked ? 4 : 0;
-            int header_len = 0;
+                    } else if (mFrameHeader.mOpcode == 10) {
+                        // dispatch WS pong
+                        onPong(framePayload);
 
-            if (payload_len1 < 126) {
-               header_len = 2 + mask_len;
-            } else if (payload_len1 == 126) {
-               header_len = 2 + 2 + mask_len;
-            } else if (payload_len1 == 127) {
-               header_len = 2 + 8 + mask_len;
-            } else {
-               // should not arrive here
-               throw new Exception("logic error");
-            }
+                    } else {
 
-            // continue when complete frame header is available
-            if (mFrameBuffer.position() >= header_len) {
-
-               // determine frame payload length
-               int i = 2;
-               long payload_len = 0;
-               if (payload_len1 == 126) {
-                  payload_len = ((0xff & mFrameBuffer.get(i)) << 8) | (0xff & mFrameBuffer.get(i+1));
-                  if (payload_len < 126) {
-                     throw new WebSocketException("invalid data frame length (not using minimal length encoding)");
-                  }
-                  i += 2;
-               } else if (payload_len1 == 127) {
-                  if ((0x80 & mFrameBuffer.get(i+0)) != 0) {
-                     throw new WebSocketException("invalid data frame length (> 2^63)");
-                  }
-                  payload_len = ((long)(0xff & mFrameBuffer.get(i+0)) << 56) |
-                                ((long)(0xff & mFrameBuffer.get(i+1)) << 48) |
-                                ((long)(0xff & mFrameBuffer.get(i+2)) << 40) |
-                                ((long)(0xff & mFrameBuffer.get(i+3)) << 32) |
-                                ((long)(0xff & mFrameBuffer.get(i+4)) << 24) |
-                                ((long)(0xff & mFrameBuffer.get(i+5)) << 16) |
-                                ((long)(0xff & mFrameBuffer.get(i+6)) <<  8) |
-                                ((long)(0xff & mFrameBuffer.get(i+7))      );
-                  if (payload_len < 65536) {
-                     throw new WebSocketException("invalid data frame length (not using minimal length encoding)");
-                  }
-                  i += 8;
-               } else {
-                  payload_len = payload_len1;
-               }
-
-               // immediately bail out on frame too large
-               if (payload_len > mOptions.getMaxFramePayloadSize()) {
-                  throw new WebSocketException("frame payload too large");
-               }
-
-               // save frame header metadata
-               mFrameHeader = new FrameHeader();
-               mFrameHeader.mOpcode = opcode;
-               mFrameHeader.mFin = fin;
-               mFrameHeader.mReserved = rsv;
-               mFrameHeader.mPayloadLen = (int) payload_len;
-               mFrameHeader.mHeaderLen = header_len;
-               mFrameHeader.mTotalLen = mFrameHeader.mHeaderLen + mFrameHeader.mPayloadLen;
-               if (masked) {
-                  mFrameHeader.mMask = new byte[4];
-                  for (int j = 0; j < 4; ++j) {
-                     mFrameHeader.mMask[i] = (byte) (0xff & mFrameBuffer.get(i + j));
-                  }
-                  i += 4;
-               } else {
-                  mFrameHeader.mMask = null;
-               }
-
-               // continue processing when payload empty or completely buffered
-               return mFrameHeader.mPayloadLen == 0 || mFrameBuffer.position() >= mFrameHeader.mTotalLen;
+                        // should not arrive here (handled before)
+                        throw new Exception("logic error");
+                    }
 
-            } else {
+                } else {
+                    // message frame
 
-               // need more data
-               return false;
-            }
-         } else {
-
-            // need more data
-            return false;
-         }
+                    if (!mInsideMessage) {
+                        // new message started
+                        mInsideMessage = true;
+                        mMessageOpcode = mFrameHeader.mOpcode;
+                        if (mMessageOpcode == 1 && mOptions.getValidateIncomingUtf8()) {
+                            mUtf8Validator.reset();
+                        }
+                    }
 
-      } else {
+                    if (framePayload != null) {
 
-         /// \todo refactor this for streaming processing, incl. fail fast on invalid UTF-8 within frame already
+                        // immediately bail out on message too large
+                        if (mMessagePayload.size() + framePayload.length > mOptions.getMaxMessagePayloadSize()) {
+                            throw new WebSocketException("message payload too large");
+                        }
 
-         // within frame
+                        // validate incoming UTF-8
+                        if (mMessageOpcode == 1 && mOptions.getValidateIncomingUtf8() && !mUtf8Validator.validate(framePayload)) {
+                            throw new WebSocketException("invalid UTF-8 in text message payload");
+                        }
 
-         // see if we buffered complete frame
-         if (mFrameBuffer.position() >= mFrameHeader.mTotalLen) {
+                        // buffer frame payload for message
+                        mMessagePayload.write(framePayload);
+                    }
 
-            // cut out frame payload
-            byte[] framePayload = null;
-            int oldPosition = mFrameBuffer.position();
-            if (mFrameHeader.mPayloadLen > 0) {
-               framePayload = new byte[mFrameHeader.mPayloadLen];
-               mFrameBuffer.position(mFrameHeader.mHeaderLen);
-               mFrameBuffer.get(framePayload, 0, (int) mFrameHeader.mPayloadLen);
-            }
-            mFrameBuffer.position(mFrameHeader.mTotalLen);
-            mFrameBuffer.limit(oldPosition);
-            mFrameBuffer.compact();
+                    // on final frame ..
+                    if (mFrameHeader.mFin) {
 
-            if (mFrameHeader.mOpcode > 7) {
-               // control frame
+                        if (mMessageOpcode == 1) {
 
-               if (mFrameHeader.mOpcode == 8) {
+                            // verify that UTF-8 ends on codepoint
+                            if (mOptions.getValidateIncomingUtf8() && !mUtf8Validator.isValid()) {
+                                throw new WebSocketException("UTF-8 text message payload ended within Unicode code point");
+                            }
 
-                  int code = 1005; // CLOSE_STATUS_CODE_NULL : no status code received
-                  String reason = null;
+                            // deliver text message
+                            if (mOptions.getReceiveTextMessagesRaw()) {
 
-                  if (mFrameHeader.mPayloadLen >= 2) {
+                                // dispatch WS text message as raw (but validated) UTF-8
+                                onRawTextMessage(mMessagePayload.toByteArray());
 
-                     // parse and check close code - see http://tools.ietf.org/html/rfc6455#section-7.4
-                     code = (framePayload[0] & 0xff) * 256 + (framePayload[1] & 0xff);
-                     if (code < 1000
-                           || (code >= 1000 && code <= 2999 &&
-                               code != 1000 && code != 1001 && code != 1002 && code != 1003 && code != 1007 && code != 1008 && code != 1009 && code != 1010 && code != 1011)
-                           || code >= 5000) {
+                            } else {
 
-                        throw new WebSocketException("invalid close code " + code);
-                     }
+                                // dispatch WS text message as Java String (previously already validated)
+                                String s = new String(mMessagePayload.toByteArray(), "UTF-8");
+                                onTextMessage(s);
+                            }
 
-                     // parse and check close reason
-                     if (mFrameHeader.mPayloadLen > 2) {
+                        } else if (mMessageOpcode == 2) {
 
-                        byte[] ra = new byte[mFrameHeader.mPayloadLen - 2];
-                        System.arraycopy(framePayload, 2, ra, 0, mFrameHeader.mPayloadLen - 2);
+                            // dispatch WS binary message
+                            onBinaryMessage(mMessagePayload.toByteArray());
 
-                        Utf8Validator val = new Utf8Validator();
-                        val.validate(ra);
-                        if (!val.isValid()) {
-                           throw new WebSocketException("invalid close reasons (not UTF-8)");
                         } else {
-                           reason = new String(ra, "UTF-8");
-                        }
-                     }
-                  }
-                  onClose(code, reason);
 
-               } else if (mFrameHeader.mOpcode == 9) {
-                  // dispatch WS ping
-                  onPing(framePayload);
+                            // should not arrive here (handled before)
+                            throw new Exception("logic error");
+                        }
 
-               } else if (mFrameHeader.mOpcode == 10) {
-                  // dispatch WS pong
-                  onPong(framePayload);
+                        // ok, message completed - reset all
+                        mInsideMessage = false;
+                        mMessagePayload.reset();
+                    }
+                }
 
-               } else {
+                // reset frame
+                mFrameHeader = null;
 
-                  // should not arrive here (handled before)
-                  throw new Exception("logic error");
-               }
+                // reprocess if more data left
+                return mFrameBuffer.position() > 0;
 
             } else {
-               // message frame
-
-               if (!mInsideMessage) {
-                  // new message started
-                  mInsideMessage = true;
-                  mMessageOpcode = mFrameHeader.mOpcode;
-                  if (mMessageOpcode == 1 && mOptions.getValidateIncomingUtf8()) {
-                     mUtf8Validator.reset();
-                  }
-               }
-
-               if (framePayload != null) {
-
-                  // immediately bail out on message too large
-                  if (mMessagePayload.size() + framePayload.length > mOptions.getMaxMessagePayloadSize()) {
-                     throw new WebSocketException("message payload too large");
-                  }
-
-                  // validate incoming UTF-8
-                  if (mMessageOpcode == 1 && mOptions.getValidateIncomingUtf8() && !mUtf8Validator.validate(framePayload)) {
-                     throw new WebSocketException("invalid UTF-8 in text message payload");
-                  }
 
-                  // buffer frame payload for message
-                  mMessagePayload.write(framePayload);
-               }
-
-               // on final frame ..
-               if (mFrameHeader.mFin) {
+                // need more data
+                return false;
+            }
+        }
+    }
 
-                  if (mMessageOpcode == 1) {
 
-                     // verify that UTF-8 ends on codepoint
-                     if (mOptions.getValidateIncomingUtf8() && !mUtf8Validator.isValid()) {
-                        throw new WebSocketException("UTF-8 text message payload ended within Unicode code point");
-                     }
+    /**
+     * WebSockets handshake reply from server received, default notifies master.
+     *
+     * @param success Success handshake flag
+     */
+    protected void onHandshake(boolean success) {
 
-                     // deliver text message
-                     if (mOptions.getReceiveTextMessagesRaw()) {
+        notify(new WebSocketMessage.ServerHandshake(success));
+    }
 
-                        // dispatch WS text message as raw (but validated) UTF-8
-                        onRawTextMessage(mMessagePayload.toByteArray());
 
-                     } else {
+    /**
+     * WebSockets close received, default notifies master.
+     */
+    protected void onClose(int code, String reason) {
+
+        notify(new WebSocketMessage.Close(code, reason));
+    }
 
-                        // dispatch WS text message as Java String (previously already validated)
-                        String s = new String(mMessagePayload.toByteArray(), "UTF-8");
-                        onTextMessage(s);
-                     }
 
-                  } else if (mMessageOpcode == 2) {
+    /**
+     * WebSockets ping received, default notifies master.
+     *
+     * @param payload Ping payload or null.
+     */
+    protected void onPing(byte[] payload) {
+
+        notify(new WebSocketMessage.Ping(payload));
+    }
+
+
+    /**
+     * WebSockets pong received, default notifies master.
+     *
+     * @param payload Pong payload or null.
+     */
+    protected void onPong(byte[] payload) {
+
+        notify(new WebSocketMessage.Pong(payload));
+    }
+
+
+    /**
+     * WebSockets text message received, default notifies master.
+     * This will only be called when the option receiveTextMessagesRaw
+     * HAS NOT been set.
+     *
+     * @param payload Text message payload as Java String decoded
+     *                from raw UTF-8 payload or null (empty payload).
+     */
+    protected void onTextMessage(String payload) {
+
+        notify(new WebSocketMessage.TextMessage(payload));
+    }
+
+
+    /**
+     * WebSockets text message received, default notifies master.
+     * This will only be called when the option receiveTextMessagesRaw
+     * HAS been set.
+     *
+     * @param payload Text message payload as raw UTF-8 octets or
+     *                null (empty payload).
+     */
+    protected void onRawTextMessage(byte[] payload) {
+
+        notify(new WebSocketMessage.RawTextMessage(payload));
+    }
+
+
+    /**
+     * WebSockets binary message received, default notifies master.
+     *
+     * @param payload Binary message payload or null (empty payload).
+     */
+    protected void onBinaryMessage(byte[] payload) {
+
+        notify(new WebSocketMessage.BinaryMessage(payload));
+    }
+
+
+    /**
+     * Process WebSockets handshake received from server.
+     */
+    private boolean processHandshake() throws UnsupportedEncodingException {
+
+        boolean res = false;
+        for (int pos = mFrameBuffer.position() - 4; pos >= 0; --pos) {
+            if (mFrameBuffer.get(pos + 0) == 0x0d &&
+                    mFrameBuffer.get(pos + 1) == 0x0a &&
+                    mFrameBuffer.get(pos + 2) == 0x0d &&
+                    mFrameBuffer.get(pos + 3) == 0x0a) {
+
+                /// \todo process & verify handshake from server
+                /// \todo forward subprotocol, if any
+
+                int oldPosition = mFrameBuffer.position();
+
+                // Check HTTP status code
+                boolean serverError = false;
+                if (mFrameBuffer.get(0) == 'H' &&
+                        mFrameBuffer.get(1) == 'T' &&
+                        mFrameBuffer.get(2) == 'T' &&
+                        mFrameBuffer.get(3) == 'P') {
+
+                    Pair<Integer, String> status = parseHttpStatus();
+                    if (status.first >= 300) {
+                        // Invalid status code for success connection
+                        notify(new WebSocketMessage.ServerError(status.first, status.second));
+                        serverError = true;
+                    }
+                }
+
+                mFrameBuffer.position(pos + 4);
+                mFrameBuffer.limit(oldPosition);
+                mFrameBuffer.compact();
+
+                if (!serverError) {
+                    // process further when data after HTTP headers left in buffer
+                    res = mFrameBuffer.position() > 0;
+
+                    mState = STATE_OPEN;
+                } else {
+                    res = true;
+                    mState = STATE_CLOSED;
+                    mStopped = true;
+                }
+
+                onHandshake(!serverError);
+                break;
+            }
+        }
+        return res;
+    }
+
+    @SuppressWarnings("unused")
+    private Map<String, String> parseHttpHeaders(byte[] buffer) throws UnsupportedEncodingException {
+        // TODO: use utf-8 validator?
+        String s = new String(buffer, "UTF-8");
+        Map<String, String> headers = new HashMap<String, String>();
+
+        String[] lines = s.split("\r\n");
+        for (String line : lines) {
+            if (line.length() > 0) {
+                String[] h = line.split(": ");
+                if (h.length == 2) {
+                    headers.put(h[0], h[1]);
+                    Log.w(TAG, String.format("'%s'='%s'", h[0], h[1]));
+                }
+            }
+        }
+
+        return headers;
+    }
+
+    private Pair<Integer, String> parseHttpStatus() throws UnsupportedEncodingException {
+        int beg, end;
+        // Find first space
+        for (beg = 4; beg < mFrameBuffer.position(); ++beg) {
+            if (mFrameBuffer.get(beg) == ' ') break;
+        }
+        // Find second space
+        for (end = beg + 1; end < mFrameBuffer.position(); ++end) {
+            if (mFrameBuffer.get(end) == ' ') break;
+        }
+        // Parse status code between them
+        ++beg;
+        int statusCode = 0;
+        for (int i = 0; beg + i < end; ++i) {
+            int digit = (mFrameBuffer.get(beg + i) - 0x30);
+            statusCode *= 10;
+            statusCode += digit;
+        }
+        // Find end of line to extract error message
+        ++end;
+        int eol;
+        for (eol = end; eol < mFrameBuffer.position(); ++eol) {
+            if (mFrameBuffer.get(eol) == 0x0d) break;
+        }
+        int statusMessageLength = eol - end;
+        byte[] statusBuf = new byte[statusMessageLength];
+        mFrameBuffer.position(end);
+        mFrameBuffer.get(statusBuf, 0, statusMessageLength);
+        String statusMessage = new String(statusBuf, "UTF-8");
+        if (DEBUG) Log.w(TAG, String.format("Status: %d (%s)", statusCode, statusMessage));
+        return new Pair<Integer, String>(statusCode, statusMessage);
+    }
+
+
+    /**
+     * Consume data buffered in mFrameBuffer.
+     */
+    private boolean consumeData() throws Exception {
+
+        if (mState == STATE_OPEN || mState == STATE_CLOSING) {
+
+            return processData();
+
+        } else if (mState == STATE_CONNECTING) {
+
+            return processHandshake();
+
+        } else if (mState == STATE_CLOSED) {
+
+            return false;
 
-                     // dispatch WS binary message
-                     onBinaryMessage(mMessagePayload.toByteArray());
+        } else {
+            // should not arrive here
+            return false;
+        }
 
-                  } else {
+    }
 
-                     // should not arrive here (handled before)
-                     throw new Exception("logic error");
-                  }
 
-                  // ok, message completed - reset all
-                  mInsideMessage = false;
-                  mMessagePayload.reset();
-               }
-            }
+    /**
+     * Run the background reader thread loop.
+     */
+    @Override
+    public void run() {
 
-            // reset frame
-            mFrameHeader = null;
+        if (DEBUG) Log.d(TAG, "running");
 
-            // reprocess if more data left
-            return mFrameBuffer.position() > 0;
+        try {
 
-         } else {
+            mFrameBuffer.clear();
+            do {
+                // blocking read on socket
+                int len;
+                if (null != mSSLEngine) {
+                    len = nioSslPeer.read(mSocket, mSSLEngine, mFrameBuffer);
+                } else {
+                    len = mSocket.read(mFrameBuffer);
+                }
+                if (len > 0) {
+                    // process buffered data
+                    while (consumeData()) {
+                    }
+                } else if (mState == STATE_CLOSED) {
+                    notify(new WebSocketMessage.Close(1000)); // Connection has been closed normally
+                    mStopped = true;
+                } else if (len < 0) {
 
-            // need more data
-            return false;
-         }
-      }
-   }
+                    if (DEBUG) Log.d(TAG, "run() : ConnectionLost");
 
+                    notify(new WebSocketMessage.ConnectionLost());
+                    mStopped = true;
+                }
+            } while (!mStopped);
 
-   /**
-    * WebSockets handshake reply from server received, default notifies master.
-    * 
-    * @param success	Success handshake flag
-    */
-   protected void onHandshake(boolean success) {
-
-      notify(new WebSocketMessage.ServerHandshake(success));
-   }
-
-
-   /**
-    * WebSockets close received, default notifies master.
-    */
-   protected void onClose(int code, String reason) {
-
-      notify(new WebSocketMessage.Close(code, reason));
-   }
-
-
-   /**
-    * WebSockets ping received, default notifies master.
-    *
-    * @param payload    Ping payload or null.
-    */
-   protected void onPing(byte[] payload) {
-
-      notify(new WebSocketMessage.Ping(payload));
-   }
-
-
-   /**
-    * WebSockets pong received, default notifies master.
-    *
-    * @param payload    Pong payload or null.
-    */
-   protected void onPong(byte[] payload) {
-
-      notify(new WebSocketMessage.Pong(payload));
-   }
-
-
-   /**
-    * WebSockets text message received, default notifies master.
-    * This will only be called when the option receiveTextMessagesRaw
-    * HAS NOT been set.
-    *
-    * @param payload    Text message payload as Java String decoded
-    *                   from raw UTF-8 payload or null (empty payload).
-    */
-   protected void onTextMessage(String payload) {
-
-      notify(new WebSocketMessage.TextMessage(payload));
-   }
-
-
-   /**
-    * WebSockets text message received, default notifies master.
-    * This will only be called when the option receiveTextMessagesRaw
-    * HAS been set.
-    *
-    * @param payload    Text message payload as raw UTF-8 octets or
-    *                   null (empty payload).
-    */
-   protected void onRawTextMessage(byte[] payload) {
-
-      notify(new WebSocketMessage.RawTextMessage(payload));
-   }
-
-
-   /**
-    * WebSockets binary message received, default notifies master.
-    *
-    * @param payload    Binary message payload or null (empty payload).
-    */
-   protected void onBinaryMessage(byte[] payload) {
-
-      notify(new WebSocketMessage.BinaryMessage(payload));
-   }
-
-
-   /**
-    * Process WebSockets handshake received from server.
-    */
-   private boolean processHandshake() throws UnsupportedEncodingException {
-
-      boolean res = false;
-      for (int pos = mFrameBuffer.position() - 4; pos >= 0; --pos) {
-         if (mFrameBuffer.get(pos+0) == 0x0d &&
-             mFrameBuffer.get(pos+1) == 0x0a &&
-             mFrameBuffer.get(pos+2) == 0x0d &&
-             mFrameBuffer.get(pos+3) == 0x0a) {
-
-            /// \todo process & verify handshake from server
-            /// \todo forward subprotocol, if any
-
-            int oldPosition = mFrameBuffer.position();
-            
-            // Check HTTP status code
-            boolean serverError = false;
-            if (mFrameBuffer.get(0) == 'H' &&
-            	mFrameBuffer.get(1) == 'T' &&
-            	mFrameBuffer.get(2) == 'T' &&
-            	mFrameBuffer.get(3) == 'P') {
-            	
-            	Pair<Integer, String> status = parseHttpStatus();
-            	if (status.first >= 300) {
-            		// Invalid status code for success connection
-            		notify(new WebSocketMessage.ServerError(status.first, status.second));
-            		serverError = true;
-            	}
-            }
-            
-            mFrameBuffer.position(pos + 4);
-            mFrameBuffer.limit(oldPosition);
-            mFrameBuffer.compact();
+        } catch (WebSocketException e) {
 
-            if (!serverError) {
-            	// process further when data after HTTP headers left in buffer
-                res = mFrameBuffer.position() > 0;
+            if (DEBUG) Log.d(TAG, "run() : WebSocketException (" + e.toString() + ")");
 
-                mState = STATE_OPEN;
-            } else {
-            	res = true;
-            	mState = STATE_CLOSED;
-            	mStopped = true;
-            }
-            
-            onHandshake(!serverError);
-            break;
-         }
-      }
-      return res;
-   }
-   
-   @SuppressWarnings("unused")
-   private Map<String, String> parseHttpHeaders(byte[] buffer) throws UnsupportedEncodingException {
-	   // TODO: use utf-8 validator?
-	   String s = new String(buffer, "UTF-8");
-	   Map<String, String> headers = new HashMap<String, String>();
-	   
-	   String[] lines = s.split("\r\n");
-	   for (String line : lines) {
-		   if (line.length() > 0) {
-			   String[] h = line.split(": ");
-			   if (h.length == 2) {
-				   headers.put(h[0], h[1]);
-				   Log.w(TAG, String.format("'%s'='%s'", h[0], h[1]));
-			   }
-		   }
-	   }
-	   
-	   return headers;
-   }
-   
-   private Pair<Integer, String> parseHttpStatus() throws UnsupportedEncodingException {
-	   int beg, end;
-		// Find first space
-		for (beg = 4; beg < mFrameBuffer.position(); ++beg) {
-			if (mFrameBuffer.get(beg) == ' ') break;
-		}
-		// Find second space
-		for (end = beg + 1; end < mFrameBuffer.position(); ++end) {
-			if (mFrameBuffer.get(end) == ' ') break;
-		}
-		// Parse status code between them
-		++beg;
-		int statusCode = 0;
-		for (int i = 0; beg + i < end; ++i) {
-			int digit = (mFrameBuffer.get(beg + i) - 0x30);
-			statusCode *= 10;
-			statusCode += digit;
-		}
-		// Find end of line to extract error message
-		++end;
-		int eol;
-		for (eol = end; eol < mFrameBuffer.position(); ++eol) {
-			if (mFrameBuffer.get(eol) == 0x0d) break;
-		}
-		int statusMessageLength = eol - end;
-		byte[] statusBuf = new byte[statusMessageLength];
-		mFrameBuffer.position(end);
-		mFrameBuffer.get(statusBuf, 0, statusMessageLength);
-		String statusMessage = new String(statusBuf, "UTF-8");
-		if (DEBUG) Log.w(TAG, String.format("Status: %d (%s)", statusCode, statusMessage));
-		return new Pair<Integer, String>(statusCode, statusMessage);
-   }
-
-
-   /**
-    * Consume data buffered in mFrameBuffer.
-    */
-   private boolean consumeData() throws Exception {
-
-      if (mState == STATE_OPEN || mState == STATE_CLOSING) {
-
-         return processData();
-
-      } else if (mState == STATE_CONNECTING) {
-
-         return processHandshake();
-
-      } else if (mState == STATE_CLOSED) {
-
-         return false;
-
-      } else {
-         // should not arrive here
-         return false;
-      }
-
-   }
-
-
-   /**
-    * Run the background reader thread loop.
-    */
-   @Override
-   public void run() {
-
-      if (DEBUG) Log.d(TAG, "running");
-
-      try {
-
-         mFrameBuffer.clear();
-         do {
-            // blocking read on socket
-            int len = mSocket.read(mFrameBuffer);
-            if (len > 0) {
-               // process buffered data
-               while (consumeData()) {
-               }
-            } else if (mState == STATE_CLOSED) {
-                notify(new WebSocketMessage.Close(1000)); // Connection has been closed normally
-                mStopped = true;
-            } else if (len < 0) {
-
-               if (DEBUG) Log.d(TAG, "run() : ConnectionLost");
-
-               notify(new WebSocketMessage.ConnectionLost());
-               mStopped = true;
-            }
-         } while (!mStopped);
+            // wrap the exception and notify master
+            notify(new WebSocketMessage.ProtocolViolation(e));
 
-      } catch (WebSocketException e) {
+        } catch (SocketException e) {
 
-         if (DEBUG) Log.d(TAG, "run() : WebSocketException (" + e.toString() + ")");
+            if (DEBUG) Log.d(TAG, "run() : SocketException (" + e.toString() + ")");
 
-         // wrap the exception and notify master
-         notify(new WebSocketMessage.ProtocolViolation(e));
+            // wrap the exception and notify master
+            notify(new WebSocketMessage.ConnectionLost());
+            ;
 
-      } catch (SocketException e) {
-    	  
-    	  if (DEBUG) Log.d(TAG, "run() : SocketException (" + e.toString() + ")");
-    	  
-    	  // wrap the exception and notify master
-    	  notify(new WebSocketMessage.ConnectionLost());;
-    	  
-      } catch (Exception e) {
+        } catch (Exception e) {
 
-         if (DEBUG) Log.d(TAG, "run() : Exception (" + e.toString() + ")");
+            if (DEBUG) Log.d(TAG, "run() : Exception (" + e.toString() + ")");
 
-         // wrap the exception and notify master
-         notify(new WebSocketMessage.Error(e));
+            // wrap the exception and notify master
+            notify(new WebSocketMessage.Error(e));
 
-      } finally {
+        } finally {
 
-         mStopped = true;
-      }
+            mStopped = true;
+        }
 
-      if (DEBUG) Log.d(TAG, "ended");
-   }
+        if (DEBUG) Log.d(TAG, "ended");
+    }
 }
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java b/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java
index 5530d97..610febf 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java
@@ -25,9 +25,13 @@
 
 import java.io.IOException;
 import java.net.SocketException;
+import java.nio.ByteBuffer;
 import java.nio.channels.SocketChannel;
 import java.util.Random;
 
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+
 /**
  * WebSocket writer, the sending leg of a WebSockets connection.
  * This is run on it's background thread with it's own message loop.
@@ -36,7 +40,7 @@
  * background thread) so that it can be formatted and sent out on the
  * underlying TCP socket.
  */
-public class WebSocketWriter extends Handler {
+public class WebSocketWriter extends NioSslPeer {
 
     private static final boolean DEBUG = true;
     private static final String TAG = WebSocketWriter.class.getName();
@@ -59,26 +63,41 @@
     /// The send buffer that holds data to send on socket.
     private final ByteBufferOutputStream mBuffer;
 
+    private SSLEngine mSSLEngine;
 
     /**
      * Create new WebSockets background writer.
      *
-     * @param looper  The message looper of the background thread on which
-     *                this object is running.
-     * @param master  The message handler of master (foreground thread).
-     * @param socket  The socket channel created on foreground thread.
-     * @param options WebSockets connection options.
+     * @param looper     The message looper of the background thread on which
+     *                   this object is running.
+     * @param master     The message handler of master (foreground thread).
+     * @param socket     The socket channel created on foreground thread.
+     * @param sslEngine   Optional {@link SSLContext}
+     * @param options    WebSockets connection options.
      */
-    public WebSocketWriter(Looper looper, Handler master, SocketChannel socket, WebSocketOptions options) {
+    public WebSocketWriter(Looper looper, Handler master, SocketChannel socket, SSLEngine sslEngine, WebSocketOptions options) {
 
         super(looper);
 
         mLooper = looper;
         mMaster = master;
         mSocket = socket;
+        mSSLEngine = sslEngine;
         mOptions = options;
         mBuffer = new ByteBufferOutputStream(options.getMaxFramePayloadSize() + 14, 4 * 64 * 1024);
 
+        try {
+            if (null != mSSLEngine) {
+                myAppData = mBuffer.getBuffer();
+                myNetData = ByteBuffer.allocate(mSSLEngine.getSession().getPacketBufferSize());
+                peerNetData = ByteBuffer.allocate(mSSLEngine.getSession().getPacketBufferSize());
+
+                doHandshake(socket, mSSLEngine);
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+
         if (DEBUG) Log.d(TAG, "created");
     }
 
@@ -93,6 +112,7 @@ public WebSocketWriter(Looper looper, Handler master, SocketChannel socket, WebS
      *                to be handled within processAppMessage() (in a class derived from
      *                this class).
      */
+
     public void forward(Object message) {
 
         Message msg = obtainMessage();
@@ -392,13 +412,16 @@ public void handleMessage(Message msg) {
             processMessage(msg.obj);
 
             // send out buffered data
-            mBuffer.flip();
-            while (mBuffer.remaining() > 0) {
-                // this can block on socket write
-                @SuppressWarnings("unused")
-                int written = mSocket.write(mBuffer.getBuffer());
+            if (null != mSSLEngine) {
+                write(mSocket, mSSLEngine, mBuffer.getBuffer());
+            } else {
+                mBuffer.flip();
+                while (mBuffer.remaining() > 0) {
+                    // this can block on socket write
+                    @SuppressWarnings("unused")
+                    int written = mSocket.write(mBuffer.getBuffer());
+                }
             }
-
         } catch (SocketException e) {
 
             if (DEBUG) Log.d(TAG, "run() : SocketException (" + e.toString() + ")");
@@ -423,6 +446,7 @@ public void handleMessage(Message msg) {
      * @param msg An instance of the message types within WebSocketMessage
      *            or a message that is handled in processAppMessage().
      */
+
     protected void processMessage(Object msg) throws IOException, WebSocketException {
 
         if (msg instanceof WebSocketMessage.TextMessage) {
@@ -480,4 +504,6 @@ protected void processAppMessage(Object msg) throws WebSocketException, IOExcept
 
         throw new WebSocketException("unknown message received by WebSocketWriter");
     }
+
+
 }
