diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocket.java b/Autobahn/src/de/tavendo/autobahn/WebSocket.java
index e846bce..a752d19 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocket.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocket.java
@@ -1,100 +1,76 @@
 package de.tavendo.autobahn;
 
-public interface WebSocket {
-   
-	/**
-    * Session handler for WebSocket sessions.
-    */
-   public interface ConnectionHandler {
-
-	   /**
-	    * Connection was closed normally.
-	    */
-	   public static final int CLOSE_NORMAL = 1;
-
-	   /**
-	    * Connection could not be established in the first place.
-	    */
-	   public static final int CLOSE_CANNOT_CONNECT = 2;
+import java.net.URI;
 
-	   /**
-	    * A previously established connection was lost unexpected.
-	    */
-	   public static final int CLOSE_CONNECTION_LOST = 3;
-
-	   /**
-	    * The connection was closed because a protocol violation
-	    * occurred.
-	    */
-	   public static final int CLOSE_PROTOCOL_ERROR = 4;
+public interface WebSocket {
+	public static final String UTF8_ENCODING = "UTF-8";
 
-	   /**
-	    * Internal error.
-	    */
-	   public static final int CLOSE_INTERNAL_ERROR = 5;
-	   
-	   /**
-	    * Server returned error while connecting
-	    */
-	   public static final int CLOSE_SERVER_ERROR = 6;
-	   
-	   /**
-	    * Server connection lost, scheduled reconnect
-	    */
-	   public static final int CLOSE_RECONNECT = 7;
+	/**
+	 * Session handler for WebSocket sessions.
+	 */
+	public interface WebSocketConnectionObserver {
+		public static enum WebSocketCloseNotification {
+			NORMAL,
+			CANNOT_CONNECT, 
+			CONNECTION_LOST, 
+			PROTOCOL_ERROR,
+			INTERNAL_ERROR,
+			SERVER_ERROR,
+			RECONNECT
+		}
 
-	   /**
-	    * Fired when the WebSockets connection has been established.
-	    * After this happened, messages may be sent.
-	    */
-	   public void onOpen();
+		/**
+		 * Fired when the WebSockets connection has been established.
+		 * After this happened, messages may be sent.
+		 */
+		public void onOpen();
 
-	   /**
-	    * Fired when the WebSockets connection has deceased (or could
-	    * not established in the first place).
-	    *
-	    * @param code       Close code.
-	    * @param reason     Close reason (human-readable).
-	    */
-	   public void onClose(int code, String reason);
+		/**
+		 * Fired when the WebSockets connection has deceased (or could
+		 * not established in the first place).
+		 *
+		 * @param code       Close code.
+		 * @param reason     Close reason (human-readable).
+		 */
+		public void onClose(WebSocketCloseNotification code, String reason);
 
-	   /**
-	    * Fired when a text message has been received (and text
-	    * messages are not set to be received raw).
-	    *
-	    * @param payload    Text message payload or null (empty payload).
-	    */
-	   public void onTextMessage(String payload);
+		/**
+		 * Fired when a text message has been received (and text
+		 * messages are not set to be received raw).
+		 *
+		 * @param payload    Text message payload or null (empty payload).
+		 */
+		public void onTextMessage(String payload);
 
-	   /**
-	    * Fired when a text message has been received (and text
-	    * messages are set to be received raw).
-	    *
-	    * @param payload    Text message payload as raw UTF-8 or null (empty payload).
-	    */
-	   public void onRawTextMessage(byte[] payload);
+		/**
+		 * Fired when a text message has been received (and text
+		 * messages are set to be received raw).
+		 *
+		 * @param payload    Text message payload as raw UTF-8 or null (empty payload).
+		 */
+		public void onRawTextMessage(byte[] payload);
 
-	   /**
-	    * Fired when a binary message has been received.
-	    *
-	    * @param payload    Binary message payload or null (empty payload).
-	    */
-	   public void onBinaryMessage(byte[] payload);
+		/**
+		 * Fired when a binary message has been received.
+		 *
+		 * @param payload    Binar message payload or null (empty payload).
+		 */
+		public void onBinaryMessage(byte[] payload);
 
-       /**
-        * Fired when a PONG message is received from the server.
-        *
-        * @param payload    Binary message payload or null (empty payload).
-        */
-       public void onPongMessage(byte[] payload);
-   }
+		/**
+		 * Fired when a PONG message is received from the server.
+		 *
+		 * @param payload    Binary message payload or null (empty payload).
+		 */
+		public void onPongMessage(byte[] payload);
+	}
 
-   public void connect(String wsUri, ConnectionHandler wsHandler) throws WebSocketException;
-   public void connect(String wsUri, ConnectionHandler wsHandler, WebSocketOptions options) throws WebSocketException;
-   public void disconnect();
-   public boolean isConnected();
-   public void sendBinaryMessage(byte[] payload);
-   public void sendRawTextMessage(byte[] payload);
-   public void sendTextMessage(String payload);
-   public void sendPingMessage(byte[] payload);
+	public void connect(URI uri, WebSocketConnectionObserver observer) throws WebSocketException;
+	public void connect(URI uri, WebSocketConnectionObserver observer, WebSocketOptions options) throws WebSocketException;
+	public void disconnect();
+	public boolean isConnected();
+	public void sendBinaryMessage(byte[] payload);
+	public void sendRawTextMessage(byte[] payload);
+	public void sendTextMessage(String payload);
+	public void sendPingMessage(byte[] payload);
 }
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java b/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java
index e424dac..f2069e9 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java
@@ -18,499 +18,533 @@
 
 package de.tavendo.autobahn;
 
+import java.io.IOException;
+import java.lang.ref.WeakReference;
+import java.net.Socket;
+import java.net.URI;
+
+import javax.net.SocketFactory;
+
+import android.net.SSLCertificateSocketFactory;
 import android.os.Handler;
-import android.os.HandlerThread;
+import android.os.Looper;
 import android.os.Message;
 import android.util.Log;
+import de.tavendo.autobahn.WebSocket.WebSocketConnectionObserver.WebSocketCloseNotification;
+import de.tavendo.autobahn.WebSocketMessage.WebSocketCloseCode;
+
+public class WebSocketConnection implements WebSocket {
+	private static final String TAG = WebSocketConnection.class.getName();
+	private static final String WS_URI_SCHEME = "ws";
+	private static final String WSS_URI_SCHEME = "wss";
+	private static final String WS_WRITER = "WebSocketWriter";
+	private static final String WS_READER = "WebSocketReader";
 
-import org.apache.http.message.BasicNameValuePair;
+	private final Handler mHandler;
 
-import java.io.IOException;
-import java.net.InetSocketAddress;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.nio.channels.SocketChannel;
-import java.util.List;
+	private WebSocketReader mWebSocketReader;
+	private WebSocketWriter mWebSocketWriter;
 
-public class WebSocketConnection implements WebSocket {
+	private Socket mSocket;
+	private SocketThread mSocketThread;
+
+	private URI mWebSocketURI;
+	private String[] mWebSocketSubprotocols;
+
+	private WeakReference<WebSocket.WebSocketConnectionObserver> mWebSocketConnectionObserver;
+
+	private WebSocketOptions mWebSocketOptions;
+	private boolean mPreviousConnection = false;
+
+
+
+	public WebSocketConnection() {
+		Log.d(TAG, "WebSocket connection created.");
+
+		this.mHandler = new ThreadHandler(this);
+	}
+
+
+
+	//
+	// Forward to the writer thread
+	public void sendTextMessage(String payload) {
+		mWebSocketWriter.forward(new WebSocketMessage.TextMessage(payload));
+	}
+
+
+	public void sendRawTextMessage(byte[] payload) {
+		mWebSocketWriter.forward(new WebSocketMessage.RawTextMessage(payload));
+	}
+
+
+	public void sendBinaryMessage(byte[] payload) {
+		mWebSocketWriter.forward(new WebSocketMessage.BinaryMessage(payload));
+	}
+
+	public void sendPingMessage(byte[] payload) {
+		mWebSocketWriter.forward(new WebSocketMessage.Ping(payload));
+	}
+
+	public boolean isConnected() {
+		return mSocket != null && mSocket.isConnected() && !mSocket.isClosed();
+	}
+
+
+
+	private void failConnection(WebSocketCloseNotification code, String reason) {
+		Log.d(TAG, "fail connection [code = " + code + ", reason = " + reason);
+
+		if (mWebSocketReader != null) {
+			mWebSocketReader.quit();
+
+			try {
+				mWebSocketReader.join();
+			} catch (InterruptedException e) {
+				e.printStackTrace();
+			}
+		} else {
+			Log.d(TAG, "mReader already NULL");
+		}
 
-   private static final boolean DEBUG = true;
-   private static final String TAG = WebSocketConnection.class.getName();
+		if (mWebSocketWriter != null) {
+			mWebSocketWriter.forward(new WebSocketMessage.Quit());
 
-   protected Handler mMasterHandler;
+			try {
+				mWebSocketWriter.join();
+			} catch (InterruptedException e) {
+				e.printStackTrace();
+			}
+		} else {
+			Log.d(TAG, "mWriter already NULL");
+		}
+
+		if (mSocket != null) {
+			mSocketThread.getHandler().post(new Runnable() {
+
+				@Override
+				public void run() {
+					mSocketThread.stopConnection();
+				}
+			});
+		} else {
+			Log.d(TAG, "mTransportChannel already NULL");
+		}
+		
+		mSocketThread.getHandler().post(new Runnable() {
+			
+			@Override
+			public void run() {
+				Looper.myLooper().quit();
+			}
+		});
 
-   protected WebSocketReader mReader;
-   protected WebSocketWriter mWriter;
-   protected HandlerThread mWriterThread;
+		onClose(code, reason);
 
-   protected SocketChannel mTransportChannel;
+		Log.d(TAG, "worker threads stopped");
+	}
+
+
+
+	public void connect(URI webSocketURI, WebSocket.WebSocketConnectionObserver connectionObserver) throws WebSocketException {
+		connect(webSocketURI, connectionObserver, new WebSocketOptions());
+	}
 
-   private URI mWsUri;
-   private String mWsScheme;
-   private String mWsHost;
-   private int mWsPort;
-   private String mWsPath;
-   private String mWsQuery;
-   private String[] mWsSubprotocols;
-   private List<BasicNameValuePair> mWsHeaders;
+	public void connect(URI webSocketURI, WebSocket.WebSocketConnectionObserver connectionObserver, WebSocketOptions options) throws WebSocketException {
+		connect(webSocketURI, null, connectionObserver, options);
+	}
 
-   private WebSocket.ConnectionHandler mWsHandler;
+	public void connect(URI webSocketURI, String[] subprotocols, WebSocket.WebSocketConnectionObserver connectionObserver, WebSocketOptions options) throws WebSocketException {
+		if (isConnected()) {
+			throw new WebSocketException("already connected");
+		}
 
-   protected WebSocketOptions mOptions;
-   
-   private boolean mActive;
-   private boolean mPrevConnected;
+		if (webSocketURI == null) {
+			throw new WebSocketException("WebSockets URI null.");
+		} else {
+			this.mWebSocketURI = webSocketURI;
+			if (!mWebSocketURI.getScheme().equals(WS_URI_SCHEME) && !mWebSocketURI.getScheme().equals(WSS_URI_SCHEME)) {
+				throw new WebSocketException("unsupported scheme for WebSockets URI");
+			}
+
+			this.mWebSocketSubprotocols = subprotocols;
+			this.mWebSocketConnectionObserver = new WeakReference<WebSocket.WebSocketConnectionObserver>(connectionObserver);
+			this.mWebSocketOptions = new WebSocketOptions(options);
+
+			connect();
+		}
+	}
+
+	public void disconnect() {
+		if (mWebSocketWriter != null && mWebSocketWriter.isAlive()) {
+			mWebSocketWriter.forward(new WebSocketMessage.Close());
+		} else {
+			Log.d(TAG, "Could not send WebSocket Close .. writer already null");
+		}
+
+		this.mPreviousConnection = false;
+	}
 
 	/**
-	 * Asynchronous socket connector.
+	 * Reconnect to the server with the latest options 
+	 * @return true if reconnection performed
 	 */
-	private class WebSocketConnector extends Thread {
+	public boolean reconnect() {
+		if (!isConnected() && (mWebSocketURI != null)) {
+			connect();
+			return true;
+		}
+		return false;
+	}
 
-		public void run() {
-			Thread.currentThread().setName("WebSocketConnector");
+	private void connect() {
+		mSocketThread = new SocketThread(mWebSocketURI, mWebSocketOptions);
 
-			/*
-			 * connect TCP socket
-			 */
+		mSocketThread.start();
+		synchronized (mSocketThread) {
 			try {
-				mTransportChannel = SocketChannel.open();
+				mSocketThread.wait();
+			} catch (InterruptedException e) {
+			}
+		}
+		mSocketThread.getHandler().post(new Runnable() {
+			
+			@Override
+			public void run() {
+				mSocketThread.startConnection();
+			}
+		});
+		
+		synchronized (mSocketThread) {
+			try {
+				mSocketThread.wait();
+			} catch (InterruptedException e) {
+			}
+		}
 
-				// the following will block until connection was established or
-				// an error occurred!
-				mTransportChannel.socket().connect(
-						new InetSocketAddress(mWsHost, mWsPort),
-						mOptions.getSocketConnectTimeout());
+		this.mSocket = mSocketThread.getSocket();
+		
+		if (mSocket == null) {
+			onClose(WebSocketCloseNotification.CANNOT_CONNECT, mSocketThread.getFailureMessage());
+		} else if (mSocket.isConnected()) {
+			try {
+				createReader();
+				createWriter();
 
-				// before doing any data transfer on the socket, set socket
-				// options
-				mTransportChannel.socket().setSoTimeout(
-						mOptions.getSocketReceiveTimeout());
-				mTransportChannel.socket().setTcpNoDelay(
-						mOptions.getTcpNoDelay());
+				WebSocketMessage.ClientHandshake clientHandshake = new WebSocketMessage.ClientHandshake(mWebSocketURI, null, mWebSocketSubprotocols);
+				mWebSocketWriter.forward(clientHandshake);
+			} catch (Exception e) {
+				onClose(WebSocketCloseNotification.INTERNAL_ERROR, e.getLocalizedMessage());
+			}
+		} else {
+			onClose(WebSocketCloseNotification.CANNOT_CONNECT, "could not connect to WebSockets server");
+		}
+	}
 
-			} catch (IOException e) {
-				onClose(WebSocketConnectionHandler.CLOSE_CANNOT_CONNECT,
-						e.getMessage());
-				return;
+	/**
+	 * Perform reconnection
+	 * 
+	 * @return true if reconnection was scheduled
+	 */
+	protected boolean scheduleReconnect() {
+		/**
+		 * Reconnect only if:
+		 *  - connection active (connected but not disconnected)
+		 *  - has previous success connections
+		 *  - reconnect interval is set
+		 */
+		int interval = mWebSocketOptions.getReconnectInterval();
+        boolean shouldReconnect = mSocket != null
+                && mSocket.isConnected()
+                && mPreviousConnection
+                && (interval > 0);
+        if (shouldReconnect) {
+			Log.d(TAG, "WebSocket reconnection scheduled");
+			mHandler.postDelayed(new Runnable() {
+
+				public void run() {
+					Log.d(TAG, "WebSocket reconnecting...");
+					reconnect();
+				}
+			}, interval);
+		}
+		return shouldReconnect;
+	}
+
+	/**
+	 * Common close handler
+	 * 
+	 * @param code       Close code.
+	 * @param reason     Close reason (human-readable).
+	 */
+	private void onClose(WebSocketCloseNotification code, String reason) {
+		boolean reconnecting = false;
+
+		if ((code == WebSocketCloseNotification.CANNOT_CONNECT) || (code == WebSocketCloseNotification.CONNECTION_LOST)) {
+			reconnecting = scheduleReconnect();
+		}
+
+		WebSocket.WebSocketConnectionObserver webSocketObserver = mWebSocketConnectionObserver.get();
+		if (webSocketObserver != null) {
+			try {
+				if (reconnecting) {
+					webSocketObserver.onClose(WebSocketConnectionObserver.WebSocketCloseNotification.RECONNECT, reason);
+				} else {
+					webSocketObserver.onClose(code, reason);
+				}
+			} catch (Exception e) {
+				e.printStackTrace();
 			}
+		} else {
+			Log.d(TAG, "WebSocketObserver null");
+		}
+	}
 
-			if (mTransportChannel.isConnected()) {
 
-				try {
 
-					// create & start WebSocket reader
-					createReader();
 
-					// create & start WebSocket writer
-					createWriter();
+	protected void processAppMessage(Object message) {
+	}
 
-					// start WebSockets handshake
-					WebSocketMessage.ClientHandshake hs = new WebSocketMessage.ClientHandshake(
-							mWsHost + ":" + mWsPort);
-					hs.mPath = mWsPath;
-					hs.mQuery = mWsQuery;
-					hs.mSubprotocols = mWsSubprotocols;
-					hs.mHeaderList = mWsHeaders;
-					mWriter.forward(hs);
 
-					mPrevConnected = true;
+	/**
+	 * Create WebSockets background writer.
+	 */
+	protected void createWriter() {
+		mWebSocketWriter = new WebSocketWriter(mHandler, mSocket, mWebSocketOptions, WS_WRITER);
+		mWebSocketWriter.start();
 
-				} catch (Exception e) {
-					onClose(WebSocketConnectionHandler.CLOSE_INTERNAL_ERROR,
-							e.getMessage());
-					return;
-				}
-			} else {
-				onClose(WebSocketConnectionHandler.CLOSE_CANNOT_CONNECT,
-						"Could not connect to WebSocket server");
-				return;
+		synchronized (mWebSocketWriter) {
+			try {
+				mWebSocketWriter.wait();
+			} catch (InterruptedException e) {
 			}
 		}
 
+		Log.d(TAG, "WebSocket writer created and started.");
 	}
 
-   public WebSocketConnection() {
-      if (DEBUG) Log.d(TAG, "created");
-      
-      // create WebSocket master handler
-      createHandler();
-      
-      // set initial values
-      mActive = false;
-      mPrevConnected = false;
-   }
 
+	/**
+	 * Create WebSockets background reader.
+	 */
+	protected void createReader() {
 
-   public void sendTextMessage(String payload) {
-      mWriter.forward(new WebSocketMessage.TextMessage(payload));
-   }
+		mWebSocketReader = new WebSocketReader(mHandler, mSocket, mWebSocketOptions, WS_READER);
+		mWebSocketReader.start();
 
+		synchronized (mWebSocketReader) {
+			try {
+				mWebSocketReader.wait();
+			} catch (InterruptedException e) {
+			}
+		}
 
-   public void sendRawTextMessage(byte[] payload) {
-      mWriter.forward(new WebSocketMessage.RawTextMessage(payload));
-   }
+		Log.d(TAG, "WebSocket reader created and started.");
+	}
 
+	private void handleMessage(Message message) {
+		WebSocket.WebSocketConnectionObserver webSocketObserver = mWebSocketConnectionObserver.get();
 
-   public void sendBinaryMessage(byte[] payload) {
-      mWriter.forward(new WebSocketMessage.BinaryMessage(payload));
-   }
+		if (message.obj instanceof WebSocketMessage.TextMessage) {
+			WebSocketMessage.TextMessage textMessage = (WebSocketMessage.TextMessage) message.obj;
 
-
-   public void sendPingMessage(byte[] payload) {
-       mWriter.forward(new WebSocketMessage.Ping(payload));
-   }
-
-   public boolean isConnected() {
-      return mTransportChannel != null && mTransportChannel.isConnected();
-   }
-
-
-   private void failConnection(int code, String reason) {
-
-      if (DEBUG) Log.d(TAG, "fail connection [code = " + code + ", reason = " + reason);
-
-      if (mReader != null) {
-         mReader.quit();
-         try {
-            mReader.join();
-         } catch (InterruptedException e) {
-            if (DEBUG) e.printStackTrace();
-         }
-         //mReader = null;
-      } else {
-         if (DEBUG) Log.d(TAG, "mReader already NULL");
-      }
-
-      if (mWriter != null) {
-         //mWriterThread.getLooper().quit();
-         mWriter.forward(new WebSocketMessage.Quit());
-         try {
-            mWriterThread.join();
-         } catch (InterruptedException e) {
-            if (DEBUG) e.printStackTrace();
-         }
-         //mWriterThread = null;
-      } else {
-         if (DEBUG) Log.d(TAG, "mWriter already NULL");
-      }
-
-      if (mTransportChannel != null) {
-         try {
-            mTransportChannel.close();
-         } catch (IOException e) {
-            if (DEBUG) e.printStackTrace();
-         }
-         //mTransportChannel = null;
-      } else {
-         if (DEBUG) Log.d(TAG, "mTransportChannel already NULL");
-      }
-
-      onClose(code, reason);
-
-      if (DEBUG) Log.d(TAG, "worker threads stopped");
-   }
-
-
-   public void connect(String wsUri, WebSocket.ConnectionHandler wsHandler) throws WebSocketException {
-      connect(wsUri, null, wsHandler, new WebSocketOptions(), null);
-   }
-
-
-   public void connect(String wsUri, WebSocket.ConnectionHandler wsHandler, WebSocketOptions options) throws WebSocketException {
-      connect(wsUri, null, wsHandler, options, null);
-   }
-
-
-   public void connect(String wsUri, String[] wsSubprotocols, WebSocket.ConnectionHandler wsHandler, WebSocketOptions options, List<BasicNameValuePair> headers) throws WebSocketException {
-
-      // don't connect if already connected .. user needs to disconnect first
-      //
-      if (mTransportChannel != null && mTransportChannel.isConnected()) {
-         throw new WebSocketException("already connected");
-      }
-
-      // parse WebSockets URI
-      //
-      try {
-         mWsUri = new URI(wsUri);
-
-         if (!mWsUri.getScheme().equals("ws") && !mWsUri.getScheme().equals("wss")) {
-            throw new WebSocketException("unsupported scheme for WebSockets URI");
-         }
-
-         if (mWsUri.getScheme().equals("wss")) {
-            throw new WebSocketException("secure WebSockets not implemented");
-         }
-
-         mWsScheme = mWsUri.getScheme();
-
-         if (mWsUri.getPort() == -1) {
-            if (mWsScheme.equals("ws")) {
-               mWsPort = 80;
-            } else {
-               mWsPort = 443;
-            }
-         } else {
-            mWsPort = mWsUri.getPort();
-         }
-
-         if (mWsUri.getHost() == null) {
-            throw new WebSocketException("no host specified in WebSockets URI");
-         } else {
-            mWsHost = mWsUri.getHost();
-         }
-
-         if (mWsUri.getPath() == null || mWsUri.getPath().equals("")) {
-            mWsPath = "/";
-         } else {
-            mWsPath = mWsUri.getPath();
-         }
-
-         if (mWsUri.getQuery() == null || mWsUri.getQuery().equals("")) {
-            mWsQuery = null;
-         } else {
-            mWsQuery = mWsUri.getQuery();
-         }
-
-      } catch (URISyntaxException e) {
-
-         throw new WebSocketException("invalid WebSockets URI");
-      }
-
-      mWsSubprotocols = wsSubprotocols;
-      mWsHeaders = headers;
-      mWsHandler = wsHandler;
-
-      // make copy of options!
-      mOptions = new WebSocketOptions(options);
-      
-      // set connection active
-      mActive = true;
-
-      // use asynch connector on short-lived background thread
-      new WebSocketConnector().start();
-   }
-
-
-   public void disconnect() {
-      if (mWriter != null) {
-         mWriter.forward(new WebSocketMessage.Close(1000));
-      } else {
-         if (DEBUG) Log.d(TAG, "could not send Close .. writer already NULL");
-      }
-      mActive = false;
-      mPrevConnected = false;
-   }
-   
-   /**
-    * Reconnect to the server with the latest options 
-    * @return true if reconnection performed
-    */
-   public boolean reconnect() {
-	   if (!isConnected() && (mWsUri != null)) {
-		   new WebSocketConnector().start();
-		   return true;
-	   }
-	   return false;
-   }
-   
-   /**
-    * Perform reconnection
-    * 
-    * @return true if reconnection was scheduled
-    */
-   protected boolean scheduleReconnect() {
-	   /**
-	    * Reconnect only if:
-	    *  - connection active (connected but not disconnected)
-	    *  - has previous success connections
-	    *  - reconnect interval is set
-	    */
-	   int interval = mOptions.getReconnectInterval();
-	   boolean need = mActive && mPrevConnected && (interval > 0);
-	   if (need) {
-		   if (DEBUG) Log.d(TAG, "Reconnection scheduled");
-		   mMasterHandler.postDelayed(new Runnable() {
-			
-			public void run() {
-				if (DEBUG) Log.d(TAG, "Reconnecting...");
-				reconnect();
+			if (webSocketObserver != null) {
+				webSocketObserver.onTextMessage(textMessage.mPayload);
+			} else {
+				Log.d(TAG, "could not call onTextMessage() .. handler already NULL");
 			}
-		}, interval);
-	   }
-	   return need;
-   }
-   
-   /**
-    * Common close handler
-    * 
-    * @param code       Close code.
-	* @param reason     Close reason (human-readable).
-    */
-   private void onClose(int code, String reason) {
-	   boolean reconnecting = false;
-	   
-	   if ((code == WebSocket.ConnectionHandler.CLOSE_CANNOT_CONNECT) ||
-			   (code == WebSocket.ConnectionHandler.CLOSE_CONNECTION_LOST)) {
-		   reconnecting = scheduleReconnect();
-	   }
-	   
-	   
-	   if (mWsHandler != null) {
-		   try {
-			   if (reconnecting) {
-				   mWsHandler.onClose(WebSocket.ConnectionHandler.CLOSE_RECONNECT, reason);
-			   } else {
-				   mWsHandler.onClose(code, reason);
-			   }
-		   } catch (Exception e) {
-			   if (DEBUG) e.printStackTrace();
-		   }
-		   //mWsHandler = null;
-	   } else {
-		   if (DEBUG) Log.d(TAG, "mWsHandler already NULL");
-	   }
-   }
-
-
-   /**
-    * Create master message handler.
-    */
-   protected void createHandler() {
-
-      mMasterHandler = new Handler() {
-
-         public void handleMessage(Message msg) {
-
-            if (msg.obj instanceof WebSocketMessage.TextMessage) {
-
-               WebSocketMessage.TextMessage textMessage = (WebSocketMessage.TextMessage) msg.obj;
 
-               if (mWsHandler != null) {
-                  mWsHandler.onTextMessage(textMessage.mPayload);
-               } else {
-                  if (DEBUG) Log.d(TAG, "could not call onTextMessage() .. handler already NULL");
-               }
+		} else if (message.obj instanceof WebSocketMessage.RawTextMessage) {
+			WebSocketMessage.RawTextMessage rawTextMessage = (WebSocketMessage.RawTextMessage) message.obj;
 
-            } else if (msg.obj instanceof WebSocketMessage.RawTextMessage) {
+			if (webSocketObserver != null) {
+				webSocketObserver.onRawTextMessage(rawTextMessage.mPayload);
+			} else {
+				Log.d(TAG, "could not call onRawTextMessage() .. handler already NULL");
+			}
 
-               WebSocketMessage.RawTextMessage rawTextMessage = (WebSocketMessage.RawTextMessage) msg.obj;
+		} else if (message.obj instanceof WebSocketMessage.BinaryMessage) {
+			WebSocketMessage.BinaryMessage binaryMessage = (WebSocketMessage.BinaryMessage) message.obj;
 
-               if (mWsHandler != null) {
-                  mWsHandler.onRawTextMessage(rawTextMessage.mPayload);
-               } else {
-                  if (DEBUG) Log.d(TAG, "could not call onRawTextMessage() .. handler already NULL");
-               }
+			if (webSocketObserver != null) {
+				webSocketObserver.onBinaryMessage(binaryMessage.mPayload);
+			} else {
+				Log.d(TAG, "could not call onBinaryMessage() .. handler already NULL");
+			}
 
-            } else if (msg.obj instanceof WebSocketMessage.BinaryMessage) {
+		} else if (message.obj instanceof WebSocketMessage.Ping) {
+			WebSocketMessage.Ping ping = (WebSocketMessage.Ping) message.obj;
+			Log.d(TAG, "WebSockets Ping received");
 
-               WebSocketMessage.BinaryMessage binaryMessage = (WebSocketMessage.BinaryMessage) msg.obj;
+			WebSocketMessage.Pong pong = new WebSocketMessage.Pong();
+			pong.mPayload = ping.mPayload;
+			mWebSocketWriter.forward(pong);
 
-               if (mWsHandler != null) {
-                  mWsHandler.onBinaryMessage(binaryMessage.mPayload);
-               } else {
-                  if (DEBUG) Log.d(TAG, "could not call onBinaryMessage() .. handler already NULL");
-               }
+		} else if (message.obj instanceof WebSocketMessage.Pong) {
+			WebSocketMessage.Pong pong = (WebSocketMessage.Pong) message.obj;
 
-            } else if (msg.obj instanceof WebSocketMessage.Ping) {
+			Log.d(TAG, "WebSockets Pong received" + pong.mPayload);
 
-               WebSocketMessage.Ping ping = (WebSocketMessage.Ping) msg.obj;
-               if (DEBUG) Log.d(TAG, "WebSockets Ping received");
+			final WebSocketMessage.Pong pongMessage = (WebSocketMessage.Pong) message.obj;
 
-               // reply with Pong
-               WebSocketMessage.Pong pong = new WebSocketMessage.Pong();
-               pong.mPayload = ping.mPayload;
-               mWriter.forward(pong);
+			if (webSocketObserver != null) {
+				webSocketObserver.onPongMessage(pongMessage.mPayload);
+			} else {
+				Log.d(TAG, "could not call onPongMessage() .. handler already NULL");
+			}
 
-            } else if (msg.obj instanceof WebSocketMessage.Pong) {
+		} else if (message.obj instanceof WebSocketMessage.Close) {
+			WebSocketMessage.Close close = (WebSocketMessage.Close) message.obj;
 
-               final WebSocketMessage.Pong pongMessage = (WebSocketMessage.Pong) msg.obj;
+			Log.d(TAG, "WebSockets Close received (" + close.getCode() + " - " + close.getReason() + ")");
 
-               if (mWsHandler != null) {
-                  mWsHandler.onPongMessage(pongMessage.mPayload);
-               } else {
-                  if (DEBUG) Log.d(TAG, "could not call onPongMessage() .. handler already NULL");
-               }
+			mWebSocketWriter.forward(new WebSocketMessage.Close(WebSocketCloseCode.NORMAL));
 
-            } else if (msg.obj instanceof WebSocketMessage.Close) {
+		} else if (message.obj instanceof WebSocketMessage.ServerHandshake) {
+			WebSocketMessage.ServerHandshake serverHandshake = (WebSocketMessage.ServerHandshake) message.obj;
 
-               WebSocketMessage.Close close = (WebSocketMessage.Close) msg.obj;
+			Log.d(TAG, "opening handshake received");
 
-               if (DEBUG) Log.d(TAG, "WebSockets Close received (" + close.mCode + " - " + close.mReason + ")");
+			if (serverHandshake.mSuccess) {
+				if (webSocketObserver != null) {
+					webSocketObserver.onOpen();
+				} else {
+					Log.d(TAG, "could not call onOpen() .. handler already NULL");
+				}
+				mPreviousConnection = true;
+			}
+
+		} else if (message.obj instanceof WebSocketMessage.ConnectionLost) {
+			//			WebSocketMessage.ConnectionLost connectionLost = (WebSocketMessage.ConnectionLost) message.obj;
+			failConnection(WebSocketCloseNotification.CONNECTION_LOST, "WebSockets connection lost");
+
+		} else if (message.obj instanceof WebSocketMessage.ProtocolViolation) {
+			//			WebSocketMessage.ProtocolViolation protocolViolation = (WebSocketMessage.ProtocolViolation) message.obj;
+			failConnection(WebSocketCloseNotification.PROTOCOL_ERROR, "WebSockets protocol violation");
+
+		} else if (message.obj instanceof WebSocketMessage.Error) {
+			WebSocketMessage.Error error = (WebSocketMessage.Error) message.obj;
+			failConnection(WebSocketCloseNotification.INTERNAL_ERROR, "WebSockets internal error (" + error.mException.toString() + ")");
 
-               mWriter.forward(new WebSocketMessage.Close(1000));
+		} else if (message.obj instanceof WebSocketMessage.ServerError) {
+			WebSocketMessage.ServerError error = (WebSocketMessage.ServerError) message.obj;
+			failConnection(WebSocketCloseNotification.SERVER_ERROR, "Server error " + error.mStatusCode + " (" + error.mStatusMessage + ")");
 
-            } else if (msg.obj instanceof WebSocketMessage.ServerHandshake) {
+		} else {
+			processAppMessage(message.obj);
+
+		}
+	}
 
-               WebSocketMessage.ServerHandshake serverHandshake = (WebSocketMessage.ServerHandshake) msg.obj;
 
-               if (DEBUG) Log.d(TAG, "opening handshake received");
-               
-               if (serverHandshake.mSuccess) {
-            	   if (mWsHandler != null) {
-                       mWsHandler.onOpen();
-                    } else {
-                       if (DEBUG) Log.d(TAG, "could not call onOpen() .. handler already NULL");
-                    }
-               }
 
-            } else if (msg.obj instanceof WebSocketMessage.ConnectionLost) {
+	public static class SocketThread extends Thread {
+		private static final String WS_CONNECTOR = "WebSocketConnector";
 
-               @SuppressWarnings("unused")
-               WebSocketMessage.ConnectionLost connnectionLost = (WebSocketMessage.ConnectionLost) msg.obj;
-               failConnection(WebSocketConnectionHandler.CLOSE_CONNECTION_LOST, "WebSockets connection lost");
+		private final URI mWebSocketURI;
 
-            } else if (msg.obj instanceof WebSocketMessage.ProtocolViolation) {
+		private Socket mSocket = null;
+		private String mFailureMessage = null;
+		
+		private Handler mHandler;
+		
 
-               @SuppressWarnings("unused")
-               WebSocketMessage.ProtocolViolation protocolViolation = (WebSocketMessage.ProtocolViolation) msg.obj;
-               failConnection(WebSocketConnectionHandler.CLOSE_PROTOCOL_ERROR, "WebSockets protocol violation");
 
-            } else if (msg.obj instanceof WebSocketMessage.Error) {
+		public SocketThread(URI uri, WebSocketOptions options) {
+			this.setName(WS_CONNECTOR);
+			
+			this.mWebSocketURI = uri;
+		}
 
-               WebSocketMessage.Error error = (WebSocketMessage.Error) msg.obj;
-               failConnection(WebSocketConnectionHandler.CLOSE_INTERNAL_ERROR, "WebSockets internal error (" + error.mException.toString() + ")");
-               
-            } else if (msg.obj instanceof WebSocketMessage.ServerError) {
-            	
-            	WebSocketMessage.ServerError error = (WebSocketMessage.ServerError) msg.obj;
-            	failConnection(WebSocketConnectionHandler.CLOSE_SERVER_ERROR, "Server error " + error.mStatusCode + " (" + error.mStatusMessage + ")");
 
-            } else {
 
-               processAppMessage(msg.obj);
+		@Override
+		public void run() {
+			Looper.prepare();
+			this.mHandler = new Handler();
+			synchronized (this) {
+				notifyAll();
+			}
+			
+			Looper.loop();
+			Log.d(TAG, "SocketThread exited.");
+		}
+
+
+
+		public void startConnection() {	
+			try {
+				String host = mWebSocketURI.getHost();
+				int port = mWebSocketURI.getPort();
+
+				if (port == -1) {
+					if (mWebSocketURI.getScheme().equals(WSS_URI_SCHEME)) {
+						port = 443;
+					} else {
+						port = 80;
+					}
+				}
+				
+				SocketFactory factory = null;
+				if (mWebSocketURI.getScheme().equalsIgnoreCase(WSS_URI_SCHEME)) {
+					factory = SSLCertificateSocketFactory.getDefault();
+				} else {
+					factory = SocketFactory.getDefault();
+				}
+
+				// Do not replace host string with InetAddress or you lose automatic host name verification
+				this.mSocket = factory.createSocket(host, port);
+			} catch (IOException e) {
+				this.mFailureMessage = e.getLocalizedMessage();
+			}
+			
+			synchronized (this) {
+				notifyAll();
+			}
+		}
+		
+		public void stopConnection() {
+			try {
+				mSocket.close();
+				this.mSocket = null;
+			} catch (IOException e) {
+				this.mFailureMessage = e.getLocalizedMessage();
+			}
+		}
 
-            }
-         }
-      };
-   }
+		public Handler getHandler() {
+			return mHandler;
+		}
+		public Socket getSocket() {
+			return mSocket;
+		}
+		public String getFailureMessage() {
+			return mFailureMessage;
+		}
+	}
 
 
-   protected void processAppMessage(Object message) {
-   }
 
+	private static class ThreadHandler extends Handler {
+		private final WeakReference<WebSocketConnection> mWebSocketConnection;
 
-   /**
-    * Create WebSockets background writer.
-    */
-   protected void createWriter() {
 
-      mWriterThread = new HandlerThread("WebSocketWriter");
-      mWriterThread.start();
-      mWriter = new WebSocketWriter(mWriterThread.getLooper(), mMasterHandler, mTransportChannel, mOptions);
 
-      if (DEBUG) Log.d(TAG, "WS writer created and started");
-   }
+		public ThreadHandler(WebSocketConnection webSocketConnection) {
+			super();
 
+			this.mWebSocketConnection = new WeakReference<WebSocketConnection>(webSocketConnection);
+		}
 
-   /**
-    * Create WebSockets background reader.
-    */
-   protected void createReader() {
 
-      mReader = new WebSocketReader(mMasterHandler, mTransportChannel, mOptions, "WebSocketReader");
-      mReader.start();
 
-      if (DEBUG) Log.d(TAG, "WS reader created and started");
-   }
+		@Override
+		public void handleMessage(Message message) {
+			WebSocketConnection webSocketConnection = mWebSocketConnection.get();
+			if (webSocketConnection != null) {
+				webSocketConnection.handleMessage(message);
+			}
+		}
+	}
 }
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketConnectionHandler.java b/Autobahn/src/de/tavendo/autobahn/WebSocketConnectionHandler.java
index 62cb604..9643e49 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketConnectionHandler.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketConnectionHandler.java
@@ -22,7 +22,7 @@
  * WebSockets event handler. Users will usually provide an instance of a class
  * derived from this to handle WebSockets received messages and open/close events
  */
-public class WebSocketConnectionHandler implements WebSocket.ConnectionHandler {
+public class WebSocketConnectionHandler implements WebSocket.WebSocketConnectionObserver {
 
    /**
     * Fired when the WebSockets connection has been established.
@@ -38,7 +38,7 @@ public void onOpen() {
     * @param code       Close code.
     * @param reason     Close reason (human-readable).
     */
-   public void onClose(int code, String reason) {
+   public void onClose(WebSocketCloseNotification code, String reason) {
    }
 
    /**
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketFrameHeader.java b/Autobahn/src/de/tavendo/autobahn/WebSocketFrameHeader.java
new file mode 100644
index 0000000..d9a068f
--- /dev/null
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketFrameHeader.java
@@ -0,0 +1,54 @@
+package de.tavendo.autobahn;
+
+public class WebSocketFrameHeader {
+	private int mOpcode;
+	private boolean mFin;
+	private int mReserved;
+	private int mHeaderLen;
+	private int mPayloadLen;
+	private int mTotalLen;
+	private byte[] mMask;
+	
+	public int getOpcode() {
+		return mOpcode;
+	}
+	public void setOpcode(int opcode) {
+		this.mOpcode = opcode;
+	}
+	public boolean isFin() {
+		return mFin;
+	}
+	public void setFin(boolean fin) {
+		this.mFin = fin;
+	}
+	public int getReserved() {
+		return mReserved;
+	}
+	public void setReserved(int reserved) {
+		this.mReserved = reserved;
+	}
+	public int getHeaderLength() {
+		return mHeaderLen;
+	}
+	public void setHeaderLength(int headerLength) {
+		this.mHeaderLen = headerLength;
+	}
+	public int getPayloadLength() {
+		return mPayloadLen;
+	}
+	public void setPayloadLength(int payloadLength) {
+		this.mPayloadLen = payloadLength;
+	}
+	public int getTotalLength() {
+		return mTotalLen;
+	}
+	public void setTotalLen(int totalLength) {
+		this.mTotalLen = totalLength;
+	}
+	public byte[] getMask() {
+		return mMask;
+	}
+	public void setMask(byte[] mask) {
+		this.mMask = mask;
+	}
+}
\ No newline at end of file
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketMessage.java b/Autobahn/src/de/tavendo/autobahn/WebSocketMessage.java
index 393d2a6..677c60c 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketMessage.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketMessage.java
@@ -18,8 +18,7 @@
 
 package de.tavendo.autobahn;
 
-import java.util.List;
-import org.apache.http.message.BasicNameValuePair;
+import java.net.URI;
 
 /**
  * WebSockets message classes.
@@ -27,170 +26,194 @@
  * for WebSockets connections.
  */
 public class WebSocketMessage {
+	public static class WebSocketCloseCode {
+		public static final int NORMAL = 1000;
+		public static final int ENDPOINT_GOING_AWAY = 1001;		 
+		public static final int ENDPOINT_PROTOCOL_ERROR = 1002;
+		public static final int ENDPOINT_UNSUPPORTED_DATA_TYPE = 1003;
+		public static final int RESERVED = 1004;
+		public static final int RESERVED_NO_STATUS = 1005;
+		public static final int RESERVED_NO_CLOSING_HANDSHAKE = 1006;
+		public static final int ENDPOINT_BAD_DATA = 1007;
+		public static final int POLICY_VIOLATION = 1008;
+		public static final int MESSAGE_TOO_BIG = 1009;
+		public static final int ENDPOINT_NEEDS_EXTENSION = 1010;
+		public static final int UNEXPECTED_CONDITION = 1011;
+		public static final int RESERVED_TLS_REQUIRED = 1015;
+	}
+
 
-   /// Base message class.
-   public static class Message {
-   }
-
-   /// Quite background thread.
-   public static class Quit extends Message {
-   }
-
-   /// Initial WebSockets handshake (client request).
-   public static class ClientHandshake extends Message {
-
-      public String mHost;
-      public String mPath;
-      public String mQuery;
-      public String mOrigin;
-      public String[] mSubprotocols;
-      public List<BasicNameValuePair> mHeaderList;
-
-      ClientHandshake(String host) {
-         mHost = host;
-         mPath = "/";
-         mOrigin = null;
-         mSubprotocols = null;
-         mHeaderList = null;
-      }
-
-      ClientHandshake(String host, String path, String origin) {
-         mHost = host;
-         mPath = path;
-         mOrigin = origin;
-         mSubprotocols = null;
-      }
-
-      ClientHandshake(String host, String path, String origin, String[] subprotocols) {
-         mHost = host;
-         mPath = path;
-         mOrigin = origin;
-         mSubprotocols = subprotocols;
-      }
-   }
-
-   /// Initial WebSockets handshake (server response).
-   public static class ServerHandshake extends Message {
-	   public boolean mSuccess;
-	   
-	   public ServerHandshake(boolean success) {
-		   mSuccess = success;
-	   }
-   }
-
-   /// WebSockets connection lost
-   public static class ConnectionLost extends Message {
-   }
-   
-   public static class ServerError extends Message {
-	   public int mStatusCode;
-	   public String mStatusMessage;
-	   
-	   public ServerError(int statusCode, String statusMessage) {
-		   mStatusCode = statusCode;
-		   mStatusMessage = statusMessage;
-	   }
-	   
-   }
-
-   /// WebSockets reader detected WS protocol violation.
-   public static class ProtocolViolation extends Message {
-
-      public WebSocketException mException;
-
-      public ProtocolViolation(WebSocketException e) {
-         mException = e;
-      }
-   }
-
-   /// An exception occured in the WS reader or WS writer.
-   public static class Error extends Message {
-
-      public Exception mException;
-
-      public Error(Exception e) {
-         mException = e;
-      }
-   }
-
-   /// WebSockets text message to send or received.
-   public static class TextMessage extends Message {
-
-      public String mPayload;
-
-      TextMessage(String payload) {
-         mPayload = payload;
-      }
-   }
-
-   /// WebSockets raw (UTF-8) text message to send or received.
-   public static class RawTextMessage extends Message {
-
-      public byte[] mPayload;
-
-      RawTextMessage(byte[] payload) {
-         mPayload = payload;
-      }
-   }
-
-   /// WebSockets binary message to send or received.
-   public static class BinaryMessage extends Message {
-
-      public byte[] mPayload;
-
-      BinaryMessage(byte[] payload) {
-         mPayload = payload;
-      }
-   }
-
-   /// WebSockets close to send or received.
-   public static class Close extends Message {
-
-      public int mCode;
-      public String mReason;
-
-      Close() {
-         mCode = -1;
-         mReason = null;
-      }
-
-      Close(int code) {
-         mCode = code;
-         mReason = null;
-      }
-
-      Close(int code, String reason) {
-         mCode = code;
-         mReason = reason;
-      }
-   }
-
-   /// WebSockets ping to send or received.
-   public static class Ping extends Message {
-
-      public byte[] mPayload;
-
-      Ping() {
-         mPayload = null;
-      }
+	/// Base message class.
+	public static class Message {
+	}
+
+	/// Quite background thread.
+	public static class Quit extends Message {
+	}
 
-      Ping(byte[] payload) {
-         mPayload = payload;
-      }
-   }
+	/// Initial WebSockets handshake (client request).
+	public static class ClientHandshake extends Message {
+		private final URI mURI;
+		private final URI mOrigin;
+		private final String[] mSubprotocols;
 
-   /// WebSockets pong to send or received.
-   public static class Pong extends Message {
 
-      public byte[] mPayload;
 
-      Pong() {
-         mPayload = null;
-      }
+		ClientHandshake(URI uri) {
+			this.mURI = uri;
+			this.mOrigin = null;
+			this.mSubprotocols = null;
+		}
 
-      Pong(byte[] payload) {
-         mPayload = payload;
-      }
-   }
+		ClientHandshake(URI uri, URI origin, String[] subprotocols) {
+			this.mURI = uri;
+			this.mOrigin = origin;
+			this.mSubprotocols = subprotocols;
+		}
+
+
+
+		public URI getURI() {
+			return mURI;
+		}
+		public URI getOrigin() {
+			return mOrigin;
+		}
+		public String[] getSubprotocols() {
+			return mSubprotocols;
+		}
+	}
+
+	/// Initial WebSockets handshake (server response).
+	public static class ServerHandshake extends Message {
+		public boolean mSuccess;
+
+		public ServerHandshake(boolean success) {
+			mSuccess = success;
+		}
+	}
+
+	/// WebSockets connection lost
+	public static class ConnectionLost extends Message {
+	}
+
+	public static class ServerError extends Message {
+		public int mStatusCode;
+		public String mStatusMessage;
+
+		public ServerError(int statusCode, String statusMessage) {
+			mStatusCode = statusCode;
+			mStatusMessage = statusMessage;
+		}
+
+	}
+
+	/// WebSockets reader detected WS protocol violation.
+	public static class ProtocolViolation extends Message {
+
+		public WebSocketException mException;
+
+		public ProtocolViolation(WebSocketException e) {
+			mException = e;
+		}
+	}
+
+	/// An exception occured in the WS reader or WS writer.
+	public static class Error extends Message {
+
+		public Exception mException;
+
+		public Error(Exception e) {
+			mException = e;
+		}
+	}
+
+	/// WebSockets text message to send or received.
+	public static class TextMessage extends Message {
+
+		public String mPayload;
+
+		TextMessage(String payload) {
+			mPayload = payload;
+		}
+	}
+
+	/// WebSockets raw (UTF-8) text message to send or received.
+	public static class RawTextMessage extends Message {
+
+		public byte[] mPayload;
+
+		RawTextMessage(byte[] payload) {
+			mPayload = payload;
+		}
+	}
+
+	/// WebSockets binary message to send or received.
+	public static class BinaryMessage extends Message {
+
+		public byte[] mPayload;
+
+		BinaryMessage(byte[] payload) {
+			mPayload = payload;
+		}
+	}
+
+	/// WebSockets close to send or received.
+	public static class Close extends Message {
+		private int mCode;
+		private String mReason;
+
+
+		Close() {
+			mCode = WebSocketCloseCode.UNEXPECTED_CONDITION;
+			mReason = null;
+		}
+
+		Close(int code) {
+			mCode = code;
+			mReason = null;
+		}
+
+		Close(int code, String reason) {
+			mCode = code;
+			mReason = reason;
+		}
+
+
+		public int getCode() {
+			return mCode;
+		}
+		public String getReason() {
+			return mReason;
+		}
+	}
+
+	/// WebSockets ping to send or received.
+	public static class Ping extends Message {
+
+		public byte[] mPayload;
+
+		Ping() {
+			mPayload = null;
+		}
+
+		Ping(byte[] payload) {
+			mPayload = payload;
+		}
+	}
+
+	/// WebSockets pong to send or received.
+	public static class Pong extends Message {
+
+		public byte[] mPayload;
+
+		Pong() {
+			mPayload = null;
+		}
+
+		Pong(byte[] payload) {
+			mPayload = payload;
+		}
+	}
 
 }
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketReader.java b/Autobahn/src/de/tavendo/autobahn/WebSocketReader.java
index 37b79a0..9037d08 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketReader.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketReader.java
@@ -18,17 +18,18 @@
 
 package de.tavendo.autobahn;
 
+import java.io.IOException;
+import java.io.InputStream;
 import java.io.UnsupportedEncodingException;
+import java.net.Socket;
 import java.net.SocketException;
 import java.nio.ByteBuffer;
-import java.nio.channels.SocketChannel;
-import java.util.HashMap;
-import java.util.Map;
 
 import android.os.Handler;
 import android.os.Message;
 import android.util.Log;
 import android.util.Pair;
+import de.tavendo.autobahn.WebSocketMessage.WebSocketCloseCode;
 
 /**
  * WebSocket reader, the receiving leg of a WebSockets connection.
@@ -38,657 +39,632 @@
  * which gracefully shuts down the background receiver thread.
  */
 public class WebSocketReader extends Thread {
+	private static final String TAG = WebSocketReader.class.getCanonicalName();
 
-   private static final boolean DEBUG = true;
-   private static final String TAG = WebSocketReader.class.getName();
+	private static enum ReaderState { 
+		STATE_CLOSED,
+		STATE_CONNECTING,
+		STATE_CLOSING,
+		STATE_OPEN
+	}
 
-   private final Handler mMaster;
-   private final SocketChannel mSocket;
-   private final WebSocketOptions mOptions;
+	private final Handler mWebSocketConnectionHandler;
+	private final Socket mSocket;
+	private InputStream mInputStream;
+	private final WebSocketOptions mWebSocketOptions;
 
-   private final ByteBuffer mFrameBuffer;
-   private NoCopyByteArrayOutputStream mMessagePayload;
+	private volatile boolean mStopped = false;
 
-   private final static int STATE_CLOSED = 0;
-   private final static int STATE_CONNECTING = 1;
-   private final static int STATE_CLOSING = 2;
-   private final static int STATE_OPEN = 3;
 
-   private boolean mStopped = false;
-   private int mState;
+	private final byte[] mNetworkBuffer;
+	private final ByteBuffer mApplicationBuffer;
+	private NoCopyByteArrayOutputStream mMessagePayload;
 
-   private boolean mInsideMessage = false;
-   private int mMessageOpcode;
+	private ReaderState mState;
 
-   /// Frame currently being received.
-   private FrameHeader mFrameHeader;
+	private boolean mInsideMessage = false;
+	private int mMessageOpcode;
 
-   private Utf8Validator mUtf8Validator = new Utf8Validator();
+	private WebSocketFrameHeader mFrameHeader;
+	private Utf8Validator mUTF8Validator = new Utf8Validator();
 
 
-   /**
-    * WebSockets frame metadata.
-    */
-   private static class FrameHeader {
-      public int mOpcode;
-      public boolean mFin;
-      @SuppressWarnings("unused")
-      public int mReserved;
-      public int mHeaderLen;
-      public int mPayloadLen;
-      public int mTotalLen;
-      public byte[] mMask;
-   }
-
-
-   /**
-    * Create new WebSockets background reader.
-    *
-    * @param master    The message handler of master (foreground thread).
-    * @param socket    The socket channel created on foreground thread.
-    */
-   public WebSocketReader(Handler master, SocketChannel socket, WebSocketOptions options, String threadName) {
-
-      super(threadName);
-
-      mMaster = master;
-      mSocket = socket;
-      mOptions = options;
-
-      mFrameBuffer = ByteBuffer.allocateDirect(options.getMaxFramePayloadSize() + 14);
-      mMessagePayload = new NoCopyByteArrayOutputStream(options.getMaxMessagePayloadSize());
-
-      mFrameHeader = null;
-      mState = STATE_CONNECTING;
-
-      if (DEBUG) Log.d(TAG, "created");
-   }
-
-
-   /**
-    * Graceful shutdown of background reader thread (called from master).
-    */
-   public void quit() {
-
-      mStopped = true;
-
-      if (DEBUG) Log.d(TAG, "quit");
-   }
-
-
-   /**
-    * Notify the master (foreground thread) of WebSockets message received
-    * and unwrapped.
-    *
-    * @param message       Message to send to master.
-    */
-   protected void notify(Object message) {
-
-      Message msg = mMaster.obtainMessage();
-      msg.obj = message;
-      mMaster.sendMessage(msg);
-   }
-
-
-   /**
-    * Process incoming WebSockets data (after handshake).
-    */
-   private boolean processData() throws Exception {
-
-      // outside frame?
-      if (mFrameHeader == null) {
-
-         // need at least 2 bytes from WS frame header to start processing
-         if (mFrameBuffer.position() >= 2) {
-
-            byte b0 = mFrameBuffer.get(0);
-            boolean fin = (b0 & 0x80) != 0;
-            int rsv = (b0 & 0x70) >> 4;
-            int opcode = b0 & 0x0f;
-
-            byte b1 = mFrameBuffer.get(1);
-            boolean masked = (b1 & 0x80) != 0;
-            int payload_len1 = b1 & 0x7f;
-
-            // now check protocol compliance
-
-            if (masked) {
-               // currently, we don't allow this. need to see whats the final spec.
-               throw new WebSocketException("masked server frame");
-            }
-
-            if (opcode > 7) {
-               // control frame
-               if (!fin) {
-                  throw new WebSocketException("fragmented control frame");
-               }
-               if (payload_len1 > 125) {
-                  throw new WebSocketException("control frame with payload length > 125 octets");
-               }
-               if (opcode != 8 && opcode != 9 && opcode != 10) {
-                  throw new WebSocketException("control frame using reserved opcode " + opcode);
-               }
-               if (opcode == 8 && payload_len1 == 1) {
-                  throw new WebSocketException("received close control frame with payload len 1");
-               }
-            } else {
-               // message frame
-               if (opcode != 0 && opcode != 1 && opcode != 2) {
-                  throw new WebSocketException("data frame using reserved opcode " + opcode);
-               }
-               if (!mInsideMessage && opcode == 0) {
-                  throw new WebSocketException("received continuation data frame outside fragmented message");
-               }
-               if (mInsideMessage && opcode != 0) {
-                  throw new WebSocketException("received non-continuation data frame while inside fragmented message");
-               }
-            }
-
-            int mask_len = masked ? 4 : 0;
-            int header_len = 0;
-
-            if (payload_len1 < 126) {
-               header_len = 2 + mask_len;
-            } else if (payload_len1 == 126) {
-               header_len = 2 + 2 + mask_len;
-            } else if (payload_len1 == 127) {
-               header_len = 2 + 8 + mask_len;
-            } else {
-               // should not arrive here
-               throw new Exception("logic error");
-            }
-
-            // continue when complete frame header is available
-            if (mFrameBuffer.position() >= header_len) {
-
-               // determine frame payload length
-               int i = 2;
-               long payload_len = 0;
-               if (payload_len1 == 126) {
-                  payload_len = ((0xff & mFrameBuffer.get(i)) << 8) | (0xff & mFrameBuffer.get(i+1));
-                  if (payload_len < 126) {
-                     throw new WebSocketException("invalid data frame length (not using minimal length encoding)");
-                  }
-                  i += 2;
-               } else if (payload_len1 == 127) {
-                  if ((0x80 & mFrameBuffer.get(i+0)) != 0) {
-                     throw new WebSocketException("invalid data frame length (> 2^63)");
-                  }
-                  payload_len = ((long)(0xff & mFrameBuffer.get(i+0)) << 56) |
-                                ((long)(0xff & mFrameBuffer.get(i+1)) << 48) |
-                                ((long)(0xff & mFrameBuffer.get(i+2)) << 40) |
-                                ((long)(0xff & mFrameBuffer.get(i+3)) << 32) |
-                                ((long)(0xff & mFrameBuffer.get(i+4)) << 24) |
-                                ((long)(0xff & mFrameBuffer.get(i+5)) << 16) |
-                                ((long)(0xff & mFrameBuffer.get(i+6)) <<  8) |
-                                ((long)(0xff & mFrameBuffer.get(i+7))      );
-                  if (payload_len < 65536) {
-                     throw new WebSocketException("invalid data frame length (not using minimal length encoding)");
-                  }
-                  i += 8;
-               } else {
-                  payload_len = payload_len1;
-               }
-
-               // immediately bail out on frame too large
-               if (payload_len > mOptions.getMaxFramePayloadSize()) {
-                  throw new WebSocketException("frame payload too large");
-               }
-
-               // save frame header metadata
-               mFrameHeader = new FrameHeader();
-               mFrameHeader.mOpcode = opcode;
-               mFrameHeader.mFin = fin;
-               mFrameHeader.mReserved = rsv;
-               mFrameHeader.mPayloadLen = (int) payload_len;
-               mFrameHeader.mHeaderLen = header_len;
-               mFrameHeader.mTotalLen = mFrameHeader.mHeaderLen + mFrameHeader.mPayloadLen;
-               if (masked) {
-                  mFrameHeader.mMask = new byte[4];
-                  for (int j = 0; j < 4; ++j) {
-                     mFrameHeader.mMask[i] = (byte) (0xff & mFrameBuffer.get(i + j));
-                  }
-                  i += 4;
-               } else {
-                  mFrameHeader.mMask = null;
-               }
-
-               // continue processing when payload empty or completely buffered
-               return mFrameHeader.mPayloadLen == 0 || mFrameBuffer.position() >= mFrameHeader.mTotalLen;
-
-            } else {
-
-               // need more data
-               return false;
-            }
-         } else {
-
-            // need more data
-            return false;
-         }
-
-      } else {
-
-         /// \todo refactor this for streaming processing, incl. fail fast on invalid UTF-8 within frame already
-
-         // within frame
-
-         // see if we buffered complete frame
-         if (mFrameBuffer.position() >= mFrameHeader.mTotalLen) {
-
-            // cut out frame payload
-            byte[] framePayload = null;
-            int oldPosition = mFrameBuffer.position();
-            if (mFrameHeader.mPayloadLen > 0) {
-               framePayload = new byte[mFrameHeader.mPayloadLen];
-               mFrameBuffer.position(mFrameHeader.mHeaderLen);
-               mFrameBuffer.get(framePayload, 0, (int) mFrameHeader.mPayloadLen);
-            }
-            mFrameBuffer.position(mFrameHeader.mTotalLen);
-            mFrameBuffer.limit(oldPosition);
-            mFrameBuffer.compact();
-
-            if (mFrameHeader.mOpcode > 7) {
-               // control frame
-
-               if (mFrameHeader.mOpcode == 8) {
-
-                  int code = 1005; // CLOSE_STATUS_CODE_NULL : no status code received
-                  String reason = null;
-
-                  if (mFrameHeader.mPayloadLen >= 2) {
-
-                     // parse and check close code
-                     code = (framePayload[0] & 0xff) * 256 + (framePayload[1] & 0xff);
-                     if (code < 1000
-                           || (code >= 1000 && code <= 2999 &&
-                               code != 1000 && code != 1001 && code != 1002 && code != 1003 && code != 1007 && code != 1008 && code != 1009 && code != 1010 && code != 1011)
-                           || code >= 5000) {
-
-                        throw new WebSocketException("invalid close code " + code);
-                     }
-
-                     // parse and check close reason
-                     if (mFrameHeader.mPayloadLen > 2) {
-
-                        byte[] ra = new byte[mFrameHeader.mPayloadLen - 2];
-                        System.arraycopy(framePayload, 2, ra, 0, mFrameHeader.mPayloadLen - 2);
-
-                        Utf8Validator val = new Utf8Validator();
-                        val.validate(ra);
-                        if (!val.isValid()) {
-                           throw new WebSocketException("invalid close reasons (not UTF-8)");
-                        } else {
-                           reason = new String(ra, "UTF-8");
-                        }
-                     }
-                  }
-                  onClose(code, reason);
-
-               } else if (mFrameHeader.mOpcode == 9) {
-                  // dispatch WS ping
-                  onPing(framePayload);
-
-               } else if (mFrameHeader.mOpcode == 10) {
-                  // dispatch WS pong
-                  onPong(framePayload);
 
-               } else {
 
-                  // should not arrive here (handled before)
-                  throw new Exception("logic error");
-               }
+	/**
+	 * Create new WebSockets background reader.
+	 *
+	 * @param master    The message handler of master (foreground thread).
+	 * @param socket    The socket channel created on foreground thread.
+	 */
+	public WebSocketReader(Handler master, Socket socket, WebSocketOptions options, String threadName) {
+		super(threadName);
 
-            } else {
-               // message frame
+		this.mWebSocketConnectionHandler = master;
 
-               if (!mInsideMessage) {
-                  // new message started
-                  mInsideMessage = true;
-                  mMessageOpcode = mFrameHeader.mOpcode;
-                  if (mMessageOpcode == 1 && mOptions.getValidateIncomingUtf8()) {
-                     mUtf8Validator.reset();
-                  }
-               }
+		this.mSocket = socket;
+		this.mWebSocketOptions = options;
+
+		this.mNetworkBuffer = new byte[4096];
+		this.mApplicationBuffer = ByteBuffer.allocateDirect(options.getMaxFramePayloadSize() + 14);
+		this.mMessagePayload = new NoCopyByteArrayOutputStream(options.getMaxMessagePayloadSize());
+
+		this.mFrameHeader = null;
+		this.mState = ReaderState.STATE_CONNECTING;
+
+		Log.d(TAG, "WebSocket reader created.");
+	}
+
+
+	/**
+	 * Graceful shutdown of background reader thread (called from master).
+	 */
+	public void quit() {
+
+		mStopped = true;
+
+		Log.d(TAG, "quit");
+	}
+
+
+	/**
+	 * Notify the master (foreground thread) of WebSockets message received
+	 * and unwrapped.
+	 *
+	 * @param message       Message to send to master.
+	 */
+	protected void notify(Object message) {
+
+		Message msg = mWebSocketConnectionHandler.obtainMessage();
+		msg.obj = message;
+		mWebSocketConnectionHandler.sendMessage(msg);
+	}
+
+
+	/**
+	 * Process incoming WebSockets data (after handshake).
+	 */
+	private boolean processData() throws Exception {
+
+		// outside frame?
+		if (mFrameHeader == null) {
+
+			// need at least 2 bytes from WS frame header to start processing
+			if (mApplicationBuffer.position() >= 2) {
+
+				byte b0 = mApplicationBuffer.get(0);
+				boolean fin = (b0 & 0x80) != 0;
+				int rsv = (b0 & 0x70) >> 4;
+				int opcode = b0 & 0x0f;
+
+				byte b1 = mApplicationBuffer.get(1);
+				boolean masked = (b1 & 0x80) != 0;
+				int payload_len1 = b1 & 0x7f;
+
+				// now check protocol compliance
+
+				if (masked) {
+					// currently, we don't allow this. need to see whats the final spec.
+					throw new WebSocketException("masked server frame");
+				}
+
+				if (opcode > 7) {
+					// control frame
+					if (!fin) {
+						throw new WebSocketException("fragmented control frame");
+					}
+					if (payload_len1 > 125) {
+						throw new WebSocketException("control frame with payload length > 125 octets");
+					}
+					if (opcode != 8 && opcode != 9 && opcode != 10) {
+						throw new WebSocketException("control frame using reserved opcode " + opcode);
+					}
+					if (opcode == 8 && payload_len1 == 1) {
+						throw new WebSocketException("received close control frame with payload len 1");
+					}
+				} else {
+					// message frame
+					if (opcode != 0 && opcode != 1 && opcode != 2) {
+						throw new WebSocketException("data frame using reserved opcode " + opcode);
+					}
+					if (!mInsideMessage && opcode == 0) {
+						throw new WebSocketException("received continuation data frame outside fragmented message");
+					}
+					if (mInsideMessage && opcode != 0) {
+						throw new WebSocketException("received non-continuation data frame while inside fragmented message");
+					}
+				}
+
+				int mask_len = masked ? 4 : 0;
+				int header_len = 0;
+
+				if (payload_len1 < 126) {
+					header_len = 2 + mask_len;
+				} else if (payload_len1 == 126) {
+					header_len = 2 + 2 + mask_len;
+				} else if (payload_len1 == 127) {
+					header_len = 2 + 8 + mask_len;
+				} else {
+					// should not arrive here
+					throw new Exception("logic error");
+				}
+
+				// continue when complete frame header is available
+				if (mApplicationBuffer.position() >= header_len) {
+
+					// determine frame payload length
+					int i = 2;
+					long payload_len = 0;
+					if (payload_len1 == 126) {
+						payload_len = ((0xff & mApplicationBuffer.get(i)) << 8) | (0xff & mApplicationBuffer.get(i+1));
+						if (payload_len < 126) {
+							throw new WebSocketException("invalid data frame length (not using minimal length encoding)");
+						}
+						i += 2;
+					} else if (payload_len1 == 127) {
+						if ((0x80 & mApplicationBuffer.get(i+0)) != 0) {
+							throw new WebSocketException("invalid data frame length (> 2^63)");
+						}
+						payload_len = ((0xff & mApplicationBuffer.get(i+0)) << 56) |
+								((0xff & mApplicationBuffer.get(i+1)) << 48) |
+								((0xff & mApplicationBuffer.get(i+2)) << 40) |
+								((0xff & mApplicationBuffer.get(i+3)) << 32) |
+								((0xff & mApplicationBuffer.get(i+4)) << 24) |
+								((0xff & mApplicationBuffer.get(i+5)) << 16) |
+								((0xff & mApplicationBuffer.get(i+6)) <<  8) |
+								((0xff & mApplicationBuffer.get(i+7))      );
+						if (payload_len < 65536) {
+							throw new WebSocketException("invalid data frame length (not using minimal length encoding)");
+						}
+						i += 8;
+					} else {
+						payload_len = payload_len1;
+					}
+
+					// immediately bail out on frame too large
+					if (payload_len > mWebSocketOptions.getMaxFramePayloadSize()) {
+						throw new WebSocketException("frame payload too large");
+					}
+
+					// save frame header metadata
+					mFrameHeader = new WebSocketFrameHeader();
+					mFrameHeader.setOpcode(opcode);
+					mFrameHeader.setFin(fin);
+					mFrameHeader.setReserved(rsv);
+					mFrameHeader.setPayloadLength((int) payload_len);
+					mFrameHeader.setHeaderLength(header_len);
+					mFrameHeader.setTotalLen(mFrameHeader.getHeaderLength() + mFrameHeader.getPayloadLength());
+
+					if (masked) {
+						byte[] mask = new byte[4];
+						for (int j = 0; j < 4; ++j) {
+							mask[i] = (byte) (0xff & mApplicationBuffer.get(i + j));
+						}
+						mFrameHeader.setMask(mask);
+
+						i += 4;						
+					} else {
+						mFrameHeader.setMask(null);
+					}
+
+					// continue processing when payload empty or completely buffered
+					return mFrameHeader.getPayloadLength() == 0 || mApplicationBuffer.position() >= mFrameHeader.getTotalLength();
+
+				} else {
+
+					// need more data
+					return false;
+				}
+			} else {
+
+				// need more data
+				return false;
+			}
+
+		} else {
+
+			/// \todo refactor this for streaming processing, incl. fail fast on invalid UTF-8 within frame already
+
+			// within frame
+
+			// see if we buffered complete frame
+			if (mApplicationBuffer.position() >= mFrameHeader.getTotalLength()) {
+
+				// cut out frame payload
+				byte[] framePayload = null;
+				int oldPosition = mApplicationBuffer.position();
+				if (mFrameHeader.getPayloadLength() > 0) {
+					framePayload = new byte[mFrameHeader.getPayloadLength()];
+					mApplicationBuffer.position(mFrameHeader.getHeaderLength());
+					mApplicationBuffer.get(framePayload, 0, (int) mFrameHeader.getPayloadLength());
+				}
+				mApplicationBuffer.position(mFrameHeader.getTotalLength());
+				mApplicationBuffer.limit(oldPosition);
+				mApplicationBuffer.compact();
+
+				if (mFrameHeader.getOpcode() > 7) {
+					// control frame
+
+					if (mFrameHeader.getOpcode() == 8) {
+
+						int code = WebSocketCloseCode.RESERVED_NO_STATUS;
+						String reason = null;
+
+						if (mFrameHeader.getPayloadLength() >= 2) {
+
+							// parse and check close code
+							code = (framePayload[0] & 0xff) * 256 + (framePayload[1] & 0xff);
+							if (code < 1000
+									|| (code >= 1000 && code <= 2999 &&
+									code != 1000 && code != 1001 && code != 1002 && code != 1003 && code != 1007 && code != 1008 && code != 1009 && code != 1010 && code != 1011)
+									|| code >= 5000) {
+
+								throw new WebSocketException("invalid close code " + code);
+							}
+
+							// parse and check close reason
+							if (mFrameHeader.getPayloadLength() > 2) {
+
+								byte[] ra = new byte[mFrameHeader.getPayloadLength() - 2];
+								System.arraycopy(framePayload, 2, ra, 0, mFrameHeader.getPayloadLength() - 2);
+
+								Utf8Validator val = new Utf8Validator();
+								val.validate(ra);
+								if (!val.isValid()) {
+									throw new WebSocketException("invalid close reasons (not UTF-8)");
+								} else {
+									reason = new String(ra, WebSocket.UTF8_ENCODING);
+								}
+							}
+						}
+						onClose(code, reason);
 
-               if (framePayload != null) {
+					} else if (mFrameHeader.getOpcode() == 9) {
+						// dispatch WS ping
+						onPing(framePayload);
 
-                  // immediately bail out on message too large
-                  if (mMessagePayload.size() + framePayload.length > mOptions.getMaxMessagePayloadSize()) {
-                     throw new WebSocketException("message payload too large");
-                  }
+					} else if (mFrameHeader.getOpcode() == 10) {
+						// dispatch WS pong
+						onPong(framePayload);
 
-                  // validate incoming UTF-8
-                  if (mMessageOpcode == 1 && mOptions.getValidateIncomingUtf8() && !mUtf8Validator.validate(framePayload)) {
-                     throw new WebSocketException("invalid UTF-8 in text message payload");
-                  }
+					} else {
 
-                  // buffer frame payload for message
-                  mMessagePayload.write(framePayload);
-               }
+						// should not arrive here (handled before)
+						throw new Exception("logic error");
+					}
 
-               // on final frame ..
-               if (mFrameHeader.mFin) {
+				} else {
+					// message frame
 
-                  if (mMessageOpcode == 1) {
+					if (!mInsideMessage) {
+						// new message started
+						mInsideMessage = true;
+						mMessageOpcode = mFrameHeader.getOpcode();
+						if (mMessageOpcode == 1 && mWebSocketOptions.getValidateIncomingUtf8()) {
+							mUTF8Validator.reset();
+						}
+					}
 
-                     // verify that UTF-8 ends on codepoint
-                     if (mOptions.getValidateIncomingUtf8() && !mUtf8Validator.isValid()) {
-                        throw new WebSocketException("UTF-8 text message payload ended within Unicode code point");
-                     }
+					if (framePayload != null) {
 
-                     // deliver text message
-                     if (mOptions.getReceiveTextMessagesRaw()) {
+						// immediately bail out on message too large
+						if (mMessagePayload.size() + framePayload.length > mWebSocketOptions.getMaxMessagePayloadSize()) {
+							throw new WebSocketException("message payload too large");
+						}
 
-                        // dispatch WS text message as raw (but validated) UTF-8
-                        onRawTextMessage(mMessagePayload.toByteArray());
+						// validate incoming UTF-8
+						if (mMessageOpcode == 1 && mWebSocketOptions.getValidateIncomingUtf8() && !mUTF8Validator.validate(framePayload)) {
+							throw new WebSocketException("invalid UTF-8 in text message payload");
+						}
 
-                     } else {
+						// buffer frame payload for message
+						mMessagePayload.write(framePayload);
+					}
 
-                        // dispatch WS text message as Java String (previously already validated)
-                        String s = new String(mMessagePayload.toByteArray(), "UTF-8");
-                        onTextMessage(s);
-                     }
+					// on final frame ..
+					if (mFrameHeader.isFin()) {
 
-                  } else if (mMessageOpcode == 2) {
+						if (mMessageOpcode == 1) {
 
-                     // dispatch WS binary message
-                     onBinaryMessage(mMessagePayload.toByteArray());
+							// verify that UTF-8 ends on codepoint
+							if (mWebSocketOptions.getValidateIncomingUtf8() && !mUTF8Validator.isValid()) {
+								throw new WebSocketException("UTF-8 text message payload ended within Unicode code point");
+							}
 
-                  } else {
+							// deliver text message
+							if (mWebSocketOptions.getReceiveTextMessagesRaw()) {
 
-                     // should not arrive here (handled before)
-                     throw new Exception("logic error");
-                  }
+								// dispatch WS text message as raw (but validated) UTF-8
+								onRawTextMessage(mMessagePayload.toByteArray());
 
-                  // ok, message completed - reset all
-                  mInsideMessage = false;
-                  mMessagePayload.reset();
-               }
-            }
+							} else {
 
-            // reset frame
-            mFrameHeader = null;
+								// dispatch WS text message as Java String (previously already validated)
+								String s = new String(mMessagePayload.toByteArray(), WebSocket.UTF8_ENCODING);
+								onTextMessage(s);
+							}
 
-            // reprocess if more data left
-            return mFrameBuffer.position() > 0;
+						} else if (mMessageOpcode == 2) {
 
-         } else {
+							// dispatch WS binary message
+							onBinaryMessage(mMessagePayload.toByteArray());
 
-            // need more data
-            return false;
-         }
-      }
-   }
+						} else {
 
+							// should not arrive here (handled before)
+							throw new Exception("logic error");
+						}
 
-   /**
-    * WebSockets handshake reply from server received, default notifies master.
-    * 
-    * @param success	Success handshake flag
-    */
-   protected void onHandshake(boolean success) {
+						// ok, message completed - reset all
+						mInsideMessage = false;
+						mMessagePayload.reset();
+					}
+				}
 
-      notify(new WebSocketMessage.ServerHandshake(success));
-   }
+				// reset frame
+				mFrameHeader = null;
 
+				// reprocess if more data left
+				return mApplicationBuffer.position() > 0;
 
-   /**
-    * WebSockets close received, default notifies master.
-    */
-   protected void onClose(int code, String reason) {
-
-      notify(new WebSocketMessage.Close(code, reason));
-   }
-
-
-   /**
-    * WebSockets ping received, default notifies master.
-    *
-    * @param payload    Ping payload or null.
-    */
-   protected void onPing(byte[] payload) {
-
-      notify(new WebSocketMessage.Ping(payload));
-   }
-
-
-   /**
-    * WebSockets pong received, default notifies master.
-    *
-    * @param payload    Pong payload or null.
-    */
-   protected void onPong(byte[] payload) {
-
-      notify(new WebSocketMessage.Pong(payload));
-   }
-
-
-   /**
-    * WebSockets text message received, default notifies master.
-    * This will only be called when the option receiveTextMessagesRaw
-    * HAS NOT been set.
-    *
-    * @param payload    Text message payload as Java String decoded
-    *                   from raw UTF-8 payload or null (empty payload).
-    */
-   protected void onTextMessage(String payload) {
-
-      notify(new WebSocketMessage.TextMessage(payload));
-   }
-
-
-   /**
-    * WebSockets text message received, default notifies master.
-    * This will only be called when the option receiveTextMessagesRaw
-    * HAS been set.
-    *
-    * @param payload    Text message payload as raw UTF-8 octets or
-    *                   null (empty payload).
-    */
-   protected void onRawTextMessage(byte[] payload) {
-
-      notify(new WebSocketMessage.RawTextMessage(payload));
-   }
-
-
-   /**
-    * WebSockets binary message received, default notifies master.
-    *
-    * @param payload    Binary message payload or null (empty payload).
-    */
-   protected void onBinaryMessage(byte[] payload) {
-
-      notify(new WebSocketMessage.BinaryMessage(payload));
-   }
-
-
-   /**
-    * Process WebSockets handshake received from server.
-    */
-   private boolean processHandshake() throws UnsupportedEncodingException {
-
-      boolean res = false;
-      for (int pos = mFrameBuffer.position() - 4; pos >= 0; --pos) {
-         if (mFrameBuffer.get(pos+0) == 0x0d &&
-             mFrameBuffer.get(pos+1) == 0x0a &&
-             mFrameBuffer.get(pos+2) == 0x0d &&
-             mFrameBuffer.get(pos+3) == 0x0a) {
-
-            /// \todo process & verify handshake from server
-            /// \todo forward subprotocol, if any
-
-            int oldPosition = mFrameBuffer.position();
-            
-            // Check HTTP status code
-            boolean serverError = false;
-            if (mFrameBuffer.get(0) == 'H' &&
-            	mFrameBuffer.get(1) == 'T' &&
-            	mFrameBuffer.get(2) == 'T' &&
-            	mFrameBuffer.get(3) == 'P') {
-            	
-            	Pair<Integer, String> status = parseHttpStatus();
-            	if (status.first >= 300) {
-            		// Invalid status code for success connection
-            		notify(new WebSocketMessage.ServerError(status.first, status.second));
-            		serverError = true;
-            	}
-            }
-            
-            mFrameBuffer.position(pos + 4);
-            mFrameBuffer.limit(oldPosition);
-            mFrameBuffer.compact();
-
-            if (!serverError) {
-            	// process further when data after HTTP headers left in buffer
-                res = mFrameBuffer.position() > 0;
-
-                mState = STATE_OPEN;
-            } else {
-            	res = true;
-            	mState = STATE_CLOSED;
-            	mStopped = true;
-            }
-            
-            onHandshake(!serverError);
-            break;
-         }
-      }
-      return res;
-   }
-   
-   @SuppressWarnings("unused")
-   private Map<String, String> parseHttpHeaders(byte[] buffer) throws UnsupportedEncodingException {
-	   // TODO: use utf-8 validator?
-	   String s = new String(buffer, "UTF-8");
-	   Map<String, String> headers = new HashMap<String, String>();
-	   
-	   String[] lines = s.split("\r\n");
-	   for (String line : lines) {
-		   if (line.length() > 0) {
-			   String[] h = line.split(": ");
-			   if (h.length == 2) {
-				   headers.put(h[0], h[1]);
-				   Log.w(TAG, String.format("'%s'='%s'", h[0], h[1]));
-			   }
-		   }
-	   }
-	   
-	   return headers;
-   }
-   
-   private Pair<Integer, String> parseHttpStatus() throws UnsupportedEncodingException {
-	   int beg, end;
+			} else {
+
+				// need more data
+				return false;
+			}
+		}
+	}
+
+
+	/**
+	 * WebSockets handshake reply from server received, default notifies master.
+	 * 
+	 * @param success	Success handshake flag
+	 */
+	protected void onHandshake(boolean success) {
+
+		notify(new WebSocketMessage.ServerHandshake(success));
+	}
+
+
+	/**
+	 * WebSockets close received, default notifies master.
+	 */
+	protected void onClose(int code, String reason) {
+
+		notify(new WebSocketMessage.Close(code, reason));
+	}
+
+
+	/**
+	 * WebSockets ping received, default notifies master.
+	 *
+	 * @param payload    Ping payload or null.
+	 */
+	protected void onPing(byte[] payload) {
+
+		notify(new WebSocketMessage.Ping(payload));
+	}
+
+
+	/**
+	 * WebSockets pong received, default notifies master.
+	 *
+	 * @param payload    Pong payload or null.
+	 */
+	protected void onPong(byte[] payload) {
+
+		notify(new WebSocketMessage.Pong(payload));
+	}
+
+
+	/**
+	 * WebSockets text message received, default notifies master.
+	 * This will only be called when the option receiveTextMessagesRaw
+	 * HAS NOT been set.
+	 *
+	 * @param payload    Text message payload as Java String decoded
+	 *                   from raw UTF-8 payload or null (empty payload).
+	 */
+	protected void onTextMessage(String payload) {
+
+		notify(new WebSocketMessage.TextMessage(payload));
+	}
+
+
+	/**
+	 * WebSockets text message received, default notifies master.
+	 * This will only be called when the option receiveTextMessagesRaw
+	 * HAS been set.
+	 *
+	 * @param payload    Text message payload as raw UTF-8 octets or
+	 *                   null (empty payload).
+	 */
+	protected void onRawTextMessage(byte[] payload) {
+
+		notify(new WebSocketMessage.RawTextMessage(payload));
+	}
+
+
+	/**
+	 * WebSockets binary message received, default notifies master.
+	 *
+	 * @param payload    Binary message payload or null (empty payload).
+	 */
+	protected void onBinaryMessage(byte[] payload) {
+
+		notify(new WebSocketMessage.BinaryMessage(payload));
+	}
+
+
+	/**
+	 * Process WebSockets handshake received from server.
+	 */
+	private boolean processHandshake() throws UnsupportedEncodingException {
+
+		boolean res = false;
+		for (int pos = mApplicationBuffer.position() - 4; pos >= 0; --pos) {
+			if (mApplicationBuffer.get(pos+0) == 0x0d &&
+					mApplicationBuffer.get(pos+1) == 0x0a &&
+					mApplicationBuffer.get(pos+2) == 0x0d &&
+					mApplicationBuffer.get(pos+3) == 0x0a) {
+
+				/// \todo process & verify handshake from server
+				/// \todo forward subprotocol, if any
+
+				int oldPosition = mApplicationBuffer.position();
+
+				// Check HTTP status code
+				boolean serverError = false;
+				if (mApplicationBuffer.get(0) == 'H' &&
+						mApplicationBuffer.get(1) == 'T' &&
+						mApplicationBuffer.get(2) == 'T' &&
+						mApplicationBuffer.get(3) == 'P') {
+
+					Pair<Integer, String> status = parseHTTPStatus();
+					if (status.first >= 300) {
+						// Invalid status code for success connection
+						notify(new WebSocketMessage.ServerError(status.first, status.second));
+						serverError = true;
+					}
+				}
+
+				mApplicationBuffer.position(pos + 4);
+				mApplicationBuffer.limit(oldPosition);
+				mApplicationBuffer.compact();
+
+				if (!serverError) {
+					// process further when data after HTTP headers left in buffer
+					res = mApplicationBuffer.position() > 0;
+
+					mState = ReaderState.STATE_OPEN;
+				} else {
+					res = true;
+					mState = ReaderState.STATE_CLOSED;
+					mStopped = true;
+				}
+
+				onHandshake(!serverError);
+				break;
+			}
+		}
+		return res;
+	}
+
+	private Pair<Integer, String> parseHTTPStatus() throws UnsupportedEncodingException {
+		int beg, end;
 		// Find first space
-		for (beg = 4; beg < mFrameBuffer.position(); ++beg) {
-			if (mFrameBuffer.get(beg) == ' ') break;
+		for (beg = 4; beg < mApplicationBuffer.position(); ++beg) {
+			if (mApplicationBuffer.get(beg) == ' ') break;
 		}
 		// Find second space
-		for (end = beg + 1; end < mFrameBuffer.position(); ++end) {
-			if (mFrameBuffer.get(end) == ' ') break;
+		for (end = beg + 1; end < mApplicationBuffer.position(); ++end) {
+			if (mApplicationBuffer.get(end) == ' ') break;
 		}
 		// Parse status code between them
 		++beg;
 		int statusCode = 0;
 		for (int i = 0; beg + i < end; ++i) {
-			int digit = (mFrameBuffer.get(beg + i) - 0x30);
+			int digit = (mApplicationBuffer.get(beg + i) - 0x30);
 			statusCode *= 10;
 			statusCode += digit;
 		}
 		// Find end of line to extract error message
 		++end;
 		int eol;
-		for (eol = end; eol < mFrameBuffer.position(); ++eol) {
-			if (mFrameBuffer.get(eol) == 0x0d) break;
+		for (eol = end; eol < mApplicationBuffer.position(); ++eol) {
+			if (mApplicationBuffer.get(eol) == 0x0d) break;
 		}
 		int statusMessageLength = eol - end;
 		byte[] statusBuf = new byte[statusMessageLength];
-		mFrameBuffer.position(end);
-		mFrameBuffer.get(statusBuf, 0, statusMessageLength);
-		String statusMessage = new String(statusBuf, "UTF-8");
-		if (DEBUG) Log.w(TAG, String.format("Status: %d (%s)", statusCode, statusMessage));
+		mApplicationBuffer.position(end);
+		mApplicationBuffer.get(statusBuf, 0, statusMessageLength);
+		String statusMessage = new String(statusBuf, WebSocket.UTF8_ENCODING);
+		Log.w(TAG, String.format("Status: %d (%s)", statusCode, statusMessage));
 		return new Pair<Integer, String>(statusCode, statusMessage);
-   }
-
-
-   /**
-    * Consume data buffered in mFrameBuffer.
-    */
-   private boolean consumeData() throws Exception {
-
-      if (mState == STATE_OPEN || mState == STATE_CLOSING) {
-
-         return processData();
-
-      } else if (mState == STATE_CONNECTING) {
-
-         return processHandshake();
-
-      } else if (mState == STATE_CLOSED) {
-
-         return false;
-
-      } else {
-         // should not arrive here
-         return false;
-      }
-
-   }
-
-
-   /**
-    * Run the background reader thread loop.
-    */
-   @Override
-   public void run() {
-
-      if (DEBUG) Log.d(TAG, "running");
-
-      try {
-
-         mFrameBuffer.clear();
-         do {
-            // blocking read on socket
-            int len = mSocket.read(mFrameBuffer);
-            if (len > 0) {
-               // process buffered data
-               while (consumeData()) {
-               }
-            } else if (len < 0) {
-
-               if (DEBUG) Log.d(TAG, "run() : ConnectionLost");
-
-               notify(new WebSocketMessage.ConnectionLost());
-               mStopped = true;
-            }
-         } while (!mStopped);
-
-      } catch (WebSocketException e) {
-
-         if (DEBUG) Log.d(TAG, "run() : WebSocketException (" + e.toString() + ")");
-
-         // wrap the exception and notify master
-         notify(new WebSocketMessage.ProtocolViolation(e));
-
-      } catch (SocketException e) {
-    	  
-    	  if (DEBUG) Log.d(TAG, "run() : SocketException (" + e.toString() + ")");
-    	  
-    	  // wrap the exception and notify master
-    	  notify(new WebSocketMessage.ConnectionLost());;
-    	  
-      } catch (Exception e) {
+	}
+
+
+	/**
+	 * Consume data buffered in mFrameBuffer.
+	 */
+	private boolean consumeData() throws Exception {
+		switch (mState) {
+		case STATE_OPEN:
+		case STATE_CLOSING:
+			return processData();
+		case STATE_CLOSED:
+			return false;
+		case STATE_CONNECTING:
+			return processHandshake();
+		default:
+			return false;
+		}
+	}
 
-         if (DEBUG) Log.d(TAG, "run() : Exception (" + e.toString() + ")");
 
-         // wrap the exception and notify master
-         notify(new WebSocketMessage.Error(e));
+	/**
+	 * Run the background reader thread loop.
+	 */
+	@Override
+	public void run() {		
+		synchronized (this) {
+			notifyAll();
+		}
+		
+		InputStream inputStream = null;
+		try {
+			inputStream = mSocket.getInputStream();
+		} catch (IOException e) {
+			Log.e(TAG, e.getLocalizedMessage());
+			return;
+		}
 
-      } finally {
+		this.mInputStream = inputStream;
+
+		Log.d(TAG, "WebSocker reader running.");
+		mApplicationBuffer.clear();
+
+		while (!mStopped) {
+			try {
+
+				int bytesRead = mInputStream.read(mNetworkBuffer);
+				if (bytesRead > 0) {
+					mApplicationBuffer.put(mNetworkBuffer, 0, bytesRead);
+					while (consumeData()) {
+					}
+				} else if (bytesRead == -1) {
+					Log.d(TAG, "run() : ConnectionLost");
+
+					notify(new WebSocketMessage.ConnectionLost());
+					this.mStopped = true;
+				} else {
+					Log.e(TAG, "WebSocketReader read() failed.");
+				}
+				
+			} catch (WebSocketException e) {
+				Log.d(TAG, "run() : WebSocketException (" + e.toString() + ")");
+
+				// wrap the exception and notify master
+				notify(new WebSocketMessage.ProtocolViolation(e));
+			} catch (SocketException e) {
+				Log.d(TAG, "run() : SocketException (" + e.toString() + ")");
+
+				// wrap the exception and notify master
+				notify(new WebSocketMessage.ConnectionLost());
+			} catch (IOException e) {
+				Log.d(TAG, "run() : IOException (" + e.toString() + ")");
+				
+				notify(new WebSocketMessage.ConnectionLost());
+			} catch (Exception e) {
+				Log.d(TAG, "run() : Exception (" + e.toString() + ")");
+
+				// wrap the exception and notify master
+				notify(new WebSocketMessage.Error(e));
+			}
+		}
 
-         mStopped = true;
-      }
 
-      if (DEBUG) Log.d(TAG, "ended");
-   }
+		Log.d(TAG, "WebSocket reader ended.");
+	}
 }
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java b/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java
index 35cded5..bdd6707 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java
@@ -19,11 +19,13 @@
 package de.tavendo.autobahn;
 
 import java.io.IOException;
+import java.io.OutputStream;
+import java.lang.ref.WeakReference;
+import java.net.Socket;
 import java.net.SocketException;
-import java.nio.channels.SocketChannel;
+import java.nio.ByteBuffer;
 import java.util.Random;
 
-import org.apache.http.NameValuePair;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
@@ -38,448 +40,423 @@
  * background thread) so that it can be formatted and sent out on the
  * underlying TCP socket.
  */
-public class WebSocketWriter extends Handler {
-
-   private static final boolean DEBUG = true;
-   private static final String TAG = WebSocketWriter.class.getName();
-
-   /// Random number generator for handshake key and frame mask generation.
-   private final Random mRng = new Random();
-
-   /// Connection master.
-   private final Handler mMaster;
-
-   /// Message looper this object is running on.
-   private final Looper mLooper;
-
-   /// The NIO socket channel created on foreground thread.
-   private final SocketChannel mSocket;
-
-   /// WebSockets options.
-   private final WebSocketOptions mOptions;
-
-   /// The send buffer that holds data to send on socket.
-   private final ByteBufferOutputStream mBuffer;
-
-
-   /**
-    * Create new WebSockets background writer.
-    *
-    * @param looper    The message looper of the background thread on which
-    *                  this object is running.
-    * @param master    The message handler of master (foreground thread).
-    * @param socket    The socket channel created on foreground thread.
-    * @param options   WebSockets connection options.
-    */
-   public WebSocketWriter(Looper looper, Handler master, SocketChannel socket, WebSocketOptions options) {
-
-      super(looper);
-
-      mLooper = looper;
-      mMaster = master;
-      mSocket = socket;
-      mOptions = options;
-      mBuffer = new ByteBufferOutputStream(options.getMaxFramePayloadSize() + 14, 4*64*1024);
-
-      if (DEBUG) Log.d(TAG, "created");
-   }
-
-
-   /**
-    * Call this from the foreground (UI) thread to make the writer
-    * (running on background thread) send a WebSocket message on the
-    * underlying TCP.
-    *
-    * @param message       Message to send to WebSockets writer. An instance of the message
-    *                      classes inside WebSocketMessage or another type which then needs
-    *                      to be handled within processAppMessage() (in a class derived from
-    *                      this class).
-    */
-   public void forward(Object message) {
-
-      Message msg = obtainMessage();
-      msg.obj = message;
-      sendMessage(msg);
-   }
-
-
-   /**
-    * Notify the master (foreground thread).
-    *
-    * @param message       Message to send to master.
-    */
-   private void notify(Object message) {
-
-      Message msg = mMaster.obtainMessage();
-      msg.obj = message;
-      mMaster.sendMessage(msg);
-   }
-
-
-   /**
-    * Create new key for WebSockets handshake.
-    *
-    * @return WebSockets handshake key (Base64 encoded).
-    */
-   private String newHandshakeKey() {
-      final byte[] ba = new byte[16];
-      mRng.nextBytes(ba);
-      return Base64.encodeToString(ba, Base64.NO_WRAP);
-   }
-
-
-   /**
-    * Create new (random) frame mask.
-    *
-    * @return Frame mask (4 octets).
-    */
-   private byte[] newFrameMask() {
-      final byte[] ba = new byte[4];
-      mRng.nextBytes(ba);
-      return ba;
-   }
-
-
-   /**
-    * Send WebSocket client handshake.
-    */
-   private void sendClientHandshake(WebSocketMessage.ClientHandshake message) throws IOException {
-
-      // write HTTP header with handshake
-      String path;
-      if (message.mQuery != null) {
-         path = message.mPath + "?" + message.mQuery;
-      } else {
-         path = message.mPath;
-      }
-      mBuffer.write("GET " + path + " HTTP/1.1");
-      mBuffer.crlf();
-      mBuffer.write("Host: " + message.mHost);
-      mBuffer.crlf();
-      mBuffer.write("Upgrade: WebSocket");
-      mBuffer.crlf();
-      mBuffer.write("Connection: Upgrade");
-      mBuffer.crlf();
-
-      mBuffer.write("Sec-WebSocket-Key: " + newHandshakeKey());
-      mBuffer.crlf();
-
-      if (message.mOrigin != null && !message.mOrigin.equals("")) {
-         mBuffer.write("Origin: " + message.mOrigin);
-         mBuffer.crlf();
-      }
-
-      if (message.mSubprotocols != null && message.mSubprotocols.length > 0) {
-         mBuffer.write("Sec-WebSocket-Protocol: ");
-         for (int i = 0; i < message.mSubprotocols.length; ++i) {
-            mBuffer.write(message.mSubprotocols[i]);
-            if (i != message.mSubprotocols.length-1) {
-               mBuffer.write(", ");
-            }
-         }
-         mBuffer.crlf();
-      }
-
-      mBuffer.write("Sec-WebSocket-Version: 13");
-      mBuffer.crlf();
-
-      // Header injection      
-      if (message.mHeaderList != null) {
-          for (NameValuePair pair : message.mHeaderList) {
-        	  mBuffer.write( pair.getName() + ":" + pair.getValue() );
-        	  mBuffer.crlf();
-          }
-      }           
-      mBuffer.crlf();
-   }
-
-
-   /**
-    * Send WebSockets close.
-    */
-   private void sendClose(WebSocketMessage.Close message) throws IOException, WebSocketException {
-
-      if (message.mCode > 0) {
-
-         byte[] payload = null;
-
-         if (message.mReason != null && !message.mReason.equals("")) {
-            byte[] pReason = message.mReason.getBytes("UTF-8");
-            payload = new byte[2 + pReason.length];
-            for (int i = 0; i < pReason.length; ++i) {
-               payload[i + 2] = pReason[i];
-            }
-         } else {
-            payload = new byte[2];
-         }
-
-         if (payload != null && payload.length > 125) {
-            throw new WebSocketException("close payload exceeds 125 octets");
-         }
-
-         payload[0] = (byte)((message.mCode >> 8) & 0xff);
-         payload[1] = (byte)(message.mCode & 0xff);
-
-         sendFrame(8, true, payload);
-
-      } else {
-
-         sendFrame(8, true, null);
-      }
-   }
-
-
-   /**
-    * Send WebSockets ping.
-    */
-   private void sendPing(WebSocketMessage.Ping message) throws IOException, WebSocketException {
-      if (message.mPayload != null && message.mPayload.length > 125) {
-         throw new WebSocketException("ping payload exceeds 125 octets");
-      }
-      sendFrame(9, true, message.mPayload);
-   }
-
-
-   /**
-    * Send WebSockets pong. Normally, unsolicited Pongs are not used,
-    * but Pongs are only send in response to a Ping from the peer.
-    */
-   private void sendPong(WebSocketMessage.Pong message) throws IOException, WebSocketException {
-      if (message.mPayload != null && message.mPayload.length > 125) {
-         throw new WebSocketException("pong payload exceeds 125 octets");
-      }
-      sendFrame(10, true, message.mPayload);
-   }
-
-
-   /**
-    * Send WebSockets binary message.
-    */
-   private void sendBinaryMessage(WebSocketMessage.BinaryMessage message) throws IOException, WebSocketException {
-      if (message.mPayload.length > mOptions.getMaxMessagePayloadSize()) {
-         throw new WebSocketException("message payload exceeds payload limit");
-      }
-      sendFrame(2, true, message.mPayload);
-   }
-
-
-   /**
-    * Send WebSockets text message.
-    */
-   private void sendTextMessage(WebSocketMessage.TextMessage message) throws IOException, WebSocketException {
-      byte[] payload = message.mPayload.getBytes("UTF-8");
-      if (payload.length > mOptions.getMaxMessagePayloadSize()) {
-         throw new WebSocketException("message payload exceeds payload limit");
-      }
-      sendFrame(1, true, payload);
-   }
-
-
-   /**
-    * Send WebSockets binary message.
-    */
-   private void sendRawTextMessage(WebSocketMessage.RawTextMessage message) throws IOException, WebSocketException {
-      if (message.mPayload.length > mOptions.getMaxMessagePayloadSize()) {
-         throw new WebSocketException("message payload exceeds payload limit");
-      }
-      sendFrame(1, true, message.mPayload);
-   }
-
-
-   /**
-    * Sends a WebSockets frame. Only need to use this method in derived classes which implement
-    * more message types in processAppMessage(). You need to know what you are doing!
-    *
-    * @param opcode     The WebSocket frame opcode.
-    * @param fin        FIN flag for WebSocket frame.
-    * @param payload    Frame payload or null.
-    */
-   protected void sendFrame(int opcode, boolean fin, byte[] payload) throws IOException {
-      if (payload != null) {
-         sendFrame(opcode, fin, payload, 0, payload.length);
-      } else {
-         sendFrame(opcode, fin, null, 0, 0);
-      }
-   }
-
-
-   /**
-    * Sends a WebSockets frame. Only need to use this method in derived classes which implement
-    * more message types in processAppMessage(). You need to know what you are doing!
-    *
-    * @param opcode     The WebSocket frame opcode.
-    * @param fin        FIN flag for WebSocket frame.
-    * @param payload    Frame payload or null.
-    * @param offset     Offset within payload of the chunk to send.
-    * @param length     Length of the chunk within payload to send.
-    */
-   protected void sendFrame(int opcode, boolean fin, byte[] payload, int offset, int length) throws IOException {
-
-      // first octet
-      byte b0 = 0;
-      if (fin) {
-         b0 |= (byte) (1 << 7);
-      }
-      b0 |= (byte) opcode;
-      mBuffer.write(b0);
-
-      // second octet
-      byte b1 = 0;
-      if (mOptions.getMaskClientFrames()) {
-         b1 = (byte) (1 << 7);
-      }
-
-      long len = length;
-
-      // extended payload length
-      if (len <= 125) {
-         b1 |= (byte) len;
-         mBuffer.write(b1);
-      } else if (len <= 0xffff) {
-         b1 |= (byte) (126 & 0xff);
-         mBuffer.write(b1);
-         mBuffer.write(new byte[] {(byte)((len >> 8) & 0xff),
-                                   (byte)(len & 0xff)});
-      } else {
-         b1 |= (byte) (127 & 0xff);
-         mBuffer.write(b1);
-         mBuffer.write(new byte[] {(byte)((len >> 56) & 0xff),
-                                   (byte)((len >> 48) & 0xff),
-                                   (byte)((len >> 40) & 0xff),
-                                   (byte)((len >> 32) & 0xff),
-                                   (byte)((len >> 24) & 0xff),
-                                   (byte)((len >> 16) & 0xff),
-                                   (byte)((len >> 8)  & 0xff),
-                                   (byte)(len         & 0xff)});
-      }
-
-      byte mask[] = null;
-      if (mOptions.getMaskClientFrames()) {
-         // a mask is always needed, even without payload
-         mask = newFrameMask();
-         mBuffer.write(mask[0]);
-         mBuffer.write(mask[1]);
-         mBuffer.write(mask[2]);
-         mBuffer.write(mask[3]);
-      }
-
-      if (len > 0) {
-         if (mOptions.getMaskClientFrames()) {
-            /// \todo optimize masking
-            /// \todo masking within buffer of output stream
-            for (int i = 0; i < len; ++i) {
-               payload[i + offset] ^= mask[i % 4];
-            }
-         }
-         mBuffer.write(payload, offset, length);
-      }
-   }
-
-
-   /**
-    * Process message received from foreground thread. This is called from
-    * the message looper set up for the background thread running this writer.
-    *
-    * @param msg     Message from thread message queue.
-    */
-   @Override
-   public void handleMessage(Message msg) {
-
-      try {
-
-         // clear send buffer
-         mBuffer.clear();
-
-         // process message from master
-         processMessage(msg.obj);
-
-         // send out buffered data
-         mBuffer.flip();
-         while (mBuffer.remaining() > 0) {
-            // this can block on socket write
-            @SuppressWarnings("unused")
-            int written = mSocket.write(mBuffer.getBuffer());
-         }
-
-      } catch (SocketException e) {
-    	  
-    	  if (DEBUG) Log.d(TAG, "run() : SocketException (" + e.toString() + ")");
-    	  
-    	  // wrap the exception and notify master
-    	  notify(new WebSocketMessage.ConnectionLost());
-      } catch (Exception e) {
-
-         if (DEBUG) e.printStackTrace();
-
-         // wrap the exception and notify master
-         notify(new WebSocketMessage.Error(e));
-      }
-   }
-
-
-   /**
-    * Process WebSockets or control message from master. Normally,
-    * there should be no reason to override this. If you do, you
-    * need to know what you are doing.
-    *
-    * @param msg     An instance of the message types within WebSocketMessage
-    *                or a message that is handled in processAppMessage().
-    */
-   protected void processMessage(Object msg) throws IOException, WebSocketException {
-
-      if (msg instanceof WebSocketMessage.TextMessage) {
-
-         sendTextMessage((WebSocketMessage.TextMessage) msg);
-
-      } else if (msg instanceof WebSocketMessage.RawTextMessage) {
-
-         sendRawTextMessage((WebSocketMessage.RawTextMessage) msg);
-
-      } else if (msg instanceof WebSocketMessage.BinaryMessage) {
-
-         sendBinaryMessage((WebSocketMessage.BinaryMessage) msg);
-
-      } else if (msg instanceof WebSocketMessage.Ping) {
-
-         sendPing((WebSocketMessage.Ping) msg);
-
-      } else if (msg instanceof WebSocketMessage.Pong) {
-
-         sendPong((WebSocketMessage.Pong) msg);
-
-      } else if (msg instanceof WebSocketMessage.Close) {
-
-         sendClose((WebSocketMessage.Close) msg);
-
-      } else if (msg instanceof WebSocketMessage.ClientHandshake) {
-
-         sendClientHandshake((WebSocketMessage.ClientHandshake) msg);
-
-      } else if (msg instanceof WebSocketMessage.Quit) {
-
-         mLooper.quit();
-
-         if  (DEBUG) Log.d(TAG, "ended");
-
-         return;
-
-      } else {
-
-         // call hook which may be overridden in derived class to process
-         // messages we don't understand in this class
-         processAppMessage(msg);
-      }
-   }
-
-
-   /**
-    * Process message other than plain WebSockets or control message.
-    * This is intended to be overridden in derived classes.
-    *
-    * @param msg      Message from foreground thread to process.
-    */
-   protected void processAppMessage(Object msg) throws WebSocketException, IOException {
-
-      throw new WebSocketException("unknown message received by WebSocketWriter");
-   }
+public class WebSocketWriter extends Thread {
+	private static final String TAG = WebSocketWriter.class.getCanonicalName();
+	
+	private static final int WEB_SOCKETS_VERSION = 13;
+	private static final String CRLF = "\r\n";
+
+	private final Random mRandom = new Random();
+	private final Handler mWebSocketConnectionHandler;
+	private final WebSocketOptions mWebSocketOptions;
+	private final ByteBuffer mApplicationBuffer;
+	private final Socket mSocket;
+
+	private OutputStream mOutputStream;
+
+	private Handler mHandler;
+
+
+	/**
+	 * Create new WebSockets background writer.
+	 *
+	 * @param looper    The message looper of the background thread on which
+	 *                  this object is running.
+	 * @param master    The message handler of master (foreground thread).
+	 * @param socket    The socket channel created on foreground thread.
+	 * @param options   WebSockets connection options.
+	 */
+	public WebSocketWriter(Handler master, Socket socket, WebSocketOptions options, String threadName) {
+		super(threadName);
+
+		this.mWebSocketConnectionHandler = master;
+		this.mWebSocketOptions = options;
+		this.mSocket = socket;
+		
+		this.mApplicationBuffer = ByteBuffer.allocate(options.getMaxFramePayloadSize() + 14);
+
+		Log.d(TAG, "WebSocket writer created.");
+	}
+
+
+	/**
+	 * Call this from the foreground (UI) thread to make the writer
+	 * (running on background thread) send a WebSocket message on the
+	 * underlying TCP.
+	 *
+	 * @param message       Message to send to WebSockets writer. An instance of the message
+	 *                      classes inside WebSocketMessage or another type which then needs
+	 *                      to be handled within processAppMessage() (in a class derived from
+	 *                      this class).
+	 */
+	public void forward(Object message) {
+		Message msg = mHandler.obtainMessage();
+		msg.obj = message;
+		mHandler.sendMessage(msg);
+	}
+
+
+	/**
+	 * Notify the master (foreground thread).
+	 *
+	 * @param message       Message to send to master.
+	 */
+	private void notify(Object message) {
+		Message msg = mWebSocketConnectionHandler.obtainMessage();
+		msg.obj = message;
+		mWebSocketConnectionHandler.sendMessage(msg);
+	}
+
+
+	/**
+	 * Create new key for WebSockets handshake.
+	 *
+	 * @return WebSockets handshake key (Base64 encoded).
+	 */
+	private String newHandshakeKey() {
+		final byte[] ba = new byte[16];
+		mRandom.nextBytes(ba);
+		return Base64.encodeToString(ba, Base64.NO_WRAP);
+	}
+
+
+	/**
+	 * Create new (random) frame mask.
+	 *
+	 * @return Frame mask (4 octets).
+	 */
+	private byte[] newFrameMask() {
+		final byte[] ba = new byte[4];
+		mRandom.nextBytes(ba);
+		return ba;
+	}
+
+
+	/**
+	 * Send WebSocket client handshake.
+	 */
+	private void sendClientHandshake(WebSocketMessage.ClientHandshake message) throws IOException {
+		String path = message.getURI().getPath();
+		if (path == null || path.length() == 0) {
+			path = "/";
+		}
+
+        String query = message.getURI().getQuery();
+        if (query != null && query.length() > 0) {
+    		path = path + "?" + query;
+    	}
+
+        mApplicationBuffer.put(("GET " + path + " HTTP/1.1" + CRLF).getBytes());
+		mApplicationBuffer.put(("Host: " + message.getURI().getHost() + CRLF).getBytes());
+		mApplicationBuffer.put(("Upgrade: WebSocket" + CRLF).getBytes());
+		mApplicationBuffer.put(("Connection: Upgrade" + CRLF).getBytes());
+		mApplicationBuffer.put(("Sec-WebSocket-Key: " + newHandshakeKey() + CRLF).getBytes());
+
+		if (message.getOrigin() != null) {
+			mApplicationBuffer.put(("Origin: " + message.getOrigin().toString() + CRLF).getBytes());
+		}
+
+		if (message.getSubprotocols() != null && message.getSubprotocols().length > 0) {
+			mApplicationBuffer.put(("Sec-WebSocket-Protocol: ").getBytes());
+			for (int i = 0; i < message.getSubprotocols().length; ++i) {
+				mApplicationBuffer.put((message.getSubprotocols()[i]).getBytes());
+				mApplicationBuffer.put((", ").getBytes());
+			}
+			mApplicationBuffer.put((CRLF).getBytes());
+		}
+
+		mApplicationBuffer.put(("Sec-WebSocket-Version: " + WEB_SOCKETS_VERSION + CRLF).getBytes());
+		mApplicationBuffer.put((CRLF).getBytes());
+	}
+
+
+	/**
+	 * Send WebSockets close.
+	 */
+	private void sendClose(WebSocketMessage.Close message) throws IOException, WebSocketException {
+		if (message.getCode() > 0) {
+			byte[] payload = null;
+
+			if (message.getReason() != null && !(message.getReason().length() > 0)) {
+				byte[] pReason = message.getReason().getBytes(WebSocket.UTF8_ENCODING);
+				payload = new byte[2 + pReason.length];
+				for (int i = 0; i < pReason.length; ++i) {
+					payload[i + 2] = pReason[i];
+				}
+			} else {
+				payload = new byte[2];
+			}
+
+			if (payload != null && payload.length > 125) {
+				throw new WebSocketException("close payload exceeds 125 octets");
+			}
+
+			payload[0] = (byte)((message.getCode() >> 8) & 0xff);
+			payload[1] = (byte)(message.getCode() & 0xff);
+
+			sendFrame(8, true, payload);
+		} else {
+			sendFrame(8, true, null);
+		}
+	}
+
+
+	/**
+	 * Send WebSockets ping.
+	 */
+	private void sendPing(WebSocketMessage.Ping message) throws IOException, WebSocketException {
+		if (message.mPayload != null && message.mPayload.length > 125) {
+			throw new WebSocketException("ping payload exceeds 125 octets");
+		}
+		sendFrame(9, true, message.mPayload);
+	}
+
+
+	/**
+	 * Send WebSockets pong. Normally, unsolicited Pongs are not used,
+	 * but Pongs are only send in response to a Ping from the peer.
+	 */
+	private void sendPong(WebSocketMessage.Pong message) throws IOException, WebSocketException {
+		if (message.mPayload != null && message.mPayload.length > 125) {
+			throw new WebSocketException("pong payload exceeds 125 octets");
+		}
+		sendFrame(10, true, message.mPayload);
+	}
+
+
+	/**
+	 * Send WebSockets binary message.
+	 */
+	private void sendBinaryMessage(WebSocketMessage.BinaryMessage message) throws IOException, WebSocketException {
+		if (message.mPayload.length > mWebSocketOptions.getMaxMessagePayloadSize()) {
+			throw new WebSocketException("message payload exceeds payload limit");
+		}
+		sendFrame(2, true, message.mPayload);
+	}
+
+
+	/**
+	 * Send WebSockets text message.
+	 */
+	private void sendTextMessage(WebSocketMessage.TextMessage message) throws IOException, WebSocketException {
+		byte[] payload = message.mPayload.getBytes(WebSocket.UTF8_ENCODING);
+		if (payload.length > mWebSocketOptions.getMaxMessagePayloadSize()) {
+			throw new WebSocketException("message payload exceeds payload limit");
+		}
+		sendFrame(1, true, payload);
+	}
+
+
+	/**
+	 * Send WebSockets binary message.
+	 */
+	private void sendRawTextMessage(WebSocketMessage.RawTextMessage message) throws IOException, WebSocketException {
+		if (message.mPayload.length > mWebSocketOptions.getMaxMessagePayloadSize()) {
+			throw new WebSocketException("message payload exceeds payload limit");
+		}
+		sendFrame(1, true, message.mPayload);
+	}
+
+
+	/**
+	 * Sends a WebSockets frame. Only need to use this method in derived classes which implement
+	 * more message types in processAppMessage(). You need to know what you are doing!
+	 *
+	 * @param opcode     The WebSocket frame opcode.
+	 * @param fin        FIN flag for WebSocket frame.
+	 * @param payload    Frame payload or null.
+	 */
+	protected void sendFrame(int opcode, boolean fin, byte[] payload) throws IOException {
+		if (payload != null) {
+			sendFrame(opcode, fin, payload, 0, payload.length);
+		} else {
+			sendFrame(opcode, fin, null, 0, 0);
+		}
+	}
+
+
+	/**
+	 * Sends a WebSockets frame. Only need to use this method in derived classes which implement
+	 * more message types in processAppMessage(). You need to know what you are doing!
+	 *
+	 * @param opcode     The WebSocket frame opcode.
+	 * @param fin        FIN flag for WebSocket frame.
+	 * @param payload    Frame payload or null.
+	 * @param offset     Offset within payload of the chunk to send.
+	 * @param length     Length of the chunk within payload to send.
+	 */
+	protected void sendFrame(int opcode, boolean fin, byte[] payload, int offset, int length) throws IOException {
+		// first octet
+		byte b0 = 0;
+		if (fin) {
+			b0 |= (byte) (1 << 7);
+		}
+		b0 |= (byte) opcode;
+		mApplicationBuffer.put(b0);
+
+		// second octet
+		byte b1 = 0;
+		if (mWebSocketOptions.getMaskClientFrames()) {
+			b1 = (byte) (1 << 7);
+		}
+
+		long len = length;
+
+		// extended payload length
+		if (len <= 125) {
+			b1 |= (byte) len;
+			mApplicationBuffer.put(b1);
+		} else if (len <= 0xffff) {
+			b1 |= (byte) (126 & 0xff);
+			mApplicationBuffer.put(b1);
+			mApplicationBuffer.put(new byte[] {(byte)((len >> 8) & 0xff), (byte)(len & 0xff)});
+		} else {
+			b1 |= (byte) (127 & 0xff);
+			mApplicationBuffer.put(b1);
+			mApplicationBuffer.put(new byte[] {(byte)((len >> 56) & 0xff),
+					(byte)((len >> 48) & 0xff),
+					(byte)((len >> 40) & 0xff),
+					(byte)((len >> 32) & 0xff),
+					(byte)((len >> 24) & 0xff),
+					(byte)((len >> 16) & 0xff),
+					(byte)((len >> 8)  & 0xff),
+					(byte)(len         & 0xff)});
+		}
+
+		byte mask[] = null;
+		if (mWebSocketOptions.getMaskClientFrames()) {
+			// a mask is always needed, even without payload
+			mask = newFrameMask();
+			mApplicationBuffer.put(mask[0]);
+			mApplicationBuffer.put(mask[1]);
+			mApplicationBuffer.put(mask[2]);
+			mApplicationBuffer.put(mask[3]);
+		}
+
+		if (len > 0) {
+			if (mWebSocketOptions.getMaskClientFrames()) {
+				/// \todo optimize masking
+				/// \todo masking within buffer of output stream
+				for (int i = 0; i < len; ++i) {
+					payload[i + offset] ^= mask[i % 4];
+				}
+			}
+			mApplicationBuffer.put(payload, offset, length);
+		}
+	}
+
+	/**
+	 * Process WebSockets or control message from master. Normally,
+	 * there should be no reason to override this. If you do, you
+	 * need to know what you are doing.
+	 *
+	 * @param msg     An instance of the message types within WebSocketMessage
+	 *                or a message that is handled in processAppMessage().
+	 */
+	protected void processMessage(Object msg) throws IOException, WebSocketException {
+
+		if (msg instanceof WebSocketMessage.TextMessage) {
+			sendTextMessage((WebSocketMessage.TextMessage) msg);
+		} else if (msg instanceof WebSocketMessage.RawTextMessage) {
+			sendRawTextMessage((WebSocketMessage.RawTextMessage) msg);
+		} else if (msg instanceof WebSocketMessage.BinaryMessage) {
+			sendBinaryMessage((WebSocketMessage.BinaryMessage) msg);
+		} else if (msg instanceof WebSocketMessage.Ping) {
+			sendPing((WebSocketMessage.Ping) msg);
+		} else if (msg instanceof WebSocketMessage.Pong) {
+			sendPong((WebSocketMessage.Pong) msg);
+		} else if (msg instanceof WebSocketMessage.Close) {
+			sendClose((WebSocketMessage.Close) msg);
+		} else if (msg instanceof WebSocketMessage.ClientHandshake) {
+			sendClientHandshake((WebSocketMessage.ClientHandshake) msg);
+		} else if (msg instanceof WebSocketMessage.Quit) {
+			Looper.myLooper().quit();
+
+			Log.d(TAG, "WebSocket writer ended.");
+		} else {
+			processAppMessage(msg);
+		}
+	}
+
+	public void writeMessageToBuffer(Message message) {
+		try {
+			mApplicationBuffer.clear();
+			processMessage(message.obj);
+			mApplicationBuffer.flip();
+
+			mOutputStream.write(mApplicationBuffer.array(), mApplicationBuffer.position(), mApplicationBuffer.limit());
+		} catch (SocketException e) {
+			Log.e(TAG, "run() : SocketException (" + e.toString() + ")");
+
+			notify(new WebSocketMessage.ConnectionLost());
+		} catch (IOException e) {
+			Log.e(TAG, "run() : IOException (" + e.toString() + ")");
+
+		} catch (Exception e) {
+			notify(new WebSocketMessage.Error(e));
+		}
+	}
+
+	/**
+	 * Process message other than plain WebSockets or control message.
+	 * This is intended to be overridden in derived classes.
+	 *
+	 * @param msg      Message from foreground thread to process.
+	 */
+	protected void processAppMessage(Object msg) throws WebSocketException, IOException {
+		throw new WebSocketException("unknown message received by WebSocketWriter");
+	}
+
+
+
+	// Thread method overrides
+	@Override
+	public void run() {	
+		OutputStream outputStream = null;
+		try {
+			outputStream = mSocket.getOutputStream();
+		} catch (IOException e) {
+			Log.e(TAG, e.getLocalizedMessage());
+		}
+		
+		this.mOutputStream = outputStream;
+		
+		Looper.prepare();
+
+		this.mHandler = new ThreadHandler(this);
+
+		synchronized (this) {
+			Log.d(TAG, "WebSocker writer running.");
+
+			notifyAll();
+		}
+
+		Looper.loop();
+	}
+
+
+
+	//
+	// Private handler class
+	private static class ThreadHandler extends Handler {
+		private final WeakReference<WebSocketWriter> mWebSocketWriterReference;
+
+
+
+		public ThreadHandler(WebSocketWriter webSocketWriter) {
+			super();
+
+			this.mWebSocketWriterReference = new WeakReference<WebSocketWriter>(webSocketWriter);
+		}
+
+
+
+		@Override
+		public void handleMessage(Message message) {
+			WebSocketWriter webSocketWriter = mWebSocketWriterReference.get();
+			if (webSocketWriter != null) {
+				webSocketWriter.writeMessageToBuffer(message);
+			}
+		}
+	}
 }
