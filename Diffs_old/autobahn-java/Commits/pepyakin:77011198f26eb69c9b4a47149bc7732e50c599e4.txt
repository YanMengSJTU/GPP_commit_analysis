diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java b/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java
index c67e13c..88648b3 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java
@@ -142,7 +142,7 @@ protected String doInBackground(Void... params) {
          try {
             mTransportChannel = createSocket();
             //mOut = mTransportChannel.getOutputStream();
-            mOut = new BufferedOutputStream(mTransportChannel.getOutputStream(), 1024*128);        
+            mOut = new BufferedOutputStream(mTransportChannel.getOutputStream(), 1024*1024*1 + 14);        
 
             return null;
 
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketReader.java b/Autobahn/src/de/tavendo/autobahn/WebSocketReader.java
index 1969f89..de01fed 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketReader.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketReader.java
@@ -20,7 +20,6 @@
 
 import java.io.UnsupportedEncodingException;
 import java.net.Socket;
-import java.nio.ByteBuffer;
 import java.net.SocketException;
 import java.util.HashMap;
 import java.util.Map;
@@ -45,8 +44,11 @@
    private final Socket mSocket;
    private final WebSocketOptions mOptions;
 
-   private final ByteBuffer mFrameBuffer;
+   //private final ByteBuffer mFrameBuffer;
    private NoCopyByteArrayOutputStream mMessagePayload;
+   
+   private final byte[] mBuffer;
+   private int mBufferLen;
 
    private final static int STATE_CLOSED = 0;
    private final static int STATE_CONNECTING = 1;
@@ -93,8 +95,8 @@ public WebSocketReader(Handler master, Socket socket, WebSocketOptions options,
       mMaster = master;
       mSocket = socket;
       mOptions = options;
-
-      mFrameBuffer = ByteBuffer.allocateDirect(options.getMaxFramePayloadSize() + 14);
+      
+      mBuffer = new byte[options.getMaxFramePayloadSize() + 14];
       mMessagePayload = new NoCopyByteArrayOutputStream(options.getMaxMessagePayloadSize());
 
       mFrameHeader = null;
@@ -138,14 +140,14 @@ private boolean processData() throws Exception {
       if (mFrameHeader == null) {
 
          // need at least 2 bytes from WS frame header to start processing
-         if (mFrameBuffer.position() >= 2) {
+         if (mBufferLen >= 2) {
 
-            byte b0 = mFrameBuffer.get(0);
+            byte b0 = mBuffer[0];
             boolean fin = (b0 & 0x80) != 0;
             int rsv = (b0 & 0x70) >> 4;
             int opcode = b0 & 0x0f;
 
-            byte b1 = mFrameBuffer.get(1);
+            byte b1 = mBuffer[1];
             boolean masked = (b1 & 0x80) != 0;
             int payload_len1 = b1 & 0x7f;
 
@@ -202,29 +204,29 @@ private boolean processData() throws Exception {
             }
 
             // continue when complete frame header is available
-            if (mFrameBuffer.position() >= header_len) {
+            if (mBufferLen >= header_len) {
 
                // determine frame payload length
                int i = 2;
                long payload_len = 0;
                if (payload_len1 == 126) {
-                  payload_len = ((0xff & mFrameBuffer.get(i)) << 8) | (0xff & mFrameBuffer.get(i+1));
+                  payload_len = ((0xff & mBuffer[i]) << 8) | (0xff & mBuffer[i+1]);
                   if (payload_len < 126) {
                      throw new WebSocketException("invalid data frame length (not using minimal length encoding)");
                   }
                   i += 2;
                } else if (payload_len1 == 127) {
-                  if ((0x80 & mFrameBuffer.get(i+0)) != 0) {
+                  if ((0x80 & mBuffer[i+0]) != 0) {
                      throw new WebSocketException("invalid data frame length (> 2^63)");
                   }
-                  payload_len = ((0xff & mFrameBuffer.get(i+0)) << 56) |
-                                ((0xff & mFrameBuffer.get(i+1)) << 48) |
-                                ((0xff & mFrameBuffer.get(i+2)) << 40) |
-                                ((0xff & mFrameBuffer.get(i+3)) << 32) |
-                                ((0xff & mFrameBuffer.get(i+4)) << 24) |
-                                ((0xff & mFrameBuffer.get(i+5)) << 16) |
-                                ((0xff & mFrameBuffer.get(i+6)) <<  8) |
-                                ((0xff & mFrameBuffer.get(i+7))      );
+                  payload_len = ((0xff & mBuffer[i+0]) << 56) |
+                                ((0xff & mBuffer[i+1]) << 48) |
+                                ((0xff & mBuffer[i+2]) << 40) |
+                                ((0xff & mBuffer[i+3]) << 32) |
+                                ((0xff & mBuffer[i+4]) << 24) |
+                                ((0xff & mBuffer[i+5]) << 16) |
+                                ((0xff & mBuffer[i+6]) <<  8) |
+                                ((0xff & mBuffer[i+7])      );
                   if (payload_len < 65536) {
                      throw new WebSocketException("invalid data frame length (not using minimal length encoding)");
                   }
@@ -249,7 +251,7 @@ private boolean processData() throws Exception {
                if (masked) {
                   mFrameHeader.mMask = new byte[4];
                   for (int j = 0; j < 4; ++j) {
-                     mFrameHeader.mMask[i] = (byte) (0xff & mFrameBuffer.get(i + j));
+                     mFrameHeader.mMask[j] = (byte) (0xff & mBuffer[i+j]);
                   }
                   i += 4;
                } else {
@@ -257,7 +259,7 @@ private boolean processData() throws Exception {
                }
 
                // continue processing when payload empty or completely buffered
-               return mFrameHeader.mPayloadLen == 0 || mFrameBuffer.position() >= mFrameHeader.mTotalLen;
+               return mFrameHeader.mPayloadLen == 0 || mBufferLen >= mFrameHeader.mTotalLen;
 
             } else {
 
@@ -277,19 +279,7 @@ private boolean processData() throws Exception {
          // within frame
 
          // see if we buffered complete frame
-         if (mFrameBuffer.position() >= mFrameHeader.mTotalLen) {
-
-            // cut out frame payload
-            byte[] framePayload = null;
-            int oldPosition = mFrameBuffer.position();
-            if (mFrameHeader.mPayloadLen > 0) {
-               framePayload = new byte[mFrameHeader.mPayloadLen];
-               mFrameBuffer.position(mFrameHeader.mHeaderLen);
-               mFrameBuffer.get(framePayload, 0, (int) mFrameHeader.mPayloadLen);
-            }
-            mFrameBuffer.position(mFrameHeader.mTotalLen);
-            mFrameBuffer.limit(oldPosition);
-            mFrameBuffer.compact();
+         if (mBufferLen >= mFrameHeader.mTotalLen) {
 
             if (mFrameHeader.mOpcode > 7) {
                // control frame
@@ -302,7 +292,7 @@ private boolean processData() throws Exception {
                   if (mFrameHeader.mPayloadLen >= 2) {
 
                      // parse and check close code
-                     code = (framePayload[0] & 0xff) * 256 + (framePayload[1] & 0xff);
+                     code = (mBuffer[mFrameHeader.mHeaderLen] & 0xff) * 256 + (mBuffer[mFrameHeader.mHeaderLen + 1] & 0xff);
                      if (code < 1000
                            || (code >= 1000 && code <= 2999 &&
                                code != 1000 && code != 1001 && code != 1002 && code != 1003 && code != 1007 && code != 1008 && code != 1009 && code != 1010 && code != 1011)
@@ -315,7 +305,7 @@ private boolean processData() throws Exception {
                      if (mFrameHeader.mPayloadLen > 2) {
 
                         byte[] ra = new byte[mFrameHeader.mPayloadLen - 2];
-                        System.arraycopy(framePayload, 2, ra, 0, mFrameHeader.mPayloadLen - 2);
+                        System.arraycopy(mBuffer, mFrameHeader.mHeaderLen + 2, ra, 0, mFrameHeader.mPayloadLen - 2);
 
                         Utf8Validator val = new Utf8Validator();
                         val.validate(ra);
@@ -329,10 +319,18 @@ private boolean processData() throws Exception {
                   onClose(code, reason);
 
                } else if (mFrameHeader.mOpcode == 9) {
+                  
+                  byte[] framePayload = new byte[mFrameHeader.mPayloadLen];
+                  System.arraycopy(mBuffer, mFrameHeader.mHeaderLen, framePayload, 0, mFrameHeader.mPayloadLen);
+                  
                   // dispatch WS ping
                   onPing(framePayload);
 
                } else if (mFrameHeader.mOpcode == 10) {
+
+                  byte[] framePayload = new byte[mFrameHeader.mPayloadLen];
+                  System.arraycopy(mBuffer, mFrameHeader.mHeaderLen, framePayload, 0, mFrameHeader.mPayloadLen);
+
                   // dispatch WS pong
                   onPong(framePayload);
 
@@ -354,20 +352,20 @@ private boolean processData() throws Exception {
                   }
                }
 
-               if (framePayload != null) {
+               if (mFrameHeader.mPayloadLen > 0) {
 
                   // immediately bail out on message too large
-                  if (mMessagePayload.size() + framePayload.length > mOptions.getMaxMessagePayloadSize()) {
+                  if (mMessagePayload.size() + mFrameHeader.mPayloadLen > mOptions.getMaxMessagePayloadSize()) {
                      throw new WebSocketException("message payload too large");
                   }
 
                   // validate incoming UTF-8
-                  if (mMessageOpcode == 1 && mOptions.getValidateIncomingUtf8() && !mUtf8Validator.validate(framePayload)) {
+                  if (mMessageOpcode == 1 && mOptions.getValidateIncomingUtf8() && !mUtf8Validator.validate(mBuffer, mFrameHeader.mHeaderLen, mFrameHeader.mPayloadLen)) {
                      throw new WebSocketException("invalid UTF-8 in text message payload");
                   }
 
                   // buffer frame payload for message
-                  mMessagePayload.write(framePayload);
+                  mMessagePayload.write(mBuffer, mFrameHeader.mHeaderLen, mFrameHeader.mPayloadLen);
                }
 
                // on final frame ..
@@ -410,11 +408,18 @@ private boolean processData() throws Exception {
                }
             }
 
+            // remember remaining stuff
+            int remaining = mBufferLen - mFrameHeader.mTotalLen;
+            if (remaining > 0) {
+               System.arraycopy(mBuffer, mFrameHeader.mTotalLen, mBuffer, 0, remaining);
+            }
+            mBufferLen = remaining;
+
             // reset frame
             mFrameHeader = null;
-
+            
             // reprocess if more data left
-            return mFrameBuffer.position() > 0;
+            return mBufferLen > 0;
 
          } else {
 
@@ -512,53 +517,85 @@ protected void onBinaryMessage(byte[] payload) {
    private boolean processHandshake() throws UnsupportedEncodingException {
 
       boolean res = false;
-      for (int pos = mFrameBuffer.position() - 4; pos >= 0; --pos) {
-         if (mFrameBuffer.get(pos+0) == 0x0d &&
-             mFrameBuffer.get(pos+1) == 0x0a &&
-             mFrameBuffer.get(pos+2) == 0x0d &&
-             mFrameBuffer.get(pos+3) == 0x0a) {
+      // FIXME: this is wrong (searching from end of buffered data!)
+      for (int pos = mBufferLen - 4; pos >= 0; --pos) {
+         if (mBuffer[pos+0] == 0x0d &&
+             mBuffer[pos+1] == 0x0a &&
+             mBuffer[pos+2] == 0x0d &&
+             mBuffer[pos+3] == 0x0a) {
 
             /// \todo process & verify handshake from server
             /// \todo forward subprotocol, if any
-
-            int oldPosition = mFrameBuffer.position();
+            onHandshake(false);
             
+            int remaining = mBufferLen - (pos + 4);
+            if (remaining > 0) {
+               System.arraycopy(mBuffer, pos + 4, mBuffer, 0, remaining);
+            }
+            mBufferLen = remaining;
+
+            // process further when data after HTTP headers left in buffer
+            res = remaining > 0;
+
+            mState = STATE_OPEN;
+            break;
+         }
+      }
+      return res;
+   }
+
+   
+   /**
+    * Process WebSockets handshake received from server.
+    */
+   @SuppressWarnings("unused")
+   private boolean processHandshake2() throws UnsupportedEncodingException {
+
+      boolean res = false;
+      for (int pos = mBufferLen - 4; pos >= 0; --pos) {
+         if (mBuffer[pos+0] == 0x0d &&
+             mBuffer[pos+1] == 0x0a &&
+             mBuffer[pos+2] == 0x0d &&
+             mBuffer[pos+3] == 0x0a) {
+
             // Check HTTP status code
             boolean serverError = false;
-            if (mFrameBuffer.get(0) == 'H' &&
-            	mFrameBuffer.get(1) == 'T' &&
-            	mFrameBuffer.get(2) == 'T' &&
-            	mFrameBuffer.get(3) == 'P') {
+            if (mBuffer[pos+0] == 'H' &&
+                mBuffer[pos+1] == 'T' &&
+                mBuffer[pos+2] == 'T' &&
+                mBuffer[pos+3] == 'P') {
             	
             	Pair<Integer, String> status = parseHttpStatus();
-            	if (status.first >= 300) {
+            	if (status.first != 101) {
             		// Invalid status code for success connection
             		notify(new WebSocketMessage.ServerError(status.first, status.second));
             		serverError = true;
             	}
             }
             
-            mFrameBuffer.position(pos + 4);
-            mFrameBuffer.limit(oldPosition);
-            mFrameBuffer.compact();
+            int remaining = mBufferLen - (pos + 4);
+            if (remaining > 0) {
+               System.arraycopy(mBuffer, pos + 4, mBuffer, 0, remaining);
+            }
+            mBufferLen = remaining;
 
-            if (!serverError) {
-            	// process further when data after HTTP headers left in buffer
-                res = mFrameBuffer.position() > 0;
+            onHandshake(!serverError);
 
-                mState = STATE_OPEN;
+            if (!serverError) {
+               // process further when data after HTTP headers left in buffer
+               res = remaining > 0;
+               mState = STATE_OPEN;
             } else {
-            	res = true;
-            	mState = STATE_CLOSED;
-            	mStopped = true;
-            }
-            
-            onHandshake(!serverError);
+               res = true;
+               mState = STATE_CLOSED;
+               mStopped = true;
+            }            
             break;
          }
       }
       return res;
    }
+
    
    @SuppressWarnings("unused")
    private Map<String, String> parseHttpHeaders(byte[] buffer) throws UnsupportedEncodingException {
@@ -579,35 +616,35 @@ private boolean processHandshake() throws UnsupportedEncodingException {
 	   
 	   return headers;
    }
+
    
    private Pair<Integer, String> parseHttpStatus() throws UnsupportedEncodingException {
 	   int beg, end;
 		// Find first space
-		for (beg = 4; beg < mFrameBuffer.position(); ++beg) {
-			if (mFrameBuffer.get(beg) == ' ') break;
+		for (beg = 4; beg < mBufferLen; ++beg) {
+			if (mBuffer[beg] == ' ') break;
 		}
 		// Find second space
-		for (end = beg + 1; end < mFrameBuffer.position(); ++end) {
-			if (mFrameBuffer.get(end) == ' ') break;
+		for (end = beg + 1; end < mBufferLen; ++end) {
+			if (mBuffer[end] == ' ') break;
 		}
 		// Parse status code between them
 		++beg;
 		int statusCode = 0;
 		for (int i = 0; beg + i < end; ++i) {
-			int digit = (mFrameBuffer.get(beg + i) - 0x30);
+			int digit = (mBuffer[beg + i] - 0x30);
 			statusCode *= 10;
 			statusCode += digit;
 		}
 		// Find end of line to extract error message
 		++end;
 		int eol;
-		for (eol = end; eol < mFrameBuffer.position(); ++eol) {
-			if (mFrameBuffer.get(eol) == 0x0d) break;
+		for (eol = end; eol < mBufferLen; ++eol) {
+			if (mBuffer[eol] == 0x0d) break;
 		}
 		int statusMessageLength = eol - end;
 		byte[] statusBuf = new byte[statusMessageLength];
-		mFrameBuffer.position(end);
-		mFrameBuffer.get(statusBuf, 0, statusMessageLength);
+		System.arraycopy(mBuffer, end, statusBuf, 0, statusMessageLength);
 		String statusMessage = new String(statusBuf, "UTF-8");
 		if (DEBUG) Log.w(TAG, String.format("Status: %d (%s)", statusCode, statusMessage));
 		return new Pair<Integer, String>(statusCode, statusMessage);
@@ -648,18 +685,19 @@ public void run() {
       if (DEBUG) Log.d(TAG, "running");
 
       try {
-
-         mFrameBuffer.clear();
-         byte readbuff[] = new byte[mFrameBuffer.capacity()];
+         
+         mBufferLen = 0;
 
          do {
             // blocking read on socket
-            int len = mSocket.getInputStream().read(readbuff, 0, readbuff.length);
+            int len = mSocket.getInputStream().read(mBuffer, mBufferLen, mBuffer.length - mBufferLen);
+            
             if (len > 0) {
-               mFrameBuffer.put(readbuff, 0, len);
+               mBufferLen += len;
+
                // process buffered data
                while (consumeData()) {
-               }
+               }               
             } else if (len < 0) {
 
                if (DEBUG) Log.d(TAG, "run() : ConnectionLost");
