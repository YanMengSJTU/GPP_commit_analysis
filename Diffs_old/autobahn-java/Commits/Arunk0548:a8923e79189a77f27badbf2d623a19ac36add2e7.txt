diff --git a/Autobahn/src/de/tavendo/autobahn/ByteBufferOutputStream.java b/Autobahn/src/de/tavendo/autobahn/ByteBufferOutputStream.java
index 98a27bc..f80eee5 100644
--- a/Autobahn/src/de/tavendo/autobahn/ByteBufferOutputStream.java
+++ b/Autobahn/src/de/tavendo/autobahn/ByteBufferOutputStream.java
@@ -173,4 +173,12 @@ public synchronized void crlf() throws IOException {
       write(0x0a);
    }
 
+   @Override
+   public synchronized String toString()
+   {
+	   String tostring = null;
+	tostring = new String(mBuffer.toString());
+	   
+	return tostring;
+   }
 }
diff --git a/Autobahn/src/de/tavendo/autobahn/Wamp.java b/Autobahn/src/de/tavendo/autobahn/Wamp.java
index 55a65e1..5edf256 100644
--- a/Autobahn/src/de/tavendo/autobahn/Wamp.java
+++ b/Autobahn/src/de/tavendo/autobahn/Wamp.java
@@ -19,6 +19,7 @@
 package de.tavendo.autobahn;
 
 
+import java.util.HashMap;
 import java.util.List;
 import org.apache.http.message.BasicNameValuePair;
 import org.codehaus.jackson.type.TypeReference;
@@ -101,7 +102,7 @@
    /**
     * Disconnect from WAMP server.
     */
-   public void disconnect();
+   public void shutdown();
 
    /**
     * Check if currently connected to server.
@@ -170,8 +171,24 @@
        *
        * @param topicUri   The URI or CURIE of the topic the event was published to.
        * @param event      The event, transformed into the type that was specified when subscribing.
+       * @param 			The optional pay load information sent by publisher
        */
-      public void onEvent(String topicUri, Object event);
+      public void onEvent(String topicUri, Object event, HashMap<String, Object> dict);
+      
+      /**
+       * Fired on failure of last request.
+       *
+       * @param errorUri   The URI or CURIE of the error that occurred.
+       * @param errorDesc  A human readable description of the error.
+       */
+      public void onError(String errorUri, String errorDesc);
+      
+      /**
+       * Fired on successful completion of current request.
+       *
+       * @param result     The request has been accepted and confirmed by broker.
+       */
+      public void onRequestAccepted(Object result);
    }
 
    /**
@@ -211,5 +228,16 @@
     * @param event         The event to be published.
     */
    public void publish(String topicUri, Object event);
+   
+   /**
+    * Publish an event to the specified topic.
+    *
+    * @param topicUri      The URI or CURIE of the topic the event is to be published for.
+    * @param acknowledge   The acknowledgment to received on publication or error.
+    * @param eventType     The type that event get transformed into.
+    * @param eventHandler	The event handler.
+    * @param arguments 		The event to be publish
+    */
+   public void publish(String topicUri, boolean acknowledge, Class<?> eventType, EventHandler eventHandler , Object... arguments);
 
 }
diff --git a/Autobahn/src/de/tavendo/autobahn/WampConnection.java b/Autobahn/src/de/tavendo/autobahn/WampConnection.java
index 487006c..dd3ec24 100644
--- a/Autobahn/src/de/tavendo/autobahn/WampConnection.java
+++ b/Autobahn/src/de/tavendo/autobahn/WampConnection.java
@@ -18,6 +18,7 @@
 
 package de.tavendo.autobahn;
 
+import java.util.HashMap;
 import java.util.List;
 import java.util.Random;
 import java.util.concurrent.ConcurrentHashMap;
@@ -27,426 +28,676 @@
 
 import android.os.HandlerThread;
 import android.util.Log;
+import de.tavendo.autobahn.WampMessage.GoodBye;
 
 public class WampConnection extends WebSocketConnection implements Wamp {
 
-   private static final boolean DEBUG = true;
-   private static final String TAG = WampConnection.class.getName();
+	private static final boolean DEBUG = true;
+	private static final String TAG = WampConnection.class.getName();
 
+	// / The message handler of the background writer.
+	protected WampWriter mWriterHandler;
 
-   /// The message handler of the background writer.
-   protected WampWriter mWriterHandler;
+	// / Prefix map for outgoing messages.
+	private final PrefixMap mOutgoingPrefixes = new PrefixMap();
 
-   /// Prefix map for outgoing messages.
-   private final PrefixMap mOutgoingPrefixes = new PrefixMap();
-
-   /// RNG for IDs.
-   private final Random mRng = new Random();
-
-   /// Set of chars to be used for IDs.
-   private static final char[] mBase64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
-         .toCharArray();
-
-   /**
-    * RPC metadata.
-    */
-   public static class CallMeta {
-
-      CallMeta(CallHandler handler, Class<?> resultClass) {
-         this.mResultHandler = handler;
-         this.mResultClass = resultClass;
-         this.mResultTypeRef = null;
-      }
-
-      CallMeta(CallHandler handler, TypeReference<?> resultTypeReference) {
-         this.mResultHandler = handler;
-         this.mResultClass = null;
-         this.mResultTypeRef = resultTypeReference;
-      }
-
-      /// Call handler to be fired on.
-      public CallHandler mResultHandler;
-
-      /// Desired call result type or null.
-      public Class<?> mResultClass;
-
-      /// Desired call result type or null.
-      public TypeReference<?> mResultTypeRef;
-   }
-
-   /// Metadata about issued, but not yet returned RPCs.
-   private final ConcurrentHashMap<String, CallMeta> mCalls = new ConcurrentHashMap<String, CallMeta>();
-
-   /**
-    * Event subscription metadata.
-    */
-   public static class SubMeta {
-
-      SubMeta(EventHandler handler, Class<?> resultClass) {
-         this.mEventHandler = handler;
-         this.mEventClass = resultClass;
-         this.mEventTypeRef = null;
-      }
-
-      SubMeta(EventHandler handler, TypeReference<?> resultTypeReference) {
-         this.mEventHandler = handler;
-         this.mEventClass = null;
-         this.mEventTypeRef = resultTypeReference;
-      }
-
-      /// Event handler to be fired on.
-      public EventHandler mEventHandler;
-
-      /// Desired event type or null.
-      public Class<?> mEventClass;
-
-      /// Desired event type or null.
-      public TypeReference<?> mEventTypeRef;
-   }
-
-   /// Metadata about active event subscriptions.
-   private final ConcurrentHashMap<String, SubMeta> mSubs = new ConcurrentHashMap<String, SubMeta>();
-
-   /// The session handler provided to connect().
-   private Wamp.ConnectionHandler mSessionHandler;
-
-
-   /**
-    * Create the connection transmitting leg writer.
-    */
-   protected void createWriter() {
-
-      mWriterThread = new HandlerThread("AutobahnWriter");
-      mWriterThread.start();
-      mWriter = new WampWriter(mWriterThread.getLooper(), mMasterHandler, mTransportChannel, mOptions);
-
-      if (DEBUG) Log.d(TAG, "writer created and started");
-   }
-
-
-   /**
-    * Create the connection receiving leg reader.
-    */
-   protected void createReader() {
-      mReader = new WampReader(mCalls, mSubs, mMasterHandler, mTransportChannel, mOptions, "AutobahnReader");
-      mReader.start();
-
-      if (DEBUG) Log.d(TAG, "reader created and started");
-   }
-
-
-   /**
-    * Create new random ID. This is used, i.e. for use in RPC calls to correlate
-    * call message with result message.
-    *
-    * @param len    Length of ID.
-    * @return       New random ID of given length.
-    */
-   private String newId(int len) {
-      char[] buffer = new char[len];
-      for (int i = 0; i < len; i++) {
-         buffer[i] = mBase64Chars[mRng.nextInt(mBase64Chars.length)];
-      }
-      return new String(buffer);
-   }
-
-
-   /**
-    * Create new random ID of default length.
-    *
-    * @return    New random ID of default length.
-    */
-   private String newId() {
-      return newId(8);
-   }
-
-
-   public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler) {
-
-      WampOptions options = new WampOptions();
-      options.setReceiveTextMessagesRaw(true);
-      options.setMaxMessagePayloadSize(64*1024);
-      options.setMaxFramePayloadSize(64*1024);
-      options.setTcpNoDelay(true);
-
-      connect(wsUri, sessionHandler, options, null);
-   }
-
-
-   /**
-    * Connect to server.
-    *
-    * @param wsUri            WebSockets server URI.
-    * @param sessionHandler   The session handler to fire callbacks on.
-    * @param headers		   The headers for connection
-    */
-   public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler, WampOptions options, List<BasicNameValuePair> headers) {
-
-      mSessionHandler = sessionHandler;
-
-      mCalls.clear();
-      mSubs.clear();
-      mOutgoingPrefixes.clear();
-
-      try {
-         connect(wsUri, new String[] {"wamp"}, new WebSocketConnectionHandler() {
-
-            @Override
-            public void onOpen() {
-               if (mSessionHandler != null) {
-                  mSessionHandler.onOpen();
-               } else {
-                  if (DEBUG) Log.d(TAG, "could not call onOpen() .. handler already NULL");
-               }
-            }
-
-            @Override
-            public void onClose(int code, String reason) {
-               if (mSessionHandler != null) {
-                  mSessionHandler.onClose(code, reason);
-               } else {
-                  if (DEBUG) Log.d(TAG, "could not call onClose() .. handler already NULL");
-               }
-            }
-
-         }, options, headers);
-
-      } catch (WebSocketException e) {
-
-         if (mSessionHandler != null) {
-            mSessionHandler.onClose(WebSocketConnectionHandler.CLOSE_CANNOT_CONNECT, "cannot connect (" + e.toString() + ")");
-         } else {
-            if (DEBUG) Log.d(TAG, "could not call onClose() .. handler already NULL");
-         }
-      }
-
-   }
+	// / RNG for IDs.
+	//private final Random mRng = new Random();
 	
-   public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler, List<BasicNameValuePair> headers) {
-
-	   WampOptions options = new WampOptions();
-	   options.setReceiveTextMessagesRaw(true);
-	   options.setMaxMessagePayloadSize(64*1024);
-	   options.setMaxFramePayloadSize(64*1024);
-	   options.setTcpNoDelay(true);
-
-	   connect(wsUri, sessionHandler, options, headers);
-   }
-
-   public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler, WampOptions options) {	
-
-	   connect(wsUri, sessionHandler, options, null);
-   }
-
-
-   /**
-    * Process WAMP messages coming from the background reader.
-    */
-   protected void processAppMessage(Object message) {
-
-      if (message instanceof WampMessage.CallResult) {
-
-         WampMessage.CallResult callresult = (WampMessage.CallResult) message;
-
-         if (mCalls.containsKey(callresult.mCallId)) {
-            CallMeta meta = mCalls.get(callresult.mCallId);
-            if (meta.mResultHandler != null) {
-               meta.mResultHandler.onResult(callresult.mResult);
-            }
-            mCalls.remove(callresult.mCallId);
-         }
-
-      } else if (message instanceof WampMessage.CallError) {
-
-         WampMessage.CallError callerror = (WampMessage.CallError) message;
-
-         if (mCalls.containsKey(callerror.mCallId)) {
-            CallMeta meta = mCalls.get(callerror.mCallId);
-            if (meta.mResultHandler != null) {
-               meta.mResultHandler.onError(callerror.mErrorUri, callerror.mErrorDesc);
-            }
-            mCalls.remove(callerror.mCallId);
-         }
-      } else if (message instanceof WampMessage.Event) {
-
-         WampMessage.Event event = (WampMessage.Event) message;
-
-         if (mSubs.containsKey(event.mTopicUri)) {
-            SubMeta meta = mSubs.get(event.mTopicUri);
-            if (meta != null && meta.mEventHandler != null) {
-               meta.mEventHandler.onEvent(event.mTopicUri, event.mEvent);
-            }
-         }
-      } else if (message instanceof WampMessage.Welcome) {
-
-         WampMessage.Welcome welcome = (WampMessage.Welcome) message;
-
-         // FIXME: safe session ID / fire session opened hook
-         if (DEBUG) Log.d(TAG, "WAMP session " + welcome.mSessionId + " established (protocol version " + welcome.mProtocolVersion + ", server " + welcome.mServerIdent + ")");
-
-      } else {
-
-         if (DEBUG) Log.d(TAG, "unknown WAMP message in AutobahnConnection.processAppMessage");
-      }
-   }
-
-
-   /**
-    * Issue a remote procedure call (RPC).
-    *
-    * @param procUri       URI or CURIE of procedure to call.
-    * @param resultMeta    Call result metadata.
-    * @param arguments     Call arguments.
-    */
-   private void call(String procUri, CallMeta resultMeta, Object... arguments) {
-
-      WampMessage.Call call = new WampMessage.Call(newId(), procUri, arguments.length);
-      for (int i = 0; i < arguments.length; ++i) {
-         call.mArgs[i] = arguments[i];
-      }
-      mCalls.put(call.mCallId, resultMeta);
-      mWriter.forward(call);
-   }
-
-
-   /**
-    * Issue a remote procedure call (RPC). This version should be used with
-    * primitive Java types and simple composite (class) types.
-    *
-    * @param procUri          URI or CURIE of procedure to call.
-    * @param resultType       Type we want the call result to be converted to.
-    * @param resultHandler    Call handler to process call result or error.
-    * @param arguments        Call arguments.
-    */
-   public void call(String procUri, Class<?> resultType, CallHandler resultHandler, Object... arguments) {
-
-      call(procUri, new CallMeta(resultHandler, resultType), arguments);
-   }
-
-
-   /**
-    * Issue a remote procedure call (RPC). This version should be used with
-    * result types which are containers, i.e. List<> or Map<>.
-    *
-    * @param procUri          URI or CURIE of procedure to call.
-    * @param resultType       Type we want the call result to be converted to.
-    * @param resultHandler    Call handler to process call result or error.
-    * @param arguments        Call arguments.
-    */
-   public void call(String procUri, TypeReference<?> resultType, CallHandler resultHandler, Object... arguments) {
-
-      call(procUri, new CallMeta(resultHandler, resultType), arguments);
-   }
-
-
-   /**
-    * Subscribe to topic to receive events for.
-    *
-    * @param topicUri         URI or CURIE of topic to subscribe to.
-    * @param meta             Subscription metadata.
-    */
-   private void subscribe(String topicUri, SubMeta meta) {
-
-      String uri = mOutgoingPrefixes.resolveOrPass(topicUri);
-
-      if (!mSubs.containsKey(uri)) {
-
-         mSubs.put(uri, meta);
-
-         WampMessage.Subscribe msg = new WampMessage.Subscribe(mOutgoingPrefixes.shrink(topicUri));
-         mWriter.forward(msg);
-      }
-   }
-
-
-   /**
-    * Subscribe to topic to receive events for. This version should be used with
-    * result types which are containers, i.e. List<> or Map<>.
-    *
-    * @param topicUri         URI or CURIE of topic to subscribe to.
-    * @param eventType        The type we want events to be converted to.
-    * @param eventHandler     The event handler to process received events.
-    */
-   public void subscribe(String topicUri, Class<?> eventType, EventHandler eventHandler) {
-
-      subscribe(topicUri, new SubMeta(eventHandler, eventType));
-   }
-
-
-   /**
-    * Subscribe to topic to receive events for.  This version should be used with
-    * primitive Java types and simple composite (class) types.
-    *
-    * @param topicUri         URI or CURIE of topic to subscribe to.
-    * @param eventType        The type we want events to be converted to.
-    * @param eventHandler     The event handler to process received events.
-    */
-   public void subscribe(String topicUri, TypeReference<?> eventType, EventHandler eventHandler) {
-
-      subscribe(topicUri, new SubMeta(eventHandler, eventType));
-   }
-
-
-   /**
-    * Unsubscribe from topic.
-    *
-    * @param topicUri      URI or CURIE of topic to unsubscribe from.
-    */
-   public void unsubscribe(String topicUri) {
-
-      if (mSubs.containsKey(topicUri)) {
-
-         WampMessage.Unsubscribe msg = new WampMessage.Unsubscribe(topicUri);
-         mWriter.forward(msg);
-         
-         mSubs.remove(topicUri);
-      }
-   }
-
-
-   /**
-    * Unsubscribe from any subscribed topic.
-    */
-   public void unsubscribe() {
-
-      for (String topicUri : mSubs.keySet()) {
-
-         WampMessage.Unsubscribe msg = new WampMessage.Unsubscribe(topicUri);
-         mWriter.forward(msg);
-      }
-      mSubs.clear();
-   }
-
-
-   /**
-    * Establish a prefix to be used in CURIEs.
-    *
-    * @param prefix     The prefix to be used in CURIEs.
-    * @param uri        The full URI this prefix shall resolve to.
-    */
-   public void prefix(String prefix, String uri) {
-
-      String currUri = mOutgoingPrefixes.get(prefix);
-
-      if (currUri == null || !currUri.equals(uri)) {
-
-         mOutgoingPrefixes.set(prefix, uri);
-
-         WampMessage.Prefix msg = new WampMessage.Prefix(prefix, uri);
-         mWriter.forward(msg);
-      }
-   }
-
-
-   /**
-    * Publish an event to a topic.
-    *
-    * @param topicUri   URI or CURIE of topic to publish event on.
-    * @param event      Event to be published.
-    */
-   public void publish(String topicUri, Object event) {
-
-      WampMessage.Publish msg = new WampMessage.Publish(mOutgoingPrefixes.shrink(topicUri), event);
-      mWriter.forward(msg);
-   }
+	// Is Shut down trigger by client.
+	private volatile boolean isShutdown;
+
+	// / Set of chars to be used for IDs.
+	/*private static final char[] mBase64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
+			.toCharArray();*/
+
+	/**
+	 * RPC metadata.
+	 */
+	public static class CallMeta {
+
+		CallMeta(CallHandler handler, Class<?> resultClass) {
+			this.mResultHandler = handler;
+			this.mResultClass = resultClass;
+			this.mResultTypeRef = null;
+		}
+
+		CallMeta(CallHandler handler, TypeReference<?> resultTypeReference) {
+			this.mResultHandler = handler;
+			this.mResultClass = null;
+			this.mResultTypeRef = resultTypeReference;
+		}
+
+		// / Call handler to be fired on.
+		public CallHandler mResultHandler;
+
+		// / Desired call result type or null.
+		public Class<?> mResultClass;
+
+		// / Desired call result type or null.
+		public TypeReference<?> mResultTypeRef;
+	}
+
+	// / Metadata about issued, but not yet returned RPCs.
+	private final ConcurrentHashMap<String, CallMeta> mCalls = new ConcurrentHashMap<String, CallMeta>();
+
+	private final ConcurrentHashMap<String, String> mRequestTopicMap = new ConcurrentHashMap<String, String>();
+
+	/**
+	 * Event subscription metadata.
+	 */
+	public static class SubMeta {
+
+		public String mSubscriptionId;
+		
+		SubMeta(EventHandler handler, Class<?> resultClass) {
+			this.mEventHandler = handler;
+			this.mEventClass = resultClass;
+			this.mEventTypeRef = null;
+		}
+
+		SubMeta(EventHandler handler, TypeReference<?> resultTypeReference) {
+			this.mEventHandler = handler;
+			this.mEventClass = null;
+			this.mEventTypeRef = resultTypeReference;
+		}
+
+		// / Event handler to be fired on.
+		public EventHandler mEventHandler;
+
+		// / Desired event type or null.
+		public Class<?> mEventClass;
+
+		// / Desired event type or null.
+		public TypeReference<?> mEventTypeRef;
+	}
+
+	/**
+	 * Event publish metadata.
+	 */
+	public static class PubMeta {
+
+		public String mPublicationId;
+		
+		PubMeta(EventHandler handler, Class<?> resultClass) {
+			this.mEventHandler = handler;
+			this.mEventClass = resultClass;
+			this.mEventTypeRef = null;
+		}
+
+		PubMeta(EventHandler handler, TypeReference<?> resultTypeReference) {
+			this.mEventHandler = handler;
+			this.mEventClass = null;
+			this.mEventTypeRef = resultTypeReference;
+		}
+
+		// / Event handler to be fired on.
+		public EventHandler mEventHandler;
+
+		// / Desired event type or null.
+		public Class<?> mEventClass;
+
+		// / Desired event type or null.
+		public TypeReference<?> mEventTypeRef;
+	}
+
+	// / Metadata about active event subscriptions.
+	private final ConcurrentHashMap<String, SubMeta> mSubs = new ConcurrentHashMap<String, SubMeta>();
+
+	// / Metadata about active event subscriptions.
+	private final ConcurrentHashMap<String, PubMeta> mPubs = new ConcurrentHashMap<String, PubMeta>();
+
+	// / The session handler provided to connect().
+	private Wamp.ConnectionHandler mSessionHandler;
+
+	/**
+	 * Create the connection transmitting leg writer.
+	 */
+	protected void createWriter() {
+
+		mWriterThread = new HandlerThread("AutobahnWriter");
+		mWriterThread.start();
+		mWriter = new WampWriter(mWriterThread.getLooper(), mMasterHandler,
+				mTransportChannel, mOptions);
+
+		if (DEBUG)
+			Log.d(TAG, "writer created and started");
+	}
+
+	/**
+	 * Create the connection receiving leg reader.
+	 */
+	protected void createReader() {
+		mReader = new WampReader(mCalls, mSubs, mPubs,mRequestTopicMap , mMasterHandler,
+				mTransportChannel, mOptions, "AutobahnReader");
+		mReader.start();
+
+		if (DEBUG)
+			Log.d(TAG, "reader created and started");
+	}
+
+	/**
+	 * Create new random ID. This is used, i.e. for use in RPC calls to
+	 * correlate call message with result message.
+	 * 
+	 * @param len
+	 *            Length of ID.
+	 * @return New random ID of given length.
+	 */
+	/*private String newId(int len) {
+		char[] buffer = new char[len];
+		for (int i = 0; i < len; i++) {
+			buffer[i] = mBase64Chars[mRng.nextInt(mBase64Chars.length)];
+		}
+		long l = Long.valueOf("9007199254740992");
+		 l = (long) (Math.random() * l);
+		return new String(String.valueOf(wampIdGenerator.generate()));
+	}*/
+
+	/**
+	 * Create new random ID of default length.
+	 * 
+	 * @return New random ID of default length.
+	 */
+	private String newId() {
+		return new String(String.valueOf(mIdGenerator.generate()));
+	}
+
+	RequestIdGenerator mIdGenerator = new RequestIdGenerator();
+	
+	private class RequestIdGenerator {
+	    private final Random random = new Random();
+	    private final long limit = (long)Math.pow(2, 50);
+
+	    public long generate() {
+	        return nextLong(this.random, this.limit);
+	    }
+
+	    private long nextLong(Random rng, long n) {
+	        // error checking and 2^x checking removed for simplicity.
+	        long bits, val;
+	        do {
+	            bits = (rng.nextLong() << 1) >>> 1;
+	            val = bits % n;
+	        } while (bits - val + (n - 1) < 0L);
+	        return val;
+	    }
+	}
+	
+	public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler) {
+
+		WampOptions options = new WampOptions();
+		options.setReceiveTextMessagesRaw(true);
+		options.setMaxMessagePayloadSize(64 * 1024);
+		options.setMaxFramePayloadSize(64 * 1024);
+		options.setTcpNoDelay(true);
+
+		connect(wsUri, sessionHandler, options, null);
+	}
+
+	/**
+	 * Connect to server.
+	 * 
+	 * @param wsUri
+	 *            WebSockets server URI.
+	 * @param sessionHandler
+	 *            The session handler to fire callbacks on.
+	 * @param headers
+	 *            The headers for connection
+	 */
+	public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler,
+			WampOptions options, List<BasicNameValuePair> headers) {
+
+		mSessionHandler = sessionHandler;
+
+		mCalls.clear();
+		mSubs.clear();
+		mOutgoingPrefixes.clear();
+
+		try {
+			connect(wsUri, new String[] { "wamp.2.json" },
+					new WebSocketConnectionHandler() {
+
+						@Override
+						public void onOpen() {
+							/*
+							 * if (mSessionHandler != null) {
+							 * mSessionHandler.onOpen();
+							 * 
+							 * 
+							 * } else { if (DEBUG) Log.d(TAG,
+							 * "could not call onOpen() .. handler already NULL"
+							 * ); }
+							 */
+
+							// send hello messsage to establish session.
+							WampMessage.Hello hellow = new WampMessage.Hello();
+							mWriter.forward(hellow);
+
+						}
+
+						@Override
+						public void onClose(int code, String reason) {
+							if (mSessionHandler != null) {
+								mSessionHandler.onClose(code, reason);
+							} else {
+								if (DEBUG)
+									Log.d(TAG,
+											"could not call onClose() .. handler already NULL");
+							}
+						}
+
+					}, options, headers);
+
+		} catch (WebSocketException e) {
+
+			if (mSessionHandler != null) {
+				mSessionHandler.onClose(
+						WebSocketConnectionHandler.CLOSE_CANNOT_CONNECT,
+						"cannot connect (" + e.toString() + ")");
+			} else {
+				if (DEBUG)
+					Log.d(TAG,
+							"could not call onClose() .. handler already NULL");
+			}
+		}
+
+	}
+
+	public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler,
+			List<BasicNameValuePair> headers) {
+
+		WampOptions options = new WampOptions();
+		options.setReceiveTextMessagesRaw(true);
+		options.setMaxMessagePayloadSize(64 * 1024);
+		options.setMaxFramePayloadSize(64 * 1024);
+		options.setTcpNoDelay(true);
+
+		connect(wsUri, sessionHandler, options, headers);
+	}
+
+	public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler,
+			WampOptions options) {
+
+		connect(wsUri, sessionHandler, options, null);
+	}
+	
+	public void shutdown()
+	{
+		isShutdown = true;
+		
+		WampMessage.GoodBye goodbye = new GoodBye(new HashMap<String, Object>(), "wamp.error.goodbye_and_out");
+		
+		mWriter.forward(goodbye);
+	}
+
+	/**
+	 * Process WAMP messages coming from the background reader.
+	 */
+	protected void processAppMessage(Object message) {
+
+		if (message instanceof WampMessage.CallResult) {
+
+			WampMessage.CallResult callresult = (WampMessage.CallResult) message;
+
+			if (mCalls.containsKey(callresult.mCallId)) {
+				CallMeta meta = mCalls.get(callresult.mCallId);
+				if (meta.mResultHandler != null) {
+					meta.mResultHandler.onResult(callresult.mResult);
+				}
+				mCalls.remove(callresult.mCallId);
+			}
+
+		} else if (message instanceof WampMessage.CallError) {
+
+			WampMessage.CallError callerror = (WampMessage.CallError) message;
+
+			if (mCalls.containsKey(callerror.mCallId)) {
+				CallMeta meta = mCalls.get(callerror.mCallId);
+				if (meta.mResultHandler != null) {
+					meta.mResultHandler.onError(callerror.mErrorUri,
+							callerror.mErrorDesc);
+				}
+				mCalls.remove(callerror.mCallId);
+			}
+		} else if (message instanceof WampMessage.Event) {
+
+			WampMessage.Event event = (WampMessage.Event) message;
+
+			if (mSubs.containsKey(event.mTopicUri)) {
+				SubMeta meta = mSubs.get(event.mTopicUri);
+				if (meta != null && meta.mEventHandler != null) {
+					meta.mEventHandler.onEvent(event.mTopicUri, event.mEvent,event.mArgumentsKw);
+				}
+			}
+		} else if (message instanceof WampMessage.Abort) {
+			WampMessage.Abort abort = (WampMessage.Abort) message;
+
+			if (DEBUG)
+				Log.d(TAG, "WAMP session abort by server : " + abort.Reason);
+
+		} else if (message instanceof WampMessage.GoodBye) {
+
+			WampMessage.GoodBye goodbye = (WampMessage.GoodBye) message;
+
+			if (DEBUG)
+				Log.d(TAG, "Session close initiated  , reason : "
+						+ goodbye.Reason);
+
+			/**
+			 * if shutdown initiated by Wamp Server, send a good bye message.
+			 */
+			if(!isShutdown){
+			goodbye.Details = new HashMap<String, Object>();
+			goodbye.Reason = "wamp.error.goodbye_and_out";
+
+			mWriter.forward(goodbye);
+			}
+			else
+			{
+				// client has request for connection close. and confirmation has been received.
+				if(DEBUG) Log.d(TAG,"client has request for connection close. and confirmation has been received.");
+				disconnect();
+			}
+		} else if (message instanceof WampMessage.Subscribed) {
+
+			WampMessage.Subscribed subscribed = (WampMessage.Subscribed) message;
+
+			if (DEBUG)
+				Log.d(TAG, " Subscribe confirmation received from WAMP server ");
+			String topicUri = mRequestTopicMap.get(subscribed.mSubscribeRequestId);
+			if (topicUri != null && mSubs.containsKey(topicUri)) {
+				SubMeta meta = mSubs.get(topicUri);
+				if (meta != null && meta.mEventHandler != null) {
+					meta.mEventHandler.onRequestAccepted(" topic : " + topicUri
+							+ " subscribed with subscription id : "
+							+ subscribed.mSubscriptionId);
+					
+					meta.mSubscriptionId = subscribed.mSubscriptionId;
+				}
+			}
+
+		} else if (message instanceof WampMessage.Published) {
+
+			WampMessage.Published published = (WampMessage.Published) message;
+
+			if (DEBUG)
+				Log.d(TAG, " Publish confirmation received from WAMP server ");
+			String topicUri = mRequestTopicMap.get(published.mPublicationRequestId);
+			if (topicUri != null && mPubs.containsKey(topicUri)) {
+				PubMeta meta = mPubs.get(topicUri);
+				if (meta != null && meta.mEventHandler != null) {
+					meta.mEventHandler.onRequestAccepted(" topic : " + topicUri
+							+ " published with publication id : "
+							+ published.mPublicationtionId);
+				}
+				 mPubs.remove(topicUri);
+				 mRequestTopicMap.remove(published.mPublicationRequestId);
+			}
+			
+		} else if (message instanceof WampMessage.Welcome) {
+
+			WampMessage.Welcome welcome = (WampMessage.Welcome) message;
+
+			// FIXME: safe session ID / fire session opened hook
+			if (DEBUG)
+				Log.d(TAG, "WAMP session " + welcome.mSessionId
+						+ " established (protocol version "
+						+ welcome.mProtocolVersion + ", server "
+						+ welcome.mServerIdent + ")");
+
+			if (mSessionHandler != null) {
+				mSessionHandler.onOpen();
+
+			} else {
+				if (DEBUG)
+					Log.d(TAG,
+							"could not call onOpen() .. handler already NULL");
+			}
+
+		} else {
+
+			if (DEBUG)
+				Log.d(TAG,
+						"unknown WAMP message in AutobahnConnection.processAppMessage");
+		}
+	}
+
+	/**
+	 * Issue a remote procedure call (RPC).
+	 * 
+	 * @param procUri
+	 *            URI or CURIE of procedure to call.
+	 * @param resultMeta
+	 *            Call result metadata.
+	 * @param arguments
+	 *            Call arguments.
+	 */
+	private void call(String procUri, CallMeta resultMeta, Object... arguments) {
+
+		WampMessage.Call call = new WampMessage.Call(newId(), procUri,
+				arguments.length);
+		for (int i = 0; i < arguments.length; ++i) {
+			call.mArgs[i] = arguments[i];
+		}
+		mCalls.put(call.mCallId, resultMeta);
+		mWriter.forward(call);
+	}
+
+	/**
+	 * Issue a remote procedure call (RPC). This version should be used with
+	 * primitive Java types and simple composite (class) types.
+	 * 
+	 * @param procUri
+	 *            URI or CURIE of procedure to call.
+	 * @param resultType
+	 *            Type we want the call result to be converted to.
+	 * @param resultHandler
+	 *            Call handler to process call result or error.
+	 * @param arguments
+	 *            Call arguments.
+	 */
+	public void call(String procUri, Class<?> resultType,
+			CallHandler resultHandler, Object... arguments) {
+
+		call(procUri, new CallMeta(resultHandler, resultType), arguments);
+	}
+
+	/**
+	 * Issue a remote procedure call (RPC). This version should be used with
+	 * result types which are containers, i.e. List<> or Map<>.
+	 * 
+	 * @param procUri
+	 *            URI or CURIE of procedure to call.
+	 * @param resultType
+	 *            Type we want the call result to be converted to.
+	 * @param resultHandler
+	 *            Call handler to process call result or error.
+	 * @param arguments
+	 *            Call arguments.
+	 */
+	public void call(String procUri, TypeReference<?> resultType,
+			CallHandler resultHandler, Object... arguments) {
+
+		call(procUri, new CallMeta(resultHandler, resultType), arguments);
+	}
+
+	/**
+	 * Subscribe to topic to receive events for.
+	 * 
+	 * @param topicUri
+	 *            URI or CURIE of topic to subscribe to.
+	 * @param meta
+	 *            Subscription metadata.
+	 */
+	private void subscribe(String topicUri, SubMeta meta) {
+
+		String uri = mOutgoingPrefixes.resolveOrPass(topicUri);
+
+		String newid = newId();
+		if (!mSubs.containsKey(uri)) {
+
+			mRequestTopicMap.put(newid, uri);
+
+			mSubs.put(uri, meta);
+
+			HashMap<String, Object> dict = new HashMap<String, Object>();
+			WampMessage.Subscribe msg = new WampMessage.Subscribe(newid, dict,
+					mOutgoingPrefixes.shrink(topicUri));
+			mWriter.forward(msg);
+		}
+	}
+
+	/**
+	 * Subscribe to topic to receive events for. This version should be used
+	 * with result types which are containers, i.e. List<> or Map<>.
+	 * 
+	 * @param topicUri
+	 *            URI or CURIE of topic to subscribe to.
+	 * @param eventType
+	 *            The type we want events to be converted to.
+	 * @param eventHandler
+	 *            The event handler to process received events.
+	 */
+	public void subscribe(String topicUri, Class<?> eventType,
+			EventHandler eventHandler) {
+
+		subscribe(topicUri, new SubMeta(eventHandler, eventType));
+	}
+
+	/**
+	 * Subscribe to topic to receive events for. This version should be used
+	 * with primitive Java types and simple composite (class) types.
+	 * 
+	 * @param topicUri
+	 *            URI or CURIE of topic to subscribe to.
+	 * @param eventType
+	 *            The type we want events to be converted to.
+	 * @param eventHandler
+	 *            The event handler to process received events.
+	 */
+	public void subscribe(String topicUri, TypeReference<?> eventType,
+			EventHandler eventHandler) {
+
+		subscribe(topicUri, new SubMeta(eventHandler, eventType));
+	}
+
+	/**
+	 * Unsubscribe from topic.
+	 * 
+	 * @param topicUri
+	 *            URI or CURIE of topic to unsubscribe from.
+	 */
+	public void unsubscribe(String topicUri) {
+
+		if (mSubs.containsKey(topicUri)) {
+
+			SubMeta meta = mSubs.get(topicUri);
+			
+			WampMessage.Unsubscribe msg = new WampMessage.Unsubscribe(newId(),meta.mSubscriptionId);
+			mWriter.forward(msg);
+
+			mSubs.remove(topicUri);
+			mRequestTopicMap.remove(topicUri);
+		}
+	}
+
+	/**
+	 * Unsubscribe from any subscribed topic.
+	 */
+	public void unsubscribe() {
+
+		for (String topicUri : mSubs.keySet()) {
+			
+			SubMeta meta = mSubs.get(topicUri);
+			
+			WampMessage.Unsubscribe msg = new WampMessage.Unsubscribe(newId(),meta.mSubscriptionId);
+			mWriter.forward(msg);
+
+		}
+		mSubs.clear();
+		mRequestTopicMap.clear();
+	}
+
+	/**
+	 * Establish a prefix to be used in CURIEs.
+	 * 
+	 * @param prefix
+	 *            The prefix to be used in CURIEs.
+	 * @param uri
+	 *            The full URI this prefix shall resolve to.
+	 */
+	public void prefix(String prefix, String uri) {
+
+		String currUri = mOutgoingPrefixes.get(prefix);
+
+		if (currUri == null || !currUri.equals(uri)) {
+
+			mOutgoingPrefixes.set(prefix, uri);
+
+			WampMessage.Prefix msg = new WampMessage.Prefix(prefix, uri);
+			mWriter.forward(msg);
+		}
+	}
+
+	/**
+	 * Publish to topic for events.
+	 * 
+	 * @param topicUri
+	 *            URI or CURIE of topic to subscribe to.
+	 * @param meta
+	 *            Subscription metadata.
+	 */
+	private void publish(String topicUri,  boolean acknowledge,
+			PubMeta meta,Object... arguments) {
+
+		String uri = mOutgoingPrefixes.resolveOrPass(topicUri);
+
+		if (!mPubs.containsKey(uri)) {
+
+			String newId = newId();
+			mPubs.put(uri, meta);
+			mRequestTopicMap.put(newId, uri);
+
+			HashMap<String, Object> dict = new HashMap<String, Object>();
+			dict.put("acknowledge", acknowledge);
+			WampMessage.Publish msg = new WampMessage.Publish(newId, dict,
+					mOutgoingPrefixes.shrink(topicUri), arguments);
+			mWriter.forward(msg);
+		}
+	}
+
+	/**
+	 * Publish an event to a topic.
+	 * 
+	 * @param topicUri
+	 *            URI or CURIE of topic to publish event on.
+	 * @param event
+	 *            Event to be published.
+	 */
+	public void publish(String topicUri, Object event) {
+
+		HashMap<String, Object> dict = new HashMap<String, Object>();
+		WampMessage.Publish msg = new WampMessage.Publish(newId(), dict,
+				mOutgoingPrefixes.shrink(topicUri), event);
+		mWriter.forward(msg);
+	}
+
+	/**
+	 * Publish an event to the specified topic.
+	 * 
+	 * @param topicUri
+	 *            The URI or CURIE of the topic the event is to be published
+	 *            for.
+	 * @param event
+	 *            The event to be published.
+	 * @param acknowledge
+	 *            The acknowledgment to received on publication or error.
+	 */
+	public void publish(String topicUri,  boolean acknowledge,
+			Class<?> eventType, EventHandler eventHandler,Object... arguments) {
+
+		publish(topicUri,  acknowledge, new PubMeta(eventHandler,
+				eventType),arguments);
+	}
 }
diff --git a/Autobahn/src/de/tavendo/autobahn/WampMessage.java b/Autobahn/src/de/tavendo/autobahn/WampMessage.java
index b2d7f3a..44651c9 100644
--- a/Autobahn/src/de/tavendo/autobahn/WampMessage.java
+++ b/Autobahn/src/de/tavendo/autobahn/WampMessage.java
@@ -18,154 +18,399 @@
 
 package de.tavendo.autobahn;
 
+import java.util.HashMap;
 
 /**
- * The master thread and the background reader/writer threads communicate
- * using these messages for Autobahn WAMP connections.
+ * The master thread and the background reader/writer threads communicate using
+ * these messages for Autobahn WAMP connections.
  */
 public class WampMessage {
 
-   public static final int MESSAGE_TYPE_WELCOME = 0;
-   public static final int MESSAGE_TYPE_PREFIX = 1;
-   public static final int MESSAGE_TYPE_CALL = 2;
-   public static final int MESSAGE_TYPE_CALL_RESULT = 3;
-   public static final int MESSAGE_TYPE_CALL_ERROR = 4;
-   public static final int MESSAGE_TYPE_SUBSCRIBE = 5;
-   public static final int MESSAGE_TYPE_UNSUBSCRIBE = 6;
-   public static final int MESSAGE_TYPE_PUBLISH = 7;
-   public static final int MESSAGE_TYPE_EVENT = 8;
-
-
-   /// Base message class.
-   public static class Message extends WebSocketMessage.Message {
-
-   }
-
-   /**
-    * RPC request message.
-    * Client-to-server message.
-    */
-   public static class Call extends Message {
-      public String mCallId;
-      public String mProcUri;
-      public Object[] mArgs;
-
-      public Call(String callId, String procUri, int argCount) {
-         mCallId = callId;
-         mProcUri = procUri;
-         mArgs = new Object[argCount];
-      }
-   }
-
-   /**
-    * RPC success response message.
-    * Server-to-client message.
-    */
-   public static class CallResult extends Message {
-      public String mCallId;
-      public Object mResult;
-
-      public CallResult(String callId, Object result) {
-         mCallId = callId;
-         mResult = result;
-      }
-   }
-
-   /**
-    * RPC failure response message.
-    * Server-to-client message.
-    */
-   public static class CallError extends Message {
-      public String mCallId;
-      public String mErrorUri;
-      public String mErrorDesc;
-
-      public CallError(String callId, String errorUri, String errorDesc) {
-         mCallId = callId;
-         mErrorUri = errorUri;
-         mErrorDesc = errorDesc;
-      }
-   }
-
-   /**
-    * Define Welcome message.
-    * Server-to-client message.
-    */
-   public static class Welcome extends Message {
-      public String mSessionId;
-      public int mProtocolVersion;
-      public String mServerIdent;
-
-      public Welcome(String sessionId, int protocolVersion, String serverIdent) {
-         mSessionId = sessionId;
-         mProtocolVersion = protocolVersion;
-         mServerIdent = serverIdent;
-      }
-   }
-
-   /**
-    * Define CURIE message.
-    * Server-to-client and client-to-server message.
-    */
-   public static class Prefix extends Message {
-      public String mPrefix;
-      public String mUri;
-
-      public Prefix(String prefix, String uri) {
-         mPrefix = prefix;
-         mUri = uri;
-      }
-   }
-
-   /**
-    * Publish to topic URI request message.
-    * Client-to-server message.
-    */
-   public static class Publish extends Message {
-      public String mTopicUri;
-      public Object mEvent;
-
-      public Publish(String topicUri, Object event) {
-         mTopicUri = topicUri;
-         mEvent = event;
-      }
-   }
-
-   /**
-    * Subscribe to topic URI request message.
-    * Client-to-server message.
-    */
-   public static class Subscribe extends Message {
-      public String mTopicUri;
-
-      public Subscribe(String topicUri) {
-         mTopicUri = topicUri;
-      }
-   }
-
-   /**
-    * Unsubscribe from topic URI request message.
-    * Client-to-server message.
-    */
-   public static class Unsubscribe extends Message {
-      public String mTopicUri;
-
-      public Unsubscribe(String topicUri) {
-         mTopicUri = topicUri;
-      }
-   }
-
-   /**
-    * Event on topic URI message.
-    * Server-to-client message.
-    */
-   public static class Event extends Message {
-      public String mTopicUri;
-      public Object mEvent;
-
-      public Event(String topicUri, Object event) {
-         mTopicUri = topicUri;
-         mEvent = event;
-      }
-   }
+	public static final int MESSAGE_TYPE_HELLO = 1;
+	public static final int MESSAGE_TYPE_WELCOME = 2;
+	public static final int MESSAGE_TYPE_ABORT = 3;
+	public static final int MESSAGE_TYPE_CHALLENGE = 4;
+	public static final int MESSAGE_TYPE_AUTHENTICATE = 5;
+	public static final int MESSAGE_TYPE_GOODBYE = 6;
+	public static final int MESSAGE_TYPE_HEARTBEAT = 7;
+	public static final int MESSAGE_TYPE_ERROR = 8;
+	public static final int MESSAGE_TYPE_PUBLISH = 16;
+	public static final int MESSAGE_TYPE_PUBLISHED = 17;
+	public static final int MESSAGE_TYPE_SUBSCRIBE = 32;
+	public static final int MESSAGE_TYPE_SUBSCRIBED = 33;
+	public static final int MESSAGE_TYPE_UNSUBSCRIBE = 34;
+	public static final int MESSAGE_TYPE_UNSUBSCRIBED = 35;
+	public static final int MESSAGE_TYPE_EVENT = 36;
+	public static final int MESSAGE_TYPE_CALL = 48;
+	public static final int MESSAGE_TYPE_CANCEL = 49;
+	public static final int MESSAGE_TYPE_RESULT = 50;
+	public static final int MESSAGE_TYPE_REGISTER = 64;
+	public static final int MESSAGE_TYPE_REGISTERED = 65;
+	public static final int MESSAGE_TYPE_UNREGISTER = 66;
+	public static final int MESSAGE_TYPE_UNREGISTERED = 67;
+	public static final int MESSAGE_TYPE_INVOCATION = 68;
+	public static final int MESSAGE_TYPE_INTERRUPT = 69;
+	public static final int MESSAGE_TYPE_YIELD = 70;
+
+
+
+	/*
+	 * public static final int MESSAGE_TYPE_WELCOME = 0; public static final int
+	 * MESSAGE_TYPE_PREFIX = 1; public static final int MESSAGE_TYPE_CALL = 2;
+	 * public static final int MESSAGE_TYPE_CALL_RESULT = 3; public static final
+	 * int MESSAGE_TYPE_CALL_ERROR = 4; public static final int
+	 * MESSAGE_TYPE_SUBSCRIBE = 5; public static final int
+	 * MESSAGE_TYPE_UNSUBSCRIBE = 6; public static final int
+	 * MESSAGE_TYPE_PUBLISH = 7; public static final int MESSAGE_TYPE_EVENT = 8;
+	 */
+
+	// / Base message class.
+	public static class Message extends WebSocketMessage.Message {
+
+	}
+
+	
+	public static class GoodBye extends Message{
+		public HashMap<String, Object> Details; 
+		public String Reason;
+		
+		public GoodBye(HashMap<String, Object> dict, String reason)
+		{
+			Details =dict;
+			Reason = reason;
+		}
+		
+	}
+	
+	public static class Abort extends Message{
+		public HashMap<String, Object> Details; 
+		public String Reason;
+		
+		public Abort(HashMap<String, Object> dict, String reason)
+		{
+			Details =dict;
+			Reason = reason;
+		}
+		
+	}
+	
+	/**
+	 * Client to Server to initiate session.
+	 * @author arun.k
+	 *
+	 */
+	public static class Hello extends Message {
+		
+		public Details details = new Details();
+		public String realm = "realm1";
+		
+		public class Details
+		{
+			public String[] authmethods = {"anonymous","cookie"};
+			public WAMP_FEATURES roles = new WampMessage.WAMP_FEATURES();
+			
+			
+		}
+		
+		
+	}
+	
+	public static class WAMP_FEATURES
+	{
+		public Caller caller = new Caller();
+		public Callee callee = new Callee();
+		public Publisher publisher = new Publisher();
+		public Subscriber subscriber = new Subscriber();
+	}
+	
+	public static class Caller{
+		public HashMap<String, Boolean> features;
+		
+		public Caller()
+		{
+			features = new HashMap<String, Boolean>();
+			
+			features.put("caller_identification", true);
+			features.put("progressive_call_results", true);
+		}
+	}
+	
+	public static class Callee{
+		public HashMap<String, Boolean> features;
+		
+		public Callee()
+		{
+			features = new HashMap<String, Boolean>();
+			
+			features.put("progressive_call_results", true);
+		}
+	}
+	
+	public static class Publisher{
+		public HashMap<String, Boolean> features;
+		
+		public Publisher()
+		{
+			features = new HashMap<String, Boolean>();
+			
+			features.put("subscriber_blackwhite_listing", true);
+			features.put("publisher_exclusion", false);
+			features.put("publisher_identification", true);
+		}
+	}
+	
+	public static class Subscriber{
+		public HashMap<String, Boolean> features;
+		
+		public Subscriber()
+		{
+			features = new HashMap<String, Boolean>();
+			
+			features.put("publisher_identification", true);
+		}
+	}
+	
+	/**
+	 * RPC request message. Client-to-server message.
+	 */
+	public static class Call extends Message {
+		public String mCallId;
+		public String mProcUri;
+		public Object[] mArgs;
+
+		public Call(String callId, String procUri, int argCount) {
+			mCallId = callId;
+			mProcUri = procUri;
+			mArgs = new Object[argCount];
+		}
+	}
+
+	/**
+	 * RPC success response message. Server-to-client message.
+	 */
+	public static class CallResult extends Message {
+		public String mCallId;
+		public Object mResult;
+
+		public CallResult(String callId, Object result) {
+			mCallId = callId;
+			mResult = result;
+		}
+	}
+
+	/**
+	 * RPC failure response message. Server-to-client message.
+	 */
+	public static class CallError extends Message {
+		public String mCallId;
+		public String mErrorUri;
+		public String mErrorDesc;
+
+		public CallError(String callId, String errorUri, String errorDesc) {
+			mCallId = callId;
+			mErrorUri = errorUri;
+			mErrorDesc = errorDesc;
+		}
+	}
+
+	/**
+	 * Define Welcome message. Server-to-client message.
+	 */
+	public static class Welcome extends Message {
+		public String mSessionId;
+		public int mProtocolVersion;
+		public String mServerIdent;
+		public String mAuthid ;
+		public String mAuthrole;
+		public String mAuthmethod;
+		public String mAuthprovider;
+		public WampMessage.WAMP_FEATURES mRoles;
+		
+
+		public Welcome(String sessionId, int protocolVersion, String serverIdent) {
+			mSessionId = sessionId;
+			mProtocolVersion = protocolVersion;
+			mServerIdent = serverIdent;
+		}
+		
+		public Welcome(String sessionId, String authid, String authrole, String authmethod, String authprovider,WampMessage.WAMP_FEATURES roles) {
+			mSessionId = sessionId;
+			mAuthid = authid;
+			mAuthrole = authrole;
+			mAuthmethod = authmethod;
+			mAuthprovider = authprovider;
+			mRoles = roles;
+		}
+	}
+
+	/**
+	 * Define CURIE message. Server-to-client and client-to-server message.
+	 */
+	public static class Prefix extends Message {
+		public String mPrefix;
+		public String mUri;
+
+		public Prefix(String prefix, String uri) {
+			mPrefix = prefix;
+			mUri = uri;
+		}
+	}
+
+	/**
+	 * Publish to topic URI request message. Client-to-server message.
+	 */
+	public static class Publish extends Message {
+		public String mRequestId;
+		public HashMap<String, Object> mOptions;
+		public String mTopicUri;
+		public Object[] mArgs;
+		public HashMap<String, Object> mArgumentsKw;
+
+		private Publish(HashMap<String, Object> options)
+		{
+			mOptions = options;
+			if(mOptions == null )
+				mOptions = new HashMap<String, Object>();
+		}
+		
+		public Publish(String reqestId,HashMap<String, Object> options, String topicUri) {
+			this(options);
+			mRequestId = reqestId;
+			
+			mTopicUri = topicUri;		
+		}
+		
+		public Publish(String reqestId,HashMap<String, Object> options, String topicUri, Object... eventsargument) {
+			this(options);
+			mRequestId = reqestId;
+			
+			mTopicUri = topicUri;
+			
+			if(eventsargument != null){
+				mArgs = new Object[eventsargument.length];
+			for(int i=0;i<eventsargument.length ;i++)
+				mArgs[i] = eventsargument[i];
+			}
+			
+		}
+		
+		public Publish(String reqestId,HashMap<String, Object> options, String topicUri,HashMap<String, Object> arguments,Object... eventsargument) {
+			this(options);
+			mRequestId = reqestId;
+	
+			mTopicUri = topicUri;
+			if(eventsargument != null){
+				mArgs = new Object[eventsargument.length];
+			for(int i=0;i<eventsargument.length ;i++)
+				mArgs[i] = eventsargument[i];
+			}
+			mArgumentsKw = arguments;
+		}
+	}
+	
+	
+	public static class Published extends Message {
+		public String mPublicationRequestId;
+		public String mPublicationtionId;
+		
+		public Published(String requestId,String publicationId) {
+			mPublicationRequestId = requestId;
+			mPublicationtionId = publicationId;
+			
+		}
+	}
+
+	/**
+	 * Subscribe to topic URI request message. Client-to-server message.
+	 */
+	public static class Subscribe extends Message {
+		public String mRequestId;
+		public HashMap<String, Object> mOptions;
+		public String mTopicUri;
+		
+		public Subscribe(String requestId,HashMap<String, Object> dict,String topicUri) {
+			mRequestId = requestId;
+			mOptions = dict;
+			mTopicUri = topicUri;
+			
+		}
+	}
+	
+	/**
+	 * Confirmation for subscribe to topic URI request message. Server - to - client.
+	 * @author arun.k
+	 *
+	 */
+	public static class Subscribed extends Message {
+		public String mSubscribeRequestId;
+		public String mSubscriptionId;
+		
+		public Subscribed(String requestId,String subscriptionId) {
+			mSubscribeRequestId = requestId;
+			mSubscriptionId = subscriptionId;
+			
+		}
+	}
+
+	/**
+	 * Unsubscribe from topic URI request message. Client-to-server message.
+	 */
+	public static class Unsubscribe extends Message {
+		public String mRequestId;
+		public String mSubscriptionId;
+
+		public Unsubscribe(String requestid, String subscriptionid) {
+			mRequestId = requestid;
+			mSubscriptionId = subscriptionid;
+		}
+	}
+	
+	/**
+	 * Unsubscribed from topic URI request message. Server-to-Client message.
+	 */
+	public static class Unsubscribed extends Message {
+		public String mUnsubscribedRequestId;
+
+
+		public Unsubscribed(String unsubscribedRequestId) {
+			mUnsubscribedRequestId = unsubscribedRequestId;
+		}
+	}
+
+	/**
+	 * Event on topic URI message. Server-to-client message.
+	 */
+	public static class Event extends Message {
+		public String mSubscriptionId;
+		public String mPublicationId;
+		public HashMap<String, Object> mOptions;
+		public Object mEvent;
+		public HashMap<String, Object> 	mArgumentsKw;
+		public String mTopicUri;
+
+		public Event(String topicUri,String subscriptionid, String publicationid, HashMap<String, Object> Options)
+		{
+			mTopicUri = topicUri;
+			mSubscriptionId = subscriptionid;
+			mPublicationId = publicationid;
+			mOptions = Options;
+		}
+		public Event(String topicUri,String subscriptionid, String publicationid, HashMap<String, Object> Options,  Object event) {
+			
+			mTopicUri = topicUri;
+			mSubscriptionId = subscriptionid;
+			mPublicationId = publicationid;
+			mOptions = Options;
+			mEvent = event;
+		}
+		public Event(String topicUri,String subscriptionid, String publicationid, HashMap<String, Object> Options,  Object event,HashMap<String, Object> argumentskw) {
+			
+			mTopicUri = topicUri;
+			mSubscriptionId = subscriptionid;
+			mPublicationId = publicationid;
+			mOptions = Options;
+			mEvent = event;
+			mArgumentsKw = argumentskw;
+		}
+	}
 }
diff --git a/Autobahn/src/de/tavendo/autobahn/WampReader.java b/Autobahn/src/de/tavendo/autobahn/WampReader.java
index 0f3f656..1e0434d 100644
--- a/Autobahn/src/de/tavendo/autobahn/WampReader.java
+++ b/Autobahn/src/de/tavendo/autobahn/WampReader.java
@@ -20,6 +20,7 @@
 
 import java.io.IOException;
 import java.nio.channels.SocketChannel;
+import java.util.HashMap;
 import java.util.concurrent.ConcurrentHashMap;
 
 import org.codehaus.jackson.JsonFactory;
@@ -28,10 +29,12 @@
 import org.codehaus.jackson.JsonToken;
 import org.codehaus.jackson.map.DeserializationConfig;
 import org.codehaus.jackson.map.ObjectMapper;
+import org.codehaus.jackson.type.TypeReference;
 
 import android.os.Handler;
 import android.util.Log;
 import de.tavendo.autobahn.WampConnection.CallMeta;
+import de.tavendo.autobahn.WampConnection.PubMeta;
 import de.tavendo.autobahn.WampConnection.SubMeta;
 
 /**
@@ -39,219 +42,399 @@
  */
 public class WampReader extends WebSocketReader {
 
-   private static final boolean DEBUG = true;
-   private static final String TAG = WampReader.class.getName();
+	private static final boolean DEBUG = true;
+	private static final String TAG = WampReader.class.getName();
+
+	// / Jackson JSON-to-object mapper.
+	private final ObjectMapper mJsonMapper;
+
+	// / Jackson JSON factory from which we create JSON parsers.
+	private final JsonFactory mJsonFactory;
+
+	// / Holds reference to call map created on master.
+	private final ConcurrentHashMap<String, CallMeta> mCalls;
+
+	// / Holds reference to event subscription map created on master.
+	private final ConcurrentHashMap<String, SubMeta> mSubs;
+
+	// / Holds reference to event publication map created on master.
+	private final ConcurrentHashMap<String, PubMeta> mPubs;
+
+	// holds reference to request id and respective request topic.
+	private final ConcurrentHashMap<String, String> mRequestTopicMap;
+
+	/**
+	 * A reader object is created in AutobahnConnection.
+	 * 
+	 * @param calls
+	 *            The call map created on master.
+	 * @param subs
+	 *            The event subscription map created on master.
+	 * @param master
+	 *            Message handler of master (used by us to notify the master).
+	 * @param socket
+	 *            The TCP socket.
+	 * @param options
+	 *            WebSockets connection options.
+	 * @param threadName
+	 *            The thread name we announce.
+	 */
+	public WampReader(ConcurrentHashMap<String, CallMeta> calls,
+			ConcurrentHashMap<String, SubMeta> subs,
+			ConcurrentHashMap<String, PubMeta> pubs,
+			ConcurrentHashMap<String, String> reqtopicmap, Handler master,
+			SocketChannel socket, WebSocketOptions options, String threadName) {
+
+		super(master, socket, options, threadName);
+
+		mCalls = calls;
+		mSubs = subs;
+		mPubs = pubs;
+		mRequestTopicMap = reqtopicmap;
 
-   /// Jackson JSON-to-object mapper.
-   private final ObjectMapper mJsonMapper;
+		mJsonMapper = new ObjectMapper();
+		mJsonMapper
+				.configure(
+						DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES,
+						false);
+		mJsonFactory = mJsonMapper.getJsonFactory();
 
-   /// Jackson JSON factory from which we create JSON parsers.
-   private final JsonFactory mJsonFactory;
+		if (DEBUG)
+			Log.d(TAG, "created");
+	}
 
-   /// Holds reference to call map created on master.
-   private final ConcurrentHashMap<String, CallMeta> mCalls;
+	protected void onTextMessage(String payload) {
+
+		// / \todo make error propagation consistent
+		notify(new WebSocketMessage.Error(new WebSocketException(
+				"non-raw receive of text message")));
+	}
 
-   /// Holds reference to event subscription map created on master.
-   private final ConcurrentHashMap<String, SubMeta> mSubs;
+	protected void onBinaryMessage(byte[] payload) {
 
-   /**
-    * A reader object is created in AutobahnConnection.
-    *
-    * @param calls         The call map created on master.
-    * @param subs          The event subscription map created on master.
-    * @param master        Message handler of master (used by us to notify the master).
-    * @param socket        The TCP socket.
-    * @param options       WebSockets connection options.
-    * @param threadName    The thread name we announce.
-    */
-   public WampReader(ConcurrentHashMap<String, CallMeta> calls,
-                         ConcurrentHashMap<String, SubMeta> subs,
-                         Handler master,
-                         SocketChannel socket,
-                         WebSocketOptions options,
-                         String threadName) {
+		// / \todo make error propagation consistent
+		notify(new WebSocketMessage.Error(new WebSocketException(
+				"received binary message")));
+	}
+
+	/**
+	 * Unwraps a WAMP message which is a WebSockets text message with JSON
+	 * payload conforming to WAMP.
+	 */
+	protected void onRawTextMessage(byte[] payload) {
+
+		try {
+
+			// create parser on top of raw UTF-8 payload
+			JsonParser parser = mJsonFactory.createJsonParser(payload);
+			JsonToken token = null;
+
+			// all Autobahn messages are JSON arrays
+			if ((token = parser.nextToken()) == JsonToken.START_ARRAY) {
+
+				// message type
+				if ((token = parser.nextToken()) == JsonToken.VALUE_NUMBER_INT) {
+
+					int msgType = parser.getIntValue();
+
+					if (msgType == WampMessage.MESSAGE_TYPE_GOODBYE) {
+						// details
+						token = parser.nextToken();
+						HashMap<String, Object> dict = parser
+								.readValueAs(new TypeReference<HashMap<String, Object>>() {
+								});
+
+						// reason
+						token = parser.nextToken();
+						String reason = parser.getText();
+
+						notify(new WampMessage.GoodBye(dict, reason));
+
+						token = parser.nextToken();
+
+					} else if (msgType == WampMessage.MESSAGE_TYPE_ABORT) {
+						// details
+						token = parser.nextToken();
+						HashMap<String, Object> dict = parser
+								.readValueAs(new TypeReference<HashMap<String, Object>>() {
+								});
+
+						// reason
+						token = parser.nextToken();
+						String reason = parser.getText();
+
+						notify(new WampMessage.Abort(dict, reason));
+
+						token = parser.nextToken();
+
+					} else if (msgType == WampMessage.MESSAGE_TYPE_RESULT) {
+
+						// call ID
+						token = parser.nextToken();
+						String callId = parser.getText();
+
+						// result
+						token = parser.nextToken();
+						Object result = null;
+
+						if (mCalls.containsKey(callId)) {
+
+							CallMeta meta = mCalls.get(callId);
+							if (meta.mResultClass != null) {
+								result = parser.readValueAs(meta.mResultClass);
+							} else if (meta.mResultTypeRef != null) {
+								result = parser
+										.readValueAs(meta.mResultTypeRef);
+							} else {
+							}
+							notify(new WampMessage.CallResult(callId, result));
+
+						} else {
 
-      super(master, socket, options, threadName);
+							if (DEBUG)
+								Log.d(TAG,
+										"WAMP RPC success return for unknown call ID received");
+						}
 
-      mCalls = calls;
-      mSubs = subs;
+						token = parser.nextToken();
 
-      mJsonMapper = new ObjectMapper();
-      mJsonMapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false);
-      mJsonFactory = mJsonMapper.getJsonFactory();
+					} else if (msgType == WampMessage.MESSAGE_TYPE_SUBSCRIBED) {
+						// subscribe request id
+						token = parser.nextToken();
+						long requestId = parser.getLongValue();
 
-      if (DEBUG) Log.d(TAG, "created");
-   }
+						// subscription id
+						token = parser.nextToken();
+						long subscriptionid = parser.getLongValue();
 
-   protected void onTextMessage(String payload) {
+						String topicUri = mRequestTopicMap.get(String
+								.valueOf(requestId));
 
-      /// \todo make error propagation consistent
-      notify(new WebSocketMessage.Error(new WebSocketException("non-raw receive of text message")));
-   }
+						SubMeta subMeta = null;
+						if (topicUri != null)
+							subMeta = mSubs.get(topicUri);
+
+						if (subMeta != null)
+							notify(new WampMessage.Subscribed(
+									String.valueOf(requestId),
+									String.valueOf(subscriptionid)));
+						else {
+							if (DEBUG)
+								Log.d(TAG,
+										" WAMP subscription success return for unknown subscribe Id received.");
+						}
+
+						token = parser.nextToken();
+					} else if (msgType == WampMessage.MESSAGE_TYPE_UNSUBSCRIBED) {
+						// unsubscribed request id.
+						token = parser.nextToken();
+						long unsubscribedId = parser.getLongValue();
+
+						if (DEBUG)
+							Log.d(TAG,
+									" Acknowledge sent by a Broker to a Subscriber to acknowledge unsubscription : "
+											+ unsubscribedId);
+
+						token = parser.nextToken();
+					} else if (msgType == WampMessage.MESSAGE_TYPE_PUBLISHED) {
+						// subscribe request id
+						token = parser.nextToken();
+						long requestId = parser.getLongValue();
+
+						// subscription id
+						token = parser.nextToken();
+						long publicationId = parser.getLongValue();
+
+						String topicUri = mRequestTopicMap.get(String
+								.valueOf(requestId));
+
+						PubMeta pubMeta = null;
+						if (topicUri != null)
+							pubMeta = mPubs.get(topicUri);
+
+						if (pubMeta != null)
+							notify(new WampMessage.Published(
+									String.valueOf(requestId),
+									String.valueOf(publicationId)));
+						else {
+							if (DEBUG)
+								Log.d(TAG,
+										" WAMP publication success return for unknown publish Id received.");
+						}
+
+						token = parser.nextToken();
+					} else if (msgType == WampMessage.MESSAGE_TYPE_ERROR) {
+
+						// call ID
+						token = parser.nextToken();
+						String callId = parser.getText();
+
+						// error URI
+						token = parser.nextToken();
+						String errorUri = parser.getText();
+
+						// error description
+						token = parser.nextToken();
+						String errorDesc = parser.getText();
+
+						if (mCalls.containsKey(callId)) {
+
+							notify(new WampMessage.CallError(callId, errorUri,
+									errorDesc));
+
+						} else {
+
+							if (DEBUG)
+								Log.d(TAG,
+										"WAMP RPC error return for unknown call ID received");
+						}
+
+						token = parser.nextToken();
+
+					} else if (msgType == WampMessage.MESSAGE_TYPE_EVENT) {
+
+						// SUBSCRIBED.Subscription id
+						token = parser.nextToken();
+						Long subscriptionId = parser.getLongValue();
+
+						// PUBLISHED.Publication id
+						token = parser.nextToken();
+						Long publicationId = parser.getLongValue();
+
+						// read option details
+						parser.nextToken();
+						HashMap<String, Object> options = parser
+								.readValueAs(new TypeReference<HashMap<String, Object>>() {
+								});
+
+						// event
+						token = parser.nextToken();
+						Object event = null;
+
+						SubMeta meta = null;
+						String mtopicUri = null;
+						for (String topicUri : mSubs.keySet()) {
+
+							SubMeta meta0 = mSubs.get(topicUri);
+
+							if (meta0.mSubscriptionId.equals(String
+									.valueOf(subscriptionId))) {
+								meta = meta0;
+								mtopicUri = topicUri;
+								break;
+							}
+						}
+
+						if (meta != null) {
+							HashMap<String, Object> argumentkw = null;
+							if (token != null && token != JsonToken.END_ARRAY) {
+								if (meta.mEventClass != null) {
+									event = parser
+											.readValueAs(meta.mEventClass);
+								} else if (meta.mEventTypeRef != null) {
+									event = parser
+											.readValueAs(meta.mEventTypeRef);
+								} else {
+								}
 
-   protected void onBinaryMessage(byte[] payload) {
+								// read argumentskw list details								
+								token = parser.nextToken();
+								if (token != null
+										&& token != JsonToken.END_ARRAY) {
 
-      /// \todo make error propagation consistent
-      notify(new WebSocketMessage.Error(new WebSocketException("received binary message")));
-   }
+									argumentkw = parser
+											.readValueAs(new TypeReference<HashMap<String, Object>>() {
+											});
+									token = parser.nextToken();
+								}
 
-   /**
-    * Unwraps a WAMP message which is a WebSockets text message with JSON
-    * payload conforming to WAMP.
-    */
-   protected void onRawTextMessage(byte[] payload) {
+							}
 
-      try {
+							notify(new WampMessage.Event(mtopicUri,
+									String.valueOf(subscriptionId),
+									String.valueOf(publicationId), options,
+									event, argumentkw));
 
-         // create parser on top of raw UTF-8 payload
-         JsonParser parser = mJsonFactory.createJsonParser(payload);
+						} else {
 
-         // all Autobahn messages are JSON arrays
-         if (parser.nextToken() == JsonToken.START_ARRAY) {
+							if (DEBUG)
+								Log.d(TAG,
+										"WAMP event for not-subscribed topic received");
+						}
 
-            // message type
-            if (parser.nextToken() == JsonToken.VALUE_NUMBER_INT) {
+					} else if (msgType == WampMessage.MESSAGE_TYPE_WELCOME) {
 
-               int msgType = parser.getIntValue();
+						if (DEBUG)
+							Log.w(TAG, "MESSAGE_TYPE_WELCOME RECEIVED.");
+						// session ID
+						token = parser.nextToken();
+						String sessionId = parser.getText();
 
-               if (msgType == WampMessage.MESSAGE_TYPE_CALL_RESULT) {
+						// auth id
+						token = parser.nextToken();
+						String authid = parser.getText();
 
-                  // call ID
-                  parser.nextToken();
-                  String callId = parser.getText();
+						// auth method
+						token = parser.nextToken();
+						String authmethod = parser.getText();
 
-                  // result
-                  parser.nextToken();
-                  Object result = null;
+						// auth role;
+						token = parser.nextToken();
+						String authrole = parser.getText();
 
-                  if (mCalls.containsKey(callId)) {
+						// roles;
+						token = parser.nextToken();
+						WampMessage.WAMP_FEATURES roles = parser
+								.readValueAs(WampMessage.WAMP_FEATURES.class);
 
-                     CallMeta meta = mCalls.get(callId);
-                     if (meta.mResultClass != null) {
-                        result = parser.readValueAs(meta.mResultClass);
-                     } else if (meta.mResultTypeRef != null) {
-                        result = parser.readValueAs(meta.mResultTypeRef);
-                     } else {
-                     }
-                     notify(new WampMessage.CallResult(callId, result));
+						notify(new WampMessage.Welcome(sessionId, authid,
+								authmethod, "", authrole, roles));
 
-                  } else {
+						token = parser.nextToken();
 
-                     if (DEBUG) Log.d(TAG, "WAMP RPC success return for unknown call ID received");
-                  }
+					} else {
 
-               } else if (msgType == WampMessage.MESSAGE_TYPE_CALL_ERROR) {
+						// FIXME: invalid WAMP message
+						if (DEBUG)
+							Log.d(TAG,
+									"invalid WAMP message: unrecognized message type");
 
-                  // call ID
-                  parser.nextToken();
-                  String callId = parser.getText();
+					}
+				} else {
 
-                  // error URI
-                  parser.nextToken();
-                  String errorUri = parser.getText();
+					if (DEBUG)
+						Log.d(TAG,
+								"invalid WAMP message: missing message type or message type not an integer");
+				}
 
-                  // error description
-                  parser.nextToken();
-                  String errorDesc = parser.getText();
+				if (token == JsonToken.END_ARRAY) {
 
-                  if (mCalls.containsKey(callId)) {
+					// nothing to do here
 
-                     notify(new WampMessage.CallError(callId, errorUri, errorDesc));
+				} else {
 
-                  } else {
+					if (DEBUG)
+						Log.d(TAG,
+								"invalid WAMP message: missing array close or invalid additional args");
+				}
 
-                     if (DEBUG) Log.d(TAG, "WAMP RPC error return for unknown call ID received");
-                  }
+			} else {
 
-               } else if (msgType == WampMessage.MESSAGE_TYPE_EVENT) {
+				if (DEBUG)
+					Log.d(TAG, "invalid WAMP message: not an array");
+			}
+			parser.close();
 
-                  // topic URI
-                  parser.nextToken();
-                  String topicUri = parser.getText();
+		} catch (JsonParseException e) {
 
-                  // event
-                  parser.nextToken();
-                  Object event = null;
+			if (DEBUG)
+				e.printStackTrace();
 
-                  if (mSubs.containsKey(topicUri)) {
+		} catch (IOException e) {
 
-                     SubMeta meta = mSubs.get(topicUri);
-                     if (meta.mEventClass != null) {
-                        event = parser.readValueAs(meta.mEventClass);
-                     } else if (meta.mEventTypeRef != null) {
-                        event = parser.readValueAs(meta.mEventTypeRef);
-                     } else {
-                     }
-                     notify(new WampMessage.Event(topicUri, event));
+			if (DEBUG)
+				e.printStackTrace();
 
-                  } else {
-
-                     if (DEBUG) Log.d(TAG, "WAMP event for not-subscribed topic received");
-                  }
-
-               } else if (msgType == WampMessage.MESSAGE_TYPE_PREFIX) {
-
-                  // prefix
-                  parser.nextToken();
-                  String prefix = parser.getText();
-
-                  // URI
-                  parser.nextToken();
-                  String uri = parser.getText();
-
-                  notify(new WampMessage.Prefix(prefix, uri));
-
-               } else if (msgType == WampMessage.MESSAGE_TYPE_WELCOME) {
-
-                  // session ID
-                  parser.nextToken();
-                  String sessionId = parser.getText();
-
-                  // protocol version
-                  parser.nextToken();
-                  int protocolVersion = parser.getIntValue();
-
-                  // server ident
-                  parser.nextToken();
-                  String serverIdent = parser.getText();
-
-                  notify(new WampMessage.Welcome(sessionId, protocolVersion, serverIdent));
-
-               } else {
-
-                  // FIXME: invalid WAMP message
-                  if (DEBUG) Log.d(TAG, "invalid WAMP message: unrecognized message type");
-
-               }
-            } else {
-
-               if (DEBUG) Log.d(TAG, "invalid WAMP message: missing message type or message type not an integer");
-            }
-
-            if (parser.nextToken() == JsonToken.END_ARRAY) {
-
-               // nothing to do here
-
-            } else {
-
-               if (DEBUG) Log.d(TAG, "invalid WAMP message: missing array close or invalid additional args");
-            }
-
-         } else {
-
-            if (DEBUG) Log.d(TAG, "invalid WAMP message: not an array");
-         }
-         parser.close();
-
-
-      } catch (JsonParseException e) {
-
-         if (DEBUG) e.printStackTrace();
-
-      } catch (IOException e) {
-
-         if (DEBUG) e.printStackTrace();
-
-      }
-   }
+		}
+	}
 }
diff --git a/Autobahn/src/de/tavendo/autobahn/WampWriter.java b/Autobahn/src/de/tavendo/autobahn/WampWriter.java
index 29f5da4..97331b2 100644
--- a/Autobahn/src/de/tavendo/autobahn/WampWriter.java
+++ b/Autobahn/src/de/tavendo/autobahn/WampWriter.java
@@ -102,13 +102,13 @@ protected void processAppMessage(Object msg) throws WebSocketException, IOExcept
 
          } else if (msg instanceof WampMessage.Prefix) {
 
-            WampMessage.Prefix prefix = (WampMessage.Prefix) msg;
+           /* WampMessage.Prefix prefix = (WampMessage.Prefix) msg;
 
             generator.writeStartArray();
             generator.writeNumber(WampMessage.MESSAGE_TYPE_PREFIX);
             generator.writeString(prefix.mPrefix);
             generator.writeString(prefix.mUri);
-            generator.writeEndArray();
+            generator.writeEndArray();*/
 
          } else if (msg instanceof WampMessage.Subscribe) {
 
@@ -116,6 +116,8 @@ protected void processAppMessage(Object msg) throws WebSocketException, IOExcept
 
             generator.writeStartArray();
             generator.writeNumber(WampMessage.MESSAGE_TYPE_SUBSCRIBE);
+            generator.writeNumber(Long.valueOf(subscribe.mRequestId));
+            generator.writeObject(subscribe.mOptions);
             generator.writeString(subscribe.mTopicUri);
             generator.writeEndArray();
 
@@ -125,7 +127,8 @@ protected void processAppMessage(Object msg) throws WebSocketException, IOExcept
 
             generator.writeStartArray();
             generator.writeNumber(WampMessage.MESSAGE_TYPE_UNSUBSCRIBE);
-            generator.writeString(unsubscribe.mTopicUri);
+            generator.writeNumber(Long.valueOf(unsubscribe.mRequestId));
+            generator.writeNumber(Long.valueOf(unsubscribe.mSubscriptionId));
             generator.writeEndArray();
 
          } else if (msg instanceof WampMessage.Publish) {
@@ -134,11 +137,36 @@ protected void processAppMessage(Object msg) throws WebSocketException, IOExcept
 
             generator.writeStartArray();
             generator.writeNumber(WampMessage.MESSAGE_TYPE_PUBLISH);
+            generator.writeNumber(Long.valueOf(publish.mRequestId));
+            generator.writeObject(publish.mOptions);
             generator.writeString(publish.mTopicUri);
-            generator.writeObject(publish.mEvent);
+            if(publish.mArgs != null){
+             	generator.writeObject(publish.mArgs);
+            }
+            if(publish.mArgumentsKw != null)
+                generator.writeObject(publish.mArgumentsKw);
             generator.writeEndArray();
 
-         } else {
+         }
+         else if(msg instanceof WampMessage.Hello)
+         {
+        	 WampMessage.Hello hello = (WampMessage.Hello)msg;
+        	  generator.writeStartArray();
+              generator.writeNumber(WampMessage.MESSAGE_TYPE_HELLO);
+              generator.writeString(hello.realm);
+              generator.writeObject(hello.details);
+              generator.writeEndArray();
+         } 
+         else if(msg instanceof WampMessage.GoodBye)
+         {
+        	 WampMessage.GoodBye goodbye = (WampMessage.GoodBye)msg;
+        	  generator.writeStartArray();
+              generator.writeNumber(WampMessage.MESSAGE_TYPE_GOODBYE);
+              generator.writeObject(goodbye.Details);
+              generator.writeString(goodbye.Reason);             
+              generator.writeEndArray();
+         } 
+         else {
 
             // this should not happen, but to be sure
             throw new WebSocketException("invalid message received by AutobahnWriter");
@@ -161,6 +189,7 @@ protected void processAppMessage(Object msg) throws WebSocketException, IOExcept
       // a text message frame using the raw sendFrame() method
       sendFrame(1, true, mPayload.getByteArray(), 0, mPayload.size());
 
+      
       // cleanup generators resources
       generator.close();
    }
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java b/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java
index 3790240..0a11368 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java
@@ -114,6 +114,7 @@ public void run() {
 					mWriter.forward(hs);
 
 					mPrevConnected = true;
+					
 
 				} catch (Exception e) {
 					onClose(WebSocketConnectionHandler.CLOSE_INTERNAL_ERROR,
@@ -453,6 +454,9 @@ public void handleMessage(Message msg) {
                     } else {
                        if (DEBUG) Log.d(TAG, "could not call onOpen() .. handler already NULL");
                     }
+            	   
+            	   //
+            	   //send hello message
                }
 
             } else if (msg.obj instanceof WebSocketMessage.ConnectionLost) {
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketReader.java b/Autobahn/src/de/tavendo/autobahn/WebSocketReader.java
index 8683df7..3360c81 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketReader.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketReader.java
@@ -31,563 +31,607 @@
 import android.util.Pair;
 
 /**
- * WebSocket reader, the receiving leg of a WebSockets connection.
- * This runs on it's own background thread and posts messages to master
- * thread's message queue for there to be consumed by the application.
- * The only method that needs to be called (from foreground thread) is quit(),
- * which gracefully shuts down the background receiver thread.
+ * WebSocket reader, the receiving leg of a WebSockets connection. This runs on
+ * it's own background thread and posts messages to master thread's message
+ * queue for there to be consumed by the application. The only method that needs
+ * to be called (from foreground thread) is quit(), which gracefully shuts down
+ * the background receiver thread.
  */
 public class WebSocketReader extends Thread {
 
-   private static final boolean DEBUG = true;
-   private static final String TAG = WebSocketReader.class.getName();
+	private static final boolean DEBUG = true;
+	private static final String TAG = WebSocketReader.class.getName();
+
+	private final Handler mMaster;
+	private final SocketChannel mSocket;
+	private final WebSocketOptions mOptions;
+
+	private final ByteBuffer mFrameBuffer;
+	private NoCopyByteArrayOutputStream mMessagePayload;
+
+	private final static int STATE_CLOSED = 0;
+	private final static int STATE_CONNECTING = 1;
+	private final static int STATE_CLOSING = 2;
+	private final static int STATE_OPEN = 3;
+
+	private boolean mStopped = false;
+	private int mState;
+
+	private boolean mInsideMessage = false;
+	private int mMessageOpcode;
+
+	// / Frame currently being received.
+	private FrameHeader mFrameHeader;
+
+	private Utf8Validator mUtf8Validator = new Utf8Validator();
+
+	/**
+	 * WebSockets frame metadata.
+	 */
+	private static class FrameHeader {
+		public int mOpcode;
+		public boolean mFin;
+		@SuppressWarnings("unused")
+		public int mReserved;
+		public int mHeaderLen;
+		public int mPayloadLen;
+		public int mTotalLen;
+		public byte[] mMask;
+	}
+
+	/**
+	 * Create new WebSockets background reader.
+	 * 
+	 * @param master
+	 *            The message handler of master (foreground thread).
+	 * @param socket
+	 *            The socket channel created on foreground thread.
+	 */
+	public WebSocketReader(Handler master, SocketChannel socket,
+			WebSocketOptions options, String threadName) {
+
+		super(threadName);
+
+		mMaster = master;
+		mSocket = socket;
+		mOptions = options;
+
+		mFrameBuffer = ByteBuffer.allocateDirect(options
+				.getMaxFramePayloadSize() + 14);
+		mMessagePayload = new NoCopyByteArrayOutputStream(
+				options.getMaxMessagePayloadSize());
+
+		mFrameHeader = null;
+		mState = STATE_CONNECTING;
+
+		if (DEBUG)
+			Log.d(TAG, "created");
+	}
+
+	/**
+	 * Graceful shutdown of background reader thread (called from master).
+	 */
+	public void quit() {
+		mState = STATE_CLOSED;
+		if (DEBUG)
+			Log.d(TAG, "quit");
+	}
+
+	/**
+	 * Notify the master (foreground thread) of WebSockets message received and
+	 * unwrapped.
+	 * 
+	 * @param message
+	 *            Message to send to master.
+	 */
+	protected void notify(Object message) {
+
+		Message msg = mMaster.obtainMessage();
+		msg.obj = message;
+		mMaster.sendMessage(msg);
+	}
+
+	/**
+	 * Process incoming WebSockets data (after handshake).
+	 */
+	private boolean processData() throws Exception {
+
+		// outside frame?
+		if (mFrameHeader == null) {
+
+		
+
+			// need at least 2 bytes from WS frame header to start processing
+			if (mFrameBuffer.position() >= 2) {
+
+				byte b0 = mFrameBuffer.get(0);
+				boolean fin = (b0 & 0x80) != 0;
+				int rsv = (b0 & 0x70) >> 4;
+				int opcode = b0 & 0x0f;
+
+				byte b1 = mFrameBuffer.get(1);
+				boolean masked = (b1 & 0x80) != 0;
+				int payload_len1 = b1 & 0x7f;
+
+				// now check protocol compliance
+
+				if (rsv != 0) {
+					throw new WebSocketException(
+							"RSV != 0 and no extension negotiated");
+				}
+
+				if (masked) {
+					// currently, we don't allow this. need to see whats the
+					// final spec.
+					throw new WebSocketException("masked server frame");
+				}
+
+				if (opcode > 7) {
+					// control frame
+					if (!fin) {
+						throw new WebSocketException("fragmented control frame");
+					}
+					if (payload_len1 > 125) {
+						throw new WebSocketException(
+								"control frame with payload length > 125 octets");
+					}
+					if (opcode != 8 && opcode != 9 && opcode != 10) {
+						throw new WebSocketException(
+								"control frame using reserved opcode " + opcode);
+					}
+					if (opcode == 8 && payload_len1 == 1) {
+						throw new WebSocketException(
+								"received close control frame with payload len 1");
+					}
+				} else {
+					// message frame
+					if (opcode != 0 && opcode != 1 && opcode != 2) {
+						throw new WebSocketException(
+								"data frame using reserved opcode " + opcode);
+					}
+					if (!mInsideMessage && opcode == 0) {
+						throw new WebSocketException(
+								"received continuation data frame outside fragmented message");
+					}
+					if (mInsideMessage && opcode != 0) {
+						throw new WebSocketException(
+								"received non-continuation data frame while inside fragmented message");
+					}
+				}
+
+				int mask_len = masked ? 4 : 0;
+				int header_len = 0;
+
+				if (payload_len1 < 126) {
+					header_len = 2 + mask_len;
+				} else if (payload_len1 == 126) {
+					header_len = 2 + 2 + mask_len;
+				} else if (payload_len1 == 127) {
+					header_len = 2 + 8 + mask_len;
+				} else {
+					// should not arrive here
+					throw new Exception("logic error");
+				}
+
+				// continue when complete frame header is available
+				if (mFrameBuffer.position() >= header_len) {
+
+					// determine frame payload length
+					int i = 2;
+					long payload_len = 0;
+					if (payload_len1 == 126) {
+						payload_len = ((0xff & mFrameBuffer.get(i)) << 8)
+								| (0xff & mFrameBuffer.get(i + 1));
+						if (payload_len < 126) {
+							throw new WebSocketException(
+									"invalid data frame length (not using minimal length encoding)");
+						}
+						i += 2;
+					} else if (payload_len1 == 127) {
+						if ((0x80 & mFrameBuffer.get(i + 0)) != 0) {
+							throw new WebSocketException(
+									"invalid data frame length (> 2^63)");
+						}
+						payload_len = ((long) (0xff & mFrameBuffer.get(i + 0)) << 56)
+								| ((long) (0xff & mFrameBuffer.get(i + 1)) << 48)
+								| ((long) (0xff & mFrameBuffer.get(i + 2)) << 40)
+								| ((long) (0xff & mFrameBuffer.get(i + 3)) << 32)
+								| ((long) (0xff & mFrameBuffer.get(i + 4)) << 24)
+								| ((long) (0xff & mFrameBuffer.get(i + 5)) << 16)
+								| ((long) (0xff & mFrameBuffer.get(i + 6)) << 8)
+								| ((long) (0xff & mFrameBuffer.get(i + 7)));
+						if (payload_len < 65536) {
+							throw new WebSocketException(
+									"invalid data frame length (not using minimal length encoding)");
+						}
+						i += 8;
+					} else {
+						payload_len = payload_len1;
+					}
+
+					// immediately bail out on frame too large
+					if (payload_len > mOptions.getMaxFramePayloadSize()) {
+						throw new WebSocketException("frame payload too large");
+					}
+
+					// save frame header metadata
+					mFrameHeader = new FrameHeader();
+					mFrameHeader.mOpcode = opcode;
+					mFrameHeader.mFin = fin;
+					mFrameHeader.mReserved = rsv;
+					mFrameHeader.mPayloadLen = (int) payload_len;
+					mFrameHeader.mHeaderLen = header_len;
+					mFrameHeader.mTotalLen = mFrameHeader.mHeaderLen
+							+ mFrameHeader.mPayloadLen;
+					if (masked) {
+						mFrameHeader.mMask = new byte[4];
+						for (int j = 0; j < 4; ++j) {
+							mFrameHeader.mMask[i] = (byte) (0xff & mFrameBuffer
+									.get(i + j));
+						}
+						i += 4;
+					} else {
+						mFrameHeader.mMask = null;
+					}
+
+					// continue processing when payload empty or completely
+					// buffered
+					return mFrameHeader.mPayloadLen == 0
+							|| mFrameBuffer.position() >= mFrameHeader.mTotalLen;
+
+				} else {
+
+					// need more data
+					return false;
+				}
+			} else {
+
+				// need more data
+				return false;
+			}
+
+		} else {
+
+			// / \todo refactor this for streaming processing, incl. fail fast
+			// on invalid UTF-8 within frame already
+
+			// within frame
+
+			// see if we buffered complete frame
+			if (mFrameBuffer.position() >= mFrameHeader.mTotalLen) {
+
+				// cut out frame payload
+				byte[] framePayload = null;
+				int oldPosition = mFrameBuffer.position();
+				if (mFrameHeader.mPayloadLen > 0) {
+					framePayload = new byte[mFrameHeader.mPayloadLen];
+					mFrameBuffer.position(mFrameHeader.mHeaderLen);
+					mFrameBuffer.get(framePayload, 0,
+							(int) mFrameHeader.mPayloadLen);
+				}
+				mFrameBuffer.position(mFrameHeader.mTotalLen);
+				mFrameBuffer.limit(oldPosition);
+				mFrameBuffer.compact();
+
+				if (mFrameHeader.mOpcode > 7) {
+					// control frame
+
+					if (mFrameHeader.mOpcode == 8) {
+
+						int code = 1005; // CLOSE_STATUS_CODE_NULL : no status
+											// code received
+						String reason = null;
+
+						if (mFrameHeader.mPayloadLen >= 2) {
+
+							// parse and check close code - see
+							// http://tools.ietf.org/html/rfc6455#section-7.4
+							code = (framePayload[0] & 0xff) * 256
+									+ (framePayload[1] & 0xff);
+							if (code < 1000
+									|| (code >= 1000 && code <= 2999
+											&& code != 1000 && code != 1001
+											&& code != 1002 && code != 1003
+											&& code != 1007 && code != 1008
+											&& code != 1009 && code != 1010 && code != 1011)
+									|| code >= 5000) {
+
+								throw new WebSocketException(
+										"invalid close code " + code);
+							}
+
+							// parse and check close reason
+							if (mFrameHeader.mPayloadLen > 2) {
+
+								byte[] ra = new byte[mFrameHeader.mPayloadLen - 2];
+								System.arraycopy(framePayload, 2, ra, 0,
+										mFrameHeader.mPayloadLen - 2);
+
+								Utf8Validator val = new Utf8Validator();
+								val.validate(ra);
+								if (!val.isValid()) {
+									throw new WebSocketException(
+											"invalid close reasons (not UTF-8)");
+								} else {
+									reason = new String(ra, "UTF-8");
+								}
+							}
+						}
+						onClose(code, reason);
+
+					} else if (mFrameHeader.mOpcode == 9) {
+						// dispatch WS ping
+						onPing(framePayload);
+
+					} else if (mFrameHeader.mOpcode == 10) {
+						// dispatch WS pong
+						onPong(framePayload);
+
+					} else {
+
+						// should not arrive here (handled before)
+						throw new Exception("logic error");
+					}
+
+				} else {
+					// message frame
+
+					if (!mInsideMessage) {
+						// new message started
+						mInsideMessage = true;
+						mMessageOpcode = mFrameHeader.mOpcode;
+						if (mMessageOpcode == 1
+								&& mOptions.getValidateIncomingUtf8()) {
+							mUtf8Validator.reset();
+						}
+					}
+
+					if (framePayload != null) {
+
+						// immediately bail out on message too large
+						if (mMessagePayload.size() + framePayload.length > mOptions
+								.getMaxMessagePayloadSize()) {
+							throw new WebSocketException(
+									"message payload too large");
+						}
+
+						// validate incoming UTF-8
+						if (mMessageOpcode == 1
+								&& mOptions.getValidateIncomingUtf8()
+								&& !mUtf8Validator.validate(framePayload)) {
+							throw new WebSocketException(
+									"invalid UTF-8 in text message payload");
+						}
+
+						// buffer frame payload for message
+						mMessagePayload.write(framePayload);
+					}
+
+					// on final frame ..
+					if (mFrameHeader.mFin) {
+
+						if (mMessageOpcode == 1) {
+
+							// verify that UTF-8 ends on codepoint
+							if (mOptions.getValidateIncomingUtf8()
+									&& !mUtf8Validator.isValid()) {
+								throw new WebSocketException(
+										"UTF-8 text message payload ended within Unicode code point");
+							}
+
+							// deliver text message
+							if (mOptions.getReceiveTextMessagesRaw()) {
+
+								// dispatch WS text message as raw (but
+								// validated) UTF-8
+								onRawTextMessage(mMessagePayload.toByteArray());
+
+							} else {
+
+								// dispatch WS text message as Java String
+								// (previously already validated)
+								String s = new String(
+										mMessagePayload.toByteArray(), "UTF-8");
+								onTextMessage(s);
+							}
+
+						} else if (mMessageOpcode == 2) {
+
+							// dispatch WS binary message
+							onBinaryMessage(mMessagePayload.toByteArray());
+
+						} else {
+
+							// should not arrive here (handled before)
+							throw new Exception("logic error");
+						}
+
+						// ok, message completed - reset all
+						mInsideMessage = false;
+						mMessagePayload.reset();
+					}
+				}
+
+				// reset frame
+				mFrameHeader = null;
+
+				// reprocess if more data left
+				return mFrameBuffer.position() > 0;
 
-   private final Handler mMaster;
-   private final SocketChannel mSocket;
-   private final WebSocketOptions mOptions;
-
-   private final ByteBuffer mFrameBuffer;
-   private NoCopyByteArrayOutputStream mMessagePayload;
-
-   private final static int STATE_CLOSED = 0;
-   private final static int STATE_CONNECTING = 1;
-   private final static int STATE_CLOSING = 2;
-   private final static int STATE_OPEN = 3;
-
-   private boolean mStopped = false;
-   private int mState;
-
-   private boolean mInsideMessage = false;
-   private int mMessageOpcode;
-
-   /// Frame currently being received.
-   private FrameHeader mFrameHeader;
-
-   private Utf8Validator mUtf8Validator = new Utf8Validator();
-
-
-   /**
-    * WebSockets frame metadata.
-    */
-   private static class FrameHeader {
-      public int mOpcode;
-      public boolean mFin;
-      @SuppressWarnings("unused")
-      public int mReserved;
-      public int mHeaderLen;
-      public int mPayloadLen;
-      public int mTotalLen;
-      public byte[] mMask;
-   }
-
-
-   /**
-    * Create new WebSockets background reader.
-    *
-    * @param master    The message handler of master (foreground thread).
-    * @param socket    The socket channel created on foreground thread.
-    */
-   public WebSocketReader(Handler master, SocketChannel socket, WebSocketOptions options, String threadName) {
-
-      super(threadName);
-
-      mMaster = master;
-      mSocket = socket;
-      mOptions = options;
-
-      mFrameBuffer = ByteBuffer.allocateDirect(options.getMaxFramePayloadSize() + 14);
-      mMessagePayload = new NoCopyByteArrayOutputStream(options.getMaxMessagePayloadSize());
-
-      mFrameHeader = null;
-      mState = STATE_CONNECTING;
-
-      if (DEBUG) Log.d(TAG, "created");
-   }
-
-
-   /**
-    * Graceful shutdown of background reader thread (called from master).
-    */
-   public void quit() {
-      mState = STATE_CLOSED;
-      if (DEBUG) Log.d(TAG, "quit");
-   }
-
-
-   /**
-    * Notify the master (foreground thread) of WebSockets message received
-    * and unwrapped.
-    *
-    * @param message       Message to send to master.
-    */
-   protected void notify(Object message) {
-
-      Message msg = mMaster.obtainMessage();
-      msg.obj = message;
-      mMaster.sendMessage(msg);
-   }
-
-
-   /**
-    * Process incoming WebSockets data (after handshake).
-    */
-   private boolean processData() throws Exception {
-
-      // outside frame?
-      if (mFrameHeader == null) {
-
-         // need at least 2 bytes from WS frame header to start processing
-         if (mFrameBuffer.position() >= 2) {
-
-            byte b0 = mFrameBuffer.get(0);
-            boolean fin = (b0 & 0x80) != 0;
-            int rsv = (b0 & 0x70) >> 4;
-            int opcode = b0 & 0x0f;
-
-            byte b1 = mFrameBuffer.get(1);
-            boolean masked = (b1 & 0x80) != 0;
-            int payload_len1 = b1 & 0x7f;
-
-            // now check protocol compliance
-
-            if (rsv != 0) {
-               throw new WebSocketException("RSV != 0 and no extension negotiated");
-            }
-
-            if (masked) {
-               // currently, we don't allow this. need to see whats the final spec.
-               throw new WebSocketException("masked server frame");
-            }
-
-            if (opcode > 7) {
-               // control frame
-               if (!fin) {
-                  throw new WebSocketException("fragmented control frame");
-               }
-               if (payload_len1 > 125) {
-                  throw new WebSocketException("control frame with payload length > 125 octets");
-               }
-               if (opcode != 8 && opcode != 9 && opcode != 10) {
-                  throw new WebSocketException("control frame using reserved opcode " + opcode);
-               }
-               if (opcode == 8 && payload_len1 == 1) {
-                  throw new WebSocketException("received close control frame with payload len 1");
-               }
-            } else {
-               // message frame
-               if (opcode != 0 && opcode != 1 && opcode != 2) {
-                  throw new WebSocketException("data frame using reserved opcode " + opcode);
-               }
-               if (!mInsideMessage && opcode == 0) {
-                  throw new WebSocketException("received continuation data frame outside fragmented message");
-               }
-               if (mInsideMessage && opcode != 0) {
-                  throw new WebSocketException("received non-continuation data frame while inside fragmented message");
-               }
-            }
-
-            int mask_len = masked ? 4 : 0;
-            int header_len = 0;
-
-            if (payload_len1 < 126) {
-               header_len = 2 + mask_len;
-            } else if (payload_len1 == 126) {
-               header_len = 2 + 2 + mask_len;
-            } else if (payload_len1 == 127) {
-               header_len = 2 + 8 + mask_len;
-            } else {
-               // should not arrive here
-               throw new Exception("logic error");
-            }
-
-            // continue when complete frame header is available
-            if (mFrameBuffer.position() >= header_len) {
-
-               // determine frame payload length
-               int i = 2;
-               long payload_len = 0;
-               if (payload_len1 == 126) {
-                  payload_len = ((0xff & mFrameBuffer.get(i)) << 8) | (0xff & mFrameBuffer.get(i+1));
-                  if (payload_len < 126) {
-                     throw new WebSocketException("invalid data frame length (not using minimal length encoding)");
-                  }
-                  i += 2;
-               } else if (payload_len1 == 127) {
-                  if ((0x80 & mFrameBuffer.get(i+0)) != 0) {
-                     throw new WebSocketException("invalid data frame length (> 2^63)");
-                  }
-                  payload_len = ((long)(0xff & mFrameBuffer.get(i+0)) << 56) |
-                                ((long)(0xff & mFrameBuffer.get(i+1)) << 48) |
-                                ((long)(0xff & mFrameBuffer.get(i+2)) << 40) |
-                                ((long)(0xff & mFrameBuffer.get(i+3)) << 32) |
-                                ((long)(0xff & mFrameBuffer.get(i+4)) << 24) |
-                                ((long)(0xff & mFrameBuffer.get(i+5)) << 16) |
-                                ((long)(0xff & mFrameBuffer.get(i+6)) <<  8) |
-                                ((long)(0xff & mFrameBuffer.get(i+7))      );
-                  if (payload_len < 65536) {
-                     throw new WebSocketException("invalid data frame length (not using minimal length encoding)");
-                  }
-                  i += 8;
-               } else {
-                  payload_len = payload_len1;
-               }
-
-               // immediately bail out on frame too large
-               if (payload_len > mOptions.getMaxFramePayloadSize()) {
-                  throw new WebSocketException("frame payload too large");
-               }
-
-               // save frame header metadata
-               mFrameHeader = new FrameHeader();
-               mFrameHeader.mOpcode = opcode;
-               mFrameHeader.mFin = fin;
-               mFrameHeader.mReserved = rsv;
-               mFrameHeader.mPayloadLen = (int) payload_len;
-               mFrameHeader.mHeaderLen = header_len;
-               mFrameHeader.mTotalLen = mFrameHeader.mHeaderLen + mFrameHeader.mPayloadLen;
-               if (masked) {
-                  mFrameHeader.mMask = new byte[4];
-                  for (int j = 0; j < 4; ++j) {
-                     mFrameHeader.mMask[i] = (byte) (0xff & mFrameBuffer.get(i + j));
-                  }
-                  i += 4;
-               } else {
-                  mFrameHeader.mMask = null;
-               }
-
-               // continue processing when payload empty or completely buffered
-               return mFrameHeader.mPayloadLen == 0 || mFrameBuffer.position() >= mFrameHeader.mTotalLen;
-
-            } else {
-
-               // need more data
-               return false;
-            }
-         } else {
-
-            // need more data
-            return false;
-         }
-
-      } else {
-
-         /// \todo refactor this for streaming processing, incl. fail fast on invalid UTF-8 within frame already
-
-         // within frame
-
-         // see if we buffered complete frame
-         if (mFrameBuffer.position() >= mFrameHeader.mTotalLen) {
-
-            // cut out frame payload
-            byte[] framePayload = null;
-            int oldPosition = mFrameBuffer.position();
-            if (mFrameHeader.mPayloadLen > 0) {
-               framePayload = new byte[mFrameHeader.mPayloadLen];
-               mFrameBuffer.position(mFrameHeader.mHeaderLen);
-               mFrameBuffer.get(framePayload, 0, (int) mFrameHeader.mPayloadLen);
-            }
-            mFrameBuffer.position(mFrameHeader.mTotalLen);
-            mFrameBuffer.limit(oldPosition);
-            mFrameBuffer.compact();
-
-            if (mFrameHeader.mOpcode > 7) {
-               // control frame
-
-               if (mFrameHeader.mOpcode == 8) {
-
-                  int code = 1005; // CLOSE_STATUS_CODE_NULL : no status code received
-                  String reason = null;
-
-                  if (mFrameHeader.mPayloadLen >= 2) {
-
-                     // parse and check close code - see http://tools.ietf.org/html/rfc6455#section-7.4
-                     code = (framePayload[0] & 0xff) * 256 + (framePayload[1] & 0xff);
-                     if (code < 1000
-                           || (code >= 1000 && code <= 2999 &&
-                               code != 1000 && code != 1001 && code != 1002 && code != 1003 && code != 1007 && code != 1008 && code != 1009 && code != 1010 && code != 1011)
-                           || code >= 5000) {
-
-                        throw new WebSocketException("invalid close code " + code);
-                     }
-
-                     // parse and check close reason
-                     if (mFrameHeader.mPayloadLen > 2) {
-
-                        byte[] ra = new byte[mFrameHeader.mPayloadLen - 2];
-                        System.arraycopy(framePayload, 2, ra, 0, mFrameHeader.mPayloadLen - 2);
-
-                        Utf8Validator val = new Utf8Validator();
-                        val.validate(ra);
-                        if (!val.isValid()) {
-                           throw new WebSocketException("invalid close reasons (not UTF-8)");
-                        } else {
-                           reason = new String(ra, "UTF-8");
-                        }
-                     }
-                  }
-                  onClose(code, reason);
-
-               } else if (mFrameHeader.mOpcode == 9) {
-                  // dispatch WS ping
-                  onPing(framePayload);
-
-               } else if (mFrameHeader.mOpcode == 10) {
-                  // dispatch WS pong
-                  onPong(framePayload);
-
-               } else {
-
-                  // should not arrive here (handled before)
-                  throw new Exception("logic error");
-               }
-
-            } else {
-               // message frame
-
-               if (!mInsideMessage) {
-                  // new message started
-                  mInsideMessage = true;
-                  mMessageOpcode = mFrameHeader.mOpcode;
-                  if (mMessageOpcode == 1 && mOptions.getValidateIncomingUtf8()) {
-                     mUtf8Validator.reset();
-                  }
-               }
-
-               if (framePayload != null) {
-
-                  // immediately bail out on message too large
-                  if (mMessagePayload.size() + framePayload.length > mOptions.getMaxMessagePayloadSize()) {
-                     throw new WebSocketException("message payload too large");
-                  }
-
-                  // validate incoming UTF-8
-                  if (mMessageOpcode == 1 && mOptions.getValidateIncomingUtf8() && !mUtf8Validator.validate(framePayload)) {
-                     throw new WebSocketException("invalid UTF-8 in text message payload");
-                  }
-
-                  // buffer frame payload for message
-                  mMessagePayload.write(framePayload);
-               }
-
-               // on final frame ..
-               if (mFrameHeader.mFin) {
-
-                  if (mMessageOpcode == 1) {
-
-                     // verify that UTF-8 ends on codepoint
-                     if (mOptions.getValidateIncomingUtf8() && !mUtf8Validator.isValid()) {
-                        throw new WebSocketException("UTF-8 text message payload ended within Unicode code point");
-                     }
-
-                     // deliver text message
-                     if (mOptions.getReceiveTextMessagesRaw()) {
-
-                        // dispatch WS text message as raw (but validated) UTF-8
-                        onRawTextMessage(mMessagePayload.toByteArray());
-
-                     } else {
-
-                        // dispatch WS text message as Java String (previously already validated)
-                        String s = new String(mMessagePayload.toByteArray(), "UTF-8");
-                        onTextMessage(s);
-                     }
-
-                  } else if (mMessageOpcode == 2) {
-
-                     // dispatch WS binary message
-                     onBinaryMessage(mMessagePayload.toByteArray());
-
-                  } else {
-
-                     // should not arrive here (handled before)
-                     throw new Exception("logic error");
-                  }
-
-                  // ok, message completed - reset all
-                  mInsideMessage = false;
-                  mMessagePayload.reset();
-               }
-            }
-
-            // reset frame
-            mFrameHeader = null;
-
-            // reprocess if more data left
-            return mFrameBuffer.position() > 0;
-
-         } else {
-
-            // need more data
-            return false;
-         }
-      }
-   }
-
-
-   /**
-    * WebSockets handshake reply from server received, default notifies master.
-    * 
-    * @param success	Success handshake flag
-    */
-   protected void onHandshake(boolean success) {
-
-      notify(new WebSocketMessage.ServerHandshake(success));
-   }
+			} else {
+
+				// need more data
+				return false;
+			}
+		}
+	}
+
+	/**
+	 * WebSockets handshake reply from server received, default notifies master.
+	 * 
+	 * @param success
+	 *            Success handshake flag
+	 */
+	protected void onHandshake(boolean success) {
+
+		notify(new WebSocketMessage.ServerHandshake(success));
+	}
+
+	/**
+	 * WebSockets close received, default notifies master.
+	 */
+	protected void onClose(int code, String reason) {
+
+		notify(new WebSocketMessage.Close(code, reason));
+	}
+
+	/**
+	 * WebSockets ping received, default notifies master.
+	 * 
+	 * @param payload
+	 *            Ping payload or null.
+	 */
+	protected void onPing(byte[] payload) {
+
+		notify(new WebSocketMessage.Ping(payload));
+	}
+
+	/**
+	 * WebSockets pong received, default notifies master.
+	 * 
+	 * @param payload
+	 *            Pong payload or null.
+	 */
+	protected void onPong(byte[] payload) {
+
+		notify(new WebSocketMessage.Pong(payload));
+	}
+
+	/**
+	 * WebSockets text message received, default notifies master. This will only
+	 * be called when the option receiveTextMessagesRaw HAS NOT been set.
+	 * 
+	 * @param payload
+	 *            Text message payload as Java String decoded from raw UTF-8
+	 *            payload or null (empty payload).
+	 */
+	protected void onTextMessage(String payload) {
+
+		notify(new WebSocketMessage.TextMessage(payload));
+	}
+
+	/**
+	 * WebSockets text message received, default notifies master. This will only
+	 * be called when the option receiveTextMessagesRaw HAS been set.
+	 * 
+	 * @param payload
+	 *            Text message payload as raw UTF-8 octets or null (empty
+	 *            payload).
+	 */
+	protected void onRawTextMessage(byte[] payload) {
+
+		notify(new WebSocketMessage.RawTextMessage(payload));
+	}
+
+	/**
+	 * WebSockets binary message received, default notifies master.
+	 * 
+	 * @param payload
+	 *            Binary message payload or null (empty payload).
+	 */
+	protected void onBinaryMessage(byte[] payload) {
+
+		notify(new WebSocketMessage.BinaryMessage(payload));
+	}
+
+	/**
+	 * Process WebSockets handshake received from server.
+	 */
+	private boolean processHandshake() throws UnsupportedEncodingException {
+
+		boolean res = false;
+		for (int pos = mFrameBuffer.position() - 4; pos >= 0; --pos) {
+			if (mFrameBuffer.get(pos + 0) == 0x0d
+					&& mFrameBuffer.get(pos + 1) == 0x0a
+					&& mFrameBuffer.get(pos + 2) == 0x0d
+					&& mFrameBuffer.get(pos + 3) == 0x0a) {
+
+				// / \todo process & verify handshake from server
+				// / \todo forward subprotocol, if any
+
+				int oldPosition = mFrameBuffer.position();
+
+				// Check HTTP status code
+				boolean serverError = false;
+				if (mFrameBuffer.get(0) == 'H' && mFrameBuffer.get(1) == 'T'
+						&& mFrameBuffer.get(2) == 'T'
+						&& mFrameBuffer.get(3) == 'P') {
+
+					Pair<Integer, String> status = parseHttpStatus();
+					if (status.first >= 300) {
+						// Invalid status code for success connection
+						notify(new WebSocketMessage.ServerError(status.first,
+								status.second));
+						serverError = true;
+					}
+				}
+
+				mFrameBuffer.position(pos + 4);
+				mFrameBuffer.limit(oldPosition);
+				mFrameBuffer.compact();
+
+				if (!serverError) {
+					// process further when data after HTTP headers left in
+					// buffer
+					res = mFrameBuffer.position() > 0;
+
+					mState = STATE_OPEN;
+				} else {
+					res = true;
+					mState = STATE_CLOSED;
+					mStopped = true;
+				}
+
+				onHandshake(!serverError);
+				break;
+			}
+		}
+		return res;
+	}
+
+	@SuppressWarnings("unused")
+	private Map<String, String> parseHttpHeaders(byte[] buffer)
+			throws UnsupportedEncodingException {
+		// TODO: use utf-8 validator?
+		String s = new String(buffer, "UTF-8");
+		Map<String, String> headers = new HashMap<String, String>();
+
+		String[] lines = s.split("\r\n");
+		for (String line : lines) {
+			if (line.length() > 0) {
+				String[] h = line.split(": ");
+				if (h.length == 2) {
+					headers.put(h[0], h[1]);
+					Log.w(TAG, String.format("'%s'='%s'", h[0], h[1]));
+				}
+			}
+		}
 
+		return headers;
+	}
 
-   /**
-    * WebSockets close received, default notifies master.
-    */
-   protected void onClose(int code, String reason) {
-
-      notify(new WebSocketMessage.Close(code, reason));
-   }
-
-
-   /**
-    * WebSockets ping received, default notifies master.
-    *
-    * @param payload    Ping payload or null.
-    */
-   protected void onPing(byte[] payload) {
-
-      notify(new WebSocketMessage.Ping(payload));
-   }
-
-
-   /**
-    * WebSockets pong received, default notifies master.
-    *
-    * @param payload    Pong payload or null.
-    */
-   protected void onPong(byte[] payload) {
-
-      notify(new WebSocketMessage.Pong(payload));
-   }
-
-
-   /**
-    * WebSockets text message received, default notifies master.
-    * This will only be called when the option receiveTextMessagesRaw
-    * HAS NOT been set.
-    *
-    * @param payload    Text message payload as Java String decoded
-    *                   from raw UTF-8 payload or null (empty payload).
-    */
-   protected void onTextMessage(String payload) {
-
-      notify(new WebSocketMessage.TextMessage(payload));
-   }
-
-
-   /**
-    * WebSockets text message received, default notifies master.
-    * This will only be called when the option receiveTextMessagesRaw
-    * HAS been set.
-    *
-    * @param payload    Text message payload as raw UTF-8 octets or
-    *                   null (empty payload).
-    */
-   protected void onRawTextMessage(byte[] payload) {
-
-      notify(new WebSocketMessage.RawTextMessage(payload));
-   }
-
-
-   /**
-    * WebSockets binary message received, default notifies master.
-    *
-    * @param payload    Binary message payload or null (empty payload).
-    */
-   protected void onBinaryMessage(byte[] payload) {
-
-      notify(new WebSocketMessage.BinaryMessage(payload));
-   }
-
-
-   /**
-    * Process WebSockets handshake received from server.
-    */
-   private boolean processHandshake() throws UnsupportedEncodingException {
-
-      boolean res = false;
-      for (int pos = mFrameBuffer.position() - 4; pos >= 0; --pos) {
-         if (mFrameBuffer.get(pos+0) == 0x0d &&
-             mFrameBuffer.get(pos+1) == 0x0a &&
-             mFrameBuffer.get(pos+2) == 0x0d &&
-             mFrameBuffer.get(pos+3) == 0x0a) {
-
-            /// \todo process & verify handshake from server
-            /// \todo forward subprotocol, if any
-
-            int oldPosition = mFrameBuffer.position();
-            
-            // Check HTTP status code
-            boolean serverError = false;
-            if (mFrameBuffer.get(0) == 'H' &&
-            	mFrameBuffer.get(1) == 'T' &&
-            	mFrameBuffer.get(2) == 'T' &&
-            	mFrameBuffer.get(3) == 'P') {
-            	
-            	Pair<Integer, String> status = parseHttpStatus();
-            	if (status.first >= 300) {
-            		// Invalid status code for success connection
-            		notify(new WebSocketMessage.ServerError(status.first, status.second));
-            		serverError = true;
-            	}
-            }
-            
-            mFrameBuffer.position(pos + 4);
-            mFrameBuffer.limit(oldPosition);
-            mFrameBuffer.compact();
-
-            if (!serverError) {
-            	// process further when data after HTTP headers left in buffer
-                res = mFrameBuffer.position() > 0;
-
-                mState = STATE_OPEN;
-            } else {
-            	res = true;
-            	mState = STATE_CLOSED;
-            	mStopped = true;
-            }
-            
-            onHandshake(!serverError);
-            break;
-         }
-      }
-      return res;
-   }
-   
-   @SuppressWarnings("unused")
-   private Map<String, String> parseHttpHeaders(byte[] buffer) throws UnsupportedEncodingException {
-	   // TODO: use utf-8 validator?
-	   String s = new String(buffer, "UTF-8");
-	   Map<String, String> headers = new HashMap<String, String>();
-	   
-	   String[] lines = s.split("\r\n");
-	   for (String line : lines) {
-		   if (line.length() > 0) {
-			   String[] h = line.split(": ");
-			   if (h.length == 2) {
-				   headers.put(h[0], h[1]);
-				   Log.w(TAG, String.format("'%s'='%s'", h[0], h[1]));
-			   }
-		   }
-	   }
-	   
-	   return headers;
-   }
-   
-   private Pair<Integer, String> parseHttpStatus() throws UnsupportedEncodingException {
-	   int beg, end;
+	private Pair<Integer, String> parseHttpStatus()
+			throws UnsupportedEncodingException {
+		int beg, end;
 		// Find first space
 		for (beg = 4; beg < mFrameBuffer.position(); ++beg) {
-			if (mFrameBuffer.get(beg) == ' ') break;
+			if (mFrameBuffer.get(beg) == ' ')
+				break;
 		}
 		// Find second space
 		for (end = beg + 1; end < mFrameBuffer.position(); ++end) {
-			if (mFrameBuffer.get(end) == ' ') break;
+			if (mFrameBuffer.get(end) == ' ')
+				break;
 		}
 		// Parse status code between them
 		++beg;
@@ -601,99 +645,109 @@ private boolean processHandshake() throws UnsupportedEncodingException {
 		++end;
 		int eol;
 		for (eol = end; eol < mFrameBuffer.position(); ++eol) {
-			if (mFrameBuffer.get(eol) == 0x0d) break;
+			if (mFrameBuffer.get(eol) == 0x0d)
+				break;
 		}
 		int statusMessageLength = eol - end;
 		byte[] statusBuf = new byte[statusMessageLength];
 		mFrameBuffer.position(end);
 		mFrameBuffer.get(statusBuf, 0, statusMessageLength);
 		String statusMessage = new String(statusBuf, "UTF-8");
-		if (DEBUG) Log.w(TAG, String.format("Status: %d (%s)", statusCode, statusMessage));
+		if (DEBUG)
+			Log.w(TAG,
+					String.format("Status: %d (%s)", statusCode, statusMessage));
 		return new Pair<Integer, String>(statusCode, statusMessage);
-   }
+	}
 
+	/**
+	 * Consume data buffered in mFrameBuffer.
+	 */
+	private boolean consumeData() throws Exception {
 
-   /**
-    * Consume data buffered in mFrameBuffer.
-    */
-   private boolean consumeData() throws Exception {
+		if (mState == STATE_OPEN || mState == STATE_CLOSING) {
 
-      if (mState == STATE_OPEN || mState == STATE_CLOSING) {
+			return processData();
 
-         return processData();
+		} else if (mState == STATE_CONNECTING) {
 
-      } else if (mState == STATE_CONNECTING) {
+			return processHandshake();
 
-         return processHandshake();
+		} else if (mState == STATE_CLOSED) {
 
-      } else if (mState == STATE_CLOSED) {
+			return false;
 
-         return false;
+		} else {
+			// should not arrive here
+			return false;
+		}
 
-      } else {
-         // should not arrive here
-         return false;
-      }
+	}
 
-   }
+	/**
+	 * Run the background reader thread loop.
+	 */
+	@Override
+	public void run() {
 
+		if (DEBUG)
+			Log.d(TAG, "running");
 
-   /**
-    * Run the background reader thread loop.
-    */
-   @Override
-   public void run() {
+		try {
 
-      if (DEBUG) Log.d(TAG, "running");
+			mFrameBuffer.clear();
+			do {
+				// blocking read on socket
+				int len = mSocket.read(mFrameBuffer);
+				if (len > 0) {
+					// process buffered data
+					while (consumeData()) {
+					}
+				} else if (mState == STATE_CLOSED) {
+					notify(new WebSocketMessage.Close(1000)); // Connection has
+																// been closed
+																// normally
+					mStopped = true;
+				} else if (len < 0) {
 
-      try {
+					if (DEBUG)
+						Log.d(TAG, "run() : ConnectionLost");
 
-         mFrameBuffer.clear();
-         do {
-            // blocking read on socket
-            int len = mSocket.read(mFrameBuffer);
-            if (len > 0) {
-               // process buffered data
-               while (consumeData()) {
-               }
-            } else if (mState == STATE_CLOSED) {
-                notify(new WebSocketMessage.Close(1000)); // Connection has been closed normally
-                mStopped = true;
-            } else if (len < 0) {
+					notify(new WebSocketMessage.ConnectionLost());
+					mStopped = true;
+				}
+			} while (!mStopped);
 
-               if (DEBUG) Log.d(TAG, "run() : ConnectionLost");
+		} catch (WebSocketException e) {
 
-               notify(new WebSocketMessage.ConnectionLost());
-               mStopped = true;
-            }
-         } while (!mStopped);
+			if (DEBUG)
+				Log.d(TAG, "run() : WebSocketException (" + e.toString() + ")");
 
-      } catch (WebSocketException e) {
+			// wrap the exception and notify master
+			notify(new WebSocketMessage.ProtocolViolation(e));
 
-         if (DEBUG) Log.d(TAG, "run() : WebSocketException (" + e.toString() + ")");
+		} catch (SocketException e) {
 
-         // wrap the exception and notify master
-         notify(new WebSocketMessage.ProtocolViolation(e));
+			if (DEBUG)
+				Log.d(TAG, "run() : SocketException (" + e.toString() + ")");
 
-      } catch (SocketException e) {
-    	  
-    	  if (DEBUG) Log.d(TAG, "run() : SocketException (" + e.toString() + ")");
-    	  
-    	  // wrap the exception and notify master
-    	  notify(new WebSocketMessage.ConnectionLost());;
-    	  
-      } catch (Exception e) {
+			// wrap the exception and notify master
+			notify(new WebSocketMessage.ConnectionLost());
+			;
 
-         if (DEBUG) Log.d(TAG, "run() : Exception (" + e.toString() + ")");
+		} catch (Exception e) {
 
-         // wrap the exception and notify master
-         notify(new WebSocketMessage.Error(e));
+			if (DEBUG)
+				Log.d(TAG, "run() : Exception (" + e.toString() + ")");
 
-      } finally {
+			// wrap the exception and notify master
+			notify(new WebSocketMessage.Error(e));
 
-         mStopped = true;
-      }
+		} finally {
+
+			mStopped = true;
+		}
 
-      if (DEBUG) Log.d(TAG, "ended");
-   }
+		if (DEBUG)
+			Log.d(TAG, "ended");
+	}
 }
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java b/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java
index 35cded5..cb0564f 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java
@@ -191,6 +191,9 @@ private void sendClientHandshake(WebSocketMessage.ClientHandshake message) throw
           }
       }           
       mBuffer.crlf();
+      if(DEBUG)
+    	  Log.w(TAG,mBuffer.toString());
+      
    }
 
 
@@ -315,6 +318,12 @@ protected void sendFrame(int opcode, boolean fin, byte[] payload) throws IOExcep
     */
    protected void sendFrame(int opcode, boolean fin, byte[] payload, int offset, int length) throws IOException {
 
+	   byte[] temp = new byte[length];
+	   
+	   System.arraycopy(payload, 0, temp, 0, length);
+	   
+	   Log.i(TAG," Writing.. : " + new String(temp));
+	   
       // first octet
       byte b0 = 0;
       if (fin) {
