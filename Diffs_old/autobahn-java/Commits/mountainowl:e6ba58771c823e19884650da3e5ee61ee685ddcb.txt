diff --git a/Autobahn/.gradle/2.8/taskArtifacts/cache.properties b/Autobahn/.gradle/2.8/taskArtifacts/cache.properties
new file mode 100644
index 0000000..0caa077
--- /dev/null
+++ b/Autobahn/.gradle/2.8/taskArtifacts/cache.properties
@@ -0,0 +1 @@
+#Thu Feb 11 18:12:10 PST 2016
diff --git a/Autobahn/.gradle/2.8/taskArtifacts/cache.properties.lock b/Autobahn/.gradle/2.8/taskArtifacts/cache.properties.lock
new file mode 100644
index 0000000..4e66876
Binary files /dev/null and b/Autobahn/.gradle/2.8/taskArtifacts/cache.properties.lock differ
diff --git a/Autobahn/.gradle/2.8/taskArtifacts/fileHashes.bin b/Autobahn/.gradle/2.8/taskArtifacts/fileHashes.bin
new file mode 100644
index 0000000..49613bd
Binary files /dev/null and b/Autobahn/.gradle/2.8/taskArtifacts/fileHashes.bin differ
diff --git a/Autobahn/.gradle/2.8/taskArtifacts/fileSnapshots.bin b/Autobahn/.gradle/2.8/taskArtifacts/fileSnapshots.bin
new file mode 100644
index 0000000..d2f8899
Binary files /dev/null and b/Autobahn/.gradle/2.8/taskArtifacts/fileSnapshots.bin differ
diff --git a/Autobahn/.gradle/2.8/taskArtifacts/outputFileStates.bin b/Autobahn/.gradle/2.8/taskArtifacts/outputFileStates.bin
new file mode 100644
index 0000000..a949835
Binary files /dev/null and b/Autobahn/.gradle/2.8/taskArtifacts/outputFileStates.bin differ
diff --git a/Autobahn/.gradle/2.8/taskArtifacts/taskArtifacts.bin b/Autobahn/.gradle/2.8/taskArtifacts/taskArtifacts.bin
new file mode 100644
index 0000000..45055f8
Binary files /dev/null and b/Autobahn/.gradle/2.8/taskArtifacts/taskArtifacts.bin differ
diff --git a/Autobahn/build.gradle b/Autobahn/build.gradle
new file mode 100644
index 0000000..a25dbb5
--- /dev/null
+++ b/Autobahn/build.gradle
@@ -0,0 +1,52 @@
+buildscript {
+    repositories {
+        jcenter()
+    }
+    dependencies {
+        classpath 'com.android.tools.build:gradle:1.3.1'
+        // NOTE: Do not place your application dependencies here; they belong
+        // in the individual module build.gradle files
+
+    }
+}
+
+apply plugin: 'com.android.library'
+
+android {
+    sourceSets {
+        main {
+            manifest.srcFile 'AndroidManifest.xml'
+
+            jniLibs.srcDirs = ['libs/']
+
+            java.srcDirs=['src/'
+            ]
+        }
+        androidTest.java.srcDirs=['test/src/']
+        androidTest.res.srcDirs=['test/res/']
+        androidTest.assets.srcDirs=['test/assets/']
+    }
+
+    lintOptions {
+        abortOnError false
+    }
+
+    defaultConfig {
+        targetSdkVersion 23
+        minSdkVersion 19
+    }
+
+    compileSdkVersion 23
+    buildToolsVersion '23.0.1'
+}
+
+repositories {
+    jcenter()
+}
+
+dependencies{
+    compile 'com.android.support:support-v4:23.1.1'
+    compile 'org.codehaus.jackson:jackson-mapper-asl:1.9.13'
+    compile 'com.squareup.okhttp3:okhttp:3.1.1'
+}
+
diff --git a/Autobahn/build/generated/source/buildConfig/androidTest/debug/de/tavendo/autobahn/test/BuildConfig.java b/Autobahn/build/generated/source/buildConfig/androidTest/debug/de/tavendo/autobahn/test/BuildConfig.java
new file mode 100644
index 0000000..bc68dc7
--- /dev/null
+++ b/Autobahn/build/generated/source/buildConfig/androidTest/debug/de/tavendo/autobahn/test/BuildConfig.java
@@ -0,0 +1,13 @@
+/**
+ * Automatically generated file. DO NOT MODIFY
+ */
+package de.tavendo.autobahn.test;
+
+public final class BuildConfig {
+  public static final boolean DEBUG = Boolean.parseBoolean("true");
+  public static final String APPLICATION_ID = "de.tavendo.autobahn.test";
+  public static final String BUILD_TYPE = "debug";
+  public static final String FLAVOR = "";
+  public static final int VERSION_CODE = -1;
+  public static final String VERSION_NAME = "";
+}
diff --git a/Autobahn/build/generated/source/buildConfig/debug/de/tavendo/autobahn/BuildConfig.java b/Autobahn/build/generated/source/buildConfig/debug/de/tavendo/autobahn/BuildConfig.java
new file mode 100644
index 0000000..8112a23
--- /dev/null
+++ b/Autobahn/build/generated/source/buildConfig/debug/de/tavendo/autobahn/BuildConfig.java
@@ -0,0 +1,13 @@
+/**
+ * Automatically generated file. DO NOT MODIFY
+ */
+package de.tavendo.autobahn;
+
+public final class BuildConfig {
+  public static final boolean DEBUG = Boolean.parseBoolean("true");
+  public static final String APPLICATION_ID = "de.tavendo.autobahn";
+  public static final String BUILD_TYPE = "debug";
+  public static final String FLAVOR = "";
+  public static final int VERSION_CODE = 1;
+  public static final String VERSION_NAME = "";
+}
diff --git a/Autobahn/build/intermediates/bundles/debug/AndroidManifest.xml b/Autobahn/build/intermediates/bundles/debug/AndroidManifest.xml
new file mode 100644
index 0000000..c5c6fca
--- /dev/null
+++ b/Autobahn/build/intermediates/bundles/debug/AndroidManifest.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="de.tavendo.autobahn"
+    android:versionCode="1"
+    android:versionName="0.1" >
+
+    <uses-sdk
+        android:minSdkVersion="19"
+        android:targetSdkVersion="23" />
+
+    <application android:label="Autobahn" />
+
+</manifest>
\ No newline at end of file
diff --git a/Autobahn/build/intermediates/bundles/debug/aapt/AndroidManifest.xml b/Autobahn/build/intermediates/bundles/debug/aapt/AndroidManifest.xml
new file mode 100644
index 0000000..c5c6fca
--- /dev/null
+++ b/Autobahn/build/intermediates/bundles/debug/aapt/AndroidManifest.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="de.tavendo.autobahn"
+    android:versionCode="1"
+    android:versionName="0.1" >
+
+    <uses-sdk
+        android:minSdkVersion="19"
+        android:targetSdkVersion="23" />
+
+    <application android:label="Autobahn" />
+
+</manifest>
\ No newline at end of file
diff --git a/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/AndroidManifest.xml b/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/AndroidManifest.xml
new file mode 100644
index 0000000..f273269
--- /dev/null
+++ b/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/AndroidManifest.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+ Copyright (C) 2014 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="android.support.v4" >
+
+    <uses-sdk android:minSdkVersion="4" />
+
+    <application />
+
+</manifest>
\ No newline at end of file
diff --git a/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/aapt/AndroidManifest.xml b/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/aapt/AndroidManifest.xml
new file mode 100644
index 0000000..f273269
--- /dev/null
+++ b/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/aapt/AndroidManifest.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+ Copyright (C) 2014 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="android.support.v4" >
+
+    <uses-sdk android:minSdkVersion="4" />
+
+    <application />
+
+</manifest>
\ No newline at end of file
diff --git a/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/aidl/android/support/v4/media/MediaMetadataCompat.aidl b/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/aidl/android/support/v4/media/MediaMetadataCompat.aidl
new file mode 100644
index 0000000..6d36b97
--- /dev/null
+++ b/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/aidl/android/support/v4/media/MediaMetadataCompat.aidl
@@ -0,0 +1,18 @@
+/* Copyright 2014, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+package android.support.v4.media;
+
+parcelable MediaMetadataCompat;
diff --git a/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/aidl/android/support/v4/media/RatingCompat.aidl b/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/aidl/android/support/v4/media/RatingCompat.aidl
new file mode 100644
index 0000000..223fd5c
--- /dev/null
+++ b/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/aidl/android/support/v4/media/RatingCompat.aidl
@@ -0,0 +1,18 @@
+/* Copyright 2014, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+package android.support.v4.media;
+
+parcelable RatingCompat;
diff --git a/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/aidl/android/support/v4/media/session/MediaSessionCompat.aidl b/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/aidl/android/support/v4/media/session/MediaSessionCompat.aidl
new file mode 100644
index 0000000..d0c2f6f
--- /dev/null
+++ b/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/aidl/android/support/v4/media/session/MediaSessionCompat.aidl
@@ -0,0 +1,20 @@
+/* Copyright 2014, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+package android.support.v4.media.session;
+
+parcelable MediaSessionCompat.Token;
+parcelable MediaSessionCompat.QueueItem;
+parcelable MediaSessionCompat.ResultReceiverWrapper;
diff --git a/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/aidl/android/support/v4/media/session/ParcelableVolumeInfo.aidl b/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/aidl/android/support/v4/media/session/ParcelableVolumeInfo.aidl
new file mode 100644
index 0000000..2e77c4f
--- /dev/null
+++ b/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/aidl/android/support/v4/media/session/ParcelableVolumeInfo.aidl
@@ -0,0 +1,18 @@
+/* Copyright 2014, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+package android.support.v4.media.session;
+
+parcelable ParcelableVolumeInfo;
diff --git a/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/aidl/android/support/v4/media/session/PlaybackStateCompat.aidl b/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/aidl/android/support/v4/media/session/PlaybackStateCompat.aidl
new file mode 100644
index 0000000..3d4ef59
--- /dev/null
+++ b/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/aidl/android/support/v4/media/session/PlaybackStateCompat.aidl
@@ -0,0 +1,18 @@
+/* Copyright 2014, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+package android.support.v4.media.session;
+
+parcelable PlaybackStateCompat;
diff --git a/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/aidl/android/support/v4/os/ResultReceiver.aidl b/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/aidl/android/support/v4/os/ResultReceiver.aidl
new file mode 100644
index 0000000..81c81f6
--- /dev/null
+++ b/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/aidl/android/support/v4/os/ResultReceiver.aidl
@@ -0,0 +1,19 @@
+/*
+** Copyright 2015, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+package android.support.v4.os;
+
+parcelable ResultReceiver;
diff --git a/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/annotations.zip b/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/annotations.zip
new file mode 100644
index 0000000..3461e00
Binary files /dev/null and b/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/annotations.zip differ
diff --git a/Autobahn/build/intermediates/incremental/aidl/androidTest/debug/dependency.store b/Autobahn/build/intermediates/incremental/aidl/androidTest/debug/dependency.store
new file mode 100644
index 0000000..8b8400d
Binary files /dev/null and b/Autobahn/build/intermediates/incremental/aidl/androidTest/debug/dependency.store differ
diff --git a/Autobahn/build/intermediates/incremental/aidl/debug/dependency.store b/Autobahn/build/intermediates/incremental/aidl/debug/dependency.store
new file mode 100644
index 0000000..8b8400d
Binary files /dev/null and b/Autobahn/build/intermediates/incremental/aidl/debug/dependency.store differ
diff --git a/Autobahn/build/intermediates/incremental/mergeAssets/androidTest/debug/merger.xml b/Autobahn/build/intermediates/incremental/mergeAssets/androidTest/debug/merger.xml
new file mode 100644
index 0000000..82226db
--- /dev/null
+++ b/Autobahn/build/intermediates/incremental/mergeAssets/androidTest/debug/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet config="23.1.1"><source path="/Users/ajay/autobahn-android/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/assets"/></dataSet><dataSet config="debug"><source path="/Users/ajay/autobahn-android/Autobahn/build/intermediates/bundles/debug/assets"/></dataSet><dataSet config="main"><source path="/Users/ajay/autobahn-android/Autobahn/test/assets"/></dataSet></merger>
\ No newline at end of file
diff --git a/Autobahn/build/intermediates/incremental/mergeAssets/debug/merger.xml b/Autobahn/build/intermediates/incremental/mergeAssets/debug/merger.xml
new file mode 100644
index 0000000..de1106c
--- /dev/null
+++ b/Autobahn/build/intermediates/incremental/mergeAssets/debug/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet config="main"><source path="/Users/ajay/autobahn-android/Autobahn/src/main/assets"/></dataSet><dataSet config="debug"><source path="/Users/ajay/autobahn-android/Autobahn/src/debug/assets"/></dataSet></merger>
\ No newline at end of file
diff --git a/Autobahn/build/intermediates/incremental/mergeResourcesandroidTest/debug/merger.xml b/Autobahn/build/intermediates/incremental/mergeResourcesandroidTest/debug/merger.xml
new file mode 100644
index 0000000..8eee8fe
--- /dev/null
+++ b/Autobahn/build/intermediates/incremental/mergeResourcesandroidTest/debug/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet config="23.1.1"><source path="/Users/ajay/autobahn-android/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/res"/></dataSet><dataSet config="debug"><source path="/Users/ajay/autobahn-android/Autobahn/build/intermediates/bundles/debug/res"/></dataSet><dataSet config="main"><source path="/Users/ajay/autobahn-android/Autobahn/test/res"/><source path="/Users/ajay/autobahn-android/Autobahn/build/generated/res/rs/androidTest/debug"/><source path="/Users/ajay/autobahn-android/Autobahn/build/generated/res/resValues/androidTest/debug"/></dataSet><mergedItems/></merger>
\ No newline at end of file
diff --git a/Autobahn/build/intermediates/incremental/mergeResourcesdebug/merger.xml b/Autobahn/build/intermediates/incremental/mergeResourcesdebug/merger.xml
new file mode 100644
index 0000000..2856180
--- /dev/null
+++ b/Autobahn/build/intermediates/incremental/mergeResourcesdebug/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet config="23.1.1"><source path="/Users/ajay/autobahn-android/Autobahn/build/intermediates/exploded-aar/com.android.support/support-v4/23.1.1/res"/></dataSet><dataSet config="main"><source path="/Users/ajay/autobahn-android/Autobahn/src/main/res"/><source path="/Users/ajay/autobahn-android/Autobahn/build/generated/res/rs/debug"/><source path="/Users/ajay/autobahn-android/Autobahn/build/generated/res/resValues/debug"/></dataSet><dataSet config="debug"><source path="/Users/ajay/autobahn-android/Autobahn/src/debug/res"/></dataSet><mergedItems/></merger>
\ No newline at end of file
diff --git a/Autobahn/build/intermediates/incremental/packageResourcesdebug/merger.xml b/Autobahn/build/intermediates/incremental/packageResourcesdebug/merger.xml
new file mode 100644
index 0000000..5da222e
--- /dev/null
+++ b/Autobahn/build/intermediates/incremental/packageResourcesdebug/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet config="main"><source path="/Users/ajay/autobahn-android/Autobahn/src/main/res"/><source path="/Users/ajay/autobahn-android/Autobahn/build/generated/res/rs/debug"/><source path="/Users/ajay/autobahn-android/Autobahn/build/generated/res/resValues/debug"/></dataSet><dataSet config="debug"><source path="/Users/ajay/autobahn-android/Autobahn/src/debug/res"/></dataSet><mergedItems/></merger>
\ No newline at end of file
diff --git a/Autobahn/build/intermediates/manifest/androidTest/debug/AndroidManifest.xml b/Autobahn/build/intermediates/manifest/androidTest/debug/AndroidManifest.xml
new file mode 100644
index 0000000..20ba153
--- /dev/null
+++ b/Autobahn/build/intermediates/manifest/androidTest/debug/AndroidManifest.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="de.tavendo.autobahn.test" >
+
+    <uses-sdk
+        android:minSdkVersion="19"
+        android:targetSdkVersion="23" />
+
+    <instrumentation
+        android:name="android.test.InstrumentationTestRunner"
+        android:functionalTest="false"
+        android:handleProfiling="false"
+        android:label="Tests for de.tavendo.autobahn.test"
+        android:targetPackage="de.tavendo.autobahn.test" />
+
+    <application android:label="Autobahn" >
+        <uses-library android:name="android.test.runner" />
+    </application>
+
+</manifest>
\ No newline at end of file
diff --git a/Autobahn/build/intermediates/manifest/tmp/manifestMerger7356070509566745059.xml b/Autobahn/build/intermediates/manifest/tmp/manifestMerger7356070509566745059.xml
new file mode 100644
index 0000000..6bd1632
--- /dev/null
+++ b/Autobahn/build/intermediates/manifest/tmp/manifestMerger7356070509566745059.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="de.tavendo.autobahn.test">
+
+    <uses-sdk android:minSdkVersion="19" android:targetSdkVersion="23" />
+
+    <application>
+        <uses-library android:name="android.test.runner" />
+    </application>
+
+    <instrumentation android:name="android.test.InstrumentationTestRunner"
+                     android:targetPackage="de.tavendo.autobahn.test"
+                     android:handleProfiling="false"
+                     android:functionalTest="false"
+                     android:label="Tests for de.tavendo.autobahn.test"/>
+</manifest>
diff --git a/Autobahn/build/intermediates/res/resources-debug-androidTest.ap_ b/Autobahn/build/intermediates/res/resources-debug-androidTest.ap_
new file mode 100644
index 0000000..09de1b4
Binary files /dev/null and b/Autobahn/build/intermediates/res/resources-debug-androidTest.ap_ differ
diff --git a/Autobahn/gradle.properties b/Autobahn/gradle.properties
new file mode 100644
index 0000000..1d3591c
--- /dev/null
+++ b/Autobahn/gradle.properties
@@ -0,0 +1,18 @@
+# Project-wide Gradle settings.
+
+# IDE (e.g. Android Studio) users:
+# Gradle settings configured through the IDE *will override*
+# any settings specified in this file.
+
+# For more details on how to configure your build environment visit
+# http://www.gradle.org/docs/current/userguide/build_environment.html
+
+# Specifies the JVM arguments used for the daemon process.
+# The setting is particularly useful for tweaking memory settings.
+# Default value: -Xmx10248m -XX:MaxPermSize=256m
+# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
+
+# When configured, Gradle will run in incubating parallel mode.
+# This option should only be used with decoupled projects. More details, visit
+# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
+# org.gradle.parallel=true
\ No newline at end of file
diff --git a/Autobahn/gradle/wrapper/gradle-wrapper.properties b/Autobahn/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000..0c71e76
--- /dev/null
+++ b/Autobahn/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Wed Apr 10 15:27:10 PDT 2013
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
diff --git a/Autobahn/gradlew b/Autobahn/gradlew
new file mode 100755
index 0000000..91a7e26
--- /dev/null
+++ b/Autobahn/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/Autobahn/gradlew.bat b/Autobahn/gradlew.bat
new file mode 100644
index 0000000..8a0b282
--- /dev/null
+++ b/Autobahn/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/Autobahn/settings.gradle b/Autobahn/settings.gradle
new file mode 100644
index 0000000..7a02932
--- /dev/null
+++ b/Autobahn/settings.gradle
@@ -0,0 +1,2 @@
+include ':Autobahn'
+
diff --git a/Autobahn/src/de/tavendo/autobahn/Wamp.java b/Autobahn/src/de/tavendo/autobahn/Wamp.java
index 55a65e1..dbcdfb7 100644
--- a/Autobahn/src/de/tavendo/autobahn/Wamp.java
+++ b/Autobahn/src/de/tavendo/autobahn/Wamp.java
@@ -1,28 +1,28 @@
 /******************************************************************************
- *
- *  Copyright 2011-2012 Tavendo GmbH
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
+ * Copyright 2011-2012 Tavendo GmbH
+ * <p/>
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * <p/>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p/>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ******************************************************************************/
 
 package de.tavendo.autobahn;
 
 
-import java.util.List;
-import org.apache.http.message.BasicNameValuePair;
+import android.support.v4.util.Pair;
+
 import org.codehaus.jackson.type.TypeReference;
 
+import java.util.List;
+
 /**
  * WAMP interface.
  */
@@ -42,174 +42,174 @@
 
     public static final String URI_WAMP_ERROR_INTERNAL = URI_WAMP_ERROR + "internal";
 
-   /**
-    * Session handler for WAMP sessions.
-    */
-   public interface ConnectionHandler {
-
-      /**
-       * Fired upon successful establishment of connection to WAMP server.
-       */
-      public void onOpen();
-
-      /**
-       * Firex upon unsuccessful connection attempt or when connection
-       * was closed normally, or abnormally.
-       *
-       * @param code       The close code, which provides information about why the connection was closed.
-       * @param reason     A humand readable description of the reason of connection close.
-       */
-      public void onClose(int code, String reason);
-   }
-
-   /**
-    * Connect to WAMP server.
-    *
-    * @param wsUri            The WebSockets URI of the server.
-    * @param sessionHandler   The handler for the session.
-    */
-   public void connect(String wsUri, ConnectionHandler sessionHandler);
-   
-   /**
-    * 
-    * @param wsUri            The WebSockets URI of the server.
-    * @param sessionHandler   The handler for the session.
-    * @param headers		  The headers with the connection
-    */
-   public void connect(String wsUri, ConnectionHandler sessionHandler, List<BasicNameValuePair> headers);
-
-
-   /**
-    * Connect to WAMP server.
-    *
-    * @param wsUri            The WebSockets URI of the server.
-    * @param sessionHandler   The handler for the session.
-    * @param options          WebSockets and Autobahn option.s
-    * @param headers		  Headers for connection
-    */
-   public void connect(String wsUri, ConnectionHandler sessionHandler, WampOptions options, List<BasicNameValuePair> headers);
-
-   /**
-    * Connect to WAMP server.
-    *
-    * @param wsUri            The WebSockets URI of the server.
-    * @param sessionHandler   The handler for the session.
-    * @param options          WebSockets and Autobahn option.s
-    */
-   public void connect(String wsUri, ConnectionHandler sessionHandler, WampOptions options);
-
-   /**
-    * Disconnect from WAMP server.
-    */
-   public void disconnect();
-
-   /**
-    * Check if currently connected to server.
-    *
-    * @return     True, iff connected.
-    */
-   public boolean isConnected();
-
-
-   /**
-    * Establish a prefix to be used in CURIEs to shorten URIs.
-    *
-    * @param prefix           The prefix to be used in CURIEs.
-    * @param uri              The full URI this prefix shall resolve to.
-    */
-   public void prefix(String prefix, String uri);
-
-   /**
-    * Call handler.
-    */
-   public interface CallHandler {
-
-      /**
-       * Fired on successful completion of call.
-       *
-       * @param result     The RPC result transformed into the type that was specified in call.
-       */
-      public void onResult(Object result);
-
-      /**
-       * Fired on call failure.
-       *
-       * @param errorUri   The URI or CURIE of the error that occurred.
-       * @param errorDesc  A human readable description of the error.
-       */
-      public void onError(String errorUri, String errorDesc);
-   }
-
-   /**
-    * Call a remote procedure (RPC).
-    *
-    * @param procUri       The URI or CURIE of the remote procedure to call.
-    * @param resultType    The type the call result gets transformed into.
-    * @param callHandler   The handler to be invoked upon call completion.
-    * @param arguments     Zero, one or more arguments for the call.
-    */
-   public void call(String procUri, Class<?> resultType, CallHandler callHandler, Object... arguments);
-
-   /**
-    * Call a remote procedure (RPC).
-    *
-    * @param procUri       The URI or CURIE of the remote procedure to call.
-    * @param resultType    The type the call result gets transformed into.
-    * @param callHandler   The handler to be invoked upon call completion.
-    * @param arguments     Zero, one or more arguments for the call.
-    */
-   public void call(String procUri, TypeReference<?> resultType, CallHandler callHandler, Object... arguments);
-
-   /**
-    * Handler for PubSub events.
-    */
-   public interface EventHandler {
-
-      /**
-       * Fired when an event for the PubSub subscription is received.
-       *
-       * @param topicUri   The URI or CURIE of the topic the event was published to.
-       * @param event      The event, transformed into the type that was specified when subscribing.
-       */
-      public void onEvent(String topicUri, Object event);
-   }
-
-   /**
-    * Subscribe to a topic. When already subscribed, overwrite the event handler.
-    *
-    * @param topicUri      The URI or CURIE of the topic to subscribe to.
-    * @param eventType     The type that event get transformed into.
-    * @param eventHandler  The event handler.
-    */
-   public void subscribe(String topicUri, Class<?> eventType, EventHandler eventHandler);
-
-   /**
-    * Subscribe to a topic. When already subscribed, overwrite the event handler.
-    *
-    * @param topicUri      The URI or CURIE of the topic to subscribe to.
-    * @param eventType     The type that event get transformed into.
-    * @param eventHandler  The event handler.
-    */
-   public void subscribe(String topicUri, TypeReference<?> eventType, EventHandler eventHandler);
-
-   /**
-    * Unsubscribe from given topic.
-    *
-    * @param topicUri      The URI or CURIE of the topic to unsubscribe from.
-    */
-   public void unsubscribe(String topicUri);
-
-   /**
-    * Unsubscribe from any topics subscribed.
-    */
-   public void unsubscribe();
-
-   /**
-    * Publish an event to the specified topic.
-    *
-    * @param topicUri      The URI or CURIE of the topic the event is to be published for.
-    * @param event         The event to be published.
-    */
-   public void publish(String topicUri, Object event);
+    /**
+     * Session handler for WAMP sessions.
+     */
+    public interface ConnectionHandler {
+
+        /**
+         * Fired upon successful establishment of connection to WAMP server.
+         */
+        public void onOpen();
+
+        /**
+         * Firex upon unsuccessful connection attempt or when connection
+         * was closed normally, or abnormally.
+         *
+         * @param code       The close code, which provides information about why the connection was closed.
+         * @param reason     A humand readable description of the reason of connection close.
+         */
+        public void onClose(int code, String reason);
+    }
+
+    /**
+     * Connect to WAMP server.
+     *
+     * @param wsUri            The WebSockets URI of the server.
+     * @param sessionHandler   The handler for the session.
+     */
+    public void connect(String wsUri, ConnectionHandler sessionHandler);
+
+    /**
+     *
+     * @param wsUri            The WebSockets URI of the server.
+     * @param sessionHandler   The handler for the session.
+     * @param headers          The headers with the connection
+     */
+    public void connect(String wsUri, ConnectionHandler sessionHandler, List<Pair> headers);
+
+
+    /**
+     * Connect to WAMP server.
+     *
+     * @param wsUri            The WebSockets URI of the server.
+     * @param sessionHandler   The handler for the session.
+     * @param options          WebSockets and Autobahn option.s
+     * @param headers          Headers for connection
+     */
+    public void connect(String wsUri, ConnectionHandler sessionHandler, WampOptions options, List<Pair> headers);
+
+    /**
+     * Connect to WAMP server.
+     *
+     * @param wsUri            The WebSockets URI of the server.
+     * @param sessionHandler   The handler for the session.
+     * @param options          WebSockets and Autobahn option.s
+     */
+    public void connect(String wsUri, ConnectionHandler sessionHandler, WampOptions options);
+
+    /**
+     * Disconnect from WAMP server.
+     */
+    public void disconnect();
+
+    /**
+     * Check if currently connected to server.
+     *
+     * @return True, iff connected.
+     */
+    public boolean isConnected();
+
+
+    /**
+     * Establish a prefix to be used in CURIEs to shorten URIs.
+     *
+     * @param prefix           The prefix to be used in CURIEs.
+     * @param uri              The full URI this prefix shall resolve to.
+     */
+    public void prefix(String prefix, String uri);
+
+    /**
+     * Call handler.
+     */
+    public interface CallHandler {
+
+        /**
+         * Fired on successful completion of call.
+         *
+         * @param result     The RPC result transformed into the type that was specified in call.
+         */
+        public void onResult(Object result);
+
+        /**
+         * Fired on call failure.
+         *
+         * @param errorUri   The URI or CURIE of the error that occurred.
+         * @param errorDesc  A human readable description of the error.
+         */
+        public void onError(String errorUri, String errorDesc);
+    }
+
+    /**
+     * Call a remote procedure (RPC).
+     *
+     * @param procUri       The URI or CURIE of the remote procedure to call.
+     * @param resultType    The type the call result gets transformed into.
+     * @param callHandler   The handler to be invoked upon call completion.
+     * @param arguments     Zero, one or more arguments for the call.
+     */
+    public void call(String procUri, Class<?> resultType, CallHandler callHandler, Object... arguments);
+
+    /**
+     * Call a remote procedure (RPC).
+     *
+     * @param procUri       The URI or CURIE of the remote procedure to call.
+     * @param resultType    The type the call result gets transformed into.
+     * @param callHandler   The handler to be invoked upon call completion.
+     * @param arguments     Zero, one or more arguments for the call.
+     */
+    public void call(String procUri, TypeReference<?> resultType, CallHandler callHandler, Object... arguments);
+
+    /**
+     * Handler for PubSub events.
+     */
+    public interface EventHandler {
+
+        /**
+         * Fired when an event for the PubSub subscription is received.
+         *
+         * @param topicUri   The URI or CURIE of the topic the event was published to.
+         * @param event      The event, transformed into the type that was specified when subscribing.
+         */
+        public void onEvent(String topicUri, Object event);
+    }
+
+    /**
+     * Subscribe to a topic. When already subscribed, overwrite the event handler.
+     *
+     * @param topicUri      The URI or CURIE of the topic to subscribe to.
+     * @param eventType     The type that event get transformed into.
+     * @param eventHandler  The event handler.
+     */
+    public void subscribe(String topicUri, Class<?> eventType, EventHandler eventHandler);
+
+    /**
+     * Subscribe to a topic. When already subscribed, overwrite the event handler.
+     *
+     * @param topicUri      The URI or CURIE of the topic to subscribe to.
+     * @param eventType     The type that event get transformed into.
+     * @param eventHandler  The event handler.
+     */
+    public void subscribe(String topicUri, TypeReference<?> eventType, EventHandler eventHandler);
+
+    /**
+     * Unsubscribe from given topic.
+     *
+     * @param topicUri      The URI or CURIE of the topic to unsubscribe from.
+     */
+    public void unsubscribe(String topicUri);
+
+    /**
+     * Unsubscribe from any topics subscribed.
+     */
+    public void unsubscribe();
+
+    /**
+     * Publish an event to the specified topic.
+     *
+     * @param topicUri      The URI or CURIE of the topic the event is to be published for.
+     * @param event         The event to be published.
+     */
+    public void publish(String topicUri, Object event);
 
 }
diff --git a/Autobahn/src/de/tavendo/autobahn/WampConnection.java b/Autobahn/src/de/tavendo/autobahn/WampConnection.java
index 487006c..68caf43 100644
--- a/Autobahn/src/de/tavendo/autobahn/WampConnection.java
+++ b/Autobahn/src/de/tavendo/autobahn/WampConnection.java
@@ -22,10 +22,10 @@
 import java.util.Random;
 import java.util.concurrent.ConcurrentHashMap;
 
-import org.apache.http.message.BasicNameValuePair;
 import org.codehaus.jackson.type.TypeReference;
 
 import android.os.HandlerThread;
+import android.support.v4.util.Pair;
 import android.util.Log;
 
 public class WampConnection extends WebSocketConnection implements Wamp {
@@ -180,7 +180,7 @@ public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler) {
     * @param sessionHandler   The session handler to fire callbacks on.
     * @param headers		   The headers for connection
     */
-   public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler, WampOptions options, List<BasicNameValuePair> headers) {
+   public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler, WampOptions options, List<Pair> headers) {
 
       mSessionHandler = sessionHandler;
 
@@ -222,7 +222,7 @@ public void onClose(int code, String reason) {
 
    }
 	
-   public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler, List<BasicNameValuePair> headers) {
+   public void connect(String wsUri, Wamp.ConnectionHandler sessionHandler, List<Pair> headers) {
 
 	   WampOptions options = new WampOptions();
 	   options.setReceiveTextMessagesRaw(true);
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java b/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java
index 5285f8b..018e282 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java
@@ -18,19 +18,19 @@
 
 package de.tavendo.autobahn;
 
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.support.v4.util.Pair;
+import android.util.Log;
+
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.nio.channels.SocketChannel;
 import java.util.List;
-import org.apache.http.message.BasicNameValuePair;
-
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Looper;
-import android.os.Message;
-import android.util.Log;
 
 public class WebSocketConnection implements WebSocket {
 
@@ -52,7 +52,7 @@
    private String mWsPath;
    private String mWsQuery;
    private String[] mWsSubprotocols;
-   private List<BasicNameValuePair> mWsHeaders;
+   private List<Pair> mWsHeaders;
 
    private WebSocket.ConnectionHandler mWsHandler;
 
@@ -217,7 +217,7 @@ public void connect(String wsUri, WebSocket.ConnectionHandler wsHandler, WebSock
    }
 
 
-   public void connect(String wsUri, String[] wsSubprotocols, WebSocket.ConnectionHandler wsHandler, WebSocketOptions options, List<BasicNameValuePair> headers) throws WebSocketException {
+   public void connect(String wsUri, String[] wsSubprotocols, WebSocket.ConnectionHandler wsHandler, WebSocketOptions options, List<Pair> headers) throws WebSocketException {
 
       // don't connect if already connected .. user needs to disconnect first
       //
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketMessage.java b/Autobahn/src/de/tavendo/autobahn/WebSocketMessage.java
index 393d2a6..0522085 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketMessage.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketMessage.java
@@ -1,25 +1,24 @@
 /******************************************************************************
- *
- *  Copyright 2011-2012 Tavendo GmbH
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
+ * Copyright 2011-2012 Tavendo GmbH
+ * <p/>
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * <p/>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p/>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ******************************************************************************/
 
 package de.tavendo.autobahn;
 
+import android.support.v4.util.Pair;
+
 import java.util.List;
-import org.apache.http.message.BasicNameValuePair;
 
 /**
  * WebSockets message classes.
@@ -28,169 +27,169 @@
  */
 public class WebSocketMessage {
 
-   /// Base message class.
-   public static class Message {
-   }
-
-   /// Quite background thread.
-   public static class Quit extends Message {
-   }
-
-   /// Initial WebSockets handshake (client request).
-   public static class ClientHandshake extends Message {
-
-      public String mHost;
-      public String mPath;
-      public String mQuery;
-      public String mOrigin;
-      public String[] mSubprotocols;
-      public List<BasicNameValuePair> mHeaderList;
-
-      ClientHandshake(String host) {
-         mHost = host;
-         mPath = "/";
-         mOrigin = null;
-         mSubprotocols = null;
-         mHeaderList = null;
-      }
-
-      ClientHandshake(String host, String path, String origin) {
-         mHost = host;
-         mPath = path;
-         mOrigin = origin;
-         mSubprotocols = null;
-      }
-
-      ClientHandshake(String host, String path, String origin, String[] subprotocols) {
-         mHost = host;
-         mPath = path;
-         mOrigin = origin;
-         mSubprotocols = subprotocols;
-      }
-   }
-
-   /// Initial WebSockets handshake (server response).
-   public static class ServerHandshake extends Message {
-	   public boolean mSuccess;
-	   
-	   public ServerHandshake(boolean success) {
-		   mSuccess = success;
-	   }
-   }
-
-   /// WebSockets connection lost
-   public static class ConnectionLost extends Message {
-   }
-   
-   public static class ServerError extends Message {
-	   public int mStatusCode;
-	   public String mStatusMessage;
-	   
-	   public ServerError(int statusCode, String statusMessage) {
-		   mStatusCode = statusCode;
-		   mStatusMessage = statusMessage;
-	   }
-	   
-   }
-
-   /// WebSockets reader detected WS protocol violation.
-   public static class ProtocolViolation extends Message {
-
-      public WebSocketException mException;
-
-      public ProtocolViolation(WebSocketException e) {
-         mException = e;
-      }
-   }
-
-   /// An exception occured in the WS reader or WS writer.
-   public static class Error extends Message {
-
-      public Exception mException;
-
-      public Error(Exception e) {
-         mException = e;
-      }
-   }
-
-   /// WebSockets text message to send or received.
-   public static class TextMessage extends Message {
-
-      public String mPayload;
-
-      TextMessage(String payload) {
-         mPayload = payload;
-      }
-   }
-
-   /// WebSockets raw (UTF-8) text message to send or received.
-   public static class RawTextMessage extends Message {
-
-      public byte[] mPayload;
-
-      RawTextMessage(byte[] payload) {
-         mPayload = payload;
-      }
-   }
-
-   /// WebSockets binary message to send or received.
-   public static class BinaryMessage extends Message {
-
-      public byte[] mPayload;
-
-      BinaryMessage(byte[] payload) {
-         mPayload = payload;
-      }
-   }
-
-   /// WebSockets close to send or received.
-   public static class Close extends Message {
-
-      public int mCode;
-      public String mReason;
-
-      Close() {
-         mCode = -1;
-         mReason = null;
-      }
-
-      Close(int code) {
-         mCode = code;
-         mReason = null;
-      }
-
-      Close(int code, String reason) {
-         mCode = code;
-         mReason = reason;
-      }
-   }
-
-   /// WebSockets ping to send or received.
-   public static class Ping extends Message {
-
-      public byte[] mPayload;
-
-      Ping() {
-         mPayload = null;
-      }
+    /// Base message class.
+    public static class Message {
+    }
+
+    /// Quite background thread.
+    public static class Quit extends Message {
+    }
+
+    /// Initial WebSockets handshake (client request).
+    public static class ClientHandshake extends Message {
+
+        public String mHost;
+        public String mPath;
+        public String mQuery;
+        public String mOrigin;
+        public String[] mSubprotocols;
+        public List<Pair> mHeaderList;
+
+        ClientHandshake(String host) {
+            mHost = host;
+            mPath = "/";
+            mOrigin = null;
+            mSubprotocols = null;
+            mHeaderList = null;
+        }
+
+        ClientHandshake(String host, String path, String origin) {
+            mHost = host;
+            mPath = path;
+            mOrigin = origin;
+            mSubprotocols = null;
+        }
+
+        ClientHandshake(String host, String path, String origin, String[] subprotocols) {
+            mHost = host;
+            mPath = path;
+            mOrigin = origin;
+            mSubprotocols = subprotocols;
+        }
+    }
+
+    /// Initial WebSockets handshake (server response).
+    public static class ServerHandshake extends Message {
+        public boolean mSuccess;
+
+        public ServerHandshake(boolean success) {
+            mSuccess = success;
+        }
+    }
+
+    /// WebSockets connection lost
+    public static class ConnectionLost extends Message {
+    }
+
+    public static class ServerError extends Message {
+        public int mStatusCode;
+        public String mStatusMessage;
+
+        public ServerError(int statusCode, String statusMessage) {
+            mStatusCode = statusCode;
+            mStatusMessage = statusMessage;
+        }
+
+    }
+
+    /// WebSockets reader detected WS protocol violation.
+    public static class ProtocolViolation extends Message {
+
+        public WebSocketException mException;
+
+        public ProtocolViolation(WebSocketException e) {
+            mException = e;
+        }
+    }
+
+    /// An exception occured in the WS reader or WS writer.
+    public static class Error extends Message {
+
+        public Exception mException;
+
+        public Error(Exception e) {
+            mException = e;
+        }
+    }
+
+    /// WebSockets text message to send or received.
+    public static class TextMessage extends Message {
+
+        public String mPayload;
+
+        TextMessage(String payload) {
+            mPayload = payload;
+        }
+    }
+
+    /// WebSockets raw (UTF-8) text message to send or received.
+    public static class RawTextMessage extends Message {
+
+        public byte[] mPayload;
+
+        RawTextMessage(byte[] payload) {
+            mPayload = payload;
+        }
+    }
+
+    /// WebSockets binary message to send or received.
+    public static class BinaryMessage extends Message {
+
+        public byte[] mPayload;
+
+        BinaryMessage(byte[] payload) {
+            mPayload = payload;
+        }
+    }
+
+    /// WebSockets close to send or received.
+    public static class Close extends Message {
+
+        public int mCode;
+        public String mReason;
+
+        Close() {
+            mCode = -1;
+            mReason = null;
+        }
+
+        Close(int code) {
+            mCode = code;
+            mReason = null;
+        }
+
+        Close(int code, String reason) {
+            mCode = code;
+            mReason = reason;
+        }
+    }
+
+    /// WebSockets ping to send or received.
+    public static class Ping extends Message {
+
+        public byte[] mPayload;
+
+        Ping() {
+            mPayload = null;
+        }
 
-      Ping(byte[] payload) {
-         mPayload = payload;
-      }
-   }
+        Ping(byte[] payload) {
+            mPayload = payload;
+        }
+    }
 
-   /// WebSockets pong to send or received.
-   public static class Pong extends Message {
+    /// WebSockets pong to send or received.
+    public static class Pong extends Message {
 
-      public byte[] mPayload;
+        public byte[] mPayload;
 
-      Pong() {
-         mPayload = null;
-      }
+        Pong() {
+            mPayload = null;
+        }
 
-      Pong(byte[] payload) {
-         mPayload = payload;
-      }
-   }
+        Pong(byte[] payload) {
+            mPayload = payload;
+        }
+    }
 
 }
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java b/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java
index 35cded5..5530d97 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java
@@ -1,35 +1,33 @@
 /******************************************************************************
- *
- *  Copyright 2011-2012 Tavendo GmbH
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
+ * Copyright 2011-2012 Tavendo GmbH
+ * <p/>
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * <p/>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p/>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  ******************************************************************************/
 
 package de.tavendo.autobahn;
 
-import java.io.IOException;
-import java.net.SocketException;
-import java.nio.channels.SocketChannel;
-import java.util.Random;
-
-import org.apache.http.NameValuePair;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
+import android.support.v4.util.Pair;
 import android.util.Base64;
 import android.util.Log;
 
+import java.io.IOException;
+import java.net.SocketException;
+import java.nio.channels.SocketChannel;
+import java.util.Random;
+
 /**
  * WebSocket writer, the sending leg of a WebSockets connection.
  * This is run on it's background thread with it's own message loop.
@@ -40,446 +38,446 @@
  */
 public class WebSocketWriter extends Handler {
 
-   private static final boolean DEBUG = true;
-   private static final String TAG = WebSocketWriter.class.getName();
-
-   /// Random number generator for handshake key and frame mask generation.
-   private final Random mRng = new Random();
-
-   /// Connection master.
-   private final Handler mMaster;
-
-   /// Message looper this object is running on.
-   private final Looper mLooper;
-
-   /// The NIO socket channel created on foreground thread.
-   private final SocketChannel mSocket;
-
-   /// WebSockets options.
-   private final WebSocketOptions mOptions;
-
-   /// The send buffer that holds data to send on socket.
-   private final ByteBufferOutputStream mBuffer;
-
-
-   /**
-    * Create new WebSockets background writer.
-    *
-    * @param looper    The message looper of the background thread on which
-    *                  this object is running.
-    * @param master    The message handler of master (foreground thread).
-    * @param socket    The socket channel created on foreground thread.
-    * @param options   WebSockets connection options.
-    */
-   public WebSocketWriter(Looper looper, Handler master, SocketChannel socket, WebSocketOptions options) {
-
-      super(looper);
-
-      mLooper = looper;
-      mMaster = master;
-      mSocket = socket;
-      mOptions = options;
-      mBuffer = new ByteBufferOutputStream(options.getMaxFramePayloadSize() + 14, 4*64*1024);
-
-      if (DEBUG) Log.d(TAG, "created");
-   }
-
-
-   /**
-    * Call this from the foreground (UI) thread to make the writer
-    * (running on background thread) send a WebSocket message on the
-    * underlying TCP.
-    *
-    * @param message       Message to send to WebSockets writer. An instance of the message
-    *                      classes inside WebSocketMessage or another type which then needs
-    *                      to be handled within processAppMessage() (in a class derived from
-    *                      this class).
-    */
-   public void forward(Object message) {
-
-      Message msg = obtainMessage();
-      msg.obj = message;
-      sendMessage(msg);
-   }
-
-
-   /**
-    * Notify the master (foreground thread).
-    *
-    * @param message       Message to send to master.
-    */
-   private void notify(Object message) {
-
-      Message msg = mMaster.obtainMessage();
-      msg.obj = message;
-      mMaster.sendMessage(msg);
-   }
-
-
-   /**
-    * Create new key for WebSockets handshake.
-    *
-    * @return WebSockets handshake key (Base64 encoded).
-    */
-   private String newHandshakeKey() {
-      final byte[] ba = new byte[16];
-      mRng.nextBytes(ba);
-      return Base64.encodeToString(ba, Base64.NO_WRAP);
-   }
-
-
-   /**
-    * Create new (random) frame mask.
-    *
-    * @return Frame mask (4 octets).
-    */
-   private byte[] newFrameMask() {
-      final byte[] ba = new byte[4];
-      mRng.nextBytes(ba);
-      return ba;
-   }
-
-
-   /**
-    * Send WebSocket client handshake.
-    */
-   private void sendClientHandshake(WebSocketMessage.ClientHandshake message) throws IOException {
-
-      // write HTTP header with handshake
-      String path;
-      if (message.mQuery != null) {
-         path = message.mPath + "?" + message.mQuery;
-      } else {
-         path = message.mPath;
-      }
-      mBuffer.write("GET " + path + " HTTP/1.1");
-      mBuffer.crlf();
-      mBuffer.write("Host: " + message.mHost);
-      mBuffer.crlf();
-      mBuffer.write("Upgrade: WebSocket");
-      mBuffer.crlf();
-      mBuffer.write("Connection: Upgrade");
-      mBuffer.crlf();
-
-      mBuffer.write("Sec-WebSocket-Key: " + newHandshakeKey());
-      mBuffer.crlf();
-
-      if (message.mOrigin != null && !message.mOrigin.equals("")) {
-         mBuffer.write("Origin: " + message.mOrigin);
-         mBuffer.crlf();
-      }
-
-      if (message.mSubprotocols != null && message.mSubprotocols.length > 0) {
-         mBuffer.write("Sec-WebSocket-Protocol: ");
-         for (int i = 0; i < message.mSubprotocols.length; ++i) {
-            mBuffer.write(message.mSubprotocols[i]);
-            if (i != message.mSubprotocols.length-1) {
-               mBuffer.write(", ");
+    private static final boolean DEBUG = true;
+    private static final String TAG = WebSocketWriter.class.getName();
+
+    /// Random number generator for handshake key and frame mask generation.
+    private final Random mRng = new Random();
+
+    /// Connection master.
+    private final Handler mMaster;
+
+    /// Message looper this object is running on.
+    private final Looper mLooper;
+
+    /// The NIO socket channel created on foreground thread.
+    private final SocketChannel mSocket;
+
+    /// WebSockets options.
+    private final WebSocketOptions mOptions;
+
+    /// The send buffer that holds data to send on socket.
+    private final ByteBufferOutputStream mBuffer;
+
+
+    /**
+     * Create new WebSockets background writer.
+     *
+     * @param looper  The message looper of the background thread on which
+     *                this object is running.
+     * @param master  The message handler of master (foreground thread).
+     * @param socket  The socket channel created on foreground thread.
+     * @param options WebSockets connection options.
+     */
+    public WebSocketWriter(Looper looper, Handler master, SocketChannel socket, WebSocketOptions options) {
+
+        super(looper);
+
+        mLooper = looper;
+        mMaster = master;
+        mSocket = socket;
+        mOptions = options;
+        mBuffer = new ByteBufferOutputStream(options.getMaxFramePayloadSize() + 14, 4 * 64 * 1024);
+
+        if (DEBUG) Log.d(TAG, "created");
+    }
+
+
+    /**
+     * Call this from the foreground (UI) thread to make the writer
+     * (running on background thread) send a WebSocket message on the
+     * underlying TCP.
+     *
+     * @param message Message to send to WebSockets writer. An instance of the message
+     *                classes inside WebSocketMessage or another type which then needs
+     *                to be handled within processAppMessage() (in a class derived from
+     *                this class).
+     */
+    public void forward(Object message) {
+
+        Message msg = obtainMessage();
+        msg.obj = message;
+        sendMessage(msg);
+    }
+
+
+    /**
+     * Notify the master (foreground thread).
+     *
+     * @param message Message to send to master.
+     */
+    private void notify(Object message) {
+
+        Message msg = mMaster.obtainMessage();
+        msg.obj = message;
+        mMaster.sendMessage(msg);
+    }
+
+
+    /**
+     * Create new key for WebSockets handshake.
+     *
+     * @return WebSockets handshake key (Base64 encoded).
+     */
+    private String newHandshakeKey() {
+        final byte[] ba = new byte[16];
+        mRng.nextBytes(ba);
+        return Base64.encodeToString(ba, Base64.NO_WRAP);
+    }
+
+
+    /**
+     * Create new (random) frame mask.
+     *
+     * @return Frame mask (4 octets).
+     */
+    private byte[] newFrameMask() {
+        final byte[] ba = new byte[4];
+        mRng.nextBytes(ba);
+        return ba;
+    }
+
+
+    /**
+     * Send WebSocket client handshake.
+     */
+    private void sendClientHandshake(WebSocketMessage.ClientHandshake message) throws IOException {
+
+        // write HTTP header with handshake
+        String path;
+        if (message.mQuery != null) {
+            path = message.mPath + "?" + message.mQuery;
+        } else {
+            path = message.mPath;
+        }
+        mBuffer.write("GET " + path + " HTTP/1.1");
+        mBuffer.crlf();
+        mBuffer.write("Host: " + message.mHost);
+        mBuffer.crlf();
+        mBuffer.write("Upgrade: WebSocket");
+        mBuffer.crlf();
+        mBuffer.write("Connection: Upgrade");
+        mBuffer.crlf();
+
+        mBuffer.write("Sec-WebSocket-Key: " + newHandshakeKey());
+        mBuffer.crlf();
+
+        if (message.mOrigin != null && !message.mOrigin.equals("")) {
+            mBuffer.write("Origin: " + message.mOrigin);
+            mBuffer.crlf();
+        }
+
+        if (message.mSubprotocols != null && message.mSubprotocols.length > 0) {
+            mBuffer.write("Sec-WebSocket-Protocol: ");
+            for (int i = 0; i < message.mSubprotocols.length; ++i) {
+                mBuffer.write(message.mSubprotocols[i]);
+                if (i != message.mSubprotocols.length - 1) {
+                    mBuffer.write(", ");
+                }
             }
-         }
-         mBuffer.crlf();
-      }
-
-      mBuffer.write("Sec-WebSocket-Version: 13");
-      mBuffer.crlf();
-
-      // Header injection      
-      if (message.mHeaderList != null) {
-          for (NameValuePair pair : message.mHeaderList) {
-        	  mBuffer.write( pair.getName() + ":" + pair.getValue() );
-        	  mBuffer.crlf();
-          }
-      }           
-      mBuffer.crlf();
-   }
-
-
-   /**
-    * Send WebSockets close.
-    */
-   private void sendClose(WebSocketMessage.Close message) throws IOException, WebSocketException {
-
-      if (message.mCode > 0) {
-
-         byte[] payload = null;
-
-         if (message.mReason != null && !message.mReason.equals("")) {
-            byte[] pReason = message.mReason.getBytes("UTF-8");
-            payload = new byte[2 + pReason.length];
-            for (int i = 0; i < pReason.length; ++i) {
-               payload[i + 2] = pReason[i];
-            }
-         } else {
-            payload = new byte[2];
-         }
-
-         if (payload != null && payload.length > 125) {
-            throw new WebSocketException("close payload exceeds 125 octets");
-         }
-
-         payload[0] = (byte)((message.mCode >> 8) & 0xff);
-         payload[1] = (byte)(message.mCode & 0xff);
-
-         sendFrame(8, true, payload);
-
-      } else {
-
-         sendFrame(8, true, null);
-      }
-   }
-
-
-   /**
-    * Send WebSockets ping.
-    */
-   private void sendPing(WebSocketMessage.Ping message) throws IOException, WebSocketException {
-      if (message.mPayload != null && message.mPayload.length > 125) {
-         throw new WebSocketException("ping payload exceeds 125 octets");
-      }
-      sendFrame(9, true, message.mPayload);
-   }
-
-
-   /**
-    * Send WebSockets pong. Normally, unsolicited Pongs are not used,
-    * but Pongs are only send in response to a Ping from the peer.
-    */
-   private void sendPong(WebSocketMessage.Pong message) throws IOException, WebSocketException {
-      if (message.mPayload != null && message.mPayload.length > 125) {
-         throw new WebSocketException("pong payload exceeds 125 octets");
-      }
-      sendFrame(10, true, message.mPayload);
-   }
-
-
-   /**
-    * Send WebSockets binary message.
-    */
-   private void sendBinaryMessage(WebSocketMessage.BinaryMessage message) throws IOException, WebSocketException {
-      if (message.mPayload.length > mOptions.getMaxMessagePayloadSize()) {
-         throw new WebSocketException("message payload exceeds payload limit");
-      }
-      sendFrame(2, true, message.mPayload);
-   }
-
-
-   /**
-    * Send WebSockets text message.
-    */
-   private void sendTextMessage(WebSocketMessage.TextMessage message) throws IOException, WebSocketException {
-      byte[] payload = message.mPayload.getBytes("UTF-8");
-      if (payload.length > mOptions.getMaxMessagePayloadSize()) {
-         throw new WebSocketException("message payload exceeds payload limit");
-      }
-      sendFrame(1, true, payload);
-   }
-
-
-   /**
-    * Send WebSockets binary message.
-    */
-   private void sendRawTextMessage(WebSocketMessage.RawTextMessage message) throws IOException, WebSocketException {
-      if (message.mPayload.length > mOptions.getMaxMessagePayloadSize()) {
-         throw new WebSocketException("message payload exceeds payload limit");
-      }
-      sendFrame(1, true, message.mPayload);
-   }
-
-
-   /**
-    * Sends a WebSockets frame. Only need to use this method in derived classes which implement
-    * more message types in processAppMessage(). You need to know what you are doing!
-    *
-    * @param opcode     The WebSocket frame opcode.
-    * @param fin        FIN flag for WebSocket frame.
-    * @param payload    Frame payload or null.
-    */
-   protected void sendFrame(int opcode, boolean fin, byte[] payload) throws IOException {
-      if (payload != null) {
-         sendFrame(opcode, fin, payload, 0, payload.length);
-      } else {
-         sendFrame(opcode, fin, null, 0, 0);
-      }
-   }
-
-
-   /**
-    * Sends a WebSockets frame. Only need to use this method in derived classes which implement
-    * more message types in processAppMessage(). You need to know what you are doing!
-    *
-    * @param opcode     The WebSocket frame opcode.
-    * @param fin        FIN flag for WebSocket frame.
-    * @param payload    Frame payload or null.
-    * @param offset     Offset within payload of the chunk to send.
-    * @param length     Length of the chunk within payload to send.
-    */
-   protected void sendFrame(int opcode, boolean fin, byte[] payload, int offset, int length) throws IOException {
-
-      // first octet
-      byte b0 = 0;
-      if (fin) {
-         b0 |= (byte) (1 << 7);
-      }
-      b0 |= (byte) opcode;
-      mBuffer.write(b0);
-
-      // second octet
-      byte b1 = 0;
-      if (mOptions.getMaskClientFrames()) {
-         b1 = (byte) (1 << 7);
-      }
-
-      long len = length;
-
-      // extended payload length
-      if (len <= 125) {
-         b1 |= (byte) len;
-         mBuffer.write(b1);
-      } else if (len <= 0xffff) {
-         b1 |= (byte) (126 & 0xff);
-         mBuffer.write(b1);
-         mBuffer.write(new byte[] {(byte)((len >> 8) & 0xff),
-                                   (byte)(len & 0xff)});
-      } else {
-         b1 |= (byte) (127 & 0xff);
-         mBuffer.write(b1);
-         mBuffer.write(new byte[] {(byte)((len >> 56) & 0xff),
-                                   (byte)((len >> 48) & 0xff),
-                                   (byte)((len >> 40) & 0xff),
-                                   (byte)((len >> 32) & 0xff),
-                                   (byte)((len >> 24) & 0xff),
-                                   (byte)((len >> 16) & 0xff),
-                                   (byte)((len >> 8)  & 0xff),
-                                   (byte)(len         & 0xff)});
-      }
-
-      byte mask[] = null;
-      if (mOptions.getMaskClientFrames()) {
-         // a mask is always needed, even without payload
-         mask = newFrameMask();
-         mBuffer.write(mask[0]);
-         mBuffer.write(mask[1]);
-         mBuffer.write(mask[2]);
-         mBuffer.write(mask[3]);
-      }
-
-      if (len > 0) {
-         if (mOptions.getMaskClientFrames()) {
-            /// \todo optimize masking
-            /// \todo masking within buffer of output stream
-            for (int i = 0; i < len; ++i) {
-               payload[i + offset] ^= mask[i % 4];
+            mBuffer.crlf();
+        }
+
+        mBuffer.write("Sec-WebSocket-Version: 13");
+        mBuffer.crlf();
+
+        // Header injection
+        if (message.mHeaderList != null) {
+            for (Pair pair : message.mHeaderList) {
+                mBuffer.write(pair.first + ":" + pair.second);
+                mBuffer.crlf();
             }
-         }
-         mBuffer.write(payload, offset, length);
-      }
-   }
+        }
+        mBuffer.crlf();
+    }
+
+
+    /**
+     * Send WebSockets close.
+     */
+    private void sendClose(WebSocketMessage.Close message) throws IOException, WebSocketException {
 
+        if (message.mCode > 0) {
 
-   /**
-    * Process message received from foreground thread. This is called from
-    * the message looper set up for the background thread running this writer.
-    *
-    * @param msg     Message from thread message queue.
-    */
-   @Override
-   public void handleMessage(Message msg) {
+            byte[] payload = null;
 
-      try {
+            if (message.mReason != null && !message.mReason.equals("")) {
+                byte[] pReason = message.mReason.getBytes("UTF-8");
+                payload = new byte[2 + pReason.length];
+                for (int i = 0; i < pReason.length; ++i) {
+                    payload[i + 2] = pReason[i];
+                }
+            } else {
+                payload = new byte[2];
+            }
+
+            if (payload != null && payload.length > 125) {
+                throw new WebSocketException("close payload exceeds 125 octets");
+            }
 
-         // clear send buffer
-         mBuffer.clear();
+            payload[0] = (byte) ((message.mCode >> 8) & 0xff);
+            payload[1] = (byte) (message.mCode & 0xff);
+
+            sendFrame(8, true, payload);
+
+        } else {
+
+            sendFrame(8, true, null);
+        }
+    }
+
+
+    /**
+     * Send WebSockets ping.
+     */
+    private void sendPing(WebSocketMessage.Ping message) throws IOException, WebSocketException {
+        if (message.mPayload != null && message.mPayload.length > 125) {
+            throw new WebSocketException("ping payload exceeds 125 octets");
+        }
+        sendFrame(9, true, message.mPayload);
+    }
+
+
+    /**
+     * Send WebSockets pong. Normally, unsolicited Pongs are not used,
+     * but Pongs are only send in response to a Ping from the peer.
+     */
+    private void sendPong(WebSocketMessage.Pong message) throws IOException, WebSocketException {
+        if (message.mPayload != null && message.mPayload.length > 125) {
+            throw new WebSocketException("pong payload exceeds 125 octets");
+        }
+        sendFrame(10, true, message.mPayload);
+    }
+
+
+    /**
+     * Send WebSockets binary message.
+     */
+    private void sendBinaryMessage(WebSocketMessage.BinaryMessage message) throws IOException, WebSocketException {
+        if (message.mPayload.length > mOptions.getMaxMessagePayloadSize()) {
+            throw new WebSocketException("message payload exceeds payload limit");
+        }
+        sendFrame(2, true, message.mPayload);
+    }
+
+
+    /**
+     * Send WebSockets text message.
+     */
+    private void sendTextMessage(WebSocketMessage.TextMessage message) throws IOException, WebSocketException {
+        byte[] payload = message.mPayload.getBytes("UTF-8");
+        if (payload.length > mOptions.getMaxMessagePayloadSize()) {
+            throw new WebSocketException("message payload exceeds payload limit");
+        }
+        sendFrame(1, true, payload);
+    }
+
+
+    /**
+     * Send WebSockets binary message.
+     */
+    private void sendRawTextMessage(WebSocketMessage.RawTextMessage message) throws IOException, WebSocketException {
+        if (message.mPayload.length > mOptions.getMaxMessagePayloadSize()) {
+            throw new WebSocketException("message payload exceeds payload limit");
+        }
+        sendFrame(1, true, message.mPayload);
+    }
+
+
+    /**
+     * Sends a WebSockets frame. Only need to use this method in derived classes which implement
+     * more message types in processAppMessage(). You need to know what you are doing!
+     *
+     * @param opcode  The WebSocket frame opcode.
+     * @param fin     FIN flag for WebSocket frame.
+     * @param payload Frame payload or null.
+     */
+    protected void sendFrame(int opcode, boolean fin, byte[] payload) throws IOException {
+        if (payload != null) {
+            sendFrame(opcode, fin, payload, 0, payload.length);
+        } else {
+            sendFrame(opcode, fin, null, 0, 0);
+        }
+    }
+
+
+    /**
+     * Sends a WebSockets frame. Only need to use this method in derived classes which implement
+     * more message types in processAppMessage(). You need to know what you are doing!
+     *
+     * @param opcode  The WebSocket frame opcode.
+     * @param fin     FIN flag for WebSocket frame.
+     * @param payload Frame payload or null.
+     * @param offset  Offset within payload of the chunk to send.
+     * @param length  Length of the chunk within payload to send.
+     */
+    protected void sendFrame(int opcode, boolean fin, byte[] payload, int offset, int length) throws IOException {
+
+        // first octet
+        byte b0 = 0;
+        if (fin) {
+            b0 |= (byte) (1 << 7);
+        }
+        b0 |= (byte) opcode;
+        mBuffer.write(b0);
+
+        // second octet
+        byte b1 = 0;
+        if (mOptions.getMaskClientFrames()) {
+            b1 = (byte) (1 << 7);
+        }
+
+        long len = length;
+
+        // extended payload length
+        if (len <= 125) {
+            b1 |= (byte) len;
+            mBuffer.write(b1);
+        } else if (len <= 0xffff) {
+            b1 |= (byte) (126 & 0xff);
+            mBuffer.write(b1);
+            mBuffer.write(new byte[]{(byte) ((len >> 8) & 0xff),
+                    (byte) (len & 0xff)});
+        } else {
+            b1 |= (byte) (127 & 0xff);
+            mBuffer.write(b1);
+            mBuffer.write(new byte[]{(byte) ((len >> 56) & 0xff),
+                    (byte) ((len >> 48) & 0xff),
+                    (byte) ((len >> 40) & 0xff),
+                    (byte) ((len >> 32) & 0xff),
+                    (byte) ((len >> 24) & 0xff),
+                    (byte) ((len >> 16) & 0xff),
+                    (byte) ((len >> 8) & 0xff),
+                    (byte) (len & 0xff)});
+        }
+
+        byte mask[] = null;
+        if (mOptions.getMaskClientFrames()) {
+            // a mask is always needed, even without payload
+            mask = newFrameMask();
+            mBuffer.write(mask[0]);
+            mBuffer.write(mask[1]);
+            mBuffer.write(mask[2]);
+            mBuffer.write(mask[3]);
+        }
+
+        if (len > 0) {
+            if (mOptions.getMaskClientFrames()) {
+                /// \todo optimize masking
+                /// \todo masking within buffer of output stream
+                for (int i = 0; i < len; ++i) {
+                    payload[i + offset] ^= mask[i % 4];
+                }
+            }
+            mBuffer.write(payload, offset, length);
+        }
+    }
+
+
+    /**
+     * Process message received from foreground thread. This is called from
+     * the message looper set up for the background thread running this writer.
+     *
+     * @param msg Message from thread message queue.
+     */
+    @Override
+    public void handleMessage(Message msg) {
+
+        try {
+
+            // clear send buffer
+            mBuffer.clear();
+
+            // process message from master
+            processMessage(msg.obj);
+
+            // send out buffered data
+            mBuffer.flip();
+            while (mBuffer.remaining() > 0) {
+                // this can block on socket write
+                @SuppressWarnings("unused")
+                int written = mSocket.write(mBuffer.getBuffer());
+            }
 
-         // process message from master
-         processMessage(msg.obj);
+        } catch (SocketException e) {
 
-         // send out buffered data
-         mBuffer.flip();
-         while (mBuffer.remaining() > 0) {
-            // this can block on socket write
-            @SuppressWarnings("unused")
-            int written = mSocket.write(mBuffer.getBuffer());
-         }
+            if (DEBUG) Log.d(TAG, "run() : SocketException (" + e.toString() + ")");
 
-      } catch (SocketException e) {
-    	  
-    	  if (DEBUG) Log.d(TAG, "run() : SocketException (" + e.toString() + ")");
-    	  
-    	  // wrap the exception and notify master
-    	  notify(new WebSocketMessage.ConnectionLost());
-      } catch (Exception e) {
+            // wrap the exception and notify master
+            notify(new WebSocketMessage.ConnectionLost());
+        } catch (Exception e) {
 
-         if (DEBUG) e.printStackTrace();
+            if (DEBUG) e.printStackTrace();
 
-         // wrap the exception and notify master
-         notify(new WebSocketMessage.Error(e));
-      }
-   }
+            // wrap the exception and notify master
+            notify(new WebSocketMessage.Error(e));
+        }
+    }
 
 
-   /**
-    * Process WebSockets or control message from master. Normally,
-    * there should be no reason to override this. If you do, you
-    * need to know what you are doing.
-    *
-    * @param msg     An instance of the message types within WebSocketMessage
-    *                or a message that is handled in processAppMessage().
-    */
-   protected void processMessage(Object msg) throws IOException, WebSocketException {
+    /**
+     * Process WebSockets or control message from master. Normally,
+     * there should be no reason to override this. If you do, you
+     * need to know what you are doing.
+     *
+     * @param msg An instance of the message types within WebSocketMessage
+     *            or a message that is handled in processAppMessage().
+     */
+    protected void processMessage(Object msg) throws IOException, WebSocketException {
 
-      if (msg instanceof WebSocketMessage.TextMessage) {
+        if (msg instanceof WebSocketMessage.TextMessage) {
 
-         sendTextMessage((WebSocketMessage.TextMessage) msg);
+            sendTextMessage((WebSocketMessage.TextMessage) msg);
 
-      } else if (msg instanceof WebSocketMessage.RawTextMessage) {
+        } else if (msg instanceof WebSocketMessage.RawTextMessage) {
 
-         sendRawTextMessage((WebSocketMessage.RawTextMessage) msg);
+            sendRawTextMessage((WebSocketMessage.RawTextMessage) msg);
 
-      } else if (msg instanceof WebSocketMessage.BinaryMessage) {
+        } else if (msg instanceof WebSocketMessage.BinaryMessage) {
 
-         sendBinaryMessage((WebSocketMessage.BinaryMessage) msg);
+            sendBinaryMessage((WebSocketMessage.BinaryMessage) msg);
 
-      } else if (msg instanceof WebSocketMessage.Ping) {
+        } else if (msg instanceof WebSocketMessage.Ping) {
 
-         sendPing((WebSocketMessage.Ping) msg);
+            sendPing((WebSocketMessage.Ping) msg);
 
-      } else if (msg instanceof WebSocketMessage.Pong) {
+        } else if (msg instanceof WebSocketMessage.Pong) {
 
-         sendPong((WebSocketMessage.Pong) msg);
+            sendPong((WebSocketMessage.Pong) msg);
 
-      } else if (msg instanceof WebSocketMessage.Close) {
+        } else if (msg instanceof WebSocketMessage.Close) {
 
-         sendClose((WebSocketMessage.Close) msg);
+            sendClose((WebSocketMessage.Close) msg);
 
-      } else if (msg instanceof WebSocketMessage.ClientHandshake) {
+        } else if (msg instanceof WebSocketMessage.ClientHandshake) {
 
-         sendClientHandshake((WebSocketMessage.ClientHandshake) msg);
+            sendClientHandshake((WebSocketMessage.ClientHandshake) msg);
 
-      } else if (msg instanceof WebSocketMessage.Quit) {
+        } else if (msg instanceof WebSocketMessage.Quit) {
 
-         mLooper.quit();
+            mLooper.quit();
 
-         if  (DEBUG) Log.d(TAG, "ended");
+            if (DEBUG) Log.d(TAG, "ended");
 
-         return;
+            return;
 
-      } else {
+        } else {
 
-         // call hook which may be overridden in derived class to process
-         // messages we don't understand in this class
-         processAppMessage(msg);
-      }
-   }
+            // call hook which may be overridden in derived class to process
+            // messages we don't understand in this class
+            processAppMessage(msg);
+        }
+    }
 
 
-   /**
-    * Process message other than plain WebSockets or control message.
-    * This is intended to be overridden in derived classes.
-    *
-    * @param msg      Message from foreground thread to process.
-    */
-   protected void processAppMessage(Object msg) throws WebSocketException, IOException {
+    /**
+     * Process message other than plain WebSockets or control message.
+     * This is intended to be overridden in derived classes.
+     *
+     * @param msg Message from foreground thread to process.
+     */
+    protected void processAppMessage(Object msg) throws WebSocketException, IOException {
 
-      throw new WebSocketException("unknown message received by WebSocketWriter");
-   }
+        throw new WebSocketException("unknown message received by WebSocketWriter");
+    }
 }
