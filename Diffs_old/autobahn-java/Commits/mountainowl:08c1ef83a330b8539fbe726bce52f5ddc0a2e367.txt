diff --git a/.gitignore b/.gitignore
index 4f542e9..8e337db 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,4 +1,4 @@
-.metadata/*
+ametadata/*
 Autobahn/doc/html/*
 
 ### Java ###
@@ -40,4 +40,5 @@ local.properties
 *.iml
 *.ipr
 *.iws
-.idea/
\ No newline at end of file
+.idea/
+.gradle/**
diff --git a/Autobahn/.gitignore b/Autobahn/.gitignore
index 7b6a007..f65519e 100644
--- a/Autobahn/.gitignore
+++ b/Autobahn/.gitignore
@@ -1,7 +1 @@
-bin/*
-gen/*
-!gen/PLACEHOLDER
-*.jar
-!libs/*
-.sconsign.dblite
-_upload
+build/**
diff --git a/Autobahn/.gradle/2.8/taskArtifacts/cache.properties.lock b/Autobahn/.gradle/2.8/taskArtifacts/cache.properties.lock
deleted file mode 100644
index 4e66876..0000000
Binary files a/Autobahn/.gradle/2.8/taskArtifacts/cache.properties.lock and /dev/null differ
diff --git a/Autobahn/.gradle/2.8/taskArtifacts/fileHashes.bin b/Autobahn/.gradle/2.8/taskArtifacts/fileHashes.bin
deleted file mode 100644
index 49613bd..0000000
Binary files a/Autobahn/.gradle/2.8/taskArtifacts/fileHashes.bin and /dev/null differ
diff --git a/Autobahn/.gradle/2.8/taskArtifacts/fileSnapshots.bin b/Autobahn/.gradle/2.8/taskArtifacts/fileSnapshots.bin
deleted file mode 100644
index d2f8899..0000000
Binary files a/Autobahn/.gradle/2.8/taskArtifacts/fileSnapshots.bin and /dev/null differ
diff --git a/Autobahn/.gradle/2.8/taskArtifacts/outputFileStates.bin b/Autobahn/.gradle/2.8/taskArtifacts/outputFileStates.bin
deleted file mode 100644
index a949835..0000000
Binary files a/Autobahn/.gradle/2.8/taskArtifacts/outputFileStates.bin and /dev/null differ
diff --git a/Autobahn/.gradle/2.8/taskArtifacts/taskArtifacts.bin b/Autobahn/.gradle/2.8/taskArtifacts/taskArtifacts.bin
deleted file mode 100644
index 45055f8..0000000
Binary files a/Autobahn/.gradle/2.8/taskArtifacts/taskArtifacts.bin and /dev/null differ
diff --git a/Autobahn/build/intermediates/bundles/debug/AndroidManifest.xml b/Autobahn/build/intermediates/bundles/debug/AndroidManifest.xml
deleted file mode 100644
index c5c6fca..0000000
--- a/Autobahn/build/intermediates/bundles/debug/AndroidManifest.xml
+++ /dev/null
@@ -1,13 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="de.tavendo.autobahn"
-    android:versionCode="1"
-    android:versionName="0.1" >
-
-    <uses-sdk
-        android:minSdkVersion="19"
-        android:targetSdkVersion="23" />
-
-    <application android:label="Autobahn" />
-
-</manifest>
\ No newline at end of file
diff --git a/Autobahn/build/intermediates/bundles/debug/aapt/AndroidManifest.xml b/Autobahn/build/intermediates/bundles/debug/aapt/AndroidManifest.xml
deleted file mode 100644
index c5c6fca..0000000
--- a/Autobahn/build/intermediates/bundles/debug/aapt/AndroidManifest.xml
+++ /dev/null
@@ -1,13 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="de.tavendo.autobahn"
-    android:versionCode="1"
-    android:versionName="0.1" >
-
-    <uses-sdk
-        android:minSdkVersion="19"
-        android:targetSdkVersion="23" />
-
-    <application android:label="Autobahn" />
-
-</manifest>
\ No newline at end of file
diff --git a/Autobahn/build/intermediates/manifest/androidTest/debug/AndroidManifest.xml b/Autobahn/build/intermediates/manifest/androidTest/debug/AndroidManifest.xml
deleted file mode 100644
index 20ba153..0000000
--- a/Autobahn/build/intermediates/manifest/androidTest/debug/AndroidManifest.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="de.tavendo.autobahn.test" >
-
-    <uses-sdk
-        android:minSdkVersion="19"
-        android:targetSdkVersion="23" />
-
-    <instrumentation
-        android:name="android.test.InstrumentationTestRunner"
-        android:functionalTest="false"
-        android:handleProfiling="false"
-        android:label="Tests for de.tavendo.autobahn.test"
-        android:targetPackage="de.tavendo.autobahn.test" />
-
-    <application android:label="Autobahn" >
-        <uses-library android:name="android.test.runner" />
-    </application>
-
-</manifest>
\ No newline at end of file
diff --git a/Autobahn/build/intermediates/manifest/tmp/manifestMerger7356070509566745059.xml b/Autobahn/build/intermediates/manifest/tmp/manifestMerger7356070509566745059.xml
deleted file mode 100644
index 6bd1632..0000000
--- a/Autobahn/build/intermediates/manifest/tmp/manifestMerger7356070509566745059.xml
+++ /dev/null
@@ -1,16 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="de.tavendo.autobahn.test">
-
-    <uses-sdk android:minSdkVersion="19" android:targetSdkVersion="23" />
-
-    <application>
-        <uses-library android:name="android.test.runner" />
-    </application>
-
-    <instrumentation android:name="android.test.InstrumentationTestRunner"
-                     android:targetPackage="de.tavendo.autobahn.test"
-                     android:handleProfiling="false"
-                     android:functionalTest="false"
-                     android:label="Tests for de.tavendo.autobahn.test"/>
-</manifest>
diff --git a/Autobahn/build/intermediates/res/resources-debug-androidTest.ap_ b/Autobahn/build/intermediates/res/resources-debug-androidTest.ap_
deleted file mode 100644
index 09de1b4..0000000
Binary files a/Autobahn/build/intermediates/res/resources-debug-androidTest.ap_ and /dev/null differ
diff --git a/Autobahn/src/de/tavendo/autobahn/NioSslPeer.java b/Autobahn/src/de/tavendo/autobahn/NioSslPeer.java
new file mode 100644
index 0000000..597445f
--- /dev/null
+++ b/Autobahn/src/de/tavendo/autobahn/NioSslPeer.java
@@ -0,0 +1,424 @@
+package de.tavendo.autobahn;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.util.Log;
+
+import java.io.IOException;
+import java.nio.BufferOverflowException;
+import java.nio.ByteBuffer;
+import java.nio.channels.SocketChannel;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLEngineResult;
+import javax.net.ssl.SSLEngineResult.HandshakeStatus;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLSession;
+
+
+/**
+ * A class that represents an SSL/TLS peer, and can be extended to create a client or a server.
+ * <p>
+ * It makes use of the JSSE framework, and specifically the {@link SSLEngine} logic, which
+ * is described by Oracle as "an advanced API, not appropriate for casual use", since
+ * it requires the user to implement much of the communication establishment procedure himself.
+ * More information about it can be found here: http://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERefGuide.html#SSLEngine
+ * <p>
+ * {@link NioSslPeer} implements the handshake protocol, required to establish a connection between two peers,
+ * which is common for both client and server and provides the abstract {@link NioSslPeer#read(SocketChannel, SSLEngine)} and
+ * {@link NioSslPeer#write(SocketChannel, SSLEngine, String)} methods, that need to be implemented by the specific SSL/TLS peer
+ * that is going to extend this class.
+ *
+ * @author <a href="mailto:travelling.with.code@gmail.com">Alex</a>
+ */
+public class NioSslPeer extends Handler {
+
+    private static final String TAG = NioSslPeer.class.getSimpleName();
+
+    /**
+     * Will contain this peer's application data in plaintext, that will be later encrypted
+     * using {@link SSLEngine#wrap(ByteBuffer, ByteBuffer)} and sent to the other peer. This buffer can typically
+     * be of any size, as long as it is large enough to contain this peer's outgoing messages.
+     * If this peer tries to send a message bigger than buffer's capacity a {@link BufferOverflowException}
+     * will be thrown.
+     */
+    protected ByteBuffer myAppData;
+
+    /**
+     * Will contain this peer's encrypted data, that will be generated after {@link javax.net.ssl.SSLEngine#wrap(ByteBuffer, ByteBuffer)}
+     * is applied on {@link NioSslPeer#myAppData}. It should be initialized using {@link SSLSession#getPacketBufferSize()},
+     * which returns the size up to which, SSL/TLS packets will be generated from the engine under a session.
+     * All SSLEngine network buffers should be sized at least this large to avoid insufficient space problems when performing wrap and unwrap calls.
+     */
+    protected ByteBuffer myNetData;
+
+    /**
+     * Will contain the other peer's (decrypted) application data. It must be large enough to hold the application data
+     * from any peer. Can be initialized with {@link SSLSession#getApplicationBufferSize()} for an estimation
+     * of the other peer's application data and should be enlarged if this size is not enough.
+     */
+    protected ByteBuffer peerAppData;
+
+    /**
+     * Will contain the other peer's encrypted data. The SSL/TLS protocols specify that implementations should produce packets containing at most 16 KB of plaintext,
+     * so a buffer sized to this value should normally cause no capacity problems. However, some implementations violate the specification and generate large records up to 32 KB.
+     * If the {@link SSLEngine#unwrap(ByteBuffer, ByteBuffer)} detects large inbound packets, the buffer sizes returned by SSLSession will be updated dynamically, so the this peer
+     * should check for overflow conditions and enlarge the buffer using the session's (updated) buffer size.
+     */
+    protected ByteBuffer peerNetData;
+
+    /**
+     * Will be used to execute tasks that may emerge during handshake in parallel with the server's main thread.
+     */
+    protected ExecutorService executor = Executors.newSingleThreadExecutor();
+
+    public NioSslPeer(Looper looper) {
+        super(looper);
+    }
+
+    /**
+     * Implements the handshake protocol between two peers, required for the establishment of the SSL/TLS connection.
+     * During the handshake, encryption configuration information - such as the list of available cipher suites - will be exchanged
+     * and if the handshake is successful will lead to an established SSL/TLS session.
+     * <p>
+     * <p>
+     * A typical handshake will usually contain the following steps:
+     * <p>
+     * <ul>
+     * <li>1. wrap:     ClientHello</li>
+     * <li>2. unwrap:   ServerHello/Cert/ServerHelloDone</li>
+     * <li>3. wrap:     ClientKeyExchange</li>
+     * <li>4. wrap:     ChangeCipherSpec</li>
+     * <li>5. wrap:     Finished</li>
+     * <li>6. unwrap:   ChangeCipherSpec</li>
+     * <li>7. unwrap:   Finished</li>
+     * </ul>
+     * <p>
+     * Handshake is also used during the end of the session, in order to properly close the connection between the two peers.
+     * A proper connection close will typically include the one peer sending a CLOSE message to another, and then wait for
+     * the other's CLOSE message to close the transport link. The other peer from his perspective would read a CLOSE message
+     * from his peer and then enter the handshake procedure to send his own CLOSE message as well.
+     *
+     * @param socketChannel - the socket channel that connects the two peers.
+     * @param engine        - the engine that will be used for encryption/decryption of the data exchanged with the other peer.
+     * @return True if the connection handshake was successful or false if an error occurred.
+     * @throws IOException - if an error occurs during read/write to the socket channel.
+     */
+    protected boolean doHandshake(SocketChannel socketChannel, SSLEngine engine) throws IOException {
+
+        Log.d(TAG, "About to do handshake...");
+
+        SSLEngineResult result;
+        HandshakeStatus handshakeStatus;
+
+        // NioSslPeer's fields myAppData and peerAppData are supposed to be large enough to hold all message data the peer
+        // will send and expects to receive from the other peer respectively. Since the messages to be exchanged will usually be less
+        // than 16KB long the capacity of these fields should also be smaller. Here we initialize these two local buffers
+        // to be used for the handshake, while keeping client's buffers at the same size.
+        int appBufferSize = engine.getSession().getApplicationBufferSize();
+        ByteBuffer myAppData = ByteBuffer.allocate(appBufferSize);
+        ByteBuffer peerAppData = ByteBuffer.allocate(appBufferSize);
+        myNetData.clear();
+        peerNetData.clear();
+
+        handshakeStatus = engine.getHandshakeStatus();
+        while (handshakeStatus != SSLEngineResult.HandshakeStatus.FINISHED && handshakeStatus != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
+            switch (handshakeStatus) {
+                case NEED_UNWRAP:
+                    if (socketChannel.read(peerNetData) < 0) {
+                        if (engine.isInboundDone() && engine.isOutboundDone()) {
+                            return false;
+                        }
+                        try {
+                            engine.closeInbound();
+                        } catch (SSLException e) {
+                            e.printStackTrace();
+                            Log.e(TAG, "This engine was forced to close inbound, without having received the proper SSL/TLS close notification message from the peer, due to end of stream.");
+                        }
+                        engine.closeOutbound();
+                        // After closeOutbound the engine will be set to WRAP state, in order to try to send a close message to the client.
+                        handshakeStatus = engine.getHandshakeStatus();
+                        break;
+                    }
+                    peerNetData.flip();
+                    try {
+                        result = engine.unwrap(peerNetData, peerAppData);
+                        peerNetData.compact();
+                        handshakeStatus = result.getHandshakeStatus();
+                    } catch (SSLException sslException) {
+                        sslException.printStackTrace();
+                        Log.e(TAG, "A problem was encountered while processing the data that caused the SSLEngine to abort. Will try to properly close connection...");
+                        engine.closeOutbound();
+                        handshakeStatus = engine.getHandshakeStatus();
+                        break;
+                    }
+                    switch (result.getStatus()) {
+                        case OK:
+                            break;
+                        case BUFFER_OVERFLOW:
+                            // Will occur when peerAppData's capacity is smaller than the data derived from peerNetData's unwrap.
+                            peerAppData = enlargeApplicationBuffer(engine, peerAppData);
+                            break;
+                        case BUFFER_UNDERFLOW:
+                            // Will occur either when no data was read from the peer or when the peerNetData buffer was too small to hold all peer's data.
+                            peerNetData = handleBufferUnderflow(engine, peerNetData);
+                            break;
+                        case CLOSED:
+                            if (engine.isOutboundDone()) {
+                                return false;
+                            } else {
+                                engine.closeOutbound();
+                                handshakeStatus = engine.getHandshakeStatus();
+                                break;
+                            }
+                        default:
+                            throw new IllegalStateException("Invalid SSL status: " + result.getStatus());
+                    }
+                    break;
+                case NEED_WRAP:
+                    myNetData.clear();
+                    try {
+                        result = engine.wrap(myAppData, myNetData);
+                        handshakeStatus = result.getHandshakeStatus();
+                    } catch (SSLException sslException) {
+                        sslException.printStackTrace();
+                        Log.e(TAG, "A problem was encountered while processing the data that caused the SSLEngine to abort. Will try to properly close connection...");
+                        engine.closeOutbound();
+                        handshakeStatus = engine.getHandshakeStatus();
+                        break;
+                    }
+                    switch (result.getStatus()) {
+                        case OK:
+                            myNetData.flip();
+                            while (myNetData.hasRemaining()) {
+                                socketChannel.write(myNetData);
+                            }
+                            break;
+                        case BUFFER_OVERFLOW:
+                            // Will occur if there is not enough space in myNetData buffer to write all the data that would be generated by the method wrap.
+                            // Since myNetData is set to session's packet size we should not get to this point because SSLEngine is supposed
+                            // to produce messages smaller or equal to that, but a general handling would be the following:
+                            myNetData = enlargePacketBuffer(engine, myNetData);
+                            break;
+                        case BUFFER_UNDERFLOW:
+                            throw new SSLException("Buffer underflow occured after a wrap. I don't think we should ever get here.");
+                        case CLOSED:
+                            try {
+                                myNetData.flip();
+                                while (myNetData.hasRemaining()) {
+                                    socketChannel.write(myNetData);
+                                }
+                                // At this point the handshake status will probably be NEED_UNWRAP so we make sure that peerNetData is clear to read.
+                                peerNetData.clear();
+                            } catch (Exception e) {
+                                e.printStackTrace();
+                                Log.e(TAG, "Failed to send server's CLOSE message due to socket channel's failure.");
+                                handshakeStatus = engine.getHandshakeStatus();
+                            }
+                            break;
+                        default:
+                            throw new IllegalStateException("Invalid SSL status: " + result.getStatus());
+                    }
+                    break;
+                case NEED_TASK:
+                    Runnable task;
+                    while ((task = engine.getDelegatedTask()) != null) {
+                        executor.execute(task);
+                    }
+                    handshakeStatus = engine.getHandshakeStatus();
+                    break;
+                case FINISHED:
+                    break;
+                case NOT_HANDSHAKING:
+                    break;
+                default:
+                    throw new IllegalStateException("Invalid SSL status: " + handshakeStatus);
+            }
+        }
+
+        return true;
+
+    }
+
+    protected ByteBuffer enlargePacketBuffer(SSLEngine engine, ByteBuffer buffer) {
+        return enlargeBuffer(buffer, engine.getSession().getPacketBufferSize());
+    }
+
+    protected ByteBuffer enlargeApplicationBuffer(SSLEngine engine, ByteBuffer buffer) {
+        return enlargeBuffer(buffer, engine.getSession().getApplicationBufferSize());
+    }
+
+    /**
+     * Compares <code>sessionProposedCapacity<code> with buffer's capacity. If buffer's capacity is smaller,
+     * returns a buffer with the proposed capacity. If it's equal or larger, returns a buffer
+     * with capacity twice the size of the initial one.
+     *
+     * @param buffer                  - the buffer to be enlarged.
+     * @param sessionProposedCapacity - the minimum size of the new buffer, proposed by {@link SSLSession}.
+     * @return A new buffer with a larger capacity.
+     */
+    protected ByteBuffer enlargeBuffer(ByteBuffer buffer, int sessionProposedCapacity) {
+        if (sessionProposedCapacity > buffer.capacity()) {
+            buffer = ByteBuffer.allocate(sessionProposedCapacity);
+        } else {
+            buffer = ByteBuffer.allocate(buffer.capacity() * 2);
+        }
+        return buffer;
+    }
+
+    /**
+     * Handles {@link SSLEngineResult.Status#BUFFER_UNDERFLOW}. Will check if the buffer is already filled, and if there is no space problem
+     * will return the same buffer, so the client tries to read again. If the buffer is already filled will try to enlarge the buffer either to
+     * session's proposed size or to a larger capacity. A buffer underflow can happen only after an unwrap, so the buffer will always be a
+     * peerNetData buffer.
+     *
+     * @param buffer - will always be peerNetData buffer.
+     * @param engine - the engine used for encryption/decryption of the data exchanged between the two peers.
+     * @return The same buffer if there is no space problem or a new buffer with the same data but more space.
+     * @throws Exception
+     */
+    protected ByteBuffer handleBufferUnderflow(SSLEngine engine, ByteBuffer buffer) {
+        if (buffer.position() < buffer.limit()) {
+            return buffer;
+        } else {
+            ByteBuffer replaceBuffer = enlargePacketBuffer(engine, buffer);
+            buffer.flip();
+            replaceBuffer.put(buffer);
+            return replaceBuffer;
+        }
+    }
+
+    /**
+     * This method should be called when this peer wants to explicitly close the connection
+     * or when a close message has arrived from the other peer, in order to provide an orderly shutdown.
+     * <p>
+     * It first calls {@link SSLEngine#closeOutbound()} which prepares this peer to send its own close message and
+     * sets {@link SSLEngine} to the <code>NEED_WRAP</code> state. Then, it delegates the exchange of close messages
+     * to the handshake method and finally, it closes socket channel.
+     *
+     * @param socketChannel - the transport link used between the two peers.
+     * @param engine        - the engine used for encryption/decryption of the data exchanged between the two peers.
+     * @throws IOException if an I/O error occurs to the socket channel.
+     */
+    protected void closeConnection(SocketChannel socketChannel, SSLEngine engine) throws IOException {
+        engine.closeOutbound();
+        doHandshake(socketChannel, engine);
+        socketChannel.close();
+    }
+
+    /**
+     * In addition to orderly shutdowns, an unorderly shutdown may occur, when the transport link (socket channel)
+     * is severed before close messages are exchanged. This may happen by getting an -1 or {@link IOException}
+     * when trying to read from the socket channel, or an {@link IOException} when trying to write to it.
+     * In both cases {@link SSLEngine#closeInbound()} should be called and then try to follow the standard procedure.
+     *
+     * @param socketChannel - the transport link used between the two peers.
+     * @param engine        - the engine used for encryption/decryption of the data exchanged between the two peers.
+     * @throws IOException if an I/O error occurs to the socket channel.
+     */
+    protected void handleEndOfStream(SocketChannel socketChannel, SSLEngine engine) throws IOException {
+        try {
+            engine.closeInbound();
+        } catch (Exception e) {
+            Log.e(TAG, "This engine was forced to close inbound, without having received the proper SSL/TLS close notification message from the peer, due to end of stream.");
+        }
+        closeConnection(socketChannel, engine);
+    }
+
+
+    /**
+     * Send encrypted packet
+     *
+     * @throws IOException
+     */
+    /**
+     * Implements the write method that sends a message to the server the client is connected to,
+     * but should not be called by the user, since socket channel and engine are inner class' variables.
+     * {@link NioSslClient#write(String)} should be called instead.
+     *
+     * @param engine - the engine used for encryption/decryption of the data exchanged between the two peers.
+     * @throws IOException if an I/O error occurs to the socket channel.
+     */
+    protected void write(SocketChannel socketChannel, SSLEngine engine, ByteBuffer byteBuffer) throws IOException {
+
+        Log.d(TAG, "About to write to the server...");
+
+        myAppData = byteBuffer;
+        myAppData.flip();
+        while (myAppData.hasRemaining()) {
+            // The loop has a meaning for (outgoing) messages larger than 16KB.
+            // Every wrap call will remove 16KB from the original message and send it to the remote peer.
+            myNetData.clear();
+            SSLEngineResult result = engine.wrap(myAppData, myNetData);
+            switch (result.getStatus()) {
+                case OK:
+                    myNetData.flip();
+                    while (myNetData.hasRemaining()) {
+                        socketChannel.write(myNetData);
+                    }
+                    Log.d(TAG, "Message sent to the server");
+                    break;
+                case BUFFER_OVERFLOW:
+                    myNetData = enlargePacketBuffer(engine, myNetData);
+                    break;
+                case BUFFER_UNDERFLOW:
+                    throw new SSLException("Buffer underflow occured after a wrap. I don't think we should ever get here.");
+                case CLOSED:
+                    closeConnection(socketChannel, engine);
+                    return;
+                default:
+                    throw new IllegalStateException("Invalid SSL status: " + result.getStatus());
+            }
+        }
+
+    }
+
+    protected int read(SocketChannel socketChannel, SSLEngine engine, ByteBuffer byteBuffer) throws Exception {
+
+        Log.d(TAG, "About to read from the server...");
+
+        peerAppData = byteBuffer;
+        peerNetData.clear();
+        int waitToReadMillis = 50;
+        int bytesConsumed = 0;
+        boolean exitReadLoop = false;
+        while (!exitReadLoop) {
+            int bytesRead = socketChannel.read(peerNetData);
+            if (bytesRead > 0) {
+                peerNetData.flip();
+                while (peerNetData.hasRemaining()) {
+                    peerAppData.clear();
+                    SSLEngineResult result = engine.unwrap(peerNetData, peerAppData);
+                    bytesConsumed += result.bytesProduced();
+                    switch (result.getStatus()) {
+                        case OK:
+                            //peerAppData.flip();
+                            //Log.d(TAG, "Server response: " + new StringBuilder(new String(peerAppData.array(), StandardCharsets.UTF_8)).toString());
+                            exitReadLoop = true;
+                            break;
+                        case BUFFER_OVERFLOW:
+                            peerAppData = enlargeApplicationBuffer(engine, peerAppData);
+                            break;
+                        case BUFFER_UNDERFLOW:
+                            peerNetData = handleBufferUnderflow(engine, peerNetData);
+                            break;
+                        case CLOSED:
+                            closeConnection(socketChannel, engine);
+                            return bytesConsumed;
+                        default:
+                            throw new IllegalStateException("Invalid SSL status: " + result.getStatus());
+                    }
+                }
+            } else if (bytesRead < 0) {
+                handleEndOfStream(socketChannel, engine);
+                return -1;
+            }
+            Thread.sleep(waitToReadMillis);
+        }
+
+        return bytesConsumed;
+    }
+
+}
\ No newline at end of file
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocket.java b/Autobahn/src/de/tavendo/autobahn/WebSocket.java
index 44dade8..c3dc58e 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocket.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocket.java
@@ -1,92 +1,104 @@
 package de.tavendo.autobahn;
 
 public interface WebSocket {
-   
-	/**
-    * Session handler for WebSocket sessions.
-    */
-   public interface ConnectionHandler {
-
-	   /**
-	    * Connection was closed normally.
-	    */
-	   public static final int CLOSE_NORMAL = 1;
-
-	   /**
-	    * Connection could not be established in the first place.
-	    */
-	   public static final int CLOSE_CANNOT_CONNECT = 2;
-
-	   /**
-	    * A previously established connection was lost unexpected.
-	    */
-	   public static final int CLOSE_CONNECTION_LOST = 3;
-
-	   /**
-	    * The connection was closed because a protocol violation
-	    * occurred.
-	    */
-	   public static final int CLOSE_PROTOCOL_ERROR = 4;
-
-	   /**
-	    * Internal error.
-	    */
-	   public static final int CLOSE_INTERNAL_ERROR = 5;
-	   
-	   /**
-	    * Server returned error while connecting
-	    */
-	   public static final int CLOSE_SERVER_ERROR = 6;
-	   
-	   /**
-	    * Server connection lost, scheduled reconnect
-	    */
-	   public static final int CLOSE_RECONNECT = 7;
-
-	   /**
-	    * Fired when the WebSockets connection has been established.
-	    * After this happened, messages may be sent.
-	    */
-	   public void onOpen();
-
-	   /**
-	    * Fired when the WebSockets connection has deceased (or could
-	    * not established in the first place).
-	    *
-	    * @param code       Close code.
-	    * @param reason     Close reason (human-readable).
-	    */
-	   public void onClose(int code, String reason);
-
-	   /**
-	    * Fired when a text message has been received (and text
-	    * messages are not set to be received raw).
-	    *
-	    * @param payload    Text message payload or null (empty payload).
-	    */
-	   public void onTextMessage(String payload);
-
-	   /**
-	    * Fired when a text message has been received (and text
-	    * messages are set to be received raw).
-	    *
-	    * @param payload    Text message payload as raw UTF-8 or null (empty payload).
-	    */
-	   public void onRawTextMessage(byte[] payload);
-
-	   /**
-	    * Fired when a binary message has been received.
-	    *
-	    * @param payload    Binar message payload or null (empty payload).
-	    */
-	   public void onBinaryMessage(byte[] payload);
-   }
-
-   public void connect(String wsUri, ConnectionHandler wsHandler) throws WebSocketException;
-   public void connect(String wsUri, ConnectionHandler wsHandler, WebSocketOptions options) throws WebSocketException;
-   public void disconnect();
-   public boolean isConnected();
-   public void sendBinaryMessage(byte[] payload);
-   public void sendRawTextMessage(byte[] payload);
-   public void sendTextMessage(String payload);
+
+    /**
+     * Session handler for WebSocket sessions.
+     */
+    public interface ConnectionHandler {
+
+        /**
+         * Connection was closed normally.
+         */
+        public static final int CLOSE_NORMAL = 1;
+
+        /**
+         * Connection could not be established in the first place.
+         */
+        public static final int CLOSE_CANNOT_CONNECT = 2;
+
+        /**
+         * A previously established connection was lost unexpected.
+         */
+        public static final int CLOSE_CONNECTION_LOST = 3;
+
+        /**
+         * The connection was closed because a protocol violation
+         * occurred.
+         */
+        public static final int CLOSE_PROTOCOL_ERROR = 4;
+
+        /**
+         * Internal error.
+         */
+        public static final int CLOSE_INTERNAL_ERROR = 5;
+
+        /**
+         * Server returned error while connecting
+         */
+        public static final int CLOSE_SERVER_ERROR = 6;
+
+        /**
+         * Server connection lost, scheduled reconnect
+         */
+        public static final int CLOSE_RECONNECT = 7;
+
+        /**
+         * Closed due to SSL error
+         */
+        public static final int CLOSE_SSL_ERROR = 8;
+
+        /**
+         * Fired when the WebSockets connection has been established.
+         * After this happened, messages may be sent.
+         */
+        public void onOpen();
+
+        /**
+         * Fired when the WebSockets connection has deceased (or could
+         * not established in the first place).
+         *
+         * @param code   Close code.
+         * @param reason Close reason (human-readable).
+         * @param t      Exception (maybe be null)
+         */
+        public void onClose(int code, String reason, Throwable t);
+
+        /**
+         * Fired when a text message has been received (and text
+         * messages are not set to be received raw).
+         *
+         * @param payload Text message payload or null (empty payload).
+         */
+        public void onTextMessage(String payload);
+
+        /**
+         * Fired when a text message has been received (and text
+         * messages are set to be received raw).
+         *
+         * @param payload Text message payload as raw UTF-8 or null (empty payload).
+         */
+        public void onRawTextMessage(byte[] payload);
+
+        /**
+         * Fired when a binary message has been received.
+         *
+         * @param payload Binar message payload or null (empty payload).
+         */
+        public void onBinaryMessage(byte[] payload);
+    }
+
+    public void connect(String wsUri, ConnectionHandler wsHandler) throws WebSocketException;
+
+    public void connect(String wsUri, ConnectionHandler wsHandler, WebSocketOptions options) throws WebSocketException;
+
+    public void disconnect();
+
+    public boolean isConnected();
+
+    public void sendBinaryMessage(byte[] payload);
+
+    public void sendRawTextMessage(byte[] payload);
+
+    public void sendTextMessage(String payload);
 }
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java b/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java
index a61b241..2f81d8c 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketConnection.java
@@ -1,12 +1,12 @@
 /******************************************************************************
  * Copyright 2011-2012 Tavendo GmbH
- * <p/>
+ * <p>
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * <p/>
+ * <p>
  * http://www.apache.org/licenses/LICENSE-2.0
- * <p/>
+ * <p>
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -28,13 +28,8 @@
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.nio.channels.SocketChannel;
-import java.security.KeyManagementException;
-import java.security.NoSuchAlgorithmException;
 import java.util.List;
 
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLEngine;
-
 public class WebSocketConnection implements WebSocket {
 
     private static final boolean DEBUG = true;
@@ -64,9 +59,7 @@
     private boolean mActive;
     private boolean mPrevConnected;
 
-    private SSLContext mSSLContext;
-    private SSLEngine mSSLEngine = null;
-
+    private WebSocketSSLContext mWebSocketSSLContext;
 
     /**
      * Asynchronous socket connector.
@@ -76,6 +69,8 @@
         public void run() {
             Thread.currentThread().setName("WebSocketConnector");
 
+            boolean isSSL = false;
+
 			/*
              * connect TCP socket
 			 */
@@ -88,12 +83,11 @@ public void run() {
                         new InetSocketAddress(mWsHost, mWsPort),
                         mOptions.getSocketConnectTimeout());
 
+                // using SSL?
                 if (mWsScheme.equals("wss")) {
-                    try {
-                        initializeSSL();
-                    } catch (NoSuchAlgorithmException | IOException | KeyManagementException e) {
-                        e.printStackTrace();
-                    }
+                    isSSL = true;
+                    if (null == mWebSocketSSLContext)
+                        mWebSocketSSLContext = new WebSocketSSLContext();
                 }
 
                 // before doing any data transfer on the socket, set socket
@@ -103,9 +97,9 @@ public void run() {
                 mTransportChannel.socket().setTcpNoDelay(
                         mOptions.getTcpNoDelay());
 
-            } catch (IOException e) {
-                onClose(WebSocketConnectionHandler.CLOSE_CANNOT_CONNECT,
-                        e.getMessage());
+            } catch (Throwable t) {
+                Log.e(TAG, "WebSocket initialization error!", t);
+                onClose(WebSocketConnectionHandler.CLOSE_CANNOT_CONNECT, t.getMessage(), t);
                 return;
             }
 
@@ -113,20 +107,14 @@ public void run() {
                 if (mTransportChannel.finishConnect()) {
 
                     try {
-
-                        if (null != mSSLContext) {
-                            mSSLContext.init(null, null, null);
-                            mSSLEngine = mSSLContext.createSSLEngine(mTransportChannel
+                        if (isSSL) {
+                            mWebSocketSSLContext.doHandshake(mTransportChannel
                                             .socket()
                                             .getInetAddress()
                                             .getHostName(),
                                     mTransportChannel
                                             .socket()
                                             .getPort());
-
-                            mSSLEngine.setUseClientMode(true);
-                            mSSLEngine.beginHandshake();
-
                         }
 
                         // create & start WebSocket reader
@@ -378,8 +366,9 @@ public void run() {
      *
      * @param code   Close code.
      * @param reason Close reason (human-readable).
+     * @param t      not-null if there was exeption
      */
-    private void onClose(int code, String reason) {
+    private void onClose(int code, String reason, Throwable t) {
         boolean reconnecting = false;
 
         if ((code == ConnectionHandler.CLOSE_CANNOT_CONNECT) ||
@@ -387,13 +376,12 @@ private void onClose(int code, String reason) {
             reconnecting = scheduleReconnect();
         }
 
-
         if (mWsHandler != null) {
             try {
                 if (reconnecting) {
-                    mWsHandler.onClose(ConnectionHandler.CLOSE_RECONNECT, reason);
+                    mWsHandler.onClose(ConnectionHandler.CLOSE_RECONNECT, reason, t);
                 } else {
-                    mWsHandler.onClose(code, reason);
+                    mWsHandler.onClose(code, reason, t);
                 }
             } catch (Exception e) {
                 if (DEBUG) e.printStackTrace();
@@ -405,6 +393,16 @@ private void onClose(int code, String reason) {
     }
 
 
+    /**
+     * Common close handler
+     *
+     * @param code   Close code.
+     * @param reason Close reason (human-readable).
+     */
+    private void onClose(int code, String reason) {
+        onClose(code, reason, null);
+    }
+
     /**
      * Create master message handler.
      */
@@ -523,8 +521,12 @@ public void handleMessage(Message msg) {
                     WebSocketMessage.ServerError error = (WebSocketMessage.ServerError) msg.obj;
                     failConnection(WebSocketConnectionHandler.CLOSE_SERVER_ERROR, "Server error " + error.mStatusCode + " (" + error.mStatusMessage + ")");
 
-                } else {
+                } else if (msg.obj instanceof WebSocketMessage.SSLException) {
+
+                    WebSocketMessage.SSLException error = (WebSocketMessage.SSLException) msg.obj;
+                    failConnection(WebSocketConnectionHandler.CLOSE_SSL_ERROR, "SSL error " + error.mException.getMessage());
 
+                } else {
                     processAppMessage(msg.obj);
 
                 }
@@ -532,10 +534,16 @@ public void handleMessage(Message msg) {
         };
     }
 
+    public WebSocketSSLContext getWebSocketSSLContext() {
+        return mWebSocketSSLContext;
+    }
 
-    protected void processAppMessage(Object message) {
+    public void setWebSocketSSLContext(WebSocketSSLContext webSocketSSLContext) {
+        this.mWebSocketSSLContext = webSocketSSLContext;
     }
 
+    protected void processAppMessage(Object message) {
+    }
 
     /**
      * Create WebSockets background writer.
@@ -544,7 +552,7 @@ protected void createWriter() {
 
         mWriterThread = new HandlerThread("WebSocketWriter");
         mWriterThread.start();
-        mWriter = new WebSocketWriter(mWriterThread.getLooper(), mMasterHandler, mTransportChannel, mSSLEngine, mOptions);
+        mWriter = new WebSocketWriter(mWriterThread.getLooper(), mMasterHandler, mTransportChannel, mWebSocketSSLContext.getSSLEngine(), mOptions);
 
         if (DEBUG) Log.d(TAG, "WS writer created and started");
     }
@@ -555,17 +563,9 @@ protected void createWriter() {
      */
     protected void createReader() {
 
-        mReader = new WebSocketReader(mMasterHandler, mTransportChannel, mSSLEngine, mOptions, "WebSocketReader");
+        mReader = new WebSocketReader(mMasterHandler, mTransportChannel, mWebSocketSSLContext.getSSLEngine(),mWriter.getHandShakeKey(),  mOptions, "WebSocketReader");
         mReader.start();
 
         if (DEBUG) Log.d(TAG, "WS reader created and started");
     }
-
-    public void setSSLContext(SSLContext context) {
-        this.mSSLContext = context;
-    }
-
-    public void initializeSSL() throws NoSuchAlgorithmException, IOException, KeyManagementException {
-        mSSLContext = SSLContext.getInstance("TLSv1.2");
-    }
 }
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketConnectionHandler.java b/Autobahn/src/de/tavendo/autobahn/WebSocketConnectionHandler.java
index bfe343d..dc160bf 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketConnectionHandler.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketConnectionHandler.java
@@ -38,7 +38,9 @@ public void onOpen() {
     * @param code       Close code.
     * @param reason     Close reason (human-readable).
     */
-   public void onClose(int code, String reason) {
+   @Override
+   public void onClose(int code, String reason, Throwable t) {
+
    }
 
    /**
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketMessage.java b/Autobahn/src/de/tavendo/autobahn/WebSocketMessage.java
index 0522085..bcad83f 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketMessage.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketMessage.java
@@ -1,12 +1,12 @@
 /******************************************************************************
  * Copyright 2011-2012 Tavendo GmbH
- * <p/>
+ * <p>
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * <p/>
+ * <p>
  * http://www.apache.org/licenses/LICENSE-2.0
- * <p/>
+ * <p>
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -102,6 +102,14 @@ public ProtocolViolation(WebSocketException e) {
         }
     }
 
+    public static class SSLException extends Message {
+        public javax.net.ssl.SSLException mException;
+
+        public SSLException(javax.net.ssl.SSLException e) {
+            mException = e;
+        }
+    }
+
     /// An exception occured in the WS reader or WS writer.
     public static class Error extends Message {
 
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketReader.java b/Autobahn/src/de/tavendo/autobahn/WebSocketReader.java
index 4034a50..148bd64 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketReader.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketReader.java
@@ -18,6 +18,7 @@
 
 import android.os.Handler;
 import android.os.Message;
+import android.util.Base64;
 import android.util.Log;
 import android.util.Pair;
 
@@ -25,10 +26,13 @@
 import java.net.SocketException;
 import java.nio.ByteBuffer;
 import java.nio.channels.SocketChannel;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import java.util.HashMap;
 import java.util.Map;
 
 import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLException;
 
 /**
  * WebSocket reader, the receiving leg of a WebSockets connection.
@@ -82,6 +86,7 @@
 
     protected NioSslPeer nioSslPeer;
     protected SSLEngine mSSLEngine;
+    protected String mSecWebsocketHandShakeKey;
 
     /**
      * Create new WebSockets background reader.
@@ -89,7 +94,7 @@
      * @param master The message handler of master (foreground thread).
      * @param socket The socket channel created on foreground thread.
      */
-    public WebSocketReader(Handler master, SocketChannel socket, SSLEngine sslEngine, WebSocketOptions options, String threadName) {
+    public WebSocketReader(Handler master, SocketChannel socket, SSLEngine sslEngine, String secWebsocketHandShakeKey, WebSocketOptions options, String threadName) {
 
         super(threadName);
 
@@ -97,6 +102,7 @@ public WebSocketReader(Handler master, SocketChannel socket, SSLEngine sslEngine
         mMaster = master;
         mSocket = socket;
         mOptions = options;
+        mSecWebsocketHandShakeKey = secWebsocketHandShakeKey;
 
         mFrameBuffer = ByteBuffer.allocateDirect(options.getMaxFramePayloadSize() + 14);
         mMessagePayload = new NoCopyByteArrayOutputStream(options.getMaxMessagePayloadSize());
@@ -581,6 +587,15 @@ private boolean processHandshake() throws UnsupportedEncodingException {
                 String[] h = line.split(": ");
                 if (h.length == 2) {
                     headers.put(h[0], h[1]);
+                    // if SSL validate Sec-WebSocket-Accept header
+                    if (null != mSSLEngine) {
+                        String expected = createSecretValidation(mSecWebsocketHandShakeKey);
+                        if (!expected.equals(mSecWebsocketHandShakeKey)) {
+                            mSecWebsocketHandShakeKey = null;
+                            throw new RuntimeException(new WebSocketException("Bad Sec-WebSocket-Accept header value."));
+                        }
+                    }
+
                     Log.w(TAG, String.format("'%s'='%s'", h[0], h[1]));
                 }
             }
@@ -683,12 +698,12 @@ public void run() {
                 }
             } while (!mStopped);
 
-        } catch (WebSocketException e) {
+        } catch (SSLException e) {
 
-            if (DEBUG) Log.d(TAG, "run() : WebSocketException (" + e.toString() + ")");
+            if (DEBUG) Log.d(TAG, "run() : SSLException (" + e.toString() + ")");
 
             // wrap the exception and notify master
-            notify(new WebSocketMessage.ProtocolViolation(e));
+            notify(new WebSocketMessage.SSLException(e));
 
         } catch (SocketException e) {
 
@@ -705,6 +720,7 @@ public void run() {
             // wrap the exception and notify master
             notify(new WebSocketMessage.Error(e));
 
+
         } finally {
 
             mStopped = true;
@@ -712,4 +728,14 @@ public void run() {
 
         if (DEBUG) Log.d(TAG, "ended");
     }
+
+    private String createSecretValidation(String secret) {
+        try {
+            MessageDigest md = MessageDigest.getInstance("SHA-1");
+            md.update((secret + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11").getBytes());
+            return Base64.encodeToString(md.digest(), Base64.DEFAULT).trim();
+        } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException(e);
+        }
+    }
 }
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketSSLContext.java b/Autobahn/src/de/tavendo/autobahn/WebSocketSSLContext.java
new file mode 100644
index 0000000..e7a42d5
--- /dev/null
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketSSLContext.java
@@ -0,0 +1,234 @@
+package de.tavendo.autobahn;
+
+import android.util.Log;
+
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.KeyManagementException;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.security.UnrecoverableKeyException;
+import java.security.cert.CertificateException;
+
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.KeyManagerFactory;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+
+/**
+ * Created by ajay on 2/13/16.
+ */
+public class WebSocketSSLContext {
+
+    public static final String TAG = WebSocketSSLContext.class.getSimpleName();
+    public static final int DEFAULT_PORT = 443;
+
+    private SSLContext mSSLContext;
+    private SSLEngine mSSLEngine = null;
+    private KeyManager[] mKeyManagers;
+    private TrustManager[] mTrustManagers;
+
+    public WebSocketSSLContext() {
+        mSSLContext = getDefaultSSLContext();
+    }
+
+    /**
+     * Initializes default SSL context using TLSv1.2
+     *
+     * @throws NoSuchAlgorithmException
+     * @throws IOException
+     * @throws KeyManagementException
+     */
+    protected SSLContext getDefaultSSLContext() {
+        try {
+            return SSLContext.getInstance("TLSv1.2");
+        } catch (NoSuchAlgorithmException e) {
+            Log.e(TAG, "Unable to initialize TLSv1.2 SSL context", e);
+        }
+
+        return null;
+    }
+
+    /**
+     * SSL key managers
+     *
+     * @param keyManagers {@link KeyManager}
+     */
+    public void setSSLKeyManagers(KeyManager[] keyManagers) {
+        mKeyManagers = keyManagers;
+    }
+
+    /**
+     * Returns SSL key managers
+     *
+     * @return array of {@link KeyManager}
+     */
+    public KeyManager[] getSSLKeyManagers() {
+        return mKeyManagers;
+    }
+
+    /**
+     * SSL X.509 certificate trustmanagers
+     *
+     * @param trustManagers {@link TrustManager}
+     */
+    public void setSSLTrustManagers(TrustManager[] trustManagers) {
+        mTrustManagers = trustManagers;
+    }
+
+    /**
+     * Returns SSL X.509 trust managers
+     *
+     * @return array of {@link TrustManager}
+     */
+    public TrustManager[] getSSLTrustManagers() {
+        return mTrustManagers;
+    }
+
+    /**
+     * This method may be used to supply alternate {@link SSLContext}. A default {@link SSLContext} is created when using wss://
+     *
+     * @param sslContext {@link SSLContext}
+     */
+    public void setSSLContext(SSLContext sslContext) {
+        mSSLContext = sslContext;
+    }
+
+    /**
+     * Returns current SSL context
+     *
+     * @return {@link SSLContext}
+     */
+    public SSLContext getSSLContext() {
+        return mSSLContext;
+    }
+
+    /**
+     * Get SSL engine
+     *
+     * @return {@link SSLEngine}
+     */
+    public SSLEngine getSSLEngine() {
+        return mSSLEngine;
+    }
+
+    /**
+     * Set SSL engine
+     *
+     * @param sslEngine {@link SSLEngine}
+     */
+    public void setSSLEngine(SSLEngine sslEngine) {
+        mSSLEngine = sslEngine;
+    }
+
+    /**
+     * Setup SSL engine and start handshake
+     *
+     * @param host hostname
+     * @param port port number
+     */
+    public void doHandshake(final String host, int port)
+            throws
+            IOException,
+            UnrecoverableKeyException,
+            KeyStoreException,
+            NoSuchAlgorithmException,
+            CertificateException,
+            KeyManagementException {
+        if (null == mKeyManagers)
+            mKeyManagers = createKeyManagers();
+        if (null == mTrustManagers)
+            mTrustManagers = createTrustManagers();
+
+        mSSLContext.init(mKeyManagers, mTrustManagers, null);
+        if (null == mSSLEngine) {
+            mSSLEngine = mSSLContext.createSSLEngine(host, port);
+            mSSLEngine.setUseClientMode(true);
+            mSSLEngine.beginHandshake();
+        }
+    }
+
+    /**
+     * Setup SSL engine and start handshake using port 443
+     *
+     * @param host
+     * @throws KeyManagementException
+     * @throws SSLException
+     */
+    public void doHandshake(final String host)
+            throws
+            IOException,
+            UnrecoverableKeyException,
+            KeyStoreException,
+            NoSuchAlgorithmException,
+            CertificateException,
+            KeyManagementException {
+        doHandshake(host, DEFAULT_PORT);
+    }
+
+
+    /**
+     * Creates default key managers required to initiate the {@link SSLContext}, using a JKS keystore as an input.
+     *
+     * @return {@link KeyManager} array that will be used to initiate the {@link SSLContext}.
+     * @throws Exception
+     */
+    public final KeyManager[] createKeyManagers() throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException, UnrecoverableKeyException {
+        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
+        try {
+            keyStore.load(null, null);
+        } finally {
+        }
+
+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
+        kmf.init(keyStore, null);
+        return kmf.getKeyManagers();
+    }
+
+    /**
+     * Creates the trust managers required to initiate the {@link SSLContext}, using a JKS keystore as an input.
+     *
+     * @param filepath         - the path to the JKS keystore.
+     * @param keystorePassword - the keystore's password.
+     * @return {@link TrustManager} array, that will be used to initiate the {@link SSLContext}.
+     * @throws Exception
+     */
+    public final TrustManager[] createTrustManagers(String filepath, String keystorePassword) throws CertificateException, NoSuchAlgorithmException, IOException, KeyStoreException {
+        KeyStore trustStore = KeyStore.getInstance("JKS");
+        InputStream trustStoreIS = new FileInputStream(filepath);
+        try {
+            trustStore.load(trustStoreIS, keystorePassword.toCharArray());
+        } finally {
+            if (trustStoreIS != null) {
+                trustStoreIS.close();
+            }
+        }
+        TrustManagerFactory trustFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
+        trustFactory.init(trustStore);
+        return trustFactory.getTrustManagers();
+    }
+
+    /**
+     * Creates default trust managers required to initiate the {@link SSLContext}, using a JKS keystore as an input.
+     *
+     * @return {@link TrustManager} array, that will be used to initiate the {@link SSLContext}.
+     * @throws Exception
+     */
+    public static final TrustManager[] createTrustManagers() throws CertificateException, NoSuchAlgorithmException, IOException, KeyStoreException {
+        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
+        try {
+            trustStore.load(null, null);
+        } finally {
+        }
+
+        TrustManagerFactory trustFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
+        trustFactory.init(trustStore);
+        return trustFactory.getTrustManagers();
+    }
+
+}
diff --git a/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java b/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java
index 610febf..4196105 100644
--- a/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java
+++ b/Autobahn/src/de/tavendo/autobahn/WebSocketWriter.java
@@ -65,6 +65,8 @@
 
     private SSLEngine mSSLEngine;
 
+    private String mHandShakeKey;
+
     /**
      * Create new WebSockets background writer.
      *
@@ -179,7 +181,8 @@ private void sendClientHandshake(WebSocketMessage.ClientHandshake message) throw
         mBuffer.write("Connection: Upgrade");
         mBuffer.crlf();
 
-        mBuffer.write("Sec-WebSocket-Key: " + newHandshakeKey());
+        mHandShakeKey = newHandshakeKey();
+        mBuffer.write("Sec-WebSocket-Key: " + mHandShakeKey);
         mBuffer.crlf();
 
         if (message.mOrigin != null && !message.mOrigin.equals("")) {
@@ -505,5 +508,7 @@ protected void processAppMessage(Object msg) throws WebSocketException, IOExcept
         throw new WebSocketException("unknown message received by WebSocketWriter");
     }
 
-
+    public String getHandShakeKey() {
+        return mHandShakeKey;
+    }
 }
