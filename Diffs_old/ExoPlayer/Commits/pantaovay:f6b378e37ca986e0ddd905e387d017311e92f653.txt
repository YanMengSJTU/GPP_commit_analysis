diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
index ace8140f4b..3f6c70e683 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
@@ -660,6 +660,7 @@ private boolean feedInputBuffer(long positionUs, boolean firstFeed) throws ExoPl
       inputIndex = -1;
       codecHasQueuedBuffers = true;
       codecReconfigurationState = RECONFIGURATION_STATE_NONE;
+      onQueuedInputBuffer(presentationTimeUs);
     } catch (CryptoException e) {
       notifyCryptoError(e);
       throw new ExoPlaybackException(e);
@@ -755,6 +756,28 @@ protected void onOutputStreamEnded() {
     // Do nothing.
   }
 
+  /**
+   * Invoked when an input buffer is queued into the codec.
+   * <p>
+   * The default implementation is a no-op.
+   *
+   * @param presentationTimeUs The timestamp associated with the input buffer.
+   */
+  protected void onQueuedInputBuffer(long presentationTimeUs) {
+    // Do nothing.
+  }
+
+  /**
+   * Invoked when an output buffer is successfully processed.
+   * <p>
+   * The default implementation is a no-op.
+   *
+   * @param presentationTimeUs The timestamp associated with the output buffer.
+   */
+  protected void onProcessedOutputBuffer(long presentationTimeUs) {
+    // Do Nothing.
+  }
+
   /**
    * Determines whether the existing {@link MediaCodec} should be reconfigured for a new format by
    * sending codec specific initialization data at the start of the next input buffer. If true is
@@ -849,6 +872,7 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
     int decodeOnlyIndex = getDecodeOnlyIndex(outputBufferInfo.presentationTimeUs);
     if (processOutputBuffer(positionUs, elapsedRealtimeUs, codec, outputBuffers[outputIndex],
         outputBufferInfo, outputIndex, decodeOnlyIndex != -1)) {
+      onProcessedOutputBuffer(outputBufferInfo.presentationTimeUs);
       if (decodeOnlyIndex != -1) {
         decodeOnlyPresentationTimestamps.remove(decodeOnlyIndex);
       }
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java
index b50b17ac6b..eaaef4aaa2 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java
@@ -22,7 +22,6 @@
 import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
 import com.google.android.exoplayer.MediaCodecSelector;
 import com.google.android.exoplayer.MediaCodecUtil;
-import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.chunk.ChunkSampleSource;
 import com.google.android.exoplayer.chunk.ChunkSource;
@@ -37,6 +36,7 @@
 import com.google.android.exoplayer.dash.mpd.Representation;
 import com.google.android.exoplayer.playbacktests.util.ActionSchedule;
 import com.google.android.exoplayer.playbacktests.util.CodecCountersUtil;
+import com.google.android.exoplayer.playbacktests.util.DebugMediaCodecVideoTrackRenderer;
 import com.google.android.exoplayer.playbacktests.util.ExoHostedTest;
 import com.google.android.exoplayer.playbacktests.util.HostActivity;
 import com.google.android.exoplayer.playbacktests.util.LogcatLogger;
@@ -413,11 +413,11 @@ public DashHostedTest(String testName, MediaPresentationDescription mpd,
       ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,
           VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, handler, logger, VIDEO_EVENT_ID,
           MIN_LOADABLE_RETRY_COUNT);
-      MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(host,
+      DebugMediaCodecVideoTrackRenderer videoRenderer = new DebugMediaCodecVideoTrackRenderer(host,
           videoSampleSource, MediaCodecSelector.DEFAULT, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT,
-          0, handler, logger, 50);
+          0, handler, logger, 50, fullPlaybackNoSeeking);
       videoCounters = videoRenderer.codecCounters;
-      player.sendMessage(videoRenderer, MediaCodecVideoTrackRenderer.MSG_SET_SURFACE, surface);
+      player.sendMessage(videoRenderer, DebugMediaCodecVideoTrackRenderer.MSG_SET_SURFACE, surface);
 
       // Build the audio renderer.
       DataSource audioDataSource = new DefaultUriDataSource(host, null, userAgent);
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/DebugMediaCodecVideoTrackRenderer.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/DebugMediaCodecVideoTrackRenderer.java
new file mode 100644
index 0000000000..62f351d999
--- /dev/null
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/DebugMediaCodecVideoTrackRenderer.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.playbacktests.util;
+
+import com.google.android.exoplayer.MediaCodecSelector;
+import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
+import com.google.android.exoplayer.SampleSource;
+import com.google.android.exoplayer.util.Assertions;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.os.Handler;
+
+/**
+ * Decodes and renders video using {@link MediaCodecVideoTrackRenderer}. Provides buffer timestamp
+ * assertions.
+ */
+@TargetApi(16)
+public class DebugMediaCodecVideoTrackRenderer extends MediaCodecVideoTrackRenderer {
+
+  private static final int ARRAY_SIZE = 1000;
+
+  public final long[] timestampsList = new long[ARRAY_SIZE];
+
+  private int startIndex;
+  private int queueSize;
+  private boolean enableBufferTimestampAssertions;
+
+  public DebugMediaCodecVideoTrackRenderer(Context context, SampleSource source,
+      MediaCodecSelector mediaCodecSelector, int videoScalingMode, long allowedJoiningTimeMs,
+      Handler eventHandler, EventListener eventListener, int maxDroppedFrameCountToNotify,
+      boolean enableBufferTimestampAssertions) {
+    super(context, source, mediaCodecSelector, videoScalingMode, allowedJoiningTimeMs, null, false,
+        eventHandler, eventListener, maxDroppedFrameCountToNotify);
+    this.enableBufferTimestampAssertions = enableBufferTimestampAssertions;
+    startIndex = 0;
+    queueSize = 0;
+  }
+
+  @Override
+  protected void onQueuedInputBuffer(long presentationTimeUs) {
+    if (enableBufferTimestampAssertions) {
+      insertTimestamp(presentationTimeUs);
+      maybeShiftTimestampsList();
+    }
+  }
+
+  @Override
+  protected void onProcessedOutputBuffer(long presentationTimeUs) {
+    if (enableBufferTimestampAssertions) {
+      Assertions.checkArgument(dequeueTimestamp() == presentationTimeUs);
+    }
+  }
+
+  private void insertTimestamp(long presentationTimeUs) {
+    for (int i = startIndex + queueSize - 1; i >= startIndex; i--) {
+      if (presentationTimeUs >= timestampsList[i]) {
+        timestampsList[i + 1] = presentationTimeUs;
+        queueSize++;
+        return;
+      }
+      timestampsList[i + 1] = timestampsList[i];
+    }
+    timestampsList[startIndex] = presentationTimeUs;
+    queueSize++;
+  }
+
+  private void maybeShiftTimestampsList() {
+    if (startIndex + queueSize == ARRAY_SIZE) {
+      System.arraycopy(timestampsList, startIndex, timestampsList, 0, queueSize);
+      startIndex = 0;
+    }
+  }
+
+  private long dequeueTimestamp() {
+    startIndex++;
+    queueSize--;
+    return timestampsList[startIndex - 1];
+  }
+}
