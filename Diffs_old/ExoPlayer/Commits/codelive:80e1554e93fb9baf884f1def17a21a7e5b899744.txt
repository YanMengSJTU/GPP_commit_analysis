diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
index cffd5220ab..29b9267551 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
@@ -556,8 +556,8 @@ private static StsdData parseStsd(ParsableByteArray stsd, int trackId, long dura
           || childAtomType == Atom.TYPE_encv || childAtomType == Atom.TYPE_mp4v
           || childAtomType == Atom.TYPE_hvc1 || childAtomType == Atom.TYPE_hev1
           || childAtomType == Atom.TYPE_s263) {
-        parseVideoSampleEntry(stsd, childStartPosition, childAtomSize, trackId, durationUs,
-            rotationDegrees, out, i);
+        parseVideoSampleEntry(stsd, childAtomType, childStartPosition, childAtomSize, trackId,
+            durationUs, rotationDegrees, out, i);
       } else if (childAtomType == Atom.TYPE_mp4a || childAtomType == Atom.TYPE_enca
           || childAtomType == Atom.TYPE_ac_3 || childAtomType == Atom.TYPE_ec_3
           || childAtomType == Atom.TYPE_dtsc || childAtomType == Atom.TYPE_dtse
@@ -585,8 +585,8 @@ private static StsdData parseStsd(ParsableByteArray stsd, int trackId, long dura
     return out;
   }
 
-  private static void parseVideoSampleEntry(ParsableByteArray parent, int position, int size,
-      int trackId, long durationUs, int rotationDegrees, StsdData out, int entryIndex) {
+  private static void parseVideoSampleEntry(ParsableByteArray parent, int atomType, int position,
+      int size, int trackId, long durationUs, int rotationDegrees, StsdData out, int entryIndex) {
     parent.setPosition(position + Atom.HEADER_SIZE);
 
     parent.skipBytes(24);
@@ -596,8 +596,13 @@ private static void parseVideoSampleEntry(ParsableByteArray parent, int position
     float pixelWidthHeightRatio = 1;
     parent.skipBytes(50);
 
-    List<byte[]> initializationData = null;
     int childPosition = parent.getPosition();
+    if (atomType == Atom.TYPE_encv) {
+      parseSampleEntryEncryptionData(parent, position, size, out, entryIndex);
+      parent.setPosition(childPosition);
+    }
+
+    List<byte[]> initializationData = null;
     String mimeType = null;
     while (childPosition - position < size) {
       parent.setPosition(childPosition);
@@ -633,9 +638,6 @@ private static void parseVideoSampleEntry(ParsableByteArray parent, int position
             parseEsdsFromParent(parent, childStartPosition);
         mimeType = mimeTypeAndInitializationData.first;
         initializationData = Collections.singletonList(mimeTypeAndInitializationData.second);
-      } else if (childAtomType == Atom.TYPE_sinf) {
-        out.trackEncryptionBoxes[entryIndex] =
-            parseSinfFromParent(parent, childStartPosition, childAtomSize);
       } else if (childAtomType == Atom.TYPE_pasp) {
         pixelWidthHeightRatio = parsePaspFromParent(parent, childStartPosition);
         pixelWidthHeightRatioFromPasp = true;
@@ -757,30 +759,6 @@ private static AvcCData parseAvcCFromParent(ParsableByteArray parent, int positi
     return Pair.create(editListDurations, editListMediaTimes);
   }
 
-  private static TrackEncryptionBox parseSinfFromParent(ParsableByteArray parent, int position,
-      int size) {
-    int childPosition = position + Atom.HEADER_SIZE;
-
-    TrackEncryptionBox trackEncryptionBox = null;
-    while (childPosition - position < size) {
-      parent.setPosition(childPosition);
-      int childAtomSize = parent.readInt();
-      int childAtomType = parent.readInt();
-      if (childAtomType == Atom.TYPE_frma) {
-        parent.readInt(); // dataFormat.
-      } else if (childAtomType == Atom.TYPE_schm) {
-        parent.skipBytes(4);
-        parent.readInt(); // schemeType. Expect cenc
-        parent.readInt(); // schemeVersion. Expect 0x00010000
-      } else if (childAtomType == Atom.TYPE_schi) {
-        trackEncryptionBox = parseSchiFromParent(parent, childPosition, childAtomSize);
-      }
-      childPosition += childAtomSize;
-    }
-
-    return trackEncryptionBox;
-  }
-
   private static float parsePaspFromParent(ParsableByteArray parent, int position) {
     parent.setPosition(position + Atom.HEADER_SIZE);
     int hSpacing = parent.readUnsignedIntToInt();
@@ -788,27 +766,6 @@ private static float parsePaspFromParent(ParsableByteArray parent, int position)
     return (float) hSpacing / vSpacing;
   }
 
-  private static TrackEncryptionBox parseSchiFromParent(ParsableByteArray parent, int position,
-      int size) {
-    int childPosition = position + Atom.HEADER_SIZE;
-    while (childPosition - position < size) {
-      parent.setPosition(childPosition);
-      int childAtomSize = parent.readInt();
-      int childAtomType = parent.readInt();
-      if (childAtomType == Atom.TYPE_tenc) {
-        parent.skipBytes(4);
-        int firstInt = parent.readInt();
-        boolean defaultIsEncrypted = (firstInt >> 8) == 1;
-        int defaultInitVectorSize = firstInt & 0xFF;
-        byte[] defaultKeyId = new byte[16];
-        parent.readBytes(defaultKeyId, 0, defaultKeyId.length);
-        return new TrackEncryptionBox(defaultIsEncrypted, defaultInitVectorSize, defaultKeyId);
-      }
-      childPosition += childAtomSize;
-    }
-    return null;
-  }
-
   private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType, int position,
       int size, int trackId, long durationUs, String language, boolean isQuickTime, StsdData out,
       int entryIndex) {
@@ -848,6 +805,12 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
       return;
     }
 
+    int childPosition = parent.getPosition();
+    if (atomType == Atom.TYPE_enca) {
+      atomType = parseSampleEntryEncryptionData(parent, position, size, out, entryIndex);
+      parent.setPosition(childPosition);
+    }
+
     // If the atom type determines a MIME type, set it immediately.
     String mimeType = null;
     if (atomType == Atom.TYPE_ac_3) {
@@ -869,19 +832,14 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
     }
 
     byte[] initializationData = null;
-    int childAtomPosition = parent.getPosition();
-    while (childAtomPosition - position < size) {
-      parent.setPosition(childAtomPosition);
+    while (childPosition - position < size) {
+      parent.setPosition(childPosition);
       int childAtomSize = parent.readInt();
       Assertions.checkArgument(childAtomSize > 0, "childAtomSize should be positive");
       int childAtomType = parent.readInt();
-      if (atomType == Atom.TYPE_mp4a || atomType == Atom.TYPE_enca) {
-        int esdsAtomPosition = -1;
-        if (childAtomType == Atom.TYPE_esds) {
-          esdsAtomPosition = childAtomPosition;
-        } else if (isQuickTime && childAtomType == Atom.TYPE_wave) {
-          esdsAtomPosition = findEsdsPosition(parent, childAtomPosition, childAtomSize);
-        }
+      if (childAtomType == Atom.TYPE_esds || (isQuickTime && childAtomType == Atom.TYPE_wave)) {
+        int esdsAtomPosition = childAtomType == Atom.TYPE_esds ? childPosition
+            : findEsdsPosition(parent, childPosition, childAtomSize);
         if (esdsAtomPosition != -1) {
           Pair<String, byte[]> mimeTypeAndInitializationData =
               parseEsdsFromParent(parent, esdsAtomPosition);
@@ -895,46 +853,32 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
             sampleRate = audioSpecificConfig.first;
             channelCount = audioSpecificConfig.second;
           }
-        } else if (childAtomType == Atom.TYPE_sinf) {
-          out.trackEncryptionBoxes[entryIndex] = parseSinfFromParent(parent, childAtomPosition,
-              childAtomSize);
         }
-      } else if (atomType == Atom.TYPE_ac_3 && childAtomType == Atom.TYPE_dac3) {
-        // TODO: Choose the right AC-3 track based on the contents of dac3/dec3.
-        // TODO: Add support for encryption (by setting out.trackEncryptionBoxes).
-        parent.setPosition(Atom.HEADER_SIZE + childAtomPosition);
+      } else if (childAtomType == Atom.TYPE_dac3) {
+        parent.setPosition(Atom.HEADER_SIZE + childPosition);
         out.mediaFormat = Ac3Util.parseAc3AnnexFFormat(parent, Integer.toString(trackId),
             durationUs, language);
-        return;
-      } else if (atomType == Atom.TYPE_ec_3 && childAtomType == Atom.TYPE_dec3) {
-        parent.setPosition(Atom.HEADER_SIZE + childAtomPosition);
+      } else if (childAtomType == Atom.TYPE_dec3) {
+        parent.setPosition(Atom.HEADER_SIZE + childPosition);
         out.mediaFormat = Ac3Util.parseEAc3AnnexFFormat(parent, Integer.toString(trackId),
             durationUs, language);
-        return;
-      } else if ((atomType == Atom.TYPE_dtsc || atomType == Atom.TYPE_dtse
-          || atomType == Atom.TYPE_dtsh || atomType == Atom.TYPE_dtsl)
-          && childAtomType == Atom.TYPE_ddts) {
+      } else if (childAtomType == Atom.TYPE_ddts) {
         out.mediaFormat = MediaFormat.createAudioFormat(Integer.toString(trackId), mimeType,
             MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, durationUs, channelCount, sampleRate, null,
             language);
-        return;
       }
-      childAtomPosition += childAtomSize;
+      childPosition += childAtomSize;
     }
 
-    // If the media type was not recognized, ignore the track.
-    if (mimeType == null) {
-      return;
+    if (out.mediaFormat == null && mimeType != null) {
+      // TODO: Determine the correct PCM encoding.
+      int pcmEncoding = MimeTypes.AUDIO_RAW.equals(mimeType) ? C.ENCODING_PCM_16BIT
+          : MediaFormat.NO_VALUE;
+      out.mediaFormat = MediaFormat.createAudioFormat(Integer.toString(trackId), mimeType,
+          MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, durationUs, channelCount, sampleRate,
+          initializationData == null ? null : Collections.singletonList(initializationData),
+          language, pcmEncoding);
     }
-
-    // TODO: Determine the correct PCM encoding.
-    int pcmEncoding = MimeTypes.AUDIO_RAW.equals(mimeType) ? C.ENCODING_PCM_16BIT
-        : MediaFormat.NO_VALUE;
-
-    out.mediaFormat = MediaFormat.createAudioFormat(Integer.toString(trackId), mimeType,
-        MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, durationUs, channelCount, sampleRate,
-        initializationData == null ? null : Collections.singletonList(initializationData),
-        language, pcmEncoding);
   }
 
   /** Returns the position of the esds box within a parent, or -1 if no esds box is found */
@@ -1027,6 +971,78 @@ private static int findEsdsPosition(ParsableByteArray parent, int position, int
     return Pair.create(mimeType, initializationData);
   }
 
+  /**
+   * Parses encryption data from an audio/video sample entry, populating {@code out} and returning
+   * the unencrypted atom type, or 0 if no sinf atom was present.
+   */
+  private static int parseSampleEntryEncryptionData(ParsableByteArray parent, int position,
+      int size, StsdData out, int entryIndex) {
+    int childPosition = parent.getPosition();
+    while (childPosition - position < size) {
+      parent.setPosition(childPosition);
+      int childAtomSize = parent.readInt();
+      Assertions.checkArgument(childAtomSize > 0, "childAtomSize should be positive");
+      int childAtomType = parent.readInt();
+      if (childAtomType == Atom.TYPE_sinf) {
+        Pair<Integer, TrackEncryptionBox> result = parseSinfFromParent(parent, childPosition,
+            childAtomSize);
+        Integer dataFormat = result.first;
+        Assertions.checkArgument(dataFormat != null, "frma atom is mandatory");
+        out.trackEncryptionBoxes[entryIndex] = result.second;
+        return dataFormat;
+      }
+      childPosition += childAtomSize;
+    }
+    // This enca/encv box does not have a data format so return an invalid atom type.
+    return 0;
+  }
+
+  private static Pair<Integer, TrackEncryptionBox> parseSinfFromParent(ParsableByteArray parent,
+      int position, int size) {
+    int childPosition = position + Atom.HEADER_SIZE;
+
+    TrackEncryptionBox trackEncryptionBox = null;
+    Integer dataFormat = null;
+    while (childPosition - position < size) {
+      parent.setPosition(childPosition);
+      int childAtomSize = parent.readInt();
+      int childAtomType = parent.readInt();
+      if (childAtomType == Atom.TYPE_frma) {
+        dataFormat = parent.readInt();
+      } else if (childAtomType == Atom.TYPE_schm) {
+        parent.skipBytes(4);
+        parent.readInt(); // schemeType. Expect cenc
+        parent.readInt(); // schemeVersion. Expect 0x00010000
+      } else if (childAtomType == Atom.TYPE_schi) {
+        trackEncryptionBox = parseSchiFromParent(parent, childPosition, childAtomSize);
+      }
+      childPosition += childAtomSize;
+    }
+
+    return Pair.create(dataFormat, trackEncryptionBox);
+  }
+
+  private static TrackEncryptionBox parseSchiFromParent(ParsableByteArray parent, int position,
+      int size) {
+    int childPosition = position + Atom.HEADER_SIZE;
+    while (childPosition - position < size) {
+      parent.setPosition(childPosition);
+      int childAtomSize = parent.readInt();
+      int childAtomType = parent.readInt();
+      if (childAtomType == Atom.TYPE_tenc) {
+        parent.skipBytes(4);
+        int firstInt = parent.readInt();
+        boolean defaultIsEncrypted = (firstInt >> 8) == 1;
+        int defaultInitVectorSize = firstInt & 0xFF;
+        byte[] defaultKeyId = new byte[16];
+        parent.readBytes(defaultKeyId, 0, defaultKeyId.length);
+        return new TrackEncryptionBox(defaultIsEncrypted, defaultInitVectorSize, defaultKeyId);
+      }
+      childPosition += childAtomSize;
+    }
+    return null;
+  }
+
   /** Parses the size of an expandable class, as specified by ISO 14496-1 subsection 8.3.3. */
   private static int parseExpandableClassSize(ParsableByteArray data) {
     int currentByte = data.readUnsignedByte();
