diff --git a/demos/main/src/main/assets/media.exolist.json b/demos/main/src/main/assets/media.exolist.json
index 959823c506..ed47b61631 100644
--- a/demos/main/src/main/assets/media.exolist.json
+++ b/demos/main/src/main/assets/media.exolist.json
@@ -21,6 +21,10 @@
       {
         "name": "Encrypted Custom",
         "uri": "https://vocatest-a40ab.firebaseapp.com/encrypted_android_no_key/prog_index.m3u8"
+      },
+      {
+        "name": "Encrypted Custom Small",
+        "uri": "https://vocatest-a40ab.firebaseapp.com/small_files/encrypted_without_key/index.m3u8"
       }
     ]
   }
diff --git a/library/core/build.gradle b/library/core/build.gradle
index 7893c6ab6c..d6c5762f56 100644
--- a/library/core/build.gradle
+++ b/library/core/build.gradle
@@ -68,6 +68,8 @@ dependencies {
     testImplementation 'org.robolectric:robolectric:' + robolectricVersion
     testImplementation 'com.google.auto.value:auto-value-annotations:' + autoValueVersion
     testAnnotationProcessor 'com.google.auto.value:auto-value:' + autoValueVersion
+    implementation 'com.google.code.gson:gson:2.8.2'
+
 }
 
 ext {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java
index ef28292a25..d84ddb3f1b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java
@@ -24,7 +24,9 @@
 import com.google.android.exoplayer2.upstream.cache.CacheDataSource;
 import com.google.android.exoplayer2.upstream.cache.CacheUtil;
 import com.google.android.exoplayer2.upstream.cache.CacheUtil.CachingCounters;
+import com.google.android.exoplayer2.upstream.vocabimate_stream.VocaDataSourceHelper;
 import com.google.android.exoplayer2.util.PriorityTaskManager;
+import com.google.gson.Gson;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -218,6 +220,15 @@ public final void remove() throws InterruptedException {
      * so that we can skip key download as we need to do it our self at some point.
      */
 
+//    DataSpec licenceSpec = new DataSpec(Uri.parse("https://vocatest-a40ab.firebaseapp.com/license_key_path_absolute.json"));
+//    DataSource source = DataSource.Factory.createDataSource();
+
+    String licenceJson = "{ \"key_path\": \"https://vocatest-a40ab.firebaseapp.com/small_files/enc.key\" }";
+
+    VocaDataSourceHelper.LicenceModel model = new Gson().fromJson(licenceJson, VocaDataSourceHelper.LicenceModel.class);
+
+    Segment segLicence = new Segment(0, new DataSpec(Uri.parse(model.getPath())));
+
     ListIterator<Segment> segmentListIterator = segments.listIterator();
     while (segmentListIterator.hasNext()){
       Segment segment = segmentListIterator.next();
@@ -227,6 +238,11 @@ public final void remove() throws InterruptedException {
       }
     }
 
+    segments.add(0, segLicence); // add licence to front
+
+    /**
+     * Changes end here
+     */
     CachingCounters cachingCounters = new CachingCounters();
     totalSegments = segments.size();
     downloadedSegments = 0;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
index a1eebabaf4..c3fbefa60f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
@@ -19,6 +19,7 @@
 import android.text.TextUtils;
 import android.util.Log;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.upstream.vocabimate_stream.AesEncryptionUtil;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Predicate;
 import com.google.android.exoplayer2.util.Util;
@@ -206,7 +207,7 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
 
     if(responseCode == 500 || responseCode == 404) { // for custom server hisham
       try {
-        connection = makeConnectionCustom(new URL(dataSpec.uri.toString()));
+        connection = makeConnectionCustom(dataSpec);
       } catch (IOException e) {
         e.printStackTrace();
       }
@@ -269,7 +270,15 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
   }
 
 
-  private HttpURLConnection makeConnectionCustom(URL url) throws IOException {
+
+  /**
+   * Custom method for custom scheme.
+   */
+  private HttpURLConnection makeConnectionCustom(DataSpec dataSpec) throws IOException {
+
+    String licenceUrl = "https://vocatest-a40ab.firebaseapp.com/license_key_path_absolute.json";
+    URL url = new URL(licenceUrl);
+
     HttpURLConnection connection = (HttpURLConnection) url.openConnection();
     connection.setConnectTimeout(connectTimeoutMillis);
     connection.setReadTimeout(readTimeoutMillis);
@@ -593,13 +602,40 @@ private int readInternal(byte[] buffer, int offset, int readLength) throws IOExc
     }
     if (bytesToRead != C.LENGTH_UNSET) {
       long bytesRemaining = bytesToRead - bytesRead;
-      if (bytesRemaining == 0) {
+      if (bytesRemaining <= 0) { // TODO hisham - getting a negative. just a quick fix.
         return C.RESULT_END_OF_INPUT;
       }
       readLength = (int) Math.min(readLength, bytesRemaining);
     }
 
-    int read = inputStream.read(buffer, offset, readLength);
+
+
+    int read;
+
+    /**
+     * Here we first check if dataSpec is hitting for key segment.
+     * We read the buffer, which should contain only 16 bytes but this buffer is quite big and contain 0's after 15th index.
+     * Also this method is called within a while loop where read = inputStream.read(buffer); returns the number of bytes read at
+     * first but then it returns -1 indicating that file has ended.
+     * Also, read = inputStream.read(buffer); gives you 16 bytes because the key is 16 bytes.
+     * Then we encrypt the 16 byte key using AesEncryptionUtil which gives us a 45 byte result (This could be more or less for different keys)
+     * We then override the read variable with the result received after our encryption.
+     * When we get -1 from read variable that means file has ended.
+     */
+    if(dataSpec.key != null && dataSpec.key.contains(".key")) {
+      read = inputStream.read(buffer);
+      if (read == 16) {
+        byte[] testValue = new byte[16];
+        System.arraycopy(buffer, 0, testValue, 0, 16);
+        byte[] finalDataWritten = AesEncryptionUtil
+            .encrypt("Bar12345Bar12345", "pppppppppppppppp", testValue);
+        System.arraycopy(finalDataWritten, 0, buffer, 0, finalDataWritten.length);
+        read = finalDataWritten.length;
+      }
+    } else {
+      read = inputStream.read(buffer, offset, readLength); // hisham - low level read happening here
+    }
+
     if (read == -1) {
       if (bytesToRead != C.LENGTH_UNSET) {
         // End of stream reached having not read sufficient data.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
index 7d2d5b79a9..05d686b2f8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
@@ -282,11 +282,16 @@ public synchronized void commitFile(File file) throws CacheException {
       file.delete();
       return;
     }
+
+
+    /**
+     * Bypassing the assertion for data length check
+     */
     // Check if the span conflicts with the set content length
-    long length = ContentMetadataInternal.getContentLength(cachedContent.getMetadata());
-    if (length != C.LENGTH_UNSET) {
-      Assertions.checkState((span.position + span.length) <= length);
-    }
+//    long length = ContentMetadataInternal.getContentLength(cachedContent.getMetadata());
+//    if (length != C.LENGTH_UNSET) {
+//      Assertions.checkState((span.position + span.length) <= length);
+//    }
     addSpan(span);
     index.store();
     notifyAll();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/vocabimate_stream/AesEncryptionUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/vocabimate_stream/AesEncryptionUtil.java
new file mode 100644
index 0000000000..487e01ffc0
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/vocabimate_stream/AesEncryptionUtil.java
@@ -0,0 +1,104 @@
+package com.google.android.exoplayer2.upstream.vocabimate_stream;
+
+import javax.crypto.Cipher;
+import javax.crypto.spec.IvParameterSpec;
+import javax.crypto.spec.SecretKeySpec;
+
+public class AesEncryptionUtil {
+	public static byte[] encrypt(String key, String initVector, byte[] value) {
+		try {
+			IvParameterSpec iv = new IvParameterSpec(initVector.getBytes("UTF-8"));
+			SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes("UTF-8"), "AES");
+
+			Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
+			cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);
+
+			byte[] encrypted = cipher.doFinal(value);
+//			System.out.println(encrypted);
+			String fileInString = new String(android.util.Base64.encode(encrypted, android.util.Base64.DEFAULT));
+//      String fileInString = Base64.encodeBase64String(encrypted);
+//			System.out.println("encrypted string: " + fileInString);
+			byte[] fileInBytes = fileInString.getBytes();
+
+			return fileInBytes;
+		} catch (Exception ex) {
+			ex.printStackTrace();
+		}
+
+		return null;
+	}
+
+    public static  byte[] decrypt(String key, String initVector, byte[] encodedfileInBytes) {
+        try {
+        	String encodedfileInString=new String(encodedfileInBytes);
+            IvParameterSpec iv = new IvParameterSpec(initVector.getBytes("UTF-8"));
+            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes("UTF-8"), "AES");
+
+            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
+            cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);
+          byte[] decodeFileInBytes=  android.util.Base64.decode(encodedfileInString, android.util.Base64.DEFAULT);
+            byte[] originalFile = cipher.doFinal(decodeFileInBytes);
+
+            return originalFile;
+        } catch (Exception ex) {
+            ex.printStackTrace();
+        }
+
+        return null;
+    }
+    
+    
+//  public static void main(String[] args) {
+//
+//	  File file = new File("D:\\crypt0.key");
+//	  //init array with file length
+//	  byte[] bytesArray = new byte[(int) file.length()];
+//	  try {
+//	  FileInputStream fis = new FileInputStream(file);
+//
+//		fis.read(bytesArray);
+//		  fis.close();
+//	} catch (IOException e) {
+//		// TODO Auto-generated catch block
+//		e.printStackTrace();
+//	} //read file into bytes[]
+//
+//
+//
+//    byte[] c=  encrypt("Bar12345Bar12345", "pppppppppppppppp",bytesArray);
+//
+//    File fileIntermediate = new File("D:\\crypt0_interm.key");
+//    try {
+//		  FileOutputStream fisIntrim = new FileOutputStream(fileIntermediate);
+//
+//		  fisIntrim.write(c);
+//		  fisIntrim.close();
+//	} catch (IOException e) {
+//		// TODO Auto-generated catch block
+//		e.printStackTrace();
+//	} //read file into bytes[]
+//
+//
+//
+//    byte[] d=	decrypt("Bar12345Bar12345", "pppppppppppppppp",c);
+//
+//    File file2 = new File("D:\\crypt0_decryted.key");
+//	  //init array with file length
+////	  byte[] bytesArray2 = new byte[(int) bytesArray.length];
+//	  try {
+//		  FileOutputStream fis2 = new FileOutputStream(file2);
+//
+//		fis2.write(d);
+//		  fis2.close();
+//	} catch (IOException e) {
+//		// TODO Auto-generated catch block
+//		e.printStackTrace();
+//	} //read file into bytes[]
+//
+//
+//    System.out.println(new String(d));
+//}
+    
+    
+    
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/vocabimate_stream/VocaDataSourceHelper.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/vocabimate_stream/VocaDataSourceHelper.java
new file mode 100644
index 0000000000..2394b2b579
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/vocabimate_stream/VocaDataSourceHelper.java
@@ -0,0 +1,73 @@
+package com.google.android.exoplayer2.upstream.vocabimate_stream;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.gson.Gson;
+import com.google.gson.annotations.SerializedName;
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.net.HttpURLConnection;
+import java.net.URLConnection;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/**
+ * Created by Hisham on 21/Sep/2018 - 17:13
+ */
+public class VocaDataSourceHelper {
+
+    private Gson gson;
+
+//    public void parseData(URLConnection connection,
+//        DataSpec dataSpec) throws IOException {
+//
+//        connection.connect();
+//        InputStream stream = connection.getInputStream();
+//        BufferedReader reader = new BufferedReader(new InputStreamReader(stream));
+//        StringBuffer buffer = new StringBuffer();
+//        String line;
+//        while ((line = reader.readLine()) != null){
+//            buffer.append(line);
+//        }
+//
+//        String finalJson = buffer.toString();
+//        try {
+//            JSONObject parentObject = new JSONObject(finalJson);
+//
+//            LicenceModel licenceModel = gson.fromJson(parentObject.toString(), LicenceModel.class);
+//            String keyPath = licenceModel.getPath();
+//            dataSpec.uri = Uri.parse(keyPath);
+//        } catch (JSONException e) {
+//            e.printStackTrace();
+//        }
+
+//    }
+
+    public class LicenceModel {
+        @SerializedName("key_path")
+        private String path;
+        @SerializedName("key")
+        private String key;
+
+        public String getPath() {
+            return path;
+        }
+
+        public LicenceModel setPath(String path) {
+            this.path = path;
+            return this;
+        }
+
+        public String getKey() {
+            return key;
+        }
+
+        public LicenceModel setKey(String key) {
+            this.key = key;
+            return this;
+        }
+    }
+
+}
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
index 37804b81f4..7085241f68 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
@@ -32,6 +32,7 @@
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.vocabimate_stream.AesEncryptionUtil;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.UriUtil;
 import com.google.android.exoplayer2.util.Util;
@@ -376,6 +377,15 @@ public void getNextChunk(
   public void onChunkLoadCompleted(Chunk chunk) {
     if (chunk instanceof EncryptionKeyChunk) {
       EncryptionKeyChunk encryptionKeyChunk = (EncryptionKeyChunk) chunk;
+
+      /**
+       * Here it loads the decryption key, which we should have already encrypted using our AesEncryptionUtil, so we need
+       * to decrypt it first. See {@Link DefaultHttpDataSource#readInternal() Line: 616} for more details.
+       */
+      if(chunk.dataSpec != null && chunk.dataSpec.uri != null && chunk.dataSpec.uri.toString().contains(".key")) { // hisham - decrypting key here
+          encryptionKeyChunk.result = AesEncryptionUtil.decrypt("Bar12345Bar12345", "pppppppppppppppp",encryptionKeyChunk.getResult());
+      }
+
       scratchSpace = encryptionKeyChunk.getDataHolder();
       setEncryptionData(encryptionKeyChunk.dataSpec.uri, encryptionKeyChunk.iv,
           encryptionKeyChunk.getResult());
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
index 7187bdb0ca..14a8b10b1f 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
@@ -416,7 +416,7 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
           if (KEYFORMAT_IDENTITY.equals(keyFormat) || keyFormat == null) {
             if (METHOD_AES_128.equals(method)) {
               // The segment is fully encrypted using an identity key.
-              encryptionKeyUri = parseStringAttr(line, REGEX_URI);
+              encryptionKeyUri = parseStringAttr(line, REGEX_URI); // hisham - reading the key line in m3u8
             } else {
               // Do nothing. Samples are encrypted using an identity key, but this is not supported.
               // Hopefully, a traditional DRM alternative is also provided.
@@ -544,7 +544,21 @@ private static String parseOptionalStringAttr(String line, Pattern pattern) {
     return matcher.find() ? matcher.group(1) : null;
   }
 
+
+  /**
+   * Intercepting the parsing of m3u8 file
+   */
   private static String parseStringAttr(String line, Pattern pattern) throws ParserException {
+
+    if(line != null && line.contains("custom://")){
+      String licenceJson = "{ \"key_path\": \"https://vocatest-a40ab.firebaseapp.com/enc.key\" }";
+
+//      VocaDataSourceHelper.LicenceModel model = new Gson().fromJson(licenceJson, VocaDataSourceHelper.LicenceModel.class);
+
+      return "https://vocatest-a40ab.firebaseapp.com/small_files/enc.key";
+
+    }
+
     Matcher matcher = pattern.matcher(line);
     if (matcher.find() && matcher.groupCount() == 1) {
       return matcher.group(1);
