diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 93c3fd2387..9bc992cbe0 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,5 +1,15 @@
 # Release notes #
 
+### r1.5.3 ###
+
+* Support for FLV (without seeking).
+* MP4: Fix for playback of media containing basic edit lists.
+* QuickTime: Fix parsing of QuickTime style audio sample entry.
+* HLS: Add H262 support for devices that have an H262 decoder.
+* Allow AudioTrack PlaybackParams (e.g. speed/pitch) on API level 23+.
+* Correctly detect 4K displays on API level 23+.
+* Misc bug fixes.
+
 ### r1.5.2 ###
 
 * MPEG-TS/HLS: Fix frame drops playing H265 video.
diff --git a/demo/assets/ic_launcher.svg~ b/demo/assets/ic_launcher.svg~
deleted file mode 100644
index c01934f697..0000000000
--- a/demo/assets/ic_launcher.svg~
+++ /dev/null
@@ -1,665 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:xlink="http://www.w3.org/1999/xlink"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   width="192"
-   height="192"
-   id="svg3089"
-   version="1.1"
-   inkscape:version="0.48.4 r9939"
-   sodipodi:docname="exoplayer.svg"
-   inkscape:export-filename="/usr/local/google/home/zakcohen/Documents/big.png"
-   inkscape:export-xdpi="225"
-   inkscape:export-ydpi="225"
-   enable-background="new">
-  <sodipodi:namedview
-     id="base"
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1.0"
-     inkscape:pageopacity="0.0"
-     inkscape:pageshadow="2"
-     inkscape:zoom="2.0893424"
-     inkscape:cx="79.970323"
-     inkscape:cy="85.448985"
-     inkscape:current-layer="layer2"
-     showgrid="true"
-     inkscape:grid-bbox="true"
-     inkscape:document-units="px"
-     showguides="true"
-     inkscape:guide-bbox="true"
-     inkscape:window-width="1920"
-     inkscape:window-height="1176"
-     inkscape:window-x="1920"
-     inkscape:window-y="24"
-     inkscape:window-maximized="1" />
-  <defs
-     id="defs3091">
-    <linearGradient
-       inkscape:collect="always"
-       id="linearGradient4624">
-      <stop
-         style="stop-color:#ffffff;stop-opacity:1;"
-         offset="0"
-         id="stop4626" />
-      <stop
-         style="stop-color:#ffffff;stop-opacity:0;"
-         offset="1"
-         id="stop4628" />
-    </linearGradient>
-    <linearGradient
-       inkscape:collect="always"
-       id="linearGradient4498">
-      <stop
-         style="stop-color:#000000;stop-opacity:1;"
-         offset="0"
-         id="stop4500" />
-      <stop
-         style="stop-color:#000000;stop-opacity:0;"
-         offset="1"
-         id="stop4502" />
-    </linearGradient>
-    <linearGradient
-       id="linearGradient4511">
-      <stop
-         id="stop4513"
-         offset="0"
-         style="stop-color:#ffffff;stop-opacity:1;" />
-      <stop
-         id="stop4515"
-         offset="1"
-         style="stop-color:#ffffff;stop-opacity:0;" />
-    </linearGradient>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter4219">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.5"
-         id="feFlood4221" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4223" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="2"
-         in="composite"
-         id="feGaussianBlur4225" />
-      <feOffset
-         result="offset"
-         dy="4"
-         dx="4"
-         id="feOffset4227" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4229" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter4464">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4466" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4468" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur4470" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4472" />
-      <feComposite
-         result="fbSourceGraphic"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4474" />
-      <feColorMatrix
-         id="feColorMatrix4476"
-         values="0 0 0 -1 0 0 0 0 -1 0 0 0 0 -1 0 0 0 0 1 0"
-         in="fbSourceGraphic"
-         result="fbSourceGraphicAlpha" />
-      <feFlood
-         in="fbSourceGraphic"
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4478" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="fbSourceGraphic"
-         id="feComposite4480" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur4482" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4484" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="fbSourceGraphic"
-         in2="offset"
-         id="feComposite4486" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter4494">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4496" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4498" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur4500" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4502" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4504" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter4535">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4537" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4539" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur4541" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4543" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4545" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter4557">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4559" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4561" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur4563" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4565" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4567" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter4575">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4577" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4579" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur4581" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4583" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4585" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       id="filter4575-6"
-       color-interpolation-filters="sRGB">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4577-1" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4579-3" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         id="feGaussianBlur4581-3" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4583-6" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4585-9" />
-    </filter>
-    <filter
-       id="filter3896"
-       inkscape:collect="always">
-      <feBlend
-         id="feBlend3898"
-         in2="BackgroundImage"
-         mode="multiply"
-         inkscape:collect="always" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter3909">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood3911" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite3913" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur3915" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset3917" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite3919" />
-    </filter>
-    <linearGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient4498"
-       id="linearGradient4504"
-       x1="43.149372"
-       y1="63.20599"
-       x2="110.44475"
-       y2="130.50137"
-       gradientUnits="userSpaceOnUse" />
-    <linearGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient4498-7"
-       id="linearGradient4504-7"
-       x1="43.149372"
-       y1="63.20599"
-       x2="110.44475"
-       y2="130.50137"
-       gradientUnits="userSpaceOnUse" />
-    <linearGradient
-       inkscape:collect="always"
-       id="linearGradient4498-7">
-      <stop
-         style="stop-color:#000000;stop-opacity:1;"
-         offset="0"
-         id="stop4500-0" />
-      <stop
-         style="stop-color:#000000;stop-opacity:0;"
-         offset="1"
-         id="stop4502-0" />
-    </linearGradient>
-    <linearGradient
-       gradientTransform="translate(-0.12691481,66.675082)"
-       y2="130.50137"
-       x2="110.44475"
-       y1="63.20599"
-       x1="43.149372"
-       gradientUnits="userSpaceOnUse"
-       id="linearGradient4521"
-       xlink:href="#linearGradient4498-7"
-       inkscape:collect="always" />
-    <radialGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient4624"
-       id="radialGradient4630"
-       cx="17.483059"
-       cy="18.005892"
-       fx="17.483059"
-       fy="18.005892"
-       r="88.000001"
-       gradientTransform="matrix(-0.00420028,0.99999118,-1.888314,-0.00793148,51.557271,20.787508)"
-       gradientUnits="userSpaceOnUse" />
-    <filter
-       id="filter4680"
-       style="color-interpolation-filters:sRGB;"
-       inkscape:label="Drop Shadow"
-       width="1.4100000000000001"
-       height="1.4700000000000002"
-       x="-0.23000000000000009"
-       y="-0.23000000000000009">
-      <feFlood
-         id="feFlood4682"
-         flood-opacity="0.2"
-         flood-color="rgb(0,0,0)"
-         result="flood" />
-      <feComposite
-         id="feComposite4684"
-         in2="SourceGraphic"
-         in="flood"
-         operator="in"
-         result="composite1" />
-      <feGaussianBlur
-         id="feGaussianBlur4686"
-         in="composite"
-         stdDeviation="6"
-         result="blur" />
-      <feOffset
-         id="feOffset4688"
-         dx="0"
-         dy="6"
-         result="offset" />
-      <feComposite
-         id="feComposite4690"
-         in2="offset"
-         in="SourceGraphic"
-         operator="over"
-         result="composite2" />
-    </filter>
-    <filter
-       id="filter4692"
-       style="color-interpolation-filters:sRGB;"
-       inkscape:label="Drop Shadow"
-       width="1.3600000000000001"
-       x="-0.2400000000000001"
-       y="-0.070000000000000034"
-       height="1.3600000000000001">
-      <feFlood
-         id="feFlood4694"
-         flood-opacity="0.2"
-         flood-color="rgb(0,0,0)"
-         result="flood" />
-      <feComposite
-         id="feComposite4696"
-         in2="SourceGraphic"
-         in="flood"
-         operator="in"
-         result="composite1" />
-      <feGaussianBlur
-         id="feGaussianBlur4698"
-         in="composite"
-         stdDeviation="6"
-         result="blur" />
-      <feOffset
-         id="feOffset4700"
-         dx="0"
-         dy="6"
-         result="offset" />
-      <feComposite
-         id="feComposite4702"
-         in2="offset"
-         in="SourceGraphic"
-         operator="over"
-         result="composite2" />
-    </filter>
-    <filter
-       id="filter4710"
-       style="color-interpolation-filters:sRGB;"
-       inkscape:label="Drop Shadow">
-      <feFlood
-         id="feFlood4712"
-         flood-opacity="0.2"
-         flood-color="rgb(0,0,0)"
-         result="flood" />
-      <feComposite
-         id="feComposite4714"
-         in2="SourceGraphic"
-         in="flood"
-         operator="in"
-         result="composite1" />
-      <feGaussianBlur
-         id="feGaussianBlur4716"
-         in="composite"
-         stdDeviation="6"
-         result="blur" />
-      <feOffset
-         id="feOffset4718"
-         dx="0"
-         dy="6"
-         result="offset" />
-      <feComposite
-         id="feComposite4720"
-         in2="offset"
-         in="SourceGraphic"
-         operator="over"
-         result="composite2" />
-    </filter>
-  </defs>
-  <metadata
-     id="metadata3094">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <g
-     style="display:none"
-     sodipodi:insensitive="true"
-     transform="translate(0,176)"
-     inkscape:groupmode="layer"
-     inkscape:label="Layer 1"
-     id="layer1">
-    <image
-       width="192"
-       height="192"
-       xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAYAAABS3GwHAAAABHNCSVQICAgIfAhkiAAAIABJREFU eJztnVlXE1vax/9JZSBAAgljoAHbNBIwKHAOCsJSUZperr7qj3A+Tn+K8w2OV2fRx0YBFwioDEqE AA3vQRYUCCRQCZmH94KVLEBIatg1xfrdKVV771Sef2oPz6D797//nenr60MqlcKPTjgcBgCUlpZq /RU5er0e8/Pz0E1OTmZqamrQ3t4u95hk5+zsDABQVlam9VfkrKysIJFIQJ9KpdDe3g6v1yv3mGQn nU4jnU5r/RU5Xq8XHR0dSCaT0Gf/0+PxaCLQKHq8Xi88Hk/u3/qLf9REoFHMXDV+4IoAAE0EGsXJ dcYPXCMAQBOBRnFxk/EDNwgA+DFFYDabYTabtf6KiHzGDwCGfDdnRZCvATEJBAJYXl5GMBiEXq+H Xn+jXonAZ588O65EIgG/34/j42Po9XqUl5ejtLQUNptNUH8MwyAcDiMUCiGdTqOqqgoOhwNGo5Hz ro5U5wDZcVmtVnR2dsJut4va302wsd28AgDkEUEwGMTY2Bjq6+vR29sLi8UiSb9s98kjkQj29vbA MAxMJhNSqRQsFgt6e3tRWVkJiqKI9pcllUrh5OQEfr8fkUgEFEUhHo/DZrOhoaGh4HOS+hwgEolg aWkJ+/v7GB4ehtVqlaRfgJ3xAywEAEgrgqWlJdA0jX/961+i93WVm35NT05OsL29jVQqBZ1Oh8rK SrS0tMBgYPX4OPd3ExRFoaqqClVVVZf+P5lMYmdnBycnJ8hkMqAoCi0tLaisrBTUn1AsFgv6+/sB AKOjo3A6nejq6hK9Xy62qnvz5k1maGiIeMN8ePv2LRwOh2xTrmAwCIqiUFpaio2NDTAMAwCor69H Y2OjKP0BEOWXcXd3F/v7+wAAm82G1tZWhMNhpFIpSX+JL+L1euH3+/H48WNR+2BrP/Pz8+zeAFnE fBMsLS3JavwAsLGxgUgkApvNhjt37qh6wdjY2JgTbSwWw/LyMhiGgcViQU9PjyxjytrP0tKSKG8C PrbJ+R0uhgiCwSBomsaLFy+ItcmWr1+/4uDgACaTCc3NzSgrK5NszSEVZrMZnZ2diEQiODs7w6dP nxCPx1FXV4fm5mZJx+LxeDA6OgqXy0X0TcTXJnltq5DeIh0bG5PU+JPJJBYXFzE3N4eKigr09vbi /v37MJvNSCaTko1DapLJJMxmM+7fv4/e3l5UVFRgbm4Oi4uLkn7uFy9eYGxsjFh7Qn6Qea/iSL0J AoEA6uvrBbXBpS+fzwebzYbu7m5J+lQyFRUVePjwIQDgy5cvYBgGbrdbkm3L+vp6BAIBwX0JtUFB G+sk3gTLy8ui7wzQNI3Z2VkEAgH09/fj7t27ovanRu7evYv+/n4EAgHMzs6CpmlR++vq6sLy8rKg Nkj8AAs+WRIqgmAwKNqcm6ZpTE9PAwD6+vpw+/ZtUfopJm7fvo2+vj4AwPT0tGhCsFgsuV0wPpBa hxI5WhUiAjFOdwOBAN6+fQsAGBgYgNPpJN5HseN0OjEwMADgfHs6EAgQ74Pvd09yE4aY9fEVgdDD pIuk02nMz88jGAzi8ePHnA2/2H1z+PTndDrx+PFjBINBzM/PEz1M4/Pdk96B5HQQxoZ8A7zq22Mw GLC/v4/a2lre/WUyGRiNRqyuruLOnTugKIr3jkaxx+gK7c9gMCCVSmF9fR3t7e1IJBLQ6XS82spk Mjg9PUV5eTn0ej0r3yHSxj8/Pw+8efMmQ5rl5eVL/2YYJvPbb79l3r17lwmHw5f+9p///EdQX0dH R5mJiYlMNBoV1E4mk8mEQqFMKBQS3E6x9xeNRjMTExOZo6MjQe3Mzs5mYrFY7t/hcDjz7t27zG+/ /ZZhGObStVdtigQfP37MkJt/XODiFqmYvj2zs7OoqanBkydPiLQnta+MWvszm8148uQJNjc3sbGx kVs0cyWTyVwa002+Q2K64IjmX+zxePDrr7/CZDIRP+QKBAIYHx/HgwcP4HK5iLatwR6Xy4UHDx5g fHyc+CL5xYsXMJlM+PXXX0V1jxFNAEtLS7lDFpIsLi6CpmkMDQ2JHh+gURi9Xo+hoSHQNI3FxUXi 7T98+BBLS0vE280iigVlfXs6OjrQ0dFBxG0ilUrh9evXcLvd6OjoIDBKDZJ0dHTA7Xbj9evXRJKs ZVOXdHR0gKZpQWcG+RBFAFd9e4Qelh0fH2NqagrPnz8vOke1YsJiseD58+eYmZnB0dER73auzvlJ +w5dhLgAbvLt4SsCn8+Hw8NDYgtdDfEZHBzE0dERfD4f53tvWvBmfYdIQ1wA+Xx7uIpgamoKNTU1 cLvdpIanIRFutxs1NTWYmppifU++3R4SvkPXQVwAhXx72IpgbGwMDx8+/C78T0M9VFVV4eHDh6ym L4W2OoX6Dt0EcQGw2ZnJJ4JkMolXr15heHgYRqOR9PA0JMZoNGJ4eBivXr269oSeoijW+/xi7PoR b5Gtf4fH48H29val62OxGD58+ICRkRHSw2KFGnxz1NTfRUZGRvDhwwfEYrHc/5lMJvh8Ptb7/CT9 xrII8gUS6ttjMBjw7t079PX14fT0FAaDAWVlZbJlMFabb47S+7uKXq/H2dkZkskkKioq8PHjR3R3 d7PyJ8rw8B0qBOeg+Cz58vb88ccf+Mc//sG6rXQ6jdraWtjtdvz88898hkOMYs/Xr5T6AB8/fgRF URgeHsb9+/dhMplY3Tc3N4fu7u7c9STyDnEWAGnfntPTU9jtdpSXlxNpTwhq9c1Ran83UV5eDoZh cHp6ymlMbH2HuMBpDfD27VsYDAZivj2xWAwGgwE///wz3G73D5eL9EfE6/XC7XbjwYMHSCaTiMfj RNp98eIFDAZDLhCKLawFQDpvTzKZxMLCwqXX8Y+YkPdH4upuT3V1Nd6/f08sI4XH44HD4eDkO8RK AFnfHpJeeW/evEF/f/93r0BNBMXJdVudqVQKQ0NDePPmDbF+PB4PJ98hVgIgnbdnbGws71anJoLi It8+fyKRwMjICFFfHy6+QwUFQDpvz9TUFCu/Hk0ExQHbQ64nT55wcpsoBFvfoYICIJm3x+fzob29 nfUJryYCdcMlkstoNKK9vZ2XA911sPUdKigAUnl7jo+PAYCzb48mAnXCJ4wxaxtZWxECW9+hggIg 4X+RSqVy21980ESgLoTE8Ga3w0kE1bCxXUkEMDExIdifXxOBOiARwP7kyRNMTEwIHgsbFwvRg2oX Fxfx6NEjIm1pIlA2JLM3PHr0SHCMcUVFBaLRaN5rRBVAIBCA2WwmGsaoiUCZkE5dYrFYYDabBUWB yf4GWFpaEiWAXROBshArb09HR4eoGSEAEQUwOzsrahyvJgJlIHbduCdPnmB2dla09okLIJPJ4Pj4 GDU1NaLn7dFEIC9SVA7V6/WoqakRlGUib/ukGzQajfB6vZJlbNNEIA9S1o52uVzwer2ihMgSF8Dq 6irvXJF80UQgLVIXTgeA/v5+UdYDRAWQTqdlKy+qiUAa5DB+4Dyeua2tDZlMhmi7RAWwuLgIiqJI NskJTQTiIpfxZykpKSGef5SYAAKBAGpqamQvM6qJQBzkNn7gPIjKZrMRzRBHTADLy8uSF12+CU0E ZFGC8Wfp6OggmiGOiABomkZrayuJpoihZBGk02kEg0GcnZ3h7OwMwWBQMQHrV1GS8QNAPB5Ha2sr seqVRDINbW1t5SoKKglSxbz5sru7mwv8TyQSMBqNSKVSMJlMqKioyF2n0+lA0zTi8Tgoispdm63s 3tjYKMv4lWb8WZxOJ6anp4lU/xQsAJqmFV1/V0oRMAyDb9++Qa/Xw2g0oqGhIe+mQHZHo7y8/Ma0 MKlUCjs7O0gkErkcSjabTZTxX0Spxp/l9u3boGlasAgEC2B7e1vyfX+uiCmCZDKJzc1N6PV61NXV 4W9/+xvR9imKQlNTU+7fDMNgY2MD6XQaLpdLlHSBSjd+4PwtMDs7K68AAoGAoBKnUkJaBMFgELu7 u7BYLGhrayPSJhtsNlvuDbC9vY1IJILGxkZeWdGuQw3Gn6W2thaBQIB3akRA4CLY5/MpevpzFRIL 41AohNXVVSQSCbjdbrS0tBAaHXdaWlrgdruRSCSwurqKUCgkqD01GT9wPg0SGkPMWwDZPVm1IUQE Xq8XoVAI7e3tcDgchEfGH4fDgfb2doRCIUGfTU3Gn8Vmswk6e+ItgOXlZdy9e5d3x3LCVQQHBwdY W1uDx+MhmiKGNPX19fB4PFhbW8PBwQHr+9Rq/ABw9+5dQecCvAVAKqejXLAVwefPnyWf5wulra0N FosFnz9/Lnitmo0/ixBb5CWAr1+/FkXdrnwiiEajWFhYwL1791Q51bPZbLh37x4WFhZujIstBuMH zjNJfP36lde9vARwcHBw6SBHzVwVgU6ng9/vx+7uLnp6emQcGRl6enqwu7sLv99/KUa2WIwfOA9+ 5zLluwgvAbAtaKAWsiIwGAzY29tDLBaTLKBHClwuF2KxGPb29mAwGIrK+LPwtUlDOBzG2dnZtb4o ZrMZV/++sbGB5ubma7NuXXd9PrheLyYulwszMzNoamqC1WoVrTL5RbIVW6TAarUiFAphZmYG/f39 kny+QoTDYYRCISQSCcHXNzU1YWFh4ZJPWqH2w+EwtzcARVGIRCKyl9ghjU6nw87ODpqamkDTtKwx DWJBURRomkZTUxN2dnZYpQxREyUlJYhEIpy/O0NpaWleg776d5vNljfPT6H2hF4vBn6/H1arFVar FX/5y1+wubkp6RSB1CluPrxeL3p7e5FKpRAMBhGPx2U/yygtLUV5eTlKSkqIXG+z2S4VACx0fWlp Kbc3wMbGBu7cucPlFsUTjUYRCATgdDqRyWSQTCYV7UrNh+ycP5lMIpPJwOl0IhAIFMyapjbu3LmD jY0NTvdwEgDDMLLVmRWLlZWVaxe8xSKCmxa8LpcLKysrMoxIPMxmMxiG4XSP6LlBlcznz5/zbnWq XQSFdnt6enpYHZYVM6wFcHJyomg3AK4cHBzg1q1bBa9TqwjYbnXeunWL9x66Eqmvr8fJyQnr61kL YHt7W7bIJDE4OTlhfcKrNhFw2ee32WycDEbpNDY2Ynt7m/X1rAVAomCBUvB6vZx9e9QiAj6HXG1t bar4bGzhYqusBVAs+8ahUAjV1dW87lW6CISc8FZXVwuOJ1AKXGyVlQAikQgqKyt5D0hJ7OzsCFrL KFUEQt0b6uvrsbOzQ3BE8lFZWYlwOMzqWlYC2NvbuxSXqlaCwSDq6uoEt6M0EZDy7amrq1OEi4RQ mpqasLu7y+paVgJgGEaU4Gup2d3dJXb6qRQRkHRsczgcrA1HyRgMBjAMQ6ZCjF6vLwrvz2QySbRU EyC/CMTw6rRYLLKntySB2WwmVyWyGHaANjc3RQlgl0sEYrk0t7S0YHNzk3i7UpNKpcgIIJFIEP/l lAMxq9VILQKx/fnFruwjBSUlJaxCJQt+Ur/fL7vXoFAYhiGy+M2HVCKQIpilrq6Os0+N0nA4HPD7 /QWvKyiA4+Nj1W+Bfvv2TZK4XrFFIFUkl81mw7dv30TvR0wcDgerNOqs1gBqDxCR8pUulgikDmNU +zQoG7xViIKf8qakrWpCjOJq+SAtAjlieKV+ZmLAJtCmoAAuRtiokd3dXTQ0NEjeLykRyBXA3tDQ oPozATa2W1AAasyJc5FYLCbbFE6oCOTM3kBRFGKxmCx9k4KN7ap7oscCuU+w+YpACalL5H52QiEy BVI7bFNuiAlXESjB+AFlPDshsFnHFL0AlLKYYysCpRg/oJxnJyZFLwAluXEUEoGSjB9Q1rMTi6IW QDqdVpwj300iUJrxA+fpBuXO2Cc2RS2As7MzRSbxvZiLVMm5OisqKiRN3ygHeXODZk/TxMr1KXZu 0OyXl63GyPZ6KXC5XFhYWABwnp5EiblIxX4eJHOD8rm+YG5Qg8HA2ng0NNQI59yghVBablCdTsfZ nUOqXJ3ZpFxKzUWq0+mQyWREex6kc4NyvZ5zblC1UVZWhtPTU7mH8R0Xc3UqORfp6emp7ImLxaao BaDX6xVXy+ymBa8SRRCPx1XvFVqI4v50gKJcuQvt9ihNBEp6dmJR9AJQynE+261OJYlAKc9OTIpe AEo4zue6z68UESjh2QmBjYCLXgByp/jge8ilBBHI/eyEwqYASEEBqD042mw2y+bTIvSEV04RpFIp 1RdDYWO7BQXANseiUmlsbMTe3p7k/ZJyb5BLBHt7e6pPh8/GdgsKoBgyBku9mCPt2yOHCIphAUxk CpROp1XvFiulR6NYjm1Si0DtXqBsE7oVFEBVVZXqK4jU1tZKspYR26tTKhEwDIPa2lrR+xGTk5MT 2O32gtcVFADbDFtKxmaziV4HSyqXZilEcHBwoPpkCGwzGhYUgNFoZJVgSOmI+UqX2p9fbBGoffoD nM//2QRDsVoDFMORuMvl4lQ8jS1yBbOIJYLt7e1r6yarDYqiWAmZlQCU5lDGB4PBQPxNJncklxgi iEQiqk+HApzngyIiAOB8Dq32U0Hg/EyA1HpGbuPPQlIEfr9f9Xv/wPkJts1mYxXMxUoADQ0NRVFA zWq1ElkMK8X4s5ASwcHBgSTBQGKzs7PDWsisBGCxWFS/FZqlqakJ+/v7vO9XmvFnESqC/f39oiiE CJxvgbLNacvaGa5YYoPLy8txdHTE616lGn8WISI4OjoqikzgADdbZS2AYtgJyuLxeLC2tsbpHqUb fxY+IlhbW1PFZ2MLF1tlLYCWlhbVp8u+SGVlJevTYbUYfxYuImAYRvUVgC6yu7vLqRgiawFUVlYK mjsrjbq6Ovz5558Fr1Ob8WdhK4I///xT9PppUrK/v89J0EUfEJOPe/fu5ZJTXYdajT9LIREsLCzg 3r17Eo5IeXASgM1mU33RhKt0dHRcWxdX7caf5SYRbG5uoqOjQ4YRiUcsFuPsw8RJAK2trVhfX+fU gdIpKSmB3W4HTdPQ6XSKztXJl4u5SHU6HWiaht1uZ51gSi2sr6+jtbWV0z15c4Nezd1JURQYhkE4 HL42RkBpuUHZYjKZcHR0hFAoBJqm0dvbq8hcnUJwuVz48OEDnE5nLtubFJ8xHyRzfV5nm4Jzg14l lUrBYrGwirRRE5lMBk1NTdjZ2YHT6VR9ANB1pFIpOJ1O7OzsoKmpqWjOdbJEo1FYLBbO3x3n3KA9 PT349OkT7t+/z+r6QoidG5QtXq8X/f392NnZQTAYhNPplKxvKdwPaJpGJpNBf3+/5LlIb4Jkrs9P nz7lcq2ybZ93btBi8A69yMVcnQ0NDTCbzdcujNXK5uYmzGYzGhoaFJ2LVAh8bZKXAOrq6hSZdJYP Vxe8mUwGDocDjY2NebdI1cLCwgIaGxvhcDguTXuKSQSnp6e8zzJ4CaC5uRk+n49Xh0oi325PSUkJ enp68PnzZ1XmRmIYBp8/f0ZPT8+NU4BiEYHP50NzczOve3kfhCmt9hZX2G513rt3D5FIhLPvkJys ra0hEomwOuQqBhEIsUXeAujs7MSXL194dywnXPf56+rq0NbWBq/Xq2h3kP39fXi9XrS1tXGaEqhZ BF++fEFnZyfv+3kLwGAwqHJqIOSQy+PxoLy8HKurq4rKlOH3+7G6uory8nJBn02NImAYRlAIpyBf ILfbja2tLSFNSAqJE97y8nK0t7fDaDTC5/OJEmjPlu3tbfh8PhiNRrS3twv251ebCLa2tuB2uwW1 ISj62W63Y21tDbdv3xY0CCkg7d5gtVrhdruRTCaxtrYGvV6Puro60fPpMAyDg4MDpNNpuFwu4gHs WREo4ZygEN++fRNse4KfXktLC2ialvTgiCtifqEGgwFtbW0Azo3zf//7H/R6PYxGIxoaGgQHEqVS Kezt7SGRSCCdTqO2tpazvwtX1CACmqY5+f3fhGABOJ1OTE9PK1YAUn6RNpvt0htgd3cXsVgMBoMB iUQCRqMRqVQKJpPpUhFqnU6H09NTxONxUBSVuzaZTMJsNssSq6t0EWxtbWFgYEBwO0Ten7dv31bk W0DuL/CmzATpdPqSI1wmk4HT6VRcQTqlioCmaWLTbiJP3Ol0YmNjg0RTxFDiF5dFr9fDarWirKwM ZWVlsFqtijP+LEpbGJtMJmxsbBD7sSX21Ds7O/H161dSzQlCycavRpQkgpWVFUH7/lchJgC73Y7D w0PZ0+ppxi8OShBB9uyJTdpzthB973Z3d8vqS68Zv7jILYJoNIru7m6ibRIVgF6vx/r6uixxw5rx S4NcIojFYlhbW4NOpyPaLvGVV3t7O2ZnZ0k3mxfN+KVFDhHMzMygq6uLeLvEBZBIJODxeCQLKNGM Xx6kFEE2gk2Mwn3EBaDT6VBVVYXDw0PRA90145cXKUSQTqdxeHiI6upqUdoXbfO5r68Pk5OTYjWv Gb9CEFsEk5OT6OvrE619UU9furq6sLKyQrxdzfiVhVgiWFlZEWXefxFRBWC32xGLxYiWJtKMX5mQ FkEkEkEsFhO0589mx0j08/fu7m68e/eOSFua8SsbkiJ49+6d4D3/QCBQMOUKqyJ5Qnn69Kng9YBm /OqAhAgmJyfx9OlTwWMhUiOMhAAoioLH4+GdSUIzfnUhRAQ+nw8ej4dIQRYiVSKtViuROXxVVRUA 4Pj4mNN9mvGrEz4iyNpG1laEEIlEWGXcKyiAzs5OLC0tCR4QcB5DvLq6yvpAQzN+dcNFBIlEAqur q4JjfLMsLS2x8hotKAC73U40Fcjg4CCr9YBm/MUBWxFMTk5icHCQWL/7+/usdpBY7QINDw9jdHRU 8KAutvfq1asb/64Zf3GRTwRGoxGvXr3C8PAwsf5GR0dZt8dKAFarFU6nk+g+77NnzzAzM/NdJJRm /MXJdSKgKArj4+N49uwZsX68Xi+cTifrjNuszwG6urrg9/uJicBgMKCnp+dSbKxm/MXNVREcHR3h wYMHxIKovF4v/H4/p9NjTgdhjx8/RjKZJDYdMpvNSCaT+PjxY277S6O4yW6Hv3//HgaDgViO2dHR USSTSTx+/JjTfZyl19XVBZfLhZcvX6K+vh5dXV2wWCy5v3OtPFJRUZErb6PxY5BNZ8inPvHFKXMk EsHS0hL29/cxPDzMq9CI7s2bN5mhoSHONwLnR83Ly8sIBoPQ6/UwGAzw+/24desWKyGYTCb88ccf GB4exsnJCZLJJKqrq2ULqwyHwwDOK4do/ZGHoigcHR3ljH9ychIDAwOso7z29/dhNBqh1+uRTqdh tVrR2dnJ219ofn5eeGrEq6+c33//Hd3d3QVP4SiKgs/nQ3d3N+7fv490Oo14PI73799jaGhIlOCH QoRCIQAQnGNT6+97jEYjxsfHMTAwkJv2JJNJAMBPP/1U8EdPr9fjv//9L/75z38SHRfxFA56vZ7V vM7r9aKzsxN7e3u560tKSvD06VO8fv0aIyMjpIdWkKzopCofWuz9XeTVq1d49uzZpQWvTqfDTz/9 hLW1NVbrPzFyJxFvkY3/Rb7dHoPBgJGREYyNjcnyFtAgSyKRwNjYGEZGRq7d7UmlUqwPy8SIMCQu gEK+Q2y3OoeHhzE3N8fZd0hDORwfH2Nubo7VoVQhEbD17eEKcQHk8x3ius8/ODiIw8PDoqhH9qPh 8/lweHjIyb0hnwjY+vZwhbgAbvId4nvI5Xa7UV1djampKRLD05CAyclJ1NTU8HJsu0kEbH17uCJK RNhV3yGhJ7zV1dXo7+/H69eviYZXapAlEong9evXGBwcFOTSfFUEXHx7uCJKIs+s71A2IJ7ECS9F UXj+/DkWFxdhNpvR0dEhuE0NcqysrCAWi+H58+dE2vN4PDn74eLbwxXRYoK7urowNzdHvN3u7m44 nU6Mj4+LnndIozDpdBrj4+NwOp3E83YCwNzcnKiZIUQTgNfrxS+//IJ4PE7UlRo4X2cMDQ3h/fv3 kmWg0/iezc3N3MEl6fn56Ogo4vE4fvnlF1HzDokigItz/q6uLgwODuLly5eYmZn5bg7P1XfoIn19 faioqMDExIQsCXl/VGKxGCYmJlBRUSE4adVV356ZmRm8fPkSg4ODuV9+MZNvCfIFuo58C16hvkM3 YTQasbS0hLa2NpSUlOSO2LlS7L45QvszGAyIRqNYW1tDV1eX4INKrr49pN3l5+fnyQqAzwB///13 /P3vfycyn89kMlhcXITNZkNHRwfi8Tin+4vdN4dvfyaTCSsrK2AYBt3d3URSlPP17SEpAsHOcBfh OzC2vkNsefToEQKBAKamptDa2sqpllSx++bw6Y+maWxsbKCzs5N4vAYf3x7ShfuIrAGEDEiMnZyL XqrT09OgaZp4H8UOTdOYnp4GcB4IJcYhFN/vnuSaQLAAhKqRVN6h63A6nblasrOzs9ja2hKln2Ji a2srV+BkYGBAtNK3Qn17SIlAkABIvIpI5h26CafTib6+PtjtdszMzODLly+i9qdGvnz5gpmZGdjt dvT19Yle85mEbw8JEfBeA5Cah5HOO1Sor/7+fiSTSSwuLiIej8PtdqOiokKS/pXG6ekpfD4fTCYT Ojs7Ja3wub+/j/7+fsHtCF0T8PrEpLejsr5DL168INZmPgwGQ+7U8uvXr1hfX4fJZEJjYyPKysok GYMcGAwGnJ2dYWtrC/F4HHV1dXj48KHk4yDt2yNEBJwFIEbqkot5h6TODNHc3Izm5mYAwMLCAiKR CGw2G+7cuQOz2SzpWMQiFothfX0dDMPAYrGgp6dHtrFwzdvDFr4i4CQAMQ20q6sLb9++lTU3UGtr KyiKQmlpKTY2NnKZKurr69HY2CjLmPiyu7ubm1rabDZ0dnYiHA7LXsfZ7/dzTl3CFj4iYH0QJpVh Li0tgaZpyaZDFwkGgwDw3a/TyckJtre3kUqloNPpUFlZiaamJsFz5pv640oymcTOzg5OTk6QyWRA URRaWlq+SztCqj8+jI6Owul0il7yCGBvq6wPwqT8VS6Ud0gOKisrLxnlyVLcAAABS0lEQVRTOBzG //3f/4FhGJjNZqRSKZSUlMDhcKCyshJGo1GUcSQSCZycnMDv9yMajYKiKMRiMdhsNjQ2NuKvf/2r KP3yhUTeHj5weRMUfAPIOSW56juk0+lgt9sF+Q3lg6uvjE6ng16vh16vRzweh9/vRyAQQCQSQUlJ CUpLS2Gz2VBSUnKtKPL1l0gkEI1GwTAMwuEwotEoLBYL7HY7HA4HTCYT0uk00uk06+chtu+RTqdD IBBAJpMhkrdHKIVst+AbQO5cndflHYpGo6L1pxbfHCX3J0fKlZtg8ya4UQByG/9NiPmA1eCbo6b+ lEAhEVx7EqxU49fQ4EO+E+PvBKAZv0YxcpMILglAM36NYuY6EeQEoBm/xo/AVRHo9Xo9VlZWNOPX +GHIioCiKBjm5+fx/PlzzM/Pyz0u2VFbjK7S+1MyFEVhamoK/w+AyfN+zOygegAAAABJRU5ErkJg gg== "
-       id="image3116"
-       x="0"
-       y="-176" />
-  </g>
-  <g
-     style="display:inline"
-     inkscape:label="base"
-     id="layer2"
-     inkscape:groupmode="layer">
-    <g
-       id="g4704"
-       style="filter:url(#filter4710)">
-      <path
-         style="fill:#8097a2;fill-opacity:1;stroke:none;display:inline"
-         d="m 68,30.7 0,52 -60,0 0,24 60,0 0,52 107.9375,0 c 0.27869,0 0.57242,-0.0352 0.84375,-0.0625 4.06997,-0.41 7.21875,-3.79916 7.21875,-7.96875 l 0,-111.9375 C 184,34.283686 180.39647,30.7 175.9375,30.7 l -107.937501,0 z"
-         id="path3938-4"
-         inkscape:connector-curvature="0" />
-      <path
-         style="fill:#546e7a;fill-opacity:1;stroke:none;display:inline"
-         d="m 68,33.3 0,52 -60,0 0,24 60,0 0,52 107.9375,0 c 0.27869,0 0.57242,-0.0352 0.84375,-0.0625 4.06997,-0.41 7.21875,-3.79916 7.21875,-7.96875 l 0,-111.9375 C 184,36.883686 180.39647,33.3 175.9375,33.3 l -107.937501,0 z"
-         id="path3938-5"
-         inkscape:connector-curvature="0" />
-      <path
-         style="fill:#607d8b;fill-opacity:1;stroke:none"
-         d="m 68,32.000003 0,52 -60,0 L 8,108 l 60,0 0,52 107.9375,0 c 0.27869,0 0.57242,-0.0352 0.84375,-0.0625 4.06997,-0.41 7.21875,-3.79916 7.21875,-7.96875 l 0,-111.937497 c 0,-4.447564 -3.60353,-8.03125 -8.0625,-8.03125 l -107.937501,0 z"
-         id="path3938"
-         inkscape:connector-curvature="0" />
-      <path
-         sodipodi:nodetypes="cccc"
-         inkscape:connector-curvature="0"
-         d="m 107.07401,68.171344 0,55.657316 L 149.27466,96 z"
-         style="fill:#ffffff;stroke:none"
-         inkscape:label="Triangle"
-         id="path4262" />
-    </g>
-  </g>
-  <g
-     style="display:inline"
-     inkscape:label="Layer"
-     id="layer3"
-     inkscape:groupmode="layer"
-     sodipodi:insensitive="true">
-    <path
-       style="opacity:0.11522636;fill:url(#linearGradient4504);fill-opacity:1;stroke:none"
-       d="M 14.214274,89.623384 74.117285,35.304552 143.41187,104.59914 106.15739,181.5665 z"
-       id="path4488"
-       inkscape:connector-curvature="0" />
-    <path
-       style="opacity:0.11522636;fill:url(#linearGradient4521);fill-opacity:1;stroke:none;display:inline"
-       d="m 74,101.96875 -8.09375,7.34375 2.09375,0 0,49.375 0,1.3125 0,1.3125 65.3125,0 L 74,101.96875 z"
-       id="path4488-8"
-       inkscape:connector-curvature="0" />
-    <g
-       transform="translate(0,2.2931745)"
-       id="g4071"
-       style="filter:url(#filter4692)">
-      <path
-         style="fill:#08a0b5;fill-opacity:1;stroke:none;display:inline"
-         d="M 22.0625,154.3 C 17.60353,154.3 14,150.71631 14,146.26875 L 14,102.3 l 60,0 0,52 -51.9375,0 z"
-         id="rect3104-7-2-1"
-         inkscape:connector-curvature="0" />
-      <path
-         style="fill:#33c9dd;fill-opacity:1;stroke:none;display:inline"
-         d="M 22.0625,151.7 C 17.60353,151.7 14,148.11631 14,143.66875 L 14,99.7 l 60,0 0,52 -51.9375,0 z"
-         id="rect3104-7-2-8"
-         inkscape:connector-curvature="0" />
-      <path
-         style="fill:#00bcd4;fill-opacity:1;stroke:none"
-         d="M 22.0625,153 C 17.60353,153 14,149.41631 14,144.96875 L 14,101 l 60,0 0,52 -51.9375,0 z"
-         id="rect3104-7-2"
-         inkscape:connector-curvature="0" />
-    </g>
-    <g
-       transform="translate(-0.511613,5.6775255)"
-       id="g4111"
-       style="filter:url(#filter4680)">
-      <g
-         id="g4106">
-        <path
-           inkscape:connector-curvature="0"
-           id="rect3104-7-2-1-0"
-           d="m 22.574113,29.7293 c -4.45897,0 -8.0625,3.58369 -8.0625,8.03125 l 0,43.96875 60,0 0,-52 -51.9375,0 z"
-           style="fill:#35baf6;fill-opacity:1;stroke:none;display:inline" />
-        <path
-           inkscape:connector-curvature="0"
-           id="rect3104-7-2-8-8"
-           d="m 22.574113,32.3293 c -4.45897,0 -8.0625,3.58369 -8.0625,8.03125 l 0,43.96875 60,0 0,-52 -51.9375,0 z"
-           style="fill:#0a91ce;fill-opacity:1;stroke:none;display:inline" />
-        <path
-           inkscape:connector-curvature="0"
-           id="rect3104-7-2-2"
-           d="m 22.574113,31.0293 c -4.45897,0 -8.0625,3.58369 -8.0625,8.03125 l 0,43.96875 60,0 0,-52 -51.9375,0 z"
-           style="fill:#03a9f4;fill-opacity:1;stroke:none" />
-      </g>
-    </g>
-  </g>
-  <g
-     inkscape:groupmode="layer"
-     id="layer5"
-     inkscape:label="finish"
-     style="opacity:0.18656718;display:inline"
-     sodipodi:insensitive="true">
-    <path
-       inkscape:connector-curvature="0"
-       style="fill:url(#radialGradient4630);fill-opacity:1;stroke:none;display:inline"
-       d="m 67.999998,30.703125 0,1.28125 0,1.3125 0,2.09375 -45.937501,0 c -4.45897,0 -8.0625,3.58369 -8.0625,8.03125 l 0,1.3125 0,1.3125 0,36.65625 -5.9999995,0 0,1.28125 0,1.3125 0,21.406255 0,1.28125 0,1.3125 5.9999995,0 0,36.65624 0,1.3125 0,1.28125 c 0,4.44756 3.60353,8.03125 8.0625,8.03125 l 45.937501,0 0,2.125 0,1.28125 0,1.3125 107.937502,0 c 0.27869,0 0.57242,-0.0352 0.84375,-0.0625 4.06997,-0.41 7.21875,-3.79915 7.21875,-7.96875 l 0,-1.3125 0,-1.28125 0,-109.343745 0,-1.3125 0,-1.28125 c 0,-4.44757 -3.60353,-8.03125 -8.0625,-8.03125 l -107.937503,0 z"
-       id="path3938-4-0" />
-  </g>
-</svg>
diff --git a/demo/build.gradle b/demo/build.gradle
index 5a95cfff41..ff294ad0b5 100644
--- a/demo/build.gradle
+++ b/demo/build.gradle
@@ -14,12 +14,12 @@
 apply plugin: 'com.android.application'
 
 android {
-    compileSdkVersion 22
-    buildToolsVersion "22.0.1"
+    compileSdkVersion 23
+    buildToolsVersion "23.0.1"
 
     defaultConfig {
         minSdkVersion 16
-        targetSdkVersion 22
+        targetSdkVersion 23
     }
     buildTypes {
         release {
diff --git a/demo/src/main/AndroidManifest.xml b/demo/src/main/AndroidManifest.xml
index e4c615999a..8cda23deff 100644
--- a/demo/src/main/AndroidManifest.xml
+++ b/demo/src/main/AndroidManifest.xml
@@ -16,14 +16,14 @@
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer.demo"
-    android:versionCode="1502"
-    android:versionName="1.5.2"
+    android:versionCode="1503"
+    android:versionName="1.5.3"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
   <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
 
-  <uses-sdk android:minSdkVersion="16" android:targetSdkVersion="22"/>
+  <uses-sdk android:minSdkVersion="16" android:targetSdkVersion="23"/>
 
   <application
       android:label="@string/application_name"
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/EventLogger.java b/demo/src/main/java/com/google/android/exoplayer/demo/EventLogger.java
index 821bd3b679..f93a7f8884 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/EventLogger.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/EventLogger.java
@@ -159,6 +159,12 @@ public void onAudioTrackWriteError(AudioTrack.WriteException e) {
     printInternalError("audioTrackWriteError", e);
   }
 
+  @Override
+  public void onAudioTrackUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {
+    printInternalError("audioTrackUnderrun [" + bufferSize + ", " + bufferSizeMs + ", "
+        + elapsedSinceLastFeedMs + "]", null);
+  }
+
   @Override
   public void onCryptoError(CryptoException e) {
     printInternalError("cryptoError", e);
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java b/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
index dbcdd2cacc..d515873adb 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
@@ -16,7 +16,10 @@
 package com.google.android.exoplayer.demo;
 
 import com.google.android.exoplayer.AspectRatioFrameLayout;
+import com.google.android.exoplayer.ExoPlaybackException;
 import com.google.android.exoplayer.ExoPlayer;
+import com.google.android.exoplayer.MediaCodecTrackRenderer.DecoderInitializationException;
+import com.google.android.exoplayer.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.audio.AudioCapabilities;
 import com.google.android.exoplayer.audio.AudioCapabilitiesReceiver;
@@ -38,10 +41,12 @@
 import com.google.android.exoplayer.util.Util;
 import com.google.android.exoplayer.util.VerboseLogUtil;
 
+import android.Manifest.permission;
 import android.annotation.TargetApi;
 import android.app.Activity;
 import android.content.Context;
 import android.content.Intent;
+import android.content.pm.PackageManager;
 import android.net.Uri;
 import android.os.Bundle;
 import android.text.TextUtils;
@@ -81,6 +86,7 @@
   // For use within demo app code.
   public static final String CONTENT_ID_EXTRA = "content_id";
   public static final String CONTENT_TYPE_EXTRA = "content_type";
+  public static final String PROVIDER_EXTRA = "provider";
   public static final int TYPE_DASH = 0;
   public static final int TYPE_SS = 1;
   public static final int TYPE_HLS = 2;
@@ -126,6 +132,7 @@
   private Uri contentUri;
   private int contentType;
   private String contentId;
+  private String provider;
 
   private AudioCapabilitiesReceiver audioCapabilitiesReceiver;
 
@@ -170,7 +177,7 @@ public boolean onKey(View v, int keyCode, KeyEvent event) {
     playerStateTextView = (TextView) findViewById(R.id.player_state_view);
     subtitleLayout = (SubtitleLayout) findViewById(R.id.subtitles);
 
-    mediaController = new MediaController(this);
+    mediaController = new KeyCompatibleMediaController(this);
     mediaController.setAnchorView(root);
     retryButton = (Button) findViewById(R.id.retry_button);
     retryButton.setOnClickListener(this);
@@ -202,9 +209,12 @@ public void onResume() {
     contentType = intent.getIntExtra(CONTENT_TYPE_EXTRA,
         inferContentType(contentUri, intent.getStringExtra(CONTENT_EXT_EXTRA)));
     contentId = intent.getStringExtra(CONTENT_ID_EXTRA);
+    provider = intent.getStringExtra(PROVIDER_EXTRA);
     configureSubtitleView();
     if (player == null) {
-      preparePlayer(true);
+      if (!maybeRequestPermission()) {
+        preparePlayer(true);
+      }
     } else {
       player.setBackgrounded(false);
     }
@@ -251,6 +261,46 @@ public void onAudioCapabilitiesChanged(AudioCapabilities audioCapabilities) {
     player.setBackgrounded(backgrounded);
   }
 
+  // Permission request listener method
+
+  @Override
+  public void onRequestPermissionsResult(int requestCode, String[] permissions,
+      int[] grantResults) {
+    if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
+      preparePlayer(true);
+    } else {
+      Toast.makeText(getApplicationContext(), R.string.storage_permission_denied,
+          Toast.LENGTH_LONG).show();
+      finish();
+    }
+  }
+
+  // Permission management methods
+
+  /**
+   * Checks whether it is necessary to ask for permission to read storage. If necessary, it also
+   * requests permission.
+   *
+   * @return true if a permission request is made. False if it is not necessary.
+   */
+  @TargetApi(23)
+  private boolean maybeRequestPermission() {
+    if (requiresPermission(contentUri)) {
+      requestPermissions(new String[] {permission.READ_EXTERNAL_STORAGE}, 0);
+      return true;
+    } else {
+      return false;
+    }
+  }
+
+  @TargetApi(23)
+  private boolean requiresPermission(Uri uri) {
+    return Util.SDK_INT >= 23
+        && Util.isLocalFileUri(uri)
+        && checkSelfPermission(permission.READ_EXTERNAL_STORAGE)
+            != PackageManager.PERMISSION_GRANTED;
+  }
+
   // Internal methods
 
   private RendererBuilder getRendererBuilder() {
@@ -261,7 +311,7 @@ private RendererBuilder getRendererBuilder() {
             new SmoothStreamingTestMediaDrmCallback());
       case TYPE_DASH:
         return new DashRendererBuilder(this, userAgent, contentUri.toString(),
-            new WidevineTestMediaDrmCallback(contentId));
+            new WidevineTestMediaDrmCallback(contentId, provider));
       case TYPE_HLS:
         return new HlsRendererBuilder(this, userAgent, contentUri.toString());
       case TYPE_OTHER:
@@ -344,13 +394,35 @@ public void onStateChanged(boolean playWhenReady, int playbackState) {
 
   @Override
   public void onError(Exception e) {
+    String errorString = null;
     if (e instanceof UnsupportedDrmException) {
       // Special case DRM failures.
       UnsupportedDrmException unsupportedDrmException = (UnsupportedDrmException) e;
-      int stringId = Util.SDK_INT < 18 ? R.string.drm_error_not_supported
+      errorString = getString(Util.SDK_INT < 18 ? R.string.error_drm_not_supported
           : unsupportedDrmException.reason == UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME
-              ? R.string.drm_error_unsupported_scheme : R.string.drm_error_unknown;
-      Toast.makeText(getApplicationContext(), stringId, Toast.LENGTH_LONG).show();
+          ? R.string.error_drm_unsupported_scheme : R.string.error_drm_unknown);
+    } else if (e instanceof ExoPlaybackException
+        && e.getCause() instanceof DecoderInitializationException) {
+      // Special case for decoder initialization failures.
+      DecoderInitializationException decoderInitializationException =
+          (DecoderInitializationException) e.getCause();
+      if (decoderInitializationException.decoderName == null) {
+        if (decoderInitializationException.getCause() instanceof DecoderQueryException) {
+          errorString = getString(R.string.error_querying_decoders);
+        } else if (decoderInitializationException.secureDecoderRequired) {
+          errorString = getString(R.string.error_no_secure_decoder,
+              decoderInitializationException.mimeType);
+        } else {
+          errorString = getString(R.string.error_no_decoder,
+              decoderInitializationException.mimeType);
+        }
+      } else {
+        errorString = getString(R.string.error_instantiating_decoder,
+            decoderInitializationException.decoderName);
+      }
+    }
+    if (errorString != null) {
+      Toast.makeText(getApplicationContext(), errorString, Toast.LENGTH_LONG).show();
     }
     playerNeedsPrepare = true;
     updateButtonVisibilities();
@@ -451,7 +523,7 @@ public boolean onMenuItemClick(MenuItem item) {
       }
     });
     Menu menu = popup.getMenu();
-    // ID_OFFSET ensures we avoid clashing with Menu.NONE (which equals 0)
+    // ID_OFFSET ensures we avoid clashing with Menu.NONE (which equals 0).
     menu.add(MENU_GROUP_TRACKS, DemoPlayer.TRACK_DISABLED + ID_OFFSET, Menu.NONE, R.string.off);
     for (int i = 0; i < trackCount; i++) {
       menu.add(MENU_GROUP_TRACKS, i + ID_OFFSET, Menu.NONE,
@@ -505,8 +577,7 @@ private static String joinWithSeparator(String first, String second) {
   }
 
   private static String buildTrackIdString(MediaFormat format) {
-    return format.trackId == MediaFormat.NO_VALUE ? ""
-        : String.format(Locale.US, " (%d)", format.trackId);
+    return format.trackId == null ? "" : " (" + format.trackId + ")";
   }
 
   private boolean onTrackItemClick(MenuItem item, int type) {
@@ -635,4 +706,38 @@ private static int inferContentType(Uri uri, String fileExtension) {
     }
   }
 
+  private static final class KeyCompatibleMediaController extends MediaController {
+
+    private MediaController.MediaPlayerControl playerControl;
+
+    public KeyCompatibleMediaController(Context context) {
+      super(context);
+    }
+
+    @Override
+    public void setMediaPlayer(MediaController.MediaPlayerControl playerControl) {
+      super.setMediaPlayer(playerControl);
+      this.playerControl = playerControl;
+    }
+
+    @Override
+    public boolean dispatchKeyEvent(KeyEvent event) {
+      int keyCode = event.getKeyCode();
+      if (playerControl.canSeekForward() && keyCode == KeyEvent.KEYCODE_MEDIA_FAST_FORWARD) {
+        if (event.getAction() == KeyEvent.ACTION_DOWN) {
+          playerControl.seekTo(playerControl.getCurrentPosition() + 15000); // milliseconds
+          show();
+        }
+        return true;
+      } else if (playerControl.canSeekBackward() && keyCode == KeyEvent.KEYCODE_MEDIA_REWIND) {
+        if (event.getAction() == KeyEvent.ACTION_DOWN) {
+          playerControl.seekTo(playerControl.getCurrentPosition() - 5000); // milliseconds
+          show();
+        }
+        return true;
+      }
+      return super.dispatchKeyEvent(event);
+    }
+  }
+
 }
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/SampleChooserActivity.java b/demo/src/main/java/com/google/android/exoplayer/demo/SampleChooserActivity.java
index 3a9fdc5529..a403c83018 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/SampleChooserActivity.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/SampleChooserActivity.java
@@ -15,17 +15,13 @@
  */
 package com.google.android.exoplayer.demo;
 
-import com.google.android.exoplayer.MediaCodecUtil;
-import com.google.android.exoplayer.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer.demo.Samples.Sample;
-import com.google.android.exoplayer.util.MimeTypes;
 
 import android.app.Activity;
 import android.content.Context;
 import android.content.Intent;
 import android.net.Uri;
 import android.os.Bundle;
-import android.util.Log;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
@@ -40,8 +36,6 @@
  */
 public class SampleChooserActivity extends Activity {
 
-  private static final String TAG = "SampleChooserActivity";
-
   @Override
   public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
@@ -52,8 +46,20 @@ public void onCreate(Bundle savedInstanceState) {
 
     sampleAdapter.add(new Header("YouTube DASH"));
     sampleAdapter.addAll((Object[]) Samples.YOUTUBE_DASH_MP4);
-    sampleAdapter.add(new Header("Widevine GTS DASH"));
+    sampleAdapter.addAll((Object[]) Samples.YOUTUBE_DASH_WEBM);
+    sampleAdapter.add(new Header("Widevine DASH Policy Tests (GTS)"));
     sampleAdapter.addAll((Object[]) Samples.WIDEVINE_GTS);
+    sampleAdapter.add(new Header("Widevine HDCP Capabilities Tests"));
+    sampleAdapter.addAll((Object[]) Samples.WIDEVINE_HDCP);
+    sampleAdapter.add(new Header("Widevine DASH: MP4,H264"));
+    sampleAdapter.addAll((Object[]) Samples.WIDEVINE_H264_MP4_CLEAR);
+    sampleAdapter.addAll((Object[]) Samples.WIDEVINE_H264_MP4_SECURE);
+    sampleAdapter.add(new Header("Widevine DASH: WebM,VP9"));
+    sampleAdapter.addAll((Object[]) Samples.WIDEVINE_VP9_WEBM_CLEAR);
+    sampleAdapter.addAll((Object[]) Samples.WIDEVINE_VP9_WEBM_SECURE);
+    sampleAdapter.add(new Header("Widevine DASH: MP4,H265"));
+    sampleAdapter.addAll((Object[]) Samples.WIDEVINE_H265_MP4_CLEAR);
+    sampleAdapter.addAll((Object[]) Samples.WIDEVINE_H265_MP4_SECURE);
     sampleAdapter.add(new Header("SmoothStreaming"));
     sampleAdapter.addAll((Object[]) Samples.SMOOTHSTREAMING);
     sampleAdapter.add(new Header("HLS"));
@@ -61,16 +67,6 @@ public void onCreate(Bundle savedInstanceState) {
     sampleAdapter.add(new Header("Misc"));
     sampleAdapter.addAll((Object[]) Samples.MISC);
 
-    // Add WebM samples if the device has a VP9 decoder.
-    try {
-      if (MediaCodecUtil.getDecoderInfo(MimeTypes.VIDEO_VP9, false) != null) {
-        sampleAdapter.add(new Header("YouTube WebM DASH (Experimental)"));
-        sampleAdapter.addAll((Object[]) Samples.YOUTUBE_DASH_WEBM);
-      }
-    } catch (DecoderQueryException e) {
-      Log.e(TAG, "Failed to query vp9 decoder", e);
-    }
-
     sampleList.setAdapter(sampleAdapter);
     sampleList.setOnItemClickListener(new OnItemClickListener() {
       @Override
@@ -87,7 +83,8 @@ private void onSampleSelected(Sample sample) {
     Intent mpdIntent = new Intent(this, PlayerActivity.class)
         .setData(Uri.parse(sample.uri))
         .putExtra(PlayerActivity.CONTENT_ID_EXTRA, sample.contentId)
-        .putExtra(PlayerActivity.CONTENT_TYPE_EXTRA, sample.type);
+        .putExtra(PlayerActivity.CONTENT_TYPE_EXTRA, sample.type)
+        .putExtra(PlayerActivity.PROVIDER_EXTRA, sample.provider);
     startActivity(mpdIntent);
   }
 
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java b/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
index ef54b3ebc0..a78a77ffa1 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
@@ -26,16 +26,18 @@
 
     public final String name;
     public final String contentId;
+    public final String provider;
     public final String uri;
     public final int type;
 
     public Sample(String name, String uri, int type) {
-      this(name, name.toLowerCase(Locale.US).replaceAll("\\s", ""), uri, type);
+      this(name, name.toLowerCase(Locale.US).replaceAll("\\s", ""), "", uri, type);
     }
 
-    public Sample(String name, String contentId, String uri, int type) {
+    public Sample(String name, String contentId, String provider, String uri, int type) {
       this.name = name;
       this.contentId = contentId;
+      this.provider = provider;
       this.uri = uri;
       this.type = type;
     }
@@ -43,12 +45,12 @@ public Sample(String name, String contentId, String uri, int type) {
   }
 
   public static final Sample[] YOUTUBE_DASH_MP4 = new Sample[] {
-    new Sample("Google Glass",
+    new Sample("Google Glass (MP4,H264)",
         "http://www.youtube.com/api/manifest/dash/id/bf5bb2419360daf1/source/youtube?"
         + "as=fmp4_audio_clear,fmp4_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&"
         + "ipbits=0&expire=19000000000&signature=51AF5F39AB0CEC3E5497CD9C900EBFEAECCCB5C7."
         + "8506521BFC350652163895D4C26DEE124209AA9E&key=ik0", PlayerActivity.TYPE_DASH),
-    new Sample("Google Play",
+    new Sample("Google Play (MP4,H264)",
         "http://www.youtube.com/api/manifest/dash/id/3aa39fa2cc27967f/source/youtube?"
         + "as=fmp4_audio_clear,fmp4_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&"
         + "ipbits=0&expire=19000000000&signature=A2716F75795F5D2AF0E88962FFCD10DB79384F29."
@@ -56,12 +58,12 @@ public Sample(String name, String contentId, String uri, int type) {
   };
 
   public static final Sample[] YOUTUBE_DASH_WEBM = new Sample[] {
-    new Sample("Google Glass",
+    new Sample("Google Glass (WebM,VP9)",
         "http://www.youtube.com/api/manifest/dash/id/bf5bb2419360daf1/source/youtube?"
         + "as=fmp4_audio_clear,webm2_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&"
         + "ipbits=0&expire=19000000000&signature=249B04F79E984D7F86B4D8DB48AE6FAF41C17AB3."
         + "7B9F0EC0505E1566E59B8E488E9419F253DDF413&key=ik0", PlayerActivity.TYPE_DASH),
-    new Sample("Google Play",
+    new Sample("Google Play (WebM,VP9)",
         "http://www.youtube.com/api/manifest/dash/id/3aa39fa2cc27967f/source/youtube?"
         + "as=fmp4_audio_clear,webm2_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&"
         + "ipbits=0&expire=19000000000&signature=B1C2A74783AC1CC4865EB312D7DD2D48230CC9FD."
@@ -77,37 +79,132 @@ public Sample(String name, String contentId, String uri, int type) {
         PlayerActivity.TYPE_SS),
   };
 
+  private static final String WIDEVINE_GTS_MPD =
+      "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears.mpd";
   public static final Sample[] WIDEVINE_GTS = new Sample[] {
-    new Sample("WV: HDCP not specified", "d286538032258a1c",
-        "http://www.youtube.com/api/manifest/dash/id/d286538032258a1c/source/youtube?"
-        + "as=fmp4_audio_cenc,fmp4_sd_hd_cenc&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0"
-        + "&ipbits=0&expire=19000000000&signature=477CF7D478BE26C205045D507E9358F85F84C065."
-        + "8971631EB657BC33EC2F48A2FF4211956760C3E9&key=ik0", PlayerActivity.TYPE_DASH),
-    new Sample("WV: HDCP not required", "48fcc369939ac96c",
-        "http://www.youtube.com/api/manifest/dash/id/48fcc369939ac96c/source/youtube?"
-        + "as=fmp4_audio_cenc,fmp4_sd_hd_cenc&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0"
-        + "&ipbits=0&expire=19000000000&signature=171DAE48D00B5BE7434BC1A9F84DAE0463C7EA7A."
-        + "0925B4DBB5605BEE9F5D088C48F25F5108E96191&key=ik0", PlayerActivity.TYPE_DASH),
-    new Sample("WV: HDCP required", "e06c39f1151da3df",
-        "http://www.youtube.com/api/manifest/dash/id/e06c39f1151da3df/source/youtube?"
-        + "as=fmp4_audio_cenc,fmp4_sd_hd_cenc&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0"
-        + "&ipbits=0&expire=19000000000&signature=8D3B8AF4E3F72B7F127C8D0D39B7AFCF37B30519."
-        + "A118BADEBF3582AD2CC257B0EE6E579C6955D8AA&key=ik0", PlayerActivity.TYPE_DASH),
-    new Sample("WV: Secure video path required", "0894c7c8719b28a0",
-        "http://www.youtube.com/api/manifest/dash/id/0894c7c8719b28a0/source/youtube?"
-        + "as=fmp4_audio_cenc,fmp4_sd_hd_cenc&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0"
-        + "&ipbits=0&expire=19000000000&signature=A41D835C7387885A4A820628F57E481E00095931."
-        + "9D50DBEEB5E37344647EE11BDA129A7FCDE8B7B9&key=ik0", PlayerActivity.TYPE_DASH),
-    new Sample("WV: HDCP + secure video path required", "efd045b1eb61888a",
-        "http://www.youtube.com/api/manifest/dash/id/efd045b1eb61888a/source/youtube?"
-        + "as=fmp4_audio_cenc,fmp4_sd_hd_cenc&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0"
-        + "&ipbits=0&expire=19000000000&signature=A97C9032C9D0C74F1643DB17C178873887C229E4."
-        + "0A657BF6F23C8BC1538F276137383478330B76DE&key=ik0", PlayerActivity.TYPE_DASH),
-    new Sample("WV: 30s license duration (fails at ~30s)", "f9a34cab7b05881a",
-        "http://www.youtube.com/api/manifest/dash/id/f9a34cab7b05881a/source/youtube?"
-        + "as=fmp4_audio_cenc,fmp4_sd_hd_cenc&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0"
-        + "&ipbits=0&expire=19000000000&signature=80648A12A7D5FC1FA02B52B4250E4EB74CF0C5FD."
-        + "66A261130CA137AA5C541EA9CED2DBF240829EE6&key=ik0", PlayerActivity.TYPE_DASH),
+    new Sample("WV: HDCP not specified", "d286538032258a1c", "widevine_test",
+        WIDEVINE_GTS_MPD, PlayerActivity.TYPE_DASH),
+    new Sample("WV: HDCP not required", "48fcc369939ac96c", "widevine_test",
+        WIDEVINE_GTS_MPD, PlayerActivity.TYPE_DASH),
+    new Sample("WV: HDCP required", "e06c39f1151da3df", "widevine_test",
+        WIDEVINE_GTS_MPD, PlayerActivity.TYPE_DASH),
+    new Sample("WV: Secure video path required (MP4,H264)", "0894c7c8719b28a0", "widevine_test",
+        WIDEVINE_GTS_MPD, PlayerActivity.TYPE_DASH),
+    new Sample("WV: Secure video path required (WebM,VP9)", "0894c7c8719b28a0", "widevine_test",
+        "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears.mpd",
+        PlayerActivity.TYPE_DASH),
+    new Sample("WV: Secure video path required (MP4,H265)", "0894c7c8719b28a0", "widevine_test",
+        "https://storage.googleapis.com/wvmedia/cenc/hevc/tears/tears.mpd",
+        PlayerActivity.TYPE_DASH),
+    new Sample("WV: HDCP + secure video path required", "efd045b1eb61888a", "widevine_test",
+        WIDEVINE_GTS_MPD, PlayerActivity.TYPE_DASH),
+    new Sample("WV: 30s license duration (fails at ~30s)", "f9a34cab7b05881a", "widevine_test",
+        WIDEVINE_GTS_MPD, PlayerActivity.TYPE_DASH),
+  };
+
+  public static final Sample[] WIDEVINE_HDCP = new Sample[] {
+    new Sample("WV: HDCP: None (not required)", "HDCP_None", "widevine_test",
+        WIDEVINE_GTS_MPD, PlayerActivity.TYPE_DASH),
+    new Sample("WV: HDCP: 1.0 required", "HDCP_V1", "widevine_test",
+        WIDEVINE_GTS_MPD, PlayerActivity.TYPE_DASH),
+    new Sample("WV: HDCP: 2.0 required", "HDCP_V2", "widevine_test",
+        WIDEVINE_GTS_MPD, PlayerActivity.TYPE_DASH),
+    new Sample("WV: HDCP: 2.1 required", "HDCP_V2_1", "widevine_test",
+        WIDEVINE_GTS_MPD, PlayerActivity.TYPE_DASH),
+    new Sample("WV: HDCP: 2.2 required", "HDCP_V2_2", "widevine_test",
+        WIDEVINE_GTS_MPD, PlayerActivity.TYPE_DASH),
+    new Sample("WV: HDCP: No digital output", "HDCP_NO_DIGTAL_OUTPUT", "widevine_test",
+        WIDEVINE_GTS_MPD, PlayerActivity.TYPE_DASH),
+  };
+
+  public static final Sample[] WIDEVINE_H264_MP4_CLEAR = new Sample[] {
+    new Sample("WV: Clear SD & HD (MP4,H264)",
+        "https://storage.googleapis.com/wvmedia/clear/h264/tears/tears.mpd",
+        PlayerActivity.TYPE_DASH),
+    new Sample("WV: Clear SD (MP4,H264)",
+        "https://storage.googleapis.com/wvmedia/clear/h264/tears/tears_sd.mpd",
+        PlayerActivity.TYPE_DASH),
+    new Sample("WV: Clear HD (MP4,H264)",
+        "https://storage.googleapis.com/wvmedia/clear/h264/tears/tears_hd.mpd",
+        PlayerActivity.TYPE_DASH),
+    new Sample("WV: Clear UHD (MP4,H264)",
+        "https://storage.googleapis.com/wvmedia/clear/h264/tears/tears_uhd.mpd",
+        PlayerActivity.TYPE_DASH),
+  };
+
+  public static final Sample[] WIDEVINE_H264_MP4_SECURE = new Sample[] {
+    new Sample("WV: Secure SD & HD (MP4,H264)", "", "widevine_test",
+        "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears.mpd",
+        PlayerActivity.TYPE_DASH),
+    new Sample("WV: Secure SD (MP4,H264)", "", "widevine_test",
+        "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears_sd.mpd",
+        PlayerActivity.TYPE_DASH),
+    new Sample("WV: Secure HD (MP4,H264)", "", "widevine_test",
+        "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears_hd.mpd",
+        PlayerActivity.TYPE_DASH),
+    new Sample("WV: Secure UHD (MP4,H264)", "", "widevine_test",
+        "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears_uhd.mpd",
+        PlayerActivity.TYPE_DASH),
+  };
+
+  public static final Sample[] WIDEVINE_VP9_WEBM_CLEAR = new Sample[] {
+    new Sample("WV: Clear SD & HD (WebM,VP9)",
+        "https://storage.googleapis.com/wvmedia/clear/vp9/tears/tears.mpd",
+        PlayerActivity.TYPE_DASH),
+    new Sample("WV: Clear SD (WebM,VP9)",
+        "https://storage.googleapis.com/wvmedia/clear/vp9/tears/tears_sd.mpd",
+        PlayerActivity.TYPE_DASH),
+    new Sample("WV: Clear HD (WebM,VP9)",
+        "https://storage.googleapis.com/wvmedia/clear/vp9/tears/tears_hd.mpd",
+        PlayerActivity.TYPE_DASH),
+    new Sample("WV: Clear UHD (WebM,VP9)",
+        "https://storage.googleapis.com/wvmedia/clear/vp9/tears/tears_uhd.mpd",
+        PlayerActivity.TYPE_DASH),
+  };
+
+  public static final Sample[] WIDEVINE_VP9_WEBM_SECURE = new Sample[] {
+    new Sample("WV: Secure SD & HD (WebM,VP9)", "", "widevine_test",
+        "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears.mpd",
+        PlayerActivity.TYPE_DASH),
+    new Sample("WV: Secure SD (WebM,VP9)", "", "widevine_test",
+        "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears_sd.mpd",
+        PlayerActivity.TYPE_DASH),
+    new Sample("WV: Secure HD (WebM,VP9)", "", "widevine_test",
+        "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears_hd.mpd",
+        PlayerActivity.TYPE_DASH),
+    new Sample("WV: Secure UHD (WebM,VP9)", "", "widevine_test",
+        "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears_uhd.mpd",
+        PlayerActivity.TYPE_DASH),
+  };
+
+  public static final Sample[] WIDEVINE_H265_MP4_CLEAR = new Sample[] {
+    new Sample("WV: Clear SD & HD (MP4,H265)",
+        "https://storage.googleapis.com/wvmedia/clear/hevc/tears/tears.mpd",
+        PlayerActivity.TYPE_DASH),
+    new Sample("WV: Clear SD (MP4,H265)",
+        "https://storage.googleapis.com/wvmedia/clear/hevc/tears/tears_sd.mpd",
+        PlayerActivity.TYPE_DASH),
+    new Sample("WV: Clear HD (MP4,H265)",
+        "https://storage.googleapis.com/wvmedia/clear/hevc/tears/tears_hd.mpd",
+        PlayerActivity.TYPE_DASH),
+    new Sample("WV: Clear UHD (MP4,H265)",
+        "https://storage.googleapis.com/wvmedia/clear/hevc/tears/tears_uhd.mpd",
+        PlayerActivity.TYPE_DASH),
+  };
+
+  public static final Sample[] WIDEVINE_H265_MP4_SECURE = new Sample[] {
+    new Sample("WV: Secure SD & HD (MP4,H265)", "", "widevine_test",
+        "https://storage.googleapis.com/wvmedia/cenc/hevc/tears/tears.mpd",
+        PlayerActivity.TYPE_DASH),
+    new Sample("WV: Secure SD (MP4,H265)", "", "widevine_test",
+        "https://storage.googleapis.com/wvmedia/cenc/hevc/tears/tears_sd.mpd",
+        PlayerActivity.TYPE_DASH),
+    new Sample("WV: Secure HD (MP4,H265)", "", "widevine_test",
+        "https://storage.googleapis.com/wvmedia/cenc/hevc/tears/tears_hd.mpd",
+        PlayerActivity.TYPE_DASH),
+    new Sample("WV: Secure UHD (MP4,H265)", "", "widevine_test",
+        "https://storage.googleapis.com/wvmedia/cenc/hevc/tears/tears_uhd.mpd",
+        PlayerActivity.TYPE_DASH),
   };
 
   public static final Sample[] HLS = new Sample[] {
@@ -145,6 +242,8 @@ public Sample(String name, String contentId, String uri, int type) {
         "http://storage.googleapis.com/exoplayer-test-media-0/play.mp3", PlayerActivity.TYPE_OTHER),
     new Sample("Google Glass (WebM Video with Vorbis Audio)",
         "http://demos.webmproject.org/exoplayer/glass_vp9_vorbis.webm", PlayerActivity.TYPE_OTHER),
+    new Sample("Big Buck Bunny (FLV Video)",
+        "http://vod.leasewebcdn.com/bbb.flv?ri=1024&rs=150&start=0", PlayerActivity.TYPE_OTHER),
   };
 
   private Samples() {}
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/WidevineTestMediaDrmCallback.java b/demo/src/main/java/com/google/android/exoplayer/demo/WidevineTestMediaDrmCallback.java
index bffd5fcb1f..4d9fcf22b8 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/WidevineTestMediaDrmCallback.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/WidevineTestMediaDrmCallback.java
@@ -33,12 +33,13 @@
 public class WidevineTestMediaDrmCallback implements MediaDrmCallback {
 
   private static final String WIDEVINE_GTS_DEFAULT_BASE_URI =
-      "http://wv-staging-proxy.appspot.com/proxy?provider=YouTube&video_id=";
+      "https://proxy.uat.widevine.com/proxy";
 
   private final String defaultUri;
 
-  public WidevineTestMediaDrmCallback(String videoId) {
-    defaultUri = WIDEVINE_GTS_DEFAULT_BASE_URI + videoId;
+  public WidevineTestMediaDrmCallback(String contentId, String provider) {
+    String params = "?video_id=" + contentId + "&provider=" + provider;
+    defaultUri = WIDEVINE_GTS_DEFAULT_BASE_URI + params;
   }
 
   @Override
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
index 982ef6c790..6f1e8b0e83 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
@@ -105,6 +105,7 @@ void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
     void onRendererInitializationError(Exception e);
     void onAudioTrackInitializationError(AudioTrack.InitializationException e);
     void onAudioTrackWriteError(AudioTrack.WriteException e);
+    void onAudioTrackUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs);
     void onDecoderInitializationError(DecoderInitializationException e);
     void onCryptoError(CryptoException e);
     void onLoadError(int sourceId, IOException e);
@@ -481,6 +482,13 @@ public void onAudioTrackWriteError(AudioTrack.WriteException e) {
     }
   }
 
+  @Override
+  public void onAudioTrackUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {
+    if (internalErrorListener != null) {
+      internalErrorListener.onAudioTrackUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
+    }
+  }
+
   @Override
   public void onCryptoError(CryptoException e) {
     if (internalErrorListener != null) {
diff --git a/demo/src/main/project.properties b/demo/src/main/project.properties
index 4fdc858b92..a656b29329 100644
--- a/demo/src/main/project.properties
+++ b/demo/src/main/project.properties
@@ -8,6 +8,6 @@
 # project structure.
 
 # Project target.
-target=android-22
+target=android-23
 android.library=false
 android.library.reference.1=../../../library/src/main
diff --git a/demo/src/main/res/values/strings.xml b/demo/src/main/res/values/strings.xml
index 1c2e68494f..70d9f20bdb 100644
--- a/demo/src/main/res/values/strings.xml
+++ b/demo/src/main/res/values/strings.xml
@@ -37,10 +37,20 @@
 
   <string name="off">[off]</string>
 
-  <string name="drm_error_not_supported">Protected content not supported on API levels below 18</string>
+  <string name="error_drm_not_supported">Protected content not supported on API levels below 18</string>
 
-  <string name="drm_error_unsupported_scheme">This device does not support the required DRM scheme</string>
+  <string name="error_drm_unsupported_scheme">This device does not support the required DRM scheme</string>
 
-  <string name="drm_error_unknown">An unknown DRM error occurred</string>
+  <string name="error_drm_unknown">An unknown DRM error occurred</string>
+
+  <string name="error_no_decoder">This device does not provide a decoder for <xliff:g id="mime_type">%1$s</xliff:g></string>
+
+  <string name="error_no_secure_decoder">This device does not provide a secure decoder for <xliff:g id="mime_type">%1$s</xliff:g></string>
+
+  <string name="error_querying_decoders">Unable to query device decoders</string>
+
+  <string name="error_instantiating_decoder">Unable to instantiate decoder <xliff:g id="decoder_name">%1$s</xliff:g></string>
+
+  <string name="storage_permission_denied">Permission to access storage was denied</string>
 
 </resources>
diff --git a/demo_misc/vp9_opus_sw/build.gradle b/demo_misc/vp9_opus_sw/build.gradle
index 60f706e33e..5b6eac3ab3 100644
--- a/demo_misc/vp9_opus_sw/build.gradle
+++ b/demo_misc/vp9_opus_sw/build.gradle
@@ -14,12 +14,12 @@
 apply plugin: 'com.android.application'
 
 android {
-    compileSdkVersion 22
-    buildToolsVersion "22.0.1"
+    compileSdkVersion 23
+    buildToolsVersion "23.0.1"
 
     defaultConfig {
         minSdkVersion 16
-        targetSdkVersion 22
+        targetSdkVersion 23
     }
     buildTypes {
         release {
diff --git a/demo_misc/vp9_opus_sw/src/main/AndroidManifest.xml b/demo_misc/vp9_opus_sw/src/main/AndroidManifest.xml
index 02ac98fb54..9824d7c1c5 100644
--- a/demo_misc/vp9_opus_sw/src/main/AndroidManifest.xml
+++ b/demo_misc/vp9_opus_sw/src/main/AndroidManifest.xml
@@ -17,8 +17,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer.demo.vp9opus"
-    android:versionCode="1502"
-    android:versionName="1.5.2"
+    android:versionCode="1503"
+    android:versionName="1.5.3"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
@@ -26,7 +26,7 @@
 
   <uses-feature android:glEsVersion="0x00020000"></uses-feature>
 
-  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="22"/>
+  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="23"/>
 
   <application
       tools:ignore="UnusedAttribute"
diff --git a/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/DashRendererBuilder.java b/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/DashRendererBuilder.java
index 9bef54606e..fc32d837a6 100644
--- a/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/DashRendererBuilder.java
+++ b/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/DashRendererBuilder.java
@@ -24,6 +24,7 @@
 import com.google.android.exoplayer.chunk.ChunkSource;
 import com.google.android.exoplayer.chunk.FormatEvaluator.AdaptiveEvaluator;
 import com.google.android.exoplayer.dash.DashChunkSource;
+import com.google.android.exoplayer.dash.DefaultDashTrackSelector;
 import com.google.android.exoplayer.dash.mpd.AdaptationSet;
 import com.google.android.exoplayer.dash.mpd.MediaPresentationDescription;
 import com.google.android.exoplayer.dash.mpd.MediaPresentationDescriptionParser;
@@ -108,7 +109,8 @@ public void onSingleManifest(MediaPresentationDescription manifest) {
     LibvpxVideoTrackRenderer videoRenderer = null;
     if (!videoRepresentationsList.isEmpty()) {
       DataSource videoDataSource = new DefaultUriDataSource(player, bandwidthMeter, userAgent);
-      ChunkSource videoChunkSource = new DashChunkSource(videoDataSource,
+      ChunkSource videoChunkSource = new DashChunkSource(
+          DefaultDashTrackSelector.newVideoInstance(null, false, false), videoDataSource,
           new AdaptiveEvaluator(bandwidthMeter), manifest.getPeriodDuration(0),
           AdaptationSet.TYPE_VIDEO, videoRepresentations);
       ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,
@@ -123,8 +125,9 @@ public void onSingleManifest(MediaPresentationDescription manifest) {
       audioRenderer = null;
     } else {
       DataSource audioDataSource = new DefaultUriDataSource(player, bandwidthMeter, userAgent);
-      DashChunkSource audioChunkSource = new DashChunkSource(audioDataSource, null,
-            manifest.getPeriodDuration(0), AdaptationSet.TYPE_AUDIO, audioRepresentation);
+      DashChunkSource audioChunkSource = new DashChunkSource(
+          DefaultDashTrackSelector.newAudioInstance(), audioDataSource, null,
+          manifest.getPeriodDuration(0), AdaptationSet.TYPE_AUDIO, audioRepresentation);
       SampleSource audioSampleSource = new ChunkSampleSource(audioChunkSource, loadControl,
           AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE);
       if (audioRepresentationIsOpus) {
diff --git a/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/VideoPlayer.java b/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/VideoPlayer.java
index b5adada15d..4733fc0f90 100644
--- a/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/VideoPlayer.java
+++ b/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/VideoPlayer.java
@@ -73,7 +73,8 @@
   private SurfaceView surfaceView;
   private VpxVideoSurfaceView vpxVideoSurfaceView;
   private TextView debugInfoView;
-  private TextView playerStateView;
+  private String debugInfo;
+  private String playerState;
 
   @Override
   public void onCreate(Bundle savedInstanceState) {
@@ -106,7 +107,10 @@ public boolean onTouch(View view, MotionEvent motionEvent) {
     surfaceView = (SurfaceView) findViewById(R.id.surface_view);
     vpxVideoSurfaceView = (VpxVideoSurfaceView) findViewById(R.id.vpx_surface_view);
     debugInfoView = (TextView) findViewById(R.id.debug_info);
-    playerStateView = (TextView) findViewById(R.id.player_state);
+    debugInfo = "";
+    playerState = "";
+    filename = "";
+    updateDebugInfoTextView();
 
     // Set the buttons' onclick listeners.
     ((Button) findViewById(R.id.choose_file)).setOnClickListener(this);
@@ -115,7 +119,6 @@ public boolean onTouch(View view, MotionEvent motionEvent) {
     // In case of DASH, start playback right away.
     if (isDash) {
       findViewById(R.id.buttons).setVisibility(View.GONE);
-      ((TextView) findViewById(R.id.filename)).setVisibility(View.GONE);
       startDashPlayback();
     }
   }
@@ -146,8 +149,7 @@ protected void onActivityResult(int requestCode, int resultCode, Intent data) {
       case FILE_PICKER_REQUEST:
         if (resultCode == Activity.RESULT_OK) {
           filename = data.getStringExtra(FilePickerActivity.FILENAME_EXTRA_ID);
-          ((TextView) findViewById(R.id.filename)).setText(
-              getString(R.string.current_path, filename));
+          updateDebugInfoTextView();
         }
         break;
     }
@@ -186,7 +188,8 @@ private void startBasicPlayback() {
   }
 
   private void startDashPlayback() {
-    playerStateView.setText("Initializing");
+    playerState = "Initializing";
+    updateDebugInfoTextView();
     final String userAgent = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like"
         + " Gecko) Chrome/38.0.2125.104 Safari/537.36";
     DashRendererBuilder rendererBuilder = new DashRendererBuilder(manifestUrl, userAgent, this);
@@ -213,7 +216,8 @@ public void onDroppedFrames(int count, long elapsed) {
   @Override
   public void onVideoSizeChanged(int width, int height) {
     videoFrame.setAspectRatio(height == 0 ? 1 : (width * 1.0f) / height);
-    debugInfoView.setText("Video: " + width + " x " + height);
+    debugInfo = "Video: " + width + " x " + height;
+    updateDebugInfoTextView();
   }
 
   @Override
@@ -223,12 +227,12 @@ public void onDrawnToSurface(Surface surface) {
 
   @Override
   public void onDecoderError(VpxDecoderException e) {
-    debugInfoView.setText("Libvpx decode failure. Giving up.");
+    debugInfo = "Libvpx decode failure. Giving up.";
+    updateDebugInfoTextView();
   }
 
   @Override
   public void onPlayerStateChanged(boolean playWhenReady, int state) {
-    String playerState = "";
     switch (player.getPlaybackState()) {
       case ExoPlayer.STATE_BUFFERING:
         playerState = "buffering";
@@ -246,12 +250,13 @@ public void onPlayerStateChanged(boolean playWhenReady, int state) {
         playerState = "ready";
         break;
     }
-    playerStateView.setText("Player State: " + playerState);
+    updateDebugInfoTextView();
   }
 
   @Override
   public void onPlayerError(ExoPlaybackException exception) {
-    debugInfoView.setText("Exoplayer Playback error. Giving up.");
+    debugInfo = "Exoplayer Playback error. Giving up.";
+    updateDebugInfoTextView();
     // TODO: show a retry button here.
   }
 
@@ -282,4 +287,20 @@ private void toggleControlsVisibility()  {
     }
   }
 
+  private void updateDebugInfoTextView() {
+    StringBuilder debugInfoText = new StringBuilder();
+    debugInfoText.append(
+        getString(R.string.libvpx_version, LibvpxVideoTrackRenderer.getLibvpxVersion()));
+    debugInfoText.append(" ");
+    debugInfoText.append(
+        getString(R.string.libopus_version, LibopusAudioTrackRenderer.getLibopusVersion()));
+    debugInfoText.append("\n");
+    debugInfoText.append(getString(R.string.current_path, filename));
+    debugInfoText.append(" ");
+    debugInfoText.append(debugInfo);
+    debugInfoText.append(" ");
+    debugInfoText.append(playerState);
+    debugInfoView.setText(debugInfoText.toString());
+  }
+
 }
diff --git a/demo_misc/vp9_opus_sw/src/main/project.properties b/demo_misc/vp9_opus_sw/src/main/project.properties
index ca0c2d0867..f85c9b372d 100644
--- a/demo_misc/vp9_opus_sw/src/main/project.properties
+++ b/demo_misc/vp9_opus_sw/src/main/project.properties
@@ -11,7 +11,7 @@
 #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
 
 # Project target.
-target=android-22
+target=android-23
 android.library.reference.1=../../../../library/src/main
 android.library.reference.2=../../../../extensions/opus/src/main
 android.library.reference.3=../../../../extensions/vp9/src/main
diff --git a/demo_misc/vp9_opus_sw/src/main/res/layout/activity_video_player.xml b/demo_misc/vp9_opus_sw/src/main/res/layout/activity_video_player.xml
index f6f841b014..c6b2aea44d 100644
--- a/demo_misc/vp9_opus_sw/src/main/res/layout/activity_video_player.xml
+++ b/demo_misc/vp9_opus_sw/src/main/res/layout/activity_video_player.xml
@@ -64,28 +64,10 @@
 
     </LinearLayout>
 
-    <LinearLayout
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content">
-
-      <TextView
-          android:id="@+id/filename"
-          android:layout_width="wrap_content"
-          android:layout_height="wrap_content"
-          android:paddingRight="10dp"/>
-
-      <TextView
-          android:id="@+id/player_state"
-          android:paddingRight="10dp"
-          android:layout_width="wrap_content"
-          android:layout_height="wrap_content"/>
-
-      <TextView
-          android:id="@+id/debug_info"
-          android:layout_width="wrap_content"
-          android:layout_height="wrap_content"/>
-
-    </LinearLayout>
+    <TextView
+        android:id="@+id/debug_info"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"/>
 
   </LinearLayout>
 
diff --git a/demo_misc/vp9_opus_sw/src/main/res/values/strings.xml b/demo_misc/vp9_opus_sw/src/main/res/values/strings.xml
index 45c9da513c..6be85034cf 100644
--- a/demo_misc/vp9_opus_sw/src/main/res/values/strings.xml
+++ b/demo_misc/vp9_opus_sw/src/main/res/values/strings.xml
@@ -22,5 +22,11 @@
   <string name="current_path">
     Path: <xliff:g id="path" example="/sdcard/test.webm">%1$s</xliff:g>
   </string>
+  <string name="libvpx_version">
+    Libvpx: <xliff:g id="path">%1$s</xliff:g>
+  </string>
+  <string name="libopus_version">
+    Libopus: <xliff:g id="path">%1$s</xliff:g>
+  </string>
 
 </resources>
diff --git a/extensions/okhttp/build.gradle b/extensions/okhttp/build.gradle
index 4d616b2a43..4d257c42e3 100644
--- a/extensions/okhttp/build.gradle
+++ b/extensions/okhttp/build.gradle
@@ -13,13 +13,13 @@
 // limitations under the License.
 apply plugin: 'com.android.library'
 
-android{
-    compileSdkVersion 22
-    buildToolsVersion "22.0.1"
+android {
+    compileSdkVersion 23
+    buildToolsVersion "23.0.1"
 
     defaultConfig {
         minSdkVersion 9
-        targetSdkVersion 22
+        targetSdkVersion 23
     }
 
     buildTypes {
diff --git a/extensions/okhttp/src/main/AndroidManifest.xml b/extensions/okhttp/src/main/AndroidManifest.xml
index 507e98474c..8ca247dcaf 100644
--- a/extensions/okhttp/src/main/AndroidManifest.xml
+++ b/extensions/okhttp/src/main/AndroidManifest.xml
@@ -17,6 +17,6 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer.ext.okhttp">
 
-    <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="22"/>
+    <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="23"/>
 
 </manifest>
diff --git a/extensions/okhttp/src/main/project.properties b/extensions/okhttp/src/main/project.properties
index 2ed62fbfcf..b92a03b7ab 100644
--- a/extensions/okhttp/src/main/project.properties
+++ b/extensions/okhttp/src/main/project.properties
@@ -11,6 +11,6 @@
 #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
 
 # Project target.
-target=android-22
+target=android-23
 android.library=true
 android.library.reference.1=../../../../library/src/main
diff --git a/extensions/opus/build.gradle b/extensions/opus/build.gradle
index 443d0d6601..9ccc1862aa 100644
--- a/extensions/opus/build.gradle
+++ b/extensions/opus/build.gradle
@@ -14,12 +14,12 @@
 apply plugin: 'com.android.library'
 
 android {
-    compileSdkVersion 22
-    buildToolsVersion "22.0.1"
+    compileSdkVersion 23
+    buildToolsVersion "23.0.1"
 
     defaultConfig {
         minSdkVersion 9
-        targetSdkVersion 22
+        targetSdkVersion 23
     }
 
     buildTypes {
diff --git a/extensions/opus/src/main/AndroidManifest.xml b/extensions/opus/src/main/AndroidManifest.xml
index 22c75aa76b..7c26ae79f3 100644
--- a/extensions/opus/src/main/AndroidManifest.xml
+++ b/extensions/opus/src/main/AndroidManifest.xml
@@ -17,6 +17,6 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer.ext.opus">
 
-    <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="22"/>
+    <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="23"/>
 
 </manifest>
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
index e8fd8c8306..b5c3bd6295 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
@@ -36,8 +36,6 @@
 
 /**
  * Decodes and renders audio using the native Opus decoder.
- *
- * @author vigneshv@google.com (Vignesh Venkatasubramanian)
  */
 public final class LibopusAudioTrackRenderer extends SampleSourceTrackRenderer
     implements MediaClock {
@@ -119,6 +117,20 @@ public LibopusAudioTrackRenderer(SampleSource source, Handler eventHandler,
     formatHolder = new MediaFormatHolder();
   }
 
+  /**
+   * Returns whether the underlying libopus library is available.
+   */
+  public static boolean isLibopusAvailable() {
+    return OpusDecoder.isLibopusAvailable();
+  }
+
+  /**
+   * Returns the version of the underlying libopus library if available, otherwise {@code null}.
+   */
+  public static String getLibopusVersion() {
+    return isLibopusAvailable() ? OpusDecoder.getLibopusVersion() : null;
+  }
+
   @Override
   protected MediaClock getMediaClock() {
     return this;
@@ -251,7 +263,7 @@ private boolean feedInputBuffer(long positionUs) throws OpusDecoderException {
     }
 
     if (inputBuffer == null) {
-      inputBuffer = decoder.getInputBuffer();
+      inputBuffer = decoder.dequeueInputBuffer();
       if (inputBuffer == null) {
         return false;
       }
@@ -310,7 +322,8 @@ protected boolean isEnded() {
 
   @Override
   protected boolean isReady() {
-    return audioTrack.hasPendingData() || (format != null && sourceIsReady);
+    return audioTrack.hasPendingData()
+        || (format != null && (sourceIsReady || outputBuffer != null));
   }
 
   @Override
@@ -370,7 +383,7 @@ private boolean readFormat(long positionUs) {
     int result = readSource(positionUs, formatHolder, null, false);
     if (result == SampleSource.FORMAT_READ) {
       format = formatHolder.format;
-      audioTrack.reconfigure(format.getFrameworkMediaFormatV16(), false);
+      audioTrack.configure(format.getFrameworkMediaFormatV16(), false);
       return true;
     }
     return false;
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java
index 6de3481c2a..8fb2b21199 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java
@@ -21,18 +21,24 @@
 
 /**
  * JNI Wrapper for the libopus Opus decoder.
- *
- * @author vigneshv@google.com (Vignesh Venkatasubramanian)
  */
 /* package */ class OpusDecoder {
 
-  private final long nativeDecoderContext;
-
+  private static final boolean IS_AVAILABLE;
   static {
-    System.loadLibrary("opus");
-    System.loadLibrary("opusJNI");
+    boolean isAvailable;
+    try {
+      System.loadLibrary("opus");
+      System.loadLibrary("opusJNI");
+      isAvailable = true;
+    } catch (UnsatisfiedLinkError exception) {
+      isAvailable = false;
+    }
+    IS_AVAILABLE = isAvailable;
   }
 
+  private final long nativeDecoderContext;
+
   /**
    * Creates the Opus Decoder.
    *
@@ -81,6 +87,18 @@ public void reset() {
     opusReset(nativeDecoderContext);
   }
 
+  /**
+   * Returns whether the underlying libopus library is available.
+   */
+  public static boolean isLibopusAvailable() {
+    return IS_AVAILABLE;
+  }
+
+  /**
+   * Returns the version string of the underlying libopus decoder.
+   */
+  public static native String getLibopusVersion();
+
   private native long opusInit(int sampleRate, int channelCount, int numStreams, int numCoupled,
       int gain, byte[] streamMap);
   private native int opusDecode(long decoder, ByteBuffer inputBuffer, int inputSize,
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoderWrapper.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoderWrapper.java
index 3687bde27b..d4f6c8e306 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoderWrapper.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoderWrapper.java
@@ -22,8 +22,6 @@
 
 /**
  * Wraps {@link OpusDecoder}, exposing a higher level decoder interface.
- *
- * @author vigneshv@google.com (Vignesh Venkatasubramanian)
  */
 /* package */ class OpusDecoderWrapper extends Thread {
 
@@ -38,8 +36,10 @@
   private final Object lock;
   private final OpusHeader opusHeader;
 
+  private final LinkedList<InputBuffer> dequeuedInputBuffers;
   private final LinkedList<InputBuffer> queuedInputBuffers;
   private final LinkedList<OutputBuffer> queuedOutputBuffers;
+  private final LinkedList<OutputBuffer> dequeuedOutputBuffers;
   private final InputBuffer[] availableInputBuffers;
   private final OutputBuffer[] availableOutputBuffers;
   private int availableInputBufferCount;
@@ -68,10 +68,14 @@ public OpusDecoderWrapper(byte[] headerBytes, long codecDelayNs,
       long seekPreRollNs) throws OpusDecoderException {
     lock = new Object();
     opusHeader = parseOpusHeader(headerBytes);
-    skipSamples = (codecDelayNs == -1) ? opusHeader.skipSamples : nsToSamples(codecDelayNs);
-    seekPreRoll = (seekPreRoll == -1) ? DEFAULT_SEEK_PRE_ROLL : nsToSamples(seekPreRollNs);
+    skipSamples = (codecDelayNs == -1) ? opusHeader.skipSamples
+        : nsToSamples(opusHeader, codecDelayNs);
+    seekPreRoll = (seekPreRoll == -1) ? DEFAULT_SEEK_PRE_ROLL
+        : nsToSamples(opusHeader, seekPreRollNs);
+    dequeuedInputBuffers = new LinkedList<>();
     queuedInputBuffers = new LinkedList<>();
     queuedOutputBuffers = new LinkedList<>();
+    dequeuedOutputBuffers = new LinkedList<>();
     availableInputBuffers = new InputBuffer[NUM_BUFFERS];
     availableOutputBuffers = new OutputBuffer[NUM_BUFFERS];
     availableInputBufferCount = NUM_BUFFERS;
@@ -82,7 +86,7 @@ public OpusDecoderWrapper(byte[] headerBytes, long codecDelayNs,
     }
   }
 
-  public InputBuffer getInputBuffer() throws OpusDecoderException {
+  public InputBuffer dequeueInputBuffer() throws OpusDecoderException {
     synchronized (lock) {
       maybeThrowDecoderError();
       if (availableInputBufferCount == 0) {
@@ -90,6 +94,7 @@ public InputBuffer getInputBuffer() throws OpusDecoderException {
       }
       InputBuffer inputBuffer = availableInputBuffers[--availableInputBufferCount];
       inputBuffer.reset();
+      dequeuedInputBuffers.addLast(inputBuffer);
       return inputBuffer;
     }
   }
@@ -97,6 +102,7 @@ public InputBuffer getInputBuffer() throws OpusDecoderException {
   public void queueInputBuffer(InputBuffer inputBuffer) throws OpusDecoderException {
     synchronized (lock) {
       maybeThrowDecoderError();
+      dequeuedInputBuffers.remove(inputBuffer);
       queuedInputBuffers.addLast(inputBuffer);
       maybeNotifyDecodeLoop();
     }
@@ -108,7 +114,9 @@ public OutputBuffer dequeueOutputBuffer() throws OpusDecoderException {
       if (queuedOutputBuffers.isEmpty()) {
         return null;
       }
-      return queuedOutputBuffers.removeFirst();
+      OutputBuffer outputBuffer = queuedOutputBuffers.removeFirst();
+      dequeuedOutputBuffers.add(outputBuffer);
+      return outputBuffer;
     }
   }
 
@@ -116,6 +124,7 @@ public void releaseOutputBuffer(OutputBuffer outputBuffer) throws OpusDecoderExc
     synchronized (lock) {
       maybeThrowDecoderError();
       outputBuffer.reset();
+      dequeuedOutputBuffers.remove(outputBuffer);
       availableOutputBuffers[availableOutputBufferCount++] = outputBuffer;
       maybeNotifyDecodeLoop();
     }
@@ -124,12 +133,18 @@ public void releaseOutputBuffer(OutputBuffer outputBuffer) throws OpusDecoderExc
   public void flush() {
     synchronized (lock) {
       flushDecodedOutputBuffer = true;
+      while (!dequeuedInputBuffers.isEmpty()) {
+        availableInputBuffers[availableInputBufferCount++] = dequeuedInputBuffers.removeFirst();
+      }
       while (!queuedInputBuffers.isEmpty()) {
         availableInputBuffers[availableInputBufferCount++] = queuedInputBuffers.removeFirst();
       }
       while (!queuedOutputBuffers.isEmpty()) {
         availableOutputBuffers[availableOutputBufferCount++] = queuedOutputBuffers.removeFirst();
       }
+      while (!dequeuedOutputBuffers.isEmpty()) {
+        availableOutputBuffers[availableOutputBufferCount++] = dequeuedOutputBuffers.removeFirst();
+      }
     }
   }
 
@@ -256,7 +271,7 @@ private boolean decodeBuffer(OpusDecoder decoder) throws InterruptedException,
     return true;
   }
 
-  private OpusHeader parseOpusHeader(byte[] headerBytes) throws OpusDecoderException {
+  private static OpusHeader parseOpusHeader(byte[] headerBytes) throws OpusDecoderException {
     final int maxChannelCount = 8;
     final int maxChannelCountWithDefaultLayout = 2;
     final int headerSize = 19;
@@ -302,13 +317,13 @@ private OpusHeader parseOpusHeader(byte[] headerBytes) throws OpusDecoderExcepti
     }
   }
 
-  private int readLittleEndian16(byte[] input, int offset) {
+  private static int readLittleEndian16(byte[] input, int offset) {
     int value = input[offset];
     value |= input[offset + 1] << 8;
     return value;
   }
 
-  private int nsToSamples(long ns) {
+  private static int nsToSamples(OpusHeader opusHeader, long ns) {
     return (int) (ns * opusHeader.sampleRate / 1000000000);
   }
 
diff --git a/extensions/opus/src/main/jni/Android.mk b/extensions/opus/src/main/jni/Android.mk
index 7ca8300316..892715e9c6 100644
--- a/extensions/opus/src/main/jni/Android.mk
+++ b/extensions/opus/src/main/jni/Android.mk
@@ -16,7 +16,6 @@
 
 WORKING_DIR := $(call my-dir)
 include $(CLEAR_VARS)
-APP_PLATFORM := android-10
 
 # build libopus.so
 LOCAL_PATH := $(WORKING_DIR)
diff --git a/extensions/opus/src/main/jni/Application.mk b/extensions/opus/src/main/jni/Application.mk
index 6563af0f50..7dc417cda1 100644
--- a/extensions/opus/src/main/jni/Application.mk
+++ b/extensions/opus/src/main/jni/Application.mk
@@ -17,3 +17,4 @@
 APP_OPTIM := release
 APP_STL := gnustl_static
 APP_CPPFLAGS := -frtti
+APP_PLATFORM := android-9
diff --git a/extensions/opus/src/main/jni/opus_jni.cc b/extensions/opus/src/main/jni/opus_jni.cc
index 0259592c94..e4ee1c60e3 100644
--- a/extensions/opus/src/main/jni/opus_jni.cc
+++ b/extensions/opus/src/main/jni/opus_jni.cc
@@ -91,6 +91,10 @@ FUNC(void, opusReset, jlong jDecoder) {
   opus_multistream_decoder_ctl(decoder, OPUS_RESET_STATE);
 }
 
+FUNC(jstring, getLibopusVersion) {
+  return env->NewStringUTF(opus_get_version_string());
+}
+
 FUNC(jstring, opusGetErrorMessage, jint errorCode) {
   return env->NewStringUTF(opus_strerror(errorCode));
 }
diff --git a/extensions/opus/src/main/project.properties b/extensions/opus/src/main/project.properties
index 2ed62fbfcf..b92a03b7ab 100644
--- a/extensions/opus/src/main/project.properties
+++ b/extensions/opus/src/main/project.properties
@@ -11,6 +11,6 @@
 #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
 
 # Project target.
-target=android-22
+target=android-23
 android.library=true
 android.library.reference.1=../../../../library/src/main
diff --git a/extensions/vp9/README.md b/extensions/vp9/README.md
index 888792f880..f47aa1225a 100644
--- a/extensions/vp9/README.md
+++ b/extensions/vp9/README.md
@@ -35,7 +35,7 @@ NDK_PATH="<path to Android NDK>"
 ```
 cd "${VP9_EXT_PATH}/jni" && \
 git clone https://chromium.googlesource.com/webm/libvpx libvpx && \
-git clone https://git.chromium.org/external/libyuv.git libyuv
+git clone https://chromium.googlesource.com/libyuv/libyuv libyuv
 ```
 
 * Run a script that generates necessary configuration files for libvpx
diff --git a/extensions/vp9/build.gradle b/extensions/vp9/build.gradle
index 443d0d6601..9ccc1862aa 100644
--- a/extensions/vp9/build.gradle
+++ b/extensions/vp9/build.gradle
@@ -14,12 +14,12 @@
 apply plugin: 'com.android.library'
 
 android {
-    compileSdkVersion 22
-    buildToolsVersion "22.0.1"
+    compileSdkVersion 23
+    buildToolsVersion "23.0.1"
 
     defaultConfig {
         minSdkVersion 9
-        targetSdkVersion 22
+        targetSdkVersion 23
     }
 
     buildTypes {
diff --git a/extensions/vp9/src/main/AndroidManifest.xml b/extensions/vp9/src/main/AndroidManifest.xml
index 3e21f70510..2869352679 100644
--- a/extensions/vp9/src/main/AndroidManifest.xml
+++ b/extensions/vp9/src/main/AndroidManifest.xml
@@ -17,7 +17,7 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer.ext.vp9">
 
-    <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="22"/>
+    <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="23"/>
     <uses-feature android:glEsVersion="0x00020000"/>
 
 </manifest>
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
index d19a0992b9..fd2d0579e4 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
@@ -108,7 +108,7 @@
   private boolean renderedFirstFrame;
   private Surface surface;
   private VpxVideoSurfaceView vpxVideoSurfaceView;
-  private boolean outputRgb;
+  private int outputMode;
 
   private boolean inputStreamEnded;
   private boolean outputStreamEnded;
@@ -148,6 +148,21 @@ public LibvpxVideoTrackRenderer(SampleSource source, boolean scaleToFit,
     previousWidth = -1;
     previousHeight = -1;
     formatHolder = new MediaFormatHolder();
+    outputMode = VpxDecoder.OUTPUT_MODE_UNKNOWN;
+  }
+
+  /**
+   * Returns whether the underlying libvpx library is available.
+   */
+  public static boolean isLibvpxAvailable() {
+    return VpxDecoder.isLibvpxAvailable();
+  }
+
+  /**
+   * Returns the version of the underlying libvpx library if available, otherwise {@code null}.
+   */
+  public static String getLibvpxVersion() {
+    return isLibvpxAvailable() ? VpxDecoder.getLibvpxVersion() : null;
   }
 
   @Override
@@ -170,9 +185,8 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPla
     }
 
     // If we don't have a decoder yet, we need to instantiate one.
-    // TODO: Add support for dynamic switching between one type of surface to another.
     if (decoder == null) {
-      decoder = new VpxDecoderWrapper(outputRgb);
+      decoder = new VpxDecoderWrapper(outputMode);
       decoder.start();
     }
 
@@ -246,15 +260,15 @@ private void processOutputBuffer(long positionUs, long elapsedRealtimeUs)
   private void renderBuffer() throws VpxDecoderException {
     codecCounters.renderedOutputBufferCount++;
     notifyIfVideoSizeChanged(outputBuffer);
-    if (outputRgb) {
+    if (outputBuffer.mode == VpxDecoder.OUTPUT_MODE_RGB && surface != null) {
       renderRgbFrame(outputBuffer, scaleToFit);
-    } else {
+      if (!drawnToSurface) {
+        drawnToSurface = true;
+        notifyDrawnToSurface(surface);
+      }
+    } else if (outputBuffer.mode == VpxDecoder.OUTPUT_MODE_YUV && vpxVideoSurfaceView != null) {
       vpxVideoSurfaceView.renderFrame(outputBuffer);
     }
-    if (!drawnToSurface) {
-      drawnToSurface = true;
-      notifyDrawnToSurface(surface);
-    }
     releaseOutputBuffer();
   }
 
@@ -284,7 +298,7 @@ private boolean feedInputBuffer(long positionUs) throws VpxDecoderException {
     }
 
     if (inputBuffer == null) {
-      inputBuffer = decoder.getInputBuffer();
+      inputBuffer = decoder.dequeueInputBuffer();
       if (inputBuffer == null) {
         return false;
       }
@@ -341,7 +355,7 @@ protected boolean isEnded() {
 
   @Override
   protected boolean isReady() {
-    return format != null && sourceIsReady;
+    return format != null && (sourceIsReady || outputBuffer != null);
   }
 
   @Override
@@ -402,18 +416,40 @@ private boolean readFormat(long positionUs) {
   @Override
   public void handleMessage(int messageType, Object message) throws ExoPlaybackException {
     if (messageType == MSG_SET_SURFACE) {
-      surface = (Surface) message;
-      vpxVideoSurfaceView = null;
-      outputRgb = true;
+      setSurface((Surface) message);
     } else if (messageType == MSG_SET_VPX_SURFACE_VIEW) {
-      vpxVideoSurfaceView = (VpxVideoSurfaceView) message;
-      surface = null;
-      outputRgb = false;
+      setVpxVideoSurfaceView((VpxVideoSurfaceView) message);
     } else {
       super.handleMessage(messageType, message);
     }
   }
 
+  private void setSurface(Surface surface) {
+    if (this.surface == surface) {
+      return;
+    }
+    this.surface = surface;
+    vpxVideoSurfaceView = null;
+    outputMode = (surface != null) ? VpxDecoder.OUTPUT_MODE_RGB : VpxDecoder.OUTPUT_MODE_UNKNOWN;
+    if (decoder != null) {
+      decoder.setOutputMode(outputMode);
+    }
+    drawnToSurface = false;
+  }
+
+  private void setVpxVideoSurfaceView(VpxVideoSurfaceView vpxVideoSurfaceView) {
+    if (this.vpxVideoSurfaceView == vpxVideoSurfaceView) {
+      return;
+    }
+    this.vpxVideoSurfaceView = vpxVideoSurfaceView;
+    surface = null;
+    outputMode =
+        (vpxVideoSurfaceView != null) ? VpxDecoder.OUTPUT_MODE_YUV : VpxDecoder.OUTPUT_MODE_UNKNOWN;
+    if (decoder != null) {
+      decoder.setOutputMode(outputMode);
+    }
+  }
+
   private void notifyIfVideoSizeChanged(final OutputBuffer outputBuffer) {
     if (previousWidth == -1 || previousHeight == -1
         || previousWidth != outputBuffer.width || previousHeight != outputBuffer.height) {
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
index 3a65c9cf77..954304d0cd 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
@@ -24,13 +24,25 @@
  */
 /* package */ class VpxDecoder {
 
-  private final long vpxDecContext;
-
+  private static final boolean IS_AVAILABLE;
   static {
-    System.loadLibrary("vpx");
-    System.loadLibrary("vpxJNI");
+    boolean isAvailable;
+    try {
+      System.loadLibrary("vpx");
+      System.loadLibrary("vpxJNI");
+      isAvailable = true;
+    } catch (UnsatisfiedLinkError exception) {
+      isAvailable = false;
+    }
+    IS_AVAILABLE = isAvailable;
   }
 
+  public static final int OUTPUT_MODE_UNKNOWN = -1;
+  public static final int OUTPUT_MODE_YUV = 0;
+  public static final int OUTPUT_MODE_RGB = 1;
+
+  private final long vpxDecContext;
+
   /**
    * Creates the VP9 Decoder.
    *
@@ -49,17 +61,15 @@ public VpxDecoder() throws VpxDecoderException {
    * @param encoded The encoded buffer.
    * @param size Size of the encoded buffer.
    * @param outputBuffer The buffer into which the decoded frame should be written.
-   * @param outputRgb True if the buffer should be converted to RGB color format. False if YUV
-   *     format should be retained.
    * @return 0 on success with a frame to render. 1 on success without a frame to render.
    * @throws VpxDecoderException on decode failure.
    */
-  public int decode(ByteBuffer encoded, int size, OutputBuffer outputBuffer, boolean outputRgb) 
+  public int decode(ByteBuffer encoded, int size, OutputBuffer outputBuffer)
       throws VpxDecoderException {
     if (vpxDecode(vpxDecContext, encoded, size) != 0) {
       throw new VpxDecoderException("libvpx decode error: " + vpxGetErrorMessage(vpxDecContext));
     }
-    return vpxGetFrame(vpxDecContext, outputBuffer, outputRgb);
+    return vpxGetFrame(vpxDecContext, outputBuffer);
   }
 
   /**
@@ -69,10 +79,22 @@ public void close() {
     vpxClose(vpxDecContext);
   }
 
+  /**
+   * Returns whether the underlying libvpx library is available.
+   */
+  public static boolean isLibvpxAvailable() {
+    return IS_AVAILABLE;
+  }
+
+  /**
+   * Returns the version string of the underlying libvpx decoder.
+   */
+  public static native String getLibvpxVersion();
+
   private native long vpxInit();
   private native long vpxClose(long context);
   private native long vpxDecode(long context, ByteBuffer encoded, int length);
-  private native int vpxGetFrame(long context, OutputBuffer outputBuffer, boolean outputRgb);
+  private native int vpxGetFrame(long context, OutputBuffer outputBuffer);
   private native String vpxGetErrorMessage(long context);
 
 }
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderWrapper.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderWrapper.java
index 49e063b52a..5999244da7 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderWrapper.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderWrapper.java
@@ -31,10 +31,11 @@
   private static final int NUM_BUFFERS = 16;
 
   private final Object lock;
-  private final boolean outputRgb;
 
+  private final LinkedList<InputBuffer> dequeuedInputBuffers;
   private final LinkedList<InputBuffer> queuedInputBuffers;
   private final LinkedList<OutputBuffer> queuedOutputBuffers;
+  private final LinkedList<OutputBuffer> dequeuedOutputBuffers;
   private final InputBuffer[] availableInputBuffers;
   private final OutputBuffer[] availableOutputBuffers;
   private int availableInputBufferCount;
@@ -42,18 +43,21 @@
 
   private boolean flushDecodedOutputBuffer;
   private boolean released;
+  private int outputMode;
 
   private VpxDecoderException decoderException;
 
   /**
-   * @param outputRgb True if the decoded output is in RGB color format. False if it is in YUV
-   *     color format.
+   * @param outputMode One of OUTPUT_MODE_* constants from {@link VpxDecoderWrapper}
+   *     depending on the desired output mode.
    */
-  public VpxDecoderWrapper(boolean outputRgb) {
+  public VpxDecoderWrapper(int outputMode) {
     lock = new Object();
-    this.outputRgb = outputRgb;
+    this.outputMode = outputMode;
+    dequeuedInputBuffers = new LinkedList<>();
     queuedInputBuffers = new LinkedList<>();
     queuedOutputBuffers = new LinkedList<>();
+    dequeuedOutputBuffers = new LinkedList<>();
     availableInputBuffers = new InputBuffer[NUM_BUFFERS];
     availableOutputBuffers = new OutputBuffer[NUM_BUFFERS];
     availableInputBufferCount = NUM_BUFFERS;
@@ -64,7 +68,11 @@ public VpxDecoderWrapper(boolean outputRgb) {
     }
   }
 
-  public InputBuffer getInputBuffer() throws VpxDecoderException {
+  public void setOutputMode(int outputMode) {
+    this.outputMode = outputMode;
+  }
+
+  public InputBuffer dequeueInputBuffer() throws VpxDecoderException {
     synchronized (lock) {
       maybeThrowDecoderError();
       if (availableInputBufferCount == 0) {
@@ -73,6 +81,7 @@ public InputBuffer getInputBuffer() throws VpxDecoderException {
       InputBuffer inputBuffer = availableInputBuffers[--availableInputBufferCount];
       inputBuffer.flags = 0;
       inputBuffer.sampleHolder.clearData();
+      dequeuedInputBuffers.addLast(inputBuffer);
       return inputBuffer;
     }
   }
@@ -80,6 +89,7 @@ public InputBuffer getInputBuffer() throws VpxDecoderException {
   public void queueInputBuffer(InputBuffer inputBuffer) throws VpxDecoderException {
     synchronized (lock) {
       maybeThrowDecoderError();
+      dequeuedInputBuffers.remove(inputBuffer);
       queuedInputBuffers.addLast(inputBuffer);
       maybeNotifyDecodeLoop();
     }
@@ -91,13 +101,16 @@ public OutputBuffer dequeueOutputBuffer() throws VpxDecoderException {
       if (queuedOutputBuffers.isEmpty()) {
         return null;
       }
-      return queuedOutputBuffers.removeFirst();
+      OutputBuffer outputBuffer = queuedOutputBuffers.removeFirst();
+      dequeuedOutputBuffers.add(outputBuffer);
+      return outputBuffer;
     }
   }
 
   public void releaseOutputBuffer(OutputBuffer outputBuffer) throws VpxDecoderException {
     synchronized (lock) {
       maybeThrowDecoderError();
+      dequeuedOutputBuffers.remove(outputBuffer);
       availableOutputBuffers[availableOutputBufferCount++] = outputBuffer;
       maybeNotifyDecodeLoop();
     }
@@ -106,12 +119,18 @@ public void releaseOutputBuffer(OutputBuffer outputBuffer) throws VpxDecoderExce
   public void flush() {
     synchronized (lock) {
       flushDecodedOutputBuffer = true;
+      while (!dequeuedInputBuffers.isEmpty()) {
+        availableInputBuffers[availableInputBufferCount++] = dequeuedInputBuffers.removeFirst();
+      }
       while (!queuedInputBuffers.isEmpty()) {
         availableInputBuffers[availableInputBufferCount++] = queuedInputBuffers.removeFirst();
       }
       while (!queuedOutputBuffers.isEmpty()) {
         availableOutputBuffers[availableOutputBufferCount++] = queuedOutputBuffers.removeFirst();
       }
+      while (!dequeuedOutputBuffers.isEmpty()) {
+        availableOutputBuffers[availableOutputBufferCount++] = dequeuedOutputBuffers.removeFirst();
+      }
     }
   }
 
@@ -192,8 +211,9 @@ private boolean decodeBuffer(VpxDecoder decoder) throws InterruptedException,
       SampleHolder sampleHolder = inputBuffer.sampleHolder;
       outputBuffer.timestampUs = sampleHolder.timeUs;
       outputBuffer.flags = 0;
+      outputBuffer.mode = outputMode;
       sampleHolder.data.position(sampleHolder.data.position() - sampleHolder.size);
-      decodeResult = decoder.decode(sampleHolder.data, sampleHolder.size, outputBuffer, outputRgb);
+      decodeResult = decoder.decode(sampleHolder.data, sampleHolder.size, outputBuffer);
     }
 
     synchronized (lock) {
@@ -242,6 +262,7 @@ public InputBuffer() {
     public int flags;
     public ByteBuffer[] yuvPlanes;
     public int[] yuvStrides;
+    public int mode;
 
     /**
      * This method is called from C++ through JNI after decoding is done. It will resize the
diff --git a/extensions/vp9/src/main/jni/Android.mk b/extensions/vp9/src/main/jni/Android.mk
index fa566dbb50..f2d8a99a90 100644
--- a/extensions/vp9/src/main/jni/Android.mk
+++ b/extensions/vp9/src/main/jni/Android.mk
@@ -16,7 +16,6 @@
 
 WORKING_DIR := $(call my-dir)
 include $(CLEAR_VARS)
-APP_PLATFORM := android-10
 LIBVPX_ROOT := $(WORKING_DIR)/libvpx
 LIBYUV_ROOT := $(WORKING_DIR)/libyuv
 
diff --git a/extensions/vp9/src/main/jni/Application.mk b/extensions/vp9/src/main/jni/Application.mk
index 6563af0f50..7dc417cda1 100644
--- a/extensions/vp9/src/main/jni/Application.mk
+++ b/extensions/vp9/src/main/jni/Application.mk
@@ -17,3 +17,4 @@
 APP_OPTIM := release
 APP_STL := gnustl_static
 APP_CPPFLAGS := -frtti
+APP_PLATFORM := android-9
diff --git a/extensions/vp9/src/main/jni/vpx_jni.cc b/extensions/vp9/src/main/jni/vpx_jni.cc
index 21a845d779..6d8fbd5298 100644
--- a/extensions/vp9/src/main/jni/vpx_jni.cc
+++ b/extensions/vp9/src/main/jni/vpx_jni.cc
@@ -48,6 +48,7 @@
 static jmethodID initForRgbFrame;
 static jmethodID initForYuvFrame;
 static jfieldID dataField;
+static jfieldID outputModeField;
 
 jint JNI_OnLoad(JavaVM* vm, void* reserved) {
   JNIEnv* env;
@@ -75,6 +76,7 @@ FUNC(jlong, vpxInit) {
                                      "(II)V");
   dataField = env->GetFieldID(outputBufferClass, "data",
                               "Ljava/nio/ByteBuffer;");
+  outputModeField = env->GetFieldID(outputBufferClass, "mode", "I");
 
   return reinterpret_cast<intptr_t>(context);
 }
@@ -99,7 +101,7 @@ FUNC(jlong, vpxClose, jlong jContext) {
   return 0;
 }
 
-FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer, jboolean isRGB) {
+FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer) {
   vpx_codec_ctx_t* const context = reinterpret_cast<vpx_codec_ctx_t*>(jContext);
   vpx_codec_iter_t iter = NULL;
   const vpx_image_t* const img = vpx_codec_get_frame(context, &iter);
@@ -108,7 +110,11 @@ FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer, jboolean isRGB) {
     return 1;
   }
 
-  if (isRGB == JNI_TRUE) {
+  const int kOutputModeYuv = 0;
+  const int kOutputModeRgb = 1;
+
+  int outputMode = env->GetIntField(jOutputBuffer, outputModeField);
+  if (outputMode == kOutputModeRgb) {
     // resize buffer if required.
     env->CallVoidMethod(jOutputBuffer, initForRgbFrame, img->d_w, img->d_h);
 
@@ -121,7 +127,7 @@ FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer, jboolean isRGB) {
                          img->planes[VPX_PLANE_U], img->stride[VPX_PLANE_U],
                          img->planes[VPX_PLANE_V], img->stride[VPX_PLANE_V],
                          dst, img->d_w * 2, img->d_w, img->d_h);
-  } else {
+  } else if (outputMode == kOutputModeYuv) {
     // resize buffer if required.
     env->CallVoidMethod(jOutputBuffer, initForYuvFrame, img->d_w, img->d_h,
                         img->stride[VPX_PLANE_Y], img->stride[VPX_PLANE_U]);
@@ -143,6 +149,10 @@ FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer, jboolean isRGB) {
   return 0;
 }
 
+FUNC(jstring, getLibvpxVersion) {
+  return env->NewStringUTF(vpx_codec_version_str());
+}
+
 FUNC(jstring, vpxGetErrorMessage, jlong jContext) {
   vpx_codec_ctx_t* const context = reinterpret_cast<vpx_codec_ctx_t*>(jContext);
   return env->NewStringUTF(vpx_codec_error(context));
diff --git a/extensions/vp9/src/main/proguard.cfg b/extensions/vp9/src/main/proguard.cfg
new file mode 100644
index 0000000000..28ec41a6b3
--- /dev/null
+++ b/extensions/vp9/src/main/proguard.cfg
@@ -0,0 +1,11 @@
+# Proguard rules specific to the VP9 extension.
+
+# This prevents the names of native methods from being obfuscated.
+-keepclasseswithmembernames class * {
+    native <methods>;
+}
+
+# Some members of this class are being accessed from native methods. Keep them unobfuscated.
+-keep class com.google.android.exoplayer.ext.vp9.VpxDecoderWrapper$OutputBuffer {
+    *;
+}
diff --git a/extensions/vp9/src/main/project.properties b/extensions/vp9/src/main/project.properties
index 2ed62fbfcf..b92a03b7ab 100644
--- a/extensions/vp9/src/main/project.properties
+++ b/extensions/vp9/src/main/project.properties
@@ -11,6 +11,6 @@
 #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
 
 # Project target.
-target=android-22
+target=android-23
 android.library=true
 android.library.reference.1=../../../../library/src/main
diff --git a/gradlew.bat b/gradlew.bat
index aec99730b4..8a0b282aa6 100644
--- a/gradlew.bat
+++ b/gradlew.bat
@@ -1,90 +1,90 @@
-@if "%DEBUG%" == "" @echo off
-@rem ##########################################################################
-@rem
-@rem  Gradle startup script for Windows
-@rem
-@rem ##########################################################################
-
-@rem Set local scope for the variables with windows NT shell
-if "%OS%"=="Windows_NT" setlocal
-
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
-set DIRNAME=%~dp0
-if "%DIRNAME%" == "" set DIRNAME=.
-set APP_BASE_NAME=%~n0
-set APP_HOME=%DIRNAME%
-
-@rem Find java.exe
-if defined JAVA_HOME goto findJavaFromJavaHome
-
-set JAVA_EXE=java.exe
-%JAVA_EXE% -version >NUL 2>&1
-if "%ERRORLEVEL%" == "0" goto init
-
-echo.
-echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:findJavaFromJavaHome
-set JAVA_HOME=%JAVA_HOME:"=%
-set JAVA_EXE=%JAVA_HOME%/bin/java.exe
-
-if exist "%JAVA_EXE%" goto init
-
-echo.
-echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:init
-@rem Get command-line arguments, handling Windowz variants
-
-if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
-
-:win9xME_args
-@rem Slurp the command line arguments.
-set CMD_LINE_ARGS=
-set _SKIP=2
-
-:win9xME_args_slurp
-if "x%~1" == "x" goto execute
-
-set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
-
-:execute
-@rem Setup the command line
-
-set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
-
-@rem Execute Gradle
-"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
-
-:end
-@rem End local scope for the variables with windows NT shell
-if "%ERRORLEVEL%"=="0" goto mainEnd
-
-:fail
-rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
-rem the _cmd.exe /c_ return code!
-if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
-exit /b 1
-
-:mainEnd
-if "%OS%"=="Windows_NT" endlocal
-
-:omega
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/library/build.gradle b/library/build.gradle
index e7deac79bf..98551f2159 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -15,8 +15,8 @@ apply plugin: 'com.android.library'
 apply plugin: 'bintray-release'
 
 android {
-    compileSdkVersion 22
-    buildToolsVersion "22.0.1"
+    compileSdkVersion 23
+    buildToolsVersion "23.0.1"
 
     defaultConfig {
         // Important: ExoPlayerLib specifies a minSdkVersion of 9 because
@@ -25,7 +25,7 @@ android {
         // functionality provided by the library requires API level 16 or
         // greater.
         minSdkVersion 9
-        targetSdkVersion 22
+        targetSdkVersion 23
     }
 
     buildTypes {
@@ -77,7 +77,7 @@ publish {
     userOrg = 'google'
     groupId = 'com.google.android.exoplayer'
     artifactId = 'exoplayer'
-    version = 'r1.5.2'
+    version = 'r1.5.3'
     description = 'The ExoPlayer library.'
     website = 'https://github.com/google/ExoPlayer'
 }
diff --git a/library/src/androidTest/AndroidManifest.xml b/library/src/androidTest/AndroidManifest.xml
index 0e6eba8cbd..6d2b1f6d08 100644
--- a/library/src/androidTest/AndroidManifest.xml
+++ b/library/src/androidTest/AndroidManifest.xml
@@ -18,7 +18,7 @@
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer.test">
 
-  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="22"/>
+  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="23"/>
 
   <application android:debuggable="true"
       android:allowBackup="false"
diff --git a/library/src/androidTest/assets/dash/sample_mpd_1 b/library/src/androidTest/assets/dash/sample_mpd_1
old mode 100755
new mode 100644
diff --git a/library/src/androidTest/assets/smoothstreaming/sample_ismc_1 b/library/src/androidTest/assets/smoothstreaming/sample_ismc_1
old mode 100755
new mode 100644
diff --git a/library/src/androidTest/assets/smoothstreaming/sample_ismc_2 b/library/src/androidTest/assets/smoothstreaming/sample_ismc_2
old mode 100755
new mode 100644
diff --git a/library/src/androidTest/assets/ttml/font_size.xml b/library/src/androidTest/assets/ttml/font_size.xml
new file mode 100644
index 0000000000..adbb8d6926
--- /dev/null
+++ b/library/src/androidTest/assets/ttml/font_size.xml
@@ -0,0 +1,30 @@
+<tt xmlns:ttm="http://www.w3.org/2006/10/ttaf1#metadata" xmlns:ttp="http://www.w3.org/2006/10/ttaf1#parameter"
+  xmlns:tts="http://www.w3.org/2006/10/ttaf1#style"
+  xmlns="http://www.w3.org/ns/ttml"
+  xmlns="http://www.w3.org/2006/10/ttaf1">
+  <head>
+    <styling>
+      <style id="s0"
+        tts:textDecoration="underline"/>
+      <style id="s1"
+        tts:textDecoration="lineThrough"/>
+    </styling>
+  </head>
+  <body>
+    <div>
+      <p begin="10s" end="18s" tts:fontSize="32px">text 1</p>
+    </div>
+    <div>
+      <p begin="20s" end="28s" tts:fontSize="2.2em">text 2</p>
+    </div>
+    <div>
+      <p begin="30s" end="38s" tts:fontSize="150%">text 3</p>
+    </div>
+    <div>
+      <p begin="40s" end="48s" tts:fontSize="32px 16px">two values</p>
+    </div>
+    <div>
+      <p begin="50s" end="58s" tts:fontSize=".5em">leading dot</p>
+    </div>
+  </body>
+</tt>
diff --git a/library/src/androidTest/assets/ttml/font_size_empty.xml b/library/src/androidTest/assets/ttml/font_size_empty.xml
new file mode 100644
index 0000000000..fdfc03ea6d
--- /dev/null
+++ b/library/src/androidTest/assets/ttml/font_size_empty.xml
@@ -0,0 +1,10 @@
+<tt xmlns:ttm="http://www.w3.org/2006/10/ttaf1#metadata" xmlns:ttp="http://www.w3.org/2006/10/ttaf1#parameter"
+  xmlns:tts="http://www.w3.org/2006/10/ttaf1#style"
+  xmlns="http://www.w3.org/ns/ttml"
+  xmlns="http://www.w3.org/2006/10/ttaf1">
+  <body>
+    <div>
+      <p begin="10s" end="18s" tts:fontSize="">empty</p>
+    </div>
+  </body>
+</tt>
diff --git a/library/src/androidTest/assets/ttml/font_size_invalid.xml b/library/src/androidTest/assets/ttml/font_size_invalid.xml
new file mode 100644
index 0000000000..2635656445
--- /dev/null
+++ b/library/src/androidTest/assets/ttml/font_size_invalid.xml
@@ -0,0 +1,16 @@
+<tt xmlns:ttm="http://www.w3.org/2006/10/ttaf1#metadata" xmlns:ttp="http://www.w3.org/2006/10/ttaf1#parameter"
+  xmlns:tts="http://www.w3.org/2006/10/ttaf1#style"
+  xmlns="http://www.w3.org/ns/ttml"
+  xmlns="http://www.w3.org/2006/10/ttaf1">
+  <body>
+    <div>
+      <p begin="10s" end="18s" tts:fontSize="px">invalid</p>
+    </div>
+    <div>
+      <p begin="20s" end="28s" tts:fontSize="12px 10px 9px">invalid</p>
+    </div>
+    <div>
+      <p begin="30s" end="38s" tts:fontSize="1.em">invalid dot</p>
+    </div>
+  </body>
+</tt>
diff --git a/library/src/androidTest/assets/ttml/font_size_no_unit.xml b/library/src/androidTest/assets/ttml/font_size_no_unit.xml
new file mode 100644
index 0000000000..126bd1ff33
--- /dev/null
+++ b/library/src/androidTest/assets/ttml/font_size_no_unit.xml
@@ -0,0 +1,10 @@
+<tt xmlns:ttm="http://www.w3.org/2006/10/ttaf1#metadata" xmlns:ttp="http://www.w3.org/2006/10/ttaf1#parameter"
+  xmlns:tts="http://www.w3.org/2006/10/ttaf1#style"
+  xmlns="http://www.w3.org/ns/ttml"
+  xmlns="http://www.w3.org/2006/10/ttaf1">
+  <body>
+    <div>
+      <p begin="10s" end="18s" tts:fontSize="32">no unit</p>
+    </div>
+  </body>
+</tt>
diff --git a/library/src/androidTest/assets/webvtt/with_bad_cue_header b/library/src/androidTest/assets/webvtt/with_bad_cue_header
new file mode 100644
index 0000000000..0cb4e8099e
--- /dev/null
+++ b/library/src/androidTest/assets/webvtt/with_bad_cue_header
@@ -0,0 +1,10 @@
+WEBVTT # This comment is allowed
+
+00:00.000 --> 00:01.234
+This is the first subtitle.
+
+00:02.badbadbadbadbadbad --> 00:03.456
+This is the second subtitle.
+
+00:04.000 --> 00:05.000
+This is the third subtitle.
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/MediaFormatTest.java b/library/src/androidTest/java/com/google/android/exoplayer/MediaFormatTest.java
index a22bc07567..c3270298a7 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/MediaFormatTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/MediaFormatTest.java
@@ -45,21 +45,18 @@ public void testConversionToFrameworkFormat() {
     initData.add(initData2);
 
     testConversionToFrameworkFormatV16(MediaFormat.createVideoFormat(
-        MediaFormat.NO_VALUE, "video/xyz", 5000, 102400, 1000L, 1280, 720, initData));
+        null, "video/xyz", 5000, 102400, 1000L, 1280, 720, initData));
     testConversionToFrameworkFormatV16(MediaFormat.createVideoFormat(
-        MediaFormat.NO_VALUE, "video/xyz", 5000, MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US, 1280, 720,
-        null));
+        null, "video/xyz", 5000, MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US, 1280, 720, null));
     testConversionToFrameworkFormatV16(MediaFormat.createAudioFormat(
-        MediaFormat.NO_VALUE, "audio/xyz", 500, 128, 1000L, 5, 44100, initData, null));
+        null, "audio/xyz", 500, 128, 1000L, 5, 44100, initData, null));
     testConversionToFrameworkFormatV16(MediaFormat.createAudioFormat(
-        MediaFormat.NO_VALUE, "audio/xyz", 500, MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US, 5, 44100,
-        null, null));
+        null, "audio/xyz", 500, MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US, 5, 44100, null, null));
     testConversionToFrameworkFormatV16(
-        MediaFormat.createTextFormat(MediaFormat.NO_VALUE, "text/xyz", MediaFormat.NO_VALUE, 1000L,
-            "eng"));
+        MediaFormat.createTextFormat(null, "text/xyz", MediaFormat.NO_VALUE, 1000L, "eng"));
     testConversionToFrameworkFormatV16(
-        MediaFormat.createTextFormat(MediaFormat.NO_VALUE, "text/xyz", MediaFormat.NO_VALUE,
-            C.UNKNOWN_TIME_US, null));
+        MediaFormat.createTextFormat(null, "text/xyz", MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US,
+        null));
   }
 
   @SuppressLint("InlinedApi")
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java b/library/src/androidTest/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java
index 955d10ada5..d1e75b8838 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java
@@ -128,7 +128,7 @@ public void testSegmentIndexInitializationOnVod() {
     ChunkOperationHolder out = new ChunkOperationHolder();
 
     // request first chunk; should get back initialization chunk
-    chunkSource.getChunkOperation(queue, 0, 0, out);
+    chunkSource.getChunkOperation(queue,  0, out);
 
     assertNotNull(out.chunk);
     assertNotNull(((InitializationChunk) out.chunk).dataSpec);
@@ -386,7 +386,7 @@ private static void checkLiveEdgeConsistency(MediaPresentationDescription mpd,
   private static void checkLiveEdgeConsistency(DashChunkSource chunkSource, List<MediaChunk> queue,
       ChunkOperationHolder out, long seekPositionMs, long availableRangeStartMs,
       long availableRangeEndMs, long chunkStartTimeMs, long chunkEndTimeMs) {
-    chunkSource.getChunkOperation(queue, seekPositionMs * 1000, 0, out);
+    chunkSource.getChunkOperation(queue, seekPositionMs * 1000, out);
     TimeRange availableRange = chunkSource.getAvailableRange();
     checkAvailableRange(availableRange, availableRangeStartMs * 1000, availableRangeEndMs * 1000);
     if (chunkStartTimeMs < availableRangeEndMs) {
@@ -487,7 +487,7 @@ private static void checkSegmentRequestSequenceOnMultiPeriodLive(DashChunkSource
 
     // request "eleventh" chunk; this chunk isn't available yet, so we should get null
     out.chunk = null;
-    chunkSource.getChunkOperation(queue, seekPositionMs * 1000, 0, out);
+    chunkSource.getChunkOperation(queue, seekPositionMs * 1000, out);
     assertNull(out.chunk);
   }
 
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/mp4/Mp4ExtractorTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/mp4/Mp4ExtractorTest.java
index 7b2d9acf0b..a7a572d3cd 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/extractor/mp4/Mp4ExtractorTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/mp4/Mp4ExtractorTest.java
@@ -70,6 +70,9 @@
   private static final byte[] AUDIO_MDHD_PAYLOAD =
       getByteArray("00000000cf6c4889cf6c488a0000ac4400a3e40055c40000");
 
+  /** String of hexadecimal bytes for an ftyp payload with major_brand mp41 and minor_version 0. **/
+  private static final byte[] FTYP_PAYLOAD = getByteArray("6d70343100000000");
+
   /** String of hexadecimal bytes containing an mvhd payload from an AVC/AAC video. */
   private static final byte[] MVHD_PAYLOAD = getByteArray(
       "00000000cf6c4888cf6c48880000025800023ad40001000001000000000000000000000000010000000000"
@@ -88,7 +91,7 @@
   /** Indices of key-frames. */
   private static final boolean[] SAMPLE_IS_SYNC = {true, false, false, false, true, true};
   /** Indices of video frame chunk offsets. */
-  private static final int[] CHUNK_OFFSETS = {1200, 2120, 3120, 4120};
+  private static final int[] CHUNK_OFFSETS = {1208, 2128, 3128, 4128};
   /** Numbers of video frames in each chunk. */
   private static final int[] SAMPLES_IN_CHUNK = {2, 2, 1, 1};
   /** The mdat box must be large enough to avoid reading chunk sample data out of bounds. */
@@ -368,7 +371,7 @@ private static int getSampleOffset(int index) {
   /** Gets a valid MP4 file with audio/video tracks and synchronization data. */
   private static byte[] getTestMp4File(boolean mp4vFormat) {
     return Mp4Atom.serialize(
-        atom(Atom.TYPE_ftyp, EMPTY),
+        atom(Atom.TYPE_ftyp, FTYP_PAYLOAD),
         atom(Atom.TYPE_moov,
             atom(Atom.TYPE_mvhd, MVHD_PAYLOAD),
             atom(Atom.TYPE_trak,
@@ -400,13 +403,13 @@ private static int getSampleOffset(int index) {
                             atom(Atom.TYPE_stsc, getStsc()),
                             atom(Atom.TYPE_stsz, getStsz()),
                             atom(Atom.TYPE_stco, getStco())))))),
-        atom(Atom.TYPE_mdat, getMdat(mp4vFormat ? 1168 : 1158, !mp4vFormat)));
+        atom(Atom.TYPE_mdat, getMdat(mp4vFormat ? 1176 : 1166, !mp4vFormat)));
   }
 
   /** Gets a valid MP4 file with audio/video tracks and without a synchronization table. */
   private static byte[] getTestMp4FileWithoutSynchronizationData(boolean mp4vFormat) {
     return Mp4Atom.serialize(
-        atom(Atom.TYPE_ftyp, EMPTY),
+        atom(Atom.TYPE_ftyp, FTYP_PAYLOAD),
         atom(Atom.TYPE_moov,
             atom(Atom.TYPE_mvhd, MVHD_PAYLOAD),
             atom(Atom.TYPE_trak,
@@ -436,7 +439,7 @@ private static int getSampleOffset(int index) {
                             atom(Atom.TYPE_stsc, getStsc()),
                             atom(Atom.TYPE_stsz, getStsz()),
                             atom(Atom.TYPE_stco, getStco())))))),
-        atom(Atom.TYPE_mdat, getMdat(mp4vFormat ? 1112 : 1102, !mp4vFormat)));
+        atom(Atom.TYPE_mdat, getMdat(mp4vFormat ? 1120 : 1110, !mp4vFormat)));
   }
 
   private static Mp4Atom atom(int type, Mp4Atom... containedMp4Atoms) {
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java
index e463a17e82..4011a53e9d 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java
@@ -21,6 +21,7 @@
 import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.drm.DrmInitData;
+import com.google.android.exoplayer.drm.DrmInitData.SchemeInitData;
 import com.google.android.exoplayer.extractor.ChunkIndex;
 import com.google.android.exoplayer.extractor.SeekMap;
 import com.google.android.exoplayer.extractor.webm.StreamBuilder.ContentEncodingSettings;
@@ -237,8 +238,12 @@ public void testPrepareContentEncodingEncryption() throws IOException, Interrupt
     assertIndex(DEFAULT_TIMECODE_SCALE, 1);
     DrmInitData drmInitData = extractorOutput.drmInitData;
     assertNotNull(drmInitData);
-    android.test.MoreAsserts.assertEquals(TEST_ENCRYPTION_KEY_ID, drmInitData.get(WIDEVINE_UUID));
-    android.test.MoreAsserts.assertEquals(TEST_ENCRYPTION_KEY_ID, drmInitData.get(ZERO_UUID));
+    SchemeInitData widevineInitData = drmInitData.get(WIDEVINE_UUID);
+    assertEquals(MimeTypes.VIDEO_WEBM, widevineInitData.mimeType);
+    android.test.MoreAsserts.assertEquals(TEST_ENCRYPTION_KEY_ID, widevineInitData.data);
+    SchemeInitData zeroInitData = drmInitData.get(ZERO_UUID);
+    assertEquals(MimeTypes.VIDEO_WEBM, zeroInitData.mimeType);
+    android.test.MoreAsserts.assertEquals(TEST_ENCRYPTION_KEY_ID, zeroInitData.data);
   }
 
   public void testPrepareThreeCuePoints() throws IOException, InterruptedException {
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java
index beec89e4a6..e4337e9650 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java
@@ -37,6 +37,7 @@ public void testParseMediaPlaylist() {
         + "#EXT-X-VERSION:3\n"
         + "#EXT-X-TARGETDURATION:8\n"
         + "#EXT-X-MEDIA-SEQUENCE:2679\n"
+        + "#EXT-X-DISCONTINUITY-SEQUENCE:4\n"
         + "#EXT-X-ALLOW-CACHE:YES\n"
         + "\n"
         + "#EXTINF:7.975,\n"
@@ -79,7 +80,7 @@ public void testParseMediaPlaylist() {
       assertNotNull(segments);
       assertEquals(5, segments.size());
 
-      assertEquals(false, segments.get(0).discontinuity);
+      assertEquals(4, segments.get(0).discontinuitySequenceNumber);
       assertEquals(7.975, segments.get(0).durationSecs);
       assertEquals(false, segments.get(0).isEncrypted);
       assertEquals(null, segments.get(0).encryptionKeyUri);
@@ -88,7 +89,7 @@ public void testParseMediaPlaylist() {
       assertEquals(0, segments.get(0).byterangeOffset);
       assertEquals("https://priv.example.com/fileSequence2679.ts", segments.get(0).url);
 
-      assertEquals(false, segments.get(1).discontinuity);
+      assertEquals(4, segments.get(1).discontinuitySequenceNumber);
       assertEquals(7.975, segments.get(1).durationSecs);
       assertEquals(true, segments.get(1).isEncrypted);
       assertEquals("https://priv.example.com/key.php?r=2680", segments.get(1).encryptionKeyUri);
@@ -97,7 +98,7 @@ public void testParseMediaPlaylist() {
       assertEquals(51370, segments.get(1).byterangeOffset);
       assertEquals("https://priv.example.com/fileSequence2680.ts", segments.get(1).url);
 
-      assertEquals(false, segments.get(2).discontinuity);
+      assertEquals(4, segments.get(2).discontinuitySequenceNumber);
       assertEquals(7.941, segments.get(2).durationSecs);
       assertEquals(false, segments.get(2).isEncrypted);
       assertEquals(null, segments.get(2).encryptionKeyUri);
@@ -106,7 +107,7 @@ public void testParseMediaPlaylist() {
       assertEquals(102871, segments.get(2).byterangeOffset);
       assertEquals("https://priv.example.com/fileSequence2681.ts", segments.get(2).url);
 
-      assertEquals(true, segments.get(3).discontinuity);
+      assertEquals(5, segments.get(3).discontinuitySequenceNumber);
       assertEquals(7.975, segments.get(3).durationSecs);
       assertEquals(true, segments.get(3).isEncrypted);
       assertEquals("https://priv.example.com/key.php?r=2682", segments.get(3).encryptionKeyUri);
@@ -117,7 +118,7 @@ public void testParseMediaPlaylist() {
       assertEquals(154372, segments.get(3).byterangeOffset);
       assertEquals("https://priv.example.com/fileSequence2682.ts", segments.get(3).url);
 
-      assertEquals(false, segments.get(4).discontinuity);
+      assertEquals(5, segments.get(4).discontinuitySequenceNumber);
       assertEquals(7.975, segments.get(4).durationSecs);
       assertEquals(true, segments.get(4).isEncrypted);
       assertEquals("https://priv.example.com/key.php?r=2682", segments.get(4).encryptionKeyUri);
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java
index 076185019d..8b7f74ad1e 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java
@@ -15,8 +15,6 @@
  */
 package com.google.android.exoplayer.text.subrip;
 
-import com.google.android.exoplayer.ParserException;
-
 import android.test.InstrumentationTestCase;
 
 import java.io.IOException;
@@ -35,7 +33,7 @@
   private static final String NO_END_TIMECODES_FILE = "subrip/no_end_timecodes";
 
   public void testParseEmpty() throws IOException {
-    SubripParser parser = new SubripParser(true);
+    SubripParser parser = new SubripParser();
     InputStream inputStream = getInputStream(EMPTY_FILE);
     SubripSubtitle subtitle = parser.parse(inputStream);
     // Assert that the subtitle is empty.
@@ -44,7 +42,7 @@ public void testParseEmpty() throws IOException {
   }
 
   public void testParseTypical() throws IOException {
-    SubripParser parser = new SubripParser(true);
+    SubripParser parser = new SubripParser();
     InputStream inputStream = getInputStream(TYPICAL_FILE);
     SubripSubtitle subtitle = parser.parse(inputStream);
     assertEquals(6, subtitle.getEventTimeCount());
@@ -54,7 +52,7 @@ public void testParseTypical() throws IOException {
   }
 
   public void testParseTypicalExtraBlankLine() throws IOException {
-    SubripParser parser = new SubripParser(true);
+    SubripParser parser = new SubripParser();
     InputStream inputStream = getInputStream(TYPICAL_EXTRA_BLANK_LINE);
     SubripSubtitle subtitle = parser.parse(inputStream);
     assertEquals(6, subtitle.getEventTimeCount());
@@ -64,19 +62,9 @@ public void testParseTypicalExtraBlankLine() throws IOException {
   }
 
   public void testParseTypicalMissingTimecode() throws IOException {
-    // Strict parsing should fail.
-    SubripParser parser = new SubripParser(true);
+    // Parsing should succeed, parsing the first and third cues only.
+    SubripParser parser = new SubripParser();
     InputStream inputStream = getInputStream(TYPICAL_MISSING_TIMECODE);
-    try {
-      parser.parse(inputStream);
-      fail();
-    } catch (ParserException e) {
-      // Expected.
-    }
-
-    // Non-strict parsing should succeed, parsing the first and third cues only.
-    parser = new SubripParser(false);
-    inputStream = getInputStream(TYPICAL_MISSING_TIMECODE);
     SubripSubtitle subtitle = parser.parse(inputStream);
     assertEquals(4, subtitle.getEventTimeCount());
     assertTypicalCue1(subtitle, 0);
@@ -84,19 +72,9 @@ public void testParseTypicalMissingTimecode() throws IOException {
   }
 
   public void testParseTypicalMissingSequence() throws IOException {
-    // Strict parsing should fail.
-    SubripParser parser = new SubripParser(true);
+    // Parsing should succeed, parsing the first and third cues only.
+    SubripParser parser = new SubripParser();
     InputStream inputStream = getInputStream(TYPICAL_MISSING_SEQUENCE);
-    try {
-      parser.parse(inputStream);
-      fail();
-    } catch (ParserException e) {
-      // Expected.
-    }
-
-    // Non-strict parsing should succeed, parsing the first and third cues only.
-    parser = new SubripParser(false);
-    inputStream = getInputStream(TYPICAL_MISSING_SEQUENCE);
     SubripSubtitle subtitle = parser.parse(inputStream);
     assertEquals(4, subtitle.getEventTimeCount());
     assertTypicalCue1(subtitle, 0);
@@ -104,7 +82,7 @@ public void testParseTypicalMissingSequence() throws IOException {
   }
 
   public void testParseNoEndTimecodes() throws IOException {
-    SubripParser parser = new SubripParser(true);
+    SubripParser parser = new SubripParser();
     InputStream inputStream = getInputStream(NO_END_TIMECODES_FILE);
     SubripSubtitle subtitle = parser.parse(inputStream);
 
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlParserTest.java
index 4133c3ce3d..eef062bce1 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlParserTest.java
@@ -19,10 +19,13 @@
 
 import android.test.InstrumentationTestCase;
 import android.text.Layout;
+import android.text.Spannable;
 import android.text.SpannableStringBuilder;
+import android.text.style.AbsoluteSizeSpan;
 import android.text.style.AlignmentSpan;
 import android.text.style.BackgroundColorSpan;
 import android.text.style.ForegroundColorSpan;
+import android.text.style.RelativeSizeSpan;
 import android.text.style.StrikethroughSpan;
 import android.text.style.StyleSpan;
 import android.text.style.TypefaceSpan;
@@ -56,6 +59,14 @@
       "ttml/namespace_confusion.xml";
   private static final String NAMESPACE_NOT_DECLARED_TTML_FILE =
       "ttml/namespace_not_declared.xml";
+  private static final String FONT_SIZE_TTML_FILE =
+      "ttml/font_size.xml";
+  private static final String FONT_SIZE_MISSING_UNIT_TTML_FILE =
+      "ttml/font_size_no_unit.xml";
+  private static final String FONT_SIZE_INVALID_TTML_FILE =
+      "ttml/font_size_invalid.xml";
+  private static final String FONT_SIZE_EMPTY_TTML_FILE =
+      "ttml/font_size_empty.xml";
 
   public void testInlineAttributes() throws IOException {
     TtmlSubtitle subtitle = getSubtitle(INLINE_ATTRIBUTES_TTML_FILE);
@@ -268,7 +279,91 @@ public void testNamespaceNotDeclared() throws IOException {
     assertEquals("sansSerif", style.getFontFamily());
     assertFalse(style.isUnderline());
     assertTrue(style.isLinethrough());
+  }
+
+  public void testFontSizeSpans() throws IOException {
+    TtmlSubtitle subtitle = getSubtitle(FONT_SIZE_TTML_FILE);
+    assertEquals(10, subtitle.getEventTimeCount());
+
+    List<Cue> cues = subtitle.getCues(10 * 1000000);
+    assertEquals(1, cues.size());
+    SpannableStringBuilder spannable = (SpannableStringBuilder) cues.get(0).text;
+    assertEquals("text 1", String.valueOf(spannable));
+    assertAbsoluteFontSize(spannable, 32);
+
+    cues = subtitle.getCues(20 * 1000000);
+    assertEquals(1, cues.size());
+    spannable = (SpannableStringBuilder) cues.get(0).text;
+    assertEquals("text 2", String.valueOf(cues.get(0).text));
+    assertRelativeFontSize(spannable, 2.2f);
+
+    cues = subtitle.getCues(30 * 1000000);
+    assertEquals(1, cues.size());
+    spannable = (SpannableStringBuilder) cues.get(0).text;
+    assertEquals("text 3", String.valueOf(cues.get(0).text));
+    assertRelativeFontSize(spannable, 1.5f);
+
+    cues = subtitle.getCues(40 * 1000000);
+    assertEquals(1, cues.size());
+    spannable = (SpannableStringBuilder) cues.get(0).text;
+    assertEquals("two values", String.valueOf(cues.get(0).text));
+    assertAbsoluteFontSize(spannable, 16);
+
+    cues = subtitle.getCues(50 * 1000000);
+    assertEquals(1, cues.size());
+    spannable = (SpannableStringBuilder) cues.get(0).text;
+    assertEquals("leading dot", String.valueOf(cues.get(0).text));
+    assertRelativeFontSize(spannable, 0.5f);
+  }
 
+  public void testFontSizeWithMissingUnitIsIgnored() throws IOException {
+    TtmlSubtitle subtitle = getSubtitle(FONT_SIZE_MISSING_UNIT_TTML_FILE);
+    assertEquals(2, subtitle.getEventTimeCount());
+    List<Cue> cues = subtitle.getCues(10 * 1000000);
+    assertEquals(1, cues.size());
+    SpannableStringBuilder spannable = (SpannableStringBuilder) cues.get(0).text;
+    assertEquals("no unit", String.valueOf(spannable));
+    assertEquals(0, spannable.getSpans(0, spannable.length(), RelativeSizeSpan.class).length);
+    assertEquals(0, spannable.getSpans(0, spannable.length(), AbsoluteSizeSpan.class).length);
+  }
+
+  public void testFontSizeWithInvalidValueIsIgnored() throws IOException {
+    TtmlSubtitle subtitle = getSubtitle(FONT_SIZE_INVALID_TTML_FILE);
+    assertEquals(6, subtitle.getEventTimeCount());
+
+    List<Cue> cues = subtitle.getCues(10 * 1000000);
+    assertEquals(1, cues.size());
+    SpannableStringBuilder spannable = (SpannableStringBuilder) cues.get(0).text;
+    assertEquals("invalid", String.valueOf(spannable));
+    assertEquals(0, spannable.getSpans(0, spannable.length(), RelativeSizeSpan.class).length);
+    assertEquals(0, spannable.getSpans(0, spannable.length(), AbsoluteSizeSpan.class).length);
+
+
+    cues = subtitle.getCues(20 * 1000000);
+    assertEquals(1, cues.size());
+    spannable = (SpannableStringBuilder) cues.get(0).text;
+    assertEquals("invalid", String.valueOf(spannable));
+    assertEquals(0, spannable.getSpans(0, spannable.length(), RelativeSizeSpan.class).length);
+    assertEquals(0, spannable.getSpans(0, spannable.length(), AbsoluteSizeSpan.class).length);
+
+
+    cues = subtitle.getCues(30 * 1000000);
+    assertEquals(1, cues.size());
+    spannable = (SpannableStringBuilder) cues.get(0).text;
+    assertEquals("invalid dot", String.valueOf(spannable));
+    assertEquals(0, spannable.getSpans(0, spannable.length(), RelativeSizeSpan.class).length);
+    assertEquals(0, spannable.getSpans(0, spannable.length(), AbsoluteSizeSpan.class).length);
+  }
+
+  public void testFontSizeWithEmptyValueIsIgnored() throws IOException {
+    TtmlSubtitle subtitle = getSubtitle(FONT_SIZE_EMPTY_TTML_FILE);
+    assertEquals(2, subtitle.getEventTimeCount());
+    List<Cue> cues = subtitle.getCues(10 * 1000000);
+    assertEquals(1, cues.size());
+    SpannableStringBuilder spannable = (SpannableStringBuilder) cues.get(0).text;
+    assertEquals("empty", String.valueOf(spannable));
+    assertEquals(0, spannable.getSpans(0, spannable.length(), RelativeSizeSpan.class).length);
+    assertEquals(0, spannable.getSpans(0, spannable.length(), AbsoluteSizeSpan.class).length);
   }
 
   private void assertSpans(TtmlSubtitle subtitle, int second,
@@ -281,26 +376,58 @@ private void assertSpans(TtmlSubtitle subtitle, int second,
 
     assertEquals(1, cues.size());
     assertEquals(text, String.valueOf(cues.get(0).text));
-
     assertEquals("single cue expected for timeUs: " + timeUs, 1, cues.size());
     SpannableStringBuilder spannable = (SpannableStringBuilder) cues.get(0).text;
 
+    assertFont(spannable, font);
+    assertStyle(spannable, fontStyle);
+    assertUnderline(spannable, isUnderline);
+    assertStrikethrough(spannable, isLinethrough);
+    assertUnderline(spannable, isUnderline);
+    assertBackground(spannable, backgroundColor);
+    assertForeground(spannable, color);
+    assertAlignment(spannable, alignment);
+  }
+
+  private void assertAbsoluteFontSize(Spannable spannable, int absoluteFontSize) {
+    AbsoluteSizeSpan[] absoluteSizeSpans = spannable.getSpans(0, spannable.length(),
+        AbsoluteSizeSpan.class);
+    assertEquals(1, absoluteSizeSpans.length);
+    assertEquals(absoluteFontSize, absoluteSizeSpans[0].getSize());
+  }
+
+  private void assertRelativeFontSize(Spannable spannable, float relativeFontSize) {
+    RelativeSizeSpan[] relativeSizeSpans = spannable.getSpans(0, spannable.length(),
+        RelativeSizeSpan.class);
+    assertEquals(1, relativeSizeSpans.length);
+    assertEquals(relativeFontSize, relativeSizeSpans[0].getSizeChange());
+  }
+
+  private void assertFont(Spannable spannable, String font) {
     TypefaceSpan[] typefaceSpans = spannable.getSpans(0, spannable.length(), TypefaceSpan.class);
     assertEquals(font, typefaceSpans[typefaceSpans.length - 1].getFamily());
+  }
 
+  private void assertStyle(Spannable spannable, int fontStyle) {
     StyleSpan[] styleSpans = spannable.getSpans(0, spannable.length(), StyleSpan.class);
     assertEquals(fontStyle, styleSpans[styleSpans.length - 1].getStyle());
+  }
 
+  private void assertUnderline(Spannable spannable, boolean isUnderline) {
     UnderlineSpan[] underlineSpans = spannable.getSpans(0, spannable.length(),
         UnderlineSpan.class);
     assertEquals(isUnderline ? "must be underlined" : "must not be underlined",
         isUnderline ? 1 : 0, underlineSpans.length);
+  }
 
+  private void assertStrikethrough(Spannable spannable, boolean isStrikethrough) {
     StrikethroughSpan[] striketroughSpans = spannable.getSpans(0, spannable.length(),
         StrikethroughSpan.class);
-    assertEquals(isLinethrough ? "must be strikethrough" : "must not be strikethrough",
-        isLinethrough ? 1 : 0, striketroughSpans.length);
+    assertEquals(isStrikethrough ? "must be strikethrough" : "must not be strikethrough",
+        isStrikethrough ? 1 : 0, striketroughSpans.length);
+  }
 
+  private void assertBackground(Spannable spannable, int backgroundColor) {
     BackgroundColorSpan[] backgroundColorSpans =
         spannable.getSpans(0, spannable.length(), BackgroundColorSpan.class);
     if (backgroundColor != 0) {
@@ -309,11 +436,16 @@ private void assertSpans(TtmlSubtitle subtitle, int second,
     } else {
       assertEquals(0, backgroundColorSpans.length);
     }
+  }
 
+  private void assertForeground(Spannable spannable, int foregroundColor) {
     ForegroundColorSpan[] foregroundColorSpans =
         spannable.getSpans(0, spannable.length(), ForegroundColorSpan.class);
-    assertEquals(color, foregroundColorSpans[foregroundColorSpans.length - 1].getForegroundColor());
+    assertEquals(foregroundColor,
+        foregroundColorSpans[foregroundColorSpans.length - 1].getForegroundColor());
+  }
 
+  private void assertAlignment(Spannable spannable, Layout.Alignment alignment) {
     if (alignment != null) {
       AlignmentSpan.Standard[] alignmentSpans =
           spannable.getSpans(0, spannable.length(), AlignmentSpan.Standard.class);
@@ -334,14 +466,13 @@ private TtmlNode queryChildrenForTag(TtmlNode node, String tag, int pos) {
         }
       }
     }
-    return null;
+    throw new IllegalStateException("tag not found");
   }
 
   private TtmlSubtitle getSubtitle(String file) throws IOException {
-    TtmlParser ttmlParser = new TtmlParser(false);
+    TtmlParser ttmlParser = new TtmlParser();
     InputStream inputStream = getInstrumentation().getContext()
         .getResources().getAssets().open(file);
-
     return (TtmlSubtitle) ttmlParser.parse(inputStream);
   }
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlStyleTest.java b/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlStyleTest.java
index c452f68327..12f6a9fe9a 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlStyleTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlStyleTest.java
@@ -59,29 +59,6 @@ public void testChainStyle() {
             BACKGROUND_COLOR, style.getBackgroundColor());
     }
 
-    public void testGetInheritableStyle() {
-        // same instance as long as everything can be inherited
-        assertSame(style, style.getInheritableStyle());
-        style.inherit(createAncestorStyle());
-        assertSame(style, style.getInheritableStyle());
-        // after setting a property which is not inheritable
-        // we expect the inheritable style to be another instance
-        style.setBackgroundColor(0);
-        TtmlStyle inheritableStyle = style.getInheritableStyle();
-        assertNotSame(style, inheritableStyle);
-        // and subsequent call give always the same instance
-        assertSame(inheritableStyle, style.getInheritableStyle());
-
-        boolean exceptionThrown = false;
-        try {
-          // setting properties after calling getInheritableStyle gives an exception
-          style.setItalic(true);
-        } catch (IllegalStateException e) {
-          exceptionThrown = true;
-        }
-        assertTrue(exceptionThrown);
-    }
-
     private TtmlStyle createAncestorStyle() {
         TtmlStyle ancestor = new TtmlStyle();
         ancestor.setId(ID);
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttCueParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttCueParserTest.java
new file mode 100644
index 0000000000..c5d1465b21
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttCueParserTest.java
@@ -0,0 +1,247 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text.webvtt;
+
+import android.graphics.Typeface;
+import android.test.InstrumentationTestCase;
+import android.text.Spanned;
+import android.text.style.StyleSpan;
+import android.text.style.UnderlineSpan;
+
+/**
+ * Unit test for {@link WebvttCueParser}.
+ */
+public final class WebvttCueParserTest extends InstrumentationTestCase {
+
+  public void testParseStrictValidClassesAndTrailingTokens() throws Exception {
+    WebvttCueParser parser = new WebvttCueParser();
+    Spanned text = parser.parse("<v.first.loud Esme>"
+        + "This <u.style1.style2 some stuff>is</u> text with <b.foo><i.bar>html</i></b> tags");
+
+    assertEquals("This is text with html tags", text.toString());
+
+    UnderlineSpan[] underlineSpans = getSpans(text, UnderlineSpan.class);
+    StyleSpan[] styleSpans = getSpans(text, StyleSpan.class);
+    assertEquals(1, underlineSpans.length);
+    assertEquals(2, styleSpans.length);
+    assertEquals(Typeface.ITALIC, styleSpans[0].getStyle());
+    assertEquals(Typeface.BOLD, styleSpans[1].getStyle());
+
+    assertEquals(5, text.getSpanStart(underlineSpans[0]));
+    assertEquals(7, text.getSpanEnd(underlineSpans[0]));
+    assertEquals(18, text.getSpanStart(styleSpans[0]));
+    assertEquals(18, text.getSpanStart(styleSpans[1]));
+    assertEquals(22, text.getSpanEnd(styleSpans[0]));
+    assertEquals(22, text.getSpanEnd(styleSpans[1]));
+  }
+
+  public void testParseStrictValidUnsupportedTagsStrippedOut() throws Exception {
+    WebvttCueParser parser = new WebvttCueParser();
+    Spanned text = parser.parse(
+        "<v.first.loud Esme>This <unsupported>is</unsupported> text with "
+        + "<notsupp><invalid>html</invalid></notsupp> tags");
+
+    assertEquals("This is text with html tags", text.toString());
+    assertEquals(0, getSpans(text, UnderlineSpan.class).length);
+    assertEquals(0, getSpans(text, StyleSpan.class).length);
+  }
+
+  public void testParseWellFormedUnclosedEndAtCueEnd() throws Exception {
+    WebvttCueParser parser = new WebvttCueParser();
+    Spanned text = parser.parse(
+        "An <u some trailing stuff>unclosed u tag with <i>italic</i> inside");
+
+    assertEquals("An unclosed u tag with italic inside", text.toString());
+
+    UnderlineSpan[] underlineSpans = getSpans(text, UnderlineSpan.class);
+    StyleSpan[] styleSpans = getSpans(text, StyleSpan.class);
+    assertEquals(1, underlineSpans.length);
+    assertEquals(1, styleSpans.length);
+    assertEquals(Typeface.ITALIC, styleSpans[0].getStyle());
+
+    assertEquals(3, text.getSpanStart(underlineSpans[0]));
+    assertEquals(23, text.getSpanStart(styleSpans[0]));
+    assertEquals(29, text.getSpanEnd(styleSpans[0]));
+    assertEquals(36, text.getSpanEnd(underlineSpans[0]));
+  }
+
+  public void testParseWellFormedUnclosedEndAtParent() throws Exception {
+    WebvttCueParser parser = new WebvttCueParser();
+    Spanned text = parser.parse(
+        "An unclosed u tag with <i><u>underline and italic</i> inside");
+
+    assertEquals("An unclosed u tag with underline and italic inside", text.toString());
+
+    UnderlineSpan[] underlineSpans = getSpans(text, UnderlineSpan.class);
+    StyleSpan[] styleSpans = getSpans(text, StyleSpan.class);
+    assertEquals(1, underlineSpans.length);
+    assertEquals(1, styleSpans.length);
+
+    assertEquals(23, text.getSpanStart(underlineSpans[0]));
+    assertEquals(23, text.getSpanStart(styleSpans[0]));
+    assertEquals(43, text.getSpanEnd(underlineSpans[0]));
+    assertEquals(43, text.getSpanEnd(styleSpans[0]));
+
+    assertEquals(Typeface.ITALIC, styleSpans[0].getStyle());
+  }
+
+  public void testParseMalformedNestedElements() throws Exception {
+    WebvttCueParser parser = new WebvttCueParser();
+    Spanned text = parser.parse(
+        "<b><u>An unclosed u tag with <i>italic</u> inside</i></b>");
+    assertEquals("An unclosed u tag with italic inside", text.toString());
+
+    UnderlineSpan[] underlineSpans = getSpans(text, UnderlineSpan.class);
+    StyleSpan[] styleSpans = getSpans(text, StyleSpan.class);
+    assertEquals(1, underlineSpans.length);
+    assertEquals(2, styleSpans.length);
+
+    // all tags applied until matching start tag found
+    assertEquals(0, text.getSpanStart(underlineSpans[0]));
+    assertEquals(29, text.getSpanEnd(underlineSpans[0]));
+    if (styleSpans[0].getStyle() == Typeface.BOLD) {
+      assertEquals(0, text.getSpanStart(styleSpans[0]));
+      assertEquals(23, text.getSpanStart(styleSpans[1]));
+      assertEquals(29, text.getSpanEnd(styleSpans[1]));
+      assertEquals(36, text.getSpanEnd(styleSpans[0]));
+    } else {
+      assertEquals(0, text.getSpanStart(styleSpans[1]));
+      assertEquals(23, text.getSpanStart(styleSpans[0]));
+      assertEquals(29, text.getSpanEnd(styleSpans[0]));
+      assertEquals(36, text.getSpanEnd(styleSpans[1]));
+    }
+  }
+
+  public void testParseCloseNonExistingTag() throws Exception {
+    WebvttCueParser parser = new WebvttCueParser();
+    Spanned text = parser.parse("blah<b>blah</i>blah</b>blah");
+    assertEquals("blahblahblahblah", text.toString());
+
+    StyleSpan[] spans = getSpans(text, StyleSpan.class);
+    assertEquals(1, spans.length);
+    assertEquals(Typeface.BOLD, spans[0].getStyle());
+    assertEquals(4, text.getSpanStart(spans[0]));
+    assertEquals(8, text.getSpanEnd(spans[0])); // should be 12 when valid
+  }
+
+  public void testParseEmptyTagName() throws Exception {
+    WebvttCueParser parser = new WebvttCueParser();
+    Spanned text = parser.parse("An unclosed u tag with <>italic inside");
+    assertEquals("An unclosed u tag with italic inside", text.toString());
+  }
+
+  public void testParseEntities() throws Exception {
+    WebvttCueParser parser = new WebvttCueParser();
+    Spanned text = parser.parse("&amp; &gt; &lt; &nbsp;");
+    assertEquals("& > <  ", text.toString());
+  }
+
+  public void testParseEntitiesUnsupported() throws Exception {
+    WebvttCueParser parser = new WebvttCueParser();
+    Spanned text = parser.parse("&noway; &sure;");
+    assertEquals(" ", text.toString());
+  }
+
+  public void testParseEntitiesNotTerminated() throws Exception {
+    WebvttCueParser parser = new WebvttCueParser();
+    Spanned text = parser.parse("&amp here comes text");
+    assertEquals("& here comes text", text.toString());
+  }
+
+  public void testParseEntitiesNotTerminatedUnsupported() throws Exception {
+    WebvttCueParser parser = new WebvttCueParser();
+    Spanned text = parser.parse("&surenot here comes text");
+    assertEquals(" here comes text", text.toString());
+  }
+
+  public void testParseEntitiesNotTerminatedNoSpace() throws Exception {
+    WebvttCueParser parser = new WebvttCueParser();
+    Spanned text = parser.parse("&surenot");
+    assertEquals("&surenot", text.toString());
+  }
+
+  public void testParseVoidTag() throws Exception {
+    WebvttCueParser parser = new WebvttCueParser();
+    Spanned text = parser.parse("here comes<br/> text<br/>");
+    assertEquals("here comes text", text.toString());
+  }
+
+  public void testParseMultipleTagsOfSameKind() {
+    WebvttCueParser parser = new WebvttCueParser();
+    Spanned text = parser.parse("blah <b>blah</b> blah <b>foo</b>");
+
+    assertEquals("blah blah blah foo", text.toString());
+    StyleSpan[] spans = getSpans(text, StyleSpan.class);
+    assertEquals(2, spans.length);
+    assertEquals(5, text.getSpanStart(spans[0]));
+    assertEquals(9, text.getSpanEnd(spans[0]));
+    assertEquals(15, text.getSpanStart(spans[1]));
+    assertEquals(18, text.getSpanEnd(spans[1]));
+    assertEquals(Typeface.BOLD, spans[0].getStyle());
+    assertEquals(Typeface.BOLD, spans[1].getStyle());
+  }
+
+  public void testParseInvalidVoidSlash() {
+    WebvttCueParser parser = new WebvttCueParser();
+    Spanned text = parser.parse("blah <b/.st1.st2 trailing stuff> blah");
+
+    assertEquals("blah  blah", text.toString());
+    StyleSpan[] spans = getSpans(text, StyleSpan.class);
+    assertEquals(0, spans.length);
+  }
+
+  public void testParseMonkey() throws Exception {
+    WebvttCueParser parser = new WebvttCueParser();
+    Spanned text = parser.parse(
+        "< u>An unclosed u tag with <<<<< i>italic</u></u></u></u    ></i><u><u> inside");
+    assertEquals("An unclosed u tag with italic inside", text.toString());
+    text = parser.parse(">>>>>>>>>An unclosed u tag with <<<<< italic</u></u></u></u  >"
+        + "</i><u><u> inside");
+    assertEquals(">>>>>>>>>An unclosed u tag with  inside", text.toString());
+  }
+
+  public void testParseCornerCases() throws Exception {
+    WebvttCueParser parser = new WebvttCueParser();
+    Spanned text = parser.parse(">");
+    assertEquals(">", text.toString());
+
+    text = parser.parse("<");
+    assertEquals("", text.toString());
+
+    text = parser.parse("<b.st1.st2 annotation");
+    assertEquals("", text.toString());
+
+    text = parser.parse("<<<<<<<<<<<<<<<<");
+    assertEquals("", text.toString());
+
+    text = parser.parse("<<<<<<>><<<<<<<<<<");
+    assertEquals(">", text.toString());
+
+    text = parser.parse("<>");
+    assertEquals("", text.toString());
+
+    text = parser.parse("&");
+    assertEquals("&", text.toString());
+
+    text = parser.parse("&&&&&&&");
+    assertEquals("&&&&&&&", text.toString());
+  }
+
+  private static <T> T[] getSpans(Spanned text, Class<T> spanType) {
+    return text.getSpans(0, text.length(), spanType);
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java
index b0d7271c9c..07967e7df7 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java
@@ -33,6 +33,7 @@
   private static final String TYPICAL_WITH_IDS_FILE = "webvtt/typical_with_identifiers";
   private static final String TYPICAL_WITH_COMMENTS_FILE = "webvtt/typical_with_comments";
   private static final String WITH_POSITIONING_FILE = "webvtt/with_positioning";
+  private static final String WITH_BAD_CUE_HEADER_FILE = "webvtt/with_bad_cue_header";
   private static final String WITH_TAGS_FILE = "webvtt/with_tags";
   private static final String EMPTY_FILE = "webvtt/empty";
 
@@ -132,6 +133,20 @@ public void testParseWithPositioning() throws IOException {
         Cue.ANCHOR_TYPE_END, 0.1f);
   }
 
+  public void testParseWithBadCueHeader() throws IOException {
+    WebvttParser parser = new WebvttParser();
+    InputStream inputStream =
+        getInstrumentation().getContext().getResources().getAssets().open(WITH_BAD_CUE_HEADER_FILE);
+    WebvttSubtitle subtitle = parser.parse(inputStream);
+
+    // test event count
+    assertEquals(4, subtitle.getEventTimeCount());
+
+    // test cues
+    assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.");
+    assertCue(subtitle, 2, 4000000, 5000000, "This is the third subtitle.");
+  }
+
   private static void assertCue(WebvttSubtitle subtitle, int eventTimeIndex, long startTimeUs,
       int endTimeUs, String text) {
     assertCue(subtitle, eventTimeIndex, startTimeUs, endTimeUs, text, null, Cue.DIMEN_UNSET,
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/util/ParsableByteArrayTest.java b/library/src/androidTest/java/com/google/android/exoplayer/util/ParsableByteArrayTest.java
index ac3590cd24..235a1a53a3 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/util/ParsableByteArrayTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/util/ParsableByteArrayTest.java
@@ -34,6 +34,31 @@ private static ParsableByteArray getTestDataArray() {
     return testArray;
   }
 
+  public void testReadShort() {
+    testReadShort((short) -1);
+    testReadShort((short) 0);
+    testReadShort((short) 1);
+    testReadShort(Short.MIN_VALUE);
+    testReadShort(Short.MAX_VALUE);
+  }
+
+  private static void testReadShort(short testValue) {
+    ParsableByteArray testArray = new ParsableByteArray(
+        ByteBuffer.allocate(4).putShort(testValue).array());
+    int readValue = testArray.readShort();
+
+    // Assert that the value we read was the value we wrote.
+    assertEquals(testValue, readValue);
+    // And that the position advanced as expected.
+    assertEquals(2, testArray.getPosition());
+
+    // And that skipping back and reading gives the same results.
+    testArray.skipBytes(-2);
+    readValue = testArray.readShort();
+    assertEquals(testValue, readValue);
+    assertEquals(2, testArray.getPosition());
+  }
+
   public void testReadInt() {
     testReadInt(0);
     testReadInt(1);
diff --git a/library/src/androidTest/project.properties b/library/src/androidTest/project.properties
index 0031332ec9..dfce3e9cd6 100644
--- a/library/src/androidTest/project.properties
+++ b/library/src/androidTest/project.properties
@@ -11,6 +11,6 @@
 #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
 
 # Project target.
-target=android-22
+target=android-23
 android.library=false
 android.library.reference.1=../main
diff --git a/library/src/main/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
index b36ae95abe..332b9178d7 100644
--- a/library/src/main/AndroidManifest.xml
+++ b/library/src/main/AndroidManifest.xml
@@ -29,6 +29,6 @@
     the library may be of use on older devices. However, please note that the core video playback
     functionality provided by the library requires API level 16 or greater.
   -->
-  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="22"/>
+  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="23"/>
 
 </manifest>
diff --git a/library/src/main/java/com/google/android/exoplayer/C.java b/library/src/main/java/com/google/android/exoplayer/C.java
index f3c5a11e89..622da04caf 100644
--- a/library/src/main/java/com/google/android/exoplayer/C.java
+++ b/library/src/main/java/com/google/android/exoplayer/C.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer;
 
+import com.google.android.exoplayer.util.Util;
+
 import android.media.AudioFormat;
 import android.media.MediaCodec;
 import android.media.MediaExtractor;
@@ -68,10 +70,24 @@
   @SuppressWarnings("InlinedApi")
   public static final int ENCODING_E_AC3 = AudioFormat.ENCODING_E_AC3;
 
-  // TODO: Switch these constants to use AudioFormat fields when the target API version is >= 23.
-  // The inlined values here are for NVIDIA Shield devices which support DTS on earlier versions.
-  public static final int ENCODING_DTS = 7;
-  public static final int ENCODING_DTS_HD = 8;
+  /**
+   * @see AudioFormat#ENCODING_DTS
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int ENCODING_DTS = AudioFormat.ENCODING_DTS;
+
+  /**
+   * @see AudioFormat#ENCODING_DTS_HD
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int ENCODING_DTS_HD = AudioFormat.ENCODING_DTS_HD;
+
+  /**
+   * @see AudioFormat#CHANNEL_OUT_7POINT1_SURROUND
+   */
+  @SuppressWarnings({"InlinedApi", "deprecation"})
+  public static final int CHANNEL_OUT_7POINT1_SURROUND = Util.SDK_INT < 23
+      ? AudioFormat.CHANNEL_OUT_7POINT1 : AudioFormat.CHANNEL_OUT_7POINT1_SURROUND;
 
   /**
    * @see MediaExtractor#SAMPLE_FLAG_SYNC
diff --git a/library/src/main/java/com/google/android/exoplayer/CodecCounters.java b/library/src/main/java/com/google/android/exoplayer/CodecCounters.java
index f70c4335f9..97b41b33a6 100644
--- a/library/src/main/java/com/google/android/exoplayer/CodecCounters.java
+++ b/library/src/main/java/com/google/android/exoplayer/CodecCounters.java
@@ -31,6 +31,7 @@
   public int renderedOutputBufferCount;
   public int skippedOutputBufferCount;
   public int droppedOutputBufferCount;
+  public int maxConsecutiveDroppedOutputBufferCount;
 
   /**
    * Should be invoked from the playback thread after the counters have been updated. Should also
@@ -52,6 +53,7 @@ public String getDebugString() {
     builder.append(" ren:").append(renderedOutputBufferCount);
     builder.append(" sob:").append(skippedOutputBufferCount);
     builder.append(" dob:").append(droppedOutputBufferCount);
+    builder.append(" mcdob:").append(maxConsecutiveDroppedOutputBufferCount);
     return builder.toString();
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java
index e239cbe442..f6658548a4 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java
@@ -108,7 +108,7 @@ public ExoPlayerImplInternal(Handler eventHandler, boolean playWhenReady,
     trackFormats = new MediaFormat[selectedTrackIndices.length][];
     // Note: The documentation for Process.THREAD_PRIORITY_AUDIO that states "Applications can
     // not normally change to this priority" is incorrect.
-    internalPlaybackThread = new PriorityHandlerThread(getClass().getSimpleName() + ":Handler",
+    internalPlaybackThread = new PriorityHandlerThread("ExoPlayerImplInternal:Handler",
         Process.THREAD_PRIORITY_AUDIO);
     internalPlaybackThread.start();
     handler = new Handler(internalPlaybackThread.getLooper(), this);
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
index 54640a3d38..e64ec76b8d 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
@@ -23,7 +23,7 @@
   /**
    * The version of the library, expressed as a string.
    */
-  public static final String VERSION = "1.5.2";
+  public static final String VERSION = "1.5.3";
 
   /**
    * The version of the library, expressed as an integer.
@@ -31,7 +31,7 @@
    * Three digits are used for each component of {@link #VERSION}. For example "1.2.3" has the
    * corresponding integer version 001002003.
    */
-  public static final int VERSION_INT = 001005002;
+  public static final int VERSION_INT = 001005003;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer.util.Assertions}
diff --git a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
index 6c0cf25b7a..e5ea8f7863 100644
--- a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer.SampleSource.SampleSourceReader;
 import com.google.android.exoplayer.drm.DrmInitData;
+import com.google.android.exoplayer.drm.DrmInitData.SchemeInitData;
 import com.google.android.exoplayer.extractor.ExtractorSampleSource;
 import com.google.android.exoplayer.extractor.mp4.PsshAtomUtil;
 import com.google.android.exoplayer.util.Assertions;
@@ -273,10 +274,10 @@ private DrmInitData getDrmInitDataV18() {
     if (psshInfo == null || psshInfo.isEmpty()) {
       return null;
     }
-    DrmInitData.Mapped drmInitData = new DrmInitData.Mapped(MimeTypes.VIDEO_MP4);
+    DrmInitData.Mapped drmInitData = new DrmInitData.Mapped();
     for (UUID uuid : psshInfo.keySet()) {
       byte[] psshAtom = PsshAtomUtil.buildPsshAtom(uuid, psshInfo.get(uuid));
-      drmInitData.put(uuid, psshAtom);
+      drmInitData.put(uuid, new SchemeInitData(MimeTypes.VIDEO_MP4, psshAtom));
     }
     return drmInitData;
   }
@@ -315,10 +316,10 @@ private static MediaFormat createMediaFormat(android.media.MediaFormat format) {
     }
     long durationUs = format.containsKey(android.media.MediaFormat.KEY_DURATION)
         ? format.getLong(android.media.MediaFormat.KEY_DURATION) : C.UNKNOWN_TIME_US;
-    MediaFormat mediaFormat = new MediaFormat(MediaFormat.NO_VALUE, mimeType, MediaFormat.NO_VALUE,
-        maxInputSize, durationUs, width, height, rotationDegrees, MediaFormat.NO_VALUE,
-        channelCount, sampleRate, language, MediaFormat.OFFSET_SAMPLE_RELATIVE, initializationData,
-        false, MediaFormat.NO_VALUE, MediaFormat.NO_VALUE);
+    MediaFormat mediaFormat = new MediaFormat(null, mimeType, MediaFormat.NO_VALUE, maxInputSize,
+        durationUs, width, height, rotationDegrees, MediaFormat.NO_VALUE, channelCount, sampleRate,
+        language, MediaFormat.OFFSET_SAMPLE_RELATIVE, initializationData, false,
+        MediaFormat.NO_VALUE, MediaFormat.NO_VALUE);
     mediaFormat.setFrameworkFormatV16(format);
     return mediaFormat;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
index 8a9f2881ba..6f641b19e1 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
@@ -24,8 +24,10 @@
 import android.annotation.TargetApi;
 import android.media.AudioManager;
 import android.media.MediaCodec;
+import android.media.PlaybackParams;
 import android.media.audiofx.Virtualizer;
 import android.os.Handler;
+import android.os.SystemClock;
 
 import java.nio.ByteBuffer;
 
@@ -55,6 +57,17 @@
      */
     void onAudioTrackWriteError(AudioTrack.WriteException e);
 
+    /**
+     * Invoked when an {@link AudioTrack} underrun occurs.
+     *
+     * @param bufferSize The size of the {@link AudioTrack}'s buffer, in bytes.
+     * @param bufferSizeMs The size of the {@link AudioTrack}'s buffer, in milliseconds, if it is
+     *     configured for PCM output. -1 if it is configured for passthrough output, as the buffered
+     *     media can have a variable bitrate so the duration may be unknown.
+     * @param elapsedSinceLastFeedMs The time since the {@link AudioTrack} was last fed data.
+     */
+    void onAudioTrackUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs);
+
   }
 
   /**
@@ -64,6 +77,15 @@
    */
   public static final int MSG_SET_VOLUME = 1;
 
+  /**
+   * The type of a message that can be passed to an instance of this class via
+   * {@link ExoPlayer#sendMessage} or {@link ExoPlayer#blockingSendMessage}. The message object
+   * should be a {@link android.media.PlaybackParams}, which will be used to configure the
+   * underlying {@link android.media.AudioTrack}. The message object should not be modified by the
+   * caller after it has been passed
+   */
+  public static final int MSG_SET_PLAYBACK_PARAMS = 2;
+
   /**
    * The name for the raw (passthrough) decoder OMX component.
    */
@@ -77,6 +99,9 @@
   private long currentPositionUs;
   private boolean allowPositionDiscontinuity;
 
+  private boolean audioTrackHasData;
+  private long lastFeedElapsedRealtimeMs;
+
   /**
    * @param source The upstream source from which the renderer obtains samples.
    */
@@ -234,7 +259,7 @@ protected void onEnabled(int track, long positionUs, boolean joining)
   @Override
   protected void onOutputFormatChanged(android.media.MediaFormat outputFormat) {
     boolean passthrough = passthroughMediaFormat != null;
-    audioTrack.reconfigure(passthrough ? passthroughMediaFormat : outputFormat, passthrough);
+    audioTrack.configure(passthrough ? passthroughMediaFormat : outputFormat, passthrough);
   }
 
   /**
@@ -272,8 +297,7 @@ protected boolean isEnded() {
 
   @Override
   protected boolean isReady() {
-    return audioTrack.hasPendingData()
-        || (super.isReady() && getSourceState() == SOURCE_STATE_READY_READ_MAY_FAIL);
+    return audioTrack.hasPendingData() || super.isReady();
   }
 
   @Override
@@ -321,8 +345,8 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
       return true;
     }
 
-    // Initialize and start the audio track now.
     if (!audioTrack.isInitialized()) {
+      // Initialize the AudioTrack now.
       try {
         if (audioSessionId != AudioTrack.SESSION_ID_NOT_SET) {
           audioTrack.initialize(audioSessionId);
@@ -330,20 +354,31 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
           audioSessionId = audioTrack.initialize();
           onAudioSessionId(audioSessionId);
         }
+        audioTrackHasData = false;
       } catch (AudioTrack.InitializationException e) {
         notifyAudioTrackInitializationError(e);
         throw new ExoPlaybackException(e);
       }
-
       if (getState() == TrackRenderer.STATE_STARTED) {
         audioTrack.play();
       }
+    } else {
+      // Check for AudioTrack underrun.
+      boolean audioTrackHadData = audioTrackHasData;
+      audioTrackHasData = audioTrack.hasPendingData();
+      if (audioTrackHadData && !audioTrackHasData && getState() == TrackRenderer.STATE_STARTED) {
+        long elapsedSinceLastFeedMs = SystemClock.elapsedRealtime() - lastFeedElapsedRealtimeMs;
+        long bufferSizeUs = audioTrack.getBufferSizeUs();
+        long bufferSizeMs = bufferSizeUs == C.UNKNOWN_TIME_US ? -1 : bufferSizeUs / 1000;
+        notifyAudioTrackUnderrun(audioTrack.getBufferSize(), bufferSizeMs, elapsedSinceLastFeedMs);
+      }
     }
 
     int handleBufferResult;
     try {
       handleBufferResult = audioTrack.handleBuffer(
           buffer, bufferInfo.offset, bufferInfo.size, bufferInfo.presentationTimeUs);
+      lastFeedElapsedRealtimeMs = SystemClock.elapsedRealtime();
     } catch (AudioTrack.WriteException e) {
       notifyAudioTrackWriteError(e);
       throw new ExoPlaybackException(e);
@@ -376,10 +411,16 @@ protected void handleDiscontinuity() {
 
   @Override
   public void handleMessage(int messageType, Object message) throws ExoPlaybackException {
-    if (messageType == MSG_SET_VOLUME) {
-      audioTrack.setVolume((Float) message);
-    } else {
-      super.handleMessage(messageType, message);
+    switch (messageType) {
+      case MSG_SET_VOLUME:
+        audioTrack.setVolume((Float) message);
+        break;
+      case MSG_SET_PLAYBACK_PARAMS:
+        audioTrack.setPlaybackParams((PlaybackParams) message);
+        break;
+      default:
+        super.handleMessage(messageType, message);
+        break;
     }
   }
 
@@ -405,4 +446,16 @@ public void run() {
     }
   }
 
+  private void notifyAudioTrackUnderrun(final int bufferSize, final long bufferSizeMs,
+      final long elapsedSinceLastFeedMs) {
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable()  {
+        @Override
+        public void run() {
+          eventListener.onAudioTrackUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
+        }
+      });
+    }
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
index f8a2518f88..ff7f9027c6 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
@@ -81,6 +81,16 @@ void onDecoderInitialized(String decoderName, long elapsedRealtimeMs,
     private static final int NO_SUITABLE_DECODER_ERROR = CUSTOM_ERROR_CODE_BASE + 1;
     private static final int DECODER_QUERY_ERROR = CUSTOM_ERROR_CODE_BASE + 2;
 
+    /**
+     * The mime type for which a decoder was being initialized.
+     */
+    public final String mimeType;
+
+    /**
+     * Whether it was required that the decoder support a secure output path.
+     */
+    public final boolean secureDecoderRequired;
+
     /**
      * The name of the decoder that failed to initialize. Null if no suitable decoder was found.
      */
@@ -91,15 +101,20 @@ void onDecoderInitialized(String decoderName, long elapsedRealtimeMs,
      */
     public final String diagnosticInfo;
 
-    public DecoderInitializationException(MediaFormat mediaFormat, Throwable cause, int errorCode) {
+    public DecoderInitializationException(MediaFormat mediaFormat, Throwable cause,
+        boolean secureDecoderRequired, int errorCode) {
       super("Decoder init failed: [" + errorCode + "], " + mediaFormat, cause);
+      this.mimeType = mediaFormat.mimeType;
+      this.secureDecoderRequired = secureDecoderRequired;
       this.decoderName = null;
       this.diagnosticInfo = buildCustomDiagnosticInfo(errorCode);
     }
 
     public DecoderInitializationException(MediaFormat mediaFormat, Throwable cause,
-        String decoderName) {
+        boolean secureDecoderRequired, String decoderName) {
       super("Decoder init failed: " + decoderName + ", " + mediaFormat, cause);
+      this.mimeType = mediaFormat.mimeType;
+      this.secureDecoderRequired = secureDecoderRequired;
       this.decoderName = decoderName;
       this.diagnosticInfo = Util.SDK_INT >= 21 ? getDiagnosticInfoV21(cause) : null;
     }
@@ -313,12 +328,12 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
       decoderInfo = getDecoderInfo(mimeType, requiresSecureDecoder);
     } catch (DecoderQueryException e) {
       notifyAndThrowDecoderInitError(new DecoderInitializationException(format, e,
-          DecoderInitializationException.DECODER_QUERY_ERROR));
+          requiresSecureDecoder, DecoderInitializationException.DECODER_QUERY_ERROR));
     }
 
     if (decoderInfo == null) {
       notifyAndThrowDecoderInitError(new DecoderInitializationException(format, null,
-          DecoderInitializationException.NO_SUITABLE_DECODER_ERROR));
+          requiresSecureDecoder, DecoderInitializationException.NO_SUITABLE_DECODER_ERROR));
     }
 
     String codecName = decoderInfo.name;
@@ -343,7 +358,8 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
       inputBuffers = codec.getInputBuffers();
       outputBuffers = codec.getOutputBuffers();
     } catch (Exception e) {
-      notifyAndThrowDecoderInitError(new DecoderInitializationException(format, e, codecName));
+      notifyAndThrowDecoderInitError(new DecoderInitializationException(format, e,
+          requiresSecureDecoder, codecName));
     }
     codecHotswapTimeMs = getState() == TrackRenderer.STATE_STARTED ?
         SystemClock.elapsedRealtime() : -1;
@@ -450,9 +466,7 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPla
     if (format == null) {
       readFormat(positionUs);
     }
-    if (codec == null && shouldInitCodec()) {
-      maybeInitCodec();
-    }
+    maybeInitCodec();
     if (codec != null) {
       TraceUtil.beginSection("drainAndFeed");
       while (drainOutputBuffer(positionUs, elapsedRealtimeUs)) {}
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
index 8c1a7b3030..8380108f29 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
@@ -183,6 +183,13 @@ private static boolean isCodecUsableDecoder(MediaCodecInfo info, String name,
       return false;
     }
 
+    // Work around broken audio decoders.
+    if ((Util.SDK_INT < 18 && "CIPAACDecoder".equals(name))
+        || (Util.SDK_INT < 18 && "CIPMP3Decoder".equals(name))
+        || (Util.SDK_INT < 20 && "AACDecoder".equals(name))) {
+      return false;
+    }
+
     // Work around an issue where creating a particular MP3 decoder on some devices on platform API
     // version 16 crashes mediaserver.
     if (Util.SDK_INT == 16
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
index caacf82d75..ba10897b56 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
@@ -112,6 +112,7 @@ void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
   private long joiningDeadlineUs;
   private long droppedFrameAccumulationStartTimeMs;
   private int droppedFrameCount;
+  private int consecutiveDroppedFrameCount;
 
   private int pendingRotationDegrees;
   private float pendingPixelWidthHeightRatio;
@@ -220,6 +221,7 @@ protected void onEnabled(int track, long positionUs, boolean joining)
       throws ExoPlaybackException {
     super.onEnabled(track, positionUs, joining);
     renderedFirstFrame = false;
+    consecutiveDroppedFrameCount = 0;
     if (joining && allowedJoiningTimeUs > 0) {
       joiningDeadlineUs = SystemClock.elapsedRealtime() * 1000L + allowedJoiningTimeUs;
     }
@@ -230,6 +232,7 @@ protected void onEnabled(int track, long positionUs, boolean joining)
   protected void seekTo(long positionUs) throws ExoPlaybackException {
     super.seekTo(positionUs);
     renderedFirstFrame = false;
+    consecutiveDroppedFrameCount = 0;
     joiningDeadlineUs = -1;
   }
 
@@ -377,6 +380,7 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
       ByteBuffer buffer, MediaCodec.BufferInfo bufferInfo, int bufferIndex, boolean shouldSkip) {
     if (shouldSkip) {
       skipOutputBuffer(codec, bufferIndex);
+      consecutiveDroppedFrameCount = 0;
       return true;
     }
 
@@ -386,6 +390,7 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
       } else {
         renderOutputBuffer(codec, bufferIndex);
       }
+      consecutiveDroppedFrameCount = 0;
       return true;
     }
 
@@ -416,6 +421,7 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
       // Let the underlying framework time the release.
       if (earlyUs < 50000) {
         renderOutputBufferV21(codec, bufferIndex, adjustedReleaseTimeNs);
+        consecutiveDroppedFrameCount = 0;
         return true;
       }
     } else {
@@ -432,6 +438,7 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
           }
         }
         renderOutputBuffer(codec, bufferIndex);
+        consecutiveDroppedFrameCount = 0;
         return true;
       }
     }
@@ -453,6 +460,9 @@ protected void dropOutputBuffer(MediaCodec codec, int bufferIndex) {
     TraceUtil.endSection();
     codecCounters.droppedOutputBufferCount++;
     droppedFrameCount++;
+    consecutiveDroppedFrameCount++;
+    codecCounters.maxConsecutiveDroppedOutputBufferCount = Math.max(consecutiveDroppedFrameCount,
+        codecCounters.maxConsecutiveDroppedOutputBufferCount);
     if (droppedFrameCount == maxDroppedFrameCountToNotify) {
       maybeNotifyDroppedFrameCount();
     }
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
index f97fbdcdec..23d7985236 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
@@ -40,10 +40,9 @@
   public static final long OFFSET_SAMPLE_RELATIVE = Long.MAX_VALUE;
 
   /**
-   * The identifier for the track represented by the format, or {@link #NO_VALUE} if unknown or not
-   * applicable.
+   * The identifier for the track represented by the format, or null if unknown or not applicable.
    */
-  public final int trackId;
+  public final String trackId;
   /**
    * The mime type of the format.
    */
@@ -139,13 +138,13 @@
   private int hashCode;
   private android.media.MediaFormat frameworkMediaFormat;
 
-  public static MediaFormat createVideoFormat(int trackId, String mimeType, int bitrate,
+  public static MediaFormat createVideoFormat(String trackId, String mimeType, int bitrate,
       int maxInputSize, long durationUs, int width, int height, List<byte[]> initializationData) {
     return createVideoFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         initializationData, NO_VALUE, NO_VALUE);
   }
 
-  public static MediaFormat createVideoFormat(int trackId, String mimeType, int bitrate,
+  public static MediaFormat createVideoFormat(String trackId, String mimeType, int bitrate,
       int maxInputSize, long durationUs, int width, int height, List<byte[]> initializationData,
       int rotationDegrees, float pixelWidthHeightRatio) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
@@ -153,7 +152,7 @@ public static MediaFormat createVideoFormat(int trackId, String mimeType, int bi
         initializationData, false, NO_VALUE, NO_VALUE);
   }
 
-  public static MediaFormat createAudioFormat(int trackId, String mimeType, int bitrate,
+  public static MediaFormat createAudioFormat(String trackId, String mimeType, int bitrate,
       int maxInputSize, long durationUs, int channelCount, int sampleRate,
       List<byte[]> initializationData, String language) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, NO_VALUE, NO_VALUE,
@@ -161,27 +160,27 @@ public static MediaFormat createAudioFormat(int trackId, String mimeType, int bi
         initializationData, false, NO_VALUE, NO_VALUE);
   }
 
-  public static MediaFormat createTextFormat(int trackId, String mimeType, int bitrate,
+  public static MediaFormat createTextFormat(String trackId, String mimeType, int bitrate,
       long durationUs, String language) {
     return createTextFormat(trackId, mimeType, bitrate, durationUs, language,
         OFFSET_SAMPLE_RELATIVE);
   }
 
-  public static MediaFormat createTextFormat(int trackId, String mimeType, int bitrate,
+  public static MediaFormat createTextFormat(String trackId, String mimeType, int bitrate,
       long durationUs, String language, long subsampleOffsetUs) {
     return new MediaFormat(trackId, mimeType, bitrate, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, language, subsampleOffsetUs, null, false, NO_VALUE,
         NO_VALUE);
   }
 
-  public static MediaFormat createFormatForMimeType(int trackId, String mimeType, int bitrate,
+  public static MediaFormat createFormatForMimeType(String trackId, String mimeType, int bitrate,
       long durationUs) {
     return new MediaFormat(trackId, mimeType, bitrate, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, OFFSET_SAMPLE_RELATIVE, null, false, NO_VALUE,
         NO_VALUE);
   }
 
-  /* package */ MediaFormat(int trackId, String mimeType, int bitrate, int maxInputSize,
+  /* package */ MediaFormat(String trackId, String mimeType, int bitrate, int maxInputSize,
       long durationUs, int width, int height, int rotationDegrees, float pixelWidthHeightRatio,
       int channelCount, int sampleRate, String language, long subsampleOffsetUs,
       List<byte[]> initializationData, boolean adaptive, int maxWidth, int maxHeight) {
@@ -229,7 +228,7 @@ public MediaFormat copyWithDurationUs(long durationUs) {
         subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight);
   }
 
-  public MediaFormat copyAsAdaptive() {
+  public MediaFormat copyAsAdaptive(String trackId) {
     return new MediaFormat(trackId, mimeType, NO_VALUE, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, OFFSET_SAMPLE_RELATIVE, null, true, maxWidth,
         maxHeight);
@@ -288,7 +287,7 @@ public String toString() {
   public int hashCode() {
     if (hashCode == 0) {
       int result = 17;
-      result = 31 * result + trackId;
+      result = 31 * result + (trackId == null ? 0 : trackId.hashCode());
       result = 31 * result + (mimeType == null ? 0 : mimeType.hashCode());
       result = 31 * result + bitrate;
       result = 31 * result + maxInputSize;
@@ -326,7 +325,7 @@ public boolean equals(Object obj) {
         || pixelWidthHeightRatio != other.pixelWidthHeightRatio
         || maxWidth != other.maxWidth || maxHeight != other.maxHeight
         || channelCount != other.channelCount || sampleRate != other.sampleRate
-        || trackId != other.trackId || !Util.areEqual(language, other.language)
+        || !Util.areEqual(trackId, other.trackId) || !Util.areEqual(language, other.language)
         || !Util.areEqual(mimeType, other.mimeType)
         || initializationData.size() != other.initializationData.size()) {
       return false;
diff --git a/library/src/main/java/com/google/android/exoplayer/ParserException.java b/library/src/main/java/com/google/android/exoplayer/ParserException.java
index ce47f8aa16..d930701be6 100644
--- a/library/src/main/java/com/google/android/exoplayer/ParserException.java
+++ b/library/src/main/java/com/google/android/exoplayer/ParserException.java
@@ -22,6 +22,10 @@
  */
 public class ParserException extends IOException {
 
+  public ParserException() {
+    super();
+  }
+
   public ParserException(String message) {
     super(message);
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java b/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
index 44159befd0..c82ea25f22 100644
--- a/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
+++ b/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
@@ -26,6 +26,7 @@
 import android.media.AudioManager;
 import android.media.AudioTimestamp;
 import android.media.MediaFormat;
+import android.media.PlaybackParams;
 import android.os.ConditionVariable;
 import android.os.SystemClock;
 import android.util.Log;
@@ -36,19 +37,24 @@
 /**
  * Plays audio data. The implementation delegates to an {@link android.media.AudioTrack} and handles
  * playback position smoothing, non-blocking writes and reconfiguration.
- *
- * <p>If {@link #isInitialized} returns {@code false}, the instance can be {@link #initialize}d.
- * After initialization, start playback by calling {@link #play}.
- *
- * <p>Call {@link #handleBuffer} to write data for playback.
- *
- * <p>Call {@link #handleDiscontinuity} when a buffer is skipped.
- *
- * <p>Call {@link #reconfigure} when the output format changes.
- *
- * <p>Call {@link #reset} to free resources. It is safe to re-{@link #initialize} the instance.
- *
- * <p>Call {@link #release} when the instance will no longer be used.
+ * <p>
+ * Before starting playback, specify the input audio format by calling one of the {@link #configure}
+ * methods and {@link #initialize} the instance, optionally specifying an audio session.
+ * <p>
+ * Call {@link #handleBuffer(ByteBuffer, int, int, long)} to write data to play back, and
+ * {@link #handleDiscontinuity()} when a buffer is skipped. Call {@link #play()} to start playing
+ * back written data.
+ * <p>
+ * Call {@link #configure} again whenever the input format changes. If {@link #isInitialized()}
+ * returns false after calling {@link #configure}, it is necessary to re-{@link #initialize} the
+ * instance before writing more data.
+ * <p>
+ * The underlying framework audio track is created by {@link #initialize} and released
+ * asynchronously by {@link #reset} (and {@link #configure}, unless the format is unchanged).
+ * Reinitialization blocks until releasing the old audio track completes. It is safe to
+ * re-{@link #initialize} the instance after calling {@link #reset()}, without reconfiguration.
+ * <p>
+ * Call {@link #release()} when the instance will no longer be used.
  */
 @TargetApi(16)
 public final class AudioTrack {
@@ -58,7 +64,9 @@
    */
   public static final class InitializationException extends Exception {
 
-    /** The state as reported by {@link android.media.AudioTrack#getState()}. */
+    /**
+     * The state as reported by {@link android.media.AudioTrack#getState()}.
+     */
     public final int audioTrackState;
 
     public InitializationException(
@@ -75,7 +83,9 @@ public InitializationException(
    */
   public static final class WriteException extends Exception {
 
-    /** The value returned from {@link android.media.AudioTrack#write(byte[], int, int)}. */
+    /**
+     * The value returned from {@link android.media.AudioTrack#write(byte[], int, int)}.
+     */
     public final int errorCode;
 
     public WriteException(int errorCode) {
@@ -97,20 +107,32 @@ public InvalidAudioTrackTimestampException(String message) {
 
   }
 
-  /** Returned in the result of {@link #handleBuffer} if the buffer was discontinuous. */
+  /**
+   * Returned in the result of {@link #handleBuffer} if the buffer was discontinuous.
+   */
   public static final int RESULT_POSITION_DISCONTINUITY = 1;
-  /** Returned in the result of {@link #handleBuffer} if the buffer can be released. */
+  /**
+   * Returned in the result of {@link #handleBuffer} if the buffer can be released.
+   */
   public static final int RESULT_BUFFER_CONSUMED = 2;
 
-  /** Represents an unset {@link android.media.AudioTrack} session identifier. */
+  /**
+   * Represents an unset {@link android.media.AudioTrack} session identifier.
+   */
   public static final int SESSION_ID_NOT_SET = 0;
 
-  /** Returned by {@link #getCurrentPositionUs} when the position is not set. */
+  /**
+   * Returned by {@link #getCurrentPositionUs} when the position is not set.
+   */
   public static final long CURRENT_POSITION_NOT_SET = Long.MIN_VALUE;
 
-  /** A minimum length for the {@link android.media.AudioTrack} buffer, in microseconds. */
+  /**
+   * A minimum length for the {@link android.media.AudioTrack} buffer, in microseconds.
+   */
   private static final long MIN_BUFFER_DURATION_US = 250000;
-  /** A maximum length for the {@link android.media.AudioTrack} buffer, in microseconds. */
+  /**
+   * A maximum length for the {@link android.media.AudioTrack} buffer, in microseconds.
+   */
   private static final long MAX_BUFFER_DURATION_US = 750000;
   /**
    * A multiplication factor to apply to the minimum buffer size requested by the underlying
@@ -135,11 +157,6 @@ public InvalidAudioTrackTimestampException(String message) {
    */
   private static final long MAX_LATENCY_US = 5 * C.MICROS_PER_SECOND;
 
-  /**
-   * Value for {@link #passthroughBitrate} before the bitrate has been calculated.
-   */
-  private static final int UNKNOWN_BITRATE = 0;
-
   private static final int START_NOT_SET = 0;
   private static final int START_IN_SYNC = 1;
   private static final int START_NEED_SYNC = 2;
@@ -171,16 +188,20 @@ public InvalidAudioTrackTimestampException(String message) {
   private final long[] playheadOffsets;
   private final AudioTrackUtil audioTrackUtil;
 
-  /** Used to keep the audio session active on pre-V21 builds (see {@link #initialize()}). */
+  /**
+   * Used to keep the audio session active on pre-V21 builds (see {@link #initialize()}).
+   */
   private android.media.AudioTrack keepSessionIdAudioTrack;
 
   private android.media.AudioTrack audioTrack;
   private int sampleRate;
   private int channelConfig;
   private int encoding;
-  private int frameSize;
+  private boolean passthrough;
+  private int pcmFrameSize;
   private int minBufferSize;
   private int bufferSize;
+  private long bufferSizeUs;
 
   private int nextPlayheadOffsetIndex;
   private int playheadOffsetCount;
@@ -190,7 +211,9 @@ public InvalidAudioTrackTimestampException(String message) {
   private long lastTimestampSampleTimeUs;
 
   private Method getLatencyMethod;
-  private long submittedBytes;
+  private long submittedPcmBytes;
+  private long submittedEncodedFrames;
+  private int framesPerEncodedSample;
   private int startMediaTimeState;
   private long startMediaTimeUs;
   private long resumeSystemTimeUs;
@@ -199,12 +222,7 @@ public InvalidAudioTrackTimestampException(String message) {
 
   private byte[] temporaryBuffer;
   private int temporaryBufferOffset;
-  private int temporaryBufferSize;
-
-  /**
-   * Bitrate measured in kilobits per second, if using passthrough.
-   */
-  private int passthroughBitrate;
+  private int bufferBytesRemaining;
 
   /**
    * Creates an audio track with default audio capabilities (no encoded audio passthrough support).
@@ -231,7 +249,9 @@ public AudioTrack(AudioCapabilities audioCapabilities, int streamType) {
         // There's no guarantee this method exists. Do nothing.
       }
     }
-    if (Util.SDK_INT >= 19) {
+    if (Util.SDK_INT >= 23) {
+      audioTrackUtil = new AudioTrackUtilV23();
+    } else if (Util.SDK_INT >= 19) {
       audioTrackUtil = new AudioTrackUtilV19();
     } else {
       audioTrackUtil = new AudioTrackUtil();
@@ -283,7 +303,10 @@ public long getCurrentPositionUs(boolean sourceEnded) {
     if (audioTimestampSet) {
       // How long ago in the past the audio timestamp is (negative if it's in the future).
       long presentationDiff = systemClockUs - (audioTrackUtil.getTimestampNanoTime() / 1000);
-      long framesDiff = durationUsToFrames(presentationDiff);
+      // Fixes such difference if the playback speed is not real time speed.
+      long actualSpeedPresentationDiff = (long) (presentationDiff
+          * audioTrackUtil.getPlaybackSpeed());
+      long framesDiff = durationUsToFrames(actualSpeedPresentationDiff);
       // The position of the frame that's currently being presented.
       long currentFramePosition = audioTrackUtil.getTimestampFramePosition() + framesDiff;
       currentPositionUs = framesToDurationUs(currentFramePosition) + startMediaTimeUs;
@@ -305,6 +328,93 @@ public long getCurrentPositionUs(boolean sourceEnded) {
     return currentPositionUs;
   }
 
+  /**
+   * Configures (or reconfigures) the audio track to play back media in {@code format}, inferring a
+   * buffer size from the format.
+   *
+   * @param format Specifies the channel count and sample rate to play back.
+   * @param passthrough Whether to play back using a passthrough encoding.
+   */
+  public void configure(MediaFormat format, boolean passthrough) {
+    configure(format, passthrough, 0);
+  }
+
+  /**
+   * Configures (or reconfigures) the audio track to play back media in {@code format}.
+   *
+   * @param format Specifies the channel count and sample rate to play back.
+   * @param passthrough Whether to play back using a passthrough encoding.
+   * @param specifiedBufferSize A specific size for the playback buffer in bytes, or 0 to use a
+   *     size inferred from the format.
+   */
+  public void configure(MediaFormat format, boolean passthrough, int specifiedBufferSize) {
+    int channelCount = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT);
+    int channelConfig;
+    switch (channelCount) {
+      case 1:
+        channelConfig = AudioFormat.CHANNEL_OUT_MONO;
+        break;
+      case 2:
+        channelConfig = AudioFormat.CHANNEL_OUT_STEREO;
+        break;
+      case 3:
+        channelConfig = AudioFormat.CHANNEL_OUT_STEREO | AudioFormat.CHANNEL_OUT_FRONT_CENTER;
+        break;
+      case 4:
+        channelConfig = AudioFormat.CHANNEL_OUT_QUAD;
+        break;
+      case 5:
+        channelConfig = AudioFormat.CHANNEL_OUT_QUAD | AudioFormat.CHANNEL_OUT_FRONT_CENTER;
+        break;
+      case 6:
+        channelConfig = AudioFormat.CHANNEL_OUT_5POINT1;
+        break;
+      case 7:
+        channelConfig = AudioFormat.CHANNEL_OUT_5POINT1 | AudioFormat.CHANNEL_OUT_BACK_CENTER;
+        break;
+      case 8:
+        channelConfig = C.CHANNEL_OUT_7POINT1_SURROUND;
+        break;
+      default:
+        throw new IllegalArgumentException("Unsupported channel count: " + channelCount);
+    }
+    int sampleRate = format.getInteger(MediaFormat.KEY_SAMPLE_RATE);
+    String mimeType = format.getString(MediaFormat.KEY_MIME);
+    int encoding = passthrough ? getEncodingForMimeType(mimeType) : AudioFormat.ENCODING_PCM_16BIT;
+    if (isInitialized() && this.sampleRate == sampleRate && this.channelConfig == channelConfig
+        && this.encoding == encoding) {
+      // We already have an audio track with the correct sample rate, encoding and channel config.
+      return;
+    }
+
+    reset();
+
+    this.encoding = encoding;
+    this.passthrough = passthrough;
+    this.sampleRate = sampleRate;
+    this.channelConfig = channelConfig;
+    pcmFrameSize = 2 * channelCount; // 2 bytes per 16 bit sample * number of channels.
+    minBufferSize = android.media.AudioTrack.getMinBufferSize(sampleRate, channelConfig, encoding);
+    Assertions.checkState(minBufferSize != android.media.AudioTrack.ERROR_BAD_VALUE);
+    if (specifiedBufferSize != 0) {
+      bufferSize = specifiedBufferSize;
+    } else if (passthrough) {
+      // TODO: Set the minimum buffer size correctly for encoded output when getMinBufferSize takes
+      // the encoding into account. [Internal: b/25181305]
+      bufferSize = minBufferSize * BUFFER_MULTIPLICATION_FACTOR * 2;
+    } else {
+      int multipliedBufferSize = minBufferSize * BUFFER_MULTIPLICATION_FACTOR;
+      int minAppBufferSize = (int) durationUsToFrames(MIN_BUFFER_DURATION_US) * pcmFrameSize;
+      int maxAppBufferSize = (int) Math.max(minBufferSize,
+          durationUsToFrames(MAX_BUFFER_DURATION_US) * pcmFrameSize);
+      bufferSize = multipliedBufferSize < minAppBufferSize ? minAppBufferSize
+          : multipliedBufferSize > maxAppBufferSize ? maxAppBufferSize
+          : multipliedBufferSize;
+    }
+    bufferSizeUs = passthrough ? C.UNKNOWN_TIME_US
+        : framesToDurationUs(pcmBytesToFrames(bufferSize));
+  }
+
   /**
    * Initializes the audio track for writing new buffers using {@link #handleBuffer}.
    *
@@ -366,76 +476,34 @@ public int initialize(int sessionId) throws InitializationException {
   }
 
   /**
-   * Reconfigures the audio track to play back media in {@code format}, inferring a buffer size from
-   * the format.
+   * Returns the size of this {@link AudioTrack}'s buffer in bytes.
+   * <p>
+   * The value returned from this method may change as a result of calling one of the
+   * {@link #configure} methods.
    *
-   * @param format Specifies the channel count and sample rate to play back.
-   * @param passthrough Whether to play back using a passthrough encoding.
+   * @return The size of the buffer in bytes.
    */
-  public void reconfigure(MediaFormat format, boolean passthrough) {
-    reconfigure(format, passthrough, 0);
+  public int getBufferSize() {
+    return bufferSize;
   }
 
   /**
-   * Reconfigures the audio track to play back media in {@code format}.
+   * Returns the size of the buffer in microseconds for PCM {@link AudioTrack}s, or
+   * {@link C#UNKNOWN_TIME_US} for passthrough {@link AudioTrack}s.
+   * <p>
+   * The value returned from this method may change as a result of calling one of the
+   * {@link #configure} methods.
    *
-   * @param format Specifies the channel count and sample rate to play back.
-   * @param passthrough Whether to playback using a passthrough encoding.
-   * @param specifiedBufferSize A specific size for the playback buffer in bytes, or 0 to use a
-   *     size inferred from the format.
+   * @return The size of the buffer in microseconds for PCM {@link AudioTrack}s, or
+   *     {@link C#UNKNOWN_TIME_US} for passthrough {@link AudioTrack}s.
    */
-  public void reconfigure(MediaFormat format, boolean passthrough, int specifiedBufferSize) {
-    int channelCount = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT);
-    int channelConfig;
-    switch (channelCount) {
-      case 1:
-        channelConfig = AudioFormat.CHANNEL_OUT_MONO;
-        break;
-      case 2:
-        channelConfig = AudioFormat.CHANNEL_OUT_STEREO;
-        break;
-      case 6:
-        channelConfig = AudioFormat.CHANNEL_OUT_5POINT1;
-        break;
-      case 8:
-        channelConfig = AudioFormat.CHANNEL_OUT_7POINT1;
-        break;
-      default:
-        throw new IllegalArgumentException("Unsupported channel count: " + channelCount);
-    }
-    int sampleRate = format.getInteger(MediaFormat.KEY_SAMPLE_RATE);
-    String mimeType = format.getString(MediaFormat.KEY_MIME);
-    int encoding = passthrough ? getEncodingForMimeType(mimeType) : AudioFormat.ENCODING_PCM_16BIT;
-    if (isInitialized() && this.sampleRate == sampleRate && this.channelConfig == channelConfig
-        && this.encoding == encoding) {
-      // We already have an audio track with the correct sample rate, encoding and channel config.
-      return;
-    }
-
-    reset();
-
-    this.encoding = encoding;
-    this.sampleRate = sampleRate;
-    this.channelConfig = channelConfig;
-    passthroughBitrate = UNKNOWN_BITRATE;
-    frameSize = 2 * channelCount; // 2 bytes per 16 bit sample * number of channels.
-    minBufferSize = android.media.AudioTrack.getMinBufferSize(sampleRate, channelConfig, encoding);
-    Assertions.checkState(minBufferSize != android.media.AudioTrack.ERROR_BAD_VALUE);
-
-    if (specifiedBufferSize != 0) {
-      bufferSize = specifiedBufferSize;
-    } else {
-      int multipliedBufferSize = minBufferSize * BUFFER_MULTIPLICATION_FACTOR;
-      int minAppBufferSize = (int) durationUsToFrames(MIN_BUFFER_DURATION_US) * frameSize;
-      int maxAppBufferSize = (int) Math.max(minBufferSize,
-          durationUsToFrames(MAX_BUFFER_DURATION_US) * frameSize);
-      bufferSize = multipliedBufferSize < minAppBufferSize ? minAppBufferSize
-          : multipliedBufferSize > maxAppBufferSize ? maxAppBufferSize
-          : multipliedBufferSize;
-    }
+  public long getBufferSizeUs() {
+    return bufferSizeUs;
   }
 
-  /** Starts/resumes playing audio if the audio track has been initialized. */
+  /**
+   * Starts or resumes playing audio if the audio track has been initialized.
+   */
   public void play() {
     if (isInitialized()) {
       resumeSystemTimeUs = System.nanoTime() / 1000;
@@ -443,7 +511,9 @@ public void play() {
     }
   }
 
-  /** Signals to the audio track that the next buffer is discontinuous with the previous buffer. */
+  /**
+   * Signals to the audio track that the next buffer is discontinuous with the previous buffer.
+   */
   public void handleDiscontinuity() {
     // Force resynchronization after a skipped buffer.
     if (startMediaTimeState == START_IN_SYNC) {
@@ -489,27 +559,25 @@ public int handleBuffer(ByteBuffer buffer, int offset, int size, long presentati
     }
 
     int result = 0;
-    if (temporaryBufferSize == 0) {
-      if (passthroughBitrate == UNKNOWN_BITRATE) {
-        if (isAc3Passthrough()) {
-          passthroughBitrate = Ac3Util.getBitrate(size, sampleRate);
-        } else if (isDtsPassthrough()) {
-          int unscaledBitrate = size * 8 * sampleRate;
-          int divisor = 1000 * 512;
-          passthroughBitrate = (unscaledBitrate + divisor / 2) / divisor;
-        }
+    if (bufferBytesRemaining == 0) {
+      // The previous buffer (if there was one) was fully written to the audio track. We're now
+      // seeing a new buffer for the first time.
+      bufferBytesRemaining = size;
+      buffer.position(offset);
+      if (passthrough && framesPerEncodedSample == 0) {
+        // If this is the first encoded sample, calculate the sample size in frames.
+        framesPerEncodedSample = getFramesPerEncodedSample(encoding, buffer);
       }
-
-      // This is the first time we've seen this {@code buffer}.
+      long frames = passthrough ? framesPerEncodedSample : pcmBytesToFrames(size);
+      long bufferDurationUs = framesToDurationUs(frames);
       // Note: presentationTimeUs corresponds to the end of the sample, not the start.
-      long bufferStartTime = presentationTimeUs - framesToDurationUs(bytesToFrames(size));
+      long bufferStartTime = presentationTimeUs - bufferDurationUs;
       if (startMediaTimeState == START_NOT_SET) {
         startMediaTimeUs = Math.max(0, bufferStartTime);
         startMediaTimeState = START_IN_SYNC;
       } else {
         // Sanity check that bufferStartTime is consistent with the expected value.
-        long expectedBufferStartTime = startMediaTimeUs
-            + framesToDurationUs(bytesToFrames(submittedBytes));
+        long expectedBufferStartTime = startMediaTimeUs + framesToDurationUs(getSubmittedFrames());
         if (startMediaTimeState == START_IN_SYNC
             && Math.abs(expectedBufferStartTime - bufferStartTime) > 200000) {
           Log.e(TAG, "Discontinuity detected [expected " + expectedBufferStartTime + ", got "
@@ -524,11 +592,6 @@ public int handleBuffer(ByteBuffer buffer, int offset, int size, long presentati
           result |= RESULT_POSITION_DISCONTINUITY;
         }
       }
-    }
-
-    if (temporaryBufferSize == 0) {
-      temporaryBufferSize = size;
-      buffer.position(offset);
       if (Util.SDK_INT < 21) {
         // Copy {@code buffer} into {@code temporaryBuffer}.
         if (temporaryBuffer == null || temporaryBuffer.length < size) {
@@ -540,29 +603,34 @@ public int handleBuffer(ByteBuffer buffer, int offset, int size, long presentati
     }
 
     int bytesWritten = 0;
-    if (Util.SDK_INT < 21) {
+    if (Util.SDK_INT < 21) { // passthrough == false
       // Work out how many bytes we can write without the risk of blocking.
       int bytesPending =
-          (int) (submittedBytes - (audioTrackUtil.getPlaybackHeadPosition() * frameSize));
+          (int) (submittedPcmBytes - (audioTrackUtil.getPlaybackHeadPosition() * pcmFrameSize));
       int bytesToWrite = bufferSize - bytesPending;
       if (bytesToWrite > 0) {
-        bytesToWrite = Math.min(temporaryBufferSize, bytesToWrite);
+        bytesToWrite = Math.min(bufferBytesRemaining, bytesToWrite);
         bytesWritten = audioTrack.write(temporaryBuffer, temporaryBufferOffset, bytesToWrite);
         if (bytesWritten >= 0) {
           temporaryBufferOffset += bytesWritten;
         }
       }
     } else {
-      bytesWritten = writeNonBlockingV21(audioTrack, buffer, temporaryBufferSize);
+      bytesWritten = writeNonBlockingV21(audioTrack, buffer, bufferBytesRemaining);
     }
 
     if (bytesWritten < 0) {
       throw new WriteException(bytesWritten);
     }
 
-    temporaryBufferSize -= bytesWritten;
-    submittedBytes += bytesWritten;
-    if (temporaryBufferSize == 0) {
+    bufferBytesRemaining -= bytesWritten;
+    if (!passthrough) {
+      submittedPcmBytes += bytesWritten;
+    }
+    if (bufferBytesRemaining == 0) {
+      if (passthrough) {
+        submittedEncodedFrames += framesPerEncodedSample;
+      }
       result |= RESULT_BUFFER_CONSUMED;
     }
     return result;
@@ -574,7 +642,7 @@ public int handleBuffer(ByteBuffer buffer, int offset, int size, long presentati
    */
   public void handleEndOfStream() {
     if (isInitialized()) {
-      audioTrackUtil.handleEndOfStream(bytesToFrames(submittedBytes));
+      audioTrackUtil.handleEndOfStream(getSubmittedFrames());
     }
   }
 
@@ -584,14 +652,29 @@ private static int writeNonBlockingV21(
     return audioTrack.write(buffer, size, android.media.AudioTrack.WRITE_NON_BLOCKING);
   }
 
-  /** Returns whether the audio track has more data pending that will be played back. */
+  /**
+   * Returns whether the audio track has more data pending that will be played back.
+   */
   public boolean hasPendingData() {
     return isInitialized()
-        && (bytesToFrames(submittedBytes) > audioTrackUtil.getPlaybackHeadPosition()
-            || overrideHasPendingData());
+        && (getSubmittedFrames() > audioTrackUtil.getPlaybackHeadPosition()
+        || overrideHasPendingData());
   }
 
-  /** Sets the playback volume. */
+  /**
+   * Sets the playback parameters. Only available for SDK_INT >= 23
+   *
+   * @throws UnsupportedOperationException if the Playback Parameters are not supported. That is,
+   *     SDK_INT < 23.
+   */
+  public void setPlaybackParams(PlaybackParams playbackParams) {
+    audioTrackUtil.setPlaybackParameters(playbackParams);
+  }
+
+
+  /**
+   * Sets the playback volume.
+   */
   public void setVolume(float volume) {
     if (this.volume != volume) {
       this.volume = volume;
@@ -619,7 +702,9 @@ private static void setAudioTrackVolumeV3(android.media.AudioTrack audioTrack, f
     audioTrack.setStereoVolume(volume, volume);
   }
 
-  /** Pauses playback. */
+  /**
+   * Pauses playback.
+   */
   public void pause() {
     if (isInitialized()) {
       resetSyncParams();
@@ -634,8 +719,10 @@ public void pause() {
    */
   public void reset() {
     if (isInitialized()) {
-      submittedBytes = 0;
-      temporaryBufferSize = 0;
+      submittedPcmBytes = 0;
+      submittedEncodedFrames = 0;
+      framesPerEncodedSample = 0;
+      bufferBytesRemaining = 0;
       startMediaTimeState = START_NOT_SET;
       latencyUs = 0;
       resetSyncParams();
@@ -662,13 +749,17 @@ public void run() {
     }
   }
 
-  /** Releases all resources associated with this instance. */
+  /**
+   * Releases all resources associated with this instance.
+   */
   public void release() {
     reset();
     releaseKeepSessionIdAudioTrack();
   }
 
-  /** Releases {@link #keepSessionIdAudioTrack} asynchronously, if it is non-{@code null}. */
+  /**
+   * Releases {@link #keepSessionIdAudioTrack} asynchronously, if it is non-{@code null}.
+   */
   private void releaseKeepSessionIdAudioTrack() {
     if (keepSessionIdAudioTrack == null) {
       return;
@@ -685,7 +776,9 @@ public void run() {
     }.start();
   }
 
-  /** Returns whether {@link #getCurrentPositionUs} can return the current playback position. */
+  /**
+   * Returns whether {@link #getCurrentPositionUs} can return the current playback position.
+   */
   private boolean hasCurrentPositionUs() {
     return isInitialized() && startMediaTimeState != START_NOT_SET;
   }
@@ -752,12 +845,12 @@ private void maybeSampleSyncParams() {
           audioTimestampSet = false;
         }
       }
-      if (getLatencyMethod != null) {
+      if (getLatencyMethod != null && !passthrough) {
         try {
           // Compute the audio track latency, excluding the latency due to the buffer (leaving
           // latency due to the mixer and audio hardware driver).
           latencyUs = (Integer) getLatencyMethod.invoke(audioTrack, (Object[]) null) * 1000L
-              - framesToDurationUs(bytesToFrames(bufferSize));
+              - bufferSizeUs;
           // Sanity check that the latency is non-negative.
           latencyUs = Math.max(latencyUs, 0);
           // Sanity check that the latency isn't too large.
@@ -799,13 +892,8 @@ private void checkAudioTrackInitialized() throws InitializationException {
     throw new InitializationException(state, sampleRate, channelConfig, bufferSize);
   }
 
-  private long bytesToFrames(long byteCount) {
-    if (isPassthrough()) {
-      return passthroughBitrate == UNKNOWN_BITRATE
-          ? 0L : byteCount * 8 * sampleRate / (1000 * passthroughBitrate);
-    } else {
-      return byteCount / frameSize;
-    }
+  private long pcmBytesToFrames(long byteCount) {
+    return byteCount / pcmFrameSize;
   }
 
   private long framesToDurationUs(long frameCount) {
@@ -816,6 +904,10 @@ private long durationUsToFrames(long durationUs) {
     return (durationUs * sampleRate) / C.MICROS_PER_SECOND;
   }
 
+  private long getSubmittedFrames() {
+    return passthrough ? submittedEncodedFrames : pcmBytesToFrames(submittedPcmBytes);
+  }
+
   private void resetSyncParams() {
     smoothedPlayheadOffsetUs = 0;
     playheadOffsetCount = 0;
@@ -825,24 +917,12 @@ private void resetSyncParams() {
     lastTimestampSampleTimeUs = 0;
   }
 
-  private boolean isPassthrough() {
-    return isAc3Passthrough() || isDtsPassthrough();
-  }
-
-  private boolean isAc3Passthrough() {
-    return encoding == C.ENCODING_AC3 || encoding == C.ENCODING_E_AC3;
-  }
-
-  private boolean isDtsPassthrough() {
-    return encoding == C.ENCODING_DTS || encoding == C.ENCODING_DTS_HD;
-  }
-
   /**
    * Returns whether to work around problems with passthrough audio tracks.
    * See [Internal: b/18899620, b/19187573, b/21145353].
    */
   private boolean needsPassthroughWorkarounds() {
-    return Util.SDK_INT < 23 && isAc3Passthrough();
+    return Util.SDK_INT < 23 && (encoding == C.ENCODING_AC3 || encoding == C.ENCODING_E_AC3);
   }
 
   /**
@@ -861,7 +941,7 @@ private static int getEncodingForMimeType(String mimeType) {
     switch (mimeType) {
       case MimeTypes.AUDIO_AC3:
         return C.ENCODING_AC3;
-      case MimeTypes.AUDIO_EC3:
+      case MimeTypes.AUDIO_E_AC3:
         return C.ENCODING_E_AC3;
       case MimeTypes.AUDIO_DTS:
         return C.ENCODING_DTS;
@@ -872,6 +952,21 @@ private static int getEncodingForMimeType(String mimeType) {
     }
   }
 
+  private static int getFramesPerEncodedSample(int encoding, ByteBuffer buffer) {
+    if (encoding == C.ENCODING_DTS || encoding == C.ENCODING_DTS_HD) {
+      // Calculate the sample size in frames as per ETSI TS 102 114 F.3.2.1.
+      int nblks = ((buffer.get(buffer.position() + 4) & 0x01) << 6)
+          | ((buffer.get(buffer.position() + 5) & 0xFC) >> 2);
+      return (nblks + 1) * 32;
+    } else if (encoding == C.ENCODING_AC3) {
+      return Ac3Util.getAc3SyncframeAudioSampleCount();
+    } else if (encoding == C.ENCODING_E_AC3) {
+      return Ac3Util.parseEAc3SyncframeAudioSampleCount(buffer);
+    } else {
+      throw new IllegalStateException("Unexpected audio encoding: " + encoding);
+    }
+  }
+
   /**
    * Wraps an {@link android.media.AudioTrack} to expose useful utility methods.
    */
@@ -1022,6 +1117,27 @@ public long getTimestampFramePosition() {
       throw new UnsupportedOperationException();
     }
 
+    /**
+     * Sets the Playback Parameters to be used by the underlying {@link android.media.AudioTrack}.
+     *
+     * @param playbackParams to be used by the {@link android.media.AudioTrack}.
+     * @throws UnsupportedOperationException If Playback Parameters are not supported
+     *     (i.e. SDK_INT < 23).
+     */
+    public void setPlaybackParameters(PlaybackParams playbackParams) {
+      throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Returns the configured playback speed according to the used Playback Parameters. If these are
+     * not supported, 1.0f(normal speed) is returned.
+     *
+     * @return The speed factor used by the underlying {@link android.media.AudioTrack}.
+     */
+    public float getPlaybackSpeed() {
+      return 1.0f;
+    }
+
   }
 
   @TargetApi(19)
@@ -1073,4 +1189,43 @@ public long getTimestampFramePosition() {
 
   }
 
+  @TargetApi(23)
+  private static class AudioTrackUtilV23 extends AudioTrackUtilV19 {
+
+    private PlaybackParams playbackParams;
+    private float playbackSpeed;
+
+    public AudioTrackUtilV23() {
+      playbackSpeed = 1.0f;
+    }
+
+    @Override
+    public void reconfigure(android.media.AudioTrack audioTrack,
+        boolean needsPassthroughWorkaround) {
+      super.reconfigure(audioTrack, needsPassthroughWorkaround);
+      maybeApplyPlaybackParams();
+    }
+
+    @Override
+    public void setPlaybackParameters(PlaybackParams playbackParams) {
+      playbackParams = (playbackParams != null ? playbackParams : new PlaybackParams())
+          .allowDefaults();
+      this.playbackParams = playbackParams;
+      this.playbackSpeed = playbackParams.getSpeed();
+      maybeApplyPlaybackParams();
+    }
+
+    @Override
+    public float getPlaybackSpeed() {
+      return playbackSpeed;
+    }
+
+    private void maybeApplyPlaybackParams() {
+      if (audioTrack != null && playbackParams != null) {
+        audioTrack.setPlaybackParams(playbackParams);
+      }
+    }
+
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
index 71c5773db1..d9c9aa6cec 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
@@ -89,11 +89,25 @@
   private MediaFormat downstreamMediaFormat;
   private Format downstreamFormat;
 
+  /**
+   * @param chunkSource A {@link ChunkSource} from which chunks to load are obtained.
+   * @param loadControl Controls when the source is permitted to load data.
+   * @param bufferSizeContribution The contribution of this source to the media buffer, in bytes.
+   */
   public ChunkSampleSource(ChunkSource chunkSource, LoadControl loadControl,
       int bufferSizeContribution) {
     this(chunkSource, loadControl, bufferSizeContribution, null, null, 0);
   }
 
+  /**
+   * @param chunkSource A {@link ChunkSource} from which chunks to load are obtained.
+   * @param loadControl Controls when the source is permitted to load data.
+   * @param bufferSizeContribution The contribution of this source to the media buffer, in bytes.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param eventSourceId An identifier that gets passed to {@code eventListener} methods.
+   */
   public ChunkSampleSource(ChunkSource chunkSource, LoadControl loadControl,
       int bufferSizeContribution, Handler eventHandler, EventListener eventListener,
       int eventSourceId) {
@@ -101,6 +115,17 @@ public ChunkSampleSource(ChunkSource chunkSource, LoadControl loadControl,
         eventSourceId, DEFAULT_MIN_LOADABLE_RETRY_COUNT);
   }
 
+  /**
+   * @param chunkSource A {@link ChunkSource} from which chunks to load are obtained.
+   * @param loadControl Controls when the source is permitted to load data.
+   * @param bufferSizeContribution The contribution of this source to the media buffer, in bytes.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param eventSourceId An identifier that gets passed to {@code eventListener} methods.
+   * @param minLoadableRetryCount The minimum number of times that the source should retry a load
+   *     before propagating an error.
+   */
   public ChunkSampleSource(ChunkSource chunkSource, LoadControl loadControl,
       int bufferSizeContribution, Handler eventHandler, EventListener eventListener,
       int eventSourceId, int minLoadableRetryCount) {
@@ -533,7 +558,8 @@ private void maybeStartLoading() {
   private void doChunkOperation() {
     currentLoadableHolder.endOfStream = false;
     currentLoadableHolder.queueSize = readOnlyMediaChunks.size();
-    chunkSource.getChunkOperation(readOnlyMediaChunks, pendingResetPositionUs, downstreamPositionUs,
+    chunkSource.getChunkOperation(readOnlyMediaChunks,
+        pendingResetPositionUs != NO_RESET_PENDING ? pendingResetPositionUs : downstreamPositionUs,
         currentLoadableHolder);
     loadingFinished = currentLoadableHolder.endOfStream;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSource.java b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSource.java
index b90fc5bf15..922025aae2 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSource.java
@@ -92,9 +92,9 @@
    * This method should only be called when the source is enabled.
    *
    * @param queue A representation of the currently buffered {@link MediaChunk}s.
-   * @param seekPositionUs If the queue is empty, this parameter must specify the seek position. If
-   *     the queue is non-empty then this parameter is ignored.
-   * @param playbackPositionUs The current playback position.
+   * @param playbackPositionUs The current playback position. If the queue is empty then this
+   *     parameter is the position from which playback is expected to start (or restart) and hence
+   *     should be interpreted as a seek position.
    * @param out A holder for the next operation, whose {@link ChunkOperationHolder#endOfStream} is
    *     initially set to false, whose {@link ChunkOperationHolder#queueSize} is initially equal to
    *     the length of the queue, and whose {@link ChunkOperationHolder#chunk} is initially equal to
@@ -103,8 +103,8 @@
    *     unchanged. Note that leaving the chunk unchanged is both preferred and more efficient than
    *     replacing it with a new but identical chunk.
    */
-  void getChunkOperation(List<? extends MediaChunk> queue, long seekPositionUs,
-      long playbackPositionUs, ChunkOperationHolder out);
+  void getChunkOperation(List<? extends MediaChunk> queue, long playbackPositionUs,
+      ChunkOperationHolder out);
 
   /**
    * Invoked when the {@link ChunkSampleSource} has finished loading a chunk obtained from this
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/Format.java b/library/src/main/java/com/google/android/exoplayer/chunk/Format.java
index 0c9df38712..b7feded311 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/Format.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/Format.java
@@ -123,7 +123,6 @@ public Format(String id, String mimeType, int width, int height, float frameRate
         null);
   }
 
-
   /**
    * @param id The format identifier.
    * @param mimeType The format mime type.
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleChunkSource.java b/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleChunkSource.java
index c8662cc12c..12fd645fa9 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleChunkSource.java
@@ -80,8 +80,8 @@ public void continueBuffering(long playbackPositionUs) {
   }
 
   @Override
-  public void getChunkOperation(List<? extends MediaChunk> queue, long seekPositionUs,
-      long playbackPositionUs, ChunkOperationHolder out) {
+  public void getChunkOperation(List<? extends MediaChunk> queue, long playbackPositionUs,
+      ChunkOperationHolder out) {
     if (!queue.isEmpty()) {
       // We've already provided the single sample.
       out.endOfStream = true;
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java b/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
index f9a4aae6b7..37b2aa42a7 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer.MediaCodecUtil;
 import com.google.android.exoplayer.MediaCodecUtil.DecoderQueryException;
+import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.Util;
 
 import android.annotation.TargetApi;
@@ -81,10 +82,10 @@
    *     viewport during playback.
    * @param viewportWidth The width in pixels of the viewport within which the video will be
    *     displayed. If the viewport size may change, this should be set to the maximum possible
-   *     width.
+   *     width. -1 if selection should not be constrained by a viewport.
    * @param viewportHeight The height in pixels of the viewport within which the video will be
    *     displayed. If the viewport size may change, this should be set to the maximum possible
-   *     height.
+   *     height. -1 if selection should not be constrained by a viewport.
    * @return An array holding the indices of the selected formats.
    * @throws DecoderQueryException
    */
@@ -106,7 +107,7 @@
         // Keep track of the number of pixels of the selected format whose resolution is the
         // smallest to exceed the maximum size at which it can be displayed within the viewport.
         // We'll discard formats of higher resolution in a second pass.
-        if (format.width > 0 && format.height > 0) {
+        if (format.width > 0 && format.height > 0 && viewportWidth > 0 && viewportHeight > 0) {
           Point maxVideoSizeInViewport = getMaxVideoSizeInViewport(orientationMayChange,
               viewportWidth, viewportHeight, format.width, format.height);
           int videoPixels = format.width * format.height;
@@ -122,11 +123,13 @@
     // Second pass to filter out formats that exceed maxVideoPixelsToRetain. These formats are have
     // unnecessarily high resolution given the size at which the video will be displayed within the
     // viewport.
-    for (int i = selectedIndexList.size() - 1; i >= 0; i--) {
-      Format format = formatWrappers.get(selectedIndexList.get(i)).getFormat();
-      if (format.width > 0 && format.height > 0
-          && format.width * format.height > maxVideoPixelsToRetain) {
-        selectedIndexList.remove(i);
+    if (maxVideoPixelsToRetain != Integer.MAX_VALUE) {
+      for (int i = selectedIndexList.size() - 1; i >= 0; i--) {
+        Format format = formatWrappers.get(selectedIndexList.get(i)).getFormat();
+        if (format.width > 0 && format.height > 0
+            && format.width * format.height > maxVideoPixelsToRetain) {
+          selectedIndexList.remove(i);
+        }
       }
     }
 
@@ -138,7 +141,7 @@
    * whether HD formats should be filtered and a maximum decodable frame size in pixels.
    */
   private static boolean isFormatPlayable(Format format, String[] allowedContainerMimeTypes,
-      boolean filterHdFormats, int maxDecodableFrameSize) {
+      boolean filterHdFormats, int maxDecodableFrameSize) throws DecoderQueryException {
     if (allowedContainerMimeTypes != null
         && !Util.contains(allowedContainerMimeTypes, format.mimeType)) {
       // Filtering format based on its container mime type.
@@ -149,9 +152,13 @@ private static boolean isFormatPlayable(Format format, String[] allowedContainer
       return false;
     }
     if (format.width > 0 && format.height > 0) {
-      // TODO: Use MediaCodecUtil.isSizeAndRateSupportedV21 on API levels >= 21 if we know the
-      // mimeType of the media samples within the container. Remove the assumption that we're
-      // dealing with H.264.
+      String videoMediaMimeType = MimeTypes.getVideoMediaMimeType(format.codecs);
+      if (Util.SDK_INT >= 21 && !MimeTypes.VIDEO_UNKNOWN.equals(videoMediaMimeType)) {
+        float frameRate = (format.frameRate > 0) ? format.frameRate : 30.0f;
+        return MediaCodecUtil.isSizeAndRateSupportedV21(videoMediaMimeType, false,
+            format.width, format.height, frameRate);
+      }
+      //Assuming that the media is H.264
       if (format.width * format.height > maxDecodableFrameSize) {
         // Filtering stream that device cannot play
         return false;
@@ -186,7 +193,7 @@ private static Point getViewportSize(Context context) {
     // Before API 23 the platform Display object does not provide a way to identify Android TVs that
     // can show 4k resolution in a SurfaceView, so check for supported devices here.
     // See also https://developer.sony.com/develop/tvs/android-tv/design-guide/.
-    if (Util.MODEL != null && Util.MODEL.startsWith("BRAVIA")
+    if (Util.SDK_INT < 23 && Util.MODEL != null && Util.MODEL.startsWith("BRAVIA")
         && context.getPackageManager().hasSystemFeature("com.sony.dtv.hardware.panel.qfhd")) {
       return new Point(3840, 2160);
     }
@@ -197,7 +204,9 @@ private static Point getViewportSize(Context context) {
 
   private static Point getDisplaySize(Display display) {
     Point displaySize = new Point();
-    if (Util.SDK_INT >= 17) {
+    if (Util.SDK_INT >= 23) {
+      getDisplaySizeV23(display, displaySize);
+    } else if (Util.SDK_INT >= 17) {
       getDisplaySizeV17(display, displaySize);
     } else if (Util.SDK_INT >= 16) {
       getDisplaySizeV16(display, displaySize);
@@ -207,6 +216,13 @@ private static Point getDisplaySize(Display display) {
     return displaySize;
   }
 
+  @TargetApi(23)
+  private static void getDisplaySizeV23(Display display, Point outSize) {
+    Display.Mode mode = display.getMode();
+    outSize.x = mode.getPhysicalWidth();
+    outSize.y = mode.getPhysicalHeight();
+  }
+
   @TargetApi(17)
   private static void getDisplaySizeV17(Display display, Point outSize) {
     display.getRealSize(outSize);
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java b/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
index 1f72d1218c..8c7350e1d5 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
@@ -52,7 +52,6 @@
 import com.google.android.exoplayer.util.SystemClock;
 
 import android.os.Handler;
-import android.text.TextUtils;
 import android.util.Log;
 import android.util.SparseArray;
 
@@ -122,6 +121,7 @@ public NoAdaptationSetException(String message) {
   private final boolean live;
 
   private MediaPresentationDescription currentManifest;
+  private MediaPresentationDescription processedManifest;
   private ExposedTrack enabledTrack;
   private int nextPeriodHolderIndex;
   private TimeRange availableRange;
@@ -133,6 +133,7 @@ public NoAdaptationSetException(String message) {
   /**
    * Lightweight constructor to use for fixed duration content.
    *
+   * @param trackSelector Selects tracks to be exposed by this source.
    * @param dataSource A {@link DataSource} suitable for loading the media data.
    * @param adaptiveFormatEvaluator For adaptive tracks, selects from the available formats.
    * @param durationMs The duration of the content.
@@ -141,15 +142,17 @@ public NoAdaptationSetException(String message) {
    *     {@link AdaptationSet#TYPE_TEXT}.
    * @param representations The representations to be considered by the source.
    */
-  public DashChunkSource(DataSource dataSource, FormatEvaluator adaptiveFormatEvaluator,
-      long durationMs, int adaptationSetType, Representation... representations) {
-    this(dataSource, adaptiveFormatEvaluator, durationMs, adaptationSetType,
+  public DashChunkSource(DashTrackSelector trackSelector, DataSource dataSource,
+      FormatEvaluator adaptiveFormatEvaluator, long durationMs, int adaptationSetType,
+      Representation... representations) {
+    this(trackSelector, dataSource, adaptiveFormatEvaluator, durationMs, adaptationSetType,
         Arrays.asList(representations));
   }
 
   /**
    * Lightweight constructor to use for fixed duration content.
    *
+   * @param trackSelector Selects tracks to be exposed by this source.
    * @param dataSource A {@link DataSource} suitable for loading the media data.
    * @param adaptiveFormatEvaluator For adaptive tracks, selects from the available formats.
    * @param durationMs The duration of the content.
@@ -158,10 +161,10 @@ public DashChunkSource(DataSource dataSource, FormatEvaluator adaptiveFormatEval
    *     {@link AdaptationSet#TYPE_TEXT}.
    * @param representations The representations to be considered by the source.
    */
-  public DashChunkSource(DataSource dataSource, FormatEvaluator adaptiveFormatEvaluator,
-      long durationMs, int adaptationSetType, List<Representation> representations) {
-    this(buildManifest(durationMs, adaptationSetType, representations),
-        DefaultDashTrackSelector.newVideoInstance(null, false, false), dataSource,
+  public DashChunkSource(DashTrackSelector trackSelector, DataSource dataSource,
+      FormatEvaluator adaptiveFormatEvaluator, long durationMs, int adaptationSetType,
+      List<Representation> representations) {
+    this(buildManifest(durationMs, adaptationSetType, representations), trackSelector, dataSource,
         adaptiveFormatEvaluator);
   }
 
@@ -320,8 +323,11 @@ public void continueBuffering(long playbackPositionUs) {
     }
 
     MediaPresentationDescription newManifest = manifestFetcher.getManifest();
-    if (currentManifest != newManifest && newManifest != null) {
+    if (newManifest != null && newManifest != processedManifest) {
       processManifest(newManifest);
+      // Manifests may be rejected, so the new manifest may not become the next currentManifest.
+      // Track a manifest has been processed to avoid processing twice when it was discarded.
+      processedManifest = newManifest;
     }
 
     // TODO: This is a temporary hack to avoid constantly refreshing the MPD in cases where
@@ -340,8 +346,8 @@ public void continueBuffering(long playbackPositionUs) {
   }
 
   @Override
-  public final void getChunkOperation(List<? extends MediaChunk> queue, long seekPositionUs,
-      long playbackPositionUs, ChunkOperationHolder out) {
+  public final void getChunkOperation(List<? extends MediaChunk> queue, long playbackPositionUs,
+      ChunkOperationHolder out) {
     if (fatalError != null) {
       out.chunk = null;
       return;
@@ -383,16 +389,16 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long seekP
         if (startAtLiveEdge) {
           // We want live streams to start at the live edge instead of the beginning of the
           // manifest
-          seekPositionUs = Math.max(availableRangeValues[0],
+          playbackPositionUs = Math.max(availableRangeValues[0],
               availableRangeValues[1] - liveEdgeLatencyUs);
         } else {
           // we subtract 1 from the upper bound because it's exclusive for that bound
-          seekPositionUs = Math.min(seekPositionUs, availableRangeValues[1] - 1);
-          seekPositionUs = Math.max(seekPositionUs, availableRangeValues[0]);
+          playbackPositionUs = Math.min(playbackPositionUs, availableRangeValues[1] - 1);
+          playbackPositionUs = Math.max(playbackPositionUs, availableRangeValues[0]);
         }
       }
 
-      periodHolder = findPeriodHolder(seekPositionUs);
+      periodHolder = findPeriodHolder(playbackPositionUs);
       startingNewPeriod = true;
     } else {
       if (startAtLiveEdge) {
@@ -470,7 +476,7 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long seekP
       return;
     }
 
-    int segmentNum = queue.isEmpty() ? representationHolder.getSegmentNum(seekPositionUs)
+    int segmentNum = queue.isEmpty() ? representationHolder.getSegmentNum(playbackPositionUs)
           : startingNewPeriod ? representationHolder.getFirstAvailableSegmentNum()
           : queue.get(out.queueSize - 1).chunkIndex + 1;
     Chunk nextMediaChunk = newMediaChunk(periodHolder, representationHolder, dataSource,
@@ -565,7 +571,7 @@ public void adaptiveTrack(MediaPresentationDescription manifest, int periodIndex
       Log.w(TAG, "Skipped adaptive track (unknown media format)");
       return;
     }
-    tracks.add(new ExposedTrack(trackFormat.copyAsAdaptive(), adaptationSetIndex,
+    tracks.add(new ExposedTrack(trackFormat.copyAsAdaptive(null), adaptationSetIndex,
         representationFormats, maxWidth, maxHeight));
   }
 
@@ -608,14 +614,14 @@ private static MediaFormat getTrackFormat(int adaptationSetType, Format format,
       String mediaMimeType, long durationUs) {
     switch (adaptationSetType) {
       case AdaptationSet.TYPE_VIDEO:
-        return MediaFormat.createVideoFormat(MediaFormat.NO_VALUE, mediaMimeType, format.bitrate,
+        return MediaFormat.createVideoFormat(format.id, mediaMimeType, format.bitrate,
             MediaFormat.NO_VALUE, durationUs, format.width, format.height, null);
       case AdaptationSet.TYPE_AUDIO:
-        return MediaFormat.createAudioFormat(MediaFormat.NO_VALUE, mediaMimeType, format.bitrate,
+        return MediaFormat.createAudioFormat(format.id, mediaMimeType, format.bitrate,
             MediaFormat.NO_VALUE, durationUs, format.audioChannels, format.audioSamplingRate, null,
             format.language);
       case AdaptationSet.TYPE_TEXT:
-        return MediaFormat.createTextFormat(MediaFormat.NO_VALUE, mediaMimeType, format.bitrate,
+        return MediaFormat.createTextFormat(format.id, mediaMimeType, format.bitrate,
             durationUs, format.language);
       default:
         return null;
@@ -625,9 +631,9 @@ private static MediaFormat getTrackFormat(int adaptationSetType, Format format,
   private static String getMediaMimeType(Format format) {
     String formatMimeType = format.mimeType;
     if (MimeTypes.isAudio(formatMimeType)) {
-      return getAudioMediaMimeType(format);
+      return MimeTypes.getAudioMediaMimeType(format.codecs);
     } else if (MimeTypes.isVideo(formatMimeType)) {
-      return getVideoMediaMimeType(format);
+      return MimeTypes.getVideoMediaMimeType(format.codecs);
     } else if (mimeTypeIsRawText(formatMimeType)) {
       return formatMimeType;
     } else if (MimeTypes.APPLICATION_MP4.equals(formatMimeType) && "stpp".equals(format.codecs)) {
@@ -637,46 +643,6 @@ private static String getMediaMimeType(Format format) {
     }
   }
 
-  private static String getVideoMediaMimeType(Format format) {
-    String codecs = format.codecs;
-    if (TextUtils.isEmpty(codecs)) {
-      Log.w(TAG, "Codecs attribute missing: " + format.id);
-      return MimeTypes.VIDEO_UNKNOWN;
-    } else if (codecs.startsWith("avc1") || codecs.startsWith("avc3")) {
-      return MimeTypes.VIDEO_H264;
-    } else if (codecs.startsWith("hev1") || codecs.startsWith("hvc1")) {
-      return MimeTypes.VIDEO_H265;
-    } else if (codecs.startsWith("vp9")) {
-      return MimeTypes.VIDEO_VP9;
-    } else if (codecs.startsWith("vp8")) {
-      return MimeTypes.VIDEO_VP8;
-    }
-    Log.w(TAG, "Failed to parse mime from codecs: " + format.id + ", " + codecs);
-    return MimeTypes.VIDEO_UNKNOWN;
-  }
-
-  private static String getAudioMediaMimeType(Format format) {
-    String codecs = format.codecs;
-    if (TextUtils.isEmpty(codecs)) {
-      Log.w(TAG, "Codecs attribute missing: " + format.id);
-      return MimeTypes.AUDIO_UNKNOWN;
-    } else if (codecs.startsWith("mp4a")) {
-      return MimeTypes.AUDIO_AAC;
-    } else if (codecs.startsWith("ac-3") || codecs.startsWith("dac3")) {
-      return MimeTypes.AUDIO_AC3;
-    } else if (codecs.startsWith("ec-3") || codecs.startsWith("dec3")) {
-      return MimeTypes.AUDIO_EC3;
-    } else if (codecs.startsWith("dtsc") || codecs.startsWith("dtse")) {
-      return MimeTypes.AUDIO_DTS;
-    } else if (codecs.startsWith("dtsh") || codecs.startsWith("dtsl")) {
-      return MimeTypes.AUDIO_DTS_HD;
-    } else if (codecs.startsWith("opus")) {
-      return MimeTypes.AUDIO_OPUS;
-    }
-    Log.w(TAG, "Failed to parse mime from codecs: " + format.id + ", " + codecs);
-    return MimeTypes.AUDIO_UNKNOWN;
-  }
-
   /* package */ static boolean mimeTypeIsWebm(String mimeType) {
     return mimeType.startsWith(MimeTypes.VIDEO_WEBM) || mimeType.startsWith(MimeTypes.AUDIO_WEBM)
         || mimeType.startsWith(MimeTypes.APPLICATION_WEBM);
@@ -765,6 +731,14 @@ private void processManifest(MediaPresentationDescription manifest) {
       periodHolders.remove(periodHolder.localIndex);
     }
 
+    // After discarding old periods, we should never have more periods than listed in the new
+    // manifest.  That would mean that a previously announced period is no longer advertised.  If
+    // this condition occurs, assume that we are hitting a manifest server that is out of sync and
+    // behind, discard this manifest, and try again later.
+    if (periodHolders.size() > manifest.getPeriodCount()) {
+      return;
+    }
+
     // Update existing periods. Only the first and last periods can change.
     try {
       int periodHolderCount = periodHolders.size();
@@ -1080,8 +1054,6 @@ private static int getRepresentationIndex(List<Representation> representations,
     }
 
     private static DrmInitData getDrmInitData(AdaptationSet adaptationSet) {
-      String drmInitMimeType = mimeTypeIsWebm(adaptationSet.representations.get(0).format.mimeType)
-          ? MimeTypes.VIDEO_WEBM : MimeTypes.VIDEO_MP4;
       if (adaptationSet.contentProtections.isEmpty()) {
         return null;
       } else {
@@ -1090,7 +1062,7 @@ private static DrmInitData getDrmInitData(AdaptationSet adaptationSet) {
           ContentProtection contentProtection = adaptationSet.contentProtections.get(i);
           if (contentProtection.uuid != null && contentProtection.data != null) {
             if (drmInitData == null) {
-              drmInitData = new DrmInitData.Mapped(drmInitMimeType);
+              drmInitData = new DrmInitData.Mapped();
             }
             drmInitData.put(contentProtection.uuid, contentProtection.data);
           }
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/ContentProtection.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/ContentProtection.java
index 8f02fdc6f4..1ebba25f4e 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/ContentProtection.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/ContentProtection.java
@@ -15,10 +15,10 @@
  */
 package com.google.android.exoplayer.dash.mpd;
 
+import com.google.android.exoplayer.drm.DrmInitData.SchemeInitData;
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.Util;
 
-import java.util.Arrays;
 import java.util.UUID;
 
 /**
@@ -37,16 +37,16 @@
   public final UUID uuid;
 
   /**
-   * Protection scheme specific data. May be null.
+   * Protection scheme specific initialization data. May be null.
    */
-  public final byte[] data;
+  public final SchemeInitData data;
 
   /**
    * @param schemeUriId Identifies the content protection scheme.
    * @param uuid The UUID of the protection scheme, if known. May be null.
    * @param data Protection scheme specific initialization data. May be null.
    */
-  public ContentProtection(String schemeUriId, UUID uuid, byte[] data) {
+  public ContentProtection(String schemeUriId, UUID uuid, SchemeInitData data) {
     this.schemeUriId = Assertions.checkNotNull(schemeUriId);
     this.uuid = uuid;
     this.data = data;
@@ -64,20 +64,14 @@ public boolean equals(Object obj) {
     ContentProtection other = (ContentProtection) obj;
     return schemeUriId.equals(other.schemeUriId)
         && Util.areEqual(uuid, other.uuid)
-        && Arrays.equals(data, other.data);
+        && Util.areEqual(data, other.data);
   }
 
   @Override
   public int hashCode() {
-    int hashCode = 1;
-
-    hashCode = hashCode * 37 + schemeUriId.hashCode();
-    if (uuid != null) {
-      hashCode = hashCode * 37 + uuid.hashCode();
-    }
-    if (data != null) {
-      hashCode = hashCode * 37 + Arrays.hashCode(data);
-    }
+    int hashCode = schemeUriId.hashCode();
+    hashCode = (37 * hashCode) + (uuid != null ? uuid.hashCode() : 0);
+    hashCode = (37 * hashCode) + (data != null ? data.hashCode() : 0);
     return hashCode;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
index 517fea235d..a205599e45 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
@@ -21,6 +21,7 @@
 import com.google.android.exoplayer.dash.mpd.SegmentBase.SegmentTemplate;
 import com.google.android.exoplayer.dash.mpd.SegmentBase.SegmentTimelineElement;
 import com.google.android.exoplayer.dash.mpd.SegmentBase.SingleSegmentBase;
+import com.google.android.exoplayer.drm.DrmInitData.SchemeInitData;
 import com.google.android.exoplayer.extractor.mp4.PsshAtomUtil;
 import com.google.android.exoplayer.upstream.UriLoadable;
 import com.google.android.exoplayer.util.Assertions;
@@ -159,6 +160,10 @@ protected MediaPresentationDescription parseMediaPresentationDescription(XmlPull
       }
     }
 
+    if (periods.isEmpty()) {
+      throw new ParserException("No periods found.");
+    }
+
     return buildMediaPresentationDescription(availabilityStartTime, durationMs, minBufferTimeMs,
         dynamic, minUpdateTimeMs, timeShiftBufferDepthMs, utcTiming, location, periods);
   }
@@ -313,23 +318,24 @@ protected ContentProtection parseContentProtection(XmlPullParser xpp)
       throws XmlPullParserException, IOException {
     String schemeIdUri = xpp.getAttributeValue(null, "schemeIdUri");
     UUID uuid = null;
-    byte[] psshAtom = null;
+    SchemeInitData data = null;
     do {
       xpp.next();
       // The cenc:pssh element is defined in 23001-7:2015
       if (ParserUtil.isStartTag(xpp, "cenc:pssh") && xpp.next() == XmlPullParser.TEXT) {
-        psshAtom = Base64.decode(xpp.getText(), Base64.DEFAULT);
-        uuid = PsshAtomUtil.parseUuid(psshAtom);
+        data = new SchemeInitData(MimeTypes.VIDEO_MP4,
+            Base64.decode(xpp.getText(), Base64.DEFAULT));
+        uuid = PsshAtomUtil.parseUuid(data.data);
         if (uuid == null) {
           throw new ParserException("Invalid pssh atom in cenc:pssh element");
         }
       }
     } while (!ParserUtil.isEndTag(xpp, "ContentProtection"));
-
-    return buildContentProtection(schemeIdUri, uuid, psshAtom);
+    return buildContentProtection(schemeIdUri, uuid, data);
   }
 
-  protected ContentProtection buildContentProtection(String schemeIdUri, UUID uuid, byte[] data) {
+  protected ContentProtection buildContentProtection(String schemeIdUri, UUID uuid,
+      SchemeInitData data) {
     return new ContentProtection(schemeIdUri, uuid, data);
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/Representation.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/Representation.java
index 8c8778f3e2..2b3ae678e6 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/Representation.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/Representation.java
@@ -53,6 +53,7 @@
    */
   public final long presentationTimeOffsetUs;
 
+  private final String cacheKey;
   private final RangedUri initializationUri;
 
   /**
@@ -66,12 +67,27 @@
    */
   public static Representation newInstance(String contentId, long revisionId, Format format,
       SegmentBase segmentBase) {
+    return newInstance(contentId, revisionId, format, segmentBase, null);
+  }
+
+  /**
+   * Constructs a new instance.
+   *
+   * @param contentId Identifies the piece of content to which this representation belongs.
+   * @param revisionId Identifies the revision of the content.
+   * @param format The format of the representation.
+   * @param segmentBase A segment base element for the representation.
+   * @param customCacheKey A custom value to be returned from {@link #getCacheKey()}, or null.
+   * @return The constructed instance.
+   */
+  public static Representation newInstance(String contentId, long revisionId, Format format,
+      SegmentBase segmentBase, String customCacheKey) {
     if (segmentBase instanceof SingleSegmentBase) {
       return new SingleSegmentRepresentation(contentId, revisionId, format,
-          (SingleSegmentBase) segmentBase, -1);
+          (SingleSegmentBase) segmentBase, customCacheKey, -1);
     } else if (segmentBase instanceof MultiSegmentBase) {
       return new MultiSegmentRepresentation(contentId, revisionId, format,
-          (MultiSegmentBase) segmentBase);
+          (MultiSegmentBase) segmentBase, customCacheKey);
     } else {
       throw new IllegalArgumentException("segmentBase must be of type SingleSegmentBase or "
           + "MultiSegmentBase");
@@ -79,10 +95,12 @@ public static Representation newInstance(String contentId, long revisionId, Form
   }
 
   private Representation(String contentId, long revisionId, Format format,
-      SegmentBase segmentBase) {
+      SegmentBase segmentBase, String customCacheKey) {
     this.contentId = contentId;
     this.revisionId = revisionId;
     this.format = format;
+    this.cacheKey = customCacheKey != null ? customCacheKey
+        : contentId + "." + format.id + "." + revisionId;
     initializationUri = segmentBase.getInitialization(this);
     presentationTimeOffsetUs = segmentBase.getPresentationTimeOffsetUs();
   }
@@ -119,13 +137,13 @@ public RangedUri getInitializationUri() {
   public abstract DashSegmentIndex getIndex();
 
   /**
-   * Generates a cache key for the {@link Representation}, in the format
+   * A cache key for the {@link Representation}, in the format
    * {@code contentId + "." + format.id + "." + revisionId}.
    *
    * @return A cache key.
    */
   public String getCacheKey() {
-    return contentId + "." + format.id + "." + revisionId;
+    return cacheKey;
   }
 
   /**
@@ -155,17 +173,18 @@ public String getCacheKey() {
      * @param initializationEnd The offset of the last byte of initialization data.
      * @param indexStart The offset of the first byte of index data.
      * @param indexEnd The offset of the last byte of index data.
+     * @param customCacheKey A custom value to be returned from {@link #getCacheKey()}, or null.
      * @param contentLength The content length, or -1 if unknown.
      */
     public static SingleSegmentRepresentation newInstance(String contentId, long revisionId,
         Format format, String uri, long initializationStart, long initializationEnd,
-        long indexStart, long indexEnd, long contentLength) {
+        long indexStart, long indexEnd, String customCacheKey, long contentLength) {
       RangedUri rangedUri = new RangedUri(uri, null, initializationStart,
           initializationEnd - initializationStart + 1);
       SingleSegmentBase segmentBase = new SingleSegmentBase(rangedUri, 1, 0, uri, indexStart,
           indexEnd - indexStart + 1);
       return new SingleSegmentRepresentation(contentId, revisionId,
-          format, segmentBase, contentLength);
+          format, segmentBase, customCacheKey, contentLength);
     }
 
     /**
@@ -173,11 +192,12 @@ public static SingleSegmentRepresentation newInstance(String contentId, long rev
      * @param revisionId Identifies the revision of the content.
      * @param format The format of the representation.
      * @param segmentBase The segment base underlying the representation.
+     * @param customCacheKey A custom value to be returned from {@link #getCacheKey()}, or null.
      * @param contentLength The content length, or -1 if unknown.
      */
     public SingleSegmentRepresentation(String contentId, long revisionId, Format format,
-        SingleSegmentBase segmentBase, long contentLength) {
-      super(contentId, revisionId, format, segmentBase);
+        SingleSegmentBase segmentBase, String customCacheKey, long contentLength) {
+      super(contentId, revisionId, format, segmentBase, customCacheKey);
       this.uri = Uri.parse(segmentBase.uri);
       this.indexUri = segmentBase.getIndex();
       this.contentLength = contentLength;
@@ -212,10 +232,11 @@ public DashSegmentIndex getIndex() {
      * @param revisionId Identifies the revision of the content.
      * @param format The format of the representation.
      * @param segmentBase The segment base underlying the representation.
+     * @param customCacheKey A custom value to be returned from {@link #getCacheKey()}, or null.
      */
     public MultiSegmentRepresentation(String contentId, long revisionId, Format format,
-        MultiSegmentBase segmentBase) {
-      super(contentId, revisionId, format, segmentBase);
+        MultiSegmentBase segmentBase, String customCacheKey) {
+      super(contentId, revisionId, format, segmentBase, customCacheKey);
       this.segmentBase = segmentBase;
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/drm/DrmInitData.java b/library/src/main/java/com/google/android/exoplayer/drm/DrmInitData.java
index bdb4565fc3..c01fc59ca7 100644
--- a/library/src/main/java/com/google/android/exoplayer/drm/DrmInitData.java
+++ b/library/src/main/java/com/google/android/exoplayer/drm/DrmInitData.java
@@ -15,25 +15,19 @@
  */
 package com.google.android.exoplayer.drm;
 
+import com.google.android.exoplayer.util.Assertions;
+
 import android.media.MediaDrm;
 
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.UUID;
 
 /**
- * Encapsulates initialization data required by a {@link MediaDrm} instance.
+ * Encapsulates initialization data required by a {@link MediaDrm} instances.
  */
-public abstract class DrmInitData {
-
-  /**
-   * The container mime type.
-   */
-  public final String mimeType;
-
-  public DrmInitData(String mimeType) {
-    this.mimeType = mimeType;
-  }
+public interface DrmInitData {
 
   /**
    * Retrieves initialization data for a given DRM scheme, specified by its UUID.
@@ -41,22 +35,21 @@ public DrmInitData(String mimeType) {
    * @param schemeUuid The DRM scheme's UUID.
    * @return The initialization data for the scheme, or null if the scheme is not supported.
    */
-  public abstract byte[] get(UUID schemeUuid);
+  public abstract SchemeInitData get(UUID schemeUuid);
 
   /**
    * A {@link DrmInitData} implementation that maps UUID onto scheme specific data.
    */
-  public static final class Mapped extends DrmInitData {
+  public static final class Mapped implements DrmInitData {
 
-    private final Map<UUID, byte[]> schemeData;
+    private final Map<UUID, SchemeInitData> schemeData;
 
-    public Mapped(String mimeType) {
-      super(mimeType);
+    public Mapped() {
       schemeData = new HashMap<>();
     }
 
     @Override
-    public byte[] get(UUID schemeUuid) {
+    public SchemeInitData get(UUID schemeUuid) {
       return schemeData.get(schemeUuid);
     }
 
@@ -64,10 +57,10 @@ public Mapped(String mimeType) {
      * Inserts scheme specific initialization data.
      *
      * @param schemeUuid The scheme UUID.
-     * @param data The corresponding initialization data.
+     * @param schemeInitData The corresponding initialization data.
      */
-    public void put(UUID schemeUuid, byte[] data) {
-      schemeData.put(schemeUuid, data);
+    public void put(UUID schemeUuid, SchemeInitData schemeInitData) {
+      schemeData.put(schemeUuid, schemeInitData);
     }
 
   }
@@ -75,20 +68,62 @@ public void put(UUID schemeUuid, byte[] data) {
   /**
    * A {@link DrmInitData} implementation that returns the same initialization data for all schemes.
    */
-  public static final class Universal extends DrmInitData {
+  public static final class Universal implements DrmInitData {
 
-    private byte[] data;
+    private SchemeInitData data;
 
-    public Universal(String mimeType, byte[] data) {
-      super(mimeType);
+    public Universal(SchemeInitData data) {
       this.data = data;
     }
 
     @Override
-    public byte[] get(UUID schemeUuid) {
+    public SchemeInitData get(UUID schemeUuid) {
       return data;
     }
 
   }
 
+  /**
+   * Scheme initialization data.
+   */
+  public static final class SchemeInitData {
+
+    /**
+     * The mimeType of {@link #data}.
+     */
+    public final String mimeType;
+    /**
+     * The initialization data.
+     */
+    public final byte[] data;
+
+    /**
+     * @param mimeType The mimeType of the initialization data.
+     * @param data The initialization data.
+     */
+    public SchemeInitData(String mimeType, byte[] data) {
+      this.mimeType = Assertions.checkNotNull(mimeType);
+      this.data = Assertions.checkNotNull(data);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (!(obj instanceof SchemeInitData)) {
+        return false;
+      }
+      if (obj == this) {
+        return true;
+      }
+
+      SchemeInitData other = (SchemeInitData) obj;
+      return mimeType.equals(other.mimeType) && Arrays.equals(data, other.data);
+    }
+
+    @Override
+    public int hashCode() {
+      return mimeType.hashCode() + 31 * Arrays.hashCode(data);
+    }
+
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/drm/StreamingDrmSessionManager.java b/library/src/main/java/com/google/android/exoplayer/drm/StreamingDrmSessionManager.java
index 6e42cea28d..be22d4c6c8 100644
--- a/library/src/main/java/com/google/android/exoplayer/drm/StreamingDrmSessionManager.java
+++ b/library/src/main/java/com/google/android/exoplayer/drm/StreamingDrmSessionManager.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer.drm;
 
+import com.google.android.exoplayer.drm.DrmInitData.SchemeInitData;
 import com.google.android.exoplayer.extractor.mp4.PsshAtomUtil;
 import com.google.android.exoplayer.util.Util;
 
@@ -103,8 +104,7 @@
   private int state;
   private MediaCrypto mediaCrypto;
   private Exception lastException;
-  private String mimeType;
-  private byte[] schemeData;
+  private SchemeInitData schemeInitData;
   private byte[] sessionId;
 
   /**
@@ -273,20 +273,19 @@ public void open(DrmInitData drmInitData) {
       requestHandlerThread.start();
       postRequestHandler = new PostRequestHandler(requestHandlerThread.getLooper());
     }
-    if (schemeData == null) {
-      mimeType = drmInitData.mimeType;
-      schemeData = drmInitData.get(uuid);
-      if (schemeData == null) {
+    if (schemeInitData == null) {
+      schemeInitData = drmInitData.get(uuid);
+      if (schemeInitData == null) {
         onError(new IllegalStateException("Media does not support uuid: " + uuid));
         return;
       }
       if (Util.SDK_INT < 21) {
         // Prior to L the Widevine CDM required data to be extracted from the PSSH atom.
-        byte[] psshData = PsshAtomUtil.parseSchemeSpecificData(schemeData, WIDEVINE_UUID);
+        byte[] psshData = PsshAtomUtil.parseSchemeSpecificData(schemeInitData.data, WIDEVINE_UUID);
         if (psshData == null) {
           // Extraction failed. schemeData isn't a Widevine PSSH atom, so leave it unchanged.
         } else {
-          schemeData = psshData;
+          schemeInitData = new SchemeInitData(schemeInitData.mimeType, psshData);
         }
       }
     }
@@ -307,7 +306,7 @@ public void close() {
     postRequestHandler = null;
     requestHandlerThread.quit();
     requestHandlerThread = null;
-    schemeData = null;
+    schemeInitData = null;
     mediaCrypto = null;
     lastException = null;
     if (sessionId != null) {
@@ -369,7 +368,7 @@ private void onProvisionResponse(Object response) {
   private void postKeyRequest() {
     KeyRequest keyRequest;
     try {
-      keyRequest = mediaDrm.getKeyRequest(sessionId, schemeData, mimeType,
+      keyRequest = mediaDrm.getKeyRequest(sessionId, schemeInitData.data, schemeInitData.mimeType,
           MediaDrm.KEY_TYPE_STREAMING, optionalKeyRequestParameters);
       postRequestHandler.obtainMessage(MSG_KEYS, keyRequest).sendToTarget();
     } catch (NotProvisionedException e) {
@@ -434,6 +433,7 @@ public MediaDrmHandler(Looper looper) {
       super(looper);
     }
 
+    @SuppressWarnings("deprecation")
     @Override
     public void handleMessage(Message msg) {
       if (openCount == 0 || (state != STATE_OPENED && state != STATE_OPENED_WITH_KEYS)) {
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/DefaultTrackOutput.java b/library/src/main/java/com/google/android/exoplayer/extractor/DefaultTrackOutput.java
index 00689ae243..993178dad1 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/DefaultTrackOutput.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/DefaultTrackOutput.java
@@ -205,7 +205,7 @@ public boolean configureSpliceTo(DefaultTrackOutput nextQueue) {
   /**
    * Advances the underlying buffer to the next sample that is eligible to be returned.
    *
-   * @boolean True if an eligible sample was found. False otherwise, in which case the underlying
+   * @return True if an eligible sample was found. False otherwise, in which case the underlying
    *     buffer has been emptied.
    */
   private boolean advanceToEligibleSample() {
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
index 8f0bc4977b..e13bb16422 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
@@ -58,9 +58,10 @@
  * <li>MP3 ({@link com.google.android.exoplayer.extractor.mp3.Mp3Extractor})</li>
  * <li>AAC ({@link com.google.android.exoplayer.extractor.ts.AdtsExtractor})</li>
  * <li>MPEG TS ({@link com.google.android.exoplayer.extractor.ts.TsExtractor}</li>
+ * <li>FLV ({@link com.google.android.exoplayer.extractor.flv.FlvExtractor}</li>
  * </ul>
  *
- * <p>Seeking in AAC and MPEG TS streams is not supported.
+ * <p>Seeking in AAC, MPEG TS and FLV streams is not supported.
  *
  * <p>To override the default extractors, pass one or more {@link Extractor} instances to the
  * constructor. When reading a new stream, the first {@link Extractor} that returns {@code true}
@@ -146,6 +147,13 @@ public UnrecognizedInputFormatException(Extractor[] extractors) {
     } catch (ClassNotFoundException e) {
       // Extractor not found.
     }
+    try {
+      DEFAULT_EXTRACTOR_CLASSES.add(
+          Class.forName("com.google.android.exoplayer.extractor.flv.FlvExtractor")
+              .asSubclass(Extractor.class));
+    } catch (ClassNotFoundException e) {
+      // Extractor not found.
+    }
   }
 
   private final ExtractorHolder extractorHolder;
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/flv/AudioTagPayloadReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/flv/AudioTagPayloadReader.java
new file mode 100644
index 0000000000..239fe69b7d
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/flv/AudioTagPayloadReader.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.flv;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.CodecSpecificDataUtil;
+import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.ParsableBitArray;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import android.util.Pair;
+
+import java.util.Collections;
+
+/**
+ * Parses audio tags from an FLV stream and extracts AAC frames.
+ */
+/* package */ final class AudioTagPayloadReader extends TagPayloadReader {
+
+  // Audio format
+  private static final int AUDIO_FORMAT_AAC = 10;
+
+  // AAC PACKET TYPE
+  private static final int AAC_PACKET_TYPE_SEQUENCE_HEADER = 0;
+  private static final int AAC_PACKET_TYPE_AAC_RAW = 1;
+
+  // SAMPLING RATES
+  private static final int[] AUDIO_SAMPLING_RATE_TABLE = new int[] {
+      5500, 11000, 22000, 44000
+  };
+
+  // State variables
+  private boolean hasParsedAudioDataHeader;
+  private boolean hasOutputFormat;
+
+  public AudioTagPayloadReader(TrackOutput output) {
+    super(output);
+  }
+
+  @Override
+  public void seek() {
+    // Do nothing.
+  }
+
+  @Override
+  protected boolean parseHeader(ParsableByteArray data) throws UnsupportedFormatException {
+    if (!hasParsedAudioDataHeader) {
+      int header = data.readUnsignedByte();
+      int audioFormat = (header >> 4) & 0x0F;
+      int sampleRateIndex = (header >> 2) & 0x03;
+      if (sampleRateIndex < 0 || sampleRateIndex >= AUDIO_SAMPLING_RATE_TABLE.length) {
+        throw new UnsupportedFormatException("Invalid sample rate index: " + sampleRateIndex);
+      }
+      // TODO: Add support for MP3 and PCM.
+      if (audioFormat != AUDIO_FORMAT_AAC) {
+        throw new UnsupportedFormatException("Audio format not supported: " + audioFormat);
+      }
+      hasParsedAudioDataHeader = true;
+    } else {
+      // Skip header if it was parsed previously.
+      data.skipBytes(1);
+    }
+    return true;
+  }
+
+  @Override
+  protected void parsePayload(ParsableByteArray data, long timeUs) {
+    int packetType = data.readUnsignedByte();
+    // Parse sequence header just in case it was not done before.
+    if (packetType == AAC_PACKET_TYPE_SEQUENCE_HEADER && !hasOutputFormat) {
+      ParsableBitArray adtsScratch = new ParsableBitArray(new byte[data.bytesLeft()]);
+      data.readBytes(adtsScratch.data, 0, data.bytesLeft());
+
+      int audioObjectType = adtsScratch.readBits(5);
+      int sampleRateIndex = adtsScratch.readBits(4);
+      int channelConfig = adtsScratch.readBits(4);
+
+      byte[] audioSpecificConfig = CodecSpecificDataUtil.buildAacAudioSpecificConfig(
+          audioObjectType, sampleRateIndex, channelConfig);
+      Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAacAudioSpecificConfig(
+          audioSpecificConfig);
+
+      MediaFormat mediaFormat = MediaFormat.createAudioFormat(null, MimeTypes.AUDIO_AAC,
+          MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, getDurationUs(), audioParams.second,
+          audioParams.first, Collections.singletonList(audioSpecificConfig), null);
+      output.format(mediaFormat);
+      hasOutputFormat = true;
+    } else if (packetType == AAC_PACKET_TYPE_AAC_RAW) {
+      // Sample audio AAC frames
+      int bytesToWrite = data.bytesLeft();
+      output.sampleData(data, bytesToWrite);
+      output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, bytesToWrite, 0, null);
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/flv/FlvExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/flv/FlvExtractor.java
new file mode 100644
index 0000000000..d1c6c766bb
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/flv/FlvExtractor.java
@@ -0,0 +1,281 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.flv;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.ExtractorOutput;
+import com.google.android.exoplayer.extractor.PositionHolder;
+import com.google.android.exoplayer.extractor.SeekMap;
+import com.google.android.exoplayer.util.ParsableByteArray;
+import com.google.android.exoplayer.util.Util;
+
+import java.io.IOException;
+
+/**
+ * Facilitates the extraction of data from the FLV container format.
+ */
+public final class FlvExtractor implements Extractor, SeekMap {
+
+  // Header sizes.
+  private static final int FLV_HEADER_SIZE = 9;
+  private static final int FLV_TAG_HEADER_SIZE = 11;
+
+  // Parser states.
+  private static final int STATE_READING_FLV_HEADER = 1;
+  private static final int STATE_SKIPPING_TO_TAG_HEADER = 2;
+  private static final int STATE_READING_TAG_HEADER = 3;
+  private static final int STATE_READING_TAG_DATA = 4;
+
+  // Tag types.
+  private static final int TAG_TYPE_AUDIO = 8;
+  private static final int TAG_TYPE_VIDEO = 9;
+  private static final int TAG_TYPE_SCRIPT_DATA = 18;
+
+  // FLV container identifier.
+  private static final int FLV_TAG = Util.getIntegerCodeForString("FLV");
+
+  // Temporary buffers.
+  private final ParsableByteArray scratch;
+  private final ParsableByteArray headerBuffer;
+  private final ParsableByteArray tagHeaderBuffer;
+  private final ParsableByteArray tagData;
+
+  // Extractor outputs.
+  private ExtractorOutput extractorOutput;
+
+  // State variables.
+  private int parserState;
+  private int bytesToNextTagHeader;
+  public int tagType;
+  public int tagDataSize;
+  public long tagTimestampUs;
+
+  // Tags readers.
+  private AudioTagPayloadReader audioReader;
+  private VideoTagPayloadReader videoReader;
+  private ScriptTagPayloadReader metadataReader;
+
+  public FlvExtractor() {
+    scratch = new ParsableByteArray(4);
+    headerBuffer = new ParsableByteArray(FLV_HEADER_SIZE);
+    tagHeaderBuffer = new ParsableByteArray(FLV_TAG_HEADER_SIZE);
+    tagData = new ParsableByteArray();
+    parserState = STATE_READING_FLV_HEADER;
+  }
+
+  @Override
+  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+    // Check if file starts with "FLV" tag
+    input.peekFully(scratch.data, 0, 3);
+    scratch.setPosition(0);
+    if (scratch.readUnsignedInt24() != FLV_TAG) {
+      return false;
+    }
+
+    // Checking reserved flags are set to 0
+    input.peekFully(scratch.data, 0, 2);
+    scratch.setPosition(0);
+    if ((scratch.readUnsignedShort() & 0xFA) != 0) {
+      return false;
+    }
+
+    // Read data offset
+    input.peekFully(scratch.data, 0, 4);
+    scratch.setPosition(0);
+    int dataOffset = scratch.readInt();
+
+    input.resetPeekPosition();
+    input.advancePeekPosition(dataOffset);
+
+    // Checking first "previous tag size" is set to 0
+    input.peekFully(scratch.data, 0, 4);
+    scratch.setPosition(0);
+
+    return scratch.readInt() == 0;
+  }
+
+  @Override
+  public void init(ExtractorOutput output) {
+    this.extractorOutput = output;
+  }
+
+  @Override
+  public void seek() {
+    parserState = STATE_READING_FLV_HEADER;
+    bytesToNextTagHeader = 0;
+  }
+
+  @Override
+  public int read(ExtractorInput input, PositionHolder seekPosition) throws IOException,
+      InterruptedException {
+    while (true) {
+      switch (parserState) {
+        case STATE_READING_FLV_HEADER:
+          if (!readFlvHeader(input)) {
+            return RESULT_END_OF_INPUT;
+          }
+          break;
+        case STATE_SKIPPING_TO_TAG_HEADER:
+          skipToTagHeader(input);
+          break;
+        case STATE_READING_TAG_HEADER:
+          if (!readTagHeader(input)) {
+            return RESULT_END_OF_INPUT;
+          }
+          break;
+        case STATE_READING_TAG_DATA:
+          if (readTagData(input)) {
+            return RESULT_CONTINUE;
+          }
+          break;
+      }
+    }
+  }
+
+  /**
+   * Reads an FLV container header from the provided {@link ExtractorInput}.
+   *
+   * @param input The {@link ExtractorInput} from which to read.
+   * @return True if header was read successfully. False if the end of stream was reached.
+   * @throws IOException If an error occurred reading or parsing data from the source.
+   * @throws InterruptedException If the thread was interrupted.
+   */
+  private boolean readFlvHeader(ExtractorInput input) throws IOException, InterruptedException {
+    if (!input.readFully(headerBuffer.data, 0, FLV_HEADER_SIZE, true)) {
+      // We've reached the end of the stream.
+      return false;
+    }
+
+    headerBuffer.setPosition(0);
+    headerBuffer.skipBytes(4);
+    int flags = headerBuffer.readUnsignedByte();
+    boolean hasAudio = (flags & 0x04) != 0;
+    boolean hasVideo = (flags & 0x01) != 0;
+    if (hasAudio && audioReader == null) {
+      audioReader = new AudioTagPayloadReader(extractorOutput.track(TAG_TYPE_AUDIO));
+    }
+    if (hasVideo && videoReader == null) {
+      videoReader = new VideoTagPayloadReader(extractorOutput.track(TAG_TYPE_VIDEO));
+    }
+    if (metadataReader == null) {
+      metadataReader = new ScriptTagPayloadReader(null);
+    }
+    extractorOutput.endTracks();
+    extractorOutput.seekMap(this);
+
+    // We need to skip any additional content in the FLV header, plus the 4 byte previous tag size.
+    bytesToNextTagHeader = headerBuffer.readInt() - FLV_HEADER_SIZE + 4;
+    parserState = STATE_SKIPPING_TO_TAG_HEADER;
+    return true;
+  }
+
+  /**
+   * Skips over data to reach the next tag header.
+   *
+   * @param input The {@link ExtractorInput} from which to read.
+   * @throws IOException If an error occurred skipping data from the source.
+   * @throws InterruptedException If the thread was interrupted.
+   */
+  private void skipToTagHeader(ExtractorInput input) throws IOException, InterruptedException {
+    input.skipFully(bytesToNextTagHeader);
+    bytesToNextTagHeader = 0;
+    parserState = STATE_READING_TAG_HEADER;
+  }
+
+  /**
+   * Reads a tag header from the provided {@link ExtractorInput}.
+   *
+   * @param input The {@link ExtractorInput} from which to read.
+   * @return True if tag header was read successfully. Otherwise, false.
+   * @throws IOException If an error occurred reading or parsing data from the source.
+   * @throws InterruptedException If the thread was interrupted.
+   */
+  private boolean readTagHeader(ExtractorInput input) throws IOException, InterruptedException {
+    if (!input.readFully(tagHeaderBuffer.data, 0, FLV_TAG_HEADER_SIZE, true)) {
+      // We've reached the end of the stream.
+      return false;
+    }
+
+    tagHeaderBuffer.setPosition(0);
+    tagType = tagHeaderBuffer.readUnsignedByte();
+    tagDataSize = tagHeaderBuffer.readUnsignedInt24();
+    tagTimestampUs = tagHeaderBuffer.readUnsignedInt24();
+    tagTimestampUs = ((tagHeaderBuffer.readUnsignedByte() << 24) | tagTimestampUs) * 1000L;
+    tagHeaderBuffer.skipBytes(3); // streamId
+    parserState = STATE_READING_TAG_DATA;
+    return true;
+  }
+
+  /**
+   * Reads the body of a tag from the provided {@link ExtractorInput}.
+   *
+   * @param input The {@link ExtractorInput} from which to read.
+   * @return True if the data was consumed by a reader. False if it was skipped.
+   * @throws IOException If an error occurred reading or parsing data from the source.
+   * @throws InterruptedException If the thread was interrupted.
+   */
+  private boolean readTagData(ExtractorInput input) throws IOException, InterruptedException {
+    boolean wasConsumed = true;
+    if (tagType == TAG_TYPE_AUDIO && audioReader != null) {
+      audioReader.consume(prepareTagData(input), tagTimestampUs);
+    } else if (tagType == TAG_TYPE_VIDEO && videoReader != null) {
+      videoReader.consume(prepareTagData(input), tagTimestampUs);
+    } else if (tagType == TAG_TYPE_SCRIPT_DATA && metadataReader != null) {
+      metadataReader.consume(prepareTagData(input), tagTimestampUs);
+      if (metadataReader.getDurationUs() != C.UNKNOWN_TIME_US) {
+        if (audioReader != null) {
+          audioReader.setDurationUs(metadataReader.getDurationUs());
+        }
+        if (videoReader != null) {
+          videoReader.setDurationUs(metadataReader.getDurationUs());
+        }
+      }
+    } else {
+      input.skipFully(tagDataSize);
+      wasConsumed = false;
+    }
+    bytesToNextTagHeader = 4; // There's a 4 byte previous tag size before the next header.
+    parserState = STATE_SKIPPING_TO_TAG_HEADER;
+    return wasConsumed;
+  }
+
+  private ParsableByteArray prepareTagData(ExtractorInput input) throws IOException,
+      InterruptedException {
+    if (tagDataSize > tagData.capacity()) {
+      tagData.reset(new byte[Math.max(tagData.capacity() * 2, tagDataSize)], 0);
+    } else {
+      tagData.setPosition(0);
+    }
+    tagData.setLimit(tagDataSize);
+    input.readFully(tagData.data, 0, tagDataSize);
+    return tagData;
+  }
+
+  // SeekMap implementation.
+
+  @Override
+  public boolean isSeekable() {
+    return false;
+  }
+
+  @Override
+  public long getPosition(long timeUs) {
+    return 0;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/flv/ScriptTagPayloadReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/flv/ScriptTagPayloadReader.java
new file mode 100644
index 0000000000..b28f422d67
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/flv/ScriptTagPayloadReader.java
@@ -0,0 +1,210 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.flv;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Parses Script Data tags from an FLV stream and extracts metadata information.
+ */
+/* package */ final class ScriptTagPayloadReader extends TagPayloadReader {
+
+  private static final String NAME_METADATA = "onMetaData";
+  private static final String KEY_DURATION = "duration";
+
+  // AMF object types
+  private static final int AMF_TYPE_NUMBER = 0;
+  private static final int AMF_TYPE_BOOLEAN = 1;
+  private static final int AMF_TYPE_STRING = 2;
+  private static final int AMF_TYPE_OBJECT = 3;
+  private static final int AMF_TYPE_ECMA_ARRAY = 8;
+  private static final int AMF_TYPE_END_MARKER = 9;
+  private static final int AMF_TYPE_STRICT_ARRAY = 10;
+  private static final int AMF_TYPE_DATE = 11;
+
+  /**
+   * @param output A {@link TrackOutput} to which samples should be written.
+   */
+  public ScriptTagPayloadReader(TrackOutput output) {
+    super(output);
+  }
+
+  @Override
+  public void seek() {
+    // Do nothing.
+  }
+
+  @Override
+  protected boolean parseHeader(ParsableByteArray data) {
+    return true;
+  }
+
+  @Override
+  protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserException {
+    int nameType = readAmfType(data);
+    if (nameType != AMF_TYPE_STRING) {
+      // Should never happen.
+      throw new ParserException();
+    }
+    String name = readAmfString(data);
+    if (!NAME_METADATA.equals(name)) {
+      // We're only interested in metadata.
+      return;
+    }
+    int type = readAmfType(data);
+    if (type != AMF_TYPE_ECMA_ARRAY) {
+      // Should never happen.
+      throw new ParserException();
+    }
+    // Set the duration to the value contained in the metadata, if present.
+    Map<String, Object> metadata = readAmfEcmaArray(data);
+    if (metadata.containsKey(KEY_DURATION)) {
+      double durationSeconds = (double) metadata.get(KEY_DURATION);
+      setDurationUs((long) (durationSeconds * C.MICROS_PER_SECOND));
+    }
+  }
+
+  private static int readAmfType(ParsableByteArray data) {
+    return data.readUnsignedByte();
+  }
+
+  /**
+   * Read a boolean from an AMF encoded buffer.
+   *
+   * @param data The buffer from which to read.
+   * @return The value read from the buffer.
+   */
+  private static Boolean readAmfBoolean(ParsableByteArray data) {
+    return data.readUnsignedByte() == 1;
+  }
+
+  /**
+   * Read a double number from an AMF encoded buffer.
+   *
+   * @param data The buffer from which to read.
+   * @return The value read from the buffer.
+   */
+  private static Double readAmfDouble(ParsableByteArray data) {
+    return Double.longBitsToDouble(data.readLong());
+  }
+
+  /**
+   * Read a string from an AMF encoded buffer.
+   *
+   * @param data The buffer from which to read.
+   * @return The value read from the buffer.
+   */
+  private static String readAmfString(ParsableByteArray data) {
+    int size = data.readUnsignedShort();
+    int position = data.getPosition();
+    data.skipBytes(size);
+    return new String(data.data, position, size);
+  }
+
+  /**
+   * Read an array from an AMF encoded buffer.
+   *
+   * @param data The buffer from which to read.
+   * @return The value read from the buffer.
+   */
+  private static ArrayList<Object> readAmfStrictArray(ParsableByteArray data) {
+    int count = data.readUnsignedIntToInt();
+    ArrayList<Object> list = new ArrayList<>(count);
+    for (int i = 0; i < count; i++) {
+      int type = readAmfType(data);
+      list.add(readAmfData(data, type));
+    }
+    return list;
+  }
+
+  /**
+   * Read an object from an AMF encoded buffer.
+   *
+   * @param data The buffer from which to read.
+   * @return The value read from the buffer.
+   */
+  private static HashMap<String, Object> readAmfObject(ParsableByteArray data) {
+    HashMap<String, Object> array = new HashMap<>();
+    while (true) {
+      String key = readAmfString(data);
+      int type = readAmfType(data);
+      if (type == AMF_TYPE_END_MARKER) {
+        break;
+      }
+      array.put(key, readAmfData(data, type));
+    }
+    return array;
+  }
+
+  /**
+   * Read an ECMA array from an AMF encoded buffer.
+   *
+   * @param data The buffer from which to read.
+   * @return The value read from the buffer.
+   */
+  private static HashMap<String, Object> readAmfEcmaArray(ParsableByteArray data) {
+    int count = data.readUnsignedIntToInt();
+    HashMap<String, Object> array = new HashMap<>(count);
+    for (int i = 0; i < count; i++) {
+      String key = readAmfString(data);
+      int type = readAmfType(data);
+      array.put(key, readAmfData(data, type));
+    }
+    return array;
+  }
+
+  /**
+   * Read a date from an AMF encoded buffer.
+   *
+   * @param data The buffer from which to read.
+   * @return The value read from the buffer.
+   */
+  private static Date readAmfDate(ParsableByteArray data) {
+    Date date = new Date((long) readAmfDouble(data).doubleValue());
+    data.skipBytes(2); // Skip reserved bytes.
+    return date;
+  }
+
+  private static Object readAmfData(ParsableByteArray data, int type) {
+    switch (type) {
+      case AMF_TYPE_NUMBER:
+        return readAmfDouble(data);
+      case AMF_TYPE_BOOLEAN:
+        return readAmfBoolean(data);
+      case AMF_TYPE_STRING:
+        return readAmfString(data);
+      case AMF_TYPE_OBJECT:
+        return readAmfObject(data);
+      case AMF_TYPE_ECMA_ARRAY:
+        return readAmfEcmaArray(data);
+      case AMF_TYPE_STRICT_ARRAY:
+        return readAmfStrictArray(data);
+      case AMF_TYPE_DATE:
+        return readAmfDate(data);
+      default:
+        return null;
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/flv/TagPayloadReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/flv/TagPayloadReader.java
new file mode 100644
index 0000000000..a4bbbd0123
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/flv/TagPayloadReader.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.flv;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+/**
+ * Extracts individual samples from FLV tags, preserving original order.
+ */
+/* package */ abstract class TagPayloadReader {
+
+  /**
+   * Thrown when the format is not supported.
+   */
+  public static final class UnsupportedFormatException extends ParserException {
+
+    public UnsupportedFormatException(String msg) {
+      super(msg);
+    }
+
+  }
+
+  protected final TrackOutput output;
+
+  private long durationUs;
+
+  /**
+   * @param output A {@link TrackOutput} to which samples should be written.
+   */
+  protected TagPayloadReader(TrackOutput output) {
+    this.output = output;
+    this.durationUs = C.UNKNOWN_TIME_US;
+  }
+
+  /**
+   * Sets duration in microseconds.
+   *
+   * @param durationUs duration in microseconds.
+   */
+  public final void setDurationUs(long durationUs) {
+    this.durationUs = durationUs;
+  }
+
+  /**
+   * Gets the duration in microseconds.
+   *
+   * @return The duration in microseconds.
+   */
+  public final long getDurationUs() {
+    return durationUs;
+  }
+
+  /**
+   * Notifies the reader that a seek has occurred.
+   * <p>
+   * Following a call to this method, the data passed to the next invocation of
+   * {@link #consume(ParsableByteArray, long)} will not be a continuation of the data that
+   * was previously passed. Hence the reader should reset any internal state.
+   */
+  public abstract void seek();
+
+  /**
+   * Consumes payload data.
+   *
+   * @param data The payload data to consume.
+   * @param timeUs The timestamp associated with the payload.
+   * @throws ParserException If an error occurs parsing the data.
+   */
+  public final void consume(ParsableByteArray data, long timeUs) throws ParserException {
+    if (parseHeader(data)) {
+      parsePayload(data, timeUs);
+    }
+  }
+
+  /**
+   * Parses tag header.
+   *
+   * @param data Buffer where the tag header is stored.
+   * @return True if the header was parsed successfully and the payload should be read. False
+   *     otherwise.
+   * @throws ParserException If an error occurs parsing the header.
+   */
+  protected abstract boolean parseHeader(ParsableByteArray data) throws ParserException;
+
+  /**
+   * Parses tag payload.
+   *
+   * @param data Buffer where tag payload is stored
+   * @param timeUs Time position of the frame
+   * @throws ParserException If an error occurs parsing the payload.
+   */
+  protected abstract void parsePayload(ParsableByteArray data, long timeUs) throws ParserException;
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/flv/VideoTagPayloadReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/flv/VideoTagPayloadReader.java
new file mode 100644
index 0000000000..599ea01636
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/flv/VideoTagPayloadReader.java
@@ -0,0 +1,200 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.flv;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.CodecSpecificDataUtil;
+import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.NalUnitUtil;
+import com.google.android.exoplayer.util.ParsableBitArray;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Parses video tags from an FLV stream and extracts H.264 nal units.
+ */
+/* package */ final class VideoTagPayloadReader extends TagPayloadReader {
+
+  // Video codec.
+  private static final int VIDEO_CODEC_AVC = 7;
+
+  // Frame types.
+  private static final int VIDEO_FRAME_KEYFRAME = 1;
+  private static final int VIDEO_FRAME_VIDEO_INFO = 5;
+
+  // Packet types.
+  private static final int AVC_PACKET_TYPE_SEQUENCE_HEADER = 0;
+  private static final int AVC_PACKET_TYPE_AVC_NALU = 1;
+
+  // Temporary arrays.
+  private final ParsableByteArray nalStartCode;
+  private final ParsableByteArray nalLength;
+  private int nalUnitLengthFieldLength;
+
+  // State variables.
+  private boolean hasOutputFormat;
+  private int frameType;
+
+  /**
+   * @param output A {@link TrackOutput} to which samples should be written.
+   */
+  public VideoTagPayloadReader(TrackOutput output) {
+    super(output);
+    nalStartCode = new ParsableByteArray(NalUnitUtil.NAL_START_CODE);
+    nalLength = new ParsableByteArray(4);
+  }
+
+  @Override
+  public void seek() {
+    // Do nothing.
+  }
+
+  @Override
+  protected boolean parseHeader(ParsableByteArray data) throws UnsupportedFormatException {
+    int header = data.readUnsignedByte();
+    int frameType = (header >> 4) & 0x0F;
+    int videoCodec = (header & 0x0F);
+    // Support just H.264 encoded content.
+    if (videoCodec != VIDEO_CODEC_AVC) {
+      throw new UnsupportedFormatException("Video format not supported: " + videoCodec);
+    }
+    this.frameType = frameType;
+    return (frameType != VIDEO_FRAME_VIDEO_INFO);
+  }
+
+  @Override
+  protected void parsePayload(ParsableByteArray data, long timeUs) throws ParserException {
+    int packetType = data.readUnsignedByte();
+    int compositionTimeMs = data.readUnsignedInt24();
+    timeUs += compositionTimeMs * 1000L;
+    // Parse avc sequence header in case this was not done before.
+    if (packetType == AVC_PACKET_TYPE_SEQUENCE_HEADER && !hasOutputFormat) {
+      ParsableByteArray videoSequence = new ParsableByteArray(new byte[data.bytesLeft()]);
+      data.readBytes(videoSequence.data, 0, data.bytesLeft());
+
+      AvcSequenceHeaderData avcData = parseAvcCodecPrivate(videoSequence);
+      nalUnitLengthFieldLength = avcData.nalUnitLengthFieldLength;
+
+      // Construct and output the format.
+      MediaFormat mediaFormat = MediaFormat.createVideoFormat(null, MimeTypes.VIDEO_H264,
+          MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, getDurationUs(), avcData.width,
+          avcData.height, avcData.initializationData, MediaFormat.NO_VALUE,
+          avcData.pixelWidthAspectRatio);
+      output.format(mediaFormat);
+      hasOutputFormat = true;
+    } else if (packetType == AVC_PACKET_TYPE_AVC_NALU) {
+      // TODO: Deduplicate with Mp4Extractor.
+      // Zero the top three bytes of the array that we'll use to parse nal unit lengths, in case
+      // they're only 1 or 2 bytes long.
+      byte[] nalLengthData = nalLength.data;
+      nalLengthData[0] = 0;
+      nalLengthData[1] = 0;
+      nalLengthData[2] = 0;
+      int nalUnitLengthFieldLengthDiff = 4 - nalUnitLengthFieldLength;
+      // NAL units are length delimited, but the decoder requires start code delimited units.
+      // Loop until we've written the sample to the track output, replacing length delimiters with
+      // start codes as we encounter them.
+      int bytesWritten = 0;
+      int bytesToWrite;
+      while (data.bytesLeft() > 0) {
+        // Read the NAL length so that we know where we find the next one.
+        data.readBytes(nalLength.data, nalUnitLengthFieldLengthDiff, nalUnitLengthFieldLength);
+        nalLength.setPosition(0);
+        bytesToWrite = nalLength.readUnsignedIntToInt();
+
+        // Write a start code for the current NAL unit.
+        nalStartCode.setPosition(0);
+        output.sampleData(nalStartCode, 4);
+        bytesWritten += 4;
+
+        // Write the payload of the NAL unit.
+        output.sampleData(data, bytesToWrite);
+        bytesWritten += bytesToWrite;
+      }
+      output.sampleMetadata(timeUs, frameType == VIDEO_FRAME_KEYFRAME ? C.SAMPLE_FLAG_SYNC : 0,
+          bytesWritten, 0, null);
+    }
+  }
+
+  /**
+   * Builds initialization data for a {@link MediaFormat} from H.264 (AVC) codec private data.
+   *
+   * @return The AvcSequenceHeader data needed to initialize the video codec.
+   * @throws ParserException If the initialization data could not be built.
+   */
+  private AvcSequenceHeaderData parseAvcCodecPrivate(ParsableByteArray buffer)
+      throws ParserException {
+    // TODO: Deduplicate with AtomParsers.parseAvcCFromParent.
+    buffer.setPosition(4);
+    int nalUnitLengthFieldLength = (buffer.readUnsignedByte() & 0x03) + 1;
+    Assertions.checkState(nalUnitLengthFieldLength != 3);
+    List<byte[]> initializationData = new ArrayList<>();
+    int numSequenceParameterSets = buffer.readUnsignedByte() & 0x1F;
+    for (int i = 0; i < numSequenceParameterSets; i++) {
+      initializationData.add(NalUnitUtil.parseChildNalUnit(buffer));
+    }
+    int numPictureParameterSets = buffer.readUnsignedByte();
+    for (int j = 0; j < numPictureParameterSets; j++) {
+      initializationData.add(NalUnitUtil.parseChildNalUnit(buffer));
+    }
+
+    float pixelWidthAspectRatio = 1;
+    int width = MediaFormat.NO_VALUE;
+    int height = MediaFormat.NO_VALUE;
+    if (numSequenceParameterSets > 0) {
+      // Parse the first sequence parameter set to obtain pixelWidthAspectRatio.
+      ParsableBitArray spsDataBitArray = new ParsableBitArray(initializationData.get(0));
+      // Skip the NAL header consisting of the nalUnitLengthField and the type (1 byte).
+      spsDataBitArray.setPosition(8 * (nalUnitLengthFieldLength + 1));
+      CodecSpecificDataUtil.SpsData sps = CodecSpecificDataUtil.parseSpsNalUnit(spsDataBitArray);
+      width = sps.width;
+      height = sps.height;
+      pixelWidthAspectRatio = sps.pixelWidthAspectRatio;
+    }
+
+    return new AvcSequenceHeaderData(initializationData, nalUnitLengthFieldLength,
+        width, height, pixelWidthAspectRatio);
+  }
+
+  /**
+   * Holds data parsed from an Sequence Header video tag atom.
+   */
+  private static final class AvcSequenceHeaderData {
+
+    public final List<byte[]> initializationData;
+    public final int nalUnitLengthFieldLength;
+    public final float pixelWidthAspectRatio;
+    public final int width;
+    public final int height;
+
+    public AvcSequenceHeaderData(List<byte[]> initializationData, int nalUnitLengthFieldLength,
+        int width, int height, float pixelWidthAspectRatio) {
+      this.initializationData = initializationData;
+      this.nalUnitLengthFieldLength = nalUnitLengthFieldLength;
+      this.pixelWidthAspectRatio = pixelWidthAspectRatio;
+      this.width = width;
+      this.height = height;
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/ConstantBitrateSeeker.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/ConstantBitrateSeeker.java
index 90fdfce85e..db134089b9 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/ConstantBitrateSeeker.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/ConstantBitrateSeeker.java
@@ -22,7 +22,6 @@
  */
 /* package */ final class ConstantBitrateSeeker implements Mp3Extractor.Seeker {
 
-  private static final int MICROSECONDS_PER_SECOND = 1000000;
   private static final int BITS_PER_BYTE = 8;
 
   private final long firstFramePosition;
@@ -43,12 +42,12 @@ public boolean isSeekable() {
   @Override
   public long getPosition(long timeUs) {
     return durationUs == C.UNKNOWN_TIME_US ? 0
-        : firstFramePosition + (timeUs * bitrate) / (MICROSECONDS_PER_SECOND * BITS_PER_BYTE);
+        : firstFramePosition + (timeUs * bitrate) / (C.MICROS_PER_SECOND * BITS_PER_BYTE);
   }
 
   @Override
   public long getTimeUs(long position) {
-    return ((position - firstFramePosition) * MICROSECONDS_PER_SECOND * BITS_PER_BYTE) / bitrate;
+    return ((position - firstFramePosition) * C.MICROS_PER_SECOND * BITS_PER_BYTE) / bitrate;
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
index bbc717fd9e..7a07c76bb1 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
@@ -187,7 +187,7 @@ private int readSample(ExtractorInput extractorInput) throws IOException, Interr
       sampleBytesRemaining = synchronizedHeader.frameSize;
     }
 
-    long timeUs = basisTimeUs + (samplesRead * 1000000L / synchronizedHeader.sampleRate);
+    long timeUs = basisTimeUs + (samplesRead * C.MICROS_PER_SECOND / synchronizedHeader.sampleRate);
 
     // Start by draining any buffered bytes, then read directly from the extractor input.
     sampleBytesRemaining -= inputBuffer.drainToOutput(trackOutput, sampleBytesRemaining);
@@ -332,10 +332,9 @@ private long synchronize(ExtractorInput extractorInput) throws IOException, Inte
     if (seeker == null) {
       setupSeeker(extractorInput, headerPosition);
       extractorOutput.seekMap(seeker);
-      trackOutput.format(MediaFormat.createAudioFormat(MediaFormat.NO_VALUE,
-          synchronizedHeader.mimeType, MediaFormat.NO_VALUE, MpegAudioHeader.MAX_FRAME_SIZE_BYTES,
-          seeker.getDurationUs(), synchronizedHeader.channels, synchronizedHeader.sampleRate, null,
-          null));
+      trackOutput.format(MediaFormat.createAudioFormat(null, synchronizedHeader.mimeType,
+          MediaFormat.NO_VALUE, MpegAudioHeader.MAX_FRAME_SIZE_BYTES, seeker.getDurationUs(),
+          synchronizedHeader.channels, synchronizedHeader.sampleRate, null, null));
     }
 
     return headerPosition;
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/VbriSeeker.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/VbriSeeker.java
index 49cb846cd7..170a944409 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/VbriSeeker.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/VbriSeeker.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer.extractor.mp3;
 
+import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.util.MpegAudioHeader;
 import com.google.android.exoplayer.util.ParsableByteArray;
 import com.google.android.exoplayer.util.Util;
@@ -44,8 +45,8 @@ public static VbriSeeker create(MpegAudioHeader mpegAudioHeader, ParsableByteArr
       return null;
     }
     int sampleRate = mpegAudioHeader.sampleRate;
-    long durationUs = Util.scaleLargeTimestamp(
-        numFrames, 1000000L * (sampleRate >= 32000 ? 1152 : 576), sampleRate);
+    long durationUs = Util.scaleLargeTimestamp(numFrames,
+        C.MICROS_PER_SECOND * (sampleRate >= 32000 ? 1152 : 576), sampleRate);
     int numEntries = frame.readUnsignedShort();
     int scale = frame.readUnsignedShort();
     int entrySize = frame.readUnsignedShort();
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/XingSeeker.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/XingSeeker.java
index 7de38898c5..bc548f676c 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/XingSeeker.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/XingSeeker.java
@@ -50,7 +50,8 @@ public static XingSeeker create(MpegAudioHeader mpegAudioHeader, ParsableByteArr
       // If the frame count is missing/invalid, the header can't be used to determine the duration.
       return null;
     }
-    long durationUs = Util.scaleLargeTimestamp(frameCount, samplesPerFrame * 1000000L, sampleRate);
+    long durationUs = Util.scaleLargeTimestamp(frameCount, samplesPerFrame * C.MICROS_PER_SECOND,
+        sampleRate);
     if ((flags & 0x06) != 0x06) {
       // If the size in bytes or table of contents is missing, the stream is not seekable.
       return new XingSeeker(inputLength, firstFramePosition, durationUs);
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
index 21b5356367..23186e0d2a 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
@@ -53,6 +53,7 @@
   public static final int TYPE_d263 = Util.getIntegerCodeForString("d263");
   public static final int TYPE_mdat = Util.getIntegerCodeForString("mdat");
   public static final int TYPE_mp4a = Util.getIntegerCodeForString("mp4a");
+  public static final int TYPE_wave = Util.getIntegerCodeForString("wave");
   public static final int TYPE_ac_3 = Util.getIntegerCodeForString("ac-3");
   public static final int TYPE_dac3 = Util.getIntegerCodeForString("dac3");
   public static final int TYPE_ec_3 = Util.getIntegerCodeForString("ec-3");
@@ -80,6 +81,8 @@
   public static final int TYPE_traf = Util.getIntegerCodeForString("traf");
   public static final int TYPE_mvex = Util.getIntegerCodeForString("mvex");
   public static final int TYPE_tkhd = Util.getIntegerCodeForString("tkhd");
+  public static final int TYPE_edts = Util.getIntegerCodeForString("edts");
+  public static final int TYPE_elst = Util.getIntegerCodeForString("elst");
   public static final int TYPE_mdhd = Util.getIntegerCodeForString("mdhd");
   public static final int TYPE_hdlr = Util.getIntegerCodeForString("hdlr");
   public static final int TYPE_stsd = Util.getIntegerCodeForString("stsd");
@@ -98,7 +101,6 @@
   public static final int TYPE_pasp = Util.getIntegerCodeForString("pasp");
   public static final int TYPE_TTML = Util.getIntegerCodeForString("TTML");
   public static final int TYPE_vmhd = Util.getIntegerCodeForString("vmhd");
-  public static final int TYPE_smhd = Util.getIntegerCodeForString("smhd");
   public static final int TYPE_mp4v = Util.getIntegerCodeForString("mp4v");
   public static final int TYPE_stts = Util.getIntegerCodeForString("stts");
   public static final int TYPE_stss = Util.getIntegerCodeForString("stss");
@@ -109,6 +111,8 @@
   public static final int TYPE_co64 = Util.getIntegerCodeForString("co64");
   public static final int TYPE_tx3g = Util.getIntegerCodeForString("tx3g");
   public static final int TYPE_stpp = Util.getIntegerCodeForString("stpp");
+  public static final int TYPE_samr = Util.getIntegerCodeForString("samr");
+  public static final int TYPE_sawb = Util.getIntegerCodeForString("sawb");
 
   public final int type;
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
index f0c10fcd3e..345afeebc9 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
@@ -32,7 +32,9 @@
 import java.util.Collections;
 import java.util.List;
 
-/** Utility methods for parsing MP4 format atom payloads according to ISO 14496-12. */
+/**
+ * Utility methods for parsing MP4 format atom payloads according to ISO 14496-12.
+ */
 /* package */ final class AtomParsers {
 
   /**
@@ -40,9 +42,10 @@
    *
    * @param trak Atom to parse.
    * @param mvhd Movie header atom, used to get the timescale.
+   * @param isQuickTime True for QuickTime media. False otherwise.
    * @return A {@link Track} instance, or {@code null} if the track's type isn't supported.
    */
-  public static Track parseTrak(Atom.ContainerAtom trak, Atom.LeafAtom mvhd) {
+  public static Track parseTrak(Atom.ContainerAtom trak, Atom.LeafAtom mvhd, boolean isQuickTime) {
     Atom.ContainerAtom mdia = trak.getContainerAtomOfType(Atom.TYPE_mdia);
     int trackType = parseHdlr(mdia.getLeafAtomOfType(Atom.TYPE_hdlr).data);
     if (trackType != Track.TYPE_soun && trackType != Track.TYPE_vide && trackType != Track.TYPE_text
@@ -64,10 +67,12 @@ public static Track parseTrak(Atom.ContainerAtom trak, Atom.LeafAtom mvhd) {
 
     Pair<Long, String> mdhdData = parseMdhd(mdia.getLeafAtomOfType(Atom.TYPE_mdhd).data);
     StsdData stsdData = parseStsd(stbl.getLeafAtomOfType(Atom.TYPE_stsd).data, tkhdData.id,
-        durationUs, tkhdData.rotationDegrees, mdhdData.second);
+        durationUs, tkhdData.rotationDegrees, mdhdData.second, isQuickTime);
+    Pair<long[], long[]> edtsData = parseEdts(trak.getContainerAtomOfType(Atom.TYPE_edts));
     return stsdData.mediaFormat == null ? null
-        : new Track(tkhdData.id, trackType, mdhdData.first, durationUs, stsdData.mediaFormat,
-            stsdData.trackEncryptionBoxes, stsdData.nalUnitLengthFieldLength);
+        : new Track(tkhdData.id, trackType, mdhdData.first, movieTimescale, durationUs,
+            stsdData.mediaFormat, stsdData.trackEncryptionBoxes, stsdData.nalUnitLengthFieldLength,
+            edtsData.first, edtsData.second);
   }
 
   /**
@@ -240,15 +245,78 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
       }
     }
 
-    Util.scaleLargeTimestampsInPlace(timestamps, 1000000, track.timescale);
-
     // Check all the expected samples have been seen.
     Assertions.checkArgument(remainingSynchronizationSamples == 0);
     Assertions.checkArgument(remainingSamplesAtTimestampDelta == 0);
     Assertions.checkArgument(remainingSamplesInChunk == 0);
     Assertions.checkArgument(remainingTimestampDeltaChanges == 0);
     Assertions.checkArgument(remainingTimestampOffsetChanges == 0);
-    return new TrackSampleTable(offsets, sizes, maximumSize, timestamps, flags);
+
+    if (track.editListDurations == null) {
+      Util.scaleLargeTimestampsInPlace(timestamps, C.MICROS_PER_SECOND, track.timescale);
+      return new TrackSampleTable(offsets, sizes, maximumSize, timestamps, flags);
+    }
+
+    // See the BMFF spec (ISO 14496-12) subsection 8.6.6. Edit lists that truncate audio and
+    // require prerolling from a sync sample after reordering are not supported. This
+    // implementation handles simple discarding/delaying of samples. The extractor may place
+    // further restrictions on what edited streams are playable.
+
+    // Count the number of samples after applying edits.
+    int editedSampleCount = 0;
+    int nextSampleIndex = 0;
+    boolean copyMetadata = false;
+    for (int i = 0; i < track.editListDurations.length; i++) {
+      long mediaTime = track.editListMediaTimes[i];
+      if (mediaTime != -1) {
+        long duration = Util.scaleLargeTimestamp(track.editListDurations[i], track.timescale,
+            track.movieTimescale);
+        int startIndex = Util.binarySearchCeil(timestamps, mediaTime, true, true);
+        int endIndex = Util.binarySearchCeil(timestamps, mediaTime + duration, true, false);
+        editedSampleCount += endIndex - startIndex;
+        copyMetadata |= nextSampleIndex != startIndex;
+        nextSampleIndex = endIndex;
+      }
+    }
+    copyMetadata |= editedSampleCount != sampleCount;
+
+    // Calculate edited sample timestamps and update the corresponding metadata arrays.
+    long[] editedOffsets = copyMetadata ? new long[editedSampleCount] : offsets;
+    int[] editedSizes = copyMetadata ? new int[editedSampleCount] : sizes;
+    int editedMaximumSize = copyMetadata ? 0 : maximumSize;
+    int[] editedFlags = copyMetadata ? new int[editedSampleCount] : flags;
+    long[] editedTimestamps = new long[editedSampleCount];
+    long pts = 0;
+    int sampleIndex = 0;
+    for (int i = 0; i < track.editListDurations.length; i++) {
+      long mediaTime = track.editListMediaTimes[i];
+      long duration = track.editListDurations[i];
+      if (mediaTime != -1) {
+        long endMediaTime = mediaTime + Util.scaleLargeTimestamp(duration, track.timescale,
+            track.movieTimescale);
+        int startIndex = Util.binarySearchCeil(timestamps, mediaTime, true, true);
+        int endIndex = Util.binarySearchCeil(timestamps, endMediaTime, true, false);
+        if (copyMetadata) {
+          int count = endIndex - startIndex;
+          System.arraycopy(offsets, startIndex, editedOffsets, sampleIndex, count);
+          System.arraycopy(sizes, startIndex, editedSizes, sampleIndex, count);
+          System.arraycopy(flags, startIndex, editedFlags, sampleIndex, count);
+        }
+        for (int j = startIndex; j < endIndex; j++) {
+          long ptsUs = Util.scaleLargeTimestamp(pts, C.MICROS_PER_SECOND, track.movieTimescale);
+          long timeInSegmentUs = Util.scaleLargeTimestamp(timestamps[j] - mediaTime,
+              C.MICROS_PER_SECOND, track.timescale);
+          editedTimestamps[sampleIndex] = ptsUs + timeInSegmentUs;
+          if (copyMetadata && editedSizes[sampleIndex] > editedMaximumSize) {
+            editedMaximumSize = sizes[j];
+          }
+          sampleIndex++;
+        }
+      }
+      pts += duration;
+    }
+    return new TrackSampleTable(editedOffsets, editedSizes, editedMaximumSize, editedTimestamps,
+        editedFlags);
   }
 
   /**
@@ -362,10 +430,11 @@ private static int parseHdlr(ParsableByteArray hdlr) {
    * @param durationUs The duration of the track in microseconds.
    * @param rotationDegrees The rotation of the track in degrees.
    * @param language The language of the track.
+   * @param isQuickTime True for QuickTime media. False otherwise.
    * @return An object containing the parsed data.
    */
   private static StsdData parseStsd(ParsableByteArray stsd, int trackId, long durationUs,
-      int rotationDegrees, String language) {
+      int rotationDegrees, String language, boolean isQuickTime) {
     stsd.setPosition(Atom.FULL_HEADER_SIZE);
     int numberOfEntries = stsd.readInt();
     StsdData out = new StsdData(numberOfEntries);
@@ -383,18 +452,20 @@ private static StsdData parseStsd(ParsableByteArray stsd, int trackId, long dura
       } else if (childAtomType == Atom.TYPE_mp4a || childAtomType == Atom.TYPE_enca
           || childAtomType == Atom.TYPE_ac_3 || childAtomType == Atom.TYPE_ec_3
           || childAtomType == Atom.TYPE_dtsc || childAtomType == Atom.TYPE_dtse
-          || childAtomType == Atom.TYPE_dtsh || childAtomType == Atom.TYPE_dtsl) {
+          || childAtomType == Atom.TYPE_dtsh || childAtomType == Atom.TYPE_dtsl
+          || childAtomType == Atom.TYPE_samr || childAtomType == Atom.TYPE_sawb) {
         parseAudioSampleEntry(stsd, childAtomType, childStartPosition, childAtomSize, trackId,
-            durationUs, language, out, i);
+            durationUs, language, isQuickTime, out, i);
       } else if (childAtomType == Atom.TYPE_TTML) {
-        out.mediaFormat = MediaFormat.createTextFormat(trackId, MimeTypes.APPLICATION_TTML,
-            MediaFormat.NO_VALUE, durationUs, language);
+        out.mediaFormat = MediaFormat.createTextFormat(Integer.toString(trackId),
+            MimeTypes.APPLICATION_TTML, MediaFormat.NO_VALUE, durationUs, language);
       } else if (childAtomType == Atom.TYPE_tx3g) {
-        out.mediaFormat = MediaFormat.createTextFormat(trackId, MimeTypes.APPLICATION_TX3G,
-            MediaFormat.NO_VALUE, durationUs, language);
+        out.mediaFormat = MediaFormat.createTextFormat(Integer.toString(trackId),
+            MimeTypes.APPLICATION_TX3G, MediaFormat.NO_VALUE, durationUs, language);
       } else if (childAtomType == Atom.TYPE_stpp) {
-        out.mediaFormat = MediaFormat.createTextFormat(trackId, MimeTypes.APPLICATION_TTML,
-            MediaFormat.NO_VALUE, durationUs, language, 0 /* subsample timing is absolute */);
+        out.mediaFormat = MediaFormat.createTextFormat(Integer.toString(trackId),
+            MimeTypes.APPLICATION_TTML, MediaFormat.NO_VALUE, durationUs, language,
+            0 /* subsample timing is absolute */);
       }
       stsd.setPosition(childStartPosition + childAtomSize);
     }
@@ -464,9 +535,9 @@ private static void parseVideoSampleEntry(ParsableByteArray parent, int position
       return;
     }
 
-    out.mediaFormat = MediaFormat.createVideoFormat(trackId, mimeType, MediaFormat.NO_VALUE,
-        MediaFormat.NO_VALUE, durationUs, width, height, initializationData, rotationDegrees,
-        pixelWidthHeightRatio);
+    out.mediaFormat = MediaFormat.createVideoFormat(Integer.toString(trackId), mimeType,
+        MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, durationUs, width, height, initializationData,
+        rotationDegrees, pixelWidthHeightRatio);
   }
 
   private static AvcCData parseAvcCFromParent(ParsableByteArray parent, int position) {
@@ -541,6 +612,39 @@ private static AvcCData parseAvcCFromParent(ParsableByteArray parent, int positi
     return Pair.create(initializationData, lengthSizeMinusOne + 1);
   }
 
+  /**
+   * Parses the edts atom (defined in 14496-12 subsection 8.6.5).
+   *
+   * @param edtsAtom edts (edit box) atom to parse.
+   * @return Pair of edit list durations and edit list media times, or a pair of nulls if they are
+   *     not present.
+   */
+  private static Pair<long[], long[]> parseEdts(Atom.ContainerAtom edtsAtom) {
+    Atom.LeafAtom elst;
+    if (edtsAtom == null || (elst = edtsAtom.getLeafAtomOfType(Atom.TYPE_elst)) == null) {
+      return Pair.create(null, null);
+    }
+    ParsableByteArray elstData = elst.data;
+    elstData.setPosition(Atom.HEADER_SIZE);
+    int fullAtom = elstData.readInt();
+    int version = Atom.parseFullAtomVersion(fullAtom);
+    int entryCount = elstData.readUnsignedIntToInt();
+    long[] editListDurations = new long[entryCount];
+    long[] editListMediaTimes = new long[entryCount];
+    for (int i = 0; i < entryCount; i++) {
+      editListDurations[i] =
+          version == 1 ? elstData.readUnsignedLongToLong() : elstData.readUnsignedInt();
+      editListMediaTimes[i] = version == 1 ? elstData.readLong() : elstData.readInt();
+      int mediaRateInteger = elstData.readShort();
+      if (mediaRateInteger != 1) {
+        // The extractor does not handle dwell edits (mediaRateInteger == 0).
+        throw new IllegalArgumentException("Unsupported media rate.");
+      }
+      elstData.skipBytes(2);
+    }
+    return Pair.create(editListDurations, editListMediaTimes);
+  }
+
   private static TrackEncryptionBox parseSinfFromParent(ParsableByteArray parent, int position,
       int size) {
     int childPosition = position + Atom.HEADER_SIZE;
@@ -594,38 +698,64 @@ private static TrackEncryptionBox parseSchiFromParent(ParsableByteArray parent,
   }
 
   private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType, int position,
-      int size, int trackId, long durationUs, String language, StsdData out, int entryIndex) {
+      int size, int trackId, long durationUs, String language, boolean isQuickTime, StsdData out,
+      int entryIndex) {
     parent.setPosition(position + Atom.HEADER_SIZE);
-    parent.skipBytes(16);
+
+    int quickTimeSoundDescriptionVersion = 0;
+    if (isQuickTime) {
+      parent.skipBytes(8);
+      quickTimeSoundDescriptionVersion = parent.readUnsignedShort();
+      parent.skipBytes(6);
+    } else {
+      parent.skipBytes(16);
+    }
+
     int channelCount = parent.readUnsignedShort();
     int sampleSize = parent.readUnsignedShort();
     parent.skipBytes(4);
     int sampleRate = parent.readUnsignedFixedPoint1616();
 
+    if (quickTimeSoundDescriptionVersion > 0) {
+      parent.skipBytes(16);
+      if (quickTimeSoundDescriptionVersion == 2) {
+        parent.skipBytes(20);
+      }
+    }
+
     // If the atom type determines a MIME type, set it immediately.
     String mimeType = null;
     if (atomType == Atom.TYPE_ac_3) {
       mimeType = MimeTypes.AUDIO_AC3;
     } else if (atomType == Atom.TYPE_ec_3) {
-      mimeType = MimeTypes.AUDIO_EC3;
+      mimeType = MimeTypes.AUDIO_E_AC3;
     } else if (atomType == Atom.TYPE_dtsc || atomType == Atom.TYPE_dtse) {
       mimeType = MimeTypes.AUDIO_DTS;
     } else if (atomType == Atom.TYPE_dtsh || atomType == Atom.TYPE_dtsl) {
       mimeType = MimeTypes.AUDIO_DTS_HD;
+    } else if (atomType == Atom.TYPE_samr) {
+      mimeType = MimeTypes.AUDIO_AMR_NB;
+    } else if (atomType == Atom.TYPE_sawb) {
+      mimeType = MimeTypes.AUDIO_AMR_WB;
     }
 
     byte[] initializationData = null;
-    int childPosition = parent.getPosition();
-    while (childPosition - position < size) {
-      parent.setPosition(childPosition);
-      int childStartPosition = parent.getPosition();
+    int childAtomPosition = parent.getPosition();
+    while (childAtomPosition - position < size) {
+      parent.setPosition(childAtomPosition);
       int childAtomSize = parent.readInt();
       Assertions.checkArgument(childAtomSize > 0, "childAtomSize should be positive");
       int childAtomType = parent.readInt();
       if (atomType == Atom.TYPE_mp4a || atomType == Atom.TYPE_enca) {
+        int esdsAtomPosition = -1;
         if (childAtomType == Atom.TYPE_esds) {
+          esdsAtomPosition = childAtomPosition;
+        } else if (isQuickTime && childAtomType == Atom.TYPE_wave) {
+          esdsAtomPosition = findEsdsPosition(parent, childAtomPosition, childAtomSize);
+        }
+        if (esdsAtomPosition != -1) {
           Pair<String, byte[]> mimeTypeAndInitializationData =
-              parseEsdsFromParent(parent, childStartPosition);
+              parseEsdsFromParent(parent, esdsAtomPosition);
           mimeType = mimeTypeAndInitializationData.first;
           initializationData = mimeTypeAndInitializationData.second;
           if (MimeTypes.AUDIO_AAC.equals(mimeType)) {
@@ -637,27 +767,30 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
             channelCount = audioSpecificConfig.second;
           }
         } else if (childAtomType == Atom.TYPE_sinf) {
-          out.trackEncryptionBoxes[entryIndex] = parseSinfFromParent(parent, childStartPosition,
+          out.trackEncryptionBoxes[entryIndex] = parseSinfFromParent(parent, childAtomPosition,
               childAtomSize);
         }
       } else if (atomType == Atom.TYPE_ac_3 && childAtomType == Atom.TYPE_dac3) {
         // TODO: Choose the right AC-3 track based on the contents of dac3/dec3.
         // TODO: Add support for encryption (by setting out.trackEncryptionBoxes).
-        parent.setPosition(Atom.HEADER_SIZE + childStartPosition);
-        out.mediaFormat = Ac3Util.parseAnnexFAc3Format(parent, trackId, durationUs, language);
+        parent.setPosition(Atom.HEADER_SIZE + childAtomPosition);
+        out.mediaFormat = Ac3Util.parseAc3AnnexFFormat(parent, Integer.toString(trackId),
+            durationUs, language);
         return;
       } else if (atomType == Atom.TYPE_ec_3 && childAtomType == Atom.TYPE_dec3) {
-        parent.setPosition(Atom.HEADER_SIZE + childStartPosition);
-        out.mediaFormat = Ac3Util.parseAnnexFEAc3Format(parent, trackId, durationUs, language);
+        parent.setPosition(Atom.HEADER_SIZE + childAtomPosition);
+        out.mediaFormat = Ac3Util.parseEAc3AnnexFFormat(parent, Integer.toString(trackId),
+            durationUs, language);
         return;
       } else if ((atomType == Atom.TYPE_dtsc || atomType == Atom.TYPE_dtse
           || atomType == Atom.TYPE_dtsh || atomType == Atom.TYPE_dtsl)
           && childAtomType == Atom.TYPE_ddts) {
-        out.mediaFormat = MediaFormat.createAudioFormat(trackId, mimeType, MediaFormat.NO_VALUE,
-            MediaFormat.NO_VALUE, durationUs, channelCount, sampleRate, null, language);
+        out.mediaFormat = MediaFormat.createAudioFormat(Integer.toString(trackId), mimeType,
+            MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, durationUs, channelCount, sampleRate, null,
+            language);
         return;
       }
-      childPosition += childAtomSize;
+      childAtomPosition += childAtomSize;
     }
 
     // If the media type was not recognized, ignore the track.
@@ -665,12 +798,28 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
       return;
     }
 
-    out.mediaFormat = MediaFormat.createAudioFormat(trackId, mimeType, MediaFormat.NO_VALUE,
-        sampleSize, durationUs, channelCount, sampleRate,
+    out.mediaFormat = MediaFormat.createAudioFormat(Integer.toString(trackId), mimeType,
+        MediaFormat.NO_VALUE, sampleSize, durationUs, channelCount, sampleRate,
         initializationData == null ? null : Collections.singletonList(initializationData),
         language);
   }
 
+  /** Returns the position of the esds box within a parent, or -1 if no esds box is found */
+  private static int findEsdsPosition(ParsableByteArray parent, int position, int size) {
+    int childAtomPosition = parent.getPosition();
+    while (childAtomPosition - position < size) {
+      parent.setPosition(childAtomPosition);
+      int childAtomSize = parent.readInt();
+      Assertions.checkArgument(childAtomSize > 0, "childAtomSize should be positive");
+      int childType = parent.readInt();
+      if (childType == Atom.TYPE_esds) {
+        return childAtomPosition;
+      }
+      childAtomPosition += childAtomSize;
+    }
+    return -1;
+  }
+
   /** Returns codec-specific initialization data contained in an esds box. */
   private static Pair<String, byte[]> parseEsdsFromParent(ParsableByteArray parent, int position) {
     parent.setPosition(position + Atom.HEADER_SIZE + 4);
@@ -726,7 +875,7 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
         mimeType = MimeTypes.AUDIO_AC3;
         break;
       case 0xA6:
-        mimeType = MimeTypes.AUDIO_EC3;
+        mimeType = MimeTypes.AUDIO_E_AC3;
         break;
       case 0xA9:
       case 0xAC:
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
index 996eab4578..56b20274e0 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
@@ -16,7 +16,9 @@
 package com.google.android.exoplayer.extractor.mp4;
 
 import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.drm.DrmInitData;
+import com.google.android.exoplayer.drm.DrmInitData.SchemeInitData;
 import com.google.android.exoplayer.extractor.ChunkIndex;
 import com.google.android.exoplayer.extractor.Extractor;
 import com.google.android.exoplayer.extractor.ExtractorInput;
@@ -26,7 +28,6 @@
 import com.google.android.exoplayer.extractor.TrackOutput;
 import com.google.android.exoplayer.extractor.mp4.Atom.ContainerAtom;
 import com.google.android.exoplayer.extractor.mp4.Atom.LeafAtom;
-import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.NalUnitUtil;
 import com.google.android.exoplayer.util.ParsableByteArray;
@@ -226,23 +227,21 @@ private boolean readAtomHeader(ExtractorInput input) throws IOException, Interru
       return true;
     }
 
-    if (shouldParseAtom(atomType)) {
-      if (shouldParseContainerAtom(atomType)) {
-        long endPosition = input.getPosition() + atomSize - Atom.HEADER_SIZE;
-        containerAtoms.add(new ContainerAtom(atomType, endPosition));
-        enterReadingAtomHeaderState();
-      } else {
-        // We don't support parsing of leaf atoms that define extended atom sizes, or that have
-        // lengths greater than Integer.MAX_VALUE.
-        Assertions.checkState(atomHeaderBytesRead == Atom.HEADER_SIZE);
-        Assertions.checkState(atomSize <= Integer.MAX_VALUE);
-        atomData = new ParsableByteArray((int) atomSize);
-        System.arraycopy(atomHeader.data, 0, atomData.data, 0, Atom.HEADER_SIZE);
-        parserState = STATE_READING_ATOM_PAYLOAD;
-      }
+    if (shouldParseContainerAtom(atomType)) {
+      long endPosition = input.getPosition() + atomSize - Atom.HEADER_SIZE;
+      containerAtoms.add(new ContainerAtom(atomType, endPosition));
+      enterReadingAtomHeaderState();
+    } else if (shouldParseLeafAtom(atomType)) {
+      // We don't support parsing of leaf atoms that define extended atom sizes, or that have
+      // lengths greater than Integer.MAX_VALUE.
+      checkState(atomHeaderBytesRead == Atom.HEADER_SIZE);
+      checkState(atomSize <= Integer.MAX_VALUE);
+      atomData = new ParsableByteArray((int) atomSize);
+      System.arraycopy(atomHeader.data, 0, atomData.data, 0, Atom.HEADER_SIZE);
+      parserState = STATE_READING_ATOM_PAYLOAD;
     } else {
       // We don't support skipping of atoms that have lengths greater than Integer.MAX_VALUE.
-      Assertions.checkState(atomSize <= Integer.MAX_VALUE);
+      checkState(atomSize <= Integer.MAX_VALUE);
       atomData = null;
       parserState = STATE_READING_ATOM_PAYLOAD;
     }
@@ -265,7 +264,7 @@ private void readAtomPayload(ExtractorInput input) throws IOException, Interrupt
     enterReadingAtomHeaderState();
   }
 
-  private void onLeafAtomRead(LeafAtom leaf, long inputPosition) {
+  private void onLeafAtomRead(LeafAtom leaf, long inputPosition) throws ParserException {
     if (!containerAtoms.isEmpty()) {
       containerAtoms.peek().add(leaf);
     } else if (leaf.type == Atom.TYPE_sidx) {
@@ -275,7 +274,7 @@ private void onLeafAtomRead(LeafAtom leaf, long inputPosition) {
     }
   }
 
-  private void onContainerAtomRead(ContainerAtom container) {
+  private void onContainerAtomRead(ContainerAtom container) throws ParserException {
     if (container.type == Atom.TYPE_moov) {
       onMoovContainerAtomRead(container);
     } else if (container.type == Atom.TYPE_moof) {
@@ -285,7 +284,7 @@ private void onContainerAtomRead(ContainerAtom container) {
     }
   }
 
-  private void onMoovContainerAtomRead(ContainerAtom moov) {
+  private void onMoovContainerAtomRead(ContainerAtom moov) throws ParserException {
     List<Atom.LeafAtom> moovChildren = moov.leafChildren;
     int moovChildrenSize = moovChildren.size();
 
@@ -294,10 +293,11 @@ private void onMoovContainerAtomRead(ContainerAtom moov) {
       LeafAtom child = moovChildren.get(i);
       if (child.type == Atom.TYPE_pssh) {
         if (drmInitData == null) {
-          drmInitData = new DrmInitData.Mapped(MimeTypes.VIDEO_MP4);
+          drmInitData = new DrmInitData.Mapped();
         }
         byte[] psshData = child.data.data;
-        drmInitData.put(PsshAtomUtil.parseUuid(psshData), psshData);
+        drmInitData.put(PsshAtomUtil.parseUuid(psshData),
+            new SchemeInitData(MimeTypes.VIDEO_MP4, psshData));
       }
     }
     if (drmInitData != null) {
@@ -307,17 +307,29 @@ private void onMoovContainerAtomRead(ContainerAtom moov) {
     ContainerAtom mvex = moov.getContainerAtomOfType(Atom.TYPE_mvex);
     extendsDefaults = parseTrex(mvex.getLeafAtomOfType(Atom.TYPE_trex).data);
     track = AtomParsers.parseTrak(moov.getContainerAtomOfType(Atom.TYPE_trak),
-        moov.getLeafAtomOfType(Atom.TYPE_mvhd));
-    Assertions.checkState(track != null);
+        moov.getLeafAtomOfType(Atom.TYPE_mvhd), false);
+    checkState(track != null);
     trackOutput.format(track.mediaFormat);
   }
 
-  private void onMoofContainerAtomRead(ContainerAtom moof) {
+  private void onMoofContainerAtomRead(ContainerAtom moof) throws ParserException {
     fragmentRun.reset();
     parseMoof(track, extendsDefaults, moof, fragmentRun, workaroundFlags, extendedTypeScratch);
     sampleIndex = 0;
   }
 
+  private static void checkState(boolean expression) throws ParserException {
+    if (!expression) {
+      throw new ParserException();
+    }
+  }
+
+  private static void checkState(boolean expression, String errorMessage) throws ParserException {
+    if (!expression) {
+      throw new ParserException(errorMessage);
+    }
+  }
+
   /**
    * Parses a trex atom (defined in 14496-12).
    */
@@ -332,9 +344,10 @@ private static DefaultSampleValues parseTrex(ParsableByteArray trex) {
   }
 
   private static void parseMoof(Track track, DefaultSampleValues extendsDefaults,
-      ContainerAtom moof, TrackFragment out, int workaroundFlags, byte[] extendedTypeScratch) {
+      ContainerAtom moof, TrackFragment out, int workaroundFlags, byte[] extendedTypeScratch)
+      throws ParserException {
     // This extractor only supports one traf per moof.
-    Assertions.checkArgument(1 == moof.getChildAtomOfTypeCount(Atom.TYPE_traf));
+    checkState(1 == moof.getChildAtomOfTypeCount(Atom.TYPE_traf));
     parseTraf(track, extendsDefaults, moof.getContainerAtomOfType(Atom.TYPE_traf),
         out, workaroundFlags, extendedTypeScratch);
   }
@@ -343,9 +356,10 @@ private static void parseMoof(Track track, DefaultSampleValues extendsDefaults,
    * Parses a traf atom (defined in 14496-12).
    */
   private static void parseTraf(Track track, DefaultSampleValues extendsDefaults,
-      ContainerAtom traf, TrackFragment out, int workaroundFlags, byte[] extendedTypeScratch) {
+      ContainerAtom traf, TrackFragment out, int workaroundFlags, byte[] extendedTypeScratch)
+      throws ParserException {
     // This extractor only supports one trun per traf.
-    Assertions.checkArgument(1 == traf.getChildAtomOfTypeCount(Atom.TYPE_trun));
+    checkState(1 == traf.getChildAtomOfTypeCount(Atom.TYPE_trun));
     LeafAtom tfdtAtom = traf.getLeafAtomOfType(Atom.TYPE_tfdt);
     long decodeTime;
     if (tfdtAtom == null || (workaroundFlags & WORKAROUND_IGNORE_TFDT_BOX) != 0) {
@@ -387,7 +401,7 @@ private static void parseTraf(Track track, DefaultSampleValues extendsDefaults,
   }
 
   private static void parseSaiz(TrackEncryptionBox encryptionBox, ParsableByteArray saiz,
-      TrackFragment out) {
+      TrackFragment out) throws ParserException {
     int vectorSize = encryptionBox.initializationVectorSize;
     saiz.setPosition(Atom.HEADER_SIZE);
     int fullAtom = saiz.readInt();
@@ -399,7 +413,7 @@ private static void parseSaiz(TrackEncryptionBox encryptionBox, ParsableByteArra
 
     int sampleCount = saiz.readUnsignedIntToInt();
     if (sampleCount != out.length) {
-      throw new IllegalStateException("Length mismatch: " + sampleCount + ", " + out.length);
+      throw new ParserException("Length mismatch: " + sampleCount + ", " + out.length);
     }
 
     int totalSize = 0;
@@ -424,7 +438,7 @@ private static void parseSaiz(TrackEncryptionBox encryptionBox, ParsableByteArra
    * @param saio The saio atom to parse.
    * @param out The track fragment to populate with data from the saio atom.
    */
-  private static void parseSaio(ParsableByteArray saio, TrackFragment out) {
+  private static void parseSaio(ParsableByteArray saio, TrackFragment out) throws ParserException {
     saio.setPosition(Atom.HEADER_SIZE);
     int fullAtom = saio.readInt();
     int flags = Atom.parseFullAtomFlags(fullAtom);
@@ -435,7 +449,7 @@ private static void parseSaio(ParsableByteArray saio, TrackFragment out) {
     int entryCount = saio.readUnsignedIntToInt();
     if (entryCount != 1) {
       // We only support one trun element currently, so always expect one entry.
-      throw new IllegalStateException("Unexpected saio entry count: " + entryCount);
+      throw new ParserException("Unexpected saio entry count: " + entryCount);
     }
 
     int version = Atom.parseFullAtomVersion(fullAtom);
@@ -558,7 +572,7 @@ private static void parseTrun(Track track, DefaultSampleValues defaultSampleValu
   }
 
   private static void parseUuid(ParsableByteArray uuid, TrackFragment out,
-      byte[] extendedTypeScratch) {
+      byte[] extendedTypeScratch) throws ParserException {
     uuid.setPosition(Atom.HEADER_SIZE);
     uuid.readBytes(extendedTypeScratch, 0, 16);
 
@@ -573,24 +587,25 @@ private static void parseUuid(ParsableByteArray uuid, TrackFragment out,
     parseSenc(uuid, 16, out);
   }
 
-  private static void parseSenc(ParsableByteArray senc, TrackFragment out) {
+  private static void parseSenc(ParsableByteArray senc, TrackFragment out) throws ParserException {
     parseSenc(senc, 0, out);
   }
 
-  private static void parseSenc(ParsableByteArray senc, int offset, TrackFragment out) {
+  private static void parseSenc(ParsableByteArray senc, int offset, TrackFragment out)
+      throws ParserException {
     senc.setPosition(Atom.HEADER_SIZE + offset);
     int fullAtom = senc.readInt();
     int flags = Atom.parseFullAtomFlags(fullAtom);
 
     if ((flags & 0x01 /* override_track_encryption_box_parameters */) != 0) {
       // TODO: Implement this.
-      throw new IllegalStateException("Overriding TrackEncryptionBox parameters is unsupported");
+      throw new ParserException("Overriding TrackEncryptionBox parameters is unsupported.");
     }
 
     boolean subsampleEncryption = (flags & 0x02 /* use_subsample_encryption */) != 0;
     int sampleCount = senc.readUnsignedIntToInt();
     if (sampleCount != out.length) {
-      throw new IllegalStateException("Length mismatch: " + sampleCount + ", " + out.length);
+      throw new ParserException("Length mismatch: " + sampleCount + ", " + out.length);
     }
 
     Arrays.fill(out.sampleHasSubsampleEncryptionTable, 0, sampleCount, subsampleEncryption);
@@ -601,7 +616,8 @@ private static void parseSenc(ParsableByteArray senc, int offset, TrackFragment
   /**
    * Parses a sidx atom (defined in 14496-12).
    */
-  private static ChunkIndex parseSidx(ParsableByteArray atom, long inputPosition) {
+  private static ChunkIndex parseSidx(ParsableByteArray atom, long inputPosition)
+      throws ParserException {
     atom.setPosition(Atom.HEADER_SIZE);
     int fullAtom = atom.readInt();
     int version = Atom.parseFullAtomVersion(fullAtom);
@@ -633,7 +649,7 @@ private static ChunkIndex parseSidx(ParsableByteArray atom, long inputPosition)
 
       int type = 0x80000000 & firstInt;
       if (type != 0) {
-        throw new IllegalStateException("Unhandled indirect reference");
+        throw new ParserException("Unhandled indirect reference");
       }
       long referenceDuration = atom.readUnsignedInt();
 
@@ -656,7 +672,7 @@ private static ChunkIndex parseSidx(ParsableByteArray atom, long inputPosition)
 
   private void readEncryptionData(ExtractorInput input) throws IOException, InterruptedException {
     int bytesToSkip = (int) (fragmentRun.auxiliaryDataPosition - input.getPosition());
-    Assertions.checkState(bytesToSkip >= 0, "Offset to encryption data was negative.");
+    checkState(bytesToSkip >= 0, "Offset to encryption data was negative.");
     input.skipFully(bytesToSkip);
     fragmentRun.fillEncryptionData(input);
     parserState = STATE_READING_SAMPLE_START;
@@ -679,13 +695,13 @@ private void readEncryptionData(ExtractorInput input) throws IOException, Interr
   private boolean readSample(ExtractorInput input) throws IOException, InterruptedException {
     if (sampleIndex == 0) {
       int bytesToSkip = (int) (fragmentRun.dataPosition - input.getPosition());
-      Assertions.checkState(bytesToSkip >= 0, "Offset to sample data was negative.");
+      checkState(bytesToSkip >= 0, "Offset to sample data was negative.");
       input.skipFully(bytesToSkip);
     }
 
     if (sampleIndex >= fragmentRun.length) {
       int bytesToSkip = (int) (endOfMdatPosition - input.getPosition());
-      Assertions.checkState(bytesToSkip >= 0, "Offset to end of mdat was negative.");
+      checkState(bytesToSkip >= 0, "Offset to end of mdat was negative.");
       input.skipFully(bytesToSkip);
       // We've run out of samples in the current mdat atom.
       enterReadingAtomHeaderState();
@@ -779,25 +795,20 @@ private int appendSampleEncryptionData(ParsableByteArray sampleEncryptionData) {
     return 1 + vectorSize + subsampleDataLength;
   }
 
-  /** Returns whether the extractor should parse an atom with type {@code atom}. */
-  private static boolean shouldParseAtom(int atom) {
-    return atom == Atom.TYPE_avc1 || atom == Atom.TYPE_avc3 || atom == Atom.TYPE_esds
-        || atom == Atom.TYPE_hdlr || atom == Atom.TYPE_mdat || atom == Atom.TYPE_mdhd
-        || atom == Atom.TYPE_moof || atom == Atom.TYPE_moov || atom == Atom.TYPE_mp4a
-        || atom == Atom.TYPE_mvhd || atom == Atom.TYPE_sidx || atom == Atom.TYPE_stsd
-        || atom == Atom.TYPE_tfdt || atom == Atom.TYPE_tfhd || atom == Atom.TYPE_tkhd
-        || atom == Atom.TYPE_traf || atom == Atom.TYPE_trak || atom == Atom.TYPE_trex
-        || atom == Atom.TYPE_trun || atom == Atom.TYPE_mvex || atom == Atom.TYPE_mdia
-        || atom == Atom.TYPE_minf || atom == Atom.TYPE_stbl || atom == Atom.TYPE_pssh
-        || atom == Atom.TYPE_saiz || atom == Atom.TYPE_saio || atom == Atom.TYPE_uuid
-        || atom == Atom.TYPE_senc || atom == Atom.TYPE_pasp || atom == Atom.TYPE_s263;
+  /** Returns whether the extractor should parse a leaf atom with type {@code atom}. */
+  private static boolean shouldParseLeafAtom(int atom) {
+    return atom == Atom.TYPE_hdlr || atom == Atom.TYPE_mdhd || atom == Atom.TYPE_mvhd
+        || atom == Atom.TYPE_sidx || atom == Atom.TYPE_stsd || atom == Atom.TYPE_tfdt
+        || atom == Atom.TYPE_tfhd || atom == Atom.TYPE_tkhd || atom == Atom.TYPE_trex
+        || atom == Atom.TYPE_trun || atom == Atom.TYPE_pssh || atom == Atom.TYPE_saiz
+        || atom == Atom.TYPE_saio || atom == Atom.TYPE_senc || atom == Atom.TYPE_uuid;
   }
 
   /** Returns whether the extractor should parse a container atom with type {@code atom}. */
   private static boolean shouldParseContainerAtom(int atom) {
     return atom == Atom.TYPE_moov || atom == Atom.TYPE_trak || atom == Atom.TYPE_mdia
-        || atom == Atom.TYPE_minf || atom == Atom.TYPE_stbl || atom == Atom.TYPE_avcC
-        || atom == Atom.TYPE_moof || atom == Atom.TYPE_traf || atom == Atom.TYPE_mvex;
+        || atom == Atom.TYPE_minf || atom == Atom.TYPE_stbl || atom == Atom.TYPE_moof
+        || atom == Atom.TYPE_traf || atom == Atom.TYPE_mvex;
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
index 3c7611b02c..a1f01b0cb8 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
@@ -25,6 +25,7 @@
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.NalUnitUtil;
 import com.google.android.exoplayer.util.ParsableByteArray;
+import com.google.android.exoplayer.util.Util;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -42,6 +43,9 @@
   private static final int STATE_READING_ATOM_PAYLOAD = 2;
   private static final int STATE_READING_SAMPLE = 3;
 
+  // Brand stored in the ftyp atom for QuickTime media.
+  private static final int BRAND_QUICKTIME = Util.getIntegerCodeForString("qt  ");
+
   /**
    * When seeking within the source, if the offset is greater than or equal to this value (or the
    * offset is negative), the source will be reloaded.
@@ -68,6 +72,7 @@
   // Extractor outputs.
   private ExtractorOutput extractorOutput;
   private Mp4Track[] tracks;
+  private boolean isQuickTime;
 
   public Mp4Extractor() {
     atomHeader = new ParsableByteArray(Atom.LONG_HEADER_SIZE);
@@ -138,11 +143,12 @@ public long getPosition(long timeUs) {
       TrackSampleTable sampleTable = tracks[trackIndex].sampleTable;
       int sampleIndex = sampleTable.getIndexOfEarlierOrEqualSynchronizationSample(timeUs);
       if (sampleIndex == TrackSampleTable.NO_SAMPLE) {
+        // Handle the case where the requested time is before the first synchronization sample.
         sampleIndex = sampleTable.getIndexOfLaterOrEqualSynchronizationSample(timeUs);
       }
       tracks[trackIndex].sampleIndex = sampleIndex;
 
-      long offset = sampleTable.offsets[tracks[trackIndex].sampleIndex];
+      long offset = sampleTable.offsets[sampleIndex];
       if (offset < earliestSamplePosition) {
         earliestSamplePosition = offset;
       }
@@ -209,7 +215,9 @@ private boolean readAtomPayload(ExtractorInput input, PositionHolder positionHol
     boolean seekRequired = false;
     if (atomData != null) {
       input.readFully(atomData.data, atomHeaderBytesRead, (int) atomPayloadSize);
-      if (!containerAtoms.isEmpty()) {
+      if (atomType == Atom.TYPE_ftyp) {
+        isQuickTime = processFtypAtom(atomData);
+      } else if (!containerAtoms.isEmpty()) {
         containerAtoms.peek().add(new Atom.LeafAtom(atomType, atomData));
       }
     } else {
@@ -239,6 +247,27 @@ private boolean readAtomPayload(ExtractorInput input, PositionHolder positionHol
     return seekRequired;
   }
 
+  /**
+   * Process an ftyp atom to determine whether the media is QuickTime.
+   *
+   * @param atomData The ftyp atom data.
+   * @return True if the media is QuickTime. False otherwise.
+   */
+  private static boolean processFtypAtom(ParsableByteArray atomData) {
+    atomData.setPosition(Atom.HEADER_SIZE);
+    int majorBrand = atomData.readInt();
+    if (majorBrand == BRAND_QUICKTIME) {
+      return true;
+    }
+    atomData.skipBytes(4); // minor_version
+    while (atomData.bytesLeft() > 0) {
+      if (atomData.readInt() == BRAND_QUICKTIME) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   /** Updates the stored track metadata to reflect the contents of the specified moov atom. */
   private void processMoovAtom(ContainerAtom moov) {
     List<Mp4Track> tracks = new ArrayList<>();
@@ -249,7 +278,8 @@ private void processMoovAtom(ContainerAtom moov) {
         continue;
       }
 
-      Track track = AtomParsers.parseTrak(atom, moov.getLeafAtomOfType(Atom.TYPE_mvhd));
+      Track track = AtomParsers.parseTrak(atom, moov.getLeafAtomOfType(Atom.TYPE_mvhd),
+          isQuickTime);
       if (track == null) {
         continue;
       }
@@ -383,18 +413,16 @@ private int getTrackIndexOfEarliestCurrentSample() {
   /** Returns whether the extractor should parse a leaf atom with type {@code atom}. */
   private static boolean shouldParseLeafAtom(int atom) {
     return atom == Atom.TYPE_mdhd || atom == Atom.TYPE_mvhd || atom == Atom.TYPE_hdlr
-        || atom == Atom.TYPE_vmhd || atom == Atom.TYPE_smhd || atom == Atom.TYPE_stsd
-        || atom == Atom.TYPE_avc1 || atom == Atom.TYPE_avcC || atom == Atom.TYPE_mp4a
-        || atom == Atom.TYPE_esds || atom == Atom.TYPE_stts || atom == Atom.TYPE_stss
-        || atom == Atom.TYPE_ctts || atom == Atom.TYPE_stsc || atom == Atom.TYPE_stsz
-        || atom == Atom.TYPE_stco || atom == Atom.TYPE_co64 || atom == Atom.TYPE_tkhd
-        || atom == Atom.TYPE_s263;
+        || atom == Atom.TYPE_stsd || atom == Atom.TYPE_stts || atom == Atom.TYPE_stss
+        || atom == Atom.TYPE_ctts || atom == Atom.TYPE_elst || atom == Atom.TYPE_stsc
+        || atom == Atom.TYPE_stsz || atom == Atom.TYPE_stco || atom == Atom.TYPE_co64
+        || atom == Atom.TYPE_tkhd || atom == Atom.TYPE_ftyp;
   }
 
   /** Returns whether the extractor should parse a container atom with type {@code atom}. */
   private static boolean shouldParseContainerAtom(int atom) {
     return atom == Atom.TYPE_moov || atom == Atom.TYPE_trak || atom == Atom.TYPE_mdia
-        || atom == Atom.TYPE_minf || atom == Atom.TYPE_stbl;
+        || atom == Atom.TYPE_minf || atom == Atom.TYPE_stbl || atom == Atom.TYPE_edts;
   }
 
   private static final class Mp4Track {
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Track.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Track.java
index bd04be1c64..1459e71a31 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Track.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Track.java
@@ -46,6 +46,11 @@
    */
   public final long timescale;
 
+  /**
+   * The movie timescale.
+   */
+  public final long movieTimescale;
+
   /**
    * The duration of the track in microseconds, or {@link C#UNKNOWN_TIME_US} if unknown.
    */
@@ -61,21 +66,35 @@
    */
   public final TrackEncryptionBox[] sampleDescriptionEncryptionBoxes;
 
+  /**
+   * Durations of edit list segments in the movie timescale. Null if there is no edit list.
+   */
+  public final long[] editListDurations;
+
+  /**
+   * Media times for edit list segments in the track timescale. Null if there is no edit list.
+   */
+  public final long[] editListMediaTimes;
+
   /**
    * For H264 video tracks, the length in bytes of the NALUnitLength field in each sample. -1 for
    * other track types.
    */
   public final int nalUnitLengthFieldLength;
 
-  public Track(int id, int type, long timescale, long durationUs, MediaFormat mediaFormat,
-      TrackEncryptionBox[] sampleDescriptionEncryptionBoxes, int nalUnitLengthFieldLength) {
+  public Track(int id, int type, long timescale, long movieTimescale, long durationUs,
+      MediaFormat mediaFormat, TrackEncryptionBox[] sampleDescriptionEncryptionBoxes,
+      int nalUnitLengthFieldLength, long[] editListDurations, long[] editListMediaTimes) {
     this.id = id;
     this.type = type;
     this.timescale = timescale;
+    this.movieTimescale = movieTimescale;
     this.durationUs = durationUs;
     this.mediaFormat = mediaFormat;
     this.sampleDescriptionEncryptionBoxes = sampleDescriptionEncryptionBoxes;
     this.nalUnitLengthFieldLength = nalUnitLengthFieldLength;
+    this.editListDurations = editListDurations;
+    this.editListMediaTimes = editListMediaTimes;
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/TrackSampleTable.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/TrackSampleTable.java
index 6717b3c54a..313d6d8db5 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/TrackSampleTable.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/TrackSampleTable.java
@@ -75,9 +75,11 @@
    * @return Index of the synchronization sample, or {@link #NO_SAMPLE} if none.
    */
   public int getIndexOfEarlierOrEqualSynchronizationSample(long timeUs) {
+    // Video frame timestamps may not be sorted, so the behavior of this call can be undefined.
+    // Frames are not reordered past synchronization samples so this works in practice.
     int startIndex = Util.binarySearchFloor(timestampsUs, timeUs, true, false);
     for (int i = startIndex; i >= 0; i--) {
-      if (timestampsUs[i] <= timeUs && (flags[i] & C.SAMPLE_FLAG_SYNC) != 0) {
+      if ((flags[i] & C.SAMPLE_FLAG_SYNC) != 0) {
         return i;
       }
     }
@@ -94,7 +96,7 @@ public int getIndexOfEarlierOrEqualSynchronizationSample(long timeUs) {
   public int getIndexOfLaterOrEqualSynchronizationSample(long timeUs) {
     int startIndex = Util.binarySearchCeil(timestampsUs, timeUs, true, false);
     for (int i = startIndex; i < timestampsUs.length; i++) {
-      if (timestampsUs[i] >= timeUs && (flags[i] & C.SAMPLE_FLAG_SYNC) != 0) {
+      if ((flags[i] & C.SAMPLE_FLAG_SYNC) != 0) {
         return i;
       }
     }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/Ac3Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/Ac3Reader.java
index baa4687450..b167fb5fe1 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/Ac3Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/Ac3Reader.java
@@ -23,7 +23,7 @@
 import com.google.android.exoplayer.util.ParsableByteArray;
 
 /**
- * Parses a continuous AC-3 byte stream and extracts individual samples.
+ * Parses a continuous (E-)AC-3 byte stream and extracts individual samples.
  */
 /* package */ final class Ac3Reader extends ElementaryStreamReader {
 
@@ -33,6 +33,7 @@
 
   private static final int HEADER_SIZE = 8;
 
+  private final boolean isEac3;
   private final ParsableBitArray headerScratchBits;
   private final ParsableByteArray headerScratchBytes;
 
@@ -43,16 +44,23 @@
   private boolean lastByteWas0B;
 
   // Used when parsing the header.
-  private long frameDurationUs;
+  private long sampleDurationUs;
   private MediaFormat mediaFormat;
   private int sampleSize;
-  private int bitrate;
 
   // Used when reading the samples.
   private long timeUs;
 
-  public Ac3Reader(TrackOutput output) {
+  /**
+   * Constructs a new reader for (E-)AC-3 elementary streams.
+   *
+   * @param output Track output for extracted samples.
+   * @param isEac3 Whether the stream is E-AC-3 (ETSI TS 102 366 Annex E). Specify {@code false} to
+   *     parse sample headers as AC-3.
+   */
+  public Ac3Reader(TrackOutput output, boolean isEac3) {
     super(output);
+    this.isEac3 = isEac3;
     headerScratchBits = new ParsableBitArray(new byte[HEADER_SIZE]);
     headerScratchBytes = new ParsableByteArray(headerScratchBits.data);
     state = STATE_FINDING_SYNC;
@@ -94,7 +102,7 @@ public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacke
           bytesRead += bytesToRead;
           if (bytesRead == sampleSize) {
             output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
-            timeUs += frameDurationUs;
+            timeUs += sampleDurationUs;
             state = STATE_FINDING_SYNC;
           }
           break;
@@ -124,11 +132,11 @@ private boolean continueRead(ParsableByteArray source, byte[] target, int target
   }
 
   /**
-   * Locates the next sync word, advancing the position to the byte that immediately follows it.
-   * If a sync word was not located, the position is advanced to the limit.
+   * Locates the next syncword, advancing the position to the byte that immediately follows it. If a
+   * syncword was not located, the position is advanced to the limit.
    *
    * @param pesBuffer The buffer whose position should be advanced.
-   * @return True if a sync word position was found. False otherwise.
+   * @return True if a syncword position was found. False otherwise.
    */
   private boolean skipToNextSync(ParsableByteArray pesBuffer) {
     while (pesBuffer.bytesLeft() > 0) {
@@ -151,16 +159,21 @@ private boolean skipToNextSync(ParsableByteArray pesBuffer) {
    * Parses the sample header.
    */
   private void parseHeader() {
-    headerScratchBits.setPosition(0);
-    sampleSize = Ac3Util.parseFrameSize(headerScratchBits);
     if (mediaFormat == null) {
-      headerScratchBits.setPosition(0);
-      mediaFormat = Ac3Util.parseFrameAc3Format(headerScratchBits, MediaFormat.NO_VALUE,
-          C.UNKNOWN_TIME_US, null);
+      mediaFormat = isEac3
+          ? Ac3Util.parseEac3SyncframeFormat(headerScratchBits, null, C.UNKNOWN_TIME_US, null)
+          : Ac3Util.parseAc3SyncframeFormat(headerScratchBits, null, C.UNKNOWN_TIME_US, null);
       output.format(mediaFormat);
-      bitrate = Ac3Util.getBitrate(sampleSize, mediaFormat.sampleRate);
     }
-    frameDurationUs = (int) (1000L * 8 * sampleSize / bitrate);
+    sampleSize = isEac3 ? Ac3Util.parseEAc3SyncframeSize(headerScratchBits.data)
+        : Ac3Util.parseAc3SyncframeSize(headerScratchBits.data);
+    int audioSamplesPerSyncframe = isEac3
+        ? Ac3Util.parseEAc3SyncframeAudioSampleCount(headerScratchBits.data)
+        : Ac3Util.getAc3SyncframeAudioSampleCount();
+    // In this class a sample is an access unit (syncframe in AC-3), but the MediaFormat sample rate
+    // specifies the number of PCM audio samples per second.
+    sampleDurationUs =
+        (int) (C.MICROS_PER_SECOND * audioSamplesPerSyncframe / mediaFormat.sampleRate);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
index cbdc58872a..f4976e8ce0 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
@@ -50,7 +50,7 @@
 
   // Used when parsing the header.
   private boolean hasOutputFormat;
-  private long frameDurationUs;
+  private long sampleDurationUs;
   private int sampleSize;
 
   // Used when reading the samples.
@@ -96,7 +96,7 @@ public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacke
           bytesRead += bytesToRead;
           if (bytesRead == sampleSize) {
             output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
-            timeUs += frameDurationUs;
+            timeUs += sampleDurationUs;
             bytesRead = 0;
             state = STATE_FINDING_SYNC;
           }
@@ -170,11 +170,12 @@ private void parseHeader() {
       Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAacAudioSpecificConfig(
           audioSpecificConfig);
 
-      MediaFormat mediaFormat = MediaFormat.createAudioFormat(MediaFormat.NO_VALUE,
-          MimeTypes.AUDIO_AAC, MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US,
-          audioParams.second, audioParams.first, Collections.singletonList(audioSpecificConfig),
-          null);
-      frameDurationUs = (C.MICROS_PER_SECOND * 1024L) / mediaFormat.sampleRate;
+      MediaFormat mediaFormat = MediaFormat.createAudioFormat(null, MimeTypes.AUDIO_AAC,
+          MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US, audioParams.second,
+          audioParams.first, Collections.singletonList(audioSpecificConfig), null);
+      // In this class a sample is an access unit, but the MediaFormat sample rate specifies the
+      // number of PCM audio samples per second.
+      sampleDurationUs = (C.MICROS_PER_SECOND * 1024) / mediaFormat.sampleRate;
       output.format(mediaFormat);
       hasOutputFormat = true;
     } else {
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H262Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H262Reader.java
new file mode 100644
index 0000000000..8e94411814
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H262Reader.java
@@ -0,0 +1,236 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ts;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.NalUnitUtil;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.util.Arrays;
+import java.util.Collections;
+
+/**
+ * Parses a continuous H262 byte stream and extracts individual frames.
+ */
+/* package */ final class H262Reader extends ElementaryStreamReader {
+
+  private static final int START_PICTURE = 0x00;
+  private static final int START_SEQUENCE_HEADER = 0xB3;
+  private static final int START_EXTENSION = 0xB5;
+  private static final int START_GROUP = 0xB8;
+
+  // State that should not be reset on seek.
+  private boolean hasOutputFormat;
+
+  // State that should be reset on seek.
+  private final boolean[] prefixFlags;
+  private final CsdBuffer csdBuffer;
+  private boolean foundFirstFrameInGroup;
+  private long totalBytesWritten;
+
+  // Per sample state that gets reset at the start of each frame.
+  private boolean isKeyframe;
+  private long framePosition;
+  private long frameTimeUs;
+
+  public H262Reader(TrackOutput output) {
+    super(output);
+    prefixFlags = new boolean[4];
+    csdBuffer = new CsdBuffer(128);
+  }
+
+  @Override
+  public void seek() {
+    NalUnitUtil.clearPrefixFlags(prefixFlags);
+    csdBuffer.reset();
+    foundFirstFrameInGroup = false;
+    totalBytesWritten = 0;
+  }
+
+  @Override
+  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
+    while (data.bytesLeft() > 0) {
+      int offset = data.getPosition();
+      int limit = data.limit();
+      byte[] dataArray = data.data;
+
+      // Append the data to the buffer.
+      totalBytesWritten += data.bytesLeft();
+      output.sampleData(data, data.bytesLeft());
+
+      int searchOffset = offset;
+      while (true) {
+        int startCodeOffset = NalUnitUtil.findNalUnit(dataArray, searchOffset, limit, prefixFlags);
+
+        if (startCodeOffset == limit) {
+          // We've scanned to the end of the data without finding another start code.
+          if (!hasOutputFormat) {
+            csdBuffer.onData(dataArray, offset, limit);
+          }
+          return;
+        }
+
+        // We've found a start code with the following value.
+        int startCodeValue = data.data[startCodeOffset + 3] & 0xFF;
+
+        if (!hasOutputFormat) {
+          // This is the number of bytes from the current offset to the start of the next start
+          // code. It may be negative if the start code started in the previously consumed data.
+          int lengthToStartCode = startCodeOffset - offset;
+          if (lengthToStartCode > 0) {
+            csdBuffer.onData(dataArray, offset, startCodeOffset);
+          }
+          // This is the number of bytes belonging to the next start code that have already been
+          // passed to csdDataTargetBuffer.
+          int bytesAlreadyPassed = lengthToStartCode < 0 ? -lengthToStartCode : 0;
+          if (csdBuffer.onStartCode(startCodeValue, bytesAlreadyPassed)) {
+            // The csd data is complete, so we can parse and output the media format.
+            output.format(parseMediaFormat(csdBuffer));
+            hasOutputFormat = true;
+          }
+        }
+
+        if (hasOutputFormat && (startCodeValue == START_GROUP || startCodeValue == START_PICTURE)) {
+          int bytesWrittenPastStartCode = limit - startCodeOffset;
+          if (foundFirstFrameInGroup) {
+            int flags = isKeyframe ? C.SAMPLE_FLAG_SYNC : 0;
+            int size = (int) (totalBytesWritten - framePosition) - bytesWrittenPastStartCode;
+            output.sampleMetadata(frameTimeUs, flags, size, bytesWrittenPastStartCode, null);
+            isKeyframe = false;
+          }
+          if (startCodeValue == START_GROUP) {
+            foundFirstFrameInGroup = false;
+            isKeyframe = true;
+          } else /* startCode == START_PICTURE */ {
+            foundFirstFrameInGroup = true;
+            frameTimeUs = pesTimeUs;
+            framePosition = totalBytesWritten - bytesWrittenPastStartCode;
+          }
+        }
+
+        offset = startCodeOffset;
+        searchOffset = offset + 3;
+      }
+    }
+  }
+
+  @Override
+  public void packetFinished() {
+    // Do nothing.
+  }
+
+  private static MediaFormat parseMediaFormat(CsdBuffer csdBuffer) {
+    byte[] csdData = Arrays.copyOf(csdBuffer.data, csdBuffer.length);
+
+    int firstByte = csdData[4] & 0xFF;
+    int secondByte = csdData[5] & 0xFF;
+    int thirdByte = csdData[6] & 0xFF;
+    int width = (firstByte << 4) | (secondByte >> 4);
+    int height = (secondByte & 0x0F) << 8 | thirdByte;
+
+    float pixelWidthHeightRatio = 1f;
+    int aspectRatioCode = (csdData[7] & 0xF0) >> 4;
+    switch(aspectRatioCode) {
+      case 2:
+        pixelWidthHeightRatio = (4 * height) / (float) (3 * width);
+        break;
+      case 3:
+        pixelWidthHeightRatio = (16 * height) / (float) (9 * width);
+        break;
+      case 4:
+        pixelWidthHeightRatio = (121 * height) / (float) (100 * width);
+        break;
+      default:
+        // Do nothing.
+        break;
+    }
+
+    return MediaFormat.createVideoFormat(null, MimeTypes.VIDEO_MPEG2, MediaFormat.NO_VALUE,
+        MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US, width, height, Collections.singletonList(csdData),
+        MediaFormat.NO_VALUE, pixelWidthHeightRatio);
+  }
+
+  private static final class CsdBuffer {
+
+    private boolean isFilling;
+    private boolean seenExtensionStartCode;
+
+    public int length;
+    public byte[] data;
+
+    public CsdBuffer(int initialCapacity) {
+      data = new byte[initialCapacity];
+    }
+
+    /**
+     * Resets the buffer, clearing any data that it holds.
+     */
+    public void reset() {
+      isFilling = false;
+      seenExtensionStartCode = false;
+      length = 0;
+    }
+
+    /**
+     * Invoked when a start code is encountered in the stream.
+     *
+     * @param startCodeValue The start code value.
+     * @param bytesAlreadyPassed The number of bytes of the start code that have already been
+     *     passed to {@link #onData(byte[], int, int)}, or 0.
+     * @return True if the csd data is now complete. False otherwise. If true is returned, neither
+     *     this method or {@link #onData(byte[], int, int)} should be called again without an
+     *     interleaving call to {@link #reset()}.
+     */
+    public boolean onStartCode(int startCodeValue, int bytesAlreadyPassed) {
+      if (isFilling) {
+        if (!seenExtensionStartCode && startCodeValue == START_EXTENSION) {
+          seenExtensionStartCode = true;
+        } else {
+          length -= bytesAlreadyPassed;
+          isFilling = false;
+          return true;
+        }
+      } else if (startCodeValue == START_SEQUENCE_HEADER) {
+        isFilling = true;
+      }
+      return false;
+    }
+
+    /**
+     * Invoked to pass stream data.
+     *
+     * @param newData Holds the data being passed.
+     * @param offset The offset of the data in {@code data}.
+     * @param limit The limit (exclusive) of the data in {@code data}.
+     */
+    public void onData(byte[] newData, int offset, int limit) {
+      if (!isFilling) {
+        return;
+      }
+      int readLength = limit - offset;
+      if (data.length < length + readLength) {
+        data = Arrays.copyOf(data, (length + readLength) * 2);
+      }
+      System.arraycopy(newData, offset, data, length, readLength);
+      length += readLength;
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java
index 848e40b29d..0465e6f573 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java
@@ -102,56 +102,60 @@ public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacke
       output.sampleData(data, data.bytesLeft());
 
       // Scan the appended data, processing NAL units as they are encountered
-      while (offset < limit) {
-        int nextNalUnitOffset = NalUnitUtil.findNalUnit(dataArray, offset, limit, prefixFlags);
-        if (nextNalUnitOffset < limit) {
-          // We've seen the start of a NAL unit.
-
-          // This is the length to the start of the unit. It may be negative if the NAL unit
-          // actually started in previously consumed data.
-          int lengthToNalUnit = nextNalUnitOffset - offset;
-          if (lengthToNalUnit > 0) {
-            feedNalUnitTargetBuffersData(dataArray, offset, nextNalUnitOffset);
-          }
-
-          int nalUnitType = NalUnitUtil.getNalUnitType(dataArray, nextNalUnitOffset);
-          int bytesWrittenPastNalUnit = limit - nextNalUnitOffset;
-          switch (nalUnitType) {
-            case NAL_UNIT_TYPE_IDR:
-              isKeyframe = true;
-              break;
-            case NAL_UNIT_TYPE_AUD:
-              if (foundFirstSample) {
-                if (ifrParserBuffer != null && ifrParserBuffer.isCompleted()) {
-                  int sliceType = ifrParserBuffer.getSliceType();
-                  isKeyframe |= (sliceType == FRAME_TYPE_I || sliceType == FRAME_TYPE_ALL_I);
-                  ifrParserBuffer.reset();
-                }
-                if (isKeyframe && !hasOutputFormat && sps.isCompleted() && pps.isCompleted()) {
-                  parseMediaFormat(sps, pps);
-                }
-                int flags = isKeyframe ? C.SAMPLE_FLAG_SYNC : 0;
-                int size = (int) (totalBytesWritten - samplePosition) - bytesWrittenPastNalUnit;
-                output.sampleMetadata(sampleTimeUs, flags, size, bytesWrittenPastNalUnit, null);
-              }
-              foundFirstSample = true;
-              samplePosition = totalBytesWritten - bytesWrittenPastNalUnit;
-              sampleTimeUs = pesTimeUs;
-              isKeyframe = false;
-              break;
-          }
-
-          // If the length to the start of the unit is negative then we wrote too many bytes to the
-          // NAL buffers. Discard the excess bytes when notifying that the unit has ended.
-          feedNalUnitTargetEnd(pesTimeUs, lengthToNalUnit < 0 ? -lengthToNalUnit : 0);
-          // Notify the start of the next NAL unit.
-          feedNalUnitTargetBuffersStart(nalUnitType);
-          // Continue scanning the data.
-          offset = nextNalUnitOffset + 3;
-        } else {
+      while (true) {
+        int nalUnitOffset = NalUnitUtil.findNalUnit(dataArray, offset, limit, prefixFlags);
+
+        if (nalUnitOffset == limit) {
+          // We've scanned to the end of the data without finding the start of another NAL unit.
           feedNalUnitTargetBuffersData(dataArray, offset, limit);
-          offset = limit;
+          return;
+        }
+
+        // We've seen the start of a NAL unit of the following type.
+        int nalUnitType = NalUnitUtil.getNalUnitType(dataArray, nalUnitOffset);
+
+        // This is the number of bytes from the current offset to the start of the next NAL unit.
+        // It may be negative if the NAL unit started in the previously consumed data.
+        int lengthToNalUnit = nalUnitOffset - offset;
+        if (lengthToNalUnit > 0) {
+          feedNalUnitTargetBuffersData(dataArray, offset, nalUnitOffset);
         }
+
+        switch (nalUnitType) {
+          case NAL_UNIT_TYPE_IDR:
+            isKeyframe = true;
+            break;
+          case NAL_UNIT_TYPE_AUD:
+            int bytesWrittenPastNalUnit = limit - nalUnitOffset;
+            if (foundFirstSample) {
+              if (ifrParserBuffer != null && ifrParserBuffer.isCompleted()) {
+                int sliceType = ifrParserBuffer.getSliceType();
+                isKeyframe |= (sliceType == FRAME_TYPE_I || sliceType == FRAME_TYPE_ALL_I);
+                ifrParserBuffer.reset();
+              }
+              if (isKeyframe && !hasOutputFormat && sps.isCompleted() && pps.isCompleted()) {
+                output.format(parseMediaFormat(sps, pps));
+                hasOutputFormat = true;
+              }
+              int flags = isKeyframe ? C.SAMPLE_FLAG_SYNC : 0;
+              int size = (int) (totalBytesWritten - samplePosition) - bytesWrittenPastNalUnit;
+              output.sampleMetadata(sampleTimeUs, flags, size, bytesWrittenPastNalUnit, null);
+            }
+            foundFirstSample = true;
+            samplePosition = totalBytesWritten - bytesWrittenPastNalUnit;
+            sampleTimeUs = pesTimeUs;
+            isKeyframe = false;
+            break;
+        }
+
+        // Indicate the end of the previous NAL unit. If the length to the start of the next unit
+        // is negative then we wrote too many bytes to the NAL buffers. Discard the excess bytes
+        // when notifying that the unit has ended.
+        feedNalUnitTargetEnd(pesTimeUs, lengthToNalUnit < 0 ? -lengthToNalUnit : 0);
+        // Indicate the start of the next NAL unit.
+        feedNalUnitTargetBuffersStart(nalUnitType);
+        // Continue scanning the data.
+        offset = nalUnitOffset + 3;
       }
     }
   }
@@ -194,14 +198,10 @@ private void feedNalUnitTargetEnd(long pesTimeUs, int discardPadding) {
     }
   }
 
-  private void parseMediaFormat(NalUnitTargetBuffer sps, NalUnitTargetBuffer pps) {
-    byte[] spsData = new byte[sps.nalLength];
-    byte[] ppsData = new byte[pps.nalLength];
-    System.arraycopy(sps.nalData, 0, spsData, 0, sps.nalLength);
-    System.arraycopy(pps.nalData, 0, ppsData, 0, pps.nalLength);
+  private static MediaFormat parseMediaFormat(NalUnitTargetBuffer sps, NalUnitTargetBuffer pps) {
     List<byte[]> initializationData = new ArrayList<>();
-    initializationData.add(spsData);
-    initializationData.add(ppsData);
+    initializationData.add(Arrays.copyOf(sps.nalData, sps.nalLength));
+    initializationData.add(Arrays.copyOf(pps.nalData, pps.nalLength));
 
     // Unescape and parse the SPS unit.
     NalUnitUtil.unescapeStream(sps.nalData, sps.nalLength);
@@ -209,12 +209,9 @@ private void parseMediaFormat(NalUnitTargetBuffer sps, NalUnitTargetBuffer pps)
     bitArray.skipBits(32); // NAL header
     SpsData parsedSpsData = CodecSpecificDataUtil.parseSpsNalUnit(bitArray);
 
-    // Construct and output the format.
-    output.format(MediaFormat.createVideoFormat(MediaFormat.NO_VALUE, MimeTypes.VIDEO_H264,
-        MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US, parsedSpsData.width,
-        parsedSpsData.height, initializationData, MediaFormat.NO_VALUE,
-        parsedSpsData.pixelWidthAspectRatio));
-    hasOutputFormat = true;
+    return MediaFormat.createVideoFormat(null, MimeTypes.VIDEO_H264, MediaFormat.NO_VALUE,
+        MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US, parsedSpsData.width, parsedSpsData.height,
+        initializationData, MediaFormat.NO_VALUE, parsedSpsData.pixelWidthAspectRatio);
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java
index a4429ab90c..2ce1e3ec39 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java
@@ -101,32 +101,34 @@ public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacke
       // Scan the appended data, processing NAL units as they are encountered
       while (offset < limit) {
         int nalUnitOffset = NalUnitUtil.findNalUnit(dataArray, offset, limit, prefixFlags);
-        if (nalUnitOffset < limit) {
-          // We've seen the start of a NAL unit.
-
-          // This is the length to the start of the unit. It may be negative if the NAL unit
-          // actually started in previously consumed data.
-          int lengthToNalUnit = nalUnitOffset - offset;
-          if (lengthToNalUnit > 0) {
-            nalUnitData(dataArray, offset, nalUnitOffset);
-          }
-          int bytesWrittenPastPosition = limit - nalUnitOffset;
-          long absolutePosition = totalBytesWritten - bytesWrittenPastPosition;
-          // Indicate the end of the previous NAL unit. If the length to the start of the next unit
-          // is negative then we wrote too many bytes to the NAL buffers. Discard the excess bytes
-          // when notifying that the unit has ended.
-          nalUnitEnd(absolutePosition, bytesWrittenPastPosition,
-              lengthToNalUnit < 0 ? -lengthToNalUnit : 0, pesTimeUs);
-
-          // Indicate the start of the next NAL unit.
-          int nalUnitType = NalUnitUtil.getH265NalUnitType(dataArray, nalUnitOffset);
-          startNalUnit(absolutePosition, bytesWrittenPastPosition, nalUnitType, pesTimeUs);
-          // Continue scanning the data.
-          offset = nalUnitOffset + 3;
-        } else {
+
+        if (nalUnitOffset == limit) {
+          // We've scanned to the end of the data without finding the start of another NAL unit.
           nalUnitData(dataArray, offset, limit);
-          offset = limit;
+          return;
         }
+
+        // We've seen the start of a NAL unit of the following type.
+        int nalUnitType = NalUnitUtil.getH265NalUnitType(dataArray, nalUnitOffset);
+
+        // This is the number of bytes from the current offset to the start of the next NAL unit.
+        // It may be negative if the NAL unit started in the previously consumed data.
+        int lengthToNalUnit = nalUnitOffset - offset;
+        if (lengthToNalUnit > 0) {
+          nalUnitData(dataArray, offset, nalUnitOffset);
+        }
+
+        int bytesWrittenPastPosition = limit - nalUnitOffset;
+        long absolutePosition = totalBytesWritten - bytesWrittenPastPosition;
+        // Indicate the end of the previous NAL unit. If the length to the start of the next unit
+        // is negative then we wrote too many bytes to the NAL buffers. Discard the excess bytes
+        // when notifying that the unit has ended.
+        nalUnitEnd(absolutePosition, bytesWrittenPastPosition,
+            lengthToNalUnit < 0 ? -lengthToNalUnit : 0, pesTimeUs);
+        // Indicate the start of the next NAL unit.
+        startNalUnit(absolutePosition, bytesWrittenPastPosition, nalUnitType, pesTimeUs);
+        // Continue scanning the data.
+        offset = nalUnitOffset + 3;
       }
     }
   }
@@ -167,7 +169,8 @@ private void nalUnitEnd(long position, int offset, int discardPadding, long pesT
       sps.endNalUnit(discardPadding);
       pps.endNalUnit(discardPadding);
       if (vps.isCompleted() && sps.isCompleted() && pps.isCompleted()) {
-        parseMediaFormat(vps, sps, pps);
+        output.format(parseMediaFormat(vps, sps, pps));
+        hasOutputFormat = true;
       }
     }
     if (prefixSei.endNalUnit(discardPadding)) {
@@ -188,7 +191,7 @@ private void nalUnitEnd(long position, int offset, int discardPadding, long pesT
     }
   }
 
-  private void parseMediaFormat(NalUnitTargetBuffer vps, NalUnitTargetBuffer sps,
+  private static MediaFormat parseMediaFormat(NalUnitTargetBuffer vps, NalUnitTargetBuffer sps,
       NalUnitTargetBuffer pps) {
     // Build codec-specific data.
     byte[] csd = new byte[vps.nalLength + sps.nalLength + pps.nalLength];
@@ -294,15 +297,13 @@ private void parseMediaFormat(NalUnitTargetBuffer vps, NalUnitTargetBuffer sps,
       }
     }
 
-    output.format(MediaFormat.createVideoFormat(MediaFormat.NO_VALUE, MimeTypes.VIDEO_H265,
-        MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US, picWidthInLumaSamples,
-        picHeightInLumaSamples, Collections.singletonList(csd), MediaFormat.NO_VALUE,
-        pixelWidthHeightRatio));
-    hasOutputFormat = true;
+    return MediaFormat.createVideoFormat(null, MimeTypes.VIDEO_H265, MediaFormat.NO_VALUE,
+        MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US, picWidthInLumaSamples, picHeightInLumaSamples,
+        Collections.singletonList(csd), MediaFormat.NO_VALUE, pixelWidthHeightRatio);
   }
 
   /** Skips scaling_list_data(). See H.265/HEVC (2014) 7.3.4. */
-  private void skipScalingList(ParsableBitArray bitArray) {
+  private static void skipScalingList(ParsableBitArray bitArray) {
     for (int sizeId = 0; sizeId < 4; sizeId++) {
       for (int matrixId = 0; matrixId < 6; matrixId += sizeId == 3 ? 3 : 1) {
         if (!bitArray.readBit()) { // scaling_list_pred_mode_flag[sizeId][matrixId]
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java
index 553aae6499..c7ec2f7dc4 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java
@@ -35,8 +35,8 @@
 
   public Id3Reader(TrackOutput output) {
     super(output);
-    output.format(MediaFormat.createFormatForMimeType(MediaFormat.NO_VALUE,
-        MimeTypes.APPLICATION_ID3, MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US));
+    output.format(MediaFormat.createFormatForMimeType(null, MimeTypes.APPLICATION_ID3,
+        MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US));
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpegAudioReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpegAudioReader.java
index 8e268e53fe..ee8f84cfde 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpegAudioReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpegAudioReader.java
@@ -160,7 +160,7 @@ private void readHeaderRemainder(ParsableByteArray source) {
     frameSize = header.frameSize;
     if (!hasOutputFormat) {
       frameDurationUs = (C.MICROS_PER_SECOND * header.samplesPerFrame) / header.sampleRate;
-      MediaFormat mediaFormat = MediaFormat.createAudioFormat(MediaFormat.NO_VALUE, header.mimeType,
+      MediaFormat mediaFormat = MediaFormat.createAudioFormat(null, header.mimeType,
           MediaFormat.NO_VALUE, MpegAudioHeader.MAX_FRAME_SIZE_BYTES, C.UNKNOWN_TIME_US,
           header.channels, header.sampleRate, null, null);
       output.format(mediaFormat);
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/PtsTimestampAdjuster.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/PtsTimestampAdjuster.java
index 59d96eb003..25a92e2bce 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/PtsTimestampAdjuster.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/PtsTimestampAdjuster.java
@@ -49,6 +49,13 @@ public void reset() {
     lastPts = Long.MIN_VALUE;
   }
 
+  /**
+   * Whether this adjuster has been initialized with a first MPEG-2 TS presentation timestamp.
+   */
+  public boolean isInitialized() {
+    return lastPts != Long.MIN_VALUE;
+  }
+
   /**
    * Scales and adjusts an MPEG-2 TS presentation timestamp.
    *
@@ -66,7 +73,7 @@ public long adjustTimestamp(long pts) {
           ? ptsWrapBelow : ptsWrapAbove;
     }
     // Calculate the corresponding timestamp.
-    long timeUs = (pts * C.MICROS_PER_SECOND) / 90000;
+    long timeUs = ptsToUs(pts);
     // If we haven't done the initial timestamp adjustment, do it now.
     if (lastPts == Long.MIN_VALUE) {
       timestampOffsetUs = firstSampleTimestampUs - timeUs;
@@ -76,4 +83,24 @@ public long adjustTimestamp(long pts) {
     return timeUs + timestampOffsetUs;
   }
 
+  /**
+   * Converts a value in MPEG-2 timestamp units to the corresponding value in microseconds.
+   *
+   * @param pts A value in MPEG-2 timestamp units.
+   * @return The corresponding value in microseconds.
+   */
+  public static long ptsToUs(long pts) {
+    return (pts * C.MICROS_PER_SECOND) / 90000;
+  }
+
+  /**
+   * Converts a value in microseconds to the corresponding values in MPEG-2 timestamp units.
+   *
+   * @param us A value in microseconds.
+   * @return The corresponding value in MPEG-2 timestamp units.
+   */
+  public static long usToPts(long us) {
+    return (us * 90000) / C.MICROS_PER_SECOND;
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/SeiReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/SeiReader.java
index 81378d1685..2aa143d44a 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/SeiReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/SeiReader.java
@@ -32,7 +32,7 @@
 
   public SeiReader(TrackOutput output) {
     super(output);
-    output.format(MediaFormat.createTextFormat(MediaFormat.NO_VALUE, MimeTypes.APPLICATION_EIA608,
+    output.format(MediaFormat.createTextFormat(null, MimeTypes.APPLICATION_EIA608,
         MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US, null));
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
index 5b553838ec..4dac4facae 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
@@ -22,6 +22,7 @@
 import com.google.android.exoplayer.extractor.SeekMap;
 import com.google.android.exoplayer.util.ParsableBitArray;
 import com.google.android.exoplayer.util.ParsableByteArray;
+import com.google.android.exoplayer.util.Util;
 
 import android.util.Log;
 import android.util.SparseArray;
@@ -43,19 +44,24 @@
   private static final int TS_STREAM_TYPE_MPA = 0x03;
   private static final int TS_STREAM_TYPE_MPA_LSF = 0x04;
   private static final int TS_STREAM_TYPE_AAC = 0x0F;
-  private static final int TS_STREAM_TYPE_ATSC_AC3 = 0x81;
-  private static final int TS_STREAM_TYPE_ATSC_E_AC3 = 0x87;
+  private static final int TS_STREAM_TYPE_AC3 = 0x81;
+  private static final int TS_STREAM_TYPE_E_AC3 = 0x87;
+  private static final int TS_STREAM_TYPE_H262 = 0x02;
   private static final int TS_STREAM_TYPE_H264 = 0x1B;
   private static final int TS_STREAM_TYPE_H265 = 0x24;
   private static final int TS_STREAM_TYPE_ID3 = 0x15;
   private static final int TS_STREAM_TYPE_EIA608 = 0x100; // 0xFF + 1
 
+  private static final long AC3_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("AC-3");
+  private static final long E_AC3_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("EAC3");
+  private static final long HEVC_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("HEVC");
+
   private final PtsTimestampAdjuster ptsTimestampAdjuster;
+  private final boolean idrKeyframesOnly;
   private final ParsableByteArray tsPacketBuffer;
   private final ParsableBitArray tsScratch;
-  private final boolean idrKeyframesOnly;
-  /* package */ final SparseBooleanArray streamTypes;
   /* package */ final SparseArray<TsPayloadReader> tsPayloadReaders; // Indexed by pid
+  /* package */ final SparseBooleanArray streamTypes;
 
   // Accessed only by the loading thread.
   private ExtractorOutput output;
@@ -70,13 +76,13 @@ public TsExtractor(PtsTimestampAdjuster ptsTimestampAdjuster) {
   }
 
   public TsExtractor(PtsTimestampAdjuster ptsTimestampAdjuster, boolean idrKeyframesOnly) {
+    this.ptsTimestampAdjuster = ptsTimestampAdjuster;
     this.idrKeyframesOnly = idrKeyframesOnly;
-    tsScratch = new ParsableBitArray(new byte[3]);
     tsPacketBuffer = new ParsableByteArray(TS_PACKET_SIZE);
-    streamTypes = new SparseBooleanArray();
+    tsScratch = new ParsableBitArray(new byte[3]);
     tsPayloadReaders = new SparseArray<>();
     tsPayloadReaders.put(TS_PAT_PID, new PatReader());
-    this.ptsTimestampAdjuster = ptsTimestampAdjuster;
+    streamTypes = new SparseBooleanArray();
   }
 
   // Extractor implementation.
@@ -230,9 +236,14 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
   private class PmtReader extends TsPayloadReader {
 
     private final ParsableBitArray pmtScratch;
+    private final ParsableByteArray sectionData;
+
+    private int sectionLength;
+    private int sectionBytesRead;
 
     public PmtReader() {
       pmtScratch = new ParsableBitArray(new byte[5]);
+      sectionData = new ParsableByteArray();
     }
 
     @Override
@@ -243,29 +254,45 @@ public void seek() {
     @Override
     public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
         ExtractorOutput output) {
-      // Skip pointer.
       if (payloadUnitStartIndicator) {
+        // Skip pointer.
         int pointerField = data.readUnsignedByte();
         data.skipBytes(pointerField);
+
+        // Note: see ISO/IEC 13818-1, section 2.4.4.8 for detailed information on the format of
+        // the header.
+        data.readBytes(pmtScratch, 3);
+        pmtScratch.skipBits(12); // table_id (8), section_syntax_indicator (1), 0 (1), reserved (2)
+        sectionLength = pmtScratch.readBits(12);
+
+        if (sectionData.capacity() < sectionLength) {
+          sectionData.reset(new byte[sectionLength], sectionLength);
+        } else {
+          sectionData.reset();
+          sectionData.setLimit(sectionLength);
+        }
       }
 
-      // Note: see ISO/IEC 13818-1, section 2.4.4.8 for detailed information on the format of
-      // the header.
-      data.readBytes(pmtScratch, 3);
-      pmtScratch.skipBits(12); // table_id (8), section_syntax_indicator (1), '0' (1), reserved (2)
-      int sectionLength = pmtScratch.readBits(12);
+      int bytesToRead = Math.min(data.bytesLeft(), sectionLength - sectionBytesRead);
+      data.readBytes(sectionData.data, sectionBytesRead, bytesToRead);
+      sectionBytesRead += bytesToRead;
+      if (sectionBytesRead < sectionLength) {
+        // Not yet fully read.
+        return;
+      }
 
       // program_number (16), reserved (2), version_number (5), current_next_indicator (1),
       // section_number (8), last_section_number (8), reserved (3), PCR_PID (13)
       // Skip the rest of the PMT header.
-      data.skipBytes(7);
+      sectionData.skipBytes(7);
 
-      data.readBytes(pmtScratch, 2);
+      // Read program_info_length.
+      sectionData.readBytes(pmtScratch, 2);
       pmtScratch.skipBits(4);
       int programInfoLength = pmtScratch.readBits(12);
 
       // Skip the descriptors.
-      data.skipBytes(programInfoLength);
+      sectionData.skipBytes(programInfoLength);
 
       if (id3Reader == null) {
         // Setup an ID3 track regardless of whether there's a corresponding entry, in case one
@@ -273,25 +300,26 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
         id3Reader = new Id3Reader(output.track(TS_STREAM_TYPE_ID3));
       }
 
-      int entriesSize = sectionLength - 9 /* Size of the rest of the fields before descriptors */
-          - programInfoLength - 4 /* CRC size */;
-      while (entriesSize > 0) {
-        data.readBytes(pmtScratch, 5);
+      int remainingEntriesLength = sectionLength - 9 /* Length of fields before descriptors */
+          - programInfoLength - 4 /* CRC length */;
+      while (remainingEntriesLength > 0) {
+        sectionData.readBytes(pmtScratch, 5);
         int streamType = pmtScratch.readBits(8);
         pmtScratch.skipBits(3); // reserved
         int elementaryPid = pmtScratch.readBits(13);
         pmtScratch.skipBits(4); // reserved
-        int esInfoLength = pmtScratch.readBits(12);
-
-        // Skip the descriptors.
-        data.skipBytes(esInfoLength);
-        entriesSize -= esInfoLength + 5;
-
+        int esInfoLength = pmtScratch.readBits(12); // ES_info_length
+        if (streamType == 0x06) {
+          // Read descriptors in PES packets containing private data.
+          streamType = readPrivateDataStreamType(sectionData, esInfoLength);
+        } else {
+          sectionData.skipBytes(esInfoLength);
+        }
+        remainingEntriesLength -= esInfoLength + 5;
         if (streamTypes.get(streamType)) {
           continue;
         }
 
-        // TODO: Detect and read DVB AC-3 streams with Ac3Reader.
         ElementaryStreamReader pesPayloadReader = null;
         switch (streamType) {
           case TS_STREAM_TYPE_MPA:
@@ -303,9 +331,14 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
           case TS_STREAM_TYPE_AAC:
             pesPayloadReader = new AdtsReader(output.track(TS_STREAM_TYPE_AAC));
             break;
-          case TS_STREAM_TYPE_ATSC_E_AC3:
-          case TS_STREAM_TYPE_ATSC_AC3:
-            pesPayloadReader = new Ac3Reader(output.track(streamType));
+          case TS_STREAM_TYPE_AC3:
+            pesPayloadReader = new Ac3Reader(output.track(TS_STREAM_TYPE_AC3), false);
+            break;
+          case TS_STREAM_TYPE_E_AC3:
+            pesPayloadReader = new Ac3Reader(output.track(TS_STREAM_TYPE_E_AC3), true);
+            break;
+          case TS_STREAM_TYPE_H262:
+            pesPayloadReader = new H262Reader(output.track(TS_STREAM_TYPE_H262));
             break;
           case TS_STREAM_TYPE_H264:
             pesPayloadReader = new H264Reader(output.track(TS_STREAM_TYPE_H264),
@@ -329,6 +362,38 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
       output.endTracks();
     }
 
+    /**
+     * Returns the stream type read from a registration descriptor in private data, or -1 if no
+     * stream type is present. Sets {@code data}'s position to the end of the descriptors.
+     *
+     * @param data A buffer with its position set to the start of the first descriptor.
+     * @param length The length of descriptors to read from the current position in {@code data}.
+     * @return The stream type read from a registration descriptor in private data, or -1 if no
+     *     stream type is present.
+     */
+    private int readPrivateDataStreamType(ParsableByteArray data, int length) {
+      int streamType = -1;
+      int descriptorsEndPosition = data.getPosition() + length;
+      while (data.getPosition() < descriptorsEndPosition) {
+        int descriptorTag = data.readUnsignedByte();
+        int descriptorLength = data.readUnsignedByte();
+        if (descriptorTag == 0x05) { // registration_descriptor
+          long formatIdentifier = data.readUnsignedInt();
+          if (formatIdentifier == AC3_FORMAT_IDENTIFIER) {
+            streamType = TS_STREAM_TYPE_AC3;
+          } else if (formatIdentifier == E_AC3_FORMAT_IDENTIFIER) {
+            streamType = TS_STREAM_TYPE_E_AC3;
+          } else if (formatIdentifier == HEVC_FORMAT_IDENTIFIER) {
+            streamType = TS_STREAM_TYPE_H265;
+          }
+          break;
+        }
+        data.skipBytes(descriptorLength);
+      }
+      data.setPosition(descriptorsEndPosition);
+      return streamType;
+    }
+
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReader.java
index 71326412e6..1b73b5dfd2 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReader.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer.extractor.webm;
 
 import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.extractor.ExtractorInput;
 import com.google.android.exoplayer.util.Assertions;
 
@@ -100,7 +101,7 @@ public boolean read(ExtractorInput input) throws IOException, InterruptedExcepti
           return true;
         case TYPE_UNSIGNED_INT:
           if (elementContentSize > MAX_INTEGER_ELEMENT_SIZE_BYTES) {
-            throw new IllegalStateException("Invalid integer size: " + elementContentSize);
+            throw new ParserException("Invalid integer size: " + elementContentSize);
           }
           output.integerElement(elementId, readInteger(input, (int) elementContentSize));
           elementState = ELEMENT_STATE_READ_ID;
@@ -108,14 +109,14 @@ public boolean read(ExtractorInput input) throws IOException, InterruptedExcepti
         case TYPE_FLOAT:
           if (elementContentSize != VALID_FLOAT32_ELEMENT_SIZE_BYTES
               && elementContentSize != VALID_FLOAT64_ELEMENT_SIZE_BYTES) {
-            throw new IllegalStateException("Invalid float size: " + elementContentSize);
+            throw new ParserException("Invalid float size: " + elementContentSize);
           }
           output.floatElement(elementId, readFloat(input, (int) elementContentSize));
           elementState = ELEMENT_STATE_READ_ID;
           return true;
         case TYPE_STRING:
           if (elementContentSize > Integer.MAX_VALUE) {
-            throw new IllegalStateException("String element size: " + elementContentSize);
+            throw new ParserException("String element size: " + elementContentSize);
           }
           output.stringElement(elementId, readString(input, (int) elementContentSize));
           elementState = ELEMENT_STATE_READ_ID;
@@ -129,7 +130,7 @@ public boolean read(ExtractorInput input) throws IOException, InterruptedExcepti
           elementState = ELEMENT_STATE_READ_ID;
           break;
         default:
-          throw new IllegalStateException("Invalid element type " + type);
+          throw new ParserException("Invalid element type " + type);
       }
     }
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
index 58d85370ee..96ce99a638 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.drm.DrmInitData;
+import com.google.android.exoplayer.drm.DrmInitData.SchemeInitData;
 import com.google.android.exoplayer.extractor.ChunkIndex;
 import com.google.android.exoplayer.extractor.Extractor;
 import com.google.android.exoplayer.extractor.ExtractorInput;
@@ -26,7 +27,6 @@
 import com.google.android.exoplayer.extractor.PositionHolder;
 import com.google.android.exoplayer.extractor.SeekMap;
 import com.google.android.exoplayer.extractor.TrackOutput;
-import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.LongArray;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.NalUnitUtil;
@@ -75,6 +75,7 @@
   private static final String CODEC_ID_AAC = "A_AAC";
   private static final String CODEC_ID_MP3 = "A_MPEG/L3";
   private static final String CODEC_ID_AC3 = "A_AC3";
+  private static final String CODEC_ID_E_AC3 = "A_EAC3";
   private static final String CODEC_ID_TRUEHD = "A_TRUEHD";
   private static final String CODEC_ID_DTS = "A_DTS";
   private static final String CODEC_ID_DTS_EXPRESS = "A_DTS/EXPRESS";
@@ -450,8 +451,8 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
             throw new ParserException("Encrypted Track found but ContentEncKeyID was not found");
           }
           if (!sentDrmInitData) {
-            extractorOutput.drmInitData(
-                new DrmInitData.Universal(MimeTypes.VIDEO_WEBM, currentTrack.encryptionKeyId));
+            extractorOutput.drmInitData(new DrmInitData.Universal(
+                new SchemeInitData(MimeTypes.VIDEO_WEBM, currentTrack.encryptionKeyId)));
             sentDrmInitData = true;
           }
         }
@@ -738,7 +739,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
                   contentSize - blockTrackNumberLength - headerSize - totalSamplesSize;
             } else {
               // Lacing is always in the range 0--3.
-              throw new IllegalStateException("Unexpected lacing value: " + lacing);
+              throw new ParserException("Unexpected lacing value: " + lacing);
             }
           }
 
@@ -1045,6 +1046,7 @@ private static boolean isCodecSupported(String codecId) {
         || CODEC_ID_AAC.equals(codecId)
         || CODEC_ID_MP3.equals(codecId)
         || CODEC_ID_AC3.equals(codecId)
+        || CODEC_ID_E_AC3.equals(codecId)
         || CODEC_ID_TRUEHD.equals(codecId)
         || CODEC_ID_DTS.equals(codecId)
         || CODEC_ID_DTS_EXPRESS.equals(codecId)
@@ -1210,6 +1212,9 @@ public void initializeOutput(ExtractorOutput output, int trackId, long durationU
         case CODEC_ID_AC3:
           mimeType = MimeTypes.AUDIO_AC3;
           break;
+        case CODEC_ID_E_AC3:
+          mimeType = MimeTypes.AUDIO_E_AC3;
+          break;
         case CODEC_ID_TRUEHD:
           mimeType = MimeTypes.AUDIO_TRUEHD;
           break;
@@ -1228,15 +1233,18 @@ public void initializeOutput(ExtractorOutput output, int trackId, long durationU
       }
 
       MediaFormat format;
+      // TODO: Consider reading the name elements of the tracks and, if present, incorporating them
+      // into the trackId passed when creating the formats.
       if (MimeTypes.isAudio(mimeType)) {
-        format = MediaFormat.createAudioFormat(trackId, mimeType, MediaFormat.NO_VALUE,
-            maxInputSize, durationUs, channelCount, sampleRate, initializationData, language);
+        format = MediaFormat.createAudioFormat(Integer.toString(trackId), mimeType,
+            MediaFormat.NO_VALUE, maxInputSize, durationUs, channelCount, sampleRate,
+            initializationData, language);
       } else if (MimeTypes.isVideo(mimeType)) {
-        format = MediaFormat.createVideoFormat(trackId, mimeType, MediaFormat.NO_VALUE,
-            maxInputSize, durationUs, width, height, initializationData);
+        format = MediaFormat.createVideoFormat(Integer.toString(trackId), mimeType,
+            MediaFormat.NO_VALUE, maxInputSize, durationUs, width, height, initializationData);
       } else if (MimeTypes.APPLICATION_SUBRIP.equals(mimeType)) {
-        format = MediaFormat.createTextFormat(trackId, mimeType, MediaFormat.NO_VALUE, durationUs,
-            language);
+        format = MediaFormat.createTextFormat(Integer.toString(trackId), mimeType,
+            MediaFormat.NO_VALUE, durationUs, language);
       } else {
         throw new ParserException("Unexpected MIME type.");
       }
@@ -1257,7 +1265,9 @@ public void initializeOutput(ExtractorOutput output, int trackId, long durationU
         // TODO: Deduplicate with AtomParsers.parseAvcCFromParent.
         buffer.setPosition(4);
         int nalUnitLengthFieldLength = (buffer.readUnsignedByte() & 0x03) + 1;
-        Assertions.checkState(nalUnitLengthFieldLength != 3);
+        if (nalUnitLengthFieldLength == 3) {
+          throw new ParserException();
+        }
         List<byte[]> initializationData = new ArrayList<>();
         int numSequenceParameterSets = buffer.readUnsignedByte() & 0x1F;
         for (int i = 0; i < numSequenceParameterSets; i++) {
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
index f70d1900f6..9e305d5969 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer.hls;
 
+import com.google.android.exoplayer.BehindLiveWindowException;
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.chunk.BaseChunkSampleSourceEventListener;
@@ -32,6 +33,7 @@
 import com.google.android.exoplayer.upstream.DataSpec;
 import com.google.android.exoplayer.upstream.HttpDataSource.InvalidResponseCodeException;
 import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.UriUtil;
 import com.google.android.exoplayer.util.Util;
 
@@ -184,7 +186,9 @@ public HlsChunkSource(DataSource dataSource, String playlistUrl, HlsPlaylist pla
     playlistParser = new HlsPlaylistParser();
 
     if (playlist.type == HlsPlaylist.TYPE_MEDIA) {
-      variants = new Variant[] {new Variant(0, playlistUrl, 0, null, -1, -1)};
+      Format format = new Format("0", MimeTypes.APPLICATION_M3U8, -1, -1, -1, -1, -1, -1, null,
+          null);
+      variants = new Variant[] {new Variant(playlistUrl, format)};
       variantPlaylists = new HlsMediaPlaylist[1];
       variantLastPlaylistLoadTimesMs = new long[1];
       variantBlacklistTimes = new long[1];
@@ -246,14 +250,14 @@ public void maybeThrowError() throws IOException {
    * be performed by the calling {@link HlsSampleSource}.
    *
    * @param previousTsChunk The previously loaded chunk that the next chunk should follow.
-   * @param seekPositionUs If there is no previous chunk, this parameter must specify the seek
-   *     position. If there is a previous chunk then this parameter is ignored.
-   * @param playbackPositionUs The current playback position.
+   * @param playbackPositionUs The current playback position. If previousTsChunk is null then this
+   *     parameter is the position from which playback is expected to start (or restart) and hence
+   *     should be interpreted as a seek position.
    * @param out The holder to populate with the result. {@link ChunkOperationHolder#queueSize} is
    *     unused.
    */
-  public void getChunkOperation(TsChunk previousTsChunk, long seekPositionUs,
-      long playbackPositionUs, ChunkOperationHolder out) {
+  public void getChunkOperation(TsChunk previousTsChunk, long playbackPositionUs,
+      ChunkOperationHolder out) {
     int nextVariantIndex;
     boolean switchingVariantSpliced;
     if (adaptiveMode == ADAPTIVE_MODE_NONE) {
@@ -283,22 +287,15 @@ public void getChunkOperation(TsChunk previousTsChunk, long seekPositionUs,
         chunkMediaSequence = switchingVariantSpliced
             ? previousTsChunk.chunkIndex : previousTsChunk.chunkIndex + 1;
         if (chunkMediaSequence < mediaPlaylist.mediaSequence) {
-          // TODO: Decide what we want to do with: https://github.com/google/ExoPlayer/issues/765
-          // if (allowSkipAhead) {
-          // If the chunk is no longer in the playlist. Skip ahead and start again.
-          chunkMediaSequence = getLiveStartChunkMediaSequence(nextVariantIndex);
-          liveDiscontinuity = true;
-          // } else {
-          //   fatalError = new BehindLiveWindowException();
-          //   return null;
-          // }
+          fatalError = new BehindLiveWindowException();
+          return;
         }
       }
     } else {
       // Not live.
       if (previousTsChunk == null) {
-        chunkMediaSequence = Util.binarySearchFloor(mediaPlaylist.segments, seekPositionUs, true,
-            true) + mediaPlaylist.mediaSequence;
+        chunkMediaSequence = Util.binarySearchFloor(mediaPlaylist.segments, playbackPositionUs,
+            true, true) + mediaPlaylist.mediaSequence;
       } else {
         chunkMediaSequence = switchingVariantSpliced
             ? previousTsChunk.chunkIndex : previousTsChunk.chunkIndex + 1;
@@ -364,10 +361,12 @@ public void getChunkOperation(TsChunk previousTsChunk, long seekPositionUs,
       Extractor extractor = new Mp3Extractor(startTimeUs);
       extractorWrapper = new HlsExtractorWrapper(trigger, format, startTimeUs, extractor,
           switchingVariantSpliced, adaptiveMaxWidth, adaptiveMaxHeight);
-    } else if (previousTsChunk == null || segment.discontinuity || liveDiscontinuity
+    } else if (previousTsChunk == null || liveDiscontinuity
+        || previousTsChunk.discontinuitySequenceNumber != segment.discontinuitySequenceNumber
         || !format.equals(previousTsChunk.format)) {
       // MPEG-2 TS segments, but we need a new extractor.
-      if (previousTsChunk == null || segment.discontinuity || liveDiscontinuity
+      if (previousTsChunk == null || liveDiscontinuity
+          || previousTsChunk.discontinuitySequenceNumber != segment.discontinuitySequenceNumber
           || ptsTimestampAdjuster == null) {
         // TODO: Use this for AAC as well, along with the ID3 PRIV priv tag values with owner
         // identifier com.apple.streaming.transportStreamTimestamp.
@@ -382,7 +381,8 @@ public void getChunkOperation(TsChunk previousTsChunk, long seekPositionUs,
     }
 
     out.chunk = new TsChunk(dataSource, dataSpec, trigger, format, startTimeUs, endTimeUs,
-        chunkMediaSequence, extractorWrapper, encryptionKey, encryptionIv);
+        chunkMediaSequence, segment.discontinuitySequenceNumber, extractorWrapper, encryptionKey,
+        encryptionIv);
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsMasterPlaylist.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsMasterPlaylist.java
index 15c4784d10..4222c5ab5b 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsMasterPlaylist.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsMasterPlaylist.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer.hls;
 
+import java.util.Collections;
 import java.util.List;
 
 /**
@@ -23,12 +24,12 @@
 public final class HlsMasterPlaylist extends HlsPlaylist {
 
   public final List<Variant> variants;
-  public final List<Subtitle> subtitles;
+  public final List<Variant> subtitles;
 
-  public HlsMasterPlaylist(String baseUri, List<Variant> variants, List<Subtitle> subtitles) {
+  public HlsMasterPlaylist(String baseUri, List<Variant> variants, List<Variant> subtitles) {
     super(baseUri, HlsPlaylist.TYPE_MASTER);
-    this.variants = variants;
-    this.subtitles = subtitles;
+    this.variants = Collections.unmodifiableList(variants);
+    this.subtitles = Collections.unmodifiableList(subtitles);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsMediaPlaylist.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsMediaPlaylist.java
index ec4c538155..44c760bccf 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsMediaPlaylist.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsMediaPlaylist.java
@@ -29,9 +29,9 @@
    */
   public static final class Segment implements Comparable<Long> {
 
-    public final boolean discontinuity;
-    public final double durationSecs;
     public final String url;
+    public final double durationSecs;
+    public final int discontinuitySequenceNumber;
     public final long startTimeUs;
     public final boolean isEncrypted;
     public final String encryptionKeyUri;
@@ -39,12 +39,12 @@
     public final int byterangeOffset;
     public final int byterangeLength;
 
-    public Segment(String uri, double durationSecs, boolean discontinuity, long startTimeUs,
-        boolean isEncrypted, String encryptionKeyUri, String encryptionIV, int byterangeOffset,
-        int byterangeLength) {
+    public Segment(String uri, double durationSecs, int discontinuitySequenceNumber,
+        long startTimeUs, boolean isEncrypted, String encryptionKeyUri, String encryptionIV,
+        int byterangeOffset, int byterangeLength) {
       this.url = uri;
       this.durationSecs = durationSecs;
-      this.discontinuity = discontinuity;
+      this.discontinuitySequenceNumber = discontinuitySequenceNumber;
       this.startTimeUs = startTimeUs;
       this.isEncrypted = isEncrypted;
       this.encryptionKeyUri = encryptionKeyUri;
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java
index 8db6eb2484..75929fc7c3 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java
@@ -17,8 +17,10 @@
 
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.chunk.Format;
 import com.google.android.exoplayer.hls.HlsMediaPlaylist.Segment;
 import com.google.android.exoplayer.upstream.UriLoadable;
+import com.google.android.exoplayer.util.MimeTypes;
 
 import java.io.BufferedReader;
 import java.io.IOException;
@@ -40,6 +42,7 @@
   private static final String STREAM_INF_TAG = "#EXT-X-STREAM-INF";
   private static final String MEDIA_TAG = "#EXT-X-MEDIA";
   private static final String DISCONTINUITY_TAG = "#EXT-X-DISCONTINUITY";
+  private static final String DISCONTINUITY_SEQUENCE_TAG = "#EXT-X-DISCONTINUITY-SEQUENCE";
   private static final String MEDIA_DURATION_TAG = "#EXTINF";
   private static final String MEDIA_SEQUENCE_TAG = "#EXT-X-MEDIA-SEQUENCE";
   private static final String TARGET_DURATION_TAG = "#EXT-X-TARGETDURATION";
@@ -52,8 +55,6 @@
   private static final String RESOLUTION_ATTR = "RESOLUTION";
   private static final String LANGUAGE_ATTR = "LANGUAGE";
   private static final String NAME_ATTR = "NAME";
-  private static final String AUTOSELECT_ATTR = "AUTOSELECT";
-  private static final String DEFAULT_ATTR = "DEFAULT";
   private static final String TYPE_ATTR = "TYPE";
   private static final String METHOD_ATTR = "METHOD";
   private static final String URI_ATTR = "URI";
@@ -97,10 +98,10 @@
       Pattern.compile(LANGUAGE_ATTR + "=\"(.+?)\"");
   private static final Pattern NAME_ATTR_REGEX =
       Pattern.compile(NAME_ATTR + "=\"(.+?)\"");
-  private static final Pattern AUTOSELECT_ATTR_REGEX =
-      HlsParserUtil.compileBooleanAttrPattern(AUTOSELECT_ATTR);
-  private static final Pattern DEFAULT_ATTR_REGEX =
-      HlsParserUtil.compileBooleanAttrPattern(DEFAULT_ATTR);
+  // private static final Pattern AUTOSELECT_ATTR_REGEX =
+  //     HlsParserUtil.compileBooleanAttrPattern(AUTOSELECT_ATTR);
+  // private static final Pattern DEFAULT_ATTR_REGEX =
+  //     HlsParserUtil.compileBooleanAttrPattern(DEFAULT_ATTR);
 
   @Override
   public HlsPlaylist parse(String connectionUrl, InputStream inputStream)
@@ -122,6 +123,7 @@ public HlsPlaylist parse(String connectionUrl, InputStream inputStream)
             || line.startsWith(KEY_TAG)
             || line.startsWith(BYTERANGE_TAG)
             || line.equals(DISCONTINUITY_TAG)
+            || line.equals(DISCONTINUITY_SEQUENCE_TAG)
             || line.equals(ENDLIST_TAG)) {
           extraLines.add(line);
           return parseMediaPlaylist(new LineIterator(extraLines, reader), connectionUrl);
@@ -138,11 +140,12 @@ public HlsPlaylist parse(String connectionUrl, InputStream inputStream)
   private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, String baseUri)
       throws IOException {
     ArrayList<Variant> variants = new ArrayList<>();
-    ArrayList<Subtitle> subtitles = new ArrayList<>();
+    ArrayList<Variant> subtitles = new ArrayList<>();
     int bitrate = 0;
     String codecs = null;
     int width = -1;
     int height = -1;
+    String name = null;
 
     boolean expectingStreamInfUrl = false;
     String line;
@@ -152,18 +155,19 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
         String type = HlsParserUtil.parseStringAttr(line, TYPE_ATTR_REGEX, TYPE_ATTR);
         if (SUBTITLES_TYPE.equals(type)) {
           // We assume all subtitles belong to the same group.
-          String name = HlsParserUtil.parseStringAttr(line, NAME_ATTR_REGEX, NAME_ATTR);
+          String subtitleName = HlsParserUtil.parseStringAttr(line, NAME_ATTR_REGEX, NAME_ATTR);
           String uri = HlsParserUtil.parseStringAttr(line, URI_ATTR_REGEX, URI_ATTR);
           String language = HlsParserUtil.parseOptionalStringAttr(line, LANGUAGE_ATTR_REGEX);
-          boolean isDefault = HlsParserUtil.parseOptionalBooleanAttr(line, DEFAULT_ATTR_REGEX);
-          boolean autoSelect = HlsParserUtil.parseOptionalBooleanAttr(line, AUTOSELECT_ATTR_REGEX);
-          subtitles.add(new Subtitle(name, uri, language, isDefault, autoSelect));
+          Format format = new Format(subtitleName, MimeTypes.TEXT_VTT, -1, -1, -1, -1, -1, -1,
+              language, codecs);
+          subtitles.add(new Variant(uri, format));
         } else {
           // TODO: Support other types of media tag.
         }
       } else if (line.startsWith(STREAM_INF_TAG)) {
         bitrate = HlsParserUtil.parseIntAttr(line, BANDWIDTH_ATTR_REGEX, BANDWIDTH_ATTR);
         codecs = HlsParserUtil.parseOptionalStringAttr(line, CODECS_ATTR_REGEX);
+        name = HlsParserUtil.parseOptionalStringAttr(line, NAME_ATTR_REGEX);
         String resolutionString = HlsParserUtil.parseOptionalStringAttr(line,
             RESOLUTION_ATTR_REGEX);
         if (resolutionString != null) {
@@ -184,16 +188,21 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
         }
         expectingStreamInfUrl = true;
       } else if (!line.startsWith("#") && expectingStreamInfUrl) {
-        variants.add(new Variant(variants.size(), line, bitrate, codecs, width, height));
+        if (name == null) {
+          name = Integer.toString(variants.size());
+        }
+        Format format = new Format(name, MimeTypes.APPLICATION_M3U8, width, height, -1, -1, -1,
+            bitrate, null, codecs);
+        variants.add(new Variant(line, format));
         bitrate = 0;
         codecs = null;
+        name = null;
         width = -1;
         height = -1;
         expectingStreamInfUrl = false;
       }
     }
-    return new HlsMasterPlaylist(baseUri, Collections.unmodifiableList(variants),
-        Collections.unmodifiableList(subtitles));
+    return new HlsMasterPlaylist(baseUri, variants, subtitles);
   }
 
   private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String baseUri)
@@ -205,7 +214,7 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
     List<Segment> segments = new ArrayList<>();
 
     double segmentDurationSecs = 0.0;
-    boolean segmentDiscontinuity = false;
+    int discontinuitySequenceNumber = 0;
     long segmentStartTimeUs = 0;
     int segmentByterangeOffset = 0;
     int segmentByterangeLength = C.LENGTH_UNBOUNDED;
@@ -246,8 +255,10 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
         if (splitByteRange.length > 1) {
           segmentByterangeOffset = Integer.parseInt(splitByteRange[1]);
         }
+      } else if (line.startsWith(DISCONTINUITY_SEQUENCE_TAG)) {
+        discontinuitySequenceNumber = Integer.parseInt(line.substring(line.indexOf(':') + 1));
       } else if (line.equals(DISCONTINUITY_TAG)) {
-        segmentDiscontinuity = true;
+        discontinuitySequenceNumber++;
       } else if (!line.startsWith("#")) {
         String segmentEncryptionIV;
         if (!isEncrypted) {
@@ -261,11 +272,10 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
         if (segmentByterangeLength == C.LENGTH_UNBOUNDED) {
           segmentByterangeOffset = 0;
         }
-        segments.add(new Segment(line, segmentDurationSecs, segmentDiscontinuity,
+        segments.add(new Segment(line, segmentDurationSecs, discontinuitySequenceNumber,
             segmentStartTimeUs, isEncrypted, encryptionKeyUri, segmentEncryptionIV,
             segmentByterangeOffset, segmentByterangeLength));
         segmentStartTimeUs += (long) (segmentDurationSecs * C.MICROS_PER_SECOND);
-        segmentDiscontinuity = false;
         segmentDurationSecs = 0.0;
         if (segmentByterangeLength != C.LENGTH_UNBOUNDED) {
           segmentByterangeOffset += segmentByterangeLength;
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
index 4eaa685e7f..f29eb095c4 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
@@ -144,7 +144,7 @@ public boolean prepare(long positionUs) {
           for (int i = 0; i < trackCount; i++) {
             MediaFormat format = extractor.getMediaFormat(i).copyWithDurationUs(durationUs);
             if (MimeTypes.isVideo(format.mimeType)) {
-              format = format.copyAsAdaptive();
+              format = format.copyAsAdaptive(null);
             }
             trackFormat[i] = format;
           }
@@ -538,8 +538,9 @@ private void maybeStartLoading() {
       return;
     }
 
-    chunkSource.getChunkOperation(previousTsLoadable, pendingResetPositionUs,
-        downstreamPositionUs, chunkOperationHolder);
+    chunkSource.getChunkOperation(previousTsLoadable,
+        pendingResetPositionUs != NO_RESET_PENDING ? pendingResetPositionUs : downstreamPositionUs,
+        chunkOperationHolder);
     boolean endOfStream = chunkOperationHolder.endOfStream;
     Chunk nextLoadable = chunkOperationHolder.chunk;
     chunkOperationHolder.clear();
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/Subtitle.java b/library/src/main/java/com/google/android/exoplayer/hls/Subtitle.java
deleted file mode 100644
index 082e86c21b..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/hls/Subtitle.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.hls;
-
-/**
- * Subtitle media tag.
- */
-public final class Subtitle {
-
-  public final String name;
-  public final String uri;
-  public final String language;
-  public final boolean isDefault;
-  public final boolean autoSelect;
-
-  public Subtitle(String name, String uri, String language, boolean isDefault, boolean autoSelect) {
-    this.name = name;
-    this.uri = uri;
-    this.language = language;
-    this.autoSelect = autoSelect;
-    this.isDefault = isDefault;
-  }
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/TsChunk.java b/library/src/main/java/com/google/android/exoplayer/hls/TsChunk.java
index 520046be36..8354e312d0 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/TsChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/TsChunk.java
@@ -31,6 +31,11 @@
  */
 public final class TsChunk extends MediaChunk {
 
+  /**
+   * The discontinuity sequence number of the chunk.
+   */
+  public final int discontinuitySequenceNumber;
+
   /**
    * The wrapped extractor into which this chunk is being consumed.
    */
@@ -48,16 +53,18 @@
    * @param format The format of the stream to which this chunk belongs.
    * @param startTimeUs The start time of the media contained by the chunk, in microseconds.
    * @param endTimeUs The end time of the media contained by the chunk, in microseconds.
+   * @param discontinuitySequenceNumber The discontinuity sequence number of the chunk.
    * @param chunkIndex The index of the chunk.
    * @param extractorWrapper A wrapped extractor to parse samples from the data.
    * @param encryptionKey For AES encryption chunks, the encryption key.
    * @param encryptionIv For AES encryption chunks, the encryption initialization vector.
    */
   public TsChunk(DataSource dataSource, DataSpec dataSpec, int trigger, Format format,
-      long startTimeUs, long endTimeUs, int chunkIndex, HlsExtractorWrapper extractorWrapper,
-      byte[] encryptionKey, byte[] encryptionIv) {
+      long startTimeUs, long endTimeUs, int chunkIndex, int discontinuitySequenceNumber,
+      HlsExtractorWrapper extractorWrapper, byte[] encryptionKey, byte[] encryptionIv) {
     super(buildDataSource(dataSource, encryptionKey, encryptionIv), dataSpec, trigger, format,
         startTimeUs, endTimeUs, chunkIndex);
+    this.discontinuitySequenceNumber = discontinuitySequenceNumber;
     this.extractorWrapper = extractorWrapper;
     // Note: this.dataSource and dataSource may be different.
     this.isEncrypted = this.dataSource instanceof Aes128DataSource;
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/Variant.java b/library/src/main/java/com/google/android/exoplayer/hls/Variant.java
index 61d6fb54ae..fa950278b3 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/Variant.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/Variant.java
@@ -17,7 +17,6 @@
 
 import com.google.android.exoplayer.chunk.Format;
 import com.google.android.exoplayer.chunk.FormatWrapper;
-import com.google.android.exoplayer.util.MimeTypes;
 
 /**
  * Variant stream reference.
@@ -27,10 +26,9 @@
   public final String url;
   public final Format format;
 
-  public Variant(int index, String url, int bitrate, String codecs, int width, int height) {
+  public Variant(String url, Format format) {
     this.url = url;
-    format = new Format(Integer.toString(index), MimeTypes.APPLICATION_M3U8, width, height, -1, -1,
-        -1, bitrate, null, codecs);
+    this.format = format;
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/WebvttExtractor.java b/library/src/main/java/com/google/android/exoplayer/hls/WebvttExtractor.java
new file mode 100644
index 0000000000..0e648a0388
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/hls/WebvttExtractor.java
@@ -0,0 +1,171 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.hls;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.ExtractorOutput;
+import com.google.android.exoplayer.extractor.PositionHolder;
+import com.google.android.exoplayer.extractor.SeekMap;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.extractor.ts.PtsTimestampAdjuster;
+import com.google.android.exoplayer.text.webvtt.WebvttParserUtil;
+import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import android.text.TextUtils;
+
+import java.io.BufferedReader;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.util.Arrays;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * A special purpose extractor for WebVTT content in HLS.
+ * <p>
+ * This extractor passes through non-empty WebVTT files untouched, however derives the correct
+ * sample timestamp for each by sniffing the X-TIMESTAMP-MAP header along with the start timestamp
+ * of the first cue header. Empty WebVTT files are not passed through, since it's not possible to
+ * derive a sample timestamp in this case.
+ */
+/* package */ final class WebvttExtractor implements Extractor {
+
+  private static final Pattern LOCAL_TIMESTAMP = Pattern.compile("LOCAL:([^,]+)");
+  private static final Pattern MEDIA_TIMESTAMP = Pattern.compile("MPEGTS:(\\d+)");
+
+  private final PtsTimestampAdjuster ptsTimestampAdjuster;
+  private final ParsableByteArray sampleDataWrapper;
+
+  private ExtractorOutput output;
+
+  private byte[] sampleData;
+  private int sampleSize;
+
+  public WebvttExtractor(PtsTimestampAdjuster ptsTimestampAdjuster) {
+    this.ptsTimestampAdjuster = ptsTimestampAdjuster;
+    this.sampleDataWrapper = new ParsableByteArray();
+    sampleData = new byte[1024];
+  }
+
+  // Extractor implementation.
+
+  @Override
+  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+    // This extractor is only used for the HLS use case, which should not call this method.
+    throw new IllegalStateException();
+  }
+
+  @Override
+  public void init(ExtractorOutput output) {
+    this.output = output;
+    output.seekMap(SeekMap.UNSEEKABLE);
+  }
+
+  @Override
+  public void seek() {
+    // This extractor is only used for the HLS use case, which should not call this method.
+    throw new IllegalStateException();
+  }
+
+  @Override
+  public int read(ExtractorInput input, PositionHolder seekPosition)
+      throws IOException, InterruptedException {
+    int currentFileSize = (int) input.getLength();
+
+    // Increase the size of sampleData if necessary.
+    if (sampleSize == sampleData.length) {
+      sampleData = Arrays.copyOf(sampleData,
+          (currentFileSize != C.LENGTH_UNBOUNDED ? currentFileSize : sampleData.length) * 3 / 2);
+    }
+
+    // Consume to the input.
+    int bytesRead = input.read(sampleData, sampleSize, sampleData.length - sampleSize);
+    if (bytesRead != C.RESULT_END_OF_INPUT) {
+      sampleSize += bytesRead;
+      if (currentFileSize == C.LENGTH_UNBOUNDED || sampleSize != currentFileSize) {
+        return Extractor.RESULT_CONTINUE;
+      }
+    }
+
+    // We've reached the end of the input, which corresponds to the end of the current file.
+    processSample();
+    return Extractor.RESULT_END_OF_INPUT;
+  }
+
+  private void processSample() throws IOException {
+    BufferedReader reader = new BufferedReader(
+        new InputStreamReader(new ByteArrayInputStream(sampleData), C.UTF8_NAME));
+
+    // Validate the first line of the header.
+    WebvttParserUtil.validateWebvttHeaderLine(reader);
+
+    // Defaults to use if the header doesn't contain an X-TIMESTAMP-MAP header.
+    long vttTimestampUs = 0;
+    long tsTimestampUs = 0;
+
+    // Parse the remainder of the header looking for X-TIMESTAMP-MAP.
+    String line;
+    while (!TextUtils.isEmpty(line = reader.readLine())) {
+      if (line.startsWith("X-TIMESTAMP-MAP")) {
+        Matcher localTimestampMatcher = LOCAL_TIMESTAMP.matcher(line);
+        if (!localTimestampMatcher.find()) {
+          throw new ParserException("X-TIMESTAMP-MAP doesn't contain local timestamp: " + line);
+        }
+        Matcher mediaTimestampMatcher = MEDIA_TIMESTAMP.matcher(line);
+        if (!mediaTimestampMatcher.find()) {
+          throw new ParserException("X-TIMESTAMP-MAP doesn't contain media timestamp: " + line);
+        }
+        vttTimestampUs = WebvttParserUtil.parseTimestampUs(localTimestampMatcher.group(1));
+        tsTimestampUs = PtsTimestampAdjuster.ptsToUs(
+            Long.parseLong(mediaTimestampMatcher.group(1)));
+      }
+    }
+
+    // Find the first cue header and parse the start time.
+    Matcher cueHeaderMatcher = WebvttParserUtil.findNextCueHeader(reader);
+    if (cueHeaderMatcher == null) {
+      // No cues found. Don't output a sample, but still output a corresponding track.
+      buildTrackOutput(0);
+      return;
+    }
+
+    long firstCueTimeUs = WebvttParserUtil.parseTimestampUs(cueHeaderMatcher.group(1));
+    long sampleTimeUs = ptsTimestampAdjuster.adjustTimestamp(
+        PtsTimestampAdjuster.usToPts(firstCueTimeUs + tsTimestampUs - vttTimestampUs));
+    long subsampleOffsetUs = sampleTimeUs - firstCueTimeUs;
+    // Output the track.
+    TrackOutput trackOutput = buildTrackOutput(subsampleOffsetUs);
+    // Output the sample.
+    sampleDataWrapper.reset(sampleData, sampleSize);
+    trackOutput.sampleData(sampleDataWrapper, sampleSize);
+    trackOutput.sampleMetadata(sampleTimeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
+  }
+
+  private TrackOutput buildTrackOutput(long subsampleOffsetUs) {
+    TrackOutput trackOutput = output.track(0);
+    trackOutput.format(MediaFormat.createTextFormat("id", MimeTypes.TEXT_VTT, MediaFormat.NO_VALUE,
+        C.UNKNOWN_TIME_US, "en", subsampleOffsetUs));
+    output.endTracks();
+    return trackOutput;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingChunkSource.java b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingChunkSource.java
index 5ab9a4aec8..79405466f6 100644
--- a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingChunkSource.java
@@ -29,6 +29,7 @@
 import com.google.android.exoplayer.chunk.FormatEvaluator.Evaluation;
 import com.google.android.exoplayer.chunk.MediaChunk;
 import com.google.android.exoplayer.drm.DrmInitData;
+import com.google.android.exoplayer.drm.DrmInitData.SchemeInitData;
 import com.google.android.exoplayer.extractor.mp4.FragmentedMp4Extractor;
 import com.google.android.exoplayer.extractor.mp4.Track;
 import com.google.android.exoplayer.extractor.mp4.TrackEncryptionBox;
@@ -144,8 +145,9 @@ private SmoothStreamingChunkSource(ManifestFetcher<SmoothStreamingManifest> mani
       byte[] keyId = getProtectionElementKeyId(protectionElement.data);
       trackEncryptionBoxes = new TrackEncryptionBox[1];
       trackEncryptionBoxes[0] = new TrackEncryptionBox(true, INITIALIZATION_VECTOR_SIZE, keyId);
-      drmInitData = new DrmInitData.Mapped(MimeTypes.VIDEO_MP4);
-      drmInitData.put(protectionElement.uuid, protectionElement.data);
+      drmInitData = new DrmInitData.Mapped();
+      drmInitData.put(protectionElement.uuid,
+          new SchemeInitData(MimeTypes.VIDEO_MP4, protectionElement.data));
     } else {
       trackEncryptionBoxes = null;
       drmInitData = null;
@@ -234,8 +236,8 @@ public void continueBuffering(long playbackPositionUs) {
   }
 
   @Override
-  public final void getChunkOperation(List<? extends MediaChunk> queue, long seekPositionUs,
-      long playbackPositionUs, ChunkOperationHolder out) {
+  public final void getChunkOperation(List<? extends MediaChunk> queue, long playbackPositionUs,
+      ChunkOperationHolder out) {
     if (fatalError != null) {
       out.chunk = null;
       return;
@@ -279,9 +281,9 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long seekP
     int chunkIndex;
     if (queue.isEmpty()) {
       if (live) {
-        seekPositionUs = getLiveSeekPosition(currentManifest, liveEdgeLatencyUs);
+        playbackPositionUs = getLiveSeekPosition(currentManifest, liveEdgeLatencyUs);
       }
-      chunkIndex = streamElement.getChunkIndex(seekPositionUs);
+      chunkIndex = streamElement.getChunkIndex(playbackPositionUs);
     } else {
       MediaChunk previous = queue.get(out.queueSize - 1);
       chunkIndex = previous.chunkIndex + 1 - currentManifestChunkOffset;
@@ -368,7 +370,7 @@ public void adaptiveTrack(SmoothStreamingManifest manifest, int element, int[] t
       maxHeight = Math.max(maxHeight, mediaFormat.height);
     }
     Arrays.sort(formats, new DecreasingBandwidthComparator());
-    MediaFormat adaptiveMediaFormat = maxHeightMediaFormat.copyAsAdaptive();
+    MediaFormat adaptiveMediaFormat = maxHeightMediaFormat.copyAsAdaptive(null);
     tracks.add(new ExposedTrack(adaptiveMediaFormat, element, formats, maxWidth, maxHeight));
   }
 
@@ -398,9 +400,8 @@ private MediaFormat initManifestTrack(SmoothStreamingManifest manifest, int elem
     int mp4TrackType;
     switch (element.type) {
       case StreamElement.TYPE_VIDEO:
-        mediaFormat = MediaFormat.createVideoFormat(MediaFormat.NO_VALUE, format.mimeType,
-            format.bitrate, MediaFormat.NO_VALUE, durationUs, format.width, format.height,
-            Arrays.asList(csdArray));
+        mediaFormat = MediaFormat.createVideoFormat(format.id, format.mimeType, format.bitrate,
+            MediaFormat.NO_VALUE, durationUs, format.width, format.height, Arrays.asList(csdArray));
         mp4TrackType = Track.TYPE_vide;
         break;
       case StreamElement.TYPE_AUDIO:
@@ -411,14 +412,14 @@ private MediaFormat initManifestTrack(SmoothStreamingManifest manifest, int elem
           csd = Collections.singletonList(CodecSpecificDataUtil.buildAacAudioSpecificConfig(
               format.audioSamplingRate, format.audioChannels));
         }
-        mediaFormat = MediaFormat.createAudioFormat(MediaFormat.NO_VALUE, format.mimeType,
-            format.bitrate, MediaFormat.NO_VALUE, durationUs, format.audioChannels,
-            format.audioSamplingRate, csd, format.language);
+        mediaFormat = MediaFormat.createAudioFormat(format.id, format.mimeType, format.bitrate,
+            MediaFormat.NO_VALUE, durationUs, format.audioChannels, format.audioSamplingRate, csd,
+            format.language);
         mp4TrackType = Track.TYPE_soun;
         break;
       case StreamElement.TYPE_TEXT:
-        mediaFormat = MediaFormat.createTextFormat(MediaFormat.NO_VALUE, format.mimeType,
-            format.bitrate, durationUs, format.language);
+        mediaFormat = MediaFormat.createTextFormat(format.id, format.mimeType, format.bitrate,
+            durationUs, format.language);
         mp4TrackType = Track.TYPE_text;
         break;
       default:
@@ -429,8 +430,9 @@ private MediaFormat initManifestTrack(SmoothStreamingManifest manifest, int elem
     FragmentedMp4Extractor mp4Extractor = new FragmentedMp4Extractor(
         FragmentedMp4Extractor.WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME
         | FragmentedMp4Extractor.WORKAROUND_IGNORE_TFDT_BOX);
-    Track mp4Track = new Track(trackIndex, mp4TrackType, element.timescale, durationUs, mediaFormat,
-        trackEncryptionBoxes, mp4TrackType == Track.TYPE_vide ? 4 : -1);
+    Track mp4Track = new Track(trackIndex, mp4TrackType, element.timescale, C.UNKNOWN_TIME_US,
+        durationUs, mediaFormat, trackEncryptionBoxes, mp4TrackType == Track.TYPE_vide ? 4 : -1,
+        null, null);
     mp4Extractor.setTrack(mp4Track);
 
     // Store the format and a wrapper around the extractor.
diff --git a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifestParser.java b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifestParser.java
index ee40743623..b4c91b7935 100644
--- a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifestParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifestParser.java
@@ -676,6 +676,16 @@ private static String fourCCToMimeType(String fourCC) {
         return MimeTypes.AUDIO_AAC;
       } else if (fourCC.equalsIgnoreCase("TTML")) {
         return MimeTypes.APPLICATION_TTML;
+      } else if (fourCC.equalsIgnoreCase("ac-3") || fourCC.equalsIgnoreCase("dac3")) {
+        return MimeTypes.AUDIO_AC3;
+      } else if (fourCC.equalsIgnoreCase("ec-3") || fourCC.equalsIgnoreCase("dec3")) {
+        return MimeTypes.AUDIO_E_AC3;
+      } else if (fourCC.equalsIgnoreCase("dtsc") || fourCC.equalsIgnoreCase("dtse")) {
+        return MimeTypes.AUDIO_DTS;
+      } else if (fourCC.equalsIgnoreCase("dtsh") || fourCC.equalsIgnoreCase("dtsl")) {
+        return MimeTypes.AUDIO_DTS_HD;
+      } else if (fourCC.equalsIgnoreCase("opus")) {
+        return MimeTypes.AUDIO_OPUS;
       }
       return null;
     }
diff --git a/library/src/main/java/com/google/android/exoplayer/text/subrip/SubripParser.java b/library/src/main/java/com/google/android/exoplayer/text/subrip/SubripParser.java
index 7c7c3f3ae1..9055c1e1ef 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/subrip/SubripParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/subrip/SubripParser.java
@@ -16,7 +16,6 @@
 package com.google.android.exoplayer.text.subrip;
 
 import com.google.android.exoplayer.C;
-import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.text.Cue;
 import com.google.android.exoplayer.text.SubtitleParser;
 import com.google.android.exoplayer.util.LongArray;
@@ -47,24 +46,14 @@
       Pattern.compile("(?:(\\d+):)?(\\d+):(\\d+),(\\d+)");
 
   private final StringBuilder textBuilder;
-  private final boolean strictParsing;
 
-  /**
-   * Equivalent to {@code SubripParser(false)}.
-   */
   public SubripParser() {
-    this(false);
+    textBuilder = new StringBuilder();
   }
 
-  /**
-   * @param strictParsing If true, {@link #parse(InputStream)} will throw a {@link ParserException}
-   *     if the stream contains invalid data. If false, the parser will make a best effort to ignore
-   *     minor errors in the stream. Note however that a {@link ParserException} will still be
-   *     thrown when this is not possible.
-   */
-  public SubripParser(boolean strictParsing) {
-    this.strictParsing = strictParsing;
-    textBuilder = new StringBuilder();
+  @Override
+  public boolean canParse(String mimeType) {
+    return MimeTypes.APPLICATION_SUBRIP.equals(mimeType);
   }
 
   @Override
@@ -85,12 +74,8 @@ public SubripSubtitle parse(InputStream inputStream) throws IOException {
       try {
         Integer.parseInt(currentLine);
       } catch (NumberFormatException e) {
-        if (!strictParsing) {
-          Log.w(TAG, "Skipping invalid index: " + currentLine);
-          continue;
-        } else {
-          throw new ParserException("Expected numeric counter: " + currentLine);
-        }
+        Log.w(TAG, "Skipping invalid index: " + currentLine);
+        continue;
       }
 
       // Read and parse the timing line.
@@ -104,11 +89,9 @@ public SubripSubtitle parse(InputStream inputStream) throws IOException {
           haveEndTimecode = true;
           cueTimesUs.add(parseTimecode(matcher.group(2)));
         }
-      } else if (!strictParsing) {
+      } else {
         Log.w(TAG, "Skipping invalid timing: " + currentLine);
         continue;
-      } else {
-        throw new ParserException("Expected timing line: " + currentLine);
       }
 
       // Read and parse the text.
@@ -133,11 +116,6 @@ public SubripSubtitle parse(InputStream inputStream) throws IOException {
     return new SubripSubtitle(cuesArray, cueTimesUsArray);
   }
 
-  @Override
-  public boolean canParse(String mimeType) {
-    return MimeTypes.APPLICATION_SUBRIP.equals(mimeType);
-  }
-
   private static long parseTimecode(String s) throws NumberFormatException {
     Matcher matcher = SUBRIP_TIMESTAMP.matcher(s);
     if (!matcher.matches()) {
diff --git a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java
index 87670e7f8b..7bbaa9a215 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java
@@ -73,6 +73,8 @@
           + "(?:(\\.[0-9]+)|:([0-9][0-9])(?:\\.([0-9]+))?)?$");
   private static final Pattern OFFSET_TIME =
       Pattern.compile("^([0-9]+(?:\\.[0-9]+)?)(h|m|s|ms|f|t)$");
+  private static final Pattern FONT_SIZE =
+      Pattern.compile("^(([0-9]*.)?[0-9]+)(px|em|%)$");
 
   // TODO: read and apply the following attributes if specified.
   private static final int DEFAULT_FRAMERATE = 30;
@@ -80,23 +82,8 @@
   private static final int DEFAULT_TICKRATE = 1;
 
   private final XmlPullParserFactory xmlParserFactory;
-  private final boolean strictParsing;
 
-  /**
-   * Equivalent to {@code TtmlParser(false)}.
-   */
   public TtmlParser() {
-    this(false);
-  }
-
-  /**
-   * @param strictParsing If true, {@link #parse(InputStream)} will throw a {@link ParserException}
-   *     if the stream contains invalid data. If false, the parser will make a best effort to ignore
-   *     minor errors in the stream. Note however that a {@link ParserException} will still be
-   *     thrown when this is not possible.
-   */
-  public TtmlParser(boolean strictParsing) {
-    this.strictParsing = strictParsing;
     try {
       xmlParserFactory = XmlPullParserFactory.newInstance();
     } catch (XmlPullParserException e) {
@@ -104,6 +91,11 @@ public TtmlParser(boolean strictParsing) {
     }
   }
 
+  @Override
+  public boolean canParse(String mimeType) {
+    return MimeTypes.APPLICATION_TTML.equals(mimeType);
+  }
+
   @Override
   public Subtitle parse(InputStream inputStream) throws IOException {
     try {
@@ -132,13 +124,9 @@ public Subtitle parse(InputStream inputStream) throws IOException {
                   parent.addChild(node);
                 }
               } catch (ParserException e) {
-                if (strictParsing) {
-                  throw e;
-                } else {
-                  Log.w(TAG, "Suppressing parser error", e);
-                  // Treat the node (and by extension, all of its children) as unsupported.
-                  unsupportedNodeDepth++;
-                }
+                Log.w(TAG, "Suppressing parser error", e);
+                // Treat the node (and by extension, all of its children) as unsupported.
+                unsupportedNodeDepth++;
               }
             }
           } else if (eventType == XmlPullParser.TEXT) {
@@ -223,7 +211,12 @@ private TtmlStyle parseStyleAttributes(XmlPullParser parser, TtmlStyle style) {
           style = createIfNull(style).setFontFamily(attributeValue);
           break;
         case TtmlNode.ATTR_TTS_FONT_SIZE:
-          // TODO: handle size
+          try {
+            style = createIfNull(style);
+            parseFontSize(attributeValue, style);
+          } catch (ParserException e) {
+            Log.w(TAG, "failed parsing fontSize value: '" + attributeValue + "'");
+          }
           break;
         case TtmlNode.ATTR_TTS_FONT_WEIGHT:
           style = createIfNull(style).setBold(
@@ -280,11 +273,6 @@ private TtmlStyle createIfNull(TtmlStyle style) {
     return style == null ? new TtmlStyle() : style;
   }
 
-  @Override
-  public boolean canParse(String mimeType) {
-    return MimeTypes.APPLICATION_TTML.equals(mimeType);
-  }
-
   private TtmlNode parseNode(XmlPullParser parser, TtmlNode parent) throws ParserException {
     long duration = 0;
     long startTime = TtmlNode.UNDEFINED_TIME;
@@ -355,6 +343,40 @@ private static boolean isSupportedTag(String tag) {
     return false;
   }
 
+  private static void parseFontSize(String expression, TtmlStyle out) throws ParserException {
+    String[] expressions = expression.split("\\s+");
+    Matcher matcher;
+    if (expressions.length == 1) {
+      matcher = FONT_SIZE.matcher(expression);
+    } else if (expressions.length == 2){
+      matcher = FONT_SIZE.matcher(expressions[1]);
+      Log.w(TAG, "multiple values in fontSize attribute. Picking the second "
+          + "value for vertical font size and ignoring the first.");
+    } else {
+      throw new ParserException();
+    }
+
+    if (matcher.matches()) {
+      String unit = matcher.group(3);
+      switch (unit) {
+        case "px":
+          out.setFontSizeUnit(TtmlStyle.FONT_SIZE_UNIT_PIXEL);
+          break;
+        case "em":
+          out.setFontSizeUnit(TtmlStyle.FONT_SIZE_UNIT_EM);
+          break;
+        case "%":
+          out.setFontSizeUnit(TtmlStyle.FONT_SIZE_UNIT_PERCENT);
+          break;
+        default:
+          throw new ParserException();
+      }
+      out.setFontSize(Float.valueOf(matcher.group(1)));
+    } else {
+      throw new ParserException();
+    }
+  }
+
   /**
    * Parses a time expression, returning the parsed timestamp.
    * <p>
diff --git a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlRenderUtil.java b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlRenderUtil.java
index 638e47d276..63b6cc8886 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlRenderUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlRenderUtil.java
@@ -18,9 +18,11 @@
 import android.text.Spannable;
 import android.text.SpannableStringBuilder;
 import android.text.Spanned;
+import android.text.style.AbsoluteSizeSpan;
 import android.text.style.AlignmentSpan;
 import android.text.style.BackgroundColorSpan;
 import android.text.style.ForegroundColorSpan;
+import android.text.style.RelativeSizeSpan;
 import android.text.style.StrikethroughSpan;
 import android.text.style.StyleSpan;
 import android.text.style.TypefaceSpan;
@@ -101,6 +103,22 @@ public static void applyStylesToSpan(SpannableStringBuilder builder,
       builder.setSpan(new AlignmentSpan.Standard(style.getTextAlign()), start, end,
           Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
     }
+    if (style.getFontSizeUnit() != TtmlStyle.UNSPECIFIED) {
+      switch (style.getFontSizeUnit()) {
+        case TtmlStyle.FONT_SIZE_UNIT_PIXEL:
+          builder.setSpan(new AbsoluteSizeSpan((int) style.getFontSize(), true), start, end,
+              Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+          break;
+        case TtmlStyle.FONT_SIZE_UNIT_EM:
+          builder.setSpan(new RelativeSizeSpan(style.getFontSize()), start, end,
+              Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+          break;
+        case TtmlStyle.FONT_SIZE_UNIT_PERCENT:
+          builder.setSpan(new RelativeSizeSpan(style.getFontSize() / 100), start, end,
+              Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+          break;
+      }
+    }
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlStyle.java b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlStyle.java
index 7bb2891d0e..4cb5f95a86 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlStyle.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlStyle.java
@@ -23,7 +23,7 @@
 /**
  * Style object of a <code>TtmlNode</code>
  */
-public final class TtmlStyle {
+/* package */ final class TtmlStyle {
 
   public static final short UNSPECIFIED = -1;
 
@@ -32,6 +32,10 @@
   public static final short STYLE_ITALIC = Typeface.ITALIC;
   public static final short STYLE_BOLD_ITALIC = Typeface.BOLD_ITALIC;
 
+  public static final short FONT_SIZE_UNIT_PIXEL = 1;
+  public static final short FONT_SIZE_UNIT_EM = 2;
+  public static final short FONT_SIZE_UNIT_PERCENT = 3;
+
   private static final short OFF = 0;
   private static final short ON = 1;
 
@@ -44,6 +48,8 @@
   private short underline = UNSPECIFIED;
   private short bold = UNSPECIFIED;
   private short italic = UNSPECIFIED;
+  private short fontSizeUnit = UNSPECIFIED;
+  private float fontSize;
   private String id;
   private TtmlStyle inheritableStyle;
   private Layout.Alignment textAlign;
@@ -139,19 +145,6 @@ public TtmlStyle setItalic(boolean isItalic) {
     return this;
   }
 
-  public TtmlStyle getInheritableStyle() {
-    if (isFullyInheritable()) {
-      return this;
-    } else if (inheritableStyle == null) {
-      inheritableStyle = new TtmlStyle().inherit(this);
-    }
-    return inheritableStyle;
-  }
-
-  private boolean isFullyInheritable() {
-    return !backgroundColorSpecified;
-  }
-
   /**
    * Inherits from an ancestor style. Properties like <i>tts:backgroundColor</i> which
    * are not inheritable are not inherited as well as properties which are already set locally
@@ -196,6 +189,10 @@ private TtmlStyle inherit(TtmlStyle ancestor, boolean chaining) {
       if (textAlign == null) {
         textAlign = ancestor.textAlign;
       }
+      if (fontSizeUnit == UNSPECIFIED) {
+        fontSizeUnit = ancestor.fontSizeUnit;
+        fontSize = ancestor.fontSize;
+      }
       // attributes not inherited as of http://www.w3.org/TR/ttml1/
       if (chaining && !backgroundColorSpecified && ancestor.backgroundColorSpecified) {
         setBackgroundColor(ancestor.backgroundColor);
@@ -221,4 +218,23 @@ public TtmlStyle setTextAlign(Layout.Alignment textAlign) {
     this.textAlign = textAlign;
     return this;
   }
+
+  public TtmlStyle setFontSize(float fontSize) {
+    this.fontSize = fontSize;
+    return this;
+  }
+
+  public TtmlStyle setFontSizeUnit(short unit) {
+    this.fontSizeUnit = unit;
+    return this;
+  }
+
+  public short getFontSizeUnit() {
+    return fontSizeUnit;
+  }
+
+  public float getFontSize() {
+    return fontSize;
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/text/tx3g/Tx3gParser.java b/library/src/main/java/com/google/android/exoplayer/text/tx3g/Tx3gParser.java
index b6f02ff2f4..4804c2e913 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/tx3g/Tx3gParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/tx3g/Tx3gParser.java
@@ -31,6 +31,11 @@
  */
 public final class Tx3gParser implements SubtitleParser {
 
+  @Override
+  public boolean canParse(String mimeType) {
+    return MimeTypes.APPLICATION_TX3G.equals(mimeType);
+  }
+
   @Override
   public Subtitle parse(InputStream inputStream) throws IOException {
     DataInputStream dataInputStream  = new DataInputStream(inputStream);
@@ -38,9 +43,4 @@ public Subtitle parse(InputStream inputStream) throws IOException {
     return new Tx3gSubtitle(new Cue(cueText));
   }
 
-  @Override
-  public boolean canParse(String mimeType) {
-    return MimeTypes.APPLICATION_TX3G.equals(mimeType);
-  }
-
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttCueParser.java b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttCueParser.java
new file mode 100644
index 0000000000..89eedf5bf9
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttCueParser.java
@@ -0,0 +1,217 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text.webvtt;
+
+import android.graphics.Typeface;
+import android.text.SpannableStringBuilder;
+import android.text.Spanned;
+import android.text.style.StyleSpan;
+import android.text.style.UnderlineSpan;
+import android.util.Log;
+
+import java.util.Stack;
+
+/**
+ * Parser for webvtt cue text. (https://w3c.github.io/webvtt/#cue-text)
+ */
+/* package */ final class WebvttCueParser {
+
+  private static final char CHAR_LESS_THAN = '<';
+  private static final char CHAR_GREATER_THAN = '>';
+  private static final char CHAR_SLASH = '/';
+  private static final char CHAR_AMPERSAND = '&';
+  private static final char CHAR_SEMI_COLON = ';';
+  private static final char CHAR_SPACE = ' ';
+  private static final String SPACE = " ";
+
+  private static final String ENTITY_LESS_THAN = "lt";
+  private static final String ENTITY_GREATER_THAN = "gt";
+  private static final String ENTITY_AMPERSAND = "amp";
+  private static final String ENTITY_NON_BREAK_SPACE = "nbsp";
+
+  private static final String TAG_BOLD = "b";
+  private static final String TAG_ITALIC = "i";
+  private static final String TAG_UNDERLINE = "u";
+  private static final String TAG_CLASS = "c";
+  private static final String TAG_VOICE = "v";
+  private static final String TAG_LANG = "lang";
+
+  private static final int STYLE_BOLD = Typeface.BOLD;
+  private static final int STYLE_ITALIC = Typeface.ITALIC;
+
+  private static final String TAG = "WebvttCueParser";
+
+  public Spanned parse(String markup) {
+    SpannableStringBuilder spannedText = new SpannableStringBuilder();
+    Stack<StartTag> startTagStack = new Stack<>();
+    String[] tagTokens;
+    int pos = 0;
+    while (pos < markup.length()) {
+      char curr = markup.charAt(pos);
+      switch (curr) {
+        case CHAR_LESS_THAN:
+          if (pos + 1 >= markup.length()) {
+            pos++;
+            break; // avoid ArrayOutOfBoundsException
+          }
+          int ltPos = pos;
+          boolean isClosingTag = markup.charAt(ltPos + 1) == CHAR_SLASH;
+          pos = findEndOfTag(markup, ltPos + 1);
+          boolean isVoidTag = markup.charAt(pos - 2) == CHAR_SLASH;
+
+          tagTokens = tokenizeTag(markup.substring(
+              ltPos + (isClosingTag ? 2 : 1), isVoidTag ? pos - 2 : pos - 1));
+          if (tagTokens == null || !isSupportedTag(tagTokens[0])) {
+            continue;
+          }
+          if (isClosingTag) {
+            StartTag startTag;
+            do {
+              if (startTagStack.isEmpty()) {
+                break;
+              }
+              startTag = startTagStack.pop();
+              applySpansForTag(startTag, spannedText);
+            } while(!startTag.name.equals(tagTokens[0]));
+          } else if (!isVoidTag) {
+            startTagStack.push(new StartTag(tagTokens[0], spannedText.length()));
+          }
+          break;
+        case CHAR_AMPERSAND:
+          int semiColonEnd = markup.indexOf(CHAR_SEMI_COLON, pos + 1);
+          int spaceEnd = markup.indexOf(CHAR_SPACE, pos + 1);
+          int entityEnd = semiColonEnd == -1 ? spaceEnd
+              : spaceEnd == -1 ? semiColonEnd : Math.min(semiColonEnd, spaceEnd);
+          if (entityEnd != -1) {
+            applyEntity(markup.substring(pos + 1, entityEnd), spannedText);
+            if (entityEnd == spaceEnd) {
+              spannedText.append(" ");
+            }
+            pos = entityEnd + 1;
+          } else {
+            spannedText.append(curr);
+            pos++;
+          }
+          break;
+        default:
+          spannedText.append(curr);
+          pos++;
+          break;
+      }
+    }
+    // apply unclosed tags
+    while (!startTagStack.isEmpty()) {
+      applySpansForTag(startTagStack.pop(), spannedText);
+    }
+    return spannedText;
+  }
+
+  /**
+   * Find end of tag (&gt;). The position returned is the position of the &gt; plus one (exclusive).
+   *
+   * @param markup The webvtt cue markup to be parsed.
+   * @param startPos the position from where to start searching for the end of tag.
+   * @return the position of the end of tag plus 1 (one).
+   */
+  private int findEndOfTag(String markup, int startPos) {
+    int idx = markup.indexOf(CHAR_GREATER_THAN, startPos);
+    return idx == -1 ? markup.length() : idx + 1;
+  }
+
+  private void applyEntity(String entity, SpannableStringBuilder spannedText) {
+    switch (entity) {
+      case ENTITY_LESS_THAN:
+        spannedText.append('<');
+        break;
+      case ENTITY_GREATER_THAN:
+        spannedText.append('>');
+        break;
+      case ENTITY_NON_BREAK_SPACE:
+        spannedText.append(' ');
+        break;
+      case ENTITY_AMPERSAND:
+        spannedText.append('&');
+        break;
+      default:
+        Log.w(TAG, "ignoring unsupported entity: '&" + entity + ";'");
+        break;
+    }
+  }
+
+  private boolean isSupportedTag(String tagName) {
+    switch (tagName) {
+      case TAG_BOLD:
+      case TAG_CLASS:
+      case TAG_ITALIC:
+      case TAG_LANG:
+      case TAG_UNDERLINE:
+      case TAG_VOICE:
+        return true;
+      default:
+        return false;
+    }
+  }
+
+  private void applySpansForTag(StartTag startTag, SpannableStringBuilder spannedText) {
+    switch(startTag.name) {
+      case TAG_BOLD:
+        spannedText.setSpan(new StyleSpan(STYLE_BOLD), startTag.position,
+            spannedText.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        return;
+      case TAG_ITALIC:
+        spannedText.setSpan(new StyleSpan(STYLE_ITALIC), startTag.position,
+            spannedText.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        return;
+      case TAG_UNDERLINE:
+        spannedText.setSpan(new UnderlineSpan(), startTag.position,
+            spannedText.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        return;
+      default:
+        break;
+    }
+  }
+
+  /**
+   * Tokenizes a tag expression into tag name (pos 0) and classes (pos 1..n).
+   *
+   * @param fullTagExpression characters between &amp;lt: and &amp;gt; of a start or end tag
+   * @return an array of <code>String</code>s with the tag name at pos 0 followed by style classes
+   *    or null if it's an empty tag: '&lt;&gt;'
+   */
+  private String[] tokenizeTag(String fullTagExpression) {
+    fullTagExpression = fullTagExpression.replace("\\s+", " ").trim();
+    if (fullTagExpression.length() == 0) {
+      return null;
+    }
+    if (fullTagExpression.contains(SPACE)) {
+      fullTagExpression = fullTagExpression.substring(0, fullTagExpression.indexOf(SPACE));
+    }
+    return fullTagExpression.split("\\.");
+  }
+
+  private static final class StartTag {
+
+    public final String name;
+    public final int position;
+
+    public StartTag(String name, int position) {
+      this.position = position;
+      this.name = name;
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParser.java b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParser.java
index 53510d257b..aca43b451f 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParser.java
@@ -16,13 +16,12 @@
 package com.google.android.exoplayer.text.webvtt;
 
 import com.google.android.exoplayer.C;
-import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.text.Cue;
 import com.google.android.exoplayer.text.SubtitleParser;
 import com.google.android.exoplayer.util.MimeTypes;
 
-import android.text.Html;
 import android.text.Layout.Alignment;
+import android.text.TextUtils;
 import android.util.Log;
 
 import java.io.BufferedReader;
@@ -42,94 +41,47 @@
 
   private static final String TAG = "WebvttParser";
 
-  private static final Pattern HEADER = Pattern.compile("^\uFEFF?WEBVTT((\u0020|\u0009).*)?$");
-  private static final Pattern COMMENT_BLOCK = Pattern.compile("^NOTE((\u0020|\u0009).*)?$");
-  private static final Pattern METADATA_HEADER = Pattern.compile("\\S*[:=]\\S*");
-  private static final Pattern CUE_IDENTIFIER = Pattern.compile("^(?!.*(-->)).*$");
-  private static final Pattern TIMESTAMP = Pattern.compile("(\\d+:)?[0-5]\\d:[0-5]\\d\\.\\d{3}");
-  private static final Pattern CUE_SETTING = Pattern.compile("\\S*:\\S*");
+  private static final Pattern CUE_SETTING = Pattern.compile("(\\S+?):(\\S+)");
 
+  private final WebvttCueParser cueParser;
   private final PositionHolder positionHolder;
   private final StringBuilder textBuilder;
-  private final boolean strictParsing;
 
-  /**
-   * Equivalent to {@code WebvttParser(false)}.
-   */
   public WebvttParser() {
-    this(false);
-  }
-
-  /**
-   * @param strictParsing If true, {@link #parse(InputStream)} will throw a {@link ParserException}
-   *     if the stream contains invalid data. If false, the parser will make a best effort to ignore
-   *     minor errors in the stream. Note however that a {@link ParserException} will still be
-   *     thrown when this is not possible.
-   */
-  public WebvttParser(boolean strictParsing) {
-    this.strictParsing = strictParsing;
+    this.cueParser = new WebvttCueParser();
     positionHolder = new PositionHolder();
     textBuilder = new StringBuilder();
   }
 
   @Override
-  public final WebvttSubtitle parse(InputStream inputStream) throws IOException {
-    ArrayList<WebvttCue> subtitles = new ArrayList<>();
+  public final boolean canParse(String mimeType) {
+    return MimeTypes.TEXT_VTT.equals(mimeType);
+  }
 
+  @Override
+  public final WebvttSubtitle parse(InputStream inputStream) throws IOException {
     BufferedReader webvttData = new BufferedReader(new InputStreamReader(inputStream, C.UTF8_NAME));
-    String line;
-
-    // file should start with "WEBVTT"
-    line = webvttData.readLine();
-    if (line == null || !HEADER.matcher(line).matches()) {
-      throw new ParserException("Expected WEBVTT. Got " + line);
-    }
-
-    // parse the remainder of the header
-    while (true) {
-      line = webvttData.readLine();
-      if (line == null) {
-        // we reached EOF before finishing the header
-        throw new ParserException("Expected an empty line after webvtt header");
-      } else if (line.isEmpty()) {
-        // we've read the newline that separates the header from the body
-        break;
-      }
 
-      if (strictParsing) {
-        Matcher matcher = METADATA_HEADER.matcher(line);
-        if (!matcher.find()) {
-          throw new ParserException("Unexpected line: " + line);
-        }
-      }
-    }
+    // Validate the first line of the header, and skip the remainder.
+    WebvttParserUtil.validateWebvttHeaderLine(webvttData);
+    while (!TextUtils.isEmpty(webvttData.readLine())) {}
 
-    // process the cues and text
-    while ((line = webvttData.readLine()) != null) {
-      // parse webvtt comment block in case it is present
-      Matcher matcher = COMMENT_BLOCK.matcher(line);
-      if (matcher.find()) {
-        // read lines until finding an empty one (webvtt line terminator: CRLF, or LF or CR)
-        while ((line = webvttData.readLine()) != null && !line.isEmpty()) {
-          // ignore comment text
-        }
+    // Process the cues and text.
+    ArrayList<WebvttCue> subtitles = new ArrayList<>();
+    Matcher cueHeaderMatcher;
+    while ((cueHeaderMatcher = WebvttParserUtil.findNextCueHeader(webvttData)) != null) {
+      long cueStartTime;
+      long cueEndTime;
+      try {
+        // Parse the cue start and end times.
+        cueStartTime = WebvttParserUtil.parseTimestampUs(cueHeaderMatcher.group(1));
+        cueEndTime = WebvttParserUtil.parseTimestampUs(cueHeaderMatcher.group(2));
+      } catch (NumberFormatException e) {
+        Log.w(TAG, "Skipping cue with bad header: " + cueHeaderMatcher.group());
         continue;
       }
 
-      // parse the cue identifier (if present) {
-      matcher = CUE_IDENTIFIER.matcher(line);
-      if (matcher.find()) {
-        // ignore the identifier (we currently don't use it) and read the next line
-        line = webvttData.readLine();
-        if (line == null) {
-          // end of file
-          break;
-        }
-      }
-
-      long cueStartTime;
-      long cueEndTime;
-      CharSequence cueText;
+      // Default cue settings.
       Alignment cueTextAlignment = null;
       float cueLine = Cue.DIMEN_UNSET;
       int cueLineType = Cue.TYPE_UNSET;
@@ -138,34 +90,11 @@ public final WebvttSubtitle parse(InputStream inputStream) throws IOException {
       int cuePositionAnchor = Cue.TYPE_UNSET;
       float cueWidth = Cue.DIMEN_UNSET;
 
-      // parse the cue timestamps
-      matcher = TIMESTAMP.matcher(line);
-
-      // parse start timestamp
-      if (!matcher.find()) {
-        throw new ParserException("Expected cue start time: " + line);
-      } else {
-        cueStartTime = parseTimestampUs(matcher.group());
-      }
-
-      // parse end timestamp
-      String endTimeString;
-      if (!matcher.find()) {
-        throw new ParserException("Expected cue end time: " + line);
-      } else {
-        endTimeString = matcher.group();
-        cueEndTime = parseTimestampUs(endTimeString);
-      }
-
-      // parse the (optional) cue setting list
-      line = line.substring(line.indexOf(endTimeString) + endTimeString.length());
-      matcher = CUE_SETTING.matcher(line);
-      while (matcher.find()) {
-        String match = matcher.group();
-        String[] parts = match.split(":", 2);
-        String name = parts[0];
-        String value = parts[1];
-
+      // Parse the cue settings list.
+      Matcher cueSettingMatcher = CUE_SETTING.matcher(cueHeaderMatcher.group(3));
+      while (cueSettingMatcher.find()) {
+        String name = cueSettingMatcher.group(1);
+        String value = cueSettingMatcher.group(2);
         try {
           if ("line".equals(name)) {
             parseLineAttribute(value, positionHolder);
@@ -184,7 +113,7 @@ public final WebvttSubtitle parse(InputStream inputStream) throws IOException {
             Log.w(TAG, "Unknown cue setting " + name + ":" + value);
           }
         } catch (NumberFormatException e) {
-          Log.w(TAG, e.getMessage() + ": " + match);
+          Log.w(TAG, "Skipping bad cue setting: " + cueSettingMatcher.group());
         }
       }
 
@@ -194,15 +123,17 @@ public final WebvttSubtitle parse(InputStream inputStream) throws IOException {
         cuePositionAnchor = alignmentToAnchor(cueTextAlignment);
       }
 
-      // parse text
+      // Parse the cue text.
       textBuilder.setLength(0);
+      String line;
       while ((line = webvttData.readLine()) != null && !line.isEmpty()) {
         if (textBuilder.length() > 0) {
-          textBuilder.append("<br>");
+          textBuilder.append("\n");
         }
         textBuilder.append(line.trim());
       }
-      cueText = Html.fromHtml(textBuilder.toString());
+
+      CharSequence cueText = cueParser.parse(textBuilder.toString());
 
       WebvttCue cue = new WebvttCue(cueStartTime, cueEndTime, cueText, cueTextAlignment, cueLine,
           cueLineType, cueLineAnchor, cuePosition, cuePositionAnchor, cueWidth);
@@ -212,21 +143,6 @@ public final WebvttSubtitle parse(InputStream inputStream) throws IOException {
     return new WebvttSubtitle(subtitles);
   }
 
-  @Override
-  public final boolean canParse(String mimeType) {
-    return MimeTypes.TEXT_VTT.equals(mimeType);
-  }
-
-  private static long parseTimestampUs(String s) throws NumberFormatException {
-    long value = 0;
-    String[] parts = s.split("\\.", 2);
-    String[] subparts = parts[0].split(":");
-    for (int i = 0; i < subparts.length; i++) {
-      value = value * 60 + Long.parseLong(subparts[i]);
-    }
-    return (value * 1000 + Long.parseLong(parts[1])) * 1000;
-  }
-
   private static void parseLineAttribute(String s, PositionHolder out)
       throws NumberFormatException {
     int lineAnchor;
diff --git a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParserUtil.java b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParserUtil.java
new file mode 100644
index 0000000000..1ecc299196
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParserUtil.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text.webvtt;
+
+import com.google.android.exoplayer.ParserException;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Utility methods for parsing WebVTT data.
+ */
+public final class WebvttParserUtil {
+
+  private static final Pattern HEADER = Pattern.compile("^\uFEFF?WEBVTT((\u0020|\u0009).*)?$");
+  private static final Pattern COMMENT = Pattern.compile("^NOTE((\u0020|\u0009).*)?$");
+  private static final Pattern CUE_HEADER = Pattern.compile("^(\\S+)\\s+-->\\s+(\\S+)(.*)?$");
+
+  private WebvttParserUtil() {}
+
+  /**
+   * Reads and validates the first line of a WebVTT file.
+   *
+   * @param input The input from which the line should be read.
+   * @throws ParserException If the line isn't the start of a valid WebVTT file.
+   * @throws IOException If an error occurs reading from the input.
+   */
+  public static void validateWebvttHeaderLine(BufferedReader input) throws IOException {
+    String line = input.readLine();
+    if (line == null || !HEADER.matcher(line).matches()) {
+      throw new ParserException("Expected WEBVTT. Got " + line);
+    }
+  }
+
+  /**
+   * Reads lines up to and including the next WebVTT cue header.
+   *
+   * @param input The input from which lines should be read.
+   * @throws IOException If an error occurs reading from the input.
+   * @return A {@link Matcher} for the WebVTT cue header, or null if the end of the input was
+   *     reached without a cue header being found. In the case that a cue header is found, groups 1,
+   *     2 and 3 of the returned matcher contain the start time, end time and settings list.
+   */
+  public static Matcher findNextCueHeader(BufferedReader input) throws IOException {
+    String line;
+    while ((line = input.readLine()) != null) {
+      if (COMMENT.matcher(line).matches()) {
+        // Skip until the end of the comment block.
+        while ((line = input.readLine()) != null && !line.isEmpty()) {}
+      } else {
+        Matcher cueHeaderMatcher = CUE_HEADER.matcher(line);
+        if (cueHeaderMatcher.matches()) {
+          return cueHeaderMatcher;
+        }
+      }
+    }
+    return null;
+  }
+
+  /**
+   * Parses a WebVTT timestamp.
+   *
+   * @param timestamp The timestamp string.
+   * @return The parsed timestamp in microseconds.
+   * @throws NumberFormatException If the timestamp could not be parsed.
+   */
+  public static long parseTimestampUs(String timestamp) throws NumberFormatException {
+    long value = 0;
+    String[] parts = timestamp.split("\\.", 2);
+    String[] subparts = parts[0].split(":");
+    for (int i = 0; i < subparts.length; i++) {
+      value = value * 60 + Long.parseLong(subparts[i]);
+    }
+    return (value * 1000 + Long.parseLong(parts[1])) * 1000;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttSubtitle.java b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttSubtitle.java
index 1f78a82a7e..309ca1d535 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttSubtitle.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttSubtitle.java
@@ -56,7 +56,6 @@ public WebvttSubtitle(List<WebvttCue> cues) {
 
   @Override
   public int getNextEventTimeIndex(long timeUs) {
-    Assertions.checkArgument(timeUs >= 0);
     int index = Util.binarySearchCeil(sortedCueTimesUs, timeUs, false, false);
     return index < sortedCueTimesUs.length ? index : -1;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultUriDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultUriDataSource.java
index 63f9023cc9..018e1a5823 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultUriDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultUriDataSource.java
@@ -16,9 +16,9 @@
 package com.google.android.exoplayer.upstream;
 
 import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.Util;
 
 import android.content.Context;
-import android.text.TextUtils;
 
 import java.io.IOException;
 
@@ -36,7 +36,6 @@
  */
 public final class DefaultUriDataSource implements UriDataSource {
 
-  private static final String SCHEME_FILE = "file";
   private static final String SCHEME_ASSET = "asset";
   private static final String SCHEME_CONTENT = "content";
 
@@ -119,7 +118,7 @@ public long open(DataSpec dataSpec) throws IOException {
     Assertions.checkState(dataSource == null);
     // Choose the correct source for the scheme.
     String scheme = dataSpec.uri.getScheme();
-    if (SCHEME_FILE.equals(scheme) || TextUtils.isEmpty(scheme)) {
+    if (Util.isLocalFileUri(dataSpec.uri)) {
       if (dataSpec.uri.getPath().startsWith("/android_asset/")) {
         dataSource = assetDataSource;
       } else {
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSource.java
index 63a3763133..fb638ea462 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSource.java
@@ -27,6 +27,7 @@
 import android.util.Log;
 
 import java.io.IOException;
+import java.io.InterruptedIOException;
 
 /**
  * A {@link DataSource} that reads and writes a {@link Cache}. Requests are fulfilled from the cache
@@ -182,46 +183,45 @@ public void close() throws IOException {
    * opened to read from the upstream source and write into the cache.
    */
   private void openNextSource() throws IOException {
-    try {
-      DataSpec dataSpec;
-      CacheSpan span;
-      if (ignoreCache) {
-        span = null;
-      } else if (bytesRemaining == C.LENGTH_UNBOUNDED) {
-        // TODO: Support caching for unbounded requests. This requires storing the source length
-        // into the cache (the simplest approach is to incorporate it into each cache file's name).
-        Log.w(TAG, "Cache bypassed due to unbounded length.");
-        span = null;
-      } else if (blockOnCache) {
+    DataSpec dataSpec;
+    CacheSpan span;
+    if (ignoreCache) {
+      span = null;
+    } else if (bytesRemaining == C.LENGTH_UNBOUNDED) {
+      // TODO: Support caching for unbounded requests. This requires storing the source length
+      // into the cache (the simplest approach is to incorporate it into each cache file's name).
+      Log.w(TAG, "Cache bypassed due to unbounded length.");
+      span = null;
+    } else if (blockOnCache) {
+      try {
         span = cache.startReadWrite(key, readPosition);
-      } else {
-        span = cache.startReadWriteNonBlocking(key, readPosition);
-      }
-      if (span == null) {
-        // The data is locked in the cache, or we're ignoring the cache. Bypass the cache and read
-        // from upstream.
-        currentDataSource = upstreamDataSource;
-        dataSpec = new DataSpec(uri, readPosition, bytesRemaining, key, flags);
-      } else if (span.isCached) {
-        // Data is cached, read from cache.
-        Uri fileUri = Uri.fromFile(span.file);
-        long filePosition = readPosition - span.position;
-        long length = Math.min(span.length - filePosition, bytesRemaining);
-        dataSpec = new DataSpec(fileUri, readPosition, filePosition, length, key, flags);
-        currentDataSource = cacheReadDataSource;
-      } else {
-        // Data is not cached, and data is not locked, read from upstream with cache backing.
-        lockedSpan = span;
-        long length = span.isOpenEnded() ? bytesRemaining : Math.min(span.length, bytesRemaining);
-        dataSpec = new DataSpec(uri, readPosition, length, key, flags);
-        currentDataSource = cacheWriteDataSource != null ? cacheWriteDataSource
-            : upstreamDataSource;
+      } catch (InterruptedException e) {
+        throw new InterruptedIOException();
       }
-      currentDataSource.open(dataSpec);
-    } catch (InterruptedException e) {
-      // Should never happen.
-      throw new RuntimeException(e);
+    } else {
+      span = cache.startReadWriteNonBlocking(key, readPosition);
+    }
+    if (span == null) {
+      // The data is locked in the cache, or we're ignoring the cache. Bypass the cache and read
+      // from upstream.
+      currentDataSource = upstreamDataSource;
+      dataSpec = new DataSpec(uri, readPosition, bytesRemaining, key, flags);
+    } else if (span.isCached) {
+      // Data is cached, read from cache.
+      Uri fileUri = Uri.fromFile(span.file);
+      long filePosition = readPosition - span.position;
+      long length = Math.min(span.length - filePosition, bytesRemaining);
+      dataSpec = new DataSpec(fileUri, readPosition, filePosition, length, key, flags);
+      currentDataSource = cacheReadDataSource;
+    } else {
+      // Data is not cached, and data is not locked, read from upstream with cache backing.
+      lockedSpan = span;
+      long length = span.isOpenEnded() ? bytesRemaining : Math.min(span.length, bytesRemaining);
+      dataSpec = new DataSpec(uri, readPosition, length, key, flags);
+      currentDataSource = cacheWriteDataSource != null ? cacheWriteDataSource
+          : upstreamDataSource;
     }
+    currentDataSource.open(dataSpec);
   }
 
   private void closeCurrentSource() throws IOException {
diff --git a/library/src/main/java/com/google/android/exoplayer/util/Ac3Util.java b/library/src/main/java/com/google/android/exoplayer/util/Ac3Util.java
index 6f1b6764aa..72062a51ac 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/Ac3Util.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/Ac3Util.java
@@ -17,42 +17,65 @@
 
 import com.google.android.exoplayer.MediaFormat;
 
+import java.nio.ByteBuffer;
+
 /**
- * Utility methods for parsing AC-3 headers.
+ * Utility methods for parsing (E-)AC-3 syncframes, which are access units in (E-)AC-3 bitstreams.
  */
 public final class Ac3Util {
 
-  /** Sample rates, indexed by fscod. */
-  private static final int[] SAMPLE_RATES = new int[] {48000, 44100, 32000};
-  /** Channel counts, indexed by acmod. */
-  private static final int[] CHANNEL_COUNTS = new int[] {2, 1, 2, 3, 3, 4, 4, 5};
-  /** Nominal bitrates in kbps, indexed by bit_rate_code. */
-  private static final int[] BITRATES = new int[] {32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192,
-      224, 256, 320, 384, 448, 512, 576, 640};
-  /** 16-bit words per sync frame, indexed by frmsizecod / 2. (See ETSI TS 102 366 table 4.13.) */
-  private static final int[] FRMSIZECOD_TO_FRAME_SIZE_44_1 = new int[] {69, 87, 104, 121, 139, 174,
-    208, 243, 278, 348, 417, 487, 557, 696, 835, 975, 1114, 1253, 1393};
+  /**
+   * The number of new samples per (E-)AC-3 audio block.
+   */
+  private static final int AUDIO_SAMPLES_PER_AUDIO_BLOCK = 256;
+  /**
+   * Each syncframe has 6 blocks that provide 256 new audio samples. See ETSI TS 102 366 4.1.
+   */
+  private static final int AC3_SYNCFRAME_AUDIO_SAMPLE_COUNT = 6 * AUDIO_SAMPLES_PER_AUDIO_BLOCK;
+  /**
+   * Number of audio blocks per E-AC-3 syncframe, indexed by numblkscod.
+   */
+  private static final int[] BLOCKS_PER_SYNCFRAME_BY_NUMBLKSCOD = new int[] {1, 2, 3, 6};
+  /**
+   * Sample rates, indexed by fscod.
+   */
+  private static final int[] SAMPLE_RATE_BY_FSCOD = new int[] {48000, 44100, 32000};
+  /**
+   * Sample rates, indexed by fscod2 (E-AC-3).
+   */
+  private static final int[] SAMPLE_RATE_BY_FSCOD2 = new int[] {24000, 22050, 16000};
+  /**
+   * Channel counts, indexed by acmod.
+   */
+  private static final int[] CHANNEL_COUNT_BY_ACMOD = new int[] {2, 1, 2, 3, 3, 4, 4, 5};
+  /**
+   * Nominal bitrates in kbps, indexed by frmsizecod / 2. (See ETSI TS 102 366 table 4.13.)
+   */
+  private static final int[] BITRATE_BY_HALF_FRMSIZECOD = new int[] {32, 40, 48, 56, 64, 80, 96,
+      112, 128, 160, 192, 224, 256, 320, 384, 448, 512, 576, 640};
+  /**
+   * 16-bit words per syncframe, indexed by frmsizecod / 2. (See ETSI TS 102 366 table 4.13.)
+   */
+  private static final int[] SYNCFRAME_SIZE_WORDS_BY_HALF_FRMSIZECOD_44_1 = new int[] {69, 87, 104,
+      121, 139, 174, 208, 243, 278, 348, 417, 487, 557, 696, 835, 975, 1114, 1253, 1393};
 
   /**
    * Returns the AC-3 format given {@code data} containing the AC3SpecificBox according to
-   * ETSI TS 102 366 Annex F.
+   * ETSI TS 102 366 Annex F. The reading position of {@code data} will be modified.
    *
-   * @param data The AC3SpecificBox.
-   * @param trackId The identifier for the track in its container, or {@link MediaFormat#NO_VALUE}.
+   * @param data The AC3SpecificBox to parse.
+   * @param trackId The track identifier to set on the format, or null.
    * @param durationUs The duration to set on the format, in microseconds.
    * @param language The language to set on the format.
    * @return The AC-3 format parsed from data in the header.
    */
-  public static MediaFormat parseAnnexFAc3Format(ParsableByteArray data, int trackId,
+  public static MediaFormat parseAc3AnnexFFormat(ParsableByteArray data, String trackId,
       long durationUs, String language) {
-    // fscod (sample rate code)
     int fscod = (data.readUnsignedByte() & 0xC0) >> 6;
-    int sampleRate = SAMPLE_RATES[fscod];
+    int sampleRate = SAMPLE_RATE_BY_FSCOD[fscod];
     int nextByte = data.readUnsignedByte();
-    // Map acmod (audio coding mode) onto a channel count.
-    int channelCount = CHANNEL_COUNTS[(nextByte & 0x38) >> 3];
-    // lfeon (low frequency effects on)
-    if ((nextByte & 0x04) != 0) {
+    int channelCount = CHANNEL_COUNT_BY_ACMOD[(nextByte & 0x38) >> 3];
+    if ((nextByte & 0x04) != 0) { // lfeon
       channelCount++;
     }
     return MediaFormat.createAudioFormat(trackId, MimeTypes.AUDIO_AC3, MediaFormat.NO_VALUE,
@@ -61,51 +84,46 @@ public static MediaFormat parseAnnexFAc3Format(ParsableByteArray data, int track
 
   /**
    * Returns the E-AC-3 format given {@code data} containing the EC3SpecificBox according to
-   * ETSI TS 102 366 Annex F.
+   * ETSI TS 102 366 Annex F. The reading position of {@code data} will be modified.
    *
-   * @param data The EC3SpecificBox.
-   * @param trackId The identifier for the track in its container, or {@link MediaFormat#NO_VALUE}.
+   * @param data The EC3SpecificBox to parse.
+   * @param trackId The track identifier to set on the format, or null.
    * @param durationUs The duration to set on the format, in microseconds.
    * @param language The language to set on the format.
    * @return The E-AC-3 format parsed from data in the header.
    */
-  public static MediaFormat parseAnnexFEAc3Format(ParsableByteArray data, int trackId,
+  public static MediaFormat parseEAc3AnnexFFormat(ParsableByteArray data, String trackId,
       long durationUs, String language) {
-    data.skipBytes(2); // Skip data_rate and num_ind_sub.
+    data.skipBytes(2); // data_rate, num_ind_sub
 
     // Read only the first substream.
     // TODO: Read later substreams?
-    // fscod (sample rate code)
     int fscod = (data.readUnsignedByte() & 0xC0) >> 6;
-    int sampleRate = SAMPLE_RATES[fscod];
+    int sampleRate = SAMPLE_RATE_BY_FSCOD[fscod];
     int nextByte = data.readUnsignedByte();
-    // Map acmod (audio coding mode) onto a channel count.
-    int channelCount = CHANNEL_COUNTS[(nextByte & 0x0E) >> 1];
-    // lfeon (low frequency effects on)
-    if ((nextByte & 0x01) != 0) {
+    int channelCount = CHANNEL_COUNT_BY_ACMOD[(nextByte & 0x0E) >> 1];
+    if ((nextByte & 0x01) != 0) { // lfeon
       channelCount++;
     }
-    return MediaFormat.createAudioFormat(trackId, MimeTypes.AUDIO_EC3, MediaFormat.NO_VALUE,
+    return MediaFormat.createAudioFormat(trackId, MimeTypes.AUDIO_E_AC3, MediaFormat.NO_VALUE,
         MediaFormat.NO_VALUE, durationUs, channelCount, sampleRate, null, language);
   }
 
   /**
-   * Returns the AC-3 format given {@code data} containing the frame header starting from the sync
-   * word.
+   * Returns the AC-3 format given {@code data} containing a syncframe. The reading position of
+   * {@code data} will be modified.
    *
-   * @param data Data to parse, positioned at the start of the syncword.
-   * @param trackId The identifier for the track in its container, or {@link MediaFormat#NO_VALUE}.
+   * @param data The data to parse, positioned at the start of the syncframe.
+   * @param trackId The track identifier to set on the format, or null.
    * @param durationUs The duration to set on the format, in microseconds.
    * @param language The language to set on the format.
    * @return The AC-3 format parsed from data in the header.
    */
-  public static MediaFormat parseFrameAc3Format(ParsableBitArray data, int trackId, long durationUs,
-      String language) {
-    // Skip syncword and crc1.
-    data.skipBits(4 * 8);
-
+  public static MediaFormat parseAc3SyncframeFormat(ParsableBitArray data, String trackId,
+      long durationUs, String language) {
+    data.skipBits(16 + 16); // syncword, crc1
     int fscod = data.readBits(2);
-    data.skipBits(14); // frmsizecod(6) + bsid (5 bits) + bsmod (3 bits)
+    data.skipBits(6 + 5 + 3); // frmsizecod, bsid, bsmod
     int acmod = data.readBits(3);
     if ((acmod & 0x01) != 0 && acmod != 1) {
       data.skipBits(2); // cmixlev
@@ -113,52 +131,108 @@ public static MediaFormat parseFrameAc3Format(ParsableBitArray data, int trackId
     if ((acmod & 0x04) != 0) {
       data.skipBits(2); // surmixlev
     }
-    if (acmod == 0x02) {
+    if (acmod == 2) {
       data.skipBits(2); // dsurmod
     }
     boolean lfeon = data.readBit();
     return MediaFormat.createAudioFormat(trackId, MimeTypes.AUDIO_AC3, MediaFormat.NO_VALUE,
-        MediaFormat.NO_VALUE, durationUs, CHANNEL_COUNTS[acmod] + (lfeon ? 1 : 0),
-        SAMPLE_RATES[fscod], null, language);
+        MediaFormat.NO_VALUE, durationUs, CHANNEL_COUNT_BY_ACMOD[acmod] + (lfeon ? 1 : 0),
+        SAMPLE_RATE_BY_FSCOD[fscod], null, language);
   }
 
   /**
-   * Returns the AC-3 frame size in bytes given {@code data} containing the frame header starting
-   * from the sync word.
+   * Returns the E-AC-3 format given {@code data} containing a syncframe. The reading position of
+   * {@code data} will be modified.
    *
-   * @param data Data to parse, positioned at the start of the syncword.
-   * @return The frame size parsed from data in the header.
+   * @param data The data to parse, positioned at the start of the syncframe.
+   * @param trackId The track identifier to set on the format, or null.
+   * @param durationUs The duration to set on the format, in microseconds.
+   * @param language The language to set on the format.
+   * @return The E-AC-3 format parsed from data in the header.
    */
-  public static int parseFrameSize(ParsableBitArray data) {
-    // Skip syncword and crc1.
-    data.skipBits(4 * 8);
-
+  public static MediaFormat parseEac3SyncframeFormat(ParsableBitArray data, String trackId,
+      long durationUs, String language) {
+    data.skipBits(16 + 2 + 11); // syncword, strmtype, frmsiz
+    int sampleRate;
     int fscod = data.readBits(2);
-    int frmsizecod = data.readBits(6);
-    int sampleRate = SAMPLE_RATES[fscod];
-    int bitrate = BITRATES[frmsizecod / 2];
-    if (sampleRate == 32000) {
-      return 6 * bitrate;
-    } else if (sampleRate == 44100) {
-      return 2 * (FRMSIZECOD_TO_FRAME_SIZE_44_1[frmsizecod / 2] + (frmsizecod % 2));
-    } else { // sampleRate == 48000
-      return 4 * bitrate;
+    if (fscod == 3) {
+      sampleRate = SAMPLE_RATE_BY_FSCOD2[data.readBits(2)];
+    } else {
+      data.skipBits(2); // numblkscod
+      sampleRate = SAMPLE_RATE_BY_FSCOD[fscod];
     }
+    int acmod = data.readBits(3);
+    boolean lfeon = data.readBit();
+    return MediaFormat.createAudioFormat(trackId, MimeTypes.AUDIO_E_AC3, MediaFormat.NO_VALUE,
+        MediaFormat.NO_VALUE, durationUs, CHANNEL_COUNT_BY_ACMOD[acmod] + (lfeon ? 1 : 0),
+        sampleRate, null, language);
+  }
+
+  /**
+   * Returns the size in bytes of the given AC-3 syncframe.
+   *
+   * @param data The syncframe to parse.
+   * @return The syncframe size in bytes.
+   */
+  public static int parseAc3SyncframeSize(byte[] data) {
+    int fscod = (data[4] & 0xC0) >> 6;
+    int frmsizecod = data[4] & 0x3F;
+    return getAc3SyncframeSize(fscod, frmsizecod);
+  }
+
+  /**
+   * Returns the size in bytes of the given E-AC-3 syncframe.
+   *
+   * @param data The syncframe to parse.
+   * @return The syncframe size in bytes.
+   */
+  public static int parseEAc3SyncframeSize(byte[] data) {
+    return 2 * (((data[2] & 0x07) << 8) + (data[3] & 0xFF) + 1); // frmsiz
+  }
+
+  /**
+   * Returns the number of audio samples in an AC-3 syncframe.
+   */
+  public static int getAc3SyncframeAudioSampleCount() {
+    return AC3_SYNCFRAME_AUDIO_SAMPLE_COUNT;
   }
 
   /**
-   * Returns the bitrate of AC-3 audio given the size of a buffer and the sample rate.
+   * Returns the number of audio samples represented by the given E-AC-3 syncframe.
    *
-   * @param bufferSize Size in bytes of a full buffer of samples.
-   * @param sampleRate Sample rate in hz.
-   * @return Bitrate of the audio stream in kbit/s.
-   */
-  public static int getBitrate(int bufferSize, int sampleRate) {
-    // Each AC-3 buffer contains 1536 frames of audio, so the AudioTrack playback position
-    // advances by 1536 per buffer (32 ms at 48 kHz).
-    int unscaledBitrate = bufferSize * 8 * sampleRate;
-    int divisor = 1000 * 1536;
-    return (unscaledBitrate + divisor / 2) / divisor;
+   * @param data The syncframe to parse.
+   * @return The number of audio samples represented by the syncframe.
+   */
+  public static int parseEAc3SyncframeAudioSampleCount(byte[] data) {
+    // See ETSI TS 102 366 subsection E.1.2.2.
+    return AUDIO_SAMPLES_PER_AUDIO_BLOCK * (((data[4] & 0xC0) >> 6) == 0x03 ? 6 // fscod
+        : BLOCKS_PER_SYNCFRAME_BY_NUMBLKSCOD[(data[4] & 0x30) >> 4]);
+  }
+
+  /**
+   * Like {@link #parseEAc3SyncframeAudioSampleCount(byte[])} but reads from a byte buffer. The
+   * buffer position is not modified.
+   *
+   * @see #parseEAc3SyncframeAudioSampleCount(byte[])
+   */
+  public static int parseEAc3SyncframeAudioSampleCount(ByteBuffer buffer) {
+    // See ETSI TS 102 366 subsection E.1.2.2.
+    int fscod = (buffer.get(buffer.position() + 4) & 0xC0) >> 6;
+    return AUDIO_SAMPLES_PER_AUDIO_BLOCK * (fscod == 0x03 ? 6
+        : BLOCKS_PER_SYNCFRAME_BY_NUMBLKSCOD[(buffer.get(buffer.position() + 4) & 0x30) >> 4]);
+  }
+
+  private static int getAc3SyncframeSize(int fscod, int frmsizecod) {
+    int sampleRate = SAMPLE_RATE_BY_FSCOD[fscod];
+    if (sampleRate == 44100) {
+      return 2 * (SYNCFRAME_SIZE_WORDS_BY_HALF_FRMSIZECOD_44_1[frmsizecod / 2] + (frmsizecod % 2));
+    }
+    int bitrate = BITRATE_BY_HALF_FRMSIZECOD[frmsizecod / 2];
+    if (sampleRate == 32000) {
+      return 6 * bitrate;
+    } else { // sampleRate == 48000
+      return 4 * bitrate;
+    }
   }
 
   private Ac3Util() {
diff --git a/library/src/main/java/com/google/android/exoplayer/util/CodecSpecificDataUtil.java b/library/src/main/java/com/google/android/exoplayer/util/CodecSpecificDataUtil.java
index 1ec1cbf9d1..70a80d7b11 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/CodecSpecificDataUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/CodecSpecificDataUtil.java
@@ -45,13 +45,54 @@ public SpsData(int width, int height, float pixelWidthAspectRatio) {
 
   private static final byte[] NAL_START_CODE = new byte[] {0, 0, 0, 1};
 
+  private static final int AUDIO_SPECIFIC_CONFIG_FREQUENCY_INDEX_ARBITRARY = 0xF;
+
   private static final int[] AUDIO_SPECIFIC_CONFIG_SAMPLING_RATE_TABLE = new int[] {
     96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350
   };
 
-  private static final int[] AUDIO_SPECIFIC_CONFIG_CHANNEL_COUNT_TABLE = new int[] {
-    0, 1, 2, 3, 4, 5, 6, 8
-  };
+  private static final int AUDIO_SPECIFIC_CONFIG_CHANNEL_CONFIGURATION_INVALID = -1;
+  /**
+   * In the channel configurations below, <A> indicates a single channel element; (A, B) indicates a
+   * channel pair element; and [A] indicates a low-frequency effects element.
+   * The speaker mapping short forms used are:
+   * - FC: front center
+   * - BC: back center
+   * - FL/FR: front left/right
+   * - FCL/FCR: front center left/right
+   * - FTL/FTR: front top left/right
+   * - SL/SR: back surround left/right
+   * - BL/BR: back left/right
+   * - LFE: low frequency effects
+   */
+  private static final int[] AUDIO_SPECIFIC_CONFIG_CHANNEL_COUNT_TABLE =
+      new int[] {
+        0,
+        1, /* mono: <FC> */
+        2, /* stereo: (FL, FR) */
+        3, /* 3.0: <FC>, (FL, FR) */
+        4, /* 4.0: <FC>, (FL, FR), <BC> */
+        5, /* 5.0 back: <FC>, (FL, FR), (SL, SR) */
+        6, /* 5.1 back: <FC>, (FL, FR), (SL, SR), <BC>, [LFE] */
+        8, /* 7.1 wide back: <FC>, (FCL, FCR), (FL, FR), (SL, SR), [LFE] */
+        AUDIO_SPECIFIC_CONFIG_CHANNEL_CONFIGURATION_INVALID,
+        AUDIO_SPECIFIC_CONFIG_CHANNEL_CONFIGURATION_INVALID,
+        AUDIO_SPECIFIC_CONFIG_CHANNEL_CONFIGURATION_INVALID,
+        7, /* 6.1: <FC>, (FL, FR), (SL, SR), <RC>, [LFE] */
+        8, /* 7.1: <FC>, (FL, FR), (SL, SR), (BL, BR), [LFE] */
+        AUDIO_SPECIFIC_CONFIG_CHANNEL_CONFIGURATION_INVALID,
+        8, /* 7.1 top: <FC>, (FL, FR), (SL, SR), [LFE], (FTL, FTR) */
+        AUDIO_SPECIFIC_CONFIG_CHANNEL_CONFIGURATION_INVALID
+      };
+
+  // Advanced Audio Coding Low-Complexity profile.
+  private static final int AUDIO_OBJECT_TYPE_AAC_LC = 2;
+  // Spectral Band Replication.
+  private static final int AUDIO_OBJECT_TYPE_SBR = 5;
+  // Error Resilient Bit-Sliced Arithmetic Coding.
+  private static final int AUDIO_OBJECT_TYPE_ER_BSAC = 22;
+  // Parametric Stereo.
+  private static final int AUDIO_OBJECT_TYPE_PS = 29;
 
   private static final String TAG = "CodecSpecificDataUtil";
 
@@ -64,13 +105,38 @@ private CodecSpecificDataUtil() {}
    * @return A pair consisting of the sample rate in Hz and the channel count.
    */
   public static Pair<Integer, Integer> parseAacAudioSpecificConfig(byte[] audioSpecificConfig) {
-    int audioObjectType = (audioSpecificConfig[0] >> 3) & 0x1F;
-    int byteOffset = audioObjectType == 5 || audioObjectType == 29 ? 1 : 0;
-    int frequencyIndex = (audioSpecificConfig[byteOffset] & 0x7) << 1
-        | ((audioSpecificConfig[byteOffset + 1] >> 7) & 0x1);
-    Assertions.checkState(frequencyIndex < 13);
-    int sampleRate = AUDIO_SPECIFIC_CONFIG_SAMPLING_RATE_TABLE[frequencyIndex];
-    int channelCount = (audioSpecificConfig[byteOffset + 1] >> 3) & 0xF;
+    ParsableBitArray bitArray = new ParsableBitArray(audioSpecificConfig);
+    int audioObjectType = bitArray.readBits(5);
+    int frequencyIndex = bitArray.readBits(4);
+    int sampleRate;
+    if (frequencyIndex == AUDIO_SPECIFIC_CONFIG_FREQUENCY_INDEX_ARBITRARY) {
+      sampleRate = bitArray.readBits(24);
+    } else {
+      Assertions.checkArgument(frequencyIndex < 13);
+      sampleRate = AUDIO_SPECIFIC_CONFIG_SAMPLING_RATE_TABLE[frequencyIndex];
+    }
+    int channelConfiguration = bitArray.readBits(4);
+    if (audioObjectType == AUDIO_OBJECT_TYPE_SBR || audioObjectType == AUDIO_OBJECT_TYPE_PS) {
+      // For an AAC bitstream using spectral band replication (SBR) or parametric stereo (PS) with
+      // explicit signaling, we return the extension sampling frequency as the sample rate of the
+      // content; this is identical to the sample rate of the decoded output but may differ from
+      // the sample rate set above.
+      // Use the extensionSamplingFrequencyIndex.
+      frequencyIndex = bitArray.readBits(4);
+      if (frequencyIndex == AUDIO_SPECIFIC_CONFIG_FREQUENCY_INDEX_ARBITRARY) {
+        sampleRate = bitArray.readBits(24);
+      } else {
+        Assertions.checkArgument(frequencyIndex < 13);
+        sampleRate = AUDIO_SPECIFIC_CONFIG_SAMPLING_RATE_TABLE[frequencyIndex];
+      }
+      audioObjectType = bitArray.readBits(5);
+      if (audioObjectType == AUDIO_OBJECT_TYPE_ER_BSAC) {
+        // Use the extensionChannelConfiguration.
+        channelConfiguration = bitArray.readBits(4);
+      }
+    }
+    int channelCount = AUDIO_SPECIFIC_CONFIG_CHANNEL_COUNT_TABLE[channelConfiguration];
+    Assertions.checkArgument(channelCount != AUDIO_SPECIFIC_CONFIG_CHANNEL_CONFIGURATION_INVALID);
     return Pair.create(sampleRate, channelCount);
   }
 
@@ -112,7 +178,7 @@ private CodecSpecificDataUtil() {}
     }
     // The full specification for AudioSpecificConfig is stated in ISO 14496-3 Section 1.6.2.1
     byte[] csd = new byte[2];
-    csd[0] = (byte) ((2 /* AAC LC */ << 3) | (sampleRateIndex >> 1));
+    csd[0] = (byte) ((AUDIO_OBJECT_TYPE_AAC_LC << 3) | (sampleRateIndex >> 1));
     csd[1] = (byte) (((sampleRateIndex & 0x1) << 7) | (channelConfig << 3));
     return csd;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ManifestFetcher.java b/library/src/main/java/com/google/android/exoplayer/util/ManifestFetcher.java
index d50b5be27f..c34e0c4f8e 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/ManifestFetcher.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/ManifestFetcher.java
@@ -48,6 +48,14 @@
  */
 public class ManifestFetcher<T> implements Loader.Callback {
 
+  /**
+   * Thrown when an error occurs trying to fetch a manifest.
+   */
+  public static final class ManifestIOException extends IOException{
+    public ManifestIOException(Throwable cause) { super(cause); }
+
+  }
+
   /**
    * Interface definition for a callback to be notified of {@link ManifestFetcher} events.
    */
@@ -112,7 +120,7 @@
 
   private int loadExceptionCount;
   private long loadExceptionTimestamp;
-  private IOException loadException;
+  private ManifestIOException loadException;
 
   private volatile T manifest;
   private volatile long manifestLoadStartTimestamp;
@@ -201,9 +209,10 @@ public long getManifestLoadCompleteTimestamp() {
    * Throws the error that affected the most recent attempt to load the manifest. Does nothing if
    * the most recent attempt was successful.
    *
-   * @throws IOException The error that affected the most recent attempt to load the manifest.
+   * @throws ManifestIOException The error that affected the most recent attempt to load the
+   *     manifest.
    */
-  public void maybeThrowError() throws IOException {
+  public void maybeThrowError() throws ManifestIOException {
     // Don't throw an exception until at least 1 retry attempt has been made.
     if (loadException == null || loadExceptionCount <= 1) {
       return;
@@ -291,7 +300,7 @@ public void onLoadError(Loadable loadable, IOException exception) {
 
     loadExceptionCount++;
     loadExceptionTimestamp = SystemClock.elapsedRealtime();
-    loadException = new IOException(exception);
+    loadException = new ManifestIOException(exception);
 
     notifyManifestError(loadException);
   }
@@ -376,7 +385,7 @@ public void onLoadCompleted(Loadable loadable) {
     public void onLoadCanceled(Loadable loadable) {
       // This shouldn't ever happen, but handle it anyway.
       try {
-        IOException exception = new IOException("Load cancelled", new CancellationException());
+        IOException exception = new ManifestIOException(new CancellationException());
         wrappedCallback.onSingleManifestError(exception);
       } finally {
         releaseLoader();
diff --git a/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java b/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
index 15cf132217..0f27a5b9ff 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
@@ -45,13 +45,16 @@
   public static final String AUDIO_MPEG_L2 = BASE_TYPE_AUDIO + "/mpeg-L2";
   public static final String AUDIO_RAW = BASE_TYPE_AUDIO + "/raw";
   public static final String AUDIO_AC3 = BASE_TYPE_AUDIO + "/ac3";
-  public static final String AUDIO_EC3 = BASE_TYPE_AUDIO + "/eac3";
+  public static final String AUDIO_E_AC3 = BASE_TYPE_AUDIO + "/eac3";
   public static final String AUDIO_TRUEHD = BASE_TYPE_AUDIO + "/true-hd";
   public static final String AUDIO_DTS = BASE_TYPE_AUDIO + "/vnd.dts";
   public static final String AUDIO_DTS_HD = BASE_TYPE_AUDIO + "/vnd.dts.hd";
   public static final String AUDIO_VORBIS = BASE_TYPE_AUDIO + "/vorbis";
   public static final String AUDIO_OPUS = BASE_TYPE_AUDIO + "/opus";
+  public static final String AUDIO_AMR_NB = BASE_TYPE_AUDIO + "/3gpp";
+  public static final String AUDIO_AMR_WB = BASE_TYPE_AUDIO + "/amr-wb";
 
+  public static final String TEXT_UNKNOWN = BASE_TYPE_TEXT + "/x-unknown";
   public static final String TEXT_VTT = BASE_TYPE_TEXT + "/vtt";
 
   public static final String APPLICATION_MP4 = BASE_TYPE_APPLICATION + "/mp4";
@@ -119,4 +122,62 @@ private static String getTopLevelType(String mimeType) {
     return mimeType.substring(0, indexOfSlash);
   }
 
+  /**
+   * Returns the video mimeType type of {@code codecs}.
+   *
+   * @param codecs The codecs for which the video mimeType is required.
+   * @return The video mimeType.
+   */
+  public static String getVideoMediaMimeType(String codecs) {
+    if (codecs == null) {
+      return MimeTypes.VIDEO_UNKNOWN;
+    }
+    String[] codecList = codecs.split(",");
+    for (String codec : codecList) {
+      codec = codec.trim();
+      if (codec.startsWith("avc1") || codec.startsWith("avc3")) {
+        return MimeTypes.VIDEO_H264;
+      } else if (codec.startsWith("hev1") || codec.startsWith("hvc1")) {
+        return MimeTypes.VIDEO_H265;
+      } else if (codec.startsWith("vp9")) {
+        return MimeTypes.VIDEO_VP9;
+      } else if (codec.startsWith("vp8")) {
+        return MimeTypes.VIDEO_VP8;
+      }
+    }
+    return MimeTypes.VIDEO_UNKNOWN;
+  }
+
+  /**
+   * Returns the audio mimeType type of {@code codecs}.
+   *
+   * @param codecs The codecs for which the audio mimeType is required.
+   * @return The audio mimeType.
+   */
+  public static String getAudioMediaMimeType(String codecs) {
+    if (codecs == null) {
+      return MimeTypes.AUDIO_UNKNOWN;
+    }
+    String[] codecList = codecs.split(",");
+    for (String codec : codecList) {
+      codec = codec.trim();
+      if (codec.startsWith("mp4a")) {
+        return MimeTypes.AUDIO_AAC;
+      } else if (codec.startsWith("ac-3") || codec.startsWith("dac3")) {
+        return MimeTypes.AUDIO_AC3;
+      } else if (codec.startsWith("ec-3") || codec.startsWith("dec3")) {
+        return MimeTypes.AUDIO_E_AC3;
+      } else if (codec.startsWith("dtsc") || codec.startsWith("dtse")) {
+        return MimeTypes.AUDIO_DTS;
+      } else if (codec.startsWith("dtsh") || codec.startsWith("dtsl")) {
+        return MimeTypes.AUDIO_DTS_HD;
+      } else if (codec.startsWith("opus")) {
+        return MimeTypes.AUDIO_OPUS;
+      } else if (codec.startsWith("vorbis")) {
+        return MimeTypes.AUDIO_VORBIS;
+      }
+    }
+    return MimeTypes.AUDIO_UNKNOWN;
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java b/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
index 563b9ebe13..4bc8313dfe 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
@@ -170,6 +170,12 @@ public int readUnsignedShort() {
         | (data[position++] & 0xFF);
   }
 
+  /** Reads the next two bytes as an signed value. */
+  public short readShort() {
+    return (short) ((data[position++] & 0xFF) << 8
+        | (data[position++] & 0xFF));
+  }
+
   /** Reads the next three bytes as an unsigned value. */
   public int readUnsignedInt24() {
     return (data[position++] & 0xFF) << 16
diff --git a/library/src/main/java/com/google/android/exoplayer/util/Util.java b/library/src/main/java/com/google/android/exoplayer/util/Util.java
index 8bd876a73f..ae9db72916 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/Util.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/Util.java
@@ -25,6 +25,7 @@
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
+import android.net.Uri;
 import android.os.Build;
 import android.text.TextUtils;
 
@@ -106,12 +107,13 @@ public static boolean isAndroidTv(Context context) {
   }
 
   /**
-   * Returns true if the URL points to a file on the local device
+   * Returns true if the URI is a path to a local file or a reference to a local file.
    *
-   * @param url The URL to test
+   * @param uri The uri to test.
    */
-  public static boolean isUrlLocalFile(URL url) {
-    return url.getProtocol().equals("file");
+  public static boolean isLocalFileUri(Uri uri) {
+    String scheme = uri.getScheme();
+    return TextUtils.isEmpty(scheme) || scheme.equals("file");
   }
 
   /**
diff --git a/library/src/main/project.properties b/library/src/main/project.properties
index 95228a4fc6..1614ebb94a 100644
--- a/library/src/main/project.properties
+++ b/library/src/main/project.properties
@@ -8,5 +8,5 @@
 # project structure.
 
 # Project target.
-target=android-22
+target=android-23
 android.library=true
diff --git a/playbacktests/build.gradle b/playbacktests/build.gradle
index 5a95cfff41..ff294ad0b5 100644
--- a/playbacktests/build.gradle
+++ b/playbacktests/build.gradle
@@ -14,12 +14,12 @@
 apply plugin: 'com.android.application'
 
 android {
-    compileSdkVersion 22
-    buildToolsVersion "22.0.1"
+    compileSdkVersion 23
+    buildToolsVersion "23.0.1"
 
     defaultConfig {
         minSdkVersion 16
-        targetSdkVersion 22
+        targetSdkVersion 23
     }
     buildTypes {
         release {
diff --git a/playbacktests/src/main/AndroidManifest.xml b/playbacktests/src/main/AndroidManifest.xml
index ee8184da6d..0d88e48c57 100644
--- a/playbacktests/src/main/AndroidManifest.xml
+++ b/playbacktests/src/main/AndroidManifest.xml
@@ -17,13 +17,13 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer.playbacktests"
-    android:versionCode="1502"
-    android:versionName="1.5.2">
+    android:versionCode="1503"
+    android:versionName="1.5.3">
 
   <uses-permission android:name="android.permission.INTERNET"/>
   <uses-permission android:name="android.permission.WAKE_LOCK"/>
 
-  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="22"/>
+  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="23"/>
 
   <application android:debuggable="true"
       android:allowBackup="false"
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java
new file mode 100644
index 0000000000..36766ce130
--- /dev/null
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java
@@ -0,0 +1,468 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.playbacktests.gts;
+
+import com.google.android.exoplayer.CodecCounters;
+import com.google.android.exoplayer.DefaultLoadControl;
+import com.google.android.exoplayer.ExoPlayer;
+import com.google.android.exoplayer.LoadControl;
+import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
+import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
+import com.google.android.exoplayer.TrackRenderer;
+import com.google.android.exoplayer.chunk.ChunkSampleSource;
+import com.google.android.exoplayer.chunk.ChunkSource;
+import com.google.android.exoplayer.chunk.FormatEvaluator;
+import com.google.android.exoplayer.chunk.VideoFormatSelectorUtil;
+import com.google.android.exoplayer.dash.DashChunkSource;
+import com.google.android.exoplayer.dash.DashTrackSelector;
+import com.google.android.exoplayer.dash.mpd.AdaptationSet;
+import com.google.android.exoplayer.dash.mpd.MediaPresentationDescription;
+import com.google.android.exoplayer.dash.mpd.MediaPresentationDescriptionParser;
+import com.google.android.exoplayer.dash.mpd.Period;
+import com.google.android.exoplayer.dash.mpd.Representation;
+import com.google.android.exoplayer.playbacktests.util.ActionSchedule;
+import com.google.android.exoplayer.playbacktests.util.CodecCountersUtil;
+import com.google.android.exoplayer.playbacktests.util.ExoHostedTest;
+import com.google.android.exoplayer.playbacktests.util.HostActivity;
+import com.google.android.exoplayer.playbacktests.util.LogcatLogger;
+import com.google.android.exoplayer.playbacktests.util.TestUtil;
+import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.upstream.DefaultAllocator;
+import com.google.android.exoplayer.upstream.DefaultUriDataSource;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.Util;
+
+import android.annotation.TargetApi;
+import android.media.MediaCodec;
+import android.os.Handler;
+import android.test.ActivityInstrumentationTestCase2;
+import android.util.Log;
+import android.view.Surface;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Tests DASH playbacks using {@link ExoPlayer}.
+ */
+public final class DashTest extends ActivityInstrumentationTestCase2<HostActivity> {
+
+  private static final String TAG = "DashTest";
+
+  private static final long MAX_PLAYING_TIME_DISCREPANCY_MS = 2000;
+  private static final float MAX_DROPPED_VIDEO_FRAME_FRACTION = 0.01f;
+  private static final int MAX_CONSECUTIVE_DROPPED_VIDEO_FRAMES = 10;
+
+  private static final long MAX_ADDITIONAL_TIME_MS = 180000;
+  private static final int MIN_LOADABLE_RETRY_COUNT = 10;
+
+  private static final String MANIFEST_URL_PREFIX = "https://storage.googleapis.com/exoplayer-test-"
+      + "media-1/gen-2/screens/dash-vod-single-segment/";
+  private static final String H264_MANIFEST = "manifest-h264.mpd";
+  private static final String VP9_MANIFEST = "manifest-vp9.mpd";
+  private static final int AAC_AUDIO_FRAME_COUNT = 5524;
+  private static final int H264_VIDEO_FRAME_COUNT = 3841;
+  private static final int VORBIS_AUDIO_FRAME_COUNT = 7773;
+  private static final int VP9_VIDEO_FRAME_COUNT = 3841;
+
+  private static final String AAC_AUDIO_REPRESENTATION_ID = "141";
+  private static final String H264_BASELINE_240P_VIDEO_REPRESENTATION_ID = "avc-baseline-240";
+  private static final String H264_BASELINE_480P_VIDEO_REPRESENTATION_ID = "avc-baseline-480";
+  private static final String H264_MAIN_240P_VIDEO_REPRESENTATION_ID = "avc-main-240";
+  private static final String H264_MAIN_480P_VIDEO_REPRESENTATION_ID = "avc-main-480";
+  // The highest quality H264 format mandated by the Android CDD.
+  private static final String H264_CDD_FIXED = Util.SDK_INT < 23
+      ? H264_BASELINE_480P_VIDEO_REPRESENTATION_ID : H264_MAIN_480P_VIDEO_REPRESENTATION_ID;
+  // Multiple H264 formats mandated by the Android CDD.
+  private static final String[] H264_CDD_ADAPTIVE = Util.SDK_INT < 23
+      ? new String[] {
+          H264_BASELINE_240P_VIDEO_REPRESENTATION_ID,
+          H264_BASELINE_480P_VIDEO_REPRESENTATION_ID}
+      : new String[] {
+          H264_BASELINE_240P_VIDEO_REPRESENTATION_ID,
+          H264_BASELINE_480P_VIDEO_REPRESENTATION_ID,
+          H264_MAIN_240P_VIDEO_REPRESENTATION_ID,
+          H264_MAIN_480P_VIDEO_REPRESENTATION_ID};
+
+  private static final String VORBIS_AUDIO_REPRESENTATION_ID = "2";
+  private static final String VP9_180P_VIDEO_REPRESENTATION_ID = "0";
+  private static final String VP9_360P_VIDEO_REPRESENTATION_ID = "1";
+
+  // Whether adaptive tests should enable video formats beyond those mandated by the Android CDD
+  // if the device advertises support for them.
+  private static final boolean ALLOW_ADDITIONAL_VIDEO_FORMATS = Util.SDK_INT >= 21;
+
+  private static final ActionSchedule SEEKING_SCHEDULE = new ActionSchedule.Builder(TAG)
+      .delay(10000).seek(15000)
+      .delay(10000).seek(30000).seek(31000).seek(32000).seek(33000).seek(34000)
+      .delay(1000).pause().delay(1000).play()
+      .delay(1000).pause().seek(100000).delay(1000).play()
+      .build();
+  private static final ActionSchedule RENDERER_DISABLING_SCHEDULE = new ActionSchedule.Builder(TAG)
+      // Wait 10 seconds, disable the video renderer, wait another 5 seconds and enable it again.
+      .delay(10000).disableRenderer(DashHostedTest.VIDEO_RENDERER_INDEX)
+      .delay(10000).enableRenderer(DashHostedTest.VIDEO_RENDERER_INDEX)
+      // Ditto for the audio renderer.
+      .delay(10000).disableRenderer(DashHostedTest.AUDIO_RENDERER_INDEX)
+      .delay(10000).enableRenderer(DashHostedTest.AUDIO_RENDERER_INDEX)
+      // Wait 10 seconds, then disable and enable the video renderer 5 times in quick succession.
+      .delay(10000).disableRenderer(DashHostedTest.VIDEO_RENDERER_INDEX)
+          .enableRenderer(DashHostedTest.VIDEO_RENDERER_INDEX)
+          .disableRenderer(DashHostedTest.VIDEO_RENDERER_INDEX)
+          .enableRenderer(DashHostedTest.VIDEO_RENDERER_INDEX)
+          .disableRenderer(DashHostedTest.VIDEO_RENDERER_INDEX)
+          .enableRenderer(DashHostedTest.VIDEO_RENDERER_INDEX)
+          .disableRenderer(DashHostedTest.VIDEO_RENDERER_INDEX)
+          .enableRenderer(DashHostedTest.VIDEO_RENDERER_INDEX)
+          .disableRenderer(DashHostedTest.VIDEO_RENDERER_INDEX)
+          .enableRenderer(DashHostedTest.VIDEO_RENDERER_INDEX)
+      // Ditto for the audio renderer.
+      .delay(10000).disableRenderer(DashHostedTest.AUDIO_RENDERER_INDEX)
+          .enableRenderer(DashHostedTest.AUDIO_RENDERER_INDEX)
+          .disableRenderer(DashHostedTest.AUDIO_RENDERER_INDEX)
+          .enableRenderer(DashHostedTest.AUDIO_RENDERER_INDEX)
+          .disableRenderer(DashHostedTest.AUDIO_RENDERER_INDEX)
+          .enableRenderer(DashHostedTest.AUDIO_RENDERER_INDEX)
+          .disableRenderer(DashHostedTest.AUDIO_RENDERER_INDEX)
+          .enableRenderer(DashHostedTest.AUDIO_RENDERER_INDEX)
+          .disableRenderer(DashHostedTest.AUDIO_RENDERER_INDEX)
+          .enableRenderer(DashHostedTest.AUDIO_RENDERER_INDEX)
+      .build();
+
+  public DashTest() {
+    super(HostActivity.class);
+  }
+
+  // H264 CDD.
+
+  public void testH264Fixed() throws IOException {
+    if (Util.SDK_INT < 16) {
+      // Pass.
+      return;
+    }
+    testDashPlayback(getActivity(), AAC_AUDIO_FRAME_COUNT, H264_VIDEO_FRAME_COUNT,
+        H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false, H264_CDD_FIXED);
+  }
+
+  public void testH264Adaptive() throws IOException {
+    if (Util.SDK_INT < 16) {
+      // Pass.
+      return;
+    }
+    testDashPlayback(getActivity(), AAC_AUDIO_FRAME_COUNT, H264_VIDEO_FRAME_COUNT,
+        H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS,
+        H264_CDD_ADAPTIVE);
+  }
+
+  public void testH264AdaptiveWithSeeking() throws IOException {
+    if (Util.SDK_INT < 16) {
+      // Pass.
+      return;
+    }
+    testDashPlayback(getActivity(), SEEKING_SCHEDULE, false, AAC_AUDIO_FRAME_COUNT,
+        H264_VIDEO_FRAME_COUNT, H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
+        ALLOW_ADDITIONAL_VIDEO_FORMATS, H264_CDD_ADAPTIVE);
+  }
+
+  public void testH264AdaptiveWithRendererDisabling() throws IOException {
+    if (Util.SDK_INT < 16) {
+      // Pass.
+      return;
+    }
+    testDashPlayback(getActivity(), RENDERER_DISABLING_SCHEDULE, false, AAC_AUDIO_FRAME_COUNT,
+        H264_VIDEO_FRAME_COUNT, H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
+        ALLOW_ADDITIONAL_VIDEO_FORMATS, H264_CDD_ADAPTIVE);
+  }
+
+  // VP9 (CDD).
+
+  public void testVp9Fixed360p() throws IOException {
+    if (Util.SDK_INT < 16) {
+      // Pass.
+      return;
+    }
+    testDashPlayback(getActivity(), VORBIS_AUDIO_FRAME_COUNT, VP9_VIDEO_FRAME_COUNT, VP9_MANIFEST,
+        VORBIS_AUDIO_REPRESENTATION_ID, false, VP9_360P_VIDEO_REPRESENTATION_ID);
+  }
+
+  public void testVp9Adaptive() throws IOException {
+    if (Util.SDK_INT < 16) {
+      // Pass.
+      return;
+    }
+    testDashPlayback(getActivity(), VORBIS_AUDIO_FRAME_COUNT, VP9_VIDEO_FRAME_COUNT, VP9_MANIFEST,
+        VORBIS_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS,
+        VP9_180P_VIDEO_REPRESENTATION_ID, VP9_360P_VIDEO_REPRESENTATION_ID);
+  }
+
+  public void testVp9AdaptiveWithSeeking() throws IOException {
+    if (Util.SDK_INT < 16) {
+      // Pass.
+      return;
+    }
+    testDashPlayback(getActivity(), SEEKING_SCHEDULE, false, VORBIS_AUDIO_FRAME_COUNT,
+        VP9_VIDEO_FRAME_COUNT, VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID,
+        ALLOW_ADDITIONAL_VIDEO_FORMATS, VP9_180P_VIDEO_REPRESENTATION_ID,
+        VP9_360P_VIDEO_REPRESENTATION_ID);
+  }
+
+  public void testVp9AdaptiveWithRendererDisabling() throws IOException {
+    if (Util.SDK_INT < 16) {
+      // Pass.
+      return;
+    }
+    testDashPlayback(getActivity(), RENDERER_DISABLING_SCHEDULE, false, VORBIS_AUDIO_FRAME_COUNT,
+        VP9_VIDEO_FRAME_COUNT, VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID,
+        ALLOW_ADDITIONAL_VIDEO_FORMATS, VP9_180P_VIDEO_REPRESENTATION_ID,
+        VP9_360P_VIDEO_REPRESENTATION_ID);
+  }
+
+  // Internal.
+
+  private static void testDashPlayback(HostActivity activity, int sourceAudioFrameCount,
+      int sourceVideoFrameCount, String manifestFileName, String audioFormat,
+      boolean includeAdditionalVideoFormats, String... videoFormats) throws IOException {
+    testDashPlayback(activity, null, true, sourceAudioFrameCount, sourceVideoFrameCount,
+        manifestFileName, audioFormat, includeAdditionalVideoFormats, videoFormats);
+  }
+
+  private static void testDashPlayback(HostActivity activity, ActionSchedule actionSchedule,
+      boolean fullPlaybackNoSeeking, int sourceAudioFrameCount, int sourceVideoFrameCount,
+      String manifestFileName, String audioFormat, boolean includeAdditionalVideoFormats,
+      String... videoFormats) throws IOException {
+    MediaPresentationDescription mpd = TestUtil.loadManifest(activity,
+        MANIFEST_URL_PREFIX + manifestFileName, new MediaPresentationDescriptionParser());
+    DashHostedTest test = new DashHostedTest(mpd, fullPlaybackNoSeeking, sourceAudioFrameCount,
+        sourceVideoFrameCount, audioFormat, includeAdditionalVideoFormats,
+        videoFormats);
+    if (actionSchedule != null) {
+      test.setSchedule(actionSchedule);
+    }
+    activity.runTest(test, mpd.duration + MAX_ADDITIONAL_TIME_MS);
+  }
+
+  @TargetApi(16)
+  private static class DashHostedTest extends ExoHostedTest {
+
+    private static final int RENDERER_COUNT = 2;
+    private static final int VIDEO_RENDERER_INDEX = 0;
+    private static final int AUDIO_RENDERER_INDEX = 1;
+
+    private static final int BUFFER_SEGMENT_SIZE = 64 * 1024;
+    private static final int VIDEO_BUFFER_SEGMENTS = 200;
+    private static final int AUDIO_BUFFER_SEGMENTS = 60;
+
+    private static final String VIDEO_TAG = "Video";
+    private static final String AUDIO_TAG = "Audio";
+    private static final int VIDEO_EVENT_ID = 0;
+    private static final int AUDIO_EVENT_ID = 1;
+
+    private final MediaPresentationDescription mpd;
+    private final boolean fullPlaybackNoSeeking;
+    private final int sourceAudioFrameCount;
+    private final int sourceVideoFrameCount;
+    private String[] audioFormats;
+    private boolean includeAdditionalVideoFormats;
+    private String[] videoFormats;
+
+    private CodecCounters videoCounters;
+    private CodecCounters audioCounters;
+
+    /**
+     * @param mpd The manifest.
+     * @param fullPlaybackNoSeeking True if the test will play the entire source with no seeking.
+     *     False otherwise.
+     * @param sourceAudioFrameCount The number of audio frames in the source.
+     * @param sourceVideoFrameCount The number of video frames in the source.
+     * @param audioFormat The audio format.
+     * @param includeAdditionalVideoFormats Whether to use video formats in addition to
+     *     those listed in the videoFormats argument, if the device is capable of playing them.
+     * @param videoFormats The video formats.
+     */
+    public DashHostedTest(MediaPresentationDescription mpd, boolean fullPlaybackNoSeeking,
+        int sourceAudioFrameCount, int sourceVideoFrameCount, String audioFormat,
+        boolean includeAdditionalVideoFormats, String... videoFormats) {
+      super(RENDERER_COUNT);
+      this.mpd = Assertions.checkNotNull(mpd);
+      this.fullPlaybackNoSeeking = fullPlaybackNoSeeking;
+      this.sourceAudioFrameCount = sourceAudioFrameCount;
+      this.sourceVideoFrameCount = sourceVideoFrameCount;
+      this.audioFormats = new String[] {audioFormat};
+      this.includeAdditionalVideoFormats = includeAdditionalVideoFormats;
+      this.videoFormats = videoFormats;
+    }
+
+    @Override
+    public TrackRenderer[] buildRenderers(HostActivity host, ExoPlayer player, Surface surface) {
+      Handler handler = new Handler();
+      LogcatLogger logger = new LogcatLogger(TAG, player);
+      LoadControl loadControl = new DefaultLoadControl(new DefaultAllocator(BUFFER_SEGMENT_SIZE));
+      String userAgent = TestUtil.getUserAgent(host);
+
+      // Build the video renderer.
+      DataSource videoDataSource = new DefaultUriDataSource(host, null, userAgent);
+      TrackSelector videoTrackSelector = new TrackSelector(AdaptationSet.TYPE_VIDEO,
+          includeAdditionalVideoFormats, videoFormats);
+      ChunkSource videoChunkSource = new DashChunkSource(mpd, videoTrackSelector, videoDataSource,
+          new FormatEvaluator.RandomEvaluator(0));
+      ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,
+          VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, handler, logger, VIDEO_EVENT_ID,
+          MIN_LOADABLE_RETRY_COUNT);
+      MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(host,
+          videoSampleSource, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 0, handler, logger, 50);
+      videoCounters = videoRenderer.codecCounters;
+      player.sendMessage(videoRenderer, MediaCodecVideoTrackRenderer.MSG_SET_SURFACE, surface);
+
+      // Build the audio renderer.
+      DataSource audioDataSource = new DefaultUriDataSource(host, null, userAgent);
+      TrackSelector audioTrackSelector = new TrackSelector(AdaptationSet.TYPE_AUDIO, false,
+          audioFormats);
+      ChunkSource audioChunkSource = new DashChunkSource(mpd, audioTrackSelector, audioDataSource,
+          null);
+      ChunkSampleSource audioSampleSource = new ChunkSampleSource(audioChunkSource, loadControl,
+          AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, handler, logger, AUDIO_EVENT_ID,
+          MIN_LOADABLE_RETRY_COUNT);
+      MediaCodecAudioTrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer(
+          audioSampleSource, handler, logger);
+      audioCounters = audioRenderer.codecCounters;
+
+      TrackRenderer[] renderers = new TrackRenderer[RENDERER_COUNT];
+      renderers[VIDEO_RENDERER_INDEX] = videoRenderer;
+      renderers[AUDIO_RENDERER_INDEX] = audioRenderer;
+      return renderers;
+    }
+
+    @Override
+    protected void assertPassedInternal() {
+      if (fullPlaybackNoSeeking) {
+        // Audio is not adaptive and we didn't seek (which can re-instantiate the audio decoder
+        // in ExoPlayer), so the decoder output format should have changed exactly once. The output
+        // buffers should have changed 0 or 1 times.
+        CodecCountersUtil.assertOutputFormatChangedCount(AUDIO_TAG, audioCounters, 1);
+        CodecCountersUtil.assertOutputBuffersChangedLimit(AUDIO_TAG, audioCounters, 1);
+
+        if (videoFormats != null && videoFormats.length == 1) {
+          // Video is not adaptive, so the decoder output format should have changed exactly once.
+          // The output buffers should have changed 0 or 1 times.
+          CodecCountersUtil.assertOutputFormatChangedCount(VIDEO_TAG, videoCounters, 1);
+          CodecCountersUtil.assertOutputBuffersChangedLimit(VIDEO_TAG, videoCounters, 1);
+        }
+
+        // We shouldn't have skipped any output buffers.
+        CodecCountersUtil.assertSkippedOutputBufferCount(AUDIO_TAG, audioCounters, 0);
+        CodecCountersUtil.assertSkippedOutputBufferCount(VIDEO_TAG, videoCounters, 0);
+
+        // We allow one fewer output buffer due to the way that MediaCodecTrackRenderer and the
+        // underlying decoders handle the end of stream. This should be tightened up in the future.
+        CodecCountersUtil.assertTotalOutputBufferCount(AUDIO_TAG, audioCounters,
+            sourceAudioFrameCount - 1, sourceAudioFrameCount);
+        CodecCountersUtil.assertTotalOutputBufferCount(VIDEO_TAG, videoCounters,
+            sourceVideoFrameCount - 1, sourceVideoFrameCount);
+
+        // The total playing time should match the source duration.
+        long sourceDuration = mpd.duration;
+        long minAllowedActualPlayingTime = sourceDuration - MAX_PLAYING_TIME_DISCREPANCY_MS;
+        long maxAllowedActualPlayingTime = sourceDuration + MAX_PLAYING_TIME_DISCREPANCY_MS;
+        long actualPlayingTime = getTotalPlayingTimeMs();
+        assertTrue("Total playing time: " + actualPlayingTime + ". Actual media duration: "
+            + sourceDuration, minAllowedActualPlayingTime <= actualPlayingTime
+            && actualPlayingTime <= maxAllowedActualPlayingTime);
+      }
+
+      // Assert that the level of performance was acceptable.
+      // Assert that total dropped frames were within limit.
+      int droppedFrameLimit = (int) Math.ceil(MAX_DROPPED_VIDEO_FRAME_FRACTION
+          * CodecCountersUtil.getTotalOutputBuffers(videoCounters));
+      CodecCountersUtil.assertDroppedOutputBufferLimit(VIDEO_TAG, videoCounters, droppedFrameLimit);
+      // Assert that consecutive dropped frames were within limit.
+      CodecCountersUtil.assertConsecutiveDroppedOutputBufferLimit(VIDEO_TAG, videoCounters,
+          MAX_CONSECUTIVE_DROPPED_VIDEO_FRAMES);
+    }
+
+    private static final class TrackSelector implements DashTrackSelector {
+
+      private final int adaptationSetType;
+      private final String[] representationIds;
+      private final boolean includeAdditionalVideoRepresentations;
+
+      private TrackSelector(int adaptationSetType, boolean includeAdditionalVideoRepresentations,
+          String[] representationIds) {
+        Assertions.checkState(!includeAdditionalVideoRepresentations
+            || adaptationSetType == AdaptationSet.TYPE_VIDEO);
+        this.adaptationSetType = adaptationSetType;
+        this.includeAdditionalVideoRepresentations = includeAdditionalVideoRepresentations;
+        this.representationIds = representationIds;
+      }
+
+      @Override
+      public void selectTracks(MediaPresentationDescription manifest, int periodIndex,
+          Output output) throws IOException {
+        Period period = manifest.getPeriod(periodIndex);
+        int adaptationSetIndex = period.getAdaptationSetIndex(adaptationSetType);
+        AdaptationSet adaptationSet = period.adaptationSets.get(adaptationSetIndex);
+        int[] representationIndices = getRepresentationIndices(adaptationSet, representationIds,
+            includeAdditionalVideoRepresentations);
+        if (adaptationSetType == AdaptationSet.TYPE_VIDEO) {
+          output.adaptiveTrack(manifest, periodIndex, adaptationSetIndex, representationIndices);
+        }
+        for (int i = 0; i < representationIndices.length; i++) {
+          output.fixedTrack(manifest, periodIndex, adaptationSetIndex, representationIndices[i]);
+        }
+      }
+
+      private static int[] getRepresentationIndices(AdaptationSet adaptationSet,
+          String[] representationIds, boolean includeAdditionalVideoRepresentations)
+          throws IOException {
+        List<Representation> availableRepresentations = adaptationSet.representations;
+        List<Integer> selectedRepresentationIndices = new ArrayList<>();
+
+        // Always select explicitly listed representations, failing if they're missing.
+        for (int i = 0; i < representationIds.length; i++) {
+          String representationId = representationIds[i];
+          boolean foundIndex = false;
+          for (int j = 0; j < availableRepresentations.size() && !foundIndex; j++) {
+            if (availableRepresentations.get(j).format.id.equals(representationId)) {
+              selectedRepresentationIndices.add(j);
+              foundIndex = true;
+            }
+          }
+          if (!foundIndex) {
+            throw new IllegalStateException("Representation " + representationId + " not found.");
+          }
+        }
+
+        // Select additional video representations, if supported by the device.
+        if (includeAdditionalVideoRepresentations) {
+           int[] supportedVideoRepresentationIndices = VideoFormatSelectorUtil.selectVideoFormats(
+               availableRepresentations, null, false, true, -1, -1);
+           for (int i = 0; i < supportedVideoRepresentationIndices.length; i++) {
+             int representationIndex = supportedVideoRepresentationIndices[i];
+             if (!selectedRepresentationIndices.contains(representationIndex)) {
+               Log.d(TAG, "Adding video format: " + availableRepresentations.get(i).format.id);
+               selectedRepresentationIndices.add(representationIndex);
+             }
+           }
+
+        }
+
+        return Util.toArray(selectedRepresentationIndices);
+      }
+    }
+  }
+
+}
+
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/H264DashTest.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/H264DashTest.java
deleted file mode 100644
index 78e1445385..0000000000
--- a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/H264DashTest.java
+++ /dev/null
@@ -1,335 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.playbacktests.gts;
-
-import com.google.android.exoplayer.CodecCounters;
-import com.google.android.exoplayer.DefaultLoadControl;
-import com.google.android.exoplayer.ExoPlayer;
-import com.google.android.exoplayer.LoadControl;
-import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
-import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
-import com.google.android.exoplayer.TrackRenderer;
-import com.google.android.exoplayer.chunk.ChunkSampleSource;
-import com.google.android.exoplayer.chunk.ChunkSource;
-import com.google.android.exoplayer.chunk.FormatEvaluator;
-import com.google.android.exoplayer.dash.DashChunkSource;
-import com.google.android.exoplayer.dash.DashTrackSelector;
-import com.google.android.exoplayer.dash.mpd.AdaptationSet;
-import com.google.android.exoplayer.dash.mpd.MediaPresentationDescription;
-import com.google.android.exoplayer.dash.mpd.MediaPresentationDescriptionParser;
-import com.google.android.exoplayer.dash.mpd.Period;
-import com.google.android.exoplayer.dash.mpd.Representation;
-import com.google.android.exoplayer.playbacktests.util.ActionSchedule;
-import com.google.android.exoplayer.playbacktests.util.CodecCountersUtil;
-import com.google.android.exoplayer.playbacktests.util.ExoHostedTest;
-import com.google.android.exoplayer.playbacktests.util.HostActivity;
-import com.google.android.exoplayer.playbacktests.util.LogcatLogger;
-import com.google.android.exoplayer.playbacktests.util.TestUtil;
-import com.google.android.exoplayer.upstream.DataSource;
-import com.google.android.exoplayer.upstream.DefaultAllocator;
-import com.google.android.exoplayer.upstream.DefaultUriDataSource;
-import com.google.android.exoplayer.util.Assertions;
-import com.google.android.exoplayer.util.Util;
-
-import android.annotation.TargetApi;
-import android.media.MediaCodec;
-import android.os.Handler;
-import android.test.ActivityInstrumentationTestCase2;
-import android.view.Surface;
-
-import java.io.IOException;
-import java.util.List;
-
-/**
- * Tests H264 DASH playbacks using {@link ExoPlayer}.
- */
-public final class H264DashTest extends ActivityInstrumentationTestCase2<HostActivity> {
-
-  private static final String TAG = "H264DashTest";
-
-  private static final long MAX_PLAYING_TIME_DISCREPANCY_MS = 2000;
-  private static final float MAX_DROPPED_VIDEO_FRAME_FRACTION = 0.01f;
-
-  private static final long MAX_ADDITIONAL_TIME_MS = 180000;
-  private static final int MIN_LOADABLE_RETRY_COUNT = 10;
-
-  private static final String SOURCE_URL = "https://storage.googleapis.com/exoplayer-test-media-1"
-      + "/gen/screens/dash-vod-single-segment/manifest-baseline.mpd";
-  private static final int SOURCE_VIDEO_FRAME_COUNT = 3840;
-  private static final int SOURCE_AUDIO_FRAME_COUNT = 5524;
-  private static final String AUDIO_REPRESENTATION_ID = "141";
-  private static final String VIDEO_REPRESENTATION_ID_240 = "avc-baseline-240";
-  private static final String VIDEO_REPRESENTATION_ID_480 = "avc-baseline-480";
-
-  public H264DashTest() {
-    super(HostActivity.class);
-  }
-
-  public void testBaseline480() throws IOException {
-    if (Util.SDK_INT < 16) {
-      // Pass.
-      return;
-    }
-    MediaPresentationDescription mpd = TestUtil.loadManifest(getActivity(), SOURCE_URL,
-        new MediaPresentationDescriptionParser());
-    H264DashHostedTest test = new H264DashHostedTest(mpd, true, AUDIO_REPRESENTATION_ID,
-        VIDEO_REPRESENTATION_ID_480);
-    getActivity().runTest(test, mpd.duration + MAX_ADDITIONAL_TIME_MS);
-  }
-
-  public void testBaselineAdaptive() throws IOException {
-    if (Util.SDK_INT < 16) {
-      // Pass.
-      return;
-    }
-    MediaPresentationDescription mpd = TestUtil.loadManifest(getActivity(), SOURCE_URL,
-        new MediaPresentationDescriptionParser());
-    H264DashHostedTest test = new H264DashHostedTest(mpd, true, AUDIO_REPRESENTATION_ID,
-        VIDEO_REPRESENTATION_ID_240, VIDEO_REPRESENTATION_ID_480);
-    getActivity().runTest(test, mpd.duration + MAX_ADDITIONAL_TIME_MS);
-  }
-
-  public void testBaselineAdaptiveWithSeeking() throws IOException {
-    if (Util.SDK_INT < 16) {
-      // Pass.
-      return;
-    }
-    MediaPresentationDescription mpd = TestUtil.loadManifest(getActivity(), SOURCE_URL,
-        new MediaPresentationDescriptionParser());
-    H264DashHostedTest test = new H264DashHostedTest(mpd, false, AUDIO_REPRESENTATION_ID,
-        VIDEO_REPRESENTATION_ID_240, VIDEO_REPRESENTATION_ID_480);
-    test.setSchedule(new ActionSchedule.Builder(TAG)
-        .delay(10000).seek(15000)
-        .delay(10000).seek(30000).seek(31000).seek(32000).seek(33000).seek(34000)
-        .delay(1000).pause().delay(1000).play()
-        .delay(1000).pause().seek(100000).delay(1000).play()
-        .build());
-    getActivity().runTest(test, mpd.duration + MAX_ADDITIONAL_TIME_MS);
-  }
-
-  public void testBaselineAdaptiveWithRendererDisabling() throws IOException {
-    if (Util.SDK_INT < 16) {
-      // Pass.
-      return;
-    }
-    MediaPresentationDescription mpd = TestUtil.loadManifest(getActivity(), SOURCE_URL,
-        new MediaPresentationDescriptionParser());
-    H264DashHostedTest test = new H264DashHostedTest(mpd, false, AUDIO_REPRESENTATION_ID,
-        VIDEO_REPRESENTATION_ID_240, VIDEO_REPRESENTATION_ID_480);
-    test.setSchedule(new ActionSchedule.Builder(TAG)
-        // Wait 10 seconds, disable the video renderer, wait another 5 seconds and enable it again.
-        .delay(10000).disableRenderer(H264DashHostedTest.VIDEO_RENDERER_INDEX)
-        .delay(10000).enableRenderer(H264DashHostedTest.VIDEO_RENDERER_INDEX)
-        // Ditto for the audio renderer.
-        .delay(10000).disableRenderer(H264DashHostedTest.AUDIO_RENDERER_INDEX)
-        .delay(10000).enableRenderer(H264DashHostedTest.AUDIO_RENDERER_INDEX)
-        // Wait 10 seconds, then disable and enable the video renderer 5 times in quick succession.
-        .delay(10000).disableRenderer(H264DashHostedTest.VIDEO_RENDERER_INDEX)
-            .enableRenderer(H264DashHostedTest.VIDEO_RENDERER_INDEX)
-            .disableRenderer(H264DashHostedTest.VIDEO_RENDERER_INDEX)
-            .enableRenderer(H264DashHostedTest.VIDEO_RENDERER_INDEX)
-            .disableRenderer(H264DashHostedTest.VIDEO_RENDERER_INDEX)
-            .enableRenderer(H264DashHostedTest.VIDEO_RENDERER_INDEX)
-            .disableRenderer(H264DashHostedTest.VIDEO_RENDERER_INDEX)
-            .enableRenderer(H264DashHostedTest.VIDEO_RENDERER_INDEX)
-            .disableRenderer(H264DashHostedTest.VIDEO_RENDERER_INDEX)
-            .enableRenderer(H264DashHostedTest.VIDEO_RENDERER_INDEX)
-        // Ditto for the audio renderer.
-        .delay(10000).disableRenderer(H264DashHostedTest.AUDIO_RENDERER_INDEX)
-            .enableRenderer(H264DashHostedTest.AUDIO_RENDERER_INDEX)
-            .disableRenderer(H264DashHostedTest.AUDIO_RENDERER_INDEX)
-            .enableRenderer(H264DashHostedTest.AUDIO_RENDERER_INDEX)
-            .disableRenderer(H264DashHostedTest.AUDIO_RENDERER_INDEX)
-            .enableRenderer(H264DashHostedTest.AUDIO_RENDERER_INDEX)
-            .disableRenderer(H264DashHostedTest.AUDIO_RENDERER_INDEX)
-            .enableRenderer(H264DashHostedTest.AUDIO_RENDERER_INDEX)
-            .disableRenderer(H264DashHostedTest.AUDIO_RENDERER_INDEX)
-            .enableRenderer(H264DashHostedTest.AUDIO_RENDERER_INDEX)
-        .build());
-    getActivity().runTest(test, mpd.duration + MAX_ADDITIONAL_TIME_MS);
-  }
-
-  @TargetApi(16)
-  private static class H264DashHostedTest extends ExoHostedTest {
-
-    private static final int RENDERER_COUNT = 2;
-    private static final int VIDEO_RENDERER_INDEX = 0;
-    private static final int AUDIO_RENDERER_INDEX = 1;
-
-    private static final int BUFFER_SEGMENT_SIZE = 64 * 1024;
-    private static final int VIDEO_BUFFER_SEGMENTS = 200;
-    private static final int AUDIO_BUFFER_SEGMENTS = 60;
-
-    private static final String VIDEO_TAG = "Video";
-    private static final String AUDIO_TAG = "Audio";
-    private static final int VIDEO_EVENT_ID = 0;
-    private static final int AUDIO_EVENT_ID = 1;
-
-    private final MediaPresentationDescription mpd;
-    private final boolean fullPlaybackNoSeeking;
-    private String[] audioFormats;
-    private String[] videoFormats;
-
-    private CodecCounters videoCounters;
-    private CodecCounters audioCounters;
-
-    /**
-     * @param mpd The manifest.
-     * @param fullPlaybackNoSeeking True if the test will play the entire source with no seeking.
-     *     False otherwise.
-     * @param audioFormat The audio format.
-     * @param videoFormats The video formats.
-     */
-    public H264DashHostedTest(MediaPresentationDescription mpd, boolean fullPlaybackNoSeeking,
-        String audioFormat, String... videoFormats) {
-      super(RENDERER_COUNT);
-      this.mpd = Assertions.checkNotNull(mpd);
-      this.fullPlaybackNoSeeking = fullPlaybackNoSeeking;
-      this.audioFormats = new String[] {audioFormat};
-      this.videoFormats = videoFormats;
-    }
-
-    @Override
-    public TrackRenderer[] buildRenderers(HostActivity host, ExoPlayer player, Surface surface) {
-      Handler handler = new Handler();
-      LogcatLogger logger = new LogcatLogger(TAG, player);
-      LoadControl loadControl = new DefaultLoadControl(new DefaultAllocator(BUFFER_SEGMENT_SIZE));
-      String userAgent = TestUtil.getUserAgent(host);
-
-      // Build the video renderer.
-      DataSource videoDataSource = new DefaultUriDataSource(host, null, userAgent);
-      TrackSelector videoTrackSelector = new TrackSelector(AdaptationSet.TYPE_VIDEO, videoFormats);
-      ChunkSource videoChunkSource = new DashChunkSource(mpd, videoTrackSelector, videoDataSource,
-          new FormatEvaluator.RandomEvaluator(0));
-      ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,
-          VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, handler, logger, VIDEO_EVENT_ID,
-          MIN_LOADABLE_RETRY_COUNT);
-      MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(host,
-          videoSampleSource, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 0, handler, logger, 50);
-      videoCounters = videoRenderer.codecCounters;
-      player.sendMessage(videoRenderer, MediaCodecVideoTrackRenderer.MSG_SET_SURFACE, surface);
-
-      // Build the audio renderer.
-      DataSource audioDataSource = new DefaultUriDataSource(host, null, userAgent);
-      TrackSelector audioTrackSelector = new TrackSelector(AdaptationSet.TYPE_AUDIO, audioFormats);
-      ChunkSource audioChunkSource = new DashChunkSource(mpd, audioTrackSelector, audioDataSource,
-          null);
-      ChunkSampleSource audioSampleSource = new ChunkSampleSource(audioChunkSource, loadControl,
-          AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, handler, logger, AUDIO_EVENT_ID,
-          MIN_LOADABLE_RETRY_COUNT);
-      MediaCodecAudioTrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer(
-          audioSampleSource, handler, logger);
-      audioCounters = audioRenderer.codecCounters;
-
-      TrackRenderer[] renderers = new TrackRenderer[RENDERER_COUNT];
-      renderers[VIDEO_RENDERER_INDEX] = videoRenderer;
-      renderers[AUDIO_RENDERER_INDEX] = audioRenderer;
-      return renderers;
-    }
-
-    @Override
-    protected void assertPassedInternal() {
-      if (fullPlaybackNoSeeking) {
-        // Audio is not adaptive and we didn't seek (which can re-instantiate the audio decoder
-        // in ExoPlayer), so the decoder output format should have changed exactly once. The output
-        // buffers should have changed 0 or 1 times.
-        CodecCountersUtil.assertOutputFormatChangedCount(AUDIO_TAG, audioCounters, 1);
-        CodecCountersUtil.assertOutputBuffersChangedLimit(AUDIO_TAG, audioCounters, 1);
-
-        if (videoFormats.length == 1) {
-          // Video is not adaptive, so the decoder output format should have changed exactly once.
-          // The output buffers should have changed 0 or 1 times.
-          CodecCountersUtil.assertOutputFormatChangedCount(VIDEO_TAG, videoCounters, 1);
-          CodecCountersUtil.assertOutputBuffersChangedLimit(VIDEO_TAG, videoCounters, 1);
-        }
-
-        // We shouldn't have skipped any output buffers.
-        CodecCountersUtil.assertSkippedOutputBufferCount(AUDIO_TAG, audioCounters, 0);
-        CodecCountersUtil.assertSkippedOutputBufferCount(VIDEO_TAG, videoCounters, 0);
-
-        // We allow one fewer output buffer due to the way that MediaCodecTrackRenderer and the
-        // underlying decoders handle the end of stream. This should be tightened up in the future.
-        CodecCountersUtil.assertTotalOutputBufferCount(VIDEO_TAG, videoCounters,
-            SOURCE_VIDEO_FRAME_COUNT - 1, SOURCE_VIDEO_FRAME_COUNT);
-        CodecCountersUtil.assertTotalOutputBufferCount(AUDIO_TAG, audioCounters,
-            SOURCE_AUDIO_FRAME_COUNT - 1, SOURCE_AUDIO_FRAME_COUNT);
-
-        // The total playing time should match the source duration.
-        long sourceDuration = mpd.duration;
-        long minAllowedActualPlayingTime = sourceDuration - MAX_PLAYING_TIME_DISCREPANCY_MS;
-        long maxAllowedActualPlayingTime = sourceDuration + MAX_PLAYING_TIME_DISCREPANCY_MS;
-        long actualPlayingTime = getTotalPlayingTimeMs();
-        assertTrue("Total playing time: " + actualPlayingTime + ". Actual media duration: "
-            + sourceDuration, minAllowedActualPlayingTime <= actualPlayingTime
-            && actualPlayingTime <= maxAllowedActualPlayingTime);
-      }
-
-      // Assert that the level of performance was acceptable.
-      int droppedFrameLimit = (int) Math.ceil(MAX_DROPPED_VIDEO_FRAME_FRACTION
-          * CodecCountersUtil.getTotalOutputBuffers(videoCounters));
-      CodecCountersUtil.assertDroppedOutputBufferLimit(VIDEO_TAG, videoCounters, droppedFrameLimit);
-    }
-
-    private static final class TrackSelector implements DashTrackSelector {
-
-      private final int adaptationSetType;
-      private final String[] representationIds;
-
-      private TrackSelector(int adaptationSetType, String[] representationIds) {
-        this.adaptationSetType = adaptationSetType;
-        this.representationIds = representationIds;
-      }
-
-      @Override
-      public void selectTracks(MediaPresentationDescription manifest, int periodIndex,
-          Output output) throws IOException {
-        Period period = manifest.getPeriod(periodIndex);
-        int adaptationSetIndex = period.getAdaptationSetIndex(adaptationSetType);
-        AdaptationSet adaptationSet = period.adaptationSets.get(adaptationSetIndex);
-        int[] representationIndices = getRepresentationIndices(representationIds, adaptationSet);
-        if (adaptationSetType == AdaptationSet.TYPE_VIDEO) {
-          output.adaptiveTrack(manifest, periodIndex, adaptationSetIndex, representationIndices);
-        }
-        for (int i = 0; i < representationIndices.length; i++) {
-          output.fixedTrack(manifest, periodIndex, adaptationSetIndex, representationIndices[i]);
-        }
-      }
-
-      private static int[] getRepresentationIndices(String[] representationIds,
-          AdaptationSet adaptationSet) {
-        List<Representation> representations = adaptationSet.representations;
-        int[] representationIndices = new int[representationIds.length];
-        for (int i = 0; i < representationIds.length; i++) {
-          String representationId = representationIds[i];
-          boolean foundIndex = false;
-          for (int j = 0; j < representations.size() && !foundIndex; j++) {
-            if (representations.get(j).format.id.equals(representationId)) {
-              representationIndices[i] = j;
-              foundIndex = true;
-            }
-          }
-          if (!foundIndex) {
-            throw new IllegalStateException("Representation " + representationId + " not found.");
-          }
-        }
-        return representationIndices;
-      }
-
-    }
-
-  }
-
-}
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/CodecCountersUtil.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/CodecCountersUtil.java
index 949b63d5c6..6034068fcc 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/CodecCountersUtil.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/CodecCountersUtil.java
@@ -77,4 +77,12 @@ public static void assertDroppedOutputBufferLimit(String name, CodecCounters cou
         + "Limit: " + limit + ".", actual <= limit);
   }
 
+  public static void assertConsecutiveDroppedOutputBufferLimit(String name, CodecCounters counters,
+      int limit) {
+    counters.ensureUpdated();
+    int actual = counters.maxConsecutiveDroppedOutputBufferCount;
+    TestCase.assertTrue("Codec(" + name + ") was late decoding: " + actual
+        + " buffers consecutively. " + "Limit: " + limit + ".", actual <= limit);
+  }
+
 }
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/LogcatLogger.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/LogcatLogger.java
index 320af8e924..db33d400aa 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/LogcatLogger.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/LogcatLogger.java
@@ -104,6 +104,12 @@ public void onAudioTrackWriteError(WriteException e) {
     Log.e(tag, "Audio track write error", e);
   }
 
+  @Override
+  public void onAudioTrackUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {
+    Log.e(tag, "Audio track underrun (" + bufferSize + ", " + bufferSizeMs + ", "
+        + elapsedSinceLastFeedMs + ")");
+  }
+
   @Override
   public void onDroppedFrames(int count, long elapsed) {
     Log.w(tag, "Dropped frames (" + count + ")");
diff --git a/playbacktests/src/main/project.properties b/playbacktests/src/main/project.properties
index 4fdc858b92..a656b29329 100644
--- a/playbacktests/src/main/project.properties
+++ b/playbacktests/src/main/project.properties
@@ -8,6 +8,6 @@
 # project structure.
 
 # Project target.
-target=android-22
+target=android-23
 android.library=false
 android.library.reference.1=../../../library/src/main
