diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveVideoTrackSelection.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveVideoTrackSelection.java
index 3ec3d29984..26357a133d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveVideoTrackSelection.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveVideoTrackSelection.java
@@ -16,11 +16,13 @@
 package com.google.android.exoplayer2.trackselection;
 
 import android.os.SystemClock;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
 import com.google.android.exoplayer2.upstream.BandwidthMeter;
+
 import java.util.List;
 
 /**
@@ -30,263 +32,263 @@
  */
 public class AdaptiveVideoTrackSelection extends BaseTrackSelection {
 
-  /**
-   * Factory for {@link AdaptiveVideoTrackSelection} instances.
-   */
-  public static final class Factory implements TrackSelection.Factory {
+    /**
+     * Factory for {@link AdaptiveVideoTrackSelection} instances.
+     */
+    public static final class Factory implements TrackSelection.Factory {
+
+        private final BandwidthMeter bandwidthMeter;
+        private final int maxInitialBitrate;
+        private final int minDurationForQualityIncreaseMs;
+        private final int maxDurationForQualityDecreaseMs;
+        private final int minDurationToRetainAfterDiscardMs;
+        private final float bandwidthFraction;
+
+        /**
+         * @param bandwidthMeter Provides an estimate of the currently available bandwidth.
+         */
+        public Factory(BandwidthMeter bandwidthMeter) {
+            this(bandwidthMeter, DEFAULT_MAX_INITIAL_BITRATE,
+                    DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS,
+                    DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS,
+                    DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS, DEFAULT_BANDWIDTH_FRACTION);
+        }
+
+        /**
+         * @param bandwidthMeter                    Provides an estimate of the currently available bandwidth.
+         * @param maxInitialBitrate                 The maximum bitrate in bits per second that should be assumed
+         *                                          when a bandwidth estimate is unavailable.
+         * @param minDurationForQualityIncreaseMs   The minimum duration of buffered data required for
+         *                                          the selected track to switch to one of higher quality.
+         * @param maxDurationForQualityDecreaseMs   The maximum duration of buffered data required for
+         *                                          the selected track to switch to one of lower quality.
+         * @param minDurationToRetainAfterDiscardMs When switching to a track of significantly higher
+         *                                          quality, the selection may indicate that media already buffered at the lower quality can
+         *                                          be discarded to speed up the switch. This is the minimum duration of media that must be
+         *                                          retained at the lower quality.
+         * @param bandwidthFraction                 The fraction of the available bandwidth that the selection should
+         *                                          consider available for use. Setting to a value less than 1 is recommended to account
+         *                                          for inaccuracies in the bandwidth estimator.
+         */
+        public Factory(BandwidthMeter bandwidthMeter, int maxInitialBitrate,
+                       int minDurationForQualityIncreaseMs, int maxDurationForQualityDecreaseMs,
+                       int minDurationToRetainAfterDiscardMs, float bandwidthFraction) {
+            this.bandwidthMeter = bandwidthMeter;
+            this.maxInitialBitrate = maxInitialBitrate;
+            this.minDurationForQualityIncreaseMs = minDurationForQualityIncreaseMs;
+            this.maxDurationForQualityDecreaseMs = maxDurationForQualityDecreaseMs;
+            this.minDurationToRetainAfterDiscardMs = minDurationToRetainAfterDiscardMs;
+            this.bandwidthFraction = bandwidthFraction;
+        }
+
+        @Override
+        public AdaptiveVideoTrackSelection createTrackSelection(TrackGroup group, int... tracks) {
+            // 如何选择一个合适的VideoTrack呢?
+            return new AdaptiveVideoTrackSelection(group, tracks, bandwidthMeter, maxInitialBitrate,
+                    minDurationForQualityIncreaseMs, maxDurationForQualityDecreaseMs,
+                    minDurationToRetainAfterDiscardMs, bandwidthFraction);
+        }
+
+    }
+
+    // 至少下载了: 2000ms，也即是2s；或者512k数据才能有一个稳定的带宽估计，这个2s时间也不短；
+    // 因此一个默认的variant的选择也很重要
+
+    // 默认是: 800K，这个就是为什么刚开始视频会比较模糊
+    // TODO: 提高编码效率, 保证低码率的视频也足够清晰
+    //
+    public static final int DEFAULT_MAX_INITIAL_BITRATE = 800000;
+
+    // 切换高质量的视频：必须至少10s,
+    public static final int DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS = 10000;
+    public static final int DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS = 25000;
+
+    public static final int DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS = 25000;
+
+    public static final float DEFAULT_BANDWIDTH_FRACTION = 0.75f; // 0.75的估算
 
     private final BandwidthMeter bandwidthMeter;
     private final int maxInitialBitrate;
-    private final int minDurationForQualityIncreaseMs;
-    private final int maxDurationForQualityDecreaseMs;
-    private final int minDurationToRetainAfterDiscardMs;
-    private final float bandwidthFraction;
+    private final long minDurationForQualityIncreaseUs;
+    private final long maxDurationForQualityDecreaseUs;
+    private final long minDurationToRetainAfterDiscardUs;
+    private final float bandwidthFraction; // 默认: 0.75
+
+    private int selectedIndex;
+    private int reason;
 
     /**
+     * @param group          The {@link TrackGroup}. Must not be null.
+     * @param tracks         The indices of the selected tracks within the {@link TrackGroup}. Must not be
+     *                       null or empty. May be in any order.
      * @param bandwidthMeter Provides an estimate of the currently available bandwidth.
      */
-    public Factory(BandwidthMeter bandwidthMeter) {
-      this (bandwidthMeter, DEFAULT_MAX_INITIAL_BITRATE,
-          DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS,
-          DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS,
-          DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS, DEFAULT_BANDWIDTH_FRACTION);
+    public AdaptiveVideoTrackSelection(TrackGroup group, int[] tracks,
+                                       BandwidthMeter bandwidthMeter) {
+        this(group, tracks, bandwidthMeter, DEFAULT_MAX_INITIAL_BITRATE,
+                DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS,
+                DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS,
+                DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS, DEFAULT_BANDWIDTH_FRACTION);
     }
 
     /**
-     * @param bandwidthMeter Provides an estimate of the currently available bandwidth.
-     * @param maxInitialBitrate The maximum bitrate in bits per second that should be assumed
-     *     when a bandwidth estimate is unavailable.
-     * @param minDurationForQualityIncreaseMs The minimum duration of buffered data required for
-     *     the selected track to switch to one of higher quality.
-     * @param maxDurationForQualityDecreaseMs The maximum duration of buffered data required for
-     *     the selected track to switch to one of lower quality.
+     * @param group                             The {@link TrackGroup}. Must not be null.
+     * @param tracks                            The indices of the selected tracks within the {@link TrackGroup}. Must not be
+     *                                          null or empty. May be in any order.
+     * @param bandwidthMeter                    Provides an estimate of the currently available bandwidth.
+     * @param maxInitialBitrate                 The maximum bitrate in bits per second that should be assumed when a
+     *                                          bandwidth estimate is unavailable.
+     * @param minDurationForQualityIncreaseMs   The minimum duration of buffered data required for the
+     *                                          selected track to switch to one of higher quality.
+     * @param maxDurationForQualityDecreaseMs   The maximum duration of buffered data required for the
+     *                                          selected track to switch to one of lower quality.
      * @param minDurationToRetainAfterDiscardMs When switching to a track of significantly higher
-     *     quality, the selection may indicate that media already buffered at the lower quality can
-     *     be discarded to speed up the switch. This is the minimum duration of media that must be
-     *     retained at the lower quality.
-     * @param bandwidthFraction The fraction of the available bandwidth that the selection should
-     *     consider available for use. Setting to a value less than 1 is recommended to account
-     *     for inaccuracies in the bandwidth estimator.
+     *                                          quality, the selection may indicate that media already buffered at the lower quality can
+     *                                          be discarded to speed up the switch. This is the minimum duration of media that must be
+     *                                          retained at the lower quality.
+     * @param bandwidthFraction                 The fraction of the available bandwidth that the selection should
+     *                                          consider available for use. Setting to a value less than 1 is recommended to account
+     *                                          for inaccuracies in the bandwidth estimator.
      */
-    public Factory(BandwidthMeter bandwidthMeter, int maxInitialBitrate,
-        int minDurationForQualityIncreaseMs, int maxDurationForQualityDecreaseMs,
-        int minDurationToRetainAfterDiscardMs, float bandwidthFraction) {
-      this.bandwidthMeter = bandwidthMeter;
-      this.maxInitialBitrate = maxInitialBitrate;
-      this.minDurationForQualityIncreaseMs = minDurationForQualityIncreaseMs;
-      this.maxDurationForQualityDecreaseMs = maxDurationForQualityDecreaseMs;
-      this.minDurationToRetainAfterDiscardMs = minDurationToRetainAfterDiscardMs;
-      this.bandwidthFraction = bandwidthFraction;
+    public AdaptiveVideoTrackSelection(TrackGroup group, int[] tracks, BandwidthMeter bandwidthMeter,
+                                       int maxInitialBitrate, long minDurationForQualityIncreaseMs,
+                                       long maxDurationForQualityDecreaseMs, long minDurationToRetainAfterDiscardMs,
+                                       float bandwidthFraction) {
+        super(group, tracks);
+
+        this.bandwidthMeter = bandwidthMeter;
+        this.maxInitialBitrate = maxInitialBitrate;
+        this.minDurationForQualityIncreaseUs = minDurationForQualityIncreaseMs * 1000L;
+        this.maxDurationForQualityDecreaseUs = maxDurationForQualityDecreaseMs * 1000L;
+        this.minDurationToRetainAfterDiscardUs = minDurationToRetainAfterDiscardMs * 1000L;
+        this.bandwidthFraction = bandwidthFraction;
+        selectedIndex = determineIdealSelectedIndex(Long.MIN_VALUE);
+        reason = C.SELECTION_REASON_INITIAL;
     }
 
     @Override
-    public AdaptiveVideoTrackSelection createTrackSelection(TrackGroup group, int... tracks) {
-      // 如何选择一个合适的VideoTrack呢?
-      return new AdaptiveVideoTrackSelection(group, tracks, bandwidthMeter, maxInitialBitrate,
-          minDurationForQualityIncreaseMs, maxDurationForQualityDecreaseMs,
-          minDurationToRetainAfterDiscardMs, bandwidthFraction);
-    }
+    public void updateSelectedTrack(long bufferedDurationUs) {
+        // 如何更新选中的额Track呢?
+        long nowMs = SystemClock.elapsedRealtime();
+
+        // Get the current and ideal selections.
+        int currentSelectedIndex = selectedIndex;
+        Format currentFormat = getSelectedFormat();
+
+        // 理想的Format
+        int idealSelectedIndex = determineIdealSelectedIndex(nowMs);
+        Format idealFormat = getFormat(idealSelectedIndex);
+
+        // Assume we can switch to the ideal selection.
+        selectedIndex = idealSelectedIndex;
+
+        // Revert back to the current selection if conditions are not suitable for switching.
+        if (currentFormat != null && !isBlacklisted(selectedIndex, nowMs)) {
+
+            // 如果birate升高了
+            if (idealFormat.bitrate > currentFormat.bitrate
+                    && bufferedDurationUs < minDurationForQualityIncreaseUs) {
+                // The ideal track is a higher quality, but we have insufficient buffer to safely switch
+                // up. Defer switching up for now.
+                // 要切换到高码率，则需要有足够的buffer时间
+                selectedIndex = currentSelectedIndex;
+
+            } else if (idealFormat.bitrate < currentFormat.bitrate
+                    && bufferedDurationUs >= maxDurationForQualityDecreaseUs) {
+                // The ideal track is a lower quality, but we have sufficient buffer to defer switching
+                // down for now.
+                // 如果我们的高清码率的视频buffer足够多，那么我们也可以不着急切换variant(format)
+                selectedIndex = currentSelectedIndex;
+            }
+        }
 
-  }
-
-  // 至少下载了: 2000ms，也即是2s；或者512k数据才能有一个稳定的带宽估计，这个2s时间也不短；
-  // 因此一个默认的variant的选择也很重要
-
-  // 默认是: 800K，这个就是为什么刚开始视频会比较模糊
-  // TODO: 提高编码效率, 保证低码率的视频也足够清晰
-  //
-  public static final int DEFAULT_MAX_INITIAL_BITRATE = 800000;
-
-  // 切换高质量的视频：必须至少10s,
-  public static final int DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS = 10000;
-  public static final int DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS = 25000;
-
-  public static final int DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS = 25000;
-
-  public static final float DEFAULT_BANDWIDTH_FRACTION = 0.75f; // 0.75的估算
-
-  private final BandwidthMeter bandwidthMeter;
-  private final int maxInitialBitrate;
-  private final long minDurationForQualityIncreaseUs;
-  private final long maxDurationForQualityDecreaseUs;
-  private final long minDurationToRetainAfterDiscardUs;
-  private final float bandwidthFraction; // 默认: 0.75
-
-  private int selectedIndex;
-  private int reason;
-
-  /**
-   * @param group The {@link TrackGroup}. Must not be null.
-   * @param tracks The indices of the selected tracks within the {@link TrackGroup}. Must not be
-   *     null or empty. May be in any order.
-   * @param bandwidthMeter Provides an estimate of the currently available bandwidth.
-   */
-  public AdaptiveVideoTrackSelection(TrackGroup group, int[] tracks,
-      BandwidthMeter bandwidthMeter) {
-    this (group, tracks, bandwidthMeter, DEFAULT_MAX_INITIAL_BITRATE,
-        DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS,
-        DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS,
-        DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS, DEFAULT_BANDWIDTH_FRACTION);
-  }
-
-  /**
-   * @param group The {@link TrackGroup}. Must not be null.
-   * @param tracks The indices of the selected tracks within the {@link TrackGroup}. Must not be
-   *     null or empty. May be in any order.
-   * @param bandwidthMeter Provides an estimate of the currently available bandwidth.
-   * @param maxInitialBitrate The maximum bitrate in bits per second that should be assumed when a
-   *     bandwidth estimate is unavailable.
-   * @param minDurationForQualityIncreaseMs The minimum duration of buffered data required for the
-   *     selected track to switch to one of higher quality.
-   * @param maxDurationForQualityDecreaseMs The maximum duration of buffered data required for the
-   *     selected track to switch to one of lower quality.
-   * @param minDurationToRetainAfterDiscardMs When switching to a track of significantly higher
-   *     quality, the selection may indicate that media already buffered at the lower quality can
-   *     be discarded to speed up the switch. This is the minimum duration of media that must be
-   *     retained at the lower quality.
-   * @param bandwidthFraction The fraction of the available bandwidth that the selection should
-   *     consider available for use. Setting to a value less than 1 is recommended to account
-   *     for inaccuracies in the bandwidth estimator.
-   */
-  public AdaptiveVideoTrackSelection(TrackGroup group, int[] tracks, BandwidthMeter bandwidthMeter,
-      int maxInitialBitrate, long minDurationForQualityIncreaseMs,
-      long maxDurationForQualityDecreaseMs, long minDurationToRetainAfterDiscardMs,
-      float bandwidthFraction) {
-    super(group, tracks);
-
-    this.bandwidthMeter = bandwidthMeter;
-    this.maxInitialBitrate = maxInitialBitrate;
-    this.minDurationForQualityIncreaseUs = minDurationForQualityIncreaseMs * 1000L;
-    this.maxDurationForQualityDecreaseUs = maxDurationForQualityDecreaseMs * 1000L;
-    this.minDurationToRetainAfterDiscardUs = minDurationToRetainAfterDiscardMs * 1000L;
-    this.bandwidthFraction = bandwidthFraction;
-    selectedIndex = determineIdealSelectedIndex(Long.MIN_VALUE);
-    reason = C.SELECTION_REASON_INITIAL;
-  }
-
-  @Override
-  public void updateSelectedTrack(long bufferedDurationUs) {
-    // 如何更新选中的额Track呢?
-    long nowMs = SystemClock.elapsedRealtime();
-
-    // Get the current and ideal selections.
-    int currentSelectedIndex = selectedIndex;
-    Format currentFormat = getSelectedFormat();
-
-    // 理想的Format
-    int idealSelectedIndex = determineIdealSelectedIndex(nowMs);
-    Format idealFormat = getFormat(idealSelectedIndex);
-
-    // Assume we can switch to the ideal selection.
-    selectedIndex = idealSelectedIndex;
-
-    // Revert back to the current selection if conditions are not suitable for switching.
-    if (currentFormat != null && !isBlacklisted(selectedIndex, nowMs)) {
-
-      // 如果birate升高了
-      if (idealFormat.bitrate > currentFormat.bitrate
-          && bufferedDurationUs < minDurationForQualityIncreaseUs) {
-        // The ideal track is a higher quality, but we have insufficient buffer to safely switch
-        // up. Defer switching up for now.
-        // 要切换到高码率，则需要有足够的buffer时间
-        selectedIndex = currentSelectedIndex;
-
-      } else if (idealFormat.bitrate < currentFormat.bitrate
-          && bufferedDurationUs >= maxDurationForQualityDecreaseUs) {
-        // The ideal track is a lower quality, but we have sufficient buffer to defer switching
-        // down for now.
-        // 如果我们的高清码率的视频buffer足够多，那么我们也可以不着急切换variant(format)
-        selectedIndex = currentSelectedIndex;
-      }
+        // 如果有变化，则标志位自适应变化
+        // If we adapted, update the trigger.
+        if (selectedIndex != currentSelectedIndex) {
+            reason = C.SELECTION_REASON_ADAPTIVE;
+        }
     }
 
-    // 如果有变化，则标志位自适应变化
-    // If we adapted, update the trigger.
-    if (selectedIndex != currentSelectedIndex) {
-      reason = C.SELECTION_REASON_ADAPTIVE;
+    @Override
+    public int getSelectedIndex() {
+        return selectedIndex;
     }
-  }
-
-  @Override
-  public int getSelectedIndex() {
-    return selectedIndex;
-  }
-
-  @Override
-  public int getSelectionReason() {
-    return reason;
-  }
-
-  @Override
-  public Object getSelectionData() {
-    return null;
-  }
-
-  @Override
-  public int evaluateQueueSize(long playbackPositionUs, List<? extends MediaChunk> queue) {
-    if (queue.isEmpty()) {
-      return 0;
+
+    @Override
+    public int getSelectionReason() {
+        return reason;
     }
 
-    // 评估需要保留的queue的size
-    int queueSize = queue.size();
-    long bufferedDurationUs = queue.get(queueSize - 1).endTimeUs - playbackPositionUs;
-    // 本来就不够，不能扔
-    if (bufferedDurationUs < minDurationToRetainAfterDiscardUs) {
-      return queueSize;
+    @Override
+    public Object getSelectionData() {
+        return null;
     }
 
+    @Override
+    public int evaluateQueueSize(long playbackPositionUs, List<? extends MediaChunk> queue) {
+        if (queue.isEmpty()) {
+            return 0;
+        }
+
+        // 评估需要保留的queue的size
+        int queueSize = queue.size();
+        long bufferedDurationUs = queue.get(queueSize - 1).endTimeUs - playbackPositionUs;
+        // 本来就不够，不能扔
+        if (bufferedDurationUs < minDurationToRetainAfterDiscardUs) {
+            return queueSize;
+        }
+
 
-    int idealSelectedIndex = determineIdealSelectedIndex(SystemClock.elapsedRealtime());
-    Format idealFormat = getFormat(idealSelectedIndex);
-    // Discard from the first SD chunk beyond minDurationToRetainAfterDiscardUs whose resolution and
-    // bitrate are both lower than the ideal track.
-    for (int i = 0; i < queueSize; i++) {
-      MediaChunk chunk = queue.get(i);
-      long durationBeforeThisChunkUs = chunk.startTimeUs - playbackPositionUs;
-
-      // 保证有足够的视频，并且chunk中的事情质量不是很高，则可以扔掉部分
-      if (durationBeforeThisChunkUs >= minDurationToRetainAfterDiscardUs
-          && chunk.trackFormat.bitrate < idealFormat.bitrate
-          && chunk.trackFormat.height < idealFormat.height
-          && chunk.trackFormat.height < 720 && chunk.trackFormat.width < 1280) {
-        return i;
-      }
+        int idealSelectedIndex = determineIdealSelectedIndex(SystemClock.elapsedRealtime());
+        Format idealFormat = getFormat(idealSelectedIndex);
+        // Discard from the first SD chunk beyond minDurationToRetainAfterDiscardUs whose resolution and
+        // bitrate are both lower than the ideal track.
+        for (int i = 0; i < queueSize; i++) {
+            MediaChunk chunk = queue.get(i);
+            long durationBeforeThisChunkUs = chunk.startTimeUs - playbackPositionUs;
+
+            // 保证有足够的视频，并且chunk中的事情质量不是很高，则可以扔掉部分
+            if (durationBeforeThisChunkUs >= minDurationToRetainAfterDiscardUs
+                    && chunk.trackFormat.bitrate < idealFormat.bitrate
+                    && chunk.trackFormat.height < idealFormat.height
+                    && chunk.trackFormat.height < 720 && chunk.trackFormat.width < 1280) {
+                return i;
+            }
+        }
+        return queueSize;
     }
-    return queueSize;
-  }
-
-  /**
-   * Computes the ideal selected index ignoring buffer health.
-   *
-   * @param nowMs The current time in the timebase of {@link SystemClock#elapsedRealtime()}, or
-   *     {@link Long#MIN_VALUE} to ignore blacklisting.
-   */
-  private int determineIdealSelectedIndex(long nowMs) {
-
-    // 确定理想的Index
-    // 1. 估计的bitrate
-    long bitrateEstimate = bandwidthMeter.getBitrateEstimate();
-    // 有效的Bitrate
-    // 最大的初始bitrate或者估算的: 0.75
-    long effectiveBitrate = bitrateEstimate == BandwidthMeter.NO_ESTIMATE ? maxInitialBitrate : (long) (bitrateEstimate * bandwidthFraction);
-
-    int lowestBitrateNonBlacklistedIndex = 0;
-    for (int i = 0; i < length; i++) {
-      if (nowMs == Long.MIN_VALUE || !isBlacklisted(i, nowMs)) {
-        // formats的码率从高到低变化
-        Format format = getFormat(i);
-
-        // 直到找到一个满足带宽需要的Format
-        if (format.bitrate <= effectiveBitrate) {
-          return i;
-        } else {
-          // 不满足条件，但是带宽最小的Format
-          lowestBitrateNonBlacklistedIndex = i;
+
+    /**
+     * Computes the ideal selected index ignoring buffer health.
+     *
+     * @param nowMs The current time in the timebase of {@link SystemClock#elapsedRealtime()}, or
+     *              {@link Long#MIN_VALUE} to ignore blacklisting.
+     */
+    private int determineIdealSelectedIndex(long nowMs) {
+
+        // 确定理想的Index
+        // 1. 估计的bitrate
+        long bitrateEstimate = bandwidthMeter.getBitrateEstimate();
+        // 有效的Bitrate
+        // 最大的初始bitrate或者估算的: 0.75
+        long effectiveBitrate = bitrateEstimate == BandwidthMeter.NO_ESTIMATE ? maxInitialBitrate : (long) (bitrateEstimate * bandwidthFraction);
+
+        int lowestBitrateNonBlacklistedIndex = 0;
+        for (int i = 0; i < length; i++) {
+            if (nowMs == Long.MIN_VALUE || !isBlacklisted(i, nowMs)) {
+                // formats的码率从高到低变化
+                Format format = getFormat(i);
+
+                // 直到找到一个满足带宽需要的Format
+                if (format.bitrate <= effectiveBitrate) {
+                    return i;
+                } else {
+                    // 不满足条件，但是带宽最小的Format
+                    lowestBitrateNonBlacklistedIndex = i;
+                }
+            }
         }
-      }
+        return lowestBitrateNonBlacklistedIndex;
     }
-    return lowestBitrateNonBlacklistedIndex;
-  }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
index 7fa2e4776e..88abc8a511 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
@@ -16,11 +16,13 @@
 package com.google.android.exoplayer2.trackselection;
 
 import android.os.SystemClock;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
 import com.google.android.exoplayer2.util.Assertions;
+
 import java.util.Arrays;
 import java.util.Comparator;
 import java.util.List;
@@ -30,169 +32,169 @@
  */
 public abstract class BaseTrackSelection implements TrackSelection {
 
-  /**
-   * The selected {@link TrackGroup}.
-   */
-  protected final TrackGroup group;
-  /**
-   * The number of selected tracks within the {@link TrackGroup}. Always greater than zero.
-   */
-  protected final int length;
-  /**
-   * The indices of the selected tracks in {@link #group}, in order of decreasing bandwidth.
-   */
-  protected final int[] tracks;
-
-  /**
-   * The {@link Format}s of the selected tracks, in order of decreasing bandwidth.
-   * 所需要的带宽从大到小排列
-   */
-  private final Format[] formats;
-  /**
-   * Selected track blacklist timestamps, in order of decreasing bandwidth.
-   */
-  private final long[] blacklistUntilTimes;
-
-  // Lazily initialized hashcode.
-  private int hashCode;
-
-  /**
-   * @param group The {@link TrackGroup}. Must not be null.
-   * @param tracks The indices of the selected tracks within the {@link TrackGroup}. Must not be
-   *     null or empty. May be in any order.
-   */
-  public BaseTrackSelection(TrackGroup group, int... tracks) {
-    Assertions.checkState(tracks.length > 0);
-    this.group = Assertions.checkNotNull(group);
-    this.length = tracks.length;
-
-    // Set the formats, sorted in order of decreasing bandwidth.
-    formats = new Format[length];
-    for (int i = 0; i < tracks.length; i++) {
-      formats[i] = group.getFormat(tracks[i]);
+    /**
+     * The selected {@link TrackGroup}.
+     */
+    protected final TrackGroup group;
+    /**
+     * The number of selected tracks within the {@link TrackGroup}. Always greater than zero.
+     */
+    protected final int length;
+    /**
+     * The indices of the selected tracks in {@link #group}, in order of decreasing bandwidth.
+     */
+    protected final int[] tracks;
+
+    /**
+     * The {@link Format}s of the selected tracks, in order of decreasing bandwidth.
+     * 所需要的带宽从大到小排列
+     */
+    private final Format[] formats;
+    /**
+     * Selected track blacklist timestamps, in order of decreasing bandwidth.
+     */
+    private final long[] blacklistUntilTimes;
+
+    // Lazily initialized hashcode.
+    private int hashCode;
+
+    /**
+     * @param group  The {@link TrackGroup}. Must not be null.
+     * @param tracks The indices of the selected tracks within the {@link TrackGroup}. Must not be
+     *               null or empty. May be in any order.
+     */
+    public BaseTrackSelection(TrackGroup group, int... tracks) {
+        Assertions.checkState(tracks.length > 0);
+        this.group = Assertions.checkNotNull(group);
+        this.length = tracks.length;
+
+        // Set the formats, sorted in order of decreasing bandwidth.
+        formats = new Format[length];
+        for (int i = 0; i < tracks.length; i++) {
+            formats[i] = group.getFormat(tracks[i]);
+        }
+        Arrays.sort(formats, new DecreasingBandwidthComparator());
+
+        // Set the format indices in the same order.
+        this.tracks = new int[length];
+        for (int i = 0; i < length; i++) {
+            this.tracks[i] = group.indexOf(formats[i]);
+        }
+        blacklistUntilTimes = new long[length];
+    }
+
+    @Override
+    public final TrackGroup getTrackGroup() {
+        return group;
     }
-    Arrays.sort(formats, new DecreasingBandwidthComparator());
 
-    // Set the format indices in the same order.
-    this.tracks = new int[length];
-    for (int i = 0; i < length; i++) {
-      this.tracks[i] = group.indexOf(formats[i]);
+    @Override
+    public final int length() {
+        return tracks.length;
     }
-    blacklistUntilTimes = new long[length];
-  }
-
-  @Override
-  public final TrackGroup getTrackGroup() {
-    return group;
-  }
-
-  @Override
-  public final int length() {
-    return tracks.length;
-  }
-
-  @Override
-  public final Format getFormat(int index) {
-    return formats[index];
-  }
-
-  @Override
-  public final int getIndexInTrackGroup(int index) {
-    return tracks[index];
-  }
-
-  @Override
-  public final int indexOf(Format format) {
-    for (int i = 0; i < length; i++) {
-      if (formats[i] == format) {
-        return i;
-      }
+
+    @Override
+    public final Format getFormat(int index) {
+        return formats[index];
     }
-    return C.INDEX_UNSET;
-  }
-
-  @Override
-  public final int indexOf(int indexInTrackGroup) {
-    for (int i = 0; i < length; i++) {
-      if (tracks[i] == indexInTrackGroup) {
-        return i;
-      }
+
+    @Override
+    public final int getIndexInTrackGroup(int index) {
+        return tracks[index];
+    }
+
+    @Override
+    public final int indexOf(Format format) {
+        for (int i = 0; i < length; i++) {
+            if (formats[i] == format) {
+                return i;
+            }
+        }
+        return C.INDEX_UNSET;
+    }
+
+    @Override
+    public final int indexOf(int indexInTrackGroup) {
+        for (int i = 0; i < length; i++) {
+            if (tracks[i] == indexInTrackGroup) {
+                return i;
+            }
+        }
+        return C.INDEX_UNSET;
     }
-    return C.INDEX_UNSET;
-  }
-
-  @Override
-  public final Format getSelectedFormat() {
-    return formats[getSelectedIndex()];
-  }
-
-  @Override
-  public final int getSelectedIndexInTrackGroup() {
-    return tracks[getSelectedIndex()];
-  }
-
-  @Override
-  public int evaluateQueueSize(long playbackPositionUs, List<? extends MediaChunk> queue) {
-    return queue.size();
-  }
-
-  @Override
-  public final boolean blacklist(int index, long blacklistDurationMs) {
-    long nowMs = SystemClock.elapsedRealtime();
-    boolean canBlacklist = isBlacklisted(index, nowMs);
-    for (int i = 0; i < length && !canBlacklist; i++) {
-      canBlacklist = i != index && !isBlacklisted(i, nowMs);
+
+    @Override
+    public final Format getSelectedFormat() {
+        return formats[getSelectedIndex()];
     }
-    if (!canBlacklist) {
-      return false;
+
+    @Override
+    public final int getSelectedIndexInTrackGroup() {
+        return tracks[getSelectedIndex()];
     }
-    blacklistUntilTimes[index] = Math.max(blacklistUntilTimes[index], nowMs + blacklistDurationMs);
-    return true;
-  }
-
-  /**
-   * Returns whether the track at the specified index in the selection is blaclisted.
-   *
-   * @param index The index of the track in the selection.
-   * @param nowMs The current time in the timebase of {@link SystemClock#elapsedRealtime()}.
-   */
-  protected final boolean isBlacklisted(int index, long nowMs) {
-    return blacklistUntilTimes[index] > nowMs;
-  }
-
-  // Object overrides.
-
-  @Override
-  public int hashCode() {
-    if (hashCode == 0) {
-      hashCode = 31 * System.identityHashCode(group) + Arrays.hashCode(tracks);
+
+    @Override
+    public int evaluateQueueSize(long playbackPositionUs, List<? extends MediaChunk> queue) {
+        return queue.size();
     }
-    return hashCode;
-  }
 
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj) {
-      return true;
+    @Override
+    public final boolean blacklist(int index, long blacklistDurationMs) {
+        long nowMs = SystemClock.elapsedRealtime();
+        boolean canBlacklist = isBlacklisted(index, nowMs);
+        for (int i = 0; i < length && !canBlacklist; i++) {
+            canBlacklist = i != index && !isBlacklisted(i, nowMs);
+        }
+        if (!canBlacklist) {
+            return false;
+        }
+        blacklistUntilTimes[index] = Math.max(blacklistUntilTimes[index], nowMs + blacklistDurationMs);
+        return true;
     }
-    if (obj == null || getClass() != obj.getClass()) {
-      return false;
+
+    /**
+     * Returns whether the track at the specified index in the selection is blaclisted.
+     *
+     * @param index The index of the track in the selection.
+     * @param nowMs The current time in the timebase of {@link SystemClock#elapsedRealtime()}.
+     */
+    protected final boolean isBlacklisted(int index, long nowMs) {
+        return blacklistUntilTimes[index] > nowMs;
     }
-    BaseTrackSelection other = (BaseTrackSelection) obj;
-    return group == other.group && Arrays.equals(tracks, other.tracks);
-  }
 
-  /**
-   * Sorts {@link Format} objects in order of decreasing bandwidth.
-   * 按照带宽从高到低排序
-   */
-  private static final class DecreasingBandwidthComparator implements Comparator<Format> {
+    // Object overrides.
+
+    @Override
+    public int hashCode() {
+        if (hashCode == 0) {
+            hashCode = 31 * System.identityHashCode(group) + Arrays.hashCode(tracks);
+        }
+        return hashCode;
+    }
 
     @Override
-    public int compare(Format a, Format b) {
-      return b.bitrate - a.bitrate;
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null || getClass() != obj.getClass()) {
+            return false;
+        }
+        BaseTrackSelection other = (BaseTrackSelection) obj;
+        return group == other.group && Arrays.equals(tracks, other.tracks);
     }
 
-  }
+    /**
+     * Sorts {@link Format} objects in order of decreasing bandwidth.
+     * 按照带宽从高到低排序
+     */
+    private static final class DecreasingBandwidthComparator implements Comparator<Format> {
+
+        @Override
+        public int compare(Format a, Format b) {
+            return b.bitrate - a.bitrate;
+        }
+
+    }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
index 79979401f7..5a8c963de7 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
@@ -18,6 +18,7 @@
 import android.content.Context;
 import android.graphics.Point;
 import android.text.TextUtils;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
@@ -26,6 +27,7 @@
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
+
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
@@ -38,789 +40,789 @@
  */
 public class DefaultTrackSelector extends MappingTrackSelector {
 
-  /**
-   * Holder for available configurations for the {@link DefaultTrackSelector}.
-   */
-  public static final class Parameters {
+    /**
+     * Holder for available configurations for the {@link DefaultTrackSelector}.
+     */
+    public static final class Parameters {
+
+        // Audio.
+        public final String preferredAudioLanguage;
+
+        // Text.
+        public final String preferredTextLanguage;
+
+        // Video.
+        public final boolean allowMixedMimeAdaptiveness;
+        public final boolean allowNonSeamlessAdaptiveness;
+        public final int maxVideoWidth;
+        public final int maxVideoHeight;
+        public final boolean exceedVideoConstraintsIfNecessary;
+        public final boolean exceedRendererCapabilitiesIfNecessary;
+        public final int viewportWidth;
+        public final int viewportHeight;
+        public final boolean orientationMayChange;
+
+        /**
+         * Constructor with default selection parameters:
+         * <ul>
+         * <li>No preferred audio language is set.</li>
+         * <li>No preferred text language is set.</li>
+         * <li>Adaptation between different mime types is not allowed.</li>
+         * <li>Non seamless adaptation is allowed.</li>
+         * <li>No max limit for video width/height.</li>
+         * <li>Video constraints are exceeded if no supported selection can be made otherwise.</li>
+         * <li>Renderer capabilities are exceeded if no supported selection can be made.</li>
+         * <li>No viewport width/height constraints are set.</li>
+         * </ul>
+         */
+        public Parameters() {
+            this(null, null, false, true, Integer.MAX_VALUE, Integer.MAX_VALUE, true, true,
+                    Integer.MAX_VALUE, Integer.MAX_VALUE, true);
+        }
 
-    // Audio.
-    public final String preferredAudioLanguage;
+        /**
+         * @param preferredAudioLanguage                The preferred language for audio, as well as for forced text
+         *                                              tracks as defined by RFC 5646. {@code null} to select the default track, or first track
+         *                                              if there's no default.
+         * @param preferredTextLanguage                 The preferred language for text tracks as defined by RFC 5646.
+         *                                              {@code null} to select the default track, or first track if there's no default.
+         * @param allowMixedMimeAdaptiveness            Whether to allow selections to contain mixed mime types.
+         * @param allowNonSeamlessAdaptiveness          Whether non-seamless adaptation is allowed.
+         * @param maxVideoWidth                         Maximum allowed video width.
+         * @param maxVideoHeight                        Maximum allowed video height.
+         * @param exceedVideoConstraintsIfNecessary     Whether to exceed video constraints when no
+         *                                              selection can be made otherwise.
+         * @param exceedRendererCapabilitiesIfNecessary Whether to exceed renderer capabilities when no
+         *                                              selection can be made otherwise.
+         * @param viewportWidth                         Viewport width in pixels.
+         * @param viewportHeight                        Viewport height in pixels.
+         * @param orientationMayChange                  Whether orientation may change during playback.
+         */
+        public Parameters(String preferredAudioLanguage, String preferredTextLanguage,
+                          boolean allowMixedMimeAdaptiveness, boolean allowNonSeamlessAdaptiveness,
+                          int maxVideoWidth, int maxVideoHeight, boolean exceedVideoConstraintsIfNecessary,
+                          boolean exceedRendererCapabilitiesIfNecessary, int viewportWidth, int viewportHeight,
+                          boolean orientationMayChange) {
+            this.preferredAudioLanguage = preferredAudioLanguage;
+            this.preferredTextLanguage = preferredTextLanguage;
+            this.allowMixedMimeAdaptiveness = allowMixedMimeAdaptiveness;
+            this.allowNonSeamlessAdaptiveness = allowNonSeamlessAdaptiveness;
+            this.maxVideoWidth = maxVideoWidth;
+            this.maxVideoHeight = maxVideoHeight;
+            this.exceedVideoConstraintsIfNecessary = exceedVideoConstraintsIfNecessary;
+            this.exceedRendererCapabilitiesIfNecessary = exceedRendererCapabilitiesIfNecessary;
+            this.viewportWidth = viewportWidth;
+            this.viewportHeight = viewportHeight;
+            this.orientationMayChange = orientationMayChange;
+        }
 
-    // Text.
-    public final String preferredTextLanguage;
+        /**
+         * Returns a {@link Parameters} instance with the provided preferred language for audio and
+         * forced text tracks.
+         *
+         * @param preferredAudioLanguage The preferred language as defined by RFC 5646. {@code null} to
+         *                               select the default track, or first track if there's no default.
+         * @return A {@link Parameters} instance with the provided preferred language for audio and
+         * forced text tracks.
+         */
+        public Parameters withPreferredAudioLanguage(String preferredAudioLanguage) {
+            preferredAudioLanguage = Util.normalizeLanguageCode(preferredAudioLanguage);
+            if (TextUtils.equals(preferredAudioLanguage, this.preferredAudioLanguage)) {
+                return this;
+            }
+            return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+                    allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
+                    exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
+                    viewportHeight, orientationMayChange);
+        }
 
-    // Video.
-    public final boolean allowMixedMimeAdaptiveness;
-    public final boolean allowNonSeamlessAdaptiveness;
-    public final int maxVideoWidth;
-    public final int maxVideoHeight;
-    public final boolean exceedVideoConstraintsIfNecessary;
-    public final boolean exceedRendererCapabilitiesIfNecessary;
-    public final int viewportWidth;
-    public final int viewportHeight;
-    public final boolean orientationMayChange;
+        /**
+         * Returns a {@link Parameters} instance with the provided preferred language for text tracks.
+         *
+         * @param preferredTextLanguage The preferred language as defined by RFC 5646. {@code null} to
+         *                              select the default track, or no track if there's no default.
+         * @return A {@link Parameters} instance with the provided preferred language for text tracks.
+         */
+        public Parameters withPreferredTextLanguage(String preferredTextLanguage) {
+            preferredTextLanguage = Util.normalizeLanguageCode(preferredTextLanguage);
+            if (TextUtils.equals(preferredTextLanguage, this.preferredTextLanguage)) {
+                return this;
+            }
+            return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+                    allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
+                    exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
+                    viewportHeight, orientationMayChange);
+        }
 
-    /**
-     * Constructor with default selection parameters:
-     * <ul>
-     *   <li>No preferred audio language is set.</li>
-     *   <li>No preferred text language is set.</li>
-     *   <li>Adaptation between different mime types is not allowed.</li>
-     *   <li>Non seamless adaptation is allowed.</li>
-     *   <li>No max limit for video width/height.</li>
-     *   <li>Video constraints are exceeded if no supported selection can be made otherwise.</li>
-     *   <li>Renderer capabilities are exceeded if no supported selection can be made.</li>
-     *   <li>No viewport width/height constraints are set.</li>
-     * </ul>
-     */
-    public Parameters() {
-      this(null, null, false, true, Integer.MAX_VALUE, Integer.MAX_VALUE, true, true,
-          Integer.MAX_VALUE, Integer.MAX_VALUE, true);
-    }
+        /**
+         * Returns a {@link Parameters} instance with the provided mixed mime adaptiveness allowance.
+         *
+         * @param allowMixedMimeAdaptiveness Whether to allow selections to contain mixed mime types.
+         * @return A {@link Parameters} instance with the provided mixed mime adaptiveness allowance.
+         */
+        public Parameters withAllowMixedMimeAdaptiveness(boolean allowMixedMimeAdaptiveness) {
+            if (allowMixedMimeAdaptiveness == this.allowMixedMimeAdaptiveness) {
+                return this;
+            }
+            return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+                    allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
+                    exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
+                    viewportHeight, orientationMayChange);
+        }
 
-    /**
-     * @param preferredAudioLanguage The preferred language for audio, as well as for forced text
-     *     tracks as defined by RFC 5646. {@code null} to select the default track, or first track
-     *     if there's no default.
-     * @param preferredTextLanguage The preferred language for text tracks as defined by RFC 5646.
-     *     {@code null} to select the default track, or first track if there's no default.
-     * @param allowMixedMimeAdaptiveness Whether to allow selections to contain mixed mime types.
-     * @param allowNonSeamlessAdaptiveness Whether non-seamless adaptation is allowed.
-     * @param maxVideoWidth Maximum allowed video width.
-     * @param maxVideoHeight Maximum allowed video height.
-     * @param exceedVideoConstraintsIfNecessary Whether to exceed video constraints when no
-     *     selection can be made otherwise.
-     * @param exceedRendererCapabilitiesIfNecessary Whether to exceed renderer capabilities when no
-     *     selection can be made otherwise.
-     * @param viewportWidth Viewport width in pixels.
-     * @param viewportHeight Viewport height in pixels.
-     * @param orientationMayChange Whether orientation may change during playback.
-     */
-    public Parameters(String preferredAudioLanguage, String preferredTextLanguage,
-        boolean allowMixedMimeAdaptiveness, boolean allowNonSeamlessAdaptiveness,
-        int maxVideoWidth, int maxVideoHeight, boolean exceedVideoConstraintsIfNecessary,
-        boolean exceedRendererCapabilitiesIfNecessary, int viewportWidth, int viewportHeight,
-        boolean orientationMayChange) {
-      this.preferredAudioLanguage = preferredAudioLanguage;
-      this.preferredTextLanguage = preferredTextLanguage;
-      this.allowMixedMimeAdaptiveness = allowMixedMimeAdaptiveness;
-      this.allowNonSeamlessAdaptiveness = allowNonSeamlessAdaptiveness;
-      this.maxVideoWidth = maxVideoWidth;
-      this.maxVideoHeight = maxVideoHeight;
-      this.exceedVideoConstraintsIfNecessary = exceedVideoConstraintsIfNecessary;
-      this.exceedRendererCapabilitiesIfNecessary = exceedRendererCapabilitiesIfNecessary;
-      this.viewportWidth = viewportWidth;
-      this.viewportHeight = viewportHeight;
-      this.orientationMayChange = orientationMayChange;
-    }
+        /**
+         * Returns a {@link Parameters} instance with the provided seamless adaptiveness allowance.
+         *
+         * @param allowNonSeamlessAdaptiveness Whether non-seamless adaptation is allowed.
+         * @return A {@link Parameters} instance with the provided seamless adaptiveness allowance.
+         */
+        public Parameters withAllowNonSeamlessAdaptiveness(boolean allowNonSeamlessAdaptiveness) {
+            if (allowNonSeamlessAdaptiveness == this.allowNonSeamlessAdaptiveness) {
+                return this;
+            }
+            return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+                    allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
+                    exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
+                    viewportHeight, orientationMayChange);
+        }
 
-    /**
-     * Returns a {@link Parameters} instance with the provided preferred language for audio and
-     * forced text tracks.
-     *
-     * @param preferredAudioLanguage The preferred language as defined by RFC 5646. {@code null} to
-     *     select the default track, or first track if there's no default.
-     * @return A {@link Parameters} instance with the provided preferred language for audio and
-     *     forced text tracks.
-     */
-    public Parameters withPreferredAudioLanguage(String preferredAudioLanguage) {
-      preferredAudioLanguage = Util.normalizeLanguageCode(preferredAudioLanguage);
-      if (TextUtils.equals(preferredAudioLanguage, this.preferredAudioLanguage)) {
-        return this;
-      }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
-          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
-          viewportHeight, orientationMayChange);
-    }
+        /**
+         * Returns a {@link Parameters} instance with the provided max video size.
+         *
+         * @param maxVideoWidth  The max video width.
+         * @param maxVideoHeight The max video width.
+         * @return A {@link Parameters} instance with the provided max video size.
+         */
+        public Parameters withMaxVideoSize(int maxVideoWidth, int maxVideoHeight) {
+            if (maxVideoWidth == this.maxVideoWidth && maxVideoHeight == this.maxVideoHeight) {
+                return this;
+            }
+            return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+                    allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
+                    exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
+                    viewportHeight, orientationMayChange);
+        }
 
-    /**
-     * Returns a {@link Parameters} instance with the provided preferred language for text tracks.
-     *
-     * @param preferredTextLanguage The preferred language as defined by RFC 5646. {@code null} to
-     *     select the default track, or no track if there's no default.
-     * @return A {@link Parameters} instance with the provided preferred language for text tracks.
-     */
-    public Parameters withPreferredTextLanguage(String preferredTextLanguage) {
-      preferredTextLanguage = Util.normalizeLanguageCode(preferredTextLanguage);
-      if (TextUtils.equals(preferredTextLanguage, this.preferredTextLanguage)) {
-        return this;
-      }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
-          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
-          viewportHeight, orientationMayChange);
-    }
+        /**
+         * Equivalent to {@code withMaxVideoSize(1279, 719)}.
+         *
+         * @return A {@link Parameters} instance with maximum standard definition as maximum video size.
+         */
+        public Parameters withMaxVideoSizeSd() {
+            return withMaxVideoSize(1279, 719);
+        }
 
-    /**
-     * Returns a {@link Parameters} instance with the provided mixed mime adaptiveness allowance.
-     *
-     * @param allowMixedMimeAdaptiveness Whether to allow selections to contain mixed mime types.
-     * @return A {@link Parameters} instance with the provided mixed mime adaptiveness allowance.
-     */
-    public Parameters withAllowMixedMimeAdaptiveness(boolean allowMixedMimeAdaptiveness) {
-      if (allowMixedMimeAdaptiveness == this.allowMixedMimeAdaptiveness) {
-        return this;
-      }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
-          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
-          viewportHeight, orientationMayChange);
-    }
+        /**
+         * Equivalent to {@code withMaxVideoSize(Integer.MAX_VALUE, Integer.MAX_VALUE)}.
+         *
+         * @return A {@link Parameters} instance without video size constraints.
+         */
+        public Parameters withoutVideoSizeConstraints() {
+            return withMaxVideoSize(Integer.MAX_VALUE, Integer.MAX_VALUE);
+        }
 
-    /**
-     * Returns a {@link Parameters} instance with the provided seamless adaptiveness allowance.
-     *
-     * @param allowNonSeamlessAdaptiveness Whether non-seamless adaptation is allowed.
-     * @return A {@link Parameters} instance with the provided seamless adaptiveness allowance.
-     */
-    public Parameters withAllowNonSeamlessAdaptiveness(boolean allowNonSeamlessAdaptiveness) {
-      if (allowNonSeamlessAdaptiveness == this.allowNonSeamlessAdaptiveness) {
-        return this;
-      }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
-          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
-          viewportHeight, orientationMayChange);
-    }
+        /**
+         * Returns a {@link Parameters} instance with the provided
+         * {@code exceedVideoConstraintsIfNecessary} value.
+         *
+         * @param exceedVideoConstraintsIfNecessary Whether to exceed video constraints when no
+         *                                          selection can be made otherwise.
+         * @return A {@link Parameters} instance with the provided
+         * {@code exceedVideoConstraintsIfNecessary} value.
+         */
+        public Parameters withExceedVideoConstraintsIfNecessary(
+                boolean exceedVideoConstraintsIfNecessary) {
+            if (exceedVideoConstraintsIfNecessary == this.exceedVideoConstraintsIfNecessary) {
+                return this;
+            }
+            return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+                    allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
+                    exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
+                    viewportHeight, orientationMayChange);
+        }
 
-    /**
-     * Returns a {@link Parameters} instance with the provided max video size.
-     *
-     * @param maxVideoWidth The max video width.
-     * @param maxVideoHeight The max video width.
-     * @return A {@link Parameters} instance with the provided max video size.
-     */
-    public Parameters withMaxVideoSize(int maxVideoWidth, int maxVideoHeight) {
-      if (maxVideoWidth == this.maxVideoWidth && maxVideoHeight == this.maxVideoHeight) {
-        return this;
-      }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
-          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
-          viewportHeight, orientationMayChange);
-    }
+        /**
+         * Returns a {@link Parameters} instance with the provided
+         * {@code exceedRendererCapabilitiesIfNecessary} value.
+         *
+         * @param exceedRendererCapabilitiesIfNecessary Whether to exceed renderer capabilities when no
+         *                                              selection can be made otherwise.
+         * @return A {@link Parameters} instance with the provided
+         * {@code exceedRendererCapabilitiesIfNecessary} value.
+         */
+        public Parameters withExceedRendererCapabilitiesIfNecessary(
+                boolean exceedRendererCapabilitiesIfNecessary) {
+            if (exceedRendererCapabilitiesIfNecessary == this.exceedRendererCapabilitiesIfNecessary) {
+                return this;
+            }
+            return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+                    allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
+                    exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
+                    viewportHeight, orientationMayChange);
+        }
 
-    /**
-     * Equivalent to {@code withMaxVideoSize(1279, 719)}.
-     *
-     * @return A {@link Parameters} instance with maximum standard definition as maximum video size.
-     */
-    public Parameters withMaxVideoSizeSd() {
-      return withMaxVideoSize(1279, 719);
-    }
+        /**
+         * Returns a {@link Parameters} instance with the provided viewport size.
+         *
+         * @param viewportWidth        Viewport width in pixels.
+         * @param viewportHeight       Viewport height in pixels.
+         * @param orientationMayChange Whether orientation may change during playback.
+         * @return A {@link Parameters} instance with the provided viewport size.
+         */
+        public Parameters withViewportSize(int viewportWidth, int viewportHeight,
+                                           boolean orientationMayChange) {
+            if (viewportWidth == this.viewportWidth && viewportHeight == this.viewportHeight
+                    && orientationMayChange == this.orientationMayChange) {
+                return this;
+            }
+            return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+                    allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
+                    exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
+                    viewportHeight, orientationMayChange);
+        }
+
+        /**
+         * Returns a {@link Parameters} instance where the viewport size is obtained from the provided
+         * {@link Context}.
+         *
+         * @param context              The context to obtain the viewport size from.
+         * @param orientationMayChange Whether orientation may change during playback.
+         * @return A {@link Parameters} instance where the viewport size is obtained from the provided
+         * {@link Context}.
+         */
+        public Parameters withViewportSizeFromContext(Context context, boolean orientationMayChange) {
+            // Assume the viewport is fullscreen.
+            Point viewportSize = Util.getPhysicalDisplaySize(context);
+            return withViewportSize(viewportSize.x, viewportSize.y, orientationMayChange);
+        }
+
+        /**
+         * Equivalent to {@code withViewportSize(Integer.MAX_VALUE, Integer.MAX_VALUE, true)}.
+         *
+         * @return A {@link Parameters} instance without viewport size constraints.
+         */
+        public Parameters withoutViewportSizeConstraints() {
+            return withViewportSize(Integer.MAX_VALUE, Integer.MAX_VALUE, true);
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj) {
+                return true;
+            }
+            if (obj == null || getClass() != obj.getClass()) {
+                return false;
+            }
+            Parameters other = (Parameters) obj;
+            return allowMixedMimeAdaptiveness == other.allowMixedMimeAdaptiveness
+                    && allowNonSeamlessAdaptiveness == other.allowNonSeamlessAdaptiveness
+                    && maxVideoWidth == other.maxVideoWidth && maxVideoHeight == other.maxVideoHeight
+                    && exceedVideoConstraintsIfNecessary == other.exceedVideoConstraintsIfNecessary
+                    && exceedRendererCapabilitiesIfNecessary == other.exceedRendererCapabilitiesIfNecessary
+                    && orientationMayChange == other.orientationMayChange
+                    && viewportWidth == other.viewportWidth && viewportHeight == other.viewportHeight
+                    && TextUtils.equals(preferredAudioLanguage, other.preferredAudioLanguage)
+                    && TextUtils.equals(preferredTextLanguage, other.preferredTextLanguage);
+        }
+
+        @Override
+        public int hashCode() {
+            int result = preferredAudioLanguage.hashCode();
+            result = 31 * result + preferredTextLanguage.hashCode();
+            result = 31 * result + (allowMixedMimeAdaptiveness ? 1 : 0);
+            result = 31 * result + (allowNonSeamlessAdaptiveness ? 1 : 0);
+            result = 31 * result + maxVideoWidth;
+            result = 31 * result + maxVideoHeight;
+            result = 31 * result + (exceedVideoConstraintsIfNecessary ? 1 : 0);
+            result = 31 * result + (exceedRendererCapabilitiesIfNecessary ? 1 : 0);
+            result = 31 * result + (orientationMayChange ? 1 : 0);
+            result = 31 * result + viewportWidth;
+            result = 31 * result + viewportHeight;
+            return result;
+        }
 
-    /**
-     * Equivalent to {@code withMaxVideoSize(Integer.MAX_VALUE, Integer.MAX_VALUE)}.
-     *
-     * @return A {@link Parameters} instance without video size constraints.
-     */
-    public Parameters withoutVideoSizeConstraints() {
-      return withMaxVideoSize(Integer.MAX_VALUE, Integer.MAX_VALUE);
     }
 
     /**
-     * Returns a {@link Parameters} instance with the provided
-     * {@code exceedVideoConstraintsIfNecessary} value.
-     *
-     * @param exceedVideoConstraintsIfNecessary Whether to exceed video constraints when no
-     *     selection can be made otherwise.
-     * @return A {@link Parameters} instance with the provided
-     *     {@code exceedVideoConstraintsIfNecessary} value.
+     * If a dimension (i.e. width or height) of a video is greater or equal to this fraction of the
+     * corresponding viewport dimension, then the video is considered as filling the viewport (in that
+     * dimension).
      */
-    public Parameters withExceedVideoConstraintsIfNecessary(
-        boolean exceedVideoConstraintsIfNecessary) {
-      if (exceedVideoConstraintsIfNecessary == this.exceedVideoConstraintsIfNecessary) {
-        return this;
-      }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
-          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
-          viewportHeight, orientationMayChange);
-    }
+    private static final float FRACTION_TO_CONSIDER_FULLSCREEN = 0.98f;
+    private static final int[] NO_TRACKS = new int[0];
+    private static final int WITHIN_RENDERER_CAPABILITIES_BONUS = 1000;
+
+    private final TrackSelection.Factory adaptiveVideoTrackSelectionFactory;
+    private final AtomicReference<Parameters> paramsReference;
 
     /**
-     * Returns a {@link Parameters} instance with the provided
-     * {@code exceedRendererCapabilitiesIfNecessary} value.
-     *
-     * @param exceedRendererCapabilitiesIfNecessary Whether to exceed renderer capabilities when no
-     *     selection can be made otherwise.
-     * @return A {@link Parameters} instance with the provided
-     *     {@code exceedRendererCapabilitiesIfNecessary} value.
+     * Constructs an instance that does not support adaptive video.
      */
-    public Parameters withExceedRendererCapabilitiesIfNecessary(
-        boolean exceedRendererCapabilitiesIfNecessary) {
-      if (exceedRendererCapabilitiesIfNecessary == this.exceedRendererCapabilitiesIfNecessary) {
-        return this;
-      }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
-          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
-          viewportHeight, orientationMayChange);
+    public DefaultTrackSelector() {
+        this(null);
     }
 
     /**
-     * Returns a {@link Parameters} instance with the provided viewport size.
+     * Constructs an instance that uses a factory to create adaptive video track selections.
      *
-     * @param viewportWidth Viewport width in pixels.
-     * @param viewportHeight Viewport height in pixels.
-     * @param orientationMayChange Whether orientation may change during playback.
-     * @return A {@link Parameters} instance with the provided viewport size.
+     * @param adaptiveVideoTrackSelectionFactory A factory for adaptive video {@link TrackSelection}s,
+     *                                           or null if the selector should not support adaptive video.
      */
-    public Parameters withViewportSize(int viewportWidth, int viewportHeight,
-        boolean orientationMayChange) {
-      if (viewportWidth == this.viewportWidth && viewportHeight == this.viewportHeight
-          && orientationMayChange == this.orientationMayChange) {
-        return this;
-      }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
-          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
-          viewportHeight, orientationMayChange);
+    public DefaultTrackSelector(TrackSelection.Factory adaptiveVideoTrackSelectionFactory) {
+        this.adaptiveVideoTrackSelectionFactory = adaptiveVideoTrackSelectionFactory;
+        paramsReference = new AtomicReference<>(new Parameters());
     }
 
     /**
-     * Returns a {@link Parameters} instance where the viewport size is obtained from the provided
-     * {@link Context}.
+     * Atomically sets the provided parameters for track selection.
      *
-     * @param context The context to obtain the viewport size from.
-     * @param orientationMayChange Whether orientation may change during playback.
-     * @return A {@link Parameters} instance where the viewport size is obtained from the provided
-     *     {@link Context}.
+     * @param params The parameters for track selection.
      */
-    public Parameters withViewportSizeFromContext(Context context, boolean orientationMayChange) {
-      // Assume the viewport is fullscreen.
-      Point viewportSize = Util.getPhysicalDisplaySize(context);
-      return withViewportSize(viewportSize.x, viewportSize.y, orientationMayChange);
+    public void setParameters(Parameters params) {
+        Assertions.checkNotNull(params);
+        if (!paramsReference.getAndSet(params).equals(params)) {
+            invalidate();
+        }
     }
 
     /**
-     * Equivalent to {@code withViewportSize(Integer.MAX_VALUE, Integer.MAX_VALUE, true)}.
+     * Gets the current selection parameters.
      *
-     * @return A {@link Parameters} instance without viewport size constraints.
+     * @return The current selection parameters.
      */
-    public Parameters withoutViewportSizeConstraints() {
-      return withViewportSize(Integer.MAX_VALUE, Integer.MAX_VALUE, true);
+    public Parameters getParameters() {
+        return paramsReference.get();
     }
 
-    @Override
-    public boolean equals(Object obj) {
-      if (this == obj) {
-        return true;
-      }
-      if (obj == null || getClass() != obj.getClass()) {
-        return false;
-      }
-      Parameters other = (Parameters) obj;
-      return allowMixedMimeAdaptiveness == other.allowMixedMimeAdaptiveness
-          && allowNonSeamlessAdaptiveness == other.allowNonSeamlessAdaptiveness
-          && maxVideoWidth == other.maxVideoWidth && maxVideoHeight == other.maxVideoHeight
-          && exceedVideoConstraintsIfNecessary == other.exceedVideoConstraintsIfNecessary
-          && exceedRendererCapabilitiesIfNecessary == other.exceedRendererCapabilitiesIfNecessary
-          && orientationMayChange == other.orientationMayChange
-          && viewportWidth == other.viewportWidth && viewportHeight == other.viewportHeight
-          && TextUtils.equals(preferredAudioLanguage, other.preferredAudioLanguage)
-          && TextUtils.equals(preferredTextLanguage, other.preferredTextLanguage);
-    }
+    // MappingTrackSelector implementation.
 
     @Override
-    public int hashCode() {
-      int result = preferredAudioLanguage.hashCode();
-      result = 31 * result + preferredTextLanguage.hashCode();
-      result = 31 * result + (allowMixedMimeAdaptiveness ? 1 : 0);
-      result = 31 * result + (allowNonSeamlessAdaptiveness ? 1 : 0);
-      result = 31 * result + maxVideoWidth;
-      result = 31 * result + maxVideoHeight;
-      result = 31 * result + (exceedVideoConstraintsIfNecessary ? 1 : 0);
-      result = 31 * result + (exceedRendererCapabilitiesIfNecessary ? 1 : 0);
-      result = 31 * result + (orientationMayChange ? 1 : 0);
-      result = 31 * result + viewportWidth;
-      result = 31 * result + viewportHeight;
-      return result;
+    protected TrackSelection[] selectTracks(RendererCapabilities[] rendererCapabilities,
+                                            TrackGroupArray[] rendererTrackGroupArrays, int[][][] rendererFormatSupports)
+            throws ExoPlaybackException {
+        // Make a track selection for each renderer.
+        TrackSelection[] rendererTrackSelections = new TrackSelection[rendererCapabilities.length];
+        Parameters params = paramsReference.get();
+        for (int i = 0; i < rendererCapabilities.length; i++) {
+            switch (rendererCapabilities[i].getTrackType()) {
+                case C.TRACK_TYPE_VIDEO:
+                    rendererTrackSelections[i] = selectVideoTrack(rendererCapabilities[i],
+                            rendererTrackGroupArrays[i], rendererFormatSupports[i], params.maxVideoWidth,
+                            params.maxVideoHeight, params.allowNonSeamlessAdaptiveness,
+                            params.allowMixedMimeAdaptiveness, params.viewportWidth, params.viewportHeight,
+                            params.orientationMayChange, adaptiveVideoTrackSelectionFactory,
+                            params.exceedVideoConstraintsIfNecessary,
+                            params.exceedRendererCapabilitiesIfNecessary);
+                    break;
+                case C.TRACK_TYPE_AUDIO:
+                    rendererTrackSelections[i] = selectAudioTrack(rendererTrackGroupArrays[i],
+                            rendererFormatSupports[i], params.preferredAudioLanguage,
+                            params.exceedRendererCapabilitiesIfNecessary);
+                    break;
+                case C.TRACK_TYPE_TEXT:
+                    rendererTrackSelections[i] = selectTextTrack(rendererTrackGroupArrays[i],
+                            rendererFormatSupports[i], params.preferredTextLanguage,
+                            params.preferredAudioLanguage, params.exceedRendererCapabilitiesIfNecessary);
+                    break;
+                default:
+                    rendererTrackSelections[i] = selectOtherTrack(rendererCapabilities[i].getTrackType(),
+                            rendererTrackGroupArrays[i], rendererFormatSupports[i],
+                            params.exceedRendererCapabilitiesIfNecessary);
+                    break;
+            }
+        }
+        return rendererTrackSelections;
+    }
+
+    // Video track selection implementation.
+
+    protected TrackSelection selectVideoTrack(RendererCapabilities rendererCapabilities,
+                                              TrackGroupArray groups, int[][] formatSupport, int maxVideoWidth, int maxVideoHeight,
+                                              boolean allowNonSeamlessAdaptiveness, boolean allowMixedMimeAdaptiveness, int viewportWidth,
+                                              int viewportHeight, boolean orientationMayChange,
+                                              TrackSelection.Factory adaptiveVideoTrackSelectionFactory,
+                                              boolean exceedConstraintsIfNecessary, boolean exceedRendererCapabilitiesIfNecessary)
+            throws ExoPlaybackException {
+        TrackSelection selection = null;
+        if (adaptiveVideoTrackSelectionFactory != null) {
+            selection = selectAdaptiveVideoTrack(rendererCapabilities, groups, formatSupport,
+                    maxVideoWidth, maxVideoHeight, allowNonSeamlessAdaptiveness,
+                    allowMixedMimeAdaptiveness, viewportWidth, viewportHeight,
+                    orientationMayChange, adaptiveVideoTrackSelectionFactory);
+        }
+        if (selection == null) {
+            selection = selectFixedVideoTrack(groups, formatSupport, maxVideoWidth, maxVideoHeight,
+                    viewportWidth, viewportHeight, orientationMayChange, exceedConstraintsIfNecessary,
+                    exceedRendererCapabilitiesIfNecessary);
+        }
+        return selection;
+    }
+
+    private static TrackSelection selectAdaptiveVideoTrack(RendererCapabilities rendererCapabilities,
+                                                           TrackGroupArray groups, int[][] formatSupport, int maxVideoWidth, int maxVideoHeight,
+                                                           boolean allowNonSeamlessAdaptiveness, boolean allowMixedMimeAdaptiveness, int viewportWidth,
+                                                           int viewportHeight, boolean orientationMayChange,
+                                                           TrackSelection.Factory adaptiveVideoTrackSelectionFactory) throws ExoPlaybackException {
+        int requiredAdaptiveSupport = allowNonSeamlessAdaptiveness
+                ? (RendererCapabilities.ADAPTIVE_NOT_SEAMLESS | RendererCapabilities.ADAPTIVE_SEAMLESS)
+                : RendererCapabilities.ADAPTIVE_SEAMLESS;
+        boolean allowMixedMimeTypes = allowMixedMimeAdaptiveness
+                && (rendererCapabilities.supportsMixedMimeTypeAdaptation() & requiredAdaptiveSupport) != 0;
+        for (int i = 0; i < groups.length; i++) {
+            TrackGroup group = groups.get(i);
+            int[] adaptiveTracks = getAdaptiveTracksForGroup(group, formatSupport[i],
+                    allowMixedMimeTypes, requiredAdaptiveSupport, maxVideoWidth, maxVideoHeight,
+                    viewportWidth, viewportHeight, orientationMayChange);
+            if (adaptiveTracks.length > 0) {
+                return adaptiveVideoTrackSelectionFactory.createTrackSelection(group, adaptiveTracks);
+            }
+        }
+        return null;
     }
 
-  }
-
-  /**
-   * If a dimension (i.e. width or height) of a video is greater or equal to this fraction of the
-   * corresponding viewport dimension, then the video is considered as filling the viewport (in that
-   * dimension).
-   */
-  private static final float FRACTION_TO_CONSIDER_FULLSCREEN = 0.98f;
-  private static final int[] NO_TRACKS = new int[0];
-  private static final int WITHIN_RENDERER_CAPABILITIES_BONUS = 1000;
-
-  private final TrackSelection.Factory adaptiveVideoTrackSelectionFactory;
-  private final AtomicReference<Parameters> paramsReference;
-
-  /**
-   * Constructs an instance that does not support adaptive video.
-   */
-  public DefaultTrackSelector() {
-    this(null);
-  }
-
-  /**
-   * Constructs an instance that uses a factory to create adaptive video track selections.
-   *
-   * @param adaptiveVideoTrackSelectionFactory A factory for adaptive video {@link TrackSelection}s,
-   *     or null if the selector should not support adaptive video.
-   */
-  public DefaultTrackSelector(TrackSelection.Factory adaptiveVideoTrackSelectionFactory) {
-    this.adaptiveVideoTrackSelectionFactory = adaptiveVideoTrackSelectionFactory;
-    paramsReference = new AtomicReference<>(new Parameters());
-  }
-
-  /**
-   * Atomically sets the provided parameters for track selection.
-   *
-   * @param params The parameters for track selection.
-   */
-  public void setParameters(Parameters params) {
-    Assertions.checkNotNull(params);
-    if (!paramsReference.getAndSet(params).equals(params)) {
-      invalidate();
-    }
-  }
-
-  /**
-   * Gets the current selection parameters.
-   *
-   * @return The current selection parameters.
-   */
-  public Parameters getParameters() {
-    return paramsReference.get();
-  }
-
-  // MappingTrackSelector implementation.
-
-  @Override
-  protected TrackSelection[] selectTracks(RendererCapabilities[] rendererCapabilities,
-      TrackGroupArray[] rendererTrackGroupArrays, int[][][] rendererFormatSupports)
-      throws ExoPlaybackException {
-    // Make a track selection for each renderer.
-    TrackSelection[] rendererTrackSelections = new TrackSelection[rendererCapabilities.length];
-    Parameters params = paramsReference.get();
-    for (int i = 0; i < rendererCapabilities.length; i++) {
-      switch (rendererCapabilities[i].getTrackType()) {
-        case C.TRACK_TYPE_VIDEO:
-          rendererTrackSelections[i] = selectVideoTrack(rendererCapabilities[i],
-              rendererTrackGroupArrays[i], rendererFormatSupports[i], params.maxVideoWidth,
-              params.maxVideoHeight, params.allowNonSeamlessAdaptiveness,
-              params.allowMixedMimeAdaptiveness, params.viewportWidth, params.viewportHeight,
-              params.orientationMayChange, adaptiveVideoTrackSelectionFactory,
-              params.exceedVideoConstraintsIfNecessary,
-              params.exceedRendererCapabilitiesIfNecessary);
-          break;
-        case C.TRACK_TYPE_AUDIO:
-          rendererTrackSelections[i] = selectAudioTrack(rendererTrackGroupArrays[i],
-              rendererFormatSupports[i], params.preferredAudioLanguage,
-              params.exceedRendererCapabilitiesIfNecessary);
-          break;
-        case C.TRACK_TYPE_TEXT:
-          rendererTrackSelections[i] = selectTextTrack(rendererTrackGroupArrays[i],
-              rendererFormatSupports[i], params.preferredTextLanguage,
-              params.preferredAudioLanguage, params.exceedRendererCapabilitiesIfNecessary);
-          break;
-        default:
-          rendererTrackSelections[i] = selectOtherTrack(rendererCapabilities[i].getTrackType(),
-              rendererTrackGroupArrays[i], rendererFormatSupports[i],
-              params.exceedRendererCapabilitiesIfNecessary);
-          break;
-      }
-    }
-    return rendererTrackSelections;
-  }
-
-  // Video track selection implementation.
-
-  protected TrackSelection selectVideoTrack(RendererCapabilities rendererCapabilities,
-      TrackGroupArray groups, int[][] formatSupport, int maxVideoWidth, int maxVideoHeight,
-      boolean allowNonSeamlessAdaptiveness, boolean allowMixedMimeAdaptiveness, int viewportWidth,
-      int viewportHeight, boolean orientationMayChange,
-      TrackSelection.Factory adaptiveVideoTrackSelectionFactory,
-      boolean exceedConstraintsIfNecessary, boolean exceedRendererCapabilitiesIfNecessary)
-      throws ExoPlaybackException {
-    TrackSelection selection = null;
-    if (adaptiveVideoTrackSelectionFactory != null) {
-      selection = selectAdaptiveVideoTrack(rendererCapabilities, groups, formatSupport,
-          maxVideoWidth, maxVideoHeight, allowNonSeamlessAdaptiveness,
-          allowMixedMimeAdaptiveness, viewportWidth, viewportHeight,
-          orientationMayChange, adaptiveVideoTrackSelectionFactory);
-    }
-    if (selection == null) {
-      selection = selectFixedVideoTrack(groups, formatSupport, maxVideoWidth, maxVideoHeight,
-          viewportWidth, viewportHeight, orientationMayChange, exceedConstraintsIfNecessary,
-          exceedRendererCapabilitiesIfNecessary);
-    }
-    return selection;
-  }
-
-  private static TrackSelection selectAdaptiveVideoTrack(RendererCapabilities rendererCapabilities,
-      TrackGroupArray groups, int[][] formatSupport, int maxVideoWidth, int maxVideoHeight,
-      boolean allowNonSeamlessAdaptiveness, boolean allowMixedMimeAdaptiveness, int viewportWidth,
-      int viewportHeight, boolean orientationMayChange,
-      TrackSelection.Factory adaptiveVideoTrackSelectionFactory) throws ExoPlaybackException {
-    int requiredAdaptiveSupport = allowNonSeamlessAdaptiveness
-        ? (RendererCapabilities.ADAPTIVE_NOT_SEAMLESS | RendererCapabilities.ADAPTIVE_SEAMLESS)
-        : RendererCapabilities.ADAPTIVE_SEAMLESS;
-    boolean allowMixedMimeTypes = allowMixedMimeAdaptiveness
-        && (rendererCapabilities.supportsMixedMimeTypeAdaptation() & requiredAdaptiveSupport) != 0;
-    for (int i = 0; i < groups.length; i++) {
-      TrackGroup group = groups.get(i);
-      int[] adaptiveTracks = getAdaptiveTracksForGroup(group, formatSupport[i],
-          allowMixedMimeTypes, requiredAdaptiveSupport, maxVideoWidth, maxVideoHeight,
-          viewportWidth, viewportHeight, orientationMayChange);
-      if (adaptiveTracks.length > 0) {
-        return adaptiveVideoTrackSelectionFactory.createTrackSelection(group, adaptiveTracks);
-      }
-    }
-    return null;
-  }
-
-  private static int[] getAdaptiveTracksForGroup(TrackGroup group, int[] formatSupport,
-      boolean allowMixedMimeTypes, int requiredAdaptiveSupport, int maxVideoWidth,
-      int maxVideoHeight, int viewportWidth, int viewportHeight, boolean orientationMayChange) {
-    if (group.length < 2) {
-      return NO_TRACKS;
-    }
+    private static int[] getAdaptiveTracksForGroup(TrackGroup group, int[] formatSupport,
+                                                   boolean allowMixedMimeTypes, int requiredAdaptiveSupport, int maxVideoWidth,
+                                                   int maxVideoHeight, int viewportWidth, int viewportHeight, boolean orientationMayChange) {
+        if (group.length < 2) {
+            return NO_TRACKS;
+        }
 
-    List<Integer> selectedTrackIndices = getViewportFilteredTrackIndices(group, viewportWidth,
-        viewportHeight, orientationMayChange);
-    if (selectedTrackIndices.size() < 2) {
-      return NO_TRACKS;
-    }
+        List<Integer> selectedTrackIndices = getViewportFilteredTrackIndices(group, viewportWidth,
+                viewportHeight, orientationMayChange);
+        if (selectedTrackIndices.size() < 2) {
+            return NO_TRACKS;
+        }
 
-    String selectedMimeType = null;
-    if (!allowMixedMimeTypes) {
-      // Select the mime type for which we have the most adaptive tracks.
-      HashSet<String> seenMimeTypes = new HashSet<>();
-      int selectedMimeTypeTrackCount = 0;
-      for (int i = 0; i < selectedTrackIndices.size(); i++) {
-        int trackIndex = selectedTrackIndices.get(i);
-        String sampleMimeType = group.getFormat(trackIndex).sampleMimeType;
-        if (!seenMimeTypes.contains(sampleMimeType)) {
-          seenMimeTypes.add(sampleMimeType);
-          int countForMimeType = getAdaptiveTrackCountForMimeType(group, formatSupport,
-              requiredAdaptiveSupport, sampleMimeType, maxVideoWidth, maxVideoHeight,
-              selectedTrackIndices);
-          if (countForMimeType > selectedMimeTypeTrackCount) {
-            selectedMimeType = sampleMimeType;
-            selectedMimeTypeTrackCount = countForMimeType;
-          }
-        }
-      }
-    }
+        String selectedMimeType = null;
+        if (!allowMixedMimeTypes) {
+            // Select the mime type for which we have the most adaptive tracks.
+            HashSet<String> seenMimeTypes = new HashSet<>();
+            int selectedMimeTypeTrackCount = 0;
+            for (int i = 0; i < selectedTrackIndices.size(); i++) {
+                int trackIndex = selectedTrackIndices.get(i);
+                String sampleMimeType = group.getFormat(trackIndex).sampleMimeType;
+                if (!seenMimeTypes.contains(sampleMimeType)) {
+                    seenMimeTypes.add(sampleMimeType);
+                    int countForMimeType = getAdaptiveTrackCountForMimeType(group, formatSupport,
+                            requiredAdaptiveSupport, sampleMimeType, maxVideoWidth, maxVideoHeight,
+                            selectedTrackIndices);
+                    if (countForMimeType > selectedMimeTypeTrackCount) {
+                        selectedMimeType = sampleMimeType;
+                        selectedMimeTypeTrackCount = countForMimeType;
+                    }
+                }
+            }
+        }
 
-    // Filter by the selected mime type.
-    filterAdaptiveTrackCountForMimeType(group, formatSupport, requiredAdaptiveSupport,
-        selectedMimeType, maxVideoWidth, maxVideoHeight, selectedTrackIndices);
-
-    return selectedTrackIndices.size() < 2 ? NO_TRACKS : Util.toArray(selectedTrackIndices);
-  }
-
-  private static int getAdaptiveTrackCountForMimeType(TrackGroup group, int[] formatSupport,
-      int requiredAdaptiveSupport, String mimeType, int maxVideoWidth, int maxVideoHeight,
-      List<Integer> selectedTrackIndices) {
-    int adaptiveTrackCount = 0;
-    for (int i = 0; i < selectedTrackIndices.size(); i++) {
-      int trackIndex = selectedTrackIndices.get(i);
-      if (isSupportedAdaptiveVideoTrack(group.getFormat(trackIndex), mimeType,
-          formatSupport[trackIndex], requiredAdaptiveSupport, maxVideoWidth, maxVideoHeight)) {
-        adaptiveTrackCount++;
-      }
+        // Filter by the selected mime type.
+        filterAdaptiveTrackCountForMimeType(group, formatSupport, requiredAdaptiveSupport,
+                selectedMimeType, maxVideoWidth, maxVideoHeight, selectedTrackIndices);
+
+        return selectedTrackIndices.size() < 2 ? NO_TRACKS : Util.toArray(selectedTrackIndices);
     }
-    return adaptiveTrackCount;
-  }
-
-  private static void filterAdaptiveTrackCountForMimeType(TrackGroup group, int[] formatSupport,
-      int requiredAdaptiveSupport, String mimeType, int maxVideoWidth, int maxVideoHeight,
-      List<Integer> selectedTrackIndices) {
-    for (int i = selectedTrackIndices.size() - 1; i >= 0; i--) {
-      int trackIndex = selectedTrackIndices.get(i);
-      if (!isSupportedAdaptiveVideoTrack(group.getFormat(trackIndex), mimeType,
-          formatSupport[trackIndex], requiredAdaptiveSupport, maxVideoWidth, maxVideoHeight)) {
-        selectedTrackIndices.remove(i);
-      }
+
+    private static int getAdaptiveTrackCountForMimeType(TrackGroup group, int[] formatSupport,
+                                                        int requiredAdaptiveSupport, String mimeType, int maxVideoWidth, int maxVideoHeight,
+                                                        List<Integer> selectedTrackIndices) {
+        int adaptiveTrackCount = 0;
+        for (int i = 0; i < selectedTrackIndices.size(); i++) {
+            int trackIndex = selectedTrackIndices.get(i);
+            if (isSupportedAdaptiveVideoTrack(group.getFormat(trackIndex), mimeType,
+                    formatSupport[trackIndex], requiredAdaptiveSupport, maxVideoWidth, maxVideoHeight)) {
+                adaptiveTrackCount++;
+            }
+        }
+        return adaptiveTrackCount;
     }
-  }
-
-  private static boolean isSupportedAdaptiveVideoTrack(Format format, String mimeType,
-      int formatSupport, int requiredAdaptiveSupport, int maxVideoWidth, int maxVideoHeight) {
-    return isSupported(formatSupport, false) && ((formatSupport & requiredAdaptiveSupport) != 0)
-        && (mimeType == null || Util.areEqual(format.sampleMimeType, mimeType))
-        && (format.width == Format.NO_VALUE || format.width <= maxVideoWidth)
-        && (format.height == Format.NO_VALUE || format.height <= maxVideoHeight);
-  }
-
-  private static TrackSelection selectFixedVideoTrack(TrackGroupArray groups,
-      int[][] formatSupport, int maxVideoWidth, int maxVideoHeight, int viewportWidth,
-      int viewportHeight, boolean orientationMayChange, boolean exceedConstraintsIfNecessary,
-      boolean exceedRendererCapabilitiesIfNecessary) {
-    TrackGroup selectedGroup = null;
-    int selectedTrackIndex = 0;
-    int selectedTrackScore = 0;
-    int selectedPixelCount = Format.NO_VALUE;
-    for (int groupIndex = 0; groupIndex < groups.length; groupIndex++) {
-      TrackGroup trackGroup = groups.get(groupIndex);
-      List<Integer> selectedTrackIndices = getViewportFilteredTrackIndices(trackGroup,
-          viewportWidth, viewportHeight, orientationMayChange);
-      int[] trackFormatSupport = formatSupport[groupIndex];
-      for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
-        if (isSupported(trackFormatSupport[trackIndex], exceedRendererCapabilitiesIfNecessary)) {
-          Format format = trackGroup.getFormat(trackIndex);
-          boolean isWithinConstraints = selectedTrackIndices.contains(trackIndex)
-              && (format.width == Format.NO_VALUE || format.width <= maxVideoWidth)
-              && (format.height == Format.NO_VALUE || format.height <= maxVideoHeight);
-          if (!isWithinConstraints && !exceedConstraintsIfNecessary) {
-            // Track should not be selected.
-            continue;
-          }
-          int trackScore = isWithinConstraints ? 2 : 1;
-          if (isSupported(trackFormatSupport[trackIndex], false)) {
-            trackScore += WITHIN_RENDERER_CAPABILITIES_BONUS;
-          }
-          boolean selectTrack = trackScore > selectedTrackScore;
-          if (trackScore == selectedTrackScore) {
-            // Use the pixel count as a tie breaker. If we're within constraints prefer a higher
-            // pixel count, else prefer a lower count. If still tied then prefer the first track
-            // (i.e. the one that's already selected).
-            int pixelComparison = comparePixelCounts(format.getPixelCount(), selectedPixelCount);
-            selectTrack = isWithinConstraints ? pixelComparison > 0 : pixelComparison < 0;
-          }
-          if (selectTrack) {
-            selectedGroup = trackGroup;
-            selectedTrackIndex = trackIndex;
-            selectedTrackScore = trackScore;
-            selectedPixelCount = format.getPixelCount();
-          }
-        }
-      }
+
+    private static void filterAdaptiveTrackCountForMimeType(TrackGroup group, int[] formatSupport,
+                                                            int requiredAdaptiveSupport, String mimeType, int maxVideoWidth, int maxVideoHeight,
+                                                            List<Integer> selectedTrackIndices) {
+        for (int i = selectedTrackIndices.size() - 1; i >= 0; i--) {
+            int trackIndex = selectedTrackIndices.get(i);
+            if (!isSupportedAdaptiveVideoTrack(group.getFormat(trackIndex), mimeType,
+                    formatSupport[trackIndex], requiredAdaptiveSupport, maxVideoWidth, maxVideoHeight)) {
+                selectedTrackIndices.remove(i);
+            }
+        }
     }
-    return selectedGroup == null ? null
-        : new FixedTrackSelection(selectedGroup, selectedTrackIndex);
-  }
-
-  /**
-   * Compares two pixel counts for order. A known pixel count is considered greater than
-   * {@link Format#NO_VALUE}.
-   *
-   * @param first The first pixel count.
-   * @param second The second pixel count.
-   * @return A negative integer if the first pixel count is less than the second. Zero if they are
-   *     equal. A positive integer if the first pixel count is greater than the second.
-   */
-  private static int comparePixelCounts(int first, int second) {
-    return first == Format.NO_VALUE ? (second == Format.NO_VALUE ? 0 : -1)
-        : (second == Format.NO_VALUE ? 1 : (first - second));
-  }
-
-
-  // Audio track selection implementation.
-
-  protected TrackSelection selectAudioTrack(TrackGroupArray groups, int[][] formatSupport,
-      String preferredAudioLanguage, boolean exceedRendererCapabilitiesIfNecessary) {
-    TrackGroup selectedGroup = null;
-    int selectedTrackIndex = 0;
-    int selectedTrackScore = 0;
-    for (int groupIndex = 0; groupIndex < groups.length; groupIndex++) {
-      TrackGroup trackGroup = groups.get(groupIndex);
-      int[] trackFormatSupport = formatSupport[groupIndex];
-      for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
-        if (isSupported(trackFormatSupport[trackIndex], exceedRendererCapabilitiesIfNecessary)) {
-          Format format = trackGroup.getFormat(trackIndex);
-          boolean isDefault = (format.selectionFlags & C.SELECTION_FLAG_DEFAULT) != 0;
-          int trackScore;
-          if (formatHasLanguage(format, preferredAudioLanguage)) {
-            if (isDefault) {
-              trackScore = 4;
-            } else {
-              trackScore = 3;
+
+    private static boolean isSupportedAdaptiveVideoTrack(Format format, String mimeType,
+                                                         int formatSupport, int requiredAdaptiveSupport, int maxVideoWidth, int maxVideoHeight) {
+        return isSupported(formatSupport, false) && ((formatSupport & requiredAdaptiveSupport) != 0)
+                && (mimeType == null || Util.areEqual(format.sampleMimeType, mimeType))
+                && (format.width == Format.NO_VALUE || format.width <= maxVideoWidth)
+                && (format.height == Format.NO_VALUE || format.height <= maxVideoHeight);
+    }
+
+    private static TrackSelection selectFixedVideoTrack(TrackGroupArray groups,
+                                                        int[][] formatSupport, int maxVideoWidth, int maxVideoHeight, int viewportWidth,
+                                                        int viewportHeight, boolean orientationMayChange, boolean exceedConstraintsIfNecessary,
+                                                        boolean exceedRendererCapabilitiesIfNecessary) {
+        TrackGroup selectedGroup = null;
+        int selectedTrackIndex = 0;
+        int selectedTrackScore = 0;
+        int selectedPixelCount = Format.NO_VALUE;
+        for (int groupIndex = 0; groupIndex < groups.length; groupIndex++) {
+            TrackGroup trackGroup = groups.get(groupIndex);
+            List<Integer> selectedTrackIndices = getViewportFilteredTrackIndices(trackGroup,
+                    viewportWidth, viewportHeight, orientationMayChange);
+            int[] trackFormatSupport = formatSupport[groupIndex];
+            for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
+                if (isSupported(trackFormatSupport[trackIndex], exceedRendererCapabilitiesIfNecessary)) {
+                    Format format = trackGroup.getFormat(trackIndex);
+                    boolean isWithinConstraints = selectedTrackIndices.contains(trackIndex)
+                            && (format.width == Format.NO_VALUE || format.width <= maxVideoWidth)
+                            && (format.height == Format.NO_VALUE || format.height <= maxVideoHeight);
+                    if (!isWithinConstraints && !exceedConstraintsIfNecessary) {
+                        // Track should not be selected.
+                        continue;
+                    }
+                    int trackScore = isWithinConstraints ? 2 : 1;
+                    if (isSupported(trackFormatSupport[trackIndex], false)) {
+                        trackScore += WITHIN_RENDERER_CAPABILITIES_BONUS;
+                    }
+                    boolean selectTrack = trackScore > selectedTrackScore;
+                    if (trackScore == selectedTrackScore) {
+                        // Use the pixel count as a tie breaker. If we're within constraints prefer a higher
+                        // pixel count, else prefer a lower count. If still tied then prefer the first track
+                        // (i.e. the one that's already selected).
+                        int pixelComparison = comparePixelCounts(format.getPixelCount(), selectedPixelCount);
+                        selectTrack = isWithinConstraints ? pixelComparison > 0 : pixelComparison < 0;
+                    }
+                    if (selectTrack) {
+                        selectedGroup = trackGroup;
+                        selectedTrackIndex = trackIndex;
+                        selectedTrackScore = trackScore;
+                        selectedPixelCount = format.getPixelCount();
+                    }
+                }
             }
-          } else if (isDefault) {
-            trackScore = 2;
-          } else {
-            trackScore = 1;
-          }
-          if (isSupported(trackFormatSupport[trackIndex], false)) {
-            trackScore += WITHIN_RENDERER_CAPABILITIES_BONUS;
-          }
-          if (trackScore > selectedTrackScore) {
-            selectedGroup = trackGroup;
-            selectedTrackIndex = trackIndex;
-            selectedTrackScore = trackScore;
-          }
-        }
-      }
+        }
+        return selectedGroup == null ? null
+                : new FixedTrackSelection(selectedGroup, selectedTrackIndex);
     }
-    return selectedGroup == null ? null
-        : new FixedTrackSelection(selectedGroup, selectedTrackIndex);
-  }
-
-  // Text track selection implementation.
-
-  protected TrackSelection selectTextTrack(TrackGroupArray groups, int[][] formatSupport,
-      String preferredTextLanguage, String preferredAudioLanguage,
-      boolean exceedRendererCapabilitiesIfNecessary) {
-    TrackGroup selectedGroup = null;
-    int selectedTrackIndex = 0;
-    int selectedTrackScore = 0;
-    for (int groupIndex = 0; groupIndex < groups.length; groupIndex++) {
-      TrackGroup trackGroup = groups.get(groupIndex);
-      int[] trackFormatSupport = formatSupport[groupIndex];
-      for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
-        if (isSupported(trackFormatSupport[trackIndex], exceedRendererCapabilitiesIfNecessary)) {
-          Format format = trackGroup.getFormat(trackIndex);
-          boolean isDefault = (format.selectionFlags & C.SELECTION_FLAG_DEFAULT) != 0;
-          boolean isForced = (format.selectionFlags & C.SELECTION_FLAG_FORCED) != 0;
-          int trackScore;
-          if (formatHasLanguage(format, preferredTextLanguage)) {
-            if (isDefault) {
-              trackScore = 6;
-            } else if (!isForced) {
-              // Prefer non-forced to forced if a preferred text language has been specified. Where
-              // both are provided the non-forced track will usually contain the forced subtitles as
-              // a subset.
-              trackScore = 5;
-            } else {
-              trackScore = 4;
+
+    /**
+     * Compares two pixel counts for order. A known pixel count is considered greater than
+     * {@link Format#NO_VALUE}.
+     *
+     * @param first  The first pixel count.
+     * @param second The second pixel count.
+     * @return A negative integer if the first pixel count is less than the second. Zero if they are
+     * equal. A positive integer if the first pixel count is greater than the second.
+     */
+    private static int comparePixelCounts(int first, int second) {
+        return first == Format.NO_VALUE ? (second == Format.NO_VALUE ? 0 : -1)
+                : (second == Format.NO_VALUE ? 1 : (first - second));
+    }
+
+
+    // Audio track selection implementation.
+
+    protected TrackSelection selectAudioTrack(TrackGroupArray groups, int[][] formatSupport,
+                                              String preferredAudioLanguage, boolean exceedRendererCapabilitiesIfNecessary) {
+        TrackGroup selectedGroup = null;
+        int selectedTrackIndex = 0;
+        int selectedTrackScore = 0;
+        for (int groupIndex = 0; groupIndex < groups.length; groupIndex++) {
+            TrackGroup trackGroup = groups.get(groupIndex);
+            int[] trackFormatSupport = formatSupport[groupIndex];
+            for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
+                if (isSupported(trackFormatSupport[trackIndex], exceedRendererCapabilitiesIfNecessary)) {
+                    Format format = trackGroup.getFormat(trackIndex);
+                    boolean isDefault = (format.selectionFlags & C.SELECTION_FLAG_DEFAULT) != 0;
+                    int trackScore;
+                    if (formatHasLanguage(format, preferredAudioLanguage)) {
+                        if (isDefault) {
+                            trackScore = 4;
+                        } else {
+                            trackScore = 3;
+                        }
+                    } else if (isDefault) {
+                        trackScore = 2;
+                    } else {
+                        trackScore = 1;
+                    }
+                    if (isSupported(trackFormatSupport[trackIndex], false)) {
+                        trackScore += WITHIN_RENDERER_CAPABILITIES_BONUS;
+                    }
+                    if (trackScore > selectedTrackScore) {
+                        selectedGroup = trackGroup;
+                        selectedTrackIndex = trackIndex;
+                        selectedTrackScore = trackScore;
+                    }
+                }
             }
-          } else if (isDefault) {
-            trackScore = 3;
-          } else if (isForced) {
-            if (formatHasLanguage(format, preferredAudioLanguage)) {
-              trackScore = 2;
-            } else {
-              trackScore = 1;
+        }
+        return selectedGroup == null ? null
+                : new FixedTrackSelection(selectedGroup, selectedTrackIndex);
+    }
+
+    // Text track selection implementation.
+
+    protected TrackSelection selectTextTrack(TrackGroupArray groups, int[][] formatSupport,
+                                             String preferredTextLanguage, String preferredAudioLanguage,
+                                             boolean exceedRendererCapabilitiesIfNecessary) {
+        TrackGroup selectedGroup = null;
+        int selectedTrackIndex = 0;
+        int selectedTrackScore = 0;
+        for (int groupIndex = 0; groupIndex < groups.length; groupIndex++) {
+            TrackGroup trackGroup = groups.get(groupIndex);
+            int[] trackFormatSupport = formatSupport[groupIndex];
+            for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
+                if (isSupported(trackFormatSupport[trackIndex], exceedRendererCapabilitiesIfNecessary)) {
+                    Format format = trackGroup.getFormat(trackIndex);
+                    boolean isDefault = (format.selectionFlags & C.SELECTION_FLAG_DEFAULT) != 0;
+                    boolean isForced = (format.selectionFlags & C.SELECTION_FLAG_FORCED) != 0;
+                    int trackScore;
+                    if (formatHasLanguage(format, preferredTextLanguage)) {
+                        if (isDefault) {
+                            trackScore = 6;
+                        } else if (!isForced) {
+                            // Prefer non-forced to forced if a preferred text language has been specified. Where
+                            // both are provided the non-forced track will usually contain the forced subtitles as
+                            // a subset.
+                            trackScore = 5;
+                        } else {
+                            trackScore = 4;
+                        }
+                    } else if (isDefault) {
+                        trackScore = 3;
+                    } else if (isForced) {
+                        if (formatHasLanguage(format, preferredAudioLanguage)) {
+                            trackScore = 2;
+                        } else {
+                            trackScore = 1;
+                        }
+                    } else {
+                        // Track should not be selected.
+                        continue;
+                    }
+                    if (isSupported(trackFormatSupport[trackIndex], false)) {
+                        trackScore += WITHIN_RENDERER_CAPABILITIES_BONUS;
+                    }
+                    if (trackScore > selectedTrackScore) {
+                        selectedGroup = trackGroup;
+                        selectedTrackIndex = trackIndex;
+                        selectedTrackScore = trackScore;
+                    }
+                }
             }
-          } else {
-            // Track should not be selected.
-            continue;
-          }
-          if (isSupported(trackFormatSupport[trackIndex], false)) {
-            trackScore += WITHIN_RENDERER_CAPABILITIES_BONUS;
-          }
-          if (trackScore > selectedTrackScore) {
-            selectedGroup = trackGroup;
-            selectedTrackIndex = trackIndex;
-            selectedTrackScore = trackScore;
-          }
-        }
-      }
-    }
-    return selectedGroup == null ? null
-        : new FixedTrackSelection(selectedGroup, selectedTrackIndex);
-  }
-
-  // General track selection methods.
-
-  protected TrackSelection selectOtherTrack(int trackType, TrackGroupArray groups,
-      int[][] formatSupport, boolean exceedRendererCapabilitiesIfNecessary) {
-    TrackGroup selectedGroup = null;
-    int selectedTrackIndex = 0;
-    int selectedTrackScore = 0;
-    for (int groupIndex = 0; groupIndex < groups.length; groupIndex++) {
-      TrackGroup trackGroup = groups.get(groupIndex);
-      int[] trackFormatSupport = formatSupport[groupIndex];
-      for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
-        if (isSupported(trackFormatSupport[trackIndex], exceedRendererCapabilitiesIfNecessary)) {
-          Format format = trackGroup.getFormat(trackIndex);
-          boolean isDefault = (format.selectionFlags & C.SELECTION_FLAG_DEFAULT) != 0;
-          int trackScore = isDefault ? 2 : 1;
-          if (isSupported(trackFormatSupport[trackIndex], false)) {
-            trackScore += WITHIN_RENDERER_CAPABILITIES_BONUS;
-          }
-          if (trackScore > selectedTrackScore) {
-            selectedGroup = trackGroup;
-            selectedTrackIndex = trackIndex;
-            selectedTrackScore = trackScore;
-          }
-        }
-      }
-    }
-    return selectedGroup == null ? null
-        : new FixedTrackSelection(selectedGroup, selectedTrackIndex);
-  }
-
-  protected static boolean isSupported(int formatSupport, boolean allowExceedsCapabilities) {
-    int maskedSupport = formatSupport & RendererCapabilities.FORMAT_SUPPORT_MASK;
-    return maskedSupport == RendererCapabilities.FORMAT_HANDLED || (allowExceedsCapabilities
-        && maskedSupport == RendererCapabilities.FORMAT_EXCEEDS_CAPABILITIES);
-  }
-
-  protected static boolean formatHasLanguage(Format format, String language) {
-    return language != null && language.equals(Util.normalizeLanguageCode(format.language));
-  }
-
-  // Viewport size util methods.
-
-  private static List<Integer> getViewportFilteredTrackIndices(TrackGroup group, int viewportWidth,
-      int viewportHeight, boolean orientationMayChange) {
-    // Initially include all indices.
-    ArrayList<Integer> selectedTrackIndices = new ArrayList<>(group.length);
-    for (int i = 0; i < group.length; i++) {
-      selectedTrackIndices.add(i);
+        }
+        return selectedGroup == null ? null
+                : new FixedTrackSelection(selectedGroup, selectedTrackIndex);
+    }
+
+    // General track selection methods.
+
+    protected TrackSelection selectOtherTrack(int trackType, TrackGroupArray groups,
+                                              int[][] formatSupport, boolean exceedRendererCapabilitiesIfNecessary) {
+        TrackGroup selectedGroup = null;
+        int selectedTrackIndex = 0;
+        int selectedTrackScore = 0;
+        for (int groupIndex = 0; groupIndex < groups.length; groupIndex++) {
+            TrackGroup trackGroup = groups.get(groupIndex);
+            int[] trackFormatSupport = formatSupport[groupIndex];
+            for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
+                if (isSupported(trackFormatSupport[trackIndex], exceedRendererCapabilitiesIfNecessary)) {
+                    Format format = trackGroup.getFormat(trackIndex);
+                    boolean isDefault = (format.selectionFlags & C.SELECTION_FLAG_DEFAULT) != 0;
+                    int trackScore = isDefault ? 2 : 1;
+                    if (isSupported(trackFormatSupport[trackIndex], false)) {
+                        trackScore += WITHIN_RENDERER_CAPABILITIES_BONUS;
+                    }
+                    if (trackScore > selectedTrackScore) {
+                        selectedGroup = trackGroup;
+                        selectedTrackIndex = trackIndex;
+                        selectedTrackScore = trackScore;
+                    }
+                }
+            }
+        }
+        return selectedGroup == null ? null
+                : new FixedTrackSelection(selectedGroup, selectedTrackIndex);
     }
 
-    if (viewportWidth == Integer.MAX_VALUE || viewportHeight == Integer.MAX_VALUE) {
-      // Viewport dimensions not set. Return the full set of indices.
-      return selectedTrackIndices;
+    protected static boolean isSupported(int formatSupport, boolean allowExceedsCapabilities) {
+        int maskedSupport = formatSupport & RendererCapabilities.FORMAT_SUPPORT_MASK;
+        return maskedSupport == RendererCapabilities.FORMAT_HANDLED || (allowExceedsCapabilities
+                && maskedSupport == RendererCapabilities.FORMAT_EXCEEDS_CAPABILITIES);
     }
 
-    int maxVideoPixelsToRetain = Integer.MAX_VALUE;
-    for (int i = 0; i < group.length; i++) {
-      Format format = group.getFormat(i);
-      // Keep track of the number of pixels of the selected format whose resolution is the
-      // smallest to exceed the maximum size at which it can be displayed within the viewport.
-      // We'll discard formats of higher resolution.
-      if (format.width > 0 && format.height > 0) {
-        Point maxVideoSizeInViewport = getMaxVideoSizeInViewport(orientationMayChange,
-            viewportWidth, viewportHeight, format.width, format.height);
-        int videoPixels = format.width * format.height;
-        if (format.width >= (int) (maxVideoSizeInViewport.x * FRACTION_TO_CONSIDER_FULLSCREEN)
-            && format.height >= (int) (maxVideoSizeInViewport.y * FRACTION_TO_CONSIDER_FULLSCREEN)
-            && videoPixels < maxVideoPixelsToRetain) {
-          maxVideoPixelsToRetain = videoPixels;
-        }
-      }
+    protected static boolean formatHasLanguage(Format format, String language) {
+        return language != null && language.equals(Util.normalizeLanguageCode(format.language));
     }
 
-    // Filter out formats that exceed maxVideoPixelsToRetain. These formats have an unnecessarily
-    // high resolution given the size at which the video will be displayed within the viewport. Also
-    // filter out formats with unknown dimensions, since we have some whose dimensions are known.
-    if (maxVideoPixelsToRetain != Integer.MAX_VALUE) {
-      for (int i = selectedTrackIndices.size() - 1; i >= 0; i--) {
-        Format format = group.getFormat(selectedTrackIndices.get(i));
-        int pixelCount = format.getPixelCount();
-        if (pixelCount == Format.NO_VALUE || pixelCount > maxVideoPixelsToRetain) {
-          selectedTrackIndices.remove(i);
-        }
-      }
-    }
+    // Viewport size util methods.
 
-    return selectedTrackIndices;
-  }
-
-  /**
-   * Given viewport dimensions and video dimensions, computes the maximum size of the video as it
-   * will be rendered to fit inside of the viewport.
-   */
-  private static Point getMaxVideoSizeInViewport(boolean orientationMayChange, int viewportWidth,
-      int viewportHeight, int videoWidth, int videoHeight) {
-    if (orientationMayChange && (videoWidth > videoHeight) != (viewportWidth > viewportHeight)) {
-      // Rotation is allowed, and the video will be larger in the rotated viewport.
-      int tempViewportWidth = viewportWidth;
-      viewportWidth = viewportHeight;
-      viewportHeight = tempViewportWidth;
+    private static List<Integer> getViewportFilteredTrackIndices(TrackGroup group, int viewportWidth,
+                                                                 int viewportHeight, boolean orientationMayChange) {
+        // Initially include all indices.
+        ArrayList<Integer> selectedTrackIndices = new ArrayList<>(group.length);
+        for (int i = 0; i < group.length; i++) {
+            selectedTrackIndices.add(i);
+        }
+
+        if (viewportWidth == Integer.MAX_VALUE || viewportHeight == Integer.MAX_VALUE) {
+            // Viewport dimensions not set. Return the full set of indices.
+            return selectedTrackIndices;
+        }
+
+        int maxVideoPixelsToRetain = Integer.MAX_VALUE;
+        for (int i = 0; i < group.length; i++) {
+            Format format = group.getFormat(i);
+            // Keep track of the number of pixels of the selected format whose resolution is the
+            // smallest to exceed the maximum size at which it can be displayed within the viewport.
+            // We'll discard formats of higher resolution.
+            if (format.width > 0 && format.height > 0) {
+                Point maxVideoSizeInViewport = getMaxVideoSizeInViewport(orientationMayChange,
+                        viewportWidth, viewportHeight, format.width, format.height);
+                int videoPixels = format.width * format.height;
+                if (format.width >= (int) (maxVideoSizeInViewport.x * FRACTION_TO_CONSIDER_FULLSCREEN)
+                        && format.height >= (int) (maxVideoSizeInViewport.y * FRACTION_TO_CONSIDER_FULLSCREEN)
+                        && videoPixels < maxVideoPixelsToRetain) {
+                    maxVideoPixelsToRetain = videoPixels;
+                }
+            }
+        }
+
+        // Filter out formats that exceed maxVideoPixelsToRetain. These formats have an unnecessarily
+        // high resolution given the size at which the video will be displayed within the viewport. Also
+        // filter out formats with unknown dimensions, since we have some whose dimensions are known.
+        if (maxVideoPixelsToRetain != Integer.MAX_VALUE) {
+            for (int i = selectedTrackIndices.size() - 1; i >= 0; i--) {
+                Format format = group.getFormat(selectedTrackIndices.get(i));
+                int pixelCount = format.getPixelCount();
+                if (pixelCount == Format.NO_VALUE || pixelCount > maxVideoPixelsToRetain) {
+                    selectedTrackIndices.remove(i);
+                }
+            }
+        }
+
+        return selectedTrackIndices;
     }
 
-    if (videoWidth * viewportHeight >= videoHeight * viewportWidth) {
-      // Horizontal letter-boxing along top and bottom.
-      return new Point(viewportWidth, Util.ceilDivide(viewportWidth * videoHeight, videoWidth));
-    } else {
-      // Vertical letter-boxing along edges.
-      return new Point(Util.ceilDivide(viewportHeight * videoWidth, videoHeight), viewportHeight);
+    /**
+     * Given viewport dimensions and video dimensions, computes the maximum size of the video as it
+     * will be rendered to fit inside of the viewport.
+     */
+    private static Point getMaxVideoSizeInViewport(boolean orientationMayChange, int viewportWidth,
+                                                   int viewportHeight, int videoWidth, int videoHeight) {
+        if (orientationMayChange && (videoWidth > videoHeight) != (viewportWidth > viewportHeight)) {
+            // Rotation is allowed, and the video will be larger in the rotated viewport.
+            int tempViewportWidth = viewportWidth;
+            viewportWidth = viewportHeight;
+            viewportHeight = tempViewportWidth;
+        }
+
+        if (videoWidth * viewportHeight >= videoHeight * viewportWidth) {
+            // Horizontal letter-boxing along top and bottom.
+            return new Point(viewportWidth, Util.ceilDivide(viewportWidth * videoHeight, videoWidth));
+        } else {
+            // Vertical letter-boxing along edges.
+            return new Point(Util.ceilDivide(viewportHeight * videoWidth, videoHeight), viewportHeight);
+        }
     }
-  }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/FixedTrackSelection.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/FixedTrackSelection.java
index de1b500c61..16b184525f 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/FixedTrackSelection.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/FixedTrackSelection.java
@@ -24,77 +24,77 @@
  */
 public final class FixedTrackSelection extends BaseTrackSelection {
 
-  /**
-   * Factory for {@link FixedTrackSelection} instances.
-   */
-  public static final class Factory implements TrackSelection.Factory {
+    /**
+     * Factory for {@link FixedTrackSelection} instances.
+     */
+    public static final class Factory implements TrackSelection.Factory {
+
+        private final int reason;
+        private final Object data;
+
+        public Factory() {
+            this.reason = C.SELECTION_REASON_UNKNOWN;
+            this.data = null;
+        }
+
+        /**
+         * @param reason A reason for the track selection.
+         * @param data   Optional data associated with the track selection.
+         */
+        public Factory(int reason, Object data) {
+            this.reason = reason;
+            this.data = data;
+        }
+
+        @Override
+        public FixedTrackSelection createTrackSelection(TrackGroup group, int... tracks) {
+            Assertions.checkArgument(tracks.length == 1);
+            return new FixedTrackSelection(group, tracks[0], reason, data);
+        }
+
+    }
 
     private final int reason;
     private final Object data;
 
-    public Factory() {
-      this.reason = C.SELECTION_REASON_UNKNOWN;
-      this.data = null;
+    /**
+     * @param group The {@link TrackGroup}. Must not be null.
+     * @param track The index of the selected track within the {@link TrackGroup}.
+     */
+    public FixedTrackSelection(TrackGroup group, int track) {
+        this(group, track, C.SELECTION_REASON_UNKNOWN, null);
     }
 
     /**
+     * @param group  The {@link TrackGroup}. Must not be null.
+     * @param track  The index of the selected track within the {@link TrackGroup}.
      * @param reason A reason for the track selection.
-     * @param data Optional data associated with the track selection.
+     * @param data   Optional data associated with the track selection.
      */
-    public Factory(int reason, Object data) {
-      this.reason = reason;
-      this.data = data;
+    public FixedTrackSelection(TrackGroup group, int track, int reason, Object data) {
+        super(group, track);
+        this.reason = reason;
+        this.data = data;
+    }
+
+    @Override
+    public void updateSelectedTrack(long bufferedDurationUs) {
+        // Do nothing.
     }
 
     @Override
-    public FixedTrackSelection createTrackSelection(TrackGroup group, int... tracks) {
-      Assertions.checkArgument(tracks.length == 1);
-      return new FixedTrackSelection(group, tracks[0], reason, data);
+    public int getSelectedIndex() {
+        return 0;
     }
 
-  }
-
-  private final int reason;
-  private final Object data;
-
-  /**
-   * @param group The {@link TrackGroup}. Must not be null.
-   * @param track The index of the selected track within the {@link TrackGroup}.
-   */
-  public FixedTrackSelection(TrackGroup group, int track) {
-    this(group, track, C.SELECTION_REASON_UNKNOWN, null);
-  }
-
-  /**
-   * @param group The {@link TrackGroup}. Must not be null.
-   * @param track The index of the selected track within the {@link TrackGroup}.
-   * @param reason A reason for the track selection.
-   * @param data Optional data associated with the track selection.
-   */
-  public FixedTrackSelection(TrackGroup group, int track, int reason, Object data) {
-    super(group, track);
-    this.reason = reason;
-    this.data = data;
-  }
-
-  @Override
-  public void updateSelectedTrack(long bufferedDurationUs) {
-    // Do nothing.
-  }
-
-  @Override
-  public int getSelectedIndex() {
-    return 0;
-  }
-
-  @Override
-  public int getSelectionReason() {
-    return reason;
-  }
-
-  @Override
-  public Object getSelectionData() {
-    return data;
-  }
+    @Override
+    public int getSelectionReason() {
+        return reason;
+    }
+
+    @Override
+    public Object getSelectionData() {
+        return data;
+    }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
index 77df9a2173..4febf660df 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
@@ -18,12 +18,14 @@
 import android.util.Pair;
 import android.util.SparseArray;
 import android.util.SparseBooleanArray;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.RendererCapabilities;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.util.Util;
+
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Map;
@@ -34,580 +36,580 @@
  */
 public abstract class MappingTrackSelector extends TrackSelector {
 
-  /**
-   * A track selection override.
-   */
-  public static final class SelectionOverride {
-
-    public final TrackSelection.Factory factory;
-    public final int groupIndex;
-    public final int[] tracks;
-    public final int length;
-
     /**
-     * @param factory A factory for creating selections from this override.
-     * @param groupIndex The overriding group index.
-     * @param tracks The overriding track indices within the group.
+     * A track selection override.
      */
-    public SelectionOverride(TrackSelection.Factory factory, int groupIndex, int... tracks) {
-      this.factory = factory;
-      this.groupIndex = groupIndex;
-      this.tracks = tracks;
-      this.length = tracks.length;
-    }
+    public static final class SelectionOverride {
+
+        public final TrackSelection.Factory factory;
+        public final int groupIndex;
+        public final int[] tracks;
+        public final int length;
+
+        /**
+         * @param factory    A factory for creating selections from this override.
+         * @param groupIndex The overriding group index.
+         * @param tracks     The overriding track indices within the group.
+         */
+        public SelectionOverride(TrackSelection.Factory factory, int groupIndex, int... tracks) {
+            this.factory = factory;
+            this.groupIndex = groupIndex;
+            this.tracks = tracks;
+            this.length = tracks.length;
+        }
 
-    /**
-     * Creates an selection from this override.
-     *
-     * @param groups The groups whose selection is being overridden.
-     * @return The selection.
-     */
-    public TrackSelection createTrackSelection(TrackGroupArray groups) {
-      return factory.createTrackSelection(groups.get(groupIndex), tracks);
-    }
+        /**
+         * Creates an selection from this override.
+         *
+         * @param groups The groups whose selection is being overridden.
+         * @return The selection.
+         */
+        public TrackSelection createTrackSelection(TrackGroupArray groups) {
+            return factory.createTrackSelection(groups.get(groupIndex), tracks);
+        }
 
-    /**
-     * Returns whether this override contains the specified track index.
-     */
-    public boolean containsTrack(int track) {
-      for (int overrideTrack : tracks) {
-        if (overrideTrack == track) {
-          return true;
+        /**
+         * Returns whether this override contains the specified track index.
+         */
+        public boolean containsTrack(int track) {
+            for (int overrideTrack : tracks) {
+                if (overrideTrack == track) {
+                    return true;
+                }
+            }
+            return false;
         }
-      }
-      return false;
-    }
 
-  }
-
-  private final SparseArray<Map<TrackGroupArray, SelectionOverride>> selectionOverrides;
-  private final SparseBooleanArray rendererDisabledFlags;
-
-  private MappedTrackInfo currentMappedTrackInfo;
-
-  public MappingTrackSelector() {
-    selectionOverrides = new SparseArray<>();
-    rendererDisabledFlags = new SparseBooleanArray();
-  }
-
-  /**
-   * Returns the mapping information associated with the current track selections, or null if no
-   * selection is currently active.
-   */
-  public final MappedTrackInfo getCurrentMappedTrackInfo() {
-    return currentMappedTrackInfo;
-  }
-
-  /**
-   * Sets whether the renderer at the specified index is disabled.
-   *
-   * @param rendererIndex The renderer index.
-   * @param disabled Whether the renderer is disabled.
-   */
-  public final void setRendererDisabled(int rendererIndex, boolean disabled) {
-    if (rendererDisabledFlags.get(rendererIndex) == disabled) {
-      // The disabled flag is unchanged.
-      return;
-    }
-    rendererDisabledFlags.put(rendererIndex, disabled);
-    invalidate();
-  }
-
-  /**
-   * Returns whether the renderer is disabled.
-   *
-   * @param rendererIndex The renderer index.
-   * @return Whether the renderer is disabled.
-   */
-  public final boolean getRendererDisabled(int rendererIndex) {
-    return rendererDisabledFlags.get(rendererIndex);
-  }
-
-  /**
-   * Overrides the track selection for the renderer at a specified index.
-   * <p>
-   * When the {@link TrackGroupArray} available to the renderer at the specified index matches the
-   * one provided, the override is applied. When the {@link TrackGroupArray} does not match, the
-   * override has no effect. The override replaces any previous override for the renderer and the
-   * provided {@link TrackGroupArray}.
-   * <p>
-   * Passing a {@code null} override will explicitly disable the renderer. To remove overrides use
-   * {@link #clearSelectionOverride(int, TrackGroupArray)}, {@link #clearSelectionOverrides(int)}
-   * or {@link #clearSelectionOverrides()}.
-   *
-   * @param rendererIndex The renderer index.
-   * @param groups The {@link TrackGroupArray} for which the override should be applied.
-   * @param override The override.
-   */
-  public final void setSelectionOverride(int rendererIndex, TrackGroupArray groups,
-      SelectionOverride override) {
-    Map<TrackGroupArray, SelectionOverride> overrides = selectionOverrides.get(rendererIndex);
-    if (overrides == null) {
-      overrides = new HashMap<>();
-      selectionOverrides.put(rendererIndex, overrides);
-    }
-    if (overrides.containsKey(groups) && Util.areEqual(overrides.get(groups), override)) {
-      // The override is unchanged.
-      return;
-    }
-    overrides.put(groups, override);
-    invalidate();
-  }
-
-  /**
-   * Returns whether there is an override for the specified renderer and {@link TrackGroupArray}.
-   *
-   * @param rendererIndex The renderer index.
-   * @param groups The {@link TrackGroupArray}.
-   * @return Whether there is an override.
-   */
-  public final boolean hasSelectionOverride(int rendererIndex, TrackGroupArray groups) {
-    Map<TrackGroupArray, SelectionOverride> overrides = selectionOverrides.get(rendererIndex);
-    return overrides != null && overrides.containsKey(groups);
-  }
-
-  /**
-   * Returns the override for the specified renderer and {@link TrackGroupArray}.
-   *
-   * @param rendererIndex The renderer index.
-   * @param groups The {@link TrackGroupArray}.
-   * @return The override, or null if no override exists.
-   */
-  public final SelectionOverride getSelectionOverride(int rendererIndex, TrackGroupArray groups) {
-    Map<TrackGroupArray, SelectionOverride> overrides = selectionOverrides.get(rendererIndex);
-    return overrides != null ? overrides.get(groups) : null;
-  }
-
-  /**
-   * Clears a track selection override for the specified renderer and {@link TrackGroupArray}.
-   *
-   * @param rendererIndex The renderer index.
-   * @param groups The {@link TrackGroupArray} for which the override should be cleared.
-   */
-  public final void clearSelectionOverride(int rendererIndex, TrackGroupArray groups) {
-    Map<TrackGroupArray, SelectionOverride> overrides = selectionOverrides.get(rendererIndex);
-    if (overrides == null || !overrides.containsKey(groups)) {
-      // Nothing to clear.
-      return;
-    }
-    overrides.remove(groups);
-    if (overrides.isEmpty()) {
-      selectionOverrides.remove(rendererIndex);
-    }
-    invalidate();
-  }
-
-  /**
-   * Clears all track selection override for the specified renderer.
-   *
-   * @param rendererIndex The renderer index.
-   */
-  public final void clearSelectionOverrides(int rendererIndex) {
-    Map<TrackGroupArray, ?> overrides = selectionOverrides.get(rendererIndex);
-    if (overrides == null || overrides.isEmpty()) {
-      // Nothing to clear.
-      return;
-    }
-    selectionOverrides.remove(rendererIndex);
-    invalidate();
-  }
-
-  /**
-   * Clears all track selection overrides.
-   */
-  public final void clearSelectionOverrides() {
-    if (selectionOverrides.size() == 0) {
-      // Nothing to clear.
-      return;
-    }
-    selectionOverrides.clear();
-    invalidate();
-  }
-
-  // TrackSelector implementation.
-
-  @Override
-  public final Pair<TrackSelectionArray, Object> selectTracks(
-      RendererCapabilities[] rendererCapabilities, TrackGroupArray trackGroups)
-      throws ExoPlaybackException {
-    // Structures into which data will be written during the selection. The extra item at the end
-    // of each array is to store data associated with track groups that cannot be associated with
-    // any renderer.
-    int[] rendererTrackGroupCounts = new int[rendererCapabilities.length + 1];
-    TrackGroup[][] rendererTrackGroups = new TrackGroup[rendererCapabilities.length + 1][];
-    int[][][] rendererFormatSupports = new int[rendererCapabilities.length + 1][][];
-    for (int i = 0; i < rendererTrackGroups.length; i++) {
-      rendererTrackGroups[i] = new TrackGroup[trackGroups.length];
-      rendererFormatSupports[i] = new int[trackGroups.length][];
     }
 
-    // Determine the extent to which each renderer supports mixed mimeType adaptation.
-    int[] mixedMimeTypeAdaptationSupport = getMixedMimeTypeAdaptationSupport(rendererCapabilities);
-
-    // Associate each track group to a preferred renderer, and evaluate the support that the
-    // renderer provides for each track in the group.
-    for (int groupIndex = 0; groupIndex < trackGroups.length; groupIndex++) {
-      TrackGroup group = trackGroups.get(groupIndex);
-      // Associate the group to a preferred renderer.
-      int rendererIndex = findRenderer(rendererCapabilities, group);
-      // Evaluate the support that the renderer provides for each track in the group.
-      int[] rendererFormatSupport = rendererIndex == rendererCapabilities.length
-          ? new int[group.length] : getFormatSupport(rendererCapabilities[rendererIndex], group);
-      // Stash the results.
-      int rendererTrackGroupCount = rendererTrackGroupCounts[rendererIndex];
-      rendererTrackGroups[rendererIndex][rendererTrackGroupCount] = group;
-      rendererFormatSupports[rendererIndex][rendererTrackGroupCount] = rendererFormatSupport;
-      rendererTrackGroupCounts[rendererIndex]++;
-    }
+    private final SparseArray<Map<TrackGroupArray, SelectionOverride>> selectionOverrides;
+    private final SparseBooleanArray rendererDisabledFlags;
 
-    // Create a track group array for each renderer, and trim each rendererFormatSupports entry.
-    TrackGroupArray[] rendererTrackGroupArrays = new TrackGroupArray[rendererCapabilities.length];
-    int[] rendererTrackTypes = new int[rendererCapabilities.length];
-    for (int i = 0; i < rendererCapabilities.length; i++) {
-      int rendererTrackGroupCount = rendererTrackGroupCounts[i];
-      rendererTrackGroupArrays[i] = new TrackGroupArray(
-          Arrays.copyOf(rendererTrackGroups[i], rendererTrackGroupCount));
-      rendererFormatSupports[i] = Arrays.copyOf(rendererFormatSupports[i], rendererTrackGroupCount);
-      rendererTrackTypes[i] = rendererCapabilities[i].getTrackType();
-    }
+    private MappedTrackInfo currentMappedTrackInfo;
 
-    // Create a track group array for track groups not associated with a renderer.
-    int unassociatedTrackGroupCount = rendererTrackGroupCounts[rendererCapabilities.length];
-    TrackGroupArray unassociatedTrackGroupArray = new TrackGroupArray(Arrays.copyOf(
-        rendererTrackGroups[rendererCapabilities.length], unassociatedTrackGroupCount));
-
-    TrackSelection[] trackSelections = selectTracks(rendererCapabilities, rendererTrackGroupArrays,
-        rendererFormatSupports);
-
-    // Apply track disabling and overriding.
-    for (int i = 0; i < rendererCapabilities.length; i++) {
-      if (rendererDisabledFlags.get(i)) {
-        trackSelections[i] = null;
-      } else {
-        TrackGroupArray rendererTrackGroup = rendererTrackGroupArrays[i];
-        Map<TrackGroupArray, SelectionOverride> overrides = selectionOverrides.get(i);
-        SelectionOverride override = overrides == null ? null : overrides.get(rendererTrackGroup);
-        if (override != null) {
-          trackSelections[i] = override.createTrackSelection(rendererTrackGroup);
-        }
-      }
+    public MappingTrackSelector() {
+        selectionOverrides = new SparseArray<>();
+        rendererDisabledFlags = new SparseBooleanArray();
     }
 
-    // Package up the track information and selections.
-    MappedTrackInfo mappedTrackInfo = new MappedTrackInfo(rendererTrackTypes,
-        rendererTrackGroupArrays, mixedMimeTypeAdaptationSupport, rendererFormatSupports,
-        unassociatedTrackGroupArray);
-    return Pair.<TrackSelectionArray, Object>create(new TrackSelectionArray(trackSelections),
-        mappedTrackInfo);
-  }
-
-  @Override
-  public final void onSelectionActivated(Object info) {
-    currentMappedTrackInfo = (MappedTrackInfo) info;
-  }
-
-  /**
-   * Given an array of renderers and a set of {@link TrackGroup}s mapped to each of them, provides a
-   * {@link TrackSelection} per renderer.
-   *
-   * @param rendererCapabilities The {@link RendererCapabilities} of the renderers for which
-   *     {@link TrackSelection}s are to be generated.
-   * @param rendererTrackGroupArrays An array of {@link TrackGroupArray}s where each entry
-   *     corresponds to the renderer of equal index in {@code renderers}.
-   * @param rendererFormatSupports Maps every available track to a specific level of support as
-   *     defined by the renderer {@code FORMAT_*} constants.
-   * @throws ExoPlaybackException If an error occurs while selecting the tracks.
-   */
-  protected abstract TrackSelection[] selectTracks(RendererCapabilities[] rendererCapabilities,
-      TrackGroupArray[] rendererTrackGroupArrays, int[][][] rendererFormatSupports)
-      throws ExoPlaybackException;
-
-  /**
-   * Finds the renderer to which the provided {@link TrackGroup} should be associated.
-   * <p>
-   * A {@link TrackGroup} is associated to a renderer that reports
-   * {@link RendererCapabilities#FORMAT_HANDLED} support for one or more of the tracks in the group,
-   * or {@link RendererCapabilities#FORMAT_EXCEEDS_CAPABILITIES} if no such renderer exists, or
-   * {@link RendererCapabilities#FORMAT_UNSUPPORTED_SUBTYPE} if again no such renderer exists. In
-   * the case that two or more renderers report the same level of support, the renderer with the
-   * lowest index is associated.
-   * <p>
-   * If all renderers report {@link RendererCapabilities#FORMAT_UNSUPPORTED_TYPE} for all of the
-   * tracks in the group, then {@code renderers.length} is returned to indicate that no association
-   * was made.
-   *
-   * @param rendererCapabilities The {@link RendererCapabilities} of the renderers.
-   * @param group The {@link TrackGroup} whose associated renderer is to be found.
-   * @return The index of the associated renderer, or {@code renderers.length} if no
-   *     association was made.
-   * @throws ExoPlaybackException If an error occurs finding a renderer.
-   */
-  private static int findRenderer(RendererCapabilities[] rendererCapabilities, TrackGroup group)
-      throws ExoPlaybackException {
-    int bestRendererIndex = rendererCapabilities.length;
-    int bestSupportLevel = RendererCapabilities.FORMAT_UNSUPPORTED_TYPE;
-    for (int rendererIndex = 0; rendererIndex < rendererCapabilities.length; rendererIndex++) {
-      RendererCapabilities rendererCapability = rendererCapabilities[rendererIndex];
-      for (int trackIndex = 0; trackIndex < group.length; trackIndex++) {
-        int trackSupportLevel = rendererCapability.supportsFormat(group.getFormat(trackIndex));
-        if (trackSupportLevel > bestSupportLevel) {
-          bestRendererIndex = rendererIndex;
-          bestSupportLevel = trackSupportLevel;
-          if (bestSupportLevel == RendererCapabilities.FORMAT_HANDLED) {
-            // We can't do better.
-            return bestRendererIndex;
-          }
-        }
-      }
-    }
-    return bestRendererIndex;
-  }
-
-  /**
-   * Calls {@link RendererCapabilities#supportsFormat} for each track in the specified
-   * {@link TrackGroup}, returning the results in an array.
-   *
-   * @param rendererCapabilities The {@link RendererCapabilities} of the renderer.
-   * @param group The {@link TrackGroup} to evaluate.
-   * @return An array containing the result of calling
-   *     {@link RendererCapabilities#supportsFormat} for each track in the group.
-   * @throws ExoPlaybackException If an error occurs determining the format support.
-   */
-  private static int[] getFormatSupport(RendererCapabilities rendererCapabilities, TrackGroup group)
-      throws ExoPlaybackException {
-    int[] formatSupport = new int[group.length];
-    for (int i = 0; i < group.length; i++) {
-      formatSupport[i] = rendererCapabilities.supportsFormat(group.getFormat(i));
-    }
-    return formatSupport;
-  }
-
-  /**
-   * Calls {@link RendererCapabilities#supportsMixedMimeTypeAdaptation()} for each renderer,
-   * returning the results in an array.
-   *
-   * @param rendererCapabilities The {@link RendererCapabilities} of the renderers.
-   * @return An array containing the result of calling
-   *     {@link RendererCapabilities#supportsMixedMimeTypeAdaptation()} for each renderer.
-   * @throws ExoPlaybackException If an error occurs determining the adaptation support.
-   */
-  private static int[] getMixedMimeTypeAdaptationSupport(
-      RendererCapabilities[] rendererCapabilities) throws ExoPlaybackException {
-    int[] mixedMimeTypeAdaptationSupport = new int[rendererCapabilities.length];
-    for (int i = 0; i < mixedMimeTypeAdaptationSupport.length; i++) {
-      mixedMimeTypeAdaptationSupport[i] = rendererCapabilities[i].supportsMixedMimeTypeAdaptation();
-    }
-    return mixedMimeTypeAdaptationSupport;
-  }
-
-  /**
-   * Provides track information for each renderer.
-   */
-  public static final class MappedTrackInfo {
-
     /**
-     * The renderer does not have any associated tracks.
+     * Returns the mapping information associated with the current track selections, or null if no
+     * selection is currently active.
      */
-    public static final int RENDERER_SUPPORT_NO_TRACKS = 0;
+    public final MappedTrackInfo getCurrentMappedTrackInfo() {
+        return currentMappedTrackInfo;
+    }
+
     /**
-     * The renderer has associated tracks, but all are of unsupported types.
+     * Sets whether the renderer at the specified index is disabled.
+     *
+     * @param rendererIndex The renderer index.
+     * @param disabled      Whether the renderer is disabled.
      */
-    public static final int RENDERER_SUPPORT_UNSUPPORTED_TRACKS = 1;
+    public final void setRendererDisabled(int rendererIndex, boolean disabled) {
+        if (rendererDisabledFlags.get(rendererIndex) == disabled) {
+            // The disabled flag is unchanged.
+            return;
+        }
+        rendererDisabledFlags.put(rendererIndex, disabled);
+        invalidate();
+    }
+
     /**
-     * The renderer has associated tracks and at least one is of a supported type, but all of the
-     * tracks whose types are supported exceed the renderer's capabilities.
+     * Returns whether the renderer is disabled.
+     *
+     * @param rendererIndex The renderer index.
+     * @return Whether the renderer is disabled.
      */
-    public static final int RENDERER_SUPPORT_EXCEEDS_CAPABILITIES_TRACKS = 2;
+    public final boolean getRendererDisabled(int rendererIndex) {
+        return rendererDisabledFlags.get(rendererIndex);
+    }
+
     /**
-     * The renderer has associated tracks and can play at least one of them.
+     * Overrides the track selection for the renderer at a specified index.
+     * <p>
+     * When the {@link TrackGroupArray} available to the renderer at the specified index matches the
+     * one provided, the override is applied. When the {@link TrackGroupArray} does not match, the
+     * override has no effect. The override replaces any previous override for the renderer and the
+     * provided {@link TrackGroupArray}.
+     * <p>
+     * Passing a {@code null} override will explicitly disable the renderer. To remove overrides use
+     * {@link #clearSelectionOverride(int, TrackGroupArray)}, {@link #clearSelectionOverrides(int)}
+     * or {@link #clearSelectionOverrides()}.
+     *
+     * @param rendererIndex The renderer index.
+     * @param groups        The {@link TrackGroupArray} for which the override should be applied.
+     * @param override      The override.
      */
-    public static final int RENDERER_SUPPORT_PLAYABLE_TRACKS = 3;
+    public final void setSelectionOverride(int rendererIndex, TrackGroupArray groups,
+                                           SelectionOverride override) {
+        Map<TrackGroupArray, SelectionOverride> overrides = selectionOverrides.get(rendererIndex);
+        if (overrides == null) {
+            overrides = new HashMap<>();
+            selectionOverrides.put(rendererIndex, overrides);
+        }
+        if (overrides.containsKey(groups) && Util.areEqual(overrides.get(groups), override)) {
+            // The override is unchanged.
+            return;
+        }
+        overrides.put(groups, override);
+        invalidate();
+    }
 
     /**
-     * The number of renderers to which tracks are mapped.
+     * Returns whether there is an override for the specified renderer and {@link TrackGroupArray}.
+     *
+     * @param rendererIndex The renderer index.
+     * @param groups        The {@link TrackGroupArray}.
+     * @return Whether there is an override.
      */
-    public final int length;
-
-    private final int[] rendererTrackTypes;
-    private final TrackGroupArray[] trackGroups;
-    private final int[] mixedMimeTypeAdaptiveSupport;
-    private final int[][][] formatSupport;
-    private final TrackGroupArray unassociatedTrackGroups;
+    public final boolean hasSelectionOverride(int rendererIndex, TrackGroupArray groups) {
+        Map<TrackGroupArray, SelectionOverride> overrides = selectionOverrides.get(rendererIndex);
+        return overrides != null && overrides.containsKey(groups);
+    }
 
     /**
-     * @param rendererTrackTypes The track type supported by each renderer.
-     * @param trackGroups The {@link TrackGroupArray}s for each renderer.
-     * @param mixedMimeTypeAdaptiveSupport The result of
-     *     {@link RendererCapabilities#supportsMixedMimeTypeAdaptation()} for each renderer.
-     * @param formatSupport The result of {@link RendererCapabilities#supportsFormat} for each
-     *     track, indexed by renderer index, group index and track index (in that order).
-     * @param unassociatedTrackGroups Contains {@link TrackGroup}s not associated with any renderer.
+     * Returns the override for the specified renderer and {@link TrackGroupArray}.
+     *
+     * @param rendererIndex The renderer index.
+     * @param groups        The {@link TrackGroupArray}.
+     * @return The override, or null if no override exists.
      */
-    /* package */ MappedTrackInfo(int[] rendererTrackTypes,
-        TrackGroupArray[] trackGroups, int[] mixedMimeTypeAdaptiveSupport,
-        int[][][] formatSupport, TrackGroupArray unassociatedTrackGroups) {
-      this.rendererTrackTypes = rendererTrackTypes;
-      this.trackGroups = trackGroups;
-      this.formatSupport = formatSupport;
-      this.mixedMimeTypeAdaptiveSupport = mixedMimeTypeAdaptiveSupport;
-      this.unassociatedTrackGroups = unassociatedTrackGroups;
-      this.length = trackGroups.length;
+    public final SelectionOverride getSelectionOverride(int rendererIndex, TrackGroupArray groups) {
+        Map<TrackGroupArray, SelectionOverride> overrides = selectionOverrides.get(rendererIndex);
+        return overrides != null ? overrides.get(groups) : null;
     }
 
     /**
-     * Returns the array of {@link TrackGroup}s associated to the renderer at a specified index.
+     * Clears a track selection override for the specified renderer and {@link TrackGroupArray}.
      *
      * @param rendererIndex The renderer index.
-     * @return The corresponding {@link TrackGroup}s.
+     * @param groups        The {@link TrackGroupArray} for which the override should be cleared.
      */
-    public TrackGroupArray getTrackGroups(int rendererIndex) {
-      return trackGroups[rendererIndex];
+    public final void clearSelectionOverride(int rendererIndex, TrackGroupArray groups) {
+        Map<TrackGroupArray, SelectionOverride> overrides = selectionOverrides.get(rendererIndex);
+        if (overrides == null || !overrides.containsKey(groups)) {
+            // Nothing to clear.
+            return;
+        }
+        overrides.remove(groups);
+        if (overrides.isEmpty()) {
+            selectionOverrides.remove(rendererIndex);
+        }
+        invalidate();
     }
 
     /**
-     * Returns the extent to which a renderer can support playback of the tracks associated to it.
+     * Clears all track selection override for the specified renderer.
      *
      * @param rendererIndex The renderer index.
-     * @return One of {@link #RENDERER_SUPPORT_PLAYABLE_TRACKS},
-     *     {@link #RENDERER_SUPPORT_EXCEEDS_CAPABILITIES_TRACKS},
-     *     {@link #RENDERER_SUPPORT_UNSUPPORTED_TRACKS} and {@link #RENDERER_SUPPORT_NO_TRACKS}.
      */
-    public int getRendererSupport(int rendererIndex) {
-      int bestRendererSupport = RENDERER_SUPPORT_NO_TRACKS;
-      int[][] rendererFormatSupport = formatSupport[rendererIndex];
-      for (int i = 0; i < rendererFormatSupport.length; i++) {
-        for (int j = 0; j < rendererFormatSupport[i].length; j++) {
-          int trackRendererSupport;
-          switch (rendererFormatSupport[i][j] & RendererCapabilities.FORMAT_SUPPORT_MASK) {
-            case RendererCapabilities.FORMAT_HANDLED:
-              return RENDERER_SUPPORT_PLAYABLE_TRACKS;
-            case RendererCapabilities.FORMAT_EXCEEDS_CAPABILITIES:
-              trackRendererSupport = RENDERER_SUPPORT_EXCEEDS_CAPABILITIES_TRACKS;
-              break;
-            default:
-              trackRendererSupport = RENDERER_SUPPORT_UNSUPPORTED_TRACKS;
-              break;
-          }
-          bestRendererSupport = Math.max(bestRendererSupport, trackRendererSupport);
+    public final void clearSelectionOverrides(int rendererIndex) {
+        Map<TrackGroupArray, ?> overrides = selectionOverrides.get(rendererIndex);
+        if (overrides == null || overrides.isEmpty()) {
+            // Nothing to clear.
+            return;
         }
-      }
-      return bestRendererSupport;
+        selectionOverrides.remove(rendererIndex);
+        invalidate();
     }
 
     /**
-     * Returns the best level of support obtained from {@link #getRendererSupport(int)} for all
-     * renderers of the specified track type. If no renderers exist for the specified type then
-     * {@link #RENDERER_SUPPORT_NO_TRACKS} is returned.
-     *
-     * @param trackType The track type. One of the {@link C} {@code TRACK_TYPE_*} constants.
-     * @return One of {@link #RENDERER_SUPPORT_PLAYABLE_TRACKS},
-     *     {@link #RENDERER_SUPPORT_EXCEEDS_CAPABILITIES_TRACKS},
-     *     {@link #RENDERER_SUPPORT_UNSUPPORTED_TRACKS} and {@link #RENDERER_SUPPORT_NO_TRACKS}.
+     * Clears all track selection overrides.
      */
-    public int getTrackTypeRendererSupport(int trackType) {
-      int bestRendererSupport = RENDERER_SUPPORT_NO_TRACKS;
-      for (int i = 0; i < length; i++) {
-        if (rendererTrackTypes[i] == trackType) {
-          bestRendererSupport = Math.max(bestRendererSupport, getRendererSupport(i));
+    public final void clearSelectionOverrides() {
+        if (selectionOverrides.size() == 0) {
+            // Nothing to clear.
+            return;
+        }
+        selectionOverrides.clear();
+        invalidate();
+    }
+
+    // TrackSelector implementation.
+
+    @Override
+    public final Pair<TrackSelectionArray, Object> selectTracks(
+            RendererCapabilities[] rendererCapabilities, TrackGroupArray trackGroups)
+            throws ExoPlaybackException {
+        // Structures into which data will be written during the selection. The extra item at the end
+        // of each array is to store data associated with track groups that cannot be associated with
+        // any renderer.
+        int[] rendererTrackGroupCounts = new int[rendererCapabilities.length + 1];
+        TrackGroup[][] rendererTrackGroups = new TrackGroup[rendererCapabilities.length + 1][];
+        int[][][] rendererFormatSupports = new int[rendererCapabilities.length + 1][][];
+        for (int i = 0; i < rendererTrackGroups.length; i++) {
+            rendererTrackGroups[i] = new TrackGroup[trackGroups.length];
+            rendererFormatSupports[i] = new int[trackGroups.length][];
         }
-      }
-      return bestRendererSupport;
+
+        // Determine the extent to which each renderer supports mixed mimeType adaptation.
+        int[] mixedMimeTypeAdaptationSupport = getMixedMimeTypeAdaptationSupport(rendererCapabilities);
+
+        // Associate each track group to a preferred renderer, and evaluate the support that the
+        // renderer provides for each track in the group.
+        for (int groupIndex = 0; groupIndex < trackGroups.length; groupIndex++) {
+            TrackGroup group = trackGroups.get(groupIndex);
+            // Associate the group to a preferred renderer.
+            int rendererIndex = findRenderer(rendererCapabilities, group);
+            // Evaluate the support that the renderer provides for each track in the group.
+            int[] rendererFormatSupport = rendererIndex == rendererCapabilities.length
+                    ? new int[group.length] : getFormatSupport(rendererCapabilities[rendererIndex], group);
+            // Stash the results.
+            int rendererTrackGroupCount = rendererTrackGroupCounts[rendererIndex];
+            rendererTrackGroups[rendererIndex][rendererTrackGroupCount] = group;
+            rendererFormatSupports[rendererIndex][rendererTrackGroupCount] = rendererFormatSupport;
+            rendererTrackGroupCounts[rendererIndex]++;
+        }
+
+        // Create a track group array for each renderer, and trim each rendererFormatSupports entry.
+        TrackGroupArray[] rendererTrackGroupArrays = new TrackGroupArray[rendererCapabilities.length];
+        int[] rendererTrackTypes = new int[rendererCapabilities.length];
+        for (int i = 0; i < rendererCapabilities.length; i++) {
+            int rendererTrackGroupCount = rendererTrackGroupCounts[i];
+            rendererTrackGroupArrays[i] = new TrackGroupArray(
+                    Arrays.copyOf(rendererTrackGroups[i], rendererTrackGroupCount));
+            rendererFormatSupports[i] = Arrays.copyOf(rendererFormatSupports[i], rendererTrackGroupCount);
+            rendererTrackTypes[i] = rendererCapabilities[i].getTrackType();
+        }
+
+        // Create a track group array for track groups not associated with a renderer.
+        int unassociatedTrackGroupCount = rendererTrackGroupCounts[rendererCapabilities.length];
+        TrackGroupArray unassociatedTrackGroupArray = new TrackGroupArray(Arrays.copyOf(
+                rendererTrackGroups[rendererCapabilities.length], unassociatedTrackGroupCount));
+
+        TrackSelection[] trackSelections = selectTracks(rendererCapabilities, rendererTrackGroupArrays,
+                rendererFormatSupports);
+
+        // Apply track disabling and overriding.
+        for (int i = 0; i < rendererCapabilities.length; i++) {
+            if (rendererDisabledFlags.get(i)) {
+                trackSelections[i] = null;
+            } else {
+                TrackGroupArray rendererTrackGroup = rendererTrackGroupArrays[i];
+                Map<TrackGroupArray, SelectionOverride> overrides = selectionOverrides.get(i);
+                SelectionOverride override = overrides == null ? null : overrides.get(rendererTrackGroup);
+                if (override != null) {
+                    trackSelections[i] = override.createTrackSelection(rendererTrackGroup);
+                }
+            }
+        }
+
+        // Package up the track information and selections.
+        MappedTrackInfo mappedTrackInfo = new MappedTrackInfo(rendererTrackTypes,
+                rendererTrackGroupArrays, mixedMimeTypeAdaptationSupport, rendererFormatSupports,
+                unassociatedTrackGroupArray);
+        return Pair.<TrackSelectionArray, Object>create(new TrackSelectionArray(trackSelections),
+                mappedTrackInfo);
+    }
+
+    @Override
+    public final void onSelectionActivated(Object info) {
+        currentMappedTrackInfo = (MappedTrackInfo) info;
     }
 
     /**
-     * Returns the extent to which the format of an individual track is supported by the renderer.
+     * Given an array of renderers and a set of {@link TrackGroup}s mapped to each of them, provides a
+     * {@link TrackSelection} per renderer.
      *
-     * @param rendererIndex The renderer index.
-     * @param groupIndex The index of the group to which the track belongs.
-     * @param trackIndex The index of the track within the group.
-     * @return One of {@link RendererCapabilities#FORMAT_HANDLED},
-     *     {@link RendererCapabilities#FORMAT_EXCEEDS_CAPABILITIES},
-     *     {@link RendererCapabilities#FORMAT_UNSUPPORTED_SUBTYPE} and
-     *     {@link RendererCapabilities#FORMAT_UNSUPPORTED_TYPE}.
+     * @param rendererCapabilities     The {@link RendererCapabilities} of the renderers for which
+     *                                 {@link TrackSelection}s are to be generated.
+     * @param rendererTrackGroupArrays An array of {@link TrackGroupArray}s where each entry
+     *                                 corresponds to the renderer of equal index in {@code renderers}.
+     * @param rendererFormatSupports   Maps every available track to a specific level of support as
+     *                                 defined by the renderer {@code FORMAT_*} constants.
+     * @throws ExoPlaybackException If an error occurs while selecting the tracks.
      */
-    public int getTrackFormatSupport(int rendererIndex, int groupIndex, int trackIndex) {
-      return formatSupport[rendererIndex][groupIndex][trackIndex]
-          & RendererCapabilities.FORMAT_SUPPORT_MASK;
-    }
+    protected abstract TrackSelection[] selectTracks(RendererCapabilities[] rendererCapabilities,
+                                                     TrackGroupArray[] rendererTrackGroupArrays, int[][][] rendererFormatSupports)
+            throws ExoPlaybackException;
 
     /**
-     * Returns the extent to which the renderer supports adaptation between supported tracks in a
-     * specified {@link TrackGroup}.
+     * Finds the renderer to which the provided {@link TrackGroup} should be associated.
+     * <p>
+     * A {@link TrackGroup} is associated to a renderer that reports
+     * {@link RendererCapabilities#FORMAT_HANDLED} support for one or more of the tracks in the group,
+     * or {@link RendererCapabilities#FORMAT_EXCEEDS_CAPABILITIES} if no such renderer exists, or
+     * {@link RendererCapabilities#FORMAT_UNSUPPORTED_SUBTYPE} if again no such renderer exists. In
+     * the case that two or more renderers report the same level of support, the renderer with the
+     * lowest index is associated.
      * <p>
-     * Tracks for which {@link #getTrackFormatSupport(int, int, int)} returns
-     * {@link RendererCapabilities#FORMAT_HANDLED} are always considered.
-     * Tracks for which {@link #getTrackFormatSupport(int, int, int)} returns
-     * {@link RendererCapabilities#FORMAT_UNSUPPORTED_TYPE} or
-     * {@link RendererCapabilities#FORMAT_UNSUPPORTED_SUBTYPE} are never considered.
-     * Tracks for which {@link #getTrackFormatSupport(int, int, int)} returns
-     * {@link RendererCapabilities#FORMAT_EXCEEDS_CAPABILITIES} are considered only if
-     * {@code includeCapabilitiesExceededTracks} is set to {@code true}.
+     * If all renderers report {@link RendererCapabilities#FORMAT_UNSUPPORTED_TYPE} for all of the
+     * tracks in the group, then {@code renderers.length} is returned to indicate that no association
+     * was made.
      *
-     * @param rendererIndex The renderer index.
-     * @param groupIndex The index of the group.
-     * @param includeCapabilitiesExceededTracks True if formats that exceed the capabilities of the
-     *     renderer should be included when determining support. False otherwise.
-     * @return One of {@link RendererCapabilities#ADAPTIVE_SEAMLESS},
-     *     {@link RendererCapabilities#ADAPTIVE_NOT_SEAMLESS} and
-     *     {@link RendererCapabilities#ADAPTIVE_NOT_SUPPORTED}.
+     * @param rendererCapabilities The {@link RendererCapabilities} of the renderers.
+     * @param group                The {@link TrackGroup} whose associated renderer is to be found.
+     * @return The index of the associated renderer, or {@code renderers.length} if no
+     * association was made.
+     * @throws ExoPlaybackException If an error occurs finding a renderer.
      */
-    public int getAdaptiveSupport(int rendererIndex, int groupIndex,
-        boolean includeCapabilitiesExceededTracks) {
-      int trackCount = trackGroups[rendererIndex].get(groupIndex).length;
-      // Iterate over the tracks in the group, recording the indices of those to consider.
-      int[] trackIndices = new int[trackCount];
-      int trackIndexCount = 0;
-      for (int i = 0; i < trackCount; i++) {
-        int fixedSupport = getTrackFormatSupport(rendererIndex, groupIndex, i);
-        if (fixedSupport == RendererCapabilities.FORMAT_HANDLED
-            || (includeCapabilitiesExceededTracks
-            && fixedSupport == RendererCapabilities.FORMAT_EXCEEDS_CAPABILITIES)) {
-          trackIndices[trackIndexCount++] = i;
+    private static int findRenderer(RendererCapabilities[] rendererCapabilities, TrackGroup group)
+            throws ExoPlaybackException {
+        int bestRendererIndex = rendererCapabilities.length;
+        int bestSupportLevel = RendererCapabilities.FORMAT_UNSUPPORTED_TYPE;
+        for (int rendererIndex = 0; rendererIndex < rendererCapabilities.length; rendererIndex++) {
+            RendererCapabilities rendererCapability = rendererCapabilities[rendererIndex];
+            for (int trackIndex = 0; trackIndex < group.length; trackIndex++) {
+                int trackSupportLevel = rendererCapability.supportsFormat(group.getFormat(trackIndex));
+                if (trackSupportLevel > bestSupportLevel) {
+                    bestRendererIndex = rendererIndex;
+                    bestSupportLevel = trackSupportLevel;
+                    if (bestSupportLevel == RendererCapabilities.FORMAT_HANDLED) {
+                        // We can't do better.
+                        return bestRendererIndex;
+                    }
+                }
+            }
         }
-      }
-      trackIndices = Arrays.copyOf(trackIndices, trackIndexCount);
-      return getAdaptiveSupport(rendererIndex, groupIndex, trackIndices);
+        return bestRendererIndex;
     }
 
     /**
-     * Returns the extent to which the renderer supports adaptation between specified tracks within
-     * a {@link TrackGroup}.
+     * Calls {@link RendererCapabilities#supportsFormat} for each track in the specified
+     * {@link TrackGroup}, returning the results in an array.
      *
-     * @param rendererIndex The renderer index.
-     * @param groupIndex The index of the group.
-     * @return One of {@link RendererCapabilities#ADAPTIVE_SEAMLESS},
-     *     {@link RendererCapabilities#ADAPTIVE_NOT_SEAMLESS} and
-     *     {@link RendererCapabilities#ADAPTIVE_NOT_SUPPORTED}.
+     * @param rendererCapabilities The {@link RendererCapabilities} of the renderer.
+     * @param group                The {@link TrackGroup} to evaluate.
+     * @return An array containing the result of calling
+     * {@link RendererCapabilities#supportsFormat} for each track in the group.
+     * @throws ExoPlaybackException If an error occurs determining the format support.
      */
-    public int getAdaptiveSupport(int rendererIndex, int groupIndex, int[] trackIndices) {
-      int handledTrackCount = 0;
-      int adaptiveSupport = RendererCapabilities.ADAPTIVE_SEAMLESS;
-      boolean multipleMimeTypes = false;
-      String firstSampleMimeType = null;
-      for (int i = 0; i < trackIndices.length; i++) {
-        int trackIndex = trackIndices[i];
-        String sampleMimeType = trackGroups[rendererIndex].get(groupIndex).getFormat(trackIndex)
-            .sampleMimeType;
-        if (handledTrackCount++ == 0) {
-          firstSampleMimeType = sampleMimeType;
-        } else {
-          multipleMimeTypes |= !Util.areEqual(firstSampleMimeType, sampleMimeType);
+    private static int[] getFormatSupport(RendererCapabilities rendererCapabilities, TrackGroup group)
+            throws ExoPlaybackException {
+        int[] formatSupport = new int[group.length];
+        for (int i = 0; i < group.length; i++) {
+            formatSupport[i] = rendererCapabilities.supportsFormat(group.getFormat(i));
         }
-        adaptiveSupport = Math.min(adaptiveSupport, formatSupport[rendererIndex][groupIndex][i]
-            & RendererCapabilities.ADAPTIVE_SUPPORT_MASK);
-      }
-      return multipleMimeTypes
-          ? Math.min(adaptiveSupport, mixedMimeTypeAdaptiveSupport[rendererIndex])
-          : adaptiveSupport;
+        return formatSupport;
     }
 
     /**
-     * Returns the {@link TrackGroup}s not associated with any renderer.
+     * Calls {@link RendererCapabilities#supportsMixedMimeTypeAdaptation()} for each renderer,
+     * returning the results in an array.
+     *
+     * @param rendererCapabilities The {@link RendererCapabilities} of the renderers.
+     * @return An array containing the result of calling
+     * {@link RendererCapabilities#supportsMixedMimeTypeAdaptation()} for each renderer.
+     * @throws ExoPlaybackException If an error occurs determining the adaptation support.
      */
-    public TrackGroupArray getUnassociatedTrackGroups() {
-      return unassociatedTrackGroups;
+    private static int[] getMixedMimeTypeAdaptationSupport(
+            RendererCapabilities[] rendererCapabilities) throws ExoPlaybackException {
+        int[] mixedMimeTypeAdaptationSupport = new int[rendererCapabilities.length];
+        for (int i = 0; i < mixedMimeTypeAdaptationSupport.length; i++) {
+            mixedMimeTypeAdaptationSupport[i] = rendererCapabilities[i].supportsMixedMimeTypeAdaptation();
+        }
+        return mixedMimeTypeAdaptationSupport;
     }
 
-  }
+    /**
+     * Provides track information for each renderer.
+     */
+    public static final class MappedTrackInfo {
+
+        /**
+         * The renderer does not have any associated tracks.
+         */
+        public static final int RENDERER_SUPPORT_NO_TRACKS = 0;
+        /**
+         * The renderer has associated tracks, but all are of unsupported types.
+         */
+        public static final int RENDERER_SUPPORT_UNSUPPORTED_TRACKS = 1;
+        /**
+         * The renderer has associated tracks and at least one is of a supported type, but all of the
+         * tracks whose types are supported exceed the renderer's capabilities.
+         */
+        public static final int RENDERER_SUPPORT_EXCEEDS_CAPABILITIES_TRACKS = 2;
+        /**
+         * The renderer has associated tracks and can play at least one of them.
+         */
+        public static final int RENDERER_SUPPORT_PLAYABLE_TRACKS = 3;
+
+        /**
+         * The number of renderers to which tracks are mapped.
+         */
+        public final int length;
+
+        private final int[] rendererTrackTypes;
+        private final TrackGroupArray[] trackGroups;
+        private final int[] mixedMimeTypeAdaptiveSupport;
+        private final int[][][] formatSupport;
+        private final TrackGroupArray unassociatedTrackGroups;
+
+        /**
+         * @param rendererTrackTypes           The track type supported by each renderer.
+         * @param trackGroups                  The {@link TrackGroupArray}s for each renderer.
+         * @param mixedMimeTypeAdaptiveSupport The result of
+         *                                     {@link RendererCapabilities#supportsMixedMimeTypeAdaptation()} for each renderer.
+         * @param formatSupport                The result of {@link RendererCapabilities#supportsFormat} for each
+         *                                     track, indexed by renderer index, group index and track index (in that order).
+         * @param unassociatedTrackGroups      Contains {@link TrackGroup}s not associated with any renderer.
+         */
+    /* package */ MappedTrackInfo(int[] rendererTrackTypes,
+                                  TrackGroupArray[] trackGroups, int[] mixedMimeTypeAdaptiveSupport,
+                                  int[][][] formatSupport, TrackGroupArray unassociatedTrackGroups) {
+            this.rendererTrackTypes = rendererTrackTypes;
+            this.trackGroups = trackGroups;
+            this.formatSupport = formatSupport;
+            this.mixedMimeTypeAdaptiveSupport = mixedMimeTypeAdaptiveSupport;
+            this.unassociatedTrackGroups = unassociatedTrackGroups;
+            this.length = trackGroups.length;
+        }
+
+        /**
+         * Returns the array of {@link TrackGroup}s associated to the renderer at a specified index.
+         *
+         * @param rendererIndex The renderer index.
+         * @return The corresponding {@link TrackGroup}s.
+         */
+        public TrackGroupArray getTrackGroups(int rendererIndex) {
+            return trackGroups[rendererIndex];
+        }
+
+        /**
+         * Returns the extent to which a renderer can support playback of the tracks associated to it.
+         *
+         * @param rendererIndex The renderer index.
+         * @return One of {@link #RENDERER_SUPPORT_PLAYABLE_TRACKS},
+         * {@link #RENDERER_SUPPORT_EXCEEDS_CAPABILITIES_TRACKS},
+         * {@link #RENDERER_SUPPORT_UNSUPPORTED_TRACKS} and {@link #RENDERER_SUPPORT_NO_TRACKS}.
+         */
+        public int getRendererSupport(int rendererIndex) {
+            int bestRendererSupport = RENDERER_SUPPORT_NO_TRACKS;
+            int[][] rendererFormatSupport = formatSupport[rendererIndex];
+            for (int i = 0; i < rendererFormatSupport.length; i++) {
+                for (int j = 0; j < rendererFormatSupport[i].length; j++) {
+                    int trackRendererSupport;
+                    switch (rendererFormatSupport[i][j] & RendererCapabilities.FORMAT_SUPPORT_MASK) {
+                        case RendererCapabilities.FORMAT_HANDLED:
+                            return RENDERER_SUPPORT_PLAYABLE_TRACKS;
+                        case RendererCapabilities.FORMAT_EXCEEDS_CAPABILITIES:
+                            trackRendererSupport = RENDERER_SUPPORT_EXCEEDS_CAPABILITIES_TRACKS;
+                            break;
+                        default:
+                            trackRendererSupport = RENDERER_SUPPORT_UNSUPPORTED_TRACKS;
+                            break;
+                    }
+                    bestRendererSupport = Math.max(bestRendererSupport, trackRendererSupport);
+                }
+            }
+            return bestRendererSupport;
+        }
+
+        /**
+         * Returns the best level of support obtained from {@link #getRendererSupport(int)} for all
+         * renderers of the specified track type. If no renderers exist for the specified type then
+         * {@link #RENDERER_SUPPORT_NO_TRACKS} is returned.
+         *
+         * @param trackType The track type. One of the {@link C} {@code TRACK_TYPE_*} constants.
+         * @return One of {@link #RENDERER_SUPPORT_PLAYABLE_TRACKS},
+         * {@link #RENDERER_SUPPORT_EXCEEDS_CAPABILITIES_TRACKS},
+         * {@link #RENDERER_SUPPORT_UNSUPPORTED_TRACKS} and {@link #RENDERER_SUPPORT_NO_TRACKS}.
+         */
+        public int getTrackTypeRendererSupport(int trackType) {
+            int bestRendererSupport = RENDERER_SUPPORT_NO_TRACKS;
+            for (int i = 0; i < length; i++) {
+                if (rendererTrackTypes[i] == trackType) {
+                    bestRendererSupport = Math.max(bestRendererSupport, getRendererSupport(i));
+                }
+            }
+            return bestRendererSupport;
+        }
+
+        /**
+         * Returns the extent to which the format of an individual track is supported by the renderer.
+         *
+         * @param rendererIndex The renderer index.
+         * @param groupIndex    The index of the group to which the track belongs.
+         * @param trackIndex    The index of the track within the group.
+         * @return One of {@link RendererCapabilities#FORMAT_HANDLED},
+         * {@link RendererCapabilities#FORMAT_EXCEEDS_CAPABILITIES},
+         * {@link RendererCapabilities#FORMAT_UNSUPPORTED_SUBTYPE} and
+         * {@link RendererCapabilities#FORMAT_UNSUPPORTED_TYPE}.
+         */
+        public int getTrackFormatSupport(int rendererIndex, int groupIndex, int trackIndex) {
+            return formatSupport[rendererIndex][groupIndex][trackIndex]
+                    & RendererCapabilities.FORMAT_SUPPORT_MASK;
+        }
+
+        /**
+         * Returns the extent to which the renderer supports adaptation between supported tracks in a
+         * specified {@link TrackGroup}.
+         * <p>
+         * Tracks for which {@link #getTrackFormatSupport(int, int, int)} returns
+         * {@link RendererCapabilities#FORMAT_HANDLED} are always considered.
+         * Tracks for which {@link #getTrackFormatSupport(int, int, int)} returns
+         * {@link RendererCapabilities#FORMAT_UNSUPPORTED_TYPE} or
+         * {@link RendererCapabilities#FORMAT_UNSUPPORTED_SUBTYPE} are never considered.
+         * Tracks for which {@link #getTrackFormatSupport(int, int, int)} returns
+         * {@link RendererCapabilities#FORMAT_EXCEEDS_CAPABILITIES} are considered only if
+         * {@code includeCapabilitiesExceededTracks} is set to {@code true}.
+         *
+         * @param rendererIndex                     The renderer index.
+         * @param groupIndex                        The index of the group.
+         * @param includeCapabilitiesExceededTracks True if formats that exceed the capabilities of the
+         *                                          renderer should be included when determining support. False otherwise.
+         * @return One of {@link RendererCapabilities#ADAPTIVE_SEAMLESS},
+         * {@link RendererCapabilities#ADAPTIVE_NOT_SEAMLESS} and
+         * {@link RendererCapabilities#ADAPTIVE_NOT_SUPPORTED}.
+         */
+        public int getAdaptiveSupport(int rendererIndex, int groupIndex,
+                                      boolean includeCapabilitiesExceededTracks) {
+            int trackCount = trackGroups[rendererIndex].get(groupIndex).length;
+            // Iterate over the tracks in the group, recording the indices of those to consider.
+            int[] trackIndices = new int[trackCount];
+            int trackIndexCount = 0;
+            for (int i = 0; i < trackCount; i++) {
+                int fixedSupport = getTrackFormatSupport(rendererIndex, groupIndex, i);
+                if (fixedSupport == RendererCapabilities.FORMAT_HANDLED
+                        || (includeCapabilitiesExceededTracks
+                        && fixedSupport == RendererCapabilities.FORMAT_EXCEEDS_CAPABILITIES)) {
+                    trackIndices[trackIndexCount++] = i;
+                }
+            }
+            trackIndices = Arrays.copyOf(trackIndices, trackIndexCount);
+            return getAdaptiveSupport(rendererIndex, groupIndex, trackIndices);
+        }
+
+        /**
+         * Returns the extent to which the renderer supports adaptation between specified tracks within
+         * a {@link TrackGroup}.
+         *
+         * @param rendererIndex The renderer index.
+         * @param groupIndex    The index of the group.
+         * @return One of {@link RendererCapabilities#ADAPTIVE_SEAMLESS},
+         * {@link RendererCapabilities#ADAPTIVE_NOT_SEAMLESS} and
+         * {@link RendererCapabilities#ADAPTIVE_NOT_SUPPORTED}.
+         */
+        public int getAdaptiveSupport(int rendererIndex, int groupIndex, int[] trackIndices) {
+            int handledTrackCount = 0;
+            int adaptiveSupport = RendererCapabilities.ADAPTIVE_SEAMLESS;
+            boolean multipleMimeTypes = false;
+            String firstSampleMimeType = null;
+            for (int i = 0; i < trackIndices.length; i++) {
+                int trackIndex = trackIndices[i];
+                String sampleMimeType = trackGroups[rendererIndex].get(groupIndex).getFormat(trackIndex)
+                        .sampleMimeType;
+                if (handledTrackCount++ == 0) {
+                    firstSampleMimeType = sampleMimeType;
+                } else {
+                    multipleMimeTypes |= !Util.areEqual(firstSampleMimeType, sampleMimeType);
+                }
+                adaptiveSupport = Math.min(adaptiveSupport, formatSupport[rendererIndex][groupIndex][i]
+                        & RendererCapabilities.ADAPTIVE_SUPPORT_MASK);
+            }
+            return multipleMimeTypes
+                    ? Math.min(adaptiveSupport, mixedMimeTypeAdaptiveSupport[rendererIndex])
+                    : adaptiveSupport;
+        }
+
+        /**
+         * Returns the {@link TrackGroup}s not associated with any renderer.
+         */
+        public TrackGroupArray getUnassociatedTrackGroups() {
+            return unassociatedTrackGroups;
+        }
+
+    }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/RandomTrackSelection.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/RandomTrackSelection.java
index 5c7625d6b4..40af4d3719 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/RandomTrackSelection.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/RandomTrackSelection.java
@@ -16,8 +16,10 @@
 package com.google.android.exoplayer2.trackselection;
 
 import android.os.SystemClock;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.source.TrackGroup;
+
 import java.util.Random;
 
 /**
@@ -25,105 +27,105 @@
  */
 public final class RandomTrackSelection extends BaseTrackSelection {
 
-  /**
-   * Factory for {@link RandomTrackSelection} instances.
-   */
-  public static final class Factory implements TrackSelection.Factory {
+    /**
+     * Factory for {@link RandomTrackSelection} instances.
+     */
+    public static final class Factory implements TrackSelection.Factory {
+
+        private final Random random;
+
+        public Factory() {
+            random = new Random();
+        }
+
+        /**
+         * @param seed A seed for the {@link Random} instance used by the factory.
+         */
+        public Factory(int seed) {
+            random = new Random(seed);
+        }
+
+        @Override
+        public RandomTrackSelection createTrackSelection(TrackGroup group, int... tracks) {
+            return new RandomTrackSelection(group, tracks, random);
+        }
+
+    }
 
     private final Random random;
 
-    public Factory() {
-      random = new Random();
+    private int selectedIndex;
+
+    /**
+     * @param group  The {@link TrackGroup}. Must not be null.
+     * @param tracks The indices of the selected tracks within the {@link TrackGroup}. Must not be
+     *               null or empty. May be in any order.
+     */
+    public RandomTrackSelection(TrackGroup group, int... tracks) {
+        super(group, tracks);
+        random = new Random();
+        selectedIndex = random.nextInt(length);
     }
 
     /**
-     * @param seed A seed for the {@link Random} instance used by the factory.
+     * @param group  The {@link TrackGroup}. Must not be null.
+     * @param tracks The indices of the selected tracks within the {@link TrackGroup}. Must not be
+     *               null or empty. May be in any order.
+     * @param seed   A seed for the {@link Random} instance used to update the selected track.
      */
-    public Factory(int seed) {
-      random = new Random(seed);
+    public RandomTrackSelection(TrackGroup group, int[] tracks, long seed) {
+        this(group, tracks, new Random(seed));
+    }
+
+    /**
+     * @param group  The {@link TrackGroup}. Must not be null.
+     * @param tracks The indices of the selected tracks within the {@link TrackGroup}. Must not be
+     *               null or empty. May be in any order.
+     * @param random A source of random numbers.
+     */
+    public RandomTrackSelection(TrackGroup group, int[] tracks, Random random) {
+        super(group, tracks);
+        this.random = random;
+        selectedIndex = random.nextInt(length);
+    }
+
+    @Override
+    public void updateSelectedTrack(long bufferedDurationUs) {
+        // Count the number of non-blacklisted formats.
+        long nowMs = SystemClock.elapsedRealtime();
+        int nonBlacklistedFormatCount = 0;
+        for (int i = 0; i < length; i++) {
+            if (!isBlacklisted(i, nowMs)) {
+                nonBlacklistedFormatCount++;
+            }
+        }
+
+        selectedIndex = random.nextInt(nonBlacklistedFormatCount);
+        if (nonBlacklistedFormatCount != length) {
+            // Adjust the format index to account for blacklisted formats.
+            nonBlacklistedFormatCount = 0;
+            for (int i = 0; i < length; i++) {
+                if (!isBlacklisted(i, nowMs) && selectedIndex == nonBlacklistedFormatCount++) {
+                    selectedIndex = i;
+                    return;
+                }
+            }
+        }
     }
 
     @Override
-    public RandomTrackSelection createTrackSelection(TrackGroup group, int... tracks) {
-      return new RandomTrackSelection(group, tracks, random);
+    public int getSelectedIndex() {
+        return selectedIndex;
     }
 
-  }
-
-  private final Random random;
-
-  private int selectedIndex;
-
-  /**
-   * @param group The {@link TrackGroup}. Must not be null.
-   * @param tracks The indices of the selected tracks within the {@link TrackGroup}. Must not be
-   *     null or empty. May be in any order.
-   */
-  public RandomTrackSelection(TrackGroup group, int... tracks) {
-    super(group, tracks);
-    random = new Random();
-    selectedIndex = random.nextInt(length);
-  }
-
-  /**
-   * @param group The {@link TrackGroup}. Must not be null.
-   * @param tracks The indices of the selected tracks within the {@link TrackGroup}. Must not be
-   *     null or empty. May be in any order.
-   * @param seed A seed for the {@link Random} instance used to update the selected track.
-   */
-  public RandomTrackSelection(TrackGroup group, int[] tracks, long seed) {
-    this(group, tracks, new Random(seed));
-  }
-
-  /**
-   * @param group The {@link TrackGroup}. Must not be null.
-   * @param tracks The indices of the selected tracks within the {@link TrackGroup}. Must not be
-   *     null or empty. May be in any order.
-   * @param random A source of random numbers.
-   */
-  public RandomTrackSelection(TrackGroup group, int[] tracks, Random random) {
-    super(group, tracks);
-    this.random = random;
-    selectedIndex = random.nextInt(length);
-  }
-
-  @Override
-  public void updateSelectedTrack(long bufferedDurationUs) {
-    // Count the number of non-blacklisted formats.
-    long nowMs = SystemClock.elapsedRealtime();
-    int nonBlacklistedFormatCount = 0;
-    for (int i = 0; i < length; i++) {
-      if (!isBlacklisted(i, nowMs)) {
-        nonBlacklistedFormatCount++;
-      }
+    @Override
+    public int getSelectionReason() {
+        return C.SELECTION_REASON_ADAPTIVE;
     }
 
-    selectedIndex = random.nextInt(nonBlacklistedFormatCount);
-    if (nonBlacklistedFormatCount != length) {
-      // Adjust the format index to account for blacklisted formats.
-      nonBlacklistedFormatCount = 0;
-      for (int i = 0; i < length; i++) {
-        if (!isBlacklisted(i, nowMs) && selectedIndex == nonBlacklistedFormatCount++) {
-          selectedIndex = i;
-          return;
-        }
-      }
+    @Override
+    public Object getSelectionData() {
+        return null;
     }
-  }
-
-  @Override
-  public int getSelectedIndex() {
-    return selectedIndex;
-  }
-
-  @Override
-  public int getSelectionReason() {
-    return C.SELECTION_REASON_ADAPTIVE;
-  }
-
-  @Override
-  public Object getSelectionData() {
-    return null;
-  }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelection.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelection.java
index fe66946a65..7e6cade819 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelection.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelection.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
+
 import java.util.List;
 
 /**
@@ -30,134 +31,134 @@
  */
 public interface TrackSelection {
 
-  /**
-   * Factory for {@link TrackSelection} instances.
-   */
-  interface Factory {
+    /**
+     * Factory for {@link TrackSelection} instances.
+     */
+    interface Factory {
+
+        /**
+         * Creates a new selection.
+         *
+         * @param group  The {@link TrackGroup}. Must not be null.
+         * @param tracks The indices of the selected tracks within the {@link TrackGroup}. Must not be
+         *               null or empty. May be in any order.
+         * @return The created selection.
+         */
+        TrackSelection createTrackSelection(TrackGroup group, int... tracks);
+
+    }
+
+    /**
+     * Returns the {@link TrackGroup} to which the selected tracks belong.
+     */
+    TrackGroup getTrackGroup();
+
+    // Static subset of selected tracks.
+
+    /**
+     * Returns the number of tracks in the selection.
+     */
+    int length();
+
+    /**
+     * Returns the format of the track at a given index in the selection.
+     *
+     * @param index The index in the selection.
+     * @return The format of the selected track.
+     */
+    Format getFormat(int index);
+
+    /**
+     * Returns the index in the track group of the track at a given index in the selection.
+     *
+     * @param index The index in the selection.
+     * @return The index of the selected track.
+     */
+    int getIndexInTrackGroup(int index);
+
+    /**
+     * Returns the index in the selection of the track with the specified format.
+     *
+     * @param format The format.
+     * @return The index in the selection, or {@link C#INDEX_UNSET} if the track with the specified
+     * format is not part of the selection.
+     */
+    int indexOf(Format format);
+
+    /**
+     * Returns the index in the selection of the track with the specified index in the track group.
+     *
+     * @param indexInTrackGroup The index in the track group.
+     * @return The index in the selection, or {@link C#INDEX_UNSET} if the track with the specified
+     * index is not part of the selection.
+     */
+    int indexOf(int indexInTrackGroup);
+
+    // Individual selected track.
+
+    /**
+     * Returns the {@link Format} of the individual selected track.
+     */
+    Format getSelectedFormat();
+
+    /**
+     * Returns the index in the track group of the individual selected track.
+     */
+    int getSelectedIndexInTrackGroup();
+
+    /**
+     * Returns the index of the selected track.
+     */
+    int getSelectedIndex();
+
+    /**
+     * Returns the reason for the current track selection.
+     */
+    int getSelectionReason();
+
+    /**
+     * Returns optional data associated with the current track selection.
+     */
+    Object getSelectionData();
+
+    // Adaptation.
+
+    /**
+     * Updates the selected track.
+     *
+     * @param bufferedDurationUs The duration of media currently buffered in microseconds.
+     */
+    void updateSelectedTrack(long bufferedDurationUs);
+
+    /**
+     * May be called periodically by sources that load media in discrete {@link MediaChunk}s and
+     * support discarding of buffered chunks in order to re-buffer using a different selected track.
+     * Returns the number of chunks that should be retained in the queue.
+     * <p>
+     * To avoid excessive re-buffering, implementations should normally return the size of the queue.
+     * An example of a case where a smaller value may be returned is if network conditions have
+     * improved dramatically, allowing chunks to be discarded and re-buffered in a track of
+     * significantly higher quality. Discarding chunks may allow faster switching to a higher quality
+     * track in this case.
+     *
+     * @param playbackPositionUs The current playback position in microseconds.
+     * @param queue              The queue of buffered {@link MediaChunk}s. Must not be modified.
+     * @return The number of chunks to retain in the queue.
+     */
+    int evaluateQueueSize(long playbackPositionUs, List<? extends MediaChunk> queue);
 
     /**
-     * Creates a new selection.
+     * Attempts to blacklist the track at the specified index in the selection, making it ineligible
+     * for selection by calls to {@link #updateSelectedTrack(long)} for the specified period of time.
+     * Blacklisting will fail if all other tracks are currently blacklisted. If blacklisting the
+     * currently selected track, note that it will remain selected until the next call to
+     * {@link #updateSelectedTrack(long)}.
      *
-     * @param group The {@link TrackGroup}. Must not be null.
-     * @param tracks The indices of the selected tracks within the {@link TrackGroup}. Must not be
-     *     null or empty. May be in any order.
-     * @return The created selection.
+     * @param index               The index of the track in the selection.
+     * @param blacklistDurationMs The duration of time for which the track should be blacklisted, in
+     *                            milliseconds.
+     * @return Whether blacklisting was successful.
      */
-    TrackSelection createTrackSelection(TrackGroup group, int... tracks);
-
-  }
-
-  /**
-   * Returns the {@link TrackGroup} to which the selected tracks belong.
-   */
-  TrackGroup getTrackGroup();
-
-  // Static subset of selected tracks.
-
-  /**
-   * Returns the number of tracks in the selection.
-   */
-  int length();
-
-  /**
-   * Returns the format of the track at a given index in the selection.
-   *
-   * @param index The index in the selection.
-   * @return The format of the selected track.
-   */
-  Format getFormat(int index);
-
-  /**
-   * Returns the index in the track group of the track at a given index in the selection.
-   *
-   * @param index The index in the selection.
-   * @return The index of the selected track.
-   */
-  int getIndexInTrackGroup(int index);
-
-  /**
-   * Returns the index in the selection of the track with the specified format.
-   *
-   * @param format The format.
-   * @return The index in the selection, or {@link C#INDEX_UNSET} if the track with the specified
-   *     format is not part of the selection.
-   */
-  int indexOf(Format format);
-
-  /**
-   * Returns the index in the selection of the track with the specified index in the track group.
-   *
-   * @param indexInTrackGroup The index in the track group.
-   * @return The index in the selection, or {@link C#INDEX_UNSET} if the track with the specified
-   *     index is not part of the selection.
-   */
-  int indexOf(int indexInTrackGroup);
-
-  // Individual selected track.
-
-  /**
-   * Returns the {@link Format} of the individual selected track.
-   */
-  Format getSelectedFormat();
-
-  /**
-   * Returns the index in the track group of the individual selected track.
-   */
-  int getSelectedIndexInTrackGroup();
-
-  /**
-   * Returns the index of the selected track.
-   */
-  int getSelectedIndex();
-
-  /**
-   * Returns the reason for the current track selection.
-   */
-  int getSelectionReason();
-
-  /**
-   * Returns optional data associated with the current track selection.
-   */
-  Object getSelectionData();
-
-  // Adaptation.
-
-  /**
-   * Updates the selected track.
-   *
-   * @param bufferedDurationUs The duration of media currently buffered in microseconds.
-   */
-  void updateSelectedTrack(long bufferedDurationUs);
-
-  /**
-   * May be called periodically by sources that load media in discrete {@link MediaChunk}s and
-   * support discarding of buffered chunks in order to re-buffer using a different selected track.
-   * Returns the number of chunks that should be retained in the queue.
-   * <p>
-   * To avoid excessive re-buffering, implementations should normally return the size of the queue.
-   * An example of a case where a smaller value may be returned is if network conditions have
-   * improved dramatically, allowing chunks to be discarded and re-buffered in a track of
-   * significantly higher quality. Discarding chunks may allow faster switching to a higher quality
-   * track in this case.
-   *
-   * @param playbackPositionUs The current playback position in microseconds.
-   * @param queue The queue of buffered {@link MediaChunk}s. Must not be modified.
-   * @return The number of chunks to retain in the queue.
-   */
-  int evaluateQueueSize(long playbackPositionUs, List<? extends MediaChunk> queue);
-
-  /**
-   * Attempts to blacklist the track at the specified index in the selection, making it ineligible
-   * for selection by calls to {@link #updateSelectedTrack(long)} for the specified period of time.
-   * Blacklisting will fail if all other tracks are currently blacklisted. If blacklisting the
-   * currently selected track, note that it will remain selected until the next call to
-   * {@link #updateSelectedTrack(long)}.
-   *
-   * @param index The index of the track in the selection.
-   * @param blacklistDurationMs The duration of time for which the track should be blacklisted, in
-   *     milliseconds.
-   * @return Whether blacklisting was successful.
-   */
-  boolean blacklist(int index, long blacklistDurationMs);
+    boolean blacklist(int index, long blacklistDurationMs);
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionArray.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionArray.java
index 809e571f10..9882e5b18a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionArray.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionArray.java
@@ -22,61 +22,61 @@
  */
 public final class TrackSelectionArray {
 
-  /**
-   * The number of selections in the result. Greater than or equal to zero.
-   */
-  public final int length;
+    /**
+     * The number of selections in the result. Greater than or equal to zero.
+     */
+    public final int length;
 
-  private final TrackSelection[] trackSelections;
+    private final TrackSelection[] trackSelections;
 
-  // Lazily initialized hashcode.
-  private int hashCode;
+    // Lazily initialized hashcode.
+    private int hashCode;
 
-  /**
-   * @param trackSelections The selections. Must not be null, but may contain null elements.
-   */
-  public TrackSelectionArray(TrackSelection... trackSelections) {
-    this.trackSelections = trackSelections;
-    this.length = trackSelections.length;
-  }
-
-  /**
-   * Returns the selection at a given index.
-   *
-   * @param index The index of the selection.
-   * @return The selection.
-   */
-  public TrackSelection get(int index) {
-    return trackSelections[index];
-  }
+    /**
+     * @param trackSelections The selections. Must not be null, but may contain null elements.
+     */
+    public TrackSelectionArray(TrackSelection... trackSelections) {
+        this.trackSelections = trackSelections;
+        this.length = trackSelections.length;
+    }
 
-  /**
-   * Returns the selections in a newly allocated array.
-   */
-  public TrackSelection[] getAll() {
-    return trackSelections.clone();
-  }
+    /**
+     * Returns the selection at a given index.
+     *
+     * @param index The index of the selection.
+     * @return The selection.
+     */
+    public TrackSelection get(int index) {
+        return trackSelections[index];
+    }
 
-  @Override
-  public int hashCode() {
-    if (hashCode == 0) {
-      int result = 17;
-      result = 31 * result + Arrays.hashCode(trackSelections);
-      hashCode = result;
+    /**
+     * Returns the selections in a newly allocated array.
+     */
+    public TrackSelection[] getAll() {
+        return trackSelections.clone();
     }
-    return hashCode;
-  }
 
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj) {
-      return true;
+    @Override
+    public int hashCode() {
+        if (hashCode == 0) {
+            int result = 17;
+            result = 31 * result + Arrays.hashCode(trackSelections);
+            hashCode = result;
+        }
+        return hashCode;
     }
-    if (obj == null || getClass() != obj.getClass()) {
-      return false;
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null || getClass() != obj.getClass()) {
+            return false;
+        }
+        TrackSelectionArray other = (TrackSelectionArray) obj;
+        return Arrays.equals(trackSelections, other.trackSelections);
     }
-    TrackSelectionArray other = (TrackSelectionArray) obj;
-    return Arrays.equals(trackSelections, other.trackSelections);
-  }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java
index 5a9d3923bf..32612b6a9d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java
@@ -16,66 +16,69 @@
 package com.google.android.exoplayer2.trackselection;
 
 import android.util.Pair;
+
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.RendererCapabilities;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 
-/** Selects tracks to be consumed by available renderers. */
+/**
+ * Selects tracks to be consumed by available renderers.
+ */
 public abstract class TrackSelector {
 
-  /**
-   * Notified when previous selections by a {@link TrackSelector} are no longer valid.
-   */
-  public interface InvalidationListener {
-
     /**
-     * Called by a {@link TrackSelector} when previous selections are no longer valid.
+     * Notified when previous selections by a {@link TrackSelector} are no longer valid.
      */
-    void onTrackSelectionsInvalidated();
+    public interface InvalidationListener {
 
-  }
+        /**
+         * Called by a {@link TrackSelector} when previous selections are no longer valid.
+         */
+        void onTrackSelectionsInvalidated();
 
-  private InvalidationListener listener;
+    }
 
-  /**
-   * Initializes the selector.
-   *
-   * @param listener A listener for the selector.
-   */
-  public final void init(InvalidationListener listener) {
-    this.listener = listener;
-  }
+    private InvalidationListener listener;
+
+    /**
+     * Initializes the selector.
+     *
+     * @param listener A listener for the selector.
+     */
+    public final void init(InvalidationListener listener) {
+        this.listener = listener;
+    }
 
-  /**
-   * Generates {@link TrackSelectionArray} for the renderers.
-   *
-   * @param rendererCapabilities The {@link RendererCapabilities} of the renderers for which
-   *     {@link TrackSelection}s are to be generated.
-   * @param trackGroups The available track groups.
-   * @return The track selections, and an implementation specific object that will be returned to
-   *     the selector via {@link #onSelectionActivated(Object)} should the selections be activated.
-   * @throws ExoPlaybackException If an error occurs selecting tracks.
-   */
-  public abstract Pair<TrackSelectionArray, Object> selectTracks(
-      RendererCapabilities[] rendererCapabilities, TrackGroupArray trackGroups)
-      throws ExoPlaybackException;
+    /**
+     * Generates {@link TrackSelectionArray} for the renderers.
+     *
+     * @param rendererCapabilities The {@link RendererCapabilities} of the renderers for which
+     *                             {@link TrackSelection}s are to be generated.
+     * @param trackGroups          The available track groups.
+     * @return The track selections, and an implementation specific object that will be returned to
+     * the selector via {@link #onSelectionActivated(Object)} should the selections be activated.
+     * @throws ExoPlaybackException If an error occurs selecting tracks.
+     */
+    public abstract Pair<TrackSelectionArray, Object> selectTracks(
+            RendererCapabilities[] rendererCapabilities, TrackGroupArray trackGroups)
+            throws ExoPlaybackException;
 
-  /**
-   * Called when {@link TrackSelectionArray} previously generated by
-   * {@link #selectTracks(RendererCapabilities[], TrackGroupArray)} are activated.
-   *
-   * @param info The information associated with the selections, or null if the selected tracks are
-   *     being cleared.
-   */
-  public abstract void onSelectionActivated(Object info);
+    /**
+     * Called when {@link TrackSelectionArray} previously generated by
+     * {@link #selectTracks(RendererCapabilities[], TrackGroupArray)} are activated.
+     *
+     * @param info The information associated with the selections, or null if the selected tracks are
+     *             being cleared.
+     */
+    public abstract void onSelectionActivated(Object info);
 
-  /**
-   * Invalidates all previously generated track selections.
-   */
-  protected final void invalidate() {
-    if (listener != null) {
-      listener.onTrackSelectionsInvalidated();
+    /**
+     * Invalidates all previously generated track selections.
+     */
+    protected final void invalidate() {
+        if (listener != null) {
+            listener.onTrackSelectionsInvalidated();
+        }
     }
-  }
 
 }
