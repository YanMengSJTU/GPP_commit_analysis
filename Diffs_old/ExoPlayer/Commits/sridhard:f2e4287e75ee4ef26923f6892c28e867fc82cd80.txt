diff --git a/README.md b/README.md
index 37967dd527..03f16bd655 100644
--- a/README.md
+++ b/README.md
@@ -27,6 +27,8 @@ repository and depend on the modules locally.
 
 ### From JCenter ###
 
+#### 1. Add repositories ####
+
 The easiest way to get started using ExoPlayer is to add it as a gradle
 dependency. You need to make sure you have the Google and JCenter repositories
 included in the `build.gradle` file in the root of your project:
@@ -38,6 +40,8 @@ repositories {
 }
 ```
 
+#### 2. Add ExoPlayer module dependencies ####
+
 Next add a dependency in the `build.gradle` file of your app module. The
 following will add a dependency to the full library:
 
@@ -45,15 +49,7 @@ following will add a dependency to the full library:
 implementation 'com.google.android.exoplayer:exoplayer:2.X.X'
 ```
 
-where `2.X.X` is your preferred version. If not enabled already, you also need
-to turn on Java 8 support in all `build.gradle` files depending on ExoPlayer, by
-adding the following to the `android` section:
-
-```gradle
-compileOptions {
-    targetCompatibility JavaVersion.VERSION_1_8
-}
-```
+where `2.X.X` is your preferred version.
 
 As an alternative to the full library, you can depend on only the library
 modules that you actually need. For example the following will add dependencies
@@ -87,6 +83,32 @@ JCenter can be found on [Bintray][].
 [extensions directory]: https://github.com/google/ExoPlayer/tree/release-v2/extensions/
 [Bintray]: https://bintray.com/google/exoplayer
 
+#### 3. Turn on Java 8 support ####
+
+If not enabled already, you also need to turn on Java 8 support in all
+`build.gradle` files depending on ExoPlayer, by adding the following to the
+`android` section:
+
+```gradle
+compileOptions {
+  targetCompatibility JavaVersion.VERSION_1_8
+}
+```
+
+Note that if you want to use Java 8 features in your own code, the following
+additional options need to be set:
+
+```gradle
+// For Java compilers:
+compileOptions {
+  sourceCompatibility JavaVersion.VERSION_1_8
+}
+// For Kotlin compilers:
+kotlinOptions {
+  jvmTarget = JavaVersion.VERSION_1_8
+}
+```
+
 ### Locally ###
 
 Cloning the repository and depending on the modules locally is required when
diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 6b3fbc4f27..68794310bd 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,5 +1,53 @@
 # Release notes #
 
+### 2.9.4 ###
+
+* IMA extension: Clear ads loader listeners on release
+  ([#4114](https://github.com/google/ExoPlayer/issues/4114)).
+* SmoothStreaming: Fix support for subtitles in DRM protected streams
+  ([#5378](https://github.com/google/ExoPlayer/issues/5378)).
+* FFmpeg extension: Treat invalid data errors as non-fatal to match the behavior
+  of MediaCodec ([#5293](https://github.com/google/ExoPlayer/issues/5293)).
+* GVR extension: upgrade GVR SDK dependency to 1.190.0.
+* Associate fatal player errors of type SOURCE with the loading source in
+  `AnalyticsListener.EventTime`
+  ([#5407](https://github.com/google/ExoPlayer/issues/5407)).
+* Add `startPositionUs` to `MediaSource.createPeriod`. This fixes an issue where
+  using lazy preparation in `ConcatenatingMediaSource` with an
+  `ExtractorMediaSource` overrides initial seek positions
+  ([#5350](https://github.com/google/ExoPlayer/issues/5350)).
+* Add subtext to the `MediaDescriptionAdapter` of the
+  `PlayerNotificationManager`.
+* Add workaround for video quality problems with Amlogic decoders
+  ([#5003](https://github.com/google/ExoPlayer/issues/5003)).
+* Fix issue where sending callbacks for playlist changes may cause problems
+  because of parallel player access
+  ([#5240](https://github.com/google/ExoPlayer/issues/5240)).
+* Fix issue with reusing a `ClippingMediaSource` with an inner
+  `ExtractorMediaSource` and a non-zero start position
+  ([#5351](https://github.com/google/ExoPlayer/issues/5351)).
+* Fix issue where uneven track durations in MP4 streams can cause OOM problems
+  ([#3670](https://github.com/google/ExoPlayer/issues/3670)).
+
+### 2.9.3 ###
+
+* Captions: Support PNG subtitles in SMPTE-TT
+  ([#1583](https://github.com/google/ExoPlayer/issues/1583)).
+* MPEG-TS: Use random access indicators to minimize the need for
+  `FLAG_ALLOW_NON_IDR_KEYFRAMES`.
+* Downloading: Reduce time taken to remove downloads
+  ([#5136](https://github.com/google/ExoPlayer/issues/5136)).
+* MP3:
+  * Use the true bitrate for constant-bitrate MP3 seeking.
+  * Fix issue where streams would play twice on some Samsung devices
+    ([#4519](https://github.com/google/ExoPlayer/issues/4519)).
+* Fix regression where some audio formats were incorrectly marked as being
+  unplayable due to under-reporting of platform decoder capabilities
+  ([#5145](https://github.com/google/ExoPlayer/issues/5145)).
+* Fix decode-only frame skipping on Nvidia Shield TV devices.
+* Workaround for MiTV (dangal) issue when swapping output surface
+  ([#5169](https://github.com/google/ExoPlayer/issues/5169)).
+
 ### 2.9.2 ###
 
 * HLS:
@@ -47,10 +95,10 @@
 * DASH: Parse ProgramInformation element if present in the manifest.
 * HLS:
   * Add constructor to `DefaultHlsExtractorFactory` for adding TS payload
-    reader factory flags.
+    reader factory flags
+    ([#4861](https://github.com/google/ExoPlayer/issues/4861)).
   * Fix bug in segment sniffing
     ([#5039](https://github.com/google/ExoPlayer/issues/5039)).
-  ([#4861](https://github.com/google/ExoPlayer/issues/4861)).
 * SubRip: Add support for alignment tags, and remove tags from the displayed
   captions ([#4306](https://github.com/google/ExoPlayer/issues/4306)).
 * Fix issue with blind seeking to windows with non-zero offset in a
diff --git a/constants.gradle b/constants.gradle
index cac4f6d78b..716ddbadba 100644
--- a/constants.gradle
+++ b/constants.gradle
@@ -13,8 +13,8 @@
 // limitations under the License.
 project.ext {
     // ExoPlayer version and version code.
-    releaseVersion = '2.9.2'
-    releaseVersionCode = 2009002
+    releaseVersion = '2.9.4'
+    releaseVersionCode = 2009004
     // Important: ExoPlayer specifies a minSdkVersion of 14 because various
     // components provided by the library may be of use on older devices.
     // However, please note that the core media playback functionality provided
diff --git a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/MainActivity.java b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/MainActivity.java
index 30968b8f85..6589685124 100644
--- a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/MainActivity.java
+++ b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/MainActivity.java
@@ -41,6 +41,7 @@
 import com.google.android.exoplayer2.ui.PlayerView;
 import com.google.android.gms.cast.framework.CastButtonFactory;
 import com.google.android.gms.cast.framework.CastContext;
+import com.google.android.gms.dynamite.DynamiteModule;
 
 /**
  * An activity that plays video using {@link SimpleExoPlayer} and {@link CastPlayer}.
@@ -61,7 +62,20 @@
   public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     // Getting the cast context later than onStart can cause device discovery not to take place.
-    castContext = CastContext.getSharedInstance(this);
+    try {
+      castContext = CastContext.getSharedInstance(this);
+    } catch (RuntimeException e) {
+      Throwable cause = e.getCause();
+      while (cause != null) {
+        if (cause instanceof DynamiteModule.LoadingException) {
+          setContentView(R.layout.cast_context_error_message_layout);
+          return;
+        }
+        cause = cause.getCause();
+      }
+      // Unknown error. We propagate it.
+      throw e;
+    }
 
     setContentView(R.layout.main_activity);
 
@@ -91,6 +105,10 @@ public boolean onCreateOptionsMenu(Menu menu) {
   @Override
   public void onResume() {
     super.onResume();
+    if (castContext == null) {
+      // There is no Cast context to work with. Do nothing.
+      return;
+    }
     playerManager =
         PlayerManager.createPlayerManager(
             /* queuePositionListener= */ this,
@@ -104,6 +122,10 @@ public void onResume() {
   @Override
   public void onPause() {
     super.onPause();
+    if (castContext == null) {
+      // Nothing to release.
+      return;
+    }
     mediaQueueListAdapter.notifyItemRangeRemoved(0, mediaQueueListAdapter.getItemCount());
     mediaQueueList.setAdapter(null);
     playerManager.release();
diff --git a/demos/cast/src/main/res/layout/cast_context_error_message_layout.xml b/demos/cast/src/main/res/layout/cast_context_error_message_layout.xml
new file mode 100644
index 0000000000..6d3260de38
--- /dev/null
+++ b/demos/cast/src/main/res/layout/cast_context_error_message_layout.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2018 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+  android:layout_width="match_parent"
+  android:layout_height="match_parent">
+
+  <TextView
+    android:id="@+id/textView"
+    android:layout_width="0dp"
+    android:layout_height="match_parent"
+    android:layout_weight="1"
+    android:textSize="20sp"
+    android:gravity="center"
+    android:text="@string/cast_context_error"/>
+</LinearLayout>
diff --git a/demos/cast/src/main/res/values/strings.xml b/demos/cast/src/main/res/values/strings.xml
index 3505c40400..58f5233412 100644
--- a/demos/cast/src/main/res/values/strings.xml
+++ b/demos/cast/src/main/res/values/strings.xml
@@ -22,4 +22,6 @@
 
   <string name="sample_list_dialog_title">Add samples</string>
 
+  <string name="cast_context_error">Failed to get Cast context. Try updating Google Play Services and restart the app.</string>
+
 </resources>
diff --git a/extensions/cast/build.gradle b/extensions/cast/build.gradle
index 30fe10085f..0baa074d4a 100644
--- a/extensions/cast/build.gradle
+++ b/extensions/cast/build.gradle
@@ -31,7 +31,9 @@ android {
 }
 
 dependencies {
-    api 'com.google.android.gms:play-services-cast-framework:16.0.3'
+    api 'com.google.android.gms:play-services-cast-framework:16.1.2'
+    compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
+    compileOnly 'org.checkerframework:checker-compat-qual:' + checkerframeworkVersion
     implementation project(modulePrefix + 'library-core')
     implementation project(modulePrefix + 'library-ui')
     testImplementation project(modulePrefix + 'testutils')
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
index 6cf6309796..71322de87e 100644
--- a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
@@ -283,20 +283,29 @@ public void setSessionAvailabilityListener(SessionAvailabilityListener listener)
   // Player implementation.
 
   @Override
+  @Nullable
   public AudioComponent getAudioComponent() {
     return null;
   }
 
   @Override
+  @Nullable
   public VideoComponent getVideoComponent() {
     return null;
   }
 
   @Override
+  @Nullable
   public TextComponent getTextComponent() {
     return null;
   }
 
+  @Override
+  @Nullable
+  public MetadataComponent getMetadataComponent() {
+    return null;
+  }
+
   @Override
   public Looper getApplicationLooper() {
     return Looper.getMainLooper();
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
index 6f3c623f3f..c5b76002fa 100644
--- a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
@@ -37,6 +37,10 @@
   private static final int OUTPUT_BUFFER_SIZE_16BIT = 65536;
   private static final int OUTPUT_BUFFER_SIZE_32BIT = OUTPUT_BUFFER_SIZE_16BIT * 2;
 
+  // Error codes matching ffmpeg_jni.cc.
+  private static final int DECODER_ERROR_INVALID_DATA = -1;
+  private static final int DECODER_ERROR_OTHER = -2;
+
   private final String codecName;
   private final @Nullable byte[] extraData;
   private final @C.Encoding int encoding;
@@ -106,8 +110,14 @@ protected FfmpegDecoderException createUnexpectedDecodeException(Throwable error
     int inputSize = inputData.limit();
     ByteBuffer outputData = outputBuffer.init(inputBuffer.timeUs, outputBufferSize);
     int result = ffmpegDecode(nativeContext, inputData, inputSize, outputData, outputBufferSize);
-    if (result < 0) {
-      return new FfmpegDecoderException("Error decoding (see logcat). Code: " + result);
+    if (result == DECODER_ERROR_INVALID_DATA) {
+      // Treat invalid data errors as non-fatal to match the behavior of MediaCodec. No output will
+      // be produced for this buffer, so mark it as decode-only to ensure that the audio sink's
+      // position is reset when more audio is produced.
+      outputBuffer.setFlags(C.BUFFER_FLAG_DECODE_ONLY);
+      return null;
+    } else if (result == DECODER_ERROR_OTHER) {
+      return new FfmpegDecoderException("Error decoding (see logcat).");
     }
     if (!hasOutputFormat) {
       channelCount = ffmpegGetChannelCount(nativeContext);
diff --git a/extensions/ffmpeg/src/main/jni/ffmpeg_jni.cc b/extensions/ffmpeg/src/main/jni/ffmpeg_jni.cc
index 87579ebb9a..dcd4560e4a 100644
--- a/extensions/ffmpeg/src/main/jni/ffmpeg_jni.cc
+++ b/extensions/ffmpeg/src/main/jni/ffmpeg_jni.cc
@@ -63,6 +63,10 @@ static const AVSampleFormat OUTPUT_FORMAT_PCM_16BIT = AV_SAMPLE_FMT_S16;
 // Output format corresponding to AudioFormat.ENCODING_PCM_FLOAT.
 static const AVSampleFormat OUTPUT_FORMAT_PCM_FLOAT = AV_SAMPLE_FMT_FLT;
 
+// Error codes matching FfmpegDecoder.java.
+static const int DECODER_ERROR_INVALID_DATA = -1;
+static const int DECODER_ERROR_OTHER = -2;
+
 /**
  * Returns the AVCodec with the specified name, or NULL if it is not available.
  */
@@ -79,7 +83,7 @@ AVCodecContext *createContext(JNIEnv *env, AVCodec *codec, jbyteArray extraData,
 
 /**
  * Decodes the packet into the output buffer, returning the number of bytes
- * written, or a negative value in the case of an error.
+ * written, or a negative DECODER_ERROR constant value in the case of an error.
  */
 int decodePacket(AVCodecContext *context, AVPacket *packet,
                  uint8_t *outputBuffer, int outputSize);
@@ -238,6 +242,7 @@ AVCodecContext *createContext(JNIEnv *env, AVCodec *codec, jbyteArray extraData,
     context->channels = rawChannelCount;
     context->channel_layout = av_get_default_channel_layout(rawChannelCount);
   }
+  context->err_recognition = AV_EF_IGNORE_ERR;
   int result = avcodec_open2(context, codec, NULL);
   if (result < 0) {
     logError("avcodec_open2", result);
@@ -254,7 +259,8 @@ int decodePacket(AVCodecContext *context, AVPacket *packet,
   result = avcodec_send_packet(context, packet);
   if (result) {
     logError("avcodec_send_packet", result);
-    return result;
+    return result == AVERROR_INVALIDDATA ? DECODER_ERROR_INVALID_DATA
+                                         : DECODER_ERROR_OTHER;
   }
 
   // Dequeue output data until it runs out.
diff --git a/extensions/gvr/build.gradle b/extensions/gvr/build.gradle
index af973e1345..234f551896 100644
--- a/extensions/gvr/build.gradle
+++ b/extensions/gvr/build.gradle
@@ -32,7 +32,8 @@ android {
 dependencies {
     implementation project(modulePrefix + 'library-core')
     implementation 'com.android.support:support-annotations:' + supportLibraryVersion
-    implementation 'com.google.vr:sdk-audio:1.80.0'
+    api 'com.google.vr:sdk-base:1.190.0'
+    compileOnly 'org.checkerframework:checker-qual:' + checkerframeworkVersion
 }
 
 ext {
diff --git a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
index 6ca3bfd881..9b4b66125c 100644
--- a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
+++ b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
@@ -597,6 +597,8 @@ public void release() {
       adsManager.destroy();
       adsManager = null;
     }
+    adsLoader.removeAdsLoadedListener(/* adsLoadedListener= */ this);
+    adsLoader.removeAdErrorListener(/* adErrorListener= */ this);
     imaPausedContent = false;
     imaAdState = IMA_AD_STATE_NONE;
     pendingAdLoadError = null;
diff --git a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsMediaSource.java b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsMediaSource.java
index 400061d019..0978ee401c 100644
--- a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsMediaSource.java
+++ b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsMediaSource.java
@@ -76,6 +76,12 @@ public ImaAdsMediaSource(
         adUiViewGroup, eventHandler, eventListener);
   }
 
+  @Override
+  @Nullable
+  public Object getTag() {
+    return adsMediaSource.getTag();
+  }
+
   @Override
   public void prepareSourceInternal(
       final ExoPlayer player,
@@ -91,8 +97,8 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
-    return adsMediaSource.createPeriod(id, allocator);
+  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
+    return adsMediaSource.createPeriod(id, allocator, startPositionUs);
   }
 
   @Override
diff --git a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakeAd.java b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakeAd.java
index b626a08780..59dfc6473c 100644
--- a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakeAd.java
+++ b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakeAd.java
@@ -64,14 +64,17 @@ public double getTimeOffset() {
         };
   }
 
+  @Override
   public int getVastMediaWidth() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public int getVastMediaHeight() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public int getVastMediaBitrate() {
     throw new UnsupportedOperationException();
   }
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueEditor.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueEditor.java
index 4f9c553a15..7c00fcdf17 100644
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueEditor.java
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueEditor.java
@@ -64,13 +64,6 @@
    * {@link MediaSessionConnector}.
    */
   public interface QueueDataAdapter {
-    /**
-     * Gets the {@link MediaDescriptionCompat} for a {@code position}.
-     *
-     * @param position The position in the queue for which to provide a description.
-     * @return A {@link MediaDescriptionCompat}.
-     */
-    MediaDescriptionCompat getMediaDescription(int position);
     /**
      * Adds a {@link MediaDescriptionCompat} at the given {@code position}.
      *
diff --git a/extensions/rtmp/README.md b/extensions/rtmp/README.md
index b222bdabd9..3863dff965 100644
--- a/extensions/rtmp/README.md
+++ b/extensions/rtmp/README.md
@@ -39,7 +39,7 @@ either instantiated and injected from application code, or obtained from
 instances of `DataSource.Factory` that are instantiated and injected from
 application code.
 
-`DefaultDataSource` will automatically use uses the RTMP extension whenever it's
+`DefaultDataSource` will automatically use the RTMP extension whenever it's
 available. Hence if your application is using `DefaultDataSource` or
 `DefaultDataSourceFactory`, adding support for RTMP streams is as simple as
 adding a dependency to the RTMP extension as described above. No changes to your
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/C.java b/library/core/src/main/java/com/google/android/exoplayer2/C.java
index fac9818d9e..8810b51000 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/C.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/C.java
@@ -460,8 +460,8 @@ private C() {}
 
   /**
    * Flags which can apply to a buffer containing a media sample. Possible flag values are {@link
-   * #BUFFER_FLAG_KEY_FRAME}, {@link #BUFFER_FLAG_END_OF_STREAM}, {@link #BUFFER_FLAG_ENCRYPTED} and
-   * {@link #BUFFER_FLAG_DECODE_ONLY}.
+   * #BUFFER_FLAG_KEY_FRAME}, {@link #BUFFER_FLAG_END_OF_STREAM}, {@link #BUFFER_FLAG_LAST_SAMPLE},
+   * {@link #BUFFER_FLAG_ENCRYPTED} and {@link #BUFFER_FLAG_DECODE_ONLY}.
    */
   @Documented
   @Retention(RetentionPolicy.SOURCE)
@@ -470,6 +470,7 @@ private C() {}
       value = {
         BUFFER_FLAG_KEY_FRAME,
         BUFFER_FLAG_END_OF_STREAM,
+        BUFFER_FLAG_LAST_SAMPLE,
         BUFFER_FLAG_ENCRYPTED,
         BUFFER_FLAG_DECODE_ONLY
       })
@@ -482,6 +483,8 @@ private C() {}
    * Flag for empty buffers that signal that the end of the stream was reached.
    */
   public static final int BUFFER_FLAG_END_OF_STREAM = MediaCodec.BUFFER_FLAG_END_OF_STREAM;
+  /** Indicates that a buffer is known to contain the last media sample of the stream. */
+  public static final int BUFFER_FLAG_LAST_SAMPLE = 1 << 29; // 0x20000000
   /** Indicates that a buffer is (at least partially) encrypted. */
   public static final int BUFFER_FLAG_ENCRYPTED = 1 << 30; // 0x40000000
   /** Indicates that a buffer should be decoded but not rendered. */
@@ -896,6 +899,26 @@ private C() {}
    */
   public static final int COLOR_RANGE_FULL = MediaFormat.COLOR_RANGE_FULL;
 
+  /** Video projection types. */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({
+    Format.NO_VALUE,
+    PROJECTION_RECTANGULAR,
+    PROJECTION_EQUIRECTANGULAR,
+    PROJECTION_CUBEMAP,
+    PROJECTION_MESH
+  })
+  public @interface Projection {}
+  /** Conventional rectangular projection. */
+  public static final int PROJECTION_RECTANGULAR = 0;
+  /** Equirectangular spherical projection. */
+  public static final int PROJECTION_EQUIRECTANGULAR = 1;
+  /** Cube map projection. */
+  public static final int PROJECTION_CUBEMAP = 2;
+  /** 3-D mesh projection. */
+  public static final int PROJECTION_MESH = 3;
+
   /**
    * Priority for media playback.
    *
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
index ffdadb78f7..35fa85e467 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
@@ -144,20 +144,29 @@ public void handleMessage(Message msg) {
   }
 
   @Override
+  @Nullable
   public AudioComponent getAudioComponent() {
     return null;
   }
 
   @Override
+  @Nullable
   public VideoComponent getVideoComponent() {
     return null;
   }
 
   @Override
+  @Nullable
   public TextComponent getTextComponent() {
     return null;
   }
 
+  @Override
+  @Nullable
+  public MetadataComponent getMetadataComponent() {
+    return null;
+  }
+
   @Override
   public Looper getPlaybackLooper() {
     return internalPlayer.getPlaybackLooper();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
index c30fe160c9..36723c5d73 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
@@ -29,11 +29,11 @@
 
   /** The version of the library expressed as a string, for example "1.2.3". */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION_INT) or vice versa.
-  public static final String VERSION = "2.9.2";
+  public static final String VERSION = "2.9.4";
 
   /** The version of the library expressed as {@code "ExoPlayerLib/" + VERSION}. */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
-  public static final String VERSION_SLASHY = "ExoPlayerLib/2.9.2";
+  public static final String VERSION_SLASHY = "ExoPlayerLib/2.9.4";
 
   /**
    * The version of the library expressed as an integer, for example 1002003.
@@ -43,7 +43,7 @@
    * integer version 123045006 (123-045-006).
    */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
-  public static final int VERSION_INT = 2009002;
+  public static final int VERSION_INT = 2009004;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer2.util.Assertions}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Format.java b/library/core/src/main/java/com/google/android/exoplayer2/Format.java
index 3456fc39a2..d40ae6eccd 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Format.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Format.java
@@ -1181,6 +1181,37 @@ public Format copyWithGaplessInfo(int encoderDelay, int encoderPadding) {
         metadata);
   }
 
+  public Format copyWithFrameRate(float frameRate) {
+    return new Format(
+        id,
+        label,
+        containerMimeType,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        maxInputSize,
+        width,
+        height,
+        frameRate,
+        rotationDegrees,
+        pixelWidthHeightRatio,
+        projectionData,
+        stereoMode,
+        colorInfo,
+        channelCount,
+        sampleRate,
+        pcmEncoding,
+        encoderDelay,
+        encoderPadding,
+        selectionFlags,
+        language,
+        accessibilityChannel,
+        subsampleOffsetUs,
+        initializationData,
+        drmInitData,
+        metadata);
+  }
+
   public Format copyWithDrmInitData(@Nullable DrmInitData drmInitData) {
     return new Format(
         id,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
index 5925c8f383..8e51740c56 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
@@ -79,7 +79,7 @@ public MediaPeriodHolder(
     this.info = info;
     sampleStreams = new SampleStream[rendererCapabilities.length];
     mayRetainStreamFlags = new boolean[rendererCapabilities.length];
-    MediaPeriod mediaPeriod = mediaSource.createPeriod(info.id, allocator);
+    MediaPeriod mediaPeriod = mediaSource.createPeriod(info.id, allocator, info.startPositionUs);
     if (info.id.endPositionUs != C.TIME_END_OF_SOURCE) {
       mediaPeriod =
           new ClippingMediaPeriod(
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Player.java b/library/core/src/main/java/com/google/android/exoplayer2/Player.java
index 16f8aa2878..e3441fb2a7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Player.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Player.java
@@ -26,6 +26,7 @@
 import com.google.android.exoplayer2.audio.AudioAttributes;
 import com.google.android.exoplayer2.audio.AudioListener;
 import com.google.android.exoplayer2.audio.AuxEffectInfo;
+import com.google.android.exoplayer2.metadata.MetadataOutput;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.text.TextOutput;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
@@ -299,6 +300,24 @@
     void removeTextOutput(TextOutput listener);
   }
 
+  /** The metadata component of a {@link Player}. */
+  interface MetadataComponent {
+
+    /**
+     * Adds a {@link MetadataOutput} to receive metadata.
+     *
+     * @param output The output to register.
+     */
+    void addMetadataOutput(MetadataOutput output);
+
+    /**
+     * Removes a {@link MetadataOutput}.
+     *
+     * @param output The output to remove.
+     */
+    void removeMetadataOutput(MetadataOutput output);
+  }
+
   /**
    * Listener of changes in player state. All methods have no-op default implementations to allow
    * selective overrides.
@@ -533,6 +552,12 @@ public void onTimelineChanged(Timeline timeline, @Nullable Object manifest) {
   @Nullable
   TextComponent getTextComponent();
 
+  /**
+   * Returns the component of this player for metadata output, or null if metadata is not supported.
+   */
+  @Nullable
+  MetadataComponent getMetadataComponent();
+
   /**
    * Returns the {@link Looper} associated with the application thread that's used to access the
    * player and on which player events are received.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
index 8517556887..eba02b0c0a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
@@ -65,7 +65,11 @@
  */
 @TargetApi(16)
 public class SimpleExoPlayer extends BasePlayer
-    implements ExoPlayer, Player.AudioComponent, Player.VideoComponent, Player.TextComponent {
+    implements ExoPlayer,
+        Player.AudioComponent,
+        Player.VideoComponent,
+        Player.TextComponent,
+        Player.MetadataComponent {
 
   /** @deprecated Use {@link com.google.android.exoplayer2.video.VideoListener}. */
   @Deprecated
@@ -90,25 +94,25 @@
 
   private final AudioFocusManager audioFocusManager;
 
-  private Format videoFormat;
-  private Format audioFormat;
+  @Nullable private Format videoFormat;
+  @Nullable private Format audioFormat;
 
-  private Surface surface;
+  @Nullable private Surface surface;
   private boolean ownsSurface;
   private @C.VideoScalingMode int videoScalingMode;
-  private SurfaceHolder surfaceHolder;
-  private TextureView textureView;
+  @Nullable private SurfaceHolder surfaceHolder;
+  @Nullable private TextureView textureView;
   private int surfaceWidth;
   private int surfaceHeight;
-  private DecoderCounters videoDecoderCounters;
-  private DecoderCounters audioDecoderCounters;
+  @Nullable private DecoderCounters videoDecoderCounters;
+  @Nullable private DecoderCounters audioDecoderCounters;
   private int audioSessionId;
   private AudioAttributes audioAttributes;
   private float audioVolume;
-  private MediaSource mediaSource;
+  @Nullable private MediaSource mediaSource;
   private List<Cue> currentCues;
-  private VideoFrameMetadataListener videoFrameMetadataListener;
-  private CameraMotionListener cameraMotionListener;
+  @Nullable private VideoFrameMetadataListener videoFrameMetadataListener;
+  @Nullable private CameraMotionListener cameraMotionListener;
   private boolean hasNotifiedFullWrongThreadWarning;
 
   /**
@@ -243,20 +247,29 @@ protected SimpleExoPlayer(
   }
 
   @Override
+  @Nullable
   public AudioComponent getAudioComponent() {
     return this;
   }
 
   @Override
+  @Nullable
   public VideoComponent getVideoComponent() {
     return this;
   }
 
   @Override
+  @Nullable
   public TextComponent getTextComponent() {
     return this;
   }
 
+  @Override
+  @Nullable
+  public MetadataComponent getMetadataComponent() {
+    return this;
+  }
+
   /**
    * Sets the video scaling mode.
    *
@@ -545,30 +558,26 @@ public void setPlaybackParams(@Nullable PlaybackParams params) {
     setPlaybackParameters(playbackParameters);
   }
 
-  /**
-   * Returns the video format currently being played, or null if no video is being played.
-   */
+  /** Returns the video format currently being played, or null if no video is being played. */
+  @Nullable
   public Format getVideoFormat() {
     return videoFormat;
   }
 
-  /**
-   * Returns the audio format currently being played, or null if no audio is being played.
-   */
+  /** Returns the audio format currently being played, or null if no audio is being played. */
+  @Nullable
   public Format getAudioFormat() {
     return audioFormat;
   }
 
-  /**
-   * Returns {@link DecoderCounters} for video, or null if no video is being played.
-   */
+  /** Returns {@link DecoderCounters} for video, or null if no video is being played. */
+  @Nullable
   public DecoderCounters getVideoDecoderCounters() {
     return videoDecoderCounters;
   }
 
-  /**
-   * Returns {@link DecoderCounters} for audio, or null if no audio is being played.
-   */
+  /** Returns {@link DecoderCounters} for audio, or null if no audio is being played. */
+  @Nullable
   public DecoderCounters getAudioDecoderCounters() {
     return audioDecoderCounters;
   }
@@ -713,20 +722,12 @@ public void clearTextOutput(TextOutput output) {
     removeTextOutput(output);
   }
 
-  /**
-   * Adds a {@link MetadataOutput} to receive metadata.
-   *
-   * @param listener The output to register.
-   */
+  @Override
   public void addMetadataOutput(MetadataOutput listener) {
     metadataOutputs.add(listener);
   }
 
-  /**
-   * Removes a {@link MetadataOutput}.
-   *
-   * @param listener The output to remove.
-   */
+  @Override
   public void removeMetadataOutput(MetadataOutput listener) {
     metadataOutputs.remove(listener);
   }
@@ -1043,7 +1044,8 @@ public Timeline getCurrentTimeline() {
   }
 
   @Override
-  public @Nullable Object getCurrentManifest() {
+  @Nullable
+  public Object getCurrentManifest() {
     verifyApplicationThread();
     return player.getCurrentManifest();
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsCollector.java b/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsCollector.java
index 113add612a..55031e2d12 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsCollector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsCollector.java
@@ -488,7 +488,10 @@ public final void onShuffleModeEnabledChanged(boolean shuffleModeEnabled) {
 
   @Override
   public final void onPlayerError(ExoPlaybackException error) {
-    EventTime eventTime = generatePlayingMediaPeriodEventTime();
+    EventTime eventTime =
+        error.type == ExoPlaybackException.TYPE_SOURCE
+            ? generateLoadingMediaPeriodEventTime()
+            : generatePlayingMediaPeriodEventTime();
     for (AnalyticsListener listener : listeners) {
       listener.onPlayerError(eventTime, error);
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioRendererEventListener.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioRendererEventListener.java
index 7c3c1481fc..eff7bc8de2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioRendererEventListener.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioRendererEventListener.java
@@ -25,7 +25,8 @@
 import com.google.android.exoplayer2.util.Assertions;
 
 /**
- * Listener of audio {@link Renderer} events.
+ * Listener of audio {@link Renderer} events. All methods have no-op default implementations to
+ * allow selective overrides.
  */
 public interface AudioRendererEventListener {
 
@@ -35,14 +36,14 @@
    * @param counters {@link DecoderCounters} that will be updated by the renderer for as long as it
    *     remains enabled.
    */
-  void onAudioEnabled(DecoderCounters counters);
+  default void onAudioEnabled(DecoderCounters counters) {}
 
   /**
    * Called when the audio session is set.
    *
    * @param audioSessionId The audio session id.
    */
-  void onAudioSessionId(int audioSessionId);
+  default void onAudioSessionId(int audioSessionId) {}
 
   /**
    * Called when a decoder is created.
@@ -52,15 +53,15 @@
    *     finished.
    * @param initializationDurationMs The time taken to initialize the decoder in milliseconds.
    */
-  void onAudioDecoderInitialized(String decoderName, long initializedTimestampMs,
-      long initializationDurationMs);
+  default void onAudioDecoderInitialized(
+      String decoderName, long initializedTimestampMs, long initializationDurationMs) {}
 
   /**
    * Called when the format of the media being consumed by the renderer changes.
    *
    * @param format The new format.
    */
-  void onAudioInputFormatChanged(Format format);
+  default void onAudioInputFormatChanged(Format format) {}
 
   /**
    * Called when an {@link AudioSink} underrun occurs.
@@ -71,14 +72,15 @@ void onAudioDecoderInitialized(String decoderName, long initializedTimestampMs,
    *     as the buffered media can have a variable bitrate so the duration may be unknown.
    * @param elapsedSinceLastFeedMs The time since the {@link AudioSink} was last fed data.
    */
-  void onAudioSinkUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs);
+  default void onAudioSinkUnderrun(
+      int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {}
 
   /**
    * Called when the renderer is disabled.
    *
    * @param counters {@link DecoderCounters} that were updated by the renderer.
    */
-  void onAudioDisabled(DecoderCounters counters);
+  default void onAudioDisabled(DecoderCounters counters) {}
 
   /**
    * Dispatches events to a {@link AudioRendererEventListener}.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
index 9b6be57e4c..bd63765953 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
@@ -366,7 +366,10 @@ private boolean drainOutputBuffer() throws ExoPlaybackException, AudioDecoderExc
       if (outputBuffer == null) {
         return false;
       }
-      decoderCounters.skippedOutputBufferCount += outputBuffer.skippedOutputBufferCount;
+      if (outputBuffer.skippedOutputBufferCount > 0) {
+        decoderCounters.skippedOutputBufferCount += outputBuffer.skippedOutputBufferCount;
+        audioSink.handleDiscontinuity();
+      }
     }
 
     if (outputBuffer.isEndOfStream()) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/MpegAudioHeader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/MpegAudioHeader.java
index ab49ca5454..87bb992082 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/MpegAudioHeader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/MpegAudioHeader.java
@@ -34,16 +34,26 @@
   private static final String[] MIME_TYPE_BY_LAYER =
       new String[] {MimeTypes.AUDIO_MPEG_L1, MimeTypes.AUDIO_MPEG_L2, MimeTypes.AUDIO_MPEG};
   private static final int[] SAMPLING_RATE_V1 = {44100, 48000, 32000};
-  private static final int[] BITRATE_V1_L1 =
-      {32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448};
-  private static final int[] BITRATE_V2_L1 =
-      {32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256};
-  private static final int[] BITRATE_V1_L2 =
-      {32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384};
-  private static final int[] BITRATE_V1_L3 =
-      {32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320};
-  private static final int[] BITRATE_V2 =
-      {8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160};
+  private static final int[] BITRATE_V1_L1 = {
+    32000, 64000, 96000, 128000, 160000, 192000, 224000, 256000, 288000, 320000, 352000, 384000,
+    416000, 448000
+  };
+  private static final int[] BITRATE_V2_L1 = {
+    32000, 48000, 56000, 64000, 80000, 96000, 112000, 128000, 144000, 160000, 176000, 192000,
+    224000, 256000
+  };
+  private static final int[] BITRATE_V1_L2 = {
+    32000, 48000, 56000, 64000, 80000, 96000, 112000, 128000, 160000, 192000, 224000, 256000,
+    320000, 384000
+  };
+  private static final int[] BITRATE_V1_L3 = {
+    32000, 40000, 48000, 56000, 64000, 80000, 96000, 112000, 128000, 160000, 192000, 224000, 256000,
+    320000
+  };
+  private static final int[] BITRATE_V2 = {
+    8000, 16000, 24000, 32000, 40000, 48000, 56000, 64000, 80000, 96000, 112000, 128000, 144000,
+    160000
+  };
 
   /**
    * Returns the size of the frame associated with {@code header}, or {@link C#LENGTH_UNSET} if it
@@ -89,7 +99,7 @@ public static int getFrameSize(int header) {
     if (layer == 3) {
       // Layer I (layer == 3)
       bitrate = version == 3 ? BITRATE_V1_L1[bitrateIndex - 1] : BITRATE_V2_L1[bitrateIndex - 1];
-      return (12000 * bitrate / samplingRate + padding) * 4;
+      return (12 * bitrate / samplingRate + padding) * 4;
     } else {
       // Layer II (layer == 2) or III (layer == 1)
       if (version == 3) {
@@ -102,10 +112,10 @@ public static int getFrameSize(int header) {
 
     if (version == 3) {
       // Version 1
-      return 144000 * bitrate / samplingRate + padding;
+      return 144 * bitrate / samplingRate + padding;
     } else {
       // Version 2 or 2.5
-      return (layer == 1 ? 72000 : 144000) * bitrate / samplingRate + padding;
+      return (layer == 1 ? 72 : 144) * bitrate / samplingRate + padding;
     }
   }
 
@@ -159,7 +169,7 @@ public static boolean populateHeader(int headerData, MpegAudioHeader header) {
     if (layer == 3) {
       // Layer I (layer == 3)
       bitrate = version == 3 ? BITRATE_V1_L1[bitrateIndex - 1] : BITRATE_V2_L1[bitrateIndex - 1];
-      frameSize = (12000 * bitrate / sampleRate + padding) * 4;
+      frameSize = (12 * bitrate / sampleRate + padding) * 4;
       samplesPerFrame = 384;
     } else {
       // Layer II (layer == 2) or III (layer == 1)
@@ -167,19 +177,22 @@ public static boolean populateHeader(int headerData, MpegAudioHeader header) {
         // Version 1
         bitrate = layer == 2 ? BITRATE_V1_L2[bitrateIndex - 1] : BITRATE_V1_L3[bitrateIndex - 1];
         samplesPerFrame = 1152;
-        frameSize = 144000 * bitrate / sampleRate + padding;
+        frameSize = 144 * bitrate / sampleRate + padding;
       } else {
         // Version 2 or 2.5.
         bitrate = BITRATE_V2[bitrateIndex - 1];
         samplesPerFrame = layer == 1 ? 576 : 1152;
-        frameSize = (layer == 1 ? 72000 : 144000) * bitrate / sampleRate + padding;
+        frameSize = (layer == 1 ? 72 : 144) * bitrate / sampleRate + padding;
       }
     }
 
+    // Calculate the bitrate in the same way Mp3Extractor calculates sample timestamps so that
+    // seeking to a given timestamp and playing from the start up to that timestamp give the same
+    // results for CBR streams. See also [internal: b/120390268].
+    bitrate = 8 * frameSize * sampleRate / samplesPerFrame;
     String mimeType = MIME_TYPE_BY_LAYER[3 - layer];
     int channels = ((headerData >> 6) & 3) == 3 ? 1 : 2;
-    header.setValues(version, mimeType, frameSize, sampleRate, channels, bitrate * 1000,
-        samplesPerFrame);
+    header.setValues(version, mimeType, frameSize, sampleRate, channels, bitrate, samplesPerFrame);
     return true;
   }
 
@@ -198,8 +211,14 @@ public static boolean populateHeader(int headerData, MpegAudioHeader header) {
   /** Number of samples stored in the frame. */
   public int samplesPerFrame;
 
-  private void setValues(int version, String mimeType, int frameSize, int sampleRate, int channels,
-      int bitrate, int samplesPerFrame) {
+  private void setValues(
+      int version,
+      String mimeType,
+      int frameSize,
+      int sampleRate,
+      int channels,
+      int bitrate,
+      int samplesPerFrame) {
     this.version = version;
     this.mimeType = mimeType;
     this.frameSize = frameSize;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
index 86b750e821..187b9ae443 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
@@ -191,7 +191,11 @@
   private static final int ID_CUE_CLUSTER_POSITION = 0xF1;
   private static final int ID_LANGUAGE = 0x22B59C;
   private static final int ID_PROJECTION = 0x7670;
+  private static final int ID_PROJECTION_TYPE = 0x7671;
   private static final int ID_PROJECTION_PRIVATE = 0x7672;
+  private static final int ID_PROJECTION_POSE_YAW = 0x7673;
+  private static final int ID_PROJECTION_POSE_PITCH = 0x7674;
+  private static final int ID_PROJECTION_POSE_ROLL = 0x7675;
   private static final int ID_STEREO_MODE = 0x53B8;
   private static final int ID_COLOUR = 0x55B0;
   private static final int ID_COLOUR_RANGE = 0x55B9;
@@ -760,6 +764,24 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       case ID_MAX_FALL:
         currentTrack.maxFrameAverageLuminance = (int) value;
         break;
+      case ID_PROJECTION_TYPE:
+        switch ((int) value) {
+          case 0:
+            currentTrack.projectionType = C.PROJECTION_RECTANGULAR;
+            break;
+          case 1:
+            currentTrack.projectionType = C.PROJECTION_EQUIRECTANGULAR;
+            break;
+          case 2:
+            currentTrack.projectionType = C.PROJECTION_CUBEMAP;
+            break;
+          case 3:
+            currentTrack.projectionType = C.PROJECTION_MESH;
+            break;
+          default:
+            break;
+        }
+        break;
       default:
         break;
     }
@@ -803,6 +825,15 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       case ID_LUMNINANCE_MIN:
         currentTrack.minMasteringLuminance = (float) value;
         break;
+      case ID_PROJECTION_POSE_YAW:
+        currentTrack.projectionPoseYaw = (float) value;
+        break;
+      case ID_PROJECTION_POSE_PITCH:
+        currentTrack.projectionPosePitch = (float) value;
+        break;
+      case ID_PROJECTION_POSE_ROLL:
+        currentTrack.projectionPoseRoll = (float) value;
+        break;
       default:
         break;
     }
@@ -1465,6 +1496,7 @@ public int getElementType(int id) {
         case ID_COLOUR_PRIMARIES:
         case ID_MAX_CLL:
         case ID_MAX_FALL:
+        case ID_PROJECTION_TYPE:
           return TYPE_UNSIGNED_INT;
         case ID_DOC_TYPE:
         case ID_NAME:
@@ -1491,6 +1523,9 @@ public int getElementType(int id) {
         case ID_WHITE_POINT_CHROMATICITY_Y:
         case ID_LUMNINANCE_MAX:
         case ID_LUMNINANCE_MIN:
+        case ID_PROJECTION_POSE_YAW:
+        case ID_PROJECTION_POSE_PITCH:
+        case ID_PROJECTION_POSE_ROLL:
           return TYPE_FLOAT;
         default:
           return TYPE_UNKNOWN;
@@ -1631,6 +1666,10 @@ public void outputPendingSampleMetadata(Track track) {
     public int displayWidth = Format.NO_VALUE;
     public int displayHeight = Format.NO_VALUE;
     public int displayUnit = DISPLAY_UNIT_PIXELS;
+    @C.Projection public int projectionType = Format.NO_VALUE;
+    public float projectionPoseYaw = 0f;
+    public float projectionPosePitch = 0f;
+    public float projectionPoseRoll = 0f;
     public byte[] projectionData = null;
     @C.StereoMode
     public int stereoMode = Format.NO_VALUE;
@@ -1850,6 +1889,21 @@ public void initializeOutput(ExtractorOutput output, int trackId) throws ParserE
         } else if ("htc_video_rotA-270".equals(name)) {
           rotationDegrees = 270;
         }
+        if (projectionType == C.PROJECTION_RECTANGULAR
+            && Float.compare(projectionPoseYaw, 0f) == 0
+            && Float.compare(projectionPosePitch, 0f) == 0) {
+          // The range of projectionPoseRoll is [-180, 180].
+          if (Float.compare(projectionPoseRoll, 0f) == 0) {
+            rotationDegrees = 0;
+          } else if (Float.compare(projectionPosePitch, 90f) == 0) {
+            rotationDegrees = 90;
+          } else if (Float.compare(projectionPosePitch, -180f) == 0
+              || Float.compare(projectionPosePitch, 180f) == 0) {
+            rotationDegrees = 180;
+          } else if (Float.compare(projectionPosePitch, -90f) == 0) {
+            rotationDegrees = 270;
+          }
+        }
         format =
             Format.createVideoSampleFormat(
                 Integer.toString(trackId),
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java
index f51c97389b..8d78337617 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java
@@ -22,8 +22,8 @@
 import java.util.Arrays;
 import java.util.List;
 
-@SuppressWarnings("ConstantField")
-/* package*/ abstract class Atom {
+@SuppressWarnings({"ConstantField", "ConstantCaseForConstants"})
+/* package */ abstract class Atom {
 
   /**
    * Size of an atom header, in bytes.
@@ -130,6 +130,7 @@
   public static final int TYPE_sawb = Util.getIntegerCodeForString("sawb");
   public static final int TYPE_udta = Util.getIntegerCodeForString("udta");
   public static final int TYPE_meta = Util.getIntegerCodeForString("meta");
+  public static final int TYPE_keys = Util.getIntegerCodeForString("keys");
   public static final int TYPE_ilst = Util.getIntegerCodeForString("ilst");
   public static final int TYPE_mean = Util.getIntegerCodeForString("mean");
   public static final int TYPE_name = Util.getIntegerCodeForString("name");
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
index d085156f2b..008a155d1f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
@@ -17,6 +17,7 @@
 
 import static com.google.android.exoplayer2.util.MimeTypes.getMimeTypeFromMp4ObjectType;
 
+import android.support.annotation.Nullable;
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
@@ -39,7 +40,7 @@
 import java.util.List;
 
 /** Utility methods for parsing MP4 format atom payloads according to ISO 14496-12. */
-@SuppressWarnings("ConstantField")
+@SuppressWarnings({"ConstantField", "ConstantCaseForConstants"})
 /* package */ final class AtomParsers {
 
   private static final String TAG = "AtomParsers";
@@ -51,6 +52,7 @@
   private static final int TYPE_subt = Util.getIntegerCodeForString("subt");
   private static final int TYPE_clcp = Util.getIntegerCodeForString("clcp");
   private static final int TYPE_meta = Util.getIntegerCodeForString("meta");
+  private static final int TYPE_mdta = Util.getIntegerCodeForString("mdta");
 
   /**
    * The threshold number of samples to trim from the start/end of an audio track when applying an
@@ -77,7 +79,7 @@ public static Track parseTrak(Atom.ContainerAtom trak, Atom.LeafAtom mvhd, long
       DrmInitData drmInitData, boolean ignoreEditLists, boolean isQuickTime)
       throws ParserException {
     Atom.ContainerAtom mdia = trak.getContainerAtomOfType(Atom.TYPE_mdia);
-    int trackType = parseHdlr(mdia.getLeafAtomOfType(Atom.TYPE_hdlr).data);
+    int trackType = getTrackTypeForHdlr(parseHdlr(mdia.getLeafAtomOfType(Atom.TYPE_hdlr).data));
     if (trackType == C.TRACK_TYPE_UNKNOWN) {
       return null;
     }
@@ -485,6 +487,7 @@ public static TrackSampleTable parseStbl(
    * @param isQuickTime True for QuickTime media. False otherwise.
    * @return Parsed metadata, or null.
    */
+  @Nullable
   public static Metadata parseUdta(Atom.LeafAtom udtaAtom, boolean isQuickTime) {
     if (isQuickTime) {
       // Meta boxes are regular boxes rather than full boxes in QuickTime. For now, don't try and
@@ -499,14 +502,69 @@ public static Metadata parseUdta(Atom.LeafAtom udtaAtom, boolean isQuickTime) {
       int atomType = udtaData.readInt();
       if (atomType == Atom.TYPE_meta) {
         udtaData.setPosition(atomPosition);
-        return parseMetaAtom(udtaData, atomPosition + atomSize);
+        return parseUdtaMeta(udtaData, atomPosition + atomSize);
       }
-      udtaData.skipBytes(atomSize - Atom.HEADER_SIZE);
+      udtaData.setPosition(atomPosition + atomSize);
     }
     return null;
   }
 
-  private static Metadata parseMetaAtom(ParsableByteArray meta, int limit) {
+  /**
+   * Parses a metadata meta atom if it contains metadata with handler 'mdta'.
+   *
+   * @param meta The metadata atom to decode.
+   * @return Parsed metadata, or null.
+   */
+  @Nullable
+  public static Metadata parseMdtaFromMeta(Atom.ContainerAtom meta) {
+    Atom.LeafAtom hdlrAtom = meta.getLeafAtomOfType(Atom.TYPE_hdlr);
+    Atom.LeafAtom keysAtom = meta.getLeafAtomOfType(Atom.TYPE_keys);
+    Atom.LeafAtom ilstAtom = meta.getLeafAtomOfType(Atom.TYPE_ilst);
+    if (hdlrAtom == null
+        || keysAtom == null
+        || ilstAtom == null
+        || AtomParsers.parseHdlr(hdlrAtom.data) != TYPE_mdta) {
+      // There isn't enough information to parse the metadata, or the handler type is unexpected.
+      return null;
+    }
+
+    // Parse metadata keys.
+    ParsableByteArray keys = keysAtom.data;
+    keys.setPosition(Atom.FULL_HEADER_SIZE);
+    int entryCount = keys.readInt();
+    String[] keyNames = new String[entryCount];
+    for (int i = 0; i < entryCount; i++) {
+      int entrySize = keys.readInt();
+      keys.skipBytes(4); // keyNamespace
+      int keySize = entrySize - 8;
+      keyNames[i] = keys.readString(keySize);
+    }
+
+    // Parse metadata items.
+    ParsableByteArray ilst = ilstAtom.data;
+    ilst.setPosition(Atom.HEADER_SIZE);
+    ArrayList<Metadata.Entry> entries = new ArrayList<>();
+    while (ilst.bytesLeft() > Atom.HEADER_SIZE) {
+      int atomPosition = ilst.getPosition();
+      int atomSize = ilst.readInt();
+      int keyIndex = ilst.readInt() - 1;
+      if (keyIndex >= 0 && keyIndex < keyNames.length) {
+        String key = keyNames[keyIndex];
+        Metadata.Entry entry =
+            MetadataUtil.parseMdtaMetadataEntryFromIlst(ilst, atomPosition + atomSize, key);
+        if (entry != null) {
+          entries.add(entry);
+        }
+      } else {
+        Log.w(TAG, "Skipped metadata with unknown key index: " + keyIndex);
+      }
+      ilst.setPosition(atomPosition + atomSize);
+    }
+    return entries.isEmpty() ? null : new Metadata(entries);
+  }
+
+  @Nullable
+  private static Metadata parseUdtaMeta(ParsableByteArray meta, int limit) {
     meta.skipBytes(Atom.FULL_HEADER_SIZE);
     while (meta.getPosition() < limit) {
       int atomPosition = meta.getPosition();
@@ -516,11 +574,12 @@ private static Metadata parseMetaAtom(ParsableByteArray meta, int limit) {
         meta.setPosition(atomPosition);
         return parseIlst(meta, atomPosition + atomSize);
       }
-      meta.skipBytes(atomSize - Atom.HEADER_SIZE);
+      meta.setPosition(atomPosition + atomSize);
     }
     return null;
   }
 
+  @Nullable
   private static Metadata parseIlst(ParsableByteArray ilst, int limit) {
     ilst.skipBytes(Atom.HEADER_SIZE);
     ArrayList<Metadata.Entry> entries = new ArrayList<>();
@@ -610,19 +669,22 @@ private static TkhdData parseTkhd(ParsableByteArray tkhd) {
    * Parses an hdlr atom.
    *
    * @param hdlr The hdlr atom to decode.
-   * @return The track type.
+   * @return The handler value.
    */
   private static int parseHdlr(ParsableByteArray hdlr) {
     hdlr.setPosition(Atom.FULL_HEADER_SIZE + 4);
-    int trackType = hdlr.readInt();
-    if (trackType == TYPE_soun) {
+    return hdlr.readInt();
+  }
+
+  /** Returns the track type for a given handler value. */
+  private static int getTrackTypeForHdlr(int hdlr) {
+    if (hdlr == TYPE_soun) {
       return C.TRACK_TYPE_AUDIO;
-    } else if (trackType == TYPE_vide) {
+    } else if (hdlr == TYPE_vide) {
       return C.TRACK_TYPE_VIDEO;
-    } else if (trackType == TYPE_text || trackType == TYPE_sbtl || trackType == TYPE_subt
-        || trackType == TYPE_clcp) {
+    } else if (hdlr == TYPE_text || hdlr == TYPE_sbtl || hdlr == TYPE_subt || hdlr == TYPE_clcp) {
       return C.TRACK_TYPE_TEXT;
-    } else if (trackType == TYPE_meta) {
+    } else if (hdlr == TYPE_meta) {
       return C.TRACK_TYPE_METADATA;
     } else {
       return C.TRACK_TYPE_UNKNOWN;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/MdtaMetadataEntry.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/MdtaMetadataEntry.java
new file mode 100644
index 0000000000..b458a8f0f4
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/MdtaMetadataEntry.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.mp4;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.util.Util;
+import java.util.Arrays;
+
+/**
+ * Stores extensible metadata with handler type 'mdta'. See also the QuickTime File Format
+ * Specification.
+ */
+public final class MdtaMetadataEntry implements Metadata.Entry {
+
+  /** The metadata key name. */
+  public final String key;
+  /** The payload. The interpretation of the value depends on {@link #typeIndicator}. */
+  public final byte[] value;
+  /** The four byte locale indicator. */
+  public final int localeIndicator;
+  /** The four byte type indicator. */
+  public final int typeIndicator;
+
+  /** Creates a new metadata entry for the specified metadata key/value. */
+  public MdtaMetadataEntry(String key, byte[] value, int localeIndicator, int typeIndicator) {
+    this.key = key;
+    this.value = value;
+    this.localeIndicator = localeIndicator;
+    this.typeIndicator = typeIndicator;
+  }
+
+  private MdtaMetadataEntry(Parcel in) {
+    key = Util.castNonNull(in.readString());
+    value = new byte[in.readInt()];
+    in.readByteArray(value);
+    localeIndicator = in.readInt();
+    typeIndicator = in.readInt();
+  }
+
+  @Override
+  public boolean equals(@Nullable Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    MdtaMetadataEntry other = (MdtaMetadataEntry) obj;
+    return key.equals(other.key)
+        && Arrays.equals(value, other.value)
+        && localeIndicator == other.localeIndicator
+        && typeIndicator == other.typeIndicator;
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + key.hashCode();
+    result = 31 * result + Arrays.hashCode(value);
+    result = 31 * result + localeIndicator;
+    result = 31 * result + typeIndicator;
+    return result;
+  }
+
+  @Override
+  public String toString() {
+    return "mdta: key=" + key;
+  }
+
+  // Parcelable implementation.
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(key);
+    dest.writeInt(value.length);
+    dest.writeByteArray(value);
+    dest.writeInt(localeIndicator);
+    dest.writeInt(typeIndicator);
+  }
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  public static final Parcelable.Creator<MdtaMetadataEntry> CREATOR =
+      new Parcelable.Creator<MdtaMetadataEntry>() {
+
+        @Override
+        public MdtaMetadataEntry createFromParcel(Parcel in) {
+          return new MdtaMetadataEntry(in);
+        }
+
+        @Override
+        public MdtaMetadataEntry[] newArray(int size) {
+          return new MdtaMetadataEntry[size];
+        }
+      };
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/MetadataUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/MetadataUtil.java
index 670fe116a6..02522897ce 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/MetadataUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/MetadataUtil.java
@@ -16,6 +16,9 @@
 package com.google.android.exoplayer2.extractor.mp4;
 
 import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.extractor.GaplessInfoHolder;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.id3.ApicFrame;
 import com.google.android.exoplayer2.metadata.id3.CommentFrame;
@@ -25,10 +28,9 @@
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
+import java.nio.ByteBuffer;
 
-/**
- * Parses metadata items stored in ilst atoms.
- */
+/** Utilities for handling metadata in MP4. */
 /* package */ final class MetadataUtil {
 
   private static final String TAG = "MetadataUtil";
@@ -103,24 +105,73 @@
 
   private static final String LANGUAGE_UNDEFINED = "und";
 
+  private static final int TYPE_TOP_BYTE_COPYRIGHT = 0xA9;
+  private static final int TYPE_TOP_BYTE_REPLACEMENT = 0xFD; // Truncated value of \uFFFD.
+
+  private static final String MDTA_KEY_ANDROID_CAPTURE_FPS = "com.android.capture.fps";
+  private static final int MDTA_TYPE_INDICATOR_FLOAT = 23;
+
   private MetadataUtil() {}
 
   /**
-   * Parses a single ilst element from a {@link ParsableByteArray}. The element is read starting
-   * from the current position of the {@link ParsableByteArray}, and the position is advanced by the
-   * size of the element. The position is advanced even if the element's type is unrecognized.
+   * Returns a {@link Format} that is the same as the input format but includes information from the
+   * specified sources of metadata.
+   */
+  public static Format getFormatWithMetadata(
+      int trackType,
+      Format format,
+      @Nullable Metadata udtaMetadata,
+      @Nullable Metadata mdtaMetadata,
+      GaplessInfoHolder gaplessInfoHolder) {
+    if (trackType == C.TRACK_TYPE_AUDIO) {
+      if (gaplessInfoHolder.hasGaplessInfo()) {
+        format =
+            format.copyWithGaplessInfo(
+                gaplessInfoHolder.encoderDelay, gaplessInfoHolder.encoderPadding);
+      }
+      // We assume all udta metadata is associated with the audio track.
+      if (udtaMetadata != null) {
+        format = format.copyWithMetadata(udtaMetadata);
+      }
+    } else if (trackType == C.TRACK_TYPE_VIDEO && mdtaMetadata != null) {
+      // Populate only metadata keys that are known to be specific to video.
+      for (int i = 0; i < mdtaMetadata.length(); i++) {
+        Metadata.Entry entry = mdtaMetadata.get(i);
+        if (entry instanceof MdtaMetadataEntry) {
+          MdtaMetadataEntry mdtaMetadataEntry = (MdtaMetadataEntry) entry;
+          if (MDTA_KEY_ANDROID_CAPTURE_FPS.equals(mdtaMetadataEntry.key)
+              && mdtaMetadataEntry.typeIndicator == MDTA_TYPE_INDICATOR_FLOAT) {
+            try {
+              float fps = ByteBuffer.wrap(mdtaMetadataEntry.value).asFloatBuffer().get();
+              format = format.copyWithFrameRate(fps);
+              format = format.copyWithMetadata(new Metadata(mdtaMetadataEntry));
+            } catch (NumberFormatException e) {
+              Log.w(TAG, "Ignoring invalid framerate");
+            }
+          }
+        }
+      }
+    }
+    return format;
+  }
+
+  /**
+   * Parses a single userdata ilst element from a {@link ParsableByteArray}. The element is read
+   * starting from the current position of the {@link ParsableByteArray}, and the position is
+   * advanced by the size of the element. The position is advanced even if the element's type is
+   * unrecognized.
    *
    * @param ilst Holds the data to be parsed.
    * @return The parsed element, or null if the element's type was not recognized.
    */
-  public static @Nullable Metadata.Entry parseIlstElement(ParsableByteArray ilst) {
+  @Nullable
+  public static Metadata.Entry parseIlstElement(ParsableByteArray ilst) {
     int position = ilst.getPosition();
     int endPosition = position + ilst.readInt();
     int type = ilst.readInt();
     int typeTopByte = (type >> 24) & 0xFF;
     try {
-      if (typeTopByte == '\u00A9' /* Copyright char */
-          || typeTopByte == '\uFFFD' /* Replacement char */) {
+      if (typeTopByte == TYPE_TOP_BYTE_COPYRIGHT || typeTopByte == TYPE_TOP_BYTE_REPLACEMENT) {
         int shortType = type & 0x00FFFFFF;
         if (shortType == SHORT_TYPE_COMMENT) {
           return parseCommentAttribute(type, ilst);
@@ -185,7 +236,36 @@ private MetadataUtil() {}
     }
   }
 
-  private static @Nullable TextInformationFrame parseTextAttribute(
+  /**
+   * Parses an 'mdta' metadata entry starting at the current position in an ilst box.
+   *
+   * @param ilst The ilst box.
+   * @param endPosition The end position of the entry in the ilst box.
+   * @param key The mdta metadata entry key for the entry.
+   * @return The parsed element, or null if the entry wasn't recognized.
+   */
+  @Nullable
+  public static MdtaMetadataEntry parseMdtaMetadataEntryFromIlst(
+      ParsableByteArray ilst, int endPosition, String key) {
+    int atomPosition;
+    while ((atomPosition = ilst.getPosition()) < endPosition) {
+      int atomSize = ilst.readInt();
+      int atomType = ilst.readInt();
+      if (atomType == Atom.TYPE_data) {
+        int typeIndicator = ilst.readInt();
+        int localeIndicator = ilst.readInt();
+        int dataSize = atomSize - 16;
+        byte[] value = new byte[dataSize];
+        ilst.readBytes(value, 0, dataSize);
+        return new MdtaMetadataEntry(key, value, localeIndicator, typeIndicator);
+      }
+      ilst.setPosition(atomPosition + atomSize);
+    }
+    return null;
+  }
+
+  @Nullable
+  private static TextInformationFrame parseTextAttribute(
       int type, String id, ParsableByteArray data) {
     int atomSize = data.readInt();
     int atomType = data.readInt();
@@ -198,7 +278,8 @@ private MetadataUtil() {}
     return null;
   }
 
-  private static @Nullable CommentFrame parseCommentAttribute(int type, ParsableByteArray data) {
+  @Nullable
+  private static CommentFrame parseCommentAttribute(int type, ParsableByteArray data) {
     int atomSize = data.readInt();
     int atomType = data.readInt();
     if (atomType == Atom.TYPE_data) {
@@ -210,7 +291,8 @@ private MetadataUtil() {}
     return null;
   }
 
-  private static @Nullable Id3Frame parseUint8Attribute(
+  @Nullable
+  private static Id3Frame parseUint8Attribute(
       int type,
       String id,
       ParsableByteArray data,
@@ -229,7 +311,8 @@ private MetadataUtil() {}
     return null;
   }
 
-  private static @Nullable TextInformationFrame parseIndexAndCountAttribute(
+  @Nullable
+  private static TextInformationFrame parseIndexAndCountAttribute(
       int type, String attributeName, ParsableByteArray data) {
     int atomSize = data.readInt();
     int atomType = data.readInt();
@@ -249,8 +332,8 @@ private MetadataUtil() {}
     return null;
   }
 
-  private static @Nullable TextInformationFrame parseStandardGenreAttribute(
-      ParsableByteArray data) {
+  @Nullable
+  private static TextInformationFrame parseStandardGenreAttribute(ParsableByteArray data) {
     int genreCode = parseUint8AttributeValue(data);
     String genreString = (0 < genreCode && genreCode <= STANDARD_GENRES.length)
         ? STANDARD_GENRES[genreCode - 1] : null;
@@ -261,7 +344,8 @@ private MetadataUtil() {}
     return null;
   }
 
-  private static @Nullable ApicFrame parseCoverArt(ParsableByteArray data) {
+  @Nullable
+  private static ApicFrame parseCoverArt(ParsableByteArray data) {
     int atomSize = data.readInt();
     int atomType = data.readInt();
     if (atomType == Atom.TYPE_data) {
@@ -285,8 +369,8 @@ private MetadataUtil() {}
     return null;
   }
 
-  private static @Nullable Id3Frame parseInternalAttribute(
-      ParsableByteArray data, int endPosition) {
+  @Nullable
+  private static Id3Frame parseInternalAttribute(ParsableByteArray data, int endPosition) {
     String domain = null;
     String name = null;
     int dataAtomPosition = -1;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
index 17c82c2c5b..eec48c23cb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
@@ -75,7 +75,7 @@
   private static final int STATE_READING_ATOM_PAYLOAD = 1;
   private static final int STATE_READING_SAMPLE = 2;
 
-  // Brand stored in the ftyp atom for QuickTime media.
+  /** Brand stored in the ftyp atom for QuickTime media. */
   private static final int BRAND_QUICKTIME = Util.getIntegerCodeForString("qt  ");
 
   /**
@@ -377,15 +377,21 @@ private void processMoovAtom(ContainerAtom moov) throws ParserException {
     long durationUs = C.TIME_UNSET;
     List<Mp4Track> tracks = new ArrayList<>();
 
-    Metadata metadata = null;
+    // Process metadata.
+    Metadata udtaMetadata = null;
     GaplessInfoHolder gaplessInfoHolder = new GaplessInfoHolder();
     Atom.LeafAtom udta = moov.getLeafAtomOfType(Atom.TYPE_udta);
     if (udta != null) {
-      metadata = AtomParsers.parseUdta(udta, isQuickTime);
-      if (metadata != null) {
-        gaplessInfoHolder.setFromMetadata(metadata);
+      udtaMetadata = AtomParsers.parseUdta(udta, isQuickTime);
+      if (udtaMetadata != null) {
+        gaplessInfoHolder.setFromMetadata(udtaMetadata);
       }
     }
+    Metadata mdtaMetadata = null;
+    Atom.ContainerAtom meta = moov.getContainerAtomOfType(Atom.TYPE_meta);
+    if (meta != null) {
+      mdtaMetadata = AtomParsers.parseMdtaFromMeta(meta);
+    }
 
     boolean ignoreEditLists = (flags & FLAG_WORKAROUND_IGNORE_EDIT_LISTS) != 0;
     ArrayList<TrackSampleTable> trackSampleTables =
@@ -401,15 +407,9 @@ private void processMoovAtom(ContainerAtom moov) throws ParserException {
       // Allow ten source samples per output sample, like the platform extractor.
       int maxInputSize = trackSampleTable.maximumSize + 3 * 10;
       Format format = track.format.copyWithMaxInputSize(maxInputSize);
-      if (track.type == C.TRACK_TYPE_AUDIO) {
-        if (gaplessInfoHolder.hasGaplessInfo()) {
-          format = format.copyWithGaplessInfo(gaplessInfoHolder.encoderDelay,
-              gaplessInfoHolder.encoderPadding);
-        }
-        if (metadata != null) {
-          format = format.copyWithMetadata(metadata);
-        }
-      }
+      format =
+          MetadataUtil.getFormatWithMetadata(
+              track.type, format, udtaMetadata, mdtaMetadata, gaplessInfoHolder);
       mp4Track.trackOutput.format(format);
 
       durationUs =
@@ -716,24 +716,37 @@ private static boolean processFtypAtom(ParsableByteArray atomData) {
     return false;
   }
 
-  /**
-   * Returns whether the extractor should decode a leaf atom with type {@code atom}.
-   */
+  /** Returns whether the extractor should decode a leaf atom with type {@code atom}. */
   private static boolean shouldParseLeafAtom(int atom) {
-    return atom == Atom.TYPE_mdhd || atom == Atom.TYPE_mvhd || atom == Atom.TYPE_hdlr
-        || atom == Atom.TYPE_stsd || atom == Atom.TYPE_stts || atom == Atom.TYPE_stss
-        || atom == Atom.TYPE_ctts || atom == Atom.TYPE_elst || atom == Atom.TYPE_stsc
-        || atom == Atom.TYPE_stsz || atom == Atom.TYPE_stz2 || atom == Atom.TYPE_stco
-        || atom == Atom.TYPE_co64 || atom == Atom.TYPE_tkhd || atom == Atom.TYPE_ftyp
-        || atom == Atom.TYPE_udta;
+    return atom == Atom.TYPE_mdhd
+        || atom == Atom.TYPE_mvhd
+        || atom == Atom.TYPE_hdlr
+        || atom == Atom.TYPE_stsd
+        || atom == Atom.TYPE_stts
+        || atom == Atom.TYPE_stss
+        || atom == Atom.TYPE_ctts
+        || atom == Atom.TYPE_elst
+        || atom == Atom.TYPE_stsc
+        || atom == Atom.TYPE_stsz
+        || atom == Atom.TYPE_stz2
+        || atom == Atom.TYPE_stco
+        || atom == Atom.TYPE_co64
+        || atom == Atom.TYPE_tkhd
+        || atom == Atom.TYPE_ftyp
+        || atom == Atom.TYPE_udta
+        || atom == Atom.TYPE_keys
+        || atom == Atom.TYPE_ilst;
   }
 
-  /**
-   * Returns whether the extractor should decode a container atom with type {@code atom}.
-   */
+  /** Returns whether the extractor should decode a container atom with type {@code atom}. */
   private static boolean shouldParseContainerAtom(int atom) {
-    return atom == Atom.TYPE_moov || atom == Atom.TYPE_trak || atom == Atom.TYPE_mdia
-        || atom == Atom.TYPE_minf || atom == Atom.TYPE_stbl || atom == Atom.TYPE_edts;
+    return atom == Atom.TYPE_moov
+        || atom == Atom.TYPE_trak
+        || atom == Atom.TYPE_mdia
+        || atom == Atom.TYPE_minf
+        || atom == Atom.TYPE_stbl
+        || atom == Atom.TYPE_edts
+        || atom == Atom.TYPE_meta;
   }
 
   private static final class Mp4Track {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Sniffer.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Sniffer.java
index 021c9de654..a1c90bf1f2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Sniffer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Sniffer.java
@@ -27,9 +27,7 @@
  */
 /* package */ final class Sniffer {
 
-  /**
-   * The maximum number of bytes to peek when sniffing.
-   */
+  /** The maximum number of bytes to peek when sniffing. */
   private static final int SEARCH_LENGTH = 4 * 1024;
 
   private static final int[] COMPATIBLE_BRANDS = new int[] {
@@ -109,15 +107,19 @@ private static boolean sniffInternal(ExtractorInput input, boolean fragmented)
         headerSize = Atom.LONG_HEADER_SIZE;
         input.peekFully(buffer.data, Atom.HEADER_SIZE, Atom.LONG_HEADER_SIZE - Atom.HEADER_SIZE);
         buffer.setLimit(Atom.LONG_HEADER_SIZE);
-        atomSize = buffer.readUnsignedLongToLong();
+        atomSize = buffer.readLong();
       } else if (atomSize == Atom.EXTENDS_TO_END_SIZE) {
         // The atom extends to the end of the file.
-        long endPosition = input.getLength();
-        if (endPosition != C.LENGTH_UNSET) {
-          atomSize = endPosition - input.getPosition() + headerSize;
+        long fileEndPosition = input.getLength();
+        if (fileEndPosition != C.LENGTH_UNSET) {
+          atomSize = fileEndPosition - input.getPeekPosition() + headerSize;
         }
       }
 
+      if (inputLength != C.LENGTH_UNSET && bytesSearched + atomSize > inputLength) {
+        // The file is invalid because the atom extends past the end of the file.
+        return false;
+      }
       if (atomSize < headerSize) {
         // The file is invalid because the atom size is too small for its header.
         return false;
@@ -125,6 +127,13 @@ private static boolean sniffInternal(ExtractorInput input, boolean fragmented)
       bytesSearched += headerSize;
 
       if (atomType == Atom.TYPE_moov) {
+        // We have seen the moov atom. We increase the search size to make sure we don't miss an
+        // mvex atom because the moov's size exceeds the search length.
+        bytesToSearch += (int) atomSize;
+        if (inputLength != C.LENGTH_UNSET && bytesToSearch > inputLength) {
+          // Make sure we don't exceed the file size.
+          bytesToSearch = (int) inputLength;
+        }
         // Check for an mvex atom inside the moov atom to identify whether the file is fragmented.
         continue;
       }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackSampleTable.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackSampleTable.java
index 56851fc1e0..59ea386335 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackSampleTable.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackSampleTable.java
@@ -64,6 +64,9 @@ public TrackSampleTable(
     this.flags = flags;
     this.durationUs = durationUs;
     sampleCount = offsets.length;
+    if (flags.length > 0) {
+      flags[flags.length - 1] |= C.BUFFER_FLAG_LAST_SAMPLE;
+    }
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java
index 93ce15a7ab..3741d52294 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import static com.google.android.exoplayer2.extractor.ts.TsPayloadReader.FLAG_DATA_ALIGNMENT_INDICATOR;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.audio.Ac3Util;
 import com.google.android.exoplayer2.extractor.Extractor;
@@ -140,7 +142,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
 
     if (!startedPacket) {
       // Pass data to the reader as though it's contained within a single infinitely long packet.
-      reader.packetStarted(firstSampleTimestampUs, true);
+      reader.packetStarted(firstSampleTimestampUs, FLAG_DATA_ALIGNMENT_INDICATOR);
       startedPacket = true;
     }
     // TODO: Make it possible for the reader to consume the dataSource directly, so that it becomes
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
index 2ef9704a7a..93724be92d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
@@ -100,7 +100,7 @@ public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator gener
   }
 
   @Override
-  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+  public void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags) {
     timeUs = pesTimeUs;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
index 04a6b571bd..77b79fa19f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import static com.google.android.exoplayer2.extractor.ts.TsPayloadReader.FLAG_DATA_ALIGNMENT_INDICATOR;
+
 import android.support.annotation.IntDef;
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
@@ -202,7 +204,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
 
     if (!startedPacket) {
       // Pass data to the reader as though it's contained within a single infinitely long packet.
-      reader.packetStarted(firstSampleTimestampUs, true);
+      reader.packetStarted(firstSampleTimestampUs, FLAG_DATA_ALIGNMENT_INDICATOR);
       startedPacket = true;
     }
     // TODO: Make it possible for reader to consume the dataSource directly, so that it becomes
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
index e31f67c77c..589b543170 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
@@ -141,7 +141,7 @@ public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGen
   }
 
   @Override
-  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+  public void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags) {
     timeUs = pesTimeUs;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java
index 2e45853951..1f9b0e79d4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java
@@ -80,7 +80,7 @@ public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGen
   }
 
   @Override
-  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+  public void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags) {
     timeUs = pesTimeUs;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DvbSubtitleReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DvbSubtitleReader.java
index 0944d1810e..3f0a772b1c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DvbSubtitleReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DvbSubtitleReader.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import static com.google.android.exoplayer2.extractor.ts.TsPayloadReader.FLAG_DATA_ALIGNMENT_INDICATOR;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
@@ -73,8 +75,8 @@ public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGen
   }
 
   @Override
-  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
-    if (!dataAlignmentIndicator) {
+  public void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags) {
+    if ((flags & FLAG_DATA_ALIGNMENT_INDICATOR) == 0) {
       return;
     }
     writingSample = true;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java
index fa7f78c8c0..e022fc237b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/ElementaryStreamReader.java
@@ -43,9 +43,9 @@
    * Called when a packet starts.
    *
    * @param pesTimeUs The timestamp associated with the packet.
-   * @param dataAlignmentIndicator The data alignment indicator associated with the packet.
+   * @param flags See {@link TsPayloadReader.Flags}.
    */
-  void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator);
+  void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags);
 
   /**
    * Consumes (possibly partial) data from the current packet.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H262Reader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H262Reader.java
index e9827893ee..1564157d44 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H262Reader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H262Reader.java
@@ -107,7 +107,8 @@ public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGen
   }
 
   @Override
-  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+  public void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags) {
+    // TODO (Internal b/32267012): Consider using random access indicator.
     this.pesTimeUs = pesTimeUs;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
index 45e094f69d..d249c1b9da 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import static com.google.android.exoplayer2.extractor.ts.TsPayloadReader.FLAG_RANDOM_ACCESS_INDICATOR;
+
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
@@ -56,9 +58,12 @@
   // State that should not be reset on seek.
   private boolean hasOutputFormat;
 
-  // Per packet state that gets reset at the start of each packet.
+  // Per PES packet state that gets reset at the start of each PES packet.
   private long pesTimeUs;
 
+  // State inherited from the TS packet header.
+  private boolean randomAccessIndicator;
+
   // Scratch variables to avoid allocations.
   private final ParsableByteArray seiWrapper;
 
@@ -88,6 +93,7 @@ public void seek() {
     sei.reset();
     sampleReader.reset();
     totalBytesWritten = 0;
+    randomAccessIndicator = false;
   }
 
   @Override
@@ -100,8 +106,9 @@ public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGen
   }
 
   @Override
-  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+  public void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags) {
     this.pesTimeUs = pesTimeUs;
+    randomAccessIndicator |= (flags & FLAG_RANDOM_ACCESS_INDICATOR) != 0;
   }
 
   @Override
@@ -220,12 +227,17 @@ private void endNalUnit(long position, int offset, int discardPadding, long pesT
       seiWrapper.setPosition(4); // NAL prefix and nal_unit() header.
       seiReader.consume(pesTimeUs, seiWrapper);
     }
-    sampleReader.endNalUnit(position, offset);
+    boolean sampleIsKeyFrame =
+        sampleReader.endNalUnit(position, offset, hasOutputFormat, randomAccessIndicator);
+    if (sampleIsKeyFrame) {
+      // This is either an IDR frame or the first I-frame since the random access indicator, so mark
+      // it as a keyframe. Clear the flag so that subsequent non-IDR I-frames are not marked as
+      // keyframes until we see another random access indicator.
+      randomAccessIndicator = false;
+    }
   }
 
-  /**
-   * Consumes a stream of NAL units and outputs samples.
-   */
+  /** Consumes a stream of NAL units and outputs samples. */
   private static final class SampleReader {
 
     private static final int DEFAULT_BUFFER_SIZE = 128;
@@ -430,11 +442,12 @@ public void appendToNalUnit(byte[] data, int offset, int limit) {
       isFilling = false;
     }
 
-    public void endNalUnit(long position, int offset) {
+    public boolean endNalUnit(
+        long position, int offset, boolean hasOutputFormat, boolean randomAccessIndicator) {
       if (nalUnitType == NAL_UNIT_TYPE_AUD
           || (detectAccessUnits && sliceHeader.isFirstVclNalUnitOfPicture(previousSliceHeader))) {
         // If the NAL unit ending is the start of a new sample, output the previous one.
-        if (readingSample) {
+        if (hasOutputFormat && readingSample) {
           int nalUnitLength = (int) (position - nalUnitStartPosition);
           outputSample(offset + nalUnitLength);
         }
@@ -443,8 +456,12 @@ public void endNalUnit(long position, int offset) {
         sampleIsKeyframe = false;
         readingSample = true;
       }
-      sampleIsKeyframe |= nalUnitType == NAL_UNIT_TYPE_IDR || (allowNonIdrKeyframes
-          && nalUnitType == NAL_UNIT_TYPE_NON_IDR && sliceHeader.isISlice());
+      boolean treatIFrameAsKeyframe =
+          allowNonIdrKeyframes ? sliceHeader.isISlice() : randomAccessIndicator;
+      sampleIsKeyframe |=
+          nalUnitType == NAL_UNIT_TYPE_IDR
+              || (treatIFrameAsKeyframe && nalUnitType == NAL_UNIT_TYPE_NON_IDR);
+      return sampleIsKeyframe;
     }
 
     private void outputSample(int offset) {
@@ -486,10 +503,21 @@ public void setSliceType(int sliceType) {
         hasSliceType = true;
       }
 
-      public void setAll(SpsData spsData, int nalRefIdc, int sliceType, int frameNum,
-          int picParameterSetId, boolean fieldPicFlag, boolean bottomFieldFlagPresent,
-          boolean bottomFieldFlag, boolean idrPicFlag, int idrPicId, int picOrderCntLsb,
-          int deltaPicOrderCntBottom, int deltaPicOrderCnt0, int deltaPicOrderCnt1) {
+      public void setAll(
+          SpsData spsData,
+          int nalRefIdc,
+          int sliceType,
+          int frameNum,
+          int picParameterSetId,
+          boolean fieldPicFlag,
+          boolean bottomFieldFlagPresent,
+          boolean bottomFieldFlag,
+          boolean idrPicFlag,
+          int idrPicId,
+          int picOrderCntLsb,
+          int deltaPicOrderCntBottom,
+          int deltaPicOrderCnt0,
+          int deltaPicOrderCnt1) {
         this.spsData = spsData;
         this.nalRefIdc = nalRefIdc;
         this.sliceType = sliceType;
@@ -514,23 +542,26 @@ public boolean isISlice() {
 
       private boolean isFirstVclNalUnitOfPicture(SliceHeaderData other) {
         // See ISO 14496-10 subsection 7.4.1.2.4.
-        return isComplete && (!other.isComplete || frameNum != other.frameNum
-            || picParameterSetId != other.picParameterSetId || fieldPicFlag != other.fieldPicFlag
-            || (bottomFieldFlagPresent && other.bottomFieldFlagPresent
-                && bottomFieldFlag != other.bottomFieldFlag)
-            || (nalRefIdc != other.nalRefIdc && (nalRefIdc == 0 || other.nalRefIdc == 0))
-            || (spsData.picOrderCountType == 0 && other.spsData.picOrderCountType == 0
-                && (picOrderCntLsb != other.picOrderCntLsb
-                    || deltaPicOrderCntBottom != other.deltaPicOrderCntBottom))
-            || (spsData.picOrderCountType == 1 && other.spsData.picOrderCountType == 1
-                && (deltaPicOrderCnt0 != other.deltaPicOrderCnt0
-                    || deltaPicOrderCnt1 != other.deltaPicOrderCnt1))
-            || idrPicFlag != other.idrPicFlag
-            || (idrPicFlag && other.idrPicFlag && idrPicId != other.idrPicId));
+        return isComplete
+            && (!other.isComplete
+                || frameNum != other.frameNum
+                || picParameterSetId != other.picParameterSetId
+                || fieldPicFlag != other.fieldPicFlag
+                || (bottomFieldFlagPresent
+                    && other.bottomFieldFlagPresent
+                    && bottomFieldFlag != other.bottomFieldFlag)
+                || (nalRefIdc != other.nalRefIdc && (nalRefIdc == 0 || other.nalRefIdc == 0))
+                || (spsData.picOrderCountType == 0
+                    && other.spsData.picOrderCountType == 0
+                    && (picOrderCntLsb != other.picOrderCntLsb
+                        || deltaPicOrderCntBottom != other.deltaPicOrderCntBottom))
+                || (spsData.picOrderCountType == 1
+                    && other.spsData.picOrderCountType == 1
+                    && (deltaPicOrderCnt0 != other.deltaPicOrderCnt0
+                        || deltaPicOrderCnt1 != other.deltaPicOrderCnt1))
+                || idrPicFlag != other.idrPicFlag
+                || (idrPicFlag && other.idrPicFlag && idrPicId != other.idrPicId));
       }
-
     }
-
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java
index 13d679c47c..88bde53746 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java
@@ -104,7 +104,8 @@ public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGen
   }
 
   @Override
-  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+  public void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags) {
+    // TODO (Internal b/32267012): Consider using random access indicator.
     this.pesTimeUs = pesTimeUs;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Id3Reader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Id3Reader.java
index 0f0f2ad981..f936fb9e43 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Id3Reader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Id3Reader.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import static com.google.android.exoplayer2.extractor.ts.TsPayloadReader.FLAG_DATA_ALIGNMENT_INDICATOR;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
@@ -63,8 +65,8 @@ public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGen
   }
 
   @Override
-  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
-    if (!dataAlignmentIndicator) {
+  public void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags) {
+    if ((flags & FLAG_DATA_ALIGNMENT_INDICATOR) == 0) {
       return;
     }
     writingSample = true;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/LatmReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/LatmReader.java
index f401a6e736..2a633c191d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/LatmReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/LatmReader.java
@@ -93,7 +93,7 @@ public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGen
   }
 
   @Override
-  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+  public void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags) {
     timeUs = pesTimeUs;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/MpegAudioReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/MpegAudioReader.java
index effa7d7c96..393e297818 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/MpegAudioReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/MpegAudioReader.java
@@ -83,7 +83,7 @@ public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGen
   }
 
   @Override
-  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+  public void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags) {
     timeUs = pesTimeUs;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java
index 91cd548367..ff755f4ece 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java
@@ -78,9 +78,8 @@ public final void seek() {
   }
 
   @Override
-  public final void consume(ParsableByteArray data, boolean payloadUnitStartIndicator)
-      throws ParserException {
-    if (payloadUnitStartIndicator) {
+  public final void consume(ParsableByteArray data, @Flags int flags) throws ParserException {
+    if ((flags & FLAG_PAYLOAD_UNIT_START_INDICATOR) != 0) {
       switch (state) {
         case STATE_FINDING_HEADER:
         case STATE_READING_HEADER:
@@ -122,7 +121,8 @@ public final void consume(ParsableByteArray data, boolean payloadUnitStartIndica
           if (continueRead(data, pesScratch.data, readLength)
               && continueRead(data, null, extendedHeaderLength)) {
             parseHeaderExtension();
-            reader.packetStarted(timeUs, dataAlignmentIndicator);
+            flags |= dataAlignmentIndicator ? FLAG_DATA_ALIGNMENT_INDICATOR : 0;
+            reader.packetStarted(timeUs, flags);
             setState(STATE_READING_BODY);
           }
           break;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
index c7a082aeac..f453a9cc43 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
@@ -343,7 +343,7 @@ public void consume(ParsableByteArray data) throws ParserException {
       data.readBytes(pesScratch.data, 0, extendedHeaderLength);
       pesScratch.setPosition(0);
       parseHeaderExtension();
-      pesPayloadReader.packetStarted(timeUs, true);
+      pesPayloadReader.packetStarted(timeUs, TsPayloadReader.FLAG_DATA_ALIGNMENT_INDICATOR);
       pesPayloadReader.consume(data);
       // We always have complete PES packets with program stream.
       pesPayloadReader.packetFinished();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionReader.java
index d217cfcb7a..101a1f74d9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionReader.java
@@ -57,7 +57,8 @@ public void seek() {
   }
 
   @Override
-  public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) {
+  public void consume(ParsableByteArray data, @Flags int flags) {
+    boolean payloadUnitStartIndicator = (flags & FLAG_PAYLOAD_UNIT_START_INDICATOR) != 0;
     int payloadStartPosition = C.POSITION_UNSET;
     if (payloadUnitStartIndicator) {
       int payloadStartOffset = data.readUnsignedByte();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
index f47a481d7e..d91842423d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import static com.google.android.exoplayer2.extractor.ts.TsPayloadReader.FLAG_PAYLOAD_UNIT_START_INDICATOR;
+
 import android.support.annotation.IntDef;
 import android.util.SparseArray;
 import android.util.SparseBooleanArray;
@@ -279,6 +281,8 @@ public void release() {
       return RESULT_CONTINUE;
     }
 
+    @TsPayloadReader.Flags int packetHeaderFlags = 0;
+
     // Note: See ISO/IEC 13818-1, section 2.4.3.2 for details of the header format.
     int tsPacketHeader = tsPacketBuffer.readInt();
     if ((tsPacketHeader & 0x800000) != 0) { // transport_error_indicator
@@ -286,7 +290,7 @@ public void release() {
       tsPacketBuffer.setPosition(endOfPacket);
       return RESULT_CONTINUE;
     }
-    boolean payloadUnitStartIndicator = (tsPacketHeader & 0x400000) != 0;
+    packetHeaderFlags |= (tsPacketHeader & 0x400000) != 0 ? FLAG_PAYLOAD_UNIT_START_INDICATOR : 0;
     // Ignoring transport_priority (tsPacketHeader & 0x200000)
     int pid = (tsPacketHeader & 0x1FFF00) >> 8;
     // Ignoring transport_scrambling_control (tsPacketHeader & 0xC0)
@@ -317,14 +321,20 @@ public void release() {
     // Skip the adaptation field.
     if (adaptationFieldExists) {
       int adaptationFieldLength = tsPacketBuffer.readUnsignedByte();
-      tsPacketBuffer.skipBytes(adaptationFieldLength);
+      int adaptationFieldFlags = tsPacketBuffer.readUnsignedByte();
+
+      packetHeaderFlags |=
+          (adaptationFieldFlags & 0x40) != 0 // random_access_indicator.
+              ? TsPayloadReader.FLAG_RANDOM_ACCESS_INDICATOR
+              : 0;
+      tsPacketBuffer.skipBytes(adaptationFieldLength - 1 /* flags */);
     }
 
     // Read the payload.
     boolean wereTracksEnded = tracksEnded;
     if (shouldConsumePacketPayload(pid)) {
       tsPacketBuffer.setLimit(endOfPacket);
-      payloadReader.consume(tsPacketBuffer, payloadUnitStartIndicator);
+      payloadReader.consume(tsPacketBuffer, packetHeaderFlags);
       tsPacketBuffer.setLimit(limit);
     }
     if (mode != MODE_HLS && !wereTracksEnded && tracksEnded && inputLength != C.LENGTH_UNSET) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
index 2ea25bb2e0..a034b05696 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
@@ -15,12 +15,16 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import android.support.annotation.IntDef;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.util.Collections;
 import java.util.List;
 
@@ -174,6 +178,29 @@ private void maybeThrowUninitializedError() {
 
   }
 
+  /**
+   * Contextual flags indicating the presence of indicators in the TS packet or PES packet headers.
+   */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(
+      flag = true,
+      value = {
+        FLAG_PAYLOAD_UNIT_START_INDICATOR,
+        FLAG_RANDOM_ACCESS_INDICATOR,
+        FLAG_DATA_ALIGNMENT_INDICATOR
+      })
+  @interface Flags {}
+
+  /** Indicates the presence of the payload_unit_start_indicator in the TS packet header. */
+  int FLAG_PAYLOAD_UNIT_START_INDICATOR = 1;
+  /**
+   * Indicates the presence of the random_access_indicator in the TS packet header adaptation field.
+   */
+  int FLAG_RANDOM_ACCESS_INDICATOR = 1 << 1;
+  /** Indicates the presence of the data_alignment_indicator in the PES header. */
+  int FLAG_DATA_ALIGNMENT_INDICATOR = 1 << 2;
+
   /**
    * Initializes the payload reader.
    *
@@ -187,10 +214,10 @@ void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
 
   /**
    * Notifies the reader that a seek has occurred.
-   * <p>
-   * Following a call to this method, the data passed to the next invocation of
-   * {@link #consume(ParsableByteArray, boolean)} will not be a continuation of the data that was
-   * previously passed. Hence the reader should reset any internal state.
+   *
+   * <p>Following a call to this method, the data passed to the next invocation of {@link #consume}
+   * will not be a continuation of the data that was previously passed. Hence the reader should
+   * reset any internal state.
    */
   void seek();
 
@@ -198,9 +225,8 @@ void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
    * Consumes the payload of a TS packet.
    *
    * @param data The TS packet. The position will be set to the start of the payload.
-   * @param payloadUnitStartIndicator Whether payloadUnitStartIndicator was set on the TS packet.
+   * @param flags See {@link Flags}.
    * @throws ParserException If the payload could not be parsed.
    */
-  void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) throws ParserException;
-
+  void consume(ParsableByteArray data, @Flags int flags) throws ParserException;
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
index 32f6bd5409..8cec75a66d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
@@ -248,9 +248,15 @@ public boolean isCodecSupported(String codec) {
       // If we don't know any better, we assume that the profile and level are supported.
       return true;
     }
+    int profile = codecProfileAndLevel.first;
+    int level = codecProfileAndLevel.second;
+    if (!isVideo && profile != CodecProfileLevel.AACObjectXHE) {
+      // Some devices/builds under-report audio capabilities, so assume support except for xHE-AAC
+      // which is not widely supported. See https://github.com/google/ExoPlayer/issues/5145.
+      return true;
+    }
     for (CodecProfileLevel capabilities : getProfileLevels()) {
-      if (capabilities.profile == codecProfileAndLevel.first
-          && capabilities.level >= codecProfileAndLevel.second) {
+      if (capabilities.profile == profile && capabilities.level >= level) {
         return true;
       }
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
index 86bbb330b7..6a813332e3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
@@ -1622,7 +1622,8 @@ private static boolean codecNeedsEosPropagationWorkaround(MediaCodecInfo codecIn
    */
   private static boolean codecNeedsEosFlushWorkaround(String name) {
     return (Util.SDK_INT <= 23 && "OMX.google.vorbis.decoder".equals(name))
-        || (Util.SDK_INT <= 19 && "hb2000".equals(Util.DEVICE)
+        || (Util.SDK_INT <= 19
+            && ("hb2000".equals(Util.DEVICE) || "stvm8".equals(Util.DEVICE))
             && ("OMX.amlogic.avc.decoder.awesome".equals(name)
                 || "OMX.amlogic.avc.decoder.awesome.secure".equals(name)));
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
index 893601a859..9ae50179c3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
@@ -318,7 +318,23 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
     }
 
     // Work around https://github.com/google/ExoPlayer/issues/4519.
-    if ("OMX.SEC.mp3.dec".equals(name) && "SM-T530".equals(Util.MODEL)) {
+    if ("OMX.SEC.mp3.dec".equals(name)
+        && (Util.MODEL.startsWith("GT-I9152")
+            || Util.MODEL.startsWith("GT-I9515")
+            || Util.MODEL.startsWith("GT-P5220")
+            || Util.MODEL.startsWith("GT-S7580")
+            || Util.MODEL.startsWith("SM-G350")
+            || Util.MODEL.startsWith("SM-G386")
+            || Util.MODEL.startsWith("SM-T231")
+            || Util.MODEL.startsWith("SM-T530")
+            || Util.MODEL.startsWith("SCH-I535")
+            || Util.MODEL.startsWith("SPH-L710"))) {
+      return false;
+    }
+    if ("OMX.brcm.audio.mp3.decoder".equals(name)
+        && (Util.MODEL.startsWith("GT-I9152")
+            || Util.MODEL.startsWith("GT-S7580")
+            || Util.MODEL.startsWith("SM-G350"))) {
       return false;
     }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
index 78e37c1869..fce1c4b877 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
@@ -216,6 +216,12 @@ public ClippingMediaSource(
     window = new Timeline.Window();
   }
 
+  @Override
+  @Nullable
+  public Object getTag() {
+    return mediaSource.getTag();
+  }
+
   @Override
   public void prepareSourceInternal(
       ExoPlayer player,
@@ -234,10 +240,10 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
+  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
     ClippingMediaPeriod mediaPeriod =
         new ClippingMediaPeriod(
-            mediaSource.createPeriod(id, allocator),
+            mediaSource.createPeriod(id, allocator, startPositionUs),
             enableInitialDiscontinuity,
             periodStartUs,
             periodEndUs);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
index 88cd4a1595..c93afdb249 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
@@ -16,13 +16,12 @@
 package com.google.android.exoplayer2.source;
 
 import android.os.Handler;
+import android.os.Message;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
-import com.google.android.exoplayer2.PlayerMessage;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.ConcatenatingMediaSource.MediaSourceHolder;
 import com.google.android.exoplayer2.source.ShuffleOrder.DefaultShuffleOrder;
@@ -45,8 +44,7 @@
  * during playback. It is valid for the same {@link MediaSource} instance to be present more than
  * once in the concatenation. Access to this class is thread-safe.
  */
-public class ConcatenatingMediaSource extends CompositeMediaSource<MediaSourceHolder>
-    implements PlayerMessage.Target {
+public class ConcatenatingMediaSource extends CompositeMediaSource<MediaSourceHolder> {
 
   private static final int MSG_ADD = 0;
   private static final int MSG_REMOVE = 1;
@@ -68,8 +66,8 @@
   private final Timeline.Window window;
   private final Timeline.Period period;
 
-  private @Nullable ExoPlayer player;
-  private @Nullable Handler playerApplicationHandler;
+  @Nullable private Handler playbackThreadHandler;
+  @Nullable private Handler applicationThreadHandler;
   private boolean listenerNotificationScheduled;
   private ShuffleOrder shuffleOrder;
   private int windowCount;
@@ -239,12 +237,10 @@ public final synchronized void addMediaSources(
       mediaSourceHolders.add(new MediaSourceHolder(mediaSource));
     }
     mediaSourcesPublic.addAll(index, mediaSourceHolders);
-    if (player != null && !mediaSources.isEmpty()) {
-      player
-          .createMessage(this)
-          .setType(MSG_ADD)
-          .setPayload(new MessageData<>(index, mediaSourceHolders, actionOnCompletion))
-          .send();
+    if (playbackThreadHandler != null && !mediaSources.isEmpty()) {
+      playbackThreadHandler
+          .obtainMessage(MSG_ADD, new MessageData<>(index, mediaSourceHolders, actionOnCompletion))
+          .sendToTarget();
     } else if (actionOnCompletion != null) {
       actionOnCompletion.run();
     }
@@ -328,12 +324,10 @@ public final synchronized void removeMediaSourceRange(
       }
       return;
     }
-    if (player != null) {
-      player
-          .createMessage(this)
-          .setType(MSG_REMOVE)
-          .setPayload(new MessageData<>(fromIndex, toIndex, actionOnCompletion))
-          .send();
+    if (playbackThreadHandler != null) {
+      playbackThreadHandler
+          .obtainMessage(MSG_REMOVE, new MessageData<>(fromIndex, toIndex, actionOnCompletion))
+          .sendToTarget();
     } else if (actionOnCompletion != null) {
       actionOnCompletion.run();
     }
@@ -371,12 +365,10 @@ public final synchronized void moveMediaSource(
       return;
     }
     mediaSourcesPublic.add(newIndex, mediaSourcesPublic.remove(currentIndex));
-    if (player != null) {
-      player
-          .createMessage(this)
-          .setType(MSG_MOVE)
-          .setPayload(new MessageData<>(currentIndex, newIndex, actionOnCompletion))
-          .send();
+    if (playbackThreadHandler != null) {
+      playbackThreadHandler
+          .obtainMessage(MSG_MOVE, new MessageData<>(currentIndex, newIndex, actionOnCompletion))
+          .sendToTarget();
     } else if (actionOnCompletion != null) {
       actionOnCompletion.run();
     }
@@ -430,8 +422,8 @@ public final synchronized void setShuffleOrder(ShuffleOrder shuffleOrder) {
    */
   public final synchronized void setShuffleOrder(
       ShuffleOrder shuffleOrder, @Nullable Runnable actionOnCompletion) {
-    ExoPlayer player = this.player;
-    if (player != null) {
+    Handler playbackThreadHandler = this.playbackThreadHandler;
+    if (playbackThreadHandler != null) {
       int size = getSize();
       if (shuffleOrder.getLength() != size) {
         shuffleOrder =
@@ -439,11 +431,11 @@ public final synchronized void setShuffleOrder(
                 .cloneAndClear()
                 .cloneAndInsert(/* insertionIndex= */ 0, /* insertionCount= */ size);
       }
-      player
-          .createMessage(this)
-          .setType(MSG_SET_SHUFFLE_ORDER)
-          .setPayload(new MessageData<>(/* index= */ 0, shuffleOrder, actionOnCompletion))
-          .send();
+      playbackThreadHandler
+          .obtainMessage(
+              MSG_SET_SHUFFLE_ORDER,
+              new MessageData<>(/* index= */ 0, shuffleOrder, actionOnCompletion))
+          .sendToTarget();
     } else {
       this.shuffleOrder =
           shuffleOrder.getLength() > 0 ? shuffleOrder.cloneAndClear() : shuffleOrder;
@@ -453,14 +445,20 @@ public final synchronized void setShuffleOrder(
     }
   }
 
+  @Override
+  @Nullable
+  public Object getTag() {
+    return null;
+  }
+
   @Override
   public final synchronized void prepareSourceInternal(
       ExoPlayer player,
       boolean isTopLevelSource,
       @Nullable TransferListener mediaTransferListener) {
     super.prepareSourceInternal(player, isTopLevelSource, mediaTransferListener);
-    this.player = player;
-    playerApplicationHandler = new Handler(player.getApplicationLooper());
+    playbackThreadHandler = new Handler(/* callback= */ this::handleMessage);
+    applicationThreadHandler = new Handler(player.getApplicationLooper());
     if (mediaSourcesPublic.isEmpty()) {
       notifyListener();
     } else {
@@ -478,7 +476,8 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public final MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
+  public final MediaPeriod createPeriod(
+      MediaPeriodId id, Allocator allocator, long startPositionUs) {
     Object mediaSourceHolderUid = getMediaSourceHolderUid(id.periodUid);
     MediaSourceHolder holder = mediaSourceByUid.get(mediaSourceHolderUid);
     if (holder == null) {
@@ -486,7 +485,8 @@ public final MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
       holder = new MediaSourceHolder(new DummyMediaSource());
       holder.hasStartedPreparing = true;
     }
-    DeferredMediaPeriod mediaPeriod = new DeferredMediaPeriod(holder.mediaSource, id, allocator);
+    DeferredMediaPeriod mediaPeriod =
+        new DeferredMediaPeriod(holder.mediaSource, id, allocator, startPositionUs);
     mediaSourceByMediaPeriod.put(mediaPeriod, holder);
     holder.activeMediaPeriods.add(mediaPeriod);
     if (!holder.hasStartedPreparing) {
@@ -513,8 +513,8 @@ public final void releaseSourceInternal() {
     super.releaseSourceInternal();
     mediaSourceHolders.clear();
     mediaSourceByUid.clear();
-    player = null;
-    playerApplicationHandler = null;
+    playbackThreadHandler = null;
+    applicationThreadHandler = null;
     shuffleOrder = shuffleOrder.cloneAndClear();
     windowCount = 0;
     periodCount = 0;
@@ -550,24 +550,22 @@ protected int getWindowIndexForChildWindowIndex(
     return windowIndex + mediaSourceHolder.firstWindowIndexInChild;
   }
 
-  @Override
   @SuppressWarnings("unchecked")
-  public final void handleMessage(int messageType, @Nullable Object message)
-      throws ExoPlaybackException {
-    if (player == null) {
+  private boolean handleMessage(Message msg) {
+    if (playbackThreadHandler == null) {
       // Stale event.
-      return;
+      return false;
     }
-    switch (messageType) {
+    switch (msg.what) {
       case MSG_ADD:
         MessageData<Collection<MediaSourceHolder>> addMessage =
-            (MessageData<Collection<MediaSourceHolder>>) Util.castNonNull(message);
+            (MessageData<Collection<MediaSourceHolder>>) Util.castNonNull(msg.obj);
         shuffleOrder = shuffleOrder.cloneAndInsert(addMessage.index, addMessage.customData.size());
         addMediaSourcesInternal(addMessage.index, addMessage.customData);
         scheduleListenerNotification(addMessage.actionOnCompletion);
         break;
       case MSG_REMOVE:
-        MessageData<Integer> removeMessage = (MessageData<Integer>) Util.castNonNull(message);
+        MessageData<Integer> removeMessage = (MessageData<Integer>) Util.castNonNull(msg.obj);
         int fromIndex = removeMessage.index;
         int toIndex = removeMessage.customData;
         if (fromIndex == 0 && toIndex == shuffleOrder.getLength()) {
@@ -581,7 +579,7 @@ public final void handleMessage(int messageType, @Nullable Object message)
         scheduleListenerNotification(removeMessage.actionOnCompletion);
         break;
       case MSG_MOVE:
-        MessageData<Integer> moveMessage = (MessageData<Integer>) Util.castNonNull(message);
+        MessageData<Integer> moveMessage = (MessageData<Integer>) Util.castNonNull(msg.obj);
         shuffleOrder = shuffleOrder.cloneAndRemove(moveMessage.index, moveMessage.index + 1);
         shuffleOrder = shuffleOrder.cloneAndInsert(moveMessage.customData, 1);
         moveMediaSourceInternal(moveMessage.index, moveMessage.customData);
@@ -589,7 +587,7 @@ public final void handleMessage(int messageType, @Nullable Object message)
         break;
       case MSG_SET_SHUFFLE_ORDER:
         MessageData<ShuffleOrder> shuffleOrderMessage =
-            (MessageData<ShuffleOrder>) Util.castNonNull(message);
+            (MessageData<ShuffleOrder>) Util.castNonNull(msg.obj);
         shuffleOrder = shuffleOrderMessage.customData;
         scheduleListenerNotification(shuffleOrderMessage.actionOnCompletion);
         break;
@@ -597,8 +595,8 @@ public final void handleMessage(int messageType, @Nullable Object message)
         notifyListener();
         break;
       case MSG_ON_COMPLETION:
-        List<Runnable> actionsOnCompletion = (List<Runnable>) Util.castNonNull(message);
-        Handler handler = Assertions.checkNotNull(playerApplicationHandler);
+        List<Runnable> actionsOnCompletion = (List<Runnable>) Util.castNonNull(msg.obj);
+        Handler handler = Assertions.checkNotNull(applicationThreadHandler);
         for (int i = 0; i < actionsOnCompletion.size(); i++) {
           handler.post(actionsOnCompletion.get(i));
         }
@@ -606,11 +604,14 @@ public final void handleMessage(int messageType, @Nullable Object message)
       default:
         throw new IllegalStateException();
     }
+    return true;
   }
 
   private void scheduleListenerNotification(@Nullable Runnable actionOnCompletion) {
     if (!listenerNotificationScheduled) {
-      Assertions.checkNotNull(player).createMessage(this).setType(MSG_NOTIFY_LISTENER).send();
+      Assertions.checkNotNull(playbackThreadHandler)
+          .obtainMessage(MSG_NOTIFY_LISTENER)
+          .sendToTarget();
       listenerNotificationScheduled = true;
     }
     if (actionOnCompletion != null) {
@@ -630,11 +631,9 @@ private void notifyListener() {
             mediaSourceHolders, windowCount, periodCount, shuffleOrder, isAtomic),
         /* manifest= */ null);
     if (!actionsOnCompletion.isEmpty()) {
-      Assertions.checkNotNull(player)
-          .createMessage(this)
-          .setType(MSG_ON_COMPLETION)
-          .setPayload(actionsOnCompletion)
-          .send();
+      Assertions.checkNotNull(playbackThreadHandler)
+          .obtainMessage(MSG_ON_COMPLETION, actionsOnCompletion)
+          .sendToTarget();
     }
   }
 
@@ -712,6 +711,7 @@ private void updateMediaSourceInternal(MediaSourceHolder mediaSourceHolder, Time
       //     unlikely to be a problem as a non-zero default position usually only occurs for live
       //     playbacks and seeking to zero in a live window would cause BehindLiveWindowExceptions
       //     anyway.
+      timeline.getWindow(/* windowIndex= */ 0, window);
       long windowStartPositionUs = window.getDefaultPositionUs();
       if (deferredMediaPeriod != null) {
         long periodPreparePositionUs = deferredMediaPeriod.getPreparePositionUs();
@@ -820,7 +820,7 @@ private static Object getPeriodUid(MediaSourceHolder holder, Object childPeriodU
 
     public MediaSourceHolder(MediaSource mediaSource) {
       this.mediaSource = mediaSource;
-      this.timeline = new DeferredTimeline();
+      this.timeline = DeferredTimeline.createWithDummyTimeline(mediaSource.getTag());
       this.activeMediaPeriods = new ArrayList<>();
       this.uid = new Object();
     }
@@ -945,10 +945,18 @@ public int getPeriodCount() {
   private static final class DeferredTimeline extends ForwardingTimeline {
 
     private static final Object DUMMY_ID = new Object();
-    private static final DummyTimeline DUMMY_TIMELINE = new DummyTimeline();
 
     private final Object replacedId;
 
+    /**
+     * Returns an instance with a dummy timeline using the provided window tag.
+     *
+     * @param windowTag A window tag.
+     */
+    public static DeferredTimeline createWithDummyTimeline(@Nullable Object windowTag) {
+      return new DeferredTimeline(new DummyTimeline(windowTag), DUMMY_ID);
+    }
+
     /**
      * Returns an instance with a real timeline, replacing the provided period ID with the already
      * assigned dummy period ID.
@@ -962,11 +970,6 @@ public static DeferredTimeline createWithRealTimeline(
       return new DeferredTimeline(timeline, firstPeriodUid);
     }
 
-    /** Creates deferred timeline exposing a {@link DummyTimeline}. */
-    public DeferredTimeline() {
-      this(DUMMY_TIMELINE, DUMMY_ID);
-    }
-
     private DeferredTimeline(Timeline timeline, Object replacedId) {
       super(timeline);
       this.replacedId = replacedId;
@@ -1010,6 +1013,12 @@ public Object getUidOfPeriod(int periodIndex) {
   /** Dummy placeholder timeline with one dynamic window with a period of indeterminate duration. */
   private static final class DummyTimeline extends Timeline {
 
+    @Nullable private final Object tag;
+
+    public DummyTimeline(@Nullable Object tag) {
+      this.tag = tag;
+    }
+
     @Override
     public int getWindowCount() {
       return 1;
@@ -1019,7 +1028,7 @@ public int getWindowCount() {
     public Window getWindow(
         int windowIndex, Window window, boolean setTag, long defaultPositionProjectionUs) {
       return window.set(
-          /* tag= */ null,
+          tag,
           /* presentationStartTimeMs= */ C.TIME_UNSET,
           /* windowStartTimeMs= */ C.TIME_UNSET,
           /* isSeekable= */ false,
@@ -1069,6 +1078,12 @@ protected void prepareSourceInternal(
       // Do nothing.
     }
 
+    @Override
+    @Nullable
+    public Object getTag() {
+      return null;
+    }
+
     @Override
     protected void releaseSourceInternal() {
       // Do nothing.
@@ -1080,7 +1095,7 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
     }
 
     @Override
-    public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
+    public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
       throw new UnsupportedOperationException();
     }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/DeferredMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/DeferredMediaPeriod.java
index 26c25a749e..858769180d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/DeferredMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/DeferredMediaPeriod.java
@@ -25,7 +25,7 @@
 
 /**
  * Media period that wraps a media source and defers calling its {@link
- * MediaSource#createPeriod(MediaPeriodId, Allocator)} method until {@link
+ * MediaSource#createPeriod(MediaPeriodId, Allocator, long)} method until {@link
  * #createPeriod(MediaPeriodId)} has been called. This is useful if you need to return a media
  * period immediately but the media source that should create it is not yet prepared.
  */
@@ -60,11 +60,14 @@
    * @param mediaSource The media source to wrap.
    * @param id The identifier used to create the deferred media period.
    * @param allocator The allocator used to create the media period.
+   * @param preparePositionUs The expected start position, in microseconds.
    */
-  public DeferredMediaPeriod(MediaSource mediaSource, MediaPeriodId id, Allocator allocator) {
+  public DeferredMediaPeriod(
+      MediaSource mediaSource, MediaPeriodId id, Allocator allocator, long preparePositionUs) {
     this.id = id;
     this.allocator = allocator;
     this.mediaSource = mediaSource;
+    this.preparePositionUs = preparePositionUs;
     preparePositionOverrideUs = C.TIME_UNSET;
   }
 
@@ -86,28 +89,25 @@ public long getPreparePositionUs() {
 
   /**
    * Overrides the default prepare position at which to prepare the media period. This value is only
-   * used if the call to {@link MediaPeriod#prepare(Callback, long)} is being deferred.
+   * used if called before {@link #createPeriod(MediaPeriodId)}.
    *
-   * @param defaultPreparePositionUs The default prepare position to use, in microseconds.
+   * @param preparePositionUs The default prepare position to use, in microseconds.
    */
-  public void overridePreparePositionUs(long defaultPreparePositionUs) {
-    preparePositionOverrideUs = defaultPreparePositionUs;
+  public void overridePreparePositionUs(long preparePositionUs) {
+    preparePositionOverrideUs = preparePositionUs;
   }
 
   /**
-   * Calls {@link MediaSource#createPeriod(MediaPeriodId, Allocator)} on the wrapped source then
-   * prepares it if {@link #prepare(Callback, long)} has been called. Call {@link #releasePeriod()}
-   * to release the period.
+   * Calls {@link MediaSource#createPeriod(MediaPeriodId, Allocator, long)} on the wrapped source
+   * then prepares it if {@link #prepare(Callback, long)} has been called. Call {@link
+   * #releasePeriod()} to release the period.
    *
    * @param id The identifier that should be used to create the media period from the media source.
    */
   public void createPeriod(MediaPeriodId id) {
-    mediaPeriod = mediaSource.createPeriod(id, allocator);
+    long preparePositionUs = getPreparePositionWithOverride(this.preparePositionUs);
+    mediaPeriod = mediaSource.createPeriod(id, allocator, preparePositionUs);
     if (callback != null) {
-      long preparePositionUs =
-          preparePositionOverrideUs != C.TIME_UNSET
-              ? preparePositionOverrideUs
-              : this.preparePositionUs;
       mediaPeriod.prepare(this, preparePositionUs);
     }
   }
@@ -124,9 +124,8 @@ public void releasePeriod() {
   @Override
   public void prepare(Callback callback, long preparePositionUs) {
     this.callback = callback;
-    this.preparePositionUs = preparePositionUs;
     if (mediaPeriod != null) {
-      mediaPeriod.prepare(this, preparePositionUs);
+      mediaPeriod.prepare(this, getPreparePositionWithOverride(this.preparePositionUs));
     }
   }
 
@@ -217,4 +216,9 @@ public void onPrepared(MediaPeriod mediaPeriod) {
     callback.onPrepared(this);
   }
 
+  private long getPreparePositionWithOverride(long preparePositionUs) {
+    return preparePositionOverrideUs != C.TIME_UNSET
+        ? preparePositionOverrideUs
+        : preparePositionUs;
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
index 31daf65d38..823901af2a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
@@ -346,18 +346,19 @@ public long getBufferedPositionUs() {
     } else if (isPendingReset()) {
       return pendingResetPositionUs;
     }
-    long largestQueuedTimestampUs;
+    long largestQueuedTimestampUs = C.TIME_UNSET;
     if (haveAudioVideoTracks) {
       // Ignore non-AV tracks, which may be sparse or poorly interleaved.
       largestQueuedTimestampUs = Long.MAX_VALUE;
       int trackCount = sampleQueues.length;
       for (int i = 0; i < trackCount; i++) {
-        if (trackIsAudioVideoFlags[i]) {
+        if (trackIsAudioVideoFlags[i] && !sampleQueues[i].isLastSampleQueued()) {
           largestQueuedTimestampUs = Math.min(largestQueuedTimestampUs,
               sampleQueues[i].getLargestQueuedTimestampUs());
         }
       }
-    } else {
+    }
+    if (largestQueuedTimestampUs == C.TIME_UNSET) {
       largestQueuedTimestampUs = getLargestQueuedTimestampUs();
     }
     return largestQueuedTimestampUs == Long.MIN_VALUE ? lastSeekPositionUs
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
index 66af3a7e62..9465a8f1a2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
@@ -358,13 +358,19 @@ private ExtractorMediaSource(
     this.tag = tag;
   }
 
+  @Override
+  @Nullable
+  public Object getTag() {
+    return tag;
+  }
+
   @Override
   public void prepareSourceInternal(
       ExoPlayer player,
       boolean isTopLevelSource,
       @Nullable TransferListener mediaTransferListener) {
     transferListener = mediaTransferListener;
-    notifySourceInfoRefreshed(timelineDurationUs, /* isSeekable= */ false);
+    notifySourceInfoRefreshed(timelineDurationUs, timelineIsSeekable);
   }
 
   @Override
@@ -373,7 +379,7 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
+  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
     DataSource dataSource = dataSourceFactory.createDataSource();
     if (transferListener != null) {
       dataSource.addTransferListener(transferListener);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
index 78a1e75d90..281465eec3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
@@ -64,6 +64,12 @@ public LoopingMediaSource(MediaSource childSource, int loopCount) {
     mediaPeriodToChildMediaPeriodId = new HashMap<>();
   }
 
+  @Override
+  @Nullable
+  public Object getTag() {
+    return childSource.getTag();
+  }
+
   @Override
   public void prepareSourceInternal(
       ExoPlayer player,
@@ -74,14 +80,15 @@ public void prepareSourceInternal(
   }
 
   @Override
-  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
+  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
     if (loopCount == Integer.MAX_VALUE) {
-      return childSource.createPeriod(id, allocator);
+      return childSource.createPeriod(id, allocator, startPositionUs);
     }
     Object childPeriodUid = LoopingTimeline.getChildPeriodUidFromConcatenatedUid(id.periodUid);
     MediaPeriodId childMediaPeriodId = id.copyWithPeriodUid(childPeriodUid);
     childMediaPeriodIdToMediaPeriodId.put(childMediaPeriodId, id);
-    MediaPeriod mediaPeriod = childSource.createPeriod(childMediaPeriodId, allocator);
+    MediaPeriod mediaPeriod =
+        childSource.createPeriod(childMediaPeriodId, allocator, startPositionUs);
     mediaPeriodToChildMediaPeriodId.put(mediaPeriod, childMediaPeriodId);
     return mediaPeriod;
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
index 6b0f5c8eeb..801737faef 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
@@ -35,8 +35,8 @@
  *       on the {@link SourceInfoRefreshListener}s passed to {@link #prepareSource(ExoPlayer,
  *       boolean, SourceInfoRefreshListener, TransferListener)}.
  *   <li>To provide {@link MediaPeriod} instances for the periods in its timeline. MediaPeriods are
- *       obtained by calling {@link #createPeriod(MediaPeriodId, Allocator)}, and provide a way for
- *       the player to load and read the media.
+ *       obtained by calling {@link #createPeriod(MediaPeriodId, Allocator, long)}, and provide a
+ *       way for the player to load and read the media.
  * </ul>
  *
  * All methods are called on the player's internal playback thread, as described in the {@link
@@ -220,6 +220,12 @@ public int hashCode() {
    */
   void removeEventListener(MediaSourceEventListener eventListener);
 
+  /** Returns the tag set on the media source, or null if none was set. */
+  @Nullable
+  default Object getTag() {
+    return null;
+  }
+
   /** @deprecated Will be removed in the next release. */
   @Deprecated
   void prepareSource(
@@ -268,9 +274,10 @@ void prepareSource(
    *
    * @param id The identifier of the period.
    * @param allocator An {@link Allocator} from which to obtain media buffer allocations.
+   * @param startPositionUs The expected start position, in microseconds.
    * @return A new {@link MediaPeriod}.
    */
-  MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator);
+  MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs);
 
   /**
    * Releases the period.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
index ecb4b10c6a..cc7202f9b2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
@@ -98,6 +98,12 @@ public MergingMediaSource(CompositeSequenceableLoaderFactory compositeSequenceab
     timelines = new Timeline[mediaSources.length];
   }
 
+  @Override
+  @Nullable
+  public Object getTag() {
+    return mediaSources.length > 0 ? mediaSources[0].getTag() : null;
+  }
+
   @Override
   public void prepareSourceInternal(
       ExoPlayer player,
@@ -118,13 +124,13 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
+  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
     MediaPeriod[] periods = new MediaPeriod[mediaSources.length];
     int periodIndex = timelines[0].getIndexOfPeriod(id.periodUid);
     for (int i = 0; i < periods.length; i++) {
       MediaPeriodId childMediaPeriodId =
           id.copyWithPeriodUid(timelines[i].getUidOfPeriod(periodIndex));
-      periods[i] = mediaSources[i].createPeriod(childMediaPeriodId, allocator);
+      periods[i] = mediaSources[i].createPeriod(childMediaPeriodId, allocator, startPositionUs);
     }
     return new MergingMediaPeriod(compositeSequenceableLoaderFactory, periods);
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleMetadataQueue.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleMetadataQueue.java
index e5b950cf2e..ab5c5e57d9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleMetadataQueue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleMetadataQueue.java
@@ -57,6 +57,7 @@
 
   private long largestDiscardedTimestampUs;
   private long largestQueuedTimestampUs;
+  private boolean isLastSampleQueued;
   private boolean upstreamKeyframeRequired;
   private boolean upstreamFormatRequired;
   private Format upstreamFormat;
@@ -93,6 +94,7 @@ public void reset(boolean resetUpstreamFormat) {
     upstreamKeyframeRequired = true;
     largestDiscardedTimestampUs = Long.MIN_VALUE;
     largestQueuedTimestampUs = Long.MIN_VALUE;
+    isLastSampleQueued = false;
     if (resetUpstreamFormat) {
       upstreamFormat = null;
       upstreamFormatRequired = true;
@@ -118,6 +120,7 @@ public long discardUpstreamSamples(int discardFromIndex) {
     Assertions.checkArgument(0 <= discardCount && discardCount <= (length - readPosition));
     length -= discardCount;
     largestQueuedTimestampUs = Math.max(largestDiscardedTimestampUs, getLargestTimestamp(length));
+    isLastSampleQueued = discardCount == 0 && isLastSampleQueued;
     if (length == 0) {
       return 0;
     } else {
@@ -186,6 +189,19 @@ public synchronized long getLargestQueuedTimestampUs() {
     return largestQueuedTimestampUs;
   }
 
+  /**
+   * Returns whether the last sample of the stream has knowingly been queued. A return value of
+   * {@code false} means that the last sample had not been queued or that it's unknown whether the
+   * last sample has been queued.
+   *
+   * <p>Samples that were discarded by calling {@link #discardUpstreamSamples(int)} are not
+   * considered as having been queued. Samples that were dequeued from the front of the queue are
+   * considered as having been queued.
+   */
+  public synchronized boolean isLastSampleQueued() {
+    return isLastSampleQueued;
+  }
+
   /** Returns the timestamp of the first sample, or {@link Long#MIN_VALUE} if the queue is empty. */
   public synchronized long getFirstTimestampUs() {
     return length == 0 ? Long.MIN_VALUE : timesUs[relativeFirstIndex];
@@ -224,7 +240,7 @@ public synchronized int read(FormatHolder formatHolder, DecoderInputBuffer buffe
       boolean formatRequired, boolean loadingFinished, Format downstreamFormat,
       SampleExtrasHolder extrasHolder) {
     if (!hasNextSample()) {
-      if (loadingFinished) {
+      if (loadingFinished || isLastSampleQueued) {
         buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
         return C.RESULT_BUFFER_READ;
       } else if (upstreamFormat != null
@@ -388,7 +404,9 @@ public synchronized void commitSample(long timeUs, @C.BufferFlags int sampleFlag
       upstreamKeyframeRequired = false;
     }
     Assertions.checkState(!upstreamFormatRequired);
-    commitSampleTimestamp(timeUs);
+
+    isLastSampleQueued = (sampleFlags & C.BUFFER_FLAG_LAST_SAMPLE) != 0;
+    largestQueuedTimestampUs = Math.max(largestQueuedTimestampUs, timeUs);
 
     int relativeEndIndex = getRelativeIndex(length);
     timesUs[relativeEndIndex] = timeUs;
@@ -439,10 +457,6 @@ public synchronized void commitSample(long timeUs, @C.BufferFlags int sampleFlag
     }
   }
 
-  public synchronized void commitSampleTimestamp(long timeUs) {
-    largestQueuedTimestampUs = Math.max(largestQueuedTimestampUs, timeUs);
-  }
-
   /**
    * Attempts to discard samples from the end of the queue to allow samples starting from the
    * specified timestamp to be spliced in. Samples will not be discarded prior to the read position.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java
index ecc720c656..0886e79d21 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java
@@ -224,6 +224,15 @@ public long getLargestQueuedTimestampUs() {
     return metadataQueue.getLargestQueuedTimestampUs();
   }
 
+  /**
+   * Returns whether the last sample of the stream has knowingly been queued. A return value of
+   * {@code false} means that the last sample had not been queued or that it's unknown whether the
+   * last sample has been queued.
+   */
+  public boolean isLastSampleQueued() {
+    return metadataQueue.isLastSampleQueued();
+  }
+
   /** Returns the timestamp of the first sample, or {@link Long#MIN_VALUE} if the queue is empty. */
   public long getFirstTimestampUs() {
     return metadataQueue.getFirstTimestampUs();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
index 1ac6207454..046672bb77 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
@@ -185,6 +185,7 @@ public SingleSampleMediaSource createMediaSource(
   private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
   private final boolean treatLoadErrorsAsEndOfStream;
   private final Timeline timeline;
+  @Nullable private final Object tag;
 
   private @Nullable TransferListener transferListener;
 
@@ -287,6 +288,7 @@ private SingleSampleMediaSource(
     this.durationUs = durationUs;
     this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
     this.treatLoadErrorsAsEndOfStream = treatLoadErrorsAsEndOfStream;
+    this.tag = tag;
     dataSpec =
         new DataSpec(uri, DataSpec.FLAG_ALLOW_GZIP | DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH);
     timeline =
@@ -295,6 +297,12 @@ private SingleSampleMediaSource(
 
   // MediaSource implementation.
 
+  @Override
+  @Nullable
+  public Object getTag() {
+    return tag;
+  }
+
   @Override
   public void prepareSourceInternal(
       ExoPlayer player,
@@ -310,7 +318,7 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
+  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
     return new SingleSampleMediaPeriod(
         dataSpec,
         dataSourceFactory,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java
index 7fc0f22bf3..4bf661ddc0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java
@@ -319,6 +319,12 @@ public AdsMediaSource(
     adsLoader.setSupportedContentTypes(adMediaSourceFactory.getSupportedTypes());
   }
 
+  @Override
+  @Nullable
+  public Object getTag() {
+    return contentMediaSource.getTag();
+  }
+
   @Override
   public void prepareSourceInternal(
       final ExoPlayer player,
@@ -335,7 +341,7 @@ public void prepareSourceInternal(
   }
 
   @Override
-  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
+  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
     if (adPlaybackState.adGroupCount > 0 && id.isAd()) {
       int adGroupIndex = id.adGroupIndex;
       int adIndexInAdGroup = id.adIndexInAdGroup;
@@ -354,7 +360,8 @@ public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
         prepareChildSource(id, adMediaSource);
       }
       MediaSource mediaSource = adGroupMediaSources[adGroupIndex][adIndexInAdGroup];
-      DeferredMediaPeriod deferredMediaPeriod = new DeferredMediaPeriod(mediaSource, id, allocator);
+      DeferredMediaPeriod deferredMediaPeriod =
+          new DeferredMediaPeriod(mediaSource, id, allocator, startPositionUs);
       deferredMediaPeriod.setPrepareErrorListener(
           new AdPrepareErrorListener(adUri, adGroupIndex, adIndexInAdGroup));
       List<DeferredMediaPeriod> mediaPeriods = deferredMediaPeriodByAdMediaSource.get(mediaSource);
@@ -370,7 +377,8 @@ public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
       }
       return deferredMediaPeriod;
     } else {
-      DeferredMediaPeriod mediaPeriod = new DeferredMediaPeriod(contentMediaSource, id, allocator);
+      DeferredMediaPeriod mediaPeriod =
+          new DeferredMediaPeriod(contentMediaSource, id, allocator, startPositionUs);
       mediaPeriod.createPeriod(id);
       return mediaPeriod;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlDecoder.java
index 2e868077a5..b39f467968 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlDecoder.java
@@ -68,6 +68,7 @@
   private static final String ATTR_END = "end";
   private static final String ATTR_STYLE = "style";
   private static final String ATTR_REGION = "region";
+  private static final String ATTR_IMAGE = "backgroundImage";
 
   private static final Pattern CLOCK_TIME =
       Pattern.compile("^([0-9][0-9]+):([0-9][0-9]):([0-9][0-9])"
@@ -77,6 +78,8 @@
   private static final Pattern FONT_SIZE = Pattern.compile("^(([0-9]*.)?[0-9]+)(px|em|%)$");
   private static final Pattern PERCENTAGE_COORDINATES =
       Pattern.compile("^(\\d+\\.?\\d*?)% (\\d+\\.?\\d*?)%$");
+  private static final Pattern PIXEL_COORDINATES =
+      Pattern.compile("^(\\d+\\.?\\d*?)px (\\d+\\.?\\d*?)px$");
   private static final Pattern CELL_RESOLUTION = Pattern.compile("^(\\d+) (\\d+)$");
 
   private static final int DEFAULT_FRAME_RATE = 30;
@@ -105,6 +108,7 @@ protected TtmlSubtitle decode(byte[] bytes, int length, boolean reset)
       XmlPullParser xmlParser = xmlParserFactory.newPullParser();
       Map<String, TtmlStyle> globalStyles = new HashMap<>();
       Map<String, TtmlRegion> regionMap = new HashMap<>();
+      Map<String, String> imageMap = new HashMap<>();
       regionMap.put(TtmlNode.ANONYMOUS_REGION_ID, new TtmlRegion(null));
       ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes, 0, length);
       xmlParser.setInput(inputStream, null);
@@ -114,6 +118,7 @@ protected TtmlSubtitle decode(byte[] bytes, int length, boolean reset)
       int eventType = xmlParser.getEventType();
       FrameAndTickRate frameAndTickRate = DEFAULT_FRAME_AND_TICK_RATE;
       CellResolution cellResolution = DEFAULT_CELL_RESOLUTION;
+      TtsExtent ttsExtent = null;
       while (eventType != XmlPullParser.END_DOCUMENT) {
         TtmlNode parent = nodeStack.peek();
         if (unsupportedNodeDepth == 0) {
@@ -122,12 +127,13 @@ protected TtmlSubtitle decode(byte[] bytes, int length, boolean reset)
             if (TtmlNode.TAG_TT.equals(name)) {
               frameAndTickRate = parseFrameAndTickRates(xmlParser);
               cellResolution = parseCellResolution(xmlParser, DEFAULT_CELL_RESOLUTION);
+              ttsExtent = parseTtsExtent(xmlParser);
             }
             if (!isSupportedTag(name)) {
               Log.i(TAG, "Ignoring unsupported tag: " + xmlParser.getName());
               unsupportedNodeDepth++;
             } else if (TtmlNode.TAG_HEAD.equals(name)) {
-              parseHeader(xmlParser, globalStyles, regionMap, cellResolution);
+              parseHeader(xmlParser, globalStyles, cellResolution, ttsExtent, regionMap, imageMap);
             } else {
               try {
                 TtmlNode node = parseNode(xmlParser, parent, regionMap, frameAndTickRate);
@@ -145,7 +151,7 @@ protected TtmlSubtitle decode(byte[] bytes, int length, boolean reset)
             parent.addChild(TtmlNode.buildTextNode(xmlParser.getText()));
           } else if (eventType == XmlPullParser.END_TAG) {
             if (xmlParser.getName().equals(TtmlNode.TAG_TT)) {
-              ttmlSubtitle = new TtmlSubtitle(nodeStack.peek(), globalStyles, regionMap);
+              ttmlSubtitle = new TtmlSubtitle(nodeStack.peek(), globalStyles, regionMap, imageMap);
             }
             nodeStack.pop();
           }
@@ -226,11 +232,34 @@ private CellResolution parseCellResolution(XmlPullParser xmlParser, CellResoluti
     }
   }
 
+  private TtsExtent parseTtsExtent(XmlPullParser xmlParser) {
+    String ttsExtent = XmlPullParserUtil.getAttributeValue(xmlParser, TtmlNode.ATTR_TTS_EXTENT);
+    if (ttsExtent == null) {
+      return null;
+    }
+
+    Matcher extentMatcher = PIXEL_COORDINATES.matcher(ttsExtent);
+    if (!extentMatcher.matches()) {
+      Log.w(TAG, "Ignoring non-pixel tts extent: " + ttsExtent);
+      return null;
+    }
+    try {
+      int width = Integer.parseInt(extentMatcher.group(1));
+      int height = Integer.parseInt(extentMatcher.group(2));
+      return new TtsExtent(width, height);
+    } catch (NumberFormatException e) {
+      Log.w(TAG, "Ignoring malformed tts extent: " + ttsExtent);
+      return null;
+    }
+  }
+
   private Map<String, TtmlStyle> parseHeader(
       XmlPullParser xmlParser,
       Map<String, TtmlStyle> globalStyles,
+      CellResolution cellResolution,
+      TtsExtent ttsExtent,
       Map<String, TtmlRegion> globalRegions,
-      CellResolution cellResolution)
+      Map<String, String> imageMap)
       throws IOException, XmlPullParserException {
     do {
       xmlParser.next();
@@ -246,23 +275,41 @@ private CellResolution parseCellResolution(XmlPullParser xmlParser, CellResoluti
           globalStyles.put(style.getId(), style);
         }
       } else if (XmlPullParserUtil.isStartTag(xmlParser, TtmlNode.TAG_REGION)) {
-        TtmlRegion ttmlRegion = parseRegionAttributes(xmlParser, cellResolution);
+        TtmlRegion ttmlRegion = parseRegionAttributes(xmlParser, cellResolution, ttsExtent);
         if (ttmlRegion != null) {
           globalRegions.put(ttmlRegion.id, ttmlRegion);
         }
+      } else if (XmlPullParserUtil.isStartTag(xmlParser, TtmlNode.TAG_METADATA)) {
+        parseMetadata(xmlParser, imageMap);
       }
     } while (!XmlPullParserUtil.isEndTag(xmlParser, TtmlNode.TAG_HEAD));
     return globalStyles;
   }
 
+  private void parseMetadata(XmlPullParser xmlParser, Map<String, String> imageMap)
+      throws IOException, XmlPullParserException {
+    do {
+      xmlParser.next();
+      if (XmlPullParserUtil.isStartTag(xmlParser, TtmlNode.TAG_IMAGE)) {
+        String id = XmlPullParserUtil.getAttributeValue(xmlParser, "id");
+        if (id != null) {
+          String encodedBitmapData = xmlParser.nextText();
+          imageMap.put(id, encodedBitmapData);
+        }
+      }
+    } while (!XmlPullParserUtil.isEndTag(xmlParser, TtmlNode.TAG_METADATA));
+  }
+
   /**
    * Parses a region declaration.
    *
-   * <p>If the region defines an origin and extent, it is required that they're defined as
-   * percentages of the viewport. Region declarations that define origin and extent in other formats
-   * are unsupported, and null is returned.
+   * <p>Supports both percentage and pixel defined regions. In case of pixel defined regions the
+   * passed {@code ttsExtent} is used as a reference window to convert the pixel values to
+   * fractions. In case of missing tts:extent the pixel defined regions can't be parsed, and null is
+   * returned.
    */
-  private TtmlRegion parseRegionAttributes(XmlPullParser xmlParser, CellResolution cellResolution) {
+  private TtmlRegion parseRegionAttributes(
+      XmlPullParser xmlParser, CellResolution cellResolution, TtsExtent ttsExtent) {
     String regionId = XmlPullParserUtil.getAttributeValue(xmlParser, TtmlNode.ATTR_ID);
     if (regionId == null) {
       return null;
@@ -270,13 +317,30 @@ private TtmlRegion parseRegionAttributes(XmlPullParser xmlParser, CellResolution
 
     float position;
     float line;
+
     String regionOrigin = XmlPullParserUtil.getAttributeValue(xmlParser, TtmlNode.ATTR_TTS_ORIGIN);
     if (regionOrigin != null) {
-      Matcher originMatcher = PERCENTAGE_COORDINATES.matcher(regionOrigin);
-      if (originMatcher.matches()) {
+      Matcher originPercentageMatcher = PERCENTAGE_COORDINATES.matcher(regionOrigin);
+      Matcher originPixelMatcher = PIXEL_COORDINATES.matcher(regionOrigin);
+      if (originPercentageMatcher.matches()) {
         try {
-          position = Float.parseFloat(originMatcher.group(1)) / 100f;
-          line = Float.parseFloat(originMatcher.group(2)) / 100f;
+          position = Float.parseFloat(originPercentageMatcher.group(1)) / 100f;
+          line = Float.parseFloat(originPercentageMatcher.group(2)) / 100f;
+        } catch (NumberFormatException e) {
+          Log.w(TAG, "Ignoring region with malformed origin: " + regionOrigin);
+          return null;
+        }
+      } else if (originPixelMatcher.matches()) {
+        if (ttsExtent == null) {
+          Log.w(TAG, "Ignoring region with missing tts:extent: " + regionOrigin);
+          return null;
+        }
+        try {
+          int width = Integer.parseInt(originPixelMatcher.group(1));
+          int height = Integer.parseInt(originPixelMatcher.group(2));
+          // Convert pixel values to fractions.
+          position = width / (float) ttsExtent.width;
+          line = height / (float) ttsExtent.height;
         } catch (NumberFormatException e) {
           Log.w(TAG, "Ignoring region with malformed origin: " + regionOrigin);
           return null;
@@ -299,11 +363,27 @@ private TtmlRegion parseRegionAttributes(XmlPullParser xmlParser, CellResolution
     float height;
     String regionExtent = XmlPullParserUtil.getAttributeValue(xmlParser, TtmlNode.ATTR_TTS_EXTENT);
     if (regionExtent != null) {
-      Matcher extentMatcher = PERCENTAGE_COORDINATES.matcher(regionExtent);
-      if (extentMatcher.matches()) {
+      Matcher extentPercentageMatcher = PERCENTAGE_COORDINATES.matcher(regionExtent);
+      Matcher extentPixelMatcher = PIXEL_COORDINATES.matcher(regionExtent);
+      if (extentPercentageMatcher.matches()) {
         try {
-          width = Float.parseFloat(extentMatcher.group(1)) / 100f;
-          height = Float.parseFloat(extentMatcher.group(2)) / 100f;
+          width = Float.parseFloat(extentPercentageMatcher.group(1)) / 100f;
+          height = Float.parseFloat(extentPercentageMatcher.group(2)) / 100f;
+        } catch (NumberFormatException e) {
+          Log.w(TAG, "Ignoring region with malformed extent: " + regionOrigin);
+          return null;
+        }
+      } else if (extentPixelMatcher.matches()) {
+        if (ttsExtent == null) {
+          Log.w(TAG, "Ignoring region with missing tts:extent: " + regionOrigin);
+          return null;
+        }
+        try {
+          int extentWidth = Integer.parseInt(extentPixelMatcher.group(1));
+          int extentHeight = Integer.parseInt(extentPixelMatcher.group(2));
+          // Convert pixel values to fractions.
+          width = extentWidth / (float) ttsExtent.width;
+          height = extentHeight / (float) ttsExtent.height;
         } catch (NumberFormatException e) {
           Log.w(TAG, "Ignoring region with malformed extent: " + regionOrigin);
           return null;
@@ -457,6 +537,7 @@ private TtmlNode parseNode(XmlPullParser parser, TtmlNode parent,
     long startTime = C.TIME_UNSET;
     long endTime = C.TIME_UNSET;
     String regionId = TtmlNode.ANONYMOUS_REGION_ID;
+    String imageId = null;
     String[] styleIds = null;
     int attributeCount = parser.getAttributeCount();
     TtmlStyle style = parseStyleAttributes(parser, null);
@@ -487,6 +568,13 @@ private TtmlNode parseNode(XmlPullParser parser, TtmlNode parent,
             regionId = value;
           }
           break;
+        case ATTR_IMAGE:
+          // Parse URI reference only if refers to an element in the same document (it must start
+          // with '#'). Resolving URIs from external sources is not supported.
+          if (value.startsWith("#")) {
+            imageId = value.substring(1);
+          }
+          break;
         default:
           // Do nothing.
           break;
@@ -509,7 +597,8 @@ private TtmlNode parseNode(XmlPullParser parser, TtmlNode parent,
         endTime = parent.endTimeUs;
       }
     }
-    return TtmlNode.buildNode(parser.getName(), startTime, endTime, style, styleIds, regionId);
+    return TtmlNode.buildNode(
+        parser.getName(), startTime, endTime, style, styleIds, regionId, imageId);
   }
 
   private static boolean isSupportedTag(String tag) {
@@ -525,9 +614,9 @@ private static boolean isSupportedTag(String tag) {
         || tag.equals(TtmlNode.TAG_LAYOUT)
         || tag.equals(TtmlNode.TAG_REGION)
         || tag.equals(TtmlNode.TAG_METADATA)
-        || tag.equals(TtmlNode.TAG_SMPTE_IMAGE)
-        || tag.equals(TtmlNode.TAG_SMPTE_DATA)
-        || tag.equals(TtmlNode.TAG_SMPTE_INFORMATION);
+        || tag.equals(TtmlNode.TAG_IMAGE)
+        || tag.equals(TtmlNode.TAG_DATA)
+        || tag.equals(TtmlNode.TAG_INFORMATION);
   }
 
   private static void parseFontSize(String expression, TtmlStyle out) throws
@@ -651,4 +740,15 @@ private static long parseTimeExpression(String time, FrameAndTickRate frameAndTi
       this.rows = rows;
     }
   }
+
+  /** Represents the tts:extent for a TTML file. */
+  private static final class TtsExtent {
+    final int width;
+    final int height;
+
+    TtsExtent(int width, int height) {
+      this.width = width;
+      this.height = height;
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlNode.java b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlNode.java
index c8b9a59de4..020bbe201b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlNode.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlNode.java
@@ -15,7 +15,12 @@
  */
 package com.google.android.exoplayer2.text.ttml;
 
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.support.annotation.Nullable;
 import android.text.SpannableStringBuilder;
+import android.util.Base64;
+import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.util.Assertions;
@@ -44,9 +49,9 @@
   public static final String TAG_LAYOUT = "layout";
   public static final String TAG_REGION = "region";
   public static final String TAG_METADATA = "metadata";
-  public static final String TAG_SMPTE_IMAGE = "smpte:image";
-  public static final String TAG_SMPTE_DATA = "smpte:data";
-  public static final String TAG_SMPTE_INFORMATION = "smpte:information";
+  public static final String TAG_IMAGE = "image";
+  public static final String TAG_DATA = "data";
+  public static final String TAG_INFORMATION = "information";
 
   public static final String ANONYMOUS_REGION_ID = "";
   public static final String ATTR_ID = "id";
@@ -75,34 +80,57 @@
   public static final String START = "start";
   public static final String END = "end";
 
-  public final String tag;
-  public final String text;
+  @Nullable public final String tag;
+  @Nullable public final String text;
   public final boolean isTextNode;
   public final long startTimeUs;
   public final long endTimeUs;
-  public final TtmlStyle style;
+  @Nullable public final TtmlStyle style;
+  @Nullable private final String[] styleIds;
   public final String regionId;
+  @Nullable public final String imageId;
 
-  private final String[] styleIds;
   private final HashMap<String, Integer> nodeStartsByRegion;
   private final HashMap<String, Integer> nodeEndsByRegion;
 
   private List<TtmlNode> children;
 
   public static TtmlNode buildTextNode(String text) {
-    return new TtmlNode(null, TtmlRenderUtil.applyTextElementSpacePolicy(text), C.TIME_UNSET,
-        C.TIME_UNSET, null, null, ANONYMOUS_REGION_ID);
+    return new TtmlNode(
+        /* tag= */ null,
+        TtmlRenderUtil.applyTextElementSpacePolicy(text),
+        /* startTimeUs= */ C.TIME_UNSET,
+        /* endTimeUs= */ C.TIME_UNSET,
+        /* style= */ null,
+        /* styleIds= */ null,
+        ANONYMOUS_REGION_ID,
+        /* imageId= */ null);
   }
 
-  public static TtmlNode buildNode(String tag, long startTimeUs, long endTimeUs,
-      TtmlStyle style, String[] styleIds, String regionId) {
-    return new TtmlNode(tag, null, startTimeUs, endTimeUs, style, styleIds, regionId);
+  public static TtmlNode buildNode(
+      @Nullable String tag,
+      long startTimeUs,
+      long endTimeUs,
+      @Nullable TtmlStyle style,
+      @Nullable String[] styleIds,
+      String regionId,
+      @Nullable String imageId) {
+    return new TtmlNode(
+        tag, /* text= */ null, startTimeUs, endTimeUs, style, styleIds, regionId, imageId);
   }
 
-  private TtmlNode(String tag, String text, long startTimeUs, long endTimeUs,
-      TtmlStyle style, String[] styleIds, String regionId) {
+  private TtmlNode(
+      @Nullable String tag,
+      @Nullable String text,
+      long startTimeUs,
+      long endTimeUs,
+      @Nullable TtmlStyle style,
+      @Nullable String[] styleIds,
+      String regionId,
+      @Nullable String imageId) {
     this.tag = tag;
     this.text = text;
+    this.imageId = imageId;
     this.style = style;
     this.styleIds = styleIds;
     this.isTextNode = text != null;
@@ -151,7 +179,8 @@ public int getChildCount() {
 
   private void getEventTimes(TreeSet<Long> out, boolean descendsPNode) {
     boolean isPNode = TAG_P.equals(tag);
-    if (descendsPNode || isPNode) {
+    boolean isDivNode = TAG_DIV.equals(tag);
+    if (descendsPNode || isPNode || (isDivNode && imageId != null)) {
       if (startTimeUs != C.TIME_UNSET) {
         out.add(startTimeUs);
       }
@@ -171,13 +200,46 @@ private void getEventTimes(TreeSet<Long> out, boolean descendsPNode) {
     return styleIds;
   }
 
-  public List<Cue> getCues(long timeUs, Map<String, TtmlStyle> globalStyles,
-      Map<String, TtmlRegion> regionMap) {
-    TreeMap<String, SpannableStringBuilder> regionOutputs = new TreeMap<>();
-    traverseForText(timeUs, false, regionId, regionOutputs);
-    traverseForStyle(timeUs, globalStyles, regionOutputs);
+  public List<Cue> getCues(
+      long timeUs,
+      Map<String, TtmlStyle> globalStyles,
+      Map<String, TtmlRegion> regionMap,
+      Map<String, String> imageMap) {
+
+    List<Pair<String, String>> regionImageOutputs = new ArrayList<>();
+    traverseForImage(timeUs, regionId, regionImageOutputs);
+
+    TreeMap<String, SpannableStringBuilder> regionTextOutputs = new TreeMap<>();
+    traverseForText(timeUs, false, regionId, regionTextOutputs);
+    traverseForStyle(timeUs, globalStyles, regionTextOutputs);
+
     List<Cue> cues = new ArrayList<>();
-    for (Entry<String, SpannableStringBuilder> entry : regionOutputs.entrySet()) {
+
+    // Create image based cues.
+    for (Pair<String, String> regionImagePair : regionImageOutputs) {
+      String encodedBitmapData = imageMap.get(regionImagePair.second);
+      if (encodedBitmapData == null) {
+        // Image reference points to an invalid image. Do nothing.
+        continue;
+      }
+
+      byte[] bitmapData = Base64.decode(encodedBitmapData, Base64.DEFAULT);
+      Bitmap bitmap = BitmapFactory.decodeByteArray(bitmapData, /* offset= */ 0, bitmapData.length);
+      TtmlRegion region = regionMap.get(regionImagePair.first);
+
+      cues.add(
+          new Cue(
+              bitmap,
+              region.position,
+              Cue.ANCHOR_TYPE_MIDDLE,
+              region.line,
+              region.lineAnchor,
+              region.width,
+              /* height= */ Cue.DIMEN_UNSET));
+    }
+
+    // Create text based cues.
+    for (Entry<String, SpannableStringBuilder> entry : regionTextOutputs.entrySet()) {
       TtmlRegion region = regionMap.get(entry.getKey());
       cues.add(
           new Cue(
@@ -192,9 +254,22 @@ private void getEventTimes(TreeSet<Long> out, boolean descendsPNode) {
               region.textSizeType,
               region.textSize));
     }
+
     return cues;
   }
 
+  private void traverseForImage(
+      long timeUs, String inheritedRegion, List<Pair<String, String>> regionImageList) {
+    String resolvedRegionId = ANONYMOUS_REGION_ID.equals(regionId) ? inheritedRegion : regionId;
+    if (isActive(timeUs) && TAG_DIV.equals(tag) && imageId != null) {
+      regionImageList.add(new Pair<>(resolvedRegionId, imageId));
+      return;
+    }
+    for (int i = 0; i < getChildCount(); ++i) {
+      getChild(i).traverseForImage(timeUs, resolvedRegionId, regionImageList);
+    }
+  }
+
   private void traverseForText(
       long timeUs,
       boolean descendsPNode,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlSubtitle.java b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlSubtitle.java
index 50916aa841..7b30461750 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlSubtitle.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlSubtitle.java
@@ -32,11 +32,16 @@
   private final long[] eventTimesUs;
   private final Map<String, TtmlStyle> globalStyles;
   private final Map<String, TtmlRegion> regionMap;
+  private final Map<String, String> imageMap;
 
-  public TtmlSubtitle(TtmlNode root, Map<String, TtmlStyle> globalStyles,
-      Map<String, TtmlRegion> regionMap) {
+  public TtmlSubtitle(
+      TtmlNode root,
+      Map<String, TtmlStyle> globalStyles,
+      Map<String, TtmlRegion> regionMap,
+      Map<String, String> imageMap) {
     this.root = root;
     this.regionMap = regionMap;
+    this.imageMap = imageMap;
     this.globalStyles =
         globalStyles != null ? Collections.unmodifiableMap(globalStyles) : Collections.emptyMap();
     this.eventTimesUs = root.getEventTimesUs();
@@ -65,7 +70,7 @@ public long getEventTime(int index) {
 
   @Override
   public List<Cue> getCues(long timeUs) {
-    return root.getCues(timeUs, globalStyles, regionMap);
+    return root.getCues(timeUs, globalStyles, regionMap, imageMap);
   }
 
   /* @VisibleForTesting */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java
index c759499577..ab22e18358 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java
@@ -64,11 +64,11 @@
   long open(DataSpec dataSpec) throws IOException;
 
   /**
-   * Reads up to {@code length} bytes of data and stores them into {@code buffer}, starting at
+   * Reads up to {@code readLength} bytes of data and stores them into {@code buffer}, starting at
    * index {@code offset}.
-   * <p>
-   * If {@code length} is zero then 0 is returned. Otherwise, if no data is available because the
-   * end of the opened range has been reached, then {@link C#RESULT_END_OF_INPUT} is returned.
+   *
+   * <p>If {@code readLength} is zero then 0 is returned. Otherwise, if no data is available because
+   * the end of the opened range has been reached, then {@link C#RESULT_END_OF_INPUT} is returned.
    * Otherwise, the call will block until at least one byte of data has been read and the number of
    * bytes read is returned.
    *
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java
index a769e9acac..b5b5dc64e6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java
@@ -82,7 +82,7 @@ public CacheException(Throwable cause) {
    * Releases the cache. This method must be called when the cache is no longer required. The cache
    * must not be used after calling this method.
    */
-  void release() throws CacheException;
+  void release();
 
   /**
    * Registers a listener to listen for changes to a given key.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
index 8d310015f8..63bc47504b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
@@ -43,8 +43,8 @@
   private final Cache cache;
   private final long maxCacheFileSize;
   private final int bufferSize;
-  private final boolean syncFileDescriptor;
 
+  private boolean syncFileDescriptor;
   private DataSpec dataSpec;
   private File file;
   private OutputStream outputStream;
@@ -64,18 +64,6 @@ public CacheDataSinkException(IOException cause) {
 
   }
 
-  /**
-   * Constructs a CacheDataSink using the {@link #DEFAULT_BUFFER_SIZE}.
-   *
-   * @param cache The cache into which data should be written.
-   * @param maxCacheFileSize The maximum size of a cache file, in bytes. If the sink is opened for
-   *    a {@link DataSpec} whose size exceeds this value, then the data will be fragmented into
-   *    multiple cache files.
-   */
-  public CacheDataSink(Cache cache, long maxCacheFileSize) {
-    this(cache, maxCacheFileSize, DEFAULT_BUFFER_SIZE, true);
-  }
-
   /**
    * Constructs a CacheDataSink using the {@link #DEFAULT_BUFFER_SIZE}.
    *
@@ -83,10 +71,9 @@ public CacheDataSink(Cache cache, long maxCacheFileSize) {
    * @param maxCacheFileSize The maximum size of a cache file, in bytes. If the sink is opened for a
    *     {@link DataSpec} whose size exceeds this value, then the data will be fragmented into
    *     multiple cache files.
-   * @param syncFileDescriptor Whether file descriptors are sync'd when closing output streams.
    */
-  public CacheDataSink(Cache cache, long maxCacheFileSize, boolean syncFileDescriptor) {
-    this(cache, maxCacheFileSize, DEFAULT_BUFFER_SIZE, syncFileDescriptor);
+  public CacheDataSink(Cache cache, long maxCacheFileSize) {
+    this(cache, maxCacheFileSize, DEFAULT_BUFFER_SIZE);
   }
 
   /**
@@ -98,23 +85,21 @@ public CacheDataSink(Cache cache, long maxCacheFileSize, boolean syncFileDescrip
    *     value disables buffering.
    */
   public CacheDataSink(Cache cache, long maxCacheFileSize, int bufferSize) {
-    this(cache, maxCacheFileSize, bufferSize, true);
+    this.cache = Assertions.checkNotNull(cache);
+    this.maxCacheFileSize = maxCacheFileSize;
+    this.bufferSize = bufferSize;
+    syncFileDescriptor = true;
   }
 
   /**
-   * @param cache The cache into which data should be written.
-   * @param maxCacheFileSize The maximum size of a cache file, in bytes. If the sink is opened for a
-   *     {@link DataSpec} whose size exceeds this value, then the data will be fragmented into
-   *     multiple cache files.
-   * @param bufferSize The buffer size in bytes for writing to a cache file. A zero or negative
-   *     value disables buffering.
-   * @param syncFileDescriptor Whether file descriptors are sync'd when closing output streams.
+   * Sets whether file descriptors are synced when closing output streams.
+   *
+   * <p>This method is experimental, and will be renamed or removed in a future release. It should
+   * only be called before the renderer is used.
+   *
+   * @param syncFileDescriptor Whether file descriptors are synced when closing output streams.
    */
-  public CacheDataSink(
-      Cache cache, long maxCacheFileSize, int bufferSize, boolean syncFileDescriptor) {
-    this.cache = Assertions.checkNotNull(cache);
-    this.maxCacheFileSize = maxCacheFileSize;
-    this.bufferSize = bufferSize;
+  public void experimental_setSyncFileDescriptor(boolean syncFileDescriptor) {
     this.syncFileDescriptor = syncFileDescriptor;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
index 3bcfac5053..43e6730844 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.upstream.cache;
 
 import android.util.SparseArray;
+import android.util.SparseBooleanArray;
 import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.AtomicFile;
@@ -41,6 +42,7 @@
 import javax.crypto.NoSuchPaddingException;
 import javax.crypto.spec.IvParameterSpec;
 import javax.crypto.spec.SecretKeySpec;
+import org.checkerframework.checker.nullness.compatqual.NullableType;
 
 /** Maintains the index of cached content. */
 /*package*/ class CachedContentIndex {
@@ -52,7 +54,30 @@
   private static final int FLAG_ENCRYPTED_INDEX = 1;
 
   private final HashMap<String, CachedContent> keyToContent;
-  private final SparseArray<String> idToKey;
+  /**
+   * Maps assigned ids to their corresponding keys. Also contains (id -> null) entries for ids that
+   * have been removed from the index since it was last stored. This prevents reuse of these ids,
+   * which is necessary to avoid clashes that could otherwise occur as a result of the sequence:
+   *
+   * <p>[1] (key1, id1) is removed from the in-memory index ... the index is not stored to disk ...
+   * [2] id1 is reused for a different key2 ... the index is not stored to disk ... [3] A file for
+   * key2 is partially written using a path corresponding to id1 ... the process is killed before
+   * the index is stored to disk ... [4] The index is read from disk, causing the partially written
+   * file to be incorrectly associated to key1
+   *
+   * <p>By avoiding id reuse in step [2], a new id2 will be used instead. Step [4] will then delete
+   * the partially written file because the index does not contain an entry for id2.
+   *
+   * <p>When the index is next stored (id -> null) entries are removed, making the ids eligible for
+   * reuse.
+   */
+  private final SparseArray<@NullableType String> idToKey;
+  /**
+   * Tracks ids for which (id -> null) entries are present in idToKey, so that they can be removed
+   * efficiently when the index is next stored.
+   */
+  private final SparseBooleanArray removedIds;
+
   private final AtomicFile atomicFile;
   private final Cipher cipher;
   private final SecretKeySpec secretKeySpec;
@@ -104,6 +129,7 @@ public CachedContentIndex(File cacheDir, byte[] secretKey, boolean encrypt) {
     }
     keyToContent = new HashMap<>();
     idToKey = new SparseArray<>();
+    removedIds = new SparseBooleanArray();
     atomicFile = new AtomicFile(new File(cacheDir, FILE_NAME));
   }
 
@@ -124,6 +150,12 @@ public void store() throws CacheException {
     }
     writeFile();
     changed = false;
+    // Make ids that were removed since the index was last stored eligible for re-use.
+    int removedIdCount = removedIds.size();
+    for (int i = 0; i < removedIdCount; i++) {
+      idToKey.remove(removedIds.keyAt(i));
+    }
+    removedIds.clear();
   }
 
   /**
@@ -168,8 +200,11 @@ public void maybeRemove(String key) {
     CachedContent cachedContent = keyToContent.get(key);
     if (cachedContent != null && cachedContent.isEmpty() && !cachedContent.isLocked()) {
       keyToContent.remove(key);
-      idToKey.remove(cachedContent.id);
       changed = true;
+      // Keep an entry in idToKey to stop the id from being reused until the index is next stored.
+      idToKey.put(cachedContent.id, /* value= */ null);
+      // Track that the entry should be removed from idToKey when the index is next stored.
+      removedIds.put(cachedContent.id, /* value= */ true);
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
index ca2983c891..ab60be2b4b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
@@ -146,13 +146,16 @@ public void run() {
   }
 
   @Override
-  public synchronized void release() throws CacheException {
+  public synchronized void release() {
     if (released) {
       return;
     }
     listeners.clear();
+    removeStaleSpans();
     try {
-      removeStaleSpansAndCachedContents();
+      index.store();
+    } catch (CacheException e) {
+      Log.e(TAG, "Storing index file failed", e);
     } finally {
       unlockFolder(cacheDir);
       released = true;
@@ -265,7 +268,7 @@ public synchronized File startFile(String key, long position, long maxLength)
     if (!cacheDir.exists()) {
       // For some reason the cache directory doesn't exist. Make a best effort to create it.
       cacheDir.mkdirs();
-      removeStaleSpansAndCachedContents();
+      removeStaleSpans();
     }
     evictor.onStartFile(this, key, position, maxLength);
     return SimpleCacheSpan.getCacheFile(
@@ -311,9 +314,9 @@ public synchronized void releaseHoleSpan(CacheSpan holeSpan) {
   }
 
   @Override
-  public synchronized void removeSpan(CacheSpan span) throws CacheException {
+  public synchronized void removeSpan(CacheSpan span) {
     Assertions.checkState(!released);
-    removeSpan(span, true);
+    removeSpanInternal(span);
   }
 
   @Override
@@ -379,7 +382,7 @@ private SimpleCacheSpan getSpan(String key, long position) throws CacheException
       if (span.isCached && !span.file.exists()) {
         // The file has been deleted from under us. It's likely that other files will have been
         // deleted too, so scan the whole in-memory representation.
-        removeStaleSpansAndCachedContents();
+        removeStaleSpans();
         continue;
       }
       return span;
@@ -431,27 +434,21 @@ private void addSpan(SimpleCacheSpan span) {
     notifySpanAdded(span);
   }
 
-  private void removeSpan(CacheSpan span, boolean removeEmptyCachedContent) throws CacheException {
+  private void removeSpanInternal(CacheSpan span) {
     CachedContent cachedContent = index.get(span.key);
     if (cachedContent == null || !cachedContent.removeSpan(span)) {
       return;
     }
     totalSpace -= span.length;
-    try {
-      if (removeEmptyCachedContent) {
-        index.maybeRemove(cachedContent.key);
-        index.store();
-      }
-    } finally {
-      notifySpanRemoved(span);
-    }
+    index.maybeRemove(cachedContent.key);
+    notifySpanRemoved(span);
   }
 
   /**
    * Scans all of the cached spans in the in-memory representation, removing any for which files no
    * longer exist.
    */
-  private void removeStaleSpansAndCachedContents() throws CacheException {
+  private void removeStaleSpans() {
     ArrayList<CacheSpan> spansToBeRemoved = new ArrayList<>();
     for (CachedContent cachedContent : index.getAll()) {
       for (CacheSpan span : cachedContent.getSpans()) {
@@ -461,11 +458,8 @@ private void removeStaleSpansAndCachedContents() throws CacheException {
       }
     }
     for (int i = 0; i < spansToBeRemoved.size(); i++) {
-      // Remove span but not CachedContent to prevent multiple index.store() calls.
-      removeSpan(spansToBeRemoved.get(i), false);
+      removeSpanInternal(spansToBeRemoved.get(i));
     }
-    index.removeEmpty();
-    index.store();
   }
 
   private void notifySpanRemoved(CacheSpan span) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/AtomicFile.java b/library/core/src/main/java/com/google/android/exoplayer2/util/AtomicFile.java
index 4bdee5ceea..2466d5a049 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/AtomicFile.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/AtomicFile.java
@@ -29,7 +29,7 @@
  * has successfully completed.
  *
  * <p>Atomic file guarantees file integrity by ensuring that a file has been completely written and
- * sync'd to disk before removing its backup. As long as the backup file exists, the original file
+ * synced to disk before removing its backup. As long as the backup file exists, the original file
  * is considered to be invalid (left over from a previous attempt to write the file).
  *
  * <p>Atomic file does not confer any file locking semantics. Do not use this class when the file
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java b/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
index eafb05226c..f7c045dbb0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
@@ -1436,11 +1436,12 @@ public static String getStringForTime(StringBuilder builder, Formatter formatter
   }
 
   /**
-   * Maps a {@link C} {@code TRACK_TYPE_*} constant to the corresponding {@link C}
-   * {@code DEFAULT_*_BUFFER_SIZE} constant.
+   * Maps a {@link C} {@code TRACK_TYPE_*} constant to the corresponding {@link C} {@code
+   * DEFAULT_*_BUFFER_SIZE} constant.
    *
    * @param trackType The track type.
    * @return The corresponding default buffer size in bytes.
+   * @throws IllegalArgumentException If the track type is an unrecognized or custom track type.
    */
   public static int getDefaultBufferSize(int trackType) {
     switch (trackType) {
@@ -1456,8 +1457,10 @@ public static int getDefaultBufferSize(int trackType) {
         return C.DEFAULT_METADATA_BUFFER_SIZE;
       case C.TRACK_TYPE_CAMERA_MOTION:
         return C.DEFAULT_CAMERA_MOTION_BUFFER_SIZE;
+      case C.TRACK_TYPE_NONE:
+        return 0;
       default:
-        throw new IllegalStateException();
+        throw new IllegalArgumentException();
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index 79adc87509..388aa29ce9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -98,7 +98,7 @@
   private final EventDispatcher eventDispatcher;
   private final long allowedJoiningTimeMs;
   private final int maxDroppedFramesToNotify;
-  private final boolean deviceNeedsAutoFrcWorkaround;
+  private final boolean deviceNeedsNoPostProcessWorkaround;
   private final long[] pendingOutputStreamOffsetsUs;
   private final long[] pendingOutputStreamSwitchTimesUs;
 
@@ -226,7 +226,7 @@ public MediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSel
     this.context = context.getApplicationContext();
     frameReleaseTimeHelper = new VideoFrameReleaseTimeHelper(this.context);
     eventDispatcher = new EventDispatcher(eventHandler, eventListener);
-    deviceNeedsAutoFrcWorkaround = deviceNeedsAutoFrcWorkaround();
+    deviceNeedsNoPostProcessWorkaround = deviceNeedsNoPostProcessWorkaround();
     pendingOutputStreamOffsetsUs = new long[MAX_PENDING_OUTPUT_STREAM_OFFSET_COUNT];
     pendingOutputStreamSwitchTimesUs = new long[MAX_PENDING_OUTPUT_STREAM_OFFSET_COUNT];
     outputStreamOffsetUs = C.TIME_UNSET;
@@ -471,7 +471,7 @@ protected void configureCodec(
             format,
             codecMaxValues,
             codecOperatingRate,
-            deviceNeedsAutoFrcWorkaround,
+            deviceNeedsNoPostProcessWorkaround,
             tunnelingAudioSessionId);
     if (surface == null) {
       Assertions.checkState(shouldUseDummySurface(codecInfo));
@@ -1027,8 +1027,8 @@ private static void configureTunnelingV21(MediaFormat mediaFormat, int tunneling
    * @param codecMaxValues Codec max values that should be used when configuring the decoder.
    * @param codecOperatingRate The codec operating rate, or {@link #CODEC_OPERATING_RATE_UNSET} if
    *     no codec operating rate should be set.
-   * @param deviceNeedsAutoFrcWorkaround Whether the device is known to enable frame-rate conversion
-   *     logic that negatively impacts ExoPlayer.
+   * @param deviceNeedsNoPostProcessWorkaround Whether the device is known to do post processing by
+   *     default that isn't compatible with ExoPlayer.
    * @param tunnelingAudioSessionId The audio session id to use for tunneling, or {@link
    *     C#AUDIO_SESSION_ID_UNSET} if tunneling should not be enabled.
    * @return The framework {@link MediaFormat} that should be used to configure the decoder.
@@ -1038,7 +1038,7 @@ protected MediaFormat getMediaFormat(
       Format format,
       CodecMaxValues codecMaxValues,
       float codecOperatingRate,
-      boolean deviceNeedsAutoFrcWorkaround,
+      boolean deviceNeedsNoPostProcessWorkaround,
       int tunnelingAudioSessionId) {
     MediaFormat mediaFormat = new MediaFormat();
     // Set format parameters that should always be set.
@@ -1062,7 +1062,8 @@ protected MediaFormat getMediaFormat(
         mediaFormat.setFloat(MediaFormat.KEY_OPERATING_RATE, codecOperatingRate);
       }
     }
-    if (deviceNeedsAutoFrcWorkaround) {
+    if (deviceNeedsNoPostProcessWorkaround) {
+      mediaFormat.setInteger("no-post-process", 1);
       mediaFormat.setInteger("auto-frc", 0);
     }
     if (tunnelingAudioSessionId != C.AUDIO_SESSION_ID_UNSET) {
@@ -1086,6 +1087,10 @@ protected CodecMaxValues getCodecMaxValues(
       throws DecoderQueryException {
     int maxWidth = format.width;
     int maxHeight = format.height;
+    if (codecNeedsMaxVideoSizeResetWorkaround(codecInfo.name)) {
+      maxWidth = Math.max(maxWidth, 1920);
+      maxHeight = Math.max(maxHeight, 1089);
+    }
     int maxInputSize = getMaxInputSize(codecInfo, format);
     if (streamFormats.length == 1) {
       // The single entry in streamFormats must correspond to the format for which the codec is
@@ -1256,21 +1261,33 @@ private static int getCodecMaxInputSize(
   }
 
   /**
-   * Returns whether the device is known to enable frame-rate conversion logic that negatively
-   * impacts ExoPlayer.
-   * <p>
-   * If true is returned then we explicitly disable the feature.
+   * Returns whether the device is known to do post processing by default that isn't compatible with
+   * ExoPlayer.
    *
-   * @return True if the device is known to enable frame-rate conversion logic that negatively
-   *     impacts ExoPlayer. False otherwise.
+   * @return Whether the device is known to do post processing by default that isn't compatible with
+   *     ExoPlayer.
    */
-  private static boolean deviceNeedsAutoFrcWorkaround() {
-    // nVidia Shield prior to M tries to adjust the playback rate to better map the frame-rate of
+  private static boolean deviceNeedsNoPostProcessWorkaround() {
+    // Nvidia devices prior to M try to adjust the playback rate to better map the frame-rate of
     // content to the refresh rate of the display. For example playback of 23.976fps content is
     // adjusted to play at 1.001x speed when the output display is 60Hz. Unfortunately the
     // implementation causes ExoPlayer's reported playback position to drift out of sync. Captions
-    // also lose sync [Internal: b/26453592].
-    return Util.SDK_INT <= 22 && "foster".equals(Util.DEVICE) && "NVIDIA".equals(Util.MANUFACTURER);
+    // also lose sync [Internal: b/26453592]. Even after M, the devices may apply post processing
+    // operations that can modify frame output timestamps, which is incompatible with ExoPlayer's
+    // logic for skipping decode-only frames.
+    return "NVIDIA".equals(Util.MANUFACTURER);
+  }
+
+  /**
+   * Returns whether the codec is known to have problems with the configuration for interlaced
+   * content and needs minimum values for the maximum video size to force reset the configuration.
+   *
+   * <p>See https://github.com/google/ExoPlayer/issues/5003.
+   *
+   * @param name The name of the codec.
+   */
+  private static boolean codecNeedsMaxVideoSizeResetWorkaround(String name) {
+    return "OMX.amlogic.avc.decoder.awesome".equals(name) && Util.SDK_INT <= 25;
   }
 
   /*
@@ -1296,163 +1313,173 @@ private static boolean deviceNeedsAutoFrcWorkaround() {
    *     incorrectly.
    */
   protected boolean codecNeedsSetOutputSurfaceWorkaround(String name) {
-    if (Util.SDK_INT >= 27 || name.startsWith("OMX.google")) {
-      // Devices running API level 27 or later should also be unaffected. Google OMX decoders are
-      // not known to have this issue on any API level.
+    if (name.startsWith("OMX.google")) {
+      // Google OMX decoders are not known to have this issue on any API level.
       return false;
     }
-    // Work around:
-    // https://github.com/google/ExoPlayer/issues/3236,
-    // https://github.com/google/ExoPlayer/issues/3355,
-    // https://github.com/google/ExoPlayer/issues/3439,
-    // https://github.com/google/ExoPlayer/issues/3724,
-    // https://github.com/google/ExoPlayer/issues/3835,
-    // https://github.com/google/ExoPlayer/issues/4006,
-    // https://github.com/google/ExoPlayer/issues/4084,
-    // https://github.com/google/ExoPlayer/issues/4104,
-    // https://github.com/google/ExoPlayer/issues/4134,
-    // https://github.com/google/ExoPlayer/issues/4315,
-    // https://github.com/google/ExoPlayer/issues/4419,
-    // https://github.com/google/ExoPlayer/issues/4460,
-    // https://github.com/google/ExoPlayer/issues/4468.
     synchronized (MediaCodecVideoRenderer.class) {
       if (!evaluatedDeviceNeedsSetOutputSurfaceWorkaround) {
-        switch (Util.DEVICE) {
-          case "1601":
-          case "1713":
-          case "1714":
-          case "A10-70F":
-          case "A1601":
-          case "A2016a40":
-          case "A7000-a":
-          case "A7000plus":
-          case "A7010a48":
-          case "A7020a48":
-          case "AquaPowerM":
-          case "ASUS_X00AD_2":
-          case "Aura_Note_2":
-          case "BLACK-1X":
-          case "BRAVIA_ATV2":
-          case "C1":
-          case "ComioS1":
-          case "CP8676_I02":
-          case "CPH1609":
-          case "CPY83_I00":
-          case "cv1":
-          case "cv3":
-          case "deb":
-          case "E5643":
-          case "ELUGA_A3_Pro":
-          case "ELUGA_Note":
-          case "ELUGA_Prim":
-          case "ELUGA_Ray_X":
-          case "EverStar_S":
-          case "F3111":
-          case "F3113":
-          case "F3116":
-          case "F3211":
-          case "F3213":
-          case "F3215":
-          case "F3311":
-          case "flo":
-          case "GiONEE_CBL7513":
-          case "GiONEE_GBL7319":
-          case "GIONEE_GBL7360":
-          case "GIONEE_SWW1609":
-          case "GIONEE_SWW1627":
-          case "GIONEE_SWW1631":
-          case "GIONEE_WBL5708":
-          case "GIONEE_WBL7365":
-          case "GIONEE_WBL7519":
-          case "griffin":
-          case "htc_e56ml_dtul":
-          case "hwALE-H":
-          case "HWBLN-H":
-          case "HWCAM-H":
-          case "HWVNS-H":
-          case "i9031":
-          case "iball8735_9806":
-          case "Infinix-X572":
-          case "iris60":
-          case "itel_S41":
-          case "j2xlteins":
-          case "JGZ":
-          case "K50a40":
-          case "kate":
-          case "le_x6":
-          case "LS-5017":
-          case "M5c":
-          case "manning":
-          case "marino_f":
-          case "MEIZU_M5":
-          case "mh":
-          case "mido":
-          case "MX6":
-          case "namath":
-          case "nicklaus_f":
-          case "NX541J":
-          case "NX573J":
-          case "OnePlus5T":
-          case "p212":
-          case "P681":
-          case "P85":
-          case "panell_d":
-          case "panell_dl":
-          case "panell_ds":
-          case "panell_dt":
-          case "PB2-670M":
-          case "PGN528":
-          case "PGN610":
-          case "PGN611":
-          case "Phantom6":
-          case "Pixi4-7_3G":
-          case "Pixi5-10_4G":
-          case "PLE":
-          case "PRO7S":
-          case "Q350":
-          case "Q4260":
-          case "Q427":
-          case "Q4310":
-          case "Q5":
-          case "QM16XE_U":
-          case "QX1":
-          case "santoni":
-          case "Slate_Pro":
-          case "SVP-DTV15":
-          case "s905x018":
-          case "taido_row":
-          case "TB3-730F":
-          case "TB3-730X":
-          case "TB3-850F":
-          case "TB3-850M":
-          case "tcl_eu":
-          case "V1":
-          case "V23GB":
-          case "V5":
-          case "vernee_M5":
-          case "watson":
-          case "whyred":
-          case "woods_f":
-          case "woods_fn":
-          case "X3_HK":
-          case "XE2X":
-          case "XT1663":
-          case "Z12_PRO":
-          case "Z80":
-            deviceNeedsSetOutputSurfaceWorkaround = true;
-            break;
-          default:
-            // Do nothing.
-            break;
-        }
-        switch (Util.MODEL) {
-          case "AFTA":
-          case "AFTN":
-            deviceNeedsSetOutputSurfaceWorkaround = true;
-            break;
-          default:
-            // Do nothing.
-            break;
+        if (Util.SDK_INT <= 27 && "dangal".equals(Util.DEVICE)) {
+          // Dangal is affected on API level 27: https://github.com/google/ExoPlayer/issues/5169.
+          deviceNeedsSetOutputSurfaceWorkaround = true;
+        } else if (Util.SDK_INT >= 27) {
+          // In general, devices running API level 27 or later should be unaffected. Do nothing.
+        } else {
+          // Enable the workaround on a per-device basis. Works around:
+          // https://github.com/google/ExoPlayer/issues/3236,
+          // https://github.com/google/ExoPlayer/issues/3355,
+          // https://github.com/google/ExoPlayer/issues/3439,
+          // https://github.com/google/ExoPlayer/issues/3724,
+          // https://github.com/google/ExoPlayer/issues/3835,
+          // https://github.com/google/ExoPlayer/issues/4006,
+          // https://github.com/google/ExoPlayer/issues/4084,
+          // https://github.com/google/ExoPlayer/issues/4104,
+          // https://github.com/google/ExoPlayer/issues/4134,
+          // https://github.com/google/ExoPlayer/issues/4315,
+          // https://github.com/google/ExoPlayer/issues/4419,
+          // https://github.com/google/ExoPlayer/issues/4460,
+          // https://github.com/google/ExoPlayer/issues/4468,
+          // https://github.com/google/ExoPlayer/issues/5312.
+          switch (Util.DEVICE) {
+            case "1601":
+            case "1713":
+            case "1714":
+            case "A10-70F":
+            case "A1601":
+            case "A2016a40":
+            case "A7000-a":
+            case "A7000plus":
+            case "A7010a48":
+            case "A7020a48":
+            case "AquaPowerM":
+            case "ASUS_X00AD_2":
+            case "Aura_Note_2":
+            case "BLACK-1X":
+            case "BRAVIA_ATV2":
+            case "BRAVIA_ATV3_4K":
+            case "C1":
+            case "ComioS1":
+            case "CP8676_I02":
+            case "CPH1609":
+            case "CPY83_I00":
+            case "cv1":
+            case "cv3":
+            case "deb":
+            case "E5643":
+            case "ELUGA_A3_Pro":
+            case "ELUGA_Note":
+            case "ELUGA_Prim":
+            case "ELUGA_Ray_X":
+            case "EverStar_S":
+            case "F3111":
+            case "F3113":
+            case "F3116":
+            case "F3211":
+            case "F3213":
+            case "F3215":
+            case "F3311":
+            case "flo":
+            case "fugu":
+            case "GiONEE_CBL7513":
+            case "GiONEE_GBL7319":
+            case "GIONEE_GBL7360":
+            case "GIONEE_SWW1609":
+            case "GIONEE_SWW1627":
+            case "GIONEE_SWW1631":
+            case "GIONEE_WBL5708":
+            case "GIONEE_WBL7365":
+            case "GIONEE_WBL7519":
+            case "griffin":
+            case "htc_e56ml_dtul":
+            case "hwALE-H":
+            case "HWBLN-H":
+            case "HWCAM-H":
+            case "HWVNS-H":
+            case "HWWAS-H":
+            case "i9031":
+            case "iball8735_9806":
+            case "Infinix-X572":
+            case "iris60":
+            case "itel_S41":
+            case "j2xlteins":
+            case "JGZ":
+            case "K50a40":
+            case "kate":
+            case "le_x6":
+            case "LS-5017":
+            case "M5c":
+            case "manning":
+            case "marino_f":
+            case "MEIZU_M5":
+            case "mh":
+            case "mido":
+            case "MX6":
+            case "namath":
+            case "nicklaus_f":
+            case "NX541J":
+            case "NX573J":
+            case "OnePlus5T":
+            case "p212":
+            case "P681":
+            case "P85":
+            case "panell_d":
+            case "panell_dl":
+            case "panell_ds":
+            case "panell_dt":
+            case "PB2-670M":
+            case "PGN528":
+            case "PGN610":
+            case "PGN611":
+            case "Phantom6":
+            case "Pixi4-7_3G":
+            case "Pixi5-10_4G":
+            case "PLE":
+            case "PRO7S":
+            case "Q350":
+            case "Q4260":
+            case "Q427":
+            case "Q4310":
+            case "Q5":
+            case "QM16XE_U":
+            case "QX1":
+            case "santoni":
+            case "Slate_Pro":
+            case "SVP-DTV15":
+            case "s905x018":
+            case "taido_row":
+            case "TB3-730F":
+            case "TB3-730X":
+            case "TB3-850F":
+            case "TB3-850M":
+            case "tcl_eu":
+            case "V1":
+            case "V23GB":
+            case "V5":
+            case "vernee_M5":
+            case "watson":
+            case "whyred":
+            case "woods_f":
+            case "woods_fn":
+            case "X3_HK":
+            case "XE2X":
+            case "XT1663":
+            case "Z12_PRO":
+            case "Z80":
+              deviceNeedsSetOutputSurfaceWorkaround = true;
+              break;
+            default:
+              // Do nothing.
+              break;
+          }
+          switch (Util.MODEL) {
+            case "AFTA":
+            case "AFTN":
+              deviceNeedsSetOutputSurfaceWorkaround = true;
+              break;
+            default:
+              // Do nothing.
+              break;
+          }
         }
         evaluatedDeviceNeedsSetOutputSurfaceWorkaround = true;
       }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoRendererEventListener.java b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoRendererEventListener.java
index 617211afb7..7d78ba03c7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoRendererEventListener.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoRendererEventListener.java
@@ -26,7 +26,8 @@
 import com.google.android.exoplayer2.util.Assertions;
 
 /**
- * Listener of video {@link Renderer} events.
+ * Listener of video {@link Renderer} events. All methods have no-op default implementations to
+ * allow selective overrides.
  */
 public interface VideoRendererEventListener {
 
@@ -36,7 +37,7 @@
    * @param counters {@link DecoderCounters} that will be updated by the renderer for as long as it
    *     remains enabled.
    */
-  void onVideoEnabled(DecoderCounters counters);
+  default void onVideoEnabled(DecoderCounters counters) {}
 
   /**
    * Called when a decoder is created.
@@ -46,15 +47,15 @@
    *     finished.
    * @param initializationDurationMs The time taken to initialize the decoder in milliseconds.
    */
-  void onVideoDecoderInitialized(String decoderName, long initializedTimestampMs,
-      long initializationDurationMs);
+  default void onVideoDecoderInitialized(
+      String decoderName, long initializedTimestampMs, long initializationDurationMs) {}
 
   /**
    * Called when the format of the media being consumed by the renderer changes.
    *
    * @param format The new format.
    */
-  void onVideoInputFormatChanged(Format format);
+  default void onVideoInputFormatChanged(Format format) {}
 
   /**
    * Called to report the number of frames dropped by the renderer. Dropped frames are reported
@@ -62,12 +63,11 @@ void onVideoDecoderInitialized(String decoderName, long initializedTimestampMs,
    * reaches a specified threshold whilst the renderer is started.
    *
    * @param count The number of dropped frames.
-   * @param elapsedMs The duration in milliseconds over which the frames were dropped. This
-   *     duration is timed from when the renderer was started or from when dropped frames were
-   *     last reported (whichever was more recent), and not from when the first of the reported
-   *     drops occurred.
+   * @param elapsedMs The duration in milliseconds over which the frames were dropped. This duration
+   *     is timed from when the renderer was started or from when dropped frames were last reported
+   *     (whichever was more recent), and not from when the first of the reported drops occurred.
    */
-  void onDroppedFrames(int count, long elapsedMs);
+  default void onDroppedFrames(int count, long elapsedMs) {}
 
   /**
    * Called before a frame is rendered for the first time since setting the surface, and each time
@@ -82,12 +82,12 @@ void onVideoDecoderInitialized(String decoderName, long initializedTimestampMs,
    *     this is not possible. Applications that use {@link TextureView} can apply the rotation by
    *     calling {@link TextureView#setTransform}. Applications that do not expect to encounter
    *     rotated videos can safely ignore this parameter.
-   * @param pixelWidthHeightRatio The width to height ratio of each pixel. For the normal case
-   *     of square pixels this will be equal to 1.0. Different values are indicative of anamorphic
+   * @param pixelWidthHeightRatio The width to height ratio of each pixel. For the normal case of
+   *     square pixels this will be equal to 1.0. Different values are indicative of anamorphic
    *     content.
    */
-  void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
-      float pixelWidthHeightRatio);
+  default void onVideoSizeChanged(
+      int width, int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {}
 
   /**
    * Called when a frame is rendered for the first time since setting the surface, and when a frame
@@ -96,14 +96,14 @@ void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
    * @param surface The {@link Surface} to which a first frame has been rendered, or {@code null} if
    *     the renderer renders to something that isn't a {@link Surface}.
    */
-  void onRenderedFirstFrame(@Nullable Surface surface);
+  default void onRenderedFirstFrame(@Nullable Surface surface) {}
 
   /**
    * Called when the renderer is disabled.
    *
    * @param counters {@link DecoderCounters} that were updated by the renderer.
    */
-  void onVideoDisabled(DecoderCounters counters);
+  default void onVideoDisabled(DecoderCounters counters) {}
 
   /**
    * Dispatches events to a {@link VideoRendererEventListener}.
diff --git a/library/core/src/test/assets/mp3/play-trimmed.mp3.0.dump b/library/core/src/test/assets/mp3/play-trimmed.mp3.0.dump
index 96b0cd259c..d4df3ffeba 100644
--- a/library/core/src/test/assets/mp3/play-trimmed.mp3.0.dump
+++ b/library/core/src/test/assets/mp3/play-trimmed.mp3.0.dump
@@ -1,6 +1,6 @@
 seekMap:
   isSeekable = true
-  duration = 26125
+  duration = 26122
   getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
diff --git a/library/core/src/test/assets/mp3/play-trimmed.mp3.1.dump b/library/core/src/test/assets/mp3/play-trimmed.mp3.1.dump
index 96b0cd259c..d4df3ffeba 100644
--- a/library/core/src/test/assets/mp3/play-trimmed.mp3.1.dump
+++ b/library/core/src/test/assets/mp3/play-trimmed.mp3.1.dump
@@ -1,6 +1,6 @@
 seekMap:
   isSeekable = true
-  duration = 26125
+  duration = 26122
   getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
diff --git a/library/core/src/test/assets/mp3/play-trimmed.mp3.2.dump b/library/core/src/test/assets/mp3/play-trimmed.mp3.2.dump
index 96b0cd259c..d4df3ffeba 100644
--- a/library/core/src/test/assets/mp3/play-trimmed.mp3.2.dump
+++ b/library/core/src/test/assets/mp3/play-trimmed.mp3.2.dump
@@ -1,6 +1,6 @@
 seekMap:
   isSeekable = true
-  duration = 26125
+  duration = 26122
   getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
diff --git a/library/core/src/test/assets/mp3/play-trimmed.mp3.3.dump b/library/core/src/test/assets/mp3/play-trimmed.mp3.3.dump
index 96b0cd259c..d4df3ffeba 100644
--- a/library/core/src/test/assets/mp3/play-trimmed.mp3.3.dump
+++ b/library/core/src/test/assets/mp3/play-trimmed.mp3.3.dump
@@ -1,6 +1,6 @@
 seekMap:
   isSeekable = true
-  duration = 26125
+  duration = 26122
   getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
diff --git a/library/core/src/test/assets/mp4/sample.mp4.0.dump b/library/core/src/test/assets/mp4/sample.mp4.0.dump
index efc804d48b..b05d8250ab 100644
--- a/library/core/src/test/assets/mp4/sample.mp4.0.dump
+++ b/library/core/src/test/assets/mp4/sample.mp4.0.dump
@@ -147,7 +147,7 @@ track 0:
     data = length 530, hash C98BC6A8
   sample 29:
     time = 934266
-    flags = 0
+    flags = 536870912
     data = length 568, hash 4FE5C8EA
 track 1:
   format:
@@ -352,6 +352,6 @@ track 1:
     data = length 229, hash FFF98DF0
   sample 44:
     time = 1065678
-    flags = 1
+    flags = 536870913
     data = length 6, hash 31B22286
 tracksEnded = true
diff --git a/library/core/src/test/assets/mp4/sample.mp4.1.dump b/library/core/src/test/assets/mp4/sample.mp4.1.dump
index 10104b5e81..84d86f8ccf 100644
--- a/library/core/src/test/assets/mp4/sample.mp4.1.dump
+++ b/library/core/src/test/assets/mp4/sample.mp4.1.dump
@@ -147,7 +147,7 @@ track 0:
     data = length 530, hash C98BC6A8
   sample 29:
     time = 934266
-    flags = 0
+    flags = 536870912
     data = length 568, hash 4FE5C8EA
 track 1:
   format:
@@ -304,6 +304,6 @@ track 1:
     data = length 229, hash FFF98DF0
   sample 32:
     time = 1065678
-    flags = 1
+    flags = 536870913
     data = length 6, hash 31B22286
 tracksEnded = true
diff --git a/library/core/src/test/assets/mp4/sample.mp4.2.dump b/library/core/src/test/assets/mp4/sample.mp4.2.dump
index 8af96be673..9bbe8caa01 100644
--- a/library/core/src/test/assets/mp4/sample.mp4.2.dump
+++ b/library/core/src/test/assets/mp4/sample.mp4.2.dump
@@ -147,7 +147,7 @@ track 0:
     data = length 530, hash C98BC6A8
   sample 29:
     time = 934266
-    flags = 0
+    flags = 536870912
     data = length 568, hash 4FE5C8EA
 track 1:
   format:
@@ -244,6 +244,6 @@ track 1:
     data = length 229, hash FFF98DF0
   sample 17:
     time = 1065678
-    flags = 1
+    flags = 536870913
     data = length 6, hash 31B22286
 tracksEnded = true
diff --git a/library/core/src/test/assets/mp4/sample.mp4.3.dump b/library/core/src/test/assets/mp4/sample.mp4.3.dump
index f1259661ed..f210f277b3 100644
--- a/library/core/src/test/assets/mp4/sample.mp4.3.dump
+++ b/library/core/src/test/assets/mp4/sample.mp4.3.dump
@@ -147,7 +147,7 @@ track 0:
     data = length 530, hash C98BC6A8
   sample 29:
     time = 934266
-    flags = 0
+    flags = 536870912
     data = length 568, hash 4FE5C8EA
 track 1:
   format:
@@ -184,6 +184,6 @@ track 1:
     data = length 229, hash FFF98DF0
   sample 2:
     time = 1065678
-    flags = 1
+    flags = 536870913
     data = length 6, hash 31B22286
 tracksEnded = true
diff --git a/library/core/src/test/assets/ttml/bitmap_percentage_region.xml b/library/core/src/test/assets/ttml/bitmap_percentage_region.xml
new file mode 100644
index 0000000000..9631650178
--- /dev/null
+++ b/library/core/src/test/assets/ttml/bitmap_percentage_region.xml
@@ -0,0 +1,26 @@
+<tt xmlns="http://www.w3.org/ns/ttml" xmlns:ttm="http://www.w3.org/ns/ttml#metadata" xmlns:tts="http://www.w3.org/ns/ttml#styling" xmlns:smpte="http://www.smpte-ra.org/schemas/2052-1/2010/smpte-tt" xml:lang="eng">
+    <head>
+        <metadata>
+            <smpte:image imagetype="PNG" encoding="Base64" xml:id="img_0">
+                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
+            </smpte:image>
+            <smpte:image imagetype="PNG" encoding="Base64" xml:id="img_1">
+                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
+            </smpte:image>
+        </metadata>
+        <styling>
+            <style/>
+        </styling>
+        <layout>
+            <region xml:id="region_0" tts:extent="51% 12%" tts:origin="24% 78%"/>
+            <region xml:id="region_1" tts:extent="57% 6%" tts:origin="21% 85%"/>
+            <region xml:id="region_2" tts:extent="51% 12%" tts:origin="24% 28%"/>
+            <region xml:id="region_3" tts:extent="57% 6%" tts:origin="21% 35%"/>
+        </layout>
+    </head>
+    <body>
+        <div begin="00:00:00.200" end="00:00:03.000" region="region_2" smpte:backgroundImage="#img_0"/>
+        <div begin="00:00:03.200" end="00:00:06.937" region="region_3" smpte:backgroundImage="#img_1"/>
+        <div begin="00:00:07.200" end="00:59:03.000" region="region_2" smpte:backgroundImage="#img_0"/>
+    </body>
+</tt>
diff --git a/library/core/src/test/assets/ttml/bitmap_pixel_region.xml b/library/core/src/test/assets/ttml/bitmap_pixel_region.xml
new file mode 100644
index 0000000000..c724c46626
--- /dev/null
+++ b/library/core/src/test/assets/ttml/bitmap_pixel_region.xml
@@ -0,0 +1,23 @@
+<tt xmlns="http://www.w3.org/ns/ttml" xmlns:ttm="http://www.w3.org/ns/ttml#metadata" xmlns:tts="http://www.w3.org/ns/ttml#styling" xmlns:smpte="http://www.smpte-ra.org/schemas/2052-1/2010/smpte-tt" xml:lang="eng" tts:extent="1280px 720px">
+    <head>
+        <metadata>
+            <smpte:image imagetype="PNG" encoding="Base64" xml:id="img_0">
+                iVBORw0KGgoAAAANSUhEUgAAAXAAAABICAYAAADvR65LAAAACXBIWXMAAAsTAAALEwEAmpwYAAANIUlEQVR4nO2d/5GjSA+GNVVfALMh4EyucAIXxDiGCWFiwKngukwghA1h74/vxMia/t3qNtjvU7W1u8Ygtbp53agFvL2/v/8hAAAAh+N/j3YAAABAGRBwAAA4KBBwAAA4KC8j4MMwEBHRuq4P9qQ/vdv+yrFOBTECFhxawFNPgnEc6Xw+ExHRPM90u92a+7YXerZ9HEc6nU50Op2IiGhZFprnGSKleOXxCGwxE/BxHLd/uwYkb1+WpeqE1iLBLMuy/XEdX54wRyEW01RCbbeyMQwDnc/nzRYRBfvjWUmN517Ho9V4eDTP0o4YJgLOJ+/pdHLOKMZxpMvlQkRE0zQVn9B8HC3eknmeq2zsBSmI8zw3EUJLG1K85Y/psiyWLu+aHn3WkqP7zzxLO1IwEXB92ezbzsEsQYu3Fge2wX+etcNKaC2iwzDc9cs0TU896wFgL5gKuEug9cldIqxyhk/0c5bNNng7xOMbGYuWcZF9jPgD0IdqAY8JdGx2nkJsYWxdV1rXFcLhoXVcQiktAEA7igScqz+I6MeCotwmt7N4l5ZP+VIntZT4k7NP7Luu7fqKQsc4N3Ytbej+1p9pm67PYrYs4l3SDzlYx7PVeAwdI8f/Hn1Zsm9tP9SOtdz21WYosgVclkAR3QdIpjnkdv77crls4ltaPlU72/N1bKzkTadxUvaRsXItrLrKyfgzPQhLY9fShus4cmzIdms/2Cbvp+NTG2+XDT4Gp3lcNlLbHotDajx7jkcr/3v0Zcm+pf1gNdb02A+NI+mrhO2mjr9sAT+dTj8cldtCAqtn4yVwh5T+ALDvLj9Pp5NTaIdhoMvl4my3r/KGbZ3PZ1qWxbuw6ion89kpzTO3suEbC7IaRbbb98Ovv1cab2lDnsCaZVl+nOjaBlFe6qk0nj3Ho6X/PfqyZN/cdliNtZxxFKqmy52NZws4/0IwoXpWKdhStHMFiG2yLT75SsqE2B9XG/h4evYgO1jvJ39FLXLNXMWhxVHarU0hWdmQcdQlhPrfEletuEyxWcQ71M/yhJPb+XP+k9qfNfFsMR7ZXuo5UeN/bV/6fC3ZN7cd1mONjy3HEJdP8/5sU44/uV8u2QJ+u902Zz4+PojIPe2XjnJgS3N067rSPM/O3JYMXsol2TzPd6I/DAMty7IFWp+4crDI6he5Hw8YCwFf15Wu1+uWS+OT2LK23coGjwV5c1VKX8v+4v/LWbpFvGP9zPblmJEzo9PplJTTJaqLp+V4lNuXZaHr9Rr1vdb/0r6M+Vqyb247rMeaFmk50eRtevLgSjdxW1KoqkKJXR5KR2vFh4/vynHJf8cuH7Wv67pug1BfCukFBtkO/lGR/ozjiEoYig8+LZyMZbxj/ewSDbm9FzXjUZ78epLjmr23ILUvc3zt0c7WY0366JsMuK48mi9iMjIAOemTGm632zawXTnMlEueHF907kzvyyebLwcG3Pgu7y3jbVmp1JKa8ejL70vhaC3gqX2Z42uPdrYea/pHWPooNYy/V9pPxQIuBVrDq7rsrCWy5lteusv8plU6g48nbWtk+3LypsAN4h2G48OTFR0PGb9Hx6fG1x7tbDnWfIKshf3r62ubAJfc9p8s4PohUvJvmUti5Hadd7SaFXAOVua82GavdIbuZNAWxPubI1351fj6qHa2GGvrutI0TbQsy12OnOg7Z9+kjNAl0nKbD520b4Er5wTAM5OSmtxLGqnG1yO1MxVebNV5dpkaJkqraksWcLnSHMofhbbV5HpS/Ou9AEV0/8t8tIF0RBDv/1Nb2dWTGl8f2c6asea6Q1nDQk70fWOPq3IlRLKAy/IcLq/hMhgJp0x4u5x1t+4Ea/HW+Sq9kiwXcvn7oBzEO8yjJikl1Pjao509xlpokVQjq+ykDzHNzFrElHWY7Jg2oJ22EG25KOrLoctLD6vKF70SfT6f70rPdHrIZ9M1EGWbYvSoKOhVtRDCKt57oEU8ZXxC5XMWz0ap9b/GV8t2+tphOdZ4kVXa0Hokt43jGNTOHIpupWeHXY3i7ZYnmMwNuWzLhQAim7pzeSxd6cK29fPJXXWejBbr0JoC0f2g1O2z+mHsYSOXmng/mh7xlPGRN8oxfJ7M85x8I08r/2t8rdk3tR1WY01mHLRNmXom+r5ZjO3IK4GSeBcLuEugLZ79HUM3kn1ipmkyXSzlSxvuJA5+ik3dOVz3mfpL63p8AH+ee3I+0kYONfHeA63j6YsP0f154EoL9Pa/xtfadqa0w3Ks+c5v12STv+9Dp55DFAl4LD1ilcJg5G2orudZsL1QmWLIH+mv63syP6UvjXx3ovF+8upB2tPPEPH5patrSuIaa3utjVj8UvyQlMY7xb6ln759U+LZajzGzoMe/lv5WrNvajtqxpq0JdMxof154it1TB8np+/e3t/f/yR98z94lu0TcIv8W4p9TWzGzy85DT35LNQul+3UqwzffvLzmF+S3Pr21LbX2EiJX8yPmF8p8a7t55R25Prt8qfFeCSyufK18D/lmKXnT+q+OeM6d6yN40hfX19E9D1Lzz2HdMaCKF83swUcAABeHSngn5+fD7vj1eSdmAAAAPoDAQcAgIMCAQcAgIMCAQcAgIMCAQcAgAL2cCcwBBwAADKRVSePfOY6yggBAOCgvP39B/od4p9fvxAgAB7EX79/vz3ahz2DFAoAABwUCDgAABwUCDgAABwUCPhOaP0QsBb08Hnvcdm7f6141XbvDQh4Q1IHOb8Pj4iy3kj9SHr4vPe47N2/Vrxqu/cIBNyYcRzvngvMyGcY+14JR0S7fVGBi5DP/LhRoro62UfFJdX/I/abBa/a7r0BATeEX5cUeuMOvwj6mS89+X2f/D7DPb7+LMTR/QevAwTcCC3erlcpyT+h92cehR4+HzEurwD6ZR9AwA3gGZt8756cZfObN3xv39nLbbk59PD5iHF5BdAv+wECboDrXXhyhr2uK63rGhzsRzwRevh8xLi8AuiXfQABN8KXOkklVLHi25ZbyuX6fk05mO948gdNL+jm2ukRF72vhf8lPliW5vn6JnRs3ifFh979AtxAwI0JLWD6CJVl6W1sw/WW+9DLhF37SH9zy8FcPvNnWgAvl8tmL8dO67j47JX47xP8mA86/Vbit68d7K/2Sy+iy+9LH5Zlcba1d78APxBwY/iEzxXEUFkWb5Mi4bLrqm5JqYzx2S3xWQsB+yavUPYQl5g9fYyY/9qXFB+GYaDL5eK1WVNjLY+p/ZeL6LLiRsM/WqH29uoX4AYCbgDPKHjg8ozKugztdDptthhpU89q9OxOpndcteq1LMtC0zRtbWekvy2qF3Lj4qPG/5K+keKt9+PPa8eObIe8F0GjhViO4VIfrPoF+IGAG7CuK83z7Myd8iC2uGyc5/nuB2EYBlqWhS6Xy2ZTzpakEPC+t9tty/P6Zl6lrOtK1+t1y3XySdp6ppUblxb+1/YN25C2WTyv12t+UP5Djj3+v15gn6Zp+zcR3flQ8yNv1S/ADwTcCB6Irhyq/HfNZbG+fF/XdTtB9YyaRZr3k3a5KsZ6Bv4ocuKyBx9038gfCD0ZqJ2psoiG9tfb2Hei7/FbYn8P/fLsQMANud1u2+DUQk50P6MpEfGc9INv0bL0eHtmD+0o7RseL67jhW78yvErp3ImlLcusQ3aAgE3RtZ8y+oPubBzPp+7XDpKkUCucV9w3/CPuuuuXfn/VuNFVyhZCjhoDwS8Ibfbbcs5E92vzo/jiPwfIKI2C8opyAol1wInRHz/QMA7oPOaODEAk3LjV4tUhBbvaZrurtQ+Pj62xUawXyDgnZCLNwAwehGzF/rGHn01iPz1MYCAd6S3eMsfjNht1KAfe/gxl+sj4LhAwA3gG2aIyFuy5buhphVSJHw3kvQQkNoqikfTwn8up4uVCbZ8doguE9QzcFwpHgMIuAG6bNC1GKTv7GstaLKWl4ju8p1E9TdpxGwzuu1HqIjp4b9cE9F9Q/TdP/M8V93I40Pbkp/pNoP9AgE3Rp/sRPezmWmaur2GikWCxYAfytRjduV6tAB/3kKQrGntP894WbzlA7N0CWGL9Jd8/EPIPtg3EHAD+GTU9d46ZRK6nT6UUolt4+36e/I2adet/UTuhzelEvNLV96UpI1axCXVbor/NT7Iu3ddKbaaxy/E2sxjY1mWH1eP8imCJcdv2S/gnre///x5tA+75p9fv7IC5Mstxy69+SW6vsd3+rZJmyEb8iW97M/5fN5KxT4/P7Pr0lP9kljasIhLiBT/LXxw2alN1cT8cn1X2ib6FvDc2Fv2y1+/f79F3H9pIOARcgX8SIzjSF9fX0RUJuAAtAYCHgYplBcGuU4Ajg0E/ImRl8b6clU/EQ8AcDwg4E+MrECRz2Ym+vnSAIg4AMcDAv7E6OdK88KRrpDBm1EAOCYQ8CeGH6JF9PNFE0Q/X/QAADgWqEKJ8AxVKJzv1nXgR7grErw2qEIJAwGP8AwCDsBRgYCH+RdHEwkWLXE/8gAAAABJRU5ErkJggg==
+            </smpte:image>
+            <smpte:image imagetype="PNG" encoding="Base64" xml:id="img_1">
+                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
+            </smpte:image>
+        </metadata>
+        <styling>
+            <style/>
+        </styling>
+        <layout>
+            <region xml:id="region_0" tts:extent="653px 86px" tts:origin="307px 562px"/>
+            <region xml:id="region_1" tts:extent="730px 43px" tts:origin="269px 612px"/>
+        </layout>
+    </head>
+    <body>
+        <div begin="00:00:00.200" end="00:00:03.000" region="region_0" smpte:backgroundImage="#img_0"/>
+        <div begin="00:00:03.200" end="00:00:06.937" region="region_1" smpte:backgroundImage="#img_1"/>
+    </body>
+</tt>
diff --git a/library/core/src/test/assets/ttml/bitmap_unsupported_region.xml b/library/core/src/test/assets/ttml/bitmap_unsupported_region.xml
new file mode 100644
index 0000000000..5e72d706fc
--- /dev/null
+++ b/library/core/src/test/assets/ttml/bitmap_unsupported_region.xml
@@ -0,0 +1,23 @@
+<tt xmlns="http://www.w3.org/ns/ttml" xmlns:ttm="http://www.w3.org/ns/ttml#metadata" xmlns:tts="http://www.w3.org/ns/ttml#styling" xmlns:smpte="http://www.smpte-ra.org/schemas/2052-1/2010/smpte-tt" xml:lang="eng">
+    <head>
+        <metadata>
+            <smpte:image imagetype="PNG" encoding="Base64" xml:id="img_0">
+                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
+            </smpte:image>
+            <smpte:image imagetype="PNG" encoding="Base64" xml:id="img_1">
+                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
+            </smpte:image>
+        </metadata>
+        <styling>
+            <style/>
+        </styling>
+        <layout>
+            <region xml:id="region_0" tts:extent="653px 86px" tts:origin="307px 562px"/>
+            <region xml:id="region_1" tts:extent="730px 43px" tts:origin="269px 612px"/>
+        </layout>
+    </head>
+    <body>
+        <div begin="00:00:00.200" end="00:00:03.000" region="region_0" smpte:backgroundImage="#img_0"/>
+        <div begin="00:00:03.200" end="00:00:06.937" region="region_1" smpte:backgroundImage="#img_1"/>
+    </body>
+</tt>
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/MdtaMetadataEntryTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/MdtaMetadataEntryTest.java
new file mode 100644
index 0000000000..2f81836540
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/MdtaMetadataEntryTest.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.mp4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.os.Parcel;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Test for {@link MdtaMetadataEntry}. */
+@RunWith(RobolectricTestRunner.class)
+public final class MdtaMetadataEntryTest {
+
+  @Test
+  public void testParcelable() {
+    MdtaMetadataEntry mdtaMetadataEntryToParcel =
+        new MdtaMetadataEntry("test", new byte[] {1, 2}, 3, 4);
+
+    Parcel parcel = Parcel.obtain();
+    mdtaMetadataEntryToParcel.writeToParcel(parcel, 0);
+    parcel.setDataPosition(0);
+
+    MdtaMetadataEntry mdtaMetadataEntryFromParcel =
+        MdtaMetadataEntry.CREATOR.createFromParcel(parcel);
+    assertThat(mdtaMetadataEntryFromParcel).isEqualTo(mdtaMetadataEntryToParcel);
+
+    parcel.recycle();
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
index f7cfd6ccaf..62da914f5b 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import static com.google.android.exoplayer2.extractor.ts.TsPayloadReader.FLAG_DATA_ALIGNMENT_INDICATOR;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
@@ -198,7 +200,7 @@ private void feed() throws ParserException {
 
   private void maybeStartPacket() {
     if (firstFeed) {
-      adtsReader.packetStarted(0, true);
+      adtsReader.packetStarted(0, FLAG_DATA_ALIGNMENT_INDICATOR);
       firstFeed = false;
     }
   }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
index 713d986d21..7bff736b4a 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import static com.google.android.exoplayer2.extractor.ts.TsPayloadReader.FLAG_PAYLOAD_UNIT_START_INDICATOR;
 import static com.google.common.truth.Truth.assertThat;
 import static java.util.Arrays.asList;
 import static java.util.Collections.singletonList;
@@ -55,7 +56,7 @@ public void setUp() {
   public void testSingleOnePacketSection() {
     packetPayload[0] = 3;
     insertTableSection(4, (byte) 99, 3);
-    reader.consume(new ParsableByteArray(packetPayload), true);
+    reader.consume(new ParsableByteArray(packetPayload), FLAG_PAYLOAD_UNIT_START_INDICATOR);
     assertThat(payloadReader.parsedTableIds).isEqualTo(singletonList(99));
   }
 
@@ -65,12 +66,12 @@ public void testHeaderSplitAcrossPackets() {
     insertTableSection(4, (byte) 100, 3); // This section header spreads across both packets.
 
     ParsableByteArray firstPacket = new ParsableByteArray(packetPayload, 5);
-    reader.consume(firstPacket, true);
+    reader.consume(firstPacket, FLAG_PAYLOAD_UNIT_START_INDICATOR);
     assertThat(payloadReader.parsedTableIds).isEmpty();
 
     ParsableByteArray secondPacket = new ParsableByteArray(packetPayload);
     secondPacket.setPosition(5);
-    reader.consume(secondPacket, false);
+    reader.consume(secondPacket, /* flags= */ 0);
     assertThat(payloadReader.parsedTableIds).isEqualTo(singletonList(100));
   }
 
@@ -85,12 +86,12 @@ public void testFiveSectionsInTwoPackets() {
     insertTableSection(54, (byte) 105, 10);
 
     ParsableByteArray firstPacket = new ParsableByteArray(packetPayload, 40);
-    reader.consume(firstPacket, true);
+    reader.consume(firstPacket, FLAG_PAYLOAD_UNIT_START_INDICATOR);
     assertThat(payloadReader.parsedTableIds).isEqualTo(asList(101, 102, 103));
 
     ParsableByteArray secondPacket = new ParsableByteArray(packetPayload);
     secondPacket.setPosition(40);
-    reader.consume(secondPacket, true);
+    reader.consume(secondPacket, FLAG_PAYLOAD_UNIT_START_INDICATOR);
     assertThat(payloadReader.parsedTableIds).isEqualTo(asList(101, 102, 103, 104, 105));
   }
 
@@ -105,22 +106,22 @@ public void testLongSectionAcrossFourPackets() {
     insertTableSection(318, (byte) 108, 10);
 
     ParsableByteArray firstPacket = new ParsableByteArray(packetPayload, 100);
-    reader.consume(firstPacket, true);
+    reader.consume(firstPacket, FLAG_PAYLOAD_UNIT_START_INDICATOR);
     assertThat(payloadReader.parsedTableIds).isEmpty();
 
     ParsableByteArray secondPacket = new ParsableByteArray(packetPayload, 200);
     secondPacket.setPosition(100);
-    reader.consume(secondPacket, false);
+    reader.consume(secondPacket, /* flags= */ 0);
     assertThat(payloadReader.parsedTableIds).isEmpty();
 
     ParsableByteArray thirdPacket = new ParsableByteArray(packetPayload, 300);
     thirdPacket.setPosition(200);
-    reader.consume(thirdPacket, false);
+    reader.consume(thirdPacket, /* flags= */ 0);
     assertThat(payloadReader.parsedTableIds).isEmpty();
 
     ParsableByteArray fourthPacket = new ParsableByteArray(packetPayload);
     fourthPacket.setPosition(300);
-    reader.consume(fourthPacket, true);
+    reader.consume(fourthPacket, FLAG_PAYLOAD_UNIT_START_INDICATOR);
     assertThat(payloadReader.parsedTableIds).isEqualTo(asList(107, 108));
   }
 
@@ -135,24 +136,24 @@ public void testSeek() {
     insertTableSection(318, (byte) 111, 10);
 
     ParsableByteArray firstPacket = new ParsableByteArray(packetPayload, 100);
-    reader.consume(firstPacket, true);
+    reader.consume(firstPacket, FLAG_PAYLOAD_UNIT_START_INDICATOR);
     assertThat(payloadReader.parsedTableIds).isEmpty();
 
     ParsableByteArray secondPacket = new ParsableByteArray(packetPayload, 200);
     secondPacket.setPosition(100);
-    reader.consume(secondPacket, false);
+    reader.consume(secondPacket, /* flags= */ 0);
     assertThat(payloadReader.parsedTableIds).isEmpty();
 
     ParsableByteArray thirdPacket = new ParsableByteArray(packetPayload, 300);
     thirdPacket.setPosition(200);
-    reader.consume(thirdPacket, false);
+    reader.consume(thirdPacket, /* flags= */ 0);
     assertThat(payloadReader.parsedTableIds).isEmpty();
 
     reader.seek();
 
     ParsableByteArray fourthPacket = new ParsableByteArray(packetPayload);
     fourthPacket.setPosition(300);
-    reader.consume(fourthPacket, true);
+    reader.consume(fourthPacket, FLAG_PAYLOAD_UNIT_START_INDICATOR);
     assertThat(payloadReader.parsedTableIds).isEqualTo(singletonList(111));
   }
 
@@ -165,9 +166,9 @@ public void testCrcChecks() {
     byte[] incorrectCrcPat = Arrays.copyOf(correctCrcPat, correctCrcPat.length);
     // Crc field is incorrect, and should not be passed to the payload reader.
     incorrectCrcPat[16]--;
-    reader.consume(new ParsableByteArray(correctCrcPat), true);
+    reader.consume(new ParsableByteArray(correctCrcPat), FLAG_PAYLOAD_UNIT_START_INDICATOR);
     assertThat(payloadReader.parsedTableIds).isEqualTo(singletonList(0));
-    reader.consume(new ParsableByteArray(incorrectCrcPat), true);
+    reader.consume(new ParsableByteArray(incorrectCrcPat), FLAG_PAYLOAD_UNIT_START_INDICATOR);
     assertThat(payloadReader.parsedTableIds).isEqualTo(singletonList(0));
   }
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
index 332fbe384a..beaa5ffa83 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
@@ -202,7 +202,7 @@ public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGen
     }
 
     @Override
-    public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {}
+    public void packetStarted(long pesTimeUs, @TsPayloadReader.Flags int flags) {}
 
     @Override
     public void consume(ParsableByteArray data) {}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java
index fdf454e5df..72fff9606c 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java
@@ -63,6 +63,9 @@
   private static final String FONT_SIZE_INVALID_TTML_FILE = "ttml/font_size_invalid.xml";
   private static final String FONT_SIZE_EMPTY_TTML_FILE = "ttml/font_size_empty.xml";
   private static final String FRAME_RATE_TTML_FILE = "ttml/frame_rate.xml";
+  private static final String BITMAP_REGION_FILE = "ttml/bitmap_percentage_region.xml";
+  private static final String BITMAP_PIXEL_REGION_FILE = "ttml/bitmap_pixel_region.xml";
+  private static final String BITMAP_UNSUPPORTED_REGION_FILE = "ttml/bitmap_unsupported_region.xml";
 
   @Test
   public void testInlineAttributes() throws IOException, SubtitleDecoderException {
@@ -259,56 +262,56 @@ public void testMergeMultipleStylesWithParentStyle()
   @Test
   public void testMultipleRegions() throws IOException, SubtitleDecoderException {
     TtmlSubtitle subtitle = getSubtitle(MULTIPLE_REGIONS_TTML_FILE);
-    List<Cue> output = subtitle.getCues(1000000);
-    assertThat(output).hasSize(2);
-    Cue ttmlCue = output.get(0);
-    assertThat(ttmlCue.text.toString()).isEqualTo("lorem");
-    assertThat(ttmlCue.position).isEqualTo(10f / 100f);
-    assertThat(ttmlCue.line).isEqualTo(10f / 100f);
-    assertThat(ttmlCue.size).isEqualTo(20f / 100f);
-
-    ttmlCue = output.get(1);
-    assertThat(ttmlCue.text.toString()).isEqualTo("amet");
-    assertThat(ttmlCue.position).isEqualTo(60f / 100f);
-    assertThat(ttmlCue.line).isEqualTo(10f / 100f);
-    assertThat(ttmlCue.size).isEqualTo(20f / 100f);
-
-    output = subtitle.getCues(5000000);
-    assertThat(output).hasSize(1);
-    ttmlCue = output.get(0);
-    assertThat(ttmlCue.text.toString()).isEqualTo("ipsum");
-    assertThat(ttmlCue.position).isEqualTo(40f / 100f);
-    assertThat(ttmlCue.line).isEqualTo(40f / 100f);
-    assertThat(ttmlCue.size).isEqualTo(20f / 100f);
-
-    output = subtitle.getCues(9000000);
-    assertThat(output).hasSize(1);
-    ttmlCue = output.get(0);
-    assertThat(ttmlCue.text.toString()).isEqualTo("dolor");
-    assertThat(ttmlCue.position).isEqualTo(Cue.DIMEN_UNSET);
-    assertThat(ttmlCue.line).isEqualTo(Cue.DIMEN_UNSET);
-    assertThat(ttmlCue.size).isEqualTo(Cue.DIMEN_UNSET);
+    List<Cue> cues = subtitle.getCues(1000000);
+    assertThat(cues).hasSize(2);
+    Cue cue = cues.get(0);
+    assertThat(cue.text.toString()).isEqualTo("lorem");
+    assertThat(cue.position).isEqualTo(10f / 100f);
+    assertThat(cue.line).isEqualTo(10f / 100f);
+    assertThat(cue.size).isEqualTo(20f / 100f);
+
+    cue = cues.get(1);
+    assertThat(cue.text.toString()).isEqualTo("amet");
+    assertThat(cue.position).isEqualTo(60f / 100f);
+    assertThat(cue.line).isEqualTo(10f / 100f);
+    assertThat(cue.size).isEqualTo(20f / 100f);
+
+    cues = subtitle.getCues(5000000);
+    assertThat(cues).hasSize(1);
+    cue = cues.get(0);
+    assertThat(cue.text.toString()).isEqualTo("ipsum");
+    assertThat(cue.position).isEqualTo(40f / 100f);
+    assertThat(cue.line).isEqualTo(40f / 100f);
+    assertThat(cue.size).isEqualTo(20f / 100f);
+
+    cues = subtitle.getCues(9000000);
+    assertThat(cues).hasSize(1);
+    cue = cues.get(0);
+    assertThat(cue.text.toString()).isEqualTo("dolor");
+    assertThat(cue.position).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.line).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.size).isEqualTo(Cue.DIMEN_UNSET);
     // TODO: Should be as below, once https://github.com/google/ExoPlayer/issues/2953 is fixed.
-    // assertEquals(10f / 100f, ttmlCue.position);
-    // assertEquals(80f / 100f, ttmlCue.line);
-    // assertEquals(1f, ttmlCue.size);
-
-    output = subtitle.getCues(21000000);
-    assertThat(output).hasSize(1);
-    ttmlCue = output.get(0);
-    assertThat(ttmlCue.text.toString()).isEqualTo("She first said this");
-    assertThat(ttmlCue.position).isEqualTo(45f / 100f);
-    assertThat(ttmlCue.line).isEqualTo(45f / 100f);
-    assertThat(ttmlCue.size).isEqualTo(35f / 100f);
-    output = subtitle.getCues(25000000);
-    ttmlCue = output.get(0);
-    assertThat(ttmlCue.text.toString()).isEqualTo("She first said this\nThen this");
-    output = subtitle.getCues(29000000);
-    assertThat(output).hasSize(1);
-    ttmlCue = output.get(0);
-    assertThat(ttmlCue.text.toString()).isEqualTo("She first said this\nThen this\nFinally this");
-    assertThat(ttmlCue.position).isEqualTo(45f / 100f);
-    assertThat(ttmlCue.line).isEqualTo(45f / 100f);
+    // assertEquals(10f / 100f, cue.position);
+    // assertEquals(80f / 100f, cue.line);
+    // assertEquals(1f, cue.size);
+
+    cues = subtitle.getCues(21000000);
+    assertThat(cues).hasSize(1);
+    cue = cues.get(0);
+    assertThat(cue.text.toString()).isEqualTo("She first said this");
+    assertThat(cue.position).isEqualTo(45f / 100f);
+    assertThat(cue.line).isEqualTo(45f / 100f);
+    assertThat(cue.size).isEqualTo(35f / 100f);
+    cues = subtitle.getCues(25000000);
+    cue = cues.get(0);
+    assertThat(cue.text.toString()).isEqualTo("She first said this\nThen this");
+    cues = subtitle.getCues(29000000);
+    assertThat(cues).hasSize(1);
+    cue = cues.get(0);
+    assertThat(cue.text.toString()).isEqualTo("She first said this\nThen this\nFinally this");
+    assertThat(cue.position).isEqualTo(45f / 100f);
+    assertThat(cue.line).isEqualTo(45f / 100f);
   }
 
   @Test
@@ -499,6 +502,91 @@ public void testFrameRate() throws IOException, SubtitleDecoderException {
     assertThat((double) subtitle.getEventTime(3)).isWithin(2000).of(2_002_000_000);
   }
 
+  @Test
+  public void testBitmapPercentageRegion() throws IOException, SubtitleDecoderException {
+    TtmlSubtitle subtitle = getSubtitle(BITMAP_REGION_FILE);
+
+    List<Cue> cues = subtitle.getCues(1000000);
+    assertThat(cues).hasSize(1);
+    Cue cue = cues.get(0);
+    assertThat(cue.text).isNull();
+    assertThat(cue.bitmap).isNotNull();
+    assertThat(cue.position).isEqualTo(24f / 100f);
+    assertThat(cue.line).isEqualTo(28f / 100f);
+    assertThat(cue.size).isEqualTo(51f / 100f);
+    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+
+    cues = subtitle.getCues(4000000);
+    assertThat(cues).hasSize(1);
+    cue = cues.get(0);
+    assertThat(cue.text).isNull();
+    assertThat(cue.bitmap).isNotNull();
+    assertThat(cue.position).isEqualTo(21f / 100f);
+    assertThat(cue.line).isEqualTo(35f / 100f);
+    assertThat(cue.size).isEqualTo(57f / 100f);
+    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+
+    cues = subtitle.getCues(7500000);
+    assertThat(cues).hasSize(1);
+    cue = cues.get(0);
+    assertThat(cue.text).isNull();
+    assertThat(cue.bitmap).isNotNull();
+    assertThat(cue.position).isEqualTo(24f / 100f);
+    assertThat(cue.line).isEqualTo(28f / 100f);
+    assertThat(cue.size).isEqualTo(51f / 100f);
+    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+  }
+
+  @Test
+  public void testBitmapPixelRegion() throws IOException, SubtitleDecoderException {
+    TtmlSubtitle subtitle = getSubtitle(BITMAP_PIXEL_REGION_FILE);
+
+    List<Cue> cues = subtitle.getCues(1000000);
+    assertThat(cues).hasSize(1);
+    Cue cue = cues.get(0);
+    assertThat(cue.text).isNull();
+    assertThat(cue.bitmap).isNotNull();
+    assertThat(cue.position).isEqualTo(307f / 1280f);
+    assertThat(cue.line).isEqualTo(562f / 720f);
+    assertThat(cue.size).isEqualTo(653f / 1280f);
+    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+
+    cues = subtitle.getCues(4000000);
+    assertThat(cues).hasSize(1);
+    cue = cues.get(0);
+    assertThat(cue.text).isNull();
+    assertThat(cue.bitmap).isNotNull();
+    assertThat(cue.position).isEqualTo(269f / 1280f);
+    assertThat(cue.line).isEqualTo(612f / 720f);
+    assertThat(cue.size).isEqualTo(730f / 1280f);
+    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+  }
+
+  @Test
+  public void testBitmapUnsupportedRegion() throws IOException, SubtitleDecoderException {
+    TtmlSubtitle subtitle = getSubtitle(BITMAP_UNSUPPORTED_REGION_FILE);
+
+    List<Cue> cues = subtitle.getCues(1000000);
+    assertThat(cues).hasSize(1);
+    Cue cue = cues.get(0);
+    assertThat(cue.text).isNull();
+    assertThat(cue.bitmap).isNotNull();
+    assertThat(cue.position).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.line).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.size).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+
+    cues = subtitle.getCues(4000000);
+    assertThat(cues).hasSize(1);
+    cue = cues.get(0);
+    assertThat(cue.text).isNull();
+    assertThat(cue.bitmap).isNotNull();
+    assertThat(cue.position).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.line).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.size).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(cue.bitmapHeight).isEqualTo(Cue.DIMEN_UNSET);
+  }
+
   private void assertSpans(
       TtmlSubtitle subtitle,
       int second,
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
index 55d05eb7d4..2285a68062 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
@@ -489,11 +489,7 @@ public void testDeleteCachedWhileReadingFromUpstreamWithBlockingCacheDataSourceD
     NavigableSet<CacheSpan> cachedSpans = cache.getCachedSpans(expectedCacheKey);
     for (CacheSpan cachedSpan : cachedSpans) {
       if (cachedSpan.position >= halfDataLength) {
-        try {
-          cache.removeSpan(cachedSpan);
-        } catch (Cache.CacheException e) {
-          // do nothing
-        }
+        cache.removeSpan(cachedSpan);
       }
     }
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
index a4e444386a..15bbb8c108 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
@@ -47,6 +47,7 @@
 public class SimpleCacheTest {
 
   private static final String KEY_1 = "key1";
+  private static final String KEY_2 = "key2";
 
   private File cacheDir;
 
@@ -152,6 +153,40 @@ public void testReloadCache() throws Exception {
     assertCachedDataReadCorrect(cacheSpan2);
   }
 
+  @Test
+  public void testReloadCacheWithoutRelease() throws Exception {
+    SimpleCache simpleCache = getSimpleCache();
+
+    // Write data for KEY_1.
+    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
+    addCache(simpleCache, KEY_1, 0, 15);
+    simpleCache.releaseHoleSpan(cacheSpan1);
+    // Write and remove data for KEY_2.
+    CacheSpan cacheSpan2 = simpleCache.startReadWrite(KEY_2, 0);
+    addCache(simpleCache, KEY_2, 0, 15);
+    simpleCache.releaseHoleSpan(cacheSpan2);
+    simpleCache.removeSpan(simpleCache.getCachedSpans(KEY_2).first());
+
+    // Don't release the cache. This means the index file wont have been written to disk after the
+    // data for KEY_2 was removed. Move the cache instead, so we can reload it without failing the
+    // folder locking check.
+    File cacheDir2 = Util.createTempFile(RuntimeEnvironment.application, "ExoPlayerTest");
+    cacheDir2.delete();
+    cacheDir.renameTo(cacheDir2);
+
+    // Reload the cache from its new location.
+    simpleCache = new SimpleCache(cacheDir2, new NoOpCacheEvictor());
+
+    // Read data back for KEY_1.
+    CacheSpan cacheSpan3 = simpleCache.startReadWrite(KEY_1, 0);
+    assertCachedDataReadCorrect(cacheSpan3);
+
+    // Check the entry for KEY_2 was removed when the cache was reloaded.
+    assertThat(simpleCache.getCachedSpans(KEY_2)).isEmpty();
+
+    Util.recursiveDelete(cacheDir2);
+  }
+
   @Test
   public void testEncryptedIndex() throws Exception {
     byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
index 5c9a933508..ea5193eae1 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
@@ -46,6 +46,7 @@
 import com.google.android.exoplayer2.upstream.LoaderErrorThrower;
 import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
@@ -452,13 +453,22 @@ private int getPrimaryStreamIndex(int embeddedStreamIndex, int[] streamIndexToTr
       if (adaptationSetSwitchingProperty == null) {
         groupedAdaptationSetIndices[groupCount++] = new int[] {i};
       } else {
-        String[] extraAdaptationSetIds = adaptationSetSwitchingProperty.value.split(",");
+        String[] extraAdaptationSetIds = Util.split(adaptationSetSwitchingProperty.value, ",");
         int[] adaptationSetIndices = new int[1 + extraAdaptationSetIds.length];
         adaptationSetIndices[0] = i;
+        int outputIndex = 1;
         for (int j = 0; j < extraAdaptationSetIds.length; j++) {
-          int extraIndex = idToIndexMap.get(Integer.parseInt(extraAdaptationSetIds[j]));
-          adaptationSetUsedFlags[extraIndex] = true;
-          adaptationSetIndices[1 + j] = extraIndex;
+          int extraIndex =
+              idToIndexMap.get(
+                  Integer.parseInt(extraAdaptationSetIds[j]), /* valueIfKeyNotFound= */ -1);
+          if (extraIndex != -1) {
+            adaptationSetUsedFlags[extraIndex] = true;
+            adaptationSetIndices[outputIndex] = extraIndex;
+            outputIndex++;
+          }
+        }
+        if (outputIndex < adaptationSetIndices.length) {
+          adaptationSetIndices = Arrays.copyOf(adaptationSetIndices, outputIndex);
         }
         groupedAdaptationSetIndices[groupCount++] = adaptationSetIndices;
       }
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
index 8ee859b8bd..c65bfceb39 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
@@ -607,6 +607,12 @@ public void replaceManifestUri(Uri manifestUri) {
 
   // MediaSource implementation.
 
+  @Override
+  @Nullable
+  public Object getTag() {
+    return tag;
+  }
+
   @Override
   public void prepareSourceInternal(
       ExoPlayer player,
@@ -629,7 +635,8 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public MediaPeriod createPeriod(MediaPeriodId periodId, Allocator allocator) {
+  public MediaPeriod createPeriod(
+      MediaPeriodId periodId, Allocator allocator, long startPositionUs) {
     int periodIndex = (Integer) periodId.periodUid - firstPeriodId;
     EventDispatcher periodEventDispatcher =
         createEventDispatcher(periodId, manifest.getPeriod(periodIndex).startMs);
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
index 5e20fb769c..3e51009f20 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
@@ -457,10 +457,10 @@ private long getSegmentNum(
   }
 
   private ArrayList<Representation> getRepresentations() {
-    List<AdaptationSet> manifestAdapationSets = manifest.getPeriod(periodIndex).adaptationSets;
+    List<AdaptationSet> manifestAdaptationSets = manifest.getPeriod(periodIndex).adaptationSets;
     ArrayList<Representation> representations = new ArrayList<>();
     for (int adaptationSetIndex : adaptationSetIndices) {
-      representations.addAll(manifestAdapationSets.get(adaptationSetIndex).representations);
+      representations.addAll(manifestAdaptationSets.get(adaptationSetIndex).representations);
     }
     return representations;
   }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
index a075dacf3a..2afd041631 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
@@ -390,6 +390,12 @@ private HlsMediaSource(
     this.tag = tag;
   }
 
+  @Override
+  @Nullable
+  public Object getTag() {
+    return tag;
+  }
+
   @Override
   public void prepareSourceInternal(
       ExoPlayer player,
@@ -406,7 +412,7 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
+  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
     EventDispatcher eventDispatcher = createEventDispatcher(id);
     return new HlsMediaPeriod(
         extractorFactory,
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
index 65f4796187..242711431c 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
@@ -360,7 +360,7 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
                   /* initializationData= */ null,
                   selectionFlags,
                   language);
-          if (uri == null) {
+          if (isMediaTagMuxed(variants, uri)) {
             muxedAudioFormat = format;
           } else {
             audios.add(new HlsMasterPlaylist.HlsUrl(uri, format));
@@ -766,6 +766,20 @@ private static Pattern compileBooleanAttrPattern(String attribute) {
     return Pattern.compile(attribute + "=(" + BOOLEAN_FALSE + "|" + BOOLEAN_TRUE + ")");
   }
 
+  private static boolean isMediaTagMuxed(
+      List<HlsMasterPlaylist.HlsUrl> variants, String mediaTagUri) {
+    if (mediaTagUri == null) {
+      return true;
+    }
+    // The URI attribute is defined, but it may match the uri of a variant.
+    for (int i = 0; i < variants.size(); i++) {
+      if (mediaTagUri.equals(variants.get(i).url)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   private static class LineIterator {
 
     private final BufferedReader reader;
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
index d03049efb3..9701171ce9 100644
--- a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
@@ -134,6 +134,17 @@
           + "#EXT-X-STREAM-INF:BANDWIDTH=65000,CODECS=\"{$codecs}\"\n"
           + "http://example.com/{$tricky}\n";
 
+  private static final String PLAYLIST_WITH_MULTIPLE_MUXED_MEDIA_TAGS =
+      "#EXTM3U\n"
+          + "#EXT-X-VERSION:3\n"
+          + "#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"a\",NAME=\"audio_0\",DEFAULT=YES,URI=\"0/0.m3u8\"\n"
+          + "#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"b\",NAME=\"audio_0\",DEFAULT=YES,URI=\"1/1.m3u8\"\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=140800,CODECS=\"mp4a.40.2\",AUDIO=\"a\"\n"
+          + "0/0.m3u8\n"
+          + "\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=281600,CODECS=\"mp4a.40.2\",AUDIO=\"b\"\n"
+          + "1/1.m3u8\n";
+
   @Test
   public void testParseMasterPlaylist() throws IOException {
     HlsMasterPlaylist masterPlaylist = parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_SIMPLE);
@@ -271,6 +282,14 @@ public void testVariableSubstitution() throws IOException {
     assertThat(variant.url).isEqualTo("http://example.com/This/{$nested}/reference/shouldnt/work");
   }
 
+  @Test
+  public void testMultipleMuxedMediaTags() throws IOException {
+    HlsMasterPlaylist playlistWithMultipleMuxedMediaTags =
+        parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_WITH_MULTIPLE_MUXED_MEDIA_TAGS);
+    assertThat(playlistWithMultipleMuxedMediaTags.variants).hasSize(2);
+    assertThat(playlistWithMultipleMuxedMediaTags.audios).isEmpty();
+  }
+
   private static HlsMasterPlaylist parseMasterPlaylist(String uri, String playlistString)
       throws IOException {
     Uri playlistUri = Uri.parse(uri);
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
index 9ac376efad..7c76dba749 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
@@ -61,14 +61,13 @@ public SsChunkSource createChunkSource(
         SsManifest manifest,
         int elementIndex,
         TrackSelection trackSelection,
-        TrackEncryptionBox[] trackEncryptionBoxes,
         @Nullable TransferListener transferListener) {
       DataSource dataSource = dataSourceFactory.createDataSource();
       if (transferListener != null) {
         dataSource.addTransferListener(transferListener);
       }
-      return new DefaultSsChunkSource(manifestLoaderErrorThrower, manifest, elementIndex,
-          trackSelection, dataSource, trackEncryptionBoxes);
+      return new DefaultSsChunkSource(
+          manifestLoaderErrorThrower, manifest, elementIndex, trackSelection, dataSource);
     }
 
   }
@@ -90,15 +89,13 @@ public SsChunkSource createChunkSource(
    * @param streamElementIndex The index of the stream element in the manifest.
    * @param trackSelection The track selection.
    * @param dataSource A {@link DataSource} suitable for loading the media data.
-   * @param trackEncryptionBoxes Track encryption boxes for the stream.
    */
   public DefaultSsChunkSource(
       LoaderErrorThrower manifestLoaderErrorThrower,
       SsManifest manifest,
       int streamElementIndex,
       TrackSelection trackSelection,
-      DataSource dataSource,
-      TrackEncryptionBox[] trackEncryptionBoxes) {
+      DataSource dataSource) {
     this.manifestLoaderErrorThrower = manifestLoaderErrorThrower;
     this.manifest = manifest;
     this.streamElementIndex = streamElementIndex;
@@ -110,6 +107,8 @@ public DefaultSsChunkSource(
     for (int i = 0; i < extractorWrappers.length; i++) {
       int manifestTrackIndex = trackSelection.getIndexInTrackGroup(i);
       Format format = streamElement.formats[manifestTrackIndex];
+      TrackEncryptionBox[] trackEncryptionBoxes =
+          format.drmInitData != null ? manifest.protectionElement.trackEncryptionBoxes : null;
       int nalUnitLengthFieldLength = streamElement.type == C.TRACK_TYPE_VIDEO ? 4 : 0;
       Track track = new Track(manifestTrackIndex, streamElement.type, streamElement.timescale,
           C.TIME_UNSET, manifest.durationUs, format, Track.TRANSFORMATION_NONE,
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsChunkSource.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsChunkSource.java
index f333a6f92c..4940f1592f 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsChunkSource.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsChunkSource.java
@@ -16,7 +16,6 @@
 package com.google.android.exoplayer2.source.smoothstreaming;
 
 import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.extractor.mp4.TrackEncryptionBox;
 import com.google.android.exoplayer2.source.chunk.ChunkSource;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
@@ -38,7 +37,6 @@
      * @param manifest The initial manifest.
      * @param streamElementIndex The index of the corresponding stream element in the manifest.
      * @param trackSelection The track selection.
-     * @param trackEncryptionBoxes Track encryption boxes for the stream.
      * @param transferListener The transfer listener which should be informed of any data transfers.
      *     May be null if no listener is available.
      * @return The created {@link SsChunkSource}.
@@ -48,7 +46,6 @@ SsChunkSource createChunkSource(
         SsManifest manifest,
         int streamElementIndex,
         TrackSelection trackSelection,
-        TrackEncryptionBox[] trackEncryptionBoxes,
         @Nullable TransferListener transferListener);
   }
 
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
index 14b54bc471..d3518c0a35 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
@@ -29,7 +29,6 @@
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.source.chunk.ChunkSampleStream;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest;
-import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.ProtectionElement;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
@@ -44,8 +43,6 @@
 /* package */ final class SsMediaPeriod implements MediaPeriod,
     SequenceableLoader.Callback<ChunkSampleStream<SsChunkSource>> {
 
-  private static final int INITIALIZATION_VECTOR_SIZE = 8;
-
   private final SsChunkSource.Factory chunkSourceFactory;
   private final @Nullable TransferListener transferListener;
   private final LoaderErrorThrower manifestLoaderErrorThrower;
@@ -53,7 +50,6 @@
   private final EventDispatcher eventDispatcher;
   private final Allocator allocator;
   private final TrackGroupArray trackGroups;
-  private final TrackEncryptionBox[] trackEncryptionBoxes;
   private final CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
 
   private @Nullable Callback callback;
@@ -71,6 +67,7 @@ public SsMediaPeriod(
       EventDispatcher eventDispatcher,
       LoaderErrorThrower manifestLoaderErrorThrower,
       Allocator allocator) {
+    this.manifest = manifest;
     this.chunkSourceFactory = chunkSourceFactory;
     this.transferListener = transferListener;
     this.manifestLoaderErrorThrower = manifestLoaderErrorThrower;
@@ -78,18 +75,7 @@ public SsMediaPeriod(
     this.eventDispatcher = eventDispatcher;
     this.allocator = allocator;
     this.compositeSequenceableLoaderFactory = compositeSequenceableLoaderFactory;
-
     trackGroups = buildTrackGroups(manifest);
-    ProtectionElement protectionElement = manifest.protectionElement;
-    if (protectionElement != null) {
-      byte[] keyId = getProtectionElementKeyId(protectionElement.data);
-      // We assume pattern encryption does not apply.
-      trackEncryptionBoxes = new TrackEncryptionBox[] {
-          new TrackEncryptionBox(true, null, INITIALIZATION_VECTOR_SIZE, keyId, 0, 0, null)};
-    } else {
-      trackEncryptionBoxes = null;
-    }
-    this.manifest = manifest;
     sampleStreams = newSampleStreamArray(0);
     compositeSequenceableLoader =
         compositeSequenceableLoaderFactory.createCompositeSequenceableLoader(sampleStreams);
@@ -229,7 +215,6 @@ public void onContinueLoadingRequested(ChunkSampleStream<SsChunkSource> sampleSt
             manifest,
             streamElementIndex,
             selection,
-            trackEncryptionBoxes,
             transferListener);
     return new ChunkSampleStream<>(
         manifest.streamElements[streamElementIndex].type,
@@ -277,5 +262,4 @@ private static void swap(byte[] data, int firstPosition, int secondPosition) {
     data[firstPosition] = data[secondPosition];
     data[secondPosition] = temp;
   }
-
 }
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
index a756b7f4f1..d025f8fa3a 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
@@ -503,6 +503,12 @@ private SsMediaSource(
 
   // MediaSource implementation.
 
+  @Override
+  @Nullable
+  public Object getTag() {
+    return tag;
+  }
+
   @Override
   public void prepareSourceInternal(
       ExoPlayer player,
@@ -527,7 +533,7 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
+  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
     EventDispatcher eventDispatcher = createEventDispatcher(id);
     SsMediaPeriod period =
         new SsMediaPeriod(
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifest.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifest.java
index 2c508f0fde..cfb772a86b 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifest.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifest.java
@@ -18,6 +18,7 @@
 import android.net.Uri;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.extractor.mp4.TrackEncryptionBox;
 import com.google.android.exoplayer2.offline.FilterableManifest;
 import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.util.Assertions;
@@ -41,10 +42,12 @@
 
     public final UUID uuid;
     public final byte[] data;
+    public final TrackEncryptionBox[] trackEncryptionBoxes;
 
-    public ProtectionElement(UUID uuid, byte[] data) {
+    public ProtectionElement(UUID uuid, byte[] data, TrackEncryptionBox[] trackEncryptionBoxes) {
       this.uuid = uuid;
       this.data = data;
+      this.trackEncryptionBoxes = trackEncryptionBoxes;
     }
   }
 
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
index 3d5ade403a..4c1c6ee0cc 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
@@ -25,6 +25,7 @@
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import com.google.android.exoplayer2.extractor.mp4.PsshAtomUtil;
+import com.google.android.exoplayer2.extractor.mp4.TrackEncryptionBox;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.ProtectionElement;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.StreamElement;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
@@ -397,9 +398,10 @@ public Object build() {
 
     public static final String TAG = "Protection";
     public static final String TAG_PROTECTION_HEADER = "ProtectionHeader";
-
     public static final String KEY_SYSTEM_ID = "SystemID";
 
+    private static final int INITIALIZATION_VECTOR_SIZE = 8;
+
     private boolean inProtectionHeader;
     private UUID uuid;
     private byte[] initData;
@@ -439,7 +441,44 @@ public void parseEndTag(XmlPullParser parser) {
 
     @Override
     public Object build() {
-      return new ProtectionElement(uuid, PsshAtomUtil.buildPsshAtom(uuid, initData));
+      return new ProtectionElement(
+          uuid, PsshAtomUtil.buildPsshAtom(uuid, initData), buildTrackEncryptionBoxes(initData));
+    }
+
+    private static TrackEncryptionBox[] buildTrackEncryptionBoxes(byte[] initData) {
+      return new TrackEncryptionBox[] {
+        new TrackEncryptionBox(
+            /* isEncrypted= */ true,
+            /* schemeType= */ null,
+            INITIALIZATION_VECTOR_SIZE,
+            getProtectionElementKeyId(initData),
+            /* defaultEncryptedBlocks= */ 0,
+            /* defaultClearBlocks= */ 0,
+            /* defaultInitializationVector= */ null)
+      };
+    }
+
+    private static byte[] getProtectionElementKeyId(byte[] initData) {
+      StringBuilder initDataStringBuilder = new StringBuilder();
+      for (int i = 0; i < initData.length; i += 2) {
+        initDataStringBuilder.append((char) initData[i]);
+      }
+      String initDataString = initDataStringBuilder.toString();
+      String keyIdString =
+          initDataString.substring(
+              initDataString.indexOf("<KID>") + 5, initDataString.indexOf("</KID>"));
+      byte[] keyId = Base64.decode(keyIdString, Base64.DEFAULT);
+      swap(keyId, 0, 3);
+      swap(keyId, 1, 2);
+      swap(keyId, 4, 5);
+      swap(keyId, 6, 7);
+      return keyId;
+    }
+
+    private static void swap(byte[] data, int firstPosition, int secondPosition) {
+      byte temp = data[firstPosition];
+      data[firstPosition] = data[secondPosition];
+      data[secondPosition] = temp;
     }
 
     private static String stripCurlyBraces(String uuidString) {
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloadHelper.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloadHelper.java
index 5125beff1c..88830dde6a 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloadHelper.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloadHelper.java
@@ -25,6 +25,7 @@
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifestParser;
+import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsUtil;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
 import com.google.android.exoplayer2.util.Assertions;
@@ -42,7 +43,7 @@
   private @MonotonicNonNull SsManifest manifest;
 
   public SsDownloadHelper(Uri uri, DataSource.Factory manifestDataSourceFactory) {
-    this.uri = uri;
+    this.uri = SsUtil.fixManifestUri(uri);;
     this.manifestDataSourceFactory = manifestDataSourceFactory;
   }
 
diff --git a/library/smoothstreaming/src/test/assets/sample_ismc_1 b/library/smoothstreaming/src/test/assets/sample_ismc_1
index 25a37d65b4..1d279d0a67 100644
--- a/library/smoothstreaming/src/test/assets/sample_ismc_1
+++ b/library/smoothstreaming/src/test/assets/sample_ismc_1
@@ -3,7 +3,7 @@
     Duration="2300000000" TimeScale="10000000">
     <Protection>
         <ProtectionHeader SystemID="9A04F079-9840-4286-AB92-E65BE0885F95">
-            <!-- Base 64-Encoded data omitted for clarity -->
+            fgMAAAEAAQB0AzwAVwBSAE0ASABFAEEARABFAFIAIAB4AG0AbABuAHMAPQAiAGgAdAB0AHAAOgAvAC8AcwBjAGgAZQBtAGEAcwAuAG0AaQBjAHIAbwBzAG8AZgB0AC4AYwBvAG0ALwBEAFIATQAvADIAMAAwADcALwAwADMALwBQAGwAYQB5AFIAZQBhAGQAeQBIAGUAYQBkAGUAcgAiACAAdgBlAHIAcwBpAG8AbgA9ACIANAAuADAALgAwAC4AMAAiAD4APABEAEEAVABBAD4APABQAFIATwBUAEUAQwBUAEkATgBGAE8APgA8AEsARQBZAEwARQBOAD4AMQA2ADwALwBLAEUAWQBMAEUATgA+ADwAQQBMAEcASQBEAD4AQQBFAFMAQwBUAFIAPAAvAEEATABHAEkARAA+ADwALwBQAFIATwBUAEUAQwBUAEkATgBGAE8APgA8AEsASQBEAD4AQgBhAFUATQBPAEcAYwBzAGgAVQBDAEQAZAB3ADMANABZAGMAawBmAFoAQQA9AD0APAAvAEsASQBEAD4APABDAEgARQBDAEsAUwBVAE0APgBnADcATgBhAFIARABJAEkATwA5ADAAPQA8AC8AQwBIAEUAQwBLAFMAVQBNAD4APABMAEEAXwBVAFIATAA+AGgAdAB0AHAAcwA6AC8ALwBUAC0ATwBOAEwASQBOAEUALgBEAFUATQBNAFkALQBTAEUAUgBWAEUAUgAvAEEAcgB0AGUAbQBpAHMATABpAGMAZQBuAHMAZQBTAGUAcgB2AGUAcgAvAFAAbABhAHkAUgBlAGEAZAB5AE0AYQBuAGEAZwBlAHIALgBhAHMAbQB4ADwALwBMAEEAXwBVAFIATAA+ADwAQwBVAFMAVABPAE0AQQBUAFQAUgBJAEIAVQBUAEUAUwA+ADwAQwBJAEQAPgAxADcANQA4ADIANgA8AC8AQwBJAEQAPgA8AEkASQBTAF8ARABSAE0AXwBWAEUAUgBTAEkATwBOAD4ANwAuADEALgAxADUANgA1AC4ANAA8AC8ASQBJAFMAXwBEAFIATQBfAFYARQBSAFMASQBPAE4APgA8AC8AQwBVAFMAVABPAE0AQQBUAFQAUgBJAEIAVQBUAEUAUwA+ADwALwBEAEEAVABBAD4APAAvAFcAUgBNAEgARQBBAEQARQBSAD4A
         </ProtectionHeader>
     </Protection>
 
diff --git a/library/smoothstreaming/src/test/assets/sample_ismc_2 b/library/smoothstreaming/src/test/assets/sample_ismc_2
index 5875a18183..7f2a53036f 100644
--- a/library/smoothstreaming/src/test/assets/sample_ismc_2
+++ b/library/smoothstreaming/src/test/assets/sample_ismc_2
@@ -3,7 +3,7 @@
     Duration="2300000000" TimeScale="10000000">
     <Protection>
         <ProtectionHeader SystemID="{9A04F079-9840-4286-AB92-E65BE0885F95}">
-            <!-- Base 64-Encoded data omitted for clarity -->
+            fgMAAAEAAQB0AzwAVwBSAE0ASABFAEEARABFAFIAIAB4AG0AbABuAHMAPQAiAGgAdAB0AHAAOgAvAC8AcwBjAGgAZQBtAGEAcwAuAG0AaQBjAHIAbwBzAG8AZgB0AC4AYwBvAG0ALwBEAFIATQAvADIAMAAwADcALwAwADMALwBQAGwAYQB5AFIAZQBhAGQAeQBIAGUAYQBkAGUAcgAiACAAdgBlAHIAcwBpAG8AbgA9ACIANAAuADAALgAwAC4AMAAiAD4APABEAEEAVABBAD4APABQAFIATwBUAEUAQwBUAEkATgBGAE8APgA8AEsARQBZAEwARQBOAD4AMQA2ADwALwBLAEUAWQBMAEUATgA+ADwAQQBMAEcASQBEAD4AQQBFAFMAQwBUAFIAPAAvAEEATABHAEkARAA+ADwALwBQAFIATwBUAEUAQwBUAEkATgBGAE8APgA8AEsASQBEAD4AQgBhAFUATQBPAEcAYwBzAGgAVQBDAEQAZAB3ADMANABZAGMAawBmAFoAQQA9AD0APAAvAEsASQBEAD4APABDAEgARQBDAEsAUwBVAE0APgBnADcATgBhAFIARABJAEkATwA5ADAAPQA8AC8AQwBIAEUAQwBLAFMAVQBNAD4APABMAEEAXwBVAFIATAA+AGgAdAB0AHAAcwA6AC8ALwBUAC0ATwBOAEwASQBOAEUALgBEAFUATQBNAFkALQBTAEUAUgBWAEUAUgAvAEEAcgB0AGUAbQBpAHMATABpAGMAZQBuAHMAZQBTAGUAcgB2AGUAcgAvAFAAbABhAHkAUgBlAGEAZAB5AE0AYQBuAGEAZwBlAHIALgBhAHMAbQB4ADwALwBMAEEAXwBVAFIATAA+ADwAQwBVAFMAVABPAE0AQQBUAFQAUgBJAEIAVQBUAEUAUwA+ADwAQwBJAEQAPgAxADcANQA4ADIANgA8AC8AQwBJAEQAPgA8AEkASQBTAF8ARABSAE0AXwBWAEUAUgBTAEkATwBOAD4ANwAuADEALgAxADUANgA1AC4ANAA8AC8ASQBJAFMAXwBEAFIATQBfAFYARQBSAFMASQBPAE4APgA8AC8AQwBVAFMAVABPAE0AQQBUAFQAUgBJAEIAVQBUAEUAUwA+ADwALwBEAEEAVABBAD4APAAvAFcAUgBNAEgARQBBAEQARQBSAD4A
         </ProtectionHeader>
     </Protection>
 
diff --git a/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestTest.java b/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestTest.java
index dc8d6754f5..b692d94c18 100644
--- a/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestTest.java
+++ b/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestTest.java
@@ -19,6 +19,7 @@
 
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.extractor.mp4.TrackEncryptionBox;
 import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.ProtectionElement;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.StreamElement;
@@ -36,7 +37,7 @@
 public class SsManifestTest {
 
   private static final ProtectionElement DUMMY_PROTECTION_ELEMENT =
-      new ProtectionElement(C.WIDEVINE_UUID, new byte[] {0, 1, 2});
+      new ProtectionElement(C.WIDEVINE_UUID, new byte[0], new TrackEncryptionBox[0]);
 
   @Test
   public void testCopy() throws Exception {
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DebugTextViewHelper.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DebugTextViewHelper.java
index 8c7c507f92..da2081db31 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DebugTextViewHelper.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DebugTextViewHelper.java
@@ -137,23 +137,40 @@ protected String getPlayerStateString() {
   /** Returns a string containing video debugging information. */
   protected String getVideoString() {
     Format format = player.getVideoFormat();
-    if (format == null) {
+    DecoderCounters decoderCounters = player.getVideoDecoderCounters();
+    if (format == null || decoderCounters == null) {
       return "";
     }
-    return "\n" + format.sampleMimeType + "(id:" + format.id + " r:" + format.width + "x"
-        + format.height + getPixelAspectRatioString(format.pixelWidthHeightRatio)
-        + getDecoderCountersBufferCountString(player.getVideoDecoderCounters()) + ")";
+    return "\n"
+        + format.sampleMimeType
+        + "(id:"
+        + format.id
+        + " r:"
+        + format.width
+        + "x"
+        + format.height
+        + getPixelAspectRatioString(format.pixelWidthHeightRatio)
+        + getDecoderCountersBufferCountString(decoderCounters)
+        + ")";
   }
 
   /** Returns a string containing audio debugging information. */
   protected String getAudioString() {
     Format format = player.getAudioFormat();
-    if (format == null) {
+    DecoderCounters decoderCounters = player.getAudioDecoderCounters();
+    if (format == null || decoderCounters == null) {
       return "";
     }
-    return "\n" + format.sampleMimeType + "(id:" + format.id + " hz:" + format.sampleRate + " ch:"
+    return "\n"
+        + format.sampleMimeType
+        + "(id:"
+        + format.id
+        + " hz:"
+        + format.sampleRate
+        + " ch:"
         + format.channelCount
-        + getDecoderCountersBufferCountString(player.getAudioDecoderCounters()) + ")";
+        + getDecoderCountersBufferCountString(decoderCounters)
+        + ")";
   }
 
   private static String getDecoderCountersBufferCountString(DecoderCounters counters) {
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java
index 47025d9bba..7cbe52d404 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java
@@ -125,6 +125,18 @@
     @Nullable
     String getCurrentContentText(Player player);
 
+    /**
+     * Gets the content sub text for the current media item.
+     *
+     * <p>See {@link NotificationCompat.Builder#setSubText(CharSequence)}.
+     *
+     * @param player The {@link Player} for which a notification is being built.
+     */
+    @Nullable
+    default String getCurrentSubText(Player player) {
+      return null;
+    }
+
     /**
      * Gets the large icon for the current media item.
      *
@@ -832,6 +844,7 @@ protected Notification createNotification(Player player, @Nullable Bitmap largeI
     // Set media specific notification properties from MediaDescriptionAdapter.
     builder.setContentTitle(mediaDescriptionAdapter.getCurrentContentTitle(player));
     builder.setContentText(mediaDescriptionAdapter.getCurrentContentText(player));
+    builder.setSubText(mediaDescriptionAdapter.getCurrentSubText(player));
     if (largeIcon == null) {
       largeIcon =
           mediaDescriptionAdapter.getCurrentLargeIcon(
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
index 310d04a064..83f5b70cbb 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
@@ -29,7 +29,6 @@
 import android.graphics.drawable.Drawable;
 import android.os.Looper;
 import android.support.annotation.IntDef;
-import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.support.v4.content.ContextCompat;
 import android.util.AttributeSet;
@@ -187,8 +186,9 @@
  *         <li>Type: {@link AspectRatioFrameLayout}
  *       </ul>
  *   <li><b>{@code exo_shutter}</b> - A view that's made visible when video should be hidden. This
- *       view is typically an opaque view that covers the video surface view, thereby obscuring it
- *       when visible.
+ *       view is typically an opaque view that covers the video surface, thereby obscuring it when
+ *       visible. Obscuring the surface in this way also helps to prevent flicker at the start of
+ *       playback when {@code surface_type="surface_view"}.
  *       <ul>
  *         <li>Type: {@link View}
  *       </ul>
@@ -271,13 +271,13 @@
   private static final int SURFACE_TYPE_MONO360_VIEW = 3;
   // LINT.ThenChange(../../../../../../res/values/attrs.xml)
 
-  private final AspectRatioFrameLayout contentFrame;
+  @Nullable private final AspectRatioFrameLayout contentFrame;
   private final View shutterView;
-  private final View surfaceView;
+  @Nullable private final View surfaceView;
   private final ImageView artworkView;
   private final SubtitleView subtitleView;
-  private final @Nullable View bufferingView;
-  private final @Nullable TextView errorMessageView;
+  @Nullable private final View bufferingView;
+  @Nullable private final TextView errorMessageView;
   private final PlayerControlView controller;
   private final ComponentListener componentListener;
   private final FrameLayout overlayFrameLayout;
@@ -285,11 +285,11 @@
   private Player player;
   private boolean useController;
   private boolean useArtwork;
-  private @Nullable Drawable defaultArtwork;
+  @Nullable private Drawable defaultArtwork;
   private @ShowBuffering int showBuffering;
   private boolean keepContentOnPlayerReset;
-  private @Nullable ErrorMessageProvider<? super ExoPlaybackException> errorMessageProvider;
-  private @Nullable CharSequence customErrorMessage;
+  @Nullable private ErrorMessageProvider<? super ExoPlaybackException> errorMessageProvider;
+  @Nullable private CharSequence customErrorMessage;
   private int controllerShowTimeoutMs;
   private boolean controllerAutoShow;
   private boolean controllerHideDuringAds;
@@ -474,9 +474,7 @@ public PlayerView(Context context, AttributeSet attrs, int defStyleAttr) {
    * @param newPlayerView The new view to attach to the player.
    */
   public static void switchTargetView(
-      @NonNull Player player,
-      @Nullable PlayerView oldPlayerView,
-      @Nullable PlayerView newPlayerView) {
+      Player player, @Nullable PlayerView oldPlayerView, @Nullable PlayerView newPlayerView) {
     if (oldPlayerView == newPlayerView) {
       return;
     }
@@ -681,8 +679,9 @@ public void setShutterBackgroundColor(int color) {
   /**
    * Sets whether the currently displayed video frame or media artwork is kept visible when the
    * player is reset. A player reset is defined to mean the player being re-prepared with different
-   * media, {@link Player#stop(boolean)} being called with {@code reset=true}, or the player being
-   * replaced or cleared by calling {@link #setPlayer(Player)}.
+   * media, the player transitioning to unprepared media, {@link Player#stop(boolean)} being called
+   * with {@code reset=true}, or the player being replaced or cleared by calling {@link
+   * #setPlayer(Player)}.
    *
    * <p>If enabled, the currently displayed video frame or media artwork will be kept visible until
    * the player set on the view has been successfully prepared with new media and loaded enough of
@@ -1074,6 +1073,26 @@ public void onPause() {
     }
   }
 
+  /**
+   * Called when there's a change in the aspect ratio of the content being displayed. The default
+   * implementation sets the aspect ratio of the content frame to that of the content, unless the
+   * content view is a {@link SphericalSurfaceView} in which case the frame's aspect ratio is
+   * cleared.
+   *
+   * @param contentAspectRatio The aspect ratio of the content.
+   * @param contentFrame The content frame, or {@code null}.
+   * @param contentView The view that holds the content being displayed, or {@code null}.
+   */
+  protected void onContentAspectRatioChanged(
+      float contentAspectRatio,
+      @Nullable AspectRatioFrameLayout contentFrame,
+      @Nullable View contentView) {
+    if (contentFrame != null) {
+      contentFrame.setAspectRatio(
+          contentView instanceof SphericalSurfaceView ? 0 : contentAspectRatio);
+    }
+  }
+
   private boolean toggleControllerVisibility() {
     if (!useController || player == null) {
       return false;
@@ -1187,9 +1206,8 @@ private boolean setDrawableArtwork(@Nullable Drawable drawable) {
       int drawableWidth = drawable.getIntrinsicWidth();
       int drawableHeight = drawable.getIntrinsicHeight();
       if (drawableWidth > 0 && drawableHeight > 0) {
-        if (contentFrame != null) {
-          contentFrame.setAspectRatio((float) drawableWidth / drawableHeight);
-        }
+        float artworkAspectRatio = (float) drawableWidth / drawableHeight;
+        onContentAspectRatioChanged(artworkAspectRatio, contentFrame, artworkView);
         artworkView.setImageDrawable(drawable);
         artworkView.setVisibility(VISIBLE);
         return true;
@@ -1322,9 +1340,6 @@ public void onCues(List<Cue> cues) {
     @Override
     public void onVideoSizeChanged(
         int width, int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {
-      if (contentFrame == null) {
-        return;
-      }
       float videoAspectRatio =
           (height == 0 || width == 0) ? 1 : (width * pixelWidthHeightRatio) / height;
 
@@ -1345,11 +1360,9 @@ public void onVideoSizeChanged(
           surfaceView.addOnLayoutChangeListener(this);
         }
         applyTextureViewRotation((TextureView) surfaceView, textureViewRotation);
-      } else if (surfaceView instanceof SphericalSurfaceView) {
-        videoAspectRatio = 0;
       }
 
-      contentFrame.setAspectRatio(videoAspectRatio);
+      onContentAspectRatioChanged(videoAspectRatio, contentFrame, surfaceView);
     }
 
     @Override
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaSource.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaSource.java
index 2fca4f42c7..999372b90a 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaSource.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaSource.java
@@ -88,6 +88,13 @@ public FakeMediaSource(@Nullable Timeline timeline, Object manifest,
     this.trackGroupArray = trackGroupArray;
   }
 
+  @Override
+  @Nullable
+  public Object getTag() {
+    boolean hasTimeline = timeline != null && !timeline.isEmpty();
+    return hasTimeline ? timeline.getWindow(0, new Timeline.Window()).tag : null;
+  }
+
   @Override
   public synchronized void prepareSourceInternal(
       ExoPlayer player,
@@ -109,7 +116,7 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   }
 
   @Override
-  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
+  public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long startPositionUs) {
     assertThat(preparedSource).isTrue();
     assertThat(releasedSource).isFalse();
     int periodIndex = timeline.getIndexOfPeriod(id.periodUid);
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/MediaSourceTestRunner.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/MediaSourceTestRunner.java
index 70e7669dfb..e6fb5bc5f3 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/MediaSourceTestRunner.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/MediaSourceTestRunner.java
@@ -142,15 +142,28 @@ public Timeline prepareSource() throws IOException {
   }
 
   /**
-   * Calls {@link MediaSource#createPeriod(MediaSource.MediaPeriodId, Allocator)} on the playback
-   * thread, asserting that a non-null {@link MediaPeriod} is returned.
+   * Calls {@link MediaSource#createPeriod(MediaSource.MediaPeriodId, Allocator, long)} with a zero
+   * start position on the playback thread, asserting that a non-null {@link MediaPeriod} is
+   * returned.
    *
    * @param periodId The id of the period to create.
    * @return The created {@link MediaPeriod}.
    */
   public MediaPeriod createPeriod(final MediaPeriodId periodId) {
+    return createPeriod(periodId, /* startPositionUs= */ 0);
+  }
+
+  /**
+   * Calls {@link MediaSource#createPeriod(MediaSource.MediaPeriodId, Allocator, long)} on the
+   * playback thread, asserting that a non-null {@link MediaPeriod} is returned.
+   *
+   * @param periodId The id of the period to create.
+   * @return The created {@link MediaPeriod}.
+   */
+  public MediaPeriod createPeriod(final MediaPeriodId periodId, long startPositionUs) {
     final MediaPeriod[] holder = new MediaPeriod[1];
-    runOnPlaybackThread(() -> holder[0] = mediaSource.createPeriod(periodId, allocator));
+    runOnPlaybackThread(
+        () -> holder[0] = mediaSource.createPeriod(periodId, allocator, startPositionUs));
     assertThat(holder[0]).isNotNull();
     return holder[0];
   }
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/StubExoPlayer.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/StubExoPlayer.java
index 156b573df8..724ed366bc 100644
--- a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/StubExoPlayer.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/StubExoPlayer.java
@@ -49,6 +49,11 @@ public TextComponent getTextComponent() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
+  public MetadataComponent getMetadataComponent() {
+    throw new UnsupportedOperationException();
+  }
+
   @Override
   public Looper getPlaybackLooper() {
     throw new UnsupportedOperationException();
