diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
index 01c76a0efd..6487829d3b 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
@@ -18,6 +18,7 @@
 import android.util.Log;
 import android.util.SparseArray;
 import android.util.SparseBooleanArray;
+import android.util.SparseIntArray;
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.extractor.DummyTrackOutput;
 import com.google.android.exoplayer.extractor.Extractor;
@@ -72,6 +73,7 @@
   private final int workaroundFlags;
   private final ParsableByteArray tsPacketBuffer;
   private final ParsableBitArray tsScratch;
+  private final SparseIntArray continuityCounters;
   /* package */ final SparseArray<TsPayloadReader> tsPayloadReaders; // Indexed by pid
   /* package */ final SparseBooleanArray trackIds;
 
@@ -97,6 +99,7 @@ public TsExtractor(PtsTimestampAdjuster ptsTimestampAdjuster, int workaroundFlag
     tsPayloadReaders.put(TS_PAT_PID, new PatReader());
     trackIds = new SparseBooleanArray();
     nextEmbeddedTrackId = BASE_EMBEDDED_TRACK_ID;
+    continuityCounters = new SparseIntArray();
   }
 
   // Extractor implementation.
@@ -132,6 +135,7 @@ public void seek() {
       tsPayloadReaders.valueAt(i).seek();
     }
     tsPacketBuffer.reset();
+    continuityCounters.clear();
   }
 
   @Override
@@ -188,7 +192,17 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     tsScratch.skipBits(2); // transport_scrambling_control
     boolean adaptationFieldExists = tsScratch.readBit();
     boolean payloadExists = tsScratch.readBit();
-    // Last 4 bits of scratch are skipped: continuity_counter
+    boolean discontinuityFound = false;
+    int continuityCounter = tsScratch.readBits(4);
+    int previousCounter = continuityCounters.get(pid, continuityCounter - 1);
+    continuityCounters.put(pid, continuityCounter);
+    if (previousCounter == continuityCounter) {
+      // Duplicate packet found.
+      tsPacketBuffer.setPosition(endOfPacket);
+      return RESULT_CONTINUE;
+    } else if (continuityCounter != (previousCounter + 1) % 16) {
+      discontinuityFound = true;
+    }
 
     // Skip the adaptation field.
     if (adaptationFieldExists) {
@@ -200,6 +214,9 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     if (payloadExists) {
       TsPayloadReader payloadReader = tsPayloadReaders.get(pid);
       if (payloadReader != null) {
+        if (discontinuityFound) {
+          payloadReader.seek();
+        }
         tsPacketBuffer.setLimit(endOfPacket);
         payloadReader.consume(tsPacketBuffer, payloadUnitStartIndicator, output);
         Assertions.checkState(tsPacketBuffer.getPosition() <= endOfPacket);
