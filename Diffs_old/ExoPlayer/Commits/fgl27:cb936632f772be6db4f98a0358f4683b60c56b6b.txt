diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 7c934c478c..d166fb41c6 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -31,6 +31,13 @@
   `DefaultTrackSelector` to allow adaptive selections of audio tracks with
   different channel counts
   ([#6257](https://github.com/google/ExoPlayer/issues/6257)).
+* Reset `DefaultBandwidthMeter` to initial values on network change.
+* Increase maximum buffer size for video in `DefaultLoadControl` to ensure high
+  quality video can be loaded up to the full default buffer duration.
+* Replace `ExoPlayerFactory` by `SimpleExoPlayer.Builder` and
+  `ExoPlayer.Builder`.
+* Inject `DrmSessionManager` into the `MediaSources` instead of `Renderers`
+  ([#5619](https://github.com/google/ExoPlayer/issues/5619)).
 
 ### 2.10.4 ###
 
diff --git a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/PlayerManager.java b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/PlayerManager.java
index 8b75eb0c74..b1a12f6bc9 100644
--- a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/PlayerManager.java
+++ b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/PlayerManager.java
@@ -20,7 +20,6 @@
 import android.view.KeyEvent;
 import android.view.View;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Player.DiscontinuityReason;
 import com.google.android.exoplayer2.Player.EventListener;
@@ -119,7 +118,7 @@ public PlayerManager(
     mediaDrms = new IdentityHashMap<>();
 
     trackSelector = new DefaultTrackSelector(context);
-    exoPlayer = ExoPlayerFactory.newSimpleInstance(context, trackSelector);
+    exoPlayer = new SimpleExoPlayer.Builder(context).setTrackSelector(trackSelector).build();
     exoPlayer.addListener(this);
     localPlayerView.setPlayer(exoPlayer);
 
diff --git a/demos/gvr/src/main/java/com/google/android/exoplayer2/gvrdemo/PlayerActivity.java b/demos/gvr/src/main/java/com/google/android/exoplayer2/gvrdemo/PlayerActivity.java
index 059f26b374..15cc9b6469 100644
--- a/demos/gvr/src/main/java/com/google/android/exoplayer2/gvrdemo/PlayerActivity.java
+++ b/demos/gvr/src/main/java/com/google/android/exoplayer2/gvrdemo/PlayerActivity.java
@@ -24,7 +24,6 @@
 import com.google.android.exoplayer2.C.ContentType;
 import com.google.android.exoplayer2.DefaultRenderersFactory;
 import com.google.android.exoplayer2.ExoPlaybackException;
-import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.PlaybackPreparer;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.SimpleExoPlayer;
@@ -138,7 +137,9 @@ private void initializePlayer() {
       lastSeenTrackGroupArray = null;
 
       player =
-          ExoPlayerFactory.newSimpleInstance(/* context= */ this, renderersFactory, trackSelector);
+          new SimpleExoPlayer.Builder(/* context= */ this, renderersFactory)
+              .setTrackSelector(trackSelector)
+              .build();
       player.addListener(new PlayerEventListener());
       player.setPlayWhenReady(startAutoPlay);
       player.addAnalyticsListener(new EventLogger(trackSelector));
diff --git a/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java b/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java
index 8f2c891e3a..3caf7f0c16 100644
--- a/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java
+++ b/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java
@@ -20,7 +20,6 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.C.ContentType;
 import com.google.android.exoplayer2.ExoPlayer;
-import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.SimpleExoPlayer;
 import com.google.android.exoplayer2.ext.ima.ImaAdsLoader;
 import com.google.android.exoplayer2.source.MediaSource;
@@ -54,7 +53,7 @@ public PlayerManager(Context context) {
 
   public void init(Context context, PlayerView playerView) {
     // Create a player instance.
-    player = ExoPlayerFactory.newSimpleInstance(context);
+    player = new SimpleExoPlayer.Builder(context).build();
     adsLoader.setPlayer(player);
     playerView.setPlayer(player);
 
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
index 1e231dd45e..d3c32ac957 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
@@ -33,7 +33,6 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.C.ContentType;
 import com.google.android.exoplayer2.ExoPlaybackException;
-import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.PlaybackPreparer;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.RenderersFactory;
@@ -371,7 +370,9 @@ private void initializePlayer() {
       lastSeenTrackGroupArray = null;
 
       player =
-          ExoPlayerFactory.newSimpleInstance(/* context= */ this, renderersFactory, trackSelector);
+          new SimpleExoPlayer.Builder(/* context= */ this, renderersFactory)
+              .setTrackSelector(trackSelector)
+              .build();
       player.addListener(new PlayerEventListener());
       player.setPlayWhenReady(startAutoPlay);
       player.addAnalyticsListener(new EventLogger(trackSelector));
diff --git a/extensions/ffmpeg/README.md b/extensions/ffmpeg/README.md
index 5b68f1e352..dd9ce38d35 100644
--- a/extensions/ffmpeg/README.md
+++ b/extensions/ffmpeg/README.md
@@ -122,22 +122,22 @@ Once you've followed the instructions above to check out, build and depend on
 the extension, the next step is to tell ExoPlayer to use `FfmpegAudioRenderer`.
 How you do this depends on which player API you're using:
 
-* If you're passing a `DefaultRenderersFactory` to
-  `ExoPlayerFactory.newSimpleInstance`, you can enable using the extension by
-  setting the `extensionRendererMode` parameter of the `DefaultRenderersFactory`
-  constructor to `EXTENSION_RENDERER_MODE_ON`. This will use
-  `FfmpegAudioRenderer` for playback if `MediaCodecAudioRenderer` doesn't
-  support the input format. Pass `EXTENSION_RENDERER_MODE_PREFER` to give
-  `FfmpegAudioRenderer` priority over `MediaCodecAudioRenderer`.
+* If you're passing a `DefaultRenderersFactory` to `SimpleExoPlayer.Builder`,
+  you can enable using the extension by setting the `extensionRendererMode`
+  parameter of the `DefaultRenderersFactory` constructor to
+  `EXTENSION_RENDERER_MODE_ON`. This will use `FfmpegAudioRenderer` for playback
+  if `MediaCodecAudioRenderer` doesn't support the input format. Pass
+  `EXTENSION_RENDERER_MODE_PREFER` to give `FfmpegAudioRenderer` priority over
+  `MediaCodecAudioRenderer`.
 * If you've subclassed `DefaultRenderersFactory`, add an `FfmpegAudioRenderer`
   to the output list in `buildAudioRenderers`. ExoPlayer will use the first
   `Renderer` in the list that supports the input media format.
 * If you've implemented your own `RenderersFactory`, return an
   `FfmpegAudioRenderer` instance from `createRenderers`. ExoPlayer will use the
   first `Renderer` in the returned array that supports the input media format.
-* If you're using `ExoPlayerFactory.newInstance`, pass an `FfmpegAudioRenderer`
-  in the array of `Renderer`s. ExoPlayer will use the first `Renderer` in the
-  list that supports the input media format.
+* If you're using `ExoPlayer.Builder`, pass an `FfmpegAudioRenderer` in the
+  array of `Renderer`s. ExoPlayer will use the first `Renderer` in the list that
+  supports the input media format.
 
 Note: These instructions assume you're using `DefaultTrackSelector`. If you have
 a custom track selector the choice of `Renderer` is up to your implementation,
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
index c78b02aa5b..5314835d1e 100644
--- a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
@@ -24,6 +24,7 @@
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.Util;
 import java.nio.ByteBuffer;
 import java.util.List;
 
@@ -106,7 +107,7 @@ protected FfmpegDecoderException createUnexpectedDecodeException(Throwable error
         return new FfmpegDecoderException("Error resetting (see logcat).");
       }
     }
-    ByteBuffer inputData = inputBuffer.data;
+    ByteBuffer inputData = Util.castNonNull(inputBuffer.data);
     int inputSize = inputData.limit();
     ByteBuffer outputData = outputBuffer.init(inputBuffer.timeUs, outputBufferSize);
     int result = ffmpegDecode(nativeContext, inputData, inputSize, outputData, outputBufferSize);
@@ -132,8 +133,8 @@ protected FfmpegDecoderException createUnexpectedDecodeException(Throwable error
       }
       hasOutputFormat = true;
     }
-    outputBuffer.data.position(0);
-    outputBuffer.data.limit(result);
+    outputData.position(0);
+    outputData.limit(result);
     return null;
   }
 
diff --git a/extensions/flac/README.md b/extensions/flac/README.md
index 78035f4d87..b4b0dae002 100644
--- a/extensions/flac/README.md
+++ b/extensions/flac/README.md
@@ -68,22 +68,22 @@ renderer.
 
 ### Using `LibflacAudioRenderer` ###
 
-* If you're passing a `DefaultRenderersFactory` to
-  `ExoPlayerFactory.newSimpleInstance`, you can enable using the extension by
-  setting the `extensionRendererMode` parameter of the `DefaultRenderersFactory`
-  constructor to `EXTENSION_RENDERER_MODE_ON`. This will use
-  `LibflacAudioRenderer` for playback if `MediaCodecAudioRenderer` doesn't
-  support the input format. Pass `EXTENSION_RENDERER_MODE_PREFER` to give
-  `LibflacAudioRenderer` priority over `MediaCodecAudioRenderer`.
+* If you're passing a `DefaultRenderersFactory` to `SimpleExoPlayer.Builder`,
+  you can enable using the extension by setting the `extensionRendererMode`
+  parameter of the `DefaultRenderersFactory` constructor to
+  `EXTENSION_RENDERER_MODE_ON`. This will use `LibflacAudioRenderer` for
+  playback if `MediaCodecAudioRenderer` doesn't support the input format. Pass
+  `EXTENSION_RENDERER_MODE_PREFER` to give `LibflacAudioRenderer` priority over
+  `MediaCodecAudioRenderer`.
 * If you've subclassed `DefaultRenderersFactory`, add a `LibflacAudioRenderer`
   to the output list in `buildAudioRenderers`. ExoPlayer will use the first
   `Renderer` in the list that supports the input media format.
 * If you've implemented your own `RenderersFactory`, return a
   `LibflacAudioRenderer` instance from `createRenderers`. ExoPlayer will use the
   first `Renderer` in the returned array that supports the input media format.
-* If you're using `ExoPlayerFactory.newInstance`, pass a `LibflacAudioRenderer`
-  in the array of `Renderer`s. ExoPlayer will use the first `Renderer` in the
-  list that supports the input media format.
+* If you're using `ExoPlayer.Builder`, pass a `LibflacAudioRenderer` in the
+  array of `Renderer`s. ExoPlayer will use the first `Renderer` in the list that
+  supports the input media format.
 
 Note: These instructions assume you're using `DefaultTrackSelector`. If you have
 a custom track selector the choice of `Renderer` is up to your implementation,
diff --git a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java
index c10d6fdb27..bf96442f61 100644
--- a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java
+++ b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java
@@ -24,13 +24,10 @@
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
-import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.Player;
-import com.google.android.exoplayer2.Renderer;
 import com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.ProgressiveMediaSource;
-import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
 import org.junit.Before;
 import org.junit.Test;
@@ -82,8 +79,7 @@ public TestPlaybackRunnable(Uri uri, Context context) {
     public void run() {
       Looper.prepare();
       LibflacAudioRenderer audioRenderer = new LibflacAudioRenderer();
-      DefaultTrackSelector trackSelector = new DefaultTrackSelector(context);
-      player = ExoPlayerFactory.newInstance(context, new Renderer[] {audioRenderer}, trackSelector);
+      player = new ExoPlayer.Builder(context, audioRenderer).build();
       player.addListener(this);
       MediaSource mediaSource =
           new ProgressiveMediaSource.Factory(
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoder.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoder.java
index 50eb048d98..890d82a006 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoder.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoder.java
@@ -22,6 +22,7 @@
 import com.google.android.exoplayer2.decoder.SimpleDecoder;
 import com.google.android.exoplayer2.decoder.SimpleOutputBuffer;
 import com.google.android.exoplayer2.util.FlacStreamMetadata;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.List;
@@ -101,7 +102,7 @@ protected FlacDecoderException decode(
     if (reset) {
       decoderJni.flush();
     }
-    decoderJni.setData(inputBuffer.data);
+    decoderJni.setData(Util.castNonNull(inputBuffer.data));
     ByteBuffer outputData = outputBuffer.init(inputBuffer.timeUs, maxOutputBufferSize);
     try {
       decoderJni.decodeSample(outputData);
diff --git a/extensions/opus/README.md b/extensions/opus/README.md
index 95c6807275..af44e84b04 100644
--- a/extensions/opus/README.md
+++ b/extensions/opus/README.md
@@ -71,22 +71,22 @@ Once you've followed the instructions above to check out, build and depend on
 the extension, the next step is to tell ExoPlayer to use `LibopusAudioRenderer`.
 How you do this depends on which player API you're using:
 
-* If you're passing a `DefaultRenderersFactory` to
-  `ExoPlayerFactory.newSimpleInstance`, you can enable using the extension by
-  setting the `extensionRendererMode` parameter of the `DefaultRenderersFactory`
-  constructor to `EXTENSION_RENDERER_MODE_ON`. This will use
-  `LibopusAudioRenderer` for playback if `MediaCodecAudioRenderer` doesn't
-  support the input format. Pass `EXTENSION_RENDERER_MODE_PREFER` to give
-  `LibopusAudioRenderer` priority over `MediaCodecAudioRenderer`.
+* If you're passing a `DefaultRenderersFactory` to `SimpleExoPlayer.Builder`,
+  you can enable using the extension by setting the `extensionRendererMode`
+  parameter of the `DefaultRenderersFactory` constructor to
+  `EXTENSION_RENDERER_MODE_ON`. This will use `LibopusAudioRenderer` for
+  playback if `MediaCodecAudioRenderer` doesn't support the input format. Pass
+  `EXTENSION_RENDERER_MODE_PREFER` to give `LibopusAudioRenderer` priority over
+  `MediaCodecAudioRenderer`.
 * If you've subclassed `DefaultRenderersFactory`, add a `LibopusAudioRenderer`
   to the output list in `buildAudioRenderers`. ExoPlayer will use the first
   `Renderer` in the list that supports the input media format.
 * If you've implemented your own `RenderersFactory`, return a
   `LibopusAudioRenderer` instance from `createRenderers`. ExoPlayer will use the
   first `Renderer` in the returned array that supports the input media format.
-* If you're using `ExoPlayerFactory.newInstance`, pass a `LibopusAudioRenderer`
-  in the array of `Renderer`s. ExoPlayer will use the first `Renderer` in the
-  list that supports the input media format.
+* If you're using `ExoPlayer.Builder`, pass a `LibopusAudioRenderer` in the
+  array of `Renderer`s. ExoPlayer will use the first `Renderer` in the list that
+  supports the input media format.
 
 Note: These instructions assume you're using `DefaultTrackSelector`. If you have
 a custom track selector the choice of `Renderer` is up to your implementation,
diff --git a/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java b/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java
index 382ee38e06..b3d5b525d5 100644
--- a/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java
+++ b/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java
@@ -24,13 +24,10 @@
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
-import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.Player;
-import com.google.android.exoplayer2.Renderer;
 import com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.ProgressiveMediaSource;
-import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
 import org.junit.Before;
 import org.junit.Test;
@@ -82,8 +79,7 @@ public TestPlaybackRunnable(Uri uri, Context context) {
     public void run() {
       Looper.prepare();
       LibopusAudioRenderer audioRenderer = new LibopusAudioRenderer();
-      DefaultTrackSelector trackSelector = new DefaultTrackSelector(context);
-      player = ExoPlayerFactory.newInstance(context, new Renderer[] {audioRenderer}, trackSelector);
+      player = new ExoPlayer.Builder(context, audioRenderer).build();
       player.addListener(this);
       MediaSource mediaSource =
           new ProgressiveMediaSource.Factory(
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoder.java b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoder.java
index d93036113c..f0e993e3b9 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoder.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoder.java
@@ -23,6 +23,7 @@
 import com.google.android.exoplayer2.decoder.SimpleOutputBuffer;
 import com.google.android.exoplayer2.drm.DecryptionException;
 import com.google.android.exoplayer2.drm.ExoMediaCrypto;
+import com.google.android.exoplayer2.util.Util;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.util.List;
@@ -165,7 +166,7 @@ protected OpusDecoderException decode(
       // any other time, skip number of samples as specified by seek preroll.
       skipSamples = (inputBuffer.timeUs == 0) ? headerSkipSamples : headerSeekPreRollSamples;
     }
-    ByteBuffer inputData = inputBuffer.data;
+    ByteBuffer inputData = Util.castNonNull(inputBuffer.data);
     CryptoInfo cryptoInfo = inputBuffer.cryptoInfo;
     int result = inputBuffer.isEncrypted()
         ? opusSecureDecode(nativeDecoderContext, inputBuffer.timeUs, inputData, inputData.limit(),
@@ -185,7 +186,7 @@ protected OpusDecoderException decode(
       }
     }
 
-    ByteBuffer outputData = outputBuffer.data;
+    ByteBuffer outputData = Util.castNonNull(outputBuffer.data);
     outputData.position(0);
     outputData.limit(result);
     if (skipSamples > 0) {
diff --git a/extensions/vp9/README.md b/extensions/vp9/README.md
index be75eae359..34230db2ec 100644
--- a/extensions/vp9/README.md
+++ b/extensions/vp9/README.md
@@ -85,22 +85,22 @@ Once you've followed the instructions above to check out, build and depend on
 the extension, the next step is to tell ExoPlayer to use `LibvpxVideoRenderer`.
 How you do this depends on which player API you're using:
 
-* If you're passing a `DefaultRenderersFactory` to
-  `ExoPlayerFactory.newSimpleInstance`, you can enable using the extension by
-  setting the `extensionRendererMode` parameter of the `DefaultRenderersFactory`
-  constructor to `EXTENSION_RENDERER_MODE_ON`. This will use
-  `LibvpxVideoRenderer` for playback if `MediaCodecVideoRenderer` doesn't
-  support decoding the input VP9 stream. Pass `EXTENSION_RENDERER_MODE_PREFER`
-  to give `LibvpxVideoRenderer` priority over `MediaCodecVideoRenderer`.
+* If you're passing a `DefaultRenderersFactory` to `SimpleExoPlayer.Builder`,
+  you can enable using the extension by setting the `extensionRendererMode`
+  parameter of the `DefaultRenderersFactory` constructor to
+  `EXTENSION_RENDERER_MODE_ON`. This will use `LibvpxVideoRenderer` for playback
+  if `MediaCodecVideoRenderer` doesn't support decoding the input VP9 stream.
+  Pass `EXTENSION_RENDERER_MODE_PREFER` to give `LibvpxVideoRenderer` priority
+  over `MediaCodecVideoRenderer`.
 * If you've subclassed `DefaultRenderersFactory`, add a `LibvpxVideoRenderer`
   to the output list in `buildVideoRenderers`. ExoPlayer will use the first
   `Renderer` in the list that supports the input media format.
 * If you've implemented your own `RenderersFactory`, return a
   `LibvpxVideoRenderer` instance from `createRenderers`. ExoPlayer will use the
   first `Renderer` in the returned array that supports the input media format.
-* If you're using `ExoPlayerFactory.newInstance`, pass a `LibvpxVideoRenderer`
-  in the array of `Renderer`s. ExoPlayer will use the first `Renderer` in the
-  list that supports the input media format.
+* If you're using `ExoPlayer.Builder`, pass a `LibvpxVideoRenderer` in the array
+  of `Renderer`s. ExoPlayer will use the first `Renderer` in the list that
+  supports the input media format.
 
 Note: These instructions assume you're using `DefaultTrackSelector`. If you have
 a custom track selector the choice of `Renderer` is up to your implementation,
diff --git a/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java b/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
index 9be1d9c0e5..d4e0795293 100644
--- a/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
+++ b/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
@@ -25,13 +25,10 @@
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
-import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.Player;
-import com.google.android.exoplayer2.Renderer;
 import com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.ProgressiveMediaSource;
-import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
 import com.google.android.exoplayer2.util.Log;
 import org.junit.Before;
@@ -115,8 +112,7 @@ public TestPlaybackRunnable(Uri uri, Context context) {
     public void run() {
       Looper.prepare();
       LibvpxVideoRenderer videoRenderer = new LibvpxVideoRenderer(0);
-      DefaultTrackSelector trackSelector = new DefaultTrackSelector(context);
-      player = ExoPlayerFactory.newInstance(context, new Renderer[] {videoRenderer}, trackSelector);
+      player = new ExoPlayer.Builder(context, videoRenderer).build();
       player.addListener(this);
       MediaSource mediaSource =
           new ProgressiveMediaSource.Factory(
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
index b000ea1b6b..dd4077964b 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
@@ -18,37 +18,25 @@
 import static java.lang.Runtime.getRuntime;
 
 import android.os.Handler;
-import android.os.Looper;
-import android.os.SystemClock;
-import androidx.annotation.CallSuper;
-import androidx.annotation.IntDef;
 import androidx.annotation.Nullable;
 import android.view.Surface;
-import com.google.android.exoplayer2.BaseRenderer;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.FormatHolder;
 import com.google.android.exoplayer2.PlayerMessage.Target;
-import com.google.android.exoplayer2.decoder.DecoderCounters;
-import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
-import com.google.android.exoplayer2.drm.DrmSession;
-import com.google.android.exoplayer2.drm.DrmSession.DrmSessionException;
+import com.google.android.exoplayer2.decoder.SimpleDecoder;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.ExoMediaCrypto;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
-import com.google.android.exoplayer2.util.TimedValueQueue;
 import com.google.android.exoplayer2.util.TraceUtil;
-import com.google.android.exoplayer2.util.Util;
+import com.google.android.exoplayer2.video.SimpleDecoderVideoRenderer;
+import com.google.android.exoplayer2.video.VideoDecoderException;
 import com.google.android.exoplayer2.video.VideoDecoderInputBuffer;
+import com.google.android.exoplayer2.video.VideoDecoderOutputBuffer;
 import com.google.android.exoplayer2.video.VideoFrameMetadataListener;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
-import com.google.android.exoplayer2.video.VideoRendererEventListener.EventDispatcher;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
 
 /**
  * Decodes and renders video using the native VP9 decoder.
@@ -64,32 +52,7 @@
  *       null.
  * </ul>
  */
-public class LibvpxVideoRenderer extends BaseRenderer {
-
-  @Documented
-  @Retention(RetentionPolicy.SOURCE)
-  @IntDef({
-    REINITIALIZATION_STATE_NONE,
-    REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM,
-    REINITIALIZATION_STATE_WAIT_END_OF_STREAM
-  })
-  private @interface ReinitializationState {}
-  /**
-   * The decoder does not need to be re-initialized.
-   */
-  private static final int REINITIALIZATION_STATE_NONE = 0;
-  /**
-   * The input format has changed in a way that requires the decoder to be re-initialized, but we
-   * haven't yet signaled an end of stream to the existing decoder. We need to do so in order to
-   * ensure that it outputs any remaining buffers before we release it.
-   */
-  private static final int REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM = 1;
-  /**
-   * The input format has changed in a way that requires the decoder to be re-initialized, and we've
-   * signaled an end of stream to the existing decoder. We're waiting for the decoder to output an
-   * end of stream signal to indicate that it has output any remaining buffers before we release it.
-   */
-  private static final int REINITIALIZATION_STATE_WAIT_END_OF_STREAM = 2;
+public class LibvpxVideoRenderer extends SimpleDecoderVideoRenderer {
 
   /**
    * The type of a message that can be passed to an instance of this class via {@link
@@ -105,56 +68,25 @@
    * requiring multiple output buffers to be dequeued at a time for it to make progress.
    */
   private final int numOutputBuffers;
-  /** The default input buffer size. */
-  private static final int DEFAULT_INPUT_BUFFER_SIZE = 768 * 1024; // Value based on cs/SoftVpx.cpp.
+  /**
+   * The default input buffer size. The value is based on <a
+   * href="https://android.googlesource.com/platform/frameworks/av/+/d42b90c5183fbd9d6a28d9baee613fddbf8131d6/media/libstagefright/codecs/on2/dec/SoftVPX.cpp">SoftVPX.cpp</a>.
+   */
+  private static final int DEFAULT_INPUT_BUFFER_SIZE = 768 * 1024;
 
   private final boolean enableRowMultiThreadMode;
   private final boolean disableLoopFilter;
-  private final long allowedJoiningTimeMs;
-  private final int maxDroppedFramesToNotify;
-  private final boolean playClearSamplesWithoutKeys;
-  private final EventDispatcher eventDispatcher;
-  private final FormatHolder formatHolder;
-  private final TimedValueQueue<Format> formatQueue;
-  private final DecoderInputBuffer flagsOnlyBuffer;
-  private final DrmSessionManager<ExoMediaCrypto> drmSessionManager;
   private final int threads;
 
-  private Format format;
-  private Format pendingFormat;
-  private Format outputFormat;
-  private VpxDecoder decoder;
-  private VideoDecoderInputBuffer inputBuffer;
-  private VpxOutputBuffer outputBuffer;
-  @Nullable private DrmSession<ExoMediaCrypto> decoderDrmSession;
-  @Nullable private DrmSession<ExoMediaCrypto> sourceDrmSession;
-
-  private @ReinitializationState int decoderReinitializationState;
-  private boolean decoderReceivedBuffers;
-
-  private boolean renderedFirstFrame;
-  private long initialPositionUs;
-  private long joiningDeadlineMs;
   private Surface surface;
   private VpxOutputBufferRenderer outputBufferRenderer;
   @C.VideoOutputMode private int outputMode;
-  private boolean waitingForKeys;
 
-  private boolean inputStreamEnded;
-  private boolean outputStreamEnded;
-  private int reportedWidth;
-  private int reportedHeight;
+  private VpxDecoder decoder;
+  private VpxOutputBuffer outputBuffer;
 
-  private long droppedFrameAccumulationStartTimeMs;
-  private int droppedFrames;
-  private int consecutiveDroppedFrameCount;
-  private int buffersInCodecCount;
-  private long lastRenderTimeUs;
-  private long outputStreamOffsetUs;
   private VideoFrameMetadataListener frameMetadataListener;
 
-  protected DecoderCounters decoderCounters;
-
   /**
    * @param allowedJoiningTimeMs The maximum duration in milliseconds for which this video renderer
    *     can attempt to seamlessly join an ongoing playback.
@@ -259,30 +191,24 @@ public LibvpxVideoRenderer(
       int threads,
       int numInputBuffers,
       int numOutputBuffers) {
-    super(C.TRACK_TYPE_VIDEO);
+    super(
+        allowedJoiningTimeMs,
+        eventHandler,
+        eventListener,
+        maxDroppedFramesToNotify,
+        drmSessionManager,
+        playClearSamplesWithoutKeys);
     this.disableLoopFilter = disableLoopFilter;
-    this.allowedJoiningTimeMs = allowedJoiningTimeMs;
-    this.maxDroppedFramesToNotify = maxDroppedFramesToNotify;
-    this.drmSessionManager = drmSessionManager;
-    this.playClearSamplesWithoutKeys = playClearSamplesWithoutKeys;
     this.enableRowMultiThreadMode = enableRowMultiThreadMode;
     this.threads = threads;
     this.numInputBuffers = numInputBuffers;
     this.numOutputBuffers = numOutputBuffers;
-    joiningDeadlineMs = C.TIME_UNSET;
-    clearReportedVideoSize();
-    formatHolder = new FormatHolder();
-    formatQueue = new TimedValueQueue<>();
-    flagsOnlyBuffer = DecoderInputBuffer.newFlagsOnlyInstance();
-    eventDispatcher = new EventDispatcher(eventHandler, eventListener);
     outputMode = C.VIDEO_OUTPUT_MODE_NONE;
-    decoderReinitializationState = REINITIALIZATION_STATE_NONE;
   }
 
-  // BaseRenderer implementation.
-
   @Override
-  public int supportsFormat(Format format) {
+  protected int supportsFormatInternal(
+      @Nullable DrmSessionManager<ExoMediaCrypto> drmSessionManager, Format format) {
     if (!VpxLibrary.isAvailable() || !MimeTypes.VIDEO_VP9.equalsIgnoreCase(format.sampleMimeType)) {
       return FORMAT_UNSUPPORTED_TYPE;
     }
@@ -298,340 +224,47 @@ public int supportsFormat(Format format) {
   }
 
   @Override
-  public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
-    if (outputStreamEnded) {
-      return;
-    }
-
-    if (format == null) {
-      // We don't have a format yet, so try and read one.
-      flagsOnlyBuffer.clear();
-      int result = readSource(formatHolder, flagsOnlyBuffer, true);
-      if (result == C.RESULT_FORMAT_READ) {
-        onInputFormatChanged(formatHolder);
-      } else if (result == C.RESULT_BUFFER_READ) {
-        // End of stream read having not read a format.
-        Assertions.checkState(flagsOnlyBuffer.isEndOfStream());
-        inputStreamEnded = true;
-        outputStreamEnded = true;
-        return;
-      } else {
-        // We still don't have a format and can't make progress without one.
-        return;
-      }
-    }
-
-    // If we don't have a decoder yet, we need to instantiate one.
-    maybeInitDecoder();
-
-    if (decoder != null) {
-      try {
-        // Rendering loop.
-        TraceUtil.beginSection("drainAndFeed");
-        while (drainOutputBuffer(positionUs, elapsedRealtimeUs)) {}
-        while (feedInputBuffer()) {}
-        TraceUtil.endSection();
-      } catch (VpxDecoderException e) {
-        throw ExoPlaybackException.createForRenderer(e, getIndex());
-      }
-      decoderCounters.ensureUpdated();
-    }
-  }
-
-
-  @Override
-  public boolean isEnded() {
-    return outputStreamEnded;
-  }
-
-  @Override
-  public boolean isReady() {
-    if (waitingForKeys) {
-      return false;
-    }
-    if (format != null
-        && (isSourceReady() || outputBuffer != null)
-        && (renderedFirstFrame || outputMode == C.VIDEO_OUTPUT_MODE_NONE)) {
-      // Ready. If we were joining then we've now joined, so clear the joining deadline.
-      joiningDeadlineMs = C.TIME_UNSET;
-      return true;
-    } else if (joiningDeadlineMs == C.TIME_UNSET) {
-      // Not joining.
-      return false;
-    } else if (SystemClock.elapsedRealtime() < joiningDeadlineMs) {
-      // Joining and still within the joining deadline.
-      return true;
-    } else {
-      // The joining deadline has been exceeded. Give up and clear the deadline.
-      joiningDeadlineMs = C.TIME_UNSET;
-      return false;
-    }
-  }
-
-  @Override
-  protected void onEnabled(boolean joining) throws ExoPlaybackException {
-    decoderCounters = new DecoderCounters();
-    eventDispatcher.enabled(decoderCounters);
-  }
-
-  @Override
-  protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {
-    inputStreamEnded = false;
-    outputStreamEnded = false;
-    clearRenderedFirstFrame();
-    initialPositionUs = C.TIME_UNSET;
-    consecutiveDroppedFrameCount = 0;
-    if (decoder != null) {
-      flushDecoder();
-    }
-    if (joining) {
-      setJoiningDeadlineMs();
-    } else {
-      joiningDeadlineMs = C.TIME_UNSET;
-    }
-    formatQueue.clear();
-  }
-
-  @Override
-  protected void onStarted() {
-    droppedFrames = 0;
-    droppedFrameAccumulationStartTimeMs = SystemClock.elapsedRealtime();
-    lastRenderTimeUs = SystemClock.elapsedRealtime() * 1000;
-  }
-
-  @Override
-  protected void onStopped() {
-    joiningDeadlineMs = C.TIME_UNSET;
-    maybeNotifyDroppedFrames();
+  protected SimpleDecoder<
+          VideoDecoderInputBuffer,
+          ? extends VideoDecoderOutputBuffer,
+          ? extends VideoDecoderException>
+      createDecoder(Format format, @Nullable ExoMediaCrypto mediaCrypto)
+          throws VideoDecoderException {
+    TraceUtil.beginSection("createVpxDecoder");
+    int initialInputBufferSize =
+        format.maxInputSize != Format.NO_VALUE ? format.maxInputSize : DEFAULT_INPUT_BUFFER_SIZE;
+    decoder =
+        new VpxDecoder(
+            numInputBuffers,
+            numOutputBuffers,
+            initialInputBufferSize,
+            mediaCrypto,
+            disableLoopFilter,
+            enableRowMultiThreadMode,
+            threads);
+    decoder.setOutputMode(outputMode);
+    TraceUtil.endSection();
+    return decoder;
   }
 
   @Override
-  protected void onDisabled() {
-    format = null;
-    waitingForKeys = false;
-    clearReportedVideoSize();
-    clearRenderedFirstFrame();
-    try {
-      setSourceDrmSession(null);
-      releaseDecoder();
-    } finally {
-      eventDispatcher.disabled(decoderCounters);
-    }
+  @Nullable
+  protected VideoDecoderOutputBuffer dequeueOutputBuffer() throws VpxDecoderException {
+    outputBuffer = decoder.dequeueOutputBuffer();
+    return outputBuffer;
   }
 
   @Override
-  protected void onStreamChanged(Format[] formats, long offsetUs) throws ExoPlaybackException {
-    outputStreamOffsetUs = offsetUs;
-    super.onStreamChanged(formats, offsetUs);
-  }
-
-  /**
-   * Called when a decoder has been created and configured.
-   *
-   * <p>The default implementation is a no-op.
-   *
-   * @param name The name of the decoder that was initialized.
-   * @param initializedTimestampMs {@link SystemClock#elapsedRealtime()} when initialization
-   *     finished.
-   * @param initializationDurationMs The time taken to initialize the decoder, in milliseconds.
-   */
-  @CallSuper
-  protected void onDecoderInitialized(
-      String name, long initializedTimestampMs, long initializationDurationMs) {
-    eventDispatcher.decoderInitialized(name, initializedTimestampMs, initializationDurationMs);
-  }
-
-  /**
-   * Flushes the decoder.
-   *
-   * @throws ExoPlaybackException If an error occurs reinitializing a decoder.
-   */
-  @CallSuper
-  protected void flushDecoder() throws ExoPlaybackException {
-    waitingForKeys = false;
-    buffersInCodecCount = 0;
-    if (decoderReinitializationState != REINITIALIZATION_STATE_NONE) {
-      releaseDecoder();
-      maybeInitDecoder();
-    } else {
-      inputBuffer = null;
-      if (outputBuffer != null) {
-        outputBuffer.release();
-        outputBuffer = null;
-      }
-      decoder.flush();
-      decoderReceivedBuffers = false;
-    }
-  }
-
-  /** Releases the decoder. */
-  @CallSuper
-  protected void releaseDecoder() {
-    inputBuffer = null;
-    outputBuffer = null;
-    decoderReinitializationState = REINITIALIZATION_STATE_NONE;
-    decoderReceivedBuffers = false;
-    buffersInCodecCount = 0;
-    if (decoder != null) {
-      decoder.release();
-      decoder = null;
-      decoderCounters.decoderReleaseCount++;
-    }
-    setDecoderDrmSession(null);
-  }
-
-  private void setSourceDrmSession(@Nullable DrmSession<ExoMediaCrypto> session) {
-    DrmSession.replaceSessionReferences(sourceDrmSession, session);
-    sourceDrmSession = session;
-  }
-
-  private void setDecoderDrmSession(@Nullable DrmSession<ExoMediaCrypto> session) {
-    DrmSession.replaceSessionReferences(decoderDrmSession, session);
-    decoderDrmSession = session;
-  }
-
-  /**
-   * Called when a new format is read from the upstream source.
-   *
-   * @param formatHolder A {@link FormatHolder} that holds the new {@link Format}.
-   * @throws ExoPlaybackException If an error occurs (re-)initializing the decoder.
-   */
-  @CallSuper
-  @SuppressWarnings("unchecked")
-  protected void onInputFormatChanged(FormatHolder formatHolder) throws ExoPlaybackException {
-    Format oldFormat = format;
-    format = formatHolder.format;
-    pendingFormat = format;
-
-    boolean drmInitDataChanged = !Util.areEqual(format.drmInitData, oldFormat == null ? null
-        : oldFormat.drmInitData);
-    if (drmInitDataChanged) {
-      if (format.drmInitData != null) {
-        if (formatHolder.includesDrmSession) {
-          setSourceDrmSession((DrmSession<ExoMediaCrypto>) formatHolder.drmSession);
-        } else {
-          if (drmSessionManager == null) {
-            throw ExoPlaybackException.createForRenderer(
-                new IllegalStateException("Media requires a DrmSessionManager"), getIndex());
-          }
-          DrmSession<ExoMediaCrypto> session =
-              drmSessionManager.acquireSession(Looper.myLooper(), format.drmInitData);
-          if (sourceDrmSession != null) {
-            sourceDrmSession.releaseReference();
-          }
-          sourceDrmSession = session;
-        }
-      } else {
-        setSourceDrmSession(null);
-      }
+  protected void renderOutputBuffer(long presentationTimeUs, Format outputFormat)
+      throws VpxDecoderException {
+    if (frameMetadataListener != null) {
+      frameMetadataListener.onVideoFrameAboutToBeRendered(
+          presentationTimeUs, System.nanoTime(), outputFormat);
     }
 
-    if (sourceDrmSession != decoderDrmSession) {
-      if (decoderReceivedBuffers) {
-        // Signal end of stream and wait for any final output buffers before re-initialization.
-        decoderReinitializationState = REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM;
-      } else {
-        // There aren't any final output buffers, so release the decoder immediately.
-        releaseDecoder();
-        maybeInitDecoder();
-      }
-    }
-
-    eventDispatcher.inputFormatChanged(format);
-  }
-
-  /**
-   * Called immediately before an input buffer is queued into the decoder.
-   *
-   * <p>The default implementation is a no-op.
-   *
-   * @param buffer The buffer that will be queued.
-   */
-  protected void onQueueInputBuffer(VideoDecoderInputBuffer buffer) {
-    // Do nothing.
-  }
-
-  /**
-   * Called when an output buffer is successfully processed.
-   *
-   * @param presentationTimeUs The timestamp associated with the output buffer.
-   */
-  @CallSuper
-  protected void onProcessedOutputBuffer(long presentationTimeUs) {
-    buffersInCodecCount--;
-  }
-
-  /**
-   * Returns whether the buffer being processed should be dropped.
-   *
-   * @param earlyUs The time until the buffer should be presented in microseconds. A negative value
-   *     indicates that the buffer is late.
-   * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
-   *     measured at the start of the current iteration of the rendering loop.
-   */
-  protected boolean shouldDropOutputBuffer(long earlyUs, long elapsedRealtimeUs) {
-    return isBufferLate(earlyUs);
-  }
-
-  /**
-   * Returns whether to drop all buffers from the buffer being processed to the keyframe at or after
-   * the current playback position, if possible.
-   *
-   * @param earlyUs The time until the current buffer should be presented in microseconds. A
-   *     negative value indicates that the buffer is late.
-   * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
-   *     measured at the start of the current iteration of the rendering loop.
-   */
-  protected boolean shouldDropBuffersToKeyframe(long earlyUs, long elapsedRealtimeUs) {
-    return isBufferVeryLate(earlyUs);
-  }
-
-  /**
-   * Returns whether to force rendering an output buffer.
-   *
-   * @param earlyUs The time until the current buffer should be presented in microseconds. A
-   *     negative value indicates that the buffer is late.
-   * @param elapsedSinceLastRenderUs The elapsed time since the last output buffer was rendered, in
-   *     microseconds.
-   * @return Returns whether to force rendering an output buffer.
-   */
-  protected boolean shouldForceRenderOutputBuffer(long earlyUs, long elapsedSinceLastRenderUs) {
-    return isBufferLate(earlyUs) && elapsedSinceLastRenderUs > 100000;
-  }
-
-  /**
-   * Skips the specified output buffer and releases it.
-   *
-   * @param outputBuffer The output buffer to skip.
-   */
-  protected void skipOutputBuffer(VpxOutputBuffer outputBuffer) {
-    decoderCounters.skippedOutputBufferCount++;
-    outputBuffer.release();
-  }
-
-  /**
-   * Drops the specified output buffer and releases it.
-   *
-   * @param outputBuffer The output buffer to drop.
-   */
-  protected void dropOutputBuffer(VpxOutputBuffer outputBuffer) {
-    updateDroppedBufferCounters(1);
-    outputBuffer.release();
-  }
-
-  /**
-   * Renders the specified output buffer.
-   *
-   * <p>The implementation of this method takes ownership of the output buffer and is responsible
-   * for calling {@link VpxOutputBuffer#release()} either immediately or in the future.
-   *
-   * @param outputBuffer The buffer to render.
-   */
-  protected void renderOutputBuffer(VpxOutputBuffer outputBuffer) throws VpxDecoderException {
     int bufferMode = outputBuffer.mode;
     boolean renderSurface = bufferMode == C.VIDEO_OUTPUT_MODE_SURFACE_YUV && surface != null;
     boolean renderYuv = bufferMode == C.VIDEO_OUTPUT_MODE_YUV && outputBufferRenderer != null;
-    lastRenderTimeUs = SystemClock.elapsedRealtime() * 1000;
     if (!renderYuv && !renderSurface) {
       dropOutputBuffer(outputBuffer);
     } else {
@@ -643,49 +276,19 @@ protected void renderOutputBuffer(VpxOutputBuffer outputBuffer) throws VpxDecode
         decoder.renderToSurface(outputBuffer, surface);
         outputBuffer.release();
       }
-      consecutiveDroppedFrameCount = 0;
-      decoderCounters.renderedOutputBufferCount++;
-      maybeNotifyRenderedFirstFrame();
+      onFrameRendered(surface);
     }
   }
 
-  /**
-   * Drops frames from the current output buffer to the next keyframe at or before the playback
-   * position. If no such keyframe exists, as the playback position is inside the same group of
-   * pictures as the buffer being processed, returns {@code false}. Returns {@code true} otherwise.
-   *
-   * @param positionUs The current playback position, in microseconds.
-   * @return Whether any buffers were dropped.
-   * @throws ExoPlaybackException If an error occurs flushing the decoder.
-   */
-  protected boolean maybeDropBuffersToKeyframe(long positionUs) throws ExoPlaybackException {
-    int droppedSourceBufferCount = skipSource(positionUs);
-    if (droppedSourceBufferCount == 0) {
-      return false;
-    }
-    decoderCounters.droppedToKeyframeCount++;
-    // We dropped some buffers to catch up, so update the decoder counters and flush the decoder,
-    // which releases all pending buffers buffers including the current output buffer.
-    updateDroppedBufferCounters(buffersInCodecCount + droppedSourceBufferCount);
-    flushDecoder();
-    return true;
+  @Override
+  protected void clearOutputBuffer() {
+    super.clearOutputBuffer();
+    outputBuffer = null;
   }
 
-  /**
-   * Updates decoder counters to reflect that {@code droppedBufferCount} additional buffers were
-   * dropped.
-   *
-   * @param droppedBufferCount The number of additional dropped buffers.
-   */
-  protected void updateDroppedBufferCounters(int droppedBufferCount) {
-    decoderCounters.droppedBufferCount += droppedBufferCount;
-    droppedFrames += droppedBufferCount;
-    consecutiveDroppedFrameCount += droppedBufferCount;
-    decoderCounters.maxConsecutiveDroppedBufferCount =
-        Math.max(consecutiveDroppedFrameCount, decoderCounters.maxConsecutiveDroppedBufferCount);
-    if (maxDroppedFramesToNotify > 0 && droppedFrames >= maxDroppedFramesToNotify) {
-      maybeNotifyDroppedFrames();
-    }
+  @Override
+  protected boolean hasOutputSurface() {
+    return outputMode != C.VIDEO_OUTPUT_MODE_NONE;
   }
 
   // PlayerMessage.Target implementation.
@@ -719,325 +322,18 @@ private void setOutput(
         outputMode =
             outputBufferRenderer != null ? C.VIDEO_OUTPUT_MODE_YUV : C.VIDEO_OUTPUT_MODE_NONE;
       }
-      if (outputMode != C.VIDEO_OUTPUT_MODE_NONE) {
+      if (hasOutputSurface()) {
         if (decoder != null) {
           decoder.setOutputMode(outputMode);
         }
-        // If we know the video size, report it again immediately.
-        maybeRenotifyVideoSizeChanged();
-        // We haven't rendered to the new output yet.
-        clearRenderedFirstFrame();
-        if (getState() == STATE_STARTED) {
-          setJoiningDeadlineMs();
-        }
+        onOutputSurfaceChanged();
       } else {
         // The output has been removed. We leave the outputMode of the underlying decoder unchanged
         // in anticipation that a subsequent output will likely be of the same type.
-        clearReportedVideoSize();
-        clearRenderedFirstFrame();
-      }
-    } else if (outputMode != C.VIDEO_OUTPUT_MODE_NONE) {
-      // The output is unchanged and non-null. If we know the video size and/or have already
-      // rendered to the output, report these again immediately.
-      maybeRenotifyVideoSizeChanged();
-      maybeRenotifyRenderedFirstFrame();
-    }
-  }
-
-  private void maybeInitDecoder() throws ExoPlaybackException {
-    if (decoder != null) {
-      return;
-    }
-
-    setDecoderDrmSession(sourceDrmSession);
-
-    ExoMediaCrypto mediaCrypto = null;
-    if (decoderDrmSession != null) {
-      mediaCrypto = decoderDrmSession.getMediaCrypto();
-      if (mediaCrypto == null) {
-        DrmSessionException drmError = decoderDrmSession.getError();
-        if (drmError != null) {
-          // Continue for now. We may be able to avoid failure if the session recovers, or if a new
-          // input format causes the session to be replaced before it's used.
-        } else {
-          // The drm session isn't open yet.
-          return;
-        }
-      }
-    }
-
-    try {
-      long decoderInitializingTimestamp = SystemClock.elapsedRealtime();
-      TraceUtil.beginSection("createVpxDecoder");
-      int initialInputBufferSize =
-          format.maxInputSize != Format.NO_VALUE ? format.maxInputSize : DEFAULT_INPUT_BUFFER_SIZE;
-      decoder =
-          new VpxDecoder(
-              numInputBuffers,
-              numOutputBuffers,
-              initialInputBufferSize,
-              mediaCrypto,
-              disableLoopFilter,
-              enableRowMultiThreadMode,
-              threads);
-      decoder.setOutputMode(outputMode);
-      TraceUtil.endSection();
-      long decoderInitializedTimestamp = SystemClock.elapsedRealtime();
-      onDecoderInitialized(
-          decoder.getName(),
-          decoderInitializedTimestamp,
-          decoderInitializedTimestamp - decoderInitializingTimestamp);
-      decoderCounters.decoderInitCount++;
-    } catch (VpxDecoderException e) {
-      throw ExoPlaybackException.createForRenderer(e, getIndex());
-    }
-  }
-
-  private boolean feedInputBuffer() throws VpxDecoderException, ExoPlaybackException {
-    if (decoder == null
-        || decoderReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM
-        || inputStreamEnded) {
-      // We need to reinitialize the decoder or the input stream has ended.
-      return false;
-    }
-
-    if (inputBuffer == null) {
-      inputBuffer = decoder.dequeueInputBuffer();
-      if (inputBuffer == null) {
-        return false;
+        onOutputSurfaceRemoved();
       }
+    } else if (hasOutputSurface()) {
+      onOutputSurfaceReset(surface);
     }
-
-    if (decoderReinitializationState == REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM) {
-      inputBuffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
-      decoder.queueInputBuffer(inputBuffer);
-      inputBuffer = null;
-      decoderReinitializationState = REINITIALIZATION_STATE_WAIT_END_OF_STREAM;
-      return false;
-    }
-
-    int result;
-    if (waitingForKeys) {
-      // We've already read an encrypted sample into buffer, and are waiting for keys.
-      result = C.RESULT_BUFFER_READ;
-    } else {
-      result = readSource(formatHolder, inputBuffer, false);
-    }
-
-    if (result == C.RESULT_NOTHING_READ) {
-      return false;
-    }
-    if (result == C.RESULT_FORMAT_READ) {
-      onInputFormatChanged(formatHolder);
-      return true;
-    }
-    if (inputBuffer.isEndOfStream()) {
-      inputStreamEnded = true;
-      decoder.queueInputBuffer(inputBuffer);
-      inputBuffer = null;
-      return false;
-    }
-    boolean bufferEncrypted = inputBuffer.isEncrypted();
-    waitingForKeys = shouldWaitForKeys(bufferEncrypted);
-    if (waitingForKeys) {
-      return false;
-    }
-    if (pendingFormat != null) {
-      formatQueue.add(inputBuffer.timeUs, pendingFormat);
-      pendingFormat = null;
-    }
-    inputBuffer.flip();
-    inputBuffer.colorInfo = format.colorInfo;
-    onQueueInputBuffer(inputBuffer);
-    decoder.queueInputBuffer(inputBuffer);
-    buffersInCodecCount++;
-    decoderReceivedBuffers = true;
-    decoderCounters.inputBufferCount++;
-    inputBuffer = null;
-    return true;
   }
-
-  /**
-   * Attempts to dequeue an output buffer from the decoder and, if successful, passes it to {@link
-   * #processOutputBuffer(long, long)}.
-   *
-   * @param positionUs The player's current position.
-   * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
-   *     measured at the start of the current iteration of the rendering loop.
-   * @return Whether it may be possible to drain more output data.
-   * @throws ExoPlaybackException If an error occurs draining the output buffer.
-   */
-  private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
-      throws ExoPlaybackException, VpxDecoderException {
-    if (outputBuffer == null) {
-      outputBuffer = decoder.dequeueOutputBuffer();
-      if (outputBuffer == null) {
-        return false;
-      }
-      decoderCounters.skippedOutputBufferCount += outputBuffer.skippedOutputBufferCount;
-      buffersInCodecCount -= outputBuffer.skippedOutputBufferCount;
-    }
-
-    if (outputBuffer.isEndOfStream()) {
-      if (decoderReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM) {
-        // We're waiting to re-initialize the decoder, and have now processed all final buffers.
-        releaseDecoder();
-        maybeInitDecoder();
-      } else {
-        outputBuffer.release();
-        outputBuffer = null;
-        outputStreamEnded = true;
-      }
-      return false;
-    }
-
-    boolean processedOutputBuffer = processOutputBuffer(positionUs, elapsedRealtimeUs);
-    if (processedOutputBuffer) {
-      onProcessedOutputBuffer(outputBuffer.timeUs);
-      outputBuffer = null;
-    }
-    return processedOutputBuffer;
-  }
-
-  /**
-   * Processes {@link #outputBuffer} by rendering it, skipping it or doing nothing, and returns
-   * whether it may be possible to process another output buffer.
-   *
-   * @param positionUs The player's current position.
-   * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
-   *     measured at the start of the current iteration of the rendering loop.
-   * @return Whether it may be possible to drain another output buffer.
-   * @throws ExoPlaybackException If an error occurs processing the output buffer.
-   */
-  private boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs)
-      throws ExoPlaybackException, VpxDecoderException {
-    if (initialPositionUs == C.TIME_UNSET) {
-      initialPositionUs = positionUs;
-    }
-
-    long earlyUs = outputBuffer.timeUs - positionUs;
-    if (outputMode == C.VIDEO_OUTPUT_MODE_NONE) {
-      // Skip frames in sync with playback, so we'll be at the right frame if the mode changes.
-      if (isBufferLate(earlyUs)) {
-        skipOutputBuffer(outputBuffer);
-        return true;
-      }
-      return false;
-    }
-
-    long presentationTimeUs = outputBuffer.timeUs - outputStreamOffsetUs;
-    Format format = formatQueue.pollFloor(presentationTimeUs);
-    if (format != null) {
-      outputFormat = format;
-    }
-
-    long elapsedRealtimeNowUs = SystemClock.elapsedRealtime() * 1000;
-    boolean isStarted = getState() == STATE_STARTED;
-    if (!renderedFirstFrame
-        || (isStarted
-            && shouldForceRenderOutputBuffer(earlyUs, elapsedRealtimeNowUs - lastRenderTimeUs))) {
-      if (frameMetadataListener != null) {
-        frameMetadataListener.onVideoFrameAboutToBeRendered(
-            presentationTimeUs, System.nanoTime(), outputFormat);
-      }
-      renderOutputBuffer(outputBuffer);
-      return true;
-    }
-
-    if (!isStarted || positionUs == initialPositionUs) {
-      return false;
-    }
-
-    if (shouldDropBuffersToKeyframe(earlyUs, elapsedRealtimeUs)
-        && maybeDropBuffersToKeyframe(positionUs)) {
-      return false;
-    } else if (shouldDropOutputBuffer(earlyUs, elapsedRealtimeUs)) {
-      dropOutputBuffer(outputBuffer);
-      return true;
-    }
-
-    if (earlyUs < 30000) {
-      if (frameMetadataListener != null) {
-        frameMetadataListener.onVideoFrameAboutToBeRendered(
-            presentationTimeUs, System.nanoTime(), outputFormat);
-      }
-      renderOutputBuffer(outputBuffer);
-      return true;
-    }
-
-    return false;
-  }
-
-  private boolean shouldWaitForKeys(boolean bufferEncrypted) throws ExoPlaybackException {
-    if (decoderDrmSession == null || (!bufferEncrypted && playClearSamplesWithoutKeys)) {
-      return false;
-    }
-    @DrmSession.State int drmSessionState = decoderDrmSession.getState();
-    if (drmSessionState == DrmSession.STATE_ERROR) {
-      throw ExoPlaybackException.createForRenderer(decoderDrmSession.getError(), getIndex());
-    }
-    return drmSessionState != DrmSession.STATE_OPENED_WITH_KEYS;
-  }
-
-  private void setJoiningDeadlineMs() {
-    joiningDeadlineMs = allowedJoiningTimeMs > 0
-        ? (SystemClock.elapsedRealtime() + allowedJoiningTimeMs) : C.TIME_UNSET;
-  }
-
-  private void clearRenderedFirstFrame() {
-    renderedFirstFrame = false;
-  }
-
-  private void maybeNotifyRenderedFirstFrame() {
-    if (!renderedFirstFrame) {
-      renderedFirstFrame = true;
-      eventDispatcher.renderedFirstFrame(surface);
-    }
-  }
-
-  private void maybeRenotifyRenderedFirstFrame() {
-    if (renderedFirstFrame) {
-      eventDispatcher.renderedFirstFrame(surface);
-    }
-  }
-
-  private void clearReportedVideoSize() {
-    reportedWidth = Format.NO_VALUE;
-    reportedHeight = Format.NO_VALUE;
-  }
-
-  private void maybeNotifyVideoSizeChanged(int width, int height) {
-    if (reportedWidth != width || reportedHeight != height) {
-      reportedWidth = width;
-      reportedHeight = height;
-      eventDispatcher.videoSizeChanged(width, height, 0, 1);
-    }
-  }
-
-  private void maybeRenotifyVideoSizeChanged() {
-    if (reportedWidth != Format.NO_VALUE || reportedHeight != Format.NO_VALUE) {
-      eventDispatcher.videoSizeChanged(reportedWidth, reportedHeight, 0, 1);
-    }
-  }
-
-  private void maybeNotifyDroppedFrames() {
-    if (droppedFrames > 0) {
-      long now = SystemClock.elapsedRealtime();
-      long elapsedMs = now - droppedFrameAccumulationStartTimeMs;
-      eventDispatcher.droppedFrames(droppedFrames, elapsedMs);
-      droppedFrames = 0;
-      droppedFrameAccumulationStartTimeMs = now;
-    }
-  }
-
-  private static boolean isBufferLate(long earlyUs) {
-    // Class a buffer as late if it should have been presented more than 30 ms ago.
-    return earlyUs < -30000;
-  }
-
-  private static boolean isBufferVeryLate(long earlyUs) {
-    // Class a buffer as very late if it should have been presented more than 500 ms ago.
-    return earlyUs < -500000;
-  }
-
 }
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
index 0efd4bd0ea..1392e782f8 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
@@ -22,6 +22,7 @@
 import com.google.android.exoplayer2.decoder.SimpleDecoder;
 import com.google.android.exoplayer2.drm.DecryptionException;
 import com.google.android.exoplayer2.drm.ExoMediaCrypto;
+import com.google.android.exoplayer2.util.Util;
 import com.google.android.exoplayer2.video.VideoDecoderInputBuffer;
 import java.nio.ByteBuffer;
 
@@ -118,7 +119,7 @@ protected VpxDecoderException createUnexpectedDecodeException(Throwable error) {
   @Nullable
   protected VpxDecoderException decode(
       VideoDecoderInputBuffer inputBuffer, VpxOutputBuffer outputBuffer, boolean reset) {
-    ByteBuffer inputData = inputBuffer.data;
+    ByteBuffer inputData = Util.castNonNull(inputBuffer.data);
     int inputSize = inputData.limit();
     CryptoInfo cryptoInfo = inputBuffer.cryptoInfo;
     final long result = inputBuffer.isEncrypted()
diff --git a/extensions/vp9/src/main/jni/vpx_jni.cc b/extensions/vp9/src/main/jni/vpx_jni.cc
index 9fc8b09a18..d23f07a90b 100644
--- a/extensions/vp9/src/main/jni/vpx_jni.cc
+++ b/extensions/vp9/src/main/jni/vpx_jni.cc
@@ -594,8 +594,14 @@ DECODER_FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer) {
       memcpy(data + yLength, img->planes[VPX_PLANE_U], uvLength);
       memcpy(data + yLength + uvLength, img->planes[VPX_PLANE_V], uvLength);
     }
-  } else if (outputMode == kOutputModeSurfaceYuv &&
-             img->fmt != VPX_IMG_FMT_I42016) {
+  } else if (outputMode == kOutputModeSurfaceYuv) {
+    if (img->fmt & VPX_IMG_FMT_HIGHBITDEPTH) {
+      LOGE(
+          "ERROR: High bit depth output format %d not supported in surface "
+          "YUV output mode",
+          img->fmt);
+      return -1;
+    }
     int id = *(int*)img->fb_priv;
     context->buffer_manager->add_ref(id);
     JniFrameBuffer* jfb = context->buffer_manager->get_buffer(id);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
index 1099b14bfc..f5db0145fe 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
@@ -65,6 +65,7 @@ public final void setIndex(int index) {
   }
 
   @Override
+  @Nullable
   public MediaClock getMediaClock() {
     return null;
   }
@@ -105,6 +106,7 @@ public final void replaceStream(Format[] formats, SampleStream stream, long offs
   }
 
   @Override
+  @Nullable
   public final SampleStream getStream() {
     return stream;
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/C.java b/library/core/src/main/java/com/google/android/exoplayer2/C.java
index daa6124df6..cd862e503f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/C.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/C.java
@@ -685,25 +685,6 @@ private C() {}
   /** A default size in bytes for an individual allocation that forms part of a larger buffer. */
   public static final int DEFAULT_BUFFER_SEGMENT_SIZE = 64 * 1024;
 
-  /** A default size in bytes for a video buffer. */
-  public static final int DEFAULT_VIDEO_BUFFER_SIZE = 200 * DEFAULT_BUFFER_SEGMENT_SIZE;
-
-  /** A default size in bytes for an audio buffer. */
-  public static final int DEFAULT_AUDIO_BUFFER_SIZE = 54 * DEFAULT_BUFFER_SEGMENT_SIZE;
-
-  /** A default size in bytes for a text buffer. */
-  public static final int DEFAULT_TEXT_BUFFER_SIZE = 2 * DEFAULT_BUFFER_SEGMENT_SIZE;
-
-  /** A default size in bytes for a metadata buffer. */
-  public static final int DEFAULT_METADATA_BUFFER_SIZE = 2 * DEFAULT_BUFFER_SEGMENT_SIZE;
-
-  /** A default size in bytes for a camera motion buffer. */
-  public static final int DEFAULT_CAMERA_MOTION_BUFFER_SIZE = 2 * DEFAULT_BUFFER_SEGMENT_SIZE;
-
-  /** A default size in bytes for a muxed buffer (e.g. containing video, audio and text). */
-  public static final int DEFAULT_MUXED_BUFFER_SIZE =
-      DEFAULT_VIDEO_BUFFER_SIZE + DEFAULT_AUDIO_BUFFER_SIZE + DEFAULT_TEXT_BUFFER_SIZE;
-
   /** "cenc" scheme type name as defined in ISO/IEC 23001-7:2016. */
   @SuppressWarnings("ConstantField")
   public static final String CENC_TYPE_cenc = "cenc";
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java b/library/core/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
index 972f651a41..1244b96d94 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
@@ -67,6 +67,25 @@
   /** The default for whether the back buffer is retained from the previous keyframe. */
   public static final boolean DEFAULT_RETAIN_BACK_BUFFER_FROM_KEYFRAME = false;
 
+  /** A default size in bytes for a video buffer. */
+  public static final int DEFAULT_VIDEO_BUFFER_SIZE = 500 * C.DEFAULT_BUFFER_SEGMENT_SIZE;
+
+  /** A default size in bytes for an audio buffer. */
+  public static final int DEFAULT_AUDIO_BUFFER_SIZE = 54 * C.DEFAULT_BUFFER_SEGMENT_SIZE;
+
+  /** A default size in bytes for a text buffer. */
+  public static final int DEFAULT_TEXT_BUFFER_SIZE = 2 * C.DEFAULT_BUFFER_SEGMENT_SIZE;
+
+  /** A default size in bytes for a metadata buffer. */
+  public static final int DEFAULT_METADATA_BUFFER_SIZE = 2 * C.DEFAULT_BUFFER_SEGMENT_SIZE;
+
+  /** A default size in bytes for a camera motion buffer. */
+  public static final int DEFAULT_CAMERA_MOTION_BUFFER_SIZE = 2 * C.DEFAULT_BUFFER_SEGMENT_SIZE;
+
+  /** A default size in bytes for a muxed buffer (e.g. containing video, audio and text). */
+  public static final int DEFAULT_MUXED_BUFFER_SIZE =
+      DEFAULT_VIDEO_BUFFER_SIZE + DEFAULT_AUDIO_BUFFER_SIZE + DEFAULT_TEXT_BUFFER_SIZE;
+
   /** Builder for {@link DefaultLoadControl}. */
   public static final class Builder {
 
@@ -404,7 +423,7 @@ protected int calculateTargetBufferSize(
     int targetBufferSize = 0;
     for (int i = 0; i < renderers.length; i++) {
       if (trackSelectionArray.get(i) != null) {
-        targetBufferSize += Util.getDefaultBufferSize(renderers[i].getTrackType());
+        targetBufferSize += getDefaultBufferSize(renderers[i].getTrackType());
       }
     }
     return targetBufferSize;
@@ -418,6 +437,27 @@ private void reset(boolean resetAllocator) {
     }
   }
 
+  private static int getDefaultBufferSize(int trackType) {
+    switch (trackType) {
+      case C.TRACK_TYPE_DEFAULT:
+        return DEFAULT_MUXED_BUFFER_SIZE;
+      case C.TRACK_TYPE_AUDIO:
+        return DEFAULT_AUDIO_BUFFER_SIZE;
+      case C.TRACK_TYPE_VIDEO:
+        return DEFAULT_VIDEO_BUFFER_SIZE;
+      case C.TRACK_TYPE_TEXT:
+        return DEFAULT_TEXT_BUFFER_SIZE;
+      case C.TRACK_TYPE_METADATA:
+        return DEFAULT_METADATA_BUFFER_SIZE;
+      case C.TRACK_TYPE_CAMERA_MOTION:
+        return DEFAULT_CAMERA_MOTION_BUFFER_SIZE;
+      case C.TRACK_TYPE_NONE:
+        return 0;
+      default:
+        throw new IllegalArgumentException();
+    }
+  }
+
   private static boolean hasVideo(Renderer[] renderers, TrackSelectionArray trackSelectionArray) {
     for (int i = 0; i < renderers.length; i++) {
       if (renderers[i].getTrackType() == C.TRACK_TYPE_VIDEO && trackSelectionArray.get(i) != null) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
index 490d961396..a97b1e0d5a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
@@ -104,7 +104,7 @@ public DefaultRenderersFactory(Context context) {
 
   /**
    * @deprecated Use {@link #DefaultRenderersFactory(Context)} and pass {@link DrmSessionManager}
-   *     directly to {@link SimpleExoPlayer} or {@link ExoPlayerFactory}.
+   *     directly to {@link SimpleExoPlayer.Builder}.
    */
   @Deprecated
   @SuppressWarnings("deprecation")
@@ -127,7 +127,7 @@ public DefaultRenderersFactory(
   /**
    * @deprecated Use {@link #DefaultRenderersFactory(Context)} and {@link
    *     #setExtensionRendererMode(int)}, and pass {@link DrmSessionManager} directly to {@link
-   *     SimpleExoPlayer} or {@link ExoPlayerFactory}.
+   *     SimpleExoPlayer.Builder}.
    */
   @Deprecated
   @SuppressWarnings("deprecation")
@@ -154,7 +154,7 @@ public DefaultRenderersFactory(
   /**
    * @deprecated Use {@link #DefaultRenderersFactory(Context)}, {@link
    *     #setExtensionRendererMode(int)} and {@link #setAllowedVideoJoiningTimeMs(long)}, and pass
-   *     {@link DrmSessionManager} directly to {@link SimpleExoPlayer} or {@link ExoPlayerFactory}.
+   *     {@link DrmSessionManager} directly to {@link SimpleExoPlayer.Builder}.
    */
   @Deprecated
   public DefaultRenderersFactory(
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
index ee29af9c99..991be9b08b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
@@ -15,8 +15,10 @@
  */
 package com.google.android.exoplayer2;
 
+import android.content.Context;
 import android.os.Looper;
 import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import com.google.android.exoplayer2.audio.MediaCodecAudioRenderer;
 import com.google.android.exoplayer2.metadata.MetadataRenderer;
 import com.google.android.exoplayer2.source.ClippingMediaSource;
@@ -29,12 +31,17 @@
 import com.google.android.exoplayer2.text.TextRenderer;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.upstream.BandwidthMeter;
 import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Clock;
+import com.google.android.exoplayer2.util.Util;
 import com.google.android.exoplayer2.video.MediaCodecVideoRenderer;
 
 /**
  * An extensible media player that plays {@link MediaSource}s. Instances can be obtained from {@link
- * ExoPlayerFactory}.
+ * SimpleExoPlayer.Builder} or {@link ExoPlayer.Builder}.
  *
  * <h3>Player components</h3>
  *
@@ -117,6 +124,161 @@
  */
 public interface ExoPlayer extends Player {
 
+  /**
+   * A builder for {@link ExoPlayer} instances.
+   *
+   * <p>See {@link #Builder(Context, Renderer...)} for the list of default values.
+   */
+  final class Builder {
+
+    private final Renderer[] renderers;
+
+    private Clock clock;
+    private TrackSelector trackSelector;
+    private LoadControl loadControl;
+    private BandwidthMeter bandwidthMeter;
+    private Looper looper;
+    private boolean buildCalled;
+
+    /**
+     * Creates a builder with a list of {@link Renderer Renderers}.
+     *
+     * <p>The builder uses the following default values:
+     *
+     * <ul>
+     *   <li>{@link TrackSelector}: {@link DefaultTrackSelector}
+     *   <li>{@link LoadControl}: {@link DefaultLoadControl}
+     *   <li>{@link BandwidthMeter}: {@link DefaultBandwidthMeter#getSingletonInstance(Context)}
+     *   <li>{@link Looper}: The {@link Looper} associated with the current thread, or the {@link
+     *       Looper} of the application's main thread if the current thread doesn't have a {@link
+     *       Looper}
+     *   <li>{@link Clock}: {@link Clock#DEFAULT}
+     * </ul>
+     *
+     * @param context A {@link Context}.
+     * @param renderers The {@link Renderer Renderers} to be used by the player.
+     */
+    public Builder(Context context, Renderer... renderers) {
+      this(
+          renderers,
+          new DefaultTrackSelector(context),
+          new DefaultLoadControl(),
+          DefaultBandwidthMeter.getSingletonInstance(context),
+          Util.getLooper(),
+          Clock.DEFAULT);
+    }
+
+    /**
+     * Creates a builder with the specified custom components.
+     *
+     * <p>Note that this constructor is only useful if you try to ensure that ExoPlayer's default
+     * components can be removed by ProGuard or R8. For most components except renderers, there is
+     * only a marginal benefit of doing that.
+     *
+     * @param renderers The {@link Renderer Renderers} to be used by the player.
+     * @param trackSelector A {@link TrackSelector}.
+     * @param loadControl A {@link LoadControl}.
+     * @param bandwidthMeter A {@link BandwidthMeter}.
+     * @param looper A {@link Looper} that must be used for all calls to the player.
+     * @param clock A {@link Clock}. Should always be {@link Clock#DEFAULT}.
+     */
+    public Builder(
+        Renderer[] renderers,
+        TrackSelector trackSelector,
+        LoadControl loadControl,
+        BandwidthMeter bandwidthMeter,
+        Looper looper,
+        Clock clock) {
+      Assertions.checkArgument(renderers.length > 0);
+      this.renderers = renderers;
+      this.trackSelector = trackSelector;
+      this.loadControl = loadControl;
+      this.bandwidthMeter = bandwidthMeter;
+      this.looper = looper;
+      this.clock = clock;
+    }
+
+    /**
+     * Sets the {@link TrackSelector} that will be used by the player.
+     *
+     * @param trackSelector A {@link TrackSelector}.
+     * @return This builder.
+     * @throws IllegalStateException If {@link #build()} has already been called.
+     */
+    public Builder setTrackSelector(TrackSelector trackSelector) {
+      Assertions.checkState(!buildCalled);
+      this.trackSelector = trackSelector;
+      return this;
+    }
+
+    /**
+     * Sets the {@link LoadControl} that will be used by the player.
+     *
+     * @param loadControl A {@link LoadControl}.
+     * @return This builder.
+     * @throws IllegalStateException If {@link #build()} has already been called.
+     */
+    public Builder setLoadControl(LoadControl loadControl) {
+      Assertions.checkState(!buildCalled);
+      this.loadControl = loadControl;
+      return this;
+    }
+
+    /**
+     * Sets the {@link BandwidthMeter} that will be used by the player.
+     *
+     * @param bandwidthMeter A {@link BandwidthMeter}.
+     * @return This builder.
+     * @throws IllegalStateException If {@link #build()} has already been called.
+     */
+    public Builder setBandwidthMeter(BandwidthMeter bandwidthMeter) {
+      Assertions.checkState(!buildCalled);
+      this.bandwidthMeter = bandwidthMeter;
+      return this;
+    }
+
+    /**
+     * Sets the {@link Looper} that must be used for all calls to the player and that is used to
+     * call listeners on.
+     *
+     * @param looper A {@link Looper}.
+     * @return This builder.
+     * @throws IllegalStateException If {@link #build()} has already been called.
+     */
+    public Builder setLooper(Looper looper) {
+      Assertions.checkState(!buildCalled);
+      this.looper = looper;
+      return this;
+    }
+
+    /**
+     * Sets the {@link Clock} that will be used by the player. Should only be set for testing
+     * purposes.
+     *
+     * @param clock A {@link Clock}.
+     * @return This builder.
+     * @throws IllegalStateException If {@link #build()} has already been called.
+     */
+    @VisibleForTesting
+    public Builder setClock(Clock clock) {
+      Assertions.checkState(!buildCalled);
+      this.clock = clock;
+      return this;
+    }
+
+    /**
+     * Builds an {@link ExoPlayer} instance.
+     *
+     * @throws IllegalStateException If {@link #build()} has already been called.
+     */
+    public ExoPlayer build() {
+      Assertions.checkState(!buildCalled);
+      buildCalled = true;
+      return new ExoPlayerImpl(
+          renderers, trackSelector, loadControl, bandwidthMeter, clock, looper);
+    }
+  }
+
   /** Returns the {@link Looper} associated with the playback thread. */
   Looper getPlaybackLooper();
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
index 9168f1bd76..ae5071717d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
@@ -21,6 +21,7 @@
 import com.google.android.exoplayer2.analytics.AnalyticsCollector;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
+import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
 import com.google.android.exoplayer2.upstream.BandwidthMeter;
@@ -28,30 +29,19 @@
 import com.google.android.exoplayer2.util.Clock;
 import com.google.android.exoplayer2.util.Util;
 
-/**
- * A factory for {@link ExoPlayer} instances.
- */
+/** @deprecated Use {@link SimpleExoPlayer.Builder} or {@link ExoPlayer.Builder} instead. */
+@Deprecated
 public final class ExoPlayerFactory {
 
-  private static @Nullable BandwidthMeter singletonBandwidthMeter;
-
   private ExoPlayerFactory() {}
 
   /**
-   * Creates a {@link SimpleExoPlayer} instance.
-   *
-   * @param context A {@link Context}.
-   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   * @param loadControl The {@link LoadControl} that will be used by the instance.
-   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
-   *     will not be used for DRM protected playbacks.
-   * @param extensionRendererMode The extension renderer mode, which determines if and how available
-   *     extension renderers are used. Note that extensions must be included in the application
-   *     build for them to be considered available.
-   * @deprecated Use {@link #newSimpleInstance(Context, RenderersFactory, TrackSelector,
-   *     LoadControl, DrmSessionManager)}.
+   * @deprecated Use {@link SimpleExoPlayer.Builder} instead. The {@link DrmSessionManager} cannot
+   *     be passed to {@link SimpleExoPlayer.Builder} and should instead be injected into the {@link
+   *     MediaSource} factories.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public static SimpleExoPlayer newSimpleInstance(
       Context context,
       TrackSelector trackSelector,
@@ -65,22 +55,12 @@ public static SimpleExoPlayer newSimpleInstance(
   }
 
   /**
-   * Creates a {@link SimpleExoPlayer} instance.
-   *
-   * @param context A {@link Context}.
-   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   * @param loadControl The {@link LoadControl} that will be used by the instance.
-   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
-   *     will not be used for DRM protected playbacks.
-   * @param extensionRendererMode The extension renderer mode, which determines if and how available
-   *     extension renderers are used. Note that extensions must be included in the application
-   *     build for them to be considered available.
-   * @param allowedVideoJoiningTimeMs The maximum duration for which a video renderer can attempt to
-   *     seamlessly join an ongoing playback.
-   * @deprecated Use {@link #newSimpleInstance(Context, RenderersFactory, TrackSelector,
-   *     LoadControl, DrmSessionManager)}.
+   * @deprecated Use {@link SimpleExoPlayer.Builder} instead. The {@link DrmSessionManager} cannot
+   *     be passed to {@link SimpleExoPlayer.Builder} and should instead be injected into the {@link
+   *     MediaSource} factories.
    */
   @Deprecated
+  @SuppressWarnings("deprecation")
   public static SimpleExoPlayer newSimpleInstance(
       Context context,
       TrackSelector trackSelector,
@@ -96,44 +76,31 @@ public static SimpleExoPlayer newSimpleInstance(
         context, renderersFactory, trackSelector, loadControl, drmSessionManager);
   }
 
-  /**
-   * Creates a {@link SimpleExoPlayer} instance.
-   *
-   * @param context A {@link Context}.
-   */
+  /** @deprecated Use {@link SimpleExoPlayer.Builder} instead. */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public static SimpleExoPlayer newSimpleInstance(Context context) {
     return newSimpleInstance(context, new DefaultTrackSelector(context));
   }
 
-  /**
-   * Creates a {@link SimpleExoPlayer} instance.
-   *
-   * @param context A {@link Context}.
-   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   */
+  /** @deprecated Use {@link SimpleExoPlayer.Builder} instead. */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector trackSelector) {
     return newSimpleInstance(context, new DefaultRenderersFactory(context), trackSelector);
   }
 
-  /**
-   * Creates a {@link SimpleExoPlayer} instance.
-   *
-   * @param context A {@link Context}.
-   * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
-   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   */
+  /** @deprecated Use {@link SimpleExoPlayer.Builder} instead. */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public static SimpleExoPlayer newSimpleInstance(
       Context context, RenderersFactory renderersFactory, TrackSelector trackSelector) {
     return newSimpleInstance(context, renderersFactory, trackSelector, new DefaultLoadControl());
   }
 
-  /**
-   * Creates a {@link SimpleExoPlayer} instance.
-   *
-   * @param context A {@link Context}.
-   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   * @param loadControl The {@link LoadControl} that will be used by the instance.
-   */
+  /** @deprecated Use {@link SimpleExoPlayer.Builder} instead. */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public static SimpleExoPlayer newSimpleInstance(
       Context context, TrackSelector trackSelector, LoadControl loadControl) {
     RenderersFactory renderersFactory = new DefaultRenderersFactory(context);
@@ -141,14 +108,12 @@ public static SimpleExoPlayer newSimpleInstance(
   }
 
   /**
-   * Creates a {@link SimpleExoPlayer} instance. Available extension renderers are not used.
-   *
-   * @param context A {@link Context}.
-   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   * @param loadControl The {@link LoadControl} that will be used by the instance.
-   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
-   *     will not be used for DRM protected playbacks.
+   * @deprecated Use {@link SimpleExoPlayer.Builder} instead. The {@link DrmSessionManager} cannot
+   *     be passed to {@link SimpleExoPlayer.Builder} and should instead be injected into the {@link
+   *     MediaSource} factories.
    */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public static SimpleExoPlayer newSimpleInstance(
       Context context,
       TrackSelector trackSelector,
@@ -160,14 +125,12 @@ public static SimpleExoPlayer newSimpleInstance(
   }
 
   /**
-   * Creates a {@link SimpleExoPlayer} instance.
-   *
-   * @param context A {@link Context}.
-   * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
-   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
-   *     will not be used for DRM protected playbacks.
+   * @deprecated Use {@link SimpleExoPlayer.Builder} instead. The {@link DrmSessionManager} cannot
+   *     be passed to {@link SimpleExoPlayer.Builder} and should instead be injected into the {@link
+   *     MediaSource} factories.
    */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public static SimpleExoPlayer newSimpleInstance(
       Context context,
       RenderersFactory renderersFactory,
@@ -177,14 +140,9 @@ public static SimpleExoPlayer newSimpleInstance(
         context, renderersFactory, trackSelector, new DefaultLoadControl(), drmSessionManager);
   }
 
-  /**
-   * Creates a {@link SimpleExoPlayer} instance.
-   *
-   * @param context A {@link Context}.
-   * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
-   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   * @param loadControl The {@link LoadControl} that will be used by the instance.
-   */
+  /** @deprecated Use {@link SimpleExoPlayer.Builder} instead. */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public static SimpleExoPlayer newSimpleInstance(
       Context context,
       RenderersFactory renderersFactory,
@@ -200,15 +158,12 @@ public static SimpleExoPlayer newSimpleInstance(
   }
 
   /**
-   * Creates a {@link SimpleExoPlayer} instance.
-   *
-   * @param context A {@link Context}.
-   * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
-   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   * @param loadControl The {@link LoadControl} that will be used by the instance.
-   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
-   *     will not be used for DRM protected playbacks.
+   * @deprecated Use {@link SimpleExoPlayer.Builder} instead. The {@link DrmSessionManager} cannot
+   *     be passed to {@link SimpleExoPlayer.Builder} and should instead be injected into the {@link
+   *     MediaSource} factories.
    */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public static SimpleExoPlayer newSimpleInstance(
       Context context,
       RenderersFactory renderersFactory,
@@ -220,16 +175,12 @@ public static SimpleExoPlayer newSimpleInstance(
   }
 
   /**
-   * Creates a {@link SimpleExoPlayer} instance.
-   *
-   * @param context A {@link Context}.
-   * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
-   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   * @param loadControl The {@link LoadControl} that will be used by the instance.
-   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
-   *     will not be used for DRM protected playbacks.
-   * @param bandwidthMeter The {@link BandwidthMeter} that will be used by the instance.
+   * @deprecated Use {@link SimpleExoPlayer.Builder} instead. The {@link DrmSessionManager} cannot
+   *     be passed to {@link SimpleExoPlayer.Builder} and should instead be injected into the {@link
+   *     MediaSource} factories.
    */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public static SimpleExoPlayer newSimpleInstance(
       Context context,
       RenderersFactory renderersFactory,
@@ -249,17 +200,12 @@ public static SimpleExoPlayer newSimpleInstance(
   }
 
   /**
-   * Creates a {@link SimpleExoPlayer} instance.
-   *
-   * @param context A {@link Context}.
-   * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
-   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   * @param loadControl The {@link LoadControl} that will be used by the instance.
-   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
-   *     will not be used for DRM protected playbacks.
-   * @param analyticsCollector The {@link AnalyticsCollector} that will collect and forward all
-   *     player events.
+   * @deprecated Use {@link SimpleExoPlayer.Builder} instead. The {@link DrmSessionManager} cannot
+   *     be passed to {@link SimpleExoPlayer.Builder} and should instead be injected into the {@link
+   *     MediaSource} factories.
    */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public static SimpleExoPlayer newSimpleInstance(
       Context context,
       RenderersFactory renderersFactory,
@@ -278,17 +224,12 @@ public static SimpleExoPlayer newSimpleInstance(
   }
 
   /**
-   * Creates a {@link SimpleExoPlayer} instance.
-   *
-   * @param context A {@link Context}.
-   * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
-   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   * @param loadControl The {@link LoadControl} that will be used by the instance.
-   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
-   *     will not be used for DRM protected playbacks.
-   * @param looper The {@link Looper} which must be used for all calls to the player and which is
-   *     used to call listeners on.
+   * @deprecated Use {@link SimpleExoPlayer.Builder} instead. The {@link DrmSessionManager} cannot
+   *     be passed to {@link SimpleExoPlayer.Builder} and should instead be injected into the {@link
+   *     MediaSource} factories.
    */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public static SimpleExoPlayer newSimpleInstance(
       Context context,
       RenderersFactory renderersFactory,
@@ -307,19 +248,12 @@ public static SimpleExoPlayer newSimpleInstance(
   }
 
   /**
-   * Creates a {@link SimpleExoPlayer} instance.
-   *
-   * @param context A {@link Context}.
-   * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
-   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   * @param loadControl The {@link LoadControl} that will be used by the instance.
-   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
-   *     will not be used for DRM protected playbacks.
-   * @param analyticsCollector The {@link AnalyticsCollector} that will collect and forward all
-   *     player events.
-   * @param looper The {@link Looper} which must be used for all calls to the player and which is
-   *     used to call listeners on.
+   * @deprecated Use {@link SimpleExoPlayer.Builder} instead. The {@link DrmSessionManager} cannot
+   *     be passed to {@link SimpleExoPlayer.Builder} and should instead be injected into the {@link
+   *     MediaSource} factories.
    */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public static SimpleExoPlayer newSimpleInstance(
       Context context,
       RenderersFactory renderersFactory,
@@ -334,25 +268,17 @@ public static SimpleExoPlayer newSimpleInstance(
         trackSelector,
         loadControl,
         drmSessionManager,
-        getDefaultBandwidthMeter(context),
+        DefaultBandwidthMeter.getSingletonInstance(context),
         analyticsCollector,
         looper);
   }
 
   /**
-   * Creates a {@link SimpleExoPlayer} instance.
-   *
-   * @param context A {@link Context}.
-   * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
-   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   * @param loadControl The {@link LoadControl} that will be used by the instance.
-   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
-   *     will not be used for DRM protected playbacks.
-   * @param analyticsCollector The {@link AnalyticsCollector} that will collect and forward all
-   *     player events.
-   * @param looper The {@link Looper} which must be used for all calls to the player and which is
-   *     used to call listeners on.
+   * @deprecated Use {@link SimpleExoPlayer.Builder} instead. The {@link DrmSessionManager} cannot
+   *     be passed to {@link SimpleExoPlayer.Builder} and should instead be injected into the {@link
+   *     MediaSource} factories.
    */
+  @Deprecated
   public static SimpleExoPlayer newSimpleInstance(
       Context context,
       RenderersFactory renderersFactory,
@@ -373,41 +299,25 @@ public static SimpleExoPlayer newSimpleInstance(
         looper);
   }
 
-  /**
-   * Creates an {@link ExoPlayer} instance.
-   *
-   * @param context A {@link Context}.
-   * @param renderers The {@link Renderer}s that will be used by the instance.
-   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   */
+  /** @deprecated Use {@link ExoPlayer.Builder} instead. */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public static ExoPlayer newInstance(
       Context context, Renderer[] renderers, TrackSelector trackSelector) {
     return newInstance(context, renderers, trackSelector, new DefaultLoadControl());
   }
 
-  /**
-   * Creates an {@link ExoPlayer} instance.
-   *
-   * @param context A {@link Context}.
-   * @param renderers The {@link Renderer}s that will be used by the instance.
-   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   * @param loadControl The {@link LoadControl} that will be used by the instance.
-   */
+  /** @deprecated Use {@link ExoPlayer.Builder} instead. */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public static ExoPlayer newInstance(
       Context context, Renderer[] renderers, TrackSelector trackSelector, LoadControl loadControl) {
     return newInstance(context, renderers, trackSelector, loadControl, Util.getLooper());
   }
 
-  /**
-   * Creates an {@link ExoPlayer} instance.
-   *
-   * @param context A {@link Context}.
-   * @param renderers The {@link Renderer}s that will be used by the instance.
-   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   * @param loadControl The {@link LoadControl} that will be used by the instance.
-   * @param looper The {@link Looper} which must be used for all calls to the player and which is
-   *     used to call listeners on.
-   */
+  /** @deprecated Use {@link ExoPlayer.Builder} instead. */
+  @Deprecated
+  @SuppressWarnings("deprecation")
   public static ExoPlayer newInstance(
       Context context,
       Renderer[] renderers,
@@ -415,21 +325,16 @@ public static ExoPlayer newInstance(
       LoadControl loadControl,
       Looper looper) {
     return newInstance(
-        context, renderers, trackSelector, loadControl, getDefaultBandwidthMeter(context), looper);
+        context,
+        renderers,
+        trackSelector,
+        loadControl,
+        DefaultBandwidthMeter.getSingletonInstance(context),
+        looper);
   }
 
-  /**
-   * Creates an {@link ExoPlayer} instance.
-   *
-   * @param context A {@link Context}.
-   * @param renderers The {@link Renderer}s that will be used by the instance.
-   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
-   * @param loadControl The {@link LoadControl} that will be used by the instance.
-   * @param bandwidthMeter The {@link BandwidthMeter} that will be used by the instance.
-   * @param looper The {@link Looper} which must be used for all calls to the player and which is
-   *     used to call listeners on.
-   */
-  @SuppressWarnings("unused")
+  /** @deprecated Use {@link ExoPlayer.Builder} instead. */
+  @Deprecated
   public static ExoPlayer newInstance(
       Context context,
       Renderer[] renderers,
@@ -440,11 +345,4 @@ public static ExoPlayer newInstance(
     return new ExoPlayerImpl(
         renderers, trackSelector, loadControl, bandwidthMeter, Clock.DEFAULT, looper);
   }
-
-  private static synchronized BandwidthMeter getDefaultBandwidthMeter(Context context) {
-    if (singletonBandwidthMeter == null) {
-      singletonBandwidthMeter = new DefaultBandwidthMeter.Builder(context).build();
-    }
-    return singletonBandwidthMeter;
-  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
index e99429d3b2..cacdaec02e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
@@ -37,7 +37,9 @@
 import java.util.ArrayDeque;
 import java.util.concurrent.CopyOnWriteArrayList;
 
-/** An {@link ExoPlayer} implementation. Instances can be obtained from {@link ExoPlayerFactory}. */
+/**
+ * An {@link ExoPlayer} implementation. Instances can be obtained from {@link ExoPlayer.Builder}.
+ */
 /* package */ final class ExoPlayerImpl extends BasePlayer implements ExoPlayer {
 
   private static final String TAG = "ExoPlayerImpl";
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Format.java b/library/core/src/main/java/com/google/android/exoplayer2/Format.java
index b2bd20f0fe..37539845dc 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Format.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Format.java
@@ -180,8 +180,8 @@
   // Video.
 
   /**
-   * @deprecated Use {@link #createVideoContainerFormat(String, String, String, String, String, int,
-   *     int, int, float, List, int, int)} instead.
+   * @deprecated Use {@link #createVideoContainerFormat(String, String, String, String, String,
+   *     Metadata, int, int, int, float, List, int, int)} instead.
    */
   @Deprecated
   public static Format createVideoContainerFormat(
@@ -201,6 +201,7 @@ public static Format createVideoContainerFormat(
         containerMimeType,
         sampleMimeType,
         codecs,
+        /* metadata= */ null,
         bitrate,
         width,
         height,
@@ -216,6 +217,7 @@ public static Format createVideoContainerFormat(
       @Nullable String containerMimeType,
       String sampleMimeType,
       String codecs,
+      @Nullable Metadata metadata,
       int bitrate,
       int width,
       int height,
@@ -230,7 +232,7 @@ public static Format createVideoContainerFormat(
         roleFlags,
         bitrate,
         codecs,
-        /* metadata= */ null,
+        metadata,
         containerMimeType,
         sampleMimeType,
         /* maxInputSize= */ NO_VALUE,
@@ -363,8 +365,8 @@ public static Format createVideoSampleFormat(
   // Audio.
 
   /**
-   * @deprecated Use {@link #createAudioContainerFormat(String, String, String, String, String, int,
-   *     int, int, List, int, int, String)} instead.
+   * @deprecated Use {@link #createAudioContainerFormat(String, String, String, String, String,
+   *     Metadata, int, int, int, List, int, int, String)} instead.
    */
   @Deprecated
   public static Format createAudioContainerFormat(
@@ -384,6 +386,7 @@ public static Format createAudioContainerFormat(
         containerMimeType,
         sampleMimeType,
         codecs,
+        /* metadata= */ null,
         bitrate,
         channelCount,
         sampleRate,
@@ -399,6 +402,7 @@ public static Format createAudioContainerFormat(
       @Nullable String containerMimeType,
       @Nullable String sampleMimeType,
       @Nullable String codecs,
+      @Nullable Metadata metadata,
       int bitrate,
       int channelCount,
       int sampleRate,
@@ -413,7 +417,7 @@ public static Format createAudioContainerFormat(
         roleFlags,
         bitrate,
         codecs,
-        /* metadata= */ null,
+        metadata,
         containerMimeType,
         sampleMimeType,
         /* maxInputSize= */ NO_VALUE,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/NoSampleRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/NoSampleRenderer.java
index e901025a07..894736571c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/NoSampleRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/NoSampleRenderer.java
@@ -49,6 +49,7 @@ public final void setIndex(int index) {
   }
 
   @Override
+  @Nullable
   public MediaClock getMediaClock() {
     return null;
   }
@@ -113,6 +114,7 @@ public final void replaceStream(Format[] formats, SampleStream stream, long offs
   }
 
   @Override
+  @Nullable
   public final SampleStream getStream() {
     return stream;
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Renderer.java b/library/core/src/main/java/com/google/android/exoplayer2/Renderer.java
index 9f52e8d9de..9e44e3741c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Renderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Renderer.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2;
 
 import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.util.MediaClock;
 import java.io.IOException;
@@ -87,11 +88,12 @@
   /**
    * If the renderer advances its own playback position then this method returns a corresponding
    * {@link MediaClock}. If provided, the player will use the returned {@link MediaClock} as its
-   * source of time during playback. A player may have at most one renderer that returns a
-   * {@link MediaClock} from this method.
+   * source of time during playback. A player may have at most one renderer that returns a {@link
+   * MediaClock} from this method.
    *
    * @return The {@link MediaClock} tracking the playback position of the renderer, or null.
    */
+  @Nullable
   MediaClock getMediaClock();
 
   /**
@@ -147,9 +149,8 @@ void enable(RendererConfiguration configuration, Format[] formats, SampleStream
   void replaceStream(Format[] formats, SampleStream stream, long offsetUs)
       throws ExoPlaybackException;
 
-  /**
-   * Returns the {@link SampleStream} being consumed, or null if the renderer is disabled.
-   */
+  /** Returns the {@link SampleStream} being consumed, or null if the renderer is disabled. */
+  @Nullable
   SampleStream getStream();
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
index 8913fbdaba..9606cc0d48 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
@@ -24,6 +24,7 @@
 import android.os.Handler;
 import android.os.Looper;
 import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 import android.view.Surface;
 import android.view.SurfaceHolder;
 import android.view.SurfaceView;
@@ -45,9 +46,11 @@
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.TextOutput;
+import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
 import com.google.android.exoplayer2.upstream.BandwidthMeter;
+import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Clock;
 import com.google.android.exoplayer2.util.Log;
@@ -63,7 +66,7 @@
 
 /**
  * An {@link ExoPlayer} implementation that uses default {@link Renderer} components. Instances can
- * be obtained from {@link ExoPlayerFactory}.
+ * be obtained from {@link SimpleExoPlayer.Builder}.
  */
 public class SimpleExoPlayer extends BasePlayer
     implements ExoPlayer,
@@ -76,6 +79,209 @@
   @Deprecated
   public interface VideoListener extends com.google.android.exoplayer2.video.VideoListener {}
 
+  /**
+   * A builder for {@link SimpleExoPlayer} instances.
+   *
+   * <p>See {@link #Builder(Context)} for the list of default values.
+   */
+  public static final class Builder {
+
+    private final Context context;
+    private final RenderersFactory renderersFactory;
+
+    private Clock clock;
+    private TrackSelector trackSelector;
+    private LoadControl loadControl;
+    private BandwidthMeter bandwidthMeter;
+    private AnalyticsCollector analyticsCollector;
+    private Looper looper;
+    private boolean buildCalled;
+
+    /**
+     * Creates a builder.
+     *
+     * <p>Use {@link #Builder(Context, RenderersFactory)} instead, if you intend to provide a custom
+     * {@link RenderersFactory}. This is to ensure that ProGuard or R8 can remove ExoPlayer's {@link
+     * DefaultRenderersFactory} from the APK.
+     *
+     * <p>The builder uses the following default values:
+     *
+     * <ul>
+     *   <li>{@link RenderersFactory}: {@link DefaultRenderersFactory}
+     *   <li>{@link TrackSelector}: {@link DefaultTrackSelector}
+     *   <li>{@link LoadControl}: {@link DefaultLoadControl}
+     *   <li>{@link BandwidthMeter}: {@link DefaultBandwidthMeter#getSingletonInstance(Context)}
+     *   <li>{@link Looper}: The {@link Looper} associated with the current thread, or the {@link
+     *       Looper} of the application's main thread if the current thread doesn't have a {@link
+     *       Looper}
+     *   <li>{@link AnalyticsCollector}: {@link AnalyticsCollector} with {@link Clock#DEFAULT}
+     *   <li>{@link Clock}: {@link Clock#DEFAULT}
+     * </ul>
+     *
+     * @param context A {@link Context}.
+     */
+    public Builder(Context context) {
+      this(context, new DefaultRenderersFactory(context));
+    }
+
+    /**
+     * Creates a builder with a custom {@link RenderersFactory}.
+     *
+     * <p>See {@link #Builder(Context)} for a list of default values.
+     *
+     * @param context A {@link Context}.
+     * @param renderersFactory A factory for creating {@link Renderer Renderers} to be used by the
+     *     player.
+     */
+    public Builder(Context context, RenderersFactory renderersFactory) {
+      this(
+          context,
+          renderersFactory,
+          new DefaultTrackSelector(context),
+          new DefaultLoadControl(),
+          DefaultBandwidthMeter.getSingletonInstance(context),
+          Util.getLooper(),
+          new AnalyticsCollector(Clock.DEFAULT),
+          Clock.DEFAULT);
+    }
+
+    /**
+     * Creates a builder with the specified custom components.
+     *
+     * <p>Note that this constructor is only useful if you try to ensure that ExoPlayer's default
+     * components can be removed by ProGuard or R8. For most components except renderers, there is
+     * only a marginal benefit of doing that.
+     *
+     * @param context A {@link Context}.
+     * @param renderersFactory A factory for creating {@link Renderer Renderers} to be used by the
+     *     player.
+     * @param trackSelector A {@link TrackSelector}.
+     * @param loadControl A {@link LoadControl}.
+     * @param bandwidthMeter A {@link BandwidthMeter}.
+     * @param looper A {@link Looper} that must be used for all calls to the player.
+     * @param analyticsCollector An {@link AnalyticsCollector}.
+     * @param clock A {@link Clock}. Should always be {@link Clock#DEFAULT}.
+     */
+    public Builder(
+        Context context,
+        RenderersFactory renderersFactory,
+        TrackSelector trackSelector,
+        LoadControl loadControl,
+        BandwidthMeter bandwidthMeter,
+        Looper looper,
+        AnalyticsCollector analyticsCollector,
+        Clock clock) {
+      this.context = context;
+      this.renderersFactory = renderersFactory;
+      this.trackSelector = trackSelector;
+      this.loadControl = loadControl;
+      this.bandwidthMeter = bandwidthMeter;
+      this.looper = looper;
+      this.analyticsCollector = analyticsCollector;
+      this.clock = clock;
+    }
+
+    /**
+     * Sets the {@link TrackSelector} that will be used by the player.
+     *
+     * @param trackSelector A {@link TrackSelector}.
+     * @return This builder.
+     * @throws IllegalStateException If {@link #build()} has already been called.
+     */
+    public Builder setTrackSelector(TrackSelector trackSelector) {
+      Assertions.checkState(!buildCalled);
+      this.trackSelector = trackSelector;
+      return this;
+    }
+
+    /**
+     * Sets the {@link LoadControl} that will be used by the player.
+     *
+     * @param loadControl A {@link LoadControl}.
+     * @return This builder.
+     * @throws IllegalStateException If {@link #build()} has already been called.
+     */
+    public Builder setLoadControl(LoadControl loadControl) {
+      Assertions.checkState(!buildCalled);
+      this.loadControl = loadControl;
+      return this;
+    }
+
+    /**
+     * Sets the {@link BandwidthMeter} that will be used by the player.
+     *
+     * @param bandwidthMeter A {@link BandwidthMeter}.
+     * @return This builder.
+     * @throws IllegalStateException If {@link #build()} has already been called.
+     */
+    public Builder setBandwidthMeter(BandwidthMeter bandwidthMeter) {
+      Assertions.checkState(!buildCalled);
+      this.bandwidthMeter = bandwidthMeter;
+      return this;
+    }
+
+    /**
+     * Sets the {@link Looper} that must be used for all calls to the player and that is used to
+     * call listeners on.
+     *
+     * @param looper A {@link Looper}.
+     * @return This builder.
+     * @throws IllegalStateException If {@link #build()} has already been called.
+     */
+    public Builder setLooper(Looper looper) {
+      Assertions.checkState(!buildCalled);
+      this.looper = looper;
+      return this;
+    }
+
+    /**
+     * Sets the {@link AnalyticsCollector} that will collect and forward all player events.
+     *
+     * @param analyticsCollector An {@link AnalyticsCollector}.
+     * @return This builder.
+     * @throws IllegalStateException If {@link #build()} has already been called.
+     */
+    public Builder setAnalyticsCollector(AnalyticsCollector analyticsCollector) {
+      Assertions.checkState(!buildCalled);
+      this.analyticsCollector = analyticsCollector;
+      return this;
+    }
+
+    /**
+     * Sets the {@link Clock} that will be used by the player. Should only be set for testing
+     * purposes.
+     *
+     * @param clock A {@link Clock}.
+     * @return This builder.
+     * @throws IllegalStateException If {@link #build()} has already been called.
+     */
+    @VisibleForTesting
+    public Builder setClock(Clock clock) {
+      Assertions.checkState(!buildCalled);
+      this.clock = clock;
+      return this;
+    }
+
+    /**
+     * Builds a {@link SimpleExoPlayer} instance.
+     *
+     * @throws IllegalStateException If {@link #build()} has already been called.
+     */
+    public SimpleExoPlayer build() {
+      Assertions.checkState(!buildCalled);
+      buildCalled = true;
+      return new SimpleExoPlayer(
+          context,
+          renderersFactory,
+          trackSelector,
+          loadControl,
+          bandwidthMeter,
+          analyticsCollector,
+          clock,
+          looper);
+    }
+  }
+
   private static final String TAG = "SimpleExoPlayer";
 
   protected final Renderer[] renderers;
@@ -128,7 +334,11 @@
    *     will not be used for DRM protected playbacks.
    * @param looper The {@link Looper} which must be used for all calls to the player and which is
    *     used to call listeners on.
+   * @deprecated Use {@link #SimpleExoPlayer(Context, RenderersFactory, TrackSelector, LoadControl,
+   *     BandwidthMeter, AnalyticsCollector, Clock, Looper)} instead, and pass the {@link
+   *     DrmSessionManager} to the {@link MediaSource} factories.
    */
+  @Deprecated
   protected SimpleExoPlayer(
       Context context,
       RenderersFactory renderersFactory,
@@ -160,7 +370,11 @@ protected SimpleExoPlayer(
    *     player events.
    * @param looper The {@link Looper} which must be used for all calls to the player and which is
    *     used to call listeners on.
+   * @deprecated Use {@link #SimpleExoPlayer(Context, RenderersFactory, TrackSelector, LoadControl,
+   *     BandwidthMeter, AnalyticsCollector, Clock, Looper)} instead, and pass the {@link
+   *     DrmSessionManager} to the {@link MediaSource} factories.
    */
+  @Deprecated
   protected SimpleExoPlayer(
       Context context,
       RenderersFactory renderersFactory,
@@ -182,6 +396,41 @@ protected SimpleExoPlayer(
         looper);
   }
 
+  /**
+   * @param context A {@link Context}.
+   * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
+   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
+   * @param loadControl The {@link LoadControl} that will be used by the instance.
+   * @param bandwidthMeter The {@link BandwidthMeter} that will be used by the instance.
+   * @param analyticsCollector A factory for creating the {@link AnalyticsCollector} that will
+   *     collect and forward all player events.
+   * @param clock The {@link Clock} that will be used by the instance. Should always be {@link
+   *     Clock#DEFAULT}, unless the player is being used from a test.
+   * @param looper The {@link Looper} which must be used for all calls to the player and which is
+   *     used to call listeners on.
+   */
+  @SuppressWarnings("deprecation")
+  protected SimpleExoPlayer(
+      Context context,
+      RenderersFactory renderersFactory,
+      TrackSelector trackSelector,
+      LoadControl loadControl,
+      BandwidthMeter bandwidthMeter,
+      AnalyticsCollector analyticsCollector,
+      Clock clock,
+      Looper looper) {
+    this(
+        context,
+        renderersFactory,
+        trackSelector,
+        loadControl,
+        DrmSessionManager.getDummyDrmSessionManager(),
+        bandwidthMeter,
+        analyticsCollector,
+        clock,
+        looper);
+  }
+
   /**
    * @param context A {@link Context}.
    * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
@@ -196,7 +445,11 @@ protected SimpleExoPlayer(
    *     Clock#DEFAULT}, unless the player is being used from a test.
    * @param looper The {@link Looper} which must be used for all calls to the player and which is
    *     used to call listeners on.
+   * @deprecated Use {@link #SimpleExoPlayer(Context, RenderersFactory, TrackSelector, LoadControl,
+   *     BandwidthMeter, AnalyticsCollector, Clock, Looper)} instead, and pass the {@link
+   *     DrmSessionManager} to the {@link MediaSource} factories.
    */
+  @Deprecated
   protected SimpleExoPlayer(
       Context context,
       RenderersFactory renderersFactory,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/analytics/package-info.java b/library/core/src/main/java/com/google/android/exoplayer2/analytics/package-info.java
new file mode 100644
index 0000000000..2764120d2a
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/analytics/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.analytics;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java
index 4e4964e817..05c20939ff 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java
@@ -156,7 +156,7 @@ private SyncFrameInfo(
    * @return The AC-3 format parsed from data in the header.
    */
   public static Format parseAc3AnnexFFormat(
-      ParsableByteArray data, String trackId, String language, DrmInitData drmInitData) {
+      ParsableByteArray data, String trackId, String language, @Nullable DrmInitData drmInitData) {
     int fscod = (data.readUnsignedByte() & 0xC0) >> 6;
     int sampleRate = SAMPLE_RATE_BY_FSCOD[fscod];
     int nextByte = data.readUnsignedByte();
@@ -189,7 +189,7 @@ public static Format parseAc3AnnexFFormat(
    * @return The E-AC-3 format parsed from data in the header.
    */
   public static Format parseEAc3AnnexFFormat(
-      ParsableByteArray data, String trackId, String language, DrmInitData drmInitData) {
+      ParsableByteArray data, String trackId, String language, @Nullable DrmInitData drmInitData) {
     data.skipBytes(2); // data_rate, num_ind_sub
 
     // Read the first independent substream.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac4Util.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac4Util.java
index 74bd5bfe98..c54e3844a3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac4Util.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac4Util.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.audio;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.drm.DrmInitData;
@@ -95,7 +96,7 @@ private SyncFrameInfo(
    * @return The AC-4 format parsed from data in the header.
    */
   public static Format parseAc4AnnexEFormat(
-      ParsableByteArray data, String trackId, String language, DrmInitData drmInitData) {
+      ParsableByteArray data, String trackId, String language, @Nullable DrmInitData drmInitData) {
     data.skipBytes(1); // ac4_dsi_version, bitstream_version[0:5]
     int sampleRate = ((data.readUnsignedByte() & 0x20) >> 5 == 1) ? 48000 : 44100;
     return Format.createAudioSampleFormat(
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioAttributes.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioAttributes.java
index 9c63eb42c6..1b0d629da7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioAttributes.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioAttributes.java
@@ -92,7 +92,7 @@ public AudioAttributes build() {
   public final @C.AudioFlags int flags;
   public final @C.AudioUsage int usage;
 
-  private @Nullable android.media.AudioAttributes audioAttributesV21;
+  @Nullable private android.media.AudioAttributes audioAttributesV21;
 
   private AudioAttributes(@C.AudioContentType int contentType, @C.AudioFlags int flags,
       @C.AudioUsage int usage) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/DtsUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/DtsUtil.java
index f65dc3fc4e..7af9d9f074 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/DtsUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/DtsUtil.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.audio;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.util.MimeTypes;
@@ -80,7 +81,7 @@ public static boolean isSyncWord(int word) {
    * @return The DTS format parsed from data in the header.
    */
   public static Format parseDtsFormat(
-      byte[] frame, String trackId, String language, DrmInitData drmInitData) {
+      byte[] frame, String trackId, @Nullable String language, @Nullable DrmInitData drmInitData) {
     ParsableBitArray frameBits = getNormalizedFrameHeader(frame);
     frameBits.skipBits(32 + 1 + 5 + 1 + 7 + 14); // SYNC, FTYPE, SHORT, CPF, NBLKS, FSIZE
     int amode = frameBits.readBits(6);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
index 6a29f316e1..251901f4f2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
@@ -300,8 +300,10 @@ public MediaCodecAudioRenderer(
   }
 
   @Override
-  protected int supportsFormat(MediaCodecSelector mediaCodecSelector,
-      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager, Format format)
+  protected int supportsFormat(
+      MediaCodecSelector mediaCodecSelector,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      Format format)
       throws DecoderQueryException {
     String mimeType = format.sampleMimeType;
     if (!MimeTypes.isAudio(mimeType)) {
@@ -386,7 +388,7 @@ protected void configureCodec(
       MediaCodecInfo codecInfo,
       MediaCodec codec,
       Format format,
-      MediaCrypto crypto,
+      @Nullable MediaCrypto crypto,
       float codecOperatingRate) {
     codecMaxInputSize = getCodecMaxInputSize(codecInfo, format, getStreamFormats());
     codecNeedsDiscardChannelsWorkaround = codecNeedsDiscardChannelsWorkaround(codecInfo.name);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/package-info.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/package-info.java
new file mode 100644
index 0000000000..5ae2413d92
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.audio;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/database/package-info.java b/library/core/src/main/java/com/google/android/exoplayer2/database/package-info.java
new file mode 100644
index 0000000000..4921e1aeea
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/database/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.database;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/decoder/Decoder.java b/library/core/src/main/java/com/google/android/exoplayer2/decoder/Decoder.java
index 7eb1fa1aa1..4552d190c3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/decoder/Decoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/decoder/Decoder.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.decoder;
 
+import androidx.annotation.Nullable;
+
 /**
  * A media decoder.
  *
@@ -37,6 +39,7 @@
    * @return The input buffer, which will have been cleared, or null if a buffer isn't available.
    * @throws E If a decoder error has occurred.
    */
+  @Nullable
   I dequeueInputBuffer() throws E;
 
   /**
@@ -53,6 +56,7 @@
    * @return The output buffer, or null if an output buffer isn't available.
    * @throws E If a decoder error has occurred.
    */
+  @Nullable
   O dequeueOutputBuffer() throws E;
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java b/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
index 7fc6fb625a..c31ae92cfc 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
@@ -16,11 +16,13 @@
 package com.google.android.exoplayer2.decoder;
 
 import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
+import org.checkerframework.checker.nullness.qual.EnsuresNonNull;
 
 /**
  * Holds input for a decoder.
@@ -58,10 +60,8 @@
    */
   public final CryptoInfo cryptoInfo;
 
-  /**
-   * The buffer's data, or {@code null} if no data has been set.
-   */
-  public ByteBuffer data;
+  /** The buffer's data, or {@code null} if no data has been set. */
+  @Nullable public ByteBuffer data;
 
   /**
    * The time at which the sample should be presented.
@@ -101,6 +101,7 @@ public DecoderInputBuffer(@BufferReplacementMode int bufferReplacementMode) {
    * @throws IllegalStateException If there is insufficient capacity to accommodate the write and
    *     the buffer replacement mode of the holder is {@link #BUFFER_REPLACEMENT_MODE_DISABLED}.
    */
+  @EnsuresNonNull("data")
   public void ensureSpaceForWrite(int length) {
     if (data == null) {
       data = createReplacementByteBuffer(length);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleDecoder.java
index b5650860e9..b7465f82eb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleDecoder.java
@@ -86,6 +86,7 @@ protected final void setInitialInputBufferSize(int size) {
   }
 
   @Override
+  @Nullable
   public final I dequeueInputBuffer() throws E {
     synchronized (lock) {
       maybeThrowException();
@@ -108,6 +109,7 @@ public final void queueInputBuffer(I inputBuffer) throws E {
   }
 
   @Override
+  @Nullable
   public final O dequeueOutputBuffer() throws E {
     synchronized (lock) {
       maybeThrowException();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleOutputBuffer.java b/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleOutputBuffer.java
index 49c7dafbd6..84cffc1145 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleOutputBuffer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleOutputBuffer.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.decoder;
 
+import androidx.annotation.Nullable;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 
@@ -25,7 +26,7 @@
 
   private final SimpleDecoder<?, SimpleOutputBuffer, ?> owner;
 
-  public ByteBuffer data;
+  @Nullable public ByteBuffer data;
 
   public SimpleOutputBuffer(SimpleDecoder<?, SimpleOutputBuffer, ?> owner) {
     this.owner = owner;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/decoder/package-info.java b/library/core/src/main/java/com/google/android/exoplayer2/decoder/package-info.java
new file mode 100644
index 0000000000..0c4dbde9d3
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/decoder/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.decoder;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/package-info.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/package-info.java
new file mode 100644
index 0000000000..d4820dd204
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.drm;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
index 974e033b67..ee2c9ad1a3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
@@ -452,12 +452,14 @@ public final int supportsFormat(Format format) throws ExoPlaybackException {
    * @param mediaCodecSelector The decoder selector.
    * @param drmSessionManager The renderer's {@link DrmSessionManager}.
    * @param format The format.
-   * @return The extent to which the renderer is capable of supporting the given format. See
-   *     {@link #supportsFormat(Format)} for more detail.
+   * @return The extent to which the renderer is capable of supporting the given format. See {@link
+   *     #supportsFormat(Format)} for more detail.
    * @throws DecoderQueryException If there was an error querying decoders.
    */
-  protected abstract int supportsFormat(MediaCodecSelector mediaCodecSelector,
-      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager, Format format)
+  protected abstract int supportsFormat(
+      MediaCodecSelector mediaCodecSelector,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      Format format)
       throws DecoderQueryException;
 
   /**
@@ -487,7 +489,7 @@ protected abstract void configureCodec(
       MediaCodecInfo codecInfo,
       MediaCodec codec,
       Format format,
-      MediaCrypto crypto,
+      @Nullable MediaCrypto crypto,
       float codecOperatingRate);
 
   protected final void maybeInitCodec() throws ExoPlaybackException {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
index cd4c4863ff..9c42916cad 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
@@ -239,6 +239,7 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
    * @return A pair (profile constant, level constant) if the codec of the {@code format} is
    *     well-formed and recognized, or null otherwise.
    */
+  @Nullable
   public static Pair<Integer, Integer> getCodecProfileAndLevel(Format format) {
     if (format.codecs == null) {
       return null;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/package-info.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/package-info.java
new file mode 100644
index 0000000000..b09404a6f8
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.mediacodec;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/Metadata.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/Metadata.java
index 7b4f4c0836..35702da576 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/Metadata.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/Metadata.java
@@ -18,6 +18,7 @@
 import android.os.Parcel;
 import android.os.Parcelable;
 import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
 import java.util.List;
@@ -28,10 +29,27 @@
  */
 public final class Metadata implements Parcelable {
 
-  /**
-   * A metadata entry.
-   */
-  public interface Entry extends Parcelable {}
+  /** A metadata entry. */
+  public interface Entry extends Parcelable {
+
+    /**
+     * Returns the {@link Format} that can be used to decode the wrapped metadata in {@link
+     * #getWrappedMetadataBytes()}, or null if this Entry doesn't contain wrapped metadata.
+     */
+    @Nullable
+    default Format getWrappedMetadataFormat() {
+      return null;
+    }
+
+    /**
+     * Returns the bytes of the wrapped metadata in this Entry, or null if it doesn't contain
+     * wrapped metadata.
+     */
+    @Nullable
+    default byte[] getWrappedMetadataBytes() {
+      return null;
+    }
+  }
 
   private final Entry[] entries;
 
@@ -122,6 +140,11 @@ public int hashCode() {
     return Arrays.hashCode(entries);
   }
 
+  @Override
+  public String toString() {
+    return "entries=" + Arrays.toString(entries);
+  }
+
   // Parcelable implementation.
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
index 0fc0a85104..0dc0dc6096 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
@@ -27,7 +27,9 @@
 import com.google.android.exoplayer2.FormatHolder;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.List;
 
 /**
  * A renderer for metadata.
@@ -123,12 +125,18 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
         } else {
           buffer.subsampleOffsetUs = subsampleOffsetUs;
           buffer.flip();
-          int index = (pendingMetadataIndex + pendingMetadataCount) % MAX_PENDING_METADATA_COUNT;
           Metadata metadata = decoder.decode(buffer);
           if (metadata != null) {
-            pendingMetadata[index] = metadata;
-            pendingMetadataTimestamps[index] = buffer.timeUs;
-            pendingMetadataCount++;
+            List<Metadata.Entry> entries = new ArrayList<>(metadata.length());
+            decodeWrappedMetadata(metadata, entries);
+            if (!entries.isEmpty()) {
+              Metadata expandedMetadata = new Metadata(entries);
+              int index =
+                  (pendingMetadataIndex + pendingMetadataCount) % MAX_PENDING_METADATA_COUNT;
+              pendingMetadata[index] = expandedMetadata;
+              pendingMetadataTimestamps[index] = buffer.timeUs;
+              pendingMetadataCount++;
+            }
           }
         }
       } else if (result == C.RESULT_FORMAT_READ) {
@@ -144,6 +152,36 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
     }
   }
 
+  /**
+   * Iterates through {@code metadata.entries} and checks each one to see if contains wrapped
+   * metadata. If it does, then we recursively decode the wrapped metadata. If it doesn't (recursion
+   * base-case), we add the {@link Metadata.Entry} to {@code decodedEntries} (output parameter).
+   */
+  private void decodeWrappedMetadata(Metadata metadata, List<Metadata.Entry> decodedEntries) {
+    for (int i = 0; i < metadata.length(); i++) {
+      Format wrappedMetadataFormat = metadata.get(i).getWrappedMetadataFormat();
+      if (wrappedMetadataFormat != null && decoderFactory.supportsFormat(wrappedMetadataFormat)) {
+        MetadataDecoder wrappedMetadataDecoder =
+            decoderFactory.createDecoder(wrappedMetadataFormat);
+        // wrappedMetadataFormat != null so wrappedMetadataBytes must be non-null too.
+        byte[] wrappedMetadataBytes =
+            Assertions.checkNotNull(metadata.get(i).getWrappedMetadataBytes());
+        buffer.clear();
+        buffer.ensureSpaceForWrite(wrappedMetadataBytes.length);
+        buffer.data.put(wrappedMetadataBytes);
+        buffer.flip();
+        @Nullable Metadata innerMetadata = wrappedMetadataDecoder.decode(buffer);
+        if (innerMetadata != null) {
+          // The decoding succeeded, so we'll try another level of unwrapping.
+          decodeWrappedMetadata(innerMetadata, decodedEntries);
+        }
+      } else {
+        // Entry doesn't contain any wrapped metadata, so output it directly.
+        decodedEntries.add(metadata.get(i));
+      }
+    }
+  }
+
   @Override
   protected void onDisabled() {
     flushPendingMetadata();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java
index ca1e390181..c9e9d54093 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java
@@ -20,7 +20,10 @@
 import android.os.Parcel;
 import android.os.Parcelable;
 import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
 
@@ -29,6 +32,13 @@
  */
 public final class EventMessage implements Metadata.Entry {
 
+  @VisibleForTesting
+  public static final String ID3_SCHEME_ID = "https://developer.apple.com/streaming/emsg-id3";
+
+  private static final Format ID3_FORMAT =
+      Format.createSampleFormat(
+          /* id= */ null, MimeTypes.APPLICATION_ID3, Format.OFFSET_SAMPLE_RELATIVE);
+
   /**
    * The message scheme.
    */
@@ -81,6 +91,18 @@ public EventMessage(
     messageData = castNonNull(in.createByteArray());
   }
 
+  @Override
+  @Nullable
+  public Format getWrappedMetadataFormat() {
+    return ID3_SCHEME_ID.equals(schemeIdUri) ? ID3_FORMAT : null;
+  }
+
+  @Override
+  @Nullable
+  public byte[] getWrappedMetadataBytes() {
+    return ID3_SCHEME_ID.equals(schemeIdUri) ? messageData : null;
+  }
+
   @Override
   public int hashCode() {
     if (hashCode == 0) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
index f592a6eee7..a1196c41c8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
@@ -29,7 +29,7 @@
   @SuppressWarnings("ByteBufferBackingArray")
   @Override
   public Metadata decode(MetadataInputBuffer inputBuffer) {
-    ByteBuffer buffer = inputBuffer.data;
+    ByteBuffer buffer = Assertions.checkNotNull(inputBuffer.data);
     byte[] data = buffer.array();
     int size = buffer.limit();
     return new Metadata(decode(new ParsableByteArray(data, size)));
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyDecoder.java
index 3d873926bb..12f65f1cda 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyDecoder.java
@@ -20,6 +20,7 @@
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataDecoder;
 import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 import java.nio.ByteBuffer;
@@ -39,7 +40,7 @@
   @Nullable
   @SuppressWarnings("ByteBufferBackingArray")
   public Metadata decode(MetadataInputBuffer inputBuffer) {
-    ByteBuffer buffer = inputBuffer.data;
+    ByteBuffer buffer = Assertions.checkNotNull(inputBuffer.data);
     byte[] data = buffer.array();
     int length = buffer.limit();
     return decode(Util.fromUtf8Bytes(data, 0, length));
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
index 85a59c3aeb..c8755f9aee 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
@@ -20,6 +20,7 @@
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataDecoder;
 import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
@@ -99,7 +100,7 @@ public Id3Decoder(@Nullable FramePredicate framePredicate) {
   @Override
   @Nullable
   public Metadata decode(MetadataInputBuffer inputBuffer) {
-    ByteBuffer buffer = inputBuffer.data;
+    ByteBuffer buffer = Assertions.checkNotNull(inputBuffer.data);
     return decode(buffer.array(), buffer.limit());
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/TextInformationFrame.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/TextInformationFrame.java
index 0e129ca7bb..8337911c0d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/TextInformationFrame.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/TextInformationFrame.java
@@ -66,7 +66,7 @@ public int hashCode() {
 
   @Override
   public String toString() {
-    return id + ": value=" + value;
+    return id + ": description=" + description + ": value=" + value;
   }
 
   // Parcelable implementation.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/package-info.java b/library/core/src/main/java/com/google/android/exoplayer2/package-info.java
new file mode 100644
index 0000000000..690f2c40c3
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/scheduler/package-info.java b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/package-info.java
new file mode 100644
index 0000000000..6273f325c4
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/scheduler/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.scheduler;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeMediaSource.java
index 4ebe97313b..7077416a02 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeMediaSource.java
@@ -96,11 +96,11 @@ protected abstract void onChildSourceInfoRefreshed(
   /**
    * Prepares a child source.
    *
-   * <p>{@link #onChildSourceInfoRefreshed(T, MediaSource, Timeline)} will be called when the child
-   * source updates its timeline with the same {@code id} passed to this method.
+   * <p>{@link #onChildSourceInfoRefreshed(Object, MediaSource, Timeline)} will be called when the
+   * child source updates its timeline with the same {@code id} passed to this method.
    *
-   * <p>Any child sources that aren't explicitly released with {@link #releaseChildSource(T)} will
-   * be released in {@link #releaseSourceInternal()}.
+   * <p>Any child sources that aren't explicitly released with {@link #releaseChildSource(Object)}
+   * will be released in {@link #releaseSourceInternal()}.
    *
    * @param id A unique id to identify the child source preparation. Null is allowed as an id.
    * @param mediaSource The child {@link MediaSource}.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SilenceMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SilenceMediaSource.java
index c3eab68983..3bb7ada7e0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SilenceMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SilenceMediaSource.java
@@ -220,9 +220,9 @@ public int readData(
 
       int bytesToWrite = (int) Math.min(SILENCE_SAMPLE.length, bytesRemaining);
       buffer.ensureSpaceForWrite(bytesToWrite);
-      buffer.addFlag(C.BUFFER_FLAG_KEY_FRAME);
       buffer.data.put(SILENCE_SAMPLE, /* offset= */ 0, bytesToWrite);
       buffer.timeUs = getAudioPositionUs(positionBytes);
+      buffer.addFlag(C.BUFFER_FLAG_KEY_FRAME);
       positionBytes += bytesToWrite;
       return C.RESULT_BUFFER_READ;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
index c5d22c15cb..fc3783d56b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
@@ -17,7 +17,6 @@
 
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
@@ -48,8 +47,6 @@
     private final long minTimeBetweenBufferReevaluationMs;
     private final Clock clock;
 
-    private TrackBitrateEstimator trackBitrateEstimator;
-
     /** Creates an adaptive track selection factory with default parameters. */
     public Factory() {
       this(
@@ -64,7 +61,7 @@ public Factory() {
 
     /**
      * @deprecated Use {@link #Factory()} instead. Custom bandwidth meter should be directly passed
-     *     to the player in {@link ExoPlayerFactory}.
+     *     to the player in {@link SimpleExoPlayer.Builder}.
      */
     @Deprecated
     @SuppressWarnings("deprecation")
@@ -112,7 +109,7 @@ public Factory(
 
     /**
      * @deprecated Use {@link #Factory(int, int, int, float)} instead. Custom bandwidth meter should
-     *     be directly passed to the player in {@link ExoPlayerFactory}.
+     *     be directly passed to the player in {@link SimpleExoPlayer.Builder}.
      */
     @Deprecated
     @SuppressWarnings("deprecation")
@@ -181,7 +178,8 @@ public Factory(
 
     /**
      * @deprecated Use {@link #Factory(int, int, int, float, float, long, Clock)} instead. Custom
-     *     bandwidth meter should be directly passed to the player in {@link ExoPlayerFactory}.
+     *     bandwidth meter should be directly passed to the player in {@link
+     *     SimpleExoPlayer.Builder}.
      */
     @Deprecated
     public Factory(
@@ -202,19 +200,6 @@ public Factory(
           bufferedFractionToLiveEdgeForQualityIncrease;
       this.minTimeBetweenBufferReevaluationMs = minTimeBetweenBufferReevaluationMs;
       this.clock = clock;
-      trackBitrateEstimator = TrackBitrateEstimator.DEFAULT;
-    }
-
-    /**
-     * Sets a TrackBitrateEstimator.
-     *
-     * <p>This method is experimental, and will be renamed or removed in a future release.
-     *
-     * @param trackBitrateEstimator A {@link TrackBitrateEstimator}.
-     */
-    public final void experimental_setTrackBitrateEstimator(
-        TrackBitrateEstimator trackBitrateEstimator) {
-      this.trackBitrateEstimator = trackBitrateEstimator;
     }
 
     @Override
@@ -245,7 +230,6 @@ public final void experimental_setTrackBitrateEstimator(
           AdaptiveTrackSelection adaptiveSelection =
               createAdaptiveTrackSelection(
                   definition.group, bandwidthMeter, definition.tracks, totalFixedBandwidth);
-          adaptiveSelection.experimental_setTrackBitrateEstimator(trackBitrateEstimator);
           adaptiveSelections.add(adaptiveSelection);
           selections[i] = adaptiveSelection;
         }
@@ -312,11 +296,7 @@ protected AdaptiveTrackSelection createAdaptiveTrackSelection(
   private final float bufferedFractionToLiveEdgeForQualityIncrease;
   private final long minTimeBetweenBufferReevaluationMs;
   private final Clock clock;
-  private final Format[] formats;
-  private final int[] formatBitrates;
-  private final int[] trackBitrates;
 
-  private TrackBitrateEstimator trackBitrateEstimator;
   private float playbackSpeed;
   private int selectedIndex;
   private int reason;
@@ -419,27 +399,6 @@ private AdaptiveTrackSelection(
     playbackSpeed = 1f;
     reason = C.SELECTION_REASON_UNKNOWN;
     lastBufferEvaluationMs = C.TIME_UNSET;
-    trackBitrateEstimator = TrackBitrateEstimator.DEFAULT;
-    formats = new Format[length];
-    formatBitrates = new int[length];
-    trackBitrates = new int[length];
-    for (int i = 0; i < length; i++) {
-      @SuppressWarnings("nullness:method.invocation.invalid")
-      Format format = getFormat(i);
-      formats[i] = format;
-      formatBitrates[i] = formats[i].bitrate;
-    }
-  }
-
-  /**
-   * Sets a TrackBitrateEstimator.
-   *
-   * <p>This method is experimental, and will be renamed or removed in a future release.
-   *
-   * @param trackBitrateEstimator A {@link TrackBitrateEstimator}.
-   */
-  public void experimental_setTrackBitrateEstimator(TrackBitrateEstimator trackBitrateEstimator) {
-    this.trackBitrateEstimator = trackBitrateEstimator;
   }
 
   /**
@@ -472,19 +431,16 @@ public void updateSelectedTrack(
       MediaChunkIterator[] mediaChunkIterators) {
     long nowMs = clock.elapsedRealtime();
 
-    // Update the estimated track bitrates.
-    trackBitrateEstimator.getBitrates(formats, queue, mediaChunkIterators, trackBitrates);
-
     // Make initial selection
     if (reason == C.SELECTION_REASON_UNKNOWN) {
       reason = C.SELECTION_REASON_INITIAL;
-      selectedIndex = determineIdealSelectedIndex(nowMs, trackBitrates);
+      selectedIndex = determineIdealSelectedIndex(nowMs);
       return;
     }
 
     // Stash the current selection, then make a new one.
     int currentSelectedIndex = selectedIndex;
-    selectedIndex = determineIdealSelectedIndex(nowMs, trackBitrates);
+    selectedIndex = determineIdealSelectedIndex(nowMs);
     if (selectedIndex == currentSelectedIndex) {
       return;
     }
@@ -548,7 +504,7 @@ public int evaluateQueueSize(long playbackPositionUs, List<? extends MediaChunk>
     if (playoutBufferedDurationBeforeLastChunkUs < minDurationToRetainAfterDiscardUs) {
       return queueSize;
     }
-    int idealSelectedIndex = determineIdealSelectedIndex(nowMs, formatBitrates);
+    int idealSelectedIndex = determineIdealSelectedIndex(nowMs);
     Format idealFormat = getFormat(idealSelectedIndex);
     // If the chunks contain video, discard from the first SD chunk beyond
     // minDurationToRetainAfterDiscardUs whose resolution and bitrate are both lower than the ideal
@@ -613,16 +569,14 @@ protected long getMinDurationToRetainAfterDiscardUs() {
    *
    * @param nowMs The current time in the timebase of {@link Clock#elapsedRealtime()}, or {@link
    *     Long#MIN_VALUE} to ignore blacklisting.
-   * @param trackBitrates The estimated track bitrates. May differ from format bitrates if more
-   *     accurate estimates of the current track bitrates are available.
    */
-  private int determineIdealSelectedIndex(long nowMs, int[] trackBitrates) {
+  private int determineIdealSelectedIndex(long nowMs) {
     long effectiveBitrate = bandwidthProvider.getAllocatedBandwidth();
     int lowestBitrateNonBlacklistedIndex = 0;
     for (int i = 0; i < length; i++) {
       if (nowMs == Long.MIN_VALUE || !isBlacklisted(i, nowMs)) {
         Format format = getFormat(i);
-        if (canSelectFormat(format, trackBitrates[i], playbackSpeed, effectiveBitrate)) {
+        if (canSelectFormat(format, format.bitrate, playbackSpeed, effectiveBitrate)) {
           return i;
         } else {
           lowestBitrateNonBlacklistedIndex = i;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
index 8e1284f7ef..b43701f1bc 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
@@ -26,7 +26,6 @@
 import android.util.SparseBooleanArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
-import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Renderer;
@@ -1408,7 +1407,7 @@ public DefaultTrackSelector() {
 
   /**
    * @deprecated Use {@link #DefaultTrackSelector(Context)} instead. The bandwidth meter should be
-   *     passed directly to the player in {@link ExoPlayerFactory}.
+   *     passed directly to the player in {@link SimpleExoPlayer.Builder}.
    */
   @Deprecated
   @SuppressWarnings("deprecation")
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackBitrateEstimator.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackBitrateEstimator.java
deleted file mode 100644
index 1cd6c09bfe..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackBitrateEstimator.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.android.exoplayer2.trackselection;
-
-import androidx.annotation.Nullable;
-import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.source.chunk.MediaChunk;
-import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
-import java.util.List;
-
-/** Estimates track bitrate values. */
-public interface TrackBitrateEstimator {
-
-  /**
-   * A {@link TrackBitrateEstimator} that returns the bitrate values defined in the track formats.
-   */
-  TrackBitrateEstimator DEFAULT =
-      (formats, queue, iterators, bitrates) ->
-          TrackSelectionUtil.getFormatBitrates(formats, bitrates);
-
-  /**
-   * Returns bitrate values for a set of tracks whose formats are given.
-   *
-   * @param formats The track formats.
-   * @param queue The queue of already buffered {@link MediaChunk} instances. Must not be modified.
-   * @param iterators An array of {@link MediaChunkIterator}s providing information about the
-   *     sequence of upcoming media chunks for each track.
-   * @param bitrates An array into which the bitrate values will be written. If non-null, this array
-   *     is the one that will be returned.
-   * @return Bitrate values for the tracks. As long as the format of a track has set bitrate, a
-   *     bitrate value is set in the returned array. Otherwise it might be set to {@link
-   *     Format#NO_VALUE}.
-   */
-  int[] getBitrates(
-      Format[] formats,
-      List<? extends MediaChunk> queue,
-      MediaChunkIterator[] iterators,
-      @Nullable int[] bitrates);
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionUtil.java
index 71afd87b0f..0f2748b1ac 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionUtil.java
@@ -16,18 +16,9 @@
 package com.google.android.exoplayer2.trackselection;
 
 import androidx.annotation.Nullable;
-import androidx.annotation.VisibleForTesting;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.source.chunk.MediaChunk;
-import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
-import com.google.android.exoplayer2.source.chunk.MediaChunkListIterator;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector.SelectionOverride;
 import com.google.android.exoplayer2.trackselection.TrackSelection.Definition;
-import com.google.android.exoplayer2.util.Assertions;
-import java.util.Arrays;
-import java.util.List;
 import org.checkerframework.checker.nullness.compatqual.NullableType;
 
 /** Track selection related utility methods. */
@@ -106,261 +97,4 @@ private TrackSelectionUtil() {}
     }
     return builder.build();
   }
-
-  /**
-   * Returns average bitrate for chunks in bits per second. Chunks are included in average until
-   * {@code maxDurationMs} or the first unknown length chunk.
-   *
-   * @param iterator Iterator for media chunk sequences.
-   * @param maxDurationUs Maximum duration of chunks to be included in average bitrate, in
-   *     microseconds.
-   * @return Average bitrate for chunks in bits per second, or {@link Format#NO_VALUE} if there are
-   *     no chunks or the first chunk length is unknown.
-   */
-  public static int getAverageBitrate(MediaChunkIterator iterator, long maxDurationUs) {
-    long totalDurationUs = 0;
-    long totalLength = 0;
-    while (iterator.next()) {
-      long chunkLength = iterator.getDataSpec().length;
-      if (chunkLength == C.LENGTH_UNSET) {
-        break;
-      }
-      long chunkDurationUs = iterator.getChunkEndTimeUs() - iterator.getChunkStartTimeUs();
-      if (totalDurationUs + chunkDurationUs >= maxDurationUs) {
-        totalLength += chunkLength * (maxDurationUs - totalDurationUs) / chunkDurationUs;
-        totalDurationUs = maxDurationUs;
-        break;
-      }
-      totalDurationUs += chunkDurationUs;
-      totalLength += chunkLength;
-    }
-    return totalDurationUs == 0
-        ? Format.NO_VALUE
-        : (int) (totalLength * C.BITS_PER_BYTE * C.MICROS_PER_SECOND / totalDurationUs);
-  }
-
-  /**
-   * Returns bitrate values for a set of tracks whose upcoming media chunk iterators and formats are
-   * given.
-   *
-   * <p>If an average bitrate can't be calculated, an estimation is calculated using average bitrate
-   * of another track and the ratio of the bitrate values defined in the formats of the two tracks.
-   *
-   * @param iterators An array of {@link MediaChunkIterator}s providing information about the
-   *     sequence of upcoming media chunks for each track.
-   * @param formats The track formats.
-   * @param maxDurationUs Maximum duration of chunks to be included in average bitrate values, in
-   *     microseconds.
-   * @param bitrates If not null, stores bitrate values in this array.
-   * @return Average bitrate values for the tracks. If for a track, an average bitrate or an
-   *     estimation can't be calculated, {@link Format#NO_VALUE} is set.
-   * @see #getAverageBitrate(MediaChunkIterator, long)
-   */
-  @VisibleForTesting
-  /* package */ static int[] getBitratesUsingFutureInfo(
-      MediaChunkIterator[] iterators,
-      Format[] formats,
-      long maxDurationUs,
-      @Nullable int[] bitrates) {
-    int trackCount = iterators.length;
-    Assertions.checkArgument(trackCount == formats.length);
-    if (trackCount == 0) {
-      return new int[0];
-    }
-    if (bitrates == null) {
-      bitrates = new int[trackCount];
-    }
-    if (maxDurationUs == 0) {
-      Arrays.fill(bitrates, Format.NO_VALUE);
-      return bitrates;
-    }
-
-    int[] formatBitrates = new int[trackCount];
-    float[] bitrateRatios = new float[trackCount];
-    boolean needEstimateBitrate = false;
-    boolean canEstimateBitrate = false;
-    for (int i = 0; i < trackCount; i++) {
-      int bitrate = getAverageBitrate(iterators[i], maxDurationUs);
-      if (bitrate != Format.NO_VALUE) {
-        int formatBitrate = formats[i].bitrate;
-        formatBitrates[i] = formatBitrate;
-        if (formatBitrate != Format.NO_VALUE) {
-          bitrateRatios[i] = ((float) bitrate) / formatBitrate;
-          canEstimateBitrate = true;
-        }
-      } else {
-        needEstimateBitrate = true;
-        formatBitrates[i] = Format.NO_VALUE;
-      }
-      bitrates[i] = bitrate;
-    }
-
-    if (needEstimateBitrate && canEstimateBitrate) {
-      estimateBitrates(bitrates, formats, formatBitrates, bitrateRatios);
-    }
-    return bitrates;
-  }
-
-  /**
-   * Returns bitrate values for a set of tracks whose formats are given, using the given queue of
-   * already buffered {@link MediaChunk} instances.
-   *
-   * @param queue The queue of already buffered {@link MediaChunk} instances. Must not be modified.
-   * @param formats The track formats.
-   * @param maxDurationUs Maximum duration of chunks to be included in average bitrate values, in
-   *     microseconds.
-   * @param bitrates If not null, calculates bitrate values only for indexes set to Format.NO_VALUE
-   *     and stores result in this array.
-   * @return Bitrate values for the tracks. If for a track, a bitrate value can't be calculated,
-   *     {@link Format#NO_VALUE} is set.
-   * @see #getBitratesUsingFutureInfo(MediaChunkIterator[], Format[], long, int[])
-   */
-  @VisibleForTesting
-  /* package */ static int[] getBitratesUsingPastInfo(
-      List<? extends MediaChunk> queue,
-      Format[] formats,
-      long maxDurationUs,
-      @Nullable int[] bitrates) {
-    if (bitrates == null) {
-      bitrates = new int[formats.length];
-      Arrays.fill(bitrates, Format.NO_VALUE);
-    }
-    if (maxDurationUs == 0) {
-      return bitrates;
-    }
-    int queueAverageBitrate = getAverageQueueBitrate(queue, maxDurationUs);
-    if (queueAverageBitrate == Format.NO_VALUE) {
-      return bitrates;
-    }
-    int queueFormatBitrate = queue.get(queue.size() - 1).trackFormat.bitrate;
-    if (queueFormatBitrate != Format.NO_VALUE) {
-      float queueBitrateRatio = ((float) queueAverageBitrate) / queueFormatBitrate;
-      estimateBitrates(
-          bitrates, formats, new int[] {queueFormatBitrate}, new float[] {queueBitrateRatio});
-    }
-    return bitrates;
-  }
-
-  /**
-   * Returns bitrate values for a set of tracks whose formats are given, using the given upcoming
-   * media chunk iterators and the queue of already buffered {@link MediaChunk}s.
-   *
-   * @param formats The track formats.
-   * @param queue The queue of already buffered {@link MediaChunk}s. Must not be modified.
-   * @param maxPastDurationUs Maximum duration of past chunks to be included in average bitrate
-   *     values, in microseconds.
-   * @param iterators An array of {@link MediaChunkIterator}s providing information about the
-   *     sequence of upcoming media chunks for each track.
-   * @param maxFutureDurationUs Maximum duration of future chunks to be included in average bitrate
-   *     values, in microseconds.
-   * @param useFormatBitrateAsLowerBound Whether to return the estimated bitrate only if it's higher
-   *     than the bitrate of the track's format.
-   * @param bitrates An array into which the bitrate values will be written. If non-null, this array
-   *     is the one that will be returned.
-   * @return Bitrate values for the tracks. As long as the format of a track has set bitrate, a
-   *     bitrate value is set in the returned array. Otherwise it might be set to {@link
-   *     Format#NO_VALUE}.
-   */
-  public static int[] getBitratesUsingPastAndFutureInfo(
-      Format[] formats,
-      List<? extends MediaChunk> queue,
-      long maxPastDurationUs,
-      MediaChunkIterator[] iterators,
-      long maxFutureDurationUs,
-      boolean useFormatBitrateAsLowerBound,
-      @Nullable int[] bitrates) {
-    bitrates = getBitratesUsingFutureInfo(iterators, formats, maxFutureDurationUs, bitrates);
-    getBitratesUsingPastInfo(queue, formats, maxPastDurationUs, bitrates);
-    for (int i = 0; i < bitrates.length; i++) {
-      int bitrate = bitrates[i];
-      if (bitrate == Format.NO_VALUE
-          || (useFormatBitrateAsLowerBound
-              && formats[i].bitrate != Format.NO_VALUE
-              && bitrate < formats[i].bitrate)) {
-        bitrates[i] = formats[i].bitrate;
-      }
-    }
-    return bitrates;
-  }
-
-  /**
-   * Returns an array containing {@link Format#bitrate} values for given each format in order.
-   *
-   * @param formats The format array to copy {@link Format#bitrate} values.
-   * @param bitrates If not null, stores bitrate values in this array.
-   * @return An array containing {@link Format#bitrate} values for given each format in order.
-   */
-  public static int[] getFormatBitrates(Format[] formats, @Nullable int[] bitrates) {
-    int trackCount = formats.length;
-    if (bitrates == null) {
-      bitrates = new int[trackCount];
-    }
-    for (int i = 0; i < trackCount; i++) {
-      bitrates[i] = formats[i].bitrate;
-    }
-    return bitrates;
-  }
-
-  /**
-   * Fills missing values in the given {@code bitrates} array by calculates an estimation using the
-   * closest reference bitrate value.
-   *
-   * @param bitrates An array of bitrates to be filled with estimations. Missing values are set to
-   *     {@link Format#NO_VALUE}.
-   * @param formats An array of formats, one for each bitrate.
-   * @param referenceBitrates An array of reference bitrates which are used to calculate
-   *     estimations.
-   * @param referenceBitrateRatios An array containing ratio of reference bitrates to their bitrate
-   *     estimates.
-   */
-  private static void estimateBitrates(
-      int[] bitrates, Format[] formats, int[] referenceBitrates, float[] referenceBitrateRatios) {
-    for (int i = 0; i < bitrates.length; i++) {
-      if (bitrates[i] == Format.NO_VALUE) {
-        int formatBitrate = formats[i].bitrate;
-        if (formatBitrate != Format.NO_VALUE) {
-          int closestReferenceBitrateIndex =
-              getClosestBitrateIndex(formatBitrate, referenceBitrates);
-          bitrates[i] =
-              (int) (referenceBitrateRatios[closestReferenceBitrateIndex] * formatBitrate);
-        }
-      }
-    }
-  }
-
-  private static int getAverageQueueBitrate(List<? extends MediaChunk> queue, long maxDurationUs) {
-    if (queue.isEmpty()) {
-      return Format.NO_VALUE;
-    }
-    MediaChunkListIterator iterator =
-        new MediaChunkListIterator(getSingleFormatSubQueue(queue), /* reverseOrder= */ true);
-    return getAverageBitrate(iterator, maxDurationUs);
-  }
-
-  private static List<? extends MediaChunk> getSingleFormatSubQueue(
-      List<? extends MediaChunk> queue) {
-    Format queueFormat = queue.get(queue.size() - 1).trackFormat;
-    int queueSize = queue.size();
-    for (int i = queueSize - 2; i >= 0; i--) {
-      if (!queue.get(i).trackFormat.equals(queueFormat)) {
-        return queue.subList(i + 1, queueSize);
-      }
-    }
-    return queue;
-  }
-
-  private static int getClosestBitrateIndex(int formatBitrate, int[] formatBitrates) {
-    int closestDistance = Integer.MAX_VALUE;
-    int closestFormat = C.INDEX_UNSET;
-    for (int j = 0; j < formatBitrates.length; j++) {
-      if (formatBitrates[j] != Format.NO_VALUE) {
-        int distance = Math.abs(formatBitrates[j] - formatBitrate);
-        if (distance < closestDistance) {
-          closestDistance = distance;
-          closestFormat = j;
-        }
-      }
-    }
-    return closestFormat;
-  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/WindowedTrackBitrateEstimator.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/WindowedTrackBitrateEstimator.java
deleted file mode 100644
index 25f7e4ea73..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/WindowedTrackBitrateEstimator.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.android.exoplayer2.trackselection;
-
-import androidx.annotation.Nullable;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.source.chunk.MediaChunk;
-import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
-import java.util.List;
-
-/** A {@link TrackBitrateEstimator} which derives estimates from a window of time. */
-public final class WindowedTrackBitrateEstimator implements TrackBitrateEstimator {
-
-  private final long maxPastDurationUs;
-  private final long maxFutureDurationUs;
-  private final boolean useFormatBitrateAsLowerBound;
-
-  /**
-   * @param maxPastDurationMs Maximum duration of past chunks to be included in average bitrate
-   *     values, in milliseconds.
-   * @param maxFutureDurationMs Maximum duration of future chunks to be included in average bitrate
-   *     values, in milliseconds.
-   * @param useFormatBitrateAsLowerBound Whether to use the bitrate of the track's format as a lower
-   *     bound for the estimated bitrate.
-   */
-  public WindowedTrackBitrateEstimator(
-      long maxPastDurationMs, long maxFutureDurationMs, boolean useFormatBitrateAsLowerBound) {
-    this.maxPastDurationUs = C.msToUs(maxPastDurationMs);
-    this.maxFutureDurationUs = C.msToUs(maxFutureDurationMs);
-    this.useFormatBitrateAsLowerBound = useFormatBitrateAsLowerBound;
-  }
-
-  @Override
-  public int[] getBitrates(
-      Format[] formats,
-      List<? extends MediaChunk> queue,
-      MediaChunkIterator[] iterators,
-      @Nullable int[] bitrates) {
-    if (maxFutureDurationUs > 0 || maxPastDurationUs > 0) {
-      return TrackSelectionUtil.getBitratesUsingPastAndFutureInfo(
-          formats,
-          queue,
-          maxPastDurationUs,
-          iterators,
-          maxFutureDurationUs,
-          useFormatBitrateAsLowerBound,
-          bitrates);
-    }
-    return TrackSelectionUtil.getFormatBitrates(formats, bitrates);
-  }
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/package-info.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/package-info.java
new file mode 100644
index 0000000000..45131e644b
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.trackselection;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java
index 4145d9a1c7..67dd9a7a55 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java
@@ -79,6 +79,8 @@
   /** Default maximum weight for the sliding window. */
   public static final int DEFAULT_SLIDING_WINDOW_MAX_WEIGHT = 2000;
 
+  @Nullable private static DefaultBandwidthMeter singletonInstance;
+
   /** Builder for a bandwidth meter. */
   public static final class Builder {
 
@@ -100,6 +102,7 @@ public Builder(Context context) {
       initialBitrateEstimates = getInitialBitrateEstimatesForCountry(Util.getCountryCode(context));
       slidingWindowMaxWeight = DEFAULT_SLIDING_WINDOW_MAX_WEIGHT;
       clock = Clock.DEFAULT;
+      resetOnNetworkTypeChange = true;
     }
 
     /**
@@ -168,14 +171,12 @@ public Builder setClock(Clock clock) {
     }
 
     /**
-     * Sets whether to reset if the network type changes.
-     *
-     * <p>This method is experimental, and will be renamed or removed in a future release.
+     * Sets whether to reset if the network type changes. The default value is {@code true}.
      *
      * @param resetOnNetworkTypeChange Whether to reset if the network type changes.
      * @return This builder.
      */
-    public Builder experimental_resetOnNetworkTypeChange(boolean resetOnNetworkTypeChange) {
+    public Builder setResetOnNetworkTypeChange(boolean resetOnNetworkTypeChange) {
       this.resetOnNetworkTypeChange = resetOnNetworkTypeChange;
       return this;
     }
@@ -215,6 +216,19 @@ public DefaultBandwidthMeter build() {
     }
   }
 
+  /**
+   * Returns a singleton instance of a {@link DefaultBandwidthMeter} with default configuration.
+   *
+   * @param context A {@link Context}.
+   * @return The singleton instance.
+   */
+  public static synchronized DefaultBandwidthMeter getSingletonInstance(Context context) {
+    if (singletonInstance == null) {
+      singletonInstance = new DefaultBandwidthMeter.Builder(context).build();
+    }
+    return singletonInstance;
+  }
+
   private static final int ELAPSED_MILLIS_FOR_ESTIMATE = 2000;
   private static final int BYTES_TRANSFERRED_FOR_ESTIMATE = 512 * 1024;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/AtomicFile.java b/library/core/src/main/java/com/google/android/exoplayer2/util/AtomicFile.java
index 74e50dfd92..f2259e8f1a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/AtomicFile.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/AtomicFile.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer2.util;
 
-import androidx.annotation.NonNull;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
@@ -189,12 +188,12 @@ public void write(int b) throws IOException {
     }
 
     @Override
-    public void write(@NonNull byte[] b) throws IOException {
+    public void write(byte[] b) throws IOException {
       fileOutputStream.write(b);
     }
 
     @Override
-    public void write(@NonNull byte[] b, int off, int len) throws IOException {
+    public void write(byte[] b, int off, int len) throws IOException {
       fileOutputStream.write(b, off, len);
     }
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/HandlerWrapper.java b/library/core/src/main/java/com/google/android/exoplayer2/util/HandlerWrapper.java
index 8f1a6544ca..5b85b26c3f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/HandlerWrapper.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/HandlerWrapper.java
@@ -18,6 +18,7 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
+import androidx.annotation.Nullable;
 
 /**
  * An interface to call through to a {@link Handler}. Instances must be created by calling {@link
@@ -32,13 +33,13 @@
   Message obtainMessage(int what);
 
   /** @see Handler#obtainMessage(int, Object) */
-  Message obtainMessage(int what, Object obj);
+  Message obtainMessage(int what, @Nullable Object obj);
 
   /** @see Handler#obtainMessage(int, int, int) */
   Message obtainMessage(int what, int arg1, int arg2);
 
   /** @see Handler#obtainMessage(int, int, int, Object) */
-  Message obtainMessage(int what, int arg1, int arg2, Object obj);
+  Message obtainMessage(int what, int arg1, int arg2, @Nullable Object obj);
 
   /** @see Handler#sendEmptyMessage(int) */
   boolean sendEmptyMessage(int what);
@@ -50,7 +51,7 @@
   void removeMessages(int what);
 
   /** @see Handler#removeCallbacksAndMessages(Object) */
-  void removeCallbacksAndMessages(Object token);
+  void removeCallbacksAndMessages(@Nullable Object token);
 
   /** @see Handler#post(Runnable) */
   boolean post(Runnable runnable);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/SystemHandlerWrapper.java b/library/core/src/main/java/com/google/android/exoplayer2/util/SystemHandlerWrapper.java
index ee469a5b2a..1fbea2ed7e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/SystemHandlerWrapper.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/SystemHandlerWrapper.java
@@ -17,6 +17,7 @@
 
 import android.os.Looper;
 import android.os.Message;
+import androidx.annotation.Nullable;
 
 /** The standard implementation of {@link HandlerWrapper}. */
 /* package */ final class SystemHandlerWrapper implements HandlerWrapper {
@@ -38,7 +39,7 @@ public Message obtainMessage(int what) {
   }
 
   @Override
-  public Message obtainMessage(int what, Object obj) {
+  public Message obtainMessage(int what, @Nullable Object obj) {
     return handler.obtainMessage(what, obj);
   }
 
@@ -48,7 +49,7 @@ public Message obtainMessage(int what, int arg1, int arg2) {
   }
 
   @Override
-  public Message obtainMessage(int what, int arg1, int arg2, Object obj) {
+  public Message obtainMessage(int what, int arg1, int arg2, @Nullable Object obj) {
     return handler.obtainMessage(what, arg1, arg2, obj);
   }
 
@@ -68,7 +69,7 @@ public void removeMessages(int what) {
   }
 
   @Override
-  public void removeCallbacksAndMessages(Object token) {
+  public void removeCallbacksAndMessages(@Nullable Object token) {
     handler.removeCallbacksAndMessages(token);
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/UriUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/util/UriUtil.java
index 071ebf2084..60f4fa17dd 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/UriUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/UriUtil.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.util;
 
 import android.net.Uri;
+import androidx.annotation.Nullable;
 import android.text.TextUtils;
 
 /**
@@ -69,19 +70,19 @@ private UriUtil() {}
    * @param baseUri The base URI.
    * @param referenceUri The reference URI to resolve.
    */
-  public static Uri resolveToUri(String baseUri, String referenceUri) {
+  public static Uri resolveToUri(@Nullable String baseUri, @Nullable String referenceUri) {
     return Uri.parse(resolve(baseUri, referenceUri));
   }
 
   /**
    * Performs relative resolution of a {@code referenceUri} with respect to a {@code baseUri}.
-   * <p>
-   * The resolution is performed as specified by RFC-3986.
+   *
+   * <p>The resolution is performed as specified by RFC-3986.
    *
    * @param baseUri The base URI.
    * @param referenceUri The reference URI to resolve.
    */
-  public static String resolve(String baseUri, String referenceUri) {
+  public static String resolve(@Nullable String baseUri, @Nullable String referenceUri) {
     StringBuilder uri = new StringBuilder();
 
     // Map null onto empty string, to make the following logic simpler.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java b/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
index e700fc6751..35a36c3cd5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
@@ -252,14 +252,14 @@ public static boolean areEqual(@Nullable Object o1, @Nullable Object o2) {
   /**
    * Tests whether an {@code items} array contains an object equal to {@code item}, according to
    * {@link Object#equals(Object)}.
-   * <p>
-   * If {@code item} is null then true is returned if and only if {@code items} contains null.
+   *
+   * <p>If {@code item} is null then true is returned if and only if {@code items} contains null.
    *
    * @param items The array of items to search.
    * @param item The item to search for.
    * @return True if the array contains an object equal to the item being searched for.
    */
-  public static boolean contains(Object[] items, Object item) {
+  public static boolean contains(@NullableType Object[] items, @Nullable Object item) {
     for (Object arrayItem : items) {
       if (areEqual(arrayItem, item)) {
         return true;
@@ -1486,7 +1486,7 @@ public static int getStreamTypeForAudioUsage(@C.AudioUsage int usage) {
    * @return The content type.
    */
   @C.ContentType
-  public static int inferContentType(Uri uri, String overrideExtension) {
+  public static int inferContentType(Uri uri, @Nullable String overrideExtension) {
     return TextUtils.isEmpty(overrideExtension)
         ? inferContentType(uri)
         : inferContentType("." + overrideExtension);
@@ -1545,35 +1545,6 @@ public static String getStringForTime(StringBuilder builder, Formatter formatter
         : formatter.format("%02d:%02d", minutes, seconds).toString();
   }
 
-  /**
-   * Maps a {@link C} {@code TRACK_TYPE_*} constant to the corresponding {@link C} {@code
-   * DEFAULT_*_BUFFER_SIZE} constant.
-   *
-   * @param trackType The track type.
-   * @return The corresponding default buffer size in bytes.
-   * @throws IllegalArgumentException If the track type is an unrecognized or custom track type.
-   */
-  public static int getDefaultBufferSize(int trackType) {
-    switch (trackType) {
-      case C.TRACK_TYPE_DEFAULT:
-        return C.DEFAULT_MUXED_BUFFER_SIZE;
-      case C.TRACK_TYPE_AUDIO:
-        return C.DEFAULT_AUDIO_BUFFER_SIZE;
-      case C.TRACK_TYPE_VIDEO:
-        return C.DEFAULT_VIDEO_BUFFER_SIZE;
-      case C.TRACK_TYPE_TEXT:
-        return C.DEFAULT_TEXT_BUFFER_SIZE;
-      case C.TRACK_TYPE_METADATA:
-        return C.DEFAULT_METADATA_BUFFER_SIZE;
-      case C.TRACK_TYPE_CAMERA_MOTION:
-        return C.DEFAULT_CAMERA_MOTION_BUFFER_SIZE;
-      case C.TRACK_TYPE_NONE:
-        return 0;
-      default:
-        throw new IllegalArgumentException();
-    }
-  }
-
   /**
    * Escapes a string so that it's safe for use as a file or directory name on at least FAT32
    * filesystems. FAT32 is the most restrictive of all filesystems still commonly used today.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/package-info.java b/library/core/src/main/java/com/google/android/exoplayer2/util/package-info.java
new file mode 100644
index 0000000000..76899fc452
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/package-info.java
@@ -0,0 +1,17 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.util;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index 2ab7e61378..de77e8318d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -308,8 +308,10 @@ public MediaCodecVideoRenderer(
   }
 
   @Override
-  protected int supportsFormat(MediaCodecSelector mediaCodecSelector,
-      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager, Format format)
+  protected int supportsFormat(
+      MediaCodecSelector mediaCodecSelector,
+      @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      Format format)
       throws DecoderQueryException {
     String mimeType = format.sampleMimeType;
     if (!MimeTypes.isVideo(mimeType)) {
@@ -601,7 +603,7 @@ protected void configureCodec(
       MediaCodecInfo codecInfo,
       MediaCodec codec,
       Format format,
-      MediaCrypto crypto,
+      @Nullable MediaCrypto crypto,
       float codecOperatingRate) {
     String codecMimeType = codecInfo.codecMimeType;
     codecMaxValues = getCodecMaxValues(codecInfo, format, getStreamFormats());
@@ -1638,6 +1640,11 @@ protected Surface getSurface() {
     return surface;
   }
 
+  /** Returns true if the first frame has been rendered (playback has not necessarily begun). */
+  protected final boolean haveRenderedFirstFrame() {
+    return renderedFirstFrame;
+  }
+
   protected static final class CodecMaxValues {
 
     public final int width;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/SimpleDecoderVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/SimpleDecoderVideoRenderer.java
new file mode 100644
index 0000000000..ad59d11c4a
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/SimpleDecoderVideoRenderer.java
@@ -0,0 +1,914 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.video;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.os.SystemClock;
+import androidx.annotation.CallSuper;
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
+import android.view.Surface;
+import com.google.android.exoplayer2.BaseRenderer;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.FormatHolder;
+import com.google.android.exoplayer2.RendererCapabilities;
+import com.google.android.exoplayer2.decoder.DecoderCounters;
+import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+import com.google.android.exoplayer2.decoder.SimpleDecoder;
+import com.google.android.exoplayer2.drm.DrmSession;
+import com.google.android.exoplayer2.drm.DrmSession.DrmSessionException;
+import com.google.android.exoplayer2.drm.DrmSessionManager;
+import com.google.android.exoplayer2.drm.ExoMediaCrypto;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.TimedValueQueue;
+import com.google.android.exoplayer2.util.TraceUtil;
+import com.google.android.exoplayer2.util.Util;
+import com.google.android.exoplayer2.video.VideoRendererEventListener.EventDispatcher;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/** Decodes and renders video using a {@link SimpleDecoder}. */
+public abstract class SimpleDecoderVideoRenderer extends BaseRenderer {
+
+  /** Decoder reinitialization states. */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({
+    REINITIALIZATION_STATE_NONE,
+    REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM,
+    REINITIALIZATION_STATE_WAIT_END_OF_STREAM
+  })
+  private @interface ReinitializationState {}
+  /** The decoder does not need to be re-initialized. */
+  private static final int REINITIALIZATION_STATE_NONE = 0;
+  /**
+   * The input format has changed in a way that requires the decoder to be re-initialized, but we
+   * haven't yet signaled an end of stream to the existing decoder. We need to do so in order to
+   * ensure that it outputs any remaining buffers before we release it.
+   */
+  private static final int REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM = 1;
+  /**
+   * The input format has changed in a way that requires the decoder to be re-initialized, and we've
+   * signaled an end of stream to the existing decoder. We're waiting for the decoder to output an
+   * end of stream signal to indicate that it has output any remaining buffers before we release it.
+   */
+  private static final int REINITIALIZATION_STATE_WAIT_END_OF_STREAM = 2;
+
+  private final long allowedJoiningTimeMs;
+  private final int maxDroppedFramesToNotify;
+  private final boolean playClearSamplesWithoutKeys;
+  private final EventDispatcher eventDispatcher;
+  private final FormatHolder formatHolder;
+  private final TimedValueQueue<Format> formatQueue;
+  private final DecoderInputBuffer flagsOnlyBuffer;
+  private final DrmSessionManager<ExoMediaCrypto> drmSessionManager;
+
+  private Format format;
+  private Format pendingFormat;
+  private Format outputFormat;
+  private SimpleDecoder<
+          VideoDecoderInputBuffer,
+          ? extends VideoDecoderOutputBuffer,
+          ? extends VideoDecoderException>
+      decoder;
+  private VideoDecoderInputBuffer inputBuffer;
+  private VideoDecoderOutputBuffer outputBuffer;
+  @Nullable private DrmSession<ExoMediaCrypto> decoderDrmSession;
+  @Nullable private DrmSession<ExoMediaCrypto> sourceDrmSession;
+
+  @ReinitializationState private int decoderReinitializationState;
+  private boolean decoderReceivedBuffers;
+
+  private boolean renderedFirstFrame;
+  private long initialPositionUs;
+  private long joiningDeadlineMs;
+  private boolean waitingForKeys;
+
+  private boolean inputStreamEnded;
+  private boolean outputStreamEnded;
+  private int reportedWidth;
+  private int reportedHeight;
+
+  private long droppedFrameAccumulationStartTimeMs;
+  private int droppedFrames;
+  private int consecutiveDroppedFrameCount;
+  private int buffersInCodecCount;
+  private long lastRenderTimeUs;
+  private long outputStreamOffsetUs;
+
+  /** Decoder event counters used for debugging purposes. */
+  protected DecoderCounters decoderCounters;
+
+  /**
+   * @param allowedJoiningTimeMs The maximum duration in milliseconds for which this video renderer
+   *     can attempt to seamlessly join an ongoing playback.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param maxDroppedFramesToNotify The maximum number of frames that can be dropped between
+   *     invocations of {@link VideoRendererEventListener#onDroppedFrames(int, long)}.
+   * @param drmSessionManager For use with encrypted media. May be null if support for encrypted
+   *     media is not required.
+   * @param playClearSamplesWithoutKeys Encrypted media may contain clear (un-encrypted) regions.
+   *     For example a media file may start with a short clear region so as to allow playback to
+   *     begin in parallel with key acquisition. This parameter specifies whether the renderer is
+   *     permitted to play clear regions of encrypted media files before {@code drmSessionManager}
+   *     has obtained the keys necessary to decrypt encrypted regions of the media.
+   */
+  protected SimpleDecoderVideoRenderer(
+      long allowedJoiningTimeMs,
+      @Nullable Handler eventHandler,
+      @Nullable VideoRendererEventListener eventListener,
+      int maxDroppedFramesToNotify,
+      @Nullable DrmSessionManager<ExoMediaCrypto> drmSessionManager,
+      boolean playClearSamplesWithoutKeys) {
+    super(C.TRACK_TYPE_VIDEO);
+    this.allowedJoiningTimeMs = allowedJoiningTimeMs;
+    this.maxDroppedFramesToNotify = maxDroppedFramesToNotify;
+    this.drmSessionManager = drmSessionManager;
+    this.playClearSamplesWithoutKeys = playClearSamplesWithoutKeys;
+    joiningDeadlineMs = C.TIME_UNSET;
+    clearReportedVideoSize();
+    formatHolder = new FormatHolder();
+    formatQueue = new TimedValueQueue<>();
+    flagsOnlyBuffer = DecoderInputBuffer.newFlagsOnlyInstance();
+    eventDispatcher = new EventDispatcher(eventHandler, eventListener);
+    decoderReinitializationState = REINITIALIZATION_STATE_NONE;
+  }
+
+  // BaseRenderer implementation.
+
+  @Override
+  public final int supportsFormat(Format format) {
+    return supportsFormatInternal(drmSessionManager, format);
+  }
+
+  @Override
+  public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
+    if (outputStreamEnded) {
+      return;
+    }
+
+    if (format == null) {
+      // We don't have a format yet, so try and read one.
+      flagsOnlyBuffer.clear();
+      int result = readSource(formatHolder, flagsOnlyBuffer, true);
+      if (result == C.RESULT_FORMAT_READ) {
+        onInputFormatChanged(formatHolder);
+      } else if (result == C.RESULT_BUFFER_READ) {
+        // End of stream read having not read a format.
+        Assertions.checkState(flagsOnlyBuffer.isEndOfStream());
+        inputStreamEnded = true;
+        outputStreamEnded = true;
+        return;
+      } else {
+        // We still don't have a format and can't make progress without one.
+        return;
+      }
+    }
+
+    // If we don't have a decoder yet, we need to instantiate one.
+    maybeInitDecoder();
+
+    if (decoder != null) {
+      try {
+        // Rendering loop.
+        TraceUtil.beginSection("drainAndFeed");
+        while (drainOutputBuffer(positionUs, elapsedRealtimeUs)) {}
+        while (feedInputBuffer()) {}
+        TraceUtil.endSection();
+      } catch (VideoDecoderException e) {
+        throw ExoPlaybackException.createForRenderer(e, getIndex());
+      }
+      decoderCounters.ensureUpdated();
+    }
+  }
+
+  @Override
+  public boolean isEnded() {
+    return outputStreamEnded;
+  }
+
+  @Override
+  public boolean isReady() {
+    if (waitingForKeys) {
+      return false;
+    }
+    if (format != null
+        && (isSourceReady() || outputBuffer != null)
+        && (renderedFirstFrame || !hasOutputSurface())) {
+      // Ready. If we were joining then we've now joined, so clear the joining deadline.
+      joiningDeadlineMs = C.TIME_UNSET;
+      return true;
+    } else if (joiningDeadlineMs == C.TIME_UNSET) {
+      // Not joining.
+      return false;
+    } else if (SystemClock.elapsedRealtime() < joiningDeadlineMs) {
+      // Joining and still within the joining deadline.
+      return true;
+    } else {
+      // The joining deadline has been exceeded. Give up and clear the deadline.
+      joiningDeadlineMs = C.TIME_UNSET;
+      return false;
+    }
+  }
+
+  @Override
+  protected void onEnabled(boolean joining) throws ExoPlaybackException {
+    decoderCounters = new DecoderCounters();
+    eventDispatcher.enabled(decoderCounters);
+  }
+
+  @Override
+  protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {
+    inputStreamEnded = false;
+    outputStreamEnded = false;
+    clearRenderedFirstFrame();
+    initialPositionUs = C.TIME_UNSET;
+    consecutiveDroppedFrameCount = 0;
+    if (decoder != null) {
+      flushDecoder();
+    }
+    if (joining) {
+      setJoiningDeadlineMs();
+    } else {
+      joiningDeadlineMs = C.TIME_UNSET;
+    }
+    formatQueue.clear();
+  }
+
+  @Override
+  protected void onStarted() {
+    droppedFrames = 0;
+    droppedFrameAccumulationStartTimeMs = SystemClock.elapsedRealtime();
+    lastRenderTimeUs = SystemClock.elapsedRealtime() * 1000;
+  }
+
+  @Override
+  protected void onStopped() {
+    joiningDeadlineMs = C.TIME_UNSET;
+    maybeNotifyDroppedFrames();
+  }
+
+  @Override
+  protected void onDisabled() {
+    format = null;
+    waitingForKeys = false;
+    clearReportedVideoSize();
+    clearRenderedFirstFrame();
+    try {
+      setSourceDrmSession(null);
+      releaseDecoder();
+    } finally {
+      eventDispatcher.disabled(decoderCounters);
+    }
+  }
+
+  @Override
+  protected void onStreamChanged(Format[] formats, long offsetUs) throws ExoPlaybackException {
+    outputStreamOffsetUs = offsetUs;
+    super.onStreamChanged(formats, offsetUs);
+  }
+
+  /**
+   * Called when a decoder has been created and configured.
+   *
+   * <p>The default implementation is a no-op.
+   *
+   * @param name The name of the decoder that was initialized.
+   * @param initializedTimestampMs {@link SystemClock#elapsedRealtime()} when initialization
+   *     finished.
+   * @param initializationDurationMs The time taken to initialize the decoder, in milliseconds.
+   */
+  @CallSuper
+  protected void onDecoderInitialized(
+      String name, long initializedTimestampMs, long initializationDurationMs) {
+    eventDispatcher.decoderInitialized(name, initializedTimestampMs, initializationDurationMs);
+  }
+
+  /**
+   * Flushes the decoder.
+   *
+   * @throws ExoPlaybackException If an error occurs reinitializing a decoder.
+   */
+  @CallSuper
+  protected void flushDecoder() throws ExoPlaybackException {
+    waitingForKeys = false;
+    buffersInCodecCount = 0;
+    if (decoderReinitializationState != REINITIALIZATION_STATE_NONE) {
+      releaseDecoder();
+      maybeInitDecoder();
+    } else {
+      inputBuffer = null;
+      if (outputBuffer != null) {
+        outputBuffer.release();
+        clearOutputBuffer();
+      }
+      decoder.flush();
+      decoderReceivedBuffers = false;
+    }
+  }
+
+  /** Releases the decoder. */
+  @CallSuper
+  protected void releaseDecoder() {
+    inputBuffer = null;
+    clearOutputBuffer();
+    decoderReinitializationState = REINITIALIZATION_STATE_NONE;
+    decoderReceivedBuffers = false;
+    buffersInCodecCount = 0;
+    if (decoder != null) {
+      decoder.release();
+      decoder = null;
+      decoderCounters.decoderReleaseCount++;
+    }
+    setDecoderDrmSession(null);
+  }
+
+  private void setSourceDrmSession(@Nullable DrmSession<ExoMediaCrypto> session) {
+    DrmSession.replaceSessionReferences(sourceDrmSession, session);
+    sourceDrmSession = session;
+  }
+
+  private void setDecoderDrmSession(@Nullable DrmSession<ExoMediaCrypto> session) {
+    DrmSession.replaceSessionReferences(decoderDrmSession, session);
+    decoderDrmSession = session;
+  }
+
+  /**
+   * Called when a new format is read from the upstream source.
+   *
+   * @param formatHolder A {@link FormatHolder} that holds the new {@link Format}.
+   * @throws ExoPlaybackException If an error occurs (re-)initializing the decoder.
+   */
+  @CallSuper
+  @SuppressWarnings("unchecked")
+  protected void onInputFormatChanged(FormatHolder formatHolder) throws ExoPlaybackException {
+    Format oldFormat = format;
+    format = formatHolder.format;
+    pendingFormat = format;
+
+    boolean drmInitDataChanged =
+        !Util.areEqual(format.drmInitData, oldFormat == null ? null : oldFormat.drmInitData);
+    if (drmInitDataChanged) {
+      if (format.drmInitData != null) {
+        if (formatHolder.includesDrmSession) {
+          setSourceDrmSession((DrmSession<ExoMediaCrypto>) formatHolder.drmSession);
+        } else {
+          if (drmSessionManager == null) {
+            throw ExoPlaybackException.createForRenderer(
+                new IllegalStateException("Media requires a DrmSessionManager"), getIndex());
+          }
+          DrmSession<ExoMediaCrypto> session =
+              drmSessionManager.acquireSession(Looper.myLooper(), format.drmInitData);
+          if (sourceDrmSession != null) {
+            sourceDrmSession.releaseReference();
+          }
+          sourceDrmSession = session;
+        }
+      } else {
+        setSourceDrmSession(null);
+      }
+    }
+
+    if (sourceDrmSession != decoderDrmSession) {
+      if (decoderReceivedBuffers) {
+        // Signal end of stream and wait for any final output buffers before re-initialization.
+        decoderReinitializationState = REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM;
+      } else {
+        // There aren't any final output buffers, so release the decoder immediately.
+        releaseDecoder();
+        maybeInitDecoder();
+      }
+    }
+
+    eventDispatcher.inputFormatChanged(format);
+  }
+
+  /**
+   * Called immediately before an input buffer is queued into the decoder.
+   *
+   * <p>The default implementation is a no-op.
+   *
+   * @param buffer The buffer that will be queued.
+   */
+  protected void onQueueInputBuffer(VideoDecoderInputBuffer buffer) {
+    // Do nothing.
+  }
+
+  /**
+   * Called when an output buffer is successfully processed.
+   *
+   * @param presentationTimeUs The timestamp associated with the output buffer.
+   */
+  @CallSuper
+  protected void onProcessedOutputBuffer(long presentationTimeUs) {
+    buffersInCodecCount--;
+  }
+
+  /**
+   * Returns whether the buffer being processed should be dropped.
+   *
+   * @param earlyUs The time until the buffer should be presented in microseconds. A negative value
+   *     indicates that the buffer is late.
+   * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
+   *     measured at the start of the current iteration of the rendering loop.
+   */
+  protected boolean shouldDropOutputBuffer(long earlyUs, long elapsedRealtimeUs) {
+    return isBufferLate(earlyUs);
+  }
+
+  /**
+   * Returns whether to drop all buffers from the buffer being processed to the keyframe at or after
+   * the current playback position, if possible.
+   *
+   * @param earlyUs The time until the current buffer should be presented in microseconds. A
+   *     negative value indicates that the buffer is late.
+   * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
+   *     measured at the start of the current iteration of the rendering loop.
+   */
+  protected boolean shouldDropBuffersToKeyframe(long earlyUs, long elapsedRealtimeUs) {
+    return isBufferVeryLate(earlyUs);
+  }
+
+  /**
+   * Returns whether to force rendering an output buffer.
+   *
+   * @param earlyUs The time until the current buffer should be presented in microseconds. A
+   *     negative value indicates that the buffer is late.
+   * @param elapsedSinceLastRenderUs The elapsed time since the last output buffer was rendered, in
+   *     microseconds.
+   * @return Returns whether to force rendering an output buffer.
+   */
+  protected boolean shouldForceRenderOutputBuffer(long earlyUs, long elapsedSinceLastRenderUs) {
+    return isBufferLate(earlyUs) && elapsedSinceLastRenderUs > 100000;
+  }
+
+  /**
+   * Skips the specified output buffer and releases it.
+   *
+   * @param outputBuffer The output buffer to skip.
+   */
+  protected void skipOutputBuffer(VideoDecoderOutputBuffer outputBuffer) {
+    decoderCounters.skippedOutputBufferCount++;
+    outputBuffer.release();
+  }
+
+  /**
+   * Drops the specified output buffer and releases it.
+   *
+   * @param outputBuffer The output buffer to drop.
+   */
+  protected void dropOutputBuffer(VideoDecoderOutputBuffer outputBuffer) {
+    updateDroppedBufferCounters(1);
+    outputBuffer.release();
+  }
+
+  /**
+   * Drops frames from the current output buffer to the next keyframe at or before the playback
+   * position. If no such keyframe exists, as the playback position is inside the same group of
+   * pictures as the buffer being processed, returns {@code false}. Returns {@code true} otherwise.
+   *
+   * @param positionUs The current playback position, in microseconds.
+   * @return Whether any buffers were dropped.
+   * @throws ExoPlaybackException If an error occurs flushing the decoder.
+   */
+  protected boolean maybeDropBuffersToKeyframe(long positionUs) throws ExoPlaybackException {
+    int droppedSourceBufferCount = skipSource(positionUs);
+    if (droppedSourceBufferCount == 0) {
+      return false;
+    }
+    decoderCounters.droppedToKeyframeCount++;
+    // We dropped some buffers to catch up, so update the decoder counters and flush the decoder,
+    // which releases all pending buffers buffers including the current output buffer.
+    updateDroppedBufferCounters(buffersInCodecCount + droppedSourceBufferCount);
+    flushDecoder();
+    return true;
+  }
+
+  /**
+   * Updates decoder counters to reflect that {@code droppedBufferCount} additional buffers were
+   * dropped.
+   *
+   * @param droppedBufferCount The number of additional dropped buffers.
+   */
+  protected void updateDroppedBufferCounters(int droppedBufferCount) {
+    decoderCounters.droppedBufferCount += droppedBufferCount;
+    droppedFrames += droppedBufferCount;
+    consecutiveDroppedFrameCount += droppedBufferCount;
+    decoderCounters.maxConsecutiveDroppedBufferCount =
+        Math.max(consecutiveDroppedFrameCount, decoderCounters.maxConsecutiveDroppedBufferCount);
+    if (maxDroppedFramesToNotify > 0 && droppedFrames >= maxDroppedFramesToNotify) {
+      maybeNotifyDroppedFrames();
+    }
+  }
+
+  /**
+   * Returns the extent to which the subclass supports a given format.
+   *
+   * @param drmSessionManager The renderer's {@link DrmSessionManager}.
+   * @param format The format, which has a video {@link Format#sampleMimeType}.
+   * @return The extent to which the subclass supports the format itself.
+   * @see RendererCapabilities#supportsFormat(Format)
+   */
+  protected abstract int supportsFormatInternal(
+      @Nullable DrmSessionManager<ExoMediaCrypto> drmSessionManager, Format format);
+
+  /**
+   * Creates a decoder for the given format.
+   *
+   * @param format The format for which a decoder is required.
+   * @param mediaCrypto The {@link ExoMediaCrypto} object required for decoding encrypted content.
+   *     May be null and can be ignored if decoder does not handle encrypted content.
+   * @return The decoder.
+   * @throws VideoDecoderException If an error occurred creating a suitable decoder.
+   */
+  protected abstract SimpleDecoder<
+          VideoDecoderInputBuffer,
+          ? extends VideoDecoderOutputBuffer,
+          ? extends VideoDecoderException>
+      createDecoder(Format format, @Nullable ExoMediaCrypto mediaCrypto)
+          throws VideoDecoderException;
+
+  /**
+   * Dequeues output buffer.
+   *
+   * @return Dequeued video decoder output buffer, or null if an output buffer isn't available.
+   * @throws VideoDecoderException If an error occurs while dequeuing the output buffer.
+   */
+  @Nullable
+  protected abstract VideoDecoderOutputBuffer dequeueOutputBuffer() throws VideoDecoderException;
+
+  /** Clears output buffer. */
+  protected void clearOutputBuffer() {
+    outputBuffer = null;
+  }
+
+  /**
+   * Renders the specified output buffer.
+   *
+   * <p>The implementation of this method takes ownership of the output buffer and is responsible
+   * for calling {@link VideoDecoderOutputBuffer#release()} either immediately or in the future.
+   *
+   * @param presentationTimeUs Presentation time in microseconds.
+   * @param outputFormat Output format.
+   */
+  // TODO: The output buffer is not being passed to this method currently. Due to the need of
+  // decoder-specific output buffer type, the reference to the output buffer is being kept in the
+  // subclass. Once the common output buffer is established, this method can be updated to receive
+  // the output buffer as an argument. See [Internal: b/139174707].
+  protected abstract void renderOutputBuffer(long presentationTimeUs, Format outputFormat)
+      throws VideoDecoderException;
+
+  /**
+   * Returns whether the renderer has output surface.
+   *
+   * @return Whether the renderer has output surface.
+   */
+  protected abstract boolean hasOutputSurface();
+
+  /** Called when the output surface is changed. */
+  protected final void onOutputSurfaceChanged() {
+    // If we know the video size, report it again immediately.
+    maybeRenotifyVideoSizeChanged();
+    // We haven't rendered to the new output yet.
+    clearRenderedFirstFrame();
+    if (getState() == STATE_STARTED) {
+      setJoiningDeadlineMs();
+    }
+  }
+
+  /** Called when the output surface is removed. */
+  protected final void onOutputSurfaceRemoved() {
+    clearReportedVideoSize();
+    clearRenderedFirstFrame();
+  }
+
+  /**
+   * Called when the output surface is set again to the same non-null value.
+   *
+   * @param surface Output surface.
+   */
+  protected final void onOutputSurfaceReset(Surface surface) {
+    // The output is unchanged and non-null. If we know the video size and/or have already
+    // rendered to the output, report these again immediately.
+    maybeRenotifyVideoSizeChanged();
+    maybeRenotifyRenderedFirstFrame(surface);
+  }
+
+  /**
+   * Notifies event dispatcher if video size changed.
+   *
+   * @param width New video width.
+   * @param height New video height.
+   */
+  protected final void maybeNotifyVideoSizeChanged(int width, int height) {
+    if (reportedWidth != width || reportedHeight != height) {
+      reportedWidth = width;
+      reportedHeight = height;
+      eventDispatcher.videoSizeChanged(
+          width, height, /* unappliedRotationDegrees= */ 0, /* pixelWidthHeightRatio= */ 1);
+    }
+  }
+
+  /** Called after rendering a frame. */
+  protected final void onFrameRendered(Surface surface) {
+    consecutiveDroppedFrameCount = 0;
+    decoderCounters.renderedOutputBufferCount++;
+    maybeNotifyRenderedFirstFrame(surface);
+  }
+
+  // Internal methods.
+
+  private void maybeInitDecoder() throws ExoPlaybackException {
+    if (decoder != null) {
+      return;
+    }
+
+    setDecoderDrmSession(sourceDrmSession);
+
+    ExoMediaCrypto mediaCrypto = null;
+    if (decoderDrmSession != null) {
+      mediaCrypto = decoderDrmSession.getMediaCrypto();
+      if (mediaCrypto == null) {
+        DrmSessionException drmError = decoderDrmSession.getError();
+        if (drmError != null) {
+          // Continue for now. We may be able to avoid failure if the session recovers, or if a new
+          // input format causes the session to be replaced before it's used.
+        } else {
+          // The drm session isn't open yet.
+          return;
+        }
+      }
+    }
+
+    try {
+      long decoderInitializingTimestamp = SystemClock.elapsedRealtime();
+      decoder = createDecoder(format, mediaCrypto);
+      long decoderInitializedTimestamp = SystemClock.elapsedRealtime();
+      onDecoderInitialized(
+          decoder.getName(),
+          decoderInitializedTimestamp,
+          decoderInitializedTimestamp - decoderInitializingTimestamp);
+      decoderCounters.decoderInitCount++;
+    } catch (VideoDecoderException e) {
+      throw ExoPlaybackException.createForRenderer(e, getIndex());
+    }
+  }
+
+  private boolean feedInputBuffer() throws VideoDecoderException, ExoPlaybackException {
+    if (decoder == null
+        || decoderReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM
+        || inputStreamEnded) {
+      // We need to reinitialize the decoder or the input stream has ended.
+      return false;
+    }
+
+    if (inputBuffer == null) {
+      inputBuffer = decoder.dequeueInputBuffer();
+      if (inputBuffer == null) {
+        return false;
+      }
+    }
+
+    if (decoderReinitializationState == REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM) {
+      inputBuffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
+      decoder.queueInputBuffer(inputBuffer);
+      inputBuffer = null;
+      decoderReinitializationState = REINITIALIZATION_STATE_WAIT_END_OF_STREAM;
+      return false;
+    }
+
+    int result;
+    if (waitingForKeys) {
+      // We've already read an encrypted sample into buffer, and are waiting for keys.
+      result = C.RESULT_BUFFER_READ;
+    } else {
+      result = readSource(formatHolder, inputBuffer, false);
+    }
+
+    if (result == C.RESULT_NOTHING_READ) {
+      return false;
+    }
+    if (result == C.RESULT_FORMAT_READ) {
+      onInputFormatChanged(formatHolder);
+      return true;
+    }
+    if (inputBuffer.isEndOfStream()) {
+      inputStreamEnded = true;
+      decoder.queueInputBuffer(inputBuffer);
+      inputBuffer = null;
+      return false;
+    }
+    boolean bufferEncrypted = inputBuffer.isEncrypted();
+    waitingForKeys = shouldWaitForKeys(bufferEncrypted);
+    if (waitingForKeys) {
+      return false;
+    }
+    if (pendingFormat != null) {
+      formatQueue.add(inputBuffer.timeUs, pendingFormat);
+      pendingFormat = null;
+    }
+    inputBuffer.flip();
+    inputBuffer.colorInfo = format.colorInfo;
+    onQueueInputBuffer(inputBuffer);
+    decoder.queueInputBuffer(inputBuffer);
+    buffersInCodecCount++;
+    decoderReceivedBuffers = true;
+    decoderCounters.inputBufferCount++;
+    inputBuffer = null;
+    return true;
+  }
+
+  /**
+   * Attempts to dequeue an output buffer from the decoder and, if successful, passes it to {@link
+   * #processOutputBuffer(long, long)}.
+   *
+   * @param positionUs The player's current position.
+   * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
+   *     measured at the start of the current iteration of the rendering loop.
+   * @return Whether it may be possible to drain more output data.
+   * @throws ExoPlaybackException If an error occurs draining the output buffer.
+   */
+  private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
+      throws ExoPlaybackException, VideoDecoderException {
+    if (outputBuffer == null) {
+      outputBuffer = dequeueOutputBuffer();
+      if (outputBuffer == null) {
+        return false;
+      }
+      decoderCounters.skippedOutputBufferCount += outputBuffer.skippedOutputBufferCount;
+      buffersInCodecCount -= outputBuffer.skippedOutputBufferCount;
+    }
+
+    if (outputBuffer.isEndOfStream()) {
+      if (decoderReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM) {
+        // We're waiting to re-initialize the decoder, and have now processed all final buffers.
+        releaseDecoder();
+        maybeInitDecoder();
+      } else {
+        outputBuffer.release();
+        clearOutputBuffer();
+        outputStreamEnded = true;
+      }
+      return false;
+    }
+
+    boolean processedOutputBuffer = processOutputBuffer(positionUs, elapsedRealtimeUs);
+    if (processedOutputBuffer) {
+      onProcessedOutputBuffer(outputBuffer.timeUs);
+      clearOutputBuffer();
+    }
+    return processedOutputBuffer;
+  }
+
+  /**
+   * Processes {@link #outputBuffer} by rendering it, skipping it or doing nothing, and returns
+   * whether it may be possible to process another output buffer.
+   *
+   * @param positionUs The player's current position.
+   * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
+   *     measured at the start of the current iteration of the rendering loop.
+   * @return Whether it may be possible to drain another output buffer.
+   * @throws ExoPlaybackException If an error occurs processing the output buffer.
+   */
+  private boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs)
+      throws ExoPlaybackException, VideoDecoderException {
+    if (initialPositionUs == C.TIME_UNSET) {
+      initialPositionUs = positionUs;
+    }
+
+    long earlyUs = outputBuffer.timeUs - positionUs;
+    if (!hasOutputSurface()) {
+      // Skip frames in sync with playback, so we'll be at the right frame if the mode changes.
+      if (isBufferLate(earlyUs)) {
+        skipOutputBuffer(outputBuffer);
+        return true;
+      }
+      return false;
+    }
+
+    long presentationTimeUs = outputBuffer.timeUs - outputStreamOffsetUs;
+    Format format = formatQueue.pollFloor(presentationTimeUs);
+    if (format != null) {
+      outputFormat = format;
+    }
+
+    long elapsedRealtimeNowUs = SystemClock.elapsedRealtime() * 1000;
+    boolean isStarted = getState() == STATE_STARTED;
+    if (!renderedFirstFrame
+        || (isStarted
+            && shouldForceRenderOutputBuffer(earlyUs, elapsedRealtimeNowUs - lastRenderTimeUs))) {
+      lastRenderTimeUs = SystemClock.elapsedRealtime() * 1000;
+      renderOutputBuffer(presentationTimeUs, outputFormat);
+      return true;
+    }
+
+    if (!isStarted || positionUs == initialPositionUs) {
+      return false;
+    }
+
+    if (shouldDropBuffersToKeyframe(earlyUs, elapsedRealtimeUs)
+        && maybeDropBuffersToKeyframe(positionUs)) {
+      return false;
+    } else if (shouldDropOutputBuffer(earlyUs, elapsedRealtimeUs)) {
+      dropOutputBuffer(outputBuffer);
+      return true;
+    }
+
+    if (earlyUs < 30000) {
+      lastRenderTimeUs = SystemClock.elapsedRealtime() * 1000;
+      renderOutputBuffer(presentationTimeUs, outputFormat);
+      return true;
+    }
+
+    return false;
+  }
+
+  private boolean shouldWaitForKeys(boolean bufferEncrypted) throws ExoPlaybackException {
+    if (decoderDrmSession == null || (!bufferEncrypted && playClearSamplesWithoutKeys)) {
+      return false;
+    }
+    @DrmSession.State int drmSessionState = decoderDrmSession.getState();
+    if (drmSessionState == DrmSession.STATE_ERROR) {
+      throw ExoPlaybackException.createForRenderer(decoderDrmSession.getError(), getIndex());
+    }
+    return drmSessionState != DrmSession.STATE_OPENED_WITH_KEYS;
+  }
+
+  private void setJoiningDeadlineMs() {
+    joiningDeadlineMs =
+        allowedJoiningTimeMs > 0
+            ? (SystemClock.elapsedRealtime() + allowedJoiningTimeMs)
+            : C.TIME_UNSET;
+  }
+
+  private void clearRenderedFirstFrame() {
+    renderedFirstFrame = false;
+  }
+
+  private void maybeNotifyRenderedFirstFrame(Surface surface) {
+    if (!renderedFirstFrame) {
+      renderedFirstFrame = true;
+      eventDispatcher.renderedFirstFrame(surface);
+    }
+  }
+
+  private void maybeRenotifyRenderedFirstFrame(Surface surface) {
+    if (renderedFirstFrame) {
+      eventDispatcher.renderedFirstFrame(surface);
+    }
+  }
+
+  private void clearReportedVideoSize() {
+    reportedWidth = Format.NO_VALUE;
+    reportedHeight = Format.NO_VALUE;
+  }
+
+  private void maybeRenotifyVideoSizeChanged() {
+    if (reportedWidth != Format.NO_VALUE || reportedHeight != Format.NO_VALUE) {
+      eventDispatcher.videoSizeChanged(
+          reportedWidth,
+          reportedHeight,
+          /* unappliedRotationDegrees= */ 0,
+          /* pixelWidthHeightRatio= */ 1);
+    }
+  }
+
+  private void maybeNotifyDroppedFrames() {
+    if (droppedFrames > 0) {
+      long now = SystemClock.elapsedRealtime();
+      long elapsedMs = now - droppedFrameAccumulationStartTimeMs;
+      eventDispatcher.droppedFrames(droppedFrames, elapsedMs);
+      droppedFrames = 0;
+      droppedFrameAccumulationStartTimeMs = now;
+    }
+  }
+
+  private static boolean isBufferLate(long earlyUs) {
+    // Class a buffer as late if it should have been presented more than 30 ms ago.
+    return earlyUs < -30000;
+  }
+
+  private static boolean isBufferVeryLate(long earlyUs) {
+    // Class a buffer as very late if it should have been presented more than 500 ms ago.
+    return earlyUs < -500000;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderInputBuffer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderInputBuffer.java
index 76742a8691..360279c11c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderInputBuffer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderInputBuffer.java
@@ -15,12 +15,13 @@
  */
 package com.google.android.exoplayer2.video;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 
 /** Input buffer to a video decoder. */
 public class VideoDecoderInputBuffer extends DecoderInputBuffer {
 
-  public ColorInfo colorInfo;
+  @Nullable public ColorInfo colorInfo;
 
   public VideoDecoderInputBuffer() {
     super(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_DIRECT);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java
index af0844defb..b4b09b20a2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.video;
 
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.decoder.OutputBuffer;
 import java.nio.ByteBuffer;
@@ -33,16 +34,16 @@
   /** Output mode. */
   @C.VideoOutputMode public int mode;
   /** RGB buffer for RGB mode. */
-  public ByteBuffer data;
+  @Nullable public ByteBuffer data;
 
   public int width;
   public int height;
-  public ColorInfo colorInfo;
+  @Nullable public ColorInfo colorInfo;
 
   /** YUV planes for YUV mode. */
-  public ByteBuffer[] yuvPlanes;
+  @Nullable public ByteBuffer[] yuvPlanes;
 
-  public int[] yuvStrides;
+  @Nullable public int[] yuvStrides;
   public int colorspace;
 
   /**
@@ -88,6 +89,10 @@ public boolean initForYuvFrame(int width, int height, int yStride, int uvStride,
     if (yuvPlanes == null) {
       yuvPlanes = new ByteBuffer[3];
     }
+
+    ByteBuffer data = this.data;
+    ByteBuffer[] yuvPlanes = this.yuvPlanes;
+
     // Rewrapping has to be done on every frame since the stride might have changed.
     yuvPlanes[0] = data.slice();
     yuvPlanes[0].limit(yLength);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/package-info.java b/library/core/src/main/java/com/google/android/exoplayer2/video/package-info.java
new file mode 100644
index 0000000000..3c2cd217e0
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.video;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/CameraMotionRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/CameraMotionRenderer.java
index 03822be17c..7d76f43d04 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/CameraMotionRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/CameraMotionRenderer.java
@@ -93,7 +93,7 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
       buffer.flip();
       lastTimestampUs = buffer.timeUs;
       if (listener != null) {
-        float[] rotation = parseMetadata(buffer.data);
+        float[] rotation = parseMetadata(Util.castNonNull(buffer.data));
         if (rotation != null) {
           Util.castNonNull(listener).onCameraMotion(lastTimestampUs - offsetUs, rotation);
         }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/package-info.java b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/package-info.java
new file mode 100644
index 0000000000..2dce6889d8
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.video.spherical;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/MetadataRendererTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/MetadataRendererTest.java
new file mode 100644
index 0000000000..4de8bb76cc
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/MetadataRendererTest.java
@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+package com.google.android.exoplayer2.metadata;
+
+import static com.google.common.truth.Truth.assertThat;
+import static java.nio.charset.StandardCharsets.ISO_8859_1;
+import static java.nio.charset.StandardCharsets.UTF_8;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.metadata.emsg.EventMessage;
+import com.google.android.exoplayer2.metadata.emsg.EventMessageEncoder;
+import com.google.android.exoplayer2.metadata.id3.TextInformationFrame;
+import com.google.android.exoplayer2.testutil.FakeSampleStream;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.MimeTypes;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Tests for {@link MetadataRenderer}. */
+@RunWith(AndroidJUnit4.class)
+public class MetadataRendererTest {
+
+  private static final Format EMSG_FORMAT =
+      Format.createSampleFormat(null, MimeTypes.APPLICATION_EMSG, Format.OFFSET_SAMPLE_RELATIVE);
+
+  private final EventMessageEncoder eventMessageEncoder = new EventMessageEncoder();
+
+  @Test
+  public void decodeMetadata() throws Exception {
+    EventMessage emsg =
+        new EventMessage(
+            "urn:test-scheme-id",
+            /* value= */ "",
+            /* durationMs= */ 1,
+            /* id= */ 0,
+            "Test data".getBytes(UTF_8));
+
+    List<Metadata> metadata = runRenderer(eventMessageEncoder.encode(emsg));
+
+    assertThat(metadata).hasSize(1);
+    assertThat(metadata.get(0).length()).isEqualTo(1);
+    assertThat(metadata.get(0).get(0)).isEqualTo(emsg);
+  }
+
+  @Test
+  public void decodeMetadata_handlesWrappedMetadata() throws Exception {
+    EventMessage emsg =
+        new EventMessage(
+            EventMessage.ID3_SCHEME_ID,
+            /* value= */ "",
+            /* durationMs= */ 1,
+            /* id= */ 0,
+            encodeTxxxId3Frame("Test description", "Test value"));
+
+    List<Metadata> metadata = runRenderer(eventMessageEncoder.encode(emsg));
+
+    assertThat(metadata).hasSize(1);
+    assertThat(metadata.get(0).length()).isEqualTo(1);
+    TextInformationFrame expectedId3Frame =
+        new TextInformationFrame("TXXX", "Test description", "Test value");
+    assertThat(metadata.get(0).get(0)).isEqualTo(expectedId3Frame);
+  }
+
+  @Test
+  public void decodeMetadata_skipsMalformedWrappedMetadata() throws Exception {
+    EventMessage emsg =
+        new EventMessage(
+            EventMessage.ID3_SCHEME_ID,
+            /* value= */ "",
+            /* durationMs= */ 1,
+            /* id= */ 0,
+            "Not a real ID3 tag".getBytes(ISO_8859_1));
+
+    List<Metadata> metadata = runRenderer(eventMessageEncoder.encode(emsg));
+
+    assertThat(metadata).isEmpty();
+  }
+
+  private static List<Metadata> runRenderer(byte[] input) throws ExoPlaybackException {
+    List<Metadata> metadata = new ArrayList<>();
+    MetadataRenderer renderer = new MetadataRenderer(metadata::add, /* outputLooper= */ null);
+    renderer.replaceStream(
+        new Format[] {EMSG_FORMAT},
+        new FakeSampleStream(EMSG_FORMAT, /* eventDispatcher= */ null, input),
+        /* offsetUs= */ 0L);
+    renderer.render(/* positionUs= */ 0, /* elapsedRealtimeUs= */ 0); // Read the format
+    renderer.render(/* positionUs= */ 0, /* elapsedRealtimeUs= */ 0); // Read the data
+
+    return Collections.unmodifiableList(metadata);
+  }
+
+  /**
+   * Builds an ID3v2 tag containing a single 'user defined text information frame' (id='TXXX') with
+   * {@code description} and {@code value}.
+   *
+   * <ul>
+   *   <li><a href="http://id3.org/id3v2.4.0-structure">ID3v2 overall structure</a>
+   *   <li><a href="http://id3.org/id3v2.4.0-frames">'user defined text information frame' spec</a>
+   *       (item 4.2.6)
+   * </ul>
+   */
+  private static byte[] encodeTxxxId3Frame(String description, String value) {
+    byte[] id3FrameData =
+        TestUtil.joinByteArrays(
+            "TXXX".getBytes(ISO_8859_1), // ID for a 'user defined text information frame'
+            TestUtil.createByteArray(0, 0, 0, 0), // Frame size (set later)
+            TestUtil.createByteArray(0, 0), // Frame flags
+            TestUtil.createByteArray(0), // Character encoding = ISO-8859-1
+            description.getBytes(ISO_8859_1),
+            TestUtil.createByteArray(0), // String null terminator
+            value.getBytes(ISO_8859_1),
+            TestUtil.createByteArray(0)); // String null terminator
+    int frameSizeIndex = 7;
+    int frameSize = id3FrameData.length - 10;
+    Assertions.checkArgument(
+        frameSize < 128, "frameSize must fit in 7 bits to avoid synch-safe encoding: " + frameSize);
+    id3FrameData[frameSizeIndex] = (byte) frameSize;
+
+    byte[] id3Bytes =
+        TestUtil.joinByteArrays(
+            "ID3".getBytes(ISO_8859_1), // identifier
+            TestUtil.createByteArray(0x04, 0x00), // version
+            TestUtil.createByteArray(0), // Tag flags
+            TestUtil.createByteArray(0, 0, 0, 0), // Tag size (set later)
+            id3FrameData);
+    int tagSizeIndex = 9;
+    int tagSize = id3Bytes.length - 10;
+    Assertions.checkArgument(
+        tagSize < 128, "tagSize must fit in 7 bits to avoid synch-safe encoding: " + tagSize);
+    id3Bytes[tagSizeIndex] = (byte) tagSize;
+    return id3Bytes;
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelectionTest.java b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelectionTest.java
index 456f7f7107..af935048e8 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelectionTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelectionTest.java
@@ -16,9 +16,6 @@
 package com.google.android.exoplayer2.trackselection;
 
 import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.argThat;
-import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
@@ -37,13 +34,11 @@
 import com.google.android.exoplayer2.upstream.BandwidthMeter;
 import com.google.android.exoplayer2.util.MimeTypes;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.mockito.ArgumentMatcher;
 import org.mockito.Mock;
 
 /** Unit test for {@link AdaptiveTrackSelection}. */
@@ -231,54 +226,6 @@ public void testUpdateSelectedTrackSwitchDownIfNotBufferedEnough() {
     assertThat(adaptiveTrackSelection.getSelectionReason()).isEqualTo(C.SELECTION_REASON_ADAPTIVE);
   }
 
-  @Test
-  public void testUpdateSelectedTrackSwitchUpIfTrackBitrateEstimateIsLow() {
-    Format format1 = videoFormat(/* bitrate= */ 500, /* width= */ 320, /* height= */ 240);
-    Format format2 = videoFormat(/* bitrate= */ 1000, /* width= */ 640, /* height= */ 480);
-    Format format3 = videoFormat(/* bitrate= */ 2000, /* width= */ 960, /* height= */ 720);
-    TrackGroup trackGroup = new TrackGroup(format1, format2, format3);
-
-    // The second measurement onward returns 1500L, which isn't enough to switch up to format3 as
-    // the format bitrate is 2000.
-    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(1000L, 1500L);
-
-    // But TrackBitrateEstimator returns 1500 for 3rd track so it should switch up.
-    TrackBitrateEstimator estimator = mock(TrackBitrateEstimator.class);
-    when(estimator.getBitrates(any(), any(), any(), any()))
-        .then(
-            (invocation) -> {
-              int[] returnValue = new int[] {500, 1000, 1500};
-              int[] inputArray = (int[]) invocation.getArguments()[3];
-              System.arraycopy(returnValue, 0, inputArray, 0, returnValue.length);
-              return returnValue;
-            });
-
-    adaptiveTrackSelection = adaptiveTrackSelection(trackGroup);
-    adaptiveTrackSelection.experimental_setTrackBitrateEstimator(estimator);
-
-    adaptiveTrackSelection.updateSelectedTrack(
-        /* playbackPositionUs= */ 0,
-        /* bufferedDurationUs= */ AdaptiveTrackSelection
-                .DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS
-            * 1000,
-        /* availableDurationUs= */ C.TIME_UNSET,
-        /* queue= */ Collections.emptyList(),
-        /* mediaChunkIterators= */ THREE_EMPTY_MEDIA_CHUNK_ITERATORS);
-
-    ArgumentMatcher<Format[]> matcher =
-        formats ->
-            formats.length == 3
-                && Arrays.asList(formats).containsAll(Arrays.asList(format1, format2, format3));
-    verify(estimator)
-        .getBitrates(
-            argThat(matcher),
-            eq(Collections.emptyList()),
-            eq(THREE_EMPTY_MEDIA_CHUNK_ITERATORS),
-            any());
-    assertThat(adaptiveTrackSelection.getSelectedFormat()).isEqualTo(format3);
-    assertThat(adaptiveTrackSelection.getSelectionReason()).isEqualTo(C.SELECTION_REASON_ADAPTIVE);
-  }
-
   @Test
   public void testEvaluateQueueSizeReturnQueueSizeIfBandwidthIsNotImproved() {
     Format format1 = videoFormat(/* bitrate= */ 500, /* width= */ 320, /* height= */ 240);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/TrackSelectionUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/TrackSelectionUtilTest.java
deleted file mode 100644
index 963e90f139..0000000000
--- a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/TrackSelectionUtilTest.java
+++ /dev/null
@@ -1,617 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.trackselection;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import android.net.Uri;
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
-import com.google.android.exoplayer2.testutil.FakeMediaChunk;
-import com.google.android.exoplayer2.testutil.FakeMediaChunkIterator;
-import com.google.android.exoplayer2.upstream.DataSpec;
-import java.util.Arrays;
-import java.util.Collections;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-/** {@link TrackSelectionUtil} tests. */
-@RunWith(AndroidJUnit4.class)
-public class TrackSelectionUtilTest {
-
-  public static final long MAX_DURATION_US = 30 * C.MICROS_PER_SECOND;
-
-  @Test
-  public void getAverageBitrate_emptyIterator_returnsNoValue() {
-    assertThat(TrackSelectionUtil.getAverageBitrate(MediaChunkIterator.EMPTY, MAX_DURATION_US))
-        .isEqualTo(Format.NO_VALUE);
-  }
-
-  @Test
-  public void getAverageBitrate_oneChunk_returnsChunkBitrate() {
-    long[] chunkTimeBoundariesSec = {12, 17};
-    long[] chunkLengths = {10};
-
-    FakeMediaChunkIterator iterator =
-        new FakeMediaChunkIterator(chunkTimeBoundariesSec, chunkLengths);
-
-    assertThat(TrackSelectionUtil.getAverageBitrate(iterator, MAX_DURATION_US)).isEqualTo(16);
-  }
-
-  @Test
-  public void getAverageBitrate_multipleSameDurationChunks_returnsAverageChunkBitrate() {
-    long[] chunkTimeBoundariesSec = {0, 5, 10};
-    long[] chunkLengths = {10, 20};
-
-    FakeMediaChunkIterator iterator =
-        new FakeMediaChunkIterator(chunkTimeBoundariesSec, chunkLengths);
-
-    assertThat(TrackSelectionUtil.getAverageBitrate(iterator, MAX_DURATION_US)).isEqualTo(24);
-  }
-
-  @Test
-  public void getAverageBitrate_multipleDifferentDurationChunks_returnsAverageChunkBitrate() {
-    long[] chunkTimeBoundariesSec = {0, 5, 15, 30};
-    long[] chunkLengths = {10, 20, 30};
-
-    FakeMediaChunkIterator iterator =
-        new FakeMediaChunkIterator(chunkTimeBoundariesSec, chunkLengths);
-
-    assertThat(TrackSelectionUtil.getAverageBitrate(iterator, MAX_DURATION_US)).isEqualTo(16);
-  }
-
-  @Test
-  public void getAverageBitrate_firstChunkLengthUnset_returnsNoValue() {
-    long[] chunkTimeBoundariesSec = {0, 5, 15, 30};
-    long[] chunkLengths = {C.LENGTH_UNSET, 20, 30};
-
-    FakeMediaChunkIterator iterator =
-        new FakeMediaChunkIterator(chunkTimeBoundariesSec, chunkLengths);
-
-    assertThat(TrackSelectionUtil.getAverageBitrate(iterator, MAX_DURATION_US))
-        .isEqualTo(Format.NO_VALUE);
-  }
-
-  @Test
-  public void getAverageBitrate_secondChunkLengthUnset_returnsFirstChunkBitrate() {
-    long[] chunkTimeBoundariesSec = {0, 5, 15, 30};
-    long[] chunkLengths = {10, C.LENGTH_UNSET, 30};
-
-    FakeMediaChunkIterator iterator =
-        new FakeMediaChunkIterator(chunkTimeBoundariesSec, chunkLengths);
-
-    assertThat(TrackSelectionUtil.getAverageBitrate(iterator, MAX_DURATION_US)).isEqualTo(16);
-  }
-
-  @Test
-  public void
-      getAverageBitrate_chunksExceedingMaxDuration_returnsAverageChunkBitrateUpToMaxDuration() {
-    long[] chunkTimeBoundariesSec = {0, 5, 15, 45, 50};
-    long[] chunkLengths = {10, 20, 30, 100};
-    FakeMediaChunkIterator iterator =
-        new FakeMediaChunkIterator(chunkTimeBoundariesSec, chunkLengths);
-
-    long maxDurationUs = 30 * C.MICROS_PER_SECOND;
-    int averageBitrate = TrackSelectionUtil.getAverageBitrate(iterator, maxDurationUs);
-
-    assertThat(averageBitrate).isEqualTo(12);
-  }
-
-  @Test
-  public void getAverageBitrate_zeroMaxDuration_returnsNoValue() {
-    long[] chunkTimeBoundariesSec = {0, 5, 10};
-    long[] chunkLengths = {10, 20};
-
-    FakeMediaChunkIterator iterator =
-        new FakeMediaChunkIterator(chunkTimeBoundariesSec, chunkLengths);
-
-    assertThat(TrackSelectionUtil.getAverageBitrate(iterator, /* maxDurationUs= */ 0))
-        .isEqualTo(Format.NO_VALUE);
-  }
-
-  @Test
-  public void getBitratesUsingFutureInfo_noIterator_returnsEmptyArray() {
-    assertThat(
-            TrackSelectionUtil.getBitratesUsingFutureInfo(
-                new MediaChunkIterator[0], new Format[0], MAX_DURATION_US, /* bitrates= */ null))
-        .hasLength(0);
-  }
-
-  @Test
-  public void getBitratesUsingFutureInfo_emptyIterator_returnsNoValue() {
-    int[] bitrates =
-        TrackSelectionUtil.getBitratesUsingFutureInfo(
-            new MediaChunkIterator[] {MediaChunkIterator.EMPTY},
-            new Format[] {createFormatWithBitrate(10)},
-            MAX_DURATION_US,
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(Format.NO_VALUE);
-  }
-
-  @Test
-  public void getBitratesUsingFutureInfo_twoTracksZeroMaxDuration_returnsNoValue() {
-    FakeMediaChunkIterator iterator1 =
-        new FakeMediaChunkIterator(
-            /* chunkTimeBoundariesSec= */ new long[] {0, 10}, /* chunkLengths= */ new long[] {10});
-    FakeMediaChunkIterator iterator2 =
-        new FakeMediaChunkIterator(
-            /* chunkTimeBoundariesSec= */ new long[] {0, 5, 15, 30},
-            /* chunkLengths= */ new long[] {10, 20, 30});
-
-    int[] bitrates =
-        TrackSelectionUtil.getBitratesUsingFutureInfo(
-            new MediaChunkIterator[] {iterator1, iterator2},
-            new Format[] {createFormatWithBitrate(10), createFormatWithBitrate(20)},
-            /* maxDurationUs= */ 0,
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(Format.NO_VALUE, Format.NO_VALUE);
-  }
-
-  @Test
-  public void getBitratesUsingFutureInfo_twoTracks_returnsBitrates() {
-    FakeMediaChunkIterator iterator1 =
-        new FakeMediaChunkIterator(
-            /* chunkTimeBoundariesSec= */ new long[] {0, 10}, /* chunkLengths= */ new long[] {10});
-    FakeMediaChunkIterator iterator2 =
-        new FakeMediaChunkIterator(
-            /* chunkTimeBoundariesSec= */ new long[] {0, 5, 15, 30},
-            /* chunkLengths= */ new long[] {10, 20, 30});
-
-    int[] bitrates =
-        TrackSelectionUtil.getBitratesUsingFutureInfo(
-            new MediaChunkIterator[] {iterator1, iterator2},
-            new Format[] {createFormatWithBitrate(10), createFormatWithBitrate(20)},
-            MAX_DURATION_US,
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(8, 16).inOrder();
-  }
-
-  @Test
-  public void getBitratesUsingFutureInfo_bitratesArrayGiven_returnsTheSameArray() {
-    FakeMediaChunkIterator iterator1 =
-        new FakeMediaChunkIterator(
-            /* chunkTimeBoundariesSec= */ new long[] {0, 10}, /* chunkLengths= */ new long[] {10});
-    FakeMediaChunkIterator iterator2 =
-        new FakeMediaChunkIterator(
-            /* chunkTimeBoundariesSec= */ new long[] {0, 5, 15, 30},
-            /* chunkLengths= */ new long[] {10, 20, 30});
-
-    int[] bitratesArrayToUse = new int[2];
-    int[] bitrates =
-        TrackSelectionUtil.getBitratesUsingFutureInfo(
-            new MediaChunkIterator[] {iterator1, iterator2},
-            new Format[] {createFormatWithBitrate(10), createFormatWithBitrate(20)},
-            MAX_DURATION_US,
-            bitratesArrayToUse);
-
-    assertThat(bitrates).isSameInstanceAs(bitratesArrayToUse);
-  }
-
-  @Test
-  public void getBitratesUsingFutureInfo_emptyIterator_returnsEstimationUsingClosest() {
-    FakeMediaChunkIterator iterator1 =
-        new FakeMediaChunkIterator(
-            /* chunkTimeBoundariesSec= */ new long[] {0, 5}, /* chunkLengths= */ new long[] {10});
-    Format format1 = createFormatWithBitrate(10);
-    MediaChunkIterator iterator2 = MediaChunkIterator.EMPTY;
-    Format format2 = createFormatWithBitrate(20);
-    FakeMediaChunkIterator iterator3 =
-        new FakeMediaChunkIterator(
-            /* chunkTimeBoundariesSec= */ new long[] {0, 5}, /* chunkLengths= */ new long[] {50});
-    Format format3 = createFormatWithBitrate(25);
-    FakeMediaChunkIterator iterator4 =
-        new FakeMediaChunkIterator(
-            /* chunkTimeBoundariesSec= */ new long[] {0, 5}, /* chunkLengths= */ new long[] {20});
-    Format format4 = createFormatWithBitrate(30);
-
-    int[] bitrates =
-        TrackSelectionUtil.getBitratesUsingFutureInfo(
-            new MediaChunkIterator[] {iterator1, iterator2, iterator3, iterator4},
-            new Format[] {format1, format2, format3, format4},
-            MAX_DURATION_US,
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(16, 64, 80, 32).inOrder();
-  }
-
-  @Test
-  public void getBitratesUsingFutureInfo_formatWithoutBitrate_returnsNoValueForEmpty() {
-    FakeMediaChunkIterator iterator1 =
-        new FakeMediaChunkIterator(
-            /* chunkTimeBoundariesSec= */ new long[] {0, 5}, /* chunkLengths= */ new long[] {10});
-    Format format1 = createFormatWithBitrate(10);
-    MediaChunkIterator iterator2 = MediaChunkIterator.EMPTY;
-    Format format2 = createFormatWithBitrate(Format.NO_VALUE);
-
-    int[] bitrates =
-        TrackSelectionUtil.getBitratesUsingFutureInfo(
-            new MediaChunkIterator[] {iterator1, iterator2},
-            new Format[] {format1, format2},
-            MAX_DURATION_US,
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(16, Format.NO_VALUE).inOrder();
-  }
-
-  @Test
-  public void getBitratesUsingPastInfo_noFormat_returnsEmptyArray() {
-    FakeMediaChunk chunk =
-        createChunk(
-            createFormatWithBitrate(10),
-            /* length= */ 10,
-            /* startTimeSec= */ 0,
-            /* endTimeSec= */ 10);
-
-    int[] bitrates =
-        TrackSelectionUtil.getBitratesUsingPastInfo(
-            Collections.singletonList(chunk), new Format[0], MAX_DURATION_US, /* bitrates= */ null);
-
-    assertThat(bitrates).hasLength(0);
-  }
-
-  @Test
-  public void getBitratesUsingPastInfo_emptyQueue_returnsNoValue() {
-    int[] bitrates =
-        TrackSelectionUtil.getBitratesUsingPastInfo(
-            Collections.emptyList(),
-            new Format[] {createFormatWithBitrate(10)},
-            MAX_DURATION_US,
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(Format.NO_VALUE);
-  }
-
-  @Test
-  public void getBitratesUsingPastInfo_oneChunkFormatNoBitrate_returnsNoValue() {
-    Format format = createFormatWithBitrate(Format.NO_VALUE);
-    FakeMediaChunk chunk =
-        createChunk(format, /* length= */ 10, /* startTimeSec= */ 0, /* endTimeSec= */ 10);
-
-    int[] bitrates =
-        TrackSelectionUtil.getBitratesUsingPastInfo(
-            Collections.singletonList(chunk),
-            new Format[] {format},
-            MAX_DURATION_US,
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(Format.NO_VALUE);
-  }
-
-  @Test
-  public void getBitratesUsingPastInfo_oneChunkNoLength_returnsNoValue() {
-    Format format = createFormatWithBitrate(10);
-    FakeMediaChunk chunk =
-        createChunk(
-            format, /* length= */ C.LENGTH_UNSET, /* startTimeSec= */ 0, /* endTimeSec= */ 10);
-
-    int[] bitrates =
-        TrackSelectionUtil.getBitratesUsingPastInfo(
-            Collections.singletonList(chunk),
-            new Format[] {format},
-            MAX_DURATION_US,
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(Format.NO_VALUE);
-  }
-
-  @Test
-  public void getBitratesUsingPastInfo_oneChunkWithSameFormat_returnsBitrates() {
-    Format format = createFormatWithBitrate(10);
-    FakeMediaChunk chunk =
-        createChunk(format, /* length= */ 10, /* startTimeSec= */ 0, /* endTimeSec= */ 10);
-
-    int[] bitrates =
-        TrackSelectionUtil.getBitratesUsingPastInfo(
-            Collections.singletonList(chunk),
-            new Format[] {format},
-            MAX_DURATION_US,
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(8).inOrder();
-  }
-
-  @Test
-  public void getBitratesUsingPastInfo_zeroMaxDuration_returnsNoValue() {
-    Format format = createFormatWithBitrate(10);
-    FakeMediaChunk chunk =
-        createChunk(format, /* length= */ 10, /* startTimeSec= */ 0, /* endTimeSec= */ 10);
-
-    int[] bitrates =
-        TrackSelectionUtil.getBitratesUsingPastInfo(
-            Collections.singletonList(chunk),
-            new Format[] {format},
-            /* maxDurationUs= */ 0,
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(Format.NO_VALUE).inOrder();
-  }
-
-  @Test
-  public void getBitratesUsingPastInfo_multipleChunkWithSameFormat_returnsAverageBitrate() {
-    Format format = createFormatWithBitrate(10);
-    FakeMediaChunk chunk =
-        createChunk(format, /* length= */ 10, /* startTimeSec= */ 0, /* endTimeSec= */ 10);
-    FakeMediaChunk chunk2 =
-        createChunk(format, /* length= */ 20, /* startTimeSec= */ 10, /* endTimeSec= */ 20);
-
-    int[] bitrates =
-        TrackSelectionUtil.getBitratesUsingPastInfo(
-            Arrays.asList(chunk, chunk2),
-            new Format[] {format},
-            MAX_DURATION_US,
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(12).inOrder();
-  }
-
-  @Test
-  public void getBitratesUsingPastInfo_oneChunkWithDifferentFormat_returnsEstimationBitrate() {
-    FakeMediaChunk chunk =
-        createChunk(
-            createFormatWithBitrate(10),
-            /* length= */ 10,
-            /* startTimeSec= */ 0,
-            /* endTimeSec= */ 10);
-
-    int[] bitrates =
-        TrackSelectionUtil.getBitratesUsingPastInfo(
-            Collections.singletonList(chunk),
-            new Format[] {createFormatWithBitrate(20)},
-            MAX_DURATION_US,
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(16).inOrder();
-  }
-
-  @Test
-  public void getBitratesUsingPastInfo_trackFormatNoBitrate_returnsNoValue() {
-    FakeMediaChunk chunk =
-        createChunk(
-            createFormatWithBitrate(10),
-            /* length= */ 10,
-            /* startTimeSec= */ 0,
-            /* endTimeSec= */ 10);
-
-    int[] bitrates =
-        TrackSelectionUtil.getBitratesUsingPastInfo(
-            Collections.singletonList(chunk),
-            new Format[] {createFormatWithBitrate(Format.NO_VALUE)},
-            MAX_DURATION_US,
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(Format.NO_VALUE);
-  }
-
-  @Test
-  public void getBitratesUsingPastInfo_multipleTracks_returnsBitrates() {
-    FakeMediaChunk chunk =
-        createChunk(
-            createFormatWithBitrate(10),
-            /* length= */ 10,
-            /* startTimeSec= */ 0,
-            /* endTimeSec= */ 10);
-
-    int[] bitrates =
-        TrackSelectionUtil.getBitratesUsingPastInfo(
-            Collections.singletonList(chunk),
-            new Format[] {createFormatWithBitrate(20), createFormatWithBitrate(30)},
-            MAX_DURATION_US,
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(16, 24).inOrder();
-  }
-
-  @Test
-  public void getBitratesUsingPastInfo_bitratesArrayGiven_returnsTheSameArray() {
-    FakeMediaChunk chunk =
-        createChunk(
-            createFormatWithBitrate(10),
-            /* length= */ 10,
-            /* startTimeSec= */ 0,
-            /* endTimeSec= */ 10);
-
-    int[] bitratesArrayToUse = new int[2];
-    int[] bitrates =
-        TrackSelectionUtil.getBitratesUsingPastInfo(
-            Collections.singletonList(chunk),
-            new Format[] {createFormatWithBitrate(20), createFormatWithBitrate(30)},
-            MAX_DURATION_US,
-            bitratesArrayToUse);
-
-    assertThat(bitrates).isSameInstanceAs(bitratesArrayToUse);
-  }
-
-  @Test
-  public void
-      getBitratesUsingPastInfo_multipleChunkExceedingMaxDuration_returnsAverageUntilMaxDuration() {
-    Format format = createFormatWithBitrate(10);
-    FakeMediaChunk chunk =
-        createChunk(format, /* length= */ 10, /* startTimeSec= */ 0, /* endTimeSec= */ 20);
-    FakeMediaChunk chunk2 =
-        createChunk(format, /* length= */ 40, /* startTimeSec= */ 20, /* endTimeSec= */ 40);
-
-    int[] bitrates =
-        TrackSelectionUtil.getBitratesUsingPastInfo(
-            Arrays.asList(chunk, chunk2),
-            new Format[] {format},
-            /* maxDurationUs= */ 30 * C.MICROS_PER_SECOND,
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(12).inOrder();
-  }
-
-  @Test
-  public void
-      getBitratesUsingPastInfo_chunksWithDifferentFormats_returnsChunkAverageBitrateForLastFormat() {
-    FakeMediaChunk chunk =
-        createChunk(
-            createFormatWithBitrate(10),
-            /* length= */ 10,
-            /* startTimeSec= */ 0,
-            /* endTimeSec= */ 10);
-    FakeMediaChunk chunk2 =
-        createChunk(
-            createFormatWithBitrate(20),
-            /* length= */ 40,
-            /* startTimeSec= */ 10,
-            /* endTimeSec= */ 20);
-
-    int[] bitrates =
-        TrackSelectionUtil.getBitratesUsingPastInfo(
-            Arrays.asList(chunk, chunk2),
-            new Format[] {createFormatWithBitrate(10)},
-            MAX_DURATION_US,
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(16).inOrder();
-  }
-
-  @Test
-  public void getBitratesUsingPastAndFutureInfo_noPastInfo_returnsBitratesUsingOnlyFutureInfo() {
-    FakeMediaChunkIterator iterator1 =
-        new FakeMediaChunkIterator(
-            /* chunkTimeBoundariesSec= */ new long[] {0, 10}, /* chunkLengths= */ new long[] {10});
-    FakeMediaChunkIterator iterator2 =
-        new FakeMediaChunkIterator(
-            /* chunkTimeBoundariesSec= */ new long[] {0, 5, 15, 30},
-            /* chunkLengths= */ new long[] {10, 20, 30});
-
-    int[] bitrates =
-        TrackSelectionUtil.getBitratesUsingPastAndFutureInfo(
-            new Format[] {createFormatWithBitrate(10), createFormatWithBitrate(20)},
-            Collections.emptyList(),
-            MAX_DURATION_US,
-            new MediaChunkIterator[] {iterator1, iterator2},
-            MAX_DURATION_US,
-            /* useFormatBitrateAsLowerBound= */ false,
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(8, 16).inOrder();
-  }
-
-  @Test
-  public void getBitratesUsingPastAndFutureInfo_noFutureInfo_returnsBitratesUsingOnlyPastInfo() {
-    FakeMediaChunk chunk =
-        createChunk(
-            createFormatWithBitrate(10),
-            /* length= */ 10,
-            /* startTimeSec= */ 0,
-            /* endTimeSec= */ 10);
-
-    int[] bitrates =
-        TrackSelectionUtil.getBitratesUsingPastAndFutureInfo(
-            new Format[] {createFormatWithBitrate(20), createFormatWithBitrate(30)},
-            Collections.singletonList(chunk),
-            MAX_DURATION_US,
-            new MediaChunkIterator[] {MediaChunkIterator.EMPTY, MediaChunkIterator.EMPTY},
-            MAX_DURATION_US,
-            /* useFormatBitrateAsLowerBound= */ false,
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(16, 24).inOrder();
-  }
-
-  @Test
-  public void
-      getBitratesUsingPastAndFutureInfo_pastAndFutureInfo_returnsBitratesUsingOnlyFutureInfo() {
-    FakeMediaChunk chunk =
-        createChunk(
-            createFormatWithBitrate(5),
-            /* length= */ 10,
-            /* startTimeSec= */ 0,
-            /* endTimeSec= */ 10);
-    FakeMediaChunkIterator iterator1 =
-        new FakeMediaChunkIterator(
-            /* chunkTimeBoundariesSec= */ new long[] {0, 10}, /* chunkLengths= */ new long[] {10});
-    FakeMediaChunkIterator iterator2 =
-        new FakeMediaChunkIterator(
-            /* chunkTimeBoundariesSec= */ new long[] {0, 5, 15, 30},
-            /* chunkLengths= */ new long[] {10, 20, 30});
-
-    int[] bitrates =
-        TrackSelectionUtil.getBitratesUsingPastAndFutureInfo(
-            new Format[] {createFormatWithBitrate(10), createFormatWithBitrate(20)},
-            Collections.singletonList(chunk),
-            MAX_DURATION_US,
-            new MediaChunkIterator[] {iterator1, iterator2},
-            MAX_DURATION_US,
-            /* useFormatBitrateAsLowerBound= */ false,
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(8, 16).inOrder();
-  }
-
-  @Test
-  public void getBitratesUsingPastAndFutureInfo_noPastAndFutureInfo_returnsBitratesOfFormats() {
-    int[] bitrates =
-        TrackSelectionUtil.getBitratesUsingPastAndFutureInfo(
-            new Format[] {createFormatWithBitrate(10), createFormatWithBitrate(20)},
-            Collections.emptyList(),
-            MAX_DURATION_US,
-            new MediaChunkIterator[] {MediaChunkIterator.EMPTY, MediaChunkIterator.EMPTY},
-            MAX_DURATION_US,
-            /* useFormatBitrateAsLowerBound= */ false,
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(10, 20).inOrder();
-  }
-
-  @Test
-  public void
-      getBitratesUsingPastAndFutureInfo_estimatesLowerAndUseFormatBitrateAsLowerBoundTrue_returnsBitratesOfFormats() {
-    FakeMediaChunk chunk =
-        createChunk(
-            createFormatWithBitrate(10),
-            /* length= */ 10,
-            /* startTimeSec= */ 0,
-            /* endTimeSec= */ 10);
-
-    int[] bitrates =
-        TrackSelectionUtil.getBitratesUsingPastAndFutureInfo(
-            new Format[] {createFormatWithBitrate(20), createFormatWithBitrate(30)},
-            Collections.singletonList(chunk),
-            MAX_DURATION_US,
-            new MediaChunkIterator[] {MediaChunkIterator.EMPTY, MediaChunkIterator.EMPTY},
-            MAX_DURATION_US,
-            /* useFormatBitrateAsLowerBound= */ true,
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(20, 30).inOrder();
-  }
-
-  private static FakeMediaChunk createChunk(
-      Format format, int length, int startTimeSec, int endTimeSec) {
-    DataSpec dataSpec =
-        new DataSpec(
-            Uri.EMPTY, /* absoluteStreamPosition= */ 0, length, /* key= */ null, /* flags= */ 0);
-    return new FakeMediaChunk(
-        dataSpec, format, startTimeSec * C.MICROS_PER_SECOND, endTimeSec * C.MICROS_PER_SECOND);
-  }
-
-  private static Format createFormatWithBitrate(int bitrate) {
-    return Format.createSampleFormat(
-        /* id= */ null,
-        /* sampleMimeType= */ null,
-        /* codecs= */ null,
-        bitrate,
-        /* drmInitData= */ null);
-  }
-}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/WindowedTrackBitrateEstimatorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/WindowedTrackBitrateEstimatorTest.java
deleted file mode 100644
index d40149baae..0000000000
--- a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/WindowedTrackBitrateEstimatorTest.java
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * Copyright (C) 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.android.exoplayer2.trackselection;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import android.net.Uri;
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.source.chunk.MediaChunk;
-import com.google.android.exoplayer2.source.chunk.MediaChunkIterator;
-import com.google.android.exoplayer2.testutil.FakeMediaChunk;
-import com.google.android.exoplayer2.testutil.FakeMediaChunkIterator;
-import com.google.android.exoplayer2.upstream.DataSpec;
-import java.util.Collections;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-/** {@link WindowedTrackBitrateEstimator} tests. */
-@RunWith(AndroidJUnit4.class)
-public class WindowedTrackBitrateEstimatorTest {
-
-  private static final long MAX_DURATION_MS = 30_000;
-
-  @Test
-  public void getBitrates_zeroMaxDuration_returnsFormatBitrates() {
-    WindowedTrackBitrateEstimator estimator =
-        new WindowedTrackBitrateEstimator(
-            /* maxPastDurationMs= */ 0,
-            /* maxFutureDurationMs= */ 0,
-            /* useFormatBitrateAsLowerBound= */ false);
-    MediaChunk chunk = createMediaChunk(/* formatBitrate= */ 5, /* actualBitrate= */ 10);
-    MediaChunkIterator iterator1 = createMediaChunkIteratorWithBitrate(8);
-    MediaChunkIterator iterator2 = createMediaChunkIteratorWithBitrate(16);
-    Format format1 = createFormatWithBitrate(10);
-    Format format2 = createFormatWithBitrate(20);
-
-    int[] bitrates =
-        estimator.getBitrates(
-            new Format[] {format1, format2},
-            Collections.singletonList(chunk),
-            new MediaChunkIterator[] {iterator1, iterator2},
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(10, 20).inOrder();
-  }
-
-  @Test
-  public void getBitrates_futureMaxDurationSet_returnsEstimateUsingFutureChunks() {
-    WindowedTrackBitrateEstimator estimator =
-        new WindowedTrackBitrateEstimator(
-            /* maxPastDurationMs= */ 0, MAX_DURATION_MS, /* useFormatBitrateAsLowerBound= */ false);
-    MediaChunk chunk = createMediaChunk(/* formatBitrate= */ 5, /* actualBitrate= */ 10);
-    MediaChunkIterator iterator1 = createMediaChunkIteratorWithBitrate(8);
-    MediaChunkIterator iterator2 = createMediaChunkIteratorWithBitrate(16);
-    Format format1 = createFormatWithBitrate(10);
-    Format format2 = createFormatWithBitrate(20);
-
-    int[] bitrates =
-        estimator.getBitrates(
-            new Format[] {format1, format2},
-            Collections.singletonList(chunk),
-            new MediaChunkIterator[] {iterator1, iterator2},
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(8, 16).inOrder();
-  }
-
-  @Test
-  public void getBitrates_pastMaxDurationSet_returnsEstimateUsingPastChunks() {
-    WindowedTrackBitrateEstimator estimator =
-        new WindowedTrackBitrateEstimator(
-            MAX_DURATION_MS,
-            /* maxFutureDurationMs= */ 0,
-            /* useFormatBitrateAsLowerBound= */ false);
-    MediaChunk chunk = createMediaChunk(/* formatBitrate= */ 5, /* actualBitrate= */ 10);
-    MediaChunkIterator iterator1 = createMediaChunkIteratorWithBitrate(8);
-    MediaChunkIterator iterator2 = createMediaChunkIteratorWithBitrate(16);
-    Format format1 = createFormatWithBitrate(10);
-    Format format2 = createFormatWithBitrate(20);
-
-    int[] bitrates =
-        estimator.getBitrates(
-            new Format[] {format1, format2},
-            Collections.singletonList(chunk),
-            new MediaChunkIterator[] {iterator1, iterator2},
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(16, 32).inOrder();
-  }
-
-  @Test
-  public void
-      getBitrates_useFormatBitrateAsLowerBoundSetTrue_returnsEstimateIfOnlyHigherThanFormat() {
-    WindowedTrackBitrateEstimator estimator =
-        new WindowedTrackBitrateEstimator(
-            MAX_DURATION_MS, MAX_DURATION_MS, /* useFormatBitrateAsLowerBound= */ true);
-    MediaChunk chunk = createMediaChunk(/* formatBitrate= */ 5, /* actualBitrate= */ 10);
-    MediaChunkIterator iterator1 = createMediaChunkIteratorWithBitrate(80);
-    MediaChunkIterator iterator2 = createMediaChunkIteratorWithBitrate(16);
-    Format format1 = createFormatWithBitrate(10);
-    Format format2 = createFormatWithBitrate(20);
-
-    int[] bitrates =
-        estimator.getBitrates(
-            new Format[] {format1, format2},
-            Collections.singletonList(chunk),
-            new MediaChunkIterator[] {iterator1, iterator2},
-            /* bitrates= */ null);
-
-    assertThat(bitrates).asList().containsExactly(80, 20).inOrder();
-  }
-
-  @Test
-  public void getBitrates_bitratesArrayGiven_returnsTheSameArray() {
-    WindowedTrackBitrateEstimator estimator =
-        new WindowedTrackBitrateEstimator(
-            MAX_DURATION_MS, MAX_DURATION_MS, /* useFormatBitrateAsLowerBound= */ true);
-    MediaChunk chunk = createMediaChunk(/* formatBitrate= */ 5, /* actualBitrate= */ 10);
-    MediaChunkIterator iterator1 = createMediaChunkIteratorWithBitrate(8);
-    MediaChunkIterator iterator2 = createMediaChunkIteratorWithBitrate(16);
-    Format format1 = createFormatWithBitrate(10);
-    Format format2 = createFormatWithBitrate(20);
-
-    int[] bitratesArrayToUse = new int[2];
-    int[] bitrates =
-        estimator.getBitrates(
-            new Format[] {format1, format2},
-            Collections.singletonList(chunk),
-            new MediaChunkIterator[] {iterator1, iterator2},
-            bitratesArrayToUse);
-
-    assertThat(bitrates).isSameInstanceAs(bitratesArrayToUse);
-  }
-
-  private static MediaChunk createMediaChunk(int formatBitrate, int actualBitrate) {
-    int length = actualBitrate / C.BITS_PER_BYTE;
-    DataSpec dataSpec =
-        new DataSpec(
-            Uri.EMPTY, /* absoluteStreamPosition= */ 0, length, /* key= */ null, /* flags= */ 0);
-    Format format = createFormatWithBitrate(formatBitrate);
-    return new FakeMediaChunk(
-        dataSpec, format, /* startTimeUs= */ 0L, /* endTimeUs= */ C.MICROS_PER_SECOND);
-  }
-
-  private static Format createFormatWithBitrate(int bitrate) {
-    return Format.createSampleFormat(
-        /* id= */ null,
-        /* sampleMimeType= */ null,
-        /* codecs= */ null,
-        bitrate,
-        /* drmInitData= */ null);
-  }
-
-  private static MediaChunkIterator createMediaChunkIteratorWithBitrate(int bitrate) {
-    return new FakeMediaChunkIterator(
-        /* chunkTimeBoundariesSec= */ new long[] {0, 1},
-        /* chunkLengths= */ new long[] {bitrate / C.BITS_PER_BYTE});
-  }
-}
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/EventSampleStream.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/EventSampleStream.java
index f06a709960..6e67be6ec5 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/EventSampleStream.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/EventSampleStream.java
@@ -115,9 +115,9 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
     byte[] serializedEvent = eventMessageEncoder.encode(eventStream.events[sampleIndex]);
     if (serializedEvent != null) {
       buffer.ensureSpaceForWrite(serializedEvent.length);
-      buffer.setFlags(C.BUFFER_FLAG_KEY_FRAME);
       buffer.data.put(serializedEvent);
       buffer.timeUs = eventTimesUs[sampleIndex];
+      buffer.setFlags(C.BUFFER_FLAG_KEY_FRAME);
       return C.RESULT_BUFFER_READ;
     } else {
       return C.RESULT_NOTHING_READ;
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
index 8affcb27ce..9f6cce672e 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
@@ -596,6 +596,7 @@ protected Format buildFormat(
             containerMimeType,
             sampleMimeType,
             codecs,
+            /* metadata= */ null,
             bitrate,
             width,
             height,
@@ -610,6 +611,7 @@ protected Format buildFormat(
             containerMimeType,
             sampleMimeType,
             codecs,
+            /* metadata= */ null,
             bitrate,
             audioChannels,
             audioSamplingRate,
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashUtilTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashUtilTest.java
index a53b1ff80d..6e769b72e1 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashUtilTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashUtilTest.java
@@ -80,6 +80,7 @@ private static Representation newRepresentations(DrmInitData drmInitData) {
             MimeTypes.VIDEO_MP4,
             MimeTypes.VIDEO_H264,
             /* codecs= */ "",
+            /* metadata= */ null,
             Format.NO_VALUE,
             /* width= */ 1024,
             /* height= */ 768,
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
index 8053958c2b..ad2a3ad265 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
@@ -25,6 +25,7 @@
 import com.google.android.exoplayer2.drm.DrmSession;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.offline.StreamKey;
 import com.google.android.exoplayer2.source.CompositeSequenceableLoaderFactory;
 import com.google.android.exoplayer2.source.MediaPeriod;
@@ -787,6 +788,7 @@ private static Format deriveVideoFormat(Format variantFormat) {
         variantFormat.containerMimeType,
         sampleMimeType,
         codecs,
+        variantFormat.metadata,
         variantFormat.bitrate,
         variantFormat.width,
         variantFormat.height,
@@ -799,6 +801,7 @@ private static Format deriveVideoFormat(Format variantFormat) {
   private static Format deriveAudioFormat(
       Format variantFormat, Format mediaTagFormat, boolean isPrimaryTrackInVariant) {
     String codecs;
+    Metadata metadata;
     int channelCount = Format.NO_VALUE;
     int selectionFlags = 0;
     int roleFlags = 0;
@@ -806,6 +809,7 @@ private static Format deriveAudioFormat(
     String label = null;
     if (mediaTagFormat != null) {
       codecs = mediaTagFormat.codecs;
+      metadata = mediaTagFormat.metadata;
       channelCount = mediaTagFormat.channelCount;
       selectionFlags = mediaTagFormat.selectionFlags;
       roleFlags = mediaTagFormat.roleFlags;
@@ -813,6 +817,7 @@ private static Format deriveAudioFormat(
       label = mediaTagFormat.label;
     } else {
       codecs = Util.getCodecsOfType(variantFormat.codecs, C.TRACK_TYPE_AUDIO);
+      metadata = variantFormat.metadata;
       if (isPrimaryTrackInVariant) {
         channelCount = variantFormat.channelCount;
         selectionFlags = variantFormat.selectionFlags;
@@ -829,6 +834,7 @@ private static Format deriveAudioFormat(
         variantFormat.containerMimeType,
         sampleMimeType,
         codecs,
+        metadata,
         bitrate,
         channelCount,
         /* sampleRate= */ Format.NO_VALUE,
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
index 42b27f259f..030520f8cb 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
@@ -349,6 +349,7 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
                 /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
                 /* sampleMimeType= */ null,
                 codecs,
+                /* metadata= */ null,
                 bitrate,
                 width,
                 height,
@@ -422,6 +423,7 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
                       /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
                       sampleMimeType,
                       codecs,
+                      /* metadata= */ null,
                       /* bitrate= */ Format.NO_VALUE,
                       width,
                       height,
@@ -451,6 +453,7 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
                   /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
                   sampleMimeType,
                   codecs,
+                  /* metadata= */ null,
                   /* bitrate= */ Format.NO_VALUE,
                   channelCount,
                   /* sampleRate= */ Format.NO_VALUE,
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriodTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriodTest.java
index 93b8be3346..847e46591d 100644
--- a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriodTest.java
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriodTest.java
@@ -128,6 +128,7 @@ private static Variant createMuxedVideoAudioVariant(int bitrate) {
             /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
             /* sampleMimeType= */ null,
             /* codecs= */ "avc1.100.41,mp4a.40.2",
+            /* metadata= */ null,
             bitrate,
             /* width= */ Format.NO_VALUE,
             /* height= */ Format.NO_VALUE,
@@ -145,6 +146,7 @@ private static Variant createAudioOnlyVariant(int bitrate) {
             /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
             /* sampleMimeType= */ null,
             /* codecs= */ "mp4a.40.2",
+            /* metadata= */ null,
             bitrate,
             /* width= */ Format.NO_VALUE,
             /* height= */ Format.NO_VALUE,
@@ -177,6 +179,7 @@ private static Format createAudioFormat(String language) {
         /* containerMimeType= */ MimeTypes.APPLICATION_M3U8,
         MimeTypes.getMediaMimeType("mp4a.40.2"),
         /* codecs= */ "mp4a.40.2",
+        /* metadata= */ null,
         /* bitrate= */ Format.NO_VALUE,
         /* channelCount= */ Format.NO_VALUE,
         /* sampleRate= */ Format.NO_VALUE,
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
index 03e9e91e22..c08a867f37 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
@@ -681,6 +681,7 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
                 MimeTypes.VIDEO_MP4,
                 sampleMimeType,
                 /* codecs= */ null,
+                /* metadata= */ null,
                 bitrate,
                 width,
                 height,
@@ -706,6 +707,7 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
                 MimeTypes.AUDIO_MP4,
                 sampleMimeType,
                 /* codecs= */ null,
+                /* metadata= */ null,
                 bitrate,
                 channels,
                 samplingRate,
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java
index e452e391d5..0d966c9080 100644
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java
@@ -23,8 +23,6 @@
 import android.net.Uri;
 import android.view.Surface;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.DefaultLoadControl;
-import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.RendererCapabilities;
 import com.google.android.exoplayer2.SimpleExoPlayer;
@@ -259,10 +257,10 @@ protected DefaultTrackSelector buildTrackSelector(HostActivity host) {
     }
 
     @Override
-    protected DefaultDrmSessionManager<FrameworkMediaCrypto> buildDrmSessionManager(
+    protected DrmSessionManager<FrameworkMediaCrypto> buildDrmSessionManager(
         final String userAgent) {
       if (widevineLicenseUrl == null) {
-        return null;
+        return DrmSessionManager.getDummyDrmSessionManager();
       }
       try {
         MediaDrmCallback drmCallback = new HttpMediaDrmCallback(widevineLicenseUrl,
@@ -285,29 +283,25 @@ protected DefaultTrackSelector buildTrackSelector(HostActivity host) {
 
     @Override
     protected SimpleExoPlayer buildExoPlayer(
-        HostActivity host,
-        Surface surface,
-        MappingTrackSelector trackSelector,
-        DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
+        HostActivity host, Surface surface, MappingTrackSelector trackSelector) {
       SimpleExoPlayer player =
-          ExoPlayerFactory.newSimpleInstance(
-              host,
-              new DebugRenderersFactory(host),
-              trackSelector,
-              new DefaultLoadControl(),
-              drmSessionManager);
+          new SimpleExoPlayer.Builder(host, new DebugRenderersFactory(host))
+              .setTrackSelector(trackSelector)
+              .build();
       player.setVideoSurface(surface);
       return player;
     }
 
     @Override
-    protected MediaSource buildSource(HostActivity host, String userAgent) {
+    protected MediaSource buildSource(
+        HostActivity host, String userAgent, DrmSessionManager<?> drmSessionManager) {
       DataSource.Factory dataSourceFactory =
           this.dataSourceFactory != null
               ? this.dataSourceFactory
               : new DefaultDataSourceFactory(host, userAgent);
       Uri manifestUri = Uri.parse(manifestUrl);
       return new DashMediaSource.Factory(dataSourceFactory)
+          .setDrmSessionManager(drmSessionManager)
           .setLoadErrorHandlingPolicy(new DefaultLoadErrorHandlingPolicy(MIN_LOADABLE_RETRY_COUNT))
           .createMediaSource(manifestUri);
     }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoHostedTest.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoHostedTest.java
index 3ebd47b7a6..5f01d7724b 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoHostedTest.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoHostedTest.java
@@ -22,13 +22,10 @@
 import android.os.SystemClock;
 import android.view.Surface;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.DefaultLoadControl;
 import com.google.android.exoplayer2.DefaultRenderersFactory;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
-import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.Player;
-import com.google.android.exoplayer2.RenderersFactory;
 import com.google.android.exoplayer2.SimpleExoPlayer;
 import com.google.android.exoplayer2.analytics.AnalyticsListener;
 import com.google.android.exoplayer2.audio.DefaultAudioSink;
@@ -133,8 +130,7 @@ public final void onStart(HostActivity host, Surface surface) {
     // Build the player.
     trackSelector = buildTrackSelector(host);
     String userAgent = "ExoPlayerPlaybackTests";
-    DrmSessionManager<FrameworkMediaCrypto> drmSessionManager = buildDrmSessionManager(userAgent);
-    player = buildExoPlayer(host, surface, trackSelector, drmSessionManager);
+    player = buildExoPlayer(host, surface, trackSelector);
     player.setPlayWhenReady(true);
     player.addAnalyticsListener(this);
     player.addAnalyticsListener(new EventLogger(trackSelector, tag));
@@ -144,7 +140,8 @@ public final void onStart(HostActivity host, Surface surface) {
       pendingSchedule.start(player, trackSelector, surface, actionHandler, /* callback= */ null);
       pendingSchedule = null;
     }
-    player.prepare(buildSource(host, Util.getUserAgent(host, userAgent)));
+    DrmSessionManager<FrameworkMediaCrypto> drmSessionManager = buildDrmSessionManager(userAgent);
+    player.prepare(buildSource(host, Util.getUserAgent(host, userAgent), drmSessionManager));
   }
 
   @Override
@@ -233,7 +230,7 @@ private boolean stopTest() {
 
   protected DrmSessionManager<FrameworkMediaCrypto> buildDrmSessionManager(String userAgent) {
     // Do nothing. Interested subclasses may override.
-    return null;
+    return DrmSessionManager.getDummyDrmSessionManager();
   }
 
   protected DefaultTrackSelector buildTrackSelector(HostActivity host) {
@@ -241,23 +238,20 @@ protected DefaultTrackSelector buildTrackSelector(HostActivity host) {
   }
 
   protected SimpleExoPlayer buildExoPlayer(
-      HostActivity host,
-      Surface surface,
-      MappingTrackSelector trackSelector,
-      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
-    RenderersFactory renderersFactory =
-        new DefaultRenderersFactory(
-            host,
-            DefaultRenderersFactory.EXTENSION_RENDERER_MODE_OFF,
-            /* allowedVideoJoiningTimeMs= */ 0);
+      HostActivity host, Surface surface, MappingTrackSelector trackSelector) {
+    DefaultRenderersFactory renderersFactory = new DefaultRenderersFactory(host);
+    renderersFactory.setExtensionRendererMode(DefaultRenderersFactory.EXTENSION_RENDERER_MODE_OFF);
+    renderersFactory.setAllowedVideoJoiningTimeMs(/* allowedVideoJoiningTimeMs= */ 0);
     SimpleExoPlayer player =
-        ExoPlayerFactory.newSimpleInstance(
-            host, renderersFactory, trackSelector, new DefaultLoadControl(), drmSessionManager);
+        new SimpleExoPlayer.Builder(host, renderersFactory)
+            .setTrackSelector(trackSelector)
+            .build();
     player.setVideoSurface(surface);
     return player;
   }
 
-  protected abstract MediaSource buildSource(HostActivity host, String userAgent);
+  protected abstract MediaSource buildSource(
+      HostActivity host, String userAgent, DrmSessionManager<?> drmSessionManager);
 
   protected void onPlayerErrorInternal(ExoPlaybackException error) {
     // Do nothing. Interested subclasses may override.
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSampleStream.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSampleStream.java
index 02d0e372e8..8b05b27046 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSampleStream.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSampleStream.java
@@ -32,6 +32,7 @@
 
   private final Format format;
   @Nullable private final EventDispatcher eventDispatcher;
+  private final byte[] sampleData;
 
   private boolean notifiedDownstreamFormat;
   private boolean readFormat;
@@ -47,9 +48,23 @@
    */
   public FakeSampleStream(
       Format format, @Nullable EventDispatcher eventDispatcher, boolean shouldOutputSample) {
+    this(format, eventDispatcher, new byte[] {0});
+    readSample = !shouldOutputSample;
+  }
+
+  /**
+   * Creates fake sample stream which outputs the given {@link Format}, one sample with the provided
+   * bytes, then end of stream.
+   *
+   * @param format The {@link Format} to output.
+   * @param eventDispatcher An {@link EventDispatcher} to notify of read events.
+   * @param sampleData The sample data to output.
+   */
+  public FakeSampleStream(
+      Format format, @Nullable EventDispatcher eventDispatcher, byte[] sampleData) {
     this.format = format;
     this.eventDispatcher = eventDispatcher;
-    readSample = !shouldOutputSample;
+    this.sampleData = sampleData;
   }
 
   @Override
@@ -58,8 +73,8 @@ public boolean isReady() {
   }
 
   @Override
-  public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
-      boolean formatRequired) {
+  public int readData(
+      FormatHolder formatHolder, DecoderInputBuffer buffer, boolean formatRequired) {
     if (eventDispatcher != null && !notifiedDownstreamFormat) {
       eventDispatcher.downstreamFormatChanged(
           C.TRACK_TYPE_UNKNOWN,
@@ -75,9 +90,8 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
       return C.RESULT_FORMAT_READ;
     } else if (!readSample) {
       buffer.timeUs = 0;
-      buffer.ensureSpaceForWrite(1);
-      buffer.data.put((byte) 0);
-      buffer.flip();
+      buffer.ensureSpaceForWrite(sampleData.length);
+      buffer.data.put(sampleData);
       readSample = true;
       return C.RESULT_BUFFER_READ;
     } else {
@@ -95,5 +109,4 @@ public void maybeThrowError() throws IOException {
   public int skipData(long positionUs) {
     return 0;
   }
-
 }
