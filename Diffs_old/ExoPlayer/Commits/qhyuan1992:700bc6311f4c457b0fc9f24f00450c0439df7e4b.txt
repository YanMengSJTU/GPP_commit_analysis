diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java b/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
index 125e78983b..14696681ab 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
@@ -226,7 +226,7 @@ public Sample(String name, String contentId, String provider, String uri, int ty
   };
 
   public static final Sample[] MISC = new Sample[] {
-    new Sample("Dizzy", "http://html5demos.com/assets/dizzy.mp4", Util.TYPE_OTHER),
+    new Sample("Dizzy", "https://media.w3.org/2010/05/sintel/trailer.mp4", Util.TYPE_OTHER),
     new Sample("Apple AAC 10s", "https://devimages.apple.com.edgekey.net/"
         + "streaming/examples/bipbop_4x3/gear0/fileSequence0.aac", Util.TYPE_OTHER),
     new Sample("Apple TS 10s", "https://devimages.apple.com.edgekey.net/streaming/examples/"
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java b/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java
index 8065d6a6f0..f13bf07140 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java
@@ -35,10 +35,10 @@
   private static final int INITIAL_SCRATCH_SIZE = 32;
 
   private final Allocator allocator;
-  private final int allocationLength;
+  private final int allocationLength; // 每个Allocation的最大字节数
 
-  private final InfoQueue infoQueue;
-  private final LinkedBlockingDeque<Allocation> dataQueue;
+  private final InfoQueue infoQueue; // 维护所有的sample的信息 里面用数组承载所有的sample
+  private final LinkedBlockingDeque<Allocation> dataQueue; // 队列包含所有的sample
   private final SampleExtrasHolder extrasHolder;
   private final ParsableByteArray scratch;
 
@@ -47,7 +47,7 @@
 
   // Accessed only by the loading thread.
   private long totalBytesWritten;
-  private Allocation lastAllocation;
+  private Allocation lastAllocation; // 最后一个Allocation
   private int lastAllocationOffset;
 
   /**
@@ -434,9 +434,9 @@ public void commitSample(long sampleTimeUs, int flags, long position, int size,
    * number of bytes that can actually be appended.
    */
   private int prepareForAppend(int length) {
-    if (lastAllocationOffset == allocationLength) {
+    if (lastAllocationOffset == allocationLength) { // 分配的Allocation已经全部填满，也可能是初次走到这儿
       lastAllocationOffset = 0;
-      lastAllocation = allocator.allocate();
+      lastAllocation = allocator.allocate(); // 重新分配一个
       dataQueue.add(lastAllocation);
     }
     return Math.min(length, allocationLength - lastAllocationOffset);
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
index 5df22494bf..0d13b40257 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
@@ -359,36 +359,38 @@ private int readSample(ExtractorInput input, PositionHolder positionHolder)
     }
     Mp4Track track = tracks[trackIndex];
     TrackOutput trackOutput = track.trackOutput;
-    int sampleIndex = track.sampleIndex;
-    long position = track.sampleTable.offsets[sampleIndex];
+    int sampleIndex = track.sampleIndex; // 当前解析到的sample的index
+    long position = track.sampleTable.offsets[sampleIndex]; // 这个sample在文件中的位置
     long skipAmount = position - input.getPosition() + sampleBytesWritten;
     if (skipAmount < 0 || skipAmount >= RELOAD_MINIMUM_SEEK_DISTANCE) {
       positionHolder.position = position;
       return RESULT_SEEK;
     }
-    input.skipFully((int) skipAmount);
-    sampleSize = track.sampleTable.sizes[sampleIndex];
-    if (track.track.nalUnitLengthFieldLength != -1) {
+    input.skipFully((int) skipAmount); //
+    sampleSize = track.sampleTable.sizes[sampleIndex]; // sample的大小
+    if (track.track.nalUnitLengthFieldLength != -1) { // h.264
       // Zero the top three bytes of the array that we'll use to parse nal unit lengths, in case
       // they're only 1 or 2 bytes long.
       byte[] nalLengthData = nalLength.data;
       nalLengthData[0] = 0;
       nalLengthData[1] = 0;
       nalLengthData[2] = 0;
-      int nalUnitLengthFieldLength = track.track.nalUnitLengthFieldLength;
+      int nalUnitLengthFieldLength = track.track.nalUnitLengthFieldLength; // h264的nalu的size用多少个字节表示
       int nalUnitLengthFieldLengthDiff = 4 - track.track.nalUnitLengthFieldLength;
       // NAL units are length delimited, but the decoder requires start code delimited units.
       // Loop until we've written the sample to the track output, replacing length delimiters with
       // start codes as we encounter them.
+      // 用0x00000001来分割nalu
+      // sample可能包含多个nalu，每多读一个nalu要多算一个nalu头(一般是4字节)
       while (sampleBytesWritten < sampleSize) {
-        if (sampleCurrentNalBytesRemaining == 0) {
+        if (sampleCurrentNalBytesRemaining == 0) { // 先读取nalu的长度到sampleCurrentNalBytesRemaining
           // Read the NAL length so that we know where we find the next one.
-          input.readFully(nalLength.data, nalUnitLengthFieldLengthDiff, nalUnitLengthFieldLength);
+          input.readFully(nalLength.data, nalUnitLengthFieldLengthDiff, nalUnitLengthFieldLength); // 读取nalu的长度
           nalLength.setPosition(0);
           sampleCurrentNalBytesRemaining = nalLength.readUnsignedIntToInt();
           // Write a start code for the current NAL unit.
           nalStartCode.setPosition(0);
-          trackOutput.sampleData(nalStartCode, 4);
+          trackOutput.sampleData(nalStartCode, 4); // 写入nalu头
           sampleBytesWritten += 4;
           sampleSize += nalUnitLengthFieldLengthDiff;
         } else {
@@ -426,7 +428,7 @@ private int getTrackIndexOfEarliestCurrentSample() {
       if (sampleIndex == track.sampleTable.sampleCount) {
         continue;
       }
-
+      // 找到当前正在解析的sample 的索引最小的那个track
       long trackSampleOffset = track.sampleTable.offsets[sampleIndex];
       if (trackSampleOffset < earliestSampleOffset) {
         earliestSampleOffset = trackSampleOffset;
@@ -463,7 +465,7 @@ private static boolean shouldParseContainerAtom(int atom) {
     public final TrackSampleTable sampleTable;
     public final TrackOutput trackOutput;
 
-    public int sampleIndex;
+    public int sampleIndex; // 当前解析的sample的索引
 
     public Mp4Track(Track track, TrackSampleTable sampleTable, TrackOutput trackOutput) {
       this.track = track;
