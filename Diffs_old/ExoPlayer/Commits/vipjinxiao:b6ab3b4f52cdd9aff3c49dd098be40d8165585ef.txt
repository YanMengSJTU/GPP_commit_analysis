diff --git a/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java b/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
index fe7015a942..9448126ba6 100644
--- a/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
+++ b/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
@@ -177,6 +177,7 @@ public boolean shouldStartPlayback(long bufferedDurationUs, boolean rebuffering)
   @Override
   public boolean shouldContinueLoading(long bufferedDurationUs) {
     int bufferTimeState = getBufferTimeState(bufferedDurationUs);
+    // targetBufferSize默认值为15.875MB
     boolean targetBufferSizeReached = allocator.getTotalBytesAllocated() >= targetBufferSize;
     boolean wasBuffering = isBuffering;
     isBuffering = bufferTimeState == BELOW_LOW_WATERMARK
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
index faf86087c9..57adb65e83 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
@@ -442,6 +442,14 @@ private void updatePlaybackPositions() throws ExoPlaybackException {
         : bufferedPositionUs;
   }
 
+  // 在prepared前(即playingPeriodHolder为空)仅更新period
+  // 在prepared后，除了更新period进度外，步骤为：
+  //    1. 更新playbackPosition
+  //    2. renderer.render()
+  //    3. 检查已在播放的是否进入STATE_END状态
+  //    4. 检查BUFFERING状态的是否进入READY状态
+  //    5. 检查READY状态的是否进入BUFFERING状态
+  //    6. 根据相应状态scheduleNextWork
   private void doSomeWork() throws ExoPlaybackException, IOException {
     long operationStartTimeMs = SystemClock.elapsedRealtime();
     updatePeriods();
@@ -1091,6 +1099,7 @@ private int resolveSubsequentPeriod(int oldPeriodIndex, Timeline oldTimeline,
     return Pair.create(periodIndex, periodPositionUs);
   }
 
+  // 每次doSomeWork都会调用，对于SinglePeriodTimeline来说主要是更新LoadingPeriod，包括触发以及跟踪其loading状态
   private void updatePeriods() throws ExoPlaybackException, IOException {
     if (timeline == null) {
       // We're waiting to get information about periods.
@@ -1187,6 +1196,7 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
     }
   }
 
+  // 对于SinglePeriodTimeline来说，仅会调用一次，即初始构建LoadingPeriod
   private void maybeUpdateLoadingPeriod() throws IOException {
     int newLoadingPeriodIndex;
     if (loadingPeriodHolder == null) {
@@ -1261,6 +1271,10 @@ private void maybeUpdateLoadingPeriod() throws IOException {
     setIsLoading(true);
   }
 
+  // 1. 用TrackSelector完成trackSelect，同时将track的sampleStream设置为ExtractorMediaPeriod提供的SampleStreamImpl，如果需要seek，使ExtractorMediaPeriod实现seek
+  // 2. 设置rendererPosition
+  // 3. 设置PlayingPeriodHolder，从此可以在doSomeWork()中走通完整流程
+  // 4. 调用maybeContinueLoading()，因为之前在ExtractorMediaPeriod的maybeFinishPrepare()中loadCondition已经close了，另外也可能因为seek需要重启load
   private void handlePeriodPrepared(MediaPeriod period) throws ExoPlaybackException {
     if (loadingPeriodHolder == null || loadingPeriodHolder.mediaPeriod != period) {
       // Stale event.
@@ -1284,6 +1298,7 @@ private void handleContinueLoadingRequested(MediaPeriod period) {
     maybeContinueLoading();
   }
 
+  // 根据ExtractorMediaPeriod的nextLoadPosition减去当前的loadingPeriodPositionUs得到bufferedDurationUs，然后通过LoadControl的shouldContinueLoading()方法确定是否需要continueLoading
   private void maybeContinueLoading() {
     long nextLoadPositionUs = !loadingPeriodHolder.prepared ? 0
         : loadingPeriodHolder.mediaPeriod.getNextLoadPositionUs();
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
index 5226043593..22058b2c58 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
@@ -175,6 +175,8 @@ public TrackGroupArray getTrackGroups() {
     return tracks;
   }
 
+  // ExoPlayerImplInternal中使用TrackSelector选择好track后调用，将每个track对应的SampleStream赋值为自身实现的SampleStreamImpl
+  // 另外，此处作为prepared之后的第一处调用，如果positionUs不为0，在此处调用seekToUs()实现seek操作
   @Override
   public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
       SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
@@ -286,6 +288,8 @@ public long getBufferedPositionUs() {
         : largestQueuedTimestampUs;
   }
 
+  // 可能被selectTracks()或是ExoPlayerImplInternal的seekToPeriodPosition()方法直接调用
+  // 先尝试在sampleQueues中直接seek，如果未在sampleQueues中seek，则会cancel掉当前的load任务，然后设置其pendingResetPositionUs，走continueLoad()的路子
   @Override
   public long seekToUs(long positionUs) {
     // Treat all seeks into non-seekable media as being to t=0.
@@ -411,7 +415,7 @@ public void onUpstreamFormatChanged(Format format) {
   }
 
   // Internal methods.
-
+  // 经Extractor调用track()、endTracks()、seekMap()、TrackOutput.format()->onUpstreamFormatChanged()后到达
   private void maybeFinishPrepare() {
     if (released || prepared || seekMap == null || !tracksBuilt) {
       return;
@@ -422,6 +426,7 @@ private void maybeFinishPrepare() {
         return;
       }
     }
+    // 完成prepare时先close，等待continueLoading
     loadCondition.close();
     TrackGroup[] trackArray = new TrackGroup[trackCount];
     trackIsAudioVideoFlags = new boolean[trackCount];
@@ -448,6 +453,8 @@ private void copyLengthFromLoader(ExtractingLoadable loadable) {
     }
   }
 
+  // prepare()与continueLoading()均会调用，每次均会new新的ExtractingLoadable
+  // 如果是之前调用过seekToUs()与continueLoading()的情况，会对ExtractingLoadable的loadPosition进行set
   private void startLoading() {
     ExtractingLoadable loadable = new ExtractingLoadable(uri, dataSource, extractorHolder,
         loadCondition);
@@ -616,6 +623,7 @@ public boolean isLoadCanceled() {
     @Override
     public void load() throws IOException, InterruptedException {
       int result = Extractor.RESULT_CONTINUE;
+      // 里层while循环可能SEEK转CONTINUE
       while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
         ExtractorInput input = null;
         try {
@@ -635,6 +643,7 @@ public void load() throws IOException, InterruptedException {
             result = extractor.read(input, positionHolder);
             if (input.getPosition() > position + CONTINUE_LOADING_CHECK_INTERVAL_BYTES) {
               position = input.getPosition();
+              // 每load 1M数据，先close，等待continueLoading，因为LoadControl判断暂时不需要continueLoading
               loadCondition.close();
               handler.post(onContinueLoadingRequestedRunnable);
             }
