diff --git a/build.gradle b/build.gradle
old mode 100644
new mode 100755
index 3813a241e0..828cc318bf
--- a/build.gradle
+++ b/build.gradle
@@ -13,11 +13,11 @@
 // limitations under the License.
 buildscript {
     repositories {
-        jcenter()
         google()
+        jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.1.0'
+        classpath 'com.android.tools.build:gradle:3.1.4'
         classpath 'com.novoda:bintray-release:0.8.1'
     }
     // Workaround for the following test coverage issue. Remove when fixed:
@@ -31,8 +31,8 @@ buildscript {
 }
 allprojects {
     repositories {
-        jcenter()
         google()
+        jcenter()
     }
     project.ext {
         exoplayerPublishEnabled = true
diff --git a/demos/cast/build.gradle b/demos/cast/build.gradle
old mode 100644
new mode 100755
index ae6bdd1d94..d12da2cc99
--- a/demos/cast/build.gradle
+++ b/demos/cast/build.gradle
@@ -44,6 +44,16 @@ android {
         disable 'MissingTranslation'
     }
 
+    flavorDimensions "extensions"
+
+    productFlavors {
+        noExtensions {
+            dimension "extensions"
+        }
+        withExtensions {
+            dimension "extensions"
+        }
+    }
 }
 
 dependencies {
@@ -56,4 +66,13 @@ dependencies {
     implementation 'com.android.support:support-v4:' + supportLibraryVersion
     implementation 'com.android.support:appcompat-v7:' + supportLibraryVersion
     implementation 'com.android.support:recyclerview-v7:' + supportLibraryVersion
+    withExtensionsImplementation project(path: modulePrefix + 'extension-ffmpeg')
+    withExtensionsImplementation project(path: modulePrefix + 'extension-mpegh')
+    withExtensionsImplementation project(path: modulePrefix + 'extension-flac')
+    withExtensionsImplementation project(path: modulePrefix + 'extension-ima')
+    withExtensionsImplementation project(path: modulePrefix + 'extension-opus')
+    withExtensionsImplementation project(path: modulePrefix + 'extension-vp9')
+    withExtensionsImplementation project(path: modulePrefix + 'extension-rtmp')
+    implementation project(path: ':extension-ffmpeg')
+    implementation project(path: ':extension-mpegh')
 }
diff --git a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DemoUtil.java b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DemoUtil.java
old mode 100644
new mode 100755
index 26ab5eb0dd..147be33ce6
--- a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DemoUtil.java
+++ b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DemoUtil.java
@@ -77,6 +77,8 @@ public String toString() {
     ArrayList<Sample> samples = new ArrayList<>();
     samples.add(new Sample("https://storage.googleapis.com/wvmedia/clear/h264/tears/tears.mpd",
         "DASH (clear,MP4,H264)", MIME_TYPE_DASH));
+    samples.add(new Sample("http://192.168.53.226:8887/contents/We_Are_SxSW_LV1_20180416/We_Are_SxSW_LV1_20180416_dash.mpd",
+            "DASH (We Are SxSW,MP4,MPEG-H 3D)", MIME_TYPE_DASH));
     samples.add(new Sample("https://commondatastorage.googleapis.com/gtv-videos-bucket/CastVideos/"
         + "hls/TearsOfSteel.m3u8", "Tears of Steel (HLS)", MIME_TYPE_HLS));
     samples.add(new Sample("https://html5demos.com/assets/dizzy.mp4", "Dizzy (MP4)",
diff --git a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/PlayerManager.java b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/PlayerManager.java
old mode 100644
new mode 100755
index 63b18b0aa7..4f11652809
--- a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/PlayerManager.java
+++ b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/PlayerManager.java
@@ -120,7 +120,7 @@ private PlayerManager(
     concatenatingMediaSource = new ConcatenatingMediaSource();
 
     DefaultTrackSelector trackSelector = new DefaultTrackSelector(BANDWIDTH_METER);
-    RenderersFactory renderersFactory = new DefaultRenderersFactory(context);
+    RenderersFactory renderersFactory = new DefaultRenderersFactory(context, DefaultRenderersFactory.EXTENSION_RENDERER_MODE_ON);
     exoPlayer = ExoPlayerFactory.newSimpleInstance(renderersFactory, trackSelector);
     exoPlayer.addListener(this);
     localPlayerView.setPlayer(exoPlayer);
diff --git a/demos/main_ia/README.md b/demos/main_ia/README.md
new file mode 100755
index 0000000000..bdb04e5ba8
--- /dev/null
+++ b/demos/main_ia/README.md
@@ -0,0 +1,5 @@
+# ExoPlayer main demo #
+
+This is the main ExoPlayer demo application. It uses ExoPlayer to play a number
+of test streams. It can be used as a starting point or reference project when
+developing other applications that make use of the ExoPlayer library.
diff --git a/demos/main_ia/build.gradle b/demos/main_ia/build.gradle
new file mode 100755
index 0000000000..7dd88d65b2
--- /dev/null
+++ b/demos/main_ia/build.gradle
@@ -0,0 +1,82 @@
+// Copyright (C) 2016 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+apply from: '../../constants.gradle'
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion project.ext.compileSdkVersion
+    buildToolsVersion project.ext.buildToolsVersion
+
+    defaultConfig {
+        versionName project.ext.releaseVersion
+        versionCode project.ext.releaseVersionCode
+        minSdkVersion 16
+        targetSdkVersion project.ext.targetSdkVersion
+    }
+
+    buildTypes {
+        release {
+            shrinkResources true
+            minifyEnabled true
+            proguardFiles = [
+                "proguard-rules.txt",
+                getDefaultProguardFile('proguard-android.txt')
+            ]
+        }
+        debug {
+            jniDebuggable = true
+        }
+    }
+
+    lintOptions {
+        // The demo app does not have translations.
+        disable 'MissingTranslation'
+    }
+
+    flavorDimensions "extensions"
+
+    productFlavors {
+        noExtensions {
+            dimension "extensions"
+        }
+        withExtensions {
+            dimension "extensions"
+        }
+    }
+}
+
+dependencies {
+    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    implementation project(modulePrefix + 'library-core')
+    implementation project(modulePrefix + 'library-dash')
+    implementation project(modulePrefix + 'library-hls')
+    implementation project(modulePrefix + 'library-smoothstreaming')
+    implementation project(modulePrefix + 'library-ui')
+    withExtensionsImplementation project(path: modulePrefix + 'extension-ffmpeg')
+    withExtensionsImplementation project(path: modulePrefix + 'extension-mpegh')
+    withExtensionsImplementation project(path: modulePrefix + 'extension-flac')
+    withExtensionsImplementation project(path: modulePrefix + 'extension-ima')
+    withExtensionsImplementation project(path: modulePrefix + 'extension-opus')
+    withExtensionsImplementation project(path: modulePrefix + 'extension-vp9')
+    withExtensionsImplementation project(path: modulePrefix + 'extension-rtmp')
+    implementation project(path: ':extension-ffmpeg')
+    implementation project(path: ':extension-mpegh')
+
+    // SAL impl
+    implementation fileTree(dir: 'libs', include: ['*.aar'])
+    implementation 'com.android.support:appcompat-v7:27.1.1'
+    implementation 'org.jacoco:org.jacoco.agent:0.7.9:runtime'
+    implementation 'com.android.support.constraint:constraint-layout:1.1.3'
+    // implementation files('libs/siaserveraccess-0.2.0.jar')
+}
diff --git a/demos/main_ia/proguard-rules.txt b/demos/main_ia/proguard-rules.txt
new file mode 100755
index 0000000000..cd201892ab
--- /dev/null
+++ b/demos/main_ia/proguard-rules.txt
@@ -0,0 +1,7 @@
+# Proguard rules specific to the main demo app.
+
+# Constructor accessed via reflection in PlayerActivity
+-dontnote com.google.android.exoplayer2.ext.ima.ImaAdsLoader
+-keepclassmembers class com.google.android.exoplayer2.ext.ima.ImaAdsLoader {
+  <init>(android.content.Context, android.net.Uri);
+}
diff --git a/demos/main_ia/src/main/AndroidManifest.xml b/demos/main_ia/src/main/AndroidManifest.xml
new file mode 100755
index 0000000000..2afdb526ec
--- /dev/null
+++ b/demos/main_ia/src/main/AndroidManifest.xml
@@ -0,0 +1,107 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.google.android.exoplayer2.demo">
+
+  <uses-permission android:name="android.permission.INTERNET"/>
+  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
+  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
+  <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
+
+  <uses-permission android:name="android.permission.WAKE_LOCK" /> <!-- SAL impl : necessary permission -->
+  <uses-permission android:name="android.permission.BLUETOOTH" /> <!-- SAL impl : necessary permission -->
+
+
+  <uses-feature android:name="android.software.leanback" android:required="false"/>
+  <uses-feature android:name="android.hardware.touchscreen" android:required="false"/>
+  <uses-sdk/>
+
+  <!-- SAL impl: changed app name -->
+  <application
+      android:label="@string/application_name"
+      android:icon="@mipmap/ic_launcher"
+      android:banner="@drawable/ic_banner"
+      android:largeHeap="true"
+      android:allowBackup="false"
+      android:name="com.google.android.exoplayer2.demo.DemoApplication">
+
+    <activity android:name="com.google.android.exoplayer2.demo.SampleChooserActivity"
+        android:configChanges="keyboardHidden"
+        android:label="@string/application_name">  <!-- SAL impl: changed app name -->
+      <intent-filter>
+        <action android:name="android.intent.action.MAIN"/>
+        <category android:name="android.intent.category.LAUNCHER"/>
+        <category android:name="android.intent.category.LEANBACK_LAUNCHER"/>
+      </intent-filter>
+      <intent-filter>
+        <action android:name="android.intent.action.VIEW"/>
+        <category android:name="android.intent.category.DEFAULT"/>
+        <category android:name="android.intent.category.BROWSABLE"/>
+        <data android:scheme="http"/>
+        <data android:scheme="https"/>
+        <data android:scheme="content"/>
+        <data android:scheme="asset"/>
+        <data android:scheme="file"/>
+        <data android:host="*"/>
+        <data android:pathPattern=".*\\.exolist\\.json"/>
+        <!-- SAL impl: receive an intent from headphone connect -->
+        <data
+            android:host="immersive-audio.sony.com"
+            android:path="/start-optimize"
+            android:scheme="com.sony.ia.iaplayback.soiaplayer" />
+      </intent-filter>
+    </activity>
+
+    <activity android:name="com.google.android.exoplayer2.demo.PlayerActivity"
+        android:configChanges="keyboard|keyboardHidden|orientation|screenSize|screenLayout|smallestScreenSize|uiMode"
+        android:launchMode="singleTop"
+        android:label="@string/application_name"
+        android:theme="@style/PlayerTheme">
+      <intent-filter>
+        <action android:name="com.google.android.exoplayer.demo.action.VIEW"/>
+        <category android:name="android.intent.category.DEFAULT"/>
+        <data android:scheme="http"/>
+        <data android:scheme="https"/>
+        <data android:scheme="content"/>
+        <data android:scheme="asset"/>
+        <data android:scheme="file"/>
+      </intent-filter>
+      <intent-filter>
+        <action android:name="com.google.android.exoplayer.demo.action.VIEW_LIST"/>
+        <category android:name="android.intent.category.DEFAULT"/>
+      </intent-filter>
+    </activity>
+
+    <service android:name="com.google.android.exoplayer2.demo.DemoDownloadService"
+        android:exported="false">
+      <intent-filter>
+        <action android:name="com.google.android.exoplayer.downloadService.action.INIT"/>
+        <category android:name="android.intent.category.DEFAULT"/>
+      </intent-filter>
+    </service>
+
+    <service android:name="com.google.android.exoplayer2.scheduler.PlatformScheduler$PlatformSchedulerService"
+        android:permission="android.permission.BIND_JOB_SERVICE"
+        android:exported="true"/>
+    <!-- SAL impl : register the SAL service-->
+    <service
+        android:name="com.sony.immersive_audio.sal.SiaServerAccess"
+        android:enabled="true"
+        android:exported="false" />
+  </application>
+
+</manifest>
diff --git a/demos/main_ia/src/main/assets/brir2.riff b/demos/main_ia/src/main/assets/brir2.riff
new file mode 100755
index 0000000000..fab3da9784
Binary files /dev/null and b/demos/main_ia/src/main/assets/brir2.riff differ
diff --git a/demos/main_ia/src/main/assets/media.exolist.json b/demos/main_ia/src/main/assets/media.exolist.json
new file mode 100755
index 0000000000..aa23953541
--- /dev/null
+++ b/demos/main_ia/src/main/assets/media.exolist.json
@@ -0,0 +1,611 @@
+[
+  {
+    "name": "Mpeg-H 3D",
+    "samples": [
+      {
+        "name": "DASH - IATESTV2",
+        "uri": "http://192.168.11.154:8887/contents/dash/IATestV2_20180425.mpd",
+        "extension": "mpd"
+      },
+      {
+        "name": "wnoise_22_2ch_mprofile",
+        "uri": "http://192.168.11.154:8887/contents/mhas/wnoise_22_2ch_mprofile.mp4"
+      },
+      {
+        "name": "HighForMe",
+        "uri": "https://www.dropbox.com/s/lqst0z9gl5jipep/HighForMe_24.mp4?dl=1"
+      }
+    ]
+  },
+  {
+    "name": "YouTube DASH",
+    "samples": [
+      {
+        "name": "Google Glass (MP4,H264)",
+        "uri": "http://www.youtube.com/api/manifest/dash/id/bf5bb2419360daf1/source/youtube?as=fmp4_audio_clear,fmp4_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&ipbits=0&expire=19000000000&signature=51AF5F39AB0CEC3E5497CD9C900EBFEAECCCB5C7.8506521BFC350652163895D4C26DEE124209AA9E&key=ik0",
+        "extension": "mpd"
+      },
+      {
+        "name": "Google Play (MP4,H264)",
+        "uri": "http://www.youtube.com/api/manifest/dash/id/3aa39fa2cc27967f/source/youtube?as=fmp4_audio_clear,fmp4_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&ipbits=0&expire=19000000000&signature=A2716F75795F5D2AF0E88962FFCD10DB79384F29.84308FF04844498CE6FBCE4731507882B8307798&key=ik0",
+        "extension": "mpd"
+      },
+      {
+        "name": "Google Glass (WebM,VP9)",
+        "uri": "http://www.youtube.com/api/manifest/dash/id/bf5bb2419360daf1/source/youtube?as=fmp4_audio_clear,webm2_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&ipbits=0&expire=19000000000&signature=249B04F79E984D7F86B4D8DB48AE6FAF41C17AB3.7B9F0EC0505E1566E59B8E488E9419F253DDF413&key=ik0",
+        "extension": "mpd"
+      },
+      {
+        "name": "Google Play (WebM,VP9)",
+        "uri": "http://www.youtube.com/api/manifest/dash/id/3aa39fa2cc27967f/source/youtube?as=fmp4_audio_clear,webm2_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&ipbits=0&expire=19000000000&signature=B1C2A74783AC1CC4865EB312D7DD2D48230CC9FD.BD153B9882175F1F94BFE5141A5482313EA38E8D&key=ik0",
+        "extension": "mpd"
+      }
+    ]
+  },
+  {
+    "name": "Widevine DASH Policy Tests (GTS)",
+    "samples": [
+      {
+        "name": "WV: HDCP not specified",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?video_id=d286538032258a1c&provider=widevine_test"
+      },
+      {
+        "name": "WV: HDCP not required",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?video_id=48fcc369939ac96c&provider=widevine_test"
+      },
+      {
+        "name": "WV: HDCP required",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?video_id=e06c39f1151da3df&provider=widevine_test"
+      },
+      {
+        "name": "WV: Secure video path required (MP4,H264)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?video_id=0894c7c8719b28a0&provider=widevine_test"
+      },
+      {
+        "name": "WV: Secure video path required (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?video_id=0894c7c8719b28a0&provider=widevine_test"
+      },
+      {
+        "name": "WV: Secure video path required (MP4,H265)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/hevc/tears/tears.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?video_id=0894c7c8719b28a0&provider=widevine_test"
+      },
+      {
+        "name": "WV: HDCP + secure video path required",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?video_id=efd045b1eb61888a&provider=widevine_test"
+      },
+      {
+        "name": "WV: 30s license duration (fails at ~30s)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?video_id=f9a34cab7b05881a&provider=widevine_test"
+      }
+    ]
+  },
+  {
+    "name": "Widevine HDCP Capabilities Tests",
+    "samples": [
+      {
+        "name": "WV: HDCP: None (not required)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?video_id=HDCP_None&provider=widevine_test"
+      },
+      {
+        "name": "WV: HDCP: 1.0 required",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?video_id=HDCP_V1&provider=widevine_test"
+      },
+      {
+        "name": "WV: HDCP: 2.0 required",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?video_id=HDCP_V2&provider=widevine_test"
+      },
+      {
+        "name": "WV: HDCP: 2.1 required",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?video_id=HDCP_V2_1&provider=widevine_test"
+      },
+      {
+        "name": "WV: HDCP: 2.2 required",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?video_id=HDCP_V2_2&provider=widevine_test"
+      },
+      {
+        "name": "WV: HDCP: No digital output",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?video_id=HDCP_NO_DIGTAL_OUTPUT&provider=widevine_test"
+      }
+    ]
+  },
+  {
+    "name": "Widevine DASH: MP4,H264",
+    "samples": [
+      {
+        "name": "WV: Clear SD & HD (MP4,H264)",
+        "uri": "https://storage.googleapis.com/wvmedia/clear/h264/tears/tears.mpd"
+      },
+      {
+        "name": "WV: Clear SD (MP4,H264)",
+        "uri": "https://storage.googleapis.com/wvmedia/clear/h264/tears/tears_sd.mpd"
+      },
+      {
+        "name": "WV: Clear HD (MP4,H264)",
+        "uri": "https://storage.googleapis.com/wvmedia/clear/h264/tears/tears_hd.mpd"
+      },
+      {
+        "name": "WV: Clear UHD (MP4,H264)",
+        "uri": "https://storage.googleapis.com/wvmedia/clear/h264/tears/tears_uhd.mpd"
+      },
+      {
+        "name": "WV: Secure SD & HD (cenc,MP4,H264)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
+      },
+      {
+        "name": "WV: Secure SD (cenc,MP4,H264)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears_sd.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
+      },
+      {
+        "name": "WV: Secure HD (cenc,MP4,H264)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears_hd.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
+      },
+      {
+        "name": "WV: Secure UHD (cenc,MP4,H264)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears_uhd.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
+      },
+      {
+        "name": "WV: Secure SD & HD (cbc1,MP4,H264)",
+        "uri": "https://storage.googleapis.com/wvmedia/cbc1/h264/tears/tears_aes_cbc1.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
+      },
+      {
+        "name": "WV: Secure SD (cbc1,MP4,H264)",
+        "uri": "https://storage.googleapis.com/wvmedia/cbc1/h264/tears/tears_aes_cbc1_sd.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
+      },
+      {
+        "name": "WV: Secure HD (cbc1,MP4,H264)",
+        "uri": "https://storage.googleapis.com/wvmedia/cbc1/h264/tears/tears_aes_cbc1_hd.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
+      },
+      {
+        "name": "WV: Secure UHD (cbc1,MP4,H264)",
+        "uri": "https://storage.googleapis.com/wvmedia/cbc1/h264/tears/tears_aes_cbc1_uhd.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
+      },
+      {
+        "name": "WV: Secure SD & HD (cbcs,MP4,H264)",
+        "uri": "https://storage.googleapis.com/wvmedia/cbcs/h264/tears/tears_aes_cbcs.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
+      },
+      {
+        "name": "WV: Secure SD (cbcs,MP4,H264)",
+        "uri": "https://storage.googleapis.com/wvmedia/cbcs/h264/tears/tears_aes_cbcs_sd.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
+      },
+      {
+        "name": "WV: Secure HD (cbcs,MP4,H264)",
+        "uri": "https://storage.googleapis.com/wvmedia/cbcs/h264/tears/tears_aes_cbcs_hd.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
+      },
+      {
+        "name": "WV: Secure UHD (cbcs,MP4,H264)",
+        "uri": "https://storage.googleapis.com/wvmedia/cbcs/h264/tears/tears_aes_cbcs_uhd.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
+      }
+    ]
+  },
+  {
+    "name": "Widevine DASH: WebM,VP9",
+    "samples": [
+      {
+        "name": "WV: Clear SD & HD (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/clear/vp9/tears/tears.mpd"
+      },
+      {
+        "name": "WV: Clear SD (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/clear/vp9/tears/tears_sd.mpd"
+      },
+      {
+        "name": "WV: Clear HD (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/clear/vp9/tears/tears_hd.mpd"
+      },
+      {
+        "name": "WV: Clear UHD (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/clear/vp9/tears/tears_uhd.mpd"
+      },
+      {
+        "name": "WV: Secure Fullsample SD & HD (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
+      },
+      {
+        "name": "WV: Secure Fullsample SD (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears_sd.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
+      },
+      {
+        "name": "WV: Secure Fullsample HD (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears_hd.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
+      },
+      {
+        "name": "WV: Secure Fullsample UHD (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears_uhd.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
+      },
+      {
+        "name": "WV: Secure Subsample SD & HD (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/subsample/24fps/tears/tears.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
+      },
+      {
+        "name": "WV: Secure Subsample SD (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/subsample/24fps/tears/tears_sd.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
+      },
+      {
+        "name": "WV: Secure Subsample HD (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/subsample/24fps/tears/tears_hd.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
+      },
+      {
+        "name": "WV: Secure Subsample UHD (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/subsample/24fps/tears/tears_uhd.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
+      }
+    ]
+  },
+  {
+    "name": "Widevine DASH: MP4,H265",
+    "samples": [
+      {
+        "name": "WV: Clear SD & HD (MP4,H265)",
+        "uri": "https://storage.googleapis.com/wvmedia/clear/hevc/tears/tears.mpd"
+      },
+      {
+        "name": "WV: Clear SD (MP4,H265)",
+        "uri": "https://storage.googleapis.com/wvmedia/clear/hevc/tears/tears_sd.mpd"
+      },
+      {
+        "name": "WV: Clear HD (MP4,H265)",
+        "uri": "https://storage.googleapis.com/wvmedia/clear/hevc/tears/tears_hd.mpd"
+      },
+      {
+        "name": "WV: Clear UHD (MP4,H265)",
+        "uri": "https://storage.googleapis.com/wvmedia/clear/hevc/tears/tears_uhd.mpd"
+      },
+      {
+        "name": "WV: Secure SD & HD (MP4,H265)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/hevc/tears/tears.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
+      },
+      {
+        "name": "WV: Secure SD (MP4,H265)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/hevc/tears/tears_sd.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
+      },
+      {
+        "name": "WV: Secure HD (MP4,H265)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/hevc/tears/tears_hd.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
+      },
+      {
+        "name": "WV: Secure UHD (MP4,H265)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/hevc/tears/tears_uhd.mpd",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
+      }
+    ]
+  },
+  {
+    "name": "SmoothStreaming",
+    "samples": [
+      {
+        "name": "Super speed",
+        "uri": "http://playready.directtaps.net/smoothstreaming/SSWSS720H264/SuperSpeedway_720.ism"
+      },
+      {
+        "name": "Super speed (PlayReady)",
+        "uri": "http://playready.directtaps.net/smoothstreaming/SSWSS720H264PR/SuperSpeedway_720.ism",
+        "drm_scheme": "playready"
+      }
+    ]
+  },
+  {
+    "name": "HLS",
+    "samples": [
+      {
+        "name": "Apple 4x3 basic stream",
+        "uri": "https://devstreaming-cdn.apple.com/videos/streaming/examples/bipbop_4x3/bipbop_4x3_variant.m3u8"
+      },
+      {
+        "name": "Apple 16x9 basic stream",
+        "uri": "https://devstreaming-cdn.apple.com/videos/streaming/examples/bipbop_16x9/bipbop_16x9_variant.m3u8"
+      },
+      {
+        "name": "Apple master playlist advanced (TS)",
+        "uri": "https://tungsten.aaplimg.com/VOD/bipbop_adv_example_v2/master.m3u8"
+      },
+      {
+        "name": "Apple master playlist advanced (fMP4)",
+        "uri": "https://tungsten.aaplimg.com/VOD/bipbop_adv_fmp4_example/master.m3u8"
+      },
+      {
+        "name": "Apple TS media playlist",
+        "uri": "https://devstreaming-cdn.apple.com/videos/streaming/examples/bipbop_4x3/gear1/prog_index.m3u8"
+      },
+      {
+        "name": "Apple AAC media playlist",
+        "uri": "https://devstreaming-cdn.apple.com/videos/streaming/examples/bipbop_4x3/gear0/prog_index.m3u8"
+      },
+      {
+        "name": "Apple ID3 metadata",
+        "uri": "http://devimages.apple.com/samplecode/adDemo/ad.m3u8"
+      }
+    ]
+  },
+  {
+    "name": "Misc",
+    "samples": [
+      {
+        "name": "Dizzy",
+        "uri": "https://html5demos.com/assets/dizzy.mp4"
+      },
+      {
+        "name": "Apple AAC 10s",
+        "uri": "https://devstreaming-cdn.apple.com/videos/streaming/examples/bipbop_4x3/gear0/fileSequence0.aac"
+      },
+      {
+        "name": "Apple TS 10s",
+        "uri": "https://devstreaming-cdn.apple.com/videos/streaming/examples/bipbop_4x3/gear1/fileSequence0.ts"
+      },
+      {
+        "name": "Android screens (Matroska)",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv"
+      },
+      {
+        "name": "Big Buck Bunny (MP4 Video)",
+        "uri": "http://redirector.c.youtube.com/videoplayback?id=604ed5ce52eda7ee&itag=22&source=youtube&sparams=ip,ipbits,expire,source,id&ip=0.0.0.0&ipbits=0&expire=19000000000&signature=513F28C7FDCBEC60A66C86C9A393556C99DC47FB.04C88036EEE12565A1ED864A875A58F15D8B5300&key=ik0"
+      },
+      {
+        "name": "Screens 360P (WebM,VP9,No Audio)",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/gen-3/screens/dash-vod-single-segment/video-vp9-360.webm"
+      },
+      {
+        "name": "Screens 480p (FMP4,H264,No Audio)",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/gen-3/screens/dash-vod-single-segment/video-avc-baseline-480.mp4"
+      },
+      {
+        "name": "Screens 1080p (FMP4,H264, No Audio)",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/gen-3/screens/dash-vod-single-segment/video-137.mp4"
+      },
+      {
+        "name": "Screens (FMP4,AAC Audio)",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/gen-3/screens/dash-vod-single-segment/audio-141.mp4"
+      },
+      {
+        "name": "Google Play (MP3 Audio)",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-0/play.mp3"
+      },
+      {
+        "name": "Google Play (Ogg/Vorbis Audio)",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/ogg/play.ogg"
+      },
+      {
+        "name": "Google Glass (WebM Video with Vorbis Audio)",
+        "uri": "http://demos.webmproject.org/exoplayer/glass_vp9_vorbis.webm"
+      },
+      {
+        "name": "Google Glass (VP9 in MP4/ISO-BMFF)",
+        "uri": "http://demos.webmproject.org/exoplayer/glass.mp4"
+      },
+      {
+        "name": "Google Glass DASH - VP9 and Opus",
+        "uri": "http://demos.webmproject.org/dash/201410/vp9_glass/manifest_vp9_opus.mpd"
+      },
+      {
+        "name": "Big Buck Bunny (FLV Video)",
+        "uri": "http://vod.leasewebcdn.com/bbb.flv?ri=1024&rs=150&start=0"
+      }
+    ]
+  },
+  {
+    "name": "Playlists",
+    "samples": [
+      {
+        "name": "Cats -> Dogs",
+        "playlist": [
+          {
+            "uri": "https://html5demos.com/assets/dizzy.mp4"
+          },
+          {
+            "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv"
+          }
+        ]
+      },
+      {
+        "name": "Audio -> Video -> Audio",
+        "playlist": [
+          {
+            "uri": "https://storage.googleapis.com/exoplayer-test-media-1/gen-3/screens/dash-vod-single-segment/audio-141.mp4"
+          },
+          {
+            "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv"
+          },
+          {
+            "uri": "https://storage.googleapis.com/exoplayer-test-media-1/gen-3/screens/dash-vod-single-segment/audio-141.mp4"
+          }
+        ]
+      },
+      {
+        "name": "Clear -> Enc -> Clear -> Enc -> Enc",
+        "drm_scheme": "widevine",
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test",
+        "playlist": [
+          {
+            "uri": "https://html5demos.com/assets/dizzy.mp4"
+          },
+          {
+            "uri": "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears_sd.mpd"
+          },
+          {
+            "uri": "https://html5demos.com/assets/dizzy.mp4"
+          },
+          {
+            "uri": "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears_sd.mpd"
+          },
+          {
+            "uri": "https://storage.googleapis.com/wvmedia/cenc/h264/tears/tears_sd.mpd"
+          }
+        ]
+      }
+    ]
+  },
+  {
+    "name": "IMA sample ad tags",
+    "samples": [
+      {
+        "name": "Single inline linear",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
+        "ad_tag_uri": "https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/124319096/external/single_ad_samples&ciu_szs=300x250&impl=s&gdfp_req=1&env=vp&output=vast&unviewed_position_start=1&cust_params=deployment%3Ddevsite%26sample_ct%3Dlinear&correlator="
+      },
+      {
+        "name": "Single skippable inline",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
+        "ad_tag_uri": "https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/124319096/external/single_ad_samples&ciu_szs=300x250&impl=s&gdfp_req=1&env=vp&output=vast&unviewed_position_start=1&cust_params=deployment%3Ddevsite%26sample_ct%3Dskippablelinear&correlator="
+      },
+      {
+        "name": "Single redirect linear",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
+        "ad_tag_uri": "https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/124319096/external/single_ad_samples&ciu_szs=300x250&impl=s&gdfp_req=1&env=vp&output=vast&unviewed_position_start=1&cust_params=deployment%3Ddevsite%26sample_ct%3Dredirectlinear&correlator="
+      },
+      {
+        "name": "Single redirect error",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
+        "ad_tag_uri": "https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/124319096/external/single_ad_samples&ciu_szs=300x250&impl=s&gdfp_req=1&env=vp&output=vast&unviewed_position_start=1&cust_params=deployment%3Ddevsite%26sample_ct%3Dredirecterror&nofb=1&correlator="
+      },
+      {
+        "name": "Single redirect broken (fallback)",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
+        "ad_tag_uri": "https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/124319096/external/single_ad_samples&ciu_szs=300x250&impl=s&gdfp_req=1&env=vp&output=vast&unviewed_position_start=1&cust_params=deployment%3Ddevsite%26sample_ct%3Dredirecterror&correlator="
+      },
+      {
+        "name": "VMAP pre-roll",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
+        "ad_tag_uri": "https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/124319096/external/ad_rule_samples&ciu_szs=300x250&ad_rule=1&impl=s&gdfp_req=1&env=vp&output=vmap&unviewed_position_start=1&cust_params=deployment%3Ddevsite%26sample_ar%3Dpreonly&cmsid=496&vid=short_onecue&correlator="
+      },
+      {
+        "name": "VMAP pre-roll + bumper",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
+        "ad_tag_uri": "https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/124319096/external/ad_rule_samples&ciu_szs=300x250&ad_rule=1&impl=s&gdfp_req=1&env=vp&output=vmap&unviewed_position_start=1&cust_params=deployment%3Ddevsite%26sample_ar%3Dpreonlybumper&cmsid=496&vid=short_onecue&correlator="
+      },
+      {
+        "name": "VMAP post-roll",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
+        "ad_tag_uri": "https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/124319096/external/ad_rule_samples&ciu_szs=300x250&ad_rule=1&impl=s&gdfp_req=1&env=vp&output=vmap&unviewed_position_start=1&cust_params=deployment%3Ddevsite%26sample_ar%3Dpostonly&cmsid=496&vid=short_onecue&correlator="
+      },
+      {
+        "name": "VMAP post-roll + bumper",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
+        "ad_tag_uri": "https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/124319096/external/ad_rule_samples&ciu_szs=300x250&ad_rule=1&impl=s&gdfp_req=1&env=vp&output=vmap&unviewed_position_start=1&cust_params=deployment%3Ddevsite%26sample_ar%3Dpostonlybumper&cmsid=496&vid=short_onecue&correlator="
+      },
+      {
+        "name": "VMAP pre-, mid- and post-rolls, single ads",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
+        "ad_tag_uri": "https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/124319096/external/ad_rule_samples&ciu_szs=300x250&ad_rule=1&impl=s&gdfp_req=1&env=vp&output=vmap&unviewed_position_start=1&cust_params=deployment%3Ddevsite%26sample_ar%3Dpremidpost&cmsid=496&vid=short_onecue&correlator="
+      },
+      {
+        "name": "VMAP pre-roll single ad, mid-roll standard pod with 3 ads, post-roll single ad",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
+        "ad_tag_uri": "https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/124319096/external/ad_rule_samples&ciu_szs=300x250&ad_rule=1&impl=s&gdfp_req=1&env=vp&output=vmap&unviewed_position_start=1&cust_params=deployment%3Ddevsite%26sample_ar%3Dpremidpostpod&cmsid=496&vid=short_onecue&correlator="
+      },
+      {
+        "name": "VMAP pre-roll single ad, mid-roll optimized pod with 3 ads, post-roll single ad",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
+        "ad_tag_uri": "https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/124319096/external/ad_rule_samples&ciu_szs=300x250&ad_rule=1&impl=s&gdfp_req=1&env=vp&output=vmap&unviewed_position_start=1&cust_params=deployment%3Ddevsite%26sample_ar%3Dpremidpostoptimizedpod&cmsid=496&vid=short_onecue&correlator="
+      },
+      {
+        "name": "VMAP pre-roll single ad, mid-roll standard pod with 3 ads, post-roll single ad (bumpers around all ad breaks)",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
+        "ad_tag_uri": "https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/124319096/external/ad_rule_samples&ciu_szs=300x250&ad_rule=1&impl=s&gdfp_req=1&env=vp&output=vmap&unviewed_position_start=1&cust_params=deployment%3Ddevsite%26sample_ar%3Dpremidpostpodbumper&cmsid=496&vid=short_onecue&correlator="
+      },
+      {
+        "name": "VMAP pre-roll single ad, mid-roll optimized pod with 3 ads, post-roll single ad (bumpers around all ad breaks)",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
+        "ad_tag_uri": "https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/124319096/external/ad_rule_samples&ciu_szs=300x250&ad_rule=1&impl=s&gdfp_req=1&env=vp&output=vmap&unviewed_position_start=1&cust_params=deployment%3Ddevsite%26sample_ar%3Dpremidpostoptimizedpodbumper&cmsid=496&vid=short_onecue&correlator="
+      },
+      {
+        "name": "VMAP pre-roll single ad, mid-roll standard pods with 5 ads every 10 seconds for 1:40, post-roll single ad",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
+        "ad_tag_uri": "https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/124319096/external/ad_rule_samples&ciu_szs=300x250&ad_rule=1&impl=s&gdfp_req=1&env=vp&output=vmap&unviewed_position_start=1&cust_params=deployment%3Ddevsite%26sample_ar%3Dpremidpostlongpod&cmsid=496&vid=short_tencue&correlator="
+      },
+      {
+        "name": "VMAP empty midroll",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
+        "ad_tag_uri": "http://vastsynthesizer.appspot.com/empty-midroll"
+      },
+      {
+        "name": "VMAP full, empty, full midrolls",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
+        "ad_tag_uri": "http://vastsynthesizer.appspot.com/empty-midroll-2"
+      }
+    ]
+  },
+  {
+    "name": "ABR",
+    "samples": [
+      {
+        "name": "Random ABR - Google Glass (MP4,H264)",
+        "uri": "http://www.youtube.com/api/manifest/dash/id/bf5bb2419360daf1/source/youtube?as=fmp4_audio_clear,fmp4_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&ipbits=0&expire=19000000000&signature=51AF5F39AB0CEC3E5497CD9C900EBFEAECCCB5C7.8506521BFC350652163895D4C26DEE124209AA9E&key=ik0",
+        "extension": "mpd",
+        "abr_algorithm": "random"
+      }
+    ]
+  }
+]
diff --git a/demos/main_ia/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java b/demos/main_ia/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
new file mode 100755
index 0000000000..b5c127d2e3
--- /dev/null
+++ b/demos/main_ia/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.demo;
+
+import android.app.Application;
+import com.google.android.exoplayer2.offline.DownloadAction.Deserializer;
+import com.google.android.exoplayer2.offline.DownloadManager;
+import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
+import com.google.android.exoplayer2.offline.ProgressiveDownloadAction;
+import com.google.android.exoplayer2.source.dash.offline.DashDownloadAction;
+import com.google.android.exoplayer2.source.hls.offline.HlsDownloadAction;
+import com.google.android.exoplayer2.source.smoothstreaming.offline.SsDownloadAction;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
+import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
+import com.google.android.exoplayer2.upstream.FileDataSourceFactory;
+import com.google.android.exoplayer2.upstream.HttpDataSource;
+import com.google.android.exoplayer2.upstream.TransferListener;
+import com.google.android.exoplayer2.upstream.cache.Cache;
+import com.google.android.exoplayer2.upstream.cache.CacheDataSource;
+import com.google.android.exoplayer2.upstream.cache.CacheDataSourceFactory;
+import com.google.android.exoplayer2.upstream.cache.NoOpCacheEvictor;
+import com.google.android.exoplayer2.upstream.cache.SimpleCache;
+import com.google.android.exoplayer2.util.Util;
+import java.io.File;
+
+/**
+ * Placeholder application to facilitate overriding Application methods for debugging and testing.
+ */
+public class DemoApplication extends Application {
+
+  private static final String DOWNLOAD_ACTION_FILE = "actions";
+  private static final String DOWNLOAD_TRACKER_ACTION_FILE = "tracked_actions";
+  private static final String DOWNLOAD_CONTENT_DIRECTORY = "downloads";
+  private static final int MAX_SIMULTANEOUS_DOWNLOADS = 2;
+  private static final Deserializer[] DOWNLOAD_DESERIALIZERS =
+      new Deserializer[] {
+        DashDownloadAction.DESERIALIZER,
+        HlsDownloadAction.DESERIALIZER,
+        SsDownloadAction.DESERIALIZER,
+        ProgressiveDownloadAction.DESERIALIZER
+      };
+
+  protected String userAgent;
+
+  private File downloadDirectory;
+  private Cache downloadCache;
+  private DownloadManager downloadManager;
+  private DownloadTracker downloadTracker;
+
+  @Override
+  public void onCreate() {
+    super.onCreate();
+    userAgent = Util.getUserAgent(this, "ExoPlayerDemo");
+  }
+
+  /** Returns a {@link DataSource.Factory}. */
+  public DataSource.Factory buildDataSourceFactory(TransferListener<? super DataSource> listener) {
+    DefaultDataSourceFactory upstreamFactory =
+        new DefaultDataSourceFactory(this, listener, buildHttpDataSourceFactory(listener));
+    return buildReadOnlyCacheDataSource(upstreamFactory, getDownloadCache());
+  }
+
+  /** Returns a {@link HttpDataSource.Factory}. */
+  public HttpDataSource.Factory buildHttpDataSourceFactory(
+      TransferListener<? super DataSource> listener) {
+    return new DefaultHttpDataSourceFactory(userAgent, listener);
+  }
+
+  /** Returns whether extension renderers should be used. */
+  public boolean useExtensionRenderers() {
+    return "withExtensions".equals(BuildConfig.FLAVOR);
+  }
+
+  public DownloadManager getDownloadManager() {
+    initDownloadManager();
+    return downloadManager;
+  }
+
+  public DownloadTracker getDownloadTracker() {
+    initDownloadManager();
+    return downloadTracker;
+  }
+
+  private synchronized void initDownloadManager() {
+    if (downloadManager == null) {
+      DownloaderConstructorHelper downloaderConstructorHelper =
+          new DownloaderConstructorHelper(
+              getDownloadCache(), buildHttpDataSourceFactory(/* listener= */ null));
+      downloadManager =
+          new DownloadManager(
+              downloaderConstructorHelper,
+              MAX_SIMULTANEOUS_DOWNLOADS,
+              DownloadManager.DEFAULT_MIN_RETRY_COUNT,
+              new File(getDownloadDirectory(), DOWNLOAD_ACTION_FILE),
+              DOWNLOAD_DESERIALIZERS);
+      downloadTracker =
+          new DownloadTracker(
+              /* context= */ this,
+              buildDataSourceFactory(/* listener= */ null),
+              new File(getDownloadDirectory(), DOWNLOAD_TRACKER_ACTION_FILE),
+              DOWNLOAD_DESERIALIZERS);
+      downloadManager.addListener(downloadTracker);
+    }
+  }
+
+  private synchronized Cache getDownloadCache() {
+    if (downloadCache == null) {
+      File downloadContentDirectory = new File(getDownloadDirectory(), DOWNLOAD_CONTENT_DIRECTORY);
+      downloadCache = new SimpleCache(downloadContentDirectory, new NoOpCacheEvictor());
+    }
+    return downloadCache;
+  }
+
+  private File getDownloadDirectory() {
+    if (downloadDirectory == null) {
+      downloadDirectory = getExternalFilesDir(null);
+      if (downloadDirectory == null) {
+        downloadDirectory = getFilesDir();
+      }
+    }
+    return downloadDirectory;
+  }
+
+  private static CacheDataSourceFactory buildReadOnlyCacheDataSource(
+      DefaultDataSourceFactory upstreamFactory, Cache cache) {
+    return new CacheDataSourceFactory(
+        cache,
+        upstreamFactory,
+        new FileDataSourceFactory(),
+        /* cacheWriteDataSinkFactory= */ null,
+        CacheDataSource.FLAG_IGNORE_CACHE_ON_ERROR,
+        /* eventListener= */ null);
+  }
+}
diff --git a/demos/main_ia/src/main/java/com/google/android/exoplayer2/demo/DemoDownloadService.java b/demos/main_ia/src/main/java/com/google/android/exoplayer2/demo/DemoDownloadService.java
new file mode 100755
index 0000000000..7d1ab16ce4
--- /dev/null
+++ b/demos/main_ia/src/main/java/com/google/android/exoplayer2/demo/DemoDownloadService.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.demo;
+
+import android.app.Notification;
+import com.google.android.exoplayer2.offline.DownloadManager;
+import com.google.android.exoplayer2.offline.DownloadManager.TaskState;
+import com.google.android.exoplayer2.offline.DownloadService;
+import com.google.android.exoplayer2.scheduler.PlatformScheduler;
+import com.google.android.exoplayer2.ui.DownloadNotificationUtil;
+import com.google.android.exoplayer2.util.NotificationUtil;
+import com.google.android.exoplayer2.util.Util;
+
+/** A service for downloading media. */
+public class DemoDownloadService extends DownloadService {
+
+  private static final String CHANNEL_ID = "download_channel";
+  private static final int JOB_ID = 1;
+  private static final int FOREGROUND_NOTIFICATION_ID = 1;
+
+  public DemoDownloadService() {
+    super(
+        FOREGROUND_NOTIFICATION_ID,
+        DEFAULT_FOREGROUND_NOTIFICATION_UPDATE_INTERVAL,
+        CHANNEL_ID,
+        R.string.exo_download_notification_channel_name);
+  }
+
+  @Override
+  protected DownloadManager getDownloadManager() {
+    return ((DemoApplication) getApplication()).getDownloadManager();
+  }
+
+  @Override
+  protected PlatformScheduler getScheduler() {
+    return Util.SDK_INT >= 21 ? new PlatformScheduler(this, JOB_ID) : null;
+  }
+
+  @Override
+  protected Notification getForegroundNotification(TaskState[] taskStates) {
+    return DownloadNotificationUtil.buildProgressNotification(
+        /* context= */ this,
+        R.drawable.exo_controls_play,
+        CHANNEL_ID,
+        /* contentIntent= */ null,
+        /* message= */ null,
+        taskStates);
+  }
+
+  @Override
+  protected void onTaskStateChanged(TaskState taskState) {
+    if (taskState.action.isRemoveAction) {
+      return;
+    }
+    Notification notification = null;
+    if (taskState.state == TaskState.STATE_COMPLETED) {
+      notification =
+          DownloadNotificationUtil.buildDownloadCompletedNotification(
+              /* context= */ this,
+              R.drawable.exo_controls_play,
+              CHANNEL_ID,
+              /* contentIntent= */ null,
+              Util.fromUtf8Bytes(taskState.action.data));
+    } else if (taskState.state == TaskState.STATE_FAILED) {
+      notification =
+          DownloadNotificationUtil.buildDownloadFailedNotification(
+              /* context= */ this,
+              R.drawable.exo_controls_play,
+              CHANNEL_ID,
+              /* contentIntent= */ null,
+              Util.fromUtf8Bytes(taskState.action.data));
+    }
+    int notificationId = FOREGROUND_NOTIFICATION_ID + 1 + taskState.taskId;
+    NotificationUtil.setNotification(this, notificationId, notification);
+  }
+}
diff --git a/demos/main_ia/src/main/java/com/google/android/exoplayer2/demo/DownloadTracker.java b/demos/main_ia/src/main/java/com/google/android/exoplayer2/demo/DownloadTracker.java
new file mode 100755
index 0000000000..b4bce01c7a
--- /dev/null
+++ b/demos/main_ia/src/main/java/com/google/android/exoplayer2/demo/DownloadTracker.java
@@ -0,0 +1,303 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.demo;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.widget.ArrayAdapter;
+import android.widget.ListView;
+import android.widget.Toast;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.offline.ActionFile;
+import com.google.android.exoplayer2.offline.DownloadAction;
+import com.google.android.exoplayer2.offline.DownloadHelper;
+import com.google.android.exoplayer2.offline.DownloadManager;
+import com.google.android.exoplayer2.offline.DownloadManager.TaskState;
+import com.google.android.exoplayer2.offline.DownloadService;
+import com.google.android.exoplayer2.offline.ProgressiveDownloadHelper;
+import com.google.android.exoplayer2.offline.SegmentDownloadAction;
+import com.google.android.exoplayer2.offline.TrackKey;
+import com.google.android.exoplayer2.source.TrackGroup;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.source.dash.offline.DashDownloadHelper;
+import com.google.android.exoplayer2.source.hls.offline.HlsDownloadHelper;
+import com.google.android.exoplayer2.source.smoothstreaming.offline.SsDownloadHelper;
+import com.google.android.exoplayer2.ui.DefaultTrackNameProvider;
+import com.google.android.exoplayer2.ui.TrackNameProvider;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.util.Util;
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArraySet;
+
+/**
+ * Tracks media that has been downloaded.
+ *
+ * <p>Tracked downloads are persisted using an {@link ActionFile}, however in a real application
+ * it's expected that state will be stored directly in the application's media database, so that it
+ * can be queried efficiently together with other information about the media.
+ */
+public class DownloadTracker implements DownloadManager.Listener {
+
+  /** Listens for changes in the tracked downloads. */
+  public interface Listener {
+
+    /** Called when the tracked downloads changed. */
+    void onDownloadsChanged();
+  }
+
+  private static final String TAG = "DownloadTracker";
+
+  private final Context context;
+  private final DataSource.Factory dataSourceFactory;
+  private final TrackNameProvider trackNameProvider;
+  private final CopyOnWriteArraySet<Listener> listeners;
+  private final HashMap<Uri, DownloadAction> trackedDownloadStates;
+  private final ActionFile actionFile;
+  private final Handler actionFileWriteHandler;
+
+  public DownloadTracker(
+      Context context,
+      DataSource.Factory dataSourceFactory,
+      File actionFile,
+      DownloadAction.Deserializer[] deserializers) {
+    this.context = context.getApplicationContext();
+    this.dataSourceFactory = dataSourceFactory;
+    this.actionFile = new ActionFile(actionFile);
+    trackNameProvider = new DefaultTrackNameProvider(context.getResources());
+    listeners = new CopyOnWriteArraySet<>();
+    trackedDownloadStates = new HashMap<>();
+    HandlerThread actionFileWriteThread = new HandlerThread("DownloadTracker");
+    actionFileWriteThread.start();
+    actionFileWriteHandler = new Handler(actionFileWriteThread.getLooper());
+    loadTrackedActions(deserializers);
+  }
+
+  public void addListener(Listener listener) {
+    listeners.add(listener);
+  }
+
+  public void removeListener(Listener listener) {
+    listeners.remove(listener);
+  }
+
+  public boolean isDownloaded(Uri uri) {
+    return trackedDownloadStates.containsKey(uri);
+  }
+
+  @SuppressWarnings("unchecked")
+  public <K> List<K> getOfflineStreamKeys(Uri uri) {
+    if (!trackedDownloadStates.containsKey(uri)) {
+      return Collections.emptyList();
+    }
+    DownloadAction action = trackedDownloadStates.get(uri);
+    if (action instanceof SegmentDownloadAction) {
+      return ((SegmentDownloadAction) action).keys;
+    }
+    return Collections.emptyList();
+  }
+
+  public void toggleDownload(Activity activity, String name, Uri uri, String extension) {
+    if (isDownloaded(uri)) {
+      DownloadAction removeAction =
+          getDownloadHelper(uri, extension).getRemoveAction(Util.getUtf8Bytes(name));
+      startServiceWithAction(removeAction);
+    } else {
+      StartDownloadDialogHelper helper =
+          new StartDownloadDialogHelper(activity, getDownloadHelper(uri, extension), name);
+      helper.prepare();
+    }
+  }
+
+  // DownloadManager.Listener
+
+  @Override
+  public void onInitialized(DownloadManager downloadManager) {
+    // Do nothing.
+  }
+
+  @Override
+  public void onTaskStateChanged(DownloadManager downloadManager, TaskState taskState) {
+    DownloadAction action = taskState.action;
+    Uri uri = action.uri;
+    if ((action.isRemoveAction && taskState.state == TaskState.STATE_COMPLETED)
+        || (!action.isRemoveAction && taskState.state == TaskState.STATE_FAILED)) {
+      // A download has been removed, or has failed. Stop tracking it.
+      if (trackedDownloadStates.remove(uri) != null) {
+        handleTrackedDownloadStatesChanged();
+      }
+    }
+  }
+
+  @Override
+  public void onIdle(DownloadManager downloadManager) {
+    // Do nothing.
+  }
+
+  // Internal methods
+
+  private void loadTrackedActions(DownloadAction.Deserializer[] deserializers) {
+    try {
+      DownloadAction[] allActions = actionFile.load(deserializers);
+      for (DownloadAction action : allActions) {
+        trackedDownloadStates.put(action.uri, action);
+      }
+    } catch (IOException e) {
+      Log.e(TAG, "Failed to load tracked actions", e);
+    }
+  }
+
+  private void handleTrackedDownloadStatesChanged() {
+    for (Listener listener : listeners) {
+      listener.onDownloadsChanged();
+    }
+    final DownloadAction[] actions = trackedDownloadStates.values().toArray(new DownloadAction[0]);
+    actionFileWriteHandler.post(
+        new Runnable() {
+          @Override
+          public void run() {
+            try {
+              actionFile.store(actions);
+            } catch (IOException e) {
+              Log.e(TAG, "Failed to store tracked actions", e);
+            }
+          }
+        });
+  }
+
+  private void startDownload(DownloadAction action) {
+    if (trackedDownloadStates.containsKey(action.uri)) {
+      // This content is already being downloaded. Do nothing.
+      return;
+    }
+    trackedDownloadStates.put(action.uri, action);
+    handleTrackedDownloadStatesChanged();
+    startServiceWithAction(action);
+  }
+
+  private void startServiceWithAction(DownloadAction action) {
+    DownloadService.startWithAction(context, DemoDownloadService.class, action, false);
+  }
+
+  private DownloadHelper getDownloadHelper(Uri uri, String extension) {
+    int type = Util.inferContentType(uri, extension);
+    switch (type) {
+      case C.TYPE_DASH:
+        return new DashDownloadHelper(uri, dataSourceFactory);
+      case C.TYPE_SS:
+        return new SsDownloadHelper(uri, dataSourceFactory);
+      case C.TYPE_HLS:
+        return new HlsDownloadHelper(uri, dataSourceFactory);
+      case C.TYPE_OTHER:
+        return new ProgressiveDownloadHelper(uri);
+      default:
+        throw new IllegalStateException("Unsupported type: " + type);
+    }
+  }
+
+  private final class StartDownloadDialogHelper
+      implements DownloadHelper.Callback, DialogInterface.OnClickListener {
+
+    private final DownloadHelper downloadHelper;
+    private final String name;
+
+    private final AlertDialog.Builder builder;
+    private final View dialogView;
+    private final List<TrackKey> trackKeys;
+    private final ArrayAdapter<String> trackTitles;
+    private final ListView representationList;
+
+    public StartDownloadDialogHelper(
+        Activity activity, DownloadHelper downloadHelper, String name) {
+      this.downloadHelper = downloadHelper;
+      this.name = name;
+      builder =
+          new AlertDialog.Builder(activity)
+              .setTitle(R.string.exo_download_description)
+              .setPositiveButton(android.R.string.ok, this)
+              .setNegativeButton(android.R.string.cancel, null);
+
+      // Inflate with the builder's context to ensure the correct style is used.
+      LayoutInflater dialogInflater = LayoutInflater.from(builder.getContext());
+      dialogView = dialogInflater.inflate(R.layout.start_download_dialog, null);
+
+      trackKeys = new ArrayList<>();
+      trackTitles =
+          new ArrayAdapter<>(
+              builder.getContext(), android.R.layout.simple_list_item_multiple_choice);
+      representationList = dialogView.findViewById(R.id.representation_list);
+      representationList.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
+      representationList.setAdapter(trackTitles);
+    }
+
+    public void prepare() {
+      downloadHelper.prepare(this);
+    }
+
+    @Override
+    public void onPrepared(DownloadHelper helper) {
+      for (int i = 0; i < downloadHelper.getPeriodCount(); i++) {
+        TrackGroupArray trackGroups = downloadHelper.getTrackGroups(i);
+        for (int j = 0; j < trackGroups.length; j++) {
+          TrackGroup trackGroup = trackGroups.get(j);
+          for (int k = 0; k < trackGroup.length; k++) {
+            trackKeys.add(new TrackKey(i, j, k));
+            trackTitles.add(trackNameProvider.getTrackName(trackGroup.getFormat(k)));
+          }
+        }
+        if (!trackKeys.isEmpty()) {
+          builder.setView(dialogView);
+        }
+        builder.create().show();
+      }
+    }
+
+    @Override
+    public void onPrepareError(DownloadHelper helper, IOException e) {
+      Toast.makeText(
+              context.getApplicationContext(), R.string.download_start_error, Toast.LENGTH_LONG)
+          .show();
+    }
+
+    @Override
+    public void onClick(DialogInterface dialog, int which) {
+      ArrayList<TrackKey> selectedTrackKeys = new ArrayList<>();
+      for (int i = 0; i < representationList.getChildCount(); i++) {
+        if (representationList.isItemChecked(i)) {
+          selectedTrackKeys.add(trackKeys.get(i));
+        }
+      }
+      if (!selectedTrackKeys.isEmpty() || trackKeys.isEmpty()) {
+        // We have selected keys, or we're dealing with single stream content.
+        DownloadAction downloadAction =
+            downloadHelper.getDownloadAction(Util.getUtf8Bytes(name), selectedTrackKeys);
+        startDownload(downloadAction);
+      }
+    }
+  }
+}
diff --git a/demos/main_ia/src/main/java/com/google/android/exoplayer2/demo/ExoplayerDemoActivity.java b/demos/main_ia/src/main/java/com/google/android/exoplayer2/demo/ExoplayerDemoActivity.java
new file mode 100755
index 0000000000..d20d40dc62
--- /dev/null
+++ b/demos/main_ia/src/main/java/com/google/android/exoplayer2/demo/ExoplayerDemoActivity.java
@@ -0,0 +1,200 @@
+package com.google.android.exoplayer2.demo;
+
+import android.app.Activity;
+import android.net.Uri;
+import android.os.Bundle;
+import android.support.annotation.Nullable;
+import android.view.View;
+import android.widget.Button;
+import android.widget.Toast;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlayerFactory;
+import com.google.android.exoplayer2.ext.mpegh.MpeghAudioRenderer;
+import com.google.android.exoplayer2.source.ExtractorMediaSource;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.dash.DashMediaSource;
+import com.google.android.exoplayer2.source.dash.DefaultDashChunkSource;
+import com.google.android.exoplayer2.source.hls.HlsMediaSource;
+import com.google.android.exoplayer2.source.smoothstreaming.DefaultSsChunkSource;
+import com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource;
+import com.google.android.exoplayer2.trackselection.AdaptiveTrackSelection;
+import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
+import com.google.android.exoplayer2.util.Util;
+import android.view.View.OnClickListener;
+
+import com.google.android.exoplayer2.upstream.BandwidthMeter;
+
+import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.LoadControl;
+import com.google.android.exoplayer2.DefaultLoadControl;
+import com.google.android.exoplayer2.ExoPlayer;
+
+import com.google.android.exoplayer2.Renderer;
+
+public class ExoplayerDemoActivity extends Activity implements OnClickListener {
+
+    // UIs
+    private Button play_button;
+    private static final String TAG = "ExoplayerDemoActivity";
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        // build UI
+        setContentView(R.layout.exoplayer_test_activity);
+        play_button = findViewById(R.id.play_button);
+        play_button.setOnClickListener(this);
+    }
+
+    // data sources
+    private DataSource.Factory mediaDataSourceFactory;
+    private MediaSource mediaSource;
+
+    //private SimpleExoPlayer player; // --> SimpleExoPlayer cannot be passed renderer classes.
+    private ExoPlayer player;
+
+    // band width estimator
+    private static final DefaultBandwidthMeter BANDWIDTH_METER = new DefaultBandwidthMeter();
+
+    // renderer
+    private Renderer[] createRenderers() {
+        MpeghAudioRenderer iaAudioRenderer = new MpeghAudioRenderer();
+        //FfmpegAudioRenderer ffmpegAudioRenderer = new FfmpegAudioRenderer();
+        Renderer[] renderers = new Renderer[1];
+        //MediaCodecAudioRenderer audioRenderer = new MediaCodecAudioRenderer(this, MediaCodecSelector.DEFAULT);
+        //renderers[0] = audioRenderer;
+        renderers[0] = iaAudioRenderer;
+        //renderers[0] = ffmpegAudioRenderer;
+        return renderers;
+    }
+
+    // media player
+    private ExoPlayer createMediaPlayer() {
+
+        BandwidthMeter bandwidthMeter = new DefaultBandwidthMeter();
+        TrackSelection.Factory videoTrackSelectionFactory = new AdaptiveTrackSelection.Factory(bandwidthMeter);
+        TrackSelector trackSelector = new DefaultTrackSelector(videoTrackSelectionFactory);
+        //TrackSelector trackSelector = new DefaultTrackSelector();
+        LoadControl loadControl = new DefaultLoadControl();
+
+        // prepare renderer
+        Renderer[] renderers = createRenderers();
+
+        // create player
+        ExoPlayer player = ExoPlayerFactory.newInstance(renderers, trackSelector, loadControl);
+        return player;
+    }
+
+    // DataSource factory
+    private DataSource.Factory buildDataSourceFactory(boolean useBandwidthMeter) {
+        return ((DemoApplication) getApplication())
+                .buildDataSourceFactory(useBandwidthMeter ? BANDWIDTH_METER : null);
+    }
+
+    // media source
+    private MediaSource buildMediaSource(Uri uri) {
+        return buildMediaSource(uri, null);
+    }
+
+    @SuppressWarnings("unchecked")
+    private MediaSource buildMediaSource(Uri uri, @Nullable String overrideExtension) {
+        @C.ContentType int type = Util.inferContentType(uri, overrideExtension);
+        switch (type) {
+            case C.TYPE_DASH:
+                return new DashMediaSource.Factory(
+                        new DefaultDashChunkSource.Factory(mediaDataSourceFactory),
+                        buildDataSourceFactory(false))
+                        //.setManifestParser(
+                        //        new FilteringManifestParser<>(
+                        //                new DashManifestParser(), (List<RepresentationKey>) getOfflineStreamKeys(uri)))
+                        .createMediaSource(uri);
+            case C.TYPE_SS:
+                return new SsMediaSource.Factory(
+                        new DefaultSsChunkSource.Factory(mediaDataSourceFactory),
+                        buildDataSourceFactory(false))
+                        //.setManifestParser(
+                        //        new FilteringManifestParser<>(
+                        //                new SsManifestParser(), (List<StreamKey>) getOfflineStreamKeys(uri)))
+                        .createMediaSource(uri);
+            case C.TYPE_HLS:
+                return new HlsMediaSource.Factory(mediaDataSourceFactory)
+                        //.setPlaylistParser(
+                        //        new FilteringManifestParser<>(
+                        //                new HlsPlaylistParser(), (List<RenditionKey>) getOfflineStreamKeys(uri)))
+                        .createMediaSource(uri);
+            case C.TYPE_OTHER:
+                return new ExtractorMediaSource.Factory(mediaDataSourceFactory).createMediaSource(uri);
+            default: {
+                throw new IllegalStateException("Unsupported type: " + type);
+            }
+        }
+    }
+
+    // on play button pressed
+    @Override
+    public void onClick(View v) {
+        // create player
+        player = this.createMediaPlayer();
+
+        // contents URIs: check media.exolist.json.
+        Uri mediaUri = Uri.parse("https://html5demos.com/assets/dizzy.mp4");
+
+        mediaDataSourceFactory = buildDataSourceFactory(true);
+        MediaSource mediaSource = buildMediaSource(mediaUri, null);
+
+        // play audio
+        player.prepare(mediaSource);
+        player.setPlayWhenReady(true);
+
+    }
+
+    // activity life cycles
+    @Override
+    public void onStart() {
+        super.onStart();
+
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+
+    }
+
+    @Override
+    public void onStop() {
+        super.onStop();
+
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        player.release();
+    }
+
+    /*@Override
+    public boolean dispatchKeyEvent(KeyEvent event) {
+        // See whether the player view wants to handle media or DPAD keys events.
+        return rootView.dispatchKeyEvent(event) || super.dispatchKeyEvent(event);
+    }*/
+
+
+    // utilities
+    private void showToast(String message) {
+        Toast.makeText(getApplicationContext(), message, Toast.LENGTH_LONG).show();
+    }
+
+
+
+}
diff --git a/demos/main_ia/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java b/demos/main_ia/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
new file mode 100755
index 0000000000..5ad75167cd
--- /dev/null
+++ b/demos/main_ia/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
@@ -0,0 +1,756 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.demo;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.net.Uri;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Pair;
+import android.view.KeyEvent;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.ViewGroup;
+import android.widget.Button;
+import android.widget.FrameLayout;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.C.ContentType;
+import com.google.android.exoplayer2.DefaultRenderersFactory;
+import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.ExoPlayerFactory;
+import com.google.android.exoplayer2.PlaybackPreparer;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.SimpleExoPlayer;
+import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
+import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
+import com.google.android.exoplayer2.drm.FrameworkMediaDrm;
+import com.google.android.exoplayer2.drm.HttpMediaDrmCallback;
+import com.google.android.exoplayer2.drm.UnsupportedDrmException;
+import com.google.android.exoplayer2.ext.mpegh.MpeghExtractorFactory;
+import com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.DecoderInitializationException;
+import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
+import com.google.android.exoplayer2.offline.FilteringManifestParser;
+import com.google.android.exoplayer2.source.BehindLiveWindowException;
+import com.google.android.exoplayer2.source.ConcatenatingMediaSource;
+import com.google.android.exoplayer2.source.ExtractorMediaSource;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.source.ads.AdsLoader;
+import com.google.android.exoplayer2.source.ads.AdsMediaSource;
+import com.google.android.exoplayer2.source.dash.DashMediaSource;
+import com.google.android.exoplayer2.source.dash.DefaultDashChunkSource;
+import com.google.android.exoplayer2.source.dash.manifest.DashManifestParser;
+import com.google.android.exoplayer2.source.dash.manifest.RepresentationKey;
+import com.google.android.exoplayer2.source.hls.HlsMediaSource;
+import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistParser;
+import com.google.android.exoplayer2.source.hls.playlist.RenditionKey;
+import com.google.android.exoplayer2.source.smoothstreaming.DefaultSsChunkSource;
+import com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource;
+import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifestParser;
+import com.google.android.exoplayer2.source.smoothstreaming.manifest.StreamKey;
+import com.google.android.exoplayer2.trackselection.AdaptiveTrackSelection;
+import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
+import com.google.android.exoplayer2.trackselection.MappingTrackSelector.MappedTrackInfo;
+import com.google.android.exoplayer2.trackselection.RandomTrackSelection;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
+import com.google.android.exoplayer2.ui.DebugTextViewHelper;
+import com.google.android.exoplayer2.ui.PlayerControlView;
+import com.google.android.exoplayer2.ui.PlayerView;
+import com.google.android.exoplayer2.ui.TrackSelectionView;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
+import com.google.android.exoplayer2.upstream.HttpDataSource;
+import com.google.android.exoplayer2.util.ErrorMessageProvider;
+import com.google.android.exoplayer2.util.EventLogger;
+import com.google.android.exoplayer2.util.Util;
+
+import java.lang.reflect.Constructor;
+import java.net.CookieHandler;
+import java.net.CookieManager;
+import java.net.CookiePolicy;
+import java.util.List;
+import java.util.UUID;
+
+/** An activity that plays media using {@link SimpleExoPlayer}. */
+public class PlayerActivity extends Activity
+    implements OnClickListener, PlaybackPreparer, PlayerControlView.VisibilityListener {
+
+  public static final String DRM_SCHEME_EXTRA = "drm_scheme";
+  public static final String DRM_LICENSE_URL_EXTRA = "drm_license_url";
+  public static final String DRM_KEY_REQUEST_PROPERTIES_EXTRA = "drm_key_request_properties";
+  public static final String DRM_MULTI_SESSION_EXTRA = "drm_multi_session";
+  public static final String PREFER_EXTENSION_DECODERS_EXTRA = "prefer_extension_decoders";
+
+  public static final String ACTION_VIEW = "com.google.android.exoplayer.demo.action.VIEW";
+  public static final String EXTENSION_EXTRA = "extension";
+
+  public static final String ACTION_VIEW_LIST =
+      "com.google.android.exoplayer.demo.action.VIEW_LIST";
+  public static final String URI_LIST_EXTRA = "uri_list";
+  public static final String EXTENSION_LIST_EXTRA = "extension_list";
+
+  public static final String AD_TAG_URI_EXTRA = "ad_tag_uri";
+
+  public static final String ABR_ALGORITHM_EXTRA = "abr_algorithm";
+  private static final String ABR_ALGORITHM_DEFAULT = "default";
+  private static final String ABR_ALGORITHM_RANDOM = "random";
+
+  // For backwards compatibility only.
+  private static final String DRM_SCHEME_UUID_EXTRA = "drm_scheme_uuid";
+
+  // Saved instance state keys.
+  private static final String KEY_TRACK_SELECTOR_PARAMETERS = "track_selector_parameters";
+  private static final String KEY_WINDOW = "window";
+  private static final String KEY_POSITION = "position";
+  private static final String KEY_AUTO_PLAY = "auto_play";
+
+  private static final DefaultBandwidthMeter BANDWIDTH_METER = new DefaultBandwidthMeter();
+  private static final CookieManager DEFAULT_COOKIE_MANAGER;
+  static {
+    DEFAULT_COOKIE_MANAGER = new CookieManager();
+    DEFAULT_COOKIE_MANAGER.setCookiePolicy(CookiePolicy.ACCEPT_ORIGINAL_SERVER);
+  }
+
+  private PlayerView playerView;
+  private LinearLayout debugRootView;
+  private TextView debugTextView;
+
+  private DataSource.Factory mediaDataSourceFactory;
+  private SimpleExoPlayer player;
+  private FrameworkMediaDrm mediaDrm;
+  private MediaSource mediaSource;
+  private DefaultTrackSelector trackSelector;
+  private DefaultTrackSelector.Parameters trackSelectorParameters;
+  private DebugTextViewHelper debugViewHelper;
+  private TrackGroupArray lastSeenTrackGroupArray;
+
+  private boolean startAutoPlay;
+  private int startWindow;
+  private long startPosition;
+
+  // Fields used only for ad playback. The ads loader is loaded via reflection.
+
+  private AdsLoader adsLoader;
+  private Uri loadedAdTagUri;
+  private ViewGroup adUiViewGroup;
+
+  // Activity lifecycle
+
+  @Override
+  public void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    mediaDataSourceFactory = buildDataSourceFactory(true);
+    if (CookieHandler.getDefault() != DEFAULT_COOKIE_MANAGER) {
+      CookieHandler.setDefault(DEFAULT_COOKIE_MANAGER);
+    }
+
+    setContentView(R.layout.player_activity);
+    View rootView = findViewById(R.id.root);
+    rootView.setOnClickListener(this);
+    debugRootView = findViewById(R.id.controls_root);
+    debugTextView = findViewById(R.id.debug_text_view);
+
+    playerView = findViewById(R.id.player_view);
+    playerView.setControllerVisibilityListener(this);
+    playerView.setErrorMessageProvider(new PlayerErrorMessageProvider());
+    playerView.requestFocus();
+
+    if (savedInstanceState != null) {
+      trackSelectorParameters = savedInstanceState.getParcelable(KEY_TRACK_SELECTOR_PARAMETERS);
+      startAutoPlay = savedInstanceState.getBoolean(KEY_AUTO_PLAY);
+      startWindow = savedInstanceState.getInt(KEY_WINDOW);
+      startPosition = savedInstanceState.getLong(KEY_POSITION);
+    } else {
+      trackSelectorParameters = new DefaultTrackSelector.ParametersBuilder().build();
+      clearStartPosition();
+    }
+  }
+
+  @Override
+  public void onNewIntent(Intent intent) {
+    releasePlayer();
+    clearStartPosition();
+    setIntent(intent);
+  }
+
+  @Override
+  public void onStart() {
+    super.onStart();
+    if (Util.SDK_INT > 23) {
+      initializePlayer();
+    }
+  }
+
+  @Override
+  public void onResume() {
+    super.onResume();
+    if (Util.SDK_INT <= 23 || player == null) {
+      initializePlayer();
+    }
+  }
+
+  @Override
+  public void onPause() {
+    super.onPause();
+    if (Util.SDK_INT <= 23) {
+        releasePlayer();
+    }
+  }
+
+  @Override
+  public void onStop() {
+    super.onStop();
+    if (Util.SDK_INT > 23) {
+      releasePlayer();
+    }
+  }
+
+  @Override
+  public void onDestroy() {
+    super.onDestroy();
+    releaseAdsLoader();
+  }
+
+  @Override
+  public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,
+      @NonNull int[] grantResults) {
+    if (grantResults.length == 0) {
+      // Empty results are triggered if a permission is requested while another request was already
+      // pending and can be safely ignored in this case.
+      return;
+    }
+    if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {
+      initializePlayer();
+    } else {
+      showToast(R.string.storage_permission_denied);
+      finish();
+    }
+  }
+
+  @Override
+  public void onSaveInstanceState(Bundle outState) {
+    updateTrackSelectorParameters();
+    updateStartPosition();
+    outState.putParcelable(KEY_TRACK_SELECTOR_PARAMETERS, trackSelectorParameters);
+    outState.putBoolean(KEY_AUTO_PLAY, startAutoPlay);
+    outState.putInt(KEY_WINDOW, startWindow);
+    outState.putLong(KEY_POSITION, startPosition);
+  }
+
+  // Activity input
+
+  @Override
+  public boolean dispatchKeyEvent(KeyEvent event) {
+    // See whether the player view wants to handle media or DPAD keys events.
+    return playerView.dispatchKeyEvent(event) || super.dispatchKeyEvent(event);
+  }
+
+  // OnClickListener methods
+
+  @Override
+  public void onClick(View view) {
+    if (view.getParent() == debugRootView) {
+      MappedTrackInfo mappedTrackInfo = trackSelector.getCurrentMappedTrackInfo();
+      if (mappedTrackInfo != null) {
+        CharSequence title = ((Button) view).getText();
+        int rendererIndex = (int) view.getTag();
+        int rendererType = mappedTrackInfo.getRendererType(rendererIndex);
+        boolean allowAdaptiveSelections =
+            rendererType == C.TRACK_TYPE_VIDEO
+                || (rendererType == C.TRACK_TYPE_AUDIO
+                    && mappedTrackInfo.getTypeSupport(C.TRACK_TYPE_VIDEO)
+                        == MappedTrackInfo.RENDERER_SUPPORT_NO_TRACKS);
+        Pair<AlertDialog, TrackSelectionView> dialogPair =
+            TrackSelectionView.getDialog(this, title, trackSelector, rendererIndex);
+        dialogPair.second.setShowDisableOption(true);
+        dialogPair.second.setAllowAdaptiveSelections(allowAdaptiveSelections);
+        dialogPair.first.show();
+      }
+    }
+  }
+
+  // PlaybackControlView.PlaybackPreparer implementation
+
+  @Override
+  public void preparePlayback() {
+    initializePlayer();
+  }
+
+  // PlaybackControlView.VisibilityListener implementation
+
+  @Override
+  public void onVisibilityChange(int visibility) {
+    debugRootView.setVisibility(visibility);
+  }
+
+  // Internal methods
+
+  private void initializePlayer() {
+    if (player == null) {
+      Intent intent = getIntent();
+      String action = intent.getAction();
+      Uri[] uris;
+      String[] extensions;
+      if (ACTION_VIEW.equals(action)) {
+        uris = new Uri[] {intent.getData()};
+        extensions = new String[] {intent.getStringExtra(EXTENSION_EXTRA)};
+      } else if (ACTION_VIEW_LIST.equals(action)) {
+        String[] uriStrings = intent.getStringArrayExtra(URI_LIST_EXTRA);
+        uris = new Uri[uriStrings.length];
+        for (int i = 0; i < uriStrings.length; i++) {
+          uris[i] = Uri.parse(uriStrings[i]);
+        }
+        extensions = intent.getStringArrayExtra(EXTENSION_LIST_EXTRA);
+        if (extensions == null) {
+          extensions = new String[uriStrings.length];
+        }
+      } else {
+        showToast(getString(R.string.unexpected_intent_action, action));
+        finish();
+        return;
+      }
+      if (Util.maybeRequestReadExternalStoragePermission(this, uris)) {
+        // The player will be reinitialized if the permission is granted.
+        return;
+      }
+
+      DefaultDrmSessionManager<FrameworkMediaCrypto> drmSessionManager = null;
+      if (intent.hasExtra(DRM_SCHEME_EXTRA) || intent.hasExtra(DRM_SCHEME_UUID_EXTRA)) {
+        String drmLicenseUrl = intent.getStringExtra(DRM_LICENSE_URL_EXTRA);
+        String[] keyRequestPropertiesArray =
+            intent.getStringArrayExtra(DRM_KEY_REQUEST_PROPERTIES_EXTRA);
+        boolean multiSession = intent.getBooleanExtra(DRM_MULTI_SESSION_EXTRA, false);
+        int errorStringId = R.string.error_drm_unknown;
+        if (Util.SDK_INT < 18) {
+          errorStringId = R.string.error_drm_not_supported;
+        } else {
+          try {
+            String drmSchemeExtra = intent.hasExtra(DRM_SCHEME_EXTRA) ? DRM_SCHEME_EXTRA
+                : DRM_SCHEME_UUID_EXTRA;
+            UUID drmSchemeUuid = Util.getDrmUuid(intent.getStringExtra(drmSchemeExtra));
+            if (drmSchemeUuid == null) {
+              errorStringId = R.string.error_drm_unsupported_scheme;
+            } else {
+              drmSessionManager =
+                  buildDrmSessionManagerV18(
+                      drmSchemeUuid, drmLicenseUrl, keyRequestPropertiesArray, multiSession);
+            }
+          } catch (UnsupportedDrmException e) {
+            errorStringId = e.reason == UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME
+                ? R.string.error_drm_unsupported_scheme : R.string.error_drm_unknown;
+          }
+        }
+        if (drmSessionManager == null) {
+          showToast(errorStringId);
+          finish();
+          return;
+        }
+      }
+
+      TrackSelection.Factory trackSelectionFactory;
+      String abrAlgorithm = intent.getStringExtra(ABR_ALGORITHM_EXTRA);
+      if (abrAlgorithm == null || ABR_ALGORITHM_DEFAULT.equals(abrAlgorithm)) {
+        trackSelectionFactory = new AdaptiveTrackSelection.Factory(BANDWIDTH_METER);
+      } else if (ABR_ALGORITHM_RANDOM.equals(abrAlgorithm)) {
+        trackSelectionFactory = new RandomTrackSelection.Factory();
+      } else {
+        showToast(R.string.error_unrecognized_abr_algorithm);
+        finish();
+        return;
+      }
+
+      boolean preferExtensionDecoders =
+          intent.getBooleanExtra(PREFER_EXTENSION_DECODERS_EXTRA, false);
+      @DefaultRenderersFactory.ExtensionRendererMode int extensionRendererMode =
+          ((DemoApplication) getApplication()).useExtensionRenderers()
+              ? (preferExtensionDecoders ? DefaultRenderersFactory.EXTENSION_RENDERER_MODE_PREFER
+              : DefaultRenderersFactory.EXTENSION_RENDERER_MODE_ON)
+              : DefaultRenderersFactory.EXTENSION_RENDERER_MODE_OFF;
+      DefaultRenderersFactory renderersFactory =
+          new DefaultRenderersFactory(this, DefaultRenderersFactory.EXTENSION_RENDERER_MODE_ON);
+
+      trackSelector = new DefaultTrackSelector(trackSelectionFactory);
+      trackSelector.setParameters(trackSelectorParameters);
+      lastSeenTrackGroupArray = null;
+
+      player =
+          ExoPlayerFactory.newSimpleInstance(renderersFactory, trackSelector, drmSessionManager);
+      player.addListener(new PlayerEventListener());
+      player.setPlayWhenReady(startAutoPlay);
+      player.addAnalyticsListener(new EventLogger(trackSelector));
+      player.setRepeatMode(Player.REPEAT_MODE_ONE);
+      playerView.setPlayer(player);
+      playerView.setPlaybackPreparer(this);
+      debugViewHelper = new DebugTextViewHelper(player, debugTextView);
+      debugViewHelper.start();
+
+      MediaSource[] mediaSources = new MediaSource[uris.length];
+      for (int i = 0; i < uris.length; i++) {
+        mediaSources[i] = buildMediaSource(uris[i], extensions[i]);
+      }
+      mediaSource =
+          mediaSources.length == 1 ? mediaSources[0] : new ConcatenatingMediaSource(mediaSources);
+      String adTagUriString = intent.getStringExtra(AD_TAG_URI_EXTRA);
+      if (adTagUriString != null) {
+        Uri adTagUri = Uri.parse(adTagUriString);
+        if (!adTagUri.equals(loadedAdTagUri)) {
+          releaseAdsLoader();
+          loadedAdTagUri = adTagUri;
+        }
+        MediaSource adsMediaSource = createAdsMediaSource(mediaSource, Uri.parse(adTagUriString));
+        if (adsMediaSource != null) {
+          mediaSource = adsMediaSource;
+        } else {
+          showToast(R.string.ima_not_loaded);
+        }
+      } else {
+        releaseAdsLoader();
+      }
+    }
+    boolean haveStartPosition = startWindow != C.INDEX_UNSET;
+    if (haveStartPosition) {
+      player.seekTo(startWindow, startPosition);
+    }
+    player.prepare(mediaSource, !haveStartPosition, false);
+    updateButtonVisibilities();
+  }
+
+  private MediaSource buildMediaSource(Uri uri) {
+    return buildMediaSource(uri, null);
+  }
+
+  @SuppressWarnings("unchecked")
+  private MediaSource buildMediaSource(Uri uri, @Nullable String overrideExtension) {
+    @ContentType int type = Util.inferContentType(uri, overrideExtension);
+    switch (type) {
+      case C.TYPE_DASH:
+        return new DashMediaSource.Factory(
+                new DefaultDashChunkSource.Factory(mediaDataSourceFactory),
+                buildDataSourceFactory(false))
+            .setManifestParser(
+                new FilteringManifestParser<>(
+                    new DashManifestParser(), (List<RepresentationKey>) getOfflineStreamKeys(uri)))
+            .createMediaSource(uri);
+      case C.TYPE_SS:
+        return new SsMediaSource.Factory(
+                new DefaultSsChunkSource.Factory(mediaDataSourceFactory),
+                buildDataSourceFactory(false))
+            .setManifestParser(
+                new FilteringManifestParser<>(
+                    new SsManifestParser(), (List<StreamKey>) getOfflineStreamKeys(uri)))
+            .createMediaSource(uri);
+      case C.TYPE_HLS:
+        return new HlsMediaSource.Factory(mediaDataSourceFactory)
+            .setPlaylistParser(
+                new FilteringManifestParser<>(
+                    new HlsPlaylistParser(), (List<RenditionKey>) getOfflineStreamKeys(uri)))
+            .createMediaSource(uri);
+      case C.TYPE_OTHER:
+
+        return new ExtractorMediaSource.Factory(mediaDataSourceFactory)
+                .setExtractorsFactory(new MpeghExtractorFactory())
+                .createMediaSource(uri);
+      default: {
+        throw new IllegalStateException("Unsupported type: " + type);
+      }
+    }
+  }
+
+  private List<?> getOfflineStreamKeys(Uri uri) {
+    return ((DemoApplication) getApplication()).getDownloadTracker().getOfflineStreamKeys(uri);
+  }
+
+  private DefaultDrmSessionManager<FrameworkMediaCrypto> buildDrmSessionManagerV18(
+      UUID uuid, String licenseUrl, String[] keyRequestPropertiesArray, boolean multiSession)
+      throws UnsupportedDrmException {
+    HttpDataSource.Factory licenseDataSourceFactory =
+        ((DemoApplication) getApplication()).buildHttpDataSourceFactory(/* listener= */ null);
+    HttpMediaDrmCallback drmCallback =
+        new HttpMediaDrmCallback(licenseUrl, licenseDataSourceFactory);
+    if (keyRequestPropertiesArray != null) {
+      for (int i = 0; i < keyRequestPropertiesArray.length - 1; i += 2) {
+        drmCallback.setKeyRequestProperty(keyRequestPropertiesArray[i],
+            keyRequestPropertiesArray[i + 1]);
+      }
+    }
+    releaseMediaDrm();
+    mediaDrm = FrameworkMediaDrm.newInstance(uuid);
+    return new DefaultDrmSessionManager<>(uuid, mediaDrm, drmCallback, null, multiSession);
+  }
+
+  private void releasePlayer() {
+    if (player != null) {
+      updateTrackSelectorParameters();
+      updateStartPosition();
+      debugViewHelper.stop();
+      debugViewHelper = null;
+      player.release();
+      player = null;
+      mediaSource = null;
+      trackSelector = null;
+    }
+    releaseMediaDrm();
+  }
+
+  private void releaseMediaDrm() {
+    if (mediaDrm != null) {
+      mediaDrm.release();
+      mediaDrm = null;
+    }
+  }
+
+  private void releaseAdsLoader() {
+    if (adsLoader != null) {
+      adsLoader.release();
+      adsLoader = null;
+      loadedAdTagUri = null;
+      playerView.getOverlayFrameLayout().removeAllViews();
+    }
+  }
+
+  private void updateTrackSelectorParameters() {
+    if (trackSelector != null) {
+      trackSelectorParameters = trackSelector.getParameters();
+    }
+  }
+
+  private void updateStartPosition() {
+    if (player != null) {
+      startAutoPlay = player.getPlayWhenReady();
+      startWindow = player.getCurrentWindowIndex();
+      startPosition = Math.max(0, player.getContentPosition());
+    }
+  }
+
+  private void clearStartPosition() {
+    startAutoPlay = true;
+    startWindow = C.INDEX_UNSET;
+    startPosition = C.TIME_UNSET;
+  }
+
+  /**
+   * Returns a new DataSource factory.
+   *
+   * @param useBandwidthMeter Whether to set {@link #BANDWIDTH_METER} as a listener to the new
+   *     DataSource factory.
+   * @return A new DataSource factory.
+   */
+  private DataSource.Factory buildDataSourceFactory(boolean useBandwidthMeter) {
+    return ((DemoApplication) getApplication())
+        .buildDataSourceFactory(useBandwidthMeter ? BANDWIDTH_METER : null);
+  }
+
+  /** Returns an ads media source, reusing the ads loader if one exists. */
+  private @Nullable MediaSource createAdsMediaSource(MediaSource mediaSource, Uri adTagUri) {
+    // Load the extension source using reflection so the demo app doesn't have to depend on it.
+    // The ads loader is reused for multiple playbacks, so that ad playback can resume.
+    try {
+      Class<?> loaderClass = Class.forName("com.google.android.exoplayer2.ext.ima.ImaAdsLoader");
+      if (adsLoader == null) {
+        // Full class names used so the LINT.IfChange rule triggers should any of the classes move.
+        // LINT.IfChange
+        Constructor<? extends AdsLoader> loaderConstructor =
+            loaderClass
+                .asSubclass(AdsLoader.class)
+                .getConstructor(android.content.Context.class, android.net.Uri.class);
+        // LINT.ThenChange(../../../../../../../../proguard-rules.txt)
+        adsLoader = loaderConstructor.newInstance(this, adTagUri);
+        adUiViewGroup = new FrameLayout(this);
+        // The demo app has a non-null overlay frame layout.
+        playerView.getOverlayFrameLayout().addView(adUiViewGroup);
+      }
+      AdsMediaSource.MediaSourceFactory adMediaSourceFactory =
+          new AdsMediaSource.MediaSourceFactory() {
+            @Override
+            public MediaSource createMediaSource(Uri uri) {
+              return PlayerActivity.this.buildMediaSource(uri);
+            }
+
+            @Override
+            public int[] getSupportedTypes() {
+              return new int[] {C.TYPE_DASH, C.TYPE_SS, C.TYPE_HLS, C.TYPE_OTHER};
+            }
+          };
+      return new AdsMediaSource(mediaSource, adMediaSourceFactory, adsLoader, adUiViewGroup);
+    } catch (ClassNotFoundException e) {
+      // IMA extension not loaded.
+      return null;
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  // User controls
+
+  private void updateButtonVisibilities() {
+    debugRootView.removeAllViews();
+    if (player == null) {
+      return;
+    }
+
+    MappedTrackInfo mappedTrackInfo = trackSelector.getCurrentMappedTrackInfo();
+    if (mappedTrackInfo == null) {
+      return;
+    }
+
+    for (int i = 0; i < mappedTrackInfo.getRendererCount(); i++) {
+      TrackGroupArray trackGroups = mappedTrackInfo.getTrackGroups(i);
+      if (trackGroups.length != 0) {
+        Button button = new Button(this);
+        int label;
+        switch (player.getRendererType(i)) {
+          case C.TRACK_TYPE_AUDIO:
+            label = R.string.exo_track_selection_title_audio;
+            break;
+          case C.TRACK_TYPE_VIDEO:
+            label = R.string.exo_track_selection_title_video;
+            break;
+          case C.TRACK_TYPE_TEXT:
+            label = R.string.exo_track_selection_title_text;
+            break;
+          default:
+            continue;
+        }
+        button.setText(label);
+        button.setTag(i);
+        button.setOnClickListener(this);
+        debugRootView.addView(button);
+      }
+    }
+  }
+
+  private void showControls() {
+    debugRootView.setVisibility(View.VISIBLE);
+  }
+
+  private void showToast(int messageId) {
+    showToast(getString(messageId));
+  }
+
+  private void showToast(String message) {
+    Toast.makeText(getApplicationContext(), message, Toast.LENGTH_LONG).show();
+  }
+
+  private static boolean isBehindLiveWindow(ExoPlaybackException e) {
+    if (e.type != ExoPlaybackException.TYPE_SOURCE) {
+      return false;
+    }
+    Throwable cause = e.getSourceException();
+    while (cause != null) {
+      if (cause instanceof BehindLiveWindowException) {
+        return true;
+      }
+      cause = cause.getCause();
+    }
+    return false;
+  }
+
+  private class PlayerEventListener extends Player.DefaultEventListener {
+
+    @Override
+    public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
+      if (playbackState == Player.STATE_ENDED) {
+        showControls();
+      }
+      updateButtonVisibilities();
+    }
+
+    @Override
+    public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
+      if (player.getPlaybackError() != null) {
+        // The user has performed a seek whilst in the error state. Update the resume position so
+        // that if the user then retries, playback resumes from the position to which they seeked.
+        updateStartPosition();
+      }
+    }
+
+    @Override
+    public void onPlayerError(ExoPlaybackException e) {
+      if (isBehindLiveWindow(e)) {
+        clearStartPosition();
+        initializePlayer();
+      } else {
+        updateStartPosition();
+        updateButtonVisibilities();
+        showControls();
+      }
+    }
+
+    @Override
+    @SuppressWarnings("ReferenceEquality")
+    public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
+      updateButtonVisibilities();
+      if (trackGroups != lastSeenTrackGroupArray) {
+        MappedTrackInfo mappedTrackInfo = trackSelector.getCurrentMappedTrackInfo();
+        if (mappedTrackInfo != null) {
+          if (mappedTrackInfo.getTypeSupport(C.TRACK_TYPE_VIDEO)
+              == MappedTrackInfo.RENDERER_SUPPORT_UNSUPPORTED_TRACKS) {
+            showToast(R.string.error_unsupported_video);
+          }
+          if (mappedTrackInfo.getTypeSupport(C.TRACK_TYPE_AUDIO)
+              == MappedTrackInfo.RENDERER_SUPPORT_UNSUPPORTED_TRACKS) {
+            showToast(R.string.error_unsupported_audio);
+          }
+        }
+        lastSeenTrackGroupArray = trackGroups;
+      }
+    }
+  }
+
+  private class PlayerErrorMessageProvider implements ErrorMessageProvider<ExoPlaybackException> {
+
+    @Override
+    public Pair<Integer, String> getErrorMessage(ExoPlaybackException e) {
+      String errorString = getString(R.string.error_generic);
+      if (e.type == ExoPlaybackException.TYPE_RENDERER) {
+        Exception cause = e.getRendererException();
+        if (cause instanceof DecoderInitializationException) {
+          // Special case for decoder initialization failures.
+          DecoderInitializationException decoderInitializationException =
+              (DecoderInitializationException) cause;
+          if (decoderInitializationException.decoderName == null) {
+            if (decoderInitializationException.getCause() instanceof DecoderQueryException) {
+              errorString = getString(R.string.error_querying_decoders);
+            } else if (decoderInitializationException.secureDecoderRequired) {
+              errorString =
+                  getString(
+                      R.string.error_no_secure_decoder, decoderInitializationException.mimeType);
+            } else {
+              errorString =
+                  getString(R.string.error_no_decoder, decoderInitializationException.mimeType);
+            }
+          } else {
+            errorString =
+                getString(
+                    R.string.error_instantiating_decoder,
+                    decoderInitializationException.decoderName);
+          }
+        }
+      }
+      return Pair.create(0, errorString);
+    }
+  }
+
+}
diff --git a/demos/main_ia/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java b/demos/main_ia/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
new file mode 100755
index 0000000000..f0d1356173
--- /dev/null
+++ b/demos/main_ia/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
@@ -0,0 +1,584 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.demo;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.content.res.AssetManager;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.util.JsonReader;
+import android.util.Log;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.ViewGroup;
+import android.widget.BaseExpandableListAdapter;
+import android.widget.ExpandableListView;
+import android.widget.ExpandableListView.OnChildClickListener;
+import android.widget.ImageButton;
+import android.widget.ProgressBar;
+import android.widget.Switch;
+import android.widget.CompoundButton;
+import android.widget.CompoundButton.OnCheckedChangeListener;
+import android.widget.TextView;
+import android.widget.Toast;
+import android.text.method.ScrollingMovementMethod;
+import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.offline.DownloadService;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSourceInputStream;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.DefaultDataSource;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+
+
+/** An activity for selecting from a list of media samples. */
+public class SampleChooserActivity extends SpappActivity // SAL impl: inherited SpappActivity
+    implements DownloadTracker.Listener, OnChildClickListener {
+
+  private static final String TAG = "SampleChooserActivity";
+
+  private DownloadTracker downloadTracker;
+  private SampleAdapter sampleAdapter;
+
+  @Override
+  public void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.sample_chooser_activity);
+    sampleAdapter = new SampleAdapter();
+    ExpandableListView sampleListView = findViewById(R.id.sample_list);
+    sampleListView.setAdapter(sampleAdapter);
+    sampleListView.setOnChildClickListener(this);
+
+    // SAL impl
+    buildSalUi();
+
+    Intent intent = getIntent();
+    String dataUri = null; //intent.getDataString(); // SAL impl
+    // The intent should have no string data because this app is launched from headphones connect app.
+
+    String[] uris;
+    if (dataUri != null) {
+      uris = new String[] {dataUri};
+    } else {
+      ArrayList<String> uriList = new ArrayList<>();
+      AssetManager assetManager = getAssets();
+      try {
+        for (String asset : assetManager.list("")) {
+          if (asset.endsWith(".exolist.json")) {
+            uriList.add("asset:///" + asset);
+          }
+        }
+      } catch (IOException e) {
+        Toast.makeText(getApplicationContext(), R.string.sample_list_load_error, Toast.LENGTH_LONG)
+            .show();
+      }
+      uris = new String[uriList.size()];
+      uriList.toArray(uris);
+      Arrays.sort(uris);
+    }
+
+    downloadTracker = ((DemoApplication) getApplication()).getDownloadTracker();
+    SampleListLoader loaderTask = new SampleListLoader();
+    loaderTask.execute(uris);
+
+    // Start the download service if it should be running but it's not currently.
+    // Starting the service in the foreground causes notification flicker if there is no scheduled
+    // action. Starting it in the background throws an exception if the app is in the background too
+    // (e.g. if device screen is locked).
+    try {
+      DownloadService.start(this, DemoDownloadService.class);
+    } catch (IllegalStateException e) {
+      DownloadService.startForeground(this, DemoDownloadService.class);
+    }
+  }
+
+  @Override
+  public void onStart() {
+    super.onStart();
+    downloadTracker.addListener(this);
+    sampleAdapter.notifyDataSetChanged();
+  }
+
+  @Override
+  public void onStop() {
+    downloadTracker.removeListener(this);
+    super.onStop();
+  }
+
+  @Override
+  public void onDownloadsChanged() {
+    sampleAdapter.notifyDataSetChanged();
+  }
+
+  private void onSampleGroups(final List<SampleGroup> groups, boolean sawError) {
+    if (sawError) {
+      Toast.makeText(getApplicationContext(), R.string.sample_list_load_error, Toast.LENGTH_LONG)
+          .show();
+    }
+    sampleAdapter.setSampleGroups(groups);
+  }
+
+  @Override
+  public boolean onChildClick(
+      ExpandableListView parent, View view, int groupPosition, int childPosition, long id) {
+    Sample sample = (Sample) view.getTag();
+    startActivity(sample.buildIntent(this));
+    return true;
+  }
+
+  private void onSampleDownloadButtonClicked(Sample sample) {
+    int downloadUnsupportedStringId = getDownloadUnsupportedStringId(sample);
+    if (downloadUnsupportedStringId != 0) {
+      Toast.makeText(getApplicationContext(), downloadUnsupportedStringId, Toast.LENGTH_LONG)
+          .show();
+    } else {
+      UriSample uriSample = (UriSample) sample;
+      downloadTracker.toggleDownload(this, sample.name, uriSample.uri, uriSample.extension);
+    }
+  }
+
+  private int getDownloadUnsupportedStringId(Sample sample) {
+    if (sample instanceof PlaylistSample) {
+      return R.string.download_playlist_unsupported;
+    }
+    UriSample uriSample = (UriSample) sample;
+    if (uriSample.drmInfo != null) {
+      return R.string.download_drm_unsupported;
+    }
+    if (uriSample.adTagUri != null) {
+      return R.string.download_ads_unsupported;
+    }
+    String scheme = uriSample.uri.getScheme();
+    if (!("http".equals(scheme) || "https".equals(scheme))) {
+      return R.string.download_scheme_unsupported;
+    }
+    return 0;
+  }
+
+  private final class SampleListLoader extends AsyncTask<String, Void, List<SampleGroup>> {
+
+    private boolean sawError;
+
+    @Override
+    protected List<SampleGroup> doInBackground(String... uris) {
+      List<SampleGroup> result = new ArrayList<>();
+      Context context = getApplicationContext();
+      String userAgent = Util.getUserAgent(context, "ExoPlayerDemo");
+      DataSource dataSource = new DefaultDataSource(context, null, userAgent, false);
+      for (String uri : uris) {
+        DataSpec dataSpec = new DataSpec(Uri.parse(uri));
+        InputStream inputStream = new DataSourceInputStream(dataSource, dataSpec);
+        try {
+          readSampleGroups(new JsonReader(new InputStreamReader(inputStream, "UTF-8")), result);
+        } catch (Exception e) {
+          Log.e(TAG, "Error loading sample list: " + uri, e);
+          sawError = true;
+        } finally {
+          Util.closeQuietly(dataSource);
+        }
+      }
+      return result;
+    }
+
+    @Override
+    protected void onPostExecute(List<SampleGroup> result) {
+      onSampleGroups(result, sawError);
+    }
+
+    private void readSampleGroups(JsonReader reader, List<SampleGroup> groups) throws IOException {
+      reader.beginArray();
+      while (reader.hasNext()) {
+        readSampleGroup(reader, groups);
+      }
+      reader.endArray();
+    }
+
+    private void readSampleGroup(JsonReader reader, List<SampleGroup> groups) throws IOException {
+      String groupName = "";
+      ArrayList<Sample> samples = new ArrayList<>();
+
+      reader.beginObject();
+      while (reader.hasNext()) {
+        String name = reader.nextName();
+        switch (name) {
+          case "name":
+            groupName = reader.nextString();
+            break;
+          case "samples":
+            reader.beginArray();
+            while (reader.hasNext()) {
+              samples.add(readEntry(reader, false));
+            }
+            reader.endArray();
+            break;
+          case "_comment":
+            reader.nextString(); // Ignore.
+            break;
+          default:
+            throw new ParserException("Unsupported name: " + name);
+        }
+      }
+      reader.endObject();
+
+      SampleGroup group = getGroup(groupName, groups);
+      group.samples.addAll(samples);
+    }
+
+    private Sample readEntry(JsonReader reader, boolean insidePlaylist) throws IOException {
+      String sampleName = null;
+      Uri uri = null;
+      String extension = null;
+      String drmScheme = null;
+      String drmLicenseUrl = null;
+      String[] drmKeyRequestProperties = null;
+      boolean drmMultiSession = false;
+      boolean preferExtensionDecoders = false;
+      ArrayList<UriSample> playlistSamples = null;
+      String adTagUri = null;
+      String abrAlgorithm = null;
+
+      reader.beginObject();
+      while (reader.hasNext()) {
+        String name = reader.nextName();
+        switch (name) {
+          case "name":
+            sampleName = reader.nextString();
+            break;
+          case "uri":
+            uri = Uri.parse(reader.nextString());
+            break;
+          case "extension":
+            extension = reader.nextString();
+            break;
+          case "drm_scheme":
+            Assertions.checkState(!insidePlaylist, "Invalid attribute on nested item: drm_scheme");
+            drmScheme = reader.nextString();
+            break;
+          case "drm_license_url":
+            Assertions.checkState(!insidePlaylist,
+                "Invalid attribute on nested item: drm_license_url");
+            drmLicenseUrl = reader.nextString();
+            break;
+          case "drm_key_request_properties":
+            Assertions.checkState(!insidePlaylist,
+                "Invalid attribute on nested item: drm_key_request_properties");
+            ArrayList<String> drmKeyRequestPropertiesList = new ArrayList<>();
+            reader.beginObject();
+            while (reader.hasNext()) {
+              drmKeyRequestPropertiesList.add(reader.nextName());
+              drmKeyRequestPropertiesList.add(reader.nextString());
+            }
+            reader.endObject();
+            drmKeyRequestProperties = drmKeyRequestPropertiesList.toArray(new String[0]);
+            break;
+          case "drm_multi_session":
+            drmMultiSession = reader.nextBoolean();
+            break;
+          case "prefer_extension_decoders":
+            Assertions.checkState(!insidePlaylist,
+                "Invalid attribute on nested item: prefer_extension_decoders");
+            preferExtensionDecoders = reader.nextBoolean();
+            break;
+          case "playlist":
+            Assertions.checkState(!insidePlaylist, "Invalid nesting of playlists");
+            playlistSamples = new ArrayList<>();
+            reader.beginArray();
+            while (reader.hasNext()) {
+              playlistSamples.add((UriSample) readEntry(reader, true));
+            }
+            reader.endArray();
+            break;
+          case "ad_tag_uri":
+            adTagUri = reader.nextString();
+            break;
+          case "abr_algorithm":
+            Assertions.checkState(
+                !insidePlaylist, "Invalid attribute on nested item: abr_algorithm");
+            abrAlgorithm = reader.nextString();
+            break;
+          default:
+            throw new ParserException("Unsupported attribute name: " + name);
+        }
+      }
+      reader.endObject();
+      DrmInfo drmInfo =
+          drmScheme == null
+              ? null
+              : new DrmInfo(drmScheme, drmLicenseUrl, drmKeyRequestProperties, drmMultiSession);
+      if (playlistSamples != null) {
+        UriSample[] playlistSamplesArray = playlistSamples.toArray(
+            new UriSample[playlistSamples.size()]);
+        return new PlaylistSample(
+            sampleName, preferExtensionDecoders, abrAlgorithm, drmInfo, playlistSamplesArray);
+      } else {
+        return new UriSample(
+            sampleName, preferExtensionDecoders, abrAlgorithm, drmInfo, uri, extension, adTagUri);
+      }
+    }
+
+    private SampleGroup getGroup(String groupName, List<SampleGroup> groups) {
+      for (int i = 0; i < groups.size(); i++) {
+        if (Util.areEqual(groupName, groups.get(i).title)) {
+          return groups.get(i);
+        }
+      }
+      SampleGroup group = new SampleGroup(groupName);
+      groups.add(group);
+      return group;
+    }
+
+  }
+
+  private final class SampleAdapter extends BaseExpandableListAdapter implements OnClickListener {
+
+    private List<SampleGroup> sampleGroups;
+
+    public SampleAdapter() {
+      sampleGroups = Collections.emptyList();
+    }
+
+    public void setSampleGroups(List<SampleGroup> sampleGroups) {
+      this.sampleGroups = sampleGroups;
+      notifyDataSetChanged();
+    }
+
+    @Override
+    public Sample getChild(int groupPosition, int childPosition) {
+      return getGroup(groupPosition).samples.get(childPosition);
+    }
+
+    @Override
+    public long getChildId(int groupPosition, int childPosition) {
+      return childPosition;
+    }
+
+    @Override
+    public View getChildView(int groupPosition, int childPosition, boolean isLastChild,
+        View convertView, ViewGroup parent) {
+      View view = convertView;
+      if (view == null) {
+        view = getLayoutInflater().inflate(R.layout.sample_list_item, parent, false);
+        View downloadButton = view.findViewById(R.id.download_button);
+        downloadButton.setOnClickListener(this);
+        downloadButton.setFocusable(false);
+      }
+      initializeChildView(view, getChild(groupPosition, childPosition));
+      return view;
+    }
+
+    @Override
+    public int getChildrenCount(int groupPosition) {
+      return getGroup(groupPosition).samples.size();
+    }
+
+    @Override
+    public SampleGroup getGroup(int groupPosition) {
+      return sampleGroups.get(groupPosition);
+    }
+
+    @Override
+    public long getGroupId(int groupPosition) {
+      return groupPosition;
+    }
+
+    @Override
+    public View getGroupView(int groupPosition, boolean isExpanded, View convertView,
+        ViewGroup parent) {
+      View view = convertView;
+      if (view == null) {
+        view =
+            getLayoutInflater()
+                .inflate(android.R.layout.simple_expandable_list_item_1, parent, false);
+      }
+      ((TextView) view).setText(getGroup(groupPosition).title);
+      return view;
+    }
+
+    @Override
+    public int getGroupCount() {
+      return sampleGroups.size();
+    }
+
+    @Override
+    public boolean hasStableIds() {
+      return false;
+    }
+
+    @Override
+    public boolean isChildSelectable(int groupPosition, int childPosition) {
+      return true;
+    }
+
+    @Override
+    public void onClick(View view) {
+      onSampleDownloadButtonClicked((Sample) view.getTag());
+    }
+
+    private void initializeChildView(View view, Sample sample) {
+      view.setTag(sample);
+      TextView sampleTitle = view.findViewById(R.id.sample_title);
+      sampleTitle.setText(sample.name);
+
+      boolean canDownload = getDownloadUnsupportedStringId(sample) == 0;
+      boolean isDownloaded = canDownload && downloadTracker.isDownloaded(((UriSample) sample).uri);
+      ImageButton downloadButton = view.findViewById(R.id.download_button);
+      downloadButton.setTag(sample);
+      downloadButton.setColorFilter(
+          canDownload ? (isDownloaded ? 0xFF42A5F5 : 0xFFBDBDBD) : 0xFFEEEEEE);
+      downloadButton.setImageResource(
+          isDownloaded ? R.drawable.ic_download_done : R.drawable.ic_download);
+    }
+  }
+
+
+  private static final class SampleGroup {
+
+    public final String title;
+    public final List<Sample> samples;
+
+    public SampleGroup(String title) {
+      this.title = title;
+      this.samples = new ArrayList<>();
+    }
+
+  }
+
+  private static final class DrmInfo {
+    public final String drmScheme;
+    public final String drmLicenseUrl;
+    public final String[] drmKeyRequestProperties;
+    public final boolean drmMultiSession;
+
+    public DrmInfo(
+        String drmScheme,
+        String drmLicenseUrl,
+        String[] drmKeyRequestProperties,
+        boolean drmMultiSession) {
+      this.drmScheme = drmScheme;
+      this.drmLicenseUrl = drmLicenseUrl;
+      this.drmKeyRequestProperties = drmKeyRequestProperties;
+      this.drmMultiSession = drmMultiSession;
+    }
+
+    public void updateIntent(Intent intent) {
+      Assertions.checkNotNull(intent);
+      intent.putExtra(PlayerActivity.DRM_SCHEME_EXTRA, drmScheme);
+      intent.putExtra(PlayerActivity.DRM_LICENSE_URL_EXTRA, drmLicenseUrl);
+      intent.putExtra(PlayerActivity.DRM_KEY_REQUEST_PROPERTIES_EXTRA, drmKeyRequestProperties);
+      intent.putExtra(PlayerActivity.DRM_MULTI_SESSION_EXTRA, drmMultiSession);
+    }
+  }
+
+  private abstract static class Sample {
+    public final String name;
+    public final boolean preferExtensionDecoders;
+    public final String abrAlgorithm;
+    public final DrmInfo drmInfo;
+
+    public Sample(
+        String name, boolean preferExtensionDecoders, String abrAlgorithm, DrmInfo drmInfo) {
+      this.name = name;
+      this.preferExtensionDecoders = preferExtensionDecoders;
+      this.abrAlgorithm = abrAlgorithm;
+      this.drmInfo = drmInfo;
+    }
+
+    public Intent buildIntent(Context context) {
+      Intent intent = new Intent(context, PlayerActivity.class);
+      intent.putExtra(PlayerActivity.PREFER_EXTENSION_DECODERS_EXTRA, preferExtensionDecoders);
+      intent.putExtra(PlayerActivity.ABR_ALGORITHM_EXTRA, abrAlgorithm);
+      if (drmInfo != null) {
+        drmInfo.updateIntent(intent);
+      }
+      return intent;
+    }
+
+  }
+
+  private static final class UriSample extends Sample {
+
+    public final Uri uri;
+    public final String extension;
+    public final String adTagUri;
+
+    public UriSample(
+        String name,
+        boolean preferExtensionDecoders,
+        String abrAlgorithm,
+        DrmInfo drmInfo,
+        Uri uri,
+        String extension,
+        String adTagUri) {
+      super(name, preferExtensionDecoders, abrAlgorithm, drmInfo);
+      this.uri = uri;
+      this.extension = extension;
+      this.adTagUri = adTagUri;
+    }
+
+    @Override
+    public Intent buildIntent(Context context) {
+      return super.buildIntent(context)
+          .setData(uri)
+          .putExtra(PlayerActivity.EXTENSION_EXTRA, extension)
+          .putExtra(PlayerActivity.AD_TAG_URI_EXTRA, adTagUri)
+          .setAction(PlayerActivity.ACTION_VIEW);
+    }
+
+  }
+
+  private static final class PlaylistSample extends Sample {
+
+    public final UriSample[] children;
+
+    public PlaylistSample(
+        String name,
+        boolean preferExtensionDecoders,
+        String abrAlgorithm,
+        DrmInfo drmInfo,
+        UriSample... children) {
+      super(name, preferExtensionDecoders, abrAlgorithm, drmInfo);
+      this.children = children;
+    }
+
+    @Override
+    public Intent buildIntent(Context context) {
+      String[] uris = new String[children.length];
+      String[] extensions = new String[children.length];
+      for (int i = 0; i < children.length; i++) {
+        uris[i] = children[i].uri.toString();
+        extensions[i] = children[i].extension;
+      }
+      return super.buildIntent(context)
+          .putExtra(PlayerActivity.URI_LIST_EXTRA, uris)
+          .putExtra(PlayerActivity.EXTENSION_LIST_EXTRA, extensions)
+          .setAction(PlayerActivity.ACTION_VIEW_LIST);
+    }
+
+  }
+
+}
diff --git a/demos/main_ia/src/main/java/com/google/android/exoplayer2/demo/SpappActivity.java b/demos/main_ia/src/main/java/com/google/android/exoplayer2/demo/SpappActivity.java
new file mode 100755
index 0000000000..5b2fb73ab6
--- /dev/null
+++ b/demos/main_ia/src/main/java/com/google/android/exoplayer2/demo/SpappActivity.java
@@ -0,0 +1,672 @@
+package com.google.android.exoplayer2.demo;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.graphics.Color;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.text.TextUtils;
+import android.text.method.ScrollingMovementMethod;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AdapterView;
+import android.widget.BaseAdapter;
+import android.widget.Button;
+import android.widget.CompoundButton;
+import android.widget.CompoundButton.OnCheckedChangeListener;
+import android.widget.ListView;
+import android.widget.ProgressBar;
+import android.widget.ScrollView;
+import android.widget.Switch;
+import android.widget.TextView;
+import android.net.Uri;
+
+import android.support.v7.app.AppCompatActivity;
+import android.widget.Toast;
+
+// SAL impl: import SAL module
+import com.sony.immersive_audio.sal.SiaOptimizationInfo;
+import com.sony.immersive_audio.sal.SiaResult;
+import com.sony.immersive_audio.sal.SiaServerAccess;
+import com.sony.immersive_audio.sal.SiaServerAccessListener;
+import com.sony.immersive_audio.sal.SiaCpInfo;
+import com.sony.immersive_audio.sal.SiaOptimizationMode;
+
+import java.text.SimpleDateFormat;
+import java.util.List;
+import java.util.Locale;
+import java.util.TimeZone;
+
+// SpappActivity wraps SAL library and optimization sequences
+public class SpappActivity extends Activity  {
+
+    private static final String TAG = "SpappActivity";
+    private SiaServerAccess mSal;
+    protected TextView textOutput;
+    protected ProgressBar progressBar;
+
+    /**
+     * A view controller class managing Cp device list view.
+     */
+    protected SalDeviceListViewController deviceListViewController;
+
+    /**
+     * A menu controller class managing menu selections.
+     */
+    private MenuController menuController;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        // bind SAL service
+        final Intent intent = new Intent(this, SiaServerAccess.class);
+        bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE);
+
+        // create SAL Cp list view controllers
+        deviceListViewController = new SalDeviceListViewController(this);
+    }
+
+    void buildSalUi()
+    {
+        // demo app UIs
+        textOutput = findViewById(R.id.textView); // added text view
+        textOutput.setMovementMethod(ScrollingMovementMethod.getInstance());
+        progressBar = findViewById(R.id.progressBar);
+        progressBar.setVisibility(android.widget.ProgressBar.INVISIBLE);
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+
+        // unbind SAL service
+        if (mSal != null) {
+            mSal.unregisterListener(mSiaServerAccessListener);
+            addOutput("unbindService()");
+            mSal = null;
+        }
+        unbindService(mServiceConnection);
+    }
+
+    ///////////////////////////////////////////////////////////////////
+    // SAL optimization sequence
+
+    /**
+     *  Server connection class.
+     */
+    private ServiceConnection mServiceConnection = new ServiceConnection() {
+        @Override
+        public void onServiceConnected(ComponentName name, IBinder service) {
+            // start optimization
+            final SiaServerAccess.LocalBinder binder = (SiaServerAccess.LocalBinder) service;
+            mSal = binder.getService();
+            mSal.registerListener(mSiaServerAccessListener);
+
+            onSalServiceConnected();
+        }
+
+        @Override
+        public void onServiceDisconnected(ComponentName name) {
+            mSal = null;
+        }
+    };
+
+    /**
+     * A callback function on SAL is connected.
+     */
+    private void onSalServiceConnected() {
+        // update device list
+        deviceListViewController.setSal(mSal);
+        deviceListViewController.updateOptimizationMode();
+        deviceListViewController.updateView();
+
+        startOptimize();
+
+        // update progressbar
+        progressBar.setMax(100);
+        progressBar.setVisibility(android.widget.ProgressBar.VISIBLE);
+    }
+
+    /**
+     * Start optimization
+     */
+    private void startOptimize() {
+        final SiaResult ret = mSal.startOptimize(getIntent());
+        addOutput("----------");
+        addOutput("startOptimize() " + ret);
+    }
+
+    /**
+     *  A listener class managing server access sequences.
+     */
+    private SiaServerAccessListener mSiaServerAccessListener = new SiaServerAccessListener() {
+        @Override
+        public void onOptimizationStarted(SiaOptimizationInfo info) {
+            Log.d(TAG, "onOptimizationStarted");
+
+            addOutput("onOptimizationStarted");
+            addOutput("  app=" + info.getAppName());
+            addOutput("  dev=" + info.getDeviceName());
+            addOutput("  devtype=" + info.getDeviceType());
+            addOutput("  hrtfState=" + info.getHrtfOptimizationState());
+            addOutput("  cpState=" + info.getCpOptimizationState());
+            progressBar.setVisibility(android.widget.ProgressBar.VISIBLE);
+        }
+
+        @Override
+        public void onOptimizationProgress(int percent) {
+            Log.d(TAG, "onOptimizationProgress" + percent);
+
+            // update progressbar
+            progressBar.setProgress(percent);
+            // addOutput("onOptimizationProgress " + percent);
+        }
+
+        @Override
+        public void onOptimizationCompleted(SiaResult result) {
+            Log.d(TAG, "onOptimizationCompleted " + result);
+
+            // update progressbar
+            progressBar.setVisibility(android.widget.ProgressBar.INVISIBLE);
+            addOutput("onOptimizationCompleted " + result);
+            Toast.makeText(getApplicationContext(), "Optimization completed", Toast.LENGTH_LONG)
+                    .show();
+
+            deviceListViewController.updateView();
+        }
+
+        @Override
+        public void onOptimizationStateChanged(SiaOptimizationInfo info) {
+            // receives optimization state change
+            addOutput("onOptimizationStateChagned");
+            addOutput("  app=" + info.getAppName());
+            addOutput("  dev=" + info.getDeviceName());
+            addOutput("  devtype=" + info.getDeviceType());
+            addOutput("  hrtfState=" + info.getHrtfOptimizationState());
+            addOutput("  cpState=" + info.getCpOptimizationState());
+
+            deviceListViewController.updateView();
+        }
+    };
+
+    /**
+     *  A callback function called on optimization canceled.
+     */
+    private void onButtonCancel() {
+        SiaResult ret = mSal.cancelOptimize();
+        addOutput("cancelOptimize " + ret);
+    }
+
+    /**
+     *  get optimization info
+     */
+    private void getOptimizationInfo() {
+        final SiaOptimizationInfo info = mSal.getOptimizationInfo();
+        addOutput("getOptimizationInfo");
+        addOutput("  app=" + info.getAppName());
+        addOutput("  dev=" + info.getDeviceName());
+        addOutput("  devtype=" + info.getDeviceType());
+        addOutput("  hrtfState=" + info.getHrtfOptimizationState());
+        addOutput("  cpState=" + info.getCpOptimizationState());
+    }
+
+
+    /**
+     *  Add outpu text
+     */
+    protected void addOutput(String s) {
+        Log.d(TAG, s);
+        String current = textOutput.getText().toString();
+        current += s;
+        current += "\n";
+        textOutput.setText(current);
+    }
+
+    /**
+     * A view controller class managing Cp device list view.
+     */
+    public class SalDeviceListViewController {
+        private String TAG = "DeviceListViewController";
+
+        /**
+         *  A context class called this controller.
+         */
+        private Context context;
+
+        /**
+         *  SAL instance
+         */
+        private  SiaServerAccess sal;
+
+        /**
+         *  HRTF optimization enable switch
+         */
+        private Switch switchHrtf;
+
+        /**
+         *  CP optimization enable switch
+         */
+        private Switch switchCp;
+
+        /**
+         *  A list view object obrained from root view.
+         */
+        private ListView deviceListView;
+
+        /**
+         *  A list content adapter
+         */
+        private CpAdapter deviceListAdaper;
+
+        /**
+         *  Dialog object on delete cp file.
+         */
+        private AlertDialog deleteComfirmDialog;
+
+        /**
+         *  Constructor.
+         */
+        SalDeviceListViewController(Context context) {
+            this.context = context;
+        }
+
+        /**
+         *  Set root view instance including a Cp list view.
+         */
+        public void setRootView(View rootView) {
+            if (rootView == null) {
+                Log.w(TAG, "setRootView: rootView is null.");
+                return;
+            }
+            buildUi(rootView);
+        }
+
+        /**
+         *  Set SAL instance.
+         */
+        public void setSal(SiaServerAccess sal) {
+            this.sal = sal;
+        }
+
+        /**
+         *  Construct UI view references.
+         */
+        private void buildUi(View rootView) {
+            // optimization switches
+            switchHrtf = rootView.findViewById(R.id.personal_opt_switch);
+            switchHrtf.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
+                @Override
+                public void onCheckedChanged (CompoundButton buttonView,
+                                              boolean isChecked) {
+                    if (sal == null) {
+                        Log.w(TAG, "SwitchHrtf onCheckedChanged: SAL not connected.");
+                        return;
+                    }
+                    sal.setHrtfOptimizationMode(
+                            switchHrtf.isChecked() ? SiaOptimizationMode.ON : SiaOptimizationMode.OFF);
+                    updateView();
+                }
+            });
+
+            switchCp = rootView.findViewById(R.id.headphone_opt_switch);
+            switchCp.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
+                @Override
+                public void onCheckedChanged (CompoundButton buttonView,
+                                              boolean isChecked) {
+                    if (sal == null) {
+                        Log.w(TAG, "SwitchCp onCheckedChanged: SAL not connected.");
+                        return;
+                    }
+                    sal.setCpOptimizationMode(
+                            switchCp.isChecked() ? SiaOptimizationMode.ON : SiaOptimizationMode.OFF);
+                    updateView();
+                }
+            });
+
+            // device list views
+            deviceListView = rootView.findViewById(R.id.list_cp);
+            deviceListAdaper = new CpAdapter(context);
+            deviceListView.setAdapter(deviceListAdaper);
+            deviceListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+                @Override
+                public void onItemClick(AdapterView<?> adapterView, View view, int position, long id) {
+                    if (sal == null) {
+                        Log.w(TAG, "DeviceListView onItemClick: SAL is not connected.");
+                        return;
+                    }
+                    final SiaCpInfo info = (SiaCpInfo) deviceListAdaper.getItem(position);
+                    sal.setPreferredCp(info.getDeviceName());
+                    updateCpList();
+                }
+            });
+
+            // clear preferred button
+            rootView.findViewById(R.id.button_clear_preferred_cp).setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View view) {
+                    clearPreferredCp();
+                }
+            });
+
+            updateView();
+        }
+
+        /**
+         *  Notify CP list is updated.
+         */
+        void updateView() {
+            if (sal != null) {
+                if (switchHrtf != null) {
+                    switchHrtf.setChecked(sal.getHrtfOptimizationMode() == SiaOptimizationMode.ON);
+                }
+                if (switchCp != null) {
+                    switchCp.setChecked(sal.getCpOptimizationMode() == SiaOptimizationMode.ON);
+                }
+            }
+            updateCpList();
+
+        }
+
+        /**
+         *  Update CP list.
+         */
+        private void updateCpList() {
+            if (sal == null) {
+                Log.w(TAG, "updateCpList: SAL is not connected.");
+                return;
+            }
+            if (deviceListAdaper == null) {
+                Log.w(TAG, "updateCpList: DeviceListAdaper is not created.");
+                return;
+            }
+            deviceListAdaper.setCpList(sal.getCpList());
+
+            if (sal.getCpOptimizationMode()==SiaOptimizationMode.OFF) {
+                deviceListView.setVisibility(View.INVISIBLE);
+            }
+            else {
+                deviceListView.setVisibility(View.VISIBLE);
+            }
+        }
+
+        /**
+         *  Clear all preferred passive devices.
+         */
+        private void clearPreferredCp() {
+            if (sal == null) {
+                Log.w(TAG, "clearPreferredCp: SAL is not connected.");
+                return;
+            }
+            sal.setPreferredCp(null);
+            updateCpList();
+        }
+
+        /**
+         *  Delete a Cp device file.
+         */
+        private void deleteCp(final String deviceName) {
+            final AlertDialog.Builder builder = new AlertDialog.Builder(context);
+            deleteComfirmDialog = builder.setMessage("delete " + deviceName + "?").
+                    setPositiveButton("OK", new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialog, int i) {
+                            dialog.dismiss();
+                            if (sal != null) {
+                                Log.w(TAG, "DeleteComfirmDialog OK: SAL is not connected.");
+                                sal.deleteCp(deviceName);
+                            }
+                            updateCpList();
+                        }
+                    }).setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
+                @Override
+                public void onClick(DialogInterface dialog, int i) {
+                    dialog.dismiss();
+                }
+            }).create();
+            deleteComfirmDialog.show();
+
+        }
+
+        /**
+         *  List adapter class for Cp device list.
+         */
+        private class CpAdapter extends BaseAdapter {
+            private Context mContext;
+            private List<SiaCpInfo> mItems;
+
+            CpAdapter(Context context) {
+                mContext = context;
+            }
+
+            void setCpList(List<SiaCpInfo> items) {
+                mItems = items;
+                notifyDataSetChanged();
+            }
+
+            @Override
+            public int getCount() {
+                if (mItems == null) {
+                    return 0;
+                }
+                return mItems.size();
+            }
+
+            @Override
+            public Object getItem(int i) {
+                if (mItems == null) {
+                    return null;
+                }
+                return mItems.get(i);
+            }
+
+            @Override
+            public long getItemId(int i) {
+                return i;
+            }
+
+            @Override
+            public View getView(int i, View view, ViewGroup viewGroup) {
+                if (sal == null) {
+                    Log.w(TAG, "CpAdapter getView: SAL is not connected.");
+                    return view;
+                }
+
+                if (view == null) {
+                    LayoutInflater inflater = LayoutInflater.from(mContext);
+                    view = inflater.inflate(R.layout.listitem_cp, viewGroup, false);
+                }
+
+                final SiaCpInfo info = mItems.get(i);
+
+                final TextView textDeviceName = view.findViewById(R.id.text_device_name);
+                textDeviceName.setText(info.getDeviceName());
+
+                final TextView textDeviceType = view.findViewById(R.id.text_device_type);
+                textDeviceType.setText(info.getDeviceType().toString());
+
+                final TextView textDate = view.findViewById(R.id.text_date);
+                if (info.getDate() != null) {
+                    final SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss", Locale.US);
+                    sdf.setTimeZone(TimeZone.getDefault());
+                    textDate.setText(sdf.format(info.getDate()));
+                }
+
+                final TextView textPreferred = view.findViewById(R.id.text_preferred);
+                final String preferred = sal.getPreferredCp();
+                if (preferred != null && TextUtils.equals(preferred, info.getDeviceName())) {
+                    textPreferred.setText("Preferred CP");
+                } else {
+                    textPreferred.setText("");
+                }
+
+                final TextView textCurrent = view.findViewById(R.id.text_current);
+                final SiaCpInfo current = sal.getCurrentCp();
+                if (current != null
+                        && TextUtils.equals(current.getDeviceName(), info.getDeviceName())) {
+                    textCurrent.setText("Current CP");
+                } else {
+                    textCurrent.setText("");
+                }
+
+                final Button buttonDelete = view.findViewById(R.id.button_delete);
+                buttonDelete.setOnClickListener(new View.OnClickListener() {
+                    @Override
+                    public void onClick(View view) {
+                        deleteCp(info.getDeviceName());
+                    }
+                });
+
+                if (current != null
+                        && TextUtils.equals(current.getDeviceName(), info.getDeviceName())) {
+                    buttonDelete.setVisibility(View.INVISIBLE);
+                } else {
+                    buttonDelete.setVisibility(View.VISIBLE);
+                }
+
+
+                if (info.isSelectable()) {
+                    view.setBackgroundColor(Color.rgb(255, 255, 255));
+                } else {
+                    view.setBackgroundColor(Color.rgb(224, 224, 224));
+                }
+
+                return view;
+            }
+        }
+
+        /**
+         *  Update optimization modes.
+         */
+        void updateOptimizationMode() {
+            if (sal == null) {
+                Log.w(TAG, "updateOptimizationMode: SAL not connected.");
+                return;
+            }
+            if (switchHrtf == null) {
+                Log.w(TAG, "updateOptimizationMode: SwitchHrtf is not obtained.");
+                return;
+            }
+            if (switchCp == null) {
+                Log.w(TAG, "updateOptimizationMode: SwitchCp is not obtained.");
+                return;
+            }
+            switchHrtf.setChecked(sal.getHrtfOptimizationMode() == SiaOptimizationMode.ON);
+            switchCp.setChecked(sal.getCpOptimizationMode() == SiaOptimizationMode.ON);
+        }
+    }
+
+    //-------------------------------------------------------------------------//
+    // menu handlers
+    //-------------------------------------------------------------------------//
+
+    /**
+     * MenuController: A class managing menu items
+     */
+    public class MenuController {
+        private String TAG = "MenuController";
+
+        /**
+         *  An activity class called this controller.
+         */
+        private Context context;
+
+        // hrtf/cp file lists
+
+        /**
+         * An alert dialog instance to show the list of coefficient files on local storage.
+         */
+        private AlertDialog alertDialog;
+
+        /**
+         *  Whether virtualier is enable or not.
+         */
+        private boolean enableVirtualizer = false;
+
+        /**
+         * SAL related 360RA setting dialog.
+         */
+        private AlertDialog iaSettingDialog;
+
+        View iaSettingView;
+
+        /**
+         * Constructor
+         * @param context
+         */
+        MenuController(Context context) {
+            this.context = context;
+
+            // create 360RA Setting view
+            final LayoutInflater inflater = LayoutInflater.from(context);
+            iaSettingView = inflater.inflate(R.layout.ia_setting_dialog, null);
+
+            AlertDialog.Builder builder = new AlertDialog.Builder(context);
+            iaSettingDialog = builder.setTitle("360RA Setting")
+                    .setView(iaSettingView)
+                    .create();
+
+        }
+
+        public boolean onOptionsItemSelected(MenuItem item) {
+            switch (item.getItemId()) {
+                case R.id.menu_item_version_display:
+                    showVersionDialog();
+                    return true;
+                case R.id.menu_ia_setting:
+                    showIASettingDialog();
+            }
+            return true;
+        }
+        /**
+         * Show version on alert dialog
+         */
+        private void showVersionDialog() {
+            AlertDialog.Builder builder = new AlertDialog.Builder(context);
+            builder.setTitle(R.string.application_name).setMessage("Version " + BuildConfig.VERSION_NAME);
+            alertDialog = builder.show();
+        }
+
+        /**
+         * Show IA setting dialog.
+         */
+        private void showIASettingDialog() {
+            iaSettingDialog.show();
+        }
+    }
+
+
+    /**
+     * Create and show menu items.
+     */
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        MenuInflater inflater = getMenuInflater();
+        inflater.inflate(R.menu.main_menu, menu);
+
+        menuController = new MenuController(this);
+        if (deviceListViewController != null) {
+            deviceListViewController.setRootView(menuController.iaSettingView);
+        }
+        return true;
+    }
+
+    /**
+     * A callback on selected menu items.
+     */
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        menuController.onOptionsItemSelected(item);
+        return super.onOptionsItemSelected(item);
+    }
+}
diff --git a/demos/main_ia/src/main/res/drawable-hdpi/ic_download.png b/demos/main_ia/src/main/res/drawable-hdpi/ic_download.png
new file mode 100755
index 0000000000..fa3ebbb310
Binary files /dev/null and b/demos/main_ia/src/main/res/drawable-hdpi/ic_download.png differ
diff --git a/demos/main_ia/src/main/res/drawable-hdpi/ic_download_done.png b/demos/main_ia/src/main/res/drawable-hdpi/ic_download_done.png
new file mode 100755
index 0000000000..fa0ec9dd68
Binary files /dev/null and b/demos/main_ia/src/main/res/drawable-hdpi/ic_download_done.png differ
diff --git a/demos/main_ia/src/main/res/drawable-mdpi/ic_download.png b/demos/main_ia/src/main/res/drawable-mdpi/ic_download.png
new file mode 100755
index 0000000000..c8a2039c58
Binary files /dev/null and b/demos/main_ia/src/main/res/drawable-mdpi/ic_download.png differ
diff --git a/demos/main_ia/src/main/res/drawable-mdpi/ic_download_done.png b/demos/main_ia/src/main/res/drawable-mdpi/ic_download_done.png
new file mode 100755
index 0000000000..08073a2a6d
Binary files /dev/null and b/demos/main_ia/src/main/res/drawable-mdpi/ic_download_done.png differ
diff --git a/demos/main_ia/src/main/res/drawable-xhdpi/ic_banner.png b/demos/main_ia/src/main/res/drawable-xhdpi/ic_banner.png
new file mode 100755
index 0000000000..09de177387
Binary files /dev/null and b/demos/main_ia/src/main/res/drawable-xhdpi/ic_banner.png differ
diff --git a/demos/main_ia/src/main/res/drawable-xhdpi/ic_download.png b/demos/main_ia/src/main/res/drawable-xhdpi/ic_download.png
new file mode 100755
index 0000000000..671e0b3ece
Binary files /dev/null and b/demos/main_ia/src/main/res/drawable-xhdpi/ic_download.png differ
diff --git a/demos/main_ia/src/main/res/drawable-xhdpi/ic_download_done.png b/demos/main_ia/src/main/res/drawable-xhdpi/ic_download_done.png
new file mode 100755
index 0000000000..2339c0bf16
Binary files /dev/null and b/demos/main_ia/src/main/res/drawable-xhdpi/ic_download_done.png differ
diff --git a/demos/main_ia/src/main/res/drawable-xxhdpi/ic_download.png b/demos/main_ia/src/main/res/drawable-xxhdpi/ic_download.png
new file mode 100755
index 0000000000..f02715177a
Binary files /dev/null and b/demos/main_ia/src/main/res/drawable-xxhdpi/ic_download.png differ
diff --git a/demos/main_ia/src/main/res/drawable-xxhdpi/ic_download_done.png b/demos/main_ia/src/main/res/drawable-xxhdpi/ic_download_done.png
new file mode 100755
index 0000000000..b631a00088
Binary files /dev/null and b/demos/main_ia/src/main/res/drawable-xxhdpi/ic_download_done.png differ
diff --git a/demos/main_ia/src/main/res/drawable-xxxhdpi/ic_download.png b/demos/main_ia/src/main/res/drawable-xxxhdpi/ic_download.png
new file mode 100755
index 0000000000..6602791545
Binary files /dev/null and b/demos/main_ia/src/main/res/drawable-xxxhdpi/ic_download.png differ
diff --git a/demos/main_ia/src/main/res/drawable-xxxhdpi/ic_download_done.png b/demos/main_ia/src/main/res/drawable-xxxhdpi/ic_download_done.png
new file mode 100755
index 0000000000..52fe8f6990
Binary files /dev/null and b/demos/main_ia/src/main/res/drawable-xxxhdpi/ic_download_done.png differ
diff --git a/demos/main_ia/src/main/res/layout/exoplayer_test_activity.xml b/demos/main_ia/src/main/res/layout/exoplayer_test_activity.xml
new file mode 100755
index 0000000000..9b923421bb
--- /dev/null
+++ b/demos/main_ia/src/main/res/layout/exoplayer_test_activity.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:orientation="vertical" android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <Button
+        android:id="@+id/play_button"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:text="play" />
+
+    <Button
+        android:id="@+id/stop_button"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:text="Stop" />
+</LinearLayout>
\ No newline at end of file
diff --git a/demos/main_ia/src/main/res/layout/ia_setting_dialog.xml b/demos/main_ia/src/main/res/layout/ia_setting_dialog.xml
new file mode 100755
index 0000000000..b14727c353
--- /dev/null
+++ b/demos/main_ia/src/main/res/layout/ia_setting_dialog.xml
@@ -0,0 +1,100 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:orientation="vertical" android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <android.support.constraint.ConstraintLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent">
+
+        <TextView
+            android:id="@+id/textView"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_marginStart="8dp"
+            android:layout_marginLeft="8dp"
+            android:layout_marginTop="8dp"
+            android:layout_marginEnd="8dp"
+            android:layout_marginRight="8dp"
+            android:background="#dddddd"
+            android:text="Optimization Mode"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toTopOf="parent" />
+
+        <Switch
+            android:id="@+id/personal_opt_switch"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginStart="8dp"
+            android:layout_marginLeft="8dp"
+            android:layout_marginTop="8dp"
+            android:layout_marginBottom="8dp"
+            android:text="Personalize"
+            app:layout_constraintBottom_toTopOf="@+id/headphone_opt_switch"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toBottomOf="@+id/textView" />
+
+        <Switch
+            android:id="@+id/headphone_opt_switch"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginStart="8dp"
+            android:layout_marginLeft="8dp"
+            android:layout_marginBottom="8dp"
+            android:text="Headphone"
+            app:layout_constraintBottom_toTopOf="@+id/textView2"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toBottomOf="@+id/personal_opt_switch" />
+
+        <TextView
+            android:id="@+id/textView2"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_marginStart="8dp"
+            android:layout_marginLeft="8dp"
+            android:layout_marginTop="8dp"
+            android:layout_marginEnd="8dp"
+            android:layout_marginRight="8dp"
+            android:layout_marginBottom="8dp"
+            android:background="#dddddd"
+            android:text="Headphone List"
+            app:layout_constraintBottom_toTopOf="@+id/list_cp"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintHorizontal_bias="0.0"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toBottomOf="@+id/headphone_opt_switch" />
+
+        <ListView
+            android:id="@+id/list_cp"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_marginStart="8dp"
+            android:layout_marginLeft="8dp"
+            android:layout_marginEnd="8dp"
+            android:layout_marginRight="8dp"
+            android:layout_marginBottom="8dp"
+            android:layout_weight="1"
+            app:layout_constraintBottom_toTopOf="@+id/button_clear_preferred_cp"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toBottomOf="@+id/textView2" />
+
+        <Button
+            android:id="@+id/button_clear_preferred_cp"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginEnd="8dp"
+            android:layout_marginRight="8dp"
+            android:layout_marginBottom="8dp"
+            android:text="Clear Preferred Headphone"
+            android:textAllCaps="false"
+            app:layout_constraintBottom_toBottomOf="parent"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintTop_toBottomOf="@+id/list_cp"
+            app:layout_constraintVertical_bias="1.0" />
+    </android.support.constraint.ConstraintLayout>
+
+</LinearLayout>
\ No newline at end of file
diff --git a/demos/main_ia/src/main/res/layout/listitem_cp.xml b/demos/main_ia/src/main/res/layout/listitem_cp.xml
new file mode 100755
index 0000000000..3e9920a294
--- /dev/null
+++ b/demos/main_ia/src/main/res/layout/listitem_cp.xml
@@ -0,0 +1,62 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:descendantFocusability="blocksDescendants"
+    android:orientation="vertical"
+    android:padding="1dp">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="horizontal">
+
+        <TextView
+            android:id="@+id/text_device_name"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:textColor="#333333"/>
+
+        <TextView
+            android:id="@+id/text_device_type"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:textColor="#333333" />
+
+        <TextView
+            android:id="@+id/text_date"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:textColor="#333333" />
+    </LinearLayout>
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="horizontal">
+
+        <TextView
+            android:id="@+id/text_current"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:textColor="#333333" />
+
+        <TextView
+            android:id="@+id/text_preferred"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:textColor="#333333" />
+
+        <Button
+            android:id="@+id/button_delete"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:text="delete" />
+    </LinearLayout>
+
+</LinearLayout>
\ No newline at end of file
diff --git a/demos/main_ia/src/main/res/layout/player_activity.xml b/demos/main_ia/src/main/res/layout/player_activity.xml
new file mode 100755
index 0000000000..6b84033273
--- /dev/null
+++ b/demos/main_ia/src/main/res/layout/player_activity.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:id="@+id/root"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:keepScreenOn="true">
+
+  <com.google.android.exoplayer2.ui.PlayerView android:id="@+id/player_view"
+      android:layout_width="match_parent"
+      android:layout_height="match_parent"/>
+
+  <LinearLayout
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:background="#88000000"
+      android:orientation="vertical">
+
+    <TextView android:id="@+id/debug_text_view"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:paddingLeft="4dp"
+        android:paddingRight="4dp"
+        android:textSize="10sp"
+        tools:ignore="SmallSp"/>
+
+    <LinearLayout android:id="@+id/controls_root"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="horizontal"
+        android:visibility="gone"/>
+
+  </LinearLayout>
+
+</FrameLayout>
diff --git a/demos/main_ia/src/main/res/layout/sample_chooser_activity.xml b/demos/main_ia/src/main/res/layout/sample_chooser_activity.xml
new file mode 100755
index 0000000000..6b62eafcbb
--- /dev/null
+++ b/demos/main_ia/src/main/res/layout/sample_chooser_activity.xml
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical">
+
+  <ExpandableListView
+      android:id="@+id/sample_list"
+      android:layout_width="match_parent"
+      android:layout_height="387dp" />
+
+  <ProgressBar
+      android:id="@+id/progressBar"
+      style="?android:attr/progressBarStyleHorizontal"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content" />
+
+  <ScrollView
+      android:layout_width="match_parent"
+      android:layout_height="match_parent"
+      android:scrollbarStyle="insideOverlay">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical">
+
+      <TextView
+          android:id="@+id/textView"
+          android:layout_width="match_parent"
+          android:layout_height="160dp"
+          android:maxLines="10" />
+
+    </LinearLayout>
+  </ScrollView>
+
+</LinearLayout>
diff --git a/demos/main_ia/src/main/res/layout/sample_list_item.xml b/demos/main_ia/src/main/res/layout/sample_list_item.xml
new file mode 100755
index 0000000000..cdb0058688
--- /dev/null
+++ b/demos/main_ia/src/main/res/layout/sample_list_item.xml
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2018 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:paddingStart="12dp"
+    android:paddingEnd="12dp"
+    android:gravity="center_vertical"
+    android:orientation="horizontal">
+
+  <TextView android:id="@+id/sample_title"
+      android:layout_width="0dp"
+      android:layout_height="wrap_content"
+      android:layout_weight="1"
+      android:gravity="center_vertical"
+      android:minHeight="?android:attr/listPreferredItemHeightSmall"
+      android:textAppearance="?android:attr/textAppearanceListItemSmall"/>
+
+  <ImageButton android:id="@+id/download_button"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:contentDescription="@string/exo_download_description"
+      android:background="@android:color/transparent"/>
+
+</LinearLayout>
diff --git a/demos/main_ia/src/main/res/layout/start_download_dialog.xml b/demos/main_ia/src/main/res/layout/start_download_dialog.xml
new file mode 100755
index 0000000000..acb9af5d97
--- /dev/null
+++ b/demos/main_ia/src/main/res/layout/start_download_dialog.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2018 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<ListView xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/representation_list"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"/>
diff --git a/demos/main_ia/src/main/res/menu/main_menu.xml b/demos/main_ia/src/main/res/menu/main_menu.xml
new file mode 100755
index 0000000000..d9cb73b17e
--- /dev/null
+++ b/demos/main_ia/src/main/res/menu/main_menu.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android">
+    <item
+        android:id="@+id/menu_ia_setting"
+        android:title="360RA Setting"
+        android:orderInCategory="100"/>
+    <item
+        android:id="@+id/menu_item_version_display"
+        android:orderInCategory="400"
+        android:title="Version"/>
+</menu>
\ No newline at end of file
diff --git a/demos/main_ia/src/main/res/mipmap-hdpi/ic_launcher.png b/demos/main_ia/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100755
index 0000000000..adaa93220e
Binary files /dev/null and b/demos/main_ia/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/demos/main_ia/src/main/res/mipmap-mdpi/ic_launcher.png b/demos/main_ia/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100755
index 0000000000..9b6f7d5e80
Binary files /dev/null and b/demos/main_ia/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/demos/main_ia/src/main/res/mipmap-xhdpi/ic_launcher.png b/demos/main_ia/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100755
index 0000000000..2101026c9f
Binary files /dev/null and b/demos/main_ia/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/demos/main_ia/src/main/res/mipmap-xxhdpi/ic_launcher.png b/demos/main_ia/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..223ec8bd11
Binary files /dev/null and b/demos/main_ia/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/demos/main_ia/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/demos/main_ia/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100755
index 0000000000..698ed68c42
Binary files /dev/null and b/demos/main_ia/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/demos/main_ia/src/main/res/raw/com_sony_immersive_audio_brir_standard.riff b/demos/main_ia/src/main/res/raw/com_sony_immersive_audio_brir_standard.riff
new file mode 100755
index 0000000000..35f054d668
Binary files /dev/null and b/demos/main_ia/src/main/res/raw/com_sony_immersive_audio_brir_standard.riff differ
diff --git a/demos/main_ia/src/main/res/values/strings.xml b/demos/main_ia/src/main/res/values/strings.xml
new file mode 100755
index 0000000000..92bd2c903e
--- /dev/null
+++ b/demos/main_ia/src/main/res/values/strings.xml
@@ -0,0 +1,63 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+
+  <string name="application_name">ExoPlayer</string>
+
+  <string name="unexpected_intent_action">Unexpected intent action: <xliff:g id="action">%1$s</xliff:g></string>
+
+  <string name="error_generic">Playback failed</string>
+
+  <string name="error_unrecognized_abr_algorithm">Unrecognized ABR algorithm</string>
+
+  <string name="error_drm_not_supported">Protected content not supported on API levels below 18</string>
+
+  <string name="error_drm_unsupported_scheme">This device does not support the required DRM scheme</string>
+
+  <string name="error_drm_unknown">An unknown DRM error occurred</string>
+
+  <string name="error_no_decoder">This device does not provide a decoder for <xliff:g id="mime_type">%1$s</xliff:g></string>
+
+  <string name="error_no_secure_decoder">This device does not provide a secure decoder for <xliff:g id="mime_type">%1$s</xliff:g></string>
+
+  <string name="error_querying_decoders">Unable to query device decoders</string>
+
+  <string name="error_instantiating_decoder">Unable to instantiate decoder <xliff:g id="decoder_name">%1$s</xliff:g></string>
+
+  <string name="error_unsupported_video">Media includes video tracks, but none are playable by this device</string>
+
+  <string name="error_unsupported_audio">Media includes audio tracks, but none are playable by this device</string>
+
+  <string name="storage_permission_denied">Permission to access storage was denied</string>
+
+  <string name="sample_list_load_error">One or more sample lists failed to load</string>
+
+  <string name="ima_not_loaded">Playing sample without ads, as the IMA extension was not loaded</string>
+
+  <string name="download_start_error">Failed to start download</string>
+
+  <string name="download_playlist_unsupported">This demo app does not support downloading playlists</string>
+
+  <string name="download_drm_unsupported">This demo app does not support downloading protected content</string>
+
+  <string name="download_scheme_unsupported">This demo app only supports downloading http streams</string>
+
+  <string name="download_ads_unsupported">IMA does not support offline ads</string>
+
+
+  <string name="virtualizer_status_on">Virtualizer Status: On</string>
+  <string name="virtualizer_status_off">Virtualizer Status: Off</string>
+</resources>
diff --git a/demos/main_ia/src/main/res/values/styles.xml b/demos/main_ia/src/main/res/values/styles.xml
new file mode 100755
index 0000000000..5616bb9869
--- /dev/null
+++ b/demos/main_ia/src/main/res/values/styles.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources xmlns:android="http://schemas.android.com/apk/res/android">
+
+  <style name="PlayerTheme" parent="android:Theme.Holo">
+    <item name="android:windowNoTitle">true</item>
+    <item name="android:windowBackground">@android:color/black</item>
+  </style>
+
+</resources>
diff --git a/extensions/mpegh/README.md b/extensions/mpegh/README.md
new file mode 100755
index 0000000000..20a40bee14
--- /dev/null
+++ b/extensions/mpegh/README.md
@@ -0,0 +1,7 @@
+# ExoPlayer MPEG-H 3D extension #
+
+The MPEG-H extension provides `MpeghAudioRenderer`, which uses Sony Mpegh Decoder Library for
+decoding and Sony ALC(Auto Level Controller) Library for adjusting output audio level.
+
+## Support profile ##
+* MPEG-H 3D Music Profile Level 1 - 3
diff --git a/extensions/mpegh/build.gradle b/extensions/mpegh/build.gradle
new file mode 100755
index 0000000000..d3519762f9
--- /dev/null
+++ b/extensions/mpegh/build.gradle
@@ -0,0 +1,55 @@
+// Copyright (C) 2017 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+apply from: '../../constants.gradle'
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion project.ext.compileSdkVersion
+    buildToolsVersion project.ext.buildToolsVersion
+
+    defaultConfig {
+        minSdkVersion project.ext.minSdkVersion
+        targetSdkVersion project.ext.targetSdkVersion
+        consumerProguardFiles 'proguard-rules.txt'
+        ndk {
+            abiFilters 'armeabi-v7a', 'arm64-v8a', 'x86', 'x86_64'
+        }
+        externalNativeBuild {
+            cmake {
+                cppFlags  "-Wl,-Bsymbolic -DRENAME_SYMBOL"
+                arguments '-DANDROID_ARM_NEON=TRUE',
+                          '-DANDROID_CPP_FEATURES=rtti',
+                          '-DANDROID_ARM_NEON=true',
+                          '-DANDROID_PLATFORM=android-21',
+                          '-DANDROID_STL=gnustl_static'
+            }
+        }
+    }
+
+    externalNativeBuild {
+        cmake {
+            path "src/main/jni/CMakeLists.txt"
+        }
+    }
+}
+
+dependencies {
+    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    implementation project(modulePrefix + 'library-core')
+}
+
+ext {
+    javadocTitle = 'mpegh extension'
+}
+apply from: '../../javadoc_library.gradle'
diff --git a/extensions/mpegh/proguard-rules.txt b/extensions/mpegh/proguard-rules.txt
new file mode 100755
index 0000000000..3dd6dea1b1
--- /dev/null
+++ b/extensions/mpegh/proguard-rules.txt
@@ -0,0 +1,6 @@
+# Proguard rules specific to the mpegh extension.
+
+# This prevents the names of native methods from being obfuscated.
+-keepclasseswithmembernames class * {
+    native <methods>;
+}
diff --git a/extensions/mpegh/src/main/AndroidManifest.xml b/extensions/mpegh/src/main/AndroidManifest.xml
new file mode 100755
index 0000000000..1a900abf99
--- /dev/null
+++ b/extensions/mpegh/src/main/AndroidManifest.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest package="com.google.android.exoplayer2.ext.mpegh"/>
diff --git a/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/Atom.java b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/Atom.java
new file mode 100755
index 0000000000..5e62c8af65
--- /dev/null
+++ b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/Atom.java
@@ -0,0 +1,318 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.mpegh;
+
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.Util;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/* package*/ abstract class Atom {
+
+  /**
+   * Size of an atom header, in bytes.
+   */
+  public static final int HEADER_SIZE = 8;
+
+  /**
+   * Size of a full atom header, in bytes.
+   */
+  public static final int FULL_HEADER_SIZE = 12;
+
+  /**
+   * Size of a long atom header, in bytes.
+   */
+  public static final int LONG_HEADER_SIZE = 16;
+
+  /**
+   * Value for the size field in an atom that defines its size in the largesize field.
+   */
+  public static final int DEFINES_LARGE_SIZE = 1;
+
+  /**
+   * Value for the size field in an atom that extends to the end of the file.
+   */
+  public static final int EXTENDS_TO_END_SIZE = 0;
+
+  public static final int TYPE_ftyp = Util.getIntegerCodeForString("ftyp");
+  public static final int TYPE_avc1 = Util.getIntegerCodeForString("avc1");
+  public static final int TYPE_avc3 = Util.getIntegerCodeForString("avc3");
+  public static final int TYPE_hvc1 = Util.getIntegerCodeForString("hvc1");
+  public static final int TYPE_hev1 = Util.getIntegerCodeForString("hev1");
+  public static final int TYPE_s263 = Util.getIntegerCodeForString("s263");
+  public static final int TYPE_d263 = Util.getIntegerCodeForString("d263");
+  public static final int TYPE_mdat = Util.getIntegerCodeForString("mdat");
+  public static final int TYPE_mp4a = Util.getIntegerCodeForString("mp4a");
+  public static final int TYPE__mp3 = Util.getIntegerCodeForString(".mp3");
+  public static final int TYPE_wave = Util.getIntegerCodeForString("wave");
+  public static final int TYPE_lpcm = Util.getIntegerCodeForString("lpcm");
+  public static final int TYPE_sowt = Util.getIntegerCodeForString("sowt");
+  public static final int TYPE_ac_3 = Util.getIntegerCodeForString("ac-3");
+  public static final int TYPE_dac3 = Util.getIntegerCodeForString("dac3");
+  public static final int TYPE_ec_3 = Util.getIntegerCodeForString("ec-3");
+  public static final int TYPE_dec3 = Util.getIntegerCodeForString("dec3");
+  public static final int TYPE_dtsc = Util.getIntegerCodeForString("dtsc");
+  public static final int TYPE_dtsh = Util.getIntegerCodeForString("dtsh");
+  public static final int TYPE_dtsl = Util.getIntegerCodeForString("dtsl");
+  public static final int TYPE_dtse = Util.getIntegerCodeForString("dtse");
+  public static final int TYPE_ddts = Util.getIntegerCodeForString("ddts");
+  public static final int TYPE_tfdt = Util.getIntegerCodeForString("tfdt");
+  public static final int TYPE_tfhd = Util.getIntegerCodeForString("tfhd");
+  public static final int TYPE_trex = Util.getIntegerCodeForString("trex");
+  public static final int TYPE_trun = Util.getIntegerCodeForString("trun");
+  public static final int TYPE_sidx = Util.getIntegerCodeForString("sidx");
+  public static final int TYPE_moov = Util.getIntegerCodeForString("moov");
+  public static final int TYPE_mvhd = Util.getIntegerCodeForString("mvhd");
+  public static final int TYPE_trak = Util.getIntegerCodeForString("trak");
+  public static final int TYPE_mdia = Util.getIntegerCodeForString("mdia");
+  public static final int TYPE_minf = Util.getIntegerCodeForString("minf");
+  public static final int TYPE_stbl = Util.getIntegerCodeForString("stbl");
+  public static final int TYPE_avcC = Util.getIntegerCodeForString("avcC");
+  public static final int TYPE_hvcC = Util.getIntegerCodeForString("hvcC");
+  public static final int TYPE_esds = Util.getIntegerCodeForString("esds");
+  public static final int TYPE_moof = Util.getIntegerCodeForString("moof");
+  public static final int TYPE_traf = Util.getIntegerCodeForString("traf");
+  public static final int TYPE_mvex = Util.getIntegerCodeForString("mvex");
+  public static final int TYPE_mehd = Util.getIntegerCodeForString("mehd");
+  public static final int TYPE_tkhd = Util.getIntegerCodeForString("tkhd");
+  public static final int TYPE_edts = Util.getIntegerCodeForString("edts");
+  public static final int TYPE_elst = Util.getIntegerCodeForString("elst");
+  public static final int TYPE_mdhd = Util.getIntegerCodeForString("mdhd");
+  public static final int TYPE_hdlr = Util.getIntegerCodeForString("hdlr");
+  public static final int TYPE_stsd = Util.getIntegerCodeForString("stsd");
+  public static final int TYPE_pssh = Util.getIntegerCodeForString("pssh");
+  public static final int TYPE_sinf = Util.getIntegerCodeForString("sinf");
+  public static final int TYPE_schm = Util.getIntegerCodeForString("schm");
+  public static final int TYPE_schi = Util.getIntegerCodeForString("schi");
+  public static final int TYPE_tenc = Util.getIntegerCodeForString("tenc");
+  public static final int TYPE_encv = Util.getIntegerCodeForString("encv");
+  public static final int TYPE_enca = Util.getIntegerCodeForString("enca");
+  public static final int TYPE_frma = Util.getIntegerCodeForString("frma");
+  public static final int TYPE_saiz = Util.getIntegerCodeForString("saiz");
+  public static final int TYPE_saio = Util.getIntegerCodeForString("saio");
+  public static final int TYPE_sbgp = Util.getIntegerCodeForString("sbgp");
+  public static final int TYPE_sgpd = Util.getIntegerCodeForString("sgpd");
+  public static final int TYPE_uuid = Util.getIntegerCodeForString("uuid");
+  public static final int TYPE_senc = Util.getIntegerCodeForString("senc");
+  public static final int TYPE_pasp = Util.getIntegerCodeForString("pasp");
+  public static final int TYPE_TTML = Util.getIntegerCodeForString("TTML");
+  public static final int TYPE_vmhd = Util.getIntegerCodeForString("vmhd");
+  public static final int TYPE_mp4v = Util.getIntegerCodeForString("mp4v");
+  public static final int TYPE_stts = Util.getIntegerCodeForString("stts");
+  public static final int TYPE_stss = Util.getIntegerCodeForString("stss");
+  public static final int TYPE_ctts = Util.getIntegerCodeForString("ctts");
+  public static final int TYPE_stsc = Util.getIntegerCodeForString("stsc");
+  public static final int TYPE_stsz = Util.getIntegerCodeForString("stsz");
+  public static final int TYPE_stz2 = Util.getIntegerCodeForString("stz2");
+  public static final int TYPE_stco = Util.getIntegerCodeForString("stco");
+  public static final int TYPE_co64 = Util.getIntegerCodeForString("co64");
+  public static final int TYPE_tx3g = Util.getIntegerCodeForString("tx3g");
+  public static final int TYPE_wvtt = Util.getIntegerCodeForString("wvtt");
+  public static final int TYPE_stpp = Util.getIntegerCodeForString("stpp");
+  public static final int TYPE_c608 = Util.getIntegerCodeForString("c608");
+  public static final int TYPE_samr = Util.getIntegerCodeForString("samr");
+  public static final int TYPE_sawb = Util.getIntegerCodeForString("sawb");
+  public static final int TYPE_udta = Util.getIntegerCodeForString("udta");
+  public static final int TYPE_meta = Util.getIntegerCodeForString("meta");
+  public static final int TYPE_ilst = Util.getIntegerCodeForString("ilst");
+  public static final int TYPE_mean = Util.getIntegerCodeForString("mean");
+  public static final int TYPE_name = Util.getIntegerCodeForString("name");
+  public static final int TYPE_data = Util.getIntegerCodeForString("data");
+  public static final int TYPE_emsg = Util.getIntegerCodeForString("emsg");
+  public static final int TYPE_st3d = Util.getIntegerCodeForString("st3d");
+  public static final int TYPE_sv3d = Util.getIntegerCodeForString("sv3d");
+  public static final int TYPE_proj = Util.getIntegerCodeForString("proj");
+  public static final int TYPE_vp08 = Util.getIntegerCodeForString("vp08");
+  public static final int TYPE_vp09 = Util.getIntegerCodeForString("vp09");
+  public static final int TYPE_vpcC = Util.getIntegerCodeForString("vpcC");
+  public static final int TYPE_camm = Util.getIntegerCodeForString("camm");
+  public static final int TYPE_alac = Util.getIntegerCodeForString("alac");
+  public static final int TYPE_mha1 = Util.getIntegerCodeForString("mha1");
+  public static final int TYPE_mhac = Util.getIntegerCodeForString("mhaC");
+
+  public final int type;
+
+  public Atom(int type) {
+    this.type = type;
+  }
+
+  @Override
+  public String toString() {
+    return getAtomTypeString(type);
+  }
+
+  /**
+   * An MP4 atom that is a leaf.
+   */
+  /* package */ static final class LeafAtom extends Atom {
+
+    /**
+     * The atom data.
+     */
+    public final ParsableByteArray data;
+
+    /**
+     * @param type The type of the atom.
+     * @param data The atom data.
+     */
+    public LeafAtom(int type, ParsableByteArray data) {
+      super(type);
+      this.data = data;
+    }
+
+  }
+
+  /**
+   * An MP4 atom that has child atoms.
+   */
+  /* package */ static final class ContainerAtom extends Atom {
+
+    public final long endPosition;
+    public final List<LeafAtom> leafChildren;
+    public final List<ContainerAtom> containerChildren;
+
+    /**
+     * @param type The type of the atom.
+     * @param endPosition The position of the first byte after the end of the atom.
+     */
+    public ContainerAtom(int type, long endPosition) {
+      super(type);
+      this.endPosition = endPosition;
+      leafChildren = new ArrayList<>();
+      containerChildren = new ArrayList<>();
+    }
+
+    /**
+     * Adds a child leaf to this container.
+     *
+     * @param atom The child to add.
+     */
+    public void add(LeafAtom atom) {
+      leafChildren.add(atom);
+    }
+
+    /**
+     * Adds a child container to this container.
+     *
+     * @param atom The child to add.
+     */
+    public void add(ContainerAtom atom) {
+      containerChildren.add(atom);
+    }
+
+    /**
+     * Returns the child leaf of the given type.
+     * <p>
+     * If no child exists with the given type then null is returned. If multiple children exist with
+     * the given type then the first one to have been added is returned.
+     *
+     * @param type The leaf type.
+     * @return The child leaf of the given type, or null if no such child exists.
+     */
+    public LeafAtom getLeafAtomOfType(int type) {
+      int childrenSize = leafChildren.size();
+      for (int i = 0; i < childrenSize; i++) {
+        LeafAtom atom = leafChildren.get(i);
+        if (atom.type == type) {
+          return atom;
+        }
+      }
+      return null;
+    }
+
+    /**
+     * Returns the child container of the given type.
+     * <p>
+     * If no child exists with the given type then null is returned. If multiple children exist with
+     * the given type then the first one to have been added is returned.
+     *
+     * @param type The container type.
+     * @return The child container of the given type, or null if no such child exists.
+     */
+    public ContainerAtom getContainerAtomOfType(int type) {
+      int childrenSize = containerChildren.size();
+      for (int i = 0; i < childrenSize; i++) {
+        ContainerAtom atom = containerChildren.get(i);
+        if (atom.type == type) {
+          return atom;
+        }
+      }
+      return null;
+    }
+
+    /**
+     * Returns the total number of leaf/container children of this atom with the given type.
+     *
+     * @param type The type of child atoms to count.
+     * @return The total number of leaf/container children of this atom with the given type.
+     */
+    public int getChildAtomOfTypeCount(int type) {
+      int count = 0;
+      int size = leafChildren.size();
+      for (int i = 0; i < size; i++) {
+        LeafAtom atom = leafChildren.get(i);
+        if (atom.type == type) {
+          count++;
+        }
+      }
+      size = containerChildren.size();
+      for (int i = 0; i < size; i++) {
+        ContainerAtom atom = containerChildren.get(i);
+        if (atom.type == type) {
+          count++;
+        }
+      }
+      return count;
+    }
+
+    @Override
+    public String toString() {
+      return getAtomTypeString(type)
+          + " leaves: " + Arrays.toString(leafChildren.toArray())
+          + " containers: " + Arrays.toString(containerChildren.toArray());
+    }
+
+  }
+
+  /**
+   * Parses the version number out of the additional integer component of a full atom.
+   */
+  public static int parseFullAtomVersion(int fullAtomInt) {
+    return 0x000000FF & (fullAtomInt >> 24);
+  }
+
+  /**
+   * Parses the atom flags out of the additional integer component of a full atom.
+   */
+  public static int parseFullAtomFlags(int fullAtomInt) {
+    return 0x00FFFFFF & fullAtomInt;
+  }
+
+  /**
+   * Converts a numeric atom type to the corresponding four character string.
+   *
+   * @param type The numeric atom type.
+   * @return The corresponding four character string.
+   */
+  public static String getAtomTypeString(int type) {
+    return "" + (char) ((type >> 24) & 0xFF)
+        + (char) ((type >> 16) & 0xFF)
+        + (char) ((type >> 8) & 0xFF)
+        + (char) (type & 0xFF);
+  }
+
+}
diff --git a/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/AtomParsers.java b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/AtomParsers.java
new file mode 100755
index 0000000000..b5c345f204
--- /dev/null
+++ b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/AtomParsers.java
@@ -0,0 +1,1410 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.mpegh;
+
+import android.util.Log;
+import android.util.Pair;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.audio.Ac3Util;
+import com.google.android.exoplayer2.drm.DrmInitData;
+import com.google.android.exoplayer2.extractor.GaplessInfoHolder;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.CodecSpecificDataUtil;
+import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.Util;
+import com.google.android.exoplayer2.video.AvcConfig;
+import com.google.android.exoplayer2.video.HevcConfig;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+import static com.google.android.exoplayer2.util.MimeTypes.getMimeTypeFromMp4ObjectType;
+
+/**
+ * Utility methods for parsing MP4 format atom payloads according to ISO 14496-12.
+ */
+/* package */ final class AtomParsers {
+
+  private static final String TAG = "AtomParsers";
+
+  private static final int TYPE_vide = Util.getIntegerCodeForString("vide");
+  private static final int TYPE_soun = Util.getIntegerCodeForString("soun");
+  private static final int TYPE_text = Util.getIntegerCodeForString("text");
+  private static final int TYPE_sbtl = Util.getIntegerCodeForString("sbtl");
+  private static final int TYPE_subt = Util.getIntegerCodeForString("subt");
+  private static final int TYPE_clcp = Util.getIntegerCodeForString("clcp");
+  private static final int TYPE_meta = Util.getIntegerCodeForString("meta");
+
+  /**
+   * The threshold number of samples to trim from the start/end of an audio track when applying an
+   * edit below which gapless info can be used (rather than removing samples from the sample table).
+   */
+  private static final int MAX_GAPLESS_TRIM_SIZE_SAMPLES = 3;
+
+  /**
+   * Parses a trak atom (defined in 14496-12).
+   *
+   * @param trak Atom to decode.
+   * @param mvhd Movie header atom, used to get the timescale.
+   * @param duration The duration in units of the timescale declared in the mvhd atom, or
+   *     {@link C#TIME_UNSET} if the duration should be parsed from the tkhd atom.
+   * @param drmInitData {@link DrmInitData} to be included in the format.
+   * @param ignoreEditLists Whether to ignore any edit lists in the trak box.
+   * @param isQuickTime True for QuickTime media. False otherwise.
+   * @return A {@link Track} instance, or {@code null} if the track's type isn't supported.
+   */
+  public static Track parseTrak(Atom.ContainerAtom trak, Atom.LeafAtom mvhd, long duration,
+      DrmInitData drmInitData, boolean ignoreEditLists, boolean isQuickTime)
+      throws ParserException {
+    Atom.ContainerAtom mdia = trak.getContainerAtomOfType(Atom.TYPE_mdia);
+    int trackType = parseHdlr(mdia.getLeafAtomOfType(Atom.TYPE_hdlr).data);
+    if (trackType == C.TRACK_TYPE_UNKNOWN) {
+      return null;
+    }
+
+    TkhdData tkhdData = parseTkhd(trak.getLeafAtomOfType(Atom.TYPE_tkhd).data);
+    if (duration == C.TIME_UNSET) {
+      duration = tkhdData.duration;
+    }
+    long movieTimescale = parseMvhd(mvhd.data);
+    long durationUs;
+    if (duration == C.TIME_UNSET) {
+      durationUs = C.TIME_UNSET;
+    } else {
+      durationUs = Util.scaleLargeTimestamp(duration, C.MICROS_PER_SECOND, movieTimescale);
+    }
+    Atom.ContainerAtom stbl = mdia.getContainerAtomOfType(Atom.TYPE_minf)
+        .getContainerAtomOfType(Atom.TYPE_stbl);
+
+    Pair<Long, String> mdhdData = parseMdhd(mdia.getLeafAtomOfType(Atom.TYPE_mdhd).data);
+    StsdData stsdData = parseStsd(stbl.getLeafAtomOfType(Atom.TYPE_stsd).data, tkhdData.id,
+        tkhdData.rotationDegrees, mdhdData.second, drmInitData, isQuickTime);
+    long[] editListDurations = null;
+    long[] editListMediaTimes = null;
+    if (!ignoreEditLists) {
+      Pair<long[], long[]> edtsData = parseEdts(trak.getContainerAtomOfType(Atom.TYPE_edts));
+      editListDurations = edtsData.first;
+      editListMediaTimes = edtsData.second;
+    }
+    return stsdData.format == null ? null
+        : new Track(tkhdData.id, trackType, mdhdData.first, movieTimescale, durationUs,
+            stsdData.format, stsdData.requiredSampleTransformation, stsdData.trackEncryptionBoxes,
+            stsdData.nalUnitLengthFieldLength, editListDurations, editListMediaTimes);
+  }
+
+  /**
+   * Parses an stbl atom (defined in 14496-12).
+   *
+   * @param track Track to which this sample table corresponds.
+   * @param stblAtom stbl (sample table) atom to decode.
+   * @param gaplessInfoHolder Holder to populate with gapless playback information.
+   * @return Sample table described by the stbl atom.
+   * @throws ParserException If the resulting sample sequence does not contain a sync sample.
+   */
+  public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAtom,
+      GaplessInfoHolder gaplessInfoHolder) throws ParserException {
+    SampleSizeBox sampleSizeBox;
+    Atom.LeafAtom stszAtom = stblAtom.getLeafAtomOfType(Atom.TYPE_stsz);
+    if (stszAtom != null) {
+      sampleSizeBox = new StszSampleSizeBox(stszAtom);
+    } else {
+      Atom.LeafAtom stz2Atom = stblAtom.getLeafAtomOfType(Atom.TYPE_stz2);
+      if (stz2Atom == null) {
+        throw new ParserException("Track has no sample table size information");
+      }
+      sampleSizeBox = new Stz2SampleSizeBox(stz2Atom);
+    }
+
+    int sampleCount = sampleSizeBox.getSampleCount();
+    if (sampleCount == 0) {
+      return new TrackSampleTable(
+          new long[0], new int[0], 0, new long[0], new int[0], C.TIME_UNSET);
+    }
+
+    // Entries are byte offsets of chunks.
+    boolean chunkOffsetsAreLongs = false;
+    Atom.LeafAtom chunkOffsetsAtom = stblAtom.getLeafAtomOfType(Atom.TYPE_stco);
+    if (chunkOffsetsAtom == null) {
+      chunkOffsetsAreLongs = true;
+      chunkOffsetsAtom = stblAtom.getLeafAtomOfType(Atom.TYPE_co64);
+    }
+    ParsableByteArray chunkOffsets = chunkOffsetsAtom.data;
+    // Entries are (chunk number, number of samples per chunk, sample description index).
+    ParsableByteArray stsc = stblAtom.getLeafAtomOfType(Atom.TYPE_stsc).data;
+    // Entries are (number of samples, timestamp delta between those samples).
+    ParsableByteArray stts = stblAtom.getLeafAtomOfType(Atom.TYPE_stts).data;
+    // Entries are the indices of samples that are synchronization samples.
+    Atom.LeafAtom stssAtom = stblAtom.getLeafAtomOfType(Atom.TYPE_stss);
+    ParsableByteArray stss = stssAtom != null ? stssAtom.data : null;
+    // Entries are (number of samples, timestamp offset).
+    Atom.LeafAtom cttsAtom = stblAtom.getLeafAtomOfType(Atom.TYPE_ctts);
+    ParsableByteArray ctts = cttsAtom != null ? cttsAtom.data : null;
+
+    // Prepare to read chunk information.
+    ChunkIterator chunkIterator = new ChunkIterator(stsc, chunkOffsets, chunkOffsetsAreLongs);
+
+    // Prepare to read sample timestamps.
+    stts.setPosition(Atom.FULL_HEADER_SIZE);
+    int remainingTimestampDeltaChanges = stts.readUnsignedIntToInt() - 1;
+    int remainingSamplesAtTimestampDelta = stts.readUnsignedIntToInt();
+    int timestampDeltaInTimeUnits = stts.readUnsignedIntToInt();
+
+    // Prepare to read sample timestamp offsets, if ctts is present.
+    int remainingSamplesAtTimestampOffset = 0;
+    int remainingTimestampOffsetChanges = 0;
+    int timestampOffset = 0;
+    if (ctts != null) {
+      ctts.setPosition(Atom.FULL_HEADER_SIZE);
+      remainingTimestampOffsetChanges = ctts.readUnsignedIntToInt();
+    }
+
+    int nextSynchronizationSampleIndex = C.INDEX_UNSET;
+    int remainingSynchronizationSamples = 0;
+    if (stss != null) {
+      stss.setPosition(Atom.FULL_HEADER_SIZE);
+      remainingSynchronizationSamples = stss.readUnsignedIntToInt();
+      if (remainingSynchronizationSamples > 0) {
+        nextSynchronizationSampleIndex = stss.readUnsignedIntToInt() - 1;
+      } else {
+        // Ignore empty stss boxes, which causes all samples to be treated as sync samples.
+        stss = null;
+      }
+    }
+
+    // Fixed sample size raw audio may need to be rechunked.
+    boolean isFixedSampleSizeRawAudio =
+        sampleSizeBox.isFixedSampleSize()
+            && MimeTypes.AUDIO_RAW.equals(track.format.sampleMimeType)
+            && remainingTimestampDeltaChanges == 0
+            && remainingTimestampOffsetChanges == 0
+            && remainingSynchronizationSamples == 0;
+
+    long[] offsets;
+    int[] sizes;
+    int maximumSize = 0;
+    long[] timestamps;
+    int[] flags;
+    long timestampTimeUnits = 0;
+    long duration;
+
+    if (!isFixedSampleSizeRawAudio) {
+      offsets = new long[sampleCount];
+      sizes = new int[sampleCount];
+      timestamps = new long[sampleCount];
+      flags = new int[sampleCount];
+      long offset = 0;
+      int remainingSamplesInChunk = 0;
+
+      for (int i = 0; i < sampleCount; i++) {
+        // Advance to the next chunk if necessary.
+        while (remainingSamplesInChunk == 0) {
+          Assertions.checkState(chunkIterator.moveNext());
+          offset = chunkIterator.offset;
+          remainingSamplesInChunk = chunkIterator.numSamples;
+        }
+
+        // Add on the timestamp offset if ctts is present.
+        if (ctts != null) {
+          while (remainingSamplesAtTimestampOffset == 0 && remainingTimestampOffsetChanges > 0) {
+            remainingSamplesAtTimestampOffset = ctts.readUnsignedIntToInt();
+            // The BMFF spec (ISO 14496-12) states that sample offsets should be unsigned integers
+            // in version 0 ctts boxes, however some streams violate the spec and use signed
+            // integers instead. It's safe to always decode sample offsets as signed integers here,
+            // because unsigned integers will still be parsed correctly (unless their top bit is
+            // set, which is never true in practice because sample offsets are always small).
+            timestampOffset = ctts.readInt();
+            remainingTimestampOffsetChanges--;
+          }
+          remainingSamplesAtTimestampOffset--;
+        }
+
+        offsets[i] = offset;
+        sizes[i] = sampleSizeBox.readNextSampleSize();
+        if (sizes[i] > maximumSize) {
+          maximumSize = sizes[i];
+        }
+        timestamps[i] = timestampTimeUnits + timestampOffset;
+
+        // All samples are synchronization samples if the stss is not present.
+        flags[i] = stss == null ? C.BUFFER_FLAG_KEY_FRAME : 0;
+        if (i == nextSynchronizationSampleIndex) {
+          flags[i] = C.BUFFER_FLAG_KEY_FRAME;
+          remainingSynchronizationSamples--;
+          if (remainingSynchronizationSamples > 0) {
+            nextSynchronizationSampleIndex = stss.readUnsignedIntToInt() - 1;
+          }
+        }
+
+        // Add on the duration of this sample.
+        timestampTimeUnits += timestampDeltaInTimeUnits;
+        remainingSamplesAtTimestampDelta--;
+        if (remainingSamplesAtTimestampDelta == 0 && remainingTimestampDeltaChanges > 0) {
+          remainingSamplesAtTimestampDelta = stts.readUnsignedIntToInt();
+          // The BMFF spec (ISO 14496-12) states that sample deltas should be unsigned integers
+          // in stts boxes, however some streams violate the spec and use signed integers instead.
+          // See https://github.com/google/ExoPlayer/issues/3384. It's safe to always decode sample
+          // deltas as signed integers here, because unsigned integers will still be parsed
+          // correctly (unless their top bit is set, which is never true in practice because sample
+          // deltas are always small).
+          timestampDeltaInTimeUnits = stts.readInt();
+          remainingTimestampDeltaChanges--;
+        }
+
+        offset += sizes[i];
+        remainingSamplesInChunk--;
+      }
+      duration = timestampTimeUnits + timestampOffset;
+
+      Assertions.checkArgument(remainingSamplesAtTimestampOffset == 0);
+      // Remove trailing ctts entries with 0-valued sample counts.
+      while (remainingTimestampOffsetChanges > 0) {
+        Assertions.checkArgument(ctts.readUnsignedIntToInt() == 0);
+        ctts.readInt(); // Ignore offset.
+        remainingTimestampOffsetChanges--;
+      }
+
+      // If the stbl's child boxes are not consistent the container is malformed, but the stream may
+      // still be playable.
+      if (remainingSynchronizationSamples != 0 || remainingSamplesAtTimestampDelta != 0
+          || remainingSamplesInChunk != 0 || remainingTimestampDeltaChanges != 0) {
+        Log.w(TAG, "Inconsistent stbl box for track " + track.id
+            + ": remainingSynchronizationSamples " + remainingSynchronizationSamples
+            + ", remainingSamplesAtTimestampDelta " + remainingSamplesAtTimestampDelta
+            + ", remainingSamplesInChunk " + remainingSamplesInChunk
+            + ", remainingTimestampDeltaChanges " + remainingTimestampDeltaChanges);
+      }
+    } else {
+      long[] chunkOffsetsBytes = new long[chunkIterator.length];
+      int[] chunkSampleCounts = new int[chunkIterator.length];
+      while (chunkIterator.moveNext()) {
+        chunkOffsetsBytes[chunkIterator.index] = chunkIterator.offset;
+        chunkSampleCounts[chunkIterator.index] = chunkIterator.numSamples;
+      }
+      int fixedSampleSize =
+          Util.getPcmFrameSize(track.format.pcmEncoding, track.format.channelCount);
+      FixedSampleSizeRechunker.Results rechunkedResults = FixedSampleSizeRechunker.rechunk(
+          fixedSampleSize, chunkOffsetsBytes, chunkSampleCounts, timestampDeltaInTimeUnits);
+      offsets = rechunkedResults.offsets;
+      sizes = rechunkedResults.sizes;
+      maximumSize = rechunkedResults.maximumSize;
+      timestamps = rechunkedResults.timestamps;
+      flags = rechunkedResults.flags;
+      duration = rechunkedResults.duration;
+    }
+    long durationUs = Util.scaleLargeTimestamp(duration, C.MICROS_PER_SECOND, track.timescale);
+
+    if (track.editListDurations == null || gaplessInfoHolder.hasGaplessInfo()) {
+      // There is no edit list, or we are ignoring it as we already have gapless metadata to apply.
+      // This implementation does not support applying both gapless metadata and an edit list.
+      Util.scaleLargeTimestampsInPlace(timestamps, C.MICROS_PER_SECOND, track.timescale);
+      return new TrackSampleTable(offsets, sizes, maximumSize, timestamps, flags, durationUs);
+    }
+
+    // See the BMFF spec (ISO 14496-12) subsection 8.6.6. Edit lists that require prerolling from a
+    // sync sample after reordering are not supported. Partial audio sample truncation is only
+    // supported in edit lists with one edit that removes less than MAX_GAPLESS_TRIM_SIZE_SAMPLES
+    // samples from the start/end of the track. This implementation handles simple
+    // discarding/delaying of samples. The extractor may place further restrictions on what edited
+    // streams are playable.
+
+    if (track.editListDurations.length == 1
+        && track.type == C.TRACK_TYPE_AUDIO
+        && timestamps.length >= 2) {
+      long editStartTime = track.editListMediaTimes[0];
+      long editEndTime = editStartTime + Util.scaleLargeTimestamp(track.editListDurations[0],
+          track.timescale, track.movieTimescale);
+      if (canApplyEditWithGaplessInfo(timestamps, duration, editStartTime, editEndTime)) {
+        long paddingTimeUnits = duration - editEndTime;
+        long encoderDelay = Util.scaleLargeTimestamp(editStartTime - timestamps[0],
+            track.format.sampleRate, track.timescale);
+        long encoderPadding = Util.scaleLargeTimestamp(paddingTimeUnits,
+            track.format.sampleRate, track.timescale);
+        if ((encoderDelay != 0 || encoderPadding != 0) && encoderDelay <= Integer.MAX_VALUE
+            && encoderPadding <= Integer.MAX_VALUE) {
+          gaplessInfoHolder.encoderDelay = (int) encoderDelay;
+          gaplessInfoHolder.encoderPadding = (int) encoderPadding;
+          Util.scaleLargeTimestampsInPlace(timestamps, C.MICROS_PER_SECOND, track.timescale);
+          return new TrackSampleTable(offsets, sizes, maximumSize, timestamps, flags, durationUs);
+        }
+      }
+    }
+
+    if (track.editListDurations.length == 1 && track.editListDurations[0] == 0) {
+      // The current version of the spec leaves handling of an edit with zero segment_duration in
+      // unfragmented files open to interpretation. We handle this as a special case and include all
+      // samples in the edit.
+      long editStartTime = track.editListMediaTimes[0];
+      for (int i = 0; i < timestamps.length; i++) {
+        timestamps[i] =
+            Util.scaleLargeTimestamp(
+                timestamps[i] - editStartTime, C.MICROS_PER_SECOND, track.timescale);
+      }
+      durationUs =
+          Util.scaleLargeTimestamp(duration - editStartTime, C.MICROS_PER_SECOND, track.timescale);
+      return new TrackSampleTable(offsets, sizes, maximumSize, timestamps, flags, durationUs);
+    }
+
+    // Omit any sample at the end point of an edit for audio tracks.
+    boolean omitClippedSample = track.type == C.TRACK_TYPE_AUDIO;
+
+    // Count the number of samples after applying edits.
+    int editedSampleCount = 0;
+    int nextSampleIndex = 0;
+    boolean copyMetadata = false;
+    for (int i = 0; i < track.editListDurations.length; i++) {
+      long editMediaTime = track.editListMediaTimes[i];
+      if (editMediaTime != -1) {
+        long editDuration =
+            Util.scaleLargeTimestamp(
+                track.editListDurations[i], track.timescale, track.movieTimescale);
+        int startIndex = Util.binarySearchCeil(timestamps, editMediaTime, true, true);
+        int endIndex =
+            Util.binarySearchCeil(
+                timestamps, editMediaTime + editDuration, omitClippedSample, false);
+        editedSampleCount += endIndex - startIndex;
+        copyMetadata |= nextSampleIndex != startIndex;
+        nextSampleIndex = endIndex;
+      }
+    }
+    copyMetadata |= editedSampleCount != sampleCount;
+
+    // Calculate edited sample timestamps and update the corresponding metadata arrays.
+    long[] editedOffsets = copyMetadata ? new long[editedSampleCount] : offsets;
+    int[] editedSizes = copyMetadata ? new int[editedSampleCount] : sizes;
+    int editedMaximumSize = copyMetadata ? 0 : maximumSize;
+    int[] editedFlags = copyMetadata ? new int[editedSampleCount] : flags;
+    long[] editedTimestamps = new long[editedSampleCount];
+    long pts = 0;
+    int sampleIndex = 0;
+    for (int i = 0; i < track.editListDurations.length; i++) {
+      long editMediaTime = track.editListMediaTimes[i];
+      long editDuration = track.editListDurations[i];
+      if (editMediaTime != -1) {
+        long endMediaTime =
+            editMediaTime
+                + Util.scaleLargeTimestamp(editDuration, track.timescale, track.movieTimescale);
+        int startIndex = Util.binarySearchCeil(timestamps, editMediaTime, true, true);
+        int endIndex = Util.binarySearchCeil(timestamps, endMediaTime, omitClippedSample, false);
+        if (copyMetadata) {
+          int count = endIndex - startIndex;
+          System.arraycopy(offsets, startIndex, editedOffsets, sampleIndex, count);
+          System.arraycopy(sizes, startIndex, editedSizes, sampleIndex, count);
+          System.arraycopy(flags, startIndex, editedFlags, sampleIndex, count);
+        }
+        for (int j = startIndex; j < endIndex; j++) {
+          long ptsUs = Util.scaleLargeTimestamp(pts, C.MICROS_PER_SECOND, track.movieTimescale);
+          long timeInSegmentUs =
+              Util.scaleLargeTimestamp(
+                  timestamps[j] - editMediaTime, C.MICROS_PER_SECOND, track.timescale);
+          editedTimestamps[sampleIndex] = ptsUs + timeInSegmentUs;
+          if (copyMetadata && editedSizes[sampleIndex] > editedMaximumSize) {
+            editedMaximumSize = sizes[j];
+          }
+          sampleIndex++;
+        }
+      }
+      pts += editDuration;
+    }
+    long editedDurationUs = Util.scaleLargeTimestamp(pts, C.MICROS_PER_SECOND, track.timescale);
+
+    boolean hasSyncSample = false;
+    for (int i = 0; i < editedFlags.length && !hasSyncSample; i++) {
+      hasSyncSample |= (editedFlags[i] & C.BUFFER_FLAG_KEY_FRAME) != 0;
+    }
+    if (!hasSyncSample) {
+      // We don't support edit lists where the edited sample sequence doesn't contain a sync sample.
+      // Such edit lists are often (although not always) broken, so we ignore it and continue.
+      Log.w(TAG, "Ignoring edit list: Edited sample sequence does not contain a sync sample.");
+      Util.scaleLargeTimestampsInPlace(timestamps, C.MICROS_PER_SECOND, track.timescale);
+      return new TrackSampleTable(offsets, sizes, maximumSize, timestamps, flags, durationUs);
+    }
+
+    return new TrackSampleTable(
+        editedOffsets,
+        editedSizes,
+        editedMaximumSize,
+        editedTimestamps,
+        editedFlags,
+        editedDurationUs);
+  }
+
+  /**
+   * Parses a udta atom.
+   *
+   * @param udtaAtom The udta (user data) atom to decode.
+   * @param isQuickTime True for QuickTime media. False otherwise.
+   * @return Parsed metadata, or null.
+   */
+  public static Metadata parseUdta(Atom.LeafAtom udtaAtom, boolean isQuickTime) {
+    if (isQuickTime) {
+      // Meta boxes are regular boxes rather than full boxes in QuickTime. For now, don't try and
+      // decode one.
+      return null;
+    }
+    ParsableByteArray udtaData = udtaAtom.data;
+    udtaData.setPosition(Atom.HEADER_SIZE);
+    while (udtaData.bytesLeft() >= Atom.HEADER_SIZE) {
+      int atomPosition = udtaData.getPosition();
+      int atomSize = udtaData.readInt();
+      int atomType = udtaData.readInt();
+      if (atomType == Atom.TYPE_meta) {
+        udtaData.setPosition(atomPosition);
+        return parseMetaAtom(udtaData, atomPosition + atomSize);
+      }
+      udtaData.skipBytes(atomSize - Atom.HEADER_SIZE);
+    }
+    return null;
+  }
+
+  private static Metadata parseMetaAtom(ParsableByteArray meta, int limit) {
+    meta.skipBytes(Atom.FULL_HEADER_SIZE);
+    while (meta.getPosition() < limit) {
+      int atomPosition = meta.getPosition();
+      int atomSize = meta.readInt();
+      int atomType = meta.readInt();
+      if (atomType == Atom.TYPE_ilst) {
+        meta.setPosition(atomPosition);
+        return parseIlst(meta, atomPosition + atomSize);
+      }
+      meta.skipBytes(atomSize - Atom.HEADER_SIZE);
+    }
+    return null;
+  }
+
+  private static Metadata parseIlst(ParsableByteArray ilst, int limit) {
+    ilst.skipBytes(Atom.HEADER_SIZE);
+    ArrayList<Metadata.Entry> entries = new ArrayList<>();
+    while (ilst.getPosition() < limit) {
+      Metadata.Entry entry = MetadataUtil.parseIlstElement(ilst);
+      if (entry != null) {
+        entries.add(entry);
+      }
+    }
+    return entries.isEmpty() ? null : new Metadata(entries);
+  }
+
+  /**
+   * Parses a mvhd atom (defined in 14496-12), returning the timescale for the movie.
+   *
+   * @param mvhd Contents of the mvhd atom to be parsed.
+   * @return Timescale for the movie.
+   */
+  private static long parseMvhd(ParsableByteArray mvhd) {
+    mvhd.setPosition(Atom.HEADER_SIZE);
+    int fullAtom = mvhd.readInt();
+    int version = Atom.parseFullAtomVersion(fullAtom);
+    mvhd.skipBytes(version == 0 ? 8 : 16);
+    return mvhd.readUnsignedInt();
+  }
+
+  /**
+   * Parses a tkhd atom (defined in 14496-12).
+   *
+   * @return An object containing the parsed data.
+   */
+  private static TkhdData parseTkhd(ParsableByteArray tkhd) {
+    tkhd.setPosition(Atom.HEADER_SIZE);
+    int fullAtom = tkhd.readInt();
+    int version = Atom.parseFullAtomVersion(fullAtom);
+
+    tkhd.skipBytes(version == 0 ? 8 : 16);
+    int trackId = tkhd.readInt();
+
+    tkhd.skipBytes(4);
+    boolean durationUnknown = true;
+    int durationPosition = tkhd.getPosition();
+    int durationByteCount = version == 0 ? 4 : 8;
+    for (int i = 0; i < durationByteCount; i++) {
+      if (tkhd.data[durationPosition + i] != -1) {
+        durationUnknown = false;
+        break;
+      }
+    }
+    long duration;
+    if (durationUnknown) {
+      tkhd.skipBytes(durationByteCount);
+      duration = C.TIME_UNSET;
+    } else {
+      duration = version == 0 ? tkhd.readUnsignedInt() : tkhd.readUnsignedLongToLong();
+      if (duration == 0) {
+        // 0 duration normally indicates that the file is fully fragmented (i.e. all of the media
+        // samples are in fragments). Treat as unknown.
+        duration = C.TIME_UNSET;
+      }
+    }
+
+    tkhd.skipBytes(16);
+    int a00 = tkhd.readInt();
+    int a01 = tkhd.readInt();
+    tkhd.skipBytes(4);
+    int a10 = tkhd.readInt();
+    int a11 = tkhd.readInt();
+
+    int rotationDegrees;
+    int fixedOne = 65536;
+    if (a00 == 0 && a01 == fixedOne && a10 == -fixedOne && a11 == 0) {
+      rotationDegrees = 90;
+    } else if (a00 == 0 && a01 == -fixedOne && a10 == fixedOne && a11 == 0) {
+      rotationDegrees = 270;
+    } else if (a00 == -fixedOne && a01 == 0 && a10 == 0 && a11 == -fixedOne) {
+      rotationDegrees = 180;
+    } else {
+      // Only 0, 90, 180 and 270 are supported. Treat anything else as 0.
+      rotationDegrees = 0;
+    }
+
+    return new TkhdData(trackId, duration, rotationDegrees);
+  }
+
+  /**
+   * Parses an hdlr atom.
+   *
+   * @param hdlr The hdlr atom to decode.
+   * @return The track type.
+   */
+  private static int parseHdlr(ParsableByteArray hdlr) {
+    hdlr.setPosition(Atom.FULL_HEADER_SIZE + 4);
+    int trackType = hdlr.readInt();
+    if (trackType == TYPE_soun) {
+      return C.TRACK_TYPE_AUDIO;
+    } else if (trackType == TYPE_vide) {
+      return C.TRACK_TYPE_VIDEO;
+    } else if (trackType == TYPE_text || trackType == TYPE_sbtl || trackType == TYPE_subt
+        || trackType == TYPE_clcp) {
+      return C.TRACK_TYPE_TEXT;
+    } else if (trackType == TYPE_meta) {
+      return C.TRACK_TYPE_METADATA;
+    } else {
+      return C.TRACK_TYPE_UNKNOWN;
+    }
+  }
+
+  /**
+   * Parses an mdhd atom (defined in 14496-12).
+   *
+   * @param mdhd The mdhd atom to decode.
+   * @return A pair consisting of the media timescale defined as the number of time units that pass
+   * in one second, and the language code.
+   */
+  private static Pair<Long, String> parseMdhd(ParsableByteArray mdhd) {
+    mdhd.setPosition(Atom.HEADER_SIZE);
+    int fullAtom = mdhd.readInt();
+    int version = Atom.parseFullAtomVersion(fullAtom);
+    mdhd.skipBytes(version == 0 ? 8 : 16);
+    long timescale = mdhd.readUnsignedInt();
+    mdhd.skipBytes(version == 0 ? 4 : 8);
+    int languageCode = mdhd.readUnsignedShort();
+    String language = "" + (char) (((languageCode >> 10) & 0x1F) + 0x60)
+        + (char) (((languageCode >> 5) & 0x1F) + 0x60)
+        + (char) (((languageCode) & 0x1F) + 0x60);
+    return Pair.create(timescale, language);
+  }
+
+  /**
+   * Parses a stsd atom (defined in 14496-12).
+   *
+   * @param stsd The stsd atom to decode.
+   * @param trackId The track's identifier in its container.
+   * @param rotationDegrees The rotation of the track in degrees.
+   * @param language The language of the track.
+   * @param drmInitData {@link DrmInitData} to be included in the format.
+   * @param isQuickTime True for QuickTime media. False otherwise.
+   * @return An object containing the parsed data.
+   */
+  private static StsdData parseStsd(ParsableByteArray stsd, int trackId, int rotationDegrees,
+      String language, DrmInitData drmInitData, boolean isQuickTime) throws ParserException {
+    stsd.setPosition(Atom.FULL_HEADER_SIZE);
+    int numberOfEntries = stsd.readInt();
+    StsdData out = new StsdData(numberOfEntries);
+    for (int i = 0; i < numberOfEntries; i++) {
+      int childStartPosition = stsd.getPosition();
+      int childAtomSize = stsd.readInt();
+      Assertions.checkArgument(childAtomSize > 0, "childAtomSize should be positive");
+      int childAtomType = stsd.readInt();
+      if (childAtomType == Atom.TYPE_avc1 || childAtomType == Atom.TYPE_avc3
+          || childAtomType == Atom.TYPE_encv || childAtomType == Atom.TYPE_mp4v
+          || childAtomType == Atom.TYPE_hvc1 || childAtomType == Atom.TYPE_hev1
+          || childAtomType == Atom.TYPE_s263 || childAtomType == Atom.TYPE_vp08
+          || childAtomType == Atom.TYPE_vp09) {
+        parseVideoSampleEntry(stsd, childAtomType, childStartPosition, childAtomSize, trackId,
+            rotationDegrees, drmInitData, out, i);
+      } else if (childAtomType == Atom.TYPE_mp4a || childAtomType == Atom.TYPE_enca
+          || childAtomType == Atom.TYPE_ac_3 || childAtomType == Atom.TYPE_ec_3
+          || childAtomType == Atom.TYPE_dtsc || childAtomType == Atom.TYPE_dtse
+          || childAtomType == Atom.TYPE_dtsh || childAtomType == Atom.TYPE_dtsl
+          || childAtomType == Atom.TYPE_samr || childAtomType == Atom.TYPE_sawb
+          || childAtomType == Atom.TYPE_lpcm || childAtomType == Atom.TYPE_sowt
+          || childAtomType == Atom.TYPE__mp3 || childAtomType == Atom.TYPE_alac
+          || childAtomType == Atom.TYPE_mha1) {
+        parseAudioSampleEntry(stsd, childAtomType, childStartPosition, childAtomSize, trackId,
+            language, isQuickTime, drmInitData, out, i);
+      } else if (childAtomType == Atom.TYPE_TTML || childAtomType == Atom.TYPE_tx3g
+          || childAtomType == Atom.TYPE_wvtt || childAtomType == Atom.TYPE_stpp
+          || childAtomType == Atom.TYPE_c608) {
+        parseTextSampleEntry(stsd, childAtomType, childStartPosition, childAtomSize, trackId,
+            language, out);
+      } else if (childAtomType == Atom.TYPE_camm) {
+        out.format = Format.createSampleFormat(Integer.toString(trackId),
+            MimeTypes.APPLICATION_CAMERA_MOTION, null, Format.NO_VALUE, null);
+      }
+      stsd.setPosition(childStartPosition + childAtomSize);
+    }
+    return out;
+  }
+
+  private static void parseTextSampleEntry(ParsableByteArray parent, int atomType, int position,
+      int atomSize, int trackId, String language, StsdData out) throws ParserException {
+    parent.setPosition(position + Atom.HEADER_SIZE + StsdData.STSD_HEADER_SIZE);
+
+    // Default values.
+    List<byte[]> initializationData = null;
+    long subsampleOffsetUs = Format.OFFSET_SAMPLE_RELATIVE;
+
+    String mimeType;
+    if (atomType == Atom.TYPE_TTML) {
+      mimeType = MimeTypes.APPLICATION_TTML;
+    } else if (atomType == Atom.TYPE_tx3g) {
+      mimeType = MimeTypes.APPLICATION_TX3G;
+      int sampleDescriptionLength = atomSize - Atom.HEADER_SIZE - 8;
+      byte[] sampleDescriptionData = new byte[sampleDescriptionLength];
+      parent.readBytes(sampleDescriptionData, 0, sampleDescriptionLength);
+      initializationData = Collections.singletonList(sampleDescriptionData);
+    } else if (atomType == Atom.TYPE_wvtt) {
+      mimeType = MimeTypes.APPLICATION_MP4VTT;
+    } else if (atomType == Atom.TYPE_stpp) {
+      mimeType = MimeTypes.APPLICATION_TTML;
+      subsampleOffsetUs = 0; // Subsample timing is absolute.
+    } else if (atomType == Atom.TYPE_c608) {
+      // Defined by the QuickTime File Format specification.
+      mimeType = MimeTypes.APPLICATION_MP4CEA608;
+      out.requiredSampleTransformation = Track.TRANSFORMATION_CEA608_CDAT;
+    } else {
+      // Never happens.
+      throw new IllegalStateException();
+    }
+
+    out.format = Format.createTextSampleFormat(Integer.toString(trackId), mimeType, null,
+        Format.NO_VALUE, 0, language, Format.NO_VALUE, null, subsampleOffsetUs, initializationData);
+  }
+
+  private static void parseVideoSampleEntry(ParsableByteArray parent, int atomType, int position,
+      int size, int trackId, int rotationDegrees, DrmInitData drmInitData, StsdData out,
+      int entryIndex) throws ParserException {
+    parent.setPosition(position + Atom.HEADER_SIZE + StsdData.STSD_HEADER_SIZE);
+
+    parent.skipBytes(16);
+    int width = parent.readUnsignedShort();
+    int height = parent.readUnsignedShort();
+    boolean pixelWidthHeightRatioFromPasp = false;
+    float pixelWidthHeightRatio = 1;
+    parent.skipBytes(50);
+
+    int childPosition = parent.getPosition();
+    if (atomType == Atom.TYPE_encv) {
+      Pair<Integer, TrackEncryptionBox> sampleEntryEncryptionData = parseSampleEntryEncryptionData(
+          parent, position, size);
+      if (sampleEntryEncryptionData != null) {
+        atomType = sampleEntryEncryptionData.first;
+        drmInitData = drmInitData == null ? null
+            : drmInitData.copyWithSchemeType(sampleEntryEncryptionData.second.schemeType);
+        out.trackEncryptionBoxes[entryIndex] = sampleEntryEncryptionData.second;
+      }
+      parent.setPosition(childPosition);
+    }
+    // TODO: Uncomment when [Internal: b/63092960] is fixed.
+    // else {
+    //   drmInitData = null;
+    // }
+
+    List<byte[]> initializationData = null;
+    String mimeType = null;
+    byte[] projectionData = null;
+    @C.StereoMode
+    int stereoMode = Format.NO_VALUE;
+    while (childPosition - position < size) {
+      parent.setPosition(childPosition);
+      int childStartPosition = parent.getPosition();
+      int childAtomSize = parent.readInt();
+      if (childAtomSize == 0 && parent.getPosition() - position == size) {
+        // Handle optional terminating four zero bytes in MOV files.
+        break;
+      }
+      Assertions.checkArgument(childAtomSize > 0, "childAtomSize should be positive");
+      int childAtomType = parent.readInt();
+      if (childAtomType == Atom.TYPE_avcC) {
+        Assertions.checkState(mimeType == null);
+        mimeType = MimeTypes.VIDEO_H264;
+        parent.setPosition(childStartPosition + Atom.HEADER_SIZE);
+        AvcConfig avcConfig = AvcConfig.parse(parent);
+        initializationData = avcConfig.initializationData;
+        out.nalUnitLengthFieldLength = avcConfig.nalUnitLengthFieldLength;
+        if (!pixelWidthHeightRatioFromPasp) {
+          pixelWidthHeightRatio = avcConfig.pixelWidthAspectRatio;
+        }
+      } else if (childAtomType == Atom.TYPE_hvcC) {
+        Assertions.checkState(mimeType == null);
+        mimeType = MimeTypes.VIDEO_H265;
+        parent.setPosition(childStartPosition + Atom.HEADER_SIZE);
+        HevcConfig hevcConfig = HevcConfig.parse(parent);
+        initializationData = hevcConfig.initializationData;
+        out.nalUnitLengthFieldLength = hevcConfig.nalUnitLengthFieldLength;
+      } else if (childAtomType == Atom.TYPE_vpcC) {
+        Assertions.checkState(mimeType == null);
+        mimeType = (atomType == Atom.TYPE_vp08) ? MimeTypes.VIDEO_VP8 : MimeTypes.VIDEO_VP9;
+      } else if (childAtomType == Atom.TYPE_d263) {
+        Assertions.checkState(mimeType == null);
+        mimeType = MimeTypes.VIDEO_H263;
+      } else if (childAtomType == Atom.TYPE_esds) {
+        Assertions.checkState(mimeType == null);
+        Pair<String, byte[]> mimeTypeAndInitializationData =
+            parseEsdsFromParent(parent, childStartPosition);
+        mimeType = mimeTypeAndInitializationData.first;
+        initializationData = Collections.singletonList(mimeTypeAndInitializationData.second);
+      } else if (childAtomType == Atom.TYPE_pasp) {
+        pixelWidthHeightRatio = parsePaspFromParent(parent, childStartPosition);
+        pixelWidthHeightRatioFromPasp = true;
+      } else if (childAtomType == Atom.TYPE_sv3d) {
+        projectionData = parseProjFromParent(parent, childStartPosition, childAtomSize);
+      } else if (childAtomType == Atom.TYPE_st3d) {
+        int version = parent.readUnsignedByte();
+        parent.skipBytes(3); // Flags.
+        if (version == 0) {
+          int layout = parent.readUnsignedByte();
+          switch (layout) {
+            case 0:
+              stereoMode = C.STEREO_MODE_MONO;
+              break;
+            case 1:
+              stereoMode = C.STEREO_MODE_TOP_BOTTOM;
+              break;
+            case 2:
+              stereoMode = C.STEREO_MODE_LEFT_RIGHT;
+              break;
+            case 3:
+              stereoMode = C.STEREO_MODE_STEREO_MESH;
+              break;
+            default:
+              break;
+          }
+        }
+      }
+      childPosition += childAtomSize;
+    }
+
+    // If the media type was not recognized, ignore the track.
+    if (mimeType == null) {
+      return;
+    }
+
+    out.format = Format.createVideoSampleFormat(Integer.toString(trackId), mimeType, null,
+        Format.NO_VALUE, Format.NO_VALUE, width, height, Format.NO_VALUE, initializationData,
+        rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode, null, drmInitData);
+  }
+
+  /**
+   * Parses the edts atom (defined in 14496-12 subsection 8.6.5).
+   *
+   * @param edtsAtom edts (edit box) atom to decode.
+   * @return Pair of edit list durations and edit list media times, or a pair of nulls if they are
+   *     not present.
+   */
+  private static Pair<long[], long[]> parseEdts(Atom.ContainerAtom edtsAtom) {
+    Atom.LeafAtom elst;
+    if (edtsAtom == null || (elst = edtsAtom.getLeafAtomOfType(Atom.TYPE_elst)) == null) {
+      return Pair.create(null, null);
+    }
+    ParsableByteArray elstData = elst.data;
+    elstData.setPosition(Atom.HEADER_SIZE);
+    int fullAtom = elstData.readInt();
+    int version = Atom.parseFullAtomVersion(fullAtom);
+    int entryCount = elstData.readUnsignedIntToInt();
+    long[] editListDurations = new long[entryCount];
+    long[] editListMediaTimes = new long[entryCount];
+    for (int i = 0; i < entryCount; i++) {
+      editListDurations[i] =
+          version == 1 ? elstData.readUnsignedLongToLong() : elstData.readUnsignedInt();
+      editListMediaTimes[i] = version == 1 ? elstData.readLong() : elstData.readInt();
+      int mediaRateInteger = elstData.readShort();
+      if (mediaRateInteger != 1) {
+        // The extractor does not handle dwell edits (mediaRateInteger == 0).
+        throw new IllegalArgumentException("Unsupported media rate.");
+      }
+      elstData.skipBytes(2);
+    }
+    return Pair.create(editListDurations, editListMediaTimes);
+  }
+
+  private static float parsePaspFromParent(ParsableByteArray parent, int position) {
+    parent.setPosition(position + Atom.HEADER_SIZE);
+    int hSpacing = parent.readUnsignedIntToInt();
+    int vSpacing = parent.readUnsignedIntToInt();
+    return (float) hSpacing / vSpacing;
+  }
+
+  private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType, int position,
+      int size, int trackId, String language, boolean isQuickTime, DrmInitData drmInitData,
+      StsdData out, int entryIndex) throws ParserException {
+    parent.setPosition(position + Atom.HEADER_SIZE + StsdData.STSD_HEADER_SIZE);
+
+    int quickTimeSoundDescriptionVersion = 0;
+    if (isQuickTime) {
+      quickTimeSoundDescriptionVersion = parent.readUnsignedShort();
+      parent.skipBytes(6);
+    } else {
+      parent.skipBytes(8);
+    }
+
+    int channelCount;
+    int sampleRate;
+
+    if (quickTimeSoundDescriptionVersion == 0 || quickTimeSoundDescriptionVersion == 1) {
+      channelCount = parent.readUnsignedShort();
+      parent.skipBytes(6);  // sampleSize, compressionId, packetSize.
+      sampleRate = parent.readUnsignedFixedPoint1616();
+
+      if (quickTimeSoundDescriptionVersion == 1) {
+        parent.skipBytes(16);
+      }
+    } else if (quickTimeSoundDescriptionVersion == 2) {
+      parent.skipBytes(16);  // always[3,16,Minus2,0,65536], sizeOfStructOnly
+
+      sampleRate = (int) Math.round(parent.readDouble());
+      channelCount = parent.readUnsignedIntToInt();
+
+      // Skip always7F000000, sampleSize, formatSpecificFlags, constBytesPerAudioPacket,
+      // constLPCMFramesPerAudioPacket.
+      parent.skipBytes(20);
+    } else {
+      // Unsupported version.
+      return;
+    }
+
+    int childPosition = parent.getPosition();
+    if (atomType == Atom.TYPE_enca) {
+      Pair<Integer, TrackEncryptionBox> sampleEntryEncryptionData = parseSampleEntryEncryptionData(
+          parent, position, size);
+      if (sampleEntryEncryptionData != null) {
+        atomType = sampleEntryEncryptionData.first;
+        drmInitData = drmInitData == null ? null
+            : drmInitData.copyWithSchemeType(sampleEntryEncryptionData.second.schemeType);
+        out.trackEncryptionBoxes[entryIndex] = sampleEntryEncryptionData.second;
+      }
+      parent.setPosition(childPosition);
+    }
+    // TODO: Uncomment when [Internal: b/63092960] is fixed.
+    // else {
+    //   drmInitData = null;
+    // }
+
+    // If the atom type determines a MIME type, set it immediately.
+    String mimeType = null;
+    if (atomType == Atom.TYPE_ac_3) {
+      mimeType = MimeTypes.AUDIO_AC3;
+    } else if (atomType == Atom.TYPE_ec_3) {
+      mimeType = MimeTypes.AUDIO_E_AC3;
+    } else if (atomType == Atom.TYPE_dtsc) {
+      mimeType = MimeTypes.AUDIO_DTS;
+    } else if (atomType == Atom.TYPE_dtsh || atomType == Atom.TYPE_dtsl) {
+      mimeType = MimeTypes.AUDIO_DTS_HD;
+    } else if (atomType == Atom.TYPE_dtse) {
+      mimeType = MimeTypes.AUDIO_DTS_EXPRESS;
+    } else if (atomType == Atom.TYPE_samr) {
+      mimeType = MimeTypes.AUDIO_AMR_NB;
+    } else if (atomType == Atom.TYPE_sawb) {
+      mimeType = MimeTypes.AUDIO_AMR_WB;
+    } else if (atomType == Atom.TYPE_lpcm || atomType == Atom.TYPE_sowt) {
+      mimeType = MimeTypes.AUDIO_RAW;
+    } else if (atomType == Atom.TYPE__mp3) {
+      mimeType = MimeTypes.AUDIO_MPEG;
+    } else if (atomType == Atom.TYPE_alac) {
+      mimeType = MimeTypes.AUDIO_ALAC;
+    } else if (atomType == Atom.TYPE_mha1) {
+      mimeType = MimeTypes.BASE_TYPE_AUDIO + "/mha1";
+    }
+
+    byte[] initializationData = null;
+    while (childPosition - position < size) {
+      parent.setPosition(childPosition);
+      int childAtomSize = parent.readInt();
+      Assertions.checkArgument(childAtomSize > 0, "childAtomSize should be positive");
+      int childAtomType = parent.readInt();
+      if (childAtomType == Atom.TYPE_esds || (isQuickTime && childAtomType == Atom.TYPE_wave)) {
+        int esdsAtomPosition = childAtomType == Atom.TYPE_esds ? childPosition
+            : findEsdsPosition(parent, childPosition, childAtomSize);
+        if (esdsAtomPosition != C.POSITION_UNSET) {
+          Pair<String, byte[]> mimeTypeAndInitializationData =
+              parseEsdsFromParent(parent, esdsAtomPosition);
+          mimeType = mimeTypeAndInitializationData.first;
+          initializationData = mimeTypeAndInitializationData.second;
+          if (MimeTypes.AUDIO_AAC.equals(mimeType)) {
+            // TODO: Do we really need to do this? See [Internal: b/10903778]
+            // Update sampleRate and channelCount from the AudioSpecificConfig initialization data.
+            Pair<Integer, Integer> audioSpecificConfig =
+                CodecSpecificDataUtil.parseAacAudioSpecificConfig(initializationData);
+            sampleRate = audioSpecificConfig.first;
+            channelCount = audioSpecificConfig.second;
+          }
+        }
+      } else if (childAtomType == Atom.TYPE_dac3) {
+        parent.setPosition(Atom.HEADER_SIZE + childPosition);
+        out.format = Ac3Util.parseAc3AnnexFFormat(parent, Integer.toString(trackId), language,
+            drmInitData);
+      } else if (childAtomType == Atom.TYPE_dec3) {
+        parent.setPosition(Atom.HEADER_SIZE + childPosition);
+        out.format = Ac3Util.parseEAc3AnnexFFormat(parent, Integer.toString(trackId), language,
+            drmInitData);
+      } else if (childAtomType == Atom.TYPE_ddts) {
+        out.format = Format.createAudioSampleFormat(Integer.toString(trackId), mimeType, null,
+            Format.NO_VALUE, Format.NO_VALUE, channelCount, sampleRate, null, drmInitData, 0,
+            language);
+      } else if (childAtomType == Atom.TYPE_alac) {
+        initializationData = new byte[childAtomSize];
+        parent.setPosition(childPosition);
+        parent.readBytes(initializationData, 0, childAtomSize);
+      } else if (childAtomType == Atom.TYPE_mhac) {
+        int mhaC_header_size = 4 /* mhaC size */ + 4 /* mhaC string */ + 3 /* version */ + 2 /* config size */;
+        int mhaC_size = childAtomSize - mhaC_header_size;
+        if (mhaC_size > 0) {
+          channelCount = 2;
+          sampleRate = 48000;
+          initializationData = new byte[mhaC_size];
+          parent.setPosition(childPosition + mhaC_header_size);
+          parent.readBytes(initializationData, 0, mhaC_size);
+        }
+      }
+      childPosition += childAtomSize;
+    }
+
+    if (out.format == null && mimeType != null) {
+      // TODO: Determine the correct PCM encoding.
+      @C.PcmEncoding int pcmEncoding =
+          MimeTypes.AUDIO_RAW.equals(mimeType) ? C.ENCODING_PCM_16BIT : Format.NO_VALUE;
+      out.format = Format.createAudioSampleFormat(Integer.toString(trackId), mimeType, null,
+          Format.NO_VALUE, Format.NO_VALUE, channelCount, sampleRate, pcmEncoding,
+          initializationData == null ? null : Collections.singletonList(initializationData),
+          drmInitData, 0, language);
+    }
+  }
+
+  /**
+   * Returns the position of the esds box within a parent, or {@link C#POSITION_UNSET} if no esds
+   * box is found
+   */
+  private static int findEsdsPosition(ParsableByteArray parent, int position, int size) {
+    int childAtomPosition = parent.getPosition();
+    while (childAtomPosition - position < size) {
+      parent.setPosition(childAtomPosition);
+      int childAtomSize = parent.readInt();
+      Assertions.checkArgument(childAtomSize > 0, "childAtomSize should be positive");
+      int childType = parent.readInt();
+      if (childType == Atom.TYPE_esds) {
+        return childAtomPosition;
+      }
+      childAtomPosition += childAtomSize;
+    }
+    return C.POSITION_UNSET;
+  }
+
+  /**
+   * Returns codec-specific initialization data contained in an esds box.
+   */
+  private static Pair<String, byte[]> parseEsdsFromParent(ParsableByteArray parent, int position) {
+    parent.setPosition(position + Atom.HEADER_SIZE + 4);
+    // Start of the ES_Descriptor (defined in 14496-1)
+    parent.skipBytes(1); // ES_Descriptor tag
+    parseExpandableClassSize(parent);
+    parent.skipBytes(2); // ES_ID
+
+    int flags = parent.readUnsignedByte();
+    if ((flags & 0x80 /* streamDependenceFlag */) != 0) {
+      parent.skipBytes(2);
+    }
+    if ((flags & 0x40 /* URL_Flag */) != 0) {
+      parent.skipBytes(parent.readUnsignedShort());
+    }
+    if ((flags & 0x20 /* OCRstreamFlag */) != 0) {
+      parent.skipBytes(2);
+    }
+
+    // Start of the DecoderConfigDescriptor (defined in 14496-1)
+    parent.skipBytes(1); // DecoderConfigDescriptor tag
+    parseExpandableClassSize(parent);
+
+    // Set the MIME type based on the object type indication (14496-1 table 5).
+    int objectTypeIndication = parent.readUnsignedByte();
+    String mimeType = getMimeTypeFromMp4ObjectType(objectTypeIndication);
+    if (MimeTypes.AUDIO_MPEG.equals(mimeType)
+        || MimeTypes.AUDIO_DTS.equals(mimeType)
+        || MimeTypes.AUDIO_DTS_HD.equals(mimeType)) {
+      return Pair.create(mimeType, null);
+    }
+
+    parent.skipBytes(12);
+
+    // Start of the DecoderSpecificInfo.
+    parent.skipBytes(1); // DecoderSpecificInfo tag
+    int initializationDataSize = parseExpandableClassSize(parent);
+    byte[] initializationData = new byte[initializationDataSize];
+    parent.readBytes(initializationData, 0, initializationDataSize);
+    return Pair.create(mimeType, initializationData);
+  }
+
+  /**
+   * Parses encryption data from an audio/video sample entry, returning a pair consisting of the
+   * unencrypted atom type and a {@link TrackEncryptionBox}. Null is returned if no common
+   * encryption sinf atom was present.
+   */
+  private static Pair<Integer, TrackEncryptionBox> parseSampleEntryEncryptionData(
+      ParsableByteArray parent, int position, int size) {
+    int childPosition = parent.getPosition();
+    while (childPosition - position < size) {
+      parent.setPosition(childPosition);
+      int childAtomSize = parent.readInt();
+      Assertions.checkArgument(childAtomSize > 0, "childAtomSize should be positive");
+      int childAtomType = parent.readInt();
+      if (childAtomType == Atom.TYPE_sinf) {
+        Pair<Integer, TrackEncryptionBox> result = parseCommonEncryptionSinfFromParent(parent,
+            childPosition, childAtomSize);
+        if (result != null) {
+          return result;
+        }
+      }
+      childPosition += childAtomSize;
+    }
+    return null;
+  }
+
+  /* package */ static Pair<Integer, TrackEncryptionBox> parseCommonEncryptionSinfFromParent(
+      ParsableByteArray parent, int position, int size) {
+    int childPosition = position + Atom.HEADER_SIZE;
+    int schemeInformationBoxPosition = C.POSITION_UNSET;
+    int schemeInformationBoxSize = 0;
+    String schemeType = null;
+    Integer dataFormat = null;
+    while (childPosition - position < size) {
+      parent.setPosition(childPosition);
+      int childAtomSize = parent.readInt();
+      int childAtomType = parent.readInt();
+      if (childAtomType == Atom.TYPE_frma) {
+        dataFormat = parent.readInt();
+      } else if (childAtomType == Atom.TYPE_schm) {
+        parent.skipBytes(4);
+        // Common encryption scheme_type values are defined in ISO/IEC 23001-7:2016, section 4.1.
+        schemeType = parent.readString(4);
+      } else if (childAtomType == Atom.TYPE_schi) {
+        schemeInformationBoxPosition = childPosition;
+        schemeInformationBoxSize = childAtomSize;
+      }
+      childPosition += childAtomSize;
+    }
+
+    if (C.CENC_TYPE_cenc.equals(schemeType) || C.CENC_TYPE_cbc1.equals(schemeType)
+        || C.CENC_TYPE_cens.equals(schemeType) || C.CENC_TYPE_cbcs.equals(schemeType)) {
+      Assertions.checkArgument(dataFormat != null, "frma atom is mandatory");
+      Assertions.checkArgument(schemeInformationBoxPosition != C.POSITION_UNSET,
+          "schi atom is mandatory");
+      TrackEncryptionBox encryptionBox = parseSchiFromParent(parent, schemeInformationBoxPosition,
+          schemeInformationBoxSize, schemeType);
+      Assertions.checkArgument(encryptionBox != null, "tenc atom is mandatory");
+      return Pair.create(dataFormat, encryptionBox);
+    } else {
+      return null;
+    }
+  }
+
+  private static TrackEncryptionBox parseSchiFromParent(ParsableByteArray parent, int position,
+      int size, String schemeType) {
+    int childPosition = position + Atom.HEADER_SIZE;
+    while (childPosition - position < size) {
+      parent.setPosition(childPosition);
+      int childAtomSize = parent.readInt();
+      int childAtomType = parent.readInt();
+      if (childAtomType == Atom.TYPE_tenc) {
+        int fullAtom = parent.readInt();
+        int version = Atom.parseFullAtomVersion(fullAtom);
+        parent.skipBytes(1); // reserved = 0.
+        int defaultCryptByteBlock = 0;
+        int defaultSkipByteBlock = 0;
+        if (version == 0) {
+          parent.skipBytes(1); // reserved = 0.
+        } else /* version 1 or greater */ {
+          int patternByte = parent.readUnsignedByte();
+          defaultCryptByteBlock = (patternByte & 0xF0) >> 4;
+          defaultSkipByteBlock = patternByte & 0x0F;
+        }
+        boolean defaultIsProtected = parent.readUnsignedByte() == 1;
+        int defaultPerSampleIvSize = parent.readUnsignedByte();
+        byte[] defaultKeyId = new byte[16];
+        parent.readBytes(defaultKeyId, 0, defaultKeyId.length);
+        byte[] constantIv = null;
+        if (defaultIsProtected && defaultPerSampleIvSize == 0) {
+          int constantIvSize = parent.readUnsignedByte();
+          constantIv = new byte[constantIvSize];
+          parent.readBytes(constantIv, 0, constantIvSize);
+        }
+        return new TrackEncryptionBox(defaultIsProtected, schemeType, defaultPerSampleIvSize,
+            defaultKeyId, defaultCryptByteBlock, defaultSkipByteBlock, constantIv);
+      }
+      childPosition += childAtomSize;
+    }
+    return null;
+  }
+
+  /**
+   * Parses the proj box from sv3d box, as specified by https://github.com/google/spatial-media.
+   */
+  private static byte[] parseProjFromParent(ParsableByteArray parent, int position, int size) {
+    int childPosition = position + Atom.HEADER_SIZE;
+    while (childPosition - position < size) {
+      parent.setPosition(childPosition);
+      int childAtomSize = parent.readInt();
+      int childAtomType = parent.readInt();
+      if (childAtomType == Atom.TYPE_proj) {
+        return Arrays.copyOfRange(parent.data, childPosition, childPosition + childAtomSize);
+      }
+      childPosition += childAtomSize;
+    }
+    return null;
+  }
+
+  /**
+   * Parses the size of an expandable class, as specified by ISO 14496-1 subsection 8.3.3.
+   */
+  private static int parseExpandableClassSize(ParsableByteArray data) {
+    int currentByte = data.readUnsignedByte();
+    int size = currentByte & 0x7F;
+    while ((currentByte & 0x80) == 0x80) {
+      currentByte = data.readUnsignedByte();
+      size = (size << 7) | (currentByte & 0x7F);
+    }
+    return size;
+  }
+
+  /** Returns whether it's possible to apply the specified edit using gapless playback info. */
+  private static boolean canApplyEditWithGaplessInfo(
+      long[] timestamps, long duration, long editStartTime, long editEndTime) {
+    int lastIndex = timestamps.length - 1;
+    int latestDelayIndex = Util.constrainValue(MAX_GAPLESS_TRIM_SIZE_SAMPLES, 0, lastIndex);
+    int earliestPaddingIndex =
+        Util.constrainValue(timestamps.length - MAX_GAPLESS_TRIM_SIZE_SAMPLES, 0, lastIndex);
+    return timestamps[0] <= editStartTime
+        && editStartTime < timestamps[latestDelayIndex]
+        && timestamps[earliestPaddingIndex] < editEndTime
+        && editEndTime <= duration;
+  }
+
+  private AtomParsers() {
+    // Prevent instantiation.
+  }
+
+  private static final class ChunkIterator {
+
+    public final int length;
+
+    public int index;
+    public int numSamples;
+    public long offset;
+
+    private final boolean chunkOffsetsAreLongs;
+    private final ParsableByteArray chunkOffsets;
+    private final ParsableByteArray stsc;
+
+    private int nextSamplesPerChunkChangeIndex;
+    private int remainingSamplesPerChunkChanges;
+
+    public ChunkIterator(ParsableByteArray stsc, ParsableByteArray chunkOffsets,
+        boolean chunkOffsetsAreLongs) {
+      this.stsc = stsc;
+      this.chunkOffsets = chunkOffsets;
+      this.chunkOffsetsAreLongs = chunkOffsetsAreLongs;
+      chunkOffsets.setPosition(Atom.FULL_HEADER_SIZE);
+      length = chunkOffsets.readUnsignedIntToInt();
+      stsc.setPosition(Atom.FULL_HEADER_SIZE);
+      remainingSamplesPerChunkChanges = stsc.readUnsignedIntToInt();
+      Assertions.checkState(stsc.readInt() == 1, "first_chunk must be 1");
+      index = -1;
+    }
+
+    public boolean moveNext() {
+      if (++index == length) {
+        return false;
+      }
+      offset = chunkOffsetsAreLongs ? chunkOffsets.readUnsignedLongToLong()
+          : chunkOffsets.readUnsignedInt();
+      if (index == nextSamplesPerChunkChangeIndex) {
+        numSamples = stsc.readUnsignedIntToInt();
+        stsc.skipBytes(4); // Skip sample_description_index
+        nextSamplesPerChunkChangeIndex = --remainingSamplesPerChunkChanges > 0
+            ? (stsc.readUnsignedIntToInt() - 1) : C.INDEX_UNSET;
+      }
+      return true;
+    }
+
+  }
+
+  /**
+   * Holds data parsed from a tkhd atom.
+   */
+  private static final class TkhdData {
+
+    private final int id;
+    private final long duration;
+    private final int rotationDegrees;
+
+    public TkhdData(int id, long duration, int rotationDegrees) {
+      this.id = id;
+      this.duration = duration;
+      this.rotationDegrees = rotationDegrees;
+    }
+
+  }
+
+  /**
+   * Holds data parsed from an stsd atom and its children.
+   */
+  private static final class StsdData {
+
+    public static final int STSD_HEADER_SIZE = 8;
+
+    public final TrackEncryptionBox[] trackEncryptionBoxes;
+
+    public Format format;
+    public int nalUnitLengthFieldLength;
+    @Track.Transformation
+    public int requiredSampleTransformation;
+
+    public StsdData(int numberOfEntries) {
+      trackEncryptionBoxes = new TrackEncryptionBox[numberOfEntries];
+      requiredSampleTransformation = Track.TRANSFORMATION_NONE;
+    }
+
+  }
+
+  /**
+   * A box containing sample sizes (e.g. stsz, stz2).
+   */
+  private interface SampleSizeBox {
+
+    /**
+     * Returns the number of samples.
+     */
+    int getSampleCount();
+
+    /**
+     * Returns the size for the next sample.
+     */
+    int readNextSampleSize();
+
+    /**
+     * Returns whether samples have a fixed size.
+     */
+    boolean isFixedSampleSize();
+
+  }
+
+  /**
+   * An stsz sample size box.
+   */
+  /* package */ static final class StszSampleSizeBox implements SampleSizeBox {
+
+    private final int fixedSampleSize;
+    private final int sampleCount;
+    private final ParsableByteArray data;
+
+    public StszSampleSizeBox(Atom.LeafAtom stszAtom) {
+      data = stszAtom.data;
+      data.setPosition(Atom.FULL_HEADER_SIZE);
+      fixedSampleSize = data.readUnsignedIntToInt();
+      sampleCount = data.readUnsignedIntToInt();
+    }
+
+    @Override
+    public int getSampleCount() {
+      return sampleCount;
+    }
+
+    @Override
+    public int readNextSampleSize() {
+      return fixedSampleSize == 0 ? data.readUnsignedIntToInt() : fixedSampleSize;
+    }
+
+    @Override
+    public boolean isFixedSampleSize() {
+      return fixedSampleSize != 0;
+    }
+
+  }
+
+  /**
+   * An stz2 sample size box.
+   */
+  /* package */ static final class Stz2SampleSizeBox implements SampleSizeBox {
+
+    private final ParsableByteArray data;
+    private final int sampleCount;
+    private final int fieldSize; // Can be 4, 8, or 16.
+
+    // Used only if fieldSize == 4.
+    private int sampleIndex;
+    private int currentByte;
+
+    public Stz2SampleSizeBox(Atom.LeafAtom stz2Atom) {
+      data = stz2Atom.data;
+      data.setPosition(Atom.FULL_HEADER_SIZE);
+      fieldSize = data.readUnsignedIntToInt() & 0x000000FF;
+      sampleCount = data.readUnsignedIntToInt();
+    }
+
+    @Override
+    public int getSampleCount() {
+      return sampleCount;
+    }
+
+    @Override
+    public int readNextSampleSize() {
+      if (fieldSize == 8) {
+        return data.readUnsignedByte();
+      } else if (fieldSize == 16) {
+        return data.readUnsignedShort();
+      } else {
+        // fieldSize == 4.
+        if ((sampleIndex++ % 2) == 0) {
+          // Read the next byte into our cached byte when we are reading the upper bits.
+          currentByte = data.readUnsignedByte();
+          // Read the upper bits from the byte and shift them to the lower 4 bits.
+          return (currentByte & 0xF0) >> 4;
+        } else {
+          // Mask out the upper 4 bits of the last byte we read.
+          return currentByte & 0x0F;
+        }
+      }
+    }
+
+    @Override
+    public boolean isFixedSampleSize() {
+      return false;
+    }
+
+  }
+
+}
diff --git a/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/DefaultSampleValues.java b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/DefaultSampleValues.java
new file mode 100755
index 0000000000..ea221016ee
--- /dev/null
+++ b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/DefaultSampleValues.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.mpegh;
+
+/* package */ final class DefaultSampleValues {
+
+  public final int sampleDescriptionIndex;
+  public final int duration;
+  public final int size;
+  public final int flags;
+
+  public DefaultSampleValues(int sampleDescriptionIndex, int duration, int size, int flags) {
+    this.sampleDescriptionIndex = sampleDescriptionIndex;
+    this.duration = duration;
+    this.size = size;
+    this.flags = flags;
+  }
+
+}
diff --git a/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/FixedSampleSizeRechunker.java b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/FixedSampleSizeRechunker.java
new file mode 100755
index 0000000000..289a349777
--- /dev/null
+++ b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/FixedSampleSizeRechunker.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.mpegh;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.Util;
+
+/**
+ * Rechunks fixed sample size media in which every sample is a key frame (e.g. uncompressed audio).
+ */
+/* package */ final class FixedSampleSizeRechunker {
+
+  /**
+   * The result of a rechunking operation.
+   */
+  public static final class Results {
+
+    public final long[] offsets;
+    public final int[] sizes;
+    public final int maximumSize;
+    public final long[] timestamps;
+    public final int[] flags;
+    public final long duration;
+
+    private Results(
+        long[] offsets,
+        int[] sizes,
+        int maximumSize,
+        long[] timestamps,
+        int[] flags,
+        long duration) {
+      this.offsets = offsets;
+      this.sizes = sizes;
+      this.maximumSize = maximumSize;
+      this.timestamps = timestamps;
+      this.flags = flags;
+      this.duration = duration;
+    }
+
+  }
+
+  /**
+   * Maximum number of bytes for each buffer in rechunked output.
+   */
+  private static final int MAX_SAMPLE_SIZE = 8 * 1024;
+
+  /**
+   * Rechunk the given fixed sample size input to produce a new sequence of samples.
+   *
+   * @param fixedSampleSize Size in bytes of each sample.
+   * @param chunkOffsets Chunk offsets in the MP4 stream to rechunk.
+   * @param chunkSampleCounts Sample counts for each of the MP4 stream's chunks.
+   * @param timestampDeltaInTimeUnits Timestamp delta between each sample in time units.
+   */
+  public static Results rechunk(int fixedSampleSize, long[] chunkOffsets, int[] chunkSampleCounts,
+      long timestampDeltaInTimeUnits) {
+    int maxSampleCount = MAX_SAMPLE_SIZE / fixedSampleSize;
+
+    // Count the number of new, rechunked buffers.
+    int rechunkedSampleCount = 0;
+    for (int chunkSampleCount : chunkSampleCounts) {
+      rechunkedSampleCount += Util.ceilDivide(chunkSampleCount, maxSampleCount);
+    }
+
+    long[] offsets = new long[rechunkedSampleCount];
+    int[] sizes = new int[rechunkedSampleCount];
+    int maximumSize = 0;
+    long[] timestamps = new long[rechunkedSampleCount];
+    int[] flags = new int[rechunkedSampleCount];
+
+    int originalSampleIndex = 0;
+    int newSampleIndex = 0;
+    for (int chunkIndex = 0; chunkIndex < chunkSampleCounts.length; chunkIndex++) {
+      int chunkSamplesRemaining = chunkSampleCounts[chunkIndex];
+      long sampleOffset = chunkOffsets[chunkIndex];
+
+      while (chunkSamplesRemaining > 0) {
+        int bufferSampleCount = Math.min(maxSampleCount, chunkSamplesRemaining);
+
+        offsets[newSampleIndex] = sampleOffset;
+        sizes[newSampleIndex] = fixedSampleSize * bufferSampleCount;
+        maximumSize = Math.max(maximumSize, sizes[newSampleIndex]);
+        timestamps[newSampleIndex] = (timestampDeltaInTimeUnits * originalSampleIndex);
+        flags[newSampleIndex] = C.BUFFER_FLAG_KEY_FRAME;
+
+        sampleOffset += sizes[newSampleIndex];
+        originalSampleIndex += bufferSampleCount;
+
+        chunkSamplesRemaining -= bufferSampleCount;
+        newSampleIndex++;
+      }
+    }
+    long duration = timestampDeltaInTimeUnits * originalSampleIndex;
+
+    return new Results(offsets, sizes, maximumSize, timestamps, flags, duration);
+  }
+
+  private FixedSampleSizeRechunker() {
+    // Prevent instantiation.
+  }
+}
diff --git a/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/MetadataUtil.java b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/MetadataUtil.java
new file mode 100755
index 0000000000..da798a7e86
--- /dev/null
+++ b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/MetadataUtil.java
@@ -0,0 +1,317 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.mpegh;;
+
+import android.util.Log;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.id3.ApicFrame;
+import com.google.android.exoplayer2.metadata.id3.CommentFrame;
+import com.google.android.exoplayer2.metadata.id3.Id3Frame;
+import com.google.android.exoplayer2.metadata.id3.TextInformationFrame;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.Util;
+
+/**
+ * Parses metadata items stored in ilst atoms.
+ */
+/* package */ final class MetadataUtil {
+
+  private static final String TAG = "MetadataUtil";
+
+  // Codes that start with the copyright character (omitted) and have equivalent ID3 frames.
+  private static final int SHORT_TYPE_NAME_1 = Util.getIntegerCodeForString("nam");
+  private static final int SHORT_TYPE_NAME_2 = Util.getIntegerCodeForString("trk");
+  private static final int SHORT_TYPE_COMMENT = Util.getIntegerCodeForString("cmt");
+  private static final int SHORT_TYPE_YEAR = Util.getIntegerCodeForString("day");
+  private static final int SHORT_TYPE_ARTIST = Util.getIntegerCodeForString("ART");
+  private static final int SHORT_TYPE_ENCODER = Util.getIntegerCodeForString("too");
+  private static final int SHORT_TYPE_ALBUM = Util.getIntegerCodeForString("alb");
+  private static final int SHORT_TYPE_COMPOSER_1 = Util.getIntegerCodeForString("com");
+  private static final int SHORT_TYPE_COMPOSER_2 = Util.getIntegerCodeForString("wrt");
+  private static final int SHORT_TYPE_LYRICS = Util.getIntegerCodeForString("lyr");
+  private static final int SHORT_TYPE_GENRE = Util.getIntegerCodeForString("gen");
+
+  // Codes that have equivalent ID3 frames.
+  private static final int TYPE_COVER_ART = Util.getIntegerCodeForString("covr");
+  private static final int TYPE_GENRE = Util.getIntegerCodeForString("gnre");
+  private static final int TYPE_GROUPING = Util.getIntegerCodeForString("grp");
+  private static final int TYPE_DISK_NUMBER = Util.getIntegerCodeForString("disk");
+  private static final int TYPE_TRACK_NUMBER = Util.getIntegerCodeForString("trkn");
+  private static final int TYPE_TEMPO = Util.getIntegerCodeForString("tmpo");
+  private static final int TYPE_COMPILATION = Util.getIntegerCodeForString("cpil");
+  private static final int TYPE_ALBUM_ARTIST = Util.getIntegerCodeForString("aART");
+  private static final int TYPE_SORT_TRACK_NAME = Util.getIntegerCodeForString("sonm");
+  private static final int TYPE_SORT_ALBUM = Util.getIntegerCodeForString("soal");
+  private static final int TYPE_SORT_ARTIST = Util.getIntegerCodeForString("soar");
+  private static final int TYPE_SORT_ALBUM_ARTIST = Util.getIntegerCodeForString("soaa");
+  private static final int TYPE_SORT_COMPOSER = Util.getIntegerCodeForString("soco");
+
+  // Types that do not have equivalent ID3 frames.
+  private static final int TYPE_RATING = Util.getIntegerCodeForString("rtng");
+  private static final int TYPE_GAPLESS_ALBUM = Util.getIntegerCodeForString("pgap");
+  private static final int TYPE_TV_SORT_SHOW = Util.getIntegerCodeForString("sosn");
+  private static final int TYPE_TV_SHOW = Util.getIntegerCodeForString("tvsh");
+
+  // Type for items that are intended for internal use by the player.
+  private static final int TYPE_INTERNAL = Util.getIntegerCodeForString("----");
+
+  // Standard genres.
+  private static final String[] STANDARD_GENRES = new String[] {
+      // These are the official ID3v1 genres.
+      "Blues", "Classic Rock", "Country", "Dance", "Disco", "Funk", "Grunge", "Hip-Hop", "Jazz",
+      "Metal", "New Age", "Oldies", "Other", "Pop", "R&B", "Rap", "Reggae", "Rock", "Techno",
+      "Industrial", "Alternative", "Ska", "Death Metal", "Pranks", "Soundtrack", "Euro-Techno",
+      "Ambient", "Trip-Hop", "Vocal", "Jazz+Funk", "Fusion", "Trance", "Classical", "Instrumental",
+      "Acid", "House", "Game", "Sound Clip", "Gospel", "Noise", "AlternRock", "Bass", "Soul",
+      "Punk", "Space", "Meditative", "Instrumental Pop", "Instrumental Rock", "Ethnic", "Gothic",
+      "Darkwave", "Techno-Industrial", "Electronic", "Pop-Folk", "Eurodance", "Dream",
+      "Southern Rock", "Comedy", "Cult", "Gangsta", "Top 40", "Christian Rap", "Pop/Funk", "Jungle",
+      "Native American", "Cabaret", "New Wave", "Psychadelic", "Rave", "Showtunes", "Trailer",
+      "Lo-Fi", "Tribal", "Acid Punk", "Acid Jazz", "Polka", "Retro", "Musical", "Rock & Roll",
+      "Hard Rock",
+      // These were made up by the authors of Winamp and later added to the ID3 spec.
+      "Folk", "Folk-Rock", "National Folk", "Swing", "Fast Fusion", "Bebob", "Latin", "Revival",
+      "Celtic", "Bluegrass", "Avantgarde", "Gothic Rock", "Progressive Rock", "Psychedelic Rock",
+      "Symphonic Rock", "Slow Rock", "Big Band", "Chorus", "Easy Listening", "Acoustic", "Humour",
+      "Speech", "Chanson", "Opera", "Chamber Music", "Sonata", "Symphony", "Booty Bass", "Primus",
+      "Porn Groove", "Satire", "Slow Jam", "Club", "Tango", "Samba", "Folklore", "Ballad",
+      "Power Ballad", "Rhythmic Soul", "Freestyle", "Duet", "Punk Rock", "Drum Solo", "A capella",
+      "Euro-House", "Dance Hall",
+      // These were med up by the authors of Winamp but have not been added to the ID3 spec.
+      "Goa", "Drum & Bass", "Club-House", "Hardcore", "Terror", "Indie", "BritPop", "Negerpunk",
+      "Polsk Punk", "Beat", "Christian Gangsta Rap", "Heavy Metal", "Black Metal", "Crossover",
+      "Contemporary Christian", "Christian Rock", "Merengue", "Salsa", "Thrash Metal", "Anime",
+      "Jpop", "Synthpop"
+  };
+
+  private static final String LANGUAGE_UNDEFINED = "und";
+
+  private MetadataUtil() {}
+
+  /**
+   * Parses a single ilst element from a {@link ParsableByteArray}. The element is read starting
+   * from the current position of the {@link ParsableByteArray}, and the position is advanced by
+   * the size of the element. The position is advanced even if the element's type is unrecognized.
+   *
+   * @param ilst Holds the data to be parsed.
+   * @return The parsed element, or null if the element's type was not recognized.
+   */
+  public static Metadata.Entry parseIlstElement(ParsableByteArray ilst) {
+    int position = ilst.getPosition();
+    int endPosition = position + ilst.readInt();
+    int type = ilst.readInt();
+    int typeTopByte = (type >> 24) & 0xFF;
+    try {
+      if (typeTopByte == '\u00A9' /* Copyright char */
+          || typeTopByte == '\uFFFD' /* Replacement char */) {
+        int shortType = type & 0x00FFFFFF;
+        if (shortType == SHORT_TYPE_COMMENT) {
+          return parseCommentAttribute(type, ilst);
+        } else if (shortType == SHORT_TYPE_NAME_1 || shortType == SHORT_TYPE_NAME_2) {
+          return parseTextAttribute(type, "TIT2", ilst);
+        } else if (shortType == SHORT_TYPE_COMPOSER_1 || shortType == SHORT_TYPE_COMPOSER_2) {
+          return parseTextAttribute(type, "TCOM", ilst);
+        } else if (shortType == SHORT_TYPE_YEAR) {
+          return parseTextAttribute(type, "TDRC", ilst);
+        } else if (shortType == SHORT_TYPE_ARTIST) {
+          return parseTextAttribute(type, "TPE1", ilst);
+        } else if (shortType == SHORT_TYPE_ENCODER) {
+          return parseTextAttribute(type, "TSSE", ilst);
+        } else if (shortType == SHORT_TYPE_ALBUM) {
+          return parseTextAttribute(type, "TALB", ilst);
+        } else if (shortType == SHORT_TYPE_LYRICS) {
+          return parseTextAttribute(type, "USLT", ilst);
+        } else if (shortType == SHORT_TYPE_GENRE) {
+          return parseTextAttribute(type, "TCON", ilst);
+        } else if (shortType == TYPE_GROUPING) {
+          return parseTextAttribute(type, "TIT1", ilst);
+        }
+      } else if (type == TYPE_GENRE) {
+        return parseStandardGenreAttribute(ilst);
+      } else if (type == TYPE_DISK_NUMBER) {
+        return parseIndexAndCountAttribute(type, "TPOS", ilst);
+      } else if (type == TYPE_TRACK_NUMBER) {
+        return parseIndexAndCountAttribute(type, "TRCK", ilst);
+      } else if (type == TYPE_TEMPO) {
+        return parseUint8Attribute(type, "TBPM", ilst, true, false);
+      } else if (type == TYPE_COMPILATION) {
+        return parseUint8Attribute(type, "TCMP", ilst, true, true);
+      } else if (type == TYPE_COVER_ART) {
+        return parseCoverArt(ilst);
+      } else if (type == TYPE_ALBUM_ARTIST) {
+        return parseTextAttribute(type, "TPE2", ilst);
+      } else if (type == TYPE_SORT_TRACK_NAME) {
+        return parseTextAttribute(type, "TSOT", ilst);
+      } else if (type == TYPE_SORT_ALBUM) {
+        return parseTextAttribute(type, "TSO2", ilst);
+      } else if (type == TYPE_SORT_ARTIST) {
+        return parseTextAttribute(type, "TSOA", ilst);
+      } else if (type == TYPE_SORT_ALBUM_ARTIST) {
+        return parseTextAttribute(type, "TSOP", ilst);
+      } else if (type == TYPE_SORT_COMPOSER) {
+        return parseTextAttribute(type, "TSOC", ilst);
+      } else if (type == TYPE_RATING) {
+        return parseUint8Attribute(type, "ITUNESADVISORY", ilst, false, false);
+      } else if (type == TYPE_GAPLESS_ALBUM) {
+        return parseUint8Attribute(type, "ITUNESGAPLESS", ilst, false, true);
+      } else if (type == TYPE_TV_SORT_SHOW) {
+        return parseTextAttribute(type, "TVSHOWSORT", ilst);
+      } else if (type == TYPE_TV_SHOW) {
+        return parseTextAttribute(type, "TVSHOW", ilst);
+      } else if (type == TYPE_INTERNAL) {
+        return parseInternalAttribute(ilst, endPosition);
+      }
+      Log.d(TAG, "Skipped unknown metadata entry: " + Atom.getAtomTypeString(type));
+      return null;
+    } finally {
+      ilst.setPosition(endPosition);
+    }
+  }
+
+  private static TextInformationFrame parseTextAttribute(int type, String id,
+      ParsableByteArray data) {
+    int atomSize = data.readInt();
+    int atomType = data.readInt();
+    if (atomType == Atom.TYPE_data) {
+      data.skipBytes(8); // version (1), flags (3), empty (4)
+      String value = data.readNullTerminatedString(atomSize - 16);
+      return new TextInformationFrame(id, null, value);
+    }
+    Log.w(TAG, "Failed to parse text attribute: " + Atom.getAtomTypeString(type));
+    return null;
+  }
+
+  private static CommentFrame parseCommentAttribute(int type, ParsableByteArray data) {
+    int atomSize = data.readInt();
+    int atomType = data.readInt();
+    if (atomType == Atom.TYPE_data) {
+      data.skipBytes(8); // version (1), flags (3), empty (4)
+      String value = data.readNullTerminatedString(atomSize - 16);
+      return new CommentFrame(LANGUAGE_UNDEFINED, value, value);
+    }
+    Log.w(TAG, "Failed to parse comment attribute: " + Atom.getAtomTypeString(type));
+    return null;
+  }
+
+  private static Id3Frame parseUint8Attribute(int type, String id, ParsableByteArray data,
+      boolean isTextInformationFrame, boolean isBoolean) {
+    int value = parseUint8AttributeValue(data);
+    if (isBoolean) {
+      value = Math.min(1, value);
+    }
+    if (value >= 0) {
+      return isTextInformationFrame ? new TextInformationFrame(id, null, Integer.toString(value))
+          : new CommentFrame(LANGUAGE_UNDEFINED, id, Integer.toString(value));
+    }
+    Log.w(TAG, "Failed to parse uint8 attribute: " + Atom.getAtomTypeString(type));
+    return null;
+  }
+
+  private static TextInformationFrame parseIndexAndCountAttribute(int type, String attributeName,
+      ParsableByteArray data) {
+    int atomSize = data.readInt();
+    int atomType = data.readInt();
+    if (atomType == Atom.TYPE_data && atomSize >= 22) {
+      data.skipBytes(10); // version (1), flags (3), empty (4), empty (2)
+      int index = data.readUnsignedShort();
+      if (index > 0) {
+        String value = "" + index;
+        int count = data.readUnsignedShort();
+        if (count > 0) {
+          value += "/" + count;
+        }
+        return new TextInformationFrame(attributeName, null, value);
+      }
+    }
+    Log.w(TAG, "Failed to parse index/count attribute: " + Atom.getAtomTypeString(type));
+    return null;
+  }
+
+  private static TextInformationFrame parseStandardGenreAttribute(ParsableByteArray data) {
+    int genreCode = parseUint8AttributeValue(data);
+    String genreString = (0 < genreCode && genreCode <= STANDARD_GENRES.length)
+        ? STANDARD_GENRES[genreCode - 1] : null;
+    if (genreString != null) {
+      return new TextInformationFrame("TCON", null, genreString);
+    }
+    Log.w(TAG, "Failed to parse standard genre code");
+    return null;
+  }
+
+  private static ApicFrame parseCoverArt(ParsableByteArray data) {
+    int atomSize = data.readInt();
+    int atomType = data.readInt();
+    if (atomType == Atom.TYPE_data) {
+      int fullVersionInt = data.readInt();
+      int flags = Atom.parseFullAtomFlags(fullVersionInt);
+      String mimeType = flags == 13 ? "image/jpeg" : flags == 14 ? "image/png" : null;
+      if (mimeType == null) {
+        Log.w(TAG, "Unrecognized cover art flags: " + flags);
+        return null;
+      }
+      data.skipBytes(4); // empty (4)
+      byte[] pictureData = new byte[atomSize - 16];
+      data.readBytes(pictureData, 0, pictureData.length);
+      return new ApicFrame(mimeType, null, 3 /* Cover (front) */, pictureData);
+    }
+    Log.w(TAG, "Failed to parse cover art attribute");
+    return null;
+  }
+
+  private static Id3Frame parseInternalAttribute(ParsableByteArray data, int endPosition) {
+    String domain = null;
+    String name = null;
+    int dataAtomPosition = -1;
+    int dataAtomSize = -1;
+    while (data.getPosition() < endPosition) {
+      int atomPosition = data.getPosition();
+      int atomSize = data.readInt();
+      int atomType = data.readInt();
+      data.skipBytes(4); // version (1), flags (3)
+      if (atomType == Atom.TYPE_mean) {
+        domain = data.readNullTerminatedString(atomSize - 12);
+      } else if (atomType == Atom.TYPE_name) {
+        name = data.readNullTerminatedString(atomSize - 12);
+      } else {
+        if (atomType == Atom.TYPE_data) {
+          dataAtomPosition = atomPosition;
+          dataAtomSize = atomSize;
+        }
+        data.skipBytes(atomSize - 12);
+      }
+    }
+    if (!"com.apple.iTunes".equals(domain) || !"iTunSMPB".equals(name) || dataAtomPosition == -1) {
+      // We're only interested in iTunSMPB.
+      return null;
+    }
+    data.setPosition(dataAtomPosition);
+    data.skipBytes(16); // size (4), type (4), version (1), flags (3), empty (4)
+    String value = data.readNullTerminatedString(dataAtomSize - 16);
+    return new CommentFrame(LANGUAGE_UNDEFINED, name, value);
+  }
+
+  private static int parseUint8AttributeValue(ParsableByteArray data) {
+    data.skipBytes(4); // atomSize
+    int atomType = data.readInt();
+    if (atomType == Atom.TYPE_data) {
+      data.skipBytes(8); // version (1), flags (3), empty (4)
+      return data.readUnsignedByte();
+    }
+    Log.w(TAG, "Failed to parse uint8 attribute value");
+    return -1;
+  }
+
+}
diff --git a/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/MpeghAudioRenderer.java b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/MpeghAudioRenderer.java
new file mode 100755
index 0000000000..a2ef3eeede
--- /dev/null
+++ b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/MpeghAudioRenderer.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.mpegh;
+
+import android.os.Handler;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.audio.AudioProcessor;
+import com.google.android.exoplayer2.audio.AudioRendererEventListener;
+import com.google.android.exoplayer2.audio.AudioSink;
+import com.google.android.exoplayer2.audio.DefaultAudioSink;
+import com.google.android.exoplayer2.audio.SimpleDecoderAudioRenderer;
+import com.google.android.exoplayer2.drm.DrmSessionManager;
+import com.google.android.exoplayer2.drm.ExoMediaCrypto;
+import com.google.android.exoplayer2.util.MimeTypes;
+
+//--------------------------------------------------------------------//
+// IA decoder impl
+//--------------------------------------------------------------------//
+
+/**
+ * Decodes and renders audio using MPEG-H Music Profile.
+ */
+public final class MpeghAudioRenderer extends SimpleDecoderAudioRenderer {
+
+  /**
+   * The number of input and output buffers.
+   */
+  private static final int NUM_BUFFERS = 16;
+  /**
+   * The initial input buffer size. Input buffers are reallocated dynamically if this value is
+   * insufficient.
+   */
+  private static final int INITIAL_INPUT_BUFFER_SIZE = 960 * 6; // ToDo : check buffer size
+
+  private MpeghDecoder decoder;
+  private static String appRootPath;
+
+  public MpeghAudioRenderer() {
+    this(null, null, null);
+  }
+
+  /**
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param appRootPath A file path of application root (Context.getFilesDir().getAbsolutePath()).
+   * @param audioProcessors Optional {@link AudioProcessor}s that will process audio before output.
+   */
+  public MpeghAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener,
+                            String appRootPath, AudioProcessor... audioProcessors) {
+    this(eventHandler, eventListener, appRootPath, new DefaultAudioSink(null, audioProcessors));
+  }
+
+  /**
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param appRootPath A file path of application root (Context.getFilesDir().getAbsolutePath()).
+   * @param audioSink The sink to which audio will be output.
+   */
+  public MpeghAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener,
+                            String appRootPath, AudioSink audioSink) {
+    super(
+        eventHandler,
+        eventListener,
+        /* drmSessionManager= */ null,
+        /* playClearSamplesWithoutKeys= */ false,
+        audioSink);
+    this.appRootPath = appRootPath;
+  }
+
+  @Override
+  protected int supportsFormatInternal(DrmSessionManager<ExoMediaCrypto> drmSessionManager,
+      Format format) {
+    String sampleMimeType = format.sampleMimeType;
+    if (!MpeghLibrary.isAvailable() || !MimeTypes.isAudio(sampleMimeType)) {
+      return FORMAT_UNSUPPORTED_TYPE;
+    } else if (!MpeghLibrary.supportsFormat(sampleMimeType) || !isOutputSupported(format)) {
+      return FORMAT_UNSUPPORTED_SUBTYPE;
+    } else if (!supportsFormatDrm(drmSessionManager, format.drmInitData)) {
+      return FORMAT_UNSUPPORTED_DRM;
+    } else {
+      return FORMAT_HANDLED;
+    }
+  }
+
+  @Override
+  public final int supportsMixedMimeTypeAdaptation() throws ExoPlaybackException {
+    return ADAPTIVE_NOT_SEAMLESS;
+  }
+
+  @Override
+  protected MpeghDecoder createDecoder(Format format, ExoMediaCrypto mediaCrypto)
+      throws MpeghDecoderException {
+    decoder = new MpeghDecoder(NUM_BUFFERS, NUM_BUFFERS, INITIAL_INPUT_BUFFER_SIZE,
+        format.sampleMimeType, appRootPath, format.initializationData);
+    return decoder;
+  }
+
+  @Override
+  public Format getOutputFormat() {
+    int channelCount = decoder.getChannelCount();
+    int sampleRate = decoder.getSampleRate();
+    @C.PcmEncoding int encoding = decoder.getEncoding();
+    return Format.createAudioSampleFormat(null, MimeTypes.AUDIO_RAW, null, Format.NO_VALUE,
+        Format.NO_VALUE, channelCount, sampleRate, encoding, null, null, 0, null);
+  }
+
+  private boolean isOutputSupported(Format inputFormat) {
+    return shouldUseFloatOutput(inputFormat);
+  }
+
+  private boolean shouldUseFloatOutput(Format inputFormat) {
+    if (!supportsOutputEncoding(C.ENCODING_PCM_FLOAT)) {
+      return false;
+    }
+    // For all other formats, assume that it's worth using 32-bit float encoding.
+    return true;
+  }
+
+}
diff --git a/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/MpeghDecoder.java b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/MpeghDecoder.java
new file mode 100755
index 0000000000..a9e7fda6cf
--- /dev/null
+++ b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/MpeghDecoder.java
@@ -0,0 +1,180 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.mpegh;
+
+import android.util.Log;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+import com.google.android.exoplayer2.decoder.SimpleDecoder;
+import com.google.android.exoplayer2.decoder.SimpleOutputBuffer;
+import com.google.android.exoplayer2.util.MimeTypes;
+
+import java.nio.ByteBuffer;
+import java.util.List;
+
+//--------------------------------------------------------------------//
+// IA decoder impl
+//--------------------------------------------------------------------//
+
+/**
+ * MPEG-H 3D audio decoder.
+ */
+/* package */ final class MpeghDecoder extends
+    SimpleDecoder<DecoderInputBuffer, SimpleOutputBuffer, MpeghDecoderException> {
+
+  static private String TAG = "MpeghDecoderClass";
+  // Space for 32 ms of 48 kHz 2 channel 32-bit Float audio.
+  private static final int OUTPUT_BUFFER_SIZE_SINGLE_PRECISION_FLOAT = 32 * 48 * 2 * 4;
+
+  private final String codecName;
+  private final byte[] extraData;
+  private final @C.Encoding int encoding;
+  private final int outputBufferSize;
+
+  private long nativeContext;
+  private boolean hasOutputFormat;
+  private volatile int channelCount;
+  private volatile int sampleRate;
+
+  public MpeghDecoder(int numInputBuffers, int numOutputBuffers, int initialInputBufferSize,
+                      String mimeType, String appRootPath, List<byte[]> initializationData)
+      throws MpeghDecoderException {
+    super(new DecoderInputBuffer[numInputBuffers], new SimpleOutputBuffer[numOutputBuffers]);
+
+    if (!MpeghLibrary.isAvailable()) {
+      throw new MpeghDecoderException("Failed to load decoder native libraries.");
+    }
+    codecName = MpeghLibrary.getCodecName(mimeType);
+    extraData = getExtraData(mimeType, initializationData);
+    encoding = C.ENCODING_PCM_FLOAT;
+    outputBufferSize = OUTPUT_BUFFER_SIZE_SINGLE_PRECISION_FLOAT;
+
+    // prepare decoder config file manager
+    MpeghDecoderConfigFile configFile = new MpeghDecoderConfigFile(appRootPath);
+    String hrtfConfigFilePath = configFile.getRelativeConfigFilePath(MpeghDecoderConfigFile.CoefType.Hrtf13);
+    String cpConfigFilePath = configFile.getRelativeConfigFilePath(MpeghDecoderConfigFile.CoefType.Cp);
+    Log.v(TAG, "MpeghInitialize: ");
+
+    // initialize a decoder
+    nativeContext = MpeghInitialize(extraData,
+            appRootPath,
+            hrtfConfigFilePath,
+            cpConfigFilePath);
+
+    if (nativeContext == 0) {
+      throw new MpeghDecoderException("Initialization failed.");
+    }
+    setInitialInputBufferSize(initialInputBufferSize);
+  }
+
+  @Override
+  public String getName() {
+    return "mpegh" + MpeghLibrary.getVersion() + "-" + codecName;
+  }
+
+  @Override
+  protected DecoderInputBuffer createInputBuffer() {
+    return new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_DIRECT);
+  }
+
+  @Override
+  protected SimpleOutputBuffer createOutputBuffer() {
+    return new SimpleOutputBuffer(this);
+  }
+
+  @Override
+  protected MpeghDecoderException createUnexpectedDecodeException(Throwable error) {
+    return new MpeghDecoderException("Unexpected decode error", error);
+  }
+
+  @Override
+  protected MpeghDecoderException decode(
+      DecoderInputBuffer inputBuffer, SimpleOutputBuffer outputBuffer, boolean reset) {
+    if (reset) {
+      nativeContext = MpeghReset(nativeContext, extraData);
+      if (nativeContext == 0) {
+        return new MpeghDecoderException("Error resetting (see logcat).");
+      }
+    }
+    ByteBuffer inputData = inputBuffer.data;
+    int inputSize = inputData.limit();
+    ByteBuffer outputData = outputBuffer.init(inputBuffer.timeUs, outputBufferSize);
+    int result = MpeghDecode(nativeContext, inputData, inputSize, outputData, outputBufferSize);
+    if (result < 0) {
+      return new MpeghDecoderException("Error decoding (see logcat). Code: " + result);
+    }
+    if (!hasOutputFormat) {
+      channelCount = MpeghGetChannelCount(nativeContext);
+      sampleRate = MpeghGetSampleRate(nativeContext);
+      hasOutputFormat = true;
+    }
+    outputBuffer.data.position(0);
+    outputBuffer.data.limit(result);
+    return null;
+  }
+
+  @Override
+  public void release() {
+    super.release();
+    MpeghRelease(nativeContext);
+    nativeContext = 0;
+  }
+
+  /**
+   * Returns the channel count of output audio. May only be called after {@link #decode}.
+   */
+  public int getChannelCount() {
+    return channelCount;
+  }
+
+  /**
+   * Returns the sample rate of output audio. May only be called after {@link #decode}.
+   */
+  public int getSampleRate() {
+    return sampleRate;
+  }
+
+  /**
+   * Returns the encoding of output audio.
+   */
+  public @C.Encoding int getEncoding() {
+    return encoding;
+  }
+
+  /**
+   * Returns mpegh-compatible codec-specific initialization data ("extra data"), or {@code null} if
+   * not required.
+   */
+  private static byte[] getExtraData(String mimeType, List<byte[]> initializationData) {
+    switch (mimeType) {
+      case MimeTypes.BASE_TYPE_AUDIO + "/mha1":
+        return initializationData.get(0);
+      default:
+        // Other codecs do not require extra data.
+        return null;
+    }
+  }
+
+  private native long MpeghInitialize(byte[] extraData, String rootPath, String fnameCoef1, String fnameCoef2);
+  private native int MpeghDecode(long context, ByteBuffer inputData, int inputSize,
+      ByteBuffer outputData, int outputSize);
+  private native int MpeghGetChannelCount(long context);
+  private native int MpeghGetSampleRate(long context);
+  private native long MpeghReset(long context, byte[] extraData);
+  private native void MpeghRelease(long context);
+
+}
diff --git a/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/MpeghDecoderConfigFile.java b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/MpeghDecoderConfigFile.java
new file mode 100755
index 0000000000..05ad4d4e0a
--- /dev/null
+++ b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/MpeghDecoderConfigFile.java
@@ -0,0 +1,188 @@
+package com.google.android.exoplayer2.ext.mpegh;
+
+import android.util.Log;
+import android.content.Context;
+import java.util.List;
+import java.io.File;
+import java.io.FileWriter;
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.FileReader;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+
+//--------------------------------------------------------------------//
+// IA decoder impl
+//--------------------------------------------------------------------//
+
+/**
+ * MpeghDecoderConfigFile A class managing config files for passing
+ * coefficient files to Mpegh decoder. It manages config file paths
+ * and coefficient file paths in the device.
+ */
+public class MpeghDecoderConfigFile {
+    static private String TAG = "MpeghDecoderConfigFile";
+
+    /**
+     * MpeghCoefType Coefficiend types for IA decoder API.
+     */
+    public enum CoefType {
+        Hrtf13("hrtf13"),
+        Cp("cp"), ;
+
+        private final String str;
+
+        private CoefType(final String str) {
+            this.str = str;
+        }
+
+        @Override
+        public String toString() {
+            return this.str;
+        }
+    }
+
+    /**
+     * Get application root path: the app specific region in the internal storage.
+     * @param context Current context which holds information of this application.
+     */
+    static public String getAppRootPath(Context context) {
+        String path = context.getFilesDir().getParent();
+        return path;
+    }
+
+    /**
+     * An application root path
+     * (ex) /data/user/0/com.google.android.exoplayer2.demo/files/
+     */
+    private String appRootpath = "";
+
+    /**
+     * A relative root path from the application root path.
+     * (ex) com.sony.immersive-audio/coef/
+     */
+    private String relativeRootPath = kRelativeFileDir;
+
+    /**
+     * Default relative root path
+     */
+    static private String kRelativeFileDir = "files/com.sony.immersive-audio/coef/";
+    /**
+     * Default HRTF config file name
+     */
+    static private String kHrtfConfigFileName = "com.sony.360ra.hrtf13.config";
+    /**
+     * Default CP config file name
+     */
+    static private String kCpConfigFileName = "com.sony.360ra.cp.config";
+
+    /**
+     * Constructor
+     * @param appRootpath An application root path. Typically it can be obtained by
+     *                    context.getFilesDir().getParent().
+     */
+    public MpeghDecoderConfigFile(String appRootpath) {
+        this.appRootpath = appRootpath + "/";
+        printInfo();
+    }
+
+    public void printInfo() {
+        Log.d(TAG, "App root path: " + appRootpath);
+        Log.d(TAG, "Relative root path: " + relativeRootPath);
+
+        Log.d(TAG, "Absolute HRTF config filepath: " + getAbsoluteConfigFilePath(CoefType.Hrtf13));
+        Log.d(TAG, "Absolute CP config filepath: " + getAbsoluteConfigFilePath(CoefType.Cp));
+        Log.d(TAG, "Relative HRTF config filepath: " + getRelativeConfigFilePath(CoefType.Hrtf13));
+        Log.d(TAG, "Relative CP config filepath: " + getRelativeConfigFilePath(CoefType.Cp));
+    }
+
+    /**
+     * Get get config file name
+     */
+    public String getConfigFileName(CoefType type) {
+        switch (type) {
+            case Hrtf13:
+                return kHrtfConfigFileName;
+            case Cp:
+                return kCpConfigFileName;
+        }
+        return "";
+    }
+
+
+    /**
+     * Get get relative root path
+     */
+    public String getRelativeRootPath() {
+        String path = relativeRootPath;
+        return path;
+    }
+
+    /**
+     * Get get absolute path of config file
+     * (ex) /data/user/0/com.google.android.exoplayer2.demo/files/
+     *       com.sony.immersive-audio/coef/com.sony.360ra.hrtf13.config
+     */
+    public String getAbsoluteConfigFilePath(CoefType type) {
+        String path = this.appRootpath + getRelativeConfigFilePath(type);
+        return path;
+    }
+
+    /**
+     * Get get relative path of config file
+     * (ex) com.sony.immersive-audio/coef/com.sony.360ra.hrtf13.config
+     */
+    public String getRelativeConfigFilePath(CoefType type) {
+        String path = relativeRootPath + getConfigFileName(type);
+        return path;
+    }
+
+
+    /**
+     * Read path stored in the current config file.
+     */
+    public String readConfigFile(String path) {
+        String str = "";
+        try{
+            File file = new File(path);
+            BufferedReader bufReader = new BufferedReader(new FileReader(file));
+            str = bufReader.readLine();
+            bufReader.close();
+            return str;
+        }catch(FileNotFoundException e){
+            System.out.println(e);
+        }catch(IOException e){
+            System.out.println(e);
+        }
+        return str;
+    }
+
+    /**
+     * Read coefficient file path stored in the current config file.
+     */
+    public String readRelativeCoefFilePath(CoefType type) {
+        String path = getAbsoluteConfigFilePath(type);
+        return readConfigFile(path);
+    }
+
+    /**
+     * Read absolute coefficient file path stored in the current config file.
+     */
+    public String readAbsoluteCoefFilePath(CoefType type) {
+        String path = getAbsoluteConfigFilePath(type);
+        String relativeFilePath = readConfigFile(path);
+        return this.appRootpath + relativeFilePath;
+    }
+
+    /**
+     * Check specified config file exists.
+     */
+    public boolean isExistConfigFile(CoefType type) {
+        File file = new File(getAbsoluteConfigFilePath(type));
+        return file.exists();
+    }
+
+}
diff --git a/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/MpeghDecoderException.java b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/MpeghDecoderException.java
new file mode 100755
index 0000000000..2a71b4b889
--- /dev/null
+++ b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/MpeghDecoderException.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.mpegh;
+
+import com.google.android.exoplayer2.audio.AudioDecoderException;
+
+//--------------------------------------------------------------------//
+// IA decoder impl
+//--------------------------------------------------------------------//
+
+/**
+ * Thrown when an mpegh decoder error occurs.
+ */
+public final class MpeghDecoderException extends AudioDecoderException {
+
+  /* package */ MpeghDecoderException(String message) {
+    super(message);
+  }
+
+  /* package */ MpeghDecoderException(String message, Throwable cause) {
+    super(message, cause);
+  }
+}
diff --git a/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/MpeghExtractor.java b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/MpeghExtractor.java
new file mode 100755
index 0000000000..7dc6dee448
--- /dev/null
+++ b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/MpeghExtractor.java
@@ -0,0 +1,775 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.mpegh;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.ext.mpegh.Atom.ContainerAtom;
+import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.extractor.ExtractorInput;
+import com.google.android.exoplayer2.extractor.ExtractorOutput;
+import com.google.android.exoplayer2.extractor.ExtractorsFactory;
+import com.google.android.exoplayer2.extractor.GaplessInfoHolder;
+import com.google.android.exoplayer2.extractor.PositionHolder;
+import com.google.android.exoplayer2.extractor.SeekMap;
+import com.google.android.exoplayer2.extractor.SeekPoint;
+import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.extractor.mp4.Mp4Extractor;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.NalUnitUtil;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.Util;
+
+import java.io.IOException;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Extracts data from the MP4 container format.
+ */
+public final class MpeghExtractor implements Extractor, SeekMap {
+
+  /**
+   * Factory for {@link MpeghExtractor} instances.
+   */
+  public static final ExtractorsFactory FACTORY = new ExtractorsFactory() {
+
+    @Override
+    public Extractor[] createExtractors() {
+      return new Extractor[] {new MpeghExtractor()};
+    }
+
+  };
+
+  /**
+   * Flags controlling the behavior of the extractor.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  //@IntDef(flag = true, value = {FLAG_WORKAROUND_IGNORE_EDIT_LISTS})
+  public @interface Flags {}
+  /**
+   * Flag to ignore any edit lists in the stream.
+   */
+  public static final int FLAG_WORKAROUND_IGNORE_EDIT_LISTS = 1;
+
+  /**
+   * Parser states.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  //@IntDef({STATE_READING_ATOM_HEADER, STATE_READING_ATOM_PAYLOAD, STATE_READING_SAMPLE})
+  private @interface State {}
+  private static final int STATE_READING_ATOM_HEADER = 0;
+  private static final int STATE_READING_ATOM_PAYLOAD = 1;
+  private static final int STATE_READING_SAMPLE = 2;
+
+  // Brand stored in the ftyp atom for QuickTime media.
+  private static final int BRAND_QUICKTIME = Util.getIntegerCodeForString("qt  ");
+
+  /**
+   * When seeking within the source, if the offset is greater than or equal to this value (or the
+   * offset is negative), the source will be reloaded.
+   */
+  private static final long RELOAD_MINIMUM_SEEK_DISTANCE = 256 * 1024;
+
+  /**
+   * For poorly interleaved streams, the maximum byte difference one track is allowed to be read
+   * ahead before the source will be reloaded at a new position to read another track.
+   */
+  private static final long MAXIMUM_READ_AHEAD_BYTES_STREAM = 10 * 1024 * 1024;
+
+  private static final int SEARCH_LENGTH = 20 * 1024;
+
+  private final @Flags int flags;
+
+  // Temporary arrays.
+  private final ParsableByteArray nalStartCode;
+  private final ParsableByteArray nalLength;
+
+  private final ParsableByteArray atomHeader;
+  private final ArrayDeque<ContainerAtom> containerAtoms;
+
+  @State private int parserState;
+  private int atomType;
+  private long atomSize;
+  private int atomHeaderBytesRead;
+  private ParsableByteArray atomData;
+
+  private int sampleTrackIndex;
+  private int sampleBytesWritten;
+  private int sampleCurrentNalBytesRemaining;
+
+  // Extractor outputs.
+  private ExtractorOutput extractorOutput;
+  private Mp4Track[] tracks;
+  private long[][] accumulatedSampleSizes;
+  private int firstVideoTrackIndex;
+  private long durationUs;
+  private boolean isQuickTime;
+
+  private Mp4Extractor mp4Extractor;
+  /**
+   * Creates a new extractor for unfragmented MP4 streams.
+   */
+  public MpeghExtractor() {
+    this(0);
+  }
+
+  /**
+   * Creates a new extractor for unfragmented MP4 streams, using the specified flags to control the
+   * extractor's behavior.
+   *
+   * @param flags Flags that control the extractor's behavior.
+   */
+  public MpeghExtractor(@Flags int flags) {
+    this.flags = flags;
+    atomHeader = new ParsableByteArray(Atom.LONG_HEADER_SIZE);
+    containerAtoms = new ArrayDeque<>();
+    nalStartCode = new ParsableByteArray(NalUnitUtil.NAL_START_CODE);
+    nalLength = new ParsableByteArray(4);
+    sampleTrackIndex = C.INDEX_UNSET;
+
+    mp4Extractor = new Mp4Extractor(flags);
+  }
+
+  @Override
+  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+     boolean snif = Sniffer.sniffUnfragmented(input);
+     if( snif ) {
+        // ok this is mp4 format, let's check do we have needed Sony atoms?
+        // 1. find stbl atom, and make sure it contains mha1 with mhaC
+         input.resetPeekPosition();
+         int bytesSearched = 0;
+         Boolean stblFound = false, mha1Found = false, mhacFound = false;
+         ParsableByteArray buffer = new ParsableByteArray(64);
+         while (bytesSearched < SEARCH_LENGTH)
+         {
+             buffer.reset(Atom.HEADER_SIZE);
+             input.peekFully(buffer.data, 0, Atom.HEADER_SIZE);
+             int atomType = buffer.readInt();
+             if (!stblFound && atomType == Atom.TYPE_stbl) {
+                 stblFound = true;
+             }
+             else if(stblFound && !mha1Found && atomType == Atom.TYPE_mha1) {
+                 mha1Found = true;
+             }
+             else if(stblFound && mha1Found && !mhacFound && atomType == Atom.TYPE_mhac ) {
+                 mhacFound = true;
+                 break;
+             }
+
+             // we are reading byte after byte...
+             bytesSearched++;
+             input.resetPeekPosition();
+             input.advancePeekPosition(bytesSearched);
+         }
+
+         snif = mhacFound;
+     }
+     return snif;
+  }
+
+  @Override
+  public void init(ExtractorOutput output) {
+    extractorOutput = output;
+  }
+
+  @Override
+  public void seek(long position, long timeUs) {
+    containerAtoms.clear();
+    atomHeaderBytesRead = 0;
+    sampleTrackIndex = C.INDEX_UNSET;
+    sampleBytesWritten = 0;
+    sampleCurrentNalBytesRemaining = 0;
+    if (position == 0) {
+      enterReadingAtomHeaderState();
+    } else if (tracks != null) {
+      updateSampleIndices(timeUs);
+    }
+  }
+
+  @Override
+  public void release() {
+    // Do nothing
+  }
+
+  @Override
+  public int read(ExtractorInput input, PositionHolder seekPosition)
+      throws IOException, InterruptedException {
+    while (true) {
+      switch (parserState) {
+        case STATE_READING_ATOM_HEADER:
+          if (!readAtomHeader(input)) {
+            return RESULT_END_OF_INPUT;
+          }
+          break;
+        case STATE_READING_ATOM_PAYLOAD:
+          if (readAtomPayload(input, seekPosition)) {
+            return RESULT_SEEK;
+          }
+          break;
+        case STATE_READING_SAMPLE:
+          return readSample(input, seekPosition);
+        default:
+          throw new IllegalStateException();
+      }
+    }
+  }
+
+  // SeekMap implementation.
+
+  @Override
+  public boolean isSeekable() {
+    return true;
+  }
+
+  @Override
+  public long getDurationUs() {
+    return durationUs;
+  }
+
+  @Override
+  public SeekPoints getSeekPoints(long timeUs) {
+    if (tracks.length == 0) {
+      return new SeekPoints(SeekPoint.START);
+    }
+
+    long firstTimeUs;
+    long firstOffset;
+    long secondTimeUs = C.TIME_UNSET;
+    long secondOffset = C.POSITION_UNSET;
+
+    // If we have a video track, use it to establish one or two seek points.
+    if (firstVideoTrackIndex != C.INDEX_UNSET) {
+      TrackSampleTable sampleTable = tracks[firstVideoTrackIndex].sampleTable;
+      int sampleIndex = getSynchronizationSampleIndex(sampleTable, timeUs);
+      if (sampleIndex == C.INDEX_UNSET) {
+        return new SeekPoints(SeekPoint.START);
+      }
+      long sampleTimeUs = sampleTable.timestampsUs[sampleIndex];
+      firstTimeUs = sampleTimeUs;
+      firstOffset = sampleTable.offsets[sampleIndex];
+      if (sampleTimeUs < timeUs && sampleIndex < sampleTable.sampleCount - 1) {
+        int secondSampleIndex = sampleTable.getIndexOfLaterOrEqualSynchronizationSample(timeUs);
+        if (secondSampleIndex != C.INDEX_UNSET && secondSampleIndex != sampleIndex) {
+          secondTimeUs = sampleTable.timestampsUs[secondSampleIndex];
+          secondOffset = sampleTable.offsets[secondSampleIndex];
+        }
+      }
+    } else {
+      firstTimeUs = timeUs;
+      firstOffset = Long.MAX_VALUE;
+    }
+
+    // Take into account other tracks.
+    for (int i = 0; i < tracks.length; i++) {
+      if (i != firstVideoTrackIndex) {
+        TrackSampleTable sampleTable = tracks[i].sampleTable;
+        firstOffset = maybeAdjustSeekOffset(sampleTable, firstTimeUs, firstOffset);
+        if (secondTimeUs != C.TIME_UNSET) {
+          secondOffset = maybeAdjustSeekOffset(sampleTable, secondTimeUs, secondOffset);
+        }
+      }
+    }
+
+    SeekPoint firstSeekPoint = new SeekPoint(firstTimeUs, firstOffset);
+    if (secondTimeUs == C.TIME_UNSET) {
+      return new SeekPoints(firstSeekPoint);
+    } else {
+      SeekPoint secondSeekPoint = new SeekPoint(secondTimeUs, secondOffset);
+      return new SeekPoints(firstSeekPoint, secondSeekPoint);
+    }
+  }
+
+  // Private methods.
+
+  private void enterReadingAtomHeaderState() {
+    parserState = STATE_READING_ATOM_HEADER;
+    atomHeaderBytesRead = 0;
+  }
+
+  private boolean readAtomHeader(ExtractorInput input) throws IOException, InterruptedException {
+    if (atomHeaderBytesRead == 0) {
+      // Read the standard length atom header.
+      if (!input.readFully(atomHeader.data, 0, Atom.HEADER_SIZE, true)) {
+        return false;
+      }
+      atomHeaderBytesRead = Atom.HEADER_SIZE;
+      atomHeader.setPosition(0);
+      atomSize = atomHeader.readUnsignedInt();
+      atomType = atomHeader.readInt();
+    }
+
+    if (atomSize == Atom.DEFINES_LARGE_SIZE) {
+      // Read the large size.
+      int headerBytesRemaining = Atom.LONG_HEADER_SIZE - Atom.HEADER_SIZE;
+      input.readFully(atomHeader.data, Atom.HEADER_SIZE, headerBytesRemaining);
+      atomHeaderBytesRead += headerBytesRemaining;
+      atomSize = atomHeader.readUnsignedLongToLong();
+    } else if (atomSize == Atom.EXTENDS_TO_END_SIZE) {
+      // The atom extends to the end of the file. Note that if the atom is within a container we can
+      // work out its size even if the input length is unknown.
+      long endPosition = input.getLength();
+      if (endPosition == C.LENGTH_UNSET && !containerAtoms.isEmpty()) {
+        endPosition = containerAtoms.peek().endPosition;
+      }
+      if (endPosition != C.LENGTH_UNSET) {
+        atomSize = endPosition - input.getPosition() + atomHeaderBytesRead;
+      }
+    }
+
+    if (atomSize < atomHeaderBytesRead) {
+      throw new ParserException("Atom size less than header length (unsupported).");
+    }
+
+    if (shouldParseContainerAtom(atomType)) {
+      long endPosition = input.getPosition() + atomSize - atomHeaderBytesRead;
+      containerAtoms.push(new ContainerAtom(atomType, endPosition));
+      if (atomSize == atomHeaderBytesRead) {
+        processAtomEnded(endPosition);
+      } else {
+        // Start reading the first child atom.
+        enterReadingAtomHeaderState();
+      }
+    } else if (shouldParseLeafAtom(atomType)) {
+      // We don't support parsing of leaf atoms that define extended atom sizes, or that have
+      // lengths greater than Integer.MAX_VALUE.
+      Assertions.checkState(atomHeaderBytesRead == Atom.HEADER_SIZE);
+      Assertions.checkState(atomSize <= Integer.MAX_VALUE);
+      atomData = new ParsableByteArray((int) atomSize);
+      System.arraycopy(atomHeader.data, 0, atomData.data, 0, Atom.HEADER_SIZE);
+      parserState = STATE_READING_ATOM_PAYLOAD;
+    } else {
+      atomData = null;
+      parserState = STATE_READING_ATOM_PAYLOAD;
+    }
+
+    return true;
+  }
+
+  /**
+   * Processes the atom payload. If {@link #atomData} is null and the size is at or above the
+   * threshold {@link #RELOAD_MINIMUM_SEEK_DISTANCE}, {@code true} is returned and the caller should
+   * restart loading at the position in {@code positionHolder}. Otherwise, the atom is read/skipped.
+   */
+  private boolean readAtomPayload(ExtractorInput input, PositionHolder positionHolder)
+      throws IOException, InterruptedException {
+    long atomPayloadSize = atomSize - atomHeaderBytesRead;
+    long atomEndPosition = input.getPosition() + atomPayloadSize;
+    boolean seekRequired = false;
+    if (atomData != null) {
+      input.readFully(atomData.data, atomHeaderBytesRead, (int) atomPayloadSize);
+      if (atomType == Atom.TYPE_ftyp) {
+        isQuickTime = processFtypAtom(atomData);
+      } else if (!containerAtoms.isEmpty()) {
+        containerAtoms.peek().add(new Atom.LeafAtom(atomType, atomData));
+      }
+    } else {
+      // We don't need the data. Skip or seek, depending on how large the atom is.
+      if (atomPayloadSize < RELOAD_MINIMUM_SEEK_DISTANCE) {
+        input.skipFully((int) atomPayloadSize);
+      } else {
+        positionHolder.position = input.getPosition() + atomPayloadSize;
+        seekRequired = true;
+      }
+    }
+    processAtomEnded(atomEndPosition);
+    return seekRequired && parserState != STATE_READING_SAMPLE;
+  }
+
+  private void processAtomEnded(long atomEndPosition) throws ParserException {
+    while (!containerAtoms.isEmpty() && containerAtoms.peek().endPosition == atomEndPosition) {
+      Atom.ContainerAtom containerAtom = containerAtoms.pop();
+      if (containerAtom.type == Atom.TYPE_moov) {
+        // We've reached the end of the moov atom. Process it and prepare to read samples.
+        processMoovAtom(containerAtom);
+        containerAtoms.clear();
+        parserState = STATE_READING_SAMPLE;
+      } else if (!containerAtoms.isEmpty()) {
+        containerAtoms.peek().add(containerAtom);
+      }
+    }
+    if (parserState != STATE_READING_SAMPLE) {
+      enterReadingAtomHeaderState();
+    }
+  }
+
+  /**
+   * Updates the stored track metadata to reflect the contents of the specified moov atom.
+   */
+  private void processMoovAtom(ContainerAtom moov) throws ParserException {
+    int firstVideoTrackIndex = C.INDEX_UNSET;
+    long durationUs = C.TIME_UNSET;
+    List<Mp4Track> tracks = new ArrayList<>();
+
+    Metadata metadata = null;
+    GaplessInfoHolder gaplessInfoHolder = new GaplessInfoHolder();
+    Atom.LeafAtom udta = moov.getLeafAtomOfType(Atom.TYPE_udta);
+    if (udta != null) {
+      metadata = AtomParsers.parseUdta(udta, isQuickTime);
+      if (metadata != null) {
+        gaplessInfoHolder.setFromMetadata(metadata);
+      }
+    }
+
+    for (int i = 0; i < moov.containerChildren.size(); i++) {
+      Atom.ContainerAtom atom = moov.containerChildren.get(i);
+      if (atom.type != Atom.TYPE_trak) {
+        continue;
+      }
+
+      Track track = AtomParsers.parseTrak(atom, moov.getLeafAtomOfType(Atom.TYPE_mvhd),
+          C.TIME_UNSET, null, (flags & FLAG_WORKAROUND_IGNORE_EDIT_LISTS) != 0, isQuickTime);
+      if (track == null) {
+        continue;
+      }
+
+      Atom.ContainerAtom stblAtom = atom.getContainerAtomOfType(Atom.TYPE_mdia)
+          .getContainerAtomOfType(Atom.TYPE_minf).getContainerAtomOfType(Atom.TYPE_stbl);
+      TrackSampleTable trackSampleTable = AtomParsers.parseStbl(track, stblAtom, gaplessInfoHolder);
+      if (trackSampleTable.sampleCount == 0) {
+        continue;
+      }
+
+      Mp4Track mp4Track = new Mp4Track(track, trackSampleTable,
+          extractorOutput.track(i, track.type));
+      // Each sample has up to three bytes of overhead for the start code that replaces its length.
+      // Allow ten source samples per output sample, like the platform extractor.
+      int maxInputSize = trackSampleTable.maximumSize + 3 * 10;
+      Format format = track.format.copyWithMaxInputSize(maxInputSize);
+      if (track.type == C.TRACK_TYPE_AUDIO) {
+        if (gaplessInfoHolder.hasGaplessInfo()) {
+          format = format.copyWithGaplessInfo(gaplessInfoHolder.encoderDelay,
+              gaplessInfoHolder.encoderPadding);
+        }
+        if (metadata != null) {
+          format = format.copyWithMetadata(metadata);
+        }
+      }
+      mp4Track.trackOutput.format(format);
+
+      durationUs =
+          Math.max(
+              durationUs,
+              track.durationUs != C.TIME_UNSET ? track.durationUs : trackSampleTable.durationUs);
+      if (track.type == C.TRACK_TYPE_VIDEO && firstVideoTrackIndex == C.INDEX_UNSET) {
+        firstVideoTrackIndex = tracks.size();
+      }
+      tracks.add(mp4Track);
+    }
+    this.firstVideoTrackIndex = firstVideoTrackIndex;
+    this.durationUs = durationUs;
+    this.tracks = tracks.toArray(new Mp4Track[tracks.size()]);
+    accumulatedSampleSizes = calculateAccumulatedSampleSizes(this.tracks);
+
+    extractorOutput.endTracks();
+    extractorOutput.seekMap(this);
+  }
+
+  /**
+   * Attempts to extract the next sample in the current mdat atom for the specified track.
+   * <p>
+   * Returns {@link #RESULT_SEEK} if the source should be reloaded from the position in
+   * {@code positionHolder}.
+   * <p>
+   * Returns {@link #RESULT_END_OF_INPUT} if no samples are left. Otherwise, returns
+   * {@link #RESULT_CONTINUE}.
+   *
+   * @param input The {@link ExtractorInput} from which to read data.
+   * @param positionHolder If {@link #RESULT_SEEK} is returned, this holder is updated to hold the
+   *     position of the required data.
+   * @return One of the {@code RESULT_*} flags in {@link Extractor}.
+   * @throws IOException If an error occurs reading from the input.
+   * @throws InterruptedException If the thread is interrupted.
+   */
+  private int readSample(ExtractorInput input, PositionHolder positionHolder)
+      throws IOException, InterruptedException {
+    long inputPosition = input.getPosition();
+    if (sampleTrackIndex == C.INDEX_UNSET) {
+      sampleTrackIndex = getTrackIndexOfNextReadSample(inputPosition);
+      if (sampleTrackIndex == C.INDEX_UNSET) {
+        return RESULT_END_OF_INPUT;
+      }
+    }
+    Mp4Track track = tracks[sampleTrackIndex];
+    TrackOutput trackOutput = track.trackOutput;
+    int sampleIndex = track.sampleIndex;
+    long position = track.sampleTable.offsets[sampleIndex];
+    int sampleSize = track.sampleTable.sizes[sampleIndex];
+    long skipAmount = position - inputPosition + sampleBytesWritten;
+    if (skipAmount < 0 || skipAmount >= RELOAD_MINIMUM_SEEK_DISTANCE) {
+      positionHolder.position = position;
+      return RESULT_SEEK;
+    }
+    if (track.track.sampleTransformation == Track.TRANSFORMATION_CEA608_CDAT) {
+      // The sample information is contained in a cdat atom. The header must be discarded for
+      // committing.
+      skipAmount += Atom.HEADER_SIZE;
+      sampleSize -= Atom.HEADER_SIZE;
+    }
+    input.skipFully((int) skipAmount);
+    if (track.track.nalUnitLengthFieldLength != 0) {
+      // Zero the top three bytes of the array that we'll use to decode nal unit lengths, in case
+      // they're only 1 or 2 bytes long.
+      byte[] nalLengthData = nalLength.data;
+      nalLengthData[0] = 0;
+      nalLengthData[1] = 0;
+      nalLengthData[2] = 0;
+      int nalUnitLengthFieldLength = track.track.nalUnitLengthFieldLength;
+      int nalUnitLengthFieldLengthDiff = 4 - track.track.nalUnitLengthFieldLength;
+      // NAL units are length delimited, but the decoder requires start code delimited units.
+      // Loop until we've written the sample to the track output, replacing length delimiters with
+      // start codes as we encounter them.
+      while (sampleBytesWritten < sampleSize) {
+        if (sampleCurrentNalBytesRemaining == 0) {
+          // Read the NAL length so that we know where we find the next one.
+          input.readFully(nalLength.data, nalUnitLengthFieldLengthDiff, nalUnitLengthFieldLength);
+          nalLength.setPosition(0);
+          sampleCurrentNalBytesRemaining = nalLength.readUnsignedIntToInt();
+          // Write a start code for the current NAL unit.
+          nalStartCode.setPosition(0);
+          trackOutput.sampleData(nalStartCode, 4);
+          sampleBytesWritten += 4;
+          sampleSize += nalUnitLengthFieldLengthDiff;
+        } else {
+          // Write the payload of the NAL unit.
+          int writtenBytes = trackOutput.sampleData(input, sampleCurrentNalBytesRemaining, false);
+          sampleBytesWritten += writtenBytes;
+          sampleCurrentNalBytesRemaining -= writtenBytes;
+        }
+      }
+    } else {
+      while (sampleBytesWritten < sampleSize) {
+        int writtenBytes = trackOutput.sampleData(input, sampleSize - sampleBytesWritten, false);
+        sampleBytesWritten += writtenBytes;
+        sampleCurrentNalBytesRemaining -= writtenBytes;
+      }
+    }
+    trackOutput.sampleMetadata(track.sampleTable.timestampsUs[sampleIndex],
+        track.sampleTable.flags[sampleIndex], sampleSize, 0, null);
+    track.sampleIndex++;
+    sampleTrackIndex = C.INDEX_UNSET;
+    sampleBytesWritten = 0;
+    sampleCurrentNalBytesRemaining = 0;
+    return RESULT_CONTINUE;
+  }
+
+  /**
+   * Returns the index of the track that contains the next sample to be read, or {@link
+   * C#INDEX_UNSET} if no samples remain.
+   *
+   * <p>The preferred choice is the sample with the smallest offset not requiring a source reload,
+   * or if not available the sample with the smallest overall offset to avoid subsequent source
+   * reloads.
+   *
+   * <p>To deal with poor sample interleaving, we also check whether the required memory to catch up
+   * with the next logical sample (based on sample time) exceeds {@link
+   * #MAXIMUM_READ_AHEAD_BYTES_STREAM}. If this is the case, we continue with this sample even
+   * though it may require a source reload.
+   */
+  private int getTrackIndexOfNextReadSample(long inputPosition) {
+    long preferredSkipAmount = Long.MAX_VALUE;
+    boolean preferredRequiresReload = true;
+    int preferredTrackIndex = C.INDEX_UNSET;
+    long preferredAccumulatedBytes = Long.MAX_VALUE;
+    long minAccumulatedBytes = Long.MAX_VALUE;
+    boolean minAccumulatedBytesRequiresReload = true;
+    int minAccumulatedBytesTrackIndex = C.INDEX_UNSET;
+    for (int trackIndex = 0; trackIndex < tracks.length; trackIndex++) {
+      Mp4Track track = tracks[trackIndex];
+      int sampleIndex = track.sampleIndex;
+      if (sampleIndex == track.sampleTable.sampleCount) {
+        continue;
+      }
+      long sampleOffset = track.sampleTable.offsets[sampleIndex];
+      long sampleAccumulatedBytes = accumulatedSampleSizes[trackIndex][sampleIndex];
+      long skipAmount = sampleOffset - inputPosition;
+      boolean requiresReload = skipAmount < 0 || skipAmount >= RELOAD_MINIMUM_SEEK_DISTANCE;
+      if ((!requiresReload && preferredRequiresReload)
+          || (requiresReload == preferredRequiresReload && skipAmount < preferredSkipAmount)) {
+        preferredRequiresReload = requiresReload;
+        preferredSkipAmount = skipAmount;
+        preferredTrackIndex = trackIndex;
+        preferredAccumulatedBytes = sampleAccumulatedBytes;
+      }
+      if (sampleAccumulatedBytes < minAccumulatedBytes) {
+        minAccumulatedBytes = sampleAccumulatedBytes;
+        minAccumulatedBytesRequiresReload = requiresReload;
+        minAccumulatedBytesTrackIndex = trackIndex;
+      }
+    }
+    return minAccumulatedBytes == Long.MAX_VALUE
+            || !minAccumulatedBytesRequiresReload
+            || preferredAccumulatedBytes < minAccumulatedBytes + MAXIMUM_READ_AHEAD_BYTES_STREAM
+        ? preferredTrackIndex
+        : minAccumulatedBytesTrackIndex;
+  }
+
+  /**
+   * Updates every track's sample index to point its latest sync sample before/at {@code timeUs}.
+   */
+  private void updateSampleIndices(long timeUs) {
+    for (Mp4Track track : tracks) {
+      TrackSampleTable sampleTable = track.sampleTable;
+      int sampleIndex = sampleTable.getIndexOfEarlierOrEqualSynchronizationSample(timeUs);
+      if (sampleIndex == C.INDEX_UNSET) {
+        // Handle the case where the requested time is before the first synchronization sample.
+        sampleIndex = sampleTable.getIndexOfLaterOrEqualSynchronizationSample(timeUs);
+      }
+      track.sampleIndex = sampleIndex;
+    }
+  }
+
+  /**
+   * For each sample of each track, calculates accumulated size of all samples which need to be read
+   * before this sample can be used.
+   */
+  private static long[][] calculateAccumulatedSampleSizes(Mp4Track[] tracks) {
+    long[][] accumulatedSampleSizes = new long[tracks.length][];
+    int[] nextSampleIndex = new int[tracks.length];
+    long[] nextSampleTimesUs = new long[tracks.length];
+    boolean[] tracksFinished = new boolean[tracks.length];
+    for (int i = 0; i < tracks.length; i++) {
+      accumulatedSampleSizes[i] = new long[tracks[i].sampleTable.sampleCount];
+      nextSampleTimesUs[i] = tracks[i].sampleTable.timestampsUs[0];
+    }
+    long accumulatedSampleSize = 0;
+    int finishedTracks = 0;
+    while (finishedTracks < tracks.length) {
+      long minTimeUs = Long.MAX_VALUE;
+      int minTimeTrackIndex = -1;
+      for (int i = 0; i < tracks.length; i++) {
+        if (!tracksFinished[i] && nextSampleTimesUs[i] <= minTimeUs) {
+          minTimeTrackIndex = i;
+          minTimeUs = nextSampleTimesUs[i];
+        }
+      }
+      int trackSampleIndex = nextSampleIndex[minTimeTrackIndex];
+      accumulatedSampleSizes[minTimeTrackIndex][trackSampleIndex] = accumulatedSampleSize;
+      accumulatedSampleSize += tracks[minTimeTrackIndex].sampleTable.sizes[trackSampleIndex];
+      nextSampleIndex[minTimeTrackIndex] = ++trackSampleIndex;
+      if (trackSampleIndex < accumulatedSampleSizes[minTimeTrackIndex].length) {
+        nextSampleTimesUs[minTimeTrackIndex] =
+            tracks[minTimeTrackIndex].sampleTable.timestampsUs[trackSampleIndex];
+      } else {
+        tracksFinished[minTimeTrackIndex] = true;
+        finishedTracks++;
+      }
+    }
+    return accumulatedSampleSizes;
+  }
+
+  /**
+   * Adjusts a seek point offset to take into account the track with the given {@code sampleTable},
+   * for a given {@code seekTimeUs}.
+   *
+   * @param sampleTable The sample table to use.
+   * @param seekTimeUs The seek time in microseconds.
+   * @param offset The current offset.
+   * @return The adjusted offset.
+   */
+  private static long maybeAdjustSeekOffset(
+      TrackSampleTable sampleTable, long seekTimeUs, long offset) {
+    int sampleIndex = getSynchronizationSampleIndex(sampleTable, seekTimeUs);
+    if (sampleIndex == C.INDEX_UNSET) {
+      return offset;
+    }
+    long sampleOffset = sampleTable.offsets[sampleIndex];
+    return Math.min(sampleOffset, offset);
+  }
+
+  /**
+   * Returns the index of the synchronization sample before or at {@code timeUs}, or the index of
+   * the first synchronization sample if located after {@code timeUs}, or {@link C#INDEX_UNSET} if
+   * there are no synchronization samples in the table.
+   *
+   * @param sampleTable The sample table in which to locate a synchronization sample.
+   * @param timeUs A time in microseconds.
+   * @return The index of the synchronization sample before or at {@code timeUs}, or the index of
+   *     the first synchronization sample if located after {@code timeUs}, or {@link C#INDEX_UNSET}
+   *     if there are no synchronization samples in the table.
+   */
+  private static int getSynchronizationSampleIndex(TrackSampleTable sampleTable, long timeUs) {
+    int sampleIndex = sampleTable.getIndexOfEarlierOrEqualSynchronizationSample(timeUs);
+    if (sampleIndex == C.INDEX_UNSET) {
+      // Handle the case where the requested time is before the first synchronization sample.
+      sampleIndex = sampleTable.getIndexOfLaterOrEqualSynchronizationSample(timeUs);
+    }
+    return sampleIndex;
+  }
+
+  /**
+   * Process an ftyp atom to determine whether the media is QuickTime.
+   *
+   * @param atomData The ftyp atom data.
+   * @return Whether the media is QuickTime.
+   */
+  private static boolean processFtypAtom(ParsableByteArray atomData) {
+    atomData.setPosition(Atom.HEADER_SIZE);
+    int majorBrand = atomData.readInt();
+    if (majorBrand == BRAND_QUICKTIME) {
+      return true;
+    }
+    atomData.skipBytes(4); // minor_version
+    while (atomData.bytesLeft() > 0) {
+      if (atomData.readInt() == BRAND_QUICKTIME) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * Returns whether the extractor should decode a leaf atom with type {@code atom}.
+   */
+  private static boolean shouldParseLeafAtom(int atom) {
+    return atom == Atom.TYPE_mdhd || atom == Atom.TYPE_mvhd || atom == Atom.TYPE_hdlr
+        || atom == Atom.TYPE_stsd || atom == Atom.TYPE_stts || atom == Atom.TYPE_stss
+        || atom == Atom.TYPE_ctts || atom == Atom.TYPE_elst || atom == Atom.TYPE_stsc
+        || atom == Atom.TYPE_stsz || atom == Atom.TYPE_stz2 || atom == Atom.TYPE_stco
+        || atom == Atom.TYPE_co64 || atom == Atom.TYPE_tkhd || atom == Atom.TYPE_ftyp
+        || atom == Atom.TYPE_udta;
+  }
+
+  /**
+   * Returns whether the extractor should decode a container atom with type {@code atom}.
+   */
+  private static boolean shouldParseContainerAtom(int atom) {
+    return atom == Atom.TYPE_moov || atom == Atom.TYPE_trak || atom == Atom.TYPE_mdia
+        || atom == Atom.TYPE_minf || atom == Atom.TYPE_stbl || atom == Atom.TYPE_edts;
+  }
+
+  private static final class Mp4Track {
+
+    public final Track track;
+    public final TrackSampleTable sampleTable;
+    public final TrackOutput trackOutput;
+
+    public int sampleIndex;
+
+    public Mp4Track(Track track, TrackSampleTable sampleTable, TrackOutput trackOutput) {
+      this.track = track;
+      this.sampleTable = sampleTable;
+      this.trackOutput = trackOutput;
+    }
+
+  }
+
+}
diff --git a/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/MpeghExtractorFactory.java b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/MpeghExtractorFactory.java
new file mode 100644
index 0000000000..5904779c26
--- /dev/null
+++ b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/MpeghExtractorFactory.java
@@ -0,0 +1,28 @@
+package com.google.android.exoplayer2.ext.mpegh;
+
+/**
+ * Created by andrija.milovanovic on 2/5/19.
+ */
+
+import com.google.android.exoplayer2.extractor.DefaultExtractorsFactory;
+import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.extractor.ExtractorsFactory;
+
+public final class MpeghExtractorFactory implements ExtractorsFactory {
+
+    private DefaultExtractorsFactory defaultExtractorsFactory = new DefaultExtractorsFactory();
+
+
+    @Override
+    public Extractor[] createExtractors() {
+        // create all default extractors
+        Extractor[] defaultExtractors = defaultExtractorsFactory.createExtractors();
+        Extractor[] mpeghExtractors = MpeghExtractor.FACTORY.createExtractors();
+
+        Extractor[] combinedExtractors = new Extractor[defaultExtractors.length + mpeghExtractors.length];
+
+        System.arraycopy(mpeghExtractors, 0, combinedExtractors, 0, mpeghExtractors.length);
+        System.arraycopy(defaultExtractors, 0, combinedExtractors, mpeghExtractors.length, defaultExtractors.length);
+        return combinedExtractors;
+    }
+}
\ No newline at end of file
diff --git a/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/MpeghLibrary.java b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/MpeghLibrary.java
new file mode 100755
index 0000000000..f454785912
--- /dev/null
+++ b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/MpeghLibrary.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.mpegh;
+
+import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
+import com.google.android.exoplayer2.util.LibraryLoader;
+import com.google.android.exoplayer2.util.MimeTypes;
+
+//--------------------------------------------------------------------//
+// IA decoder impl
+//--------------------------------------------------------------------//
+
+/**
+ * Configures and queries the underlying native library.
+ */
+public final class MpeghLibrary {
+
+  static {
+    ExoPlayerLibraryInfo.registerModule("goog.exo.mpegh");
+  }
+
+  private static final LibraryLoader LOADER =
+      new LibraryLoader("mpegh");
+
+  private MpeghLibrary() {}
+
+  /**
+   * Override the names of the mpegh native libraries. If an application wishes to call this
+   * method, it must do so before calling any other method defined by this class, and before
+   * instantiating a {@link MpeghAudioRenderer} instance.
+   *
+   * @param libraries The names of the mpegh native libraries.
+   */
+  public static void setLibraries(String... libraries)  {
+    LOADER.setLibraries(libraries);
+  }
+
+  /**
+   * Returns whether the underlying library is available, loading it if necessary.
+   */
+  public static boolean isAvailable() {
+    return LOADER.isAvailable();
+  }
+
+  /**
+   * Returns the version of the underlying library if available, or null otherwise.
+   */
+  public static String getVersion() {
+    LOADER.isAvailable();
+    return MpeghGetVersion();
+  }
+
+  /**
+   * Returns whether the underlying library supports the specified MIME type.
+   *
+   * @param mimeType The MIME type to check.
+   */
+  public static boolean supportsFormat(String mimeType) {
+    if (!isAvailable()) {
+      return false;
+    }
+    String codecName = getCodecName(mimeType);
+    return codecName != null && codecName == "mpegh";
+  }
+
+  /**
+   * Returns the name of the mpegh decoder that could be used to decode {@code mimeType}.
+   */
+  /* package */ static String getCodecName(String mimeType) {
+    switch (mimeType) {
+      case MimeTypes.BASE_TYPE_AUDIO + "/mha1":
+        return "mpegh";
+      default:
+        return null;
+    }
+  }
+
+  private static native String MpeghGetVersion();
+}
diff --git a/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/PsshAtomUtil.java b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/PsshAtomUtil.java
new file mode 100755
index 0000000000..70e7e4ea4f
--- /dev/null
+++ b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/PsshAtomUtil.java
@@ -0,0 +1,198 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.mpegh;
+
+import android.support.annotation.Nullable;
+import android.util.Log;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.nio.ByteBuffer;
+import java.util.UUID;
+
+/**
+ * Utility methods for handling PSSH atoms.
+ */
+public final class PsshAtomUtil {
+
+  private static final String TAG = "PsshAtomUtil";
+
+  private PsshAtomUtil() {}
+
+  /**
+   * Builds a version 0 PSSH atom for a given system id, containing the given data.
+   *
+   * @param systemId The system id of the scheme.
+   * @param data The scheme specific data.
+   * @return The PSSH atom.
+   */
+  public static byte[] buildPsshAtom(UUID systemId, @Nullable byte[] data) {
+    return buildPsshAtom(systemId, null, data);
+  }
+
+  /**
+   * Builds a PSSH atom for the given system id, containing the given key ids and data.
+   *
+   * @param systemId The system id of the scheme.
+   * @param keyIds The key ids for a version 1 PSSH atom, or null for a version 0 PSSH atom.
+   * @param data The scheme specific data.
+   * @return The PSSH atom.
+   */
+  @SuppressWarnings("ParameterNotNullable")
+  public static byte[] buildPsshAtom(
+      UUID systemId, @Nullable UUID[] keyIds, @Nullable byte[] data) {
+    boolean buildV1Atom = keyIds != null;
+    int dataLength = data != null ? data.length : 0;
+    int psshBoxLength = Atom.FULL_HEADER_SIZE + 16 /* SystemId */ + 4 /* DataSize */ + dataLength;
+    if (buildV1Atom) {
+      psshBoxLength += 4 /* KID_count */ + (keyIds.length * 16) /* KIDs */;
+    }
+    ByteBuffer psshBox = ByteBuffer.allocate(psshBoxLength);
+    psshBox.putInt(psshBoxLength);
+    psshBox.putInt(Atom.TYPE_pssh);
+    psshBox.putInt(buildV1Atom ? 0x01000000 : 0 /* version=(buildV1Atom ? 1 : 0), flags=0 */);
+    psshBox.putLong(systemId.getMostSignificantBits());
+    psshBox.putLong(systemId.getLeastSignificantBits());
+    if (buildV1Atom) {
+      psshBox.putInt(keyIds.length);
+      for (UUID keyId : keyIds) {
+        psshBox.putLong(keyId.getMostSignificantBits());
+        psshBox.putLong(keyId.getLeastSignificantBits());
+      }
+    }
+    if (dataLength != 0) {
+      psshBox.putInt(data.length);
+      psshBox.put(data);
+    } // Else the last 4 bytes are a 0 DataSize.
+    return psshBox.array();
+  }
+
+  /**
+   * Parses the UUID from a PSSH atom. Version 0 and 1 PSSH atoms are supported.
+   *
+   * <p>The UUID is only parsed if the data is a valid PSSH atom.
+   *
+   * @param atom The atom to parse.
+   * @return The parsed UUID. Null if the input is not a valid PSSH atom, or if the PSSH atom has an
+   *     unsupported version.
+   */
+  public static @Nullable UUID parseUuid(byte[] atom) {
+    PsshAtom parsedAtom = parsePsshAtom(atom);
+    if (parsedAtom == null) {
+      return null;
+    }
+    return parsedAtom.uuid;
+  }
+
+  /**
+   * Parses the version from a PSSH atom. Version 0 and 1 PSSH atoms are supported.
+   * <p>
+   * The version is only parsed if the data is a valid PSSH atom.
+   *
+   * @param atom The atom to parse.
+   * @return The parsed version. -1 if the input is not a valid PSSH atom, or if the PSSH atom has
+   *     an unsupported version.
+   */
+  public static int parseVersion(byte[] atom) {
+    PsshAtom parsedAtom = parsePsshAtom(atom);
+    if (parsedAtom == null) {
+      return -1;
+    }
+    return parsedAtom.version;
+  }
+
+  /**
+   * Parses the scheme specific data from a PSSH atom. Version 0 and 1 PSSH atoms are supported.
+   *
+   * <p>The scheme specific data is only parsed if the data is a valid PSSH atom matching the given
+   * UUID, or if the data is a valid PSSH atom of any type in the case that the passed UUID is null.
+   *
+   * @param atom The atom to parse.
+   * @param uuid The required UUID of the PSSH atom, or null to accept any UUID.
+   * @return The parsed scheme specific data. Null if the input is not a valid PSSH atom, or if the
+   *     PSSH atom has an unsupported version, or if the PSSH atom does not match the passed UUID.
+   */
+  public static @Nullable byte[] parseSchemeSpecificData(byte[] atom, UUID uuid) {
+    PsshAtom parsedAtom = parsePsshAtom(atom);
+    if (parsedAtom == null) {
+      return null;
+    }
+    if (uuid != null && !uuid.equals(parsedAtom.uuid)) {
+      Log.w(TAG, "UUID mismatch. Expected: " + uuid + ", got: " + parsedAtom.uuid + ".");
+      return null;
+    }
+    return parsedAtom.schemeData;
+  }
+
+  /**
+   * Parses a PSSH atom. Version 0 and 1 PSSH atoms are supported.
+   *
+   * @param atom The atom to parse.
+   * @return The parsed PSSH atom. Null if the input is not a valid PSSH atom, or if the PSSH atom
+   *     has an unsupported version.
+   */
+  // TODO: Support parsing of the key ids for version 1 PSSH atoms.
+  private static @Nullable PsshAtom parsePsshAtom(byte[] atom) {
+    ParsableByteArray atomData = new ParsableByteArray(atom);
+    if (atomData.limit() < Atom.FULL_HEADER_SIZE + 16 /* UUID */ + 4 /* DataSize */) {
+      // Data too short.
+      return null;
+    }
+    atomData.setPosition(0);
+    int atomSize = atomData.readInt();
+    if (atomSize != atomData.bytesLeft() + 4) {
+      // Not an atom, or incorrect atom size.
+      return null;
+    }
+    int atomType = atomData.readInt();
+    if (atomType != Atom.TYPE_pssh) {
+      // Not an atom, or incorrect atom type.
+      return null;
+    }
+    int atomVersion = Atom.parseFullAtomVersion(atomData.readInt());
+    if (atomVersion > 1) {
+      Log.w(TAG, "Unsupported pssh version: " + atomVersion);
+      return null;
+    }
+    UUID uuid = new UUID(atomData.readLong(), atomData.readLong());
+    if (atomVersion == 1) {
+      int keyIdCount = atomData.readUnsignedIntToInt();
+      atomData.skipBytes(16 * keyIdCount);
+    }
+    int dataSize = atomData.readUnsignedIntToInt();
+    if (dataSize != atomData.bytesLeft()) {
+      // Incorrect dataSize.
+      return null;
+    }
+    byte[] data = new byte[dataSize];
+    atomData.readBytes(data, 0, dataSize);
+    return new PsshAtom(uuid, atomVersion, data);
+  }
+
+  // TODO: Consider exposing this and making parsePsshAtom public.
+  private static class PsshAtom {
+
+    private final UUID uuid;
+    private final int version;
+    private final byte[] schemeData;
+
+    public PsshAtom(UUID uuid, int version, byte[] schemeData) {
+      this.uuid = uuid;
+      this.version = version;
+      this.schemeData = schemeData;
+    }
+
+  }
+
+}
diff --git a/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/Sniffer.java b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/Sniffer.java
new file mode 100755
index 0000000000..baccd7b7a2
--- /dev/null
+++ b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/Sniffer.java
@@ -0,0 +1,194 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.mpegh;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.extractor.ExtractorInput;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.Util;
+import java.io.IOException;
+
+/**
+ * Provides methods that peek data from an {@link ExtractorInput} and return whether the input
+ * appears to be in MP4 format.
+ */
+/* package */ final class Sniffer {
+
+  /**
+   * The maximum number of bytes to peek when sniffing.
+   */
+  private static final int SEARCH_LENGTH = 4 * 1024;
+
+  private static final int[] COMPATIBLE_BRANDS = new int[] {
+      Util.getIntegerCodeForString("isom"),
+      Util.getIntegerCodeForString("iso2"),
+      Util.getIntegerCodeForString("iso3"),
+      Util.getIntegerCodeForString("iso4"),
+      Util.getIntegerCodeForString("iso5"),
+      Util.getIntegerCodeForString("iso6"),
+      Util.getIntegerCodeForString("avc1"),
+      Util.getIntegerCodeForString("hvc1"),
+      Util.getIntegerCodeForString("hev1"),
+      Util.getIntegerCodeForString("mp41"),
+      Util.getIntegerCodeForString("mp42"),
+      Util.getIntegerCodeForString("3g2a"),
+      Util.getIntegerCodeForString("3g2b"),
+      Util.getIntegerCodeForString("3gr6"),
+      Util.getIntegerCodeForString("3gs6"),
+      Util.getIntegerCodeForString("3ge6"),
+      Util.getIntegerCodeForString("3gg6"),
+      Util.getIntegerCodeForString("M4V "),
+      Util.getIntegerCodeForString("M4A "),
+      Util.getIntegerCodeForString("f4v "),
+      Util.getIntegerCodeForString("kddi"),
+      Util.getIntegerCodeForString("M4VP"),
+      Util.getIntegerCodeForString("qt  "), // Apple QuickTime
+      Util.getIntegerCodeForString("MSNV"), // Sony PSP
+  };
+
+  /**
+   * Returns whether data peeked from the current position in {@code input} is consistent with the
+   * input being a fragmented MP4 file.
+   *
+   * @param input The extractor input from which to peek data. The peek position will be modified.
+   * @return Whether the input appears to be in the fragmented MP4 format.
+   * @throws IOException If an error occurs reading from the input.
+   * @throws InterruptedException If the thread has been interrupted.
+   */
+  public static boolean sniffFragmented(ExtractorInput input)
+      throws IOException, InterruptedException {
+    return sniffInternal(input, true);
+  }
+
+  /**
+   * Returns whether data peeked from the current position in {@code input} is consistent with the
+   * input being an unfragmented MP4 file.
+   *
+   * @param input The extractor input from which to peek data. The peek position will be modified.
+   * @return Whether the input appears to be in the unfragmented MP4 format.
+   * @throws IOException If an error occurs reading from the input.
+   * @throws InterruptedException If the thread has been interrupted.
+   */
+  public static boolean sniffUnfragmented(ExtractorInput input)
+      throws IOException, InterruptedException {
+    return sniffInternal(input, false);
+  }
+
+  private static boolean sniffInternal(ExtractorInput input, boolean fragmented)
+      throws IOException, InterruptedException {
+    long inputLength = input.getLength();
+    int bytesToSearch = (int) (inputLength == C.LENGTH_UNSET || inputLength > SEARCH_LENGTH
+        ? SEARCH_LENGTH : inputLength);
+
+    ParsableByteArray buffer = new ParsableByteArray(64);
+    int bytesSearched = 0;
+    boolean foundGoodFileType = false;
+    boolean isFragmented = false;
+    while (bytesSearched < bytesToSearch) {
+      // Read an atom header.
+      int headerSize = Atom.HEADER_SIZE;
+      buffer.reset(headerSize);
+      input.peekFully(buffer.data, 0, headerSize);
+      long atomSize = buffer.readUnsignedInt();
+      int atomType = buffer.readInt();
+      if (atomSize == Atom.DEFINES_LARGE_SIZE) {
+        // Read the large atom size.
+        headerSize = Atom.LONG_HEADER_SIZE;
+        input.peekFully(buffer.data, Atom.HEADER_SIZE, Atom.LONG_HEADER_SIZE - Atom.HEADER_SIZE);
+        buffer.setLimit(Atom.LONG_HEADER_SIZE);
+        atomSize = buffer.readUnsignedLongToLong();
+      } else if (atomSize == Atom.EXTENDS_TO_END_SIZE) {
+        // The atom extends to the end of the file.
+        long endPosition = input.getLength();
+        if (endPosition != C.LENGTH_UNSET) {
+          atomSize = endPosition - input.getPosition() + headerSize;
+        }
+      }
+
+      if (atomSize < headerSize) {
+        // The file is invalid because the atom size is too small for its header.
+        return false;
+      }
+      bytesSearched += headerSize;
+
+      if (atomType == Atom.TYPE_moov) {
+        // Check for an mvex atom inside the moov atom to identify whether the file is fragmented.
+        continue;
+      }
+
+      if (atomType == Atom.TYPE_moof || atomType == Atom.TYPE_mvex) {
+        // The movie is fragmented. Stop searching as we must have read any ftyp atom already.
+        isFragmented = true;
+        break;
+      }
+
+      if (bytesSearched + atomSize - headerSize >= bytesToSearch) {
+        // Stop searching as peeking this atom would exceed the search limit.
+        break;
+      }
+
+      int atomDataSize = (int) (atomSize - headerSize);
+      bytesSearched += atomDataSize;
+      if (atomType == Atom.TYPE_ftyp) {
+        // Parse the atom and check the file type/brand is compatible with the extractors.
+        if (atomDataSize < 8) {
+          return false;
+        }
+        buffer.reset(atomDataSize);
+        input.peekFully(buffer.data, 0, atomDataSize);
+        int brandsCount = atomDataSize / 4;
+        for (int i = 0; i < brandsCount; i++) {
+          if (i == 1) {
+            // This index refers to the minorVersion, not a brand, so skip it.
+            buffer.skipBytes(4);
+          } else if (isCompatibleBrand(buffer.readInt())) {
+            foundGoodFileType = true;
+            break;
+          }
+        }
+        if (!foundGoodFileType) {
+          // The types were not compatible and there is only one ftyp atom, so reject the file.
+          return false;
+        }
+      } else if (atomDataSize != 0) {
+        // Skip the atom.
+        input.advancePeekPosition(atomDataSize);
+      }
+    }
+    return foundGoodFileType && fragmented == isFragmented;
+  }
+
+  /**
+   * Returns whether {@code brand} is an ftyp atom brand that is compatible with the MP4 extractors.
+   */
+  private static boolean isCompatibleBrand(int brand) {
+    // Accept all brands starting '3gp'.
+    if (brand >>> 8 == Util.getIntegerCodeForString("3gp")) {
+      return true;
+    }
+    for (int compatibleBrand : COMPATIBLE_BRANDS) {
+      if (compatibleBrand == brand) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private Sniffer() {
+    // Prevent instantiation.
+  }
+
+}
diff --git a/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/Track.java b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/Track.java
new file mode 100755
index 0000000000..6ab38f712f
--- /dev/null
+++ b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/Track.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.mpegh;
+
+import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * Encapsulates information describing an MP4 track.
+ */
+public final class Track {
+
+  /**
+   * The transformation to apply to samples in the track, if any.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({TRANSFORMATION_NONE, TRANSFORMATION_CEA608_CDAT})
+  public @interface Transformation {}
+  /**
+   * A no-op sample transformation.
+   */
+  public static final int TRANSFORMATION_NONE = 0;
+  /**
+   * A transformation for caption samples in cdat atoms.
+   */
+  public static final int TRANSFORMATION_CEA608_CDAT = 1;
+
+  /**
+   * The track identifier.
+   */
+  public final int id;
+
+  /**
+   * One of {@link C#TRACK_TYPE_AUDIO}, {@link C#TRACK_TYPE_VIDEO} and {@link C#TRACK_TYPE_TEXT}.
+   */
+  public final int type;
+
+  /**
+   * The track timescale, defined as the number of time units that pass in one second.
+   */
+  public final long timescale;
+
+  /**
+   * The movie timescale.
+   */
+  public final long movieTimescale;
+
+  /**
+   * The duration of the track in microseconds, or {@link C#TIME_UNSET} if unknown.
+   */
+  public final long durationUs;
+
+  /**
+   * The format.
+   */
+  public final Format format;
+
+  /**
+   * One of {@code TRANSFORMATION_*}. Defines the transformation to apply before outputting each
+   * sample.
+   */
+  @Transformation public final int sampleTransformation;
+
+  /**
+   * Durations of edit list segments in the movie timescale. Null if there is no edit list.
+   */
+  @Nullable public final long[] editListDurations;
+
+  /**
+   * Media times for edit list segments in the track timescale. Null if there is no edit list.
+   */
+  @Nullable public final long[] editListMediaTimes;
+
+  /**
+   * For H264 video tracks, the length in bytes of the NALUnitLength field in each sample. 0 for
+   * other track types.
+   */
+  public final int nalUnitLengthFieldLength;
+
+  @Nullable private final TrackEncryptionBox[] sampleDescriptionEncryptionBoxes;
+
+  public Track(int id, int type, long timescale, long movieTimescale, long durationUs,
+      Format format, @Transformation int sampleTransformation,
+      @Nullable TrackEncryptionBox[] sampleDescriptionEncryptionBoxes, int nalUnitLengthFieldLength,
+      @Nullable long[] editListDurations, @Nullable long[] editListMediaTimes) {
+    this.id = id;
+    this.type = type;
+    this.timescale = timescale;
+    this.movieTimescale = movieTimescale;
+    this.durationUs = durationUs;
+    this.format = format;
+    this.sampleTransformation = sampleTransformation;
+    this.sampleDescriptionEncryptionBoxes = sampleDescriptionEncryptionBoxes;
+    this.nalUnitLengthFieldLength = nalUnitLengthFieldLength;
+    this.editListDurations = editListDurations;
+    this.editListMediaTimes = editListMediaTimes;
+  }
+
+  /**
+   * Returns the {@link TrackEncryptionBox} for the given sample description index.
+   *
+   * @param sampleDescriptionIndex The given sample description index
+   * @return The {@link TrackEncryptionBox} for the given sample description index. Maybe null if no
+   *     such entry exists.
+   */
+  public TrackEncryptionBox getSampleDescriptionEncryptionBox(int sampleDescriptionIndex) {
+    return sampleDescriptionEncryptionBoxes == null ? null
+        : sampleDescriptionEncryptionBoxes[sampleDescriptionIndex];
+  }
+
+}
diff --git a/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/TrackEncryptionBox.java b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/TrackEncryptionBox.java
new file mode 100755
index 0000000000..f4ff354c45
--- /dev/null
+++ b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/TrackEncryptionBox.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.mpegh;
+
+import android.support.annotation.Nullable;
+import android.util.Log;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.util.Assertions;
+
+/**
+ * Encapsulates information parsed from a track encryption (tenc) box or sample group description 
+ * (sgpd) box in an MP4 stream.
+ */
+public final class TrackEncryptionBox {
+
+  private static final String TAG = "TrackEncryptionBox";
+
+  /**
+   * Indicates the encryption state of the samples in the sample group.
+   */
+  public final boolean isEncrypted;
+
+  /**
+   * The protection scheme type, as defined by the 'schm' box, or null if unknown.
+   */
+  @Nullable public final String schemeType;
+
+  /**
+   * A {@link TrackOutput.CryptoData} instance containing the encryption information from this
+   * {@link TrackEncryptionBox}.
+   */
+  public final TrackOutput.CryptoData cryptoData;
+
+  /**
+   * The initialization vector size in bytes for the samples in the corresponding sample group.
+   */
+  public final int initializationVectorSize;
+
+  /**
+   * If {@link #initializationVectorSize} is 0, holds the default initialization vector as defined
+   * in the track encryption box or sample group description box. Null otherwise.
+   */
+  public final byte[] defaultInitializationVector;
+
+  /**
+   * @param isEncrypted See {@link #isEncrypted}.
+   * @param schemeType See {@link #schemeType}.
+   * @param initializationVectorSize See {@link #initializationVectorSize}.
+   * @param keyId See {@link TrackOutput.CryptoData#encryptionKey}.
+   * @param defaultEncryptedBlocks See {@link TrackOutput.CryptoData#encryptedBlocks}.
+   * @param defaultClearBlocks See {@link TrackOutput.CryptoData#clearBlocks}.
+   * @param defaultInitializationVector See {@link #defaultInitializationVector}.
+   */
+  public TrackEncryptionBox(boolean isEncrypted, @Nullable String schemeType,
+      int initializationVectorSize, byte[] keyId, int defaultEncryptedBlocks,
+      int defaultClearBlocks, @Nullable byte[] defaultInitializationVector) {
+    Assertions.checkArgument(initializationVectorSize == 0 ^ defaultInitializationVector == null);
+    this.isEncrypted = isEncrypted;
+    this.schemeType = schemeType;
+    this.initializationVectorSize = initializationVectorSize;
+    this.defaultInitializationVector = defaultInitializationVector;
+    cryptoData = new TrackOutput.CryptoData(schemeToCryptoMode(schemeType), keyId,
+        defaultEncryptedBlocks, defaultClearBlocks);
+  }
+
+  @C.CryptoMode
+  private static int schemeToCryptoMode(@Nullable String schemeType) {
+    if (schemeType == null) {
+      // If unknown, assume cenc.
+      return C.CRYPTO_MODE_AES_CTR;
+    }
+    switch (schemeType) {
+      case C.CENC_TYPE_cenc:
+      case C.CENC_TYPE_cens:
+        return C.CRYPTO_MODE_AES_CTR;
+      case C.CENC_TYPE_cbc1:
+      case C.CENC_TYPE_cbcs:
+        return C.CRYPTO_MODE_AES_CBC;
+      default:
+        Log.w(TAG, "Unsupported protection scheme type '" + schemeType + "'. Assuming AES-CTR "
+            + "crypto mode.");
+        return C.CRYPTO_MODE_AES_CTR;
+    }
+  }
+
+}
diff --git a/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/TrackFragment.java b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/TrackFragment.java
new file mode 100755
index 0000000000..a52198b2c8
--- /dev/null
+++ b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/TrackFragment.java
@@ -0,0 +1,193 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.mpegh;;
+
+import com.google.android.exoplayer2.extractor.ExtractorInput;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.io.IOException;
+
+/**
+ * A holder for information corresponding to a single fragment of an mp4 file.
+ */
+/* package */ final class TrackFragment {
+
+  /**
+   * The default values for samples from the track fragment header.
+   */
+  public DefaultSampleValues header;
+  /**
+   * The position (byte offset) of the start of fragment.
+   */
+  public long atomPosition;
+  /**
+   * The position (byte offset) of the start of data contained in the fragment.
+   */
+  public long dataPosition;
+  /**
+   * The position (byte offset) of the start of auxiliary data.
+   */
+  public long auxiliaryDataPosition;
+  /**
+   * The number of track runs of the fragment.
+   */
+  public int trunCount;
+  /**
+   * The total number of samples in the fragment.
+   */
+  public int sampleCount;
+  /**
+   * The position (byte offset) of the start of sample data of each track run in the fragment.
+   */
+  public long[] trunDataPosition;
+  /**
+   * The number of samples contained by each track run in the fragment.
+   */
+  public int[] trunLength;
+  /**
+   * The size of each sample in the fragment.
+   */
+  public int[] sampleSizeTable;
+  /**
+   * The composition time offset of each sample in the fragment.
+   */
+  public int[] sampleCompositionTimeOffsetTable;
+  /**
+   * The decoding time of each sample in the fragment.
+   */
+  public long[] sampleDecodingTimeTable;
+  /**
+   * Indicates which samples are sync frames.
+   */
+  public boolean[] sampleIsSyncFrameTable;
+  /**
+   * Whether the fragment defines encryption data.
+   */
+  public boolean definesEncryptionData;
+  /**
+   * If {@link #definesEncryptionData} is true, indicates which samples use sub-sample encryption.
+   * Undefined otherwise.
+   */
+  public boolean[] sampleHasSubsampleEncryptionTable;
+  /**
+   * Fragment specific track encryption. May be null.
+   */
+  public TrackEncryptionBox trackEncryptionBox;
+  /**
+   * If {@link #definesEncryptionData} is true, indicates the length of the sample encryption data.
+   * Undefined otherwise.
+   */
+  public int sampleEncryptionDataLength;
+  /**
+   * If {@link #definesEncryptionData} is true, contains binary sample encryption data. Undefined
+   * otherwise.
+   */
+  public ParsableByteArray sampleEncryptionData;
+  /**
+   * Whether {@link #sampleEncryptionData} needs populating with the actual encryption data.
+   */
+  public boolean sampleEncryptionDataNeedsFill;
+  /**
+   * The absolute decode time of the start of the next fragment.
+   */
+  public long nextFragmentDecodeTime;
+
+  /**
+   * Resets the fragment.
+   * <p>
+   * {@link #sampleCount} and {@link #nextFragmentDecodeTime} are set to 0, and both
+   * {@link #definesEncryptionData} and {@link #sampleEncryptionDataNeedsFill} is set to false,
+   * and {@link #trackEncryptionBox} is set to null.
+   */
+  public void reset() {
+    trunCount = 0;
+    nextFragmentDecodeTime = 0;
+    definesEncryptionData = false;
+    sampleEncryptionDataNeedsFill = false;
+    trackEncryptionBox = null;
+  }
+
+  /**
+   * Configures the fragment for the specified number of samples.
+   * <p>
+   * The {@link #sampleCount} of the fragment is set to the specified sample count, and the
+   * contained tables are resized if necessary such that they are at least this length.
+   *
+   * @param sampleCount The number of samples in the new run.
+   */
+  public void initTables(int trunCount, int sampleCount) {
+    this.trunCount = trunCount;
+    this.sampleCount = sampleCount;
+    if (trunLength == null || trunLength.length < trunCount) {
+      trunDataPosition = new long[trunCount];
+      trunLength = new int[trunCount];
+    }
+    if (sampleSizeTable == null || sampleSizeTable.length < sampleCount) {
+      // Size the tables 25% larger than needed, so as to make future resize operations less
+      // likely. The choice of 25% is relatively arbitrary.
+      int tableSize = (sampleCount * 125) / 100;
+      sampleSizeTable = new int[tableSize];
+      sampleCompositionTimeOffsetTable = new int[tableSize];
+      sampleDecodingTimeTable = new long[tableSize];
+      sampleIsSyncFrameTable = new boolean[tableSize];
+      sampleHasSubsampleEncryptionTable = new boolean[tableSize];
+    }
+  }
+
+  /**
+   * Configures the fragment to be one that defines encryption data of the specified length.
+   * <p>
+   * {@link #definesEncryptionData} is set to true, {@link #sampleEncryptionDataLength} is set to
+   * the specified length, and {@link #sampleEncryptionData} is resized if necessary such that it
+   * is at least this length.
+   *
+   * @param length The length in bytes of the encryption data.
+   */
+  public void initEncryptionData(int length) {
+    if (sampleEncryptionData == null || sampleEncryptionData.limit() < length) {
+      sampleEncryptionData = new ParsableByteArray(length);
+    }
+    sampleEncryptionDataLength = length;
+    definesEncryptionData = true;
+    sampleEncryptionDataNeedsFill = true;
+  }
+
+  /**
+   * Fills {@link #sampleEncryptionData} from the provided input.
+   *
+   * @param input An {@link ExtractorInput} from which to read the encryption data.
+   */
+  public void fillEncryptionData(ExtractorInput input) throws IOException, InterruptedException {
+    input.readFully(sampleEncryptionData.data, 0, sampleEncryptionDataLength);
+    sampleEncryptionData.setPosition(0);
+    sampleEncryptionDataNeedsFill = false;
+  }
+
+  /**
+   * Fills {@link #sampleEncryptionData} from the provided source.
+   *
+   * @param source A source from which to read the encryption data.
+   */
+  public void fillEncryptionData(ParsableByteArray source) {
+    source.readBytes(sampleEncryptionData.data, 0, sampleEncryptionDataLength);
+    sampleEncryptionData.setPosition(0);
+    sampleEncryptionDataNeedsFill = false;
+  }
+
+  public long getSamplePresentationTime(int index) {
+    return sampleDecodingTimeTable[index] + sampleCompositionTimeOffsetTable[index];
+  }
+
+}
diff --git a/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/TrackSampleTable.java b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/TrackSampleTable.java
new file mode 100755
index 0000000000..307a925f23
--- /dev/null
+++ b/extensions/mpegh/src/main/java/com/google/android/exoplayer2/ext/mpegh/TrackSampleTable.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.mpegh;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
+
+/**
+ * Sample table for a track in an MP4 file.
+ */
+/* package */ final class TrackSampleTable {
+
+  /**
+   * Number of samples.
+   */
+  public final int sampleCount;
+  /**
+   * Sample offsets in bytes.
+   */
+  public final long[] offsets;
+  /**
+   * Sample sizes in bytes.
+   */
+  public final int[] sizes;
+  /**
+   * Maximum sample size in {@link #sizes}.
+   */
+  public final int maximumSize;
+  /**
+   * Sample timestamps in microseconds.
+   */
+  public final long[] timestampsUs;
+  /**
+   * Sample flags.
+   */
+  public final int[] flags;
+  /**
+   * The duration of the track sample table in microseconds, or {@link C#TIME_UNSET} if the sample
+   * table is empty.
+   */
+  public final long durationUs;
+
+  public TrackSampleTable(
+      long[] offsets,
+      int[] sizes,
+      int maximumSize,
+      long[] timestampsUs,
+      int[] flags,
+      long durationUs) {
+    Assertions.checkArgument(sizes.length == timestampsUs.length);
+    Assertions.checkArgument(offsets.length == timestampsUs.length);
+    Assertions.checkArgument(flags.length == timestampsUs.length);
+
+    this.offsets = offsets;
+    this.sizes = sizes;
+    this.maximumSize = maximumSize;
+    this.timestampsUs = timestampsUs;
+    this.flags = flags;
+    this.durationUs = durationUs;
+    sampleCount = offsets.length;
+  }
+
+  /**
+   * Returns the sample index of the closest synchronization sample at or before the given
+   * timestamp, if one is available.
+   *
+   * @param timeUs Timestamp adjacent to which to find a synchronization sample.
+   * @return Index of the synchronization sample, or {@link C#INDEX_UNSET} if none.
+   */
+  public int getIndexOfEarlierOrEqualSynchronizationSample(long timeUs) {
+    // Video frame timestamps may not be sorted, so the behavior of this call can be undefined.
+    // Frames are not reordered past synchronization samples so this works in practice.
+    int startIndex = Util.binarySearchFloor(timestampsUs, timeUs, true, false);
+    for (int i = startIndex; i >= 0; i--) {
+      if ((flags[i] & C.BUFFER_FLAG_KEY_FRAME) != 0) {
+        return i;
+      }
+    }
+    return C.INDEX_UNSET;
+  }
+
+  /**
+   * Returns the sample index of the closest synchronization sample at or after the given timestamp,
+   * if one is available.
+   *
+   * @param timeUs Timestamp adjacent to which to find a synchronization sample.
+   * @return index Index of the synchronization sample, or {@link C#INDEX_UNSET} if none.
+   */
+  public int getIndexOfLaterOrEqualSynchronizationSample(long timeUs) {
+    int startIndex = Util.binarySearchCeil(timestampsUs, timeUs, true, false);
+    for (int i = startIndex; i < timestampsUs.length; i++) {
+      if ((flags[i] & C.BUFFER_FLAG_KEY_FRAME) != 0) {
+        return i;
+      }
+    }
+    return C.INDEX_UNSET;
+  }
+
+}
diff --git a/extensions/mpegh/src/main/jni/ALCApi_rename.h b/extensions/mpegh/src/main/jni/ALCApi_rename.h
new file mode 100755
index 0000000000..09adb13293
--- /dev/null
+++ b/extensions/mpegh/src/main/jni/ALCApi_rename.h
@@ -0,0 +1,17 @@
+/******************************************************************************
+ *
+ *    alc_rename.h
+ *
+ *    Header file for ALC component
+ *
+ *    (C) Copyright 2019 Sony Corporation All Rights Reserved.
+ *
+ ******************************************************************************/
+
+#pragma once
+
+#define alc_init 				t75u0149qbmywfaze2kdhpvoxn
+#define alc_set					djbhsx9ci4a5g1e2wzlrkq7o0u
+#define alc_proc				o1d4rv0ik6yqzljsben7w89xcm
+#define alc_get_version			yv68m34scoazq90p5wbdlg1i7k
+#define alc_get_worksize		hlyb21ox8395zfwdr7tme0kn6j
diff --git a/extensions/mpegh/src/main/jni/CMakeLists.txt b/extensions/mpegh/src/main/jni/CMakeLists.txt
new file mode 100755
index 0000000000..fe6d1181ba
--- /dev/null
+++ b/extensions/mpegh/src/main/jni/CMakeLists.txt
@@ -0,0 +1,30 @@
+## cmake_version
+cmake_minimum_required(VERSION 3.1)
+
+enable_language(CXX)
+set(CMAKE_CXX_STANDARD 14)
+
+include_directories(
+ ${CMAKE_CURRENT_SOURCE_DIR}
+ )
+
+find_library(log-lib
+             log)
+
+add_library(mpegh
+            SHARED
+            mpegh_jni.cc mpegh_decoder.cc)
+
+add_library(SonyIA_mobile STATIC IMPORTED)
+set_target_properties(SonyIA_mobile
+                      PROPERTIES IMPORTED_LOCATION
+                      ${CMAKE_CURRENT_SOURCE_DIR}/mpegh/android-libs/${ANDROID_ABI}/libSonyIA_mobile.a)
+
+add_library(AlcApi STATIC IMPORTED)
+set_target_properties(AlcApi
+                      PROPERTIES IMPORTED_LOCATION
+                      ${CMAKE_CURRENT_SOURCE_DIR}/mpegh/android-libs/${ANDROID_ABI}/libAlcApi.a)
+
+target_link_libraries(
+        mpegh SonyIA_mobile AlcApi ${log-lib}
+)
\ No newline at end of file
diff --git a/extensions/mpegh/src/main/jni/alc.h b/extensions/mpegh/src/main/jni/alc.h
new file mode 100755
index 0000000000..6d4ab4aa96
--- /dev/null
+++ b/extensions/mpegh/src/main/jni/alc.h
@@ -0,0 +1,76 @@
+/******************************************************************************
+ *
+ *    alc.h
+ *
+ *    Header file for ALC component
+ *
+ *    (C) Copyright 2019 Sony Corporation All Rights Reserved.
+ *
+ ******************************************************************************/
+
+#ifndef ALC_H
+#define ALC_H
+
+#ifdef RENAME_SYMBOL
+#include "ALCApi_rename.h"
+#endif
+
+typedef struct {
+    unsigned int fs;
+    short        ramp_coef;
+    short        ramp_shift;
+    short        alc_delay;
+    int          alc_att_time;
+    int          alc_rel_time;
+    short        alc_comp_thresh;
+    short        alc_gate_thresh;
+	int          gain;
+} alc_config_t;
+
+//#define ALC_WORKSIZE                 9086
+//#define ALC_WORKSIZE                 17278
+#define ALC_WORKSIZE                 39278
+
+#define ALC_SUCCESS                     0
+#define ALC_FAIL_NOINIT              (-1)
+#define ALC_FAIL_ADDR                (-2)
+#define ALC_FAIL_BLOCK_SIZE          (-3)
+#define ALC_FAIL_FS                  (-4)
+#define ALC_FAIL_ALLOC               (-5)
+#define ALC_FAIL_FREE                (-6)
+
+#define ALC_FAIL_ALC_DELAY           (-7)
+#define ALC_FAIL_GAIN                (-8)
+
+#define ALC_DELAY_44                  22
+#define ALC_DELAY_48                  24
+
+#define ALC_ATT_x44                0x6b231a90
+#define ALC_ATT_x48                0x67d2ec9b
+#define ALC_REL_x44                0x7fff67d3
+#define ALC_REL_x48                0x7fff7430
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+int alc_init(
+    void *alc_work_ptr,
+    unsigned int framelength
+);
+int alc_set(
+    void *alc_work_ptr,
+    alc_config_t *alc_config
+);
+int alc_proc(
+    void *alc_work_ptr,
+    float *input,
+    float *output
+);
+int alc_get_version(void);
+int alc_get_worksize(void);
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ALC_H */
diff --git a/extensions/mpegh/src/main/jni/libSonyIA_mobile.h b/extensions/mpegh/src/main/jni/libSonyIA_mobile.h
new file mode 100755
index 0000000000..c228b9cb78
--- /dev/null
+++ b/extensions/mpegh/src/main/jni/libSonyIA_mobile.h
@@ -0,0 +1,68 @@
+/***********************************************************************************
+ Unified library of MPEG-H 3D Audio Core Decoder, GE Renderer and Virtualizer
+ ***********************************************************************************/
+
+#ifndef __LIB_SIA_MOBILE_H__
+#define __LIB_SIA_MOBILE_H__
+
+#ifdef __cplusplus
+//#define EXTERNC extern "C"
+#if defined(__WIN32__)
+#define EXTERNC extern "C" __declspec(dllexport) 
+#elif defined(__GNUC__) && __GNUC__ >= 4
+#define EXTERNC extern "C" __attribute__ ((visibility("default")))
+#elif defined(__GNUC__) && __GNUC__ >= 2
+#define EXTERNC extern "C" __declspec(dllexport)
+#else
+#define EXTERNC extern "C"
+#endif
+#else
+#define EXTERNC
+#endif
+
+#define SIA_ERR_NO_ERROR         0
+#define SIA_ERR_MEM_ALLOC        1
+#define SIA_ERR_GET_HANDLE       2
+#define SIA_ERR_NULL_HANDLE      3
+#define SIA_ERR_TYPE_1           4
+#define SIA_ERR_TYPE_2           5
+#define SIA_ERR_TYPE_3           6
+
+typedef struct _sia_mha_struct_ *SIA_MHA_HANDLE;
+
+typedef struct _sia_mha_param_ {
+  int reserved[16];
+} SIA_MHA_PARAM;
+
+
+EXTERNC unsigned int sia_mha_getVersion(void);
+EXTERNC int sia_mha_getHandle(SIA_MHA_HANDLE *phSiaDec, const char *appRootPath, const char *fnameCoef1, const char *fnameCoef2);
+EXTERNC void sia_mha_freeHandle(SIA_MHA_HANDLE hSiaDec);
+EXTERNC int sia_mha_init(SIA_MHA_HANDLE hSiaDec, SIA_MHA_PARAM *pParam);
+EXTERNC int sia_mha_close(SIA_MHA_HANDLE hSiaDec);
+EXTERNC int sia_mha_reset(SIA_MHA_HANDLE hSiaDec);
+
+EXTERNC int sia_mha_procFrame(SIA_MHA_HANDLE hSiaDec, int *isLastFrame, float **pOutput);
+
+EXTERNC int sia_mha_fOpen(SIA_MHA_HANDLE hSiaDec, char *inFile);
+EXTERNC int sia_mha_fReadFrame(SIA_MHA_HANDLE hSiaDec, int *isLastFrame);
+EXTERNC int sia_mha_fClose(SIA_MHA_HANDLE hSiaDec);
+
+EXTERNC int sia_mha_bsOpen(SIA_MHA_HANDLE hSiaDec, unsigned char *bs_in, long bs_size);
+EXTERNC int sia_mha_bsReadFrame(SIA_MHA_HANDLE hSiaDec, unsigned char *bs_in, long bs_size, int *isLastFrame);
+EXTERNC int sia_mha_bsClose(SIA_MHA_HANDLE hSiaDec);
+
+EXTERNC void sia_mha_getErrorDetail(SIA_MHA_HANDLE hSiaDec, int *pErrorCode, int *pErrorDetail);
+EXTERNC unsigned int sia_mha_getNumObjects(SIA_MHA_HANDLE hSiaDec);
+EXTERNC unsigned int sia_mha_getTotalNumFrames(SIA_MHA_HANDLE hSiaDec);
+EXTERNC unsigned int sia_mha_getCurrentFrameIndex(SIA_MHA_HANDLE hSiaDec);
+EXTERNC int sia_mha_setFrameIndex(SIA_MHA_HANDLE hSiaDec, unsigned int index);
+
+EXTERNC int sia_mha_rawbsOpen(SIA_MHA_HANDLE hSiaDec, unsigned char *bs_in, long bs_size);
+EXTERNC int sia_mha_rawbsReadFrame(SIA_MHA_HANDLE hSiaDec, unsigned char *bs_in, long bs_size, int *isLastFrame);
+EXTERNC int sia_mha_rawbsClose(SIA_MHA_HANDLE hSiaDec);
+
+EXTERNC int sia_coef1_getVersion(SIA_MHA_HANDLE hSiaDec, signed char *name, unsigned char *sum, 
+								int *year, int *month, int *day, int *hour, int *min);
+EXTERNC int sia_coef2_getVersion(SIA_MHA_HANDLE hSiaDec, signed char *name, unsigned char *sum);
+#endif /* __LIB_SIA_MOBILE_H__ */
diff --git a/extensions/mpegh/src/main/jni/mpegh/android-libs/arm64-v8a/libAlcApi.a b/extensions/mpegh/src/main/jni/mpegh/android-libs/arm64-v8a/libAlcApi.a
new file mode 100755
index 0000000000..8925b6c57f
Binary files /dev/null and b/extensions/mpegh/src/main/jni/mpegh/android-libs/arm64-v8a/libAlcApi.a differ
diff --git a/extensions/mpegh/src/main/jni/mpegh/android-libs/arm64-v8a/libSonyIA_mobile.a b/extensions/mpegh/src/main/jni/mpegh/android-libs/arm64-v8a/libSonyIA_mobile.a
new file mode 100755
index 0000000000..a107e0d3f8
Binary files /dev/null and b/extensions/mpegh/src/main/jni/mpegh/android-libs/arm64-v8a/libSonyIA_mobile.a differ
diff --git a/extensions/mpegh/src/main/jni/mpegh/android-libs/armeabi-v7a/libAlcApi.a b/extensions/mpegh/src/main/jni/mpegh/android-libs/armeabi-v7a/libAlcApi.a
new file mode 100755
index 0000000000..ce3d987e6d
Binary files /dev/null and b/extensions/mpegh/src/main/jni/mpegh/android-libs/armeabi-v7a/libAlcApi.a differ
diff --git a/extensions/mpegh/src/main/jni/mpegh/android-libs/armeabi-v7a/libSonyIA_mobile.a b/extensions/mpegh/src/main/jni/mpegh/android-libs/armeabi-v7a/libSonyIA_mobile.a
new file mode 100755
index 0000000000..fab6e988bc
Binary files /dev/null and b/extensions/mpegh/src/main/jni/mpegh/android-libs/armeabi-v7a/libSonyIA_mobile.a differ
diff --git a/extensions/mpegh/src/main/jni/mpegh/android-libs/x86/libAlcApi.a b/extensions/mpegh/src/main/jni/mpegh/android-libs/x86/libAlcApi.a
new file mode 100755
index 0000000000..3d3447a33c
Binary files /dev/null and b/extensions/mpegh/src/main/jni/mpegh/android-libs/x86/libAlcApi.a differ
diff --git a/extensions/mpegh/src/main/jni/mpegh/android-libs/x86/libSonyIA_mobile.a b/extensions/mpegh/src/main/jni/mpegh/android-libs/x86/libSonyIA_mobile.a
new file mode 100755
index 0000000000..442c6723f3
Binary files /dev/null and b/extensions/mpegh/src/main/jni/mpegh/android-libs/x86/libSonyIA_mobile.a differ
diff --git a/extensions/mpegh/src/main/jni/mpegh/android-libs/x86_64/libAlcApi.a b/extensions/mpegh/src/main/jni/mpegh/android-libs/x86_64/libAlcApi.a
new file mode 100755
index 0000000000..7838c3591b
Binary files /dev/null and b/extensions/mpegh/src/main/jni/mpegh/android-libs/x86_64/libAlcApi.a differ
diff --git a/extensions/mpegh/src/main/jni/mpegh/android-libs/x86_64/libSonyIA_mobile.a b/extensions/mpegh/src/main/jni/mpegh/android-libs/x86_64/libSonyIA_mobile.a
new file mode 100755
index 0000000000..8e89f4d29f
Binary files /dev/null and b/extensions/mpegh/src/main/jni/mpegh/android-libs/x86_64/libSonyIA_mobile.a differ
diff --git a/extensions/mpegh/src/main/jni/mpegh_decoder.cc b/extensions/mpegh/src/main/jni/mpegh_decoder.cc
new file mode 100755
index 0000000000..736aa7d164
--- /dev/null
+++ b/extensions/mpegh/src/main/jni/mpegh_decoder.cc
@@ -0,0 +1,256 @@
+#include <stdlib.h>
+#include <cstdint>
+#include <cstring>
+#include <string>
+#include <android/log.h>
+#include "mpegh_decoder.h"
+
+#define LOG_TAG "mpegh_decoder"
+#define LOGE(...) ((void)__android_log_print(ANDROID_LOG_ERROR, LOG_TAG, \
+                                             __VA_ARGS__))
+#define LOGI(...) ((void)__android_log_print(ANDROID_LOG_INFO, LOG_TAG, \
+                                             __VA_ARGS__))
+#define LOGD(...) ((void)__android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, \
+                                             __VA_ARGS__))
+
+/**
+ * Alc configuration
+ */
+static constexpr alc_config_t alc_default_config = {
+  48000,
+  0x0000,             // ramp_coef = 0dB
+  0,                  // ramp_shift = 0dB
+  ALC_DELAY_48,
+  ALC_ATT_x48,
+  ALC_REL_x48,
+  (short)0x0000,      // comp_thresh = 0dBFS
+  (short)0x8000,      // gate_thresh
+  AMPLIFY_GAIN_DB     // front gain(dB)
+};
+static constexpr uint16_t alc_alignment = 32;  // 32byte = 256bit
+
+MpeghDecoder::MpeghDecoder(const std::string& root_path,
+                           const std::string& config_path_hrtf,
+                           const std::string& config_path_cp)
+                           : is_initialized_(false)
+                           , is_opened_(false) {
+  LOGD("%s", __FUNCTION__);
+  int work_size = alc_get_worksize();
+  if (work_size <= 0) return;
+
+  uint8_t *work_area = NULL;
+  int error = posix_memalign(reinterpret_cast<void**>(&work_area),
+                             alc_alignment, work_size);
+  if (error != 0) {
+    LOGE("posix_memalign error : %d", error);
+    return;
+  } else if (reinterpret_cast<uint64_t>(work_area) % alc_alignment != 0) {
+    LOGE("alc work area not aligned");
+    return;
+  }
+  p_alc_work_area_.reset(work_area);
+  LOGD("alc work area : %p", p_alc_work_area_.get());
+
+  Initialize(root_path, config_path_hrtf, config_path_cp);
+}
+
+bool MpeghDecoder::Initialize(const std::string& rootPath,
+                              const std::string& configFilePathHrtf,
+                              const std::string& configFilePathCp) {
+  LOGD("%s::sia_mha_getVersion()", __FUNCTION__);
+  unsigned int version = sia_mha_getVersion();
+  LOGI("SIA decoder lib version %2d.%02d.%02d\n",
+      (version >> 16) & 0xFF, (version >> 8) & 0xFF, version & 0xFF);
+
+  // Alc initialize
+  bool alc_ret = AlcInit();
+  if (alc_ret == false) {
+      LOGE("Alc initialize failed");
+      return false;
+  }
+  LOGD("alc work buffer size : %d", alc_get_worksize());
+  LOGI("RootPath: %s", rootPath.c_str());
+  LOGI("HrtfConfigPath: %s", configFilePathHrtf.c_str());
+  LOGI("CpConfigPath: %s", configFilePathCp.c_str());
+
+  _sia_mha_struct_* context;
+  unsigned int uret = sia_mha_getHandle(&context, rootPath.c_str(),
+                                        configFilePathHrtf.c_str(),
+                                        configFilePathCp.c_str());
+  LOGD("%s::sia_mha_getHandle() ret:%d cxt:%p", __FUNCTION__, uret, context);
+  if (uret) {
+      LOGE("Failed to allocate context.");
+      return false;
+  }
+  p_context_.reset(context);
+
+  is_initialized_ = true;
+  return true;
+}
+
+bool MpeghDecoder::Open(size_t config_size, uint8_t *config) {
+
+  if (!is_initialized_ || is_opened_) return false;
+
+  p_mhac_config_.reset(new uint8_t[config_size]);
+  std::memcpy(static_cast<void*>(p_mhac_config_.get()),
+              static_cast<const void*>(config),
+              config_size);
+
+  int ret = sia_mha_rawbsOpen(p_context_.get(),
+                              p_mhac_config_.get(),
+                              config_size);
+  LOGD("%s::sia_mha_rawbsOpen(cxt:%p, mhac:%p, mhac_size:%d)",
+       __FUNCTION__, p_context_.get(), p_mhac_config_.get(),
+      static_cast<int>(config_size));
+  if (ret) {
+      LOGE("sia_mha_rawbsOpen failed ret:%d", ret);
+      if (ret >= SIA_ERR_TYPE_1) {
+          PrintLastError();
+      }
+      p_mhac_config_.reset();
+      return false;
+  }
+
+  SIA_MHA_PARAM param = {0};
+  ret = sia_mha_init(p_context_.get(), &param);
+  LOGD("%s::sia_mha_init(cxt:%p, param:%p)",
+       __FUNCTION__, p_context_.get(), &param);
+  if (ret) {
+      LOGE("sia_mha_init failed ret:%d", ret);
+      if (ret >= SIA_ERR_TYPE_1) {
+          PrintLastError();
+      }
+      sia_mha_rawbsClose(p_context_.get());
+      p_mhac_config_.reset();
+      return false;
+  }
+
+  is_opened_ = true;
+  return true;
+}
+
+bool MpeghDecoder::Close() {
+  if (!is_initialized_ || !is_opened_) return false;
+  int ret = sia_mha_close(p_context_.get());
+  LOGD("%s::sia_mha_close(cxt:%p)",
+       __FUNCTION__, p_context_.get());
+  if (ret) {
+    LOGE("sia_mha_close() error : %d", ret);
+  }
+  ret = sia_mha_rawbsClose(p_context_.get());
+  LOGD("%s::sia_mha_rawbsClose(cxt:%p)",
+       __FUNCTION__, p_context_.get());
+  if (ret) {
+    LOGE("sia_mha_bsClose() error : %d", ret);
+  }
+  p_mhac_config_.reset();
+
+  is_opened_ = false;
+  return true;
+}
+
+bool MpeghDecoder::Decode(uint8_t *inputBuffer, int inputSize,
+                          float* outputBuffer) {
+  int result = 0;
+  int is_last_frame = 0;
+  if (inputBuffer == NULL || outputBuffer == NULL) return false;
+  if (inputSize <= 0) return false;
+  if (!is_initialized_ || !is_opened_) return false;
+
+  result = sia_mha_rawbsReadFrame(p_context_.get(),
+                                  inputBuffer, inputSize, &is_last_frame);
+  if (result) {
+    LOGE("sia_mha_rawbsReadFrame : %d", result);
+    if (result >= SIA_ERR_TYPE_1) {
+      PrintLastError();
+    }
+      return false;
+  }
+
+  float temp_buff_planar[SAMPLE_PER_FRAME * NUMBER_OF_CHANNELS];
+  float *p_pcm_out[NUMBER_OF_CHANNELS] =
+          {temp_buff_planar, temp_buff_planar + SAMPLE_PER_FRAME};
+  result = sia_mha_procFrame(p_context_.get(), &is_last_frame, p_pcm_out);
+  if (result) {
+    LOGE("sia_mha_procFrame : %d", result);
+    return false;
+  }
+
+  int i, j;
+  for (i=0; i < SAMPLE_PER_FRAME; i++) {
+    for (j=0; j < NUMBER_OF_CHANNELS; j++) {
+      outputBuffer[(i*NUMBER_OF_CHANNELS)+j] = *(p_pcm_out[j]+i);
+    }
+  }
+
+  // Alc process
+  result = alc_proc(GetAlcHandle(), outputBuffer, outputBuffer);
+  if (result != 0) {
+    LOGE("alc_proc() : error (code=%d)\n", result);
+    return false;
+  }
+
+  return true;
+}
+
+void MpeghDecoder::Reset() {
+  if (!is_initialized_ || !is_opened_) return;
+  sia_mha_reset(p_context_.get());
+  LOGD("%s()", __FUNCTION__);
+}
+
+void MpeghDecoder::PrintLastError() {
+  int error_code = 0;
+  int error_detail = 0;
+  sia_mha_getErrorDetail(p_context_.get(), &error_code, &error_detail);
+  LOGE("Error_code:%d error_detail:%d", error_code, error_detail);
+}
+
+bool MpeghDecoder::AlcInit() {
+  int ret = alc_init(GetAlcHandle(), SAMPLE_PER_FRAME);
+  LOGD("%s(handle:%p, samples:%d)",
+       __FUNCTION__, GetAlcHandle(), SAMPLE_PER_FRAME);
+  if (ret != 0) {
+    LOGE("alc_init() : error (code=%d)\n", ret);
+    return false;
+  }
+
+  ret = alc_set(GetAlcHandle(), const_cast<alc_config_t*>(&alc_default_config));
+  LOGD("%s(handle:%p)",
+       __FUNCTION__, GetAlcHandle());
+  PrintAlcParam(alc_default_config);
+  if (ret != 0) {
+    LOGE("alc_set() : error (code=%d)\n", ret);
+    return false;
+  }
+
+  return true;
+}
+
+void* MpeghDecoder::GetAlcHandle() {
+  return static_cast<void*>(p_alc_work_area_.get());
+}
+
+void MpeghDecoder::PrintAlcParam(const alc_config_t& alc_config) {
+  LOGI("AlcParam");
+  LOGI("\tfs:%d", alc_config.fs);
+  LOGI("\tramp_coef:%d", alc_config.ramp_coef);
+  LOGI("\tramp_shift:%d", alc_config.ramp_shift);
+  LOGI("\tdelay:%d", alc_config.alc_delay);
+  LOGI("\tatt_time:%x", alc_config.alc_att_time);
+  LOGI("\trel_time:%x", alc_config.alc_rel_time);
+  LOGI("\tcomp_thresh:%hx", alc_config.alc_comp_thresh);
+  LOGI("\tgate_thresh:%hx", alc_config.alc_gate_thresh);
+  LOGI("\tgain:%d", alc_config.gain);
+}
+
+void MpeghDecoder::SiaMhaDeleter::operator()(_sia_mha_struct_* handle) const {
+  LOGD("%s::sia_mha_freeHandle(cxt:%p)", __FUNCTION__, handle);
+  sia_mha_freeHandle(handle);
+}
+
+void MpeghDecoder::AlignedAllocDeleter::operator()(uint8_t* data) const {
+  LOGD("%s(free(%p)", __FUNCTION__, data);
+  free(data);
+}
\ No newline at end of file
diff --git a/extensions/mpegh/src/main/jni/mpegh_decoder.h b/extensions/mpegh/src/main/jni/mpegh_decoder.h
new file mode 100755
index 0000000000..14a97273e1
--- /dev/null
+++ b/extensions/mpegh/src/main/jni/mpegh_decoder.h
@@ -0,0 +1,81 @@
+#ifndef EXTENSIONS_MPEGH_SRC_MAIN_JNI_MPEGH_DECODER_H_
+#define EXTENSIONS_MPEGH_SRC_MAIN_JNI_MPEGH_DECODER_H_
+
+#include <stdlib.h>
+#include <memory>
+#include <string>
+#include "libSonyIA_mobile.h"
+#include "alc.h"
+
+static const int AMPLIFY_GAIN_DB      = 2;
+static const int NUMBER_OF_CHANNELS   = 2;
+static const int SUPPORT_FREQUENCY    = 48000;
+static const int SAMPLE_PER_FRAME     = 1024;
+static const int SAMPLE_SIZE          = 4;    // single-presision float
+static const int OUTPUT_SIZE          = SAMPLE_PER_FRAME * NUMBER_OF_CHANNELS *
+                                        SAMPLE_SIZE;
+
+class MpeghDecoder {
+ public:
+    MpeghDecoder(const std::string& root_path,
+                 const std::string& config_path_hrtf,
+                 const std::string& config_path_cp);
+    ~MpeghDecoder() = default;
+    MpeghDecoder(const MpeghDecoder& rhs) = delete;
+    MpeghDecoder& operator=(const MpeghDecoder& rhs) = delete;
+
+   /*!
+   * Set mpeg-h configulation (mhac container)
+   *
+   * [in] config_size   mhac configuration size
+   * [in] config        pointer to mhac configuration
+   * [return] true : success false : failed
+   */
+    bool Open(size_t config_size, uint8_t *config);
+
+   /*!
+   * Decode mpeg-h data
+   *
+   * [in] input_buffer    pointer to mpeg-h sample
+   * [in] input_size      size of one sample of mpeg-h data
+   * [out] output_buffer  pointer to output buffer
+   *                      output sample is always 1024sample/ch=2048sample
+   * [return] true : success false : failed
+   */
+    bool Decode(uint8_t *input_buffer, int input_size,
+                float* output_buffer);
+
+   /*!
+   * Reset decoder's internal state
+   */
+    void Reset();
+
+   /*!
+   * Close mpegh decoder and reset mpeg-h configulation
+   */
+    bool Close();
+
+    struct SiaMhaDeleter {
+      void operator()(_sia_mha_struct_* handle) const;
+    };
+
+    struct AlignedAllocDeleter {
+      void operator()(uint8_t* data) const;
+    };
+
+ private:
+    std::unique_ptr<_sia_mha_struct_, SiaMhaDeleter> p_context_;
+    std::unique_ptr<uint8_t> p_mhac_config_;
+    std::unique_ptr<uint8_t, AlignedAllocDeleter> p_alc_work_area_;
+    bool is_initialized_;
+    bool is_opened_;
+    void PrintLastError();
+    bool Initialize(const std::string& rootPath,
+                    const std::string& configFilePathHrtf,
+                    const std::string& configFilePathCp);
+    bool AlcInit();
+    void* GetAlcHandle();
+    void PrintAlcParam(const alc_config_t& alc_config);
+};
+
+#endif  // EXTENSIONS_MPEGH_SRC_MAIN_JNI_MPEGH_DECODER_H_
diff --git a/extensions/mpegh/src/main/jni/mpegh_jni.cc b/extensions/mpegh/src/main/jni/mpegh_jni.cc
new file mode 100755
index 0000000000..fb18e5e6f1
--- /dev/null
+++ b/extensions/mpegh/src/main/jni/mpegh_jni.cc
@@ -0,0 +1,176 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <jni.h>
+#include <android/log.h>
+#include <cstring>
+#include <sstream>
+#include "mpegh_decoder.h"
+
+extern "C" {
+#ifdef __cplusplus
+#define __STDC_CONSTANT_MACROS
+#ifdef _STDINT_H
+#undef _STDINT_H
+#endif
+#include <stdint.h>
+#endif
+}
+
+#define LOG_TAG "mpegh_jni"
+#define LOGE(...) ((void)__android_log_print(ANDROID_LOG_ERROR, LOG_TAG, \
+                                             __VA_ARGS__))
+#define LOGI(...) ((void)__android_log_print(ANDROID_LOG_INFO, LOG_TAG, \
+                                             __VA_ARGS__))
+#define LOGD(...) ((void)__android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, \
+                                             __VA_ARGS__))
+
+#define DECODER_FUNC(RETURN_TYPE, NAME, ...)                            \
+  extern "C" {                                                          \
+    JNIEXPORT RETURN_TYPE                                               \
+    Java_com_google_android_exoplayer2_ext_mpegh_MpeghDecoder_ ## NAME  \
+    (JNIEnv* env, jobject thiz, ##__VA_ARGS__);                         \
+  }                                                                     \
+  JNIEXPORT RETURN_TYPE                                                 \
+  Java_com_google_android_exoplayer2_ext_mpegh_MpeghDecoder_ ## NAME    \
+  (JNIEnv* env, jobject thiz, ##__VA_ARGS__)                            \
+
+#define LIBRARY_FUNC(RETURN_TYPE, NAME, ...)                            \
+    extern "C" {                                                        \
+      JNIEXPORT RETURN_TYPE                                             \
+      Java_com_google_android_exoplayer2_ext_mpegh_MpeghLibrary_ ## NAME \
+      (JNIEnv* env, jobject thiz, ##__VA_ARGS__);                       \
+    }                                                                   \
+    JNIEXPORT RETURN_TYPE                                               \
+    Java_com_google_android_exoplayer2_ext_mpegh_MpeghLibrary_ ## NAME  \
+    (JNIEnv* env, jobject thiz, ##__VA_ARGS__)                          \
+
+jint JNI_OnLoad(JavaVM *vm, void *reserved) {
+    JNIEnv *env;
+    if (vm->GetEnv(reinterpret_cast<void**>(&env), JNI_VERSION_1_6) != JNI_OK) {
+        return -1;
+    }
+    return JNI_VERSION_1_6;
+}
+
+LIBRARY_FUNC(jstring, MpeghGetVersion) {
+    unsigned int version = sia_mha_getVersion();
+    unsigned int X = (version >> 16) & 0xFF;
+    unsigned int Y = (version >> 8) & 0xFF;
+    unsigned int Z = version & 0xFF;
+    std::ostringstream stream;
+    stream << X << "." << Y << "." << Z;
+    return env->NewStringUTF(stream.str().c_str());
+}
+
+DECODER_FUNC(jlong, MpeghInitialize, jbyteArray extraData,
+             jstring rootPath, jstring configFilePathHrtf,
+             jstring configFilePathCp) {
+    const char* root = env->GetStringUTFChars(rootPath, 0);
+    const char* hrtf = env->GetStringUTFChars(configFilePathHrtf, 0);
+    const char* cp = env->GetStringUTFChars(configFilePathCp, 0);
+    jsize config_size = env->GetArrayLength(extraData);
+    jbyte *config = env->GetByteArrayElements(extraData, 0);
+
+    LOGI("Decoder 1");
+    // mpehg decoder initialize
+    MpeghDecoder* decoder = new MpeghDecoder(std::string(root),
+                                             std::string(hrtf),
+                                             std::string(cp));
+    bool ret = decoder->Open(config_size, reinterpret_cast<uint8_t*>(config));
+    if (ret != true) {
+        delete decoder;
+        decoder = NULL;
+    }
+
+    env->ReleaseByteArrayElements(extraData, config, 0);
+    env->ReleaseStringUTFChars(rootPath, root);
+    env->ReleaseStringUTFChars(configFilePathHrtf, hrtf);
+    env->ReleaseStringUTFChars(configFilePathCp, cp);
+
+    return (jlong)decoder;
+}
+
+DECODER_FUNC(jint, MpeghDecode, jlong jHandle, jobject inputData,
+             jint inputSize, jobject outputData, jint outputSize) {
+    if (!jHandle) {
+        LOGE("Handler must be non-NULL.");
+        return -1;
+    }
+    if (!inputData || !outputData) {
+        LOGE("Input and output buffers must be non-NULL.");
+        return -1;
+    }
+    if (inputSize < 0) {
+        LOGE("Invalid input buffer size: %d.", inputSize);
+        return -1;
+    }
+    if (outputSize < SAMPLE_PER_FRAME*NUMBER_OF_CHANNELS*sizeof(float)) {
+        LOGE("Invalid output buffer length: %d", outputSize);
+        return -1;
+    }
+
+    MpeghDecoder* decoder =
+            reinterpret_cast<MpeghDecoder*>(jHandle);
+    uint8_t *inputBuffer =
+            reinterpret_cast<uint8_t*>(env->GetDirectBufferAddress(inputData));
+    float *outputBuffer =
+            reinterpret_cast<float*>(env->GetDirectBufferAddress(outputData));
+    bool ret = decoder->Decode(inputBuffer,
+                               inputSize,
+                               outputBuffer);
+    if (ret == false) return 0;
+
+    return OUTPUT_SIZE;
+}
+
+DECODER_FUNC(jint, MpeghGetChannelCount, jlong jHandle) {
+    if (!jHandle) {
+        LOGE("Handle must be non-NULL.");
+        return -1;
+    }
+    return NUMBER_OF_CHANNELS;
+}
+
+DECODER_FUNC(jint, MpeghGetSampleRate, jlong jHandle) {
+    if (!jHandle) {
+        LOGE("Handle must be non-NULL.");
+        return -1;
+    }
+    return SUPPORT_FREQUENCY;
+}
+
+DECODER_FUNC(jlong, MpeghReset, jlong jHandle, jbyteArray extraData) {
+    if (!jHandle) {
+        LOGE("Handle must be non-NULL.");
+        return 0L;
+    }
+    MpeghDecoder *decoder =
+            reinterpret_cast<MpeghDecoder*>(jHandle);
+    decoder->Reset();
+    return (jlong) jHandle;
+}
+
+DECODER_FUNC(void, MpeghRelease, jlong jHandle) {
+    if (!jHandle) {
+        LOGE("Handle must be non-NULL.");
+        return;
+    }
+    MpeghDecoder *decoder =
+            reinterpret_cast<MpeghDecoder*>(jHandle);
+    decoder->Close();
+    delete decoder;
+    return;
+}
diff --git a/extensions/virtualizer/README.md b/extensions/virtualizer/README.md
new file mode 100755
index 0000000000..bcd37a6fdc
--- /dev/null
+++ b/extensions/virtualizer/README.md
@@ -0,0 +1,2 @@
+# ExoPlayer Sony 3D Audio Virtualizer Processor extension #
+
diff --git a/extensions/virtualizer/build.gradle b/extensions/virtualizer/build.gradle
new file mode 100755
index 0000000000..72b5c58dde
--- /dev/null
+++ b/extensions/virtualizer/build.gradle
@@ -0,0 +1,63 @@
+// Copyright (C) 2017 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+apply from: '../../constants.gradle'
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion project.ext.compileSdkVersion
+    buildToolsVersion project.ext.buildToolsVersion
+
+    defaultConfig {
+        minSdkVersion project.ext.minSdkVersion
+        targetSdkVersion project.ext.targetSdkVersion
+        consumerProguardFiles 'proguard-rules.txt'
+        ndk {
+            abiFilters 'armeabi-v7a', 'arm64-v8a'
+        }
+        externalNativeBuild {
+            cmake {
+                cppFlags '-std=c++11'
+                arguments '-DANDROID_ARM_NEON=TRUE',
+                        '-DANDROID_CPP_FEATURES=rtti exceptions',
+                        '-DANDROID_ARM_NEON=true',
+                        '-DANDROID_PLATFORM=android-21',
+                        '-DANDROID_STL=gnustl_static'
+            }
+        }
+    }
+
+    // sourceSets.main {
+    //    jniLibs.srcDir 'src/main/libs'
+    //    jni.srcDirs = [] // Disable the automatic ndk-build call by Android Studio.
+    // }
+
+// Specifies the location of the top level CMakeLists.txt
+// The path is relative to the hosting directory
+// of this build.gradle file
+    externalNativeBuild {
+        cmake {
+            path "src/main/jni/CMakeLists.txt"
+        }
+    }
+
+}
+
+dependencies {
+    implementation project(modulePrefix + 'library-core')
+}
+
+ext {
+    javadocTitle = 'Sony IA audio processor'
+}
+apply from: '../../javadoc_library.gradle'
\ No newline at end of file
diff --git a/extensions/virtualizer/proguard-rules.txt b/extensions/virtualizer/proguard-rules.txt
new file mode 100755
index 0000000000..3dd6dea1b1
--- /dev/null
+++ b/extensions/virtualizer/proguard-rules.txt
@@ -0,0 +1,6 @@
+# Proguard rules specific to the mpegh extension.
+
+# This prevents the names of native methods from being obfuscated.
+-keepclasseswithmembernames class * {
+    native <methods>;
+}
diff --git a/extensions/virtualizer/src/main/AndroidManifest.xml b/extensions/virtualizer/src/main/AndroidManifest.xml
new file mode 100755
index 0000000000..f912ccebcd
--- /dev/null
+++ b/extensions/virtualizer/src/main/AndroidManifest.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<manifest package="com.google.android.exoplayer2.ext.virtualizer"/>
diff --git a/extensions/virtualizer/src/main/java/com/google/android/exoplayer2/ext/virtualizer/VirtualizerAudioProcessor.java b/extensions/virtualizer/src/main/java/com/google/android/exoplayer2/ext/virtualizer/VirtualizerAudioProcessor.java
new file mode 100755
index 0000000000..072e13ccd1
--- /dev/null
+++ b/extensions/virtualizer/src/main/java/com/google/android/exoplayer2/ext/virtualizer/VirtualizerAudioProcessor.java
@@ -0,0 +1,328 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.virtualizer;
+
+
+import android.util.Log;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.audio.AudioProcessor;
+import com.google.android.exoplayer2.util.LibraryLoader;
+import com.google.android.exoplayer2.util.Util;
+
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+
+/**
+ * An {@link AudioProcessor} that uses {@code VirtualizerAudioProcessor} to provide rendering of
+ * 3D surround sound.
+ */
+public final class VirtualizerAudioProcessor implements AudioProcessor {
+
+    static {
+        ExoPlayerLibraryInfo.registerModule("goog.exo.virtualizer");
+    }
+
+    private static final String TAG = "Virtualizer";
+    private static final LibraryLoader LOADER = new LibraryLoader("virtualizer");
+
+    private static final int FLOAT_NAN_AS_INT = Float.floatToIntBits(Float.NaN);
+    private static final double PCM_32_BIT_INT_TO_PCM_32_BIT_FLOAT_FACTOR = 1.0 / 0x7FFFFFFF;
+
+    private static final int FRAMES_PER_OUTPUT_BUFFER = 10240; // ToDo : Need to optimize
+    private static final int OUTPUT_CHANNEL_COUNT = 2;
+    private static final int OUTPUT_FRAME_SIZE = FRAMES_PER_OUTPUT_BUFFER * OUTPUT_CHANNEL_COUNT * Float.BYTES; // single-precision float
+
+    private String appRootPath;
+    private String configFilePathHrtf;
+    private String configFilePathCp;
+    private int sampleRateHz;
+    private int channelCount;
+    private int resampleRateHz;
+    private @C.PcmEncoding int sourceEncoding;
+    private boolean inputEnded;
+    private long nativeHandler;
+    private boolean initialized;
+
+    private ByteBuffer inputBuffer;
+    private ByteBuffer tempFloatBuffer;
+    private ByteBuffer outputBuffer;
+
+    public static void setLibraries(String... libraries)  {
+        LOADER.setLibraries(libraries);
+    }
+
+    /** Creates a new Virtualizer audio processor. */
+    public VirtualizerAudioProcessor(String appRootPath) {
+        Log.d(TAG, "VirtualizerAudioPorcessor() root:" + appRootPath);
+        if (!isAvailable()) {
+            // ToDo : Add Exception
+        }
+        this.appRootPath = appRootPath;
+        configFilePathHrtf = "files/com.sony.immersive-audio/coef/com.sony.360ra.hrtf2.config";
+        configFilePathCp = "files/com.sony.immersive-audio/coef/com.sony.360ra.cp.config";
+        sampleRateHz = Format.NO_VALUE;
+        channelCount = Format.NO_VALUE;
+        sourceEncoding = C.ENCODING_INVALID;
+        inputBuffer = EMPTY_BUFFER;
+        outputBuffer = EMPTY_BUFFER;
+        nativeHandler = 0;
+        initialized = false;
+    }
+
+    public static boolean isAvailable() {
+        //Log.d(TAG, "isAvailable() called");
+        return LOADER.isAvailable();
+    }
+
+    @Override
+    public synchronized boolean configure(
+            int sampleRateHz, int channelCount, @C.Encoding int encoding)
+            throws UnhandledFormatException {
+        Log.d(TAG, "configure() sampleRateHz:" + sampleRateHz +
+                " channelCount:" + channelCount + " encoding:" + encoding);
+        if (encoding == C.ENCODING_PCM_FLOAT) {
+            throw new UnhandledFormatException(sampleRateHz, channelCount, encoding);
+        }
+        if (this.sampleRateHz == sampleRateHz
+                && this.channelCount == channelCount
+                && sourceEncoding == encoding) {
+            return false;
+        }
+        this.sampleRateHz = sampleRateHz;
+        this.channelCount = channelCount;
+        sourceEncoding = encoding;
+
+        if (nativeHandler != 0) VirtualizerReset(nativeHandler);
+        nativeHandler = VirtualizerInitialize(sampleRateHz, appRootPath, configFilePathHrtf, configFilePathCp);
+        if (nativeHandler == 0) {
+            Log.e(TAG, "VirtualizerInitialize() Error");
+            throw new UnhandledFormatException(sampleRateHz, channelCount, encoding);
+        }
+        resampleRateHz = VirtualizerGetSampleRate(nativeHandler);
+        tempFloatBuffer = ByteBuffer.allocateDirect(OUTPUT_FRAME_SIZE).order(ByteOrder.nativeOrder());
+        initialized = true;
+        return true;
+    }
+
+    @Override
+    public boolean isActive()
+    {
+        Log.v(TAG, "IaActive() :" + ((nativeHandler!=0)?"true":"false"));
+        return nativeHandler != 0;
+    }
+
+    @Override
+    public int getOutputChannelCount() {
+        Log.v(TAG, "getOutputChannelCount() :" + OUTPUT_CHANNEL_COUNT);
+        return OUTPUT_CHANNEL_COUNT;
+    }
+
+    @Override
+    public int getOutputEncoding() {
+        Log.v(TAG, "getOutputEncoding() :" + C.ENCODING_PCM_16BIT);
+        return C.ENCODING_PCM_16BIT;
+    }
+
+    @Override
+    public int getOutputSampleRateHz() {
+        if (!initialized) return 0;
+        Log.v(TAG, "getOutputSampleRateHz() sampleRate:" + resampleRateHz);
+        return resampleRateHz;
+    }
+
+    @Override
+    public void queueInput(ByteBuffer inputBuffer) {
+        if (!initialized) {
+            Log.e(TAG, "queueInput Error not initialized");
+            return;
+        }
+        int position = inputBuffer.position();
+        int limit = inputBuffer.limit();
+        int size = limit - position;
+        int sampleByte = 0;
+        int resampledSize = 0;
+
+        switch (sourceEncoding) {
+            case C.ENCODING_PCM_32BIT:
+                resampledSize = size;
+                sampleByte = 4;
+                break;
+            case C.ENCODING_PCM_24BIT:
+                resampledSize = size/3*4;
+                sampleByte = 3;
+                break;
+            case C.ENCODING_PCM_16BIT:
+                resampledSize = size/2*4;
+                sampleByte = 2;
+                break;
+            case C.ENCODING_PCM_8BIT:
+                resampledSize = size*4;
+                sampleByte = 1;
+                break;
+        }
+        if (sourceEncoding == C.ENCODING_PCM_32BIT) {
+        }
+        if (this.inputBuffer.capacity() < resampledSize) {
+            this.inputBuffer = EMPTY_BUFFER;
+            this.inputBuffer = ByteBuffer.allocateDirect(resampledSize).order(ByteOrder.nativeOrder());
+        } else {
+            this.inputBuffer.clear();
+        }
+        this.inputBuffer.limit(resampledSize);
+
+        if (sourceEncoding == C.ENCODING_PCM_32BIT) {
+            for (int i = position; i < limit; i += 4) {
+                int pcm32BitInteger =
+                        (inputBuffer.get(i) & 0xFF)
+                                | ((inputBuffer.get(i + 1) & 0xFF) << 8)
+                                | ((inputBuffer.get(i + 2) & 0xFF) << 16)
+                                | ((inputBuffer.get(i + 3) & 0xFF) << 24);
+                writePcm32BitFloat(pcm32BitInteger, this.inputBuffer);
+            }
+        } else if (sourceEncoding == C.ENCODING_PCM_24BIT){
+            for (int i = position; i < limit; i += 3) {
+                int pcm32BitInteger =
+                        ((inputBuffer.get(i) & 0xFF) << 8)
+                                | ((inputBuffer.get(i + 1) & 0xFF) << 16)
+                                | ((inputBuffer.get(i + 2) & 0xFF) << 24);
+                writePcm32BitFloat(pcm32BitInteger, this.inputBuffer);
+            }
+        } else if (sourceEncoding == C.ENCODING_PCM_16BIT) {
+            for (int i = position; i < limit; i += 2) {
+                int pcm32BitInteger =
+                        ((inputBuffer.get(i) & 0xFF) << 16)
+                                | ((inputBuffer.get(i + 1) & 0xFF) << 24);
+                writePcm32BitFloat(pcm32BitInteger, this.inputBuffer);
+            }
+        } else if (sourceEncoding == C.ENCODING_PCM_8BIT) {
+            for (int i = position; i < limit; i += 1) {
+                int pcm32BitInteger =
+                        ((inputBuffer.get(i) & 0xFF) << 24);
+                writePcm32BitFloat(pcm32BitInteger, this.inputBuffer);
+            }
+        }
+        this.inputBuffer.flip();
+
+        boolean ret = VirtualizerQueueInput(this.nativeHandler, this.inputBuffer, resampledSize/Float.BYTES);
+        inputBuffer.position(position + size);
+        if (ret == false) {
+            Log.e(TAG, "queueInput() called size:" + size + " input_size:" + resampledSize/Float.BYTES);
+        }
+
+    }
+
+    @Override
+    public void queueEndOfStream() {
+        if (!initialized) {
+            Log.e(TAG, "queueEndOfStream Error not initialized");
+            return;
+        }
+        Log.v(TAG, "queueEndOfStream() called");
+        inputEnded = true;
+        //gvrAudioSurround.triggerProcessing();
+    }
+
+    @Override
+    public ByteBuffer getOutput() {
+        if (!initialized) {
+            Log.e(TAG, "getOutput Error not initialized");
+            return EMPTY_BUFFER;
+        }
+
+        tempFloatBuffer.clear();
+        outputBuffer.clear();
+        int outputSampleCount = VirtualizerGetOutput(this.nativeHandler, tempFloatBuffer, OUTPUT_FRAME_SIZE/4);
+        if (outputSampleCount == 0) {
+            outputBuffer.limit(0);
+            return outputBuffer;
+        }
+
+        int outputByteFloat = outputSampleCount * Float.BYTES;
+        tempFloatBuffer.limit(outputByteFloat);
+
+        int outputByteInt16 = outputByteFloat/2;
+        if (this.outputBuffer.capacity() < outputByteInt16) {
+            this.outputBuffer = EMPTY_BUFFER;
+            this.outputBuffer = ByteBuffer.allocateDirect(outputByteInt16).order(ByteOrder.nativeOrder());
+        } else {
+            this.outputBuffer.clear();
+        }
+        this.outputBuffer.limit(outputByteInt16);
+
+        while(tempFloatBuffer.hasRemaining()) {
+            float fsample = tempFloatBuffer.getFloat();
+            short isample;
+            fsample = fsample * 32768;
+            fsample = Math.round(fsample);
+            if( fsample > 32767 ) fsample = 32767;
+            if( fsample < -32768 ) fsample = -32768;
+            isample = (short) fsample;
+            outputBuffer.putShort(isample);
+        }
+        outputBuffer.flip();
+
+        return outputBuffer;
+    }
+
+    @Override
+    public boolean isEnded() {
+        Log.v(TAG, "isEnded() called");
+        return inputEnded;
+    }
+
+    @Override
+    public void flush() {
+        Log.v(TAG, "flush() called");
+        VirtualizerReset(nativeHandler);
+        inputEnded = false;
+    }
+
+    @Override
+    public synchronized void reset() {
+        Log.v(TAG, "reset() called");
+        inputEnded = false;
+        VirtualizerRelease(nativeHandler);
+        initialized = false;
+        nativeHandler = 0;
+    }
+
+    /**
+     * Converts the provided 32-bit integer to a 32-bit float value and writes it to {@code buffer}.
+     *
+     * @param pcm32BitInt The 32-bit integer value to convert to 32-bit float in [-1.0, 1.0].
+     * @param buffer The output buffer.
+     */
+    private static void writePcm32BitFloat(int pcm32BitInt, ByteBuffer buffer) {
+        float pcm32BitFloat = (float) (PCM_32_BIT_INT_TO_PCM_32_BIT_FLOAT_FACTOR * pcm32BitInt);
+        int floatBits = Float.floatToIntBits(pcm32BitFloat);
+        if (floatBits == FLOAT_NAN_AS_INT) {
+            floatBits = Float.floatToIntBits((float) 0.0);
+        }
+        buffer.putInt(floatBits);
+    }
+
+    private native long VirtualizerInitialize(int fs, String rootPath, String configFilePathHrtf, String configFilePathCp);
+    private native boolean VirtualizerQueueInput(long context, ByteBuffer inputData, int inputSize);
+    private native int VirtualizerGetOutput(long context, ByteBuffer outputData, int outputCapacity);
+    private native int VirtualizerGetChannelCount(long context);
+    private native int VirtualizerGetSampleRate(long context);
+    private native long VirtualizerReset(long context);
+    private native void VirtualizerRelease(long context);
+
+}
diff --git a/extensions/virtualizer/src/main/jni/Application.mk b/extensions/virtualizer/src/main/jni/Application.mk
new file mode 100755
index 0000000000..f6a4778e49
--- /dev/null
+++ b/extensions/virtualizer/src/main/jni/Application.mk
@@ -0,0 +1,20 @@
+#
+# Copyright (C) 2016 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+APP_OPTIM := release
+APP_STL := gnustl_static
+APP_CPPFLAGS += -frtti -std=c++11 -fexceptions -Wall
+APP_PLATFORM := android-21
diff --git a/extensions/virtualizer/src/main/jni/CMakeLists.txt b/extensions/virtualizer/src/main/jni/CMakeLists.txt
new file mode 100755
index 0000000000..7ff32960b4
--- /dev/null
+++ b/extensions/virtualizer/src/main/jni/CMakeLists.txt
@@ -0,0 +1,47 @@
+## cmake_version
+cmake_minimum_required(VERSION 3.1)
+
+enable_language(CXX)
+set(CMAKE_CXX_STANDARD 14)
+
+#[[
+# Sets lib_src_DIR to the path of the target CMake project.
+set( lib_src_DIR ${CMAKE_CURRENT_SOURCE_DIR}/virtualizer )
+# Sets lib_build_DIR to the path of the desired output directory.
+set( lib_build_DIR ${CMAKE_CURRENT_SOURCE_DIR}/virtualizer/outputs )
+file(MAKE_DIRECTORY ${lib_build_DIR})
+# Adds the CMakeLists.txt file located in the specified directory
+# as a build dependency.
+add_subdirectory( # Specifies the directory of the CMakeLists.txt file.
+        ${lib_src_DIR}
+        # Specifies the directory for the build outputs.
+        ${lib_build_DIR} )
+]]
+
+include_directories(
+ ${CMAKE_CURRENT_SOURCE_DIR}/../../../../../../VirtualizerLib/include/
+ )
+
+find_library( # Defines the name of the path variable that stores the
+              # location of the NDK library.
+              log-lib
+
+              # Specifies the name of the NDK library that
+              # CMake needs to locate.
+              log )
+
+add_library(virtualizer
+            SHARED
+            virtualizer_jni.cc )
+add_library(SonyVirtualizer STATIC IMPORTED)
+set_target_properties(SonyVirtualizer
+                      PROPERTIES IMPORTED_LOCATION
+                      ${CMAKE_CURRENT_SOURCE_DIR}/../../../../../../VirtualizerLib/outputs/android/${ANDROID_ABI}/libSonyVirtualizer.a)
+
+target_link_libraries(
+  virtualizer SonyVirtualizer ${log-lib}
+)
+
+#link_directories(
+#${CMAKE_CURRENT_SOURCE_DIR}/android-libs/${ANDROID_ABI}
+#)
diff --git a/extensions/virtualizer/src/main/jni/virtualizer_jni.cc b/extensions/virtualizer/src/main/jni/virtualizer_jni.cc
new file mode 100755
index 0000000000..9a683f8ada
--- /dev/null
+++ b/extensions/virtualizer/src/main/jni/virtualizer_jni.cc
@@ -0,0 +1,265 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <jni.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <cstring>
+#include <android/log.h>
+#include "libSonyVirtualizer.h"
+
+extern "C" {
+#ifdef __cplusplus
+#define __STDC_CONSTANT_MACROS
+#ifdef _STDINT_H
+#undef _STDINT_H
+#endif
+#include <stdint.h>
+#endif
+}
+
+#define LOG_TAG "Virtualizer_jni"
+#define LOGE(...) ((void)__android_log_print(ANDROID_LOG_ERROR, LOG_TAG, \
+                   __VA_ARGS__))
+#define LOGI(...) ((void)__android_log_print(ANDROID_LOG_INFO, LOG_TAG, \
+                   __VA_ARGS__))
+#define LOGD(...) ((void)__android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, \
+                   __VA_ARGS__))
+#define LOGV(...) ((void)__android_log_print(ANDROID_LOG_VERBOSE, LOG_TAG, \
+                   __VA_ARGS__))
+
+#define LIBRARY_FUNC(RETURN_TYPE, NAME, ...) \
+  extern "C" { \
+  JNIEXPORT RETURN_TYPE \
+    Java_com_google_android_exoplayer2_ext_virtualizer_VirtualizerAudioProcessor_ ## NAME \
+      (JNIEnv* env, jobject thiz, ##__VA_ARGS__);\
+  } \
+  JNIEXPORT RETURN_TYPE \
+    Java_com_google_android_exoplayer2_ext_virtualizer_VirtualizerAudioProcessor_ ## NAME \
+      (JNIEnv* env, jobject thiz, ##__VA_ARGS__)\
+
+static constexpr int NUMBER_OF_CHANNELS = 2;
+
+/**
+ * Allocates and opens a new handler for the virtualizer audio processor, passing the
+ * provided extraData as initialization data for the decoder
+ * Returns the created context.
+ */
+SIA_3DV_HANDLE createHandle(JNIEnv *env ,jint fs, jstring appRootPath,
+                            jstring configFilePathHrtf, jstring configFilePathCp);
+/**
+ * Releases the specified handle.
+ */
+void releaseHandle(SIA_3DV_HANDLE handle);
+
+jint JNI_OnLoad(JavaVM *vm, void *reserved) {
+  JNIEnv *env;
+  if (vm->GetEnv(reinterpret_cast<void**>(&env), JNI_VERSION_1_6) != JNI_OK) {
+    return -1;
+  }
+  return JNI_VERSION_1_6;
+}
+
+LIBRARY_FUNC(jstring, VirtualizerGetVersion) {
+  // LOGV("VirtualizerGetVersion() called");
+  SiaVersion version = sia_3dv_get_version();
+  char versionStr[16];
+  snprintf(versionStr, sizeof(versionStr), "V%d.%d.%d",
+           version.major, version.minorA, version.minorB);
+  return env->NewStringUTF(&versionStr[0]);
+}
+
+LIBRARY_FUNC(jlong, VirtualizerInitialize, jint fs,
+             jstring rootPath, jstring configFilePathHrtf,
+             jstring configFilePathCp) {
+  // LOGV("VirtualizerInitialize() called");
+  return (jlong) createHandle(env, fs,
+                              rootPath, configFilePathHrtf, configFilePathCp);
+}
+
+LIBRARY_FUNC(jboolean, VirtualizerQueueInput, jlong jHandle,
+             jobject inputData, jint inputSampleSize) {
+  // LOGV("VirtualizerQueueInput() called inputSampleSize:%d", inputSampleSize);
+  if (!jHandle) {
+    LOGE("Handler must be non-NULL.");
+    return false;
+  }
+  if (!inputData) {
+    LOGE("Input and output buffers must be non-NULL.");
+    return false;
+  }
+  if (inputSampleSize < 0) {
+    LOGE("Invalid input buffer size: %d.", inputSampleSize);
+    return false;
+  }
+
+  SIA_3DV_HANDLE handle = reinterpret_cast<SIA_3DV_HANDLE>(jHandle);
+  float *inputBuffer = reinterpret_cast<float*>(env->GetDirectBufferAddress(inputData));
+
+  SiaStatus ret = sia_3dv_queue_input(handle, inputSampleSize, inputBuffer, false);
+  if (ret != kSiaSuccess) {
+      LOGE("sia_3dv_queue_input error:%d", ret);
+      return false;
+  }
+
+  return true;
+}
+
+LIBRARY_FUNC(jint, VirtualizerGetOutput, jlong jHandle,
+             jobject outputData, jint outputCapacity) {
+  // LOGD("VirtualizerGetOutput() called");
+  if (!jHandle) {
+    LOGE("Handler must be non-NULL.");
+    return -1;
+  }
+  if (!outputData) {
+    LOGE("Input and output buffers must be non-NULL.");
+    return -1;
+  }
+  if (outputCapacity < 0) {
+    LOGE("Invalid output buffer size: %d.", outputCapacity);
+    return -1;
+  }
+
+  SIA_3DV_HANDLE handle =
+      reinterpret_cast<SIA_3DV_HANDLE>(jHandle);
+  float *outputBuffer = reinterpret_cast<float*>(env->GetDirectBufferAddress(outputData));
+
+  unsigned int outputSize;
+  SiaStatus ret = sia_3dv_get_output(handle, outputCapacity, outputBuffer, &outputSize);
+  if (ret != kSiaSuccess && ret != kSiaEeos && ret != kSiaEagain) {
+      LOGE("sia_3dv_get_output error:%d", ret);
+      return -1;
+  }
+
+  return outputSize;
+}
+
+LIBRARY_FUNC(jint, VirtualizerGetChannelCount, jlong jHandle) {
+  // LOGV("VirtualizerGetChannelCount() called");
+  if (!jHandle) {
+    LOGE("Handle must be non-NULL.");
+    return -1;
+  }
+  return NUMBER_OF_CHANNELS;
+}
+
+LIBRARY_FUNC(jint, VirtualizerGetSampleRate, jlong jHandle) {
+  // LOGV("VirtualizerGetSampleRate() called");
+  if (!jHandle) {
+    LOGE("Handle must be non-NULL.");
+    return -1;
+  }
+  SIA_3DV_HANDLE handle =
+      reinterpret_cast<SIA_3DV_HANDLE>(jHandle);
+  SiaFs sia_fs;
+  int fs = 0;
+  SiaStatus ret = sia_3dv_get_output_fs(handle, &sia_fs);
+  if (ret != kSiaSuccess) {
+      LOGE("sia_3dv_get_output_fs error:%d", ret);
+      return -1;
+  }
+  switch (sia_fs) {
+    case kSiaFs44100:
+      fs = 44100;
+      break;
+    case kSiaFs48000:
+      fs = 48000;
+      break;
+    default:
+      return -1;
+  }
+  return fs;
+}
+
+LIBRARY_FUNC(jlong, VirtualizerReset, jlong jHandle) {
+  // LOGV("VirtualizerReset() called");
+  if (!jHandle) {
+    LOGE("Invalid param : jHandle");
+    return 0L;
+  }
+  SIA_3DV_HANDLE handle =
+    reinterpret_cast<SIA_3DV_HANDLE>(jHandle);
+
+  sia_3dv_reset(handle);
+  return (jlong) jHandle;
+}
+
+SIA_3DV_HANDLE createHandle(JNIEnv *env , jint input_fs, jstring appRootPath,
+                            jstring configFilePathHrtf, jstring configFilePathCp) {
+
+  SIA_3DV_HANDLE handle;
+  unsigned int buffSize = 61440;
+
+  SiaStatus ret = sia_3dv_get_handle(&handle, buffSize);
+  if (ret != kSiaSuccess) {
+    LOGE("sia_3dv_get_handle error:%d", ret);
+    return 0L;
+  }
+  // LOGV("sia_3da_getHandle() handle:%p", handle);
+
+  const char* root = env->GetStringUTFChars(appRootPath, 0);
+  const char* hrtf = env->GetStringUTFChars(configFilePathHrtf, 0);
+  const char* cp = env->GetStringUTFChars(configFilePathCp, 0);
+
+  SiaFs output_sia_fs;
+  SiaFs input_sia_fs;
+  bool through_mode = false;
+  switch (input_fs) {
+      case 32000:
+          input_sia_fs = kSiaFs32000;
+          break;
+      case 44100:
+          input_sia_fs = kSiaFs44100;
+          break;
+      case 48000:
+          input_sia_fs = kSiaFs48000;
+          break;
+      case 96000:
+          input_sia_fs = kSiaFs96000;
+          break;
+      case 192000:
+          input_sia_fs = kSiaFs192000;
+          break;
+      default:
+          return 0L;
+  }
+  ret = sia_3dv_init(handle, root, hrtf, cp, input_sia_fs, &output_sia_fs, through_mode);
+  if (ret != kSiaSuccess) {
+    LOGE("sia_3dv_init error:%d", ret);
+    sia_3dv_free_handle(handle);
+    return 0L;
+  }
+  return handle;
+}
+
+void releaseHandle(SIA_3DV_HANDLE handle) {
+  if (handle) {
+    sia_3dv_free_handle(handle);
+    handle = NULL;
+  }
+}
+
+LIBRARY_FUNC(void, VirtualizerRelease, jlong jHandle) {
+  // LOGD("VirtualizerRelease() called");
+  if (!jHandle) {
+    LOGE("Invalid param : jHandle");
+    return;
+  }
+  SIA_3DV_HANDLE handle =
+      reinterpret_cast<SIA_3DV_HANDLE>(jHandle);
+  releaseHandle(handle);
+  return;
+}
diff --git a/settings.gradle b/settings.gradle
old mode 100644
new mode 100755
index d4530d67b7..082483e4c8
--- a/settings.gradle
+++ b/settings.gradle
@@ -21,10 +21,14 @@ if (gradle.ext.has('exoplayerModulePrefix')) {
 include modulePrefix + 'demo'
 include modulePrefix + 'demo-cast'
 include modulePrefix + 'demo-ima'
+include modulePrefix + 'demo-ia'
+include modulePrefix + 'soiaplayer'
 include modulePrefix + 'playbacktests'
 project(modulePrefix + 'demo').projectDir = new File(rootDir, 'demos/main')
 project(modulePrefix + 'demo-cast').projectDir = new File(rootDir, 'demos/cast')
 project(modulePrefix + 'demo-ima').projectDir = new File(rootDir, 'demos/ima')
+project(modulePrefix + 'demo-ia').projectDir = new File(rootDir, 'demos/main_ia')
+project(modulePrefix + 'soiaplayer').projectDir = new File(rootDir, 'demos/soiaplayer')
 project(modulePrefix + 'playbacktests').projectDir = new File(rootDir, 'playbacktests')
 
 apply from: 'core_settings.gradle'
