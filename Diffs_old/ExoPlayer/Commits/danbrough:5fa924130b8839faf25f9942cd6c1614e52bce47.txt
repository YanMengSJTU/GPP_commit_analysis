diff --git a/core_settings.gradle b/core_settings.gradle
index c4914e3040..4dbae5e306 100644
--- a/core_settings.gradle
+++ b/core_settings.gradle
@@ -17,6 +17,7 @@ if (gradle.ext.has('exoplayerModulePrefix')) {
     modulePrefix += gradle.ext.exoplayerModulePrefix
 }
 
+include modulePrefix + 'shoutcast'
 include modulePrefix + 'library'
 include modulePrefix + 'library-core'
 include modulePrefix + 'library-dash'
diff --git a/extensions/ffmpeg/build.gradle b/extensions/ffmpeg/build.gradle
index e2d3a08e36..dba66b30c8 100644
--- a/extensions/ffmpeg/build.gradle
+++ b/extensions/ffmpeg/build.gradle
@@ -34,7 +34,4 @@ dependencies {
     implementation project(modulePrefix + 'library-core')
 }
 
-ext {
-    javadocTitle = 'FFmpeg extension'
-}
-apply from: '../../javadoc_library.gradle'
+apply from: '../../publish.gradle'
diff --git a/extensions/flac/build.gradle b/extensions/flac/build.gradle
index d7bd37921c..36676b96c8 100644
--- a/extensions/flac/build.gradle
+++ b/extensions/flac/build.gradle
@@ -37,7 +37,5 @@ dependencies {
     androidTestImplementation project(modulePrefix + 'testutils')
 }
 
-ext {
-    javadocTitle = 'FLAC extension'
-}
-apply from: '../../javadoc_library.gradle'
+
+apply from: '../../publish.gradle'
diff --git a/shoutcast/.gitignore b/shoutcast/.gitignore
new file mode 100644
index 0000000000..796b96d1c4
--- /dev/null
+++ b/shoutcast/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/shoutcast/build.gradle b/shoutcast/build.gradle
new file mode 100644
index 0000000000..6a001ae795
--- /dev/null
+++ b/shoutcast/build.gradle
@@ -0,0 +1,34 @@
+apply from: '../constants.gradle'
+apply plugin: 'com.android.library'
+apply plugin: 'com.github.dcendents.android-maven'
+group='com.github.danbroid.exoplayer'
+
+android {
+    compileSdkVersion project.ext.compileSdkVersion
+    buildToolsVersion project.ext.buildToolsVersion
+
+    defaultConfig {
+        minSdkVersion project.ext.minSdkVersion
+        targetSdkVersion project.ext.targetSdkVersion
+        consumerProguardFiles 'proguard-rules.txt'
+    }
+
+    sourceSets.main {
+        jniLibs.srcDir 'src/main/libs'
+        jni.srcDirs = [] // Disable the automatic ndk-build call by Android Studio.
+    }
+}
+
+dependencies {
+
+    implementation "com.android.support:support-annotations:27.1.0"
+
+    implementation project(modulePrefix + 'library-core')
+    implementation project(modulePrefix + 'library-ui')
+    implementation project(modulePrefix + 'extension-okhttp')
+    implementation('com.squareup.okhttp3:okhttp:3.10.0') {
+        exclude group: 'org.json'
+    }
+
+    //implementation 'com.squareup.okhttp3:okhttp:3.10.0'
+}
diff --git a/shoutcast/proguard-rules.pro b/shoutcast/proguard-rules.pro
new file mode 100644
index 0000000000..547b322131
--- /dev/null
+++ b/shoutcast/proguard-rules.pro
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in C:\Users\matkse\AppData\Local\Android\Sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/shoutcast/proguard-rules.txt b/shoutcast/proguard-rules.txt
new file mode 100644
index 0000000000..ee0a9fa5b5
--- /dev/null
+++ b/shoutcast/proguard-rules.txt
@@ -0,0 +1,14 @@
+# Proguard rules specific to the Flac extension.
+
+# This prevents the names of native methods from being obfuscated.
+-keepclasseswithmembernames class * {
+    native <methods>;
+}
+
+# Some members of these classes are being accessed from native methods. Keep them unobfuscated.
+-keep class com.google.android.exoplayer2.ext.flac.FlacDecoderJni {
+    *;
+}
+-keep class com.google.android.exoplayer2.util.FlacStreamInfo {
+    *;
+}
diff --git a/shoutcast/src/androidTest/java/se/greenbird/exoplayershoutcast/ExampleInstrumentedTest.java b/shoutcast/src/androidTest/java/se/greenbird/exoplayershoutcast/ExampleInstrumentedTest.java
new file mode 100644
index 0000000000..783a606ed5
--- /dev/null
+++ b/shoutcast/src/androidTest/java/se/greenbird/exoplayershoutcast/ExampleInstrumentedTest.java
@@ -0,0 +1,26 @@
+package se.greenbird.exoplayershoutcast;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.junit.Assert.*;
+
+/**
+ * Instrumentation test, which will execute on an Android device.
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+@RunWith(AndroidJUnit4.class)
+public class ExampleInstrumentedTest {
+    @Test
+    public void useAppContext() throws Exception {
+        // Context of the app under test.
+        Context appContext = InstrumentationRegistry.getTargetContext();
+
+        assertEquals("se.greenbird.exoplayershoutcast", appContext.getPackageName());
+    }
+}
diff --git a/shoutcast/src/main/AndroidManifest.xml b/shoutcast/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..28ed65cd21
--- /dev/null
+++ b/shoutcast/src/main/AndroidManifest.xml
@@ -0,0 +1,12 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="se.greenbird.exoplayershoutcast">
+
+    <application
+        android:allowBackup="true"
+        android:icon="@mipmap/ic_launcher"
+        android:label="@string/app_name"
+        android:supportsRtl="true">
+
+    </application>
+
+</manifest>
diff --git a/shoutcast/src/main/java/se/greenbird/exoplayershoutcast/IcyInputStream.java b/shoutcast/src/main/java/se/greenbird/exoplayershoutcast/IcyInputStream.java
new file mode 100644
index 0000000000..15880ff388
--- /dev/null
+++ b/shoutcast/src/main/java/se/greenbird/exoplayershoutcast/IcyInputStream.java
@@ -0,0 +1,172 @@
+/**
+ * Copyright 2016 Mattias Karlsson
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package se.greenbird.exoplayershoutcast;
+
+import android.support.annotation.NonNull;
+import android.util.Log;
+
+import java.io.FilterInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+class IcyInputStream extends FilterInputStream {
+    private static final String TAG = IcyInputStream.class.getName();
+    private final String characterEncoding;
+    private final MetadataListener metadataListener;
+    private final int interval;
+    private int remaining;
+
+
+    /**
+     * Creates a new input stream.
+     * @param in the underlying input stream
+     * @param interval the interval of metadata frame is repeating (in bytes)
+     */
+    private IcyInputStream(InputStream in, int interval, MetadataListener metadataListener) {
+        this(in, interval, null, metadataListener);
+    }
+
+    /**
+     * Creates a new input stream.
+     * @param in the underlying input stream
+     * @param interval the interval of metadata frame is repeating (in bytes)
+     * @param characterEncoding the encoding used for metadata strings - may be null = default is UTF-8
+     */
+    public IcyInputStream(InputStream in, int interval, String characterEncoding, MetadataListener metadataListener) {
+        super(in);
+        this.interval = interval;
+        this.characterEncoding = characterEncoding != null ? characterEncoding : "UTF-8";
+        this.metadataListener = metadataListener;
+        this.remaining = interval;
+    }
+
+    @Override
+    public int read() throws IOException {
+        int ret = super.read();
+
+        if (--remaining == 0) {
+            getMetadata();
+        }
+
+        return ret;
+    }
+
+    @Override
+    public int read(@NonNull byte[] buffer, int offset, int len ) throws IOException {
+        int ret = super.in.read( buffer, offset, remaining < len ? remaining : len );
+
+        if (remaining == ret) {
+            getMetadata();
+        } else {
+            remaining -= ret;
+        }
+
+        return ret;
+    }
+
+    /**
+     * Tries to read all bytes into the target buffer.
+     * @param size the requested size
+     * @return the number of really bytes read; if less than requested, then eof detected
+     */
+    private int readFully(byte[] buffer, int offset, int size) throws IOException {
+        int n;
+        int oo = offset;
+
+        while (size > 0 && (n = in.read( buffer, offset, size )) != -1) {
+            offset += n;
+            size -= n;
+        }
+
+        return offset - oo;
+    }
+
+    private void getMetadata() throws IOException {
+        remaining = interval;
+
+        int size = super.in.read();
+
+        // either no metadata or eof:
+        if (size < 1) return;
+
+        size *= 16;
+
+        byte[] buffer = new byte[ size ];
+
+        size = readFully(buffer, 0, size );
+
+        // find the string end:
+        for (int i=0; i < size; i++) {
+            if (buffer[i] == 0) {
+                size = i;
+                break;
+            }
+        }
+
+        String s;
+
+        try {
+            s = new String(buffer, 0, size, characterEncoding );
+        }
+        catch (Exception e) {
+            Log.e(TAG, "Cannot convert bytes to String" );
+            return;
+        }
+
+        Log.d(TAG, "Metadata string: " + s );
+
+        parseMetadata(s);
+    }
+
+
+    /**
+     * Parses the metadata
+     * @param data the metadata string like: StreamTitle='...';StreamUrl='...';
+     */
+    private void parseMetadata(String data) {
+        Matcher match = Pattern.compile("StreamTitle='([^;]*)'").matcher(data.trim());
+        if (match.find())
+        {
+            // Presume artist/title is separated by " - ".
+            String[] metadata = match.group(1).split(" - ");
+            switch (metadata.length) {
+                case 3:
+                    metadataReceived(metadata[1], metadata[2], metadata[0]);
+                    break;
+                case 2:
+                    metadataReceived(metadata[0], metadata[1], null);
+                    break;
+                case 1:
+                    metadataReceived(null, null, metadata[0]);
+            }
+        }
+    }
+
+    private void metadataReceived(String artist, String song, String show) {
+        Log.i(TAG, "Metadata received: ");
+        Log.i(TAG, "Show: " + show);
+        Log.i(TAG, "Artist: " + artist);
+        Log.i(TAG, "Song: " + song);
+
+        if (this.metadataListener != null) {
+            this.metadataListener.onMetadataReceived(artist, song, show);
+        }
+    }
+}
+
diff --git a/shoutcast/src/main/java/se/greenbird/exoplayershoutcast/Metadata.java b/shoutcast/src/main/java/se/greenbird/exoplayershoutcast/Metadata.java
new file mode 100644
index 0000000000..c9813a7adc
--- /dev/null
+++ b/shoutcast/src/main/java/se/greenbird/exoplayershoutcast/Metadata.java
@@ -0,0 +1,71 @@
+/**
+ * Copyright 2016 Mattias Karlsson
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package se.greenbird.exoplayershoutcast;
+
+public class Metadata {
+    private final String artist;
+    private final String song;
+    private final String show;
+    private final String channels;
+    private final String bitrate;
+    private final String station;
+    private final String genre;
+    private final String url;
+
+    public Metadata(String artist, String song, String show, String channels, String bitrate, String station, String genre, String url) {
+        this.artist = artist;
+        this.song = song;
+        this.show = show;
+        this.channels = channels;
+        this.bitrate = bitrate;
+        this.station = station;
+        this.genre = genre;
+        this.url = url;
+    }
+
+    public String getArtist() {
+        return artist;
+    }
+
+    public String getSong() {
+        return song;
+    }
+
+    public String getShow() {
+        return show;
+    }
+
+    public String getChannels() {
+        return channels;
+    }
+
+    public String getBitrate() {
+        return bitrate;
+    }
+
+    public String getStation() {
+        return station;
+    }
+
+    public String getGenre() {
+        return genre;
+    }
+
+    public String getUrl() {
+        return url;
+    }
+}
\ No newline at end of file
diff --git a/shoutcast/src/main/java/se/greenbird/exoplayershoutcast/MetadataListener.java b/shoutcast/src/main/java/se/greenbird/exoplayershoutcast/MetadataListener.java
new file mode 100644
index 0000000000..91bcb93b2b
--- /dev/null
+++ b/shoutcast/src/main/java/se/greenbird/exoplayershoutcast/MetadataListener.java
@@ -0,0 +1,21 @@
+/**
+ * Copyright 2016 Mattias Karlsson
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package se.greenbird.exoplayershoutcast;
+
+interface MetadataListener {
+    void onMetadataReceived(String artist, String song, String show);
+}
diff --git a/shoutcast/src/main/java/se/greenbird/exoplayershoutcast/OggInputStream.java b/shoutcast/src/main/java/se/greenbird/exoplayershoutcast/OggInputStream.java
new file mode 100644
index 0000000000..0de9ea0bda
--- /dev/null
+++ b/shoutcast/src/main/java/se/greenbird/exoplayershoutcast/OggInputStream.java
@@ -0,0 +1,278 @@
+/**
+ * Copyright 2016 Mattias Karlsson
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package se.greenbird.exoplayershoutcast;
+
+import android.util.Log;
+
+import com.google.android.exoplayer2.util.ParsableByteArray;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.HashMap;
+
+final class OggInputStream extends PeekInputStream { // TODO: Use PushbackInputStream instead of Peek?
+    private static final String TAG = OggInputStream.class.getName();
+
+    private final PacketInfoHolder holder = new PacketInfoHolder();
+    private final IdHeader idHeader = new IdHeader();
+    private final CommentHeader commentHeader = new CommentHeader();
+    private final PageHeader pageHeader = new PageHeader();
+
+    private final ParsableByteArray packetArray = new ParsableByteArray(new byte['︁'], 0);
+    private final ParsableByteArray headerArray = new ParsableByteArray(282);
+    private final MetadataListener listener;
+
+
+    public OggInputStream(InputStream in, MetadataListener listener) {
+        super(in);
+        this.listener = listener;
+    }
+
+    @Override
+    public int read(byte[] target, int offset, int length) throws IOException {
+        try {
+            if(peekPacket(this, this.packetArray, this.headerArray, this.pageHeader, this.holder)) {
+                unpackIdHeader(this.packetArray, this.idHeader);
+                unpackCommentHeader(this.packetArray, this.commentHeader, this.listener);
+            }
+
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+
+        return super.read(target, offset, length);
+    }
+
+    private static boolean peekPacket(PeekInputStream stream, ParsableByteArray packetArray, ParsableByteArray headerArray, PageHeader header, PacketInfoHolder holder) throws IOException, InterruptedException {
+        int segmentIndex;
+        int currentSegmentIndex = -1;
+        packetArray.reset();
+        for(boolean packetComplete = false; !packetComplete; currentSegmentIndex = segmentIndex == header.pageSegmentCount?-1:segmentIndex) {
+            if(currentSegmentIndex < 0) {
+                if(!unpackPageHeader(stream, headerArray, header)) {
+                    return false;
+                }
+
+                segmentIndex = 0;
+                if((header.type & 1) == 1 && packetArray.limit() == 0) {
+                    calculatePacketSize(header, segmentIndex, holder);
+                    segmentIndex += holder.segmentCount;
+                }
+
+                currentSegmentIndex = segmentIndex;
+            }
+
+            calculatePacketSize(header, currentSegmentIndex, holder);
+            segmentIndex = currentSegmentIndex + holder.segmentCount;
+            if(holder.size > 0) {
+                stream.peekFully(packetArray.data, packetArray.limit(), holder.size);
+                packetArray.setLimit(packetArray.limit() + holder.size);
+                packetComplete = header.laces[segmentIndex - 1] != 255;
+            }
+        }
+
+        return true;
+    }
+
+    private static void calculatePacketSize(PageHeader header, int startSegmentIndex, PacketInfoHolder holder) {
+        holder.segmentCount = 0;
+        holder.size = 0;
+
+        int segmentLength;
+        while(startSegmentIndex + holder.segmentCount < header.pageSegmentCount) {
+             segmentLength = header.laces[startSegmentIndex + holder.segmentCount++];
+            holder.size += segmentLength;
+            if(segmentLength != 255) {
+                break;
+            }
+        }
+
+    }
+
+    private static boolean unpackPageHeader(PeekInputStream stream, ParsableByteArray headerArray, PageHeader header) throws IOException, InterruptedException {
+        headerArray.reset();
+        header.reset();
+        if(stream.peekFully(headerArray.data, 0, 27, true)) {
+            if(headerArray.readUnsignedByte() == 79 && headerArray.readUnsignedByte() == 103 && headerArray.readUnsignedByte() == 103 && headerArray.readUnsignedByte() == 83) {
+                header.revision = headerArray.readUnsignedByte();
+                if(header.revision != 0) {
+                    return false;
+                } else {
+                    header.type = headerArray.readUnsignedByte();
+                    header.granulePosition = headerArray.readLittleEndianLong();
+                    header.streamSerialNumber = headerArray.readLittleEndianUnsignedInt();
+                    header.pageSequenceNumber = headerArray.readLittleEndianUnsignedInt();
+                    header.pageChecksum = headerArray.readLittleEndianUnsignedInt();
+                    header.pageSegmentCount = headerArray.readUnsignedByte();
+                    headerArray.reset();
+                    header.headerSize = 27 + header.pageSegmentCount;
+                    stream.peekFully(headerArray.data, 0, header.pageSegmentCount);
+
+                    for(int i = 0; i < header.pageSegmentCount; ++i) {
+                        header.laces[i] = headerArray.readUnsignedByte();
+                        header.bodySize += header.laces[i];
+                    }
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    private static void unpackIdHeader(ParsableByteArray scratch, IdHeader header) {
+        scratch.reset();
+        if(scratch.readUnsignedByte() == 1) {
+            if (scratch.readUnsignedByte() == 118 && scratch.readUnsignedByte() == 111 && scratch.readUnsignedByte() == 114 && scratch.readUnsignedByte() == 98 && scratch.readUnsignedByte() == 105 && scratch.readUnsignedByte() == 115) {
+                header.reset();
+                header.version = scratch.readLittleEndianUnsignedInt();
+                header.audioChannels = scratch.readUnsignedByte();
+                header.audioSampleRate = scratch.readLittleEndianUnsignedInt();
+                header.bitRateMaximum = scratch.readLittleEndianInt();
+                header.bitRateNominal = scratch.readLittleEndianInt();
+                header.bitRateMinimum = scratch.readLittleEndianInt();
+
+                int blockSize = scratch.readUnsignedByte();
+                header.blockSize0 = (int) Math.pow(2, (blockSize & 15));
+                header.blockSize1 = (int) Math.pow(2, (blockSize >> 4));
+            }
+        }
+    }
+
+    private static void unpackCommentHeader(ParsableByteArray scratch, CommentHeader header, MetadataListener listener) {
+        scratch.reset();
+        if (scratch.readUnsignedByte() == 3) {
+            if (scratch.readUnsignedByte() == 118 && scratch.readUnsignedByte() == 111 && scratch.readUnsignedByte() == 114 && scratch.readUnsignedByte() == 98 && scratch.readUnsignedByte() == 105 && scratch.readUnsignedByte() == 115) {
+                header.reset();
+                int vendorLength = (int) scratch.readLittleEndianUnsignedInt();
+                int length = 7 + 4;
+                header.vendor = scratch.readString(vendorLength);
+                length += header.vendor.length();
+                long commentListLen = scratch.readLittleEndianUnsignedInt();
+                length += 4;
+
+                int len;
+                String comment;
+                for (int i = 0; (long) i < commentListLen; ++i) {
+                    len = (int) scratch.readLittleEndianUnsignedInt();
+                    length += 4;
+                    comment = scratch.readString(len);
+                    unPackComment(comment, header.comments);
+                    length += comment.length();
+                }
+                header.length = length;
+                metadataReceived(header.comments.get("ARTIST"), header.comments.get("TITLE"), listener);
+            }
+        }
+    }
+
+    private static void unPackComment(String comment, HashMap<String, String> commentContainer) {
+        if (comment.contains("=")) {
+            String[] kv = comment.split("=");
+            if (kv.length == 2) {
+                commentContainer.put(kv[0], kv[1]);
+            } else if (kv.length == 1) {
+                commentContainer.put(kv[0], "");
+            }
+        }
+    }
+
+    private static void metadataReceived(String artist, String song, MetadataListener listener) {
+        Log.i(TAG, "Metadata received: ");
+        Log.i(TAG, "Artist: " + artist);
+        Log.i(TAG, "Song: " + song);
+        if (listener != null) {
+            listener.onMetadataReceived(artist, song, "");
+        }
+    }
+
+    private class PageHeader {
+        public int revision;
+        public int type;
+        public long granulePosition;
+        public long streamSerialNumber;
+        public long pageSequenceNumber;
+        public long pageChecksum;
+        public int pageSegmentCount;
+        public int headerSize;
+        public int bodySize;
+        public final int[] laces = new int[255];
+
+        private PageHeader() {
+        }
+
+        public void reset() {
+            this.revision = 0;
+            this.type = 0;
+            this.granulePosition = 0L;
+            this.streamSerialNumber = 0L;
+            this.pageSequenceNumber = 0L;
+            this.pageChecksum = 0L;
+            this.pageSegmentCount = 0;
+            this.headerSize = 0;
+            this.bodySize = 0;
+        }
+    }
+
+    private class IdHeader {
+        public long version;
+        public int audioChannels;
+        public long audioSampleRate;
+        public int bitRateMaximum;
+        public int bitRateNominal;
+        public int bitRateMinimum;
+        public int blockSize0;
+        public int blockSize1;
+
+        private IdHeader() {}
+
+        public void reset() {
+            this.audioChannels = 0;
+            this.audioSampleRate = 0;
+            this.bitRateMaximum = 0;
+            this.bitRateNominal = 0;
+            this.bitRateMinimum = 0;
+            this.blockSize0 = 0;
+            this.blockSize1 = 0;
+        }
+    }
+
+    private class CommentHeader {
+        public String vendor;
+        public final HashMap<String, String> comments;
+        public int length;
+
+        public CommentHeader() {
+            this.comments = new HashMap<>();
+        }
+
+        public void reset() {
+            this.vendor = "";
+            this.comments.clear();
+            this.length = 0;
+        }
+    }
+
+    private class PacketInfoHolder {
+        public int size;
+        public int segmentCount;
+
+        public PacketInfoHolder() {
+        }
+    }
+}
+
+
diff --git a/shoutcast/src/main/java/se/greenbird/exoplayershoutcast/PeekInputStream.java b/shoutcast/src/main/java/se/greenbird/exoplayershoutcast/PeekInputStream.java
new file mode 100644
index 0000000000..a23ad0a6dc
--- /dev/null
+++ b/shoutcast/src/main/java/se/greenbird/exoplayershoutcast/PeekInputStream.java
@@ -0,0 +1,231 @@
+/**
+ * Copyright 2016 Mattias Karlsson
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package se.greenbird.exoplayershoutcast;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Arrays;
+
+class PeekInputStream extends InputStream {
+    private static final byte[] SCRATCH_SPACE = new byte[4096];
+    private final InputStream stream;
+    private final long streamLength;
+    private long position;
+    private byte[] peekBuffer = new byte[8192];
+    private int peekBufferPosition;
+    private int peekBufferLength;
+
+    PeekInputStream(InputStream stream) {
+        this(stream, 0, -1L);
+    }
+
+    private PeekInputStream(InputStream stream, long position, long length) {
+        this.stream = stream;
+        this.position = position;
+        this.streamLength = length;
+    }
+
+    @Override
+    public int read() throws IOException {
+        int bytesRead = this.readFromPeekBuffer();
+        if (bytesRead == 0) {
+            try {
+                bytesRead = this.readFromStream();
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            }
+        }
+        this.commitBytesRead(bytesRead);
+        return bytesRead;
+    }
+
+    @Override
+    public int read(byte[] target, int offset, int length) throws IOException {
+        int bytesRead = this.readFromPeekBuffer(target, offset, length);
+        if(bytesRead == 0) {
+            try {
+                bytesRead = this.readFromStream(target, offset, length, 0, true);
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            }
+        }
+
+        this.commitBytesRead(bytesRead);
+        return bytesRead;
+    }
+
+    private boolean readFully(byte[] target, int offset, int length, boolean allowEndOfInput) throws IOException, InterruptedException {
+        int bytesRead;
+        for(bytesRead = this.readFromPeekBuffer(target, offset, length); bytesRead < length && bytesRead != -1; bytesRead = this.readFromStream(target, offset, length, bytesRead, allowEndOfInput)) {
+        }
+
+        this.commitBytesRead(bytesRead);
+        return bytesRead != -1;
+    }
+
+    public void readFully(byte[] target, int offset, int length) throws IOException, InterruptedException {
+        this.readFully(target, offset, length, false);
+    }
+
+    public int skip(int length) throws IOException, InterruptedException {
+        int bytesSkipped = this.skipFromPeekBuffer(length);
+        if(bytesSkipped == 0) {
+            bytesSkipped = this.readFromStream(SCRATCH_SPACE, 0, Math.min(length, SCRATCH_SPACE.length), 0, true);
+        }
+
+        this.commitBytesRead(bytesSkipped);
+        return bytesSkipped;
+    }
+
+    private boolean skipFully(int length, boolean allowEndOfInput) throws IOException, InterruptedException {
+        int bytesSkipped;
+        for(bytesSkipped = this.skipFromPeekBuffer(length); bytesSkipped < length && bytesSkipped != -1; bytesSkipped = this.readFromStream(SCRATCH_SPACE, -bytesSkipped, Math.min(length, bytesSkipped + SCRATCH_SPACE.length), bytesSkipped, allowEndOfInput)) {
+        }
+
+        this.commitBytesRead(bytesSkipped);
+        return bytesSkipped != -1;
+    }
+
+    public void skipFully(int length) throws IOException, InterruptedException {
+        this.skipFully(length, false);
+    }
+
+    boolean peekFully(byte[] target, int offset, int length, boolean allowEndOfInput) throws IOException, InterruptedException {
+        if(!this.advancePeekPosition(length, allowEndOfInput)) {
+            return false;
+        } else {
+            System.arraycopy(this.peekBuffer, this.peekBufferPosition - length, target, offset, length);
+            return true;
+        }
+    }
+
+    void peekFully(byte[] target, int offset, int length) throws IOException, InterruptedException {
+        this.peekFully(target, offset, length, false);
+    }
+
+    private boolean advancePeekPosition(int length, boolean allowEndOfInput) throws IOException, InterruptedException {
+        this.ensureSpaceForPeek(length);
+        int bytesPeeked = Math.min(this.peekBufferLength - this.peekBufferPosition, length);
+        this.peekBufferLength += length - bytesPeeked;
+
+        do {
+            if(bytesPeeked >= length) {
+                this.peekBufferPosition += length;
+                return true;
+            }
+
+            bytesPeeked = this.readFromStream(this.peekBuffer, this.peekBufferPosition, length, bytesPeeked, allowEndOfInput);
+        } while(bytesPeeked != -1);
+
+        return false;
+    }
+
+    public void advancePeekPosition(int length) throws IOException, InterruptedException {
+        this.advancePeekPosition(length, false);
+    }
+
+    public void resetPeekPosition() {
+        this.peekBufferPosition = 0;
+    }
+
+    public long getPeekPosition() {
+        return this.position + (long)this.peekBufferPosition;
+    }
+
+    public long getPosition() {
+        return this.position;
+    }
+
+    public long getLength() {
+        return this.streamLength;
+    }
+
+    private void ensureSpaceForPeek(int length) {
+        int requiredLength = this.peekBufferPosition + length;
+        if(requiredLength > this.peekBuffer.length) {
+            this.peekBuffer = Arrays.copyOf(this.peekBuffer, Math.max(this.peekBuffer.length * 2, requiredLength));
+        }
+
+    }
+
+    private int skipFromPeekBuffer(int length) {
+        int bytesSkipped = Math.min(this.peekBufferLength, length);
+        this.updatePeekBuffer(bytesSkipped);
+        return bytesSkipped;
+    }
+
+    private int readFromPeekBuffer() {
+        if(this.peekBufferLength == 0) {
+            return 0;
+        } else {
+            int bytesRead = this.peekBuffer[0];
+            this.updatePeekBuffer(1);
+            return bytesRead;
+        }
+    }
+
+    private int readFromPeekBuffer(byte[] target, int offset, int length) {
+        if(this.peekBufferLength == 0) {
+            return 0;
+        } else {
+            int peekBytes = Math.min(this.peekBufferLength, length);
+            System.arraycopy(this.peekBuffer, 0, target, offset, peekBytes);
+            this.updatePeekBuffer(peekBytes);
+            return peekBytes;
+        }
+    }
+
+    private void updatePeekBuffer(int bytesConsumed) {
+        this.peekBufferLength -= bytesConsumed;
+        this.peekBufferPosition = 0;
+        System.arraycopy(this.peekBuffer, bytesConsumed, this.peekBuffer, 0, this.peekBufferLength);
+    }
+
+    private int readFromStream() throws InterruptedException, IOException {
+        if(Thread.interrupted()) {
+            throw new InterruptedException();
+        } else {
+            return this.stream.read();
+        }
+    }
+
+    private int readFromStream(byte[] target, int offset, int length, int bytesAlreadyRead, boolean allowEndOfInput) throws InterruptedException, IOException {
+        if(Thread.interrupted()) {
+            throw new InterruptedException();
+        } else {
+            int bytesRead = this.stream.read(target, offset + bytesAlreadyRead, length - bytesAlreadyRead);
+            if(bytesRead == -1) {
+                if(bytesAlreadyRead == 0 && allowEndOfInput) {
+                    return -1;
+                } else {
+                    throw new EOFException();
+                }
+            } else {
+                return bytesAlreadyRead + bytesRead;
+            }
+        }
+    }
+
+    private void commitBytesRead(int bytesRead) {
+        if(bytesRead != -1) {
+            this.position += (long)bytesRead;
+        }
+
+    }
+}
+
diff --git a/shoutcast/src/main/java/se/greenbird/exoplayershoutcast/ShoutcastDataSource.java b/shoutcast/src/main/java/se/greenbird/exoplayershoutcast/ShoutcastDataSource.java
new file mode 100644
index 0000000000..ef1369c5b9
--- /dev/null
+++ b/shoutcast/src/main/java/se/greenbird/exoplayershoutcast/ShoutcastDataSource.java
@@ -0,0 +1,407 @@
+/**
+ * Copyright 2016 Mattias Karlsson
+ * <p>
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package se.greenbird.exoplayershoutcast;
+
+import android.net.Uri;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.upstream.DataSourceException;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.HttpDataSource;
+import com.google.android.exoplayer2.upstream.TransferListener;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Predicate;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InterruptedIOException;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicReference;
+
+import okhttp3.CacheControl;
+import okhttp3.Call;
+import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+
+/**
+ * An {@link ShoutcastDataSource} that delegates to Square's {@link Call.Factory}.
+ */
+final class ShoutcastDataSource implements HttpDataSource, MetadataListener {
+
+  private class IcyHeader {
+    public String channels;
+    public String bitrate;
+    public String station;
+    public String genre;
+    public String url;
+  }
+
+  private static final String MP3 = "audio/mpeg";
+  private static final String AAC = "audio/aac";
+  private static final String AACP = "audio/aacp";
+  private static final String OGG = "application/ogg";
+  private static final String ICY_METADATA = "Icy-Metadata";
+  private static final String ICY_METAINT = "icy-metaint";
+
+
+  private static final AtomicReference<byte[]> skipBufferReference = new AtomicReference<>();
+
+  private final Call.Factory callFactory;
+  private final String userAgent;
+  private final Predicate<String> contentTypePredicate;
+  private final TransferListener<? super ShoutcastDataSource> transferListener;
+  private final ShoutcastMetadataListener shoutcastMetadataListener;
+  private final CacheControl cacheControl;
+  private final HashMap<String, String> requestProperties;
+
+  private DataSpec dataSpec;
+  private Response response;
+  private InputStream responseByteStream;
+  private boolean opened;
+
+  private long bytesToSkip;
+  private long bytesToRead;
+  private long bytesSkipped;
+  private long bytesRead;
+
+  private IcyHeader icyHeader;
+
+  /**
+   * @param callFactory          An {@link Call.Factory} for use by the source.
+   * @param userAgent            The User-Agent string that should be used.
+   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
+   *                             predicate then a InvalidContentTypeException} is thrown from {@link #open(DataSpec)}.
+   */
+  public ShoutcastDataSource(Call.Factory callFactory, String userAgent,
+                             Predicate<String> contentTypePredicate) {
+    this(callFactory, userAgent, contentTypePredicate, null, null);
+  }
+
+  /**
+   * @param callFactory          An {@link Call.Factory} for use by the source.
+   * @param userAgent            The User-Agent string that should be used.
+   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
+   *                             predicate then a {@link InvalidContentTypeException} is thrown from
+   *                             {@link #open(DataSpec)}.
+   * @param transferListener     An optional transferListener.
+   */
+  private ShoutcastDataSource(Call.Factory callFactory, String userAgent,
+                              Predicate<String> contentTypePredicate, TransferListener<? super ShoutcastDataSource> transferListener,
+                              ShoutcastMetadataListener shoutcastMetadataListener) {
+    this(callFactory, userAgent, contentTypePredicate, transferListener, shoutcastMetadataListener, null);
+  }
+
+  /**
+   * @param callFactory          An {@link Call.Factory} for use by the source.
+   * @param userAgent            The User-Agent string that should be used.
+   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
+   *                             predicate then a {@link InvalidContentTypeException} is thrown from
+   *                             {@link #open(DataSpec)}.
+   * @param transferListener     An optional transferListener.
+   * @param cacheControl         An optional {@link CacheControl} which sets all requests' Cache-Control
+   *                             header. For example, you could force the network response for all requests.
+   */
+  public ShoutcastDataSource(Call.Factory callFactory, String userAgent,
+                             Predicate<String> contentTypePredicate, TransferListener<? super ShoutcastDataSource> transferListener,
+                             ShoutcastMetadataListener shoutcastMetadataListener,
+                             CacheControl cacheControl) {
+    this.callFactory = Assertions.checkNotNull(callFactory);
+    this.userAgent = Assertions.checkNotEmpty(userAgent);
+    this.contentTypePredicate = contentTypePredicate;
+    this.transferListener = transferListener;
+    this.shoutcastMetadataListener = shoutcastMetadataListener;
+    this.cacheControl = cacheControl;
+    this.requestProperties = new HashMap<>();
+  }
+
+  @Override
+  public Uri getUri() {
+    return response == null ? null : Uri.parse(response.request().url().toString());
+  }
+
+  @Override
+  public Map<String, List<String>> getResponseHeaders() {
+    return response == null ? null : response.headers().toMultimap();
+  }
+
+  @Override
+  public void setRequestProperty(String name, String value) {
+    Assertions.checkNotNull(name);
+    Assertions.checkNotNull(value);
+    synchronized (requestProperties) {
+      requestProperties.put(name, value);
+    }
+  }
+
+  @Override
+  public void clearRequestProperty(String name) {
+    Assertions.checkNotNull(name);
+    synchronized (requestProperties) {
+      requestProperties.remove(name);
+    }
+  }
+
+  @Override
+  public void clearAllRequestProperties() {
+    synchronized (requestProperties) {
+      requestProperties.clear();
+    }
+  }
+
+  @Override
+  public long open(DataSpec dataSpec) throws HttpDataSourceException {
+    this.dataSpec = dataSpec;
+    this.bytesRead = 0;
+    this.bytesSkipped = 0;
+    setRequestProperty(ICY_METADATA, "1");
+    Request request = makeRequest(dataSpec);
+    try {
+      response = callFactory.newCall(request).execute();
+      responseByteStream = getInputStream(response);
+    } catch (IOException e) {
+      throw new HttpDataSourceException("Unable to connect to " + dataSpec.uri.toString(), e,
+          dataSpec, HttpDataSourceException.TYPE_OPEN);
+    }
+
+    int responseCode = response.code();
+
+    // Check for a valid response code.
+    if (!response.isSuccessful()) {
+      Map<String, List<String>> headers = request.headers().toMultimap();
+      closeConnectionQuietly();
+      InvalidResponseCodeException exception = new InvalidResponseCodeException(
+          responseCode, headers, dataSpec);
+      if (responseCode == 416) {
+        exception.initCause(new DataSourceException(DataSourceException.POSITION_OUT_OF_RANGE));
+      }
+      throw exception;
+    }
+
+    // Check for a valid content type.
+    MediaType mediaType = response.body().contentType();
+    String contentType = mediaType != null ? mediaType.toString() : null;
+    if (contentTypePredicate != null && !contentTypePredicate.evaluate(contentType)) {
+      closeConnectionQuietly();
+      throw new InvalidContentTypeException(contentType, dataSpec);
+    }
+
+    // If we requested a range starting from a non-zero position and received a 200 rather than a
+    // 206, then the server does not support partial requests. We'll need to manually skip to the
+    // requested position.
+    bytesToSkip = responseCode == 200 && dataSpec.position != 0 ? dataSpec.position : 0;
+
+    // Determine the length of the data to be read, after skipping.
+    if (dataSpec.length != C.LENGTH_UNSET) {
+      bytesToRead = dataSpec.length;
+    } else {
+      long contentLength = response.body().contentLength();
+      bytesToRead = contentLength != -1 ? (contentLength - bytesToSkip) : C.LENGTH_UNSET;
+    }
+
+    opened = true;
+    if (transferListener != null) {
+      transferListener.onTransferStart(this, dataSpec);
+    }
+
+    return bytesToRead;
+  }
+
+  @Override
+  public int read(byte[] buffer, int offset, int readLength) throws HttpDataSourceException {
+    try {
+      skipInternal();
+      return readInternal(buffer, offset, readLength);
+    } catch (IOException e) {
+      throw new HttpDataSourceException(e, dataSpec, HttpDataSourceException.TYPE_READ);
+    }
+  }
+
+  @Override
+  public void close() throws HttpDataSourceException {
+    if (opened) {
+      opened = false;
+      if (transferListener != null) {
+        transferListener.onTransferEnd(this);
+      }
+      closeConnectionQuietly();
+    }
+  }
+
+  /**
+   * Establishes a connection.
+   */
+  private Request makeRequest(DataSpec dataSpec) {
+    boolean allowGzip = (dataSpec.flags & DataSpec.FLAG_ALLOW_GZIP) != 0;
+
+    HttpUrl url = HttpUrl.parse(dataSpec.uri.toString());
+    Request.Builder builder = new Request.Builder().url(url);
+    if (cacheControl != null) {
+      builder.cacheControl(cacheControl);
+    }
+    synchronized (requestProperties) {
+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {
+        builder.addHeader(property.getKey(), property.getValue());
+      }
+    }
+    builder.addHeader("User-Agent", userAgent);
+    if (!allowGzip) {
+      builder.addHeader("Accept-Encoding", "identity");
+    }
+    if (dataSpec.postBody != null) {
+      builder.post(RequestBody.create(null, dataSpec.postBody));
+    }
+    return builder.build();
+  }
+
+  private InputStream getInputStream(Response response) throws IOException {
+    String contentType = response.header("Content-Type");
+    setIcyHeader(response.headers());
+    InputStream input = response.body().byteStream();
+    switch (contentType) {
+      case MP3:
+      case AAC:
+      case AACP:
+
+        try {
+          int interval = Integer.parseInt(response.header(ICY_METAINT));
+          input = new IcyInputStream(input, interval, null, this);
+        } catch (NumberFormatException e) {
+        }
+
+        break;
+      case OGG:
+        input = new OggInputStream(input, this);
+        break;
+    }
+    return input;
+  }
+
+  /**
+   * Skips any bytes that need skipping. Else does nothing.
+   * <p>
+   * This implementation is based roughly on {@code libcore.io.Streams.skipByReading()}.
+   *
+   * @throws InterruptedIOException If the thread is interrupted during the operation.
+   * @throws EOFException           If the end of the input stream is reached before the bytes are skipped.
+   */
+  private void skipInternal() throws IOException {
+    if (bytesSkipped == bytesToSkip) {
+      return;
+    }
+
+    // Acquire the shared skip buffer.
+    byte[] skipBuffer = skipBufferReference.getAndSet(null);
+    if (skipBuffer == null) {
+      skipBuffer = new byte[4096];
+    }
+
+    while (bytesSkipped != bytesToSkip) {
+      int readLength = (int) Math.min(bytesToSkip - bytesSkipped, skipBuffer.length);
+      int read = responseByteStream.read(skipBuffer, 0, readLength);
+      if (Thread.interrupted()) {
+        throw new InterruptedIOException();
+      }
+      if (read == -1) {
+        throw new EOFException();
+      }
+      bytesSkipped += read;
+      if (transferListener != null) {
+        transferListener.onBytesTransferred(this, read);
+      }
+    }
+
+    // Release the shared skip buffer.
+    skipBufferReference.set(skipBuffer);
+  }
+
+  /**
+   * Reads up to {@code length} bytes of data and stores them into {@code buffer}, starting at
+   * index {@code offset}.
+   * <p>
+   * This method blocks until at least one byte of data can be read, the end of the opened range is
+   * detected, or an exception is thrown.
+   *
+   * @param buffer     The buffer into which the read data should be stored.
+   * @param offset     The start offset into {@code buffer} at which data should be written.
+   * @param readLength The maximum number of bytes to read.
+   * @return The number of bytes read, or {@link C#RESULT_END_OF_INPUT} if the end of the opened
+   * range is reached.
+   * @throws IOException If an error occurs reading from the source.
+   */
+  private int readInternal(byte[] buffer, int offset, int readLength) throws IOException {
+    if (readLength == 0) {
+      return 0;
+    }
+    if (bytesToRead != C.LENGTH_UNSET) {
+      long bytesRemaining = bytesToRead - bytesRead;
+      if (bytesRemaining == 0) {
+        return C.RESULT_END_OF_INPUT;
+      }
+      readLength = (int) Math.min(readLength, bytesRemaining);
+    }
+
+    int read = responseByteStream.read(buffer, offset, readLength);
+    if (read == -1) {
+      if (bytesToRead != C.LENGTH_UNSET) {
+        // End of stream reached having not read sufficient data.
+        throw new EOFException();
+      }
+      return C.RESULT_END_OF_INPUT;
+    }
+
+    bytesRead += read;
+    if (transferListener != null) {
+      transferListener.onBytesTransferred(this, read);
+    }
+    return read;
+  }
+
+  /**
+   * Closes the current connection quietly, if there is one.
+   */
+  private void closeConnectionQuietly() {
+    response.body().close();
+    response = null;
+    responseByteStream = null;
+  }
+
+  private void setIcyHeader(Headers headers) {
+    if (icyHeader == null) {
+      icyHeader = new IcyHeader();
+    }
+    icyHeader.station = headers.get("icy-name");
+    icyHeader.url = headers.get("icy-url");
+    icyHeader.genre = headers.get("icy-genre");
+    icyHeader.channels = headers.get("icy-channels");
+    icyHeader.bitrate = headers.get("icy-br");
+  }
+
+  @Override
+  public void onMetadataReceived(String artist, String song, String show) {
+    if (shoutcastMetadataListener != null) {
+      Metadata metadata = new Metadata(artist, song, show, icyHeader.channels, icyHeader.bitrate, icyHeader.station, icyHeader.genre, icyHeader.url);
+      shoutcastMetadataListener.onMetadataReceived(metadata);
+    }
+  }
+}
\ No newline at end of file
diff --git a/shoutcast/src/main/java/se/greenbird/exoplayershoutcast/ShoutcastDataSourceFactory.java b/shoutcast/src/main/java/se/greenbird/exoplayershoutcast/ShoutcastDataSourceFactory.java
new file mode 100644
index 0000000000..baa1669d9e
--- /dev/null
+++ b/shoutcast/src/main/java/se/greenbird/exoplayershoutcast/ShoutcastDataSourceFactory.java
@@ -0,0 +1,59 @@
+/**
+ * Copyright 2016 Mattias Karlsson
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package se.greenbird.exoplayershoutcast;
+
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.HttpDataSource;
+import com.google.android.exoplayer2.upstream.HttpDataSource.Factory;
+import com.google.android.exoplayer2.upstream.TransferListener;
+
+import okhttp3.CacheControl;
+import okhttp3.Call;
+
+/**
+ * A {@link Factory} that produces {@link ShoutcastDataSource}.
+ */
+public final class ShoutcastDataSourceFactory extends HttpDataSource.BaseFactory {
+
+    private final Call.Factory callFactory;
+    private final String userAgent;
+    private final TransferListener<? super DataSource> transferListener;
+    private final ShoutcastMetadataListener shoutcastMetadataListener;
+    private final CacheControl cacheControl;
+
+    public ShoutcastDataSourceFactory(Call.Factory callFactory, String userAgent,
+                                      TransferListener<? super DataSource> transferListener,
+                                      ShoutcastMetadataListener shoutcastMetadataListener) {
+        this(callFactory, userAgent, transferListener, shoutcastMetadataListener, null);
+    }
+
+    private ShoutcastDataSourceFactory(Call.Factory callFactory, String userAgent,
+                                       TransferListener<? super DataSource> transferListener,
+                                       ShoutcastMetadataListener shoutcastMetadataListener, CacheControl cacheControl) {
+        this.callFactory = callFactory;
+        this.userAgent = userAgent;
+        this.transferListener = transferListener;
+        this.shoutcastMetadataListener = shoutcastMetadataListener;
+        this.cacheControl = cacheControl;
+    }
+
+    @Override
+    protected HttpDataSource createDataSourceInternal(HttpDataSource.RequestProperties requestProperties) {
+        return new ShoutcastDataSource(callFactory, userAgent, null, transferListener, shoutcastMetadataListener, cacheControl);
+    }
+
+}
diff --git a/shoutcast/src/main/java/se/greenbird/exoplayershoutcast/ShoutcastMetadataListener.java b/shoutcast/src/main/java/se/greenbird/exoplayershoutcast/ShoutcastMetadataListener.java
new file mode 100644
index 0000000000..f4eb299b53
--- /dev/null
+++ b/shoutcast/src/main/java/se/greenbird/exoplayershoutcast/ShoutcastMetadataListener.java
@@ -0,0 +1,21 @@
+/**
+ * Copyright 2016 Mattias Karlsson
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package se.greenbird.exoplayershoutcast;
+
+public interface ShoutcastMetadataListener {
+    void onMetadataReceived(Metadata data);
+}
\ No newline at end of file
diff --git a/shoutcast/src/main/res/mipmap-hdpi/ic_launcher.png b/shoutcast/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100644
index 0000000000..cde69bccce
Binary files /dev/null and b/shoutcast/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/shoutcast/src/main/res/mipmap-mdpi/ic_launcher.png b/shoutcast/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100644
index 0000000000..c133a0cbd3
Binary files /dev/null and b/shoutcast/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/shoutcast/src/main/res/mipmap-xhdpi/ic_launcher.png b/shoutcast/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100644
index 0000000000..bfa42f0e7b
Binary files /dev/null and b/shoutcast/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/shoutcast/src/main/res/mipmap-xxhdpi/ic_launcher.png b/shoutcast/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..324e72cdd7
Binary files /dev/null and b/shoutcast/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/shoutcast/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/shoutcast/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..aee44e1384
Binary files /dev/null and b/shoutcast/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/shoutcast/src/main/res/values/strings.xml b/shoutcast/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..9a4fc871b2
--- /dev/null
+++ b/shoutcast/src/main/res/values/strings.xml
@@ -0,0 +1,3 @@
+<resources>
+    <string name="app_name">ExoplayerShoutcast</string>
+</resources>
