diff --git a/README.md b/README.md
index 8ed742d69e..58b954f350 100644
--- a/README.md
+++ b/README.md
@@ -81,15 +81,3 @@ and copy `library.jar` to the libs folder of your new project.
 
 To develop ExoPlayer using Android Studio, simply open the ExoPlayer project in
 the root directory of the repository.
-
-#### Using Eclipse ####
-
-To develop ExoPlayer using Eclipse:
-
-  1. Install Eclipse and setup the [Android SDK][].
-  1. Open Eclipse and navigate to File->Import->General->Existing Projects into
-     Workspace.
-  1. Select the root directory of the repository.
-  1. Import the projects.
-
-[Android SDK]: http://developer.android.com/sdk/index.html
diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index d8be58a59a..8af8a83f8c 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,14 +1,26 @@
 # Release notes #
 
+### r1.5.7 ###
+
+* OGG: Support added for OGG.
+* FLAC: Support for FLAC extraction and playback (via an extension).
+* HLS: Multiple audio track support (via Renditions).
+* FMP4: Support multiple tracks in fragmented MP4 (not applicable to
+  DASH/SmoothStreaming).
+* WAV: Support for 16-bit WAV files.
+* MKV: Support non-square pixel formats.
+* Misc bug fixes.
+
 ### r1.5.6 ###
 
-* MP3: Fix mono streams playing at 2x speed on some MediaTek based devices (#801).
+* MP3: Fix mono streams playing at 2x speed on some MediaTek based devices
+  (#801).
 * MP3: Fix playback of some streams when stream length is unknown.
 * ID3: Support multiple frames of the same type in a single tag.
-* EIA608: Correctly handle repeated control characters, fixing an issue in which captions would
-  immediately disappear.
-* AVC3: Fix decoder failures on some MediaTek devices in the case where the first buffer fed to the
-  decoder does not start with SPS/PPS NAL units.
+* EIA608: Correctly handle repeated control characters, fixing an issue in which
+  captions would immediately disappear.
+* AVC3: Fix decoder failures on some MediaTek devices in the case where the
+  first buffer fed to the decoder does not start with SPS/PPS NAL units.
 * Misc bug fixes.
 
 ### r1.5.5 ###
@@ -95,9 +107,10 @@
 
 ### r1.3.2 ###
 
-* DataSource improvements: `DefaultUriDataSource` now handles http://, https://, file://, asset://
-  and content:// URIs automatically. It also handles file:///android_asset/* URIs, and file paths
-  like /path/to/media.mp4 where the scheme is omitted.
+* DataSource improvements: `DefaultUriDataSource` now handles http://, https://,
+  file://, asset:// and content:// URIs automatically. It also handles
+  file:///android_asset/* URIs, and file paths like /path/to/media.mp4 where the
+  scheme is omitted.
 * HLS: Fix for some ID3 events being dropped.
 * HLS: Correctly handle 0x0 and floating point RESOLUTION tags.
 * Mp3Extractor: robustness improvements.
diff --git a/build.gradle b/build.gradle
index 96547cc1b3..ca11487c42 100644
--- a/build.gradle
+++ b/build.gradle
@@ -20,7 +20,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.2.3'
+        classpath 'com.android.tools.build:gradle:1.5.0'
         classpath 'com.novoda:bintray-release:0.3.4'
     }
 }
diff --git a/demo/src/main/AndroidManifest.xml b/demo/src/main/AndroidManifest.xml
index 6a49b8804b..2d17093118 100644
--- a/demo/src/main/AndroidManifest.xml
+++ b/demo/src/main/AndroidManifest.xml
@@ -16,8 +16,8 @@
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer.demo"
-    android:versionCode="1506"
-    android:versionName="1.5.6"
+    android:versionCode="1507"
+    android:versionName="1.5.7"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
@@ -41,8 +41,8 @@
     </activity>
 
     <activity android:name="com.google.android.exoplayer.demo.PlayerActivity"
-        android:configChanges="keyboard|keyboardHidden|orientation|screenSize"
-        android:launchMode="singleInstance"
+        android:configChanges="keyboard|keyboardHidden|orientation|screenSize|screenLayout|smallestScreenSize|uiMode"
+        android:launchMode="singleTop"
         android:label="@string/application_name"
         android:theme="@style/PlayerTheme">
       <intent-filter>
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java b/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
index d1813c72ea..6c6c62d9c5 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
@@ -194,9 +194,23 @@ public void onNewIntent(Intent intent) {
     setIntent(intent);
   }
 
+  @Override
+  public void onStart() {
+    super.onStart();
+    if (Util.SDK_INT > 23) {
+      onShown();
+    }
+  }
+
   @Override
   public void onResume() {
     super.onResume();
+    if (Util.SDK_INT <= 23 || player == null) {
+      onShown();
+    }
+  }
+
+  private void onShown() {
     Intent intent = getIntent();
     contentUri = intent.getData();
     contentType = intent.getIntExtra(CONTENT_TYPE_EXTRA,
@@ -216,6 +230,20 @@ public void onResume() {
   @Override
   public void onPause() {
     super.onPause();
+    if (Util.SDK_INT <= 23) {
+      onHidden();
+    }
+  }
+
+  @Override
+  public void onStop() {
+    super.onStop();
+    if (Util.SDK_INT > 23) {
+      onHidden();
+    }
+  }
+
+  private void onHidden() {
     if (!enableBackgroundAudio) {
       releasePlayer();
     } else {
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java b/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
index 9f58528895..9be0c43b76 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
@@ -242,6 +242,8 @@ public Sample(String name, String contentId, String provider, String uri, int ty
         + "&key=ik0", Util.TYPE_OTHER),
     new Sample("Google Play (MP3 Audio)",
         "http://storage.googleapis.com/exoplayer-test-media-0/play.mp3", Util.TYPE_OTHER),
+    new Sample("Google Play (Ogg/Vorbis Audio)",
+        "https://storage.googleapis.com/exoplayer-test-media-1/ogg/play.ogg", Util.TYPE_OTHER),
     new Sample("Google Glass (WebM Video with Vorbis Audio)",
         "http://demos.webmproject.org/exoplayer/glass_vp9_vorbis.webm", Util.TYPE_OTHER),
     new Sample("Big Buck Bunny (FLV Video)",
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
index c3c37bde32..6d3925f751 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
@@ -24,6 +24,7 @@
 import com.google.android.exoplayer.MediaCodecTrackRenderer.DecoderInitializationException;
 import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
 import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.SingleSampleSource;
 import com.google.android.exoplayer.TimeRange;
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.audio.AudioTrack;
@@ -31,6 +32,7 @@
 import com.google.android.exoplayer.chunk.Format;
 import com.google.android.exoplayer.dash.DashChunkSource;
 import com.google.android.exoplayer.drm.StreamingDrmSessionManager;
+import com.google.android.exoplayer.extractor.ExtractorSampleSource;
 import com.google.android.exoplayer.hls.HlsSampleSource;
 import com.google.android.exoplayer.metadata.MetadataTrackRenderer.MetadataRenderer;
 import com.google.android.exoplayer.metadata.id3.Id3Frame;
@@ -57,7 +59,8 @@
  * SmoothStreaming and so on).
  */
 public class DemoPlayer implements ExoPlayer.Listener, ChunkSampleSource.EventListener,
-    HlsSampleSource.EventListener, DefaultBandwidthMeter.EventListener,
+    HlsSampleSource.EventListener, ExtractorSampleSource.EventListener,
+    SingleSampleSource.EventListener, DefaultBandwidthMeter.EventListener,
     MediaCodecVideoTrackRenderer.EventListener, MediaCodecAudioTrackRenderer.EventListener,
     StreamingDrmSessionManager.EventListener, DashChunkSource.EventListener, TextRenderer,
     MetadataRenderer<List<Id3Frame>>, DebugTextViewHelper.Provider {
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/ExtractorRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/ExtractorRendererBuilder.java
index 70cdf54717..8da7961707 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/ExtractorRendererBuilder.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/ExtractorRendererBuilder.java
@@ -34,6 +34,7 @@
 import android.media.AudioManager;
 import android.media.MediaCodec;
 import android.net.Uri;
+import android.os.Handler;
 
 /**
  * A {@link RendererBuilder} for streams that can be read using an {@link Extractor}.
@@ -56,21 +57,21 @@ public ExtractorRendererBuilder(Context context, String userAgent, Uri uri) {
   @Override
   public void buildRenderers(DemoPlayer player) {
     Allocator allocator = new DefaultAllocator(BUFFER_SEGMENT_SIZE);
+    Handler mainHandler = player.getMainHandler();
 
     // Build the video and audio renderers.
-    DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter(player.getMainHandler(),
-        null);
+    DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter(mainHandler, null);
     DataSource dataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
     ExtractorSampleSource sampleSource = new ExtractorSampleSource(uri, dataSource, allocator,
-        BUFFER_SEGMENT_COUNT * BUFFER_SEGMENT_SIZE);
+        BUFFER_SEGMENT_COUNT * BUFFER_SEGMENT_SIZE, mainHandler, player, 0);
     MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(context,
         sampleSource, MediaCodecSelector.DEFAULT, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000,
-        player.getMainHandler(), player, 50);
+        mainHandler, player, 50);
     MediaCodecAudioTrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer(sampleSource,
-        MediaCodecSelector.DEFAULT, null, true, player.getMainHandler(), player,
+        MediaCodecSelector.DEFAULT, null, true, mainHandler, player,
         AudioCapabilities.getCapabilities(context), AudioManager.STREAM_MUSIC);
     TrackRenderer textRenderer = new TextTrackRenderer(sampleSource, player,
-        player.getMainHandler().getLooper());
+        mainHandler.getLooper());
 
     // Invoke the callback.
     TrackRenderer[] renderers = new TrackRenderer[DemoPlayer.RENDERER_COUNT];
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
index abc3595476..b9c34fe595 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
@@ -20,6 +20,7 @@
 import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
 import com.google.android.exoplayer.MediaCodecSelector;
 import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
+import com.google.android.exoplayer.SampleSource;
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.audio.AudioCapabilities;
 import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilder;
@@ -56,7 +57,8 @@
 public class HlsRendererBuilder implements RendererBuilder {
 
   private static final int BUFFER_SEGMENT_SIZE = 64 * 1024;
-  private static final int MAIN_BUFFER_SEGMENTS = 256;
+  private static final int MAIN_BUFFER_SEGMENTS = 254;
+  private static final int AUDIO_BUFFER_SEGMENTS = 54;
   private static final int TEXT_BUFFER_SEGMENTS = 2;
 
   private final Context context;
@@ -133,7 +135,15 @@ public void onSingleManifest(HlsPlaylist manifest) {
       DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter();
       PtsTimestampAdjusterProvider timestampAdjusterProvider = new PtsTimestampAdjusterProvider();
 
-      // Build the video/audio/metadata renderers.
+      boolean haveSubtitles = false;
+      boolean haveAudios = false;
+      if (manifest instanceof HlsMasterPlaylist) {
+        HlsMasterPlaylist masterPlaylist = (HlsMasterPlaylist) manifest;
+        haveSubtitles = !masterPlaylist.subtitles.isEmpty();
+        haveAudios = !masterPlaylist.audios.isEmpty();
+      }
+
+      // Build the video/id3 renderers.
       DataSource dataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
       HlsChunkSource chunkSource = new HlsChunkSource(true /* isMaster */, dataSource, url,
           manifest, DefaultHlsTrackSelector.newDefaultInstance(context), bandwidthMeter,
@@ -143,22 +153,35 @@ public void onSingleManifest(HlsPlaylist manifest) {
       MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(context,
           sampleSource, MediaCodecSelector.DEFAULT, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT,
           5000, mainHandler, player, 50);
-      MediaCodecAudioTrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer(sampleSource,
-          MediaCodecSelector.DEFAULT, null, true, player.getMainHandler(), player,
-          AudioCapabilities.getCapabilities(context), AudioManager.STREAM_MUSIC);
       MetadataTrackRenderer<List<Id3Frame>> id3Renderer = new MetadataTrackRenderer<>(
           sampleSource, new Id3Parser(), player, mainHandler.getLooper());
 
-      // Build the text renderer, preferring Webvtt where available.
-      boolean preferWebvtt = false;
-      if (manifest instanceof HlsMasterPlaylist) {
-        preferWebvtt = !((HlsMasterPlaylist) manifest).subtitles.isEmpty();
+      // Build the audio renderer.
+      MediaCodecAudioTrackRenderer audioRenderer;
+      if (haveAudios) {
+        DataSource audioDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
+        HlsChunkSource audioChunkSource = new HlsChunkSource(false /* isMaster */, audioDataSource,
+            url, manifest, DefaultHlsTrackSelector.newAudioInstance(), bandwidthMeter,
+            timestampAdjusterProvider, HlsChunkSource.ADAPTIVE_MODE_SPLICE);
+        HlsSampleSource audioSampleSource = new HlsSampleSource(audioChunkSource, loadControl,
+            AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, mainHandler, player,
+            DemoPlayer.TYPE_AUDIO);
+        audioRenderer = new MediaCodecAudioTrackRenderer(
+            new SampleSource[] {sampleSource, audioSampleSource}, MediaCodecSelector.DEFAULT, null,
+            true, player.getMainHandler(), player, AudioCapabilities.getCapabilities(context),
+            AudioManager.STREAM_MUSIC);
+      } else {
+        audioRenderer = new MediaCodecAudioTrackRenderer(sampleSource,
+            MediaCodecSelector.DEFAULT, null, true, player.getMainHandler(), player,
+            AudioCapabilities.getCapabilities(context), AudioManager.STREAM_MUSIC);
       }
+
+      // Build the text renderer.
       TrackRenderer textRenderer;
-      if (preferWebvtt) {
+      if (haveSubtitles) {
         DataSource textDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
         HlsChunkSource textChunkSource = new HlsChunkSource(false /* isMaster */, textDataSource,
-            url, manifest, DefaultHlsTrackSelector.newVttInstance(), bandwidthMeter,
+            url, manifest, DefaultHlsTrackSelector.newSubtitleInstance(), bandwidthMeter,
             timestampAdjusterProvider, HlsChunkSource.ADAPTIVE_MODE_SPLICE);
         HlsSampleSource textSampleSource = new HlsSampleSource(textChunkSource, loadControl,
             TEXT_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, mainHandler, player, DemoPlayer.TYPE_TEXT);
diff --git a/demo_ext/README.md b/demo_ext/README.md
new file mode 100644
index 0000000000..33af38780c
--- /dev/null
+++ b/demo_ext/README.md
@@ -0,0 +1,6 @@
+# Extensions Demo #
+
+A demo app that shows how to use the ExoPlayer extensions in your app.
+
+The demo app depends on the VP9, Flac and Opus extensions being configured and
+built correctly.
diff --git a/demo_misc/vp9_opus_sw/build.gradle b/demo_ext/build.gradle
similarity index 90%
rename from demo_misc/vp9_opus_sw/build.gradle
rename to demo_ext/build.gradle
index 5b6eac3ab3..d466aa26a7 100644
--- a/demo_misc/vp9_opus_sw/build.gradle
+++ b/demo_ext/build.gradle
@@ -26,6 +26,10 @@ android {
             minifyEnabled false
             proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
         }
+        debug {
+            jniDebuggable = true
+            debuggable = true
+        }
     }
 
     lintOptions {
@@ -37,4 +41,5 @@ dependencies {
     compile project(':library')
     compile project(':extension-opus')
     compile project(':extension-vp9')
+    compile project(':extension-flac')
 }
diff --git a/demo_misc/vp9_opus_sw/src/main/.classpath b/demo_ext/src/main/.classpath
similarity index 100%
rename from demo_misc/vp9_opus_sw/src/main/.classpath
rename to demo_ext/src/main/.classpath
diff --git a/demo_misc/vp9_opus_sw/src/main/.project b/demo_ext/src/main/.project
similarity index 94%
rename from demo_misc/vp9_opus_sw/src/main/.project
rename to demo_ext/src/main/.project
index 1b6d3fd5ba..547ad46aff 100644
--- a/demo_misc/vp9_opus_sw/src/main/.project
+++ b/demo_ext/src/main/.project
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <projectDescription>
-	<name>ExoPlayerDemoMisc-Vp9OpusSw</name>
+	<name>ExoPlayerDemoExt</name>
 	<comment></comment>
 	<projects>
 	</projects>
diff --git a/demo_misc/vp9_opus_sw/src/main/AndroidManifest.xml b/demo_ext/src/main/AndroidManifest.xml
similarity index 86%
rename from demo_misc/vp9_opus_sw/src/main/AndroidManifest.xml
rename to demo_ext/src/main/AndroidManifest.xml
index 376540734c..daced900c8 100644
--- a/demo_misc/vp9_opus_sw/src/main/AndroidManifest.xml
+++ b/demo_ext/src/main/AndroidManifest.xml
@@ -16,9 +16,9 @@
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
-    package="com.google.android.exoplayer.demo.vp9opus"
-    android:versionCode="1506"
-    android:versionName="1.5.6"
+    package="com.google.android.exoplayer.demo.ext"
+    android:versionCode="1507"
+    android:versionName="1.5.7"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
@@ -35,7 +35,7 @@
       android:allowBackup="false"
       android:icon="@drawable/ic_launcher">
 
-    <activity android:name="com.google.android.exoplayer.demo.vp9opus.SampleChooserActivity"
+    <activity android:name="com.google.android.exoplayer.demo.ext.SampleChooserActivity"
         android:label="@string/app_name"
         android:configChanges="keyboardHidden">
       <intent-filter>
@@ -44,7 +44,7 @@
       </intent-filter>
     </activity>
 
-    <activity android:name=".PlayerActivity"
+    <activity android:name="com.google.android.exoplayer.demo.ext.PlayerActivity"
         android:configChanges="keyboardHidden|orientation|screenSize"
         android:label="@string/app_name"
         android:theme="@style/PlayerTheme"/>
diff --git a/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/DashRendererBuilder.java b/demo_ext/src/main/java/com/google/android/exoplayer/demo/ext/DashRendererBuilder.java
similarity index 99%
rename from demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/DashRendererBuilder.java
rename to demo_ext/src/main/java/com/google/android/exoplayer/demo/ext/DashRendererBuilder.java
index 06d05070f9..03c8cbc347 100644
--- a/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/DashRendererBuilder.java
+++ b/demo_ext/src/main/java/com/google/android/exoplayer/demo/ext/DashRendererBuilder.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.demo.vp9opus;
+package com.google.android.exoplayer.demo.ext;
 
 import com.google.android.exoplayer.DefaultLoadControl;
 import com.google.android.exoplayer.LoadControl;
diff --git a/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/PlayerActivity.java b/demo_ext/src/main/java/com/google/android/exoplayer/demo/ext/PlayerActivity.java
similarity index 92%
rename from demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/PlayerActivity.java
rename to demo_ext/src/main/java/com/google/android/exoplayer/demo/ext/PlayerActivity.java
index f37f3f92c3..2f361c3cd4 100644
--- a/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/PlayerActivity.java
+++ b/demo_ext/src/main/java/com/google/android/exoplayer/demo/ext/PlayerActivity.java
@@ -13,12 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.demo.vp9opus;
+package com.google.android.exoplayer.demo.ext;
 
 import com.google.android.exoplayer.AspectRatioFrameLayout;
 import com.google.android.exoplayer.ExoPlaybackException;
 import com.google.android.exoplayer.ExoPlayer;
+import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
+import com.google.android.exoplayer.MediaCodecSelector;
 import com.google.android.exoplayer.TrackRenderer;
+import com.google.android.exoplayer.ext.flac.FlacExtractor;
+import com.google.android.exoplayer.ext.flac.LibflacAudioTrackRenderer;
 import com.google.android.exoplayer.ext.opus.LibopusAudioTrackRenderer;
 import com.google.android.exoplayer.ext.vp9.LibvpxVideoTrackRenderer;
 import com.google.android.exoplayer.ext.vp9.VpxDecoderException;
@@ -129,7 +133,7 @@ public void onPause() {
   }
 
   private void startBasicPlayback() {
-    player = ExoPlayer.Factory.newInstance(2);
+    player = ExoPlayer.Factory.newInstance(4);
     player.addListener(this);
     mediaController.setMediaPlayer(new PlayerControl(player));
     mediaController.setEnabled(true);
@@ -137,7 +141,7 @@ private void startBasicPlayback() {
         contentUri,
         new DefaultUriDataSource(this, Util.getUserAgent(this, "ExoPlayerExtWebMDemo")),
         new DefaultAllocator(BUFFER_SEGMENT_SIZE), BUFFER_SEGMENT_SIZE * BUFFER_SEGMENT_COUNT,
-        new WebmExtractor());
+        new WebmExtractor(), new FlacExtractor());
     TrackRenderer videoRenderer =
         new LibvpxVideoTrackRenderer(sampleSource, true, handler, this, 50);
     if (useOpenGL) {
@@ -150,8 +154,13 @@ private void startBasicPlayback() {
           surfaceView.getHolder().getSurface());
       vpxVideoSurfaceView.setVisibility(View.GONE);
     }
-    TrackRenderer audioRenderer = new LibopusAudioTrackRenderer(sampleSource);
-    player.prepare(videoRenderer, audioRenderer);
+    TrackRenderer opusAudioTrackRenderer = new LibopusAudioTrackRenderer(sampleSource);
+    TrackRenderer flacAudioTrackRenderer = new LibflacAudioTrackRenderer(sampleSource);
+    TrackRenderer mediaCodecAudioTrackRenderer = new MediaCodecAudioTrackRenderer(sampleSource,
+        MediaCodecSelector.DEFAULT);
+
+    player.prepare(videoRenderer, opusAudioTrackRenderer, flacAudioTrackRenderer,
+        mediaCodecAudioTrackRenderer);
     player.setPlayWhenReady(true);
   }
 
diff --git a/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/SampleChooserActivity.java b/demo_ext/src/main/java/com/google/android/exoplayer/demo/ext/SampleChooserActivity.java
similarity index 98%
rename from demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/SampleChooserActivity.java
rename to demo_ext/src/main/java/com/google/android/exoplayer/demo/ext/SampleChooserActivity.java
index adf0ba1e31..d119897539 100644
--- a/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/SampleChooserActivity.java
+++ b/demo_ext/src/main/java/com/google/android/exoplayer/demo/ext/SampleChooserActivity.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.demo.vp9opus;
+package com.google.android.exoplayer.demo.ext;
 
 import com.google.android.exoplayer.util.Util;
 
@@ -44,6 +44,7 @@ public void onCreate(Bundle savedInstanceState) {
     ListView sampleList = (ListView) findViewById(R.id.sample_list);
     final SampleAdapter sampleAdapter = new SampleAdapter(this);
 
+
     sampleAdapter.add(new Header("DASH - VP9 Only"));
     sampleAdapter.add(new Sample("Google Glass",
         "http://demos.webmproject.org/dash/201410/vp9_glass/manifest_vp9.mpd",
diff --git a/demo_ext/src/main/project.properties b/demo_ext/src/main/project.properties
new file mode 100644
index 0000000000..5f21a4e480
--- /dev/null
+++ b/demo_ext/src/main/project.properties
@@ -0,0 +1,18 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-23
+android.library.reference.1=../../../library/src/main
+android.library.reference.2=../../../extensions/opus/src/main
+android.library.reference.3=../../../extensions/vp9/src/main
+android.library.reference.4=../../../extensions/flac/src/main
diff --git a/demo_misc/vp9_opus_sw/src/main/res/drawable-hdpi/ic_launcher.png b/demo_ext/src/main/res/drawable-hdpi/ic_launcher.png
similarity index 100%
rename from demo_misc/vp9_opus_sw/src/main/res/drawable-hdpi/ic_launcher.png
rename to demo_ext/src/main/res/drawable-hdpi/ic_launcher.png
diff --git a/demo_misc/vp9_opus_sw/src/main/res/drawable-mdpi/ic_launcher.png b/demo_ext/src/main/res/drawable-mdpi/ic_launcher.png
similarity index 100%
rename from demo_misc/vp9_opus_sw/src/main/res/drawable-mdpi/ic_launcher.png
rename to demo_ext/src/main/res/drawable-mdpi/ic_launcher.png
diff --git a/demo_misc/vp9_opus_sw/src/main/res/drawable-xhdpi/ic_launcher.png b/demo_ext/src/main/res/drawable-xhdpi/ic_launcher.png
similarity index 100%
rename from demo_misc/vp9_opus_sw/src/main/res/drawable-xhdpi/ic_launcher.png
rename to demo_ext/src/main/res/drawable-xhdpi/ic_launcher.png
diff --git a/demo_misc/vp9_opus_sw/src/main/res/drawable-xxhdpi/ic_launcher.png b/demo_ext/src/main/res/drawable-xxhdpi/ic_launcher.png
similarity index 100%
rename from demo_misc/vp9_opus_sw/src/main/res/drawable-xxhdpi/ic_launcher.png
rename to demo_ext/src/main/res/drawable-xxhdpi/ic_launcher.png
diff --git a/demo_misc/vp9_opus_sw/src/main/res/drawable-xxxhdpi/ic_launcher.png b/demo_ext/src/main/res/drawable-xxxhdpi/ic_launcher.png
similarity index 100%
rename from demo_misc/vp9_opus_sw/src/main/res/drawable-xxxhdpi/ic_launcher.png
rename to demo_ext/src/main/res/drawable-xxxhdpi/ic_launcher.png
diff --git a/demo_misc/vp9_opus_sw/src/main/res/layout/activity_video_player.xml b/demo_ext/src/main/res/layout/activity_video_player.xml
similarity index 100%
rename from demo_misc/vp9_opus_sw/src/main/res/layout/activity_video_player.xml
rename to demo_ext/src/main/res/layout/activity_video_player.xml
diff --git a/demo_misc/vp9_opus_sw/src/main/res/layout/rows.xml b/demo_ext/src/main/res/layout/rows.xml
similarity index 100%
rename from demo_misc/vp9_opus_sw/src/main/res/layout/rows.xml
rename to demo_ext/src/main/res/layout/rows.xml
diff --git a/demo_misc/vp9_opus_sw/src/main/res/layout/sample_chooser_activity.xml b/demo_ext/src/main/res/layout/sample_chooser_activity.xml
similarity index 100%
rename from demo_misc/vp9_opus_sw/src/main/res/layout/sample_chooser_activity.xml
rename to demo_ext/src/main/res/layout/sample_chooser_activity.xml
diff --git a/demo_misc/vp9_opus_sw/src/main/res/layout/sample_chooser_inline_header.xml b/demo_ext/src/main/res/layout/sample_chooser_inline_header.xml
similarity index 100%
rename from demo_misc/vp9_opus_sw/src/main/res/layout/sample_chooser_inline_header.xml
rename to demo_ext/src/main/res/layout/sample_chooser_inline_header.xml
diff --git a/demo_misc/vp9_opus_sw/src/main/res/values-v11/styles.xml b/demo_ext/src/main/res/values-v11/styles.xml
similarity index 100%
rename from demo_misc/vp9_opus_sw/src/main/res/values-v11/styles.xml
rename to demo_ext/src/main/res/values-v11/styles.xml
diff --git a/demo_misc/vp9_opus_sw/src/main/res/values/strings.xml b/demo_ext/src/main/res/values/strings.xml
similarity index 95%
rename from demo_misc/vp9_opus_sw/src/main/res/values/strings.xml
rename to demo_ext/src/main/res/values/strings.xml
index b12c865ebc..8f0eb7c02a 100644
--- a/demo_misc/vp9_opus_sw/src/main/res/values/strings.xml
+++ b/demo_ext/src/main/res/values/strings.xml
@@ -16,7 +16,7 @@
 
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
 
-  <string name="app_name">WebM ExoPlayer Demo</string>
+  <string name="app_name">ExoPlayer Extensions Demo</string>
   <string name="choose_file">Choose File</string>
   <string name="play">Play</string>
   <string name="current_path">
diff --git a/demo_misc/vp9_opus_sw/src/main/res/values/styles.xml b/demo_ext/src/main/res/values/styles.xml
similarity index 100%
rename from demo_misc/vp9_opus_sw/src/main/res/values/styles.xml
rename to demo_ext/src/main/res/values/styles.xml
diff --git a/demo_misc/README.md b/demo_misc/README.md
deleted file mode 100644
index f7d7af6ac4..0000000000
--- a/demo_misc/README.md
+++ /dev/null
@@ -1,7 +0,0 @@
-# Miscellaneous demos #
-
-This folder contains miscellaneous demo applications. For example applications
-that demonstrate use of optional extensions, or more advanced features.
-
-A general purpose ExoPlayer demo application can be found in the [demo](../demo)
-folder.
diff --git a/demo_misc/vp9_opus_sw/README.md b/demo_misc/vp9_opus_sw/README.md
deleted file mode 100644
index 4714d34084..0000000000
--- a/demo_misc/vp9_opus_sw/README.md
+++ /dev/null
@@ -1,5 +0,0 @@
-# WebM (VP9/Opus) Software Decoder Demo #
-
-A demo app that shows how to use the ExoPlayer [VP9](../../extensions/vp9) and [Opus](../../extensions/opus) Extensions to enable VP9 and Opus playback in your app by bundling native libraries along with it.
-
-The demo app depends on the VP9 and Opus Extensions being configured built correctly.
diff --git a/extensions/flac/README.md b/extensions/flac/README.md
new file mode 100644
index 0000000000..7d6abc9c8b
--- /dev/null
+++ b/extensions/flac/README.md
@@ -0,0 +1,65 @@
+# ExoPlayer Flac Extension #
+
+## Description ##
+
+The Flac Extension is a [TrackRenderer][] implementation that helps you bundle
+libFLAC (the Flac decoding library) into your app and use it along with
+ExoPlayer to play Flac audio on Android devices.
+
+[TrackRenderer]: https://google.github.io/ExoPlayer/doc/reference/com/google/android/exoplayer/TrackRenderer.html
+
+## Build Instructions ##
+
+* Checkout ExoPlayer along with Extensions:
+
+```
+git clone https://github.com/google/ExoPlayer.git
+```
+
+* Set the following environment variables:
+
+```
+cd "<path to exoplayer checkout>"
+EXOPLAYER_ROOT="$(pwd)"
+FLAC_EXT_PATH="${EXOPLAYER_ROOT}/extensions/flac/src/main"
+```
+
+* Download the [Android NDK][] and set its location in an environment variable:
+
+[Android NDK]: https://developer.android.com/tools/sdk/ndk/index.html
+
+```
+NDK_PATH="<path to Android NDK>"
+```
+
+* Download and extract flac-1.3.1 as "${FLAC_EXT_PATH}/jni/flac" folder:
+
+```
+curl http://downloads.xiph.org/releases/flac/flac-1.3.1.tar.xz | tar xJ && \
+mv flac-1.3.1 flac
+```
+
+* Build the JNI native libraries from the command line:
+
+```
+cd "${FLAC_EXT_PATH}"/jni && \
+${NDK_PATH}/ndk-build APP_ABI=all -j4
+```
+
+* In your project, you can add a dependency to the Flac Extension by using a
+  rule like this:
+
+```
+// in settings.gradle
+include ':..:ExoPlayer:library'
+include ':..:ExoPlayer:extension-flac'
+
+// in build.gradle
+dependencies {
+    compile project(':..:ExoPlayer:library')
+    compile project(':..:ExoPlayer:extension-flac')
+}
+```
+
+* Now, when you build your app, the Flac extension will be built and the native
+  libraries will be packaged along with the APK.
diff --git a/extensions/flac/build.gradle b/extensions/flac/build.gradle
new file mode 100644
index 0000000000..e170263d74
--- /dev/null
+++ b/extensions/flac/build.gradle
@@ -0,0 +1,45 @@
+// Copyright (C) 2016 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion 23
+    buildToolsVersion "23.0.1"
+
+    defaultConfig {
+        minSdkVersion 9
+        targetSdkVersion 23
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
+        }
+    }
+
+    lintOptions {
+        abortOnError false
+    }
+
+    sourceSets.main {
+        jniLibs.srcDir 'src/main/libs'
+        jni.srcDirs = [] // Disable the automatic ndk-build call by Android Studio.
+    }
+}
+
+dependencies {
+    compile project(':library')
+}
+
diff --git a/extensions/flac/src/main/.classpath b/extensions/flac/src/main/.classpath
new file mode 100644
index 0000000000..503bb38b67
--- /dev/null
+++ b/extensions/flac/src/main/.classpath
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="src" path="java"/>
+	<classpathentry kind="src" path="/ExoPlayerLib"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/extensions/flac/src/main/.project b/extensions/flac/src/main/.project
new file mode 100644
index 0000000000..d96e765c9a
--- /dev/null
+++ b/extensions/flac/src/main/.project
@@ -0,0 +1,97 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>ExoPlayerExt-Flac</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
+			<triggers>clean,full,incremental,</triggers>
+			<arguments>
+				<dictionary>
+					<key>?children?</key>
+					<value>?name?=outputEntries\|?children?=?name?=entry\\\\\\\|\\\|?name?=entry\\\\\\\|\\\|\||</value>
+				</dictionary>
+				<dictionary>
+					<key>?name?</key>
+					<value></value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.append_environment</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildArguments</key>
+					<value></value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildCommand</key>
+					<value>ndk-build</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.cleanBuildTarget</key>
+					<value>clean</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.contents</key>
+					<value>org.eclipse.cdt.make.core.activeConfigSettings</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableAutoBuild</key>
+					<value>false</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableCleanBuild</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableFullBuild</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.stopOnError</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.useDefaultBuildCmd</key>
+					<value>true</value>
+				</dictionary>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</name>
+			<triggers>full,incremental,</triggers>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+		<nature>org.eclipse.cdt.core.cnature</nature>
+		<nature>org.eclipse.cdt.core.ccnature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
+	</natures>
+</projectDescription>
diff --git a/extensions/flac/src/main/AndroidManifest.xml b/extensions/flac/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..1a075c0948
--- /dev/null
+++ b/extensions/flac/src/main/AndroidManifest.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.google.android.exoplayer.ext.flac">
+
+    <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="23"/>
+
+</manifest>
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java
new file mode 100644
index 0000000000..7881b45ecd
--- /dev/null
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.flac;
+
+import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.util.extensions.InputBuffer;
+import com.google.android.exoplayer.util.extensions.SimpleDecoder;
+
+import java.nio.ByteBuffer;
+import java.util.List;
+
+/**
+ * Flac decoder.
+ */
+/* package */ final class FlacDecoder extends
+    SimpleDecoder<InputBuffer, FlacOutputBuffer, FlacDecoderException> {
+
+  private final int maxOutputBufferSize;
+  private final FlacJni decoder;
+  /**
+   * Creates a Flac decoder.
+   *
+   * @param numInputBuffers The number of input buffers.
+   * @param numOutputBuffers The number of output buffers.
+   * @param initializationData Codec-specific initialization data.
+   * @throws FlacDecoderException Thrown if an exception occurs when initializing the decoder.
+   */
+  public FlacDecoder(int numInputBuffers, int numOutputBuffers, List<byte[]> initializationData)
+      throws FlacDecoderException {
+    super(new InputBuffer[numInputBuffers], new FlacOutputBuffer[numOutputBuffers]);
+    if (initializationData.size() != 1) {
+      throw new FlacDecoderException("Wrong number of initialization data");
+    }
+
+    decoder = new FlacJni();
+
+    ByteBuffer metadata = ByteBuffer.wrap(initializationData.get(0));
+    decoder.setData(metadata);
+    FlacStreamInfo streamInfo = decoder.decodeMetadata();
+    if (streamInfo == null) {
+      throw new FlacDecoderException("Metadata decoding failed");
+    }
+
+    setInitialInputBufferSize(streamInfo.maxFrameSize);
+    maxOutputBufferSize = streamInfo.maxDecodedFrameSize();
+  }
+
+  @Override
+  public InputBuffer createInputBuffer() {
+    return new InputBuffer();
+  }
+
+  @Override
+  public FlacOutputBuffer createOutputBuffer() {
+    return new FlacOutputBuffer(this);
+  }
+
+  @Override
+  protected void releaseOutputBuffer(FlacOutputBuffer buffer) {
+    super.releaseOutputBuffer(buffer);
+  }
+
+  @Override
+  public FlacDecoderException decode(InputBuffer inputBuffer, FlacOutputBuffer outputBuffer) {
+    SampleHolder sampleHolder = inputBuffer.sampleHolder;
+    outputBuffer.timestampUs = sampleHolder.timeUs;
+    sampleHolder.data.limit(sampleHolder.data.position());
+    sampleHolder.data.position(sampleHolder.data.position() - sampleHolder.size);
+    outputBuffer.init(maxOutputBufferSize);
+    decoder.setData(sampleHolder.data);
+    int result = decoder.decodeSample(outputBuffer.data);
+    if (result < 0) {
+      return new FlacDecoderException("Frame decoding failed");
+    }
+    outputBuffer.data.position(0);
+    outputBuffer.data.limit(result);
+    return null;
+  }
+
+  @Override
+  public void release() {
+    super.release();
+    decoder.release();
+  }
+
+}
+
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoderException.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoderException.java
new file mode 100644
index 0000000000..8aeb564bea
--- /dev/null
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoderException.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.flac;
+
+/**
+ * Thrown when an Flac decoder error occurs.
+ */
+public final class FlacDecoderException extends Exception {
+
+  /* package */ FlacDecoderException(String message) {
+    super(message);
+  }
+
+}
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacExtractor.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacExtractor.java
new file mode 100644
index 0000000000..7090a36a1a
--- /dev/null
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacExtractor.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.flac;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.ExtractorOutput;
+import com.google.android.exoplayer.extractor.PositionHolder;
+import com.google.android.exoplayer.extractor.SeekMap;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+/**
+ * Facilitates the extraction of data from the FLAC container format.
+ */
+public final class FlacExtractor implements Extractor {
+  /**
+   * FLAC signature: first 4 is the signature word, second 4 is the sizeof STREAMINFO. 0x22 is the
+   * mandatory STREAMINFO.
+   */
+  private static final byte[] FLAC_SIGNATURE = {'f', 'L', 'a', 'C', 0, 0, 0, 0x22};
+
+  private TrackOutput output;
+
+  private FlacJni decoder;
+
+  private boolean metadataParsed;
+
+  private ParsableByteArray outputBuffer;
+  private ByteBuffer outputByteBuffer;
+
+  private boolean isSeekable;
+
+  @Override
+  public void init(ExtractorOutput output) {
+    this.output = output.track(0);
+    output.endTracks();
+
+    output.seekMap(new SeekMap() {
+      @Override
+      public boolean isSeekable() {
+        return isSeekable;
+      }
+
+      @Override
+      public long getPosition(long timeUs) {
+        return isSeekable ? decoder.getSeekPosition(timeUs) : 0;
+      }
+    });
+
+    try {
+      decoder = new FlacJni();
+    } catch (FlacDecoderException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @Override
+  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+    byte[] header = new byte[FLAC_SIGNATURE.length];
+    input.peekFully(header, 0, FLAC_SIGNATURE.length);
+    return Arrays.equals(header, FLAC_SIGNATURE);
+  }
+
+  @Override
+  public int read(final ExtractorInput input, PositionHolder seekPosition)
+      throws IOException, InterruptedException {
+    decoder.setData(input);
+
+    if (!metadataParsed) {
+      FlacStreamInfo streamInfo = decoder.decodeMetadata();
+      if (streamInfo == null) {
+        throw new IOException("Metadata decoding failed");
+      }
+      metadataParsed = true;
+      isSeekable = decoder.getSeekPosition(0) != -1;
+
+      MediaFormat mediaFormat = MediaFormat.createAudioFormat(null, MimeTypes.AUDIO_RAW,
+              MediaFormat.NO_VALUE, streamInfo.bitRate(), streamInfo.durationUs(),
+              streamInfo.channels, streamInfo.sampleRate, null, null);
+      output.format(mediaFormat);
+
+      outputBuffer = new ParsableByteArray(streamInfo.maxDecodedFrameSize());
+      outputByteBuffer = ByteBuffer.wrap(outputBuffer.data);
+    }
+
+    outputBuffer.reset();
+    int size = decoder.decodeSample(outputByteBuffer);
+    if (size <= 0) {
+      return RESULT_END_OF_INPUT;
+    }
+    output.sampleData(outputBuffer, size);
+
+    output.sampleMetadata(decoder.getLastSampleTimestamp(), C.SAMPLE_FLAG_SYNC, size, 0, null);
+
+    return decoder.isEndOfData() ? RESULT_END_OF_INPUT : RESULT_CONTINUE;
+  }
+
+  @Override
+  public void seek() {
+    decoder.flush();
+  }
+
+  @Override
+  public void release() {
+    decoder.release();
+    decoder = null;
+  }
+
+}
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacJni.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacJni.java
new file mode 100644
index 0000000000..1c26909c26
--- /dev/null
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacJni.java
@@ -0,0 +1,192 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.flac;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+/**
+ * JNI wrapper for the libflac Flac decoder.
+ */
+/* package */ final class FlacJni {
+
+  /**
+   * Whether the underlying libflac library is available.
+   */
+  public static final boolean IS_AVAILABLE;
+  static {
+    boolean isAvailable;
+    try {
+      System.loadLibrary("flacJNI");
+      isAvailable = true;
+    } catch (UnsatisfiedLinkError exception) {
+      isAvailable = false;
+    }
+    IS_AVAILABLE = isAvailable;
+  }
+
+  private static final int TEMP_BUFFER_SIZE = 8192; // The same buffer size which libflac has
+
+  private final long nativeDecoderContext;
+
+  private ByteBuffer byteBufferData;
+
+  private ExtractorInput extractorInput;
+  private boolean endOfExtractorInput;
+  private byte[] tempBuffer;
+
+  public FlacJni() throws FlacDecoderException {
+    nativeDecoderContext = flacInit();
+    if (nativeDecoderContext == 0) {
+      throw new FlacDecoderException("Failed to initialize decoder");
+    }
+  }
+
+  /**
+   * Sets data to be parsed by libflac.
+   * @param byteBufferData Source {@link ByteBuffer}
+   */
+  public void setData(ByteBuffer byteBufferData) {
+    this.byteBufferData = byteBufferData;
+    this.extractorInput = null;
+    this.tempBuffer = null;
+  }
+
+  /**
+   * Sets data to be parsed by libflac.
+   * @param extractorInput Source {@link ExtractorInput}
+   */
+  public void setData(ExtractorInput extractorInput) {
+    this.byteBufferData = null;
+    this.extractorInput = extractorInput;
+    if (tempBuffer == null) {
+      this.tempBuffer = new byte[TEMP_BUFFER_SIZE];
+    }
+    endOfExtractorInput = false;
+  }
+
+  public boolean isEndOfData() {
+    if (byteBufferData != null) {
+      return byteBufferData.remaining() == 0;
+    } else if (extractorInput != null) {
+      return endOfExtractorInput;
+    }
+    return true;
+  }
+
+  /**
+   * Reads up to {@code length} bytes from the data source.
+   * <p>
+   * This method blocks until at least one byte of data can be read, the end of the input is
+   * detected or an exception is thrown.
+   * <p>
+   * This method is called from the native code.
+   *
+   * @param target A target {@link ByteBuffer} into which data should be written.
+   * @return Returns the number of bytes read, or -1 on failure. It's not an error if this returns
+   * zero; it just means all the data read from the source.
+   */
+  public int read(ByteBuffer target) throws IOException, InterruptedException {
+    int byteCount = target.remaining();
+    if (byteBufferData != null) {
+      byteCount = Math.min(byteCount, byteBufferData.remaining());
+      int originalLimit = byteBufferData.limit();
+      byteBufferData.limit(byteBufferData.position() + byteCount);
+
+      target.put(byteBufferData);
+
+      byteBufferData.limit(originalLimit);
+    } else if (extractorInput != null) {
+      byteCount = Math.min(byteCount, TEMP_BUFFER_SIZE);
+      int read = readFromExtractorInput(0, byteCount);
+      if (read < 4) {
+        // Reading less than 4 bytes, most of the time, happens because of getting the bytes left in
+        // the buffer of the input. Do another read to reduce the number of calls to this method
+        // from the native code.
+        read += readFromExtractorInput(read, byteCount - read);
+      }
+      byteCount = read;
+      target.put(tempBuffer, 0, byteCount);
+    } else {
+      return -1;
+    }
+    return byteCount;
+  }
+
+  public FlacStreamInfo decodeMetadata() {
+    return flacDecodeMetadata(nativeDecoderContext);
+  }
+
+  public int decodeSample(ByteBuffer output) {
+    return output.isDirect()
+        ? flacDecodeToBuffer(nativeDecoderContext, output)
+        : flacDecodeToArray(nativeDecoderContext, output.array());
+  }
+
+  public long getLastSampleTimestamp() {
+    return flacGetLastTimestamp(nativeDecoderContext);
+  }
+
+  /**
+   * Maps a seek position in microseconds to a corresponding position (byte offset) in the flac
+   * stream.
+   *
+   * @param timeUs A seek position in microseconds.
+   * @return The corresponding position (byte offset) in the flac stream or -1 if the stream doesn't
+   * have a seek table.
+   */
+  public long getSeekPosition(long timeUs) {
+    return flacGetSeekPosition(nativeDecoderContext, timeUs);
+  }
+
+  public void flush() {
+    flacFlush(nativeDecoderContext);
+  }
+
+  public void release() {
+    flacRelease(nativeDecoderContext);
+  }
+
+  private int readFromExtractorInput(int offset, int length)
+      throws IOException, InterruptedException {
+    int read = extractorInput.read(tempBuffer, offset, length);
+    if (read == C.RESULT_END_OF_INPUT) {
+      endOfExtractorInput = true;
+      read = 0;
+    }
+    return read;
+  }
+
+  private native long flacInit();
+
+  private native FlacStreamInfo flacDecodeMetadata(long context);
+
+  private native int flacDecodeToBuffer(long context, ByteBuffer outputBuffer);
+
+  private native int flacDecodeToArray(long context, byte[] outputArray);
+
+  private native long flacGetLastTimestamp(long context);
+
+  private native long flacGetSeekPosition(long context, long timeUs);
+
+  private native void flacFlush(long context);
+
+  private native void flacRelease(long context);
+
+}
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacOutputBuffer.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacOutputBuffer.java
new file mode 100644
index 0000000000..26356d7020
--- /dev/null
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacOutputBuffer.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.flac;
+
+import com.google.android.exoplayer.util.extensions.OutputBuffer;
+
+import java.nio.ByteBuffer;
+
+/**
+ * Buffer for {@link FlacDecoder} output.
+ */
+public final class FlacOutputBuffer extends OutputBuffer {
+
+  private final FlacDecoder owner;
+
+  public ByteBuffer data;
+
+  /* package */ FlacOutputBuffer(FlacDecoder owner) {
+    this.owner = owner;
+  }
+
+  /* package */ void init(int size) {
+    if (data == null || data.capacity() < size) {
+      data = ByteBuffer.allocateDirect(size);
+    }
+    data.position(0);
+    data.limit(size);
+  }
+
+  @Override
+  public void reset() {
+    super.reset();
+    if (data != null) {
+      data.clear();
+    }
+  }
+
+  @Override
+  public void release() {
+    owner.releaseOutputBuffer(this);
+  }
+
+}
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacStreamInfo.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacStreamInfo.java
new file mode 100644
index 0000000000..8de58f7993
--- /dev/null
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacStreamInfo.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.flac;
+
+/**
+ * Holder for flac stream info.
+ */
+/* package */ final class FlacStreamInfo {
+  public final int minBlockSize;
+  public final int maxBlockSize;
+  public final int minFrameSize;
+  public final int maxFrameSize;
+  public final int sampleRate;
+  public final int channels;
+  public final int bitsPerSample;
+  public final long totalSamples;
+
+  public FlacStreamInfo(int minBlockSize, int maxBlockSize, int minFrameSize, int maxFrameSize,
+      int sampleRate, int channels, int bitsPerSample, long totalSamples) {
+    this.minBlockSize = minBlockSize;
+    this.maxBlockSize = maxBlockSize;
+    this.minFrameSize = minFrameSize;
+    this.maxFrameSize = maxFrameSize;
+    this.sampleRate = sampleRate;
+    this.channels = channels;
+    this.bitsPerSample = bitsPerSample;
+    this.totalSamples = totalSamples;
+  }
+
+  public int maxDecodedFrameSize() {
+    return maxBlockSize * channels * 2;
+  }
+
+  public int bitRate() {
+    return bitsPerSample * sampleRate;
+  }
+
+  public long durationUs() {
+    return (totalSamples * 1000000L) / sampleRate;
+  }
+}
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
new file mode 100644
index 0000000000..e1b07e2162
--- /dev/null
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
@@ -0,0 +1,394 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.flac;
+
+import com.google.android.exoplayer.CodecCounters;
+import com.google.android.exoplayer.ExoPlaybackException;
+import com.google.android.exoplayer.ExoPlayer;
+import com.google.android.exoplayer.MediaClock;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.MediaFormatHolder;
+import com.google.android.exoplayer.SampleSource;
+import com.google.android.exoplayer.SampleSourceTrackRenderer;
+import com.google.android.exoplayer.TrackRenderer;
+import com.google.android.exoplayer.audio.AudioTrack;
+import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.extensions.Buffer;
+import com.google.android.exoplayer.util.extensions.InputBuffer;
+
+import android.os.Handler;
+
+import java.util.List;
+
+/**
+ * Decodes and renders audio using the native Flac decoder.
+ */
+public final class LibflacAudioTrackRenderer extends SampleSourceTrackRenderer
+    implements MediaClock {
+
+  /**
+   * Interface definition for a callback to be notified of {@link LibflacAudioTrackRenderer} events.
+   */
+  public interface EventListener {
+
+    /**
+     * Invoked when the {@link AudioTrack} fails to initialize.
+     *
+     * @param e The corresponding exception.
+     */
+    void onAudioTrackInitializationError(AudioTrack.InitializationException e);
+
+    /**
+     * Invoked when an {@link AudioTrack} write fails.
+     *
+     * @param e The corresponding exception.
+     */
+    void onAudioTrackWriteError(AudioTrack.WriteException e);
+
+    /**
+     * Invoked when decoding fails.
+     *
+     * @param e The corresponding exception.
+     */
+    void onDecoderError(FlacDecoderException e);
+
+  }
+
+  /**
+   * The type of a message that can be passed to an instance of this class via
+   * {@link ExoPlayer#sendMessage} or {@link ExoPlayer#blockingSendMessage}. The message object
+   * should be a {@link Float} with 0 being silence and 1 being unity gain.
+   */
+  public static final int MSG_SET_VOLUME = 1;
+
+  private static final int NUM_BUFFERS = 16;
+
+  public final CodecCounters codecCounters = new CodecCounters();
+
+  private final Handler eventHandler;
+  private final EventListener eventListener;
+  private final MediaFormatHolder formatHolder;
+
+  private MediaFormat format;
+  private FlacDecoder decoder;
+  private InputBuffer inputBuffer;
+  private FlacOutputBuffer outputBuffer;
+
+  private long currentPositionUs;
+  private boolean allowPositionDiscontinuity;
+  private boolean inputStreamEnded;
+  private boolean outputStreamEnded;
+  private boolean sourceIsReady;
+
+  private final AudioTrack audioTrack;
+  private int audioSessionId;
+
+  /**
+   * @param source The upstream source from which the renderer obtains samples.
+   */
+  public LibflacAudioTrackRenderer(SampleSource source) {
+    this(source, null, null);
+  }
+
+  /**
+   * @param source The upstream source from which the renderer obtains samples.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   */
+  public LibflacAudioTrackRenderer(SampleSource source, Handler eventHandler,
+      EventListener eventListener) {
+    super(source);
+    this.eventHandler = eventHandler;
+    this.eventListener = eventListener;
+    this.audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
+    this.audioTrack = new AudioTrack();
+    formatHolder = new MediaFormatHolder();
+  }
+
+  /**
+   * Returns whether the underlying libflac library is available.
+   */
+  public static boolean isLibflacAvailable() {
+    return FlacJni.IS_AVAILABLE;
+  }
+
+  @Override
+  protected MediaClock getMediaClock() {
+    return this;
+  }
+
+  @Override
+  protected boolean handlesTrack(MediaFormat mediaFormat) {
+    return MimeTypes.AUDIO_FLAC.equalsIgnoreCase(mediaFormat.mimeType);
+  }
+
+  @Override
+  protected void doSomeWork(long positionUs, long elapsedRealtimeUs, boolean sourceIsReady)
+      throws ExoPlaybackException {
+    if (outputStreamEnded) {
+      return;
+    }
+    this.sourceIsReady = sourceIsReady;
+
+    // Try and read a format if we don't have one already.
+    if (format == null && !readFormat(positionUs)) {
+      // We can't make progress without one.
+      return;
+    }
+
+    // If we don't have a decoder yet, we need to instantiate one.
+    if (decoder == null) {
+      // For flac, the format can contain only one entry in initializationData which is the flac
+      // file header.
+      List<byte[]> initializationData = format.initializationData;
+      if (initializationData.size() < 1) {
+        throw new ExoPlaybackException("Missing initialization data");
+      }
+      try {
+        decoder = new FlacDecoder(NUM_BUFFERS, NUM_BUFFERS, initializationData);
+      } catch (FlacDecoderException e) {
+        notifyDecoderError(e);
+        throw new ExoPlaybackException(e);
+      }
+      decoder.start();
+      codecCounters.codecInitCount++;
+    }
+
+    // Rendering loop.
+    try {
+      renderBuffer();
+      while (feedInputBuffer(positionUs)) {}
+    } catch (AudioTrack.InitializationException e) {
+      notifyAudioTrackInitializationError(e);
+      throw new ExoPlaybackException(e);
+    } catch (AudioTrack.WriteException e) {
+      notifyAudioTrackWriteError(e);
+      throw new ExoPlaybackException(e);
+    } catch (FlacDecoderException e) {
+      notifyDecoderError(e);
+      throw new ExoPlaybackException(e);
+    }
+    codecCounters.ensureUpdated();
+  }
+
+  private void renderBuffer() throws FlacDecoderException, AudioTrack.InitializationException,
+      AudioTrack.WriteException {
+    if (outputStreamEnded) {
+      return;
+    }
+
+    if (outputBuffer == null) {
+      outputBuffer = decoder.dequeueOutputBuffer();
+      if (outputBuffer == null) {
+        return;
+      }
+    }
+
+    if (outputBuffer.getFlag(Buffer.FLAG_END_OF_STREAM)) {
+      outputStreamEnded = true;
+      audioTrack.handleEndOfStream();
+      outputBuffer.release();
+      outputBuffer = null;
+      return;
+    }
+
+    if (!audioTrack.isInitialized()) {
+      if (audioSessionId != AudioTrack.SESSION_ID_NOT_SET) {
+        audioTrack.initialize(audioSessionId);
+      } else {
+        audioSessionId = audioTrack.initialize();
+      }
+      if (getState() == TrackRenderer.STATE_STARTED) {
+        audioTrack.play();
+      }
+    }
+
+    int handleBufferResult;
+    handleBufferResult = audioTrack.handleBuffer(outputBuffer.data, outputBuffer.data.position(),
+        outputBuffer.data.remaining(), outputBuffer.timestampUs);
+
+    // If we are out of sync, allow currentPositionUs to jump backwards.
+    if ((handleBufferResult & AudioTrack.RESULT_POSITION_DISCONTINUITY) != 0) {
+      allowPositionDiscontinuity = true;
+    }
+
+    // Release the buffer if it was consumed.
+    if ((handleBufferResult & AudioTrack.RESULT_BUFFER_CONSUMED) != 0) {
+      codecCounters.renderedOutputBufferCount++;
+      outputBuffer.release();
+      outputBuffer = null;
+    }
+  }
+
+  private boolean feedInputBuffer(long positionUs) throws FlacDecoderException {
+    if (inputStreamEnded) {
+      return false;
+    }
+
+    if (inputBuffer == null) {
+      inputBuffer = decoder.dequeueInputBuffer();
+      if (inputBuffer == null) {
+        return false;
+      }
+    }
+
+    int result = readSource(positionUs, formatHolder, inputBuffer.sampleHolder);
+    if (result == SampleSource.NOTHING_READ) {
+      return false;
+    }
+    if (result == SampleSource.FORMAT_READ) {
+      format = formatHolder.format;
+      return true;
+    }
+    if (result == SampleSource.END_OF_STREAM) {
+      inputBuffer.setFlag(Buffer.FLAG_END_OF_STREAM);
+      decoder.queueInputBuffer(inputBuffer);
+      inputBuffer = null;
+      inputStreamEnded = true;
+      return false;
+    }
+
+    decoder.queueInputBuffer(inputBuffer);
+    inputBuffer = null;
+    return true;
+  }
+
+  private void flushDecoder() {
+    inputBuffer = null;
+    if (outputBuffer != null) {
+      outputBuffer.release();
+      outputBuffer = null;
+    }
+    decoder.flush();
+  }
+
+  @Override
+  protected boolean isEnded() {
+    return outputStreamEnded && !audioTrack.hasPendingData();
+  }
+
+  @Override
+  protected boolean isReady() {
+    return audioTrack.hasPendingData()
+        || (format != null && (sourceIsReady || outputBuffer != null));
+  }
+
+  @Override
+  public long getPositionUs() {
+    long newCurrentPositionUs = audioTrack.getCurrentPositionUs(isEnded());
+    if (newCurrentPositionUs != AudioTrack.CURRENT_POSITION_NOT_SET) {
+      currentPositionUs = allowPositionDiscontinuity ? newCurrentPositionUs
+          : Math.max(currentPositionUs, newCurrentPositionUs);
+      allowPositionDiscontinuity = false;
+    }
+    return currentPositionUs;
+  }
+
+  @Override
+  protected void onDiscontinuity(long positionUs) {
+    audioTrack.reset();
+    currentPositionUs = positionUs;
+    allowPositionDiscontinuity = true;
+    inputStreamEnded = false;
+    outputStreamEnded = false;
+    sourceIsReady = false;
+    if (decoder != null) {
+      flushDecoder();
+    }
+  }
+
+  @Override
+  protected void onStarted() {
+    audioTrack.play();
+  }
+
+  @Override
+  protected void onStopped() {
+    audioTrack.pause();
+  }
+
+  @Override
+  protected void onDisabled() throws ExoPlaybackException {
+    inputBuffer = null;
+    outputBuffer = null;
+    format = null;
+    audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
+    try {
+      if (decoder != null) {
+        decoder.release();
+        decoder = null;
+        codecCounters.codecReleaseCount++;
+      }
+      audioTrack.release();
+    } finally {
+      super.onDisabled();
+    }
+  }
+
+  private boolean readFormat(long positionUs) {
+    int result = readSource(positionUs, formatHolder, null);
+    if (result == SampleSource.FORMAT_READ) {
+      format = formatHolder.format;
+      audioTrack.configure(format.getFrameworkMediaFormatV16(), false);
+      return true;
+    }
+    return false;
+  }
+
+  @Override
+  public void handleMessage(int messageType, Object message) throws ExoPlaybackException {
+    if (messageType == MSG_SET_VOLUME) {
+      audioTrack.setVolume((Float) message);
+    } else {
+      super.handleMessage(messageType, message);
+    }
+  }
+
+  private void notifyAudioTrackInitializationError(final AudioTrack.InitializationException e) {
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable() {
+        @Override
+        public void run() {
+          eventListener.onAudioTrackInitializationError(e);
+        }
+      });
+    }
+  }
+
+  private void notifyAudioTrackWriteError(final AudioTrack.WriteException e) {
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable() {
+        @Override
+        public void run() {
+          eventListener.onAudioTrackWriteError(e);
+        }
+      });
+    }
+  }
+
+  private void notifyDecoderError(final FlacDecoderException e) {
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable() {
+        @Override
+        public void run() {
+          eventListener.onDecoderError(e);
+        }
+      });
+    }
+  }
+
+}
diff --git a/extensions/flac/src/main/jni/Android.mk b/extensions/flac/src/main/jni/Android.mk
new file mode 100644
index 0000000000..e009333633
--- /dev/null
+++ b/extensions/flac/src/main/jni/Android.mk
@@ -0,0 +1,38 @@
+#
+# Copyright (C) 2016 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+WORKING_DIR := $(call my-dir)
+
+# build libflacJNI.so
+include $(CLEAR_VARS)
+include $(WORKING_DIR)/flac_sources.mk
+
+LOCAL_PATH := $(WORKING_DIR)
+LOCAL_MODULE := libflacJNI
+LOCAL_ARM_MODE := arm
+LOCAL_CPP_EXTENSION := .cc
+
+LOCAL_C_INCLUDES := \
+    $(LOCAL_PATH)/flac/include \
+    $(LOCAL_PATH)/flac/src/libFLAC/include
+LOCAL_SRC_FILES := $(FLAC_SOURCES)
+
+LOCAL_CFLAGS += '-DVERSION="1.3.1"' -DFLAC__NO_MD5 -DFLAC__INTEGER_ONLY_LIBRARY -DFLAC__NO_ASM
+LOCAL_CFLAGS += -D_REENTRANT -DPIC -DU_COMMON_IMPLEMENTATION -fPIC
+LOCAL_CFLAGS += -O3 -funroll-loops -finline-functions
+
+LOCAL_LDLIBS := -llog -lz -lm
+include $(BUILD_SHARED_LIBRARY)
diff --git a/extensions/flac/src/main/jni/Application.mk b/extensions/flac/src/main/jni/Application.mk
new file mode 100644
index 0000000000..59bf5f8f87
--- /dev/null
+++ b/extensions/flac/src/main/jni/Application.mk
@@ -0,0 +1,20 @@
+#
+# Copyright (C) 2016 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+APP_OPTIM := release
+APP_STL := gnustl_static
+APP_CPPFLAGS := -frtti
+APP_PLATFORM := android-9
diff --git a/extensions/flac/src/main/jni/flac_jni.cc b/extensions/flac/src/main/jni/flac_jni.cc
new file mode 100644
index 0000000000..7fe1887971
--- /dev/null
+++ b/extensions/flac/src/main/jni/flac_jni.cc
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <jni.h>
+
+#include <android/log.h>
+
+#include <cstdlib>
+
+#include "include/flac_parser.h"
+
+#define LOG_TAG "FlacJniJNI"
+#define ALOGE(...) \
+  ((void)__android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__))
+#define ALOGV(...) \
+  ((void)__android_log_print(ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__))
+
+#define FUNC(RETURN_TYPE, NAME, ...)                                       \
+  extern "C" {                                                             \
+  JNIEXPORT RETURN_TYPE                                                    \
+      Java_com_google_android_exoplayer_ext_flac_FlacJni_##NAME( \
+          JNIEnv *env, jobject thiz, ##__VA_ARGS__);                       \
+  }                                                                        \
+  JNIEXPORT RETURN_TYPE                                                    \
+      Java_com_google_android_exoplayer_ext_flac_FlacJni_##NAME( \
+          JNIEnv *env, jobject thiz, ##__VA_ARGS__)
+
+class JavaDataSource : public DataSource {
+ public:
+  void setFlacJni(JNIEnv *env, jobject flacJni) {
+    this->env = env;
+    this->flacJni = flacJni;
+    if (mid == NULL) {
+      jclass cls = env->GetObjectClass(flacJni);
+      mid = env->GetMethodID(cls, "read", "(Ljava/nio/ByteBuffer;)I");
+      env->DeleteLocalRef(cls);
+    }
+  }
+
+  ssize_t readAt(off64_t offset, void *const data, size_t size) {
+    jobject byteBuffer = env->NewDirectByteBuffer(data, size);
+    int result = env->CallIntMethod(flacJni, mid, byteBuffer);
+    if (env->ExceptionOccurred()) {
+      result = -1;
+    }
+    env->DeleteLocalRef(byteBuffer);
+    return result;
+  }
+
+ private:
+  JNIEnv *env;
+  jobject flacJni;
+  jmethodID mid;
+};
+
+struct Context {
+  JavaDataSource *source;
+  FLACParser *parser;
+};
+
+FUNC(jlong, flacInit) {
+  Context *context = new Context;
+  context->source = new JavaDataSource();
+  context->parser = new FLACParser(context->source);
+  return reinterpret_cast<intptr_t>(context);
+}
+
+FUNC(jobject, flacDecodeMetadata, jlong jContext) {
+  Context *context = reinterpret_cast<Context *>(jContext);
+  context->source->setFlacJni(env, thiz);
+  if (!context->parser->init()) {
+    return NULL;
+  }
+
+  const FLAC__StreamMetadata_StreamInfo &streamInfo =
+      context->parser->getStreamInfo();
+
+  jclass cls = env->FindClass(
+      "com/google/android/exoplayer/ext/flac/"
+      "FlacStreamInfo");
+  jmethodID constructor = env->GetMethodID(cls, "<init>", "(IIIIIIIJ)V");
+
+  return env->NewObject(cls, constructor, streamInfo.min_blocksize,
+                        streamInfo.max_blocksize, streamInfo.min_framesize,
+                        streamInfo.max_framesize, streamInfo.sample_rate,
+                        streamInfo.channels, streamInfo.bits_per_sample,
+                        streamInfo.total_samples);
+}
+
+FUNC(jint, flacDecodeToBuffer, jlong jContext, jobject jOutputBuffer) {
+  Context *context = reinterpret_cast<Context *>(jContext);
+  context->source->setFlacJni(env, thiz);
+  void *outputBuffer = env->GetDirectBufferAddress(jOutputBuffer);
+  jint outputSize = env->GetDirectBufferCapacity(jOutputBuffer);
+  return context->parser->readBuffer(outputBuffer, outputSize);
+}
+
+FUNC(jint, flacDecodeToArray, jlong jContext, jbyteArray jOutputArray) {
+  Context *context = reinterpret_cast<Context *>(jContext);
+  context->source->setFlacJni(env, thiz);
+  jbyte *outputBuffer = env->GetByteArrayElements(jOutputArray, NULL);
+  jint outputSize = env->GetArrayLength(jOutputArray);
+  int count = context->parser->readBuffer(outputBuffer, outputSize);
+  env->ReleaseByteArrayElements(jOutputArray, outputBuffer, 0);
+  return count;
+}
+
+FUNC(jlong, flacGetLastTimestamp, jlong jContext) {
+  Context *context = reinterpret_cast<Context *>(jContext);
+  return context->parser->getLastTimestamp();
+}
+
+FUNC(jlong, flacGetSeekPosition, jlong jContext, jlong timeUs) {
+  Context *context = reinterpret_cast<Context *>(jContext);
+  return context->parser->getSeekPosition(timeUs);
+}
+
+FUNC(void, flacFlush, jlong jContext) {
+  Context *context = reinterpret_cast<Context *>(jContext);
+  context->parser->flush();
+}
+
+FUNC(void, flacRelease, jlong jContext) {
+  Context *context = reinterpret_cast<Context *>(jContext);
+  delete context->parser;
+  delete context->source;
+  delete context;
+}
diff --git a/extensions/flac/src/main/jni/flac_parser.cc b/extensions/flac/src/main/jni/flac_parser.cc
new file mode 100644
index 0000000000..b6658444cb
--- /dev/null
+++ b/extensions/flac/src/main/jni/flac_parser.cc
@@ -0,0 +1,456 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "include/flac_parser.h"
+
+#include <jni.h>
+
+#include <android/log.h>
+
+#include <cassert>
+#include <cstdlib>
+
+#define LOG_TAG "FLACParser"
+#define ALOGE(...) \
+  ((void)__android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__))
+#define ALOGV(...) \
+  ((void)__android_log_print(ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__))
+
+#define LOG_ALWAYS_FATAL(...) \
+  (__android_log_assert(NULL, LOG_TAG, ##__VA_ARGS__))
+
+#define LITERAL_TO_STRING_INTERNAL(x) #x
+#define LITERAL_TO_STRING(x) LITERAL_TO_STRING_INTERNAL(x)
+
+#define TRESPASS()          \
+  LOG_ALWAYS_FATAL(__FILE__ \
+                   ":" LITERAL_TO_STRING(__LINE__) " Should not be here.");
+#define CHECK(x) \
+  if (!(x)) ALOGE("Check failed: %s ", #x)
+
+// The FLAC parser calls our C++ static callbacks using C calling conventions,
+// inside FLAC__stream_decoder_process_until_end_of_metadata
+// and FLAC__stream_decoder_process_single.
+// We immediately then call our corresponding C++ instance methods
+// with the same parameter list, but discard redundant information.
+
+FLAC__StreamDecoderReadStatus FLACParser::read_callback(
+    const FLAC__StreamDecoder * /* decoder */, FLAC__byte buffer[],
+    size_t *bytes, void *client_data) {
+  return reinterpret_cast<FLACParser *>(client_data)
+      ->readCallback(buffer, bytes);
+}
+
+FLAC__StreamDecoderSeekStatus FLACParser::seek_callback(
+    const FLAC__StreamDecoder * /* decoder */,
+    FLAC__uint64 absolute_byte_offset, void *client_data) {
+  return reinterpret_cast<FLACParser *>(client_data)
+      ->seekCallback(absolute_byte_offset);
+}
+
+FLAC__StreamDecoderTellStatus FLACParser::tell_callback(
+    const FLAC__StreamDecoder * /* decoder */,
+    FLAC__uint64 *absolute_byte_offset, void *client_data) {
+  return reinterpret_cast<FLACParser *>(client_data)
+      ->tellCallback(absolute_byte_offset);
+}
+
+FLAC__StreamDecoderLengthStatus FLACParser::length_callback(
+    const FLAC__StreamDecoder * /* decoder */, FLAC__uint64 *stream_length,
+    void *client_data) {
+  return reinterpret_cast<FLACParser *>(client_data)
+      ->lengthCallback(stream_length);
+}
+
+FLAC__bool FLACParser::eof_callback(const FLAC__StreamDecoder * /* decoder */,
+                                    void *client_data) {
+  return reinterpret_cast<FLACParser *>(client_data)->eofCallback();
+}
+
+FLAC__StreamDecoderWriteStatus FLACParser::write_callback(
+    const FLAC__StreamDecoder * /* decoder */, const FLAC__Frame *frame,
+    const FLAC__int32 *const buffer[], void *client_data) {
+  return reinterpret_cast<FLACParser *>(client_data)
+      ->writeCallback(frame, buffer);
+}
+
+void FLACParser::metadata_callback(const FLAC__StreamDecoder * /* decoder */,
+                                   const FLAC__StreamMetadata *metadata,
+                                   void *client_data) {
+  reinterpret_cast<FLACParser *>(client_data)->metadataCallback(metadata);
+}
+
+void FLACParser::error_callback(const FLAC__StreamDecoder * /* decoder */,
+                                FLAC__StreamDecoderErrorStatus status,
+                                void *client_data) {
+  reinterpret_cast<FLACParser *>(client_data)->errorCallback(status);
+}
+
+// These are the corresponding callbacks with C++ calling conventions
+
+FLAC__StreamDecoderReadStatus FLACParser::readCallback(FLAC__byte buffer[],
+                                                       size_t *bytes) {
+  size_t requested = *bytes;
+  ssize_t actual = mDataSource->readAt(mCurrentPos, buffer, requested);
+  if (0 > actual) {
+    *bytes = 0;
+    return FLAC__STREAM_DECODER_READ_STATUS_ABORT;
+  } else if (0 == actual) {
+    *bytes = 0;
+    mEOF = true;
+    return FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;
+  } else {
+    assert(actual <= requested);
+    *bytes = actual;
+    mCurrentPos += actual;
+    return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;
+  }
+}
+
+FLAC__StreamDecoderSeekStatus FLACParser::seekCallback(
+    FLAC__uint64 absolute_byte_offset) {
+  mCurrentPos = absolute_byte_offset;
+  mEOF = false;
+  return FLAC__STREAM_DECODER_SEEK_STATUS_OK;
+}
+
+FLAC__StreamDecoderTellStatus FLACParser::tellCallback(
+    FLAC__uint64 *absolute_byte_offset) {
+  *absolute_byte_offset = mCurrentPos;
+  return FLAC__STREAM_DECODER_TELL_STATUS_OK;
+}
+
+FLAC__StreamDecoderLengthStatus FLACParser::lengthCallback(
+    FLAC__uint64 *stream_length) {
+  return FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED;
+}
+
+FLAC__bool FLACParser::eofCallback() { return mEOF; }
+
+FLAC__StreamDecoderWriteStatus FLACParser::writeCallback(
+    const FLAC__Frame *frame, const FLAC__int32 *const buffer[]) {
+  if (mWriteRequested) {
+    mWriteRequested = false;
+    // FLAC parser doesn't free or realloc buffer until next frame or finish
+    mWriteHeader = frame->header;
+    mWriteBuffer = buffer;
+    mWriteCompleted = true;
+    return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
+  } else {
+    ALOGE("FLACParser::writeCallback unexpected");
+    return FLAC__STREAM_DECODER_WRITE_STATUS_ABORT;
+  }
+}
+
+void FLACParser::metadataCallback(const FLAC__StreamMetadata *metadata) {
+  switch (metadata->type) {
+    case FLAC__METADATA_TYPE_STREAMINFO:
+      if (!mStreamInfoValid) {
+        mStreamInfo = metadata->data.stream_info;
+        mStreamInfoValid = true;
+      } else {
+        ALOGE("FLACParser::metadataCallback unexpected STREAMINFO");
+      }
+      break;
+    case FLAC__METADATA_TYPE_SEEKTABLE:
+      mSeekTable = &metadata->data.seek_table;
+      break;
+    default:
+      ALOGE("FLACParser::metadataCallback unexpected type %u", metadata->type);
+      break;
+  }
+}
+
+void FLACParser::errorCallback(FLAC__StreamDecoderErrorStatus status) {
+  ALOGE("FLACParser::errorCallback status=%d", status);
+  mErrorStatus = status;
+}
+
+// Copy samples from FLAC native 32-bit non-interleaved to 16-bit interleaved.
+// These are candidates for optimization if needed.
+
+static void copyMono8(int16_t *dst, const int *const *src, unsigned nSamples,
+                      unsigned /* nChannels */) {
+  for (unsigned i = 0; i < nSamples; ++i) {
+    *dst++ = src[0][i] << 8;
+  }
+}
+
+static void copyStereo8(int16_t *dst, const int *const *src, unsigned nSamples,
+                        unsigned /* nChannels */) {
+  for (unsigned i = 0; i < nSamples; ++i) {
+    *dst++ = src[0][i] << 8;
+    *dst++ = src[1][i] << 8;
+  }
+}
+
+static void copyMultiCh8(int16_t *dst, const int *const *src, unsigned nSamples,
+                         unsigned nChannels) {
+  for (unsigned i = 0; i < nSamples; ++i) {
+    for (unsigned c = 0; c < nChannels; ++c) {
+      *dst++ = src[c][i] << 8;
+    }
+  }
+}
+
+static void copyMono16(int16_t *dst, const int *const *src, unsigned nSamples,
+                       unsigned /* nChannels */) {
+  for (unsigned i = 0; i < nSamples; ++i) {
+    *dst++ = src[0][i];
+  }
+}
+
+static void copyStereo16(int16_t *dst, const int *const *src, unsigned nSamples,
+                         unsigned /* nChannels */) {
+  for (unsigned i = 0; i < nSamples; ++i) {
+    *dst++ = src[0][i];
+    *dst++ = src[1][i];
+  }
+}
+
+static void copyMultiCh16(int16_t *dst, const int *const *src,
+                          unsigned nSamples, unsigned nChannels) {
+  for (unsigned i = 0; i < nSamples; ++i) {
+    for (unsigned c = 0; c < nChannels; ++c) {
+      *dst++ = src[c][i];
+    }
+  }
+}
+
+// 24-bit versions should do dithering or noise-shaping, here or in AudioFlinger
+
+static void copyMono24(int16_t *dst, const int *const *src, unsigned nSamples,
+                       unsigned /* nChannels */) {
+  for (unsigned i = 0; i < nSamples; ++i) {
+    *dst++ = src[0][i] >> 8;
+  }
+}
+
+static void copyStereo24(int16_t *dst, const int *const *src, unsigned nSamples,
+                         unsigned /* nChannels */) {
+  for (unsigned i = 0; i < nSamples; ++i) {
+    *dst++ = src[0][i] >> 8;
+    *dst++ = src[1][i] >> 8;
+  }
+}
+
+static void copyMultiCh24(int16_t *dst, const int *const *src,
+                          unsigned nSamples, unsigned nChannels) {
+  for (unsigned i = 0; i < nSamples; ++i) {
+    for (unsigned c = 0; c < nChannels; ++c) {
+      *dst++ = src[c][i] >> 8;
+    }
+  }
+}
+
+static void copyTrespass(int16_t * /* dst */, const int *const * /* src */,
+                         unsigned /* nSamples */, unsigned /* nChannels */) {
+  TRESPASS();
+}
+
+// FLACParser
+
+FLACParser::FLACParser(DataSource *source)
+    : mDataSource(source),
+      mCopy(copyTrespass),
+      mDecoder(NULL),
+      mCurrentPos(0LL),
+      mEOF(false),
+      mStreamInfoValid(false),
+      mWriteRequested(false),
+      mWriteCompleted(false),
+      mWriteBuffer(NULL),
+      mErrorStatus((FLAC__StreamDecoderErrorStatus)-1) {
+  ALOGV("FLACParser::FLACParser");
+  memset(&mStreamInfo, 0, sizeof(mStreamInfo));
+  memset(&mWriteHeader, 0, sizeof(mWriteHeader));
+}
+
+FLACParser::~FLACParser() {
+  ALOGV("FLACParser::~FLACParser");
+  if (mDecoder != NULL) {
+    FLAC__stream_decoder_delete(mDecoder);
+    mDecoder = NULL;
+  }
+}
+
+bool FLACParser::init() {
+  // setup libFLAC parser
+  mDecoder = FLAC__stream_decoder_new();
+  if (mDecoder == NULL) {
+    // The new should succeed, since probably all it does is a malloc
+    // that always succeeds in Android.  But to avoid dependence on the
+    // libFLAC internals, we check and log here.
+    ALOGE("new failed");
+    return false;
+  }
+  FLAC__stream_decoder_set_md5_checking(mDecoder, false);
+  FLAC__stream_decoder_set_metadata_ignore_all(mDecoder);
+  FLAC__stream_decoder_set_metadata_respond(mDecoder,
+                                            FLAC__METADATA_TYPE_STREAMINFO);
+  FLAC__stream_decoder_set_metadata_respond(mDecoder,
+                                            FLAC__METADATA_TYPE_SEEKTABLE);
+  FLAC__StreamDecoderInitStatus initStatus;
+  initStatus = FLAC__stream_decoder_init_stream(
+      mDecoder, read_callback, seek_callback, tell_callback, length_callback,
+      eof_callback, write_callback, metadata_callback, error_callback,
+      reinterpret_cast<void *>(this));
+  if (initStatus != FLAC__STREAM_DECODER_INIT_STATUS_OK) {
+    // A failure here probably indicates a programming error and so is
+    // unlikely to happen. But we check and log here similarly to above.
+    ALOGE("init_stream failed %d", initStatus);
+    return false;
+  }
+  // parse all metadata
+  if (!FLAC__stream_decoder_process_until_end_of_metadata(mDecoder)) {
+    ALOGE("end_of_metadata failed");
+    return false;
+  }
+  // store first frame offset
+  FLAC__stream_decoder_get_decode_position(mDecoder, &firstFrameOffset);
+
+  if (mStreamInfoValid) {
+    // check channel count
+    if (getChannels() == 0 || getChannels() > 8) {
+      ALOGE("unsupported channel count %u", getChannels());
+      return false;
+    }
+    // check bit depth
+    switch (getBitsPerSample()) {
+      case 8:
+      case 16:
+      case 24:
+        break;
+      default:
+        ALOGE("unsupported bits per sample %u", getBitsPerSample());
+        return false;
+    }
+    // check sample rate
+    switch (getSampleRate()) {
+      case 8000:
+      case 11025:
+      case 12000:
+      case 16000:
+      case 22050:
+      case 24000:
+      case 32000:
+      case 44100:
+      case 48000:
+      case 88200:
+      case 96000:
+        break;
+      default:
+        ALOGE("unsupported sample rate %u", getSampleRate());
+        return false;
+    }
+    // configure the appropriate copy function, defaulting to trespass
+    static const struct {
+      unsigned mChannels;
+      unsigned mBitsPerSample;
+      void (*mCopy)(int16_t *dst, const int *const *src, unsigned nSamples,
+                    unsigned nChannels);
+    } table[] = {
+        {1, 8, copyMono8},   {2, 8, copyStereo8},   {8, 8, copyMultiCh8},
+        {1, 16, copyMono16}, {2, 16, copyStereo16}, {8, 16, copyMultiCh16},
+        {1, 24, copyMono24}, {2, 24, copyStereo24}, {8, 24, copyMultiCh24},
+    };
+    for (unsigned i = 0; i < sizeof(table) / sizeof(table[0]); ++i) {
+      if (table[i].mChannels >= getChannels() &&
+          table[i].mBitsPerSample == getBitsPerSample()) {
+        mCopy = table[i].mCopy;
+        break;
+      }
+    }
+  } else {
+    ALOGE("missing STREAMINFO");
+    return false;
+  }
+  return true;
+}
+
+size_t FLACParser::readBuffer(void *output, size_t output_size) {
+  mWriteRequested = true;
+  mWriteCompleted = false;
+
+  if (!FLAC__stream_decoder_process_single(mDecoder)) {
+    ALOGE("FLACParser::readBuffer process_single failed. Status: %s",
+            FLAC__stream_decoder_get_resolved_state_string(mDecoder));
+    return -1;
+  }
+  if (!mWriteCompleted) {
+    if (FLAC__stream_decoder_get_state(mDecoder) !=
+        FLAC__STREAM_DECODER_END_OF_STREAM) {
+      ALOGE("FLACParser::readBuffer write did not complete. Status: %s",
+            FLAC__stream_decoder_get_resolved_state_string(mDecoder));
+    }
+    return -1;
+  }
+
+  // verify that block header keeps the promises made by STREAMINFO
+  unsigned blocksize = mWriteHeader.blocksize;
+  if (blocksize == 0 || blocksize > getMaxBlockSize()) {
+    ALOGE("FLACParser::readBuffer write invalid blocksize %u", blocksize);
+    return -1;
+  }
+  if (mWriteHeader.sample_rate != getSampleRate() ||
+      mWriteHeader.channels != getChannels() ||
+      mWriteHeader.bits_per_sample != getBitsPerSample()) {
+    ALOGE(
+        "FLACParser::readBuffer write changed parameters mid-stream: %d/%d/%d "
+        "-> %d/%d/%d",
+        getSampleRate(), getChannels(), getBitsPerSample(),
+        mWriteHeader.sample_rate, mWriteHeader.channels,
+        mWriteHeader.bits_per_sample);
+    return -1;
+  }
+
+  size_t bufferSize = blocksize * getChannels() * sizeof(int16_t);
+  if (bufferSize > output_size) {
+    ALOGE(
+        "FLACParser::readBuffer not enough space in output buffer "
+        "%zu < %zu",
+        output_size, bufferSize);
+    return -1;
+  }
+
+  // copy PCM from FLAC write buffer to our media buffer, with interleaving.
+  (*mCopy)(reinterpret_cast<int16_t *>(output), mWriteBuffer, blocksize,
+           getChannels());
+
+  // fill in buffer metadata
+  CHECK(mWriteHeader.number_type == FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER);
+
+  return bufferSize;
+}
+
+int64_t FLACParser::getSeekPosition(int64_t timeUs) {
+  if (!mSeekTable) {
+    return -1;
+  }
+
+  int64_t sample = (timeUs * getSampleRate()) / 1000000LL;
+  if (sample >= getTotalSamples()) {
+      sample = getTotalSamples();
+  }
+
+  FLAC__StreamMetadata_SeekPoint* points = mSeekTable->points;
+  for (unsigned i = mSeekTable->num_points - 1; i >= 0; i--) {
+    if (points[i].sample_number <= sample) {
+      return firstFrameOffset + points[i].stream_offset;
+    }
+  }
+  return firstFrameOffset;
+}
diff --git a/extensions/flac/src/main/jni/flac_sources.mk b/extensions/flac/src/main/jni/flac_sources.mk
new file mode 100644
index 0000000000..ade9daa359
--- /dev/null
+++ b/extensions/flac/src/main/jni/flac_sources.mk
@@ -0,0 +1,45 @@
+#
+# Copyright (C) 2016 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+FLAC_SOURCES = \
+  flac_jni.cc                                    \
+  flac_parser.cc                                 \
+  flac/src/libFLAC/bitmath.c                     \
+  flac/src/libFLAC/bitreader.c                   \
+  flac/src/libFLAC/bitwriter.c                   \
+  flac/src/libFLAC/cpu.c                         \
+  flac/src/libFLAC/crc.c                         \
+  flac/src/libFLAC/fixed.c                       \
+  flac/src/libFLAC/fixed_intrin_sse2.c           \
+  flac/src/libFLAC/fixed_intrin_ssse3.c          \
+  flac/src/libFLAC/float.c                       \
+  flac/src/libFLAC/format.c                      \
+  flac/src/libFLAC/lpc.c                         \
+  flac/src/libFLAC/lpc_intrin_avx2.c             \
+  flac/src/libFLAC/lpc_intrin_sse2.c             \
+  flac/src/libFLAC/lpc_intrin_sse41.c            \
+  flac/src/libFLAC/lpc_intrin_sse.c              \
+  flac/src/libFLAC/md5.c                         \
+  flac/src/libFLAC/memory.c                      \
+  flac/src/libFLAC/metadata_iterators.c          \
+  flac/src/libFLAC/metadata_object.c             \
+  flac/src/libFLAC/stream_decoder.c              \
+  flac/src/libFLAC/stream_encoder.c              \
+  flac/src/libFLAC/stream_encoder_framing.c      \
+  flac/src/libFLAC/stream_encoder_intrin_avx2.c  \
+  flac/src/libFLAC/stream_encoder_intrin_sse2.c  \
+  flac/src/libFLAC/stream_encoder_intrin_ssse3.c \
+  flac/src/libFLAC/window.c
diff --git a/extensions/flac/src/main/jni/include/data_source.h b/extensions/flac/src/main/jni/include/data_source.h
new file mode 100644
index 0000000000..175431dd7a
--- /dev/null
+++ b/extensions/flac/src/main/jni/include/data_source.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef INCLUDE_DATA_SOURCE_H_
+#define INCLUDE_DATA_SOURCE_H_
+
+#include <jni.h>
+#include <sys/types.h>
+
+class DataSource {
+ public:
+  // Returns the number of bytes read, or -1 on failure. It's not an error if
+  // this returns zero; it just means the given offset is equal to, or
+  // beyond, the end of the source.
+  virtual ssize_t readAt(off64_t offset, void* const data, size_t size) = 0;
+};
+
+#endif  // INCLUDE_DATA_SOURCE_H_
diff --git a/extensions/flac/src/main/jni/include/flac_parser.h b/extensions/flac/src/main/jni/include/flac_parser.h
new file mode 100644
index 0000000000..22c17f7cff
--- /dev/null
+++ b/extensions/flac/src/main/jni/include/flac_parser.h
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FLAC_PARSER_H_
+#define FLAC_PARSER_H_
+
+#include <stdint.h>
+
+// libFLAC parser
+#include "FLAC/stream_decoder.h"
+
+#include "include/data_source.h"
+
+typedef int status_t;
+
+class FLACParser {
+ public:
+  FLACParser(DataSource *source);
+  ~FLACParser();
+
+  bool init();
+
+  // stream properties
+  unsigned getMaxBlockSize() const { return mStreamInfo.max_blocksize; }
+  unsigned getSampleRate() const { return mStreamInfo.sample_rate; }
+  unsigned getChannels() const { return mStreamInfo.channels; }
+  unsigned getBitsPerSample() const { return mStreamInfo.bits_per_sample; }
+  FLAC__uint64 getTotalSamples() const { return mStreamInfo.total_samples; }
+
+  const FLAC__StreamMetadata_StreamInfo& getStreamInfo() const {
+    return mStreamInfo;
+  }
+
+  int64_t getLastTimestamp() const {
+    return (1000000LL * mWriteHeader.number.sample_number) / getSampleRate();
+  }
+
+  size_t readBuffer(void *output, size_t output_size);
+
+  int64_t getSeekPosition(int64_t timeUs);
+
+  void flush() {
+    if (mDecoder != NULL) {
+      FLAC__stream_decoder_flush(mDecoder);
+    }
+  }
+
+ private:
+  DataSource *mDataSource;
+
+  void (*mCopy)(int16_t *dst, const int *const *src, unsigned nSamples,
+                unsigned nChannels);
+
+  // handle to underlying libFLAC parser
+  FLAC__StreamDecoder *mDecoder;
+
+  // current position within the data source
+  off64_t mCurrentPos;
+  bool mEOF;
+
+  // cached when the STREAMINFO metadata is parsed by libFLAC
+  FLAC__StreamMetadata_StreamInfo mStreamInfo;
+  bool mStreamInfoValid;
+
+  const FLAC__StreamMetadata_SeekTable *mSeekTable;
+  uint64_t firstFrameOffset;
+
+  // cached when a decoded PCM block is "written" by libFLAC parser
+  bool mWriteRequested;
+  bool mWriteCompleted;
+  FLAC__FrameHeader mWriteHeader;
+  const FLAC__int32 *const *mWriteBuffer;
+
+  // most recent error reported by libFLAC parser
+  FLAC__StreamDecoderErrorStatus mErrorStatus;
+
+  // no copy constructor or assignment
+  FLACParser(const FLACParser &);
+  FLACParser &operator=(const FLACParser &);
+
+  // FLAC parser callbacks as C++ instance methods
+  FLAC__StreamDecoderReadStatus readCallback(FLAC__byte buffer[],
+                                             size_t *bytes);
+  FLAC__StreamDecoderSeekStatus seekCallback(FLAC__uint64 absolute_byte_offset);
+  FLAC__StreamDecoderTellStatus tellCallback(
+      FLAC__uint64 *absolute_byte_offset);
+  FLAC__StreamDecoderLengthStatus lengthCallback(FLAC__uint64 *stream_length);
+  FLAC__bool eofCallback();
+  FLAC__StreamDecoderWriteStatus writeCallback(
+      const FLAC__Frame *frame, const FLAC__int32 *const buffer[]);
+  void metadataCallback(const FLAC__StreamMetadata *metadata);
+  void errorCallback(FLAC__StreamDecoderErrorStatus status);
+
+  // FLAC parser callbacks as C-callable functions
+  static FLAC__StreamDecoderReadStatus read_callback(
+      const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes,
+      void *client_data);
+  static FLAC__StreamDecoderSeekStatus seek_callback(
+      const FLAC__StreamDecoder *decoder, FLAC__uint64 absolute_byte_offset,
+      void *client_data);
+  static FLAC__StreamDecoderTellStatus tell_callback(
+      const FLAC__StreamDecoder *decoder, FLAC__uint64 *absolute_byte_offset,
+      void *client_data);
+  static FLAC__StreamDecoderLengthStatus length_callback(
+      const FLAC__StreamDecoder *decoder, FLAC__uint64 *stream_length,
+      void *client_data);
+  static FLAC__bool eof_callback(const FLAC__StreamDecoder *decoder,
+                                 void *client_data);
+  static FLAC__StreamDecoderWriteStatus write_callback(
+      const FLAC__StreamDecoder *decoder, const FLAC__Frame *frame,
+      const FLAC__int32 *const buffer[], void *client_data);
+  static void metadata_callback(const FLAC__StreamDecoder *decoder,
+                                const FLAC__StreamMetadata *metadata,
+                                void *client_data);
+  static void error_callback(const FLAC__StreamDecoder *decoder,
+                             FLAC__StreamDecoderErrorStatus status,
+                             void *client_data);
+};
+
+#endif  // FLAC_PARSER_H_
diff --git a/extensions/flac/src/main/proguard.cfg b/extensions/flac/src/main/proguard.cfg
new file mode 100644
index 0000000000..d951cd9496
--- /dev/null
+++ b/extensions/flac/src/main/proguard.cfg
@@ -0,0 +1,11 @@
+# Proguard rules specific to the Flac extension.
+
+# This prevents the names of native methods from being obfuscated.
+-keepclasseswithmembernames class * {
+    native <methods>;
+}
+
+# Some members of this class are being accessed from native methods. Keep them unobfuscated.
+-keep class com.google.android.exoplayer.ext.flac.FlacJni {
+    *;
+}
diff --git a/demo_misc/vp9_opus_sw/src/main/project.properties b/extensions/flac/src/main/project.properties
similarity index 82%
rename from demo_misc/vp9_opus_sw/src/main/project.properties
rename to extensions/flac/src/main/project.properties
index f85c9b372d..b92a03b7ab 100644
--- a/demo_misc/vp9_opus_sw/src/main/project.properties
+++ b/extensions/flac/src/main/project.properties
@@ -12,6 +12,5 @@
 
 # Project target.
 target=android-23
+android.library=true
 android.library.reference.1=../../../../library/src/main
-android.library.reference.2=../../../../extensions/opus/src/main
-android.library.reference.3=../../../../extensions/vp9/src/main
diff --git a/extensions/okhttp/README.md b/extensions/okhttp/README.md
index 688bf8e08a..cf04ac106e 100644
--- a/extensions/okhttp/README.md
+++ b/extensions/okhttp/README.md
@@ -2,8 +2,8 @@
 
 ## Description ##
 
-The OkHttp Extension is an [HttpDataSource][] implementation using Square's [OkHttp][].
+The OkHttp Extension is an [HttpDataSource][] implementation using Square's
+[OkHttp][].
 
 [HttpDataSource]: https://google.github.io/ExoPlayer/doc/reference/com/google/android/exoplayer/upstream/HttpDataSource.html
 [OkHttp]: https://square.github.io/okhttp/
-
diff --git a/extensions/okhttp/src/main/.project b/extensions/okhttp/src/main/.project
index b36efd2579..c431b89f66 100644
--- a/extensions/okhttp/src/main/.project
+++ b/extensions/okhttp/src/main/.project
@@ -30,4 +30,16 @@
 		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
 		<nature>org.eclipse.jdt.core.javanature</nature>
 	</natures>
+	<linkedResources>
+		<link>
+			<name>libs/okhttp-3.2.0.jar</name>
+			<type>1</type>
+			<locationURI>$%7BPARENT-4-PROJECT_LOC%7D/third_party/okhttp3/okhttp-3.2.0.jar</locationURI>
+		</link>
+		<link>
+			<name>libs/okio-1.6.0.jar</name>
+			<type>1</type>
+			<locationURI>$%7BPARENT-4-PROJECT_LOC%7D/third_party/okio/okio-1.6.0.jar</locationURI>
+		</link>
+	</linkedResources>
 </projectDescription>
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer/ext/okhttp/OkHttpDataSource.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer/ext/okhttp/OkHttpDataSource.java
index 6163655a63..9e69804c7a 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer/ext/okhttp/OkHttpDataSource.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer/ext/okhttp/OkHttpDataSource.java
@@ -24,6 +24,7 @@
 
 import okhttp3.CacheControl;
 import okhttp3.HttpUrl;
+import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.RequestBody;
@@ -171,7 +172,8 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     }
 
     // Check for a valid content type.
-    String contentType = response.body().contentType().toString();
+    MediaType mediaType = response.body().contentType();
+    String contentType = mediaType != null ? mediaType.toString() : null;
     if (contentTypePredicate != null && !contentTypePredicate.evaluate(contentType)) {
       closeConnectionQuietly();
       throw new InvalidContentTypeException(contentType, dataSpec);
diff --git a/extensions/opus/README.md b/extensions/opus/README.md
index 46bb6942e6..8b1409c423 100644
--- a/extensions/opus/README.md
+++ b/extensions/opus/README.md
@@ -2,15 +2,15 @@
 
 ## Description ##
 
-The Opus Extension is a [TrackRenderer][] implementation that helps you bundle libopus (the Opus decoding library) into your app and use it along with ExoPlayer to play Opus audio on Android devices.
+The Opus Extension is a [TrackRenderer][] implementation that helps you bundle
+libopus (the Opus decoding library) into your app and use it along with
+ExoPlayer to play Opus audio on Android devices.
 
 [TrackRenderer]: https://google.github.io/ExoPlayer/doc/reference/com/google/android/exoplayer/TrackRenderer.html
 
-## Build Instructions (Android Studio and Eclipse) ##
+## Build Instructions ##
 
-Building the Opus Extension involves building libopus and JNI bindings using the Android NDK and linking it into your app. The following steps will tell you how to do that using Android Studio or Eclipse.
-
-* Checkout ExoPlayer along with Extensions
+* Checkout ExoPlayer along with Extensions:
 
 ```
 git clone https://github.com/google/ExoPlayer.git
@@ -30,102 +30,48 @@ OPUS_EXT_PATH="${EXOPLAYER_ROOT}/extensions/opus/src/main"
 NDK_PATH="<path to Android NDK>"
 ```
 
-* Fetch libopus
+* Fetch libopus:
 
 ```
 cd "${OPUS_EXT_PATH}/jni" && \
 git clone git://git.opus-codec.org/opus.git libopus
 ```
 
-* Run the script to convert arm assembly to NDK compatible format
+* Run the script to convert arm assembly to NDK compatible format:
 
 ```
 cd ${OPUS_EXT_PATH}/jni && ./convert_android_asm.sh
 ```
 
-### Android Studio ###
-
-For Android Studio, we build the native libraries from the command line and then Gradle will pick it up when building your app using Android Studio.
-
-* Build the JNI native libraries
+* Build the JNI native libraries from the command line:
 
 ```
 cd "${OPUS_EXT_PATH}"/jni && \
 ${NDK_PATH}/ndk-build APP_ABI=all -j4
 ```
 
-* In your project, you can add a dependency to the Opus Extension by using a rule like this:
+* In your project, you can add a dependency to the Opus Extension by using a
+rule like this:
 
 ```
 // in settings.gradle
 include ':..:ExoPlayer:library'
-include ':..:ExoPlayer:opus-extension'
+include ':..:ExoPlayer:extension-opus'
 
 // in build.gradle
 dependencies {
     compile project(':..:ExoPlayer:library')
-    compile project(':..:ExoPlayer:opus-extension')
+    compile project(':..:ExoPlayer:extension-opus')
 }
 ```
 
-* Now, when you build your app, the Opus extension will be built and the native libraries will be packaged along with the APK.
-
-### Eclipse ###
-
-* The following steps assume that you have installed Eclipse and configured it with the [Android SDK][] and [Android NDK ][]:
-  * Navigate to File->Import->General->Existing Projects into Workspace
-  * Select the root directory of the repository
-  * Import the following projects:
-    * ExoPlayerLib
-    * ExoPlayerExt-Opus
-    * If you are able to build ExoPlayerExt-Opus project, then you're all set.
-    * (Optional) To speed up the NDK build:
-      * Right click on ExoPlayerExt-Opus in the Project Explorer pane and choose Properties
-      * Click on C/C++ Build
-      * Uncheck `Use default build command`
-      * In `Build Command` enter: `ndk-build -j4` (adjust 4 to a reasonable number depending on the number of cores in your computer)
-      * Click Apply
-
-You can now create your own Android App project and add ExoPlayerLib along with ExoPlayerExt-Opus as a dependencies to use ExoPlayer along with the Opus Extension.
-
-
-[Android NDK]: https://developer.android.com/tools/sdk/ndk/index.html
-<!---
-Work around to point to two different links for the same text.
--->
-[Android NDK ]: http://tools.android.com/recent/usingthendkplugin
-[Android SDK]: http://developer.android.com/sdk/installing/index.html?pkg=tools
-
-## Building for various Architectures ##
-
-### Android Studio ###
-
-The manual invocation of `ndk-build` will build the library for all architectures and the correct one will be picked up from the APK based on the device its running on.
-
-### Eclipse  ###
-
-libopus can be built for the following architectures:
-
-* armeabi (the default - does not include neon optimizations)
-* armeabi-v7a (choose this to enable neon optimizations)
-* mips
-* x86
-* all (will result in a larger binary but will cover all architectures)
-
-You can build for a specific architecture in two ways:
-
-* Method 1 (edit `Application.mk`)
-  * Edit `${OPUS_EXT_PATH}/jni/Application.mk` and add the following line `APP_ABI := <arch>` (where `<arch>` is one of the above 4 architectures)
-* Method 2 (pass NDK build flag)
-  * Right click on ExoPlayerExt-Opus in the Project Explorer pane and choose Properties
-  * Click on C/C++ Build
-  * Uncheck `Use default build command`
-  * In `Build Command` enter: `ndk-build APP_ABI=<arch>` (where `<arch>` is one of the above 4 architectures)
-  * Click Apply
+* Now, when you build your app, the Opus extension will be built and the native
+  libraries will be packaged along with the APK.
 
-## Other Things to Note ##
+## Notes ##
 
 * Every time there is a change to the libopus checkout:
   * Arm assembly should be converted by running `convert_android_asm.sh`
   * Clean and re-build the project.
-* If you want to use your own version of libopus, place it in `${OPUS_EXT_PATH}/jni/libopus`.
+* If you want to use your own version of libopus, place it in
+  `${OPUS_EXT_PATH}/jni/libopus`.
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
index ace9a1f05c..ae337d1960 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
@@ -25,14 +25,12 @@
 import com.google.android.exoplayer.SampleSourceTrackRenderer;
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.audio.AudioTrack;
-import com.google.android.exoplayer.ext.opus.OpusDecoderWrapper.InputBuffer;
-import com.google.android.exoplayer.ext.opus.OpusDecoderWrapper.OutputBuffer;
 import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.extensions.Buffer;
+import com.google.android.exoplayer.util.extensions.InputBuffer;
 
 import android.os.Handler;
 
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
 import java.util.List;
 
 /**
@@ -76,16 +74,20 @@
    */
   public static final int MSG_SET_VOLUME = 1;
 
+  private static final int NUM_BUFFERS = 16;
+  private static final int INITIAL_INPUT_BUFFER_SIZE = 960 * 6;
+
   public final CodecCounters codecCounters = new CodecCounters();
 
   private final Handler eventHandler;
   private final EventListener eventListener;
+  private final AudioTrack audioTrack;
   private final MediaFormatHolder formatHolder;
 
   private MediaFormat format;
-  private OpusDecoderWrapper decoder;
+  private OpusDecoder decoder;
   private InputBuffer inputBuffer;
-  private OutputBuffer outputBuffer;
+  private OpusOutputBuffer outputBuffer;
 
   private long currentPositionUs;
   private boolean allowPositionDiscontinuity;
@@ -94,7 +96,6 @@
   private boolean sourceIsReady;
   private boolean notifyDiscontinuityToDecoder;
 
-  private AudioTrack audioTrack;
   private int audioSessionId;
 
   /**
@@ -116,7 +117,7 @@ public LibopusAudioTrackRenderer(SampleSource source, Handler eventHandler,
     this.eventHandler = eventHandler;
     this.eventListener = eventListener;
     this.audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
-    this.audioTrack = new AudioTrack();
+    audioTrack = new AudioTrack();
     formatHolder = new MediaFormatHolder();
   }
 
@@ -124,7 +125,7 @@ public LibopusAudioTrackRenderer(SampleSource source, Handler eventHandler,
    * Returns whether the underlying libopus library is available.
    */
   public static boolean isLibopusAvailable() {
-    return OpusDecoder.isLibopusAvailable();
+    return OpusDecoder.IS_AVAILABLE;
   }
 
   /**
@@ -169,19 +170,9 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs, boolean sourc
       if (initializationData.size() < 1) {
         throw new ExoPlaybackException("Missing initialization data");
       }
-      long codecDelayNs = -1;
-      long seekPreRollNs = -1;
-      if (initializationData.size() == 3) {
-        if (initializationData.get(1).length != 8 || initializationData.get(2).length != 8) {
-          throw new ExoPlaybackException("Invalid Codec Delay or Seek Preroll");
-        }
-        codecDelayNs =
-            ByteBuffer.wrap(initializationData.get(1)).order(ByteOrder.LITTLE_ENDIAN).getLong();
-        seekPreRollNs =
-            ByteBuffer.wrap(initializationData.get(2)).order(ByteOrder.LITTLE_ENDIAN).getLong();
-      }
       try {
-        decoder = new OpusDecoderWrapper(initializationData.get(0), codecDelayNs, seekPreRollNs);
+        decoder = new OpusDecoder(NUM_BUFFERS, NUM_BUFFERS, INITIAL_INPUT_BUFFER_SIZE,
+            initializationData);
       } catch (OpusDecoderException e) {
         notifyDecoderError(e);
         throw new ExoPlaybackException(e);
@@ -220,10 +211,10 @@ private void renderBuffer() throws OpusDecoderException, AudioTrack.Initializati
       }
     }
 
-    if (outputBuffer.getFlag(OpusDecoderWrapper.FLAG_END_OF_STREAM)) {
+    if (outputBuffer.getFlag(Buffer.FLAG_END_OF_STREAM)) {
       outputStreamEnded = true;
       audioTrack.handleEndOfStream();
-      decoder.releaseOutputBuffer(outputBuffer);
+      outputBuffer.release();
       outputBuffer = null;
       return;
     }
@@ -240,8 +231,8 @@ private void renderBuffer() throws OpusDecoderException, AudioTrack.Initializati
     }
 
     int handleBufferResult;
-    handleBufferResult = audioTrack.handleBuffer(outputBuffer.data,
-        outputBuffer.data.position(), outputBuffer.size, outputBuffer.timestampUs);
+    handleBufferResult = audioTrack.handleBuffer(outputBuffer.data, outputBuffer.data.position(),
+        outputBuffer.data.remaining(), outputBuffer.timestampUs);
 
     // If we are out of sync, allow currentPositionUs to jump backwards.
     if ((handleBufferResult & AudioTrack.RESULT_POSITION_DISCONTINUITY) != 0) {
@@ -250,8 +241,8 @@ private void renderBuffer() throws OpusDecoderException, AudioTrack.Initializati
 
     // Release the buffer if it was consumed.
     if ((handleBufferResult & AudioTrack.RESULT_BUFFER_CONSUMED) != 0) {
-      decoder.releaseOutputBuffer(outputBuffer);
       codecCounters.renderedOutputBufferCount++;
+      outputBuffer.release();
       outputBuffer = null;
     }
   }
@@ -277,7 +268,7 @@ private boolean feedInputBuffer(long positionUs) throws OpusDecoderException {
       return true;
     }
     if (result == SampleSource.END_OF_STREAM) {
-      inputBuffer.setFlag(OpusDecoderWrapper.FLAG_END_OF_STREAM);
+      inputBuffer.setFlag(Buffer.FLAG_END_OF_STREAM);
       decoder.queueInputBuffer(inputBuffer);
       inputBuffer = null;
       inputStreamEnded = true;
@@ -285,7 +276,7 @@ private boolean feedInputBuffer(long positionUs) throws OpusDecoderException {
     }
     if (notifyDiscontinuityToDecoder) {
       notifyDiscontinuityToDecoder = false;
-      inputBuffer.setFlag(OpusDecoderWrapper.FLAG_RESET_DECODER);
+      inputBuffer.setFlag(Buffer.FLAG_RESET);
     }
 
     decoder.queueInputBuffer(inputBuffer);
@@ -295,7 +286,10 @@ private boolean feedInputBuffer(long positionUs) throws OpusDecoderException {
 
   private void flushDecoder() {
     inputBuffer = null;
-    outputBuffer = null;
+    if (outputBuffer != null) {
+      outputBuffer.release();
+      outputBuffer = null;
+    }
     decoder.flush();
     notifyDiscontinuityToDecoder = true;
   }
@@ -384,7 +378,7 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
 
   private void notifyAudioTrackInitializationError(final AudioTrack.InitializationException e) {
     if (eventHandler != null && eventListener != null) {
-      eventHandler.post(new Runnable()  {
+      eventHandler.post(new Runnable() {
         @Override
         public void run() {
           eventListener.onAudioTrackInitializationError(e);
@@ -395,7 +389,7 @@ public void run() {
 
   private void notifyAudioTrackWriteError(final AudioTrack.WriteException e) {
     if (eventHandler != null && eventListener != null) {
-      eventHandler.post(new Runnable()  {
+      eventHandler.post(new Runnable() {
         @Override
         public void run() {
           eventListener.onAudioTrackWriteError(e);
@@ -406,7 +400,7 @@ public void run() {
 
   private void notifyDecoderError(final OpusDecoderException e) {
     if (eventHandler != null && eventListener != null) {
-      eventHandler.post(new Runnable()  {
+      eventHandler.post(new Runnable() {
         @Override
         public void run() {
           eventListener.onDecoderError(e);
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java
index d63da51700..9ad75f9e62 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java
@@ -15,16 +15,25 @@
  */
 package com.google.android.exoplayer.ext.opus;
 
-import com.google.android.exoplayer.ext.opus.OpusDecoderWrapper.OpusHeader;
+import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.util.extensions.Buffer;
+import com.google.android.exoplayer.util.extensions.InputBuffer;
+import com.google.android.exoplayer.util.extensions.SimpleDecoder;
 
 import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.List;
 
 /**
- * JNI Wrapper for the libopus Opus decoder.
+ * JNI wrapper for the libopus Opus decoder.
  */
-/* package */ class OpusDecoder {
+/* package */ final class OpusDecoder extends
+    SimpleDecoder<InputBuffer, OpusOutputBuffer, OpusDecoderException> {
 
-  private static final boolean IS_AVAILABLE;
+  /**
+   * Whether the underlying libopus library is available.
+   */
+  public static final boolean IS_AVAILABLE;
   static {
     boolean isAvailable;
     try {
@@ -37,74 +46,173 @@
     IS_AVAILABLE = isAvailable;
   }
 
+  /**
+   * Returns the version string of the underlying libopus decoder.
+   */
+  public static native String getLibopusVersion();
+
+  private static final int DEFAULT_SEEK_PRE_ROLL_SAMPLES = 3840;
+
+  /**
+   * Opus streams are always decoded at 48000 Hz.
+   */
+  private static final int SAMPLE_RATE = 48000;
+
+  private final int channelCount;
+  private final int headerSkipSamples;
+  private final int headerSeekPreRollSamples;
   private final long nativeDecoderContext;
 
+  private int skipSamples;
+
   /**
-   * Creates the Opus Decoder.
+   * Creates an Opus decoder.
    *
-   * @param opusHeader OpusHeader used to initialize the decoder.
-   * @throws OpusDecoderException if the decoder initialization fails.
+   * @param numInputBuffers The number of input buffers.
+   * @param numOutputBuffers The number of output buffers.
+   * @param initialInputBufferSize The initial size of each input buffer.
+   * @param initializationData Codec-specific initialization data. The first element must contain an
+   *     opus header. Optionally, the list may contain two additional buffers, which must contain
+   *     the encoder delay and seek pre roll values in nanoseconds, encoded as longs.
+   * @throws OpusDecoderException Thrown if an exception occurs when initializing the decoder.
    */
-  public OpusDecoder(OpusHeader opusHeader) throws OpusDecoderException {
-    nativeDecoderContext = opusInit(
-        opusHeader.sampleRate, opusHeader.channelCount, opusHeader.numStreams,
-        opusHeader.numCoupled, opusHeader.gain, opusHeader.streamMap);
+  public OpusDecoder(int numInputBuffers, int numOutputBuffers, int initialInputBufferSize,
+      List<byte[]> initializationData) throws OpusDecoderException {
+    super(new InputBuffer[numInputBuffers], new OpusOutputBuffer[numOutputBuffers]);
+    byte[] headerBytes = initializationData.get(0);
+    if (headerBytes.length < 19) {
+      throw new OpusDecoderException("Header size is too small.");
+    }
+    channelCount = headerBytes[9] & 0xFF;
+    if (channelCount > 8) {
+      throw new OpusDecoderException("Invalid channel count: " + channelCount);
+    }
+    int preskip = readLittleEndian16(headerBytes, 10);
+    int gain = readLittleEndian16(headerBytes, 16);
+
+    byte[] streamMap = new byte[8];
+    int numStreams, numCoupled;
+    if (headerBytes[18] == 0) { // Channel mapping
+      // If there is no channel mapping, use the defaults.
+      if (channelCount > 2) { // Maximum channel count with default layout.
+        throw new OpusDecoderException("Invalid Header, missing stream map.");
+      }
+      numStreams = 1;
+      numCoupled = (channelCount == 2) ? 1 : 0;
+      streamMap[0] = 0;
+      streamMap[1] = 1;
+    } else {
+      if (headerBytes.length < 21 + channelCount) {
+        throw new OpusDecoderException("Header size is too small.");
+      }
+      // Read the channel mapping.
+      numStreams = headerBytes[19] & 0xFF;
+      numCoupled = headerBytes[20] & 0xFF;
+      for (int i = 0; i < channelCount; i++) {
+        streamMap[i] = headerBytes[21 + i];
+      }
+    }
+    if (initializationData.size() == 3) {
+      if (initializationData.get(1).length != 8 || initializationData.get(2).length != 8) {
+        throw new OpusDecoderException("Invalid Codec Delay or Seek Preroll");
+      }
+      long codecDelayNs =
+          ByteBuffer.wrap(initializationData.get(1)).order(ByteOrder.LITTLE_ENDIAN).getLong();
+      long seekPreRollNs =
+          ByteBuffer.wrap(initializationData.get(2)).order(ByteOrder.LITTLE_ENDIAN).getLong();
+      headerSkipSamples = nsToSamples(codecDelayNs);
+      headerSeekPreRollSamples = nsToSamples(seekPreRollNs);
+    } else {
+      headerSkipSamples = preskip;
+      headerSeekPreRollSamples = DEFAULT_SEEK_PRE_ROLL_SAMPLES;
+    }
+    nativeDecoderContext = opusInit(SAMPLE_RATE, channelCount, numStreams, numCoupled, gain,
+        streamMap);
     if (nativeDecoderContext == 0) {
       throw new OpusDecoderException("Failed to initialize decoder");
     }
+    setInitialInputBufferSize(initialInputBufferSize);
   }
 
-  /**
-   * Decodes an Opus Encoded Stream.
-   *
-   * @param inputBuffer buffer containing the encoded data. Must be allocated using allocateDirect.
-   * @param inputSize size of the input buffer.
-   * @param outputBuffer buffer to write the decoded data. Must be allocated using allocateDirect.
-   * @param outputSize Maximum capacity of the output buffer.
-   * @return number of decoded bytes.
-   * @throws OpusDecoderException if decode fails.
-   */
-  public int decode(ByteBuffer inputBuffer, int inputSize, ByteBuffer outputBuffer,
-      int outputSize) throws OpusDecoderException {
-    int result = opusDecode(nativeDecoderContext, inputBuffer, inputSize, outputBuffer, outputSize);
-    if (result < 0) {
-      throw new OpusDecoderException("Decode error: " + opusGetErrorMessage(result));
-    }
-    return result;
+  @Override
+  public InputBuffer createInputBuffer() {
+    return new InputBuffer();
   }
 
-  /**
-   * Closes the native decoder.
-   */
-  public void close() {
-    opusClose(nativeDecoderContext);
+  @Override
+  public OpusOutputBuffer createOutputBuffer() {
+    return new OpusOutputBuffer(this);
   }
 
-  /**
-   * Resets the native decode on discontinuity (during seek for example).
-   */
-  public void reset() {
-    opusReset(nativeDecoderContext);
+  @Override
+  protected void releaseOutputBuffer(OpusOutputBuffer buffer) {
+    super.releaseOutputBuffer(buffer);
   }
 
-  /**
-   * Returns whether the underlying libopus library is available.
-   */
-  public static boolean isLibopusAvailable() {
-    return IS_AVAILABLE;
+  @Override
+  public OpusDecoderException decode(InputBuffer inputBuffer, OpusOutputBuffer outputBuffer) {
+    if (inputBuffer.getFlag(Buffer.FLAG_RESET)) {
+      opusReset(nativeDecoderContext);
+      // When seeking to 0, skip number of samples as specified in opus header. When seeking to
+      // any other time, skip number of samples as specified by seek preroll.
+      skipSamples =
+          (inputBuffer.sampleHolder.timeUs == 0) ? headerSkipSamples : headerSeekPreRollSamples;
+    }
+    SampleHolder sampleHolder = inputBuffer.sampleHolder;
+    outputBuffer.timestampUs = sampleHolder.timeUs;
+    sampleHolder.data.position(sampleHolder.data.position() - sampleHolder.size);
+    int requiredOutputBufferSize =
+        opusGetRequiredOutputBufferSize(sampleHolder.data, sampleHolder.size, SAMPLE_RATE);
+    if (requiredOutputBufferSize < 0) {
+      return new OpusDecoderException("Error when computing required output buffer size.");
+    }
+    outputBuffer.init(requiredOutputBufferSize);
+    int result = opusDecode(nativeDecoderContext, sampleHolder.data, sampleHolder.size,
+        outputBuffer.data, outputBuffer.data.capacity());
+    if (result < 0) {
+      return new OpusDecoderException("Decode error: " + opusGetErrorMessage(result));
+    }
+    outputBuffer.data.position(0);
+    outputBuffer.data.limit(result);
+    if (skipSamples > 0) {
+      int bytesPerSample = channelCount * 2;
+      int skipBytes = skipSamples * bytesPerSample;
+      if (result <= skipBytes) {
+        skipSamples -= result / bytesPerSample;
+        outputBuffer.setFlag(Buffer.FLAG_DECODE_ONLY);
+        outputBuffer.data.position(result);
+      } else {
+        skipSamples = 0;
+        outputBuffer.data.position(skipBytes);
+      }
+    }
+    return null;
   }
 
-  /**
-   * Returns the version string of the underlying libopus decoder.
-   */
-  public static native String getLibopusVersion();
+  @Override
+  public void release() {
+    super.release();
+    opusClose(nativeDecoderContext);
+  }
 
   private native long opusInit(int sampleRate, int channelCount, int numStreams, int numCoupled,
       int gain, byte[] streamMap);
   private native int opusDecode(long decoder, ByteBuffer inputBuffer, int inputSize,
       ByteBuffer outputBuffer, int outputSize);
+  private native int opusGetRequiredOutputBufferSize(
+      ByteBuffer inputBuffer, int inputSize, int sampleRate);
   private native void opusClose(long decoder);
   private native void opusReset(long decoder);
   private native String opusGetErrorMessage(int errorCode);
 
+  private static int nsToSamples(long ns) {
+    return (int) (ns * SAMPLE_RATE / 1000000000);
+  }
+
+  private static int readLittleEndian16(byte[] input, int offset) {
+    int value = input[offset] & 0xFF;
+    value |= (input[offset + 1] & 0xFF) << 8;
+    return value;
+  }
+
 }
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoderException.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoderException.java
index 13e7739df9..a3ff1b0688 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoderException.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoderException.java
@@ -18,10 +18,10 @@
 /**
  * Thrown when an Opus decoder error occurs.
  */
-public class OpusDecoderException extends Exception {
+public final class OpusDecoderException extends Exception {
 
-    public OpusDecoderException(String message) {
-      super(message);
-    }
+  /* package */ OpusDecoderException(String message) {
+    super(message);
+  }
 
 }
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoderWrapper.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoderWrapper.java
deleted file mode 100644
index d4f6c8e306..0000000000
--- a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoderWrapper.java
+++ /dev/null
@@ -1,400 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.ext.opus;
-
-import com.google.android.exoplayer.SampleHolder;
-
-import java.nio.ByteBuffer;
-import java.util.LinkedList;
-
-/**
- * Wraps {@link OpusDecoder}, exposing a higher level decoder interface.
- */
-/* package */ class OpusDecoderWrapper extends Thread {
-
-  public static final int FLAG_END_OF_STREAM = 1;
-  public static final int FLAG_RESET_DECODER = 2;
-
-  private static final int INPUT_BUFFER_SIZE = 960 * 6;
-  private static final int OUTPUT_BUFFER_SIZE = 960 * 6 * 2;
-  private static final int NUM_BUFFERS = 16;
-  private static final int DEFAULT_SEEK_PRE_ROLL = 3840;
-
-  private final Object lock;
-  private final OpusHeader opusHeader;
-
-  private final LinkedList<InputBuffer> dequeuedInputBuffers;
-  private final LinkedList<InputBuffer> queuedInputBuffers;
-  private final LinkedList<OutputBuffer> queuedOutputBuffers;
-  private final LinkedList<OutputBuffer> dequeuedOutputBuffers;
-  private final InputBuffer[] availableInputBuffers;
-  private final OutputBuffer[] availableOutputBuffers;
-  private int availableInputBufferCount;
-  private int availableOutputBufferCount;
-
-  private int skipSamples;
-  private boolean flushDecodedOutputBuffer;
-  private boolean released;
-
-  private int seekPreRoll;
-
-  private OpusDecoderException decoderException;
-
-  /**
-   * @param headerBytes Opus header data that is used to initialize the decoder. For WebM Container,
-   *    this comes from the CodecPrivate Track element.
-   * @param codecDelayNs Delay in nanoseconds added by the codec at the beginning. For WebM
-   *    Container, this comes from the CodecDelay Track Element. Can be -1 in which case the value
-   *    from the codec header will be used.
-   * @param seekPreRollNs Duration in nanoseconds of samples to discard when there is a
-   *    discontinuity. For WebM Container, this comes from the SeekPreRoll Track Element. Can be -1
-   *    in which case the default value of 80ns will be used.
-   * @throws OpusDecoderException if an exception occurs when initializing the decoder.
-   */
-  public OpusDecoderWrapper(byte[] headerBytes, long codecDelayNs,
-      long seekPreRollNs) throws OpusDecoderException {
-    lock = new Object();
-    opusHeader = parseOpusHeader(headerBytes);
-    skipSamples = (codecDelayNs == -1) ? opusHeader.skipSamples
-        : nsToSamples(opusHeader, codecDelayNs);
-    seekPreRoll = (seekPreRoll == -1) ? DEFAULT_SEEK_PRE_ROLL
-        : nsToSamples(opusHeader, seekPreRollNs);
-    dequeuedInputBuffers = new LinkedList<>();
-    queuedInputBuffers = new LinkedList<>();
-    queuedOutputBuffers = new LinkedList<>();
-    dequeuedOutputBuffers = new LinkedList<>();
-    availableInputBuffers = new InputBuffer[NUM_BUFFERS];
-    availableOutputBuffers = new OutputBuffer[NUM_BUFFERS];
-    availableInputBufferCount = NUM_BUFFERS;
-    availableOutputBufferCount = NUM_BUFFERS;
-    for (int i = 0; i < NUM_BUFFERS; i++) {
-      availableInputBuffers[i] = new InputBuffer();
-      availableOutputBuffers[i] = new OutputBuffer();
-    }
-  }
-
-  public InputBuffer dequeueInputBuffer() throws OpusDecoderException {
-    synchronized (lock) {
-      maybeThrowDecoderError();
-      if (availableInputBufferCount == 0) {
-        return null;
-      }
-      InputBuffer inputBuffer = availableInputBuffers[--availableInputBufferCount];
-      inputBuffer.reset();
-      dequeuedInputBuffers.addLast(inputBuffer);
-      return inputBuffer;
-    }
-  }
-
-  public void queueInputBuffer(InputBuffer inputBuffer) throws OpusDecoderException {
-    synchronized (lock) {
-      maybeThrowDecoderError();
-      dequeuedInputBuffers.remove(inputBuffer);
-      queuedInputBuffers.addLast(inputBuffer);
-      maybeNotifyDecodeLoop();
-    }
-  }
-
-  public OutputBuffer dequeueOutputBuffer() throws OpusDecoderException {
-    synchronized (lock) {
-      maybeThrowDecoderError();
-      if (queuedOutputBuffers.isEmpty()) {
-        return null;
-      }
-      OutputBuffer outputBuffer = queuedOutputBuffers.removeFirst();
-      dequeuedOutputBuffers.add(outputBuffer);
-      return outputBuffer;
-    }
-  }
-
-  public void releaseOutputBuffer(OutputBuffer outputBuffer) throws OpusDecoderException {
-    synchronized (lock) {
-      maybeThrowDecoderError();
-      outputBuffer.reset();
-      dequeuedOutputBuffers.remove(outputBuffer);
-      availableOutputBuffers[availableOutputBufferCount++] = outputBuffer;
-      maybeNotifyDecodeLoop();
-    }
-  }
-
-  public void flush() {
-    synchronized (lock) {
-      flushDecodedOutputBuffer = true;
-      while (!dequeuedInputBuffers.isEmpty()) {
-        availableInputBuffers[availableInputBufferCount++] = dequeuedInputBuffers.removeFirst();
-      }
-      while (!queuedInputBuffers.isEmpty()) {
-        availableInputBuffers[availableInputBufferCount++] = queuedInputBuffers.removeFirst();
-      }
-      while (!queuedOutputBuffers.isEmpty()) {
-        availableOutputBuffers[availableOutputBufferCount++] = queuedOutputBuffers.removeFirst();
-      }
-      while (!dequeuedOutputBuffers.isEmpty()) {
-        availableOutputBuffers[availableOutputBufferCount++] = dequeuedOutputBuffers.removeFirst();
-      }
-    }
-  }
-
-  public void release() {
-    synchronized (lock) {
-      released = true;
-      lock.notify();
-    }
-    try {
-      join();
-    } catch (InterruptedException e) {
-      Thread.currentThread().interrupt();
-    }
-  }
-
-  private void maybeThrowDecoderError() throws OpusDecoderException {
-    if (decoderException != null) {
-      throw decoderException;
-    }
-  }
-
-  /**
-   * Notifies the decode loop if there exists a queued input buffer and an available output buffer
-   * to decode into.
-   * <p>
-   * Should only be called whilst synchronized on the lock object.
-   */
-  private void maybeNotifyDecodeLoop() {
-    if (!queuedInputBuffers.isEmpty() && availableOutputBufferCount > 0) {
-      lock.notify();
-    }
-  }
-
-  @Override
-  public void run() {
-    OpusDecoder decoder = null;
-    try {
-      decoder = new OpusDecoder(opusHeader);
-      while (decodeBuffer(decoder)) {
-        // Do nothing.
-      }
-    } catch (OpusDecoderException e) {
-      synchronized (lock) {
-        decoderException = e;
-      }
-    } catch (InterruptedException e) {
-      // Shouldn't ever happen.
-    } finally {
-      if (decoder != null) {
-        decoder.close();
-      }
-    }
-  }
-
-  private boolean decodeBuffer(OpusDecoder decoder) throws InterruptedException,
-      OpusDecoderException {
-    InputBuffer inputBuffer;
-    OutputBuffer outputBuffer;
-
-    // Wait until we have an input buffer to decode, and an output buffer to decode into.
-    synchronized (lock) {
-      while (!released && (queuedInputBuffers.isEmpty() || availableOutputBufferCount == 0)) {
-        lock.wait();
-      }
-      if (released) {
-        return false;
-      }
-      inputBuffer = queuedInputBuffers.removeFirst();
-      outputBuffer = availableOutputBuffers[--availableOutputBufferCount];
-      flushDecodedOutputBuffer = false;
-    }
-
-    // Decode.
-    boolean skipBuffer = false;
-    if (inputBuffer.getFlag(FLAG_END_OF_STREAM)) {
-      outputBuffer.setFlag(FLAG_END_OF_STREAM);
-    } else {
-      if (inputBuffer.getFlag(FLAG_RESET_DECODER)) {
-        decoder.reset();
-        // When seeking to 0, skip number of samples as specified in opus header. When seeking to
-        // any other time, skip number of samples as specified by seek preroll.
-        skipSamples = (inputBuffer.sampleHolder.timeUs == 0) ? opusHeader.skipSamples : seekPreRoll;
-      }
-      SampleHolder sampleHolder = inputBuffer.sampleHolder;
-      sampleHolder.data.position(sampleHolder.data.position() - sampleHolder.size);
-      outputBuffer.timestampUs = sampleHolder.timeUs;
-      outputBuffer.size = decoder.decode(sampleHolder.data, sampleHolder.size,
-          outputBuffer.data, outputBuffer.data.capacity());
-      outputBuffer.data.position(0);
-      if (skipSamples > 0) {
-        int bytesPerSample = opusHeader.channelCount * 2;
-        int skipBytes = skipSamples * bytesPerSample;
-        if (outputBuffer.size <= skipBytes) {
-          skipSamples -= outputBuffer.size / bytesPerSample;
-          outputBuffer.size = 0;
-          skipBuffer = true;
-        } else {
-          skipSamples = 0;
-          outputBuffer.size -= skipBytes;
-          outputBuffer.data.position(skipBytes);
-        }
-      }
-    }
-
-    synchronized (lock) {
-      if (flushDecodedOutputBuffer
-          || inputBuffer.sampleHolder.isDecodeOnly()
-          || skipBuffer) {
-        // In the following cases, we make the output buffer available again rather than queuing it
-        // to be consumed:
-        // 1) A flush occured whilst we were decoding.
-        // 2) The input sample has decodeOnly flag set.
-        // 3) We skip the entire buffer due to skipSamples being greater than bytes decoded.
-        outputBuffer.reset();
-        availableOutputBuffers[availableOutputBufferCount++] = outputBuffer;
-      } else {
-        // Queue the decoded output buffer to be consumed.
-        queuedOutputBuffers.addLast(outputBuffer);
-      }
-      // Make the input buffer available again.
-      availableInputBuffers[availableInputBufferCount++] = inputBuffer;
-    }
-
-    return true;
-  }
-
-  private static OpusHeader parseOpusHeader(byte[] headerBytes) throws OpusDecoderException {
-    final int maxChannelCount = 8;
-    final int maxChannelCountWithDefaultLayout = 2;
-    final int headerSize = 19;
-    final int headerChannelCountOffset = 9;
-    final int headerSkipSamplesOffset = 10;
-    final int headerGainOffset = 16;
-    final int headerChannelMappingOffset = 18;
-    final int headerNumStreamsOffset = headerSize;
-    final int headerNumCoupledOffset = headerNumStreamsOffset + 1;
-    final int headerStreamMapOffset = headerNumStreamsOffset + 2;
-    OpusHeader opusHeader = new OpusHeader();
-    try {
-      // Opus streams are always decoded at 48000 hz.
-      opusHeader.sampleRate = 48000;
-      opusHeader.channelCount = headerBytes[headerChannelCountOffset];
-      if (opusHeader.channelCount > maxChannelCount) {
-        throw new OpusDecoderException("Invalid channel count: " + opusHeader.channelCount);
-      }
-      opusHeader.skipSamples = readLittleEndian16(headerBytes, headerSkipSamplesOffset);
-      opusHeader.gain = readLittleEndian16(headerBytes, headerGainOffset);
-      opusHeader.channelMapping = headerBytes[headerChannelMappingOffset];
-
-      if (opusHeader.channelMapping == 0) {
-        // If there is no channel mapping, use the defaults.
-        if (opusHeader.channelCount > maxChannelCountWithDefaultLayout) {
-          throw new OpusDecoderException("Invalid Header, missing stream map.");
-        }
-        opusHeader.numStreams = 1;
-        opusHeader.numCoupled = (opusHeader.channelCount > 1) ? 1 : 0;
-        opusHeader.streamMap[0] = 0;
-        opusHeader.streamMap[1] = 1;
-      } else {
-        // Read the channel mapping.
-        opusHeader.numStreams = headerBytes[headerNumStreamsOffset];
-        opusHeader.numCoupled = headerBytes[headerNumCoupledOffset];
-        for (int i = 0; i < opusHeader.channelCount; i++) {
-          opusHeader.streamMap[i] = headerBytes[headerStreamMapOffset + i];
-        }
-      }
-      return opusHeader;
-    } catch (ArrayIndexOutOfBoundsException e) {
-      throw new OpusDecoderException("Header size is too small.");
-    }
-  }
-
-  private static int readLittleEndian16(byte[] input, int offset) {
-    int value = input[offset];
-    value |= input[offset + 1] << 8;
-    return value;
-  }
-
-  private static int nsToSamples(OpusHeader opusHeader, long ns) {
-    return (int) (ns * opusHeader.sampleRate / 1000000000);
-  }
-
-  /* package */ static final class InputBuffer {
-
-    public final SampleHolder sampleHolder;
-
-    public int flags;
-
-    public InputBuffer() {
-      sampleHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_DIRECT);
-      sampleHolder.data = ByteBuffer.allocateDirect(INPUT_BUFFER_SIZE);
-    }
-
-    public void reset() {
-      sampleHolder.clearData();
-      flags = 0;
-    }
-
-    public void setFlag(int flag) {
-      flags |= flag;
-    }
-
-    public boolean getFlag(int flag) {
-      return (flags & flag) == flag;
-    }
-
-  }
-
-  /* package */ static final class OutputBuffer {
-
-    public ByteBuffer data;
-    public int size;
-    public long timestampUs;
-    public int flags;
-
-    public OutputBuffer() {
-      data = ByteBuffer.allocateDirect(OUTPUT_BUFFER_SIZE);
-    }
-
-    public void reset() {
-      data.clear();
-      size = 0;
-      flags = 0;
-    }
-
-    public void setFlag(int flag) {
-      flags |= flag;
-    }
-
-    public boolean getFlag(int flag) {
-      return (flags & flag) == flag;
-    }
-
-  }
-
-  /* package */ static final class OpusHeader {
-
-    public int sampleRate;
-    public int channelCount;
-    public int skipSamples;
-    public int gain;
-    public int channelMapping;
-    public int numStreams;
-    public int numCoupled;
-    public byte[] streamMap;
-
-    public OpusHeader() {
-      streamMap = new byte[8];
-    }
-
-  }
-
-}
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusOutputBuffer.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusOutputBuffer.java
new file mode 100644
index 0000000000..3160d07710
--- /dev/null
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusOutputBuffer.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.opus;
+
+import com.google.android.exoplayer.util.extensions.OutputBuffer;
+
+import java.nio.ByteBuffer;
+
+/**
+ * Buffer for {@link OpusDecoder} output.
+ */
+public final class OpusOutputBuffer extends OutputBuffer {
+
+  private final OpusDecoder owner;
+
+  public ByteBuffer data;
+
+  /* package */ OpusOutputBuffer(OpusDecoder owner) {
+    this.owner = owner;
+  }
+
+  /* package */ void init(int size) {
+    if (data == null || data.capacity() < size) {
+      data = ByteBuffer.allocateDirect(size);
+    }
+    data.position(0);
+    data.limit(size);
+  }
+
+  @Override
+  public void reset() {
+    super.reset();
+    if (data != null) {
+      data.clear();
+    }
+  }
+
+  @Override
+  public void release() {
+    owner.releaseOutputBuffer(this);
+  }
+
+}
diff --git a/extensions/opus/src/main/jni/opus_jni.cc b/extensions/opus/src/main/jni/opus_jni.cc
index e4ee1c60e3..b15da26565 100644
--- a/extensions/opus/src/main/jni/opus_jni.cc
+++ b/extensions/opus/src/main/jni/opus_jni.cc
@@ -45,6 +45,7 @@ jint JNI_OnLoad(JavaVM* vm, void* reserved) {
   return JNI_VERSION_1_6;
 }
 
+static const int kBytesPerSample = 2;  // opus fixed point uses 16 bit samples.
 static int channelCount;
 
 FUNC(jlong, opusInit, jint sampleRate, jint channelCount, jint numStreams,
@@ -76,9 +77,19 @@ FUNC(jint, opusDecode, jlong jDecoder, jobject jInputBuffer, jint inputSize,
           env->GetDirectBufferAddress(jInputBuffer));
   int16_t* outputBuffer = reinterpret_cast<int16_t*>(
       env->GetDirectBufferAddress(jOutputBuffer));
-  int numFrames = opus_multistream_decode(decoder, inputBuffer, inputSize,
-                                          outputBuffer, outputSize, 0);
-  return (numFrames < 0) ? numFrames : numFrames * 2 * channelCount;
+  int sampleCount = opus_multistream_decode(decoder, inputBuffer, inputSize,
+                                            outputBuffer, outputSize, 0);
+  return (sampleCount < 0) ? sampleCount
+                           : sampleCount * kBytesPerSample * channelCount;
+}
+
+FUNC(jint, opusGetRequiredOutputBufferSize, jobject jInputBuffer,
+     jint inputSize, jint sampleRate) {
+  const uint8_t* inputBuffer = reinterpret_cast<const uint8_t*>(
+      env->GetDirectBufferAddress(jInputBuffer));
+  const int32_t sampleCount =
+      opus_packet_get_nb_samples(inputBuffer, inputSize, sampleRate);
+  return sampleCount * kBytesPerSample * channelCount;
 }
 
 FUNC(void, opusClose, jlong jDecoder) {
diff --git a/extensions/vp9/README.md b/extensions/vp9/README.md
index f47aa1225a..28252fdfda 100644
--- a/extensions/vp9/README.md
+++ b/extensions/vp9/README.md
@@ -2,15 +2,15 @@
 
 ## Description ##
 
-The VP9 Extension is a [TrackRenderer][] implementation that helps you bundle libvpx (the VP9 decoding library) into your app and use it along with ExoPlayer to play VP9 video on Android devices.
+The VP9 Extension is a [TrackRenderer][] implementation that helps you bundle
+libvpx (the VP9 decoding library) into your app and use it along with ExoPlayer
+to play VP9 video on Android devices.
 
 [TrackRenderer]: https://google.github.io/ExoPlayer/doc/reference/com/google/android/exoplayer/TrackRenderer.html
 
-## Build Instructions (Android Studio and Eclipse) ##
+## Build Instructions ##
 
-Building the VP9 Extension involves building libvpx and JNI bindings using the Android NDK and linking it into your app. The following steps will tell you how to do that using Android Studio or Eclipse.
-
-* Checkout ExoPlayer along with Extensions
+* Checkout ExoPlayer along with Extensions:
 
 ```
 git clone https://github.com/google/ExoPlayer.git
@@ -30,7 +30,7 @@ VP9_EXT_PATH="${EXOPLAYER_ROOT}/extensions/vp9/src/main"
 NDK_PATH="<path to Android NDK>"
 ```
 
-* Fetch libvpx and libyuv
+* Fetch libvpx and libyuv:
 
 ```
 cd "${VP9_EXT_PATH}/jni" && \
@@ -38,100 +38,44 @@ git clone https://chromium.googlesource.com/webm/libvpx libvpx && \
 git clone https://chromium.googlesource.com/libyuv/libyuv libyuv
 ```
 
-* Run a script that generates necessary configuration files for libvpx
+* Run a script that generates necessary configuration files for libvpx:
 
 ```
 cd ${VP9_EXT_PATH}/jni && \
 ./generate_libvpx_android_configs.sh "${NDK_PATH}"
 ```
 
-### Android Studio ###
-
-For Android Studio, we build the native libraries from the command line and then Gradle will pick it up when building your app using Android Studio.
-
-* Build the JNI native libraries
+* Build the JNI native libraries from the command line:
 
 ```
 cd "${VP9_EXT_PATH}"/jni && \
 ${NDK_PATH}/ndk-build APP_ABI=all -j4
 ```
 
-* In your project, you can add a dependency to the VP9 Extension by using a the following rule
+* In your project, you can add a dependency to the VP9 Extension by using a the
+  following rule:
 
 ```
 // in settings.gradle
 include ':..:ExoPlayer:library'
-include ':..:ExoPlayer:vp9-extension'
+include ':..:ExoPlayer:extension-vp9'
 
 // in build.gradle
 dependencies {
     compile project(':..:ExoPlayer:library')
-    compile project(':..:ExoPlayer:vp9-extension')
+    compile project(':..:ExoPlayer:extension-vp9')
 }
 ```
 
-* Now, when you build your app, the VP9 extension will be built and the native libraries will be packaged along with the APK.
-
-### Eclipse ###
-
-* The following steps assume that you have installed Eclipse and configured it with the [Android SDK][] and [Android NDK ][]:
-  * Navigate to File->Import->General->Existing Projects into Workspace
-  * Select the root directory of the repository
-  * Import the following projects:
-    * ExoPlayerLib
-    * ExoPlayerExt-VP9
-    * If you are able to build ExoPlayerExt-VP9 project, then you're all set.
-    * (Optional) To speed up the NDK build:
-      * Right click on ExoPlayerExt-VP9 in the Project Explorer pane and choose Properties
-      * Click on C/C++ Build
-      * Uncheck `Use default build command`
-      * In `Build Command` enter: `ndk-build -j4` (adjust 4 to a reasonable number depending on the number of cores in your computer)
-      * Click Apply
-
-You can now create your own Android App project and add ExoPlayerLib along with ExoPlayerExt-VP9 as a dependencies to use ExoPlayer along with the VP9 Extension.
-
-
-[Android NDK]: https://developer.android.com/tools/sdk/ndk/index.html
-<!---
-Work around to point to two different links for the same text.
--->
-[Android NDK ]: http://tools.android.com/recent/usingthendkplugin
-[Android SDK]: http://developer.android.com/sdk/installing/index.html?pkg=tools
-
-## Building for various Architectures ##
-
-### Android Studio ###
-
-The manual invocation of `ndk-build` will build the library for all architectures and the correct one will be picked up from the APK based on the device its running on.
-
-### Eclipse  ###
-
-libvpx is optimized for various architectures (like neon, x86, etc.). The `generate_libvpx_android_configs.sh` script generates Android configurations for the following architectures:
-
-* armeabi (the default - does not include neon optimizations)
-* armeabi-v7a (choose this to enable neon optimizations)
-* mips
-* x86
-* arm64-v8a
-* mips64
-* x86_64
-* all (will result in a larger binary but will cover all architectures)
-
-You can build for a specific architecture in two ways:
-
-* Method 1 (edit `Application.mk`)
-  * Edit `${VP9_EXT_PATH}/jni/Application.mk` and add the following line `APP_ABI := <arch>` (where `<arch>` is one of the above 7 architectures)
-* Method 2 (pass NDK build flag)
-  * Right click on ExoPlayerExt-VP9 in the Project Explorer pane and choose Properties
-  * Click on C/C++ Build
-  * Uncheck `Use default build command`
-  * In `Build Command` enter: `ndk-build APP_ABI=<arch>` (where `<arch>` is one of the above 7 architectures)
-  * Click Apply
+* Now, when you build your app, the VP9 extension will be built and the native
+  libraries will be packaged along with the APK.
 
-## Other Things to Note ##
+## Notes ##
 
 * Every time there is a change to the libvpx checkout:
-  * Android config scripts should be re-generated by running `generate_libvpx_android_configs.sh`
+  * Android config scripts should be re-generated by running
+    `generate_libvpx_android_configs.sh`
   * Clean and re-build the project.
-* If you want to use your own version of libvpx or libyuv, place it in `${VP9_EXT_PATH}/jni/libvpx` or `${VP9_EXT_PATH}/jni/libyuv` respectively.
+* If you want to use your own version of libvpx or libyuv, place it in
+  `${VP9_EXT_PATH}/jni/libvpx` or `${VP9_EXT_PATH}/jni/libyuv` respectively.
 
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
index 2a1b29ef47..2dc9c6e6f0 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
@@ -23,8 +23,8 @@
 import com.google.android.exoplayer.SampleSource;
 import com.google.android.exoplayer.SampleSourceTrackRenderer;
 import com.google.android.exoplayer.TrackRenderer;
-import com.google.android.exoplayer.ext.vp9.VpxDecoderWrapper.VpxInputBuffer;
 import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.extensions.Buffer;
 
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
@@ -105,6 +105,14 @@ void onDecoderInitialized(String decoderName, long elapsedRealtimeMs,
    */
   public static final int MSG_SET_OUTPUT_BUFFER_RENDERER = 2;
 
+  /**
+   * The number of input buffers and the number of output buffers. The track renderer may limit the
+   * minimum possible value due to requiring multiple output buffers to be dequeued at a time for it
+   * to make progress.
+   */
+  private static final int NUM_BUFFERS = 16;
+  private static final int INITIAL_INPUT_BUFFER_SIZE = 768 * 1024; // Value based on cs/SoftVpx.cpp.
+
   public final CodecCounters codecCounters = new CodecCounters();
 
   private final boolean scaleToFit;
@@ -114,9 +122,10 @@ void onDecoderInitialized(String decoderName, long elapsedRealtimeMs,
   private final MediaFormatHolder formatHolder;
 
   private MediaFormat format;
-  private VpxDecoderWrapper decoder;
+  private VpxDecoder decoder;
   private VpxInputBuffer inputBuffer;
   private VpxOutputBuffer outputBuffer;
+  private VpxOutputBuffer nextOutputBuffer;
 
   private Bitmap bitmap;
   private boolean drawnToSurface;
@@ -170,7 +179,7 @@ public LibvpxVideoTrackRenderer(SampleSource source, boolean scaleToFit,
    * Returns whether the underlying libvpx library is available.
    */
   public static boolean isLibvpxAvailable() {
-    return VpxDecoder.isLibvpxAvailable();
+    return VpxDecoder.IS_AVAILABLE;
   }
 
   /**
@@ -199,18 +208,17 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs, boolean sourc
       return;
     }
 
-    // If we don't have a decoder yet, we need to instantiate one.
-    if (decoder == null) {
-      long startElapsedRealtimeMs = SystemClock.elapsedRealtime();
-      decoder = new VpxDecoderWrapper(outputMode);
-      decoder.start();
-      notifyDecoderInitialized(startElapsedRealtimeMs, SystemClock.elapsedRealtime());
-      codecCounters.codecInitCount++;
-    }
-
-    // Rendering loop.
     try {
-      processOutputBuffer(positionUs, elapsedRealtimeUs);
+      if (decoder == null) {
+        // If we don't have a decoder yet, we need to instantiate one.
+        long startElapsedRealtimeMs = SystemClock.elapsedRealtime();
+        decoder = new VpxDecoder(NUM_BUFFERS, NUM_BUFFERS, INITIAL_INPUT_BUFFER_SIZE);
+        decoder.setOutputMode(outputMode);
+        decoder.start();
+        notifyDecoderInitialized(startElapsedRealtimeMs, SystemClock.elapsedRealtime());
+        codecCounters.codecInitCount++;
+      }
+      while (processOutputBuffer(positionUs)) {}
       while (feedInputBuffer(positionUs)) {}
     } catch (VpxDecoderException e) {
       notifyDecoderError(e);
@@ -219,63 +227,63 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs, boolean sourc
     codecCounters.ensureUpdated();
   }
 
-  private void processOutputBuffer(long positionUs, long elapsedRealtimeUs)
+  private boolean processOutputBuffer(long positionUs)
       throws VpxDecoderException {
     if (outputStreamEnded) {
-      return;
+      return false;
     }
 
+    // Acquire outputBuffer either from nextOutputBuffer or from the decoder.
     if (outputBuffer == null) {
-      outputBuffer = decoder.dequeueOutputBuffer();
+      if (nextOutputBuffer != null) {
+        outputBuffer = nextOutputBuffer;
+        nextOutputBuffer = null;
+      } else {
+        outputBuffer = decoder.dequeueOutputBuffer();
+      }
       if (outputBuffer == null) {
-        return;
+        return false;
       }
     }
 
-    if (outputBuffer.flags == VpxDecoderWrapper.FLAG_END_OF_STREAM) {
+    if (nextOutputBuffer == null) {
+      nextOutputBuffer = decoder.dequeueOutputBuffer();
+    }
+
+    if (outputBuffer.getFlag(Buffer.FLAG_END_OF_STREAM)) {
       outputStreamEnded = true;
-      decoder.releaseOutputBuffer(outputBuffer);
+      outputBuffer.release();
       outputBuffer = null;
-      return;
+      return false;
     }
 
-    long elapsedSinceStartOfLoop = SystemClock.elapsedRealtime() * 1000 - elapsedRealtimeUs;
-    long timeToRenderUs = outputBuffer.timestampUs - positionUs - elapsedSinceStartOfLoop;
-
-    if (timeToRenderUs < -30000 || outputBuffer.timestampUs < positionUs) {
+    // Drop frame only if we have the next frame and that's also late, otherwise render whatever we
+    // have.
+    if (nextOutputBuffer != null && nextOutputBuffer.timestampUs < positionUs) {
       // Drop frame if we are too late.
       codecCounters.droppedOutputBufferCount++;
       droppedFrameCount++;
       if (droppedFrameCount == maxDroppedFrameCountToNotify) {
         notifyAndResetDroppedFrameCount();
       }
-      decoder.releaseOutputBuffer(outputBuffer);
+      outputBuffer.release();
       outputBuffer = null;
-      return;
+      return true;
     }
 
     // If we have not rendered any frame so far (either initially or immediately following a seek),
-    // render one frame irrespective of the state.
+    // render one frame irrespective of the state or current position.
     if (!renderedFirstFrame) {
       renderBuffer();
       renderedFirstFrame = true;
-      return;
-    }
-
-    // Do nothing if we are not playing or if we are too early to render the next frame.
-    if (getState() != TrackRenderer.STATE_STARTED || timeToRenderUs > 30000) {
-      return;
+      return false;
     }
 
-    if (timeToRenderUs > 11000) {
-      try {
-        // Subtracting 10000 rather than 11000 ensures that the sleep time will be at least 1ms.
-        Thread.sleep((timeToRenderUs - 10000) / 1000);
-      } catch (InterruptedException e) {
-        Thread.currentThread().interrupt();
-      }
+    if (getState() == TrackRenderer.STATE_STARTED
+        && outputBuffer.timestampUs <= positionUs + 30000) {
+      renderBuffer();
     }
-    renderBuffer();
+    return false;
   }
 
   private void renderBuffer() {
@@ -333,7 +341,7 @@ private boolean feedInputBuffer(long positionUs) throws VpxDecoderException {
       return true;
     }
     if (result == SampleSource.END_OF_STREAM) {
-      inputBuffer.flags = VpxDecoderWrapper.FLAG_END_OF_STREAM;
+      inputBuffer.setFlag(Buffer.FLAG_END_OF_STREAM);
       decoder.queueInputBuffer(inputBuffer);
       inputBuffer = null;
       inputStreamEnded = true;
@@ -350,9 +358,13 @@ private boolean feedInputBuffer(long positionUs) throws VpxDecoderException {
   private void flushDecoder() {
     inputBuffer = null;
     if (outputBuffer != null) {
-      decoder.releaseOutputBuffer(outputBuffer);
+      outputBuffer.release();
       outputBuffer = null;
     }
+    if (nextOutputBuffer != null) {
+      nextOutputBuffer.release();
+      nextOutputBuffer = null;
+    }
     decoder.flush();
   }
 
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
index 3e54003633..4f8c845db8 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
@@ -15,14 +15,26 @@
  */
 package com.google.android.exoplayer.ext.vp9;
 
+import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.util.extensions.Buffer;
+import com.google.android.exoplayer.util.extensions.SimpleDecoder;
+
 import java.nio.ByteBuffer;
 
 /**
- * JNI Wrapper for the libvpx VP9 decoder.
+ * JNI wrapper for the libvpx VP9 decoder.
  */
-/* package */ class VpxDecoder {
+/* package */ final class VpxDecoder extends
+    SimpleDecoder<VpxInputBuffer, VpxOutputBuffer, VpxDecoderException> {
+
+  public static final int OUTPUT_MODE_UNKNOWN = -1;
+  public static final int OUTPUT_MODE_YUV = 0;
+  public static final int OUTPUT_MODE_RGB = 1;
 
-  private static final boolean IS_AVAILABLE;
+  /**
+   * Whether the underlying libvpx library is available.
+   */
+  public static final boolean IS_AVAILABLE;
   static {
     boolean isAvailable;
     try {
@@ -35,59 +47,78 @@
     IS_AVAILABLE = isAvailable;
   }
 
-  public static final int OUTPUT_MODE_UNKNOWN = -1;
-  public static final int OUTPUT_MODE_YUV = 0;
-  public static final int OUTPUT_MODE_RGB = 1;
+  /**
+   * Returns the version string of the underlying libvpx decoder.
+   */
+  public static native String getLibvpxVersion();
 
   private final long vpxDecContext;
 
+  private volatile int outputMode;
+
   /**
-   * Creates the VP9 Decoder.
+   * Creates a VP9 decoder.
    *
-   * @throws VpxDecoderException if the decoder fails to initialize.
+   * @param numInputBuffers The number of input buffers.
+   * @param numOutputBuffers The number of output buffers.
+   * @param initialInputBufferSize The initial size of each input buffer.
+   * @throws VpxDecoderException Thrown if an exception occurs when initializing the decoder.
    */
-  public VpxDecoder() throws VpxDecoderException {
+  public VpxDecoder(int numInputBuffers, int numOutputBuffers, int initialInputBufferSize)
+      throws VpxDecoderException {
+    super(new VpxInputBuffer[numInputBuffers], new VpxOutputBuffer[numOutputBuffers]);
     vpxDecContext = vpxInit();
     if (vpxDecContext == 0) {
       throw new VpxDecoderException("Failed to initialize decoder");
     }
+    setInitialInputBufferSize(initialInputBufferSize);
   }
 
   /**
-   * Decodes a vp9 encoded frame and converts it to RGB565.
+   * Sets the output mode for frames rendered by the decoder.
    *
-   * @param encoded The encoded buffer.
-   * @param size Size of the encoded buffer.
-   * @param outputBuffer The buffer into which the decoded frame should be written.
-   * @return 0 on success with a frame to render. 1 on success without a frame to render.
-   * @throws VpxDecoderException on decode failure.
+   * @param outputMode The output mode to use, which must be one of the {@code OUTPUT_MODE_*}
+   *     constants in {@link VpxDecoder}.
    */
-  public int decode(ByteBuffer encoded, int size, VpxOutputBuffer outputBuffer)
-      throws VpxDecoderException {
-    if (vpxDecode(vpxDecContext, encoded, size) != 0) {
-      throw new VpxDecoderException("Decode error: " + vpxGetErrorMessage(vpxDecContext));
-    }
-    return vpxGetFrame(vpxDecContext, outputBuffer);
+  public void setOutputMode(int outputMode) {
+    this.outputMode = outputMode;
   }
 
-  /**
-   * Destroys the decoder.
-   */
-  public void close() {
-    vpxClose(vpxDecContext);
+  @Override
+  protected VpxInputBuffer createInputBuffer() {
+    return new VpxInputBuffer();
   }
 
-  /**
-   * Returns whether the underlying libvpx library is available.
-   */
-  public static boolean isLibvpxAvailable() {
-    return IS_AVAILABLE;
+  @Override
+  protected VpxOutputBuffer createOutputBuffer() {
+    return new VpxOutputBuffer(this);
   }
 
-  /**
-   * Returns the version string of the underlying libvpx decoder.
-   */
-  public static native String getLibvpxVersion();
+  @Override
+  protected void releaseOutputBuffer(VpxOutputBuffer buffer) {
+    super.releaseOutputBuffer(buffer);
+  }
+
+  @Override
+  protected VpxDecoderException decode(VpxInputBuffer inputBuffer, VpxOutputBuffer outputBuffer) {
+    SampleHolder sampleHolder = inputBuffer.sampleHolder;
+    outputBuffer.timestampUs = sampleHolder.timeUs;
+    sampleHolder.data.position(sampleHolder.data.position() - sampleHolder.size);
+    if (vpxDecode(vpxDecContext, sampleHolder.data, sampleHolder.size) != 0) {
+      return new VpxDecoderException("Decode error: " + vpxGetErrorMessage(vpxDecContext));
+    }
+    outputBuffer.mode = outputMode;
+    if (vpxGetFrame(vpxDecContext, outputBuffer) != 0) {
+      outputBuffer.setFlag(Buffer.FLAG_DECODE_ONLY);
+    }
+    return null;
+  }
+
+  @Override
+  public void release() {
+    super.release();
+    vpxClose(vpxDecContext);
+  }
 
   private native long vpxInit();
   private native long vpxClose(long context);
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderException.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderException.java
index 1afa01a6c7..6d08f1b0d1 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderException.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderException.java
@@ -20,7 +20,7 @@
  */
 public class VpxDecoderException extends Exception {
 
-    public VpxDecoderException(String message) {
+    /* package */ VpxDecoderException(String message) {
       super(message);
     }
 
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderWrapper.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderWrapper.java
deleted file mode 100644
index 5dff64a846..0000000000
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderWrapper.java
+++ /dev/null
@@ -1,264 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.ext.vp9;
-
-import com.google.android.exoplayer.SampleHolder;
-import com.google.android.exoplayer.util.Assertions;
-
-import java.nio.ByteBuffer;
-import java.util.LinkedList;
-
-/**
- * Wraps {@link VpxDecoder}, exposing a higher level decoder interface.
- */
-/* package */ final class VpxDecoderWrapper extends Thread {
-
-  public static final int FLAG_END_OF_STREAM = 1;
-
-  private static final int INPUT_BUFFER_SIZE = 768 * 1024; // Value based on cs/SoftVpx.cpp.
-  /**
-   * The number of input buffers and the number of output buffers. The track renderer may limit the
-   * minimum possible value due to requiring multiple output buffers to be dequeued at a time for it
-   * to make progress.
-   */
-  private static final int NUM_BUFFERS = 16;
-
-  private final Object lock;
-
-  private final LinkedList<VpxInputBuffer> queuedInputBuffers;
-  private final LinkedList<VpxOutputBuffer> queuedOutputBuffers;
-  private final VpxInputBuffer[] availableInputBuffers;
-  private final VpxOutputBuffer[] availableOutputBuffers;
-  private int availableInputBufferCount;
-  private int availableOutputBufferCount;
-  private VpxInputBuffer dequeuedInputBuffer;
-
-  private boolean flushDecodedOutputBuffer;
-  private boolean released;
-  private int outputMode;
-
-  private VpxDecoderException decoderException;
-
-  /**
-   * @param outputMode One of OUTPUT_MODE_* constants from {@link VpxDecoderWrapper}
-   *     depending on the desired output mode.
-   */
-  public VpxDecoderWrapper(int outputMode) {
-    lock = new Object();
-    this.outputMode = outputMode;
-    queuedInputBuffers = new LinkedList<>();
-    queuedOutputBuffers = new LinkedList<>();
-    availableInputBuffers = new VpxInputBuffer[NUM_BUFFERS];
-    availableOutputBuffers = new VpxOutputBuffer[NUM_BUFFERS];
-    availableInputBufferCount = NUM_BUFFERS;
-    availableOutputBufferCount = NUM_BUFFERS;
-    for (int i = 0; i < NUM_BUFFERS; i++) {
-      availableInputBuffers[i] = new VpxInputBuffer();
-      availableOutputBuffers[i] = new VpxOutputBuffer(this);
-    }
-  }
-
-  public void setOutputMode(int outputMode) {
-    this.outputMode = outputMode;
-  }
-
-  public VpxInputBuffer dequeueInputBuffer() throws VpxDecoderException {
-    synchronized (lock) {
-      maybeThrowDecoderError();
-      Assertions.checkState(dequeuedInputBuffer == null);
-      if (availableInputBufferCount == 0) {
-        return null;
-      }
-      VpxInputBuffer inputBuffer = availableInputBuffers[--availableInputBufferCount];
-      inputBuffer.flags = 0;
-      inputBuffer.sampleHolder.clearData();
-      dequeuedInputBuffer = inputBuffer;
-      return inputBuffer;
-    }
-  }
-
-  public void queueInputBuffer(VpxInputBuffer inputBuffer) throws VpxDecoderException {
-    synchronized (lock) {
-      maybeThrowDecoderError();
-      Assertions.checkArgument(inputBuffer == dequeuedInputBuffer);
-      queuedInputBuffers.addLast(inputBuffer);
-      maybeNotifyDecodeLoop();
-      dequeuedInputBuffer = null;
-    }
-  }
-
-  public VpxOutputBuffer dequeueOutputBuffer() throws VpxDecoderException {
-    synchronized (lock) {
-      maybeThrowDecoderError();
-      if (queuedOutputBuffers.isEmpty()) {
-        return null;
-      }
-      return queuedOutputBuffers.removeFirst();
-    }
-  }
-
-  public void releaseOutputBuffer(VpxOutputBuffer outputBuffer) {
-    synchronized (lock) {
-      availableOutputBuffers[availableOutputBufferCount++] = outputBuffer;
-      maybeNotifyDecodeLoop();
-    }
-  }
-
-  /**
-   * Flushes input/output buffers that have not been dequeued yet and returns ownership of any
-   * dequeued input buffer to the decoder. Flushes any pending output currently in the decoder. The
-   * caller is still responsible for releasing any dequeued output buffers.
-   */
-  public void flush() {
-    synchronized (lock) {
-      flushDecodedOutputBuffer = true;
-      if (dequeuedInputBuffer != null) {
-        availableInputBuffers[availableInputBufferCount++] = dequeuedInputBuffer;
-        dequeuedInputBuffer = null;
-      }
-      while (!queuedInputBuffers.isEmpty()) {
-        availableInputBuffers[availableInputBufferCount++] = queuedInputBuffers.removeFirst();
-      }
-      while (!queuedOutputBuffers.isEmpty()) {
-        availableOutputBuffers[availableOutputBufferCount++] = queuedOutputBuffers.removeFirst();
-      }
-    }
-  }
-
-  public void release() {
-    synchronized (lock) {
-      released = true;
-      lock.notify();
-    }
-    try {
-      join();
-    } catch (InterruptedException e) {
-      Thread.currentThread().interrupt();
-    }
-  }
-
-  private void maybeThrowDecoderError() throws VpxDecoderException {
-    if (decoderException != null) {
-      throw decoderException;
-    }
-  }
-
-  /**
-   * Notifies the decode loop if there exists a queued input buffer and an available output buffer
-   * to decode into.
-   * <p>
-   * Should only be called whilst synchronized on the lock object.
-   */
-  private void maybeNotifyDecodeLoop() {
-    if (canDecodeBuffer()) {
-      lock.notify();
-    }
-  }
-
-  @Override
-  public void run() {
-    VpxDecoder decoder = null;
-    try {
-      decoder = new VpxDecoder();
-      while (decodeBuffer(decoder)) {
-        // Do nothing.
-      }
-    } catch (VpxDecoderException e) {
-      synchronized (lock) {
-        decoderException = e;
-      }
-    } catch (InterruptedException e) {
-      // Shouldn't ever happen.
-    } finally {
-      if (decoder != null) {
-        decoder.close();
-      }
-    }
-  }
-
-  private boolean decodeBuffer(VpxDecoder decoder) throws InterruptedException,
-      VpxDecoderException {
-    VpxInputBuffer inputBuffer;
-    VpxOutputBuffer outputBuffer;
-
-    // Wait until we have an input buffer to decode, and an output buffer to decode into.
-    synchronized (lock) {
-      while (!released && !canDecodeBuffer()) {
-        lock.wait();
-      }
-      if (released) {
-        return false;
-      }
-      inputBuffer = queuedInputBuffers.removeFirst();
-      outputBuffer = availableOutputBuffers[--availableOutputBufferCount];
-      flushDecodedOutputBuffer = false;
-    }
-
-    // Decode.
-    int decodeResult = -1;
-    if (inputBuffer.flags == FLAG_END_OF_STREAM) {
-      outputBuffer.flags = FLAG_END_OF_STREAM;
-    } else {
-      SampleHolder sampleHolder = inputBuffer.sampleHolder;
-      outputBuffer.timestampUs = sampleHolder.timeUs;
-      outputBuffer.flags = 0;
-      outputBuffer.mode = outputMode;
-      sampleHolder.data.position(sampleHolder.data.position() - sampleHolder.size);
-      decodeResult = decoder.decode(sampleHolder.data, sampleHolder.size, outputBuffer);
-    }
-
-    synchronized (lock) {
-      if (flushDecodedOutputBuffer
-          || inputBuffer.sampleHolder.isDecodeOnly()
-          || decodeResult == 1) {
-        // In the following cases, we make the output buffer available again rather than queuing it
-        // to be consumed:
-        // 1) A flush occured whilst we were decoding.
-        // 2) The input sample has decodeOnly flag set.
-        // 3) The decode succeeded, but we did not get any frame back for rendering (happens in case
-        // of an unpacked altref frame).
-        availableOutputBuffers[availableOutputBufferCount++] = outputBuffer;
-      } else {
-        // Queue the decoded output buffer to be consumed.
-        queuedOutputBuffers.addLast(outputBuffer);
-      }
-      // Make the input buffer available again.
-      availableInputBuffers[availableInputBufferCount++] = inputBuffer;
-    }
-
-    return true;
-  }
-
-  private boolean canDecodeBuffer() {
-    return !queuedInputBuffers.isEmpty() && availableOutputBufferCount > 0;
-  }
-
-  /* package */ static final class VpxInputBuffer {
-
-    public final SampleHolder sampleHolder;
-
-    public int width;
-    public int height;
-    public int flags;
-
-    public VpxInputBuffer() {
-      sampleHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_DIRECT);
-      sampleHolder.data = ByteBuffer.allocateDirect(INPUT_BUFFER_SIZE);
-    }
-
-  }
-
-}
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxInputBuffer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxInputBuffer.java
new file mode 100644
index 0000000000..f237d0d8e0
--- /dev/null
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxInputBuffer.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.vp9;
+
+import com.google.android.exoplayer.util.extensions.InputBuffer;
+
+/**
+ * Input buffer to a {@link VpxDecoder}.
+ */
+/* package */ final class VpxInputBuffer extends InputBuffer {
+
+  public int width;
+  public int height;
+
+}
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBuffer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBuffer.java
index 1a2b40a069..709e504139 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBuffer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBuffer.java
@@ -15,44 +15,42 @@
  */
 package com.google.android.exoplayer.ext.vp9;
 
+import com.google.android.exoplayer.util.extensions.OutputBuffer;
+
 import java.nio.ByteBuffer;
 
 /**
- * OutputBuffer for storing the video frame.
+ * Output buffer containing video frame data, populated by {@link VpxDecoder}.
  */
-public final class VpxOutputBuffer {
+public final class VpxOutputBuffer extends OutputBuffer {
 
   public static final int COLORSPACE_UNKNOWN = 0;
   public static final int COLORSPACE_BT601 = 1;
   public static final int COLORSPACE_BT709 = 2;
 
-  private final VpxDecoderWrapper decoder;
-
-  /* package */ VpxOutputBuffer(VpxDecoderWrapper decoder) {
-    this.decoder = decoder;
-  }
+  private final VpxDecoder owner;
 
+  public int mode;
   /**
    * RGB buffer for RGB mode.
    */
   public ByteBuffer data;
-  public long timestampUs;
   public int width;
   public int height;
-  public int flags;
   /**
    * YUV planes for YUV mode.
    */
   public ByteBuffer[] yuvPlanes;
   public int[] yuvStrides;
-  public int mode;
   public int colorspace;
 
-  /**
-   * Releases the buffer back to the decoder, allowing it to be reused.
-   */
+  /* package */ VpxOutputBuffer(VpxDecoder owner) {
+    this.owner = owner;
+  }
+
+  @Override
   public void release() {
-    decoder.releaseOutputBuffer(this);
+    owner.releaseOutputBuffer(this);
   }
 
   /**
diff --git a/gradle.properties b/gradle.properties
index 34fb4618f0..e4a0986904 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,18 +1,16 @@
-# Project-wide Gradle settings.
-
-# IDE (e.g. Android Studio) users:
-# Settings specified in this file will override any Gradle settings
-# configured through the IDE.
-
+## Project-wide Gradle settings.
+#
 # For more details on how to configure your build environment visit
 # http://www.gradle.org/docs/current/userguide/build_environment.html
-
+#
 # Specifies the JVM arguments used for the daemon process.
 # The setting is particularly useful for tweaking memory settings.
 # Default value: -Xmx10248m -XX:MaxPermSize=256m
 # org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
-
+#
 # When configured, Gradle will run in incubating parallel mode.
 # This option should only be used with decoupled projects. More details, visit
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
+#Thu Feb 04 15:49:07 GMT 2016
+android.useDeprecatedNdk=true
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index d3b131076c..9a01254a87 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Mon Dec 22 10:29:11 CST 2014
+#Tue Feb 23 12:44:36 GMT 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
diff --git a/library/build.gradle b/library/build.gradle
index ad4dff4e49..a8580f2597 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -77,7 +77,7 @@ publish {
     userOrg = 'google'
     groupId = 'com.google.android.exoplayer'
     artifactId = 'exoplayer'
-    version = 'r1.5.6'
+    version = 'r1.5.7'
     description = 'The ExoPlayer library.'
     website = 'https://github.com/google/ExoPlayer'
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggReaderTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggReaderTest.java
new file mode 100644
index 0000000000..f1270aeb2f
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggReaderTest.java
@@ -0,0 +1,365 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ogg;
+
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.testutil.FakeExtractorInput;
+import com.google.android.exoplayer.testutil.TestUtil;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import android.test.MoreAsserts;
+
+import junit.framework.TestCase;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Random;
+
+/**
+ * Unit test for {@link OggReader}.
+ */
+public final class OggReaderTest extends TestCase {
+
+  private Random random;
+  private OggReader oggReader;
+  private ParsableByteArray scratch;
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    random = new Random(0);
+    oggReader = new OggReader();
+    scratch = new ParsableByteArray(new byte[255 * 255], 0);
+  }
+
+  public void testReadPacketsWithEmptyPage() throws Exception {
+    byte[] firstPacket = TestUtil.buildTestData(8, random);
+    byte[] secondPacket = TestUtil.buildTestData(272, random);
+    byte[] thirdPacket = TestUtil.buildTestData(256, random);
+    byte[] fourthPacket = TestUtil.buildTestData(271, random);
+
+    FakeExtractorInput input = TestData.createInput(
+        TestUtil.joinByteArrays(
+            // First page with a single packet.
+            TestData.buildOggHeader(0x02,  0, 1000, 0x01),
+            TestUtil.createByteArray(0x08), // Laces
+            firstPacket,
+            // Second page with a single packet.
+            TestData.buildOggHeader(0x00,  16, 1001, 0x02),
+            TestUtil.createByteArray(0xFF, 0x11), // Laces
+            secondPacket,
+            // Third page with zero packets.
+            TestData.buildOggHeader(0x00,  16, 1002, 0x00),
+            // Fourth page with two packets.
+            TestData.buildOggHeader(0x04,  128, 1003, 0x04),
+            TestUtil.createByteArray(0xFF, 0x01, 0xFF, 0x10), // Laces
+            thirdPacket,
+            fourthPacket), true);
+
+    assertReadPacket(input, firstPacket);
+    assertTrue((oggReader.getPageHeader().type & 0x02) == 0x02);
+    assertFalse((oggReader.getPageHeader().type & 0x04) == 0x04);
+    assertEquals(0x02, oggReader.getPageHeader().type);
+    assertEquals(27 + 1, oggReader.getPageHeader().headerSize);
+    assertEquals(8, oggReader.getPageHeader().bodySize);
+    assertEquals(0x00, oggReader.getPageHeader().revision);
+    assertEquals(1, oggReader.getPageHeader().pageSegmentCount);
+    assertEquals(1000, oggReader.getPageHeader().pageSequenceNumber);
+    assertEquals(4096, oggReader.getPageHeader().streamSerialNumber);
+    assertEquals(0, oggReader.getPageHeader().granulePosition);
+
+    assertReadPacket(input, secondPacket);
+    assertFalse((oggReader.getPageHeader().type & 0x02) == 0x02);
+    assertFalse((oggReader.getPageHeader().type & 0x04) == 0x04);
+    assertEquals(0, oggReader.getPageHeader().type);
+    assertEquals(27 + 2, oggReader.getPageHeader().headerSize);
+    assertEquals(255 + 17, oggReader.getPageHeader().bodySize);
+    assertEquals(2, oggReader.getPageHeader().pageSegmentCount);
+    assertEquals(1001, oggReader.getPageHeader().pageSequenceNumber);
+    assertEquals(16, oggReader.getPageHeader().granulePosition);
+
+    assertReadPacket(input, thirdPacket);
+    assertFalse((oggReader.getPageHeader().type & 0x02) == 0x02);
+    assertTrue((oggReader.getPageHeader().type & 0x04) == 0x04);
+    assertEquals(4, oggReader.getPageHeader().type);
+    assertEquals(27 + 4, oggReader.getPageHeader().headerSize);
+    assertEquals(255 + 1 + 255 + 16, oggReader.getPageHeader().bodySize);
+    assertEquals(4, oggReader.getPageHeader().pageSegmentCount);
+    // Page 1002 is empty, so current page is 1003.
+    assertEquals(1003, oggReader.getPageHeader().pageSequenceNumber);
+    assertEquals(128, oggReader.getPageHeader().granulePosition);
+
+    assertReadPacket(input, fourthPacket);
+
+    assertReadEof(input);
+  }
+
+  public void testReadPacketWithZeroSizeTerminator() throws Exception {
+    byte[] firstPacket = TestUtil.buildTestData(255, random);
+    byte[] secondPacket = TestUtil.buildTestData(8, random);
+
+    FakeExtractorInput input = TestData.createInput(
+        TestUtil.joinByteArrays(
+            TestData.buildOggHeader(0x06, 0, 1000, 0x04),
+            TestUtil.createByteArray(0xFF, 0x00, 0x00, 0x08), // Laces.
+            firstPacket,
+            secondPacket), true);
+
+    assertReadPacket(input, firstPacket);
+    assertReadPacket(input, secondPacket);
+    assertReadEof(input);
+  }
+
+  public void testReadContinuedPacketOverTwoPages() throws Exception {
+    byte[] firstPacket = TestUtil.buildTestData(518);
+
+    FakeExtractorInput input = TestData.createInput(
+        TestUtil.joinByteArrays(
+            // First page.
+            TestData.buildOggHeader(0x02, 0, 1000, 0x02),
+            TestUtil.createByteArray(0xFF, 0xFF), // Laces.
+            Arrays.copyOf(firstPacket, 510),
+            // Second page (continued packet).
+            TestData.buildOggHeader(0x05, 10, 1001, 0x01),
+            TestUtil.createByteArray(0x08), // Laces.
+            Arrays.copyOfRange(firstPacket, 510, 510 + 8)), true);
+
+    assertReadPacket(input, firstPacket);
+    assertTrue((oggReader.getPageHeader().type & 0x04) == 0x04);
+    assertFalse((oggReader.getPageHeader().type & 0x02) == 0x02);
+    assertEquals(1001, oggReader.getPageHeader().pageSequenceNumber);
+
+    assertReadEof(input);
+  }
+
+  public void testReadContinuedPacketOverFourPages() throws Exception {
+    byte[] firstPacket = TestUtil.buildTestData(1028);
+
+    FakeExtractorInput input = TestData.createInput(
+        TestUtil.joinByteArrays(
+            // First page.
+            TestData.buildOggHeader(0x02, 0, 1000, 0x02),
+            TestUtil.createByteArray(0xFF, 0xFF), // Laces.
+            Arrays.copyOf(firstPacket, 510),
+            // Second page (continued packet).
+            TestData.buildOggHeader(0x01, 10, 1001, 0x01),
+            TestUtil.createByteArray(0xFF), // Laces.
+            Arrays.copyOfRange(firstPacket, 510, 510 + 255),
+            // Third page (continued packet).
+            TestData.buildOggHeader(0x01, 10, 1002, 0x01),
+            TestUtil.createByteArray(0xFF), // Laces.
+            Arrays.copyOfRange(firstPacket, 510 + 255, 510 + 255 + 255),
+            // Fourth page (continued packet).
+            TestData.buildOggHeader(0x05, 10, 1003, 0x01),
+            TestUtil.createByteArray(0x08), // Laces.
+            Arrays.copyOfRange(firstPacket, 510 + 255 + 255, 510 + 255 + 255 + 8)), true);
+
+    assertReadPacket(input, firstPacket);
+    assertTrue((oggReader.getPageHeader().type & 0x04) == 0x04);
+    assertFalse((oggReader.getPageHeader().type & 0x02) == 0x02);
+    assertEquals(1003, oggReader.getPageHeader().pageSequenceNumber);
+
+    assertReadEof(input);
+  }
+
+  public void testReadDiscardContinuedPacketAtStart() throws Exception {
+    byte[] pageBody = TestUtil.buildTestData(256 + 8);
+
+    FakeExtractorInput input = TestData.createInput(
+        TestUtil.joinByteArrays(
+            // Page with a continued packet at start.
+            TestData.buildOggHeader(0x01, 10, 1001, 0x03),
+            TestUtil.createByteArray(255, 1, 8), // Laces.
+            pageBody), true);
+
+    // Expect the first partial packet to be discarded.
+    assertReadPacket(input, Arrays.copyOfRange(pageBody, 256, 256 + 8));
+    assertReadEof(input);
+  }
+
+  public void testReadZeroSizedPacketsAtEndOfStream() throws Exception {
+    byte[] firstPacket = TestUtil.buildTestData(8, random);
+    byte[] secondPacket = TestUtil.buildTestData(8, random);
+    byte[] thirdPacket = TestUtil.buildTestData(8, random);
+
+    FakeExtractorInput input = TestData.createInput(
+        TestUtil.joinByteArrays(
+            TestData.buildOggHeader(0x02, 0, 1000, 0x01),
+            TestUtil.createByteArray(0x08), // Laces.
+            firstPacket,
+            TestData.buildOggHeader(0x04, 0, 1001, 0x03),
+            TestUtil.createByteArray(0x08, 0x00, 0x00), // Laces.
+            secondPacket,
+            TestData.buildOggHeader(0x04, 0, 1002, 0x03),
+            TestUtil.createByteArray(0x08, 0x00, 0x00), // Laces.
+            thirdPacket), true);
+
+    assertReadPacket(input, firstPacket);
+    assertReadPacket(input, secondPacket);
+    assertReadPacket(input, thirdPacket);
+    assertReadEof(input);
+  }
+
+  public void testSkipToPageOfGranule() throws IOException, InterruptedException {
+    byte[] packet = TestUtil.buildTestData(3 * 254, random);
+    FakeExtractorInput input = TestData.createInput(
+        TestUtil.joinByteArrays(
+            TestData.buildOggHeader(0x01, 20000, 1000, 0x03),
+            TestUtil.createByteArray(254, 254, 254), // Laces.
+            packet,
+            TestData.buildOggHeader(0x04, 40000, 1001, 0x03),
+            TestUtil.createByteArray(254, 254, 254), // Laces.
+            packet,
+            TestData.buildOggHeader(0x04, 60000, 1002, 0x03),
+            TestUtil.createByteArray(254, 254, 254), // Laces.
+            packet), false);
+
+    // expect to be granule of the previous page returned as elapsedSamples
+    skipToPageOfGranule(input, 54000, 40000);
+    // expect to be at the start of the third page
+    assertEquals(2 * (30 + (3 * 254)), input.getPosition());
+  }
+
+  public void testSkipToPageOfGranulePreciseMatch() throws IOException, InterruptedException {
+    byte[] packet = TestUtil.buildTestData(3 * 254, random);
+    FakeExtractorInput input = TestData.createInput(
+        TestUtil.joinByteArrays(
+            TestData.buildOggHeader(0x01, 20000, 1000, 0x03),
+            TestUtil.createByteArray(254, 254, 254), // Laces.
+            packet,
+            TestData.buildOggHeader(0x04, 40000, 1001, 0x03),
+            TestUtil.createByteArray(254, 254, 254), // Laces.
+            packet,
+            TestData.buildOggHeader(0x04, 60000, 1002, 0x03),
+            TestUtil.createByteArray(254, 254, 254), // Laces.
+            packet), false);
+
+    skipToPageOfGranule(input, 40000, 20000);
+    // expect to be at the start of the second page
+    assertEquals((30 + (3 * 254)), input.getPosition());
+  }
+
+  public void testSkipToPageOfGranuleAfterTargetPage() throws IOException, InterruptedException {
+    byte[] packet = TestUtil.buildTestData(3 * 254, random);
+    FakeExtractorInput input = TestData.createInput(
+        TestUtil.joinByteArrays(
+            TestData.buildOggHeader(0x01, 20000, 1000, 0x03),
+            TestUtil.createByteArray(254, 254, 254), // Laces.
+            packet,
+            TestData.buildOggHeader(0x04, 40000, 1001, 0x03),
+            TestUtil.createByteArray(254, 254, 254), // Laces.
+            packet,
+            TestData.buildOggHeader(0x04, 60000, 1002, 0x03),
+            TestUtil.createByteArray(254, 254, 254), // Laces.
+            packet), false);
+
+    try {
+      skipToPageOfGranule(input, 10000, 20000);
+      fail();
+    } catch (ParserException e) {
+      // ignored
+    }
+    assertEquals(0, input.getPosition());
+  }
+
+  private void skipToPageOfGranule(ExtractorInput input, long granule,
+      long elapsedSamplesExpected) throws IOException, InterruptedException {
+    while (true) {
+      try {
+        assertEquals(elapsedSamplesExpected, oggReader.skipToPageOfGranule(input, granule));
+        return;
+      } catch (FakeExtractorInput.SimulatedIOException e) {
+        input.resetPeekPosition();
+      }
+    }
+  }
+
+  public void testReadGranuleOfLastPage() throws IOException, InterruptedException {
+    FakeExtractorInput input = TestData.createInput(TestUtil.joinByteArrays(
+        TestUtil.buildTestData(100, random),
+        TestData.buildOggHeader(0x00, 20000, 66, 3),
+        TestUtil.createByteArray(254, 254, 254), // laces
+        TestUtil.buildTestData(3 * 254, random),
+        TestData.buildOggHeader(0x00, 40000, 67, 3),
+        TestUtil.createByteArray(254, 254, 254), // laces
+        TestUtil.buildTestData(3 * 254, random),
+        TestData.buildOggHeader(0x05, 60000, 68, 3),
+        TestUtil.createByteArray(254, 254, 254), // laces
+        TestUtil.buildTestData(3 * 254, random)
+    ), false);
+    assertReadGranuleOfLastPage(input, 60000);
+  }
+
+  public void testReadGranuleOfLastPageAfterLastHeader() throws IOException, InterruptedException {
+    FakeExtractorInput input = TestData.createInput(TestUtil.buildTestData(100, random), false);
+    try {
+      assertReadGranuleOfLastPage(input, 60000);
+      fail();
+    } catch (EOFException e) {
+      // ignored
+    }
+  }
+
+  public void testReadGranuleOfLastPageWithUnboundedLength()
+      throws IOException, InterruptedException {
+    FakeExtractorInput input = TestData.createInput(new byte[0], true);
+    try {
+      assertReadGranuleOfLastPage(input, 60000);
+      fail();
+    } catch (IllegalArgumentException e) {
+      // ignored
+    }
+  }
+
+  private void assertReadGranuleOfLastPage(FakeExtractorInput input, int expected)
+      throws IOException, InterruptedException {
+    while (true) {
+      try {
+        assertEquals(expected, oggReader.readGranuleOfLastPage(input));
+        break;
+      } catch (FakeExtractorInput.SimulatedIOException e) {
+        // ignored
+      }
+    }
+  }
+
+  private void assertReadPacket(FakeExtractorInput extractorInput, byte[] expected)
+      throws IOException, InterruptedException {
+    scratch.reset();
+    assertTrue(readPacket(extractorInput, scratch));
+    MoreAsserts.assertEquals(expected, Arrays.copyOf(scratch.data, scratch.limit()));
+  }
+
+  private void assertReadEof(FakeExtractorInput extractorInput)
+      throws IOException, InterruptedException {
+    scratch.reset();
+    assertFalse(readPacket(extractorInput, scratch));
+  }
+
+  private boolean readPacket(FakeExtractorInput input, ParsableByteArray scratch)
+      throws InterruptedException, IOException {
+    while (true) {
+      try {
+        return oggReader.readPacket(input, scratch);
+      } catch (FakeExtractorInput.SimulatedIOException e) {
+        // Ignore.
+      }
+    }
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggSeekerTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggSeekerTest.java
new file mode 100644
index 0000000000..de0034fce4
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggSeekerTest.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ogg;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.testutil.FakeExtractorInput;
+import com.google.android.exoplayer.testutil.TestUtil;
+
+import junit.framework.TestCase;
+
+import java.io.IOException;
+
+/**
+ * Unit test for {@link OggSeeker}.
+ */
+public final class OggSeekerTest extends TestCase {
+
+  private OggSeeker oggSeeker;
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    oggSeeker = new OggSeeker();
+    oggSeeker.setup(1, 1);
+  }
+
+  public void testSetupUnboundAudioLength() {
+    try {
+      new OggSeeker().setup(C.LENGTH_UNBOUNDED, 1000);
+      fail();
+    } catch (IllegalArgumentException e) {
+      // ignored
+    }
+  }
+
+  public void testSetupZeroOrNegativeTotalSamples() {
+    try {
+      new OggSeeker().setup(1000, 0);
+      fail();
+    } catch (IllegalArgumentException e) {
+      // ignored
+    }
+    try {
+      new OggSeeker().setup(1000, -1000);
+      fail();
+    } catch (IllegalArgumentException e) {
+      // ignored
+    }
+  }
+
+  public void testGetNextSeekPositionSetupNotCalled() throws IOException, InterruptedException {
+    try {
+      new OggSeeker().getNextSeekPosition(1000, TestData.createInput(new byte[0], false));
+      fail();
+    } catch (IllegalStateException e) {
+      // ignored
+    }
+  }
+
+  public void testGetNextSeekPositionMatch() throws IOException, InterruptedException {
+    long targetGranule = 100000;
+    long headerGranule = 52001;
+    FakeExtractorInput input = TestData.createInput(TestUtil.joinByteArrays(
+        TestData.buildOggHeader(0x00, headerGranule, 22, 2),
+        TestUtil.createByteArray(54, 55) // laces
+    ), false);
+    long expectedPosition = -1;
+    assertGetNextSeekPosition(expectedPosition, targetGranule, input);
+  }
+
+  public void testGetNextSeekPositionTooHigh() throws IOException, InterruptedException {
+    long targetGranule = 100000;
+    long headerGranule = 200000;
+    FakeExtractorInput input = TestData.createInput(TestUtil.joinByteArrays(
+        TestData.buildOggHeader(0x00, headerGranule, 22, 2),
+        TestUtil.createByteArray(54, 55) // laces
+    ), false);
+    long doublePageSize = 2 * (input.getLength() + 54 + 55);
+    long expectedPosition = -doublePageSize + (targetGranule - headerGranule);
+    assertGetNextSeekPosition(expectedPosition, targetGranule, input);
+  }
+
+  public void testGetNextSeekPositionTooHighDistanceLower48000()
+      throws IOException, InterruptedException {
+    long targetGranule = 199999;
+    long headerGranule = 200000;
+    FakeExtractorInput input = TestData.createInput(TestUtil.joinByteArrays(
+        TestData.buildOggHeader(0x00, headerGranule, 22, 2),
+        TestUtil.createByteArray(54, 55) // laces
+    ), false);
+    long doublePageSize = 2 * (input.getLength() + 54 + 55);
+    long expectedPosition = -doublePageSize - 1;
+    assertGetNextSeekPosition(expectedPosition, targetGranule, input);
+  }
+
+  public void testGetNextSeekPositionTooLow() throws IOException, InterruptedException {
+    long headerGranule = 200000;
+    FakeExtractorInput input = TestData.createInput(TestUtil.joinByteArrays(
+        TestData.buildOggHeader(0x00, headerGranule, 22, 2),
+        TestUtil.createByteArray(54, 55) // laces
+    ), false);
+    long targetGranule = 300000;
+    long expectedPosition = -(27 + 2 + 54 + 55) + (targetGranule - headerGranule);
+    assertGetNextSeekPosition(expectedPosition, targetGranule, input);
+  }
+
+  private void assertGetNextSeekPosition(long expectedPosition, long targetGranule,
+      FakeExtractorInput input) throws IOException, InterruptedException {
+    while (true) {
+      try {
+        assertEquals(expectedPosition, oggSeeker.getNextSeekPosition(targetGranule, input));
+        break;
+      } catch (FakeExtractorInput.SimulatedIOException e) {
+        // ignored
+      }
+    }
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggUtilTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggUtilTest.java
new file mode 100644
index 0000000000..b5c4ae08e8
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggUtilTest.java
@@ -0,0 +1,190 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ogg;
+
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.testutil.FakeExtractorInput;
+import com.google.android.exoplayer.testutil.FakeExtractorInput.SimulatedIOException;
+import com.google.android.exoplayer.testutil.TestUtil;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import junit.framework.TestCase;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.Random;
+
+/**
+ * Unit test for {@link OggUtil}.
+ */
+public final class OggUtilTest extends TestCase {
+
+  private Random random = new Random(0);
+
+  public void testReadBits() throws Exception {
+    assertEquals(0, OggUtil.readBits((byte) 0x00, 2, 2));
+    assertEquals(1, OggUtil.readBits((byte) 0x02, 1, 1));
+    assertEquals(15, OggUtil.readBits((byte) 0xF0, 4, 4));
+    assertEquals(1, OggUtil.readBits((byte) 0x80, 1, 7));
+  }
+
+  public void testPopulatePageHeader() throws IOException, InterruptedException {
+    FakeExtractorInput input = TestData.createInput(TestUtil.joinByteArrays(
+        TestData.buildOggHeader(0x01, 123456, 4, 2),
+        TestUtil.createByteArray(2, 2)
+    ), true);
+    OggUtil.PageHeader header = new OggUtil.PageHeader();
+    ParsableByteArray byteArray = new ParsableByteArray(27 + 2);
+    populatePageHeader(input, header, byteArray, false);
+
+    assertEquals(0x01, header.type);
+    assertEquals(27 + 2, header.headerSize);
+    assertEquals(4, header.bodySize);
+    assertEquals(2, header.pageSegmentCount);
+    assertEquals(123456, header.granulePosition);
+    assertEquals(4, header.pageSequenceNumber);
+    assertEquals(0x1000, header.streamSerialNumber);
+    assertEquals(0x100000, header.pageChecksum);
+    assertEquals(0, header.revision);
+  }
+
+  public void testPopulatePageHeaderQuiteOnExceptionLessThan27Bytes()
+      throws IOException, InterruptedException {
+    FakeExtractorInput input = TestData.createInput(TestUtil.createByteArray(2, 2), false);
+    OggUtil.PageHeader header = new OggUtil.PageHeader();
+    ParsableByteArray byteArray = new ParsableByteArray(27 + 2);
+    assertFalse(populatePageHeader(input, header, byteArray, true));
+  }
+
+  public void testPopulatePageHeaderQuiteOnExceptionNotOgg()
+      throws IOException, InterruptedException {
+    byte[] headerBytes = TestUtil.joinByteArrays(
+        TestData.buildOggHeader(0x01, 123456, 4, 2),
+        TestUtil.createByteArray(2, 2)
+    );
+    // change from 'O' to 'o'
+    headerBytes[0] = 'o';
+    FakeExtractorInput input = TestData.createInput(headerBytes, false);
+    OggUtil.PageHeader header = new OggUtil.PageHeader();
+    ParsableByteArray byteArray = new ParsableByteArray(27 + 2);
+    assertFalse(populatePageHeader(input, header, byteArray, true));
+  }
+
+  public void testPopulatePageHeaderQuiteOnExceptionWrongRevision()
+      throws IOException, InterruptedException {
+    byte[] headerBytes = TestUtil.joinByteArrays(
+        TestData.buildOggHeader(0x01, 123456, 4, 2),
+        TestUtil.createByteArray(2, 2)
+    );
+    // change revision from 0 to 1
+    headerBytes[4] = 0x01;
+    FakeExtractorInput input = TestData.createInput(headerBytes, false);
+    OggUtil.PageHeader header = new OggUtil.PageHeader();
+    ParsableByteArray byteArray = new ParsableByteArray(27 + 2);
+    assertFalse(populatePageHeader(input, header, byteArray, true));
+  }
+
+  private boolean populatePageHeader(FakeExtractorInput input, OggUtil.PageHeader header,
+      ParsableByteArray byteArray, boolean quite) throws IOException, InterruptedException {
+    while (true) {
+      try {
+        return OggUtil.populatePageHeader(input, header, byteArray, quite);
+      } catch (SimulatedIOException e) {
+        // ignored
+      }
+    }
+  }
+
+  public void testSkipToNextPage() throws Exception {
+    FakeExtractorInput extractorInput = createInput(
+        TestUtil.joinByteArrays(
+            TestUtil.buildTestData(4000, random),
+            new byte[]{'O', 'g', 'g', 'S'},
+            TestUtil.buildTestData(4000, random)
+        ), false);
+    skipToNextPage(extractorInput);
+    assertEquals(4000, extractorInput.getPosition());
+  }
+
+  public void testSkipToNextPageUnbounded() throws Exception {
+    FakeExtractorInput extractorInput = createInput(
+        TestUtil.joinByteArrays(
+            TestUtil.buildTestData(4000, random),
+            new byte[]{'O', 'g', 'g', 'S'},
+            TestUtil.buildTestData(4000, random)
+        ), true);
+    skipToNextPage(extractorInput);
+    assertEquals(4000, extractorInput.getPosition());
+  }
+
+  public void testSkipToNextPageOverlap() throws Exception {
+    FakeExtractorInput extractorInput = createInput(
+        TestUtil.joinByteArrays(
+            TestUtil.buildTestData(2046, random),
+            new byte[]{'O', 'g', 'g', 'S'},
+            TestUtil.buildTestData(4000, random)
+        ), false);
+    skipToNextPage(extractorInput);
+    assertEquals(2046, extractorInput.getPosition());
+  }
+
+  public void testSkipToNextPageOverlapUnbounded() throws Exception {
+    FakeExtractorInput extractorInput = createInput(
+        TestUtil.joinByteArrays(
+            TestUtil.buildTestData(2046, random),
+            new byte[]{'O', 'g', 'g', 'S'},
+            TestUtil.buildTestData(4000, random)
+        ), true);
+    skipToNextPage(extractorInput);
+    assertEquals(2046, extractorInput.getPosition());
+  }
+
+  public void testSkipToNextPageInputShorterThanPeekLength() throws Exception {
+    FakeExtractorInput extractorInput = createInput(
+        TestUtil.joinByteArrays(
+            new byte[]{'x', 'O', 'g', 'g', 'S'}
+        ), false);
+    skipToNextPage(extractorInput);
+    assertEquals(1, extractorInput.getPosition());
+  }
+
+  public void testSkipToNextPageNoMatch() throws Exception {
+    FakeExtractorInput extractorInput = createInput(new byte[]{'g', 'g', 'S', 'O', 'g', 'g'},
+        false);
+    try {
+      skipToNextPage(extractorInput);
+      fail();
+    } catch (EOFException e) {
+      // expected
+    }
+  }
+
+  private static void skipToNextPage(ExtractorInput extractorInput)
+      throws IOException, InterruptedException {
+    while (true) {
+      try {
+        OggUtil.skipToNextPage(extractorInput);
+        break;
+      } catch (SimulatedIOException e) { /* ignored */ }
+    }
+  }
+
+  private static FakeExtractorInput createInput(byte[] data, boolean simulateUnknownLength) {
+    return new FakeExtractorInput.Builder().setData(data).setSimulateIOErrors(true)
+        .setSimulateUnknownLength(simulateUnknownLength).setSimulatePartialReads(true).build();
+  }
+}
+
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggVorbisExtractorTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggVorbisExtractorTest.java
new file mode 100644
index 0000000000..46f59200c3
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/OggVorbisExtractorTest.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ogg;
+
+import com.google.android.exoplayer.extractor.ogg.OggVorbisExtractor.VorbisSetup;
+import com.google.android.exoplayer.testutil.FakeExtractorInput;
+import com.google.android.exoplayer.testutil.FakeExtractorInput.SimulatedIOException;
+import com.google.android.exoplayer.testutil.TestUtil;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import junit.framework.TestCase;
+
+import java.io.IOException;
+
+/**
+ * Unit test for {@link OggVorbisExtractor}.
+ */
+public final class OggVorbisExtractorTest extends TestCase {
+
+  private OggVorbisExtractor extractor;
+  private ParsableByteArray scratch;
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    extractor = new OggVorbisExtractor();
+    scratch = new ParsableByteArray(new byte[255 * 255], 0);
+  }
+
+  public void testSniff() throws Exception {
+    byte[] data = TestUtil.joinByteArrays(
+        TestData.buildOggHeader(0x02, 0, 1000, 0x02),
+        TestUtil.createByteArray(120, 120),  // Laces
+        new byte[]{0x01, 'v', 'o', 'r', 'b', 'i', 's'});
+    assertTrue(sniff(createInput(data)));
+  }
+
+  public void testSniffFailsOpusFile() throws Exception {
+    byte[] data = TestUtil.joinByteArrays(
+        TestData.buildOggHeader(0x02, 0, 1000, 0x00),
+        new byte[]{'O', 'p', 'u', 's'});
+    assertFalse(sniff(createInput(data)));
+  }
+
+  public void testSniffFailsInvalidOggHeader() throws Exception {
+    byte[] data = TestData.buildOggHeader(0x00, 0, 1000, 0x00);
+    assertFalse(sniff(createInput(data)));
+  }
+
+  public void testSniffInvalidVorbisHeader() throws Exception {
+    byte[] data = TestUtil.joinByteArrays(
+        TestData.buildOggHeader(0x02, 0, 1000, 0x02),
+        TestUtil.createByteArray(120, 120),  // Laces
+        new byte[]{0x01, 'X', 'o', 'r', 'b', 'i', 's'});
+    assertFalse(sniff(createInput(data)));
+  }
+
+  public void testSniffFailsEOF() throws Exception {
+    byte[] data = TestData.buildOggHeader(0x02, 0, 1000, 0x00);
+    assertFalse(sniff(createInput(data)));
+  }
+
+  public void testAppendNumberOfSamples() throws Exception {
+    ParsableByteArray buffer = new ParsableByteArray(4);
+    buffer.setLimit(0);
+    OggVorbisExtractor.appendNumberOfSamples(buffer, 0x01234567);
+    assertEquals(4, buffer.limit());
+    assertEquals(0x67, buffer.data[0]);
+    assertEquals(0x45, buffer.data[1]);
+    assertEquals(0x23, buffer.data[2]);
+    assertEquals(0x01, buffer.data[3]);
+  }
+
+  public void testReadSetupHeadersWithIOExceptions() throws IOException, InterruptedException {
+    byte[] data = TestData.getVorbisHeaderPages();
+    OggVorbisExtractor.VorbisSetup vorbisSetup = readSetupHeaders(createInput(data));
+
+    assertNotNull(vorbisSetup.idHeader);
+    assertNotNull(vorbisSetup.commentHeader);
+    assertNotNull(vorbisSetup.setupHeaderData);
+    assertNotNull(vorbisSetup.modes);
+
+    assertEquals(45, vorbisSetup.commentHeader.length);
+    assertEquals(30, vorbisSetup.idHeader.data.length);
+    assertEquals(3597, vorbisSetup.setupHeaderData.length);
+
+    assertEquals(-1, vorbisSetup.idHeader.bitrateMax);
+    assertEquals(-1, vorbisSetup.idHeader.bitrateMin);
+    assertEquals(66666, vorbisSetup.idHeader.bitrateNominal);
+    assertEquals(512, vorbisSetup.idHeader.blockSize0);
+    assertEquals(1024, vorbisSetup.idHeader.blockSize1);
+    assertEquals(2, vorbisSetup.idHeader.channels);
+    assertTrue(vorbisSetup.idHeader.framingFlag);
+    assertEquals(22050, vorbisSetup.idHeader.sampleRate);
+    assertEquals(0, vorbisSetup.idHeader.version);
+
+    assertEquals("Xiph.Org libVorbis I 20030909", vorbisSetup.commentHeader.vendor);
+    assertEquals(1, vorbisSetup.iLogModes);
+
+    assertEquals(data[data.length - 1],
+        vorbisSetup.setupHeaderData[vorbisSetup.setupHeaderData.length - 1]);
+
+    assertFalse(vorbisSetup.modes[0].blockFlag);
+    assertTrue(vorbisSetup.modes[1].blockFlag);
+  }
+
+  private static FakeExtractorInput createInput(byte[] data) {
+    return new FakeExtractorInput.Builder().setData(data).setSimulateIOErrors(true)
+        .setSimulateUnknownLength(true).setSimulatePartialReads(true).build();
+  }
+
+  private boolean sniff(FakeExtractorInput input) throws InterruptedException, IOException {
+    while (true) {
+      try {
+        return extractor.sniff(input);
+      } catch (SimulatedIOException e) {
+        // Ignore.
+      }
+    }
+  }
+
+  private VorbisSetup readSetupHeaders(FakeExtractorInput input)
+      throws IOException, InterruptedException {
+    while (true) {
+      try {
+        return extractor.readSetupHeaders(input, scratch);
+      } catch (SimulatedIOException e) {
+        // Ignore.
+      }
+    }
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/TestData.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/TestData.java
new file mode 100644
index 0000000000..014438ee1f
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/TestData.java
@@ -0,0 +1,1076 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ogg;
+
+import com.google.android.exoplayer.testutil.FakeExtractorInput;
+import com.google.android.exoplayer.testutil.TestUtil;
+
+/**
+ * Provides ogg/vorbis test data in bytes for unit tests.
+ */
+/* package */ final class TestData {
+
+  /* package */ static FakeExtractorInput createInput(byte[] data, boolean simulateUnkownLength) {
+    return new FakeExtractorInput.Builder().setData(data).setSimulateIOErrors(true)
+        .setSimulateUnknownLength(simulateUnkownLength).setSimulatePartialReads(true).build();
+  }
+
+  public static byte[] buildOggHeader(int headerType, long granule, int pageSequenceCounter,
+      int pageSegmentCount) {
+    return TestUtil.createByteArray(
+        0x4F, 0x67, 0x67, 0x53, // Oggs.
+        0x00, // Stream revision.
+        headerType,
+        (int) (granule >> 0) & 0xFF,
+        (int) (granule >> 8) & 0xFF,
+        (int) (granule >> 16) & 0xFF,
+        (int) (granule >> 24) & 0xFF,
+        (int) (granule >> 32) & 0xFF,
+        (int) (granule >> 40) & 0xFF,
+        (int) (granule >> 48) & 0xFF,
+        (int) (granule >> 56) & 0xFF,
+        0x00, // LSB of data serial number.
+        0x10,
+        0x00,
+        0x00, // MSB of data serial number.
+        (pageSequenceCounter >> 0) & 0xFF,
+        (pageSequenceCounter >> 8) & 0xFF,
+        (pageSequenceCounter >> 16) & 0xFF,
+        (pageSequenceCounter >> 24) & 0xFF,
+        0x00, // LSB of page checksum.
+        0x00,
+        0x10,
+        0x00, // MSB of page checksum.
+        pageSegmentCount);
+  }
+
+  /**
+   * Returns the initial two pages of bytes which by spec contain the three vorbis header packets:
+   * identification, comment and setup header.
+   */
+  public static byte[] getVorbisHeaderPages() {
+    byte[] data = new byte[VORBIS_HEADER_PAGES.length];
+    System.arraycopy(VORBIS_HEADER_PAGES, 0, data, 0,
+        VORBIS_HEADER_PAGES.length);
+    return data;
+  }
+
+  /**
+   * Returns a valid vorbis identification header in bytes.
+   */
+  public static byte[] getIdentificationHeaderData() {
+    int idHeaderStart = 28;
+    int idHeaderLength = 30;
+    byte[] idHeaderData = new byte[idHeaderLength];
+    System.arraycopy(VORBIS_HEADER_PAGES, idHeaderStart, idHeaderData, 0, idHeaderLength);
+    return idHeaderData;
+  }
+
+  /**
+   * Returns a valid vorbis comment header with 3 comments including utf8 chars in bytes.
+   */
+  public static byte[] getCommentHeaderDataUTF8() {
+    byte[] commentHeaderData = new byte[COMMENT_HEADER_WITH_UTF8.length];
+    System.arraycopy(COMMENT_HEADER_WITH_UTF8, 0, commentHeaderData, 0,
+        COMMENT_HEADER_WITH_UTF8.length);
+    return commentHeaderData;
+  }
+
+  /**
+   * Returns a valid vorbis setup header in bytes.
+   */
+  public static byte[] getSetupHeaderData() {
+    int setupHeaderStart = 146;
+    int setupHeaderLength = VORBIS_HEADER_PAGES.length - setupHeaderStart;
+    byte[] setupHeaderData = new byte[setupHeaderLength];
+    System.arraycopy(VORBIS_HEADER_PAGES, setupHeaderStart, setupHeaderData, 0, setupHeaderLength);
+    return setupHeaderData;
+  }
+
+  private static final byte[] COMMENT_HEADER_WITH_UTF8 = {
+      (byte) 0x03, (byte) 0x76, (byte) 0x6f, (byte) 0x72, // 3, v, o, r,
+      (byte) 0x62, (byte) 0x69, (byte) 0x73, (byte) 0x2b, // b, i, s, .
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x58,
+      (byte) 0x69, (byte) 0x70, (byte) 0x68, (byte) 0x2e,
+      (byte) 0x4f, (byte) 0x72, (byte) 0x67, (byte) 0x20,
+      (byte) 0x6c, (byte) 0x69, (byte) 0x62, (byte) 0x56,
+      (byte) 0x6f, (byte) 0x72, (byte) 0x62, (byte) 0x69,
+      (byte) 0x73, (byte) 0x20, (byte) 0x49, (byte) 0x20,
+      (byte) 0x32, (byte) 0x30, (byte) 0x31, (byte) 0x32,
+      (byte) 0x30, (byte) 0x32, (byte) 0x30, (byte) 0x33,
+      (byte) 0x20, (byte) 0x28, (byte) 0x4f, (byte) 0x6d,
+      (byte) 0x6e, (byte) 0x69, (byte) 0x70, (byte) 0x72,
+      (byte) 0x65, (byte) 0x73, (byte) 0x65, (byte) 0x6e,
+      (byte) 0x74, (byte) 0x29, (byte) 0x03, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x0a, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0x4c,
+      (byte) 0x42, (byte) 0x55, (byte) 0x4d, (byte) 0x3d,
+      (byte) 0xc3, (byte) 0xa4, (byte) 0xc3, (byte) 0xb6,
+      (byte) 0x13, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x54, (byte) 0x49, (byte) 0x54, (byte) 0x4c,
+      (byte) 0x45, (byte) 0x3d, (byte) 0x41, (byte) 0x20,
+      (byte) 0x73, (byte) 0x61, (byte) 0x6d, (byte) 0x70,
+      (byte) 0x6c, (byte) 0x65, (byte) 0x20, (byte) 0x73,
+      (byte) 0x6f, (byte) 0x6e, (byte) 0x67, (byte) 0x0d,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41,
+      (byte) 0x52, (byte) 0x54, (byte) 0x49, (byte) 0x53,
+      (byte) 0x54, (byte) 0x3d, (byte) 0x47, (byte) 0x6f,
+      (byte) 0x6f, (byte) 0x67, (byte) 0x6c, (byte) 0x65,
+      (byte) 0x01
+  };
+
+  // two OGG pages with 3 packets (id, comment and setup header)
+  // length: 3743 bytes
+  private static final byte[] VORBIS_HEADER_PAGES = {     /* capture pattern ogg header 1 */
+      (byte) 0x4f, (byte) 0x67, (byte) 0x67, (byte) 0x53, // O,g,g,S  : start pos 0
+      (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x5e, (byte) 0x5f,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x83, (byte) 0x36,
+      (byte) 0xe3, (byte) 0x49, (byte) 0x01, (byte) 0x1e, /* capture pattern vorbis id header */
+      (byte) 0x01, (byte) 0x76, (byte) 0x6f, (byte) 0x72, // 1,v,o,r  : start pos 28
+      (byte) 0x62, (byte) 0x69, (byte) 0x73, (byte) 0x00, // b,i,s,.
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02,
+      (byte) 0x22, (byte) 0x56, (byte) 0x00, (byte) 0x00,
+      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+      (byte) 0x6a, (byte) 0x04, (byte) 0x01, (byte) 0x00,
+      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, /* capture pattern ogg header 2 */
+      (byte) 0xa9, (byte) 0x01, (byte) 0x4f, (byte) 0x67, // .,.,O,g  : start pos 86
+      (byte) 0x67, (byte) 0x53, (byte) 0x00, (byte) 0x00, // g,S,.,.
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x5e, (byte) 0x5f, (byte) 0x00, (byte) 0x00,
+      (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x69, (byte) 0xf8, (byte) 0xeb, (byte) 0xe1,
+      (byte) 0x10, (byte) 0x2d, (byte) 0xff, (byte) 0xff,
+      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, /* capture pattern vorbis comment header*/
+      (byte) 0x1b, (byte) 0x03, (byte) 0x76, (byte) 0x6f, // .,3,v,o  : start pos 101
+      (byte) 0x72, (byte) 0x62, (byte) 0x69, (byte) 0x73, // r,b,i,s
+      (byte) 0x1d, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x58, (byte) 0x69, (byte) 0x70, (byte) 0x68,
+      (byte) 0x2e, (byte) 0x4f, (byte) 0x72, (byte) 0x67,
+      (byte) 0x20, (byte) 0x6c, (byte) 0x69, (byte) 0x62,
+      (byte) 0x56, (byte) 0x6f, (byte) 0x72, (byte) 0x62,
+      (byte) 0x69, (byte) 0x73, (byte) 0x20, (byte) 0x49,
+      (byte) 0x20, (byte) 0x32, (byte) 0x30, (byte) 0x30,
+      (byte) 0x33, (byte) 0x30, (byte) 0x39, (byte) 0x30,
+      (byte) 0x39, (byte) 0x00, (byte) 0x00, (byte) 0x00, /* capture pattern vorbis setup header */
+      (byte) 0x00, (byte) 0x01, (byte) 0x05, (byte) 0x76, // .,.,5,v  : start pos 146
+      (byte) 0x6f, (byte) 0x72, (byte) 0x62, (byte) 0x69, // o,r,b,i
+      (byte) 0x73, (byte) 0x22, (byte) 0x42, (byte) 0x43, // s,.
+      (byte) 0x56, (byte) 0x01, (byte) 0x00, (byte) 0x40,
+      (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x42,
+      (byte) 0x10, (byte) 0x2a, (byte) 0x05, (byte) 0xad,
+      (byte) 0x63, (byte) 0x8e, (byte) 0x3a, (byte) 0xc8,
+      (byte) 0x15, (byte) 0x21, (byte) 0x8c, (byte) 0x19,
+      (byte) 0xa2, (byte) 0xa0, (byte) 0x42, (byte) 0xca,
+      (byte) 0x29, (byte) 0xc7, (byte) 0x1d, (byte) 0x42,
+      (byte) 0xd0, (byte) 0x21, (byte) 0xa3, (byte) 0x24,
+      (byte) 0x43, (byte) 0x88, (byte) 0x3a, (byte) 0xc6,
+      (byte) 0x35, (byte) 0xc7, (byte) 0x18, (byte) 0x63,
+      (byte) 0x47, (byte) 0xb9, (byte) 0x64, (byte) 0x8a,
+      (byte) 0x42, (byte) 0xc9, (byte) 0x81, (byte) 0xd0,
+      (byte) 0x90, (byte) 0x55, (byte) 0x00, (byte) 0x00,
+      (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0xa4,
+      (byte) 0x1c, (byte) 0x57, (byte) 0x50, (byte) 0x72,
+      (byte) 0x49, (byte) 0x2d, (byte) 0xe7, (byte) 0x9c,
+      (byte) 0x73, (byte) 0xa3, (byte) 0x18, (byte) 0x57,
+      (byte) 0xcc, (byte) 0x71, (byte) 0xe8, (byte) 0x20,
+      (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xe5,
+      (byte) 0x20, (byte) 0x67, (byte) 0xcc, (byte) 0x71,
+      (byte) 0x09, (byte) 0x25, (byte) 0xe7, (byte) 0x9c,
+      (byte) 0x73, (byte) 0x8e, (byte) 0x39, (byte) 0xe7,
+      (byte) 0x92, (byte) 0x72, (byte) 0x8e, (byte) 0x31,
+      (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xa3,
+      (byte) 0x18, (byte) 0x57, (byte) 0x0e, (byte) 0x72,
+      (byte) 0x29, (byte) 0x2d, (byte) 0xe7, (byte) 0x9c,
+      (byte) 0x73, (byte) 0x81, (byte) 0x14, (byte) 0x47,
+      (byte) 0x8a, (byte) 0x71, (byte) 0xa7, (byte) 0x18,
+      (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xa4,
+      (byte) 0x1c, (byte) 0x47, (byte) 0x8a, (byte) 0x71,
+      (byte) 0xa8, (byte) 0x18, (byte) 0xe7, (byte) 0x9c,
+      (byte) 0x73, (byte) 0x6d, (byte) 0x31, (byte) 0xb7,
+      (byte) 0x92, (byte) 0x72, (byte) 0xce, (byte) 0x39,
+      (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xe6,
+      (byte) 0x20, (byte) 0x87, (byte) 0x52, (byte) 0x72,
+      (byte) 0xae, (byte) 0x35, (byte) 0xe7, (byte) 0x9c,
+      (byte) 0x73, (byte) 0xa4, (byte) 0x18, (byte) 0x67,
+      (byte) 0x0e, (byte) 0x72, (byte) 0x0b, (byte) 0x25,
+      (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xc6,
+      (byte) 0x20, (byte) 0x67, (byte) 0xcc, (byte) 0x71,
+      (byte) 0xeb, (byte) 0x20, (byte) 0xe7, (byte) 0x9c,
+      (byte) 0x73, (byte) 0x8c, (byte) 0x35, (byte) 0xb7,
+      (byte) 0xd4, (byte) 0x72, (byte) 0xce, (byte) 0x39,
+      (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xce,
+      (byte) 0x39, (byte) 0xe7, (byte) 0x9c, (byte) 0x73,
+      (byte) 0xce, (byte) 0x39, (byte) 0xe7, (byte) 0x9c,
+      (byte) 0x73, (byte) 0x8c, (byte) 0x31, (byte) 0xe7,
+      (byte) 0x9c, (byte) 0x73, (byte) 0xce, (byte) 0x39,
+      (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0x6e,
+      (byte) 0x31, (byte) 0xe7, (byte) 0x16, (byte) 0x73,
+      (byte) 0xae, (byte) 0x39, (byte) 0xe7, (byte) 0x9c,
+      (byte) 0x73, (byte) 0xce, (byte) 0x39, (byte) 0xe7,
+      (byte) 0x1c, (byte) 0x73, (byte) 0xce, (byte) 0x39,
+      (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0x20,
+      (byte) 0x34, (byte) 0x64, (byte) 0x15, (byte) 0x00,
+      (byte) 0x90, (byte) 0x00, (byte) 0x00, (byte) 0xa0,
+      (byte) 0xa1, (byte) 0x28, (byte) 0x8a, (byte) 0xe2,
+      (byte) 0x28, (byte) 0x0e, (byte) 0x10, (byte) 0x1a,
+      (byte) 0xb2, (byte) 0x0a, (byte) 0x00, (byte) 0xc8,
+      (byte) 0x00, (byte) 0x00, (byte) 0x10, (byte) 0x40,
+      (byte) 0x71, (byte) 0x14, (byte) 0x47, (byte) 0x91,
+      (byte) 0x14, (byte) 0x4b, (byte) 0xb1, (byte) 0x1c,
+      (byte) 0xcb, (byte) 0xd1, (byte) 0x24, (byte) 0x0d,
+      (byte) 0x08, (byte) 0x0d, (byte) 0x59, (byte) 0x05,
+      (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
+      (byte) 0x08, (byte) 0x00, (byte) 0x00, (byte) 0xa0,
+      (byte) 0x48, (byte) 0x86, (byte) 0xa4, (byte) 0x48,
+      (byte) 0x8a, (byte) 0xa5, (byte) 0x58, (byte) 0x8e,
+      (byte) 0x66, (byte) 0x69, (byte) 0x9e, (byte) 0x26,
+      (byte) 0x7a, (byte) 0xa2, (byte) 0x28, (byte) 0x9a,
+      (byte) 0xa2, (byte) 0x2a, (byte) 0xab, (byte) 0xb2,
+      (byte) 0x69, (byte) 0xca, (byte) 0xb2, (byte) 0x2c,
+      (byte) 0xcb, (byte) 0xb2, (byte) 0xeb, (byte) 0xba,
+      (byte) 0x2e, (byte) 0x10, (byte) 0x1a, (byte) 0xb2,
+      (byte) 0x0a, (byte) 0x00, (byte) 0x48, (byte) 0x00,
+      (byte) 0x00, (byte) 0x50, (byte) 0x51, (byte) 0x14,
+      (byte) 0xc5, (byte) 0x70, (byte) 0x14, (byte) 0x07,
+      (byte) 0x08, (byte) 0x0d, (byte) 0x59, (byte) 0x05,
+      (byte) 0x00, (byte) 0x64, (byte) 0x00, (byte) 0x00,
+      (byte) 0x08, (byte) 0x60, (byte) 0x28, (byte) 0x8a,
+      (byte) 0xa3, (byte) 0x38, (byte) 0x8e, (byte) 0xe4,
+      (byte) 0x58, (byte) 0x92, (byte) 0xa5, (byte) 0x59,
+      (byte) 0x9e, (byte) 0x07, (byte) 0x84, (byte) 0x86,
+      (byte) 0xac, (byte) 0x02, (byte) 0x00, (byte) 0x80,
+      (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
+      (byte) 0x00, (byte) 0x50, (byte) 0x0c, (byte) 0x47,
+      (byte) 0xb1, (byte) 0x14, (byte) 0x4d, (byte) 0xf1,
+      (byte) 0x24, (byte) 0xcf, (byte) 0xf2, (byte) 0x3c,
+      (byte) 0xcf, (byte) 0xf3, (byte) 0x3c, (byte) 0xcf,
+      (byte) 0xf3, (byte) 0x3c, (byte) 0xcf, (byte) 0xf3,
+      (byte) 0x3c, (byte) 0xcf, (byte) 0xf3, (byte) 0x3c,
+      (byte) 0xcf, (byte) 0xf3, (byte) 0x3c, (byte) 0xcf,
+      (byte) 0xf3, (byte) 0x3c, (byte) 0x0d, (byte) 0x08,
+      (byte) 0x0d, (byte) 0x59, (byte) 0x05, (byte) 0x00,
+      (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x82, (byte) 0x28, (byte) 0x64, (byte) 0x18,
+      (byte) 0x03, (byte) 0x42, (byte) 0x43, (byte) 0x56,
+      (byte) 0x01, (byte) 0x00, (byte) 0x40, (byte) 0x00,
+      (byte) 0x00, (byte) 0x08, (byte) 0x21, (byte) 0x1a,
+      (byte) 0x19, (byte) 0x43, (byte) 0x9d, (byte) 0x52,
+      (byte) 0x12, (byte) 0x5c, (byte) 0x0a, (byte) 0x16,
+      (byte) 0x42, (byte) 0x1c, (byte) 0x11, (byte) 0x43,
+      (byte) 0x1d, (byte) 0x42, (byte) 0xce, (byte) 0x43,
+      (byte) 0xa9, (byte) 0xa5, (byte) 0x83, (byte) 0xe0,
+      (byte) 0x29, (byte) 0x85, (byte) 0x25, (byte) 0x63,
+      (byte) 0xd2, (byte) 0x53, (byte) 0xac, (byte) 0x41,
+      (byte) 0x08, (byte) 0x21, (byte) 0x7c, (byte) 0xef,
+      (byte) 0x3d, (byte) 0xf7, (byte) 0xde, (byte) 0x7b,
+      (byte) 0xef, (byte) 0x81, (byte) 0xd0, (byte) 0x90,
+      (byte) 0x55, (byte) 0x00, (byte) 0x00, (byte) 0x10,
+      (byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x14,
+      (byte) 0x38, (byte) 0x88, (byte) 0x81, (byte) 0xc7,
+      (byte) 0x24, (byte) 0x08, (byte) 0x21, (byte) 0x84,
+      (byte) 0x62, (byte) 0x14, (byte) 0x27, (byte) 0x44,
+      (byte) 0x71, (byte) 0xa6, (byte) 0x20, (byte) 0x08,
+      (byte) 0x21, (byte) 0x84, (byte) 0xe5, (byte) 0x24,
+      (byte) 0x58, (byte) 0xca, (byte) 0x79, (byte) 0xe8,
+      (byte) 0x24, (byte) 0x08, (byte) 0xdd, (byte) 0x83,
+      (byte) 0x10, (byte) 0x42, (byte) 0xb8, (byte) 0x9c,
+      (byte) 0x7b, (byte) 0xcb, (byte) 0xb9, (byte) 0xf7,
+      (byte) 0xde, (byte) 0x7b, (byte) 0x20, (byte) 0x34,
+      (byte) 0x64, (byte) 0x15, (byte) 0x00, (byte) 0x00,
+      (byte) 0x08, (byte) 0x00, (byte) 0xc0, (byte) 0x20,
+      (byte) 0x84, (byte) 0x10, (byte) 0x42, (byte) 0x08,
+      (byte) 0x21, (byte) 0x84, (byte) 0x10, (byte) 0x42,
+      (byte) 0x08, (byte) 0x29, (byte) 0xa4, (byte) 0x94,
+      (byte) 0x52, (byte) 0x48, (byte) 0x29, (byte) 0xa6,
+      (byte) 0x98, (byte) 0x62, (byte) 0x8a, (byte) 0x29,
+      (byte) 0xc7, (byte) 0x1c, (byte) 0x73, (byte) 0xcc,
+      (byte) 0x31, (byte) 0xc7, (byte) 0x20, (byte) 0x83,
+      (byte) 0x0c, (byte) 0x32, (byte) 0xe8, (byte) 0xa0,
+      (byte) 0x93, (byte) 0x4e, (byte) 0x3a, (byte) 0xc9,
+      (byte) 0xa4, (byte) 0x92, (byte) 0x4e, (byte) 0x3a,
+      (byte) 0xca, (byte) 0x24, (byte) 0xa3, (byte) 0x8e,
+      (byte) 0x52, (byte) 0x6b, (byte) 0x29, (byte) 0xb5,
+      (byte) 0x14, (byte) 0x53, (byte) 0x4c, (byte) 0xb1,
+      (byte) 0xe5, (byte) 0x16, (byte) 0x63, (byte) 0xad,
+      (byte) 0xb5, (byte) 0xd6, (byte) 0x9c, (byte) 0x73,
+      (byte) 0xaf, (byte) 0x41, (byte) 0x29, (byte) 0x63,
+      (byte) 0x8c, (byte) 0x31, (byte) 0xc6, (byte) 0x18,
+      (byte) 0x63, (byte) 0x8c, (byte) 0x31, (byte) 0xc6,
+      (byte) 0x18, (byte) 0x63, (byte) 0x8c, (byte) 0x31,
+      (byte) 0xc6, (byte) 0x18, (byte) 0x23, (byte) 0x08,
+      (byte) 0x0d, (byte) 0x59, (byte) 0x05, (byte) 0x00,
+      (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x10,
+      (byte) 0x06, (byte) 0x19, (byte) 0x64, (byte) 0x90,
+      (byte) 0x41, (byte) 0x08, (byte) 0x21, (byte) 0x84,
+      (byte) 0x14, (byte) 0x52, (byte) 0x48, (byte) 0x29,
+      (byte) 0xa6, (byte) 0x98, (byte) 0x72, (byte) 0xcc,
+      (byte) 0x31, (byte) 0xc7, (byte) 0x1c, (byte) 0x03,
+      (byte) 0x42, (byte) 0x43, (byte) 0x56, (byte) 0x01,
+      (byte) 0x00, (byte) 0x80, (byte) 0x00, (byte) 0x00,
+      (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x1c, (byte) 0x45, (byte) 0x52, (byte) 0x24,
+      (byte) 0x47, (byte) 0x72, (byte) 0x24, (byte) 0x47,
+      (byte) 0x92, (byte) 0x24, (byte) 0xc9, (byte) 0x92,
+      (byte) 0x2c, (byte) 0x49, (byte) 0x93, (byte) 0x3c,
+      (byte) 0xcb, (byte) 0xb3, (byte) 0x3c, (byte) 0xcb,
+      (byte) 0xb3, (byte) 0x3c, (byte) 0x4d, (byte) 0xd4,
+      (byte) 0x44, (byte) 0x4d, (byte) 0x15, (byte) 0x55,
+      (byte) 0xd5, (byte) 0x55, (byte) 0x6d, (byte) 0xd7,
+      (byte) 0xf6, (byte) 0x6d, (byte) 0x5f, (byte) 0xf6,
+      (byte) 0x6d, (byte) 0xdf, (byte) 0xd5, (byte) 0x65,
+      (byte) 0xdf, (byte) 0xf6, (byte) 0x65, (byte) 0xdb,
+      (byte) 0xd5, (byte) 0x65, (byte) 0x5d, (byte) 0x96,
+      (byte) 0x65, (byte) 0xdd, (byte) 0xb5, (byte) 0x6d,
+      (byte) 0x5d, (byte) 0xd6, (byte) 0x5d, (byte) 0x5d,
+      (byte) 0xd7, (byte) 0x75, (byte) 0x5d, (byte) 0xd7,
+      (byte) 0x75, (byte) 0x5d, (byte) 0xd7, (byte) 0x75,
+      (byte) 0x5d, (byte) 0xd7, (byte) 0x75, (byte) 0x5d,
+      (byte) 0xd7, (byte) 0x75, (byte) 0x5d, (byte) 0xd7,
+      (byte) 0x81, (byte) 0xd0, (byte) 0x90, (byte) 0x55,
+      (byte) 0x00, (byte) 0x80, (byte) 0x04, (byte) 0x00,
+      (byte) 0x80, (byte) 0x8e, (byte) 0xe4, (byte) 0x38,
+      (byte) 0x8e, (byte) 0xe4, (byte) 0x38, (byte) 0x8e,
+      (byte) 0xe4, (byte) 0x48, (byte) 0x8e, (byte) 0xa4,
+      (byte) 0x48, (byte) 0x0a, (byte) 0x10, (byte) 0x1a,
+      (byte) 0xb2, (byte) 0x0a, (byte) 0x00, (byte) 0x90,
+      (byte) 0x01, (byte) 0x00, (byte) 0x10, (byte) 0x00,
+      (byte) 0x80, (byte) 0xa3, (byte) 0x38, (byte) 0x8a,
+      (byte) 0xe3, (byte) 0x48, (byte) 0x8e, (byte) 0xe4,
+      (byte) 0x58, (byte) 0x8e, (byte) 0x25, (byte) 0x59,
+      (byte) 0x92, (byte) 0x26, (byte) 0x69, (byte) 0x96,
+      (byte) 0x67, (byte) 0x79, (byte) 0x96, (byte) 0xa7,
+      (byte) 0x79, (byte) 0x9a, (byte) 0xa8, (byte) 0x89,
+      (byte) 0x1e, (byte) 0x10, (byte) 0x1a, (byte) 0xb2,
+      (byte) 0x0a, (byte) 0x00, (byte) 0x00, (byte) 0x04,
+      (byte) 0x00, (byte) 0x10, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x80,
+      (byte) 0xa2, (byte) 0x28, (byte) 0x8a, (byte) 0xa3,
+      (byte) 0x38, (byte) 0x8e, (byte) 0x24, (byte) 0x59,
+      (byte) 0x96, (byte) 0xa6, (byte) 0x69, (byte) 0x9e,
+      (byte) 0xa7, (byte) 0x7a, (byte) 0xa2, (byte) 0x28,
+      (byte) 0x9a, (byte) 0xaa, (byte) 0xaa, (byte) 0x8a,
+      (byte) 0xa6, (byte) 0xa9, (byte) 0xaa, (byte) 0xaa,
+      (byte) 0x6a, (byte) 0x9a, (byte) 0xa6, (byte) 0x69,
+      (byte) 0x9a, (byte) 0xa6, (byte) 0x69, (byte) 0x9a,
+      (byte) 0xa6, (byte) 0x69, (byte) 0x9a, (byte) 0xa6,
+      (byte) 0x69, (byte) 0x9a, (byte) 0xa6, (byte) 0x69,
+      (byte) 0x9a, (byte) 0xa6, (byte) 0x69, (byte) 0x9a,
+      (byte) 0xa6, (byte) 0x69, (byte) 0x9a, (byte) 0xa6,
+      (byte) 0x69, (byte) 0x9a, (byte) 0xa6, (byte) 0x69,
+      (byte) 0x9a, (byte) 0xa6, (byte) 0x69, (byte) 0x9a,
+      (byte) 0xa6, (byte) 0x69, (byte) 0x02, (byte) 0xa1,
+      (byte) 0x21, (byte) 0xab, (byte) 0x00, (byte) 0x00,
+      (byte) 0x09, (byte) 0x00, (byte) 0x00, (byte) 0x1d,
+      (byte) 0xc7, (byte) 0x71, (byte) 0x1c, (byte) 0x47,
+      (byte) 0x71, (byte) 0x1c, (byte) 0xc7, (byte) 0x71,
+      (byte) 0x24, (byte) 0x47, (byte) 0x92, (byte) 0x24,
+      (byte) 0x20, (byte) 0x34, (byte) 0x64, (byte) 0x15,
+      (byte) 0x00, (byte) 0x20, (byte) 0x03, (byte) 0x00,
+      (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x43,
+      (byte) 0x51, (byte) 0x1c, (byte) 0x45, (byte) 0x72,
+      (byte) 0x2c, (byte) 0xc7, (byte) 0x92, (byte) 0x34,
+      (byte) 0x4b, (byte) 0xb3, (byte) 0x3c, (byte) 0xcb,
+      (byte) 0xd3, (byte) 0x44, (byte) 0xcf, (byte) 0xf4,
+      (byte) 0x5c, (byte) 0x51, (byte) 0x36, (byte) 0x75,
+      (byte) 0x53, (byte) 0x57, (byte) 0x6d, (byte) 0x20,
+      (byte) 0x34, (byte) 0x64, (byte) 0x15, (byte) 0x00,
+      (byte) 0x00, (byte) 0x08, (byte) 0x00, (byte) 0x20,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0xc7, (byte) 0x73,
+      (byte) 0x3c, (byte) 0xc7, (byte) 0x73, (byte) 0x3c,
+      (byte) 0xc9, (byte) 0x93, (byte) 0x3c, (byte) 0xcb,
+      (byte) 0x73, (byte) 0x3c, (byte) 0xc7, (byte) 0x93,
+      (byte) 0x3c, (byte) 0x49, (byte) 0xd3, (byte) 0x34,
+      (byte) 0x4d, (byte) 0xd3, (byte) 0x34, (byte) 0x4d,
+      (byte) 0xd3, (byte) 0x34, (byte) 0x4d, (byte) 0xd3,
+      (byte) 0x34, (byte) 0x4d, (byte) 0xd3, (byte) 0x34,
+      (byte) 0x4d, (byte) 0xd3, (byte) 0x34, (byte) 0x4d,
+      (byte) 0xd3, (byte) 0x34, (byte) 0x4d, (byte) 0xd3,
+      (byte) 0x34, (byte) 0x4d, (byte) 0xd3, (byte) 0x34,
+      (byte) 0x4d, (byte) 0xd3, (byte) 0x34, (byte) 0x4d,
+      (byte) 0xd3, (byte) 0x34, (byte) 0x4d, (byte) 0xd3,
+      (byte) 0x34, (byte) 0x4d, (byte) 0xd3, (byte) 0x34,
+      (byte) 0x4d, (byte) 0xd3, (byte) 0x34, (byte) 0x4d,
+      (byte) 0x03, (byte) 0x42, (byte) 0x43, (byte) 0x56,
+      (byte) 0x02, (byte) 0x00, (byte) 0x64, (byte) 0x00,
+      (byte) 0x00, (byte) 0x90, (byte) 0x02, (byte) 0xcf,
+      (byte) 0x42, (byte) 0x29, (byte) 0x2d, (byte) 0x46,
+      (byte) 0x02, (byte) 0x1c, (byte) 0x88, (byte) 0x98,
+      (byte) 0xa3, (byte) 0xd8, (byte) 0x7b, (byte) 0xef,
+      (byte) 0xbd, (byte) 0xf7, (byte) 0xde, (byte) 0x7b,
+      (byte) 0x65, (byte) 0x3c, (byte) 0x92, (byte) 0x88,
+      (byte) 0x49, (byte) 0xed, (byte) 0x31, (byte) 0xf4,
+      (byte) 0xd4, (byte) 0x31, (byte) 0x07, (byte) 0xb1,
+      (byte) 0x67, (byte) 0xc6, (byte) 0x23, (byte) 0x66,
+      (byte) 0x94, (byte) 0xa3, (byte) 0xd8, (byte) 0x29,
+      (byte) 0xcf, (byte) 0x1c, (byte) 0x42, (byte) 0x0c,
+      (byte) 0x62, (byte) 0xe8, (byte) 0x3c, (byte) 0x74,
+      (byte) 0x4a, (byte) 0x31, (byte) 0x88, (byte) 0x29,
+      (byte) 0xf5, (byte) 0x52, (byte) 0x32, (byte) 0xc6,
+      (byte) 0x20, (byte) 0xc6, (byte) 0xd8, (byte) 0x63,
+      (byte) 0x0c, (byte) 0x21, (byte) 0x94, (byte) 0x18,
+      (byte) 0x08, (byte) 0x0d, (byte) 0x59, (byte) 0x21,
+      (byte) 0x00, (byte) 0x84, (byte) 0x66, (byte) 0x00,
+      (byte) 0x18, (byte) 0x24, (byte) 0x09, (byte) 0x90,
+      (byte) 0x34, (byte) 0x0d, (byte) 0x90, (byte) 0x34,
+      (byte) 0x0d, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x24, (byte) 0x4f, (byte) 0x03, (byte) 0x34,
+      (byte) 0x51, (byte) 0x04, (byte) 0x34, (byte) 0x4f,
+      (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x49, (byte) 0xf3, (byte) 0x00, (byte) 0x4d,
+      (byte) 0xf4, (byte) 0x00, (byte) 0x4d, (byte) 0x14,
+      (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x90, (byte) 0x3c, (byte) 0x0d, (byte) 0xf0,
+      (byte) 0x44, (byte) 0x11, (byte) 0xd0, (byte) 0x44,
+      (byte) 0x11, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x34, (byte) 0x51, (byte) 0x04, (byte) 0x44,
+      (byte) 0x51, (byte) 0x05, (byte) 0x44, (byte) 0xd5,
+      (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x4d, (byte) 0x14, (byte) 0x01, (byte) 0x4f,
+      (byte) 0x15, (byte) 0x01, (byte) 0xd1, (byte) 0x54,
+      (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x90, (byte) 0x34, (byte) 0x0f, (byte) 0xd0,
+      (byte) 0x44, (byte) 0x11, (byte) 0xf0, (byte) 0x44,
+      (byte) 0x11, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x34, (byte) 0x51, (byte) 0x04, (byte) 0x44,
+      (byte) 0xd5, (byte) 0x04, (byte) 0x3c, (byte) 0x51,
+      (byte) 0x05, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x4d, (byte) 0x14, (byte) 0x01, (byte) 0xd1,
+      (byte) 0x54, (byte) 0x01, (byte) 0x51, (byte) 0x15,
+      (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04,
+      (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x38,
+      (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x58,
+      (byte) 0x08, (byte) 0x85, (byte) 0x86, (byte) 0xac,
+      (byte) 0x08, (byte) 0x00, (byte) 0xe2, (byte) 0x04,
+      (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x10,
+      (byte) 0x00, (byte) 0x00, (byte) 0x30, (byte) 0xe0,
+      (byte) 0x00, (byte) 0x00, (byte) 0x10, (byte) 0x60,
+      (byte) 0x42, (byte) 0x19, (byte) 0x28, (byte) 0x34,
+      (byte) 0x64, (byte) 0x45, (byte) 0x00, (byte) 0x10,
+      (byte) 0x27, (byte) 0x00, (byte) 0x60, (byte) 0x70,
+      (byte) 0x1c, (byte) 0xcb, (byte) 0x02, (byte) 0x00,
+      (byte) 0x00, (byte) 0x47, (byte) 0x92, (byte) 0x34,
+      (byte) 0x0d, (byte) 0x00, (byte) 0x00, (byte) 0x1c,
+      (byte) 0x49, (byte) 0xd2, (byte) 0x34, (byte) 0x00,
+      (byte) 0x00, (byte) 0xd0, (byte) 0x34, (byte) 0x4d,
+      (byte) 0x14, (byte) 0x01, (byte) 0x00, (byte) 0xc0,
+      (byte) 0xd2, (byte) 0x34, (byte) 0x51, (byte) 0x04,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x10, (byte) 0x00, (byte) 0x00, (byte) 0x30,
+      (byte) 0xe0, (byte) 0x00, (byte) 0x00, (byte) 0x10,
+      (byte) 0x60, (byte) 0x42, (byte) 0x19, (byte) 0x28,
+      (byte) 0x34, (byte) 0x64, (byte) 0x25, (byte) 0x00,
+      (byte) 0x10, (byte) 0x05, (byte) 0x00, (byte) 0x60,
+      (byte) 0x30, (byte) 0x14, (byte) 0x4d, (byte) 0x03,
+      (byte) 0x58, (byte) 0x16, (byte) 0xc0, (byte) 0xb2,
+      (byte) 0x00, (byte) 0x9a, (byte) 0x06, (byte) 0xd0,
+      (byte) 0x34, (byte) 0x80, (byte) 0xe7, (byte) 0x01,
+      (byte) 0x3c, (byte) 0x11, (byte) 0x60, (byte) 0x9a,
+      (byte) 0x00, (byte) 0x40, (byte) 0x00, (byte) 0x00,
+      (byte) 0x40, (byte) 0x81, (byte) 0x03, (byte) 0x00,
+      (byte) 0x40, (byte) 0x80, (byte) 0x0d, (byte) 0x9a,
+      (byte) 0x12, (byte) 0x8b, (byte) 0x03, (byte) 0x14,
+      (byte) 0x1a, (byte) 0xb2, (byte) 0x12, (byte) 0x00,
+      (byte) 0x88, (byte) 0x02, (byte) 0x00, (byte) 0x30,
+      (byte) 0x28, (byte) 0x8a, (byte) 0x24, (byte) 0x59,
+      (byte) 0x96, (byte) 0xe7, (byte) 0x41, (byte) 0xd3,
+      (byte) 0x34, (byte) 0x4d, (byte) 0x14, (byte) 0xa1,
+      (byte) 0x69, (byte) 0x9a, (byte) 0x26, (byte) 0x8a,
+      (byte) 0xf0, (byte) 0x3c, (byte) 0xcf, (byte) 0x13,
+      (byte) 0x45, (byte) 0x78, (byte) 0x9e, (byte) 0xe7,
+      (byte) 0x99, (byte) 0x26, (byte) 0x44, (byte) 0xd1,
+      (byte) 0xf3, (byte) 0x4c, (byte) 0x13, (byte) 0xa2,
+      (byte) 0xe8, (byte) 0x79, (byte) 0xa6, (byte) 0x09,
+      (byte) 0xd3, (byte) 0x14, (byte) 0x45, (byte) 0xd3,
+      (byte) 0x04, (byte) 0xa2, (byte) 0x68, (byte) 0x9a,
+      (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x0a,
+      (byte) 0x1c, (byte) 0x00, (byte) 0x00, (byte) 0x02,
+      (byte) 0x6c, (byte) 0xd0, (byte) 0x94, (byte) 0x58,
+      (byte) 0x1c, (byte) 0xa0, (byte) 0xd0, (byte) 0x90,
+      (byte) 0x95, (byte) 0x00, (byte) 0x40, (byte) 0x48,
+      (byte) 0x00, (byte) 0x80, (byte) 0x41, (byte) 0x51,
+      (byte) 0x2c, (byte) 0xcb, (byte) 0xf3, (byte) 0x44,
+      (byte) 0x51, (byte) 0x14, (byte) 0x4d, (byte) 0x53,
+      (byte) 0x55, (byte) 0x5d, (byte) 0x17, (byte) 0x9a,
+      (byte) 0xe6, (byte) 0x79, (byte) 0xa2, (byte) 0x28,
+      (byte) 0x8a, (byte) 0xa6, (byte) 0xa9, (byte) 0xaa,
+      (byte) 0xae, (byte) 0x0b, (byte) 0x4d, (byte) 0xf3,
+      (byte) 0x3c, (byte) 0x51, (byte) 0x14, (byte) 0x45,
+      (byte) 0xd3, (byte) 0x54, (byte) 0x55, (byte) 0xd7,
+      (byte) 0x85, (byte) 0xe7, (byte) 0x79, (byte) 0xa2,
+      (byte) 0x29, (byte) 0x9a, (byte) 0xa6, (byte) 0x69,
+      (byte) 0xaa, (byte) 0xaa, (byte) 0xeb, (byte) 0xc2,
+      (byte) 0xf3, (byte) 0x44, (byte) 0xd1, (byte) 0x34,
+      (byte) 0x4d, (byte) 0x53, (byte) 0x55, (byte) 0x55,
+      (byte) 0xd7, (byte) 0x75, (byte) 0xe1, (byte) 0x79,
+      (byte) 0xa2, (byte) 0x68, (byte) 0x9a, (byte) 0xa6,
+      (byte) 0xa9, (byte) 0xaa, (byte) 0xae, (byte) 0xeb,
+      (byte) 0xba, (byte) 0xf0, (byte) 0x3c, (byte) 0x51,
+      (byte) 0x34, (byte) 0x4d, (byte) 0xd3, (byte) 0x54,
+      (byte) 0x55, (byte) 0xd7, (byte) 0x95, (byte) 0x65,
+      (byte) 0x88, (byte) 0xa2, (byte) 0x28, (byte) 0x9a,
+      (byte) 0xa6, (byte) 0x69, (byte) 0xaa, (byte) 0xaa,
+      (byte) 0xeb, (byte) 0xca, (byte) 0x32, (byte) 0x10,
+      (byte) 0x45, (byte) 0xd3, (byte) 0x34, (byte) 0x4d,
+      (byte) 0x55, (byte) 0x75, (byte) 0x5d, (byte) 0x59,
+      (byte) 0x06, (byte) 0xa2, (byte) 0x68, (byte) 0x9a,
+      (byte) 0xaa, (byte) 0xea, (byte) 0xba, (byte) 0xae,
+      (byte) 0x2b, (byte) 0xcb, (byte) 0x40, (byte) 0x14,
+      (byte) 0x4d, (byte) 0x53, (byte) 0x55, (byte) 0x5d,
+      (byte) 0xd7, (byte) 0x75, (byte) 0x65, (byte) 0x19,
+      (byte) 0x98, (byte) 0xa6, (byte) 0x6a, (byte) 0xaa,
+      (byte) 0xaa, (byte) 0xeb, (byte) 0xca, (byte) 0xb2,
+      (byte) 0x2c, (byte) 0x03, (byte) 0x4c, (byte) 0x53,
+      (byte) 0x55, (byte) 0x5d, (byte) 0x57, (byte) 0x96,
+      (byte) 0x65, (byte) 0x19, (byte) 0xa0, (byte) 0xaa,
+      (byte) 0xae, (byte) 0xeb, (byte) 0xba, (byte) 0xb2,
+      (byte) 0x6c, (byte) 0xdb, (byte) 0x00, (byte) 0x55,
+      (byte) 0x75, (byte) 0x5d, (byte) 0xd7, (byte) 0x95,
+      (byte) 0x65, (byte) 0xdb, (byte) 0x06, (byte) 0xb8,
+      (byte) 0xae, (byte) 0xeb, (byte) 0xca, (byte) 0xb2,
+      (byte) 0x2c, (byte) 0xdb, (byte) 0x36, (byte) 0x00,
+      (byte) 0xd7, (byte) 0x95, (byte) 0x65, (byte) 0x59,
+      (byte) 0xb6, (byte) 0x6d, (byte) 0x01, (byte) 0x00,
+      (byte) 0x00, (byte) 0x07, (byte) 0x0e, (byte) 0x00,
+      (byte) 0x00, (byte) 0x01, (byte) 0x46, (byte) 0xd0,
+      (byte) 0x49, (byte) 0x46, (byte) 0x95, (byte) 0x45,
+      (byte) 0xd8, (byte) 0x68, (byte) 0xc2, (byte) 0x85,
+      (byte) 0x07, (byte) 0xa0, (byte) 0xd0, (byte) 0x90,
+      (byte) 0x15, (byte) 0x01, (byte) 0x40, (byte) 0x14,
+      (byte) 0x00, (byte) 0x00, (byte) 0x60, (byte) 0x8c,
+      (byte) 0x52, (byte) 0x8a, (byte) 0x29, (byte) 0x65,
+      (byte) 0x18, (byte) 0x93, (byte) 0x50, (byte) 0x4a,
+      (byte) 0x09, (byte) 0x0d, (byte) 0x63, (byte) 0x52,
+      (byte) 0x4a, (byte) 0x2a, (byte) 0xa5, (byte) 0x92,
+      (byte) 0x92, (byte) 0x52, (byte) 0x4a, (byte) 0xa5,
+      (byte) 0x54, (byte) 0x12, (byte) 0x52, (byte) 0x4a,
+      (byte) 0xa9, (byte) 0x94, (byte) 0x4a, (byte) 0x4a,
+      (byte) 0x4a, (byte) 0x29, (byte) 0x95, (byte) 0x92,
+      (byte) 0x51, (byte) 0x4a, (byte) 0x29, (byte) 0xb5,
+      (byte) 0x96, (byte) 0x2a, (byte) 0x29, (byte) 0xa9,
+      (byte) 0x94, (byte) 0x94, (byte) 0x52, (byte) 0x25,
+      (byte) 0xa5, (byte) 0xa4, (byte) 0x92, (byte) 0x52,
+      (byte) 0x2a, (byte) 0x00, (byte) 0x00, (byte) 0xec,
+      (byte) 0xc0, (byte) 0x01, (byte) 0x00, (byte) 0xec,
+      (byte) 0xc0, (byte) 0x42, (byte) 0x28, (byte) 0x34,
+      (byte) 0x64, (byte) 0x25, (byte) 0x00, (byte) 0x90,
+      (byte) 0x07, (byte) 0x00, (byte) 0x40, (byte) 0x10,
+      (byte) 0x82, (byte) 0x14, (byte) 0x63, (byte) 0x8c,
+      (byte) 0x39, (byte) 0x27, (byte) 0xa5, (byte) 0x54,
+      (byte) 0x8a, (byte) 0x31, (byte) 0xe7, (byte) 0x9c,
+      (byte) 0x93, (byte) 0x52, (byte) 0x2a, (byte) 0xc5,
+      (byte) 0x98, (byte) 0x73, (byte) 0xce, (byte) 0x49,
+      (byte) 0x29, (byte) 0x19, (byte) 0x63, (byte) 0xcc,
+      (byte) 0x39, (byte) 0xe7, (byte) 0xa4, (byte) 0x94,
+      (byte) 0x8c, (byte) 0x31, (byte) 0xe6, (byte) 0x9c,
+      (byte) 0x73, (byte) 0x52, (byte) 0x4a, (byte) 0xc6,
+      (byte) 0x9c, (byte) 0x73, (byte) 0xce, (byte) 0x39,
+      (byte) 0x29, (byte) 0x25, (byte) 0x63, (byte) 0xce,
+      (byte) 0x39, (byte) 0xe7, (byte) 0x9c, (byte) 0x94,
+      (byte) 0xd2, (byte) 0x39, (byte) 0xe7, (byte) 0x9c,
+      (byte) 0x83, (byte) 0x50, (byte) 0x4a, (byte) 0x29,
+      (byte) 0xa5, (byte) 0x73, (byte) 0xce, (byte) 0x41,
+      (byte) 0x28, (byte) 0xa5, (byte) 0x94, (byte) 0x12,
+      (byte) 0x42, (byte) 0xe7, (byte) 0x20, (byte) 0x94,
+      (byte) 0x52, (byte) 0x4a, (byte) 0xe9, (byte) 0x9c,
+      (byte) 0x73, (byte) 0x10, (byte) 0x0a, (byte) 0x00,
+      (byte) 0x00, (byte) 0x2a, (byte) 0x70, (byte) 0x00,
+      (byte) 0x00, (byte) 0x08, (byte) 0xb0, (byte) 0x51,
+      (byte) 0x64, (byte) 0x73, (byte) 0x82, (byte) 0x91,
+      (byte) 0xa0, (byte) 0x42, (byte) 0x43, (byte) 0x56,
+      (byte) 0x02, (byte) 0x00, (byte) 0xa9, (byte) 0x00,
+      (byte) 0x00, (byte) 0x06, (byte) 0xc7, (byte) 0xb1,
+      (byte) 0x2c, (byte) 0x4d, (byte) 0xd3, (byte) 0x34,
+      (byte) 0xcf, (byte) 0x13, (byte) 0x45, (byte) 0x4b,
+      (byte) 0x92, (byte) 0x34, (byte) 0xcf, (byte) 0x13,
+      (byte) 0x3d, (byte) 0x4f, (byte) 0x14, (byte) 0x4d,
+      (byte) 0xd5, (byte) 0x92, (byte) 0x24, (byte) 0xcf,
+      (byte) 0x13, (byte) 0x45, (byte) 0xcf, (byte) 0x13,
+      (byte) 0x4d, (byte) 0x53, (byte) 0xe5, (byte) 0x79,
+      (byte) 0x9e, (byte) 0x28, (byte) 0x8a, (byte) 0xa2,
+      (byte) 0x68, (byte) 0x9a, (byte) 0xaa, (byte) 0x4a,
+      (byte) 0x14, (byte) 0x45, (byte) 0x4f, (byte) 0x14,
+      (byte) 0x45, (byte) 0xd1, (byte) 0x34, (byte) 0x55,
+      (byte) 0x95, (byte) 0x2c, (byte) 0x8b, (byte) 0xa2,
+      (byte) 0x69, (byte) 0x9a, (byte) 0xa6, (byte) 0xaa,
+      (byte) 0xba, (byte) 0x2e, (byte) 0x5b, (byte) 0x16,
+      (byte) 0x45, (byte) 0xd3, (byte) 0x34, (byte) 0x4d,
+      (byte) 0x55, (byte) 0x75, (byte) 0x5d, (byte) 0x98,
+      (byte) 0xa6, (byte) 0x28, (byte) 0xaa, (byte) 0xaa,
+      (byte) 0xeb, (byte) 0xca, (byte) 0x2e, (byte) 0x4c,
+      (byte) 0x53, (byte) 0x14, (byte) 0x4d, (byte) 0xd3,
+      (byte) 0x75, (byte) 0x65, (byte) 0x19, (byte) 0xb2,
+      (byte) 0xad, (byte) 0x9a, (byte) 0xaa, (byte) 0xea,
+      (byte) 0xba, (byte) 0xb2, (byte) 0x0d, (byte) 0xdb,
+      (byte) 0x36, (byte) 0x4d, (byte) 0x55, (byte) 0x75,
+      (byte) 0x5d, (byte) 0x59, (byte) 0x06, (byte) 0xae,
+      (byte) 0xeb, (byte) 0xba, (byte) 0xb2, (byte) 0x6c,
+      (byte) 0xeb, (byte) 0xc0, (byte) 0x75, (byte) 0x5d,
+      (byte) 0x57, (byte) 0x96, (byte) 0x6d, (byte) 0x5d,
+      (byte) 0x00, (byte) 0x00, (byte) 0x78, (byte) 0x82,
+      (byte) 0x03, (byte) 0x00, (byte) 0x50, (byte) 0x81,
+      (byte) 0x0d, (byte) 0xab, (byte) 0x23, (byte) 0x9c,
+      (byte) 0x14, (byte) 0x8d, (byte) 0x05, (byte) 0x16,
+      (byte) 0x1a, (byte) 0xb2, (byte) 0x12, (byte) 0x00,
+      (byte) 0xc8, (byte) 0x00, (byte) 0x00, (byte) 0x20,
+      (byte) 0x08, (byte) 0x41, (byte) 0x48, (byte) 0x29,
+      (byte) 0x85, (byte) 0x90, (byte) 0x52, (byte) 0x0a,
+      (byte) 0x21, (byte) 0xa5, (byte) 0x14, (byte) 0x42,
+      (byte) 0x4a, (byte) 0x29, (byte) 0x84, (byte) 0x04,
+      (byte) 0x00, (byte) 0x00, (byte) 0x0c, (byte) 0x38,
+      (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x98,
+      (byte) 0x50, (byte) 0x06, (byte) 0x0a, (byte) 0x0d,
+      (byte) 0x59, (byte) 0x09, (byte) 0x00, (byte) 0xa4,
+      (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x10,
+      (byte) 0x42, (byte) 0x08, (byte) 0x21, (byte) 0x84,
+      (byte) 0x10, (byte) 0x42, (byte) 0x08, (byte) 0x21,
+      (byte) 0x84, (byte) 0x10, (byte) 0x42, (byte) 0x08,
+      (byte) 0x21, (byte) 0x84, (byte) 0x10, (byte) 0x42,
+      (byte) 0x08, (byte) 0x21, (byte) 0x84, (byte) 0x10,
+      (byte) 0x42, (byte) 0x08, (byte) 0x21, (byte) 0x84,
+      (byte) 0x10, (byte) 0x42, (byte) 0x08, (byte) 0x21,
+      (byte) 0x84, (byte) 0x10, (byte) 0x42, (byte) 0x08,
+      (byte) 0x21, (byte) 0x84, (byte) 0x10, (byte) 0x42,
+      (byte) 0x08, (byte) 0x21, (byte) 0x84, (byte) 0x10,
+      (byte) 0x42, (byte) 0x08, (byte) 0x21, (byte) 0x84,
+      (byte) 0x10, (byte) 0x42, (byte) 0x08, (byte) 0x21,
+      (byte) 0x84, (byte) 0xce, (byte) 0x39, (byte) 0xe7,
+      (byte) 0x9c, (byte) 0x73, (byte) 0xce, (byte) 0x39,
+      (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xce,
+      (byte) 0x39, (byte) 0xe7, (byte) 0x9c, (byte) 0x73,
+      (byte) 0xce, (byte) 0x39, (byte) 0xe7, (byte) 0x9c,
+      (byte) 0x73, (byte) 0xce, (byte) 0x39, (byte) 0xe7,
+      (byte) 0x9c, (byte) 0x73, (byte) 0xce, (byte) 0x39,
+      (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xce,
+      (byte) 0x39, (byte) 0xe7, (byte) 0x9c, (byte) 0x73,
+      (byte) 0xce, (byte) 0x39, (byte) 0xe7, (byte) 0x9c,
+      (byte) 0x73, (byte) 0xce, (byte) 0x39, (byte) 0xe7,
+      (byte) 0x9c, (byte) 0x73, (byte) 0xce, (byte) 0x39,
+      (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xce,
+      (byte) 0x39, (byte) 0xe7, (byte) 0x9c, (byte) 0x73,
+      (byte) 0x02, (byte) 0x00, (byte) 0xb1, (byte) 0x2b,
+      (byte) 0x1c, (byte) 0x00, (byte) 0x76, (byte) 0x22,
+      (byte) 0x6c, (byte) 0x58, (byte) 0x1d, (byte) 0xe1,
+      (byte) 0xa4, (byte) 0x68, (byte) 0x2c, (byte) 0xb0,
+      (byte) 0xd0, (byte) 0x90, (byte) 0x95, (byte) 0x00,
+      (byte) 0x40, (byte) 0x38, (byte) 0x00, (byte) 0x00,
+      (byte) 0x60, (byte) 0x8c, (byte) 0x31, (byte) 0xce,
+      (byte) 0x59, (byte) 0xac, (byte) 0xb5, (byte) 0xd6,
+      (byte) 0x5a, (byte) 0x2b, (byte) 0xa5, (byte) 0x94,
+      (byte) 0x92, (byte) 0x50, (byte) 0x6b, (byte) 0xad,
+      (byte) 0xb5, (byte) 0xd6, (byte) 0x9a, (byte) 0x29,
+      (byte) 0xa4, (byte) 0x94, (byte) 0x84, (byte) 0x16,
+      (byte) 0x63, (byte) 0x8c, (byte) 0x31, (byte) 0xc6,
+      (byte) 0x98, (byte) 0x31, (byte) 0x08, (byte) 0x29,
+      (byte) 0xb5, (byte) 0x18, (byte) 0x63, (byte) 0x8c,
+      (byte) 0x31, (byte) 0xc6, (byte) 0x8c, (byte) 0x39,
+      (byte) 0x47, (byte) 0x2d, (byte) 0xc6, (byte) 0x18,
+      (byte) 0x63, (byte) 0x8c, (byte) 0x31, (byte) 0xb6,
+      (byte) 0x56, (byte) 0x4a, (byte) 0x6c, (byte) 0x31,
+      (byte) 0xc6, (byte) 0x18, (byte) 0x63, (byte) 0x8c,
+      (byte) 0xb1, (byte) 0xb5, (byte) 0x52, (byte) 0x62,
+      (byte) 0x8c, (byte) 0x31, (byte) 0xc6, (byte) 0x18,
+      (byte) 0x63, (byte) 0x8c, (byte) 0x31, (byte) 0xc6,
+      (byte) 0x16, (byte) 0x5b, (byte) 0x8c, (byte) 0x31,
+      (byte) 0xc6, (byte) 0x18, (byte) 0x63, (byte) 0x8c,
+      (byte) 0x31, (byte) 0xb6, (byte) 0x18, (byte) 0x63,
+      (byte) 0x8c, (byte) 0x31, (byte) 0xc6, (byte) 0x18,
+      (byte) 0x63, (byte) 0x8c, (byte) 0x31, (byte) 0xc6,
+      (byte) 0x18, (byte) 0x63, (byte) 0x8c, (byte) 0x31,
+      (byte) 0xc6, (byte) 0x18, (byte) 0x63, (byte) 0x8c,
+      (byte) 0x31, (byte) 0xb6, (byte) 0x18, (byte) 0x63,
+      (byte) 0x8c, (byte) 0x31, (byte) 0xc6, (byte) 0x18,
+      (byte) 0x63, (byte) 0x8c, (byte) 0x31, (byte) 0xc6,
+      (byte) 0x18, (byte) 0x63, (byte) 0x8c, (byte) 0x31,
+      (byte) 0xc6, (byte) 0x18, (byte) 0x63, (byte) 0x8c,
+      (byte) 0x31, (byte) 0xc6, (byte) 0x18, (byte) 0x63,
+      (byte) 0x8c, (byte) 0x31, (byte) 0xc6, (byte) 0x18,
+      (byte) 0x63, (byte) 0x6c, (byte) 0x31, (byte) 0xc6,
+      (byte) 0x18, (byte) 0x63, (byte) 0x8c, (byte) 0x31,
+      (byte) 0xc6, (byte) 0x18, (byte) 0x63, (byte) 0x8c,
+      (byte) 0x31, (byte) 0xc6, (byte) 0x18, (byte) 0x63,
+      (byte) 0x2c, (byte) 0x00, (byte) 0xc0, (byte) 0xe4,
+      (byte) 0xc1, (byte) 0x01, (byte) 0x00, (byte) 0x2a,
+      (byte) 0xc1, (byte) 0xc6, (byte) 0x19, (byte) 0x56,
+      (byte) 0x92, (byte) 0xce, (byte) 0x0a, (byte) 0x47,
+      (byte) 0x83, (byte) 0x0b, (byte) 0x0d, (byte) 0x59,
+      (byte) 0x09, (byte) 0x00, (byte) 0xe4, (byte) 0x06,
+      (byte) 0x00, (byte) 0x00, (byte) 0xc6, (byte) 0x28,
+      (byte) 0xc5, (byte) 0x98, (byte) 0x63, (byte) 0xce,
+      (byte) 0x41, (byte) 0x08, (byte) 0xa1, (byte) 0x94,
+      (byte) 0x12, (byte) 0x4a, (byte) 0x49, (byte) 0xad,
+      (byte) 0x75, (byte) 0xce, (byte) 0x39, (byte) 0x08,
+      (byte) 0x21, (byte) 0x94, (byte) 0x52, (byte) 0x4a,
+      (byte) 0x49, (byte) 0xa9, (byte) 0xb4, (byte) 0x94,
+      (byte) 0x62, (byte) 0xca, (byte) 0x98, (byte) 0x73,
+      (byte) 0xce, (byte) 0x41, (byte) 0x08, (byte) 0xa5,
+      (byte) 0x94, (byte) 0x12, (byte) 0x4a, (byte) 0x49,
+      (byte) 0xa9, (byte) 0xa5, (byte) 0xd4, (byte) 0x39,
+      (byte) 0xe7, (byte) 0x20, (byte) 0x94, (byte) 0x52,
+      (byte) 0x4a, (byte) 0x4a, (byte) 0x29, (byte) 0xa5,
+      (byte) 0x94, (byte) 0x5a, (byte) 0x6a, (byte) 0xad,
+      (byte) 0x73, (byte) 0x10, (byte) 0x42, (byte) 0x08,
+      (byte) 0xa5, (byte) 0x94, (byte) 0x52, (byte) 0x4a,
+      (byte) 0x4a, (byte) 0x29, (byte) 0xa5, (byte) 0xd4,
+      (byte) 0x52, (byte) 0x08, (byte) 0x21, (byte) 0x94,
+      (byte) 0x52, (byte) 0x4a, (byte) 0x2a, (byte) 0x29,
+      (byte) 0xa5, (byte) 0x94, (byte) 0x52, (byte) 0x6b,
+      (byte) 0xad, (byte) 0xa5, (byte) 0x10, (byte) 0x42,
+      (byte) 0x28, (byte) 0xa5, (byte) 0x94, (byte) 0x94,
+      (byte) 0x52, (byte) 0x4a, (byte) 0x29, (byte) 0xa5,
+      (byte) 0xd4, (byte) 0x5a, (byte) 0x8b, (byte) 0xa1,
+      (byte) 0x94, (byte) 0x90, (byte) 0x4a, (byte) 0x29,
+      (byte) 0x25, (byte) 0xa5, (byte) 0x94, (byte) 0x52,
+      (byte) 0x49, (byte) 0x2d, (byte) 0xb5, (byte) 0x96,
+      (byte) 0x5a, (byte) 0x2a, (byte) 0xa1, (byte) 0x94,
+      (byte) 0x54, (byte) 0x52, (byte) 0x4a, (byte) 0x29,
+      (byte) 0xa5, (byte) 0x94, (byte) 0x52, (byte) 0x6b,
+      (byte) 0xa9, (byte) 0xb5, (byte) 0x56, (byte) 0x4a,
+      (byte) 0x49, (byte) 0x25, (byte) 0xa5, (byte) 0x94,
+      (byte) 0x52, (byte) 0x4a, (byte) 0x29, (byte) 0xa5,
+      (byte) 0xd4, (byte) 0x62, (byte) 0x6b, (byte) 0x29,
+      (byte) 0x94, (byte) 0x92, (byte) 0x52, (byte) 0x49,
+      (byte) 0x29, (byte) 0xb5, (byte) 0x94, (byte) 0x52,
+      (byte) 0x4a, (byte) 0xad, (byte) 0xc5, (byte) 0xd8,
+      (byte) 0x62, (byte) 0x29, (byte) 0xad, (byte) 0xa4,
+      (byte) 0x94, (byte) 0x52, (byte) 0x4a, (byte) 0x29,
+      (byte) 0xa5, (byte) 0xd6, (byte) 0x52, (byte) 0x6c,
+      (byte) 0xad, (byte) 0xb5, (byte) 0xd8, (byte) 0x52,
+      (byte) 0x4a, (byte) 0x29, (byte) 0xa5, (byte) 0x96,
+      (byte) 0x5a, (byte) 0x4a, (byte) 0x29, (byte) 0xb5,
+      (byte) 0x16, (byte) 0x5b, (byte) 0x6a, (byte) 0x2d,
+      (byte) 0xa5, (byte) 0x94, (byte) 0x52, (byte) 0x4b,
+      (byte) 0x29, (byte) 0xa5, (byte) 0x96, (byte) 0x52,
+      (byte) 0x4b, (byte) 0x2d, (byte) 0xc6, (byte) 0xd6,
+      (byte) 0x5a, (byte) 0x4b, (byte) 0x29, (byte) 0xa5,
+      (byte) 0xd4, (byte) 0x52, (byte) 0x6a, (byte) 0xa9,
+      (byte) 0xa5, (byte) 0x94, (byte) 0x52, (byte) 0x6c,
+      (byte) 0xad, (byte) 0xb5, (byte) 0x98, (byte) 0x52,
+      (byte) 0x6a, (byte) 0x2d, (byte) 0xa5, (byte) 0xd4,
+      (byte) 0x52, (byte) 0x6b, (byte) 0x2d, (byte) 0xb5,
+      (byte) 0xd8, (byte) 0x52, (byte) 0x6a, (byte) 0x2d,
+      (byte) 0xb5, (byte) 0x94, (byte) 0x52, (byte) 0x6b,
+      (byte) 0xa9, (byte) 0xa5, (byte) 0x94, (byte) 0x5a,
+      (byte) 0x6b, (byte) 0x2d, (byte) 0xb6, (byte) 0xd8,
+      (byte) 0x5a, (byte) 0x6b, (byte) 0x29, (byte) 0xb5,
+      (byte) 0x94, (byte) 0x52, (byte) 0x4a, (byte) 0xa9,
+      (byte) 0xb5, (byte) 0x16, (byte) 0x5b, (byte) 0x8a,
+      (byte) 0xb1, (byte) 0xb5, (byte) 0xd4, (byte) 0x4a,
+      (byte) 0x4a, (byte) 0x29, (byte) 0xb5, (byte) 0xd4,
+      (byte) 0x5a, (byte) 0x6a, (byte) 0x2d, (byte) 0xb6,
+      (byte) 0x16, (byte) 0x5b, (byte) 0x6b, (byte) 0xad,
+      (byte) 0xa5, (byte) 0xd6, (byte) 0x5a, (byte) 0x6a,
+      (byte) 0x29, (byte) 0xa5, (byte) 0x16, (byte) 0x5b,
+      (byte) 0x8c, (byte) 0x31, (byte) 0xc6, (byte) 0x16,
+      (byte) 0x63, (byte) 0x6b, (byte) 0x31, (byte) 0xa5,
+      (byte) 0x94, (byte) 0x52, (byte) 0x4b, (byte) 0xa9,
+      (byte) 0xa5, (byte) 0x02, (byte) 0x00, (byte) 0x80,
+      (byte) 0x0e, (byte) 0x1c, (byte) 0x00, (byte) 0x00,
+      (byte) 0x02, (byte) 0x8c, (byte) 0xa8, (byte) 0xb4,
+      (byte) 0x10, (byte) 0x3b, (byte) 0xcd, (byte) 0xb8,
+      (byte) 0xf2, (byte) 0x08, (byte) 0x1c, (byte) 0x51,
+      (byte) 0xc8, (byte) 0x30, (byte) 0x01, (byte) 0x15,
+      (byte) 0x1a, (byte) 0xb2, (byte) 0x12, (byte) 0x00,
+      (byte) 0x20, (byte) 0x03, (byte) 0x00, (byte) 0x20,
+      (byte) 0x90, (byte) 0x69, (byte) 0x92, (byte) 0x39,
+      (byte) 0x49, (byte) 0xa9, (byte) 0x11, (byte) 0x26,
+      (byte) 0x39, (byte) 0xc5, (byte) 0xa0, (byte) 0x94,
+      (byte) 0xe6, (byte) 0x9c, (byte) 0x53, (byte) 0x4a,
+      (byte) 0x29, (byte) 0xa5, (byte) 0x34, (byte) 0x44,
+      (byte) 0x96, (byte) 0x64, (byte) 0x90, (byte) 0x62,
+      (byte) 0x50, (byte) 0x1d, (byte) 0x99, (byte) 0x8c,
+      (byte) 0x39, (byte) 0x49, (byte) 0x39, (byte) 0x43,
+      (byte) 0xa4, (byte) 0x31, (byte) 0xa4, (byte) 0x20,
+      (byte) 0xf5, (byte) 0x4c, (byte) 0x91, (byte) 0xc7,
+      (byte) 0x94, (byte) 0x62, (byte) 0x10, (byte) 0x43,
+      (byte) 0x48, (byte) 0x2a, (byte) 0x74, (byte) 0x8a,
+      (byte) 0x39, (byte) 0x6c, (byte) 0x35, (byte) 0xf9,
+      (byte) 0x58, (byte) 0x42, (byte) 0x07, (byte) 0xb1,
+      (byte) 0x06, (byte) 0x65, (byte) 0x8c, (byte) 0x70,
+      (byte) 0x29, (byte) 0xc5, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x08, (byte) 0x02, (byte) 0x00,
+      (byte) 0x04, (byte) 0x84, (byte) 0x04, (byte) 0x00,
+      (byte) 0x18, (byte) 0x20, (byte) 0x28, (byte) 0x98,
+      (byte) 0x01, (byte) 0x00, (byte) 0x06, (byte) 0x07,
+      (byte) 0x08, (byte) 0x23, (byte) 0x07, (byte) 0x02,
+      (byte) 0x1d, (byte) 0x01, (byte) 0x04, (byte) 0x0e,
+      (byte) 0x6d, (byte) 0x00, (byte) 0x80, (byte) 0x81,
+      (byte) 0x08, (byte) 0x99, (byte) 0x09, (byte) 0x0c,
+      (byte) 0x0a, (byte) 0xa1, (byte) 0xc1, (byte) 0x41,
+      (byte) 0x26, (byte) 0x00, (byte) 0x3c, (byte) 0x40,
+      (byte) 0x44, (byte) 0x48, (byte) 0x05, (byte) 0x00,
+      (byte) 0x89, (byte) 0x09, (byte) 0x8a, (byte) 0xd2,
+      (byte) 0x85, (byte) 0x2e, (byte) 0x08, (byte) 0x21,
+      (byte) 0x82, (byte) 0x74, (byte) 0x11, (byte) 0x64,
+      (byte) 0xf1, (byte) 0xc0, (byte) 0x85, (byte) 0x13,
+      (byte) 0x37, (byte) 0x9e, (byte) 0xb8, (byte) 0xe1,
+      (byte) 0x84, (byte) 0x0e, (byte) 0x6d, (byte) 0x20,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x20, (byte) 0x00, (byte) 0xf0,
+      (byte) 0x01, (byte) 0x00, (byte) 0x90, (byte) 0x50,
+      (byte) 0x00, (byte) 0x11, (byte) 0x11, (byte) 0xd1,
+      (byte) 0xcc, (byte) 0x55, (byte) 0x58, (byte) 0x5c,
+      (byte) 0x60, (byte) 0x64, (byte) 0x68, (byte) 0x6c,
+      (byte) 0x70, (byte) 0x74, (byte) 0x78, (byte) 0x7c,
+      (byte) 0x80, (byte) 0x84, (byte) 0x08, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x10, (byte) 0x00, (byte) 0x7c, (byte) 0x00,
+      (byte) 0x00, (byte) 0x24, (byte) 0x22, (byte) 0x40,
+      (byte) 0x44, (byte) 0x44, (byte) 0x34, (byte) 0x73,
+      (byte) 0x15, (byte) 0x16, (byte) 0x17, (byte) 0x18,
+      (byte) 0x19, (byte) 0x1a, (byte) 0x1b, (byte) 0x1c,
+      (byte) 0x1d, (byte) 0x1e, (byte) 0x1f, (byte) 0x20,
+      (byte) 0x21, (byte) 0x01, (byte) 0x00, (byte) 0x80,
+      (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x00, (byte) 0x20, (byte) 0x80,
+      (byte) 0x00, (byte) 0x04, (byte) 0x04, (byte) 0x04,
+      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00,
+      (byte) 0x00, (byte) 0x04, (byte) 0x04
+  };
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/VorbisBitArrayTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/VorbisBitArrayTest.java
new file mode 100644
index 0000000000..17a0fd241e
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/VorbisBitArrayTest.java
@@ -0,0 +1,336 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ogg;
+
+import com.google.android.exoplayer.util.ParsableBitArray;
+
+import junit.framework.TestCase;
+
+/**
+ * Unit test for {@link VorbisBitArray}.
+ */
+public final class VorbisBitArrayTest extends TestCase {
+
+  public void testReadBit() {
+    VorbisBitArray bitArray = new VorbisBitArray(new byte[]{
+        (byte) 0x5c, 0x50
+    });
+
+    assertFalse(bitArray.readBit());
+    assertFalse(bitArray.readBit());
+    assertTrue(bitArray.readBit());
+    assertTrue(bitArray.readBit());
+
+    assertTrue(bitArray.readBit());
+    assertFalse(bitArray.readBit());
+    assertTrue(bitArray.readBit());
+    assertFalse(bitArray.readBit());
+
+    assertFalse(bitArray.readBit());
+    assertFalse(bitArray.readBit());
+    assertFalse(bitArray.readBit());
+    assertFalse(bitArray.readBit());
+
+    assertTrue(bitArray.readBit());
+    assertFalse(bitArray.readBit());
+    assertTrue(bitArray.readBit());
+    assertFalse(bitArray.readBit());
+
+    try {
+      assertFalse(bitArray.readBit());
+      fail();
+    } catch (IllegalStateException e) {/* ignored */}
+  }
+
+  public void testSkipBits() {
+    VorbisBitArray bitArray = new VorbisBitArray(new byte[]{
+        (byte) 0xF0, 0x0F
+    });
+
+    bitArray.skipBits(10);
+    assertEquals(10, bitArray.getPosition());
+    assertTrue(bitArray.readBit());
+    assertTrue(bitArray.readBit());
+    assertFalse(bitArray.readBit());
+    bitArray.skipBits(1);
+    assertEquals(14, bitArray.getPosition());
+    assertFalse(bitArray.readBit());
+    assertFalse(bitArray.readBit());
+    try {
+      bitArray.readBit();
+      fail();
+    } catch (IllegalStateException e) {
+      // ignored
+    }
+  }
+
+
+  public void testSkipBitsThrowsErrorIfEOB() {
+    VorbisBitArray bitArray = new VorbisBitArray(new byte[]{
+        (byte) 0xF0, 0x0F
+    });
+
+    try {
+      bitArray.skipBits(17);
+      fail();
+    } catch (IllegalStateException e) {/* ignored */}
+  }
+
+  public void testGetPosition() throws Exception {
+    VorbisBitArray bitArray = new VorbisBitArray(new byte[]{
+        (byte) 0xF0, 0x0F
+    });
+
+    assertEquals(0, bitArray.getPosition());
+    bitArray.readBit();
+    assertEquals(1, bitArray.getPosition());
+    bitArray.readBit();
+    bitArray.readBit();
+    bitArray.skipBits(4);
+    assertEquals(7, bitArray.getPosition());
+  }
+
+  public void testSetPosition() throws Exception {
+    VorbisBitArray bitArray = new VorbisBitArray(new byte[]{
+        (byte) 0xF0, 0x0F
+    });
+
+    assertEquals(0, bitArray.getPosition());
+    bitArray.setPosition(4);
+    assertEquals(4, bitArray.getPosition());
+
+    bitArray.setPosition(15);
+    assertFalse(bitArray.readBit());
+    try {
+      bitArray.readBit();
+      fail();
+    } catch (IllegalStateException e) {/* ignored */}
+
+  }
+  public void testSetPositionIllegalPositions() throws Exception {
+    VorbisBitArray bitArray = new VorbisBitArray(new byte[]{
+        (byte) 0xF0, 0x0F
+    });
+
+    try {
+      bitArray.setPosition(16);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals(0, bitArray.getPosition());
+    }
+
+    try {
+      bitArray.setPosition(-1);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals(0, bitArray.getPosition());
+    }
+  }
+
+  public void testReadInt32() {
+    byte[] data = {(byte) 0xF0, 0x0F, (byte) 0xF0, 0x0F};
+    VorbisBitArray lsb = new VorbisBitArray(data);
+    assertEquals(0x0FF00FF0, lsb.readBits(32));
+
+    data = new byte[]{0x0F, (byte) 0xF0, 0x0F, (byte) 0xF0};
+    lsb = new VorbisBitArray(data);
+    assertEquals(0xF00FF00F, lsb.readBits(32));
+  }
+
+  public void testReadBits() throws Exception {
+    VorbisBitArray bitArray = new VorbisBitArray(new byte[]{
+      (byte) 0x03, 0x22
+    });
+
+    assertEquals(3, bitArray.readBits(2));
+    bitArray.skipBits(6);
+    assertEquals(2, bitArray.readBits(2));
+    bitArray.skipBits(2);
+    assertEquals(2, bitArray.readBits(2));
+
+    bitArray.reset();
+    assertEquals(0x2203, bitArray.readBits(16));
+  }
+
+  public void testRead4BitsBeyondBoundary() throws Exception {
+    VorbisBitArray bitArray = new VorbisBitArray(new byte[]{
+        0x2e, 0x10
+    });
+    assertEquals(0x2e, bitArray.readBits(7));
+    assertEquals(7, bitArray.getPosition());
+    assertEquals(0x0, bitArray.readBits(4));
+  }
+
+  public void testReadBitsBeyondByteBoundaries() throws Exception {
+    VorbisBitArray bitArray = new VorbisBitArray(new byte[]{
+        (byte) 0xFF, (byte) 0x0F, (byte) 0xFF, (byte) 0x0F
+    });
+
+    assertEquals(0x0FFF0FFF, bitArray.readBits(32));
+
+    bitArray.reset();
+    bitArray.skipBits(4);
+    assertEquals(0xF0FF, bitArray.readBits(16));
+
+    bitArray.reset();
+    bitArray.skipBits(6);
+    assertEquals(0xc3F, bitArray.readBits(12));
+
+    bitArray.reset();
+    bitArray.skipBits(6);
+    assertTrue(bitArray.readBit());
+    assertTrue(bitArray.readBit());
+    assertEquals(24, bitArray.bitsLeft());
+
+    bitArray.reset();
+    bitArray.skipBits(10);
+    assertEquals(3, bitArray.readBits(5));
+    assertEquals(15, bitArray.getPosition());
+  }
+
+  public void testReadBitsIllegalLengths() throws Exception {
+    VorbisBitArray bitArray = new VorbisBitArray(new byte[]{
+        (byte) 0x03, 0x22, 0x30
+    });
+
+    // reading zero bits gets 0 without advancing position
+    // (like a zero-bit read is defined to yield zer0)
+    assertEquals(0, bitArray.readBits(0));
+    assertEquals(0, bitArray.getPosition());
+    bitArray.readBit();
+    assertEquals(1, bitArray.getPosition());
+
+    try {
+      bitArray.readBits(24);
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals(1, bitArray.getPosition());
+    }
+  }
+
+  public void testLimit() {
+    VorbisBitArray bitArray = new VorbisBitArray(new byte[]{
+        (byte) 0xc0, 0x02
+    }, 1);
+
+    try {
+      bitArray.skipBits(9);
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals(0, bitArray.getPosition());
+    }
+
+    try {
+      bitArray.readBits(9);
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals(0, bitArray.getPosition());
+    }
+
+    bitArray.readBits(8);
+    assertEquals(8, bitArray.getPosition());
+    try {
+      bitArray.readBit();
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals(8, bitArray.getPosition());
+    }
+  }
+
+  public void testBitsLeft() {
+    VorbisBitArray bitArray = new VorbisBitArray(new byte[]{
+        (byte) 0xc0, 0x02
+    });
+    assertEquals(16, bitArray.bitsLeft());
+    assertEquals(bitArray.limit(), bitArray.getPosition() + bitArray.bitsLeft());
+
+    bitArray.skipBits(1);
+    assertEquals(15, bitArray.bitsLeft());
+    assertEquals(bitArray.limit(), bitArray.getPosition() + bitArray.bitsLeft());
+
+    bitArray.skipBits(3);
+    assertEquals(12, bitArray.bitsLeft());
+    assertEquals(bitArray.limit(), bitArray.getPosition() + bitArray.bitsLeft());
+
+    bitArray.setPosition(6);
+    assertEquals(10, bitArray.bitsLeft());
+    assertEquals(bitArray.limit(), bitArray.getPosition() + bitArray.bitsLeft());
+
+    bitArray.skipBits(1);
+    assertEquals(9, bitArray.bitsLeft());
+    assertEquals(bitArray.limit(), bitArray.getPosition() + bitArray.bitsLeft());
+
+    bitArray.skipBits(1);
+    assertEquals(8, bitArray.bitsLeft());
+    assertEquals(bitArray.limit(), bitArray.getPosition() + bitArray.bitsLeft());
+
+    bitArray.readBits(4);
+    assertEquals(4, bitArray.bitsLeft());
+    assertEquals(bitArray.limit(), bitArray.getPosition() + bitArray.bitsLeft());
+
+    bitArray.readBits(4);
+    assertEquals(0, bitArray.bitsLeft());
+    assertEquals(bitArray.limit(), bitArray.getPosition() + bitArray.bitsLeft());
+
+    try {
+      bitArray.readBit();
+      fail();
+    } catch (IllegalStateException e) {
+      assertEquals(0, bitArray.bitsLeft());
+    }
+  }
+
+  public void testReadBitCompareWithMSb() {
+    byte[] data = {0x0F};
+    VorbisBitArray lsb = new VorbisBitArray(data);
+    ParsableBitArray msb = new ParsableBitArray(data);
+
+    assertEquals(lsb.readBit(), !msb.readBit());
+    assertEquals(lsb.readBit(), !msb.readBit());
+    assertEquals(lsb.readBit(), !msb.readBit());
+    assertEquals(lsb.readBit(), !msb.readBit());
+    assertEquals(lsb.readBit(), !msb.readBit());
+    assertEquals(lsb.readBit(), !msb.readBit());
+    assertEquals(lsb.readBit(), !msb.readBit());
+    assertEquals(lsb.readBit(), !msb.readBit());
+  }
+
+  public void testReadBitsCompareWithMSb() {
+    byte[] data = {0x0F};
+    VorbisBitArray lsb = new VorbisBitArray(data);
+    ParsableBitArray msb = new ParsableBitArray(data);
+
+    assertEquals(15, lsb.readBits(4));
+    assertEquals(lsb.readBits(4), msb.readBits(4));
+    assertEquals(15, msb.readBits(4));
+  }
+
+  public void testReadBitsCompareWithMSbBeyondByteBoundary() {
+    byte[] data = {(byte) 0xF0, 0x0F};
+    VorbisBitArray lsb = new VorbisBitArray(data);
+    ParsableBitArray msb = new ParsableBitArray(data);
+
+    assertEquals(0x00, lsb.readBits(4));
+    assertEquals(0x0F, msb.readBits(4));
+
+    assertEquals(0xFF, lsb.readBits(8));
+    assertEquals(0x00, msb.readBits(8));
+
+    assertEquals(0x00, lsb.readBits(4));
+    assertEquals(0x0F, msb.readBits(4));
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/VorbisUtilTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/VorbisUtilTest.java
new file mode 100644
index 0000000000..434cda6650
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/VorbisUtilTest.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ogg;
+
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import junit.framework.TestCase;
+
+/**
+ * Unit test for {@link VorbisUtil}.
+ */
+public final class VorbisUtilTest extends TestCase {
+
+  public void testILog() throws Exception {
+    assertEquals(0, VorbisUtil.iLog(0));
+    assertEquals(1, VorbisUtil.iLog(1));
+    assertEquals(2, VorbisUtil.iLog(2));
+    assertEquals(2, VorbisUtil.iLog(3));
+    assertEquals(3, VorbisUtil.iLog(4));
+    assertEquals(3, VorbisUtil.iLog(5));
+    assertEquals(4, VorbisUtil.iLog(8));
+
+    assertEquals(0, VorbisUtil.iLog(-1));
+    assertEquals(0, VorbisUtil.iLog(-122));
+  }
+
+  public void testReadIdHeader() throws Exception {
+    byte[] data = TestData.getIdentificationHeaderData();
+    ParsableByteArray headerData = new ParsableByteArray(data, data.length);
+
+    VorbisUtil.VorbisIdHeader vorbisIdHeader =
+        VorbisUtil.readVorbisIdentificationHeader(headerData);
+
+    assertEquals(22050, vorbisIdHeader.sampleRate);
+    assertEquals(0, vorbisIdHeader.version);
+    assertTrue(vorbisIdHeader.framingFlag);
+    assertEquals(2, vorbisIdHeader.channels);
+    assertEquals(512, vorbisIdHeader.blockSize0);
+    assertEquals(1024, vorbisIdHeader.blockSize1);
+    assertEquals(-1, vorbisIdHeader.bitrateMax);
+    assertEquals(-1, vorbisIdHeader.bitrateMin);
+    assertEquals(66666, vorbisIdHeader.bitrateNominal);
+    assertEquals(66666, vorbisIdHeader.getApproximateBitrate());
+  }
+
+  public void testReadCommentHeader() throws ParserException {
+    byte[] data = TestData.getCommentHeaderDataUTF8();
+    ParsableByteArray headerData = new ParsableByteArray(data, data.length);
+
+    VorbisUtil.CommentHeader commentHeader = VorbisUtil.readVorbisCommentHeader(headerData);
+    assertEquals("Xiph.Org libVorbis I 20120203 (Omnipresent)", commentHeader.vendor);
+    assertEquals(3, commentHeader.comments.length);
+    assertEquals("ALBUM=äö", commentHeader.comments[0]);
+    assertEquals("TITLE=A sample song", commentHeader.comments[1]);
+    assertEquals("ARTIST=Google", commentHeader.comments[2]);
+  }
+
+  public void testReadVorbisModes() throws ParserException {
+    byte[] data = TestData.getSetupHeaderData();
+    ParsableByteArray headerData = new ParsableByteArray(data, data.length);
+
+    VorbisUtil.Mode[] modes = VorbisUtil.readVorbisModes(headerData, 2);
+
+    assertEquals(2, modes.length);
+
+    assertEquals(false, modes[0].blockFlag);
+    assertEquals(0, modes[0].mapping);
+    assertEquals(0, modes[0].transformType);
+    assertEquals(0, modes[0].windowType);
+
+    assertEquals(true, modes[1].blockFlag);
+    assertEquals(1, modes[1].mapping);
+    assertEquals(0, modes[1].transformType);
+    assertEquals(0, modes[1].windowType);
+  }
+
+  public void testVerifyVorbisHeaderCapturePattern() throws ParserException {
+    ParsableByteArray header = new ParsableByteArray(
+        new byte[]{0x01, 'v', 'o', 'r', 'b', 'i', 's'});
+    assertEquals(true, VorbisUtil.verifyVorbisHeaderCapturePattern(0x01, header, false));
+  }
+
+  public void testVerifyVorbisHeaderCapturePatternInvalidHeader() {
+    ParsableByteArray header = new ParsableByteArray(
+        new byte[]{0x01, 'v', 'o', 'r', 'b', 'i', 's'});
+    try {
+      VorbisUtil.verifyVorbisHeaderCapturePattern(0x99, header, false);
+      fail();
+    } catch (ParserException e) {
+      assertEquals("expected header type 99", e.getMessage());
+    }
+  }
+
+  public void testVerifyVorbisHeaderCapturePatternInvalidHeaderQuite() throws ParserException {
+    ParsableByteArray header = new ParsableByteArray(
+        new byte[]{0x01, 'v', 'o', 'r', 'b', 'i', 's'});
+    assertFalse(VorbisUtil.verifyVorbisHeaderCapturePattern(0x99, header, true));
+  }
+
+  public void testVerifyVorbisHeaderCapturePatternInvalidPattern() {
+    ParsableByteArray header = new ParsableByteArray(
+        new byte[]{0x01, 'x', 'v', 'o', 'r', 'b', 'i', 's'});
+    try {
+      VorbisUtil.verifyVorbisHeaderCapturePattern(0x01, header, false);
+      fail();
+    } catch (ParserException e) {
+      assertEquals("expected characters 'vorbis'", e.getMessage());
+    }
+  }
+
+  public void testVerifyVorbisHeaderCapturePatternQuiteInvalidPatternQuite()
+      throws ParserException {
+    ParsableByteArray header = new ParsableByteArray(
+        new byte[]{0x01, 'x', 'v', 'o', 'r', 'b', 'i', 's'});
+    assertFalse(VorbisUtil.verifyVorbisHeaderCapturePattern(0x01, header, true));
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java
index e4337e9650..bc8fcdae51 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java
@@ -46,18 +46,18 @@ public void testParseMediaPlaylist() {
         + "\n"
         + "#EXT-X-KEY:METHOD=AES-128,URI=\"https://priv.example.com/key.php?r=2680\",IV=0x1566B\n"
         + "#EXTINF:7.975,\n"
-        + "#EXT-X-BYTERANGE:51501@51370\n"
+        + "#EXT-X-BYTERANGE:51501@2147483648\n"
         + "https://priv.example.com/fileSequence2680.ts\n"
         + "\n"
         + "#EXT-X-KEY:METHOD=NONE\n"
         + "#EXTINF:7.941,\n"
-        + "#EXT-X-BYTERANGE:51501\n" // @102871
+        + "#EXT-X-BYTERANGE:51501\n" // @2147535149
         + "https://priv.example.com/fileSequence2681.ts\n"
         + "\n"
         + "#EXT-X-DISCONTINUITY\n"
         + "#EXT-X-KEY:METHOD=AES-128,URI=\"https://priv.example.com/key.php?r=2682\"\n"
         + "#EXTINF:7.975,\n"
-        + "#EXT-X-BYTERANGE:51740\n" // @154372
+        + "#EXT-X-BYTERANGE:51740\n" // @2147586650
         + "https://priv.example.com/fileSequence2682.ts\n"
         + "\n"
         + "#EXTINF:7.975,\n"
@@ -95,7 +95,7 @@ public void testParseMediaPlaylist() {
       assertEquals("https://priv.example.com/key.php?r=2680", segments.get(1).encryptionKeyUri);
       assertEquals("0x1566B", segments.get(1).encryptionIV);
       assertEquals(51501, segments.get(1).byterangeLength);
-      assertEquals(51370, segments.get(1).byterangeOffset);
+      assertEquals(2147483648L, segments.get(1).byterangeOffset);
       assertEquals("https://priv.example.com/fileSequence2680.ts", segments.get(1).url);
 
       assertEquals(4, segments.get(2).discontinuitySequenceNumber);
@@ -104,7 +104,7 @@ public void testParseMediaPlaylist() {
       assertEquals(null, segments.get(2).encryptionKeyUri);
       assertEquals(null, segments.get(2).encryptionIV);
       assertEquals(51501, segments.get(2).byterangeLength);
-      assertEquals(102871, segments.get(2).byterangeOffset);
+      assertEquals(2147535149L, segments.get(2).byterangeOffset);
       assertEquals("https://priv.example.com/fileSequence2681.ts", segments.get(2).url);
 
       assertEquals(5, segments.get(3).discontinuitySequenceNumber);
@@ -115,7 +115,7 @@ public void testParseMediaPlaylist() {
       assertNotNull(segments.get(3).encryptionIV);
       assertEquals("A7A", segments.get(3).encryptionIV.toUpperCase(Locale.getDefault()));
       assertEquals(51740, segments.get(3).byterangeLength);
-      assertEquals(154372, segments.get(3).byterangeOffset);
+      assertEquals(2147586650L, segments.get(3).byterangeOffset);
       assertEquals("https://priv.example.com/fileSequence2682.ts", segments.get(3).url);
 
       assertEquals(5, segments.get(4).discontinuitySequenceNumber);
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/util/UtilTest.java b/library/src/androidTest/java/com/google/android/exoplayer/util/UtilTest.java
index 7ffff22960..7efa0aafc8 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/util/UtilTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/util/UtilTest.java
@@ -161,4 +161,20 @@ private static void assertLongSplittingForValue(long value) {
     assertEquals(value, reconstructedValue);
   }
 
+  public void testUnescapeInvalidFileName() {
+    assertNull(Util.unescapeFileName("%a"));
+    assertNull(Util.unescapeFileName("%xyz"));
+  }
+
+  public void testEscapeUnescapeFileName() {
+    assertEscapeUnescapeFileName("just+a regular+fileName", "just+a regular+fileName");
+    assertEscapeUnescapeFileName("key:value", "key%3avalue");
+    assertEscapeUnescapeFileName("<>:\"/\\|?*%", "%3c%3e%3a%22%2f%5c%7c%3f%2a%25");
+  }
+
+  private static void assertEscapeUnescapeFileName(String fileName, String escapedFileName) {
+    assertEquals(escapedFileName, Util.escapeFileName(fileName));
+    assertEquals(fileName, Util.unescapeFileName(escapedFileName));
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/CodecCounters.java b/library/src/main/java/com/google/android/exoplayer/CodecCounters.java
index 97b41b33a6..f23b8f421c 100644
--- a/library/src/main/java/com/google/android/exoplayer/CodecCounters.java
+++ b/library/src/main/java/com/google/android/exoplayer/CodecCounters.java
@@ -26,6 +26,7 @@
 
   public int codecInitCount;
   public int codecReleaseCount;
+  public int inputBufferCount;
   public int outputFormatChangedCount;
   public int outputBuffersChangedCount;
   public int renderedOutputBufferCount;
@@ -48,6 +49,7 @@ public String getDebugString() {
     StringBuilder builder = new StringBuilder();
     builder.append("cic:").append(codecInitCount);
     builder.append(" crc:").append(codecReleaseCount);
+    builder.append(" ibc:").append(inputBufferCount);
     builder.append(" ofc:").append(outputFormatChangedCount);
     builder.append(" obc:").append(outputBuffersChangedCount);
     builder.append(" ren:").append(renderedOutputBufferCount);
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java
index e8a79efa04..b7d52790e3 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java
@@ -260,14 +260,6 @@ private void prepareInternal(TrackRenderer[] renderers) throws ExoPlaybackExcept
     resetInternal();
     this.renderers = renderers;
     Arrays.fill(trackFormats, null);
-    for (int i = 0; i < renderers.length; i++) {
-      MediaClock mediaClock = renderers[i].getMediaClock();
-      if (mediaClock != null) {
-        Assertions.checkState(rendererMediaClock == null);
-        rendererMediaClock = mediaClock;
-        rendererMediaClockSource = renderers[i];
-      }
-    }
     setState(ExoPlayer.STATE_PREPARING);
     incrementalPrepareInternal();
   }
@@ -319,8 +311,7 @@ private void incrementalPrepareInternal() throws ExoPlaybackException {
         }
         int trackIndex = selectedTrackIndices[rendererIndex];
         if (0 <= trackIndex && trackIndex < rendererTrackFormats.length) {
-          renderer.enable(trackIndex, positionUs, false);
-          enabledRenderers.add(renderer);
+          enableRenderer(renderer, trackIndex, false);
           allRenderersEnded = allRenderersEnded && renderer.isEnded();
           allRenderersReadyOrEnded = allRenderersReadyOrEnded && rendererReadyOrEnded(renderer);
         }
@@ -347,6 +338,18 @@ private void incrementalPrepareInternal() throws ExoPlaybackException {
     handler.sendEmptyMessage(MSG_DO_SOME_WORK);
   }
 
+  private void enableRenderer(TrackRenderer renderer, int trackIndex, boolean joining)
+      throws ExoPlaybackException {
+    renderer.enable(trackIndex, positionUs, joining);
+    enabledRenderers.add(renderer);
+    MediaClock mediaClock = renderer.getMediaClock();
+    if (mediaClock != null) {
+      Assertions.checkState(rendererMediaClock == null);
+      rendererMediaClock = mediaClock;
+      rendererMediaClockSource = renderer;
+    }
+  }
+
   private boolean rendererReadyOrEnded(TrackRenderer renderer) {
     if (renderer.isEnded()) {
       return true;
@@ -556,10 +559,7 @@ private void resetInternal() {
 
   private void stopAndDisable(TrackRenderer renderer) {
     try {
-      ensureStopped(renderer);
-      if (renderer.getState() == TrackRenderer.STATE_ENABLED) {
-        renderer.disable();
-      }
+      ensureDisabled(renderer);
     } catch (ExoPlaybackException e) {
       // There's nothing we can do.
       Log.e(TAG, "Stop failed.", e);
@@ -632,9 +632,8 @@ private void setRendererSelectedTrackInternal(int rendererIndex, int trackIndex)
         // timing responsibilities.
         standaloneMediaClock.setPositionUs(rendererMediaClock.getPositionUs());
       }
-      ensureStopped(renderer);
+      ensureDisabled(renderer);
       enabledRenderers.remove(renderer);
-      renderer.disable();
     }
 
     if (shouldEnable) {
@@ -642,8 +641,7 @@ private void setRendererSelectedTrackInternal(int rendererIndex, int trackIndex)
       boolean playing = playWhenReady && state == ExoPlayer.STATE_READY;
       // Consider as joining if the renderer was previously disabled, but not when switching tracks.
       boolean joining = !isEnabled && playing;
-      renderer.enable(trackIndex, positionUs, joining);
-      enabledRenderers.add(renderer);
+      enableRenderer(renderer, trackIndex, joining);
       if (playing) {
         renderer.start();
       }
@@ -657,4 +655,14 @@ private void ensureStopped(TrackRenderer renderer) throws ExoPlaybackException {
     }
   }
 
+  private void ensureDisabled(TrackRenderer renderer) throws ExoPlaybackException {
+    ensureStopped(renderer);
+    if (renderer.getState() == TrackRenderer.STATE_ENABLED) {
+      renderer.disable();
+      if (renderer == rendererMediaClockSource) {
+        rendererMediaClock = null;
+        rendererMediaClockSource = null;
+      }
+    }
+  }
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
index ade47c08e9..2c36a09b9a 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
@@ -23,7 +23,7 @@
   /**
    * The version of the library, expressed as a string.
    */
-  public static final String VERSION = "1.5.6";
+  public static final String VERSION = "1.5.7";
 
   /**
    * The version of the library, expressed as an integer.
@@ -31,7 +31,7 @@
    * Three digits are used for each component of {@link #VERSION}. For example "1.2.3" has the
    * corresponding integer version 001002003.
    */
-  public static final int VERSION_INT = 001005006;
+  public static final int VERSION_INT = 001005007;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer.util.Assertions}
diff --git a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
index 064410798c..b7a16768f9 100644
--- a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
@@ -42,10 +42,11 @@
  * <p>
  * Warning - This class is marked as deprecated because there are known device specific issues
  * associated with its use, including playbacks not starting, playbacks stuttering and other
- * miscellaneous failures. For mp4, m4a, mp3, webm, mkv, mpeg-ts and aac playbacks it is strongly
- * recommended to use {@link ExtractorSampleSource} instead. Where this is not possible this class
- * can still be used, but please be aware of the associated risks. Playing container formats for
- * which an ExoPlayer extractor does not yet exist (e.g. ogg) is a valid use case of this class.
+ * miscellaneous failures. For mp4, m4a, mp3, webm, mkv, mpeg-ts, ogg, wav and aac playbacks it is
+ * strongly recommended to use {@link ExtractorSampleSource} instead. Where this is not possible
+ * this class can still be used, but please be aware of the associated risks. Playing container
+ * formats for which an ExoPlayer extractor does not yet exist (e.g. avi) is a valid use case of
+ * this class.
  * <p>
  * Over time we hope to enhance {@link ExtractorSampleSource} to support more formats, and hence
  * make use of this class unnecessary.
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
index e39d7c51e9..d61d5410bb 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
@@ -176,7 +176,32 @@ public MediaCodecAudioTrackRenderer(SampleSource source, MediaCodecSelector medi
       DrmSessionManager drmSessionManager, boolean playClearSamplesWithoutKeys,
       Handler eventHandler, EventListener eventListener, AudioCapabilities audioCapabilities,
       int streamType) {
-    super(source, mediaCodecSelector, drmSessionManager, playClearSamplesWithoutKeys, eventHandler,
+    this (new SampleSource[] {source}, mediaCodecSelector, drmSessionManager,
+        playClearSamplesWithoutKeys, eventHandler, eventListener, audioCapabilities, streamType);
+  }
+
+  /**
+   * @param sources The upstream sources from which the renderer obtains samples.
+   * @param mediaCodecSelector A decoder selector.
+   * @param drmSessionManager For use with encrypted content. May be null if support for encrypted
+   *     content is not required.
+   * @param playClearSamplesWithoutKeys Encrypted media may contain clear (un-encrypted) regions.
+   *     For example a media file may start with a short clear region so as to allow playback to
+   *     begin in parallel with key acquisition. This parameter specifies whether the renderer is
+   *     permitted to play clear regions of encrypted media files before {@code drmSessionManager}
+   *     has obtained the keys necessary to decrypt encrypted regions of the media.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param audioCapabilities The audio capabilities for playback on this device. May be null if the
+   *     default capabilities (no encoded audio passthrough support) should be assumed.
+   * @param streamType The type of audio stream for the {@link AudioTrack}.
+   */
+  public MediaCodecAudioTrackRenderer(SampleSource[] sources, MediaCodecSelector mediaCodecSelector,
+      DrmSessionManager drmSessionManager, boolean playClearSamplesWithoutKeys,
+      Handler eventHandler, EventListener eventListener, AudioCapabilities audioCapabilities,
+      int streamType) {
+    super(sources, mediaCodecSelector, drmSessionManager, playClearSamplesWithoutKeys, eventHandler,
         eventListener);
     this.eventListener = eventListener;
     this.audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
index 6e92e90535..a8e9c84aa1 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
@@ -250,7 +250,28 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   public MediaCodecTrackRenderer(SampleSource source, MediaCodecSelector mediaCodecSelector,
       DrmSessionManager drmSessionManager, boolean playClearSamplesWithoutKeys,
       Handler eventHandler, EventListener eventListener) {
-    super(source);
+    this (new SampleSource[] {source}, mediaCodecSelector, drmSessionManager,
+        playClearSamplesWithoutKeys, eventHandler, eventListener);
+  }
+
+  /**
+   * @param sources The upstream sources from which the renderer obtains samples.
+   * @param mediaCodecSelector A decoder selector.
+   * @param drmSessionManager For use with encrypted media. May be null if support for encrypted
+   *     media is not required.
+   * @param playClearSamplesWithoutKeys Encrypted media may contain clear (un-encrypted) regions.
+   *     For example a media file may start with a short clear region so as to allow playback to
+   *     begin in parallel with key acquisition. This parameter specifies whether the renderer is
+   *     permitted to play clear regions of encrypted media files before {@code drmSessionManager}
+   *     has obtained the keys necessary to decrypt encrypted regions of the media.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   */
+  public MediaCodecTrackRenderer(SampleSource[] sources, MediaCodecSelector mediaCodecSelector,
+      DrmSessionManager drmSessionManager, boolean playClearSamplesWithoutKeys,
+      Handler eventHandler, EventListener eventListener) {
+    super(sources);
     Assertions.checkState(Util.SDK_INT >= 16);
     this.mediaCodecSelector = Assertions.checkNotNull(mediaCodecSelector);
     this.drmSessionManager = drmSessionManager;
@@ -664,6 +685,9 @@ private boolean feedInputBuffer(long positionUs, boolean firstFeed) throws ExoPl
       if (sampleHolder.isDecodeOnly()) {
         decodeOnlyPresentationTimestamps.add(presentationTimeUs);
       }
+
+      onQueuedInputBuffer(presentationTimeUs, sampleHolder.data, bufferSize, sampleEncrypted);
+
       if (sampleEncrypted) {
         MediaCodec.CryptoInfo cryptoInfo = getFrameworkCryptoInfo(sampleHolder,
             adaptiveReconfigurationBytes);
@@ -674,7 +698,7 @@ private boolean feedInputBuffer(long positionUs, boolean firstFeed) throws ExoPl
       inputIndex = -1;
       codecReceivedBuffers = true;
       codecReconfigurationState = RECONFIGURATION_STATE_NONE;
-      onQueuedInputBuffer(presentationTimeUs);
+      codecCounters.inputBufferCount++;
     } catch (CryptoException e) {
       notifyCryptoError(e);
       throw new ExoPlaybackException(e);
@@ -771,13 +795,17 @@ protected void onOutputStreamEnded() {
   }
 
   /**
-   * Invoked when an input buffer is queued into the codec.
+   * Invoked immediately before an input buffer is queued into the codec.
    * <p>
    * The default implementation is a no-op.
    *
    * @param presentationTimeUs The timestamp associated with the input buffer.
+   * @param buffer The buffer to be queued.
+   * @param bufferSize the size of the sample data stored in the buffer.
+   * @param sampleEncrypted Whether the sample data is encrypted.
    */
-  protected void onQueuedInputBuffer(long presentationTimeUs) {
+  protected void onQueuedInputBuffer(
+      long presentationTimeUs, ByteBuffer buffer, int bufferSize, boolean sampleEncrypted) {
     // Do nothing.
   }
 
@@ -789,7 +817,7 @@ protected void onQueuedInputBuffer(long presentationTimeUs) {
    * @param presentationTimeUs The timestamp associated with the output buffer.
    */
   protected void onProcessedOutputBuffer(long presentationTimeUs) {
-    // Do Nothing.
+    // Do nothing.
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
index a5a1760e8f..4152391310 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
@@ -512,6 +512,11 @@ private void maybeSetMaxInputSize(android.media.MediaFormat format, boolean code
     int maxPixels;
     int minCompressionRatio;
     switch (format.getString(android.media.MediaFormat.KEY_MIME)) {
+      case MimeTypes.VIDEO_H263:
+      case MimeTypes.VIDEO_MP4V:
+        maxPixels = maxWidth * maxHeight;
+        minCompressionRatio = 2;
+        break;
       case MimeTypes.VIDEO_H264:
         if ("BRAVIA 4K 2015".equals(Util.MODEL)) {
           // The Sony BRAVIA 4k TV has input buffers that are too small for the calculated 4k video
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
index bc68b93e3a..b39ff7da95 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
@@ -182,6 +182,13 @@ public static MediaFormat createTextFormat(String trackId, String mimeType, int
         NO_VALUE, NO_VALUE, NO_VALUE);
   }
 
+  public static MediaFormat createImageFormat(String trackId, String mimeType, int bitrate,
+      long durationUs, List<byte[]> initializationData, String language) {
+    return new MediaFormat(trackId, mimeType, bitrate, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
+        NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, language, OFFSET_SAMPLE_RELATIVE,
+        initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
+  }
+
   public static MediaFormat createFormatForMimeType(String trackId, String mimeType, int bitrate,
       long durationUs) {
     return new MediaFormat(trackId, mimeType, bitrate, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
@@ -249,6 +256,13 @@ public MediaFormat copyWithDurationUs(long durationUs) {
         encoderPadding);
   }
 
+  public MediaFormat copyWithLanguage(String language) {
+    return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
+        rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
+        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, encoderDelay,
+        encoderPadding);
+  }
+
   public MediaFormat copyWithFixedTrackInfo(String trackId, int bitrate, int width, int height,
       String language) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
diff --git a/library/src/main/java/com/google/android/exoplayer/SingleSampleSource.java b/library/src/main/java/com/google/android/exoplayer/SingleSampleSource.java
index ca66e23316..6d0aac646d 100644
--- a/library/src/main/java/com/google/android/exoplayer/SingleSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/SingleSampleSource.java
@@ -23,6 +23,7 @@
 import com.google.android.exoplayer.util.Assertions;
 
 import android.net.Uri;
+import android.os.Handler;
 import android.os.SystemClock;
 
 import java.io.IOException;
@@ -34,6 +35,21 @@
 public final class SingleSampleSource implements SampleSource, SampleSourceReader, Loader.Callback,
     Loadable {
 
+  /**
+   * Interface definition for a callback to be notified of {@link SingleSampleSource} events.
+   */
+  public interface EventListener {
+
+    /**
+     * Invoked when an error occurs loading media data.
+     *
+     * @param sourceId The id of the reporting {@link SampleSource}.
+     * @param e The cause of the failure.
+     */
+    void onLoadError(int sourceId, IOException e);
+
+  }
+
   /**
    * The default minimum number of times to retry loading data prior to failing.
    */
@@ -52,6 +68,9 @@
   private final DataSource dataSource;
   private final MediaFormat format;
   private final int minLoadableRetryCount;
+  private final Handler eventHandler;
+  private final EventListener eventListener;
+  private final int eventSourceId;
 
   private int state;
   private byte[] sampleData;
@@ -70,10 +89,19 @@ public SingleSampleSource(Uri uri, DataSource dataSource, MediaFormat format) {
 
   public SingleSampleSource(Uri uri, DataSource dataSource, MediaFormat format,
       int minLoadableRetryCount) {
+    this(uri, dataSource, format, minLoadableRetryCount, null, null, 0);
+  }
+
+  public SingleSampleSource(Uri uri, DataSource dataSource, MediaFormat format,
+      int minLoadableRetryCount, Handler eventHandler, EventListener eventListener,
+      int eventSourceId) {
     this.uri = uri;
     this.dataSource = dataSource;
     this.format = format;
     this.minLoadableRetryCount = minLoadableRetryCount;
+    this.eventHandler = eventHandler;
+    this.eventListener = eventListener;
+    this.eventSourceId = eventSourceId;
     sampleData = new byte[INITIAL_SAMPLE_SIZE];
   }
 
@@ -222,6 +250,7 @@ public void onLoadError(Loadable loadable, IOException e) {
     currentLoadableException = e;
     currentLoadableExceptionCount++;
     currentLoadableExceptionTimestamp = SystemClock.elapsedRealtime();
+    notifyLoadError(e);
     maybeStartLoading();
   }
 
@@ -258,4 +287,15 @@ public void load() throws IOException, InterruptedException {
     }
   }
 
+  private void notifyLoadError(final IOException e) {
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable()  {
+        @Override
+        public void run() {
+          eventListener.onLoadError(eventSourceId, e);
+        }
+      });
+    }
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/audio/AudioCapabilities.java b/library/src/main/java/com/google/android/exoplayer/audio/AudioCapabilities.java
index f470f9ebab..33ff498aa7 100644
--- a/library/src/main/java/com/google/android/exoplayer/audio/AudioCapabilities.java
+++ b/library/src/main/java/com/google/android/exoplayer/audio/AudioCapabilities.java
@@ -32,9 +32,9 @@
 public final class AudioCapabilities {
 
   /**
-   * Default to stereo PCM on SDK < 21 and when HDMI is unplugged.
+   * The minimum audio capabilities supported by all devices.
    */
-  private static final AudioCapabilities DEFAULT_AUDIO_CAPABILITIES =
+  public static final AudioCapabilities DEFAULT_AUDIO_CAPABILITIES =
       new AudioCapabilities(new int[] {AudioFormat.ENCODING_PCM_16BIT}, 2);
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
index f7d4e12dfc..c1db4257a9 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
@@ -581,6 +581,7 @@ private boolean discardUpstreamMediaChunks(int queueLength) {
     while (mediaChunks.size() > queueLength) {
       removed = mediaChunks.removeLast();
       startTimeUs = removed.startTimeUs;
+      loadingFinished = false;
     }
     sampleQueue.discardUpstreamSamples(removed.getFirstSampleIndex());
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/Extractor.java
index 46b70232f6..98429e6a43 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/Extractor.java
@@ -97,4 +97,9 @@ int read(ExtractorInput input, PositionHolder seekPosition)
    */
   void seek();
 
+  /**
+   * Releases all kept resources.
+   */
+  void release();
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorInput.java b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorInput.java
index 6e03e932a6..31391dfd84 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorInput.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorInput.java
@@ -26,7 +26,7 @@
 public interface ExtractorInput {
 
   /**
-   * Reads up to {@code length} bytes from the input.
+   * Reads up to {@code length} bytes from the input and resets the peek position.
    * <p>
    * This method blocks until at least one byte of data can be read, the end of the input is
    * detected, or an exception is thrown.
@@ -153,7 +153,7 @@ boolean peekFully(byte[] target, int offset, int length, boolean allowEndOfInput
    * {@code offset}. The current read position is left unchanged.
    * <p>
    * Calling {@link #resetPeekPosition()} resets the peek position to equal the current read
-   * position, so the caller can peek the same data again. Reading and skipping also reset the peek
+   * position, so the caller can peek the same data again. Reading or skipping also resets the peek
    * position.
    *
    * @param target A target array into which data should be written.
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
index e0c5a84eb5..db640a5464 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
@@ -33,6 +33,7 @@
 import com.google.android.exoplayer.util.Util;
 
 import android.net.Uri;
+import android.os.Handler;
 import android.os.SystemClock;
 import android.util.SparseArray;
 
@@ -48,16 +49,17 @@
  * format will be detected automatically from the following supported formats:
  *
  * <ul>
- * <li>Fragmented MP4
- * ({@link com.google.android.exoplayer.extractor.mp4.FragmentedMp4Extractor})</li>
- * <li>Unfragmented MP4, including M4A
- * ({@link com.google.android.exoplayer.extractor.mp4.Mp4Extractor})</li>
- * <li>Matroska, including WebM
- * ({@link com.google.android.exoplayer.extractor.webm.WebmExtractor})</li>
+ * <li>MP4, including M4A ({@link com.google.android.exoplayer.extractor.mp4.Mp4Extractor})</li>
+ * <li>fMP4 ({@link com.google.android.exoplayer.extractor.mp4.FragmentedMp4Extractor})</li>
+ * <li>Matroska and WebM ({@link com.google.android.exoplayer.extractor.webm.WebmExtractor})</li>
+ * <li>Ogg Vorbis ({@link com.google.android.exoplayer.extractor.ogg.OggVorbisExtractor}</li>
  * <li>MP3 ({@link com.google.android.exoplayer.extractor.mp3.Mp3Extractor})</li>
  * <li>AAC ({@link com.google.android.exoplayer.extractor.ts.AdtsExtractor})</li>
- * <li>MPEG TS ({@link com.google.android.exoplayer.extractor.ts.TsExtractor}</li>
- * <li>FLV ({@link com.google.android.exoplayer.extractor.flv.FlvExtractor}</li>
+ * <li>MPEG TS ({@link com.google.android.exoplayer.extractor.ts.TsExtractor})</li>
+ * <li>MPEG PS ({@link com.google.android.exoplayer.extractor.ts.PsExtractor})</li>
+ * <li>FLV ({@link com.google.android.exoplayer.extractor.flv.FlvExtractor})</li>
+ * <li>WAV ({@link com.google.android.exoplayer.extractor.wav.WavExtractor})</li>
+ * <li>FLAC (only available if the FLAC extension is built and included)</li>
  * </ul>
  *
  * <p>Seeking in AAC, MPEG TS and FLV streams is not supported.
@@ -69,6 +71,21 @@
 public final class ExtractorSampleSource implements SampleSource, SampleSourceReader,
     ExtractorOutput, Loader.Callback {
 
+  /**
+   * Interface definition for a callback to be notified of {@link ExtractorSampleSource} events.
+   */
+  public interface EventListener {
+
+    /**
+     * Invoked when an error occurs loading media data.
+     *
+     * @param sourceId The id of the reporting {@link SampleSource}.
+     * @param e The cause of the failure.
+     */
+    void onLoadError(int sourceId, IOException e);
+
+  }
+
   /**
    * Thrown if the input format could not recognized.
    */
@@ -153,6 +170,13 @@ public UnrecognizedInputFormatException(Extractor[] extractors) {
     } catch (ClassNotFoundException e) {
       // Extractor not found.
     }
+    try {
+      DEFAULT_EXTRACTOR_CLASSES.add(
+          Class.forName("com.google.android.exoplayer.extractor.ogg.OggVorbisExtractor")
+              .asSubclass(Extractor.class));
+    } catch (ClassNotFoundException e) {
+      // Extractor not found.
+    }
     try {
       DEFAULT_EXTRACTOR_CLASSES.add(
           Class.forName("com.google.android.exoplayer.extractor.ts.PsExtractor")
@@ -160,6 +184,20 @@ public UnrecognizedInputFormatException(Extractor[] extractors) {
     } catch (ClassNotFoundException e) {
       // Extractor not found.
     }
+    try {
+      DEFAULT_EXTRACTOR_CLASSES.add(
+          Class.forName("com.google.android.exoplayer.extractor.wav.WavExtractor")
+              .asSubclass(Extractor.class));
+    } catch (ClassNotFoundException e) {
+      // Extractor not found.
+    }
+    try {
+      DEFAULT_EXTRACTOR_CLASSES.add(
+          Class.forName("com.google.android.exoplayer.ext.flac.FlacExtractor")
+              .asSubclass(Extractor.class));
+    } catch (ClassNotFoundException e) {
+      // Extractor not found.
+    }
   }
 
   private final ExtractorHolder extractorHolder;
@@ -169,6 +207,9 @@ public UnrecognizedInputFormatException(Extractor[] extractors) {
   private final int minLoadableRetryCount;
   private final Uri uri;
   private final DataSource dataSource;
+  private final Handler eventHandler;
+  private final EventListener eventListener;
+  private final int eventSourceId;
 
   private volatile boolean tracksBuilt;
   private volatile SeekMap seekMap;
@@ -217,6 +258,26 @@ public ExtractorSampleSource(Uri uri, DataSource dataSource, Allocator allocator
         extractors);
   }
 
+  /**
+   * @param uri The {@link Uri} of the media stream.
+   * @param dataSource A data source to read the media stream.
+   * @param allocator An {@link Allocator} from which to obtain memory allocations.
+   * @param requestedBufferSize The requested total buffer size for storing sample data, in bytes.
+   *     The actual allocated size may exceed the value passed in if the implementation requires it.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param eventSourceId An identifier that gets passed to {@code eventListener} methods.
+   * @param extractors {@link Extractor}s to extract the media stream, in order of decreasing
+   *     priority. If omitted, the default extractors will be used.
+   */
+  public ExtractorSampleSource(Uri uri, DataSource dataSource, Allocator allocator,
+      int requestedBufferSize, Handler eventHandler, EventListener eventListener,
+      int eventSourceId, Extractor... extractors) {
+    this(uri, dataSource, allocator, requestedBufferSize, MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA,
+        eventHandler, eventListener, eventSourceId, extractors);
+  }
+
   /**
    * @param uri The {@link Uri} of the media stream.
    * @param dataSource A data source to read the media stream.
@@ -230,8 +291,33 @@ public ExtractorSampleSource(Uri uri, DataSource dataSource, Allocator allocator
    */
   public ExtractorSampleSource(Uri uri, DataSource dataSource, Allocator allocator,
       int requestedBufferSize, int minLoadableRetryCount, Extractor... extractors) {
+    this(uri, dataSource, allocator, requestedBufferSize, minLoadableRetryCount, null, null, 0,
+        extractors);
+  }
+
+  /**
+   * @param uri The {@link Uri} of the media stream.
+   * @param dataSource A data source to read the media stream.
+   * @param allocator An {@link Allocator} from which to obtain memory allocations.
+   * @param requestedBufferSize The requested total buffer size for storing sample data, in bytes.
+   *     The actual allocated size may exceed the value passed in if the implementation requires it.
+   * @param minLoadableRetryCount The minimum number of times that the sample source will retry
+   *     if a loading error occurs.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param eventSourceId An identifier that gets passed to {@code eventListener} methods.
+   * @param extractors {@link Extractor}s to extract the media stream, in order of decreasing
+   *     priority. If omitted, the default extractors will be used.
+   */
+  public ExtractorSampleSource(Uri uri, DataSource dataSource, Allocator allocator,
+      int requestedBufferSize, int minLoadableRetryCount, Handler eventHandler,
+      EventListener eventListener, int eventSourceId, Extractor... extractors) {
     this.uri = uri;
     this.dataSource = dataSource;
+    this.eventListener = eventListener;
+    this.eventHandler = eventHandler;
+    this.eventSourceId = eventSourceId;
     this.allocator = allocator;
     this.requestedBufferSize = requestedBufferSize;
     this.minLoadableRetryCount = minLoadableRetryCount;
@@ -468,9 +554,15 @@ public long getBufferedPositionUs() {
   @Override
   public void release() {
     Assertions.checkState(remainingReleaseCount > 0);
-    if (--remainingReleaseCount == 0 && loader != null) {
-      loader.release();
-      loader = null;
+    if (--remainingReleaseCount == 0) {
+      if (loader != null) {
+        loader.release();
+        loader = null;
+      }
+      if (extractorHolder.extractor != null) {
+        extractorHolder.extractor.release();
+        extractorHolder.extractor = null;
+      }
     }
   }
 
@@ -497,6 +589,7 @@ public void onLoadError(Loadable ignored, IOException e) {
     currentLoadableExceptionCount = extractedSampleCount > extractedSampleCountAtStartOfLoad ? 1
         : currentLoadableExceptionCount + 1;
     currentLoadableExceptionTimestamp = SystemClock.elapsedRealtime();
+    notifyLoadError(e);
     maybeStartLoading();
   }
 
@@ -654,6 +747,17 @@ private long getRetryDelayMillis(long errorCount) {
     return Math.min((errorCount - 1) * 1000, 5000);
   }
 
+  private void notifyLoadError(final IOException e) {
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable()  {
+        @Override
+        public void run() {
+          eventListener.onLoadError(eventSourceId, e);
+        }
+      });
+    }
+  }
+
   /**
    * Extension of {@link DefaultTrackOutput} that increments a shared counter of the total number
    * of extracted samples.
@@ -787,8 +891,9 @@ public Extractor selectExtractor(ExtractorInput input)
           }
         } catch (EOFException e) {
           // Do nothing.
+        } finally {
+          input.resetPeekPosition();
         }
-        input.resetPeekPosition();
       }
       if (extractor == null) {
         throw new UnrecognizedInputFormatException(extractors);
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java b/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java
index 4a349494b7..48df138304 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java
@@ -528,8 +528,8 @@ public int getReadIndex() {
      * The first entry in {@code offsetHolder} is filled with the absolute position of the sample's
      * data in the rolling buffer.
      * <p>
-     * The fields set are {SampleHolder#size}, {SampleHolder#timeUs}, {SampleHolder#flags} and
-     * {@code offsetHolder[0]}.
+     * Populates {@link SampleHolder#size}, {@link SampleHolder#timeUs}, {@link SampleHolder#flags}
+     * and the {@code extrasHolder}.
      *
      * @param holder The holder into which the current sample information should be written.
      * @param extrasHolder The holder into which extra sample information should be written.
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/flv/FlvExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/flv/FlvExtractor.java
index d1c6c766bb..d179f65aee 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/flv/FlvExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/flv/FlvExtractor.java
@@ -120,6 +120,11 @@ public void seek() {
     bytesToNextTagHeader = 0;
   }
 
+  @Override
+  public void release() {
+    // Do nothing
+  }
+
   @Override
   public int read(ExtractorInput input, PositionHolder seekPosition) throws IOException,
       InterruptedException {
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/flv/VideoTagPayloadReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/flv/VideoTagPayloadReader.java
index 599ea01636..63cdcf0999 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/flv/VideoTagPayloadReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/flv/VideoTagPayloadReader.java
@@ -20,7 +20,6 @@
 import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.extractor.TrackOutput;
 import com.google.android.exoplayer.util.Assertions;
-import com.google.android.exoplayer.util.CodecSpecificDataUtil;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.NalUnitUtil;
 import com.google.android.exoplayer.util.ParsableBitArray;
@@ -165,7 +164,7 @@ private AvcSequenceHeaderData parseAvcCodecPrivate(ParsableByteArray buffer)
       ParsableBitArray spsDataBitArray = new ParsableBitArray(initializationData.get(0));
       // Skip the NAL header consisting of the nalUnitLengthField and the type (1 byte).
       spsDataBitArray.setPosition(8 * (nalUnitLengthFieldLength + 1));
-      CodecSpecificDataUtil.SpsData sps = CodecSpecificDataUtil.parseSpsNalUnit(spsDataBitArray);
+      NalUnitUtil.SpsData sps = NalUnitUtil.parseSpsNalUnit(spsDataBitArray);
       width = sps.width;
       height = sps.height;
       pixelWidthAspectRatio = sps.pixelWidthAspectRatio;
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
index 72f6e4b6ed..a962982d4e 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
@@ -110,6 +110,11 @@ public void seek() {
     sampleBytesRemaining = 0;
   }
 
+  @Override
+  public void release() {
+    // Do nothing
+  }
+
   @Override
   public int read(ExtractorInput input, PositionHolder seekPosition)
       throws IOException, InterruptedException {
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
index 9b3bb9c4f6..b7ab5d6c0e 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.extractor.GaplessInfo;
 import com.google.android.exoplayer.util.Ac3Util;
 import com.google.android.exoplayer.util.Assertions;
@@ -82,8 +83,10 @@ public static Track parseTrak(Atom.ContainerAtom trak, Atom.LeafAtom mvhd, boole
    * @param track Track to which this sample table corresponds.
    * @param stblAtom stbl (sample table) atom to parse.
    * @return Sample table described by the stbl atom.
+   * @throws ParserException If the resulting sample sequence does not contain a sync sample.
    */
-  public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAtom) {
+  public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAtom)
+      throws ParserException {
     // Array of sample sizes.
     ParsableByteArray stsz = stblAtom.getLeafAtomOfType(Atom.TYPE_stsz).data;
 
@@ -149,14 +152,7 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
     int timestampOffset = 0;
     if (ctts != null) {
       ctts.setPosition(Atom.FULL_HEADER_SIZE);
-      remainingTimestampOffsetChanges = ctts.readUnsignedIntToInt() - 1;
-      remainingSamplesAtTimestampOffset = ctts.readUnsignedIntToInt();
-      // The BMFF spec (ISO 14496-12) states that sample offsets should be unsigned integers in
-      // version 0 ctts boxes, however some streams violate the spec and use signed integers
-      // instead. It's safe to always parse sample offsets as signed integers here, because
-      // unsigned integers will still be parsed correctly (unless their top bit is set, which
-      // is never true in practice because sample offsets are always small).
-      timestampOffset = ctts.readInt();
+      remainingTimestampOffsetChanges = ctts.readUnsignedIntToInt();
     }
 
     int nextSynchronizationSampleIndex = -1;
@@ -177,6 +173,21 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
 
     long timestampTimeUnits = 0;
     for (int i = 0; i < sampleCount; i++) {
+      // Add on the timestamp offset if ctts is present.
+      if (ctts != null) {
+        while (remainingSamplesAtTimestampOffset == 0 && remainingTimestampOffsetChanges > 0) {
+          remainingSamplesAtTimestampOffset = ctts.readUnsignedIntToInt();
+          // The BMFF spec (ISO 14496-12) states that sample offsets should be unsigned integers in
+          // version 0 ctts boxes, however some streams violate the spec and use signed integers
+          // instead. It's safe to always parse sample offsets as signed integers here, because
+          // unsigned integers will still be parsed correctly (unless their top bit is set, which is
+          // never true in practice because sample offsets are always small).
+          timestampOffset = ctts.readInt();
+          remainingTimestampOffsetChanges--;
+        }
+        remainingSamplesAtTimestampOffset--;
+      }
+
       offsets[i] = offsetBytes;
       sizes[i] = fixedSampleSize == 0 ? stsz.readUnsignedIntToInt() : fixedSampleSize;
       if (sizes[i] > maximumSize) {
@@ -203,17 +214,6 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
         remainingTimestampDeltaChanges--;
       }
 
-      // Add on the timestamp offset if ctts is present.
-      if (ctts != null) {
-        remainingSamplesAtTimestampOffset--;
-        if (remainingSamplesAtTimestampOffset == 0 && remainingTimestampOffsetChanges > 0) {
-          remainingSamplesAtTimestampOffset = ctts.readUnsignedIntToInt();
-          // Read a signed offset even for version 0 ctts boxes (see comment above).
-          timestampOffset = ctts.readInt();
-          remainingTimestampOffsetChanges--;
-        }
-      }
-
       // If we're at the last sample in this chunk, move to the next chunk.
       remainingSamplesInChunk--;
       if (remainingSamplesInChunk == 0) {
@@ -327,6 +327,15 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
       }
       pts += duration;
     }
+
+    boolean hasSyncSample = false;
+    for (int i = 0; i < editedFlags.length && !hasSyncSample; i++) {
+      hasSyncSample |= (editedFlags[i] & C.SAMPLE_FLAG_SYNC) != 0;
+    }
+    if (!hasSyncSample) {
+      throw new ParserException("The edited sample sequence does not contain a sync sample.");
+    }
+
     return new TrackSampleTable(editedOffsets, editedSizes, editedMaximumSize, editedTimestamps,
         editedFlags);
   }
@@ -335,28 +344,46 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
    * Parses a udta atom.
    *
    * @param udtaAtom The udta (user data) atom to parse.
+   * @param isQuickTime True for QuickTime media. False otherwise.
    * @return Gapless playback information stored in the user data, or {@code null} if not present.
    */
-  public static GaplessInfo parseUdta(Atom.ContainerAtom udtaAtom) {
-    Atom.LeafAtom metaAtom = udtaAtom.getLeafAtomOfType(Atom.TYPE_meta);
-    if (metaAtom == null) {
+  public static GaplessInfo parseUdta(Atom.LeafAtom udtaAtom, boolean isQuickTime) {
+    if (isQuickTime) {
+      // Meta boxes are regular boxes rather than full boxes in QuickTime. For now, don't try and
+      // parse one.
       return null;
     }
-    ParsableByteArray data = metaAtom.data;
-    data.setPosition(Atom.FULL_HEADER_SIZE);
+    ParsableByteArray udtaData = udtaAtom.data;
+    udtaData.setPosition(Atom.HEADER_SIZE);
+    while (udtaData.bytesLeft() >= Atom.HEADER_SIZE) {
+      int atomSize = udtaData.readInt();
+      int atomType = udtaData.readInt();
+      if (atomType == Atom.TYPE_meta) {
+        udtaData.setPosition(udtaData.getPosition() - Atom.HEADER_SIZE);
+        udtaData.setLimit(udtaData.getPosition() + atomSize);
+        return parseMetaAtom(udtaData);
+      } else {
+        udtaData.skipBytes(atomSize - Atom.HEADER_SIZE);
+      }
+    }
+    return null;
+  }
+
+  private static GaplessInfo parseMetaAtom(ParsableByteArray data) {
+    data.skipBytes(Atom.FULL_HEADER_SIZE);
     ParsableByteArray ilst = new ParsableByteArray();
-    while (data.bytesLeft() > 0) {
-      int length = data.readInt() - Atom.HEADER_SIZE;
-      int type = data.readInt();
-      if (type == Atom.TYPE_ilst) {
-        ilst.reset(data.data, data.getPosition() + length);
+    while (data.bytesLeft() >= Atom.HEADER_SIZE) {
+      int payloadSize = data.readInt() - Atom.HEADER_SIZE;
+      int atomType = data.readInt();
+      if (atomType == Atom.TYPE_ilst) {
+        ilst.reset(data.data, data.getPosition() + payloadSize);
         ilst.setPosition(data.getPosition());
         GaplessInfo gaplessInfo = parseIlst(ilst);
         if (gaplessInfo != null) {
           return gaplessInfo;
         }
       }
-      data.skipBytes(length);
+      data.skipBytes(payloadSize);
     }
     return null;
   }
@@ -643,8 +670,7 @@ private static AvcCData parseAvcCFromParent(ParsableByteArray parent, int positi
       ParsableBitArray spsDataBitArray = new ParsableBitArray(initializationData.get(0));
       // Skip the NAL header consisting of the nalUnitLengthField and the type (1 byte).
       spsDataBitArray.setPosition(8 * (nalUnitLengthFieldLength + 1));
-      pixelWidthAspectRatio = CodecSpecificDataUtil.parseSpsNalUnit(spsDataBitArray)
-          .pixelWidthAspectRatio;
+      pixelWidthAspectRatio = NalUnitUtil.parseSpsNalUnit(spsDataBitArray).pixelWidthAspectRatio;
     }
 
     return new AvcCData(initializationData, nalUnitLengthFieldLength, pixelWidthAspectRatio);
@@ -907,10 +933,7 @@ private static int findEsdsPosition(ParsableByteArray parent, int position, int
     parent.setPosition(position + Atom.HEADER_SIZE + 4);
     // Start of the ES_Descriptor (defined in 14496-1)
     parent.skipBytes(1); // ES_Descriptor tag
-    int varIntByte = parent.readUnsignedByte();
-    while (varIntByte > 127) {
-      varIntByte = parent.readUnsignedByte();
-    }
+    parseExpandableClassSize(parent);
     parent.skipBytes(2); // ES_ID
 
     int flags = parent.readUnsignedByte();
@@ -926,10 +949,7 @@ private static int findEsdsPosition(ParsableByteArray parent, int position, int
 
     // Start of the DecoderConfigDescriptor (defined in 14496-1)
     parent.skipBytes(1); // DecoderConfigDescriptor tag
-    varIntByte = parent.readUnsignedByte();
-    while (varIntByte > 127) {
-      varIntByte = parent.readUnsignedByte();
-    }
+    parseExpandableClassSize(parent);
 
     // Set the MIME type based on the object type indication (14496-1 table 5).
     int objectTypeIndication = parent.readUnsignedByte();
@@ -976,18 +996,23 @@ private static int findEsdsPosition(ParsableByteArray parent, int position, int
 
     // Start of the AudioSpecificConfig.
     parent.skipBytes(1); // AudioSpecificConfig tag
-    varIntByte = parent.readUnsignedByte();
-    int varInt = varIntByte & 0x7F;
-    while (varIntByte > 127) {
-      varIntByte = parent.readUnsignedByte();
-      varInt = varInt << 8;
-      varInt |= varIntByte & 0x7F;
-    }
-    byte[] initializationData = new byte[varInt];
-    parent.readBytes(initializationData, 0, varInt);
+    int initializationDataSize = parseExpandableClassSize(parent);
+    byte[] initializationData = new byte[initializationDataSize];
+    parent.readBytes(initializationData, 0, initializationDataSize);
     return Pair.create(mimeType, initializationData);
   }
 
+  /** Parses the size of an expandable class, as specified by ISO 14496-1 subsection 8.3.3. */
+  private static int parseExpandableClassSize(ParsableByteArray data) {
+    int currentByte = data.readUnsignedByte();
+    int size = currentByte & 0x7F;
+    while ((currentByte & 0x80) == 0x80) {
+      currentByte = data.readUnsignedByte();
+      size = (size << 7) | (currentByte & 0x7F);
+    }
+    return size;
+  }
+
   private AtomParsers() {
     // Prevent instantiation.
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
index e9d402efd2..4ca0266824 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
@@ -28,12 +28,15 @@
 import com.google.android.exoplayer.extractor.TrackOutput;
 import com.google.android.exoplayer.extractor.mp4.Atom.ContainerAtom;
 import com.google.android.exoplayer.extractor.mp4.Atom.LeafAtom;
+import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.NalUnitUtil;
 import com.google.android.exoplayer.util.ParsableByteArray;
 import com.google.android.exoplayer.util.Util;
 
 import android.util.Log;
+import android.util.Pair;
+import android.util.SparseArray;
 
 import java.io.IOException;
 import java.util.Arrays;
@@ -43,8 +46,6 @@
 
 /**
  * Facilitates the extraction of data from the fragmented mp4 container format.
- * <p>
- * This implementation only supports de-muxed (i.e. single track) streams.
  */
 public final class FragmentedMp4Extractor implements Extractor {
 
@@ -57,35 +58,45 @@
    * <p>
    * This flag does nothing if the stream is not a video stream.
    */
-  public static final int WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME = 1;
+  public static final int FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME = 1;
 
   /**
    * Flag to ignore any tfdt boxes in the stream.
    */
-  public static final int WORKAROUND_IGNORE_TFDT_BOX = 2;
+  public static final int FLAG_WORKAROUND_IGNORE_TFDT_BOX = 2;
+
+  /**
+   * Flag to indicate that the {@link Track} was sideloaded, instead of being declared by the MP4
+   * container.
+   */
+  private static final int FLAG_SIDELOADED = 4;
 
   private static final byte[] PIFF_SAMPLE_ENCRYPTION_BOX_EXTENDED_TYPE =
       new byte[] {-94, 57, 79, 82, 90, -101, 79, 20, -94, 68, 108, 66, 124, 100, -115, -12};
 
-  // Parser states
+  // Parser states.
   private static final int STATE_READING_ATOM_HEADER = 0;
   private static final int STATE_READING_ATOM_PAYLOAD = 1;
   private static final int STATE_READING_ENCRYPTION_DATA = 2;
   private static final int STATE_READING_SAMPLE_START = 3;
   private static final int STATE_READING_SAMPLE_CONTINUE = 4;
 
-  private final int workaroundFlags;
+  // Workarounds.
+  private final int flags;
+  private final Track sideloadedTrack;
+
+  // Track-linked data bundle, accessible as a whole through trackID.
+  private final SparseArray<TrackBundle> trackBundles;
 
   // Temporary arrays.
   private final ParsableByteArray nalStartCode;
   private final ParsableByteArray nalLength;
   private final ParsableByteArray encryptionSignalByte;
 
-  // Parser state
+  // Parser state.
   private final ParsableByteArray atomHeader;
   private final byte[] extendedTypeScratch;
   private final Stack<ContainerAtom> containerAtoms;
-  private final TrackFragment fragmentRun;
 
   private int parserState;
   private int atomType;
@@ -94,18 +105,13 @@
   private ParsableByteArray atomData;
   private long endOfMdatPosition;
 
-  private int sampleIndex;
+  private TrackBundle currentTrackBundle;
   private int sampleSize;
   private int sampleBytesWritten;
   private int sampleCurrentNalBytesRemaining;
 
-  // Data parsed from moov atom.
-  private Track track;
-  private DefaultSampleValues extendsDefaults;
-
-  // Extractor outputs.
+  // Extractor output.
   private ExtractorOutput extractorOutput;
-  private TrackOutput trackOutput;
 
   // Whether extractorOutput.seekMap has been invoked.
   private boolean haveOutputSeekMap;
@@ -115,18 +121,27 @@ public FragmentedMp4Extractor() {
   }
 
   /**
-   * @param workaroundFlags Flags to allow parsing of faulty streams.
-   *     {@link #WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME} is currently the only flag defined.
+   * @param flags Flags to allow parsing of faulty streams.
+   */
+  public FragmentedMp4Extractor(int flags) {
+    this(flags, null);
+  }
+
+  /**
+   * @param flags Flags to allow parsing of faulty streams.
+   * @param sideloadedTrack Sideloaded track information, in the case that the extractor
+   *     will not receive a moov box in the input data.
    */
-  public FragmentedMp4Extractor(int workaroundFlags) {
-    this.workaroundFlags = workaroundFlags;
+  public FragmentedMp4Extractor(int flags, Track sideloadedTrack) {
+    this.sideloadedTrack = sideloadedTrack;
+    this.flags = flags | (sideloadedTrack != null ? FLAG_SIDELOADED : 0);
     atomHeader = new ParsableByteArray(Atom.LONG_HEADER_SIZE);
     nalStartCode = new ParsableByteArray(NalUnitUtil.NAL_START_CODE);
     nalLength = new ParsableByteArray(4);
     encryptionSignalByte = new ParsableByteArray(1);
     extendedTypeScratch = new byte[16];
     containerAtoms = new Stack<>();
-    fragmentRun = new TrackFragment();
+    trackBundles = new SparseArray<>();
     enterReadingAtomHeaderState();
   }
 
@@ -135,25 +150,15 @@ public boolean sniff(ExtractorInput input) throws IOException, InterruptedExcept
     return Sniffer.sniffFragmented(input);
   }
 
-  /**
-   * Sideloads track information into the extractor.
-   * <p>
-   * Should be called before {@link #read(ExtractorInput, PositionHolder)} in the case that the
-   * extractor will not receive a moov atom in the input data, from which track information would
-   * normally be parsed.
-   *
-   * @param track The track to sideload.
-   */
-  public void setTrack(Track track) {
-    this.extendsDefaults = new DefaultSampleValues(0, 0, 0, 0);
-    this.track = track;
-  }
-
   @Override
   public void init(ExtractorOutput output) {
     extractorOutput = output;
-    trackOutput = output.track(0);
-    extractorOutput.endTracks();
+    if (sideloadedTrack != null) {
+      TrackBundle bundle = new TrackBundle(output.track(0));
+      bundle.init(sideloadedTrack, new DefaultSampleValues(0, 0, 0, 0));
+      trackBundles.put(0, bundle);
+      extractorOutput.endTracks();
+    }
   }
 
   @Override
@@ -162,6 +167,11 @@ public void seek() {
     enterReadingAtomHeaderState();
   }
 
+  @Override
+  public void release() {
+    // Do nothing
+  }
+
   @Override
   public int read(ExtractorInput input, PositionHolder seekPosition)
       throws IOException, InterruptedException {
@@ -214,28 +224,34 @@ private boolean readAtomHeader(ExtractorInput input) throws IOException, Interru
     long atomPosition = input.getPosition() - atomHeaderBytesRead;
     if (atomType == Atom.TYPE_moof) {
       // The data positions may be updated when parsing the tfhd/trun.
-      fragmentRun.auxiliaryDataPosition = atomPosition;
-      fragmentRun.dataPosition = atomPosition;
+      int trackCount = trackBundles.size();
+      for (int i = 0; i < trackCount; i++) {
+        TrackFragment fragment = trackBundles.valueAt(i).fragment;
+        fragment.auxiliaryDataPosition = atomPosition;
+        fragment.dataPosition = atomPosition;
+      }
     }
 
     if (atomType == Atom.TYPE_mdat) {
+      currentTrackBundle = null;
       endOfMdatPosition = atomPosition + atomSize;
       if (!haveOutputSeekMap) {
         extractorOutput.seekMap(SeekMap.UNSEEKABLE);
         haveOutputSeekMap = true;
       }
-      if (fragmentRun.sampleEncryptionDataNeedsFill) {
-        parserState = STATE_READING_ENCRYPTION_DATA;
-      } else {
-        parserState = STATE_READING_SAMPLE_START;
-      }
+      parserState = STATE_READING_ENCRYPTION_DATA;
       return true;
     }
 
     if (shouldParseContainerAtom(atomType)) {
       long endPosition = input.getPosition() + atomSize - Atom.HEADER_SIZE;
       containerAtoms.add(new ContainerAtom(atomType, endPosition));
-      enterReadingAtomHeaderState();
+      if (atomSize == atomHeaderBytesRead) {
+        processAtomEnded(endPosition);
+      } else {
+        // Start reading the first child atom.
+        enterReadingAtomHeaderState();
+      }
     } else if (shouldParseLeafAtom(atomType)) {
       if (atomHeaderBytesRead != Atom.HEADER_SIZE) {
         throw new ParserException("Leaf atom defines extended atom size (unsupported).");
@@ -265,8 +281,11 @@ private void readAtomPayload(ExtractorInput input) throws IOException, Interrupt
     } else {
       input.skipFully(atomPayloadSize);
     }
-    long currentPosition = input.getPosition();
-    while (!containerAtoms.isEmpty() && containerAtoms.peek().endPosition == currentPosition) {
+    processAtomEnded(input.getPosition());
+  }
+
+  private void processAtomEnded(long atomEndPosition) throws ParserException {
+    while (!containerAtoms.isEmpty() && containerAtoms.peek().endPosition == atomEndPosition) {
       onContainerAtomRead(containerAtoms.pop());
     }
     enterReadingAtomHeaderState();
@@ -292,13 +311,14 @@ private void onContainerAtomRead(ContainerAtom container) throws ParserException
     }
   }
 
-  private void onMoovContainerAtomRead(ContainerAtom moov) throws ParserException {
-    List<Atom.LeafAtom> moovChildren = moov.leafChildren;
-    int moovChildrenSize = moovChildren.size();
+  private void onMoovContainerAtomRead(ContainerAtom moov) {
+    Assertions.checkState(sideloadedTrack == null, "Unexpected moov box.");
+    List<Atom.LeafAtom> moovLeafChildren = moov.leafChildren;
+    int moovLeafChildrenSize = moovLeafChildren.size();
 
     DrmInitData.Mapped drmInitData = null;
-    for (int i = 0; i < moovChildrenSize; i++) {
-      LeafAtom child = moovChildren.get(i);
+    for (int i = 0; i < moovLeafChildrenSize; i++) {
+      LeafAtom child = moovLeafChildren.get(i);
       if (child.type == Atom.TYPE_pssh) {
         if (drmInitData == null) {
           drmInitData = new DrmInitData.Mapped();
@@ -317,90 +337,130 @@ private void onMoovContainerAtomRead(ContainerAtom moov) throws ParserException
       extractorOutput.drmInitData(drmInitData);
     }
 
+    // Read declaration of track fragments in the Moov box.
     ContainerAtom mvex = moov.getContainerAtomOfType(Atom.TYPE_mvex);
-    extendsDefaults = parseTrex(mvex.getLeafAtomOfType(Atom.TYPE_trex).data);
-    track = AtomParsers.parseTrak(moov.getContainerAtomOfType(Atom.TYPE_trak),
-        moov.getLeafAtomOfType(Atom.TYPE_mvhd), false);
-    if (track == null) {
-      throw new ParserException("Track type not supported.");
+    SparseArray<DefaultSampleValues> defaultSampleValuesArray = new SparseArray<>();
+    int mvexChildrenSize = mvex.leafChildren.size();
+    for (int i = 0; i < mvexChildrenSize; i++) {
+      Atom.LeafAtom atom = mvex.leafChildren.get(i);
+      if (atom.type == Atom.TYPE_trex) {
+        Pair<Integer, DefaultSampleValues> trexData = parseTrex(atom.data);
+        defaultSampleValuesArray.put(trexData.first, trexData.second);
+      }
+    }
+
+    // Construction of tracks.
+    SparseArray<Track> tracks = new SparseArray<>();
+    int moovContainerChildrenSize = moov.containerChildren.size();
+    for (int i = 0; i < moovContainerChildrenSize; i++) {
+      Atom.ContainerAtom atom = moov.containerChildren.get(i);
+      if (atom.type == Atom.TYPE_trak) {
+        Track track = AtomParsers.parseTrak(atom, moov.getLeafAtomOfType(Atom.TYPE_mvhd), false);
+        if (track != null) {
+          tracks.put(track.id, track);
+        }
+      }
+    }
+    int trackCount = tracks.size();
+
+    if (trackBundles.size() == 0) {
+      // We need to create the track bundles.
+      for (int i = 0; i < trackCount; i++) {
+        trackBundles.put(tracks.valueAt(i).id, new TrackBundle(extractorOutput.track(i)));
+      }
+      extractorOutput.endTracks();
+    } else {
+      Assertions.checkState(trackBundles.size() == trackCount);
+    }
+
+    // Initialization of tracks and default sample values.
+    for (int i = 0; i < trackCount; i++) {
+      Track track = tracks.valueAt(i);
+      trackBundles.get(track.id).init(track, defaultSampleValuesArray.get(track.id));
     }
-    trackOutput.format(track.mediaFormat);
   }
 
   private void onMoofContainerAtomRead(ContainerAtom moof) throws ParserException {
-    fragmentRun.reset();
-    parseMoof(track, extendsDefaults, moof, fragmentRun, workaroundFlags, extendedTypeScratch);
-    sampleIndex = 0;
+    parseMoof(moof, trackBundles, flags, extendedTypeScratch);
   }
 
   /**
    * Parses a trex atom (defined in 14496-12).
    */
-  private static DefaultSampleValues parseTrex(ParsableByteArray trex) {
-    trex.setPosition(Atom.FULL_HEADER_SIZE + 4);
+  private static Pair<Integer, DefaultSampleValues> parseTrex(ParsableByteArray trex) {
+    trex.setPosition(Atom.FULL_HEADER_SIZE);
+    int trackId = trex.readInt();
     int defaultSampleDescriptionIndex = trex.readUnsignedIntToInt() - 1;
     int defaultSampleDuration = trex.readUnsignedIntToInt();
     int defaultSampleSize = trex.readUnsignedIntToInt();
     int defaultSampleFlags = trex.readInt();
-    return new DefaultSampleValues(defaultSampleDescriptionIndex, defaultSampleDuration,
-        defaultSampleSize, defaultSampleFlags);
+
+    return Pair.create(trackId, new DefaultSampleValues(defaultSampleDescriptionIndex,
+        defaultSampleDuration, defaultSampleSize, defaultSampleFlags));
   }
 
-  private static void parseMoof(Track track, DefaultSampleValues extendsDefaults,
-      ContainerAtom moof, TrackFragment out, int workaroundFlags, byte[] extendedTypeScratch)
-      throws ParserException {
-    if (moof.getChildAtomOfTypeCount(Atom.TYPE_traf) != 1) {
-      throw new ParserException("Traf count in moof != 1 (unsupported).");
+  private static void parseMoof(ContainerAtom moof, SparseArray<TrackBundle> trackBundleArray,
+      int flags, byte[] extendedTypeScratch) throws ParserException {
+    int moofContainerChildrenSize = moof.containerChildren.size();
+    for (int i = 0; i < moofContainerChildrenSize; i++) {
+      Atom.ContainerAtom child = moof.containerChildren.get(i);
+      if (child.type == Atom.TYPE_traf) {
+        parseTraf(child, trackBundleArray, flags, extendedTypeScratch);
+      }
     }
-    parseTraf(track, extendsDefaults, moof.getContainerAtomOfType(Atom.TYPE_traf),
-        out, workaroundFlags, extendedTypeScratch);
   }
 
   /**
    * Parses a traf atom (defined in 14496-12).
    */
-  private static void parseTraf(Track track, DefaultSampleValues extendsDefaults,
-      ContainerAtom traf, TrackFragment out, int workaroundFlags, byte[] extendedTypeScratch)
-      throws ParserException {
+  private static void parseTraf(ContainerAtom traf, SparseArray<TrackBundle> trackBundleArray,
+      int flags, byte[] extendedTypeScratch) throws ParserException {
     if (traf.getChildAtomOfTypeCount(Atom.TYPE_trun) != 1) {
       throw new ParserException("Trun count in traf != 1 (unsupported).");
     }
+
+    LeafAtom tfhd = traf.getLeafAtomOfType(Atom.TYPE_tfhd);
+    TrackBundle trackBundle = parseTfhd(tfhd.data, trackBundleArray, flags);
+    if (trackBundle == null) {
+      return;
+    }
+    TrackFragment fragment = trackBundle.fragment;
+    trackBundle.currentSampleIndex = 0;
+    fragment.reset();
+
     LeafAtom tfdtAtom = traf.getLeafAtomOfType(Atom.TYPE_tfdt);
     long decodeTime;
-    if (tfdtAtom == null || (workaroundFlags & WORKAROUND_IGNORE_TFDT_BOX) != 0) {
+    if (tfdtAtom == null || (flags & FLAG_WORKAROUND_IGNORE_TFDT_BOX) != 0) {
       decodeTime = 0;
     } else {
       decodeTime = parseTfdt(traf.getLeafAtomOfType(Atom.TYPE_tfdt).data);
     }
 
-    LeafAtom tfhd = traf.getLeafAtomOfType(Atom.TYPE_tfhd);
-    parseTfhd(extendsDefaults, tfhd.data, out);
-
     LeafAtom trun = traf.getLeafAtomOfType(Atom.TYPE_trun);
-    parseTrun(track, out.header, decodeTime, workaroundFlags, trun.data, out);
+    parseTrun(trackBundle, decodeTime, flags, trun.data);
 
     LeafAtom saiz = traf.getLeafAtomOfType(Atom.TYPE_saiz);
     if (saiz != null) {
-      TrackEncryptionBox trackEncryptionBox =
-          track.sampleDescriptionEncryptionBoxes[out.header.sampleDescriptionIndex];
-      parseSaiz(trackEncryptionBox, saiz.data, out);
+      TrackEncryptionBox trackEncryptionBox = trackBundle.track
+          .sampleDescriptionEncryptionBoxes[fragment.header.sampleDescriptionIndex];
+      parseSaiz(trackEncryptionBox, saiz.data, fragment);
     }
 
     LeafAtom saio = traf.getLeafAtomOfType(Atom.TYPE_saio);
     if (saio != null) {
-      parseSaio(saio.data, out);
+      parseSaio(saio.data, fragment);
     }
 
     LeafAtom senc = traf.getLeafAtomOfType(Atom.TYPE_senc);
     if (senc != null) {
-      parseSenc(senc.data, out);
+      parseSenc(senc.data, fragment);
     }
 
     int childrenSize = traf.leafChildren.size();
     for (int i = 0; i < childrenSize; i++) {
       LeafAtom atom = traf.leafChildren.get(i);
       if (atom.type == Atom.TYPE_uuid) {
-        parseUuid(atom.data, out, extendedTypeScratch);
+        parseUuid(atom.data, fragment, extendedTypeScratch);
       }
     }
   }
@@ -441,7 +501,7 @@ private static void parseSaiz(TrackEncryptionBox encryptionBox, ParsableByteArra
    * Parses a saio atom (defined in 14496-12).
    *
    * @param saio The saio atom to parse.
-   * @param out The track fragment to populate with data from the saio atom.
+   * @param out The {@link TrackFragment} to populate with data from the saio atom.
    */
   private static void parseSaio(ParsableByteArray saio, TrackFragment out) throws ParserException {
     saio.setPosition(Atom.HEADER_SIZE);
@@ -463,36 +523,44 @@ private static void parseSaio(ParsableByteArray saio, TrackFragment out) throws
   }
 
   /**
-   * Parses a tfhd atom (defined in 14496-12).
+   * Parses a tfhd atom (defined in 14496-12), updates the corresponding {@link TrackFragment} and
+   * returns the {@link TrackBundle} of the corresponding {@link Track}. If the tfhd does not refer
+   * to any {@link TrackBundle}, {@code null} is returned and no changes are made.
    *
-   * @param extendsDefaults Default sample values from the trex atom.
    * @param tfhd The tfhd atom to parse.
-   * @param out The track fragment to populate with data from the tfhd atom.
+   * @param trackBundles The track bundles, one of which corresponds to the tfhd atom being parsed.
+   * @return The {@link TrackBundle} to which the {@link TrackFragment} belongs, or null if the tfhd
+   *     does not refer to any {@link TrackBundle}.
    */
-  private static void parseTfhd(DefaultSampleValues extendsDefaults, ParsableByteArray tfhd,
-      TrackFragment out) {
+  private static TrackBundle parseTfhd(ParsableByteArray tfhd,
+      SparseArray<TrackBundle> trackBundles, int flags) {
     tfhd.setPosition(Atom.HEADER_SIZE);
     int fullAtom = tfhd.readInt();
-    int flags = Atom.parseFullAtomFlags(fullAtom);
-
-    tfhd.skipBytes(4); // trackId
-    if ((flags & 0x01 /* base_data_offset_present */) != 0) {
+    int atomFlags = Atom.parseFullAtomFlags(fullAtom);
+    int trackId = tfhd.readInt();
+    TrackBundle trackBundle = trackBundles.get((flags & FLAG_SIDELOADED) == 0 ? trackId : 0);
+    if (trackBundle == null) {
+      return null;
+    }
+    if ((atomFlags & 0x01 /* base_data_offset_present */) != 0) {
       long baseDataPosition = tfhd.readUnsignedLongToLong();
-      out.dataPosition = baseDataPosition;
-      out.auxiliaryDataPosition = baseDataPosition;
+      trackBundle.fragment.dataPosition = baseDataPosition;
+      trackBundle.fragment.auxiliaryDataPosition = baseDataPosition;
     }
 
+    DefaultSampleValues defaultSampleValues = trackBundle.defaultSampleValues;
     int defaultSampleDescriptionIndex =
-        ((flags & 0x02 /* default_sample_description_index_present */) != 0)
-        ? tfhd.readUnsignedIntToInt() - 1 : extendsDefaults.sampleDescriptionIndex;
-    int defaultSampleDuration = ((flags & 0x08 /* default_sample_duration_present */) != 0)
-        ? tfhd.readUnsignedIntToInt() : extendsDefaults.duration;
-    int defaultSampleSize = ((flags & 0x10 /* default_sample_size_present */) != 0)
-        ? tfhd.readUnsignedIntToInt() : extendsDefaults.size;
-    int defaultSampleFlags = ((flags & 0x20 /* default_sample_flags_present */) != 0)
-        ? tfhd.readUnsignedIntToInt() : extendsDefaults.flags;
-    out.header = new DefaultSampleValues(defaultSampleDescriptionIndex, defaultSampleDuration,
-        defaultSampleSize, defaultSampleFlags);
+        ((atomFlags & 0x02 /* default_sample_description_index_present */) != 0)
+        ? tfhd.readUnsignedIntToInt() - 1 : defaultSampleValues.sampleDescriptionIndex;
+    int defaultSampleDuration = ((atomFlags & 0x08 /* default_sample_duration_present */) != 0)
+        ? tfhd.readUnsignedIntToInt() : defaultSampleValues.duration;
+    int defaultSampleSize = ((atomFlags & 0x10 /* default_sample_size_present */) != 0)
+        ? tfhd.readUnsignedIntToInt() : defaultSampleValues.size;
+    int defaultSampleFlags = ((atomFlags & 0x20 /* default_sample_flags_present */) != 0)
+        ? tfhd.readUnsignedIntToInt() : defaultSampleValues.flags;
+    trackBundle.fragment.header = new DefaultSampleValues(defaultSampleDescriptionIndex,
+        defaultSampleDuration, defaultSampleSize, defaultSampleFlags);
+    return trackBundle;
   }
 
   /**
@@ -511,34 +579,38 @@ private static long parseTfdt(ParsableByteArray tfdt) {
   /**
    * Parses a trun atom (defined in 14496-12).
    *
-   * @param track The corresponding track.
-   * @param defaultSampleValues Default sample values.
-   * @param decodeTime The decode time.
+   * @param trackBundle The {@link TrackBundle} that contains the {@link TrackFragment} into
+   *     which parsed data should be placed.
+   * @param decodeTime The decode time of the first sample in the fragment run.
+   * @param flags Flags to allow any required workaround to be executed.
    * @param trun The trun atom to parse.
-   * @param out The {@TrackFragment} into which parsed data should be placed.
    */
-  private static void parseTrun(Track track, DefaultSampleValues defaultSampleValues,
-      long decodeTime, int workaroundFlags, ParsableByteArray trun, TrackFragment out) {
+  private static void parseTrun(TrackBundle trackBundle, long decodeTime, int flags,
+      ParsableByteArray trun) {
     trun.setPosition(Atom.HEADER_SIZE);
     int fullAtom = trun.readInt();
-    int flags = Atom.parseFullAtomFlags(fullAtom);
+    int atomFlags = Atom.parseFullAtomFlags(fullAtom);
+
+    Track track = trackBundle.track;
+    TrackFragment fragment = trackBundle.fragment;
+    DefaultSampleValues defaultSampleValues = fragment.header;
 
     int sampleCount = trun.readUnsignedIntToInt();
-    if ((flags & 0x01 /* data_offset_present */) != 0) {
-      out.dataPosition += trun.readInt();
+    if ((atomFlags & 0x01 /* data_offset_present */) != 0) {
+      fragment.dataPosition += trun.readInt();
     }
 
-    boolean firstSampleFlagsPresent = (flags & 0x04 /* first_sample_flags_present */) != 0;
+    boolean firstSampleFlagsPresent = (atomFlags & 0x04 /* first_sample_flags_present */) != 0;
     int firstSampleFlags = defaultSampleValues.flags;
     if (firstSampleFlagsPresent) {
       firstSampleFlags = trun.readUnsignedIntToInt();
     }
 
-    boolean sampleDurationsPresent = (flags & 0x100 /* sample_duration_present */) != 0;
-    boolean sampleSizesPresent = (flags & 0x200 /* sample_size_present */) != 0;
-    boolean sampleFlagsPresent = (flags & 0x400 /* sample_flags_present */) != 0;
+    boolean sampleDurationsPresent = (atomFlags & 0x100 /* sample_duration_present */) != 0;
+    boolean sampleSizesPresent = (atomFlags & 0x200 /* sample_size_present */) != 0;
+    boolean sampleFlagsPresent = (atomFlags & 0x400 /* sample_flags_present */) != 0;
     boolean sampleCompositionTimeOffsetsPresent =
-        (flags & 0x800 /* sample_composition_time_offsets_present */) != 0;
+        (atomFlags & 0x800 /* sample_composition_time_offsets_present */) != 0;
 
     // Offset to the entire video timeline. In the presence of B-frames this is usually used to
     // ensure that the first frame's presentation timestamp is zero.
@@ -551,16 +623,16 @@ private static void parseTrun(Track track, DefaultSampleValues defaultSampleValu
       edtsOffset = Util.scaleLargeTimestamp(track.editListMediaTimes[0], 1000, track.timescale);
     }
 
-    out.initTables(sampleCount);
-    int[] sampleSizeTable = out.sampleSizeTable;
-    int[] sampleCompositionTimeOffsetTable = out.sampleCompositionTimeOffsetTable;
-    long[] sampleDecodingTimeTable = out.sampleDecodingTimeTable;
-    boolean[] sampleIsSyncFrameTable = out.sampleIsSyncFrameTable;
+    fragment.initTables(sampleCount);
+    int[] sampleSizeTable = fragment.sampleSizeTable;
+    int[] sampleCompositionTimeOffsetTable = fragment.sampleCompositionTimeOffsetTable;
+    long[] sampleDecodingTimeTable = fragment.sampleDecodingTimeTable;
+    boolean[] sampleIsSyncFrameTable = fragment.sampleIsSyncFrameTable;
 
     long timescale = track.timescale;
     long cumulativeTime = decodeTime;
     boolean workaroundEveryVideoFrameIsSyncFrame = track.type == Track.TYPE_vide
-        && (workaroundFlags & WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME) != 0;
+        && (flags & FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME) != 0;
     for (int i = 0; i < sampleCount; i++) {
       // Use trun values if present, otherwise tfhd, otherwise trex.
       int sampleDuration = sampleDurationsPresent ? trun.readUnsignedIntToInt()
@@ -688,13 +760,27 @@ private static ChunkIndex parseSidx(ParsableByteArray atom, long inputPosition)
   }
 
   private void readEncryptionData(ExtractorInput input) throws IOException, InterruptedException {
-    int bytesToSkip = (int) (fragmentRun.auxiliaryDataPosition - input.getPosition());
+    TrackBundle nextTrackBundle = null;
+    long nextDataOffset = Long.MAX_VALUE;
+    int trackBundlesSize = trackBundles.size();
+    for (int i = 0; i < trackBundlesSize; i++) {
+      TrackFragment trackFragment = trackBundles.valueAt(i).fragment;
+      if (trackFragment.sampleEncryptionDataNeedsFill
+          && trackFragment.auxiliaryDataPosition < nextDataOffset) {
+        nextDataOffset = trackFragment.auxiliaryDataPosition;
+        nextTrackBundle = trackBundles.valueAt(i);
+      }
+    }
+    if (nextTrackBundle == null) {
+      parserState = STATE_READING_SAMPLE_START;
+      return;
+    }
+    int bytesToSkip = (int) (nextDataOffset - input.getPosition());
     if (bytesToSkip < 0) {
       throw new ParserException("Offset to encryption data was negative.");
     }
     input.skipFully(bytesToSkip);
-    fragmentRun.fillEncryptionData(input);
-    parserState = STATE_READING_SAMPLE_START;
+    nextTrackBundle.fragment.fillEncryptionData(input);
   }
 
   /**
@@ -713,36 +799,44 @@ private void readEncryptionData(ExtractorInput input) throws IOException, Interr
    */
   private boolean readSample(ExtractorInput input) throws IOException, InterruptedException {
     if (parserState == STATE_READING_SAMPLE_START) {
-      if (sampleIndex == fragmentRun.length) {
-        // We've run out of samples in the current mdat. Discard any trailing data and prepare to
-        // read the header of the next atom.
-        int bytesToSkip = (int) (endOfMdatPosition - input.getPosition());
-        if (bytesToSkip < 0) {
-          throw new ParserException("Offset to end of mdat was negative.");
+      if (currentTrackBundle == null) {
+        currentTrackBundle = getNextFragmentRun(trackBundles);
+        if (currentTrackBundle == null) {
+          // We've run out of samples in the current mdat. Discard any trailing data and prepare to
+          // read the header of the next atom.
+          int bytesToSkip = (int) (endOfMdatPosition - input.getPosition());
+          if (bytesToSkip < 0) {
+            throw new ParserException("Offset to end of mdat was negative.");
+          }
+          input.skipFully(bytesToSkip);
+          enterReadingAtomHeaderState();
+          return false;
         }
-        input.skipFully(bytesToSkip);
-        enterReadingAtomHeaderState();
-        return false;
-      }
-      if (sampleIndex == 0) {
-        // We're reading the first sample in the current mdat. Discard any preceding data.
-        int bytesToSkip = (int) (fragmentRun.dataPosition - input.getPosition());
+
+        long nextDataPosition = currentTrackBundle.fragment.dataPosition;
+        // We skip bytes preceding the next sample to read.
+        int bytesToSkip = (int) (nextDataPosition - input.getPosition());
         if (bytesToSkip < 0) {
           throw new ParserException("Offset to sample data was negative.");
         }
         input.skipFully(bytesToSkip);
       }
-      sampleSize = fragmentRun.sampleSizeTable[sampleIndex];
-      if (fragmentRun.definesEncryptionData) {
-        sampleBytesWritten = appendSampleEncryptionData(fragmentRun.sampleEncryptionData);
+      sampleSize = currentTrackBundle.fragment
+          .sampleSizeTable[currentTrackBundle.currentSampleIndex];
+      if (currentTrackBundle.fragment.definesEncryptionData) {
+        sampleBytesWritten = appendSampleEncryptionData(currentTrackBundle);
         sampleSize += sampleBytesWritten;
       } else {
         sampleBytesWritten = 0;
       }
-      sampleCurrentNalBytesRemaining = 0;
       parserState = STATE_READING_SAMPLE_CONTINUE;
+      sampleCurrentNalBytesRemaining = 0;
     }
 
+    TrackFragment fragment = currentTrackBundle.fragment;
+    Track track = currentTrackBundle.track;
+    TrackOutput output = currentTrackBundle.output;
+    int sampleIndex = currentTrackBundle.currentSampleIndex;
     if (track.nalUnitLengthFieldLength != -1) {
       // Zero the top three bytes of the array that we'll use to parse nal unit lengths, in case
       // they're only 1 or 2 bytes long.
@@ -763,49 +857,88 @@ private boolean readSample(ExtractorInput input) throws IOException, Interrupted
           sampleCurrentNalBytesRemaining = nalLength.readUnsignedIntToInt();
           // Write a start code for the current NAL unit.
           nalStartCode.setPosition(0);
-          trackOutput.sampleData(nalStartCode, 4);
+          output.sampleData(nalStartCode, 4);
           sampleBytesWritten += 4;
           sampleSize += nalUnitLengthFieldLengthDiff;
         } else {
           // Write the payload of the NAL unit.
-          int writtenBytes = trackOutput.sampleData(input, sampleCurrentNalBytesRemaining, false);
+          int writtenBytes = output.sampleData(input, sampleCurrentNalBytesRemaining, false);
           sampleBytesWritten += writtenBytes;
           sampleCurrentNalBytesRemaining -= writtenBytes;
         }
       }
     } else {
       while (sampleBytesWritten < sampleSize) {
-        int writtenBytes = trackOutput.sampleData(input, sampleSize - sampleBytesWritten, false);
+        int writtenBytes = output.sampleData(input, sampleSize - sampleBytesWritten, false);
         sampleBytesWritten += writtenBytes;
       }
     }
 
-    long sampleTimeUs = fragmentRun.getSamplePresentationTime(sampleIndex) * 1000L;
-    int sampleFlags = (fragmentRun.definesEncryptionData ? C.SAMPLE_FLAG_ENCRYPTED : 0)
-        | (fragmentRun.sampleIsSyncFrameTable[sampleIndex] ? C.SAMPLE_FLAG_SYNC : 0);
-    int sampleDescriptionIndex = fragmentRun.header.sampleDescriptionIndex;
-    byte[] encryptionKey = fragmentRun.definesEncryptionData
+    long sampleTimeUs = fragment.getSamplePresentationTime(sampleIndex) * 1000L;
+    int sampleFlags = (fragment.definesEncryptionData ? C.SAMPLE_FLAG_ENCRYPTED : 0)
+        | (fragment.sampleIsSyncFrameTable[sampleIndex] ? C.SAMPLE_FLAG_SYNC : 0);
+    int sampleDescriptionIndex = fragment.header.sampleDescriptionIndex;
+    byte[] encryptionKey = fragment.definesEncryptionData
         ? track.sampleDescriptionEncryptionBoxes[sampleDescriptionIndex].keyId : null;
-    trackOutput.sampleMetadata(sampleTimeUs, sampleFlags, sampleSize, 0, encryptionKey);
+    output.sampleMetadata(sampleTimeUs, sampleFlags, sampleSize, 0, encryptionKey);
 
-    sampleIndex++;
+    currentTrackBundle.currentSampleIndex++;
+    if (currentTrackBundle.currentSampleIndex == fragment.length) {
+      currentTrackBundle = null;
+    }
     parserState = STATE_READING_SAMPLE_START;
     return true;
   }
 
-  private int appendSampleEncryptionData(ParsableByteArray sampleEncryptionData) {
-    int sampleDescriptionIndex = fragmentRun.header.sampleDescriptionIndex;
-    TrackEncryptionBox encryptionBox =
-        track.sampleDescriptionEncryptionBoxes[sampleDescriptionIndex];
+  /**
+   * Returns the {@link TrackBundle} whose fragment run has the earliest file position out of those
+   * yet to be consumed, or null if all have been consumed.
+   */
+  private static TrackBundle getNextFragmentRun(SparseArray<TrackBundle> trackBundles) {
+    TrackBundle nextTrackBundle = null;
+    long nextTrackRunOffset = Long.MAX_VALUE;
+
+    int trackBundlesSize = trackBundles.size();
+    for (int i = 0; i < trackBundlesSize; i++) {
+      TrackBundle trackBundle = trackBundles.valueAt(i);
+      if (trackBundle.currentSampleIndex == trackBundle.fragment.length) {
+        // This track fragment contains no more runs in the next mdat box.
+      } else {
+        long trunOffset = trackBundle.fragment.dataPosition;
+        if (trunOffset < nextTrackRunOffset) {
+          nextTrackBundle = trackBundle;
+          nextTrackRunOffset = trunOffset;
+        }
+      }
+    }
+    return nextTrackBundle;
+  }
+
+  /**
+   * Appends the corresponding encryption data to the {@link TrackOutput} contained in the given
+   * {@link TrackBundle}.
+   *
+   * @param trackBundle The {@link TrackBundle} that contains the {@link Track} for which the
+   *     Sample encryption data must be output.
+   * @return The number of written bytes.
+   */
+  private int appendSampleEncryptionData(TrackBundle trackBundle) {
+    TrackFragment trackFragment = trackBundle.fragment;
+    ParsableByteArray sampleEncryptionData = trackFragment.sampleEncryptionData;
+    int sampleDescriptionIndex = trackFragment.header.sampleDescriptionIndex;
+    TrackEncryptionBox encryptionBox = trackBundle.track
+        .sampleDescriptionEncryptionBoxes[sampleDescriptionIndex];
     int vectorSize = encryptionBox.initializationVectorSize;
-    boolean subsampleEncryption = fragmentRun.sampleHasSubsampleEncryptionTable[sampleIndex];
+    boolean subsampleEncryption = trackFragment
+        .sampleHasSubsampleEncryptionTable[trackBundle.currentSampleIndex];
 
     // Write the signal byte, containing the vector size and the subsample encryption flag.
     encryptionSignalByte.data[0] = (byte) (vectorSize | (subsampleEncryption ? 0x80 : 0));
     encryptionSignalByte.setPosition(0);
-    trackOutput.sampleData(encryptionSignalByte, 1);
+    TrackOutput output = trackBundle.output;
+    output.sampleData(encryptionSignalByte, 1);
     // Write the vector.
-    trackOutput.sampleData(sampleEncryptionData, vectorSize);
+    output.sampleData(sampleEncryptionData, vectorSize);
     // If we don't have subsample encryption data, we're done.
     if (!subsampleEncryption) {
       return 1 + vectorSize;
@@ -814,7 +947,7 @@ private int appendSampleEncryptionData(ParsableByteArray sampleEncryptionData) {
     int subsampleCount = sampleEncryptionData.readUnsignedShort();
     sampleEncryptionData.skipBytes(-2);
     int subsampleDataLength = 2 + 6 * subsampleCount;
-    trackOutput.sampleData(sampleEncryptionData, subsampleDataLength);
+    output.sampleData(sampleEncryptionData, subsampleDataLength);
     return 1 + vectorSize + subsampleDataLength;
   }
 
@@ -835,4 +968,31 @@ private static boolean shouldParseContainerAtom(int atom) {
         || atom == Atom.TYPE_traf || atom == Atom.TYPE_mvex || atom == Atom.TYPE_edts;
   }
 
+  /**
+   * Holds data corresponding to a single track.
+   */
+  private static final class TrackBundle {
+
+    public final TrackFragment fragment;
+    public final TrackOutput output;
+
+    public Track track;
+    public DefaultSampleValues defaultSampleValues;
+    public int currentSampleIndex;
+
+    public TrackBundle(TrackOutput output) {
+      fragment = new TrackFragment();
+      this.output = output;
+    }
+
+    public void init(Track track, DefaultSampleValues defaultSampleValues) {
+      this.track = Assertions.checkNotNull(track);
+      this.defaultSampleValues = Assertions.checkNotNull(defaultSampleValues);
+      output.format(track.mediaFormat);
+      fragment.reset();
+      currentSampleIndex = 0;
+    }
+
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
index 4d5500054d..ff25ea03bc 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer.extractor.mp4;
 
 import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.extractor.Extractor;
 import com.google.android.exoplayer.extractor.ExtractorInput;
 import com.google.android.exoplayer.extractor.ExtractorOutput;
@@ -103,6 +104,11 @@ public void seek() {
     parserState = STATE_AFTER_SEEK;
   }
 
+  @Override
+  public void release() {
+    // Do nothing
+  }
+
   @Override
   public int read(ExtractorInput input, PositionHolder seekPosition)
       throws IOException, InterruptedException {
@@ -188,7 +194,12 @@ private boolean readAtomHeader(ExtractorInput input) throws IOException, Interru
     if (shouldParseContainerAtom(atomType)) {
       long endPosition = input.getPosition() + atomSize - atomHeaderBytesRead;
       containerAtoms.add(new ContainerAtom(atomType, endPosition));
-      enterReadingAtomHeaderState();
+      if (atomSize == atomHeaderBytesRead) {
+        processAtomEnded(endPosition);
+      } else {
+        // Start reading the first child atom.
+        enterReadingAtomHeaderState();
+      }
     } else if (shouldParseLeafAtom(atomType)) {
       // We don't support parsing of leaf atoms that define extended atom sizes, or that have
       // lengths greater than Integer.MAX_VALUE.
@@ -231,7 +242,11 @@ private boolean readAtomPayload(ExtractorInput input, PositionHolder positionHol
         seekRequired = true;
       }
     }
+    processAtomEnded(atomEndPosition);
+    return seekRequired && parserState != STATE_READING_SAMPLE;
+  }
 
+  private void processAtomEnded(long atomEndPosition) throws ParserException {
     while (!containerAtoms.isEmpty() && containerAtoms.peek().endPosition == atomEndPosition) {
       Atom.ContainerAtom containerAtom = containerAtoms.pop();
       if (containerAtom.type == Atom.TYPE_moov) {
@@ -239,14 +254,13 @@ private boolean readAtomPayload(ExtractorInput input, PositionHolder positionHol
         processMoovAtom(containerAtom);
         containerAtoms.clear();
         parserState = STATE_READING_SAMPLE;
-        return false;
       } else if (!containerAtoms.isEmpty()) {
         containerAtoms.peek().add(containerAtom);
       }
     }
-
-    enterReadingAtomHeaderState();
-    return seekRequired;
+    if (parserState != STATE_READING_SAMPLE) {
+      enterReadingAtomHeaderState();
+    }
   }
 
   /**
@@ -273,13 +287,13 @@ private static boolean processFtypAtom(ParsableByteArray atomData) {
   /**
    * Updates the stored track metadata to reflect the contents of the specified moov atom.
    */
-  private void processMoovAtom(ContainerAtom moov) {
+  private void processMoovAtom(ContainerAtom moov) throws ParserException {
     List<Mp4Track> tracks = new ArrayList<>();
     long earliestSampleOffset = Long.MAX_VALUE;
     GaplessInfo gaplessInfo = null;
-    Atom.ContainerAtom udta = moov.getContainerAtomOfType(Atom.TYPE_udta);
+    Atom.LeafAtom udta = moov.getLeafAtomOfType(Atom.TYPE_udta);
     if (udta != null) {
-      gaplessInfo = AtomParsers.parseUdta(udta);
+      gaplessInfo = AtomParsers.parseUdta(udta, isQuickTime);
     }
     for (int i = 0; i < moov.containerChildren.size(); i++) {
       Atom.ContainerAtom atom = moov.containerChildren.get(i);
@@ -432,7 +446,7 @@ private static boolean shouldParseLeafAtom(int atom) {
         || atom == Atom.TYPE_stsd || atom == Atom.TYPE_stts || atom == Atom.TYPE_stss
         || atom == Atom.TYPE_ctts || atom == Atom.TYPE_elst || atom == Atom.TYPE_stsc
         || atom == Atom.TYPE_stsz || atom == Atom.TYPE_stco || atom == Atom.TYPE_co64
-        || atom == Atom.TYPE_tkhd || atom == Atom.TYPE_ftyp || atom == Atom.TYPE_meta;
+        || atom == Atom.TYPE_tkhd || atom == Atom.TYPE_ftyp || atom == Atom.TYPE_udta;
   }
 
   /**
@@ -440,8 +454,7 @@ private static boolean shouldParseLeafAtom(int atom) {
    */
   private static boolean shouldParseContainerAtom(int atom) {
     return atom == Atom.TYPE_moov || atom == Atom.TYPE_trak || atom == Atom.TYPE_mdia
-        || atom == Atom.TYPE_minf || atom == Atom.TYPE_stbl || atom == Atom.TYPE_edts
-        || atom == Atom.TYPE_udta;
+        || atom == Atom.TYPE_minf || atom == Atom.TYPE_stbl || atom == Atom.TYPE_edts;
   }
 
   private static final class Mp4Track {
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggReader.java
new file mode 100644
index 0000000000..3fb2ed473a
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggReader.java
@@ -0,0 +1,176 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ogg;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.ogg.OggUtil.PacketInfoHolder;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.io.IOException;
+
+/**
+ * Reads OGG packets from an {@link ExtractorInput}.
+ */
+/* package */ final class OggReader {
+
+  public static final int OGG_MAX_SEGMENT_SIZE = 255;
+
+  private final OggUtil.PageHeader pageHeader = new OggUtil.PageHeader();
+  private final ParsableByteArray headerArray = new ParsableByteArray(27 + 255);
+  private final PacketInfoHolder holder = new PacketInfoHolder();
+
+  private int currentSegmentIndex = -1;
+  private long elapsedSamples;
+
+  /**
+   * Resets this reader.
+   */
+  public void reset() {
+    pageHeader.reset();
+    headerArray.reset();
+    currentSegmentIndex = -1;
+  }
+
+  /**
+   * Reads the next packet of the ogg stream. In case of an {@code IOException} the caller must make
+   * sure to pass the same instance of {@code ParsableByteArray} to this method again so this reader
+   * can resume properly from an error while reading a continued packet spanned across multiple
+   * pages.
+   *
+   * @param input the {@link ExtractorInput} to read data from.
+   * @param packetArray the {@link ParsableByteArray} to write the packet data into.
+   * @return {@code true} if the read was successful. {@code false} if the end of the input was
+   *    encountered having read no data.
+   * @throws IOException thrown if reading from the input fails.
+   * @throws InterruptedException thrown if interrupted while reading from input.
+   */
+  public boolean readPacket(ExtractorInput input, ParsableByteArray packetArray)
+      throws IOException, InterruptedException {
+    Assertions.checkState(input != null && packetArray != null);
+
+    boolean packetComplete = false;
+    while (!packetComplete) {
+      if (currentSegmentIndex < 0) {
+        // We're at the start of a page.
+        if (!OggUtil.populatePageHeader(input, pageHeader, headerArray, true)) {
+          return false;
+        }
+        int segmentIndex = 0;
+        int bytesToSkip = pageHeader.headerSize;
+        if ((pageHeader.type & 0x01) == 0x01 && packetArray.limit() == 0) {
+          // After seeking, the first packet may be the remainder
+          // part of a continued packet which has to be discarded.
+          OggUtil.calculatePacketSize(pageHeader, segmentIndex, holder);
+          segmentIndex += holder.segmentCount;
+          bytesToSkip += holder.size;
+        }
+        input.skipFully(bytesToSkip);
+        currentSegmentIndex = segmentIndex;
+      }
+
+      OggUtil.calculatePacketSize(pageHeader, currentSegmentIndex, holder);
+      int segmentIndex = currentSegmentIndex + holder.segmentCount;
+      if (holder.size > 0) {
+        input.readFully(packetArray.data, packetArray.limit(), holder.size);
+        packetArray.setLimit(packetArray.limit() + holder.size);
+        packetComplete = pageHeader.laces[segmentIndex - 1] != 255;
+      }
+      // advance now since we are sure reading didn't throw an exception
+      currentSegmentIndex = segmentIndex == pageHeader.pageSegmentCount ? -1
+          : segmentIndex;
+    }
+    return true;
+  }
+
+  /**
+   * Skips to the last Ogg page in the stream and reads the header's granule field which is the
+   * total number of samples per channel.
+   *
+   * @param input The {@link ExtractorInput} to read from.
+   * @return the total number of samples of this input.
+   * @throws IOException thrown if reading from the input fails.
+   * @throws InterruptedException thrown if interrupted while reading from the input.
+   */
+  public long readGranuleOfLastPage(ExtractorInput input)
+      throws IOException, InterruptedException {
+    Assertions.checkArgument(input.getLength() != C.LENGTH_UNBOUNDED); // never read forever!
+    OggUtil.skipToNextPage(input);
+    pageHeader.reset();
+    while ((pageHeader.type & 0x04) != 0x04) {
+      if (pageHeader.bodySize > 0) {
+        input.skipFully(pageHeader.bodySize);
+      }
+      OggUtil.populatePageHeader(input, pageHeader, headerArray, false);
+      input.skipFully(pageHeader.headerSize);
+    }
+    return pageHeader.granulePosition;
+  }
+
+  /**
+   * Skips to the position of the start of the page containing the {@code targetGranule} and
+   * returns the elapsed samples which is the granule of the page previous to the target page.
+   * <p>
+   * Note that the position of the {@code input} must be before the start of the page previous to
+   * the page containing the targetGranule to get the correct number of elapsed samples.
+   * Which is in short like: {@code pos(input) <= pos(targetPage.pageSequence - 1)}.
+   *
+   * @param input the {@link ExtractorInput} to read from.
+   * @param targetGranule the target granule (number of frames per channel).
+   * @return the number of elapsed samples at the start of the target page.
+   * @throws ParserException thrown if populating the page header fails.
+   * @throws IOException thrown if reading from the input fails.
+   * @throws InterruptedException thrown if interrupted while reading from the input.
+   */
+  public long skipToPageOfGranule(ExtractorInput input, long targetGranule)
+      throws IOException, InterruptedException {
+    OggUtil.skipToNextPage(input);
+    OggUtil.populatePageHeader(input, pageHeader, headerArray, false);
+    while (pageHeader.granulePosition < targetGranule) {
+      input.skipFully(pageHeader.headerSize + pageHeader.bodySize);
+      // Store in a member field to be able to resume after IOExceptions.
+      elapsedSamples = pageHeader.granulePosition;
+      // Peek next header.
+      OggUtil.populatePageHeader(input, pageHeader, headerArray, false);
+    }
+    if (elapsedSamples == 0) {
+      throw new ParserException();
+    }
+    input.resetPeekPosition();
+    long returnValue = elapsedSamples;
+    // Reset member state.
+    elapsedSamples = 0;
+    currentSegmentIndex = -1;
+    return returnValue;
+  }
+
+  /**
+   * Returns the {@link OggUtil.PageHeader} of the current page. The header might not have been
+   * populated if the first packet has yet to be read.
+   * <p>
+   * Note that there is only a single instance of {@code OggReader.PageHeader} which is mutable.
+   * The value of the fields might be changed by the reader when reading the stream advances and
+   * the next page is read (which implies reading and populating the next header).
+   *
+   * @return the {@code PageHeader} of the current page or {@code null}.
+   */
+  public OggUtil.PageHeader getPageHeader() {
+    return pageHeader;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggSeeker.java b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggSeeker.java
new file mode 100644
index 0000000000..7466c8d2e8
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggSeeker.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ogg;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.io.IOException;
+
+/**
+ * Used to seek in an Ogg stream.
+ */
+/* package */ final class OggSeeker {
+
+  private static final int MATCH_RANGE = 72000;
+
+  private final OggUtil.PageHeader pageHeader = new OggUtil.PageHeader();
+  private final ParsableByteArray headerArray = new ParsableByteArray(27 + 255);
+  private long audioDataLength = C.LENGTH_UNBOUNDED;
+  private long totalSamples;
+
+  /**
+   * Setup the seeker with the data it needs to to an educated guess of seeking positions.
+   *
+   * @param audioDataLength the length of the audio data (total bytes - header bytes).
+   * @param totalSamples the total number of samples of audio data.
+   */
+  public void setup(long audioDataLength, long totalSamples) {
+    Assertions.checkArgument(audioDataLength > 0 && totalSamples > 0);
+    this.audioDataLength = audioDataLength;
+    this.totalSamples = totalSamples;
+  }
+
+  /**
+   * Resets this {@code OggSeeker}.
+   */
+  public void reset() {
+    pageHeader.reset();
+    headerArray.reset();
+  }
+
+  /**
+   * Returns a position converging to the {@code targetGranule} to which the {@link ExtractorInput}
+   * has to seek and then be passed for another call until -1 is return. If -1 is returned the
+   * input is at a position which is before the start of the page before the target page and at
+   * which it is sensible to just skip pages to the target granule and pre-roll instead of doing
+   * another seek request.
+   *
+   * @param targetGranule the target granule position to seek to.
+   * @param input the {@link ExtractorInput} to read from.
+   * @return the position to seek the {@link ExtractorInput} to for a next call or -1 if it's close
+   *    enough to skip to the target page.
+   * @throws IOException thrown if reading from the input fails.
+   * @throws InterruptedException thrown if interrupted while reading from the input.
+   */
+  public long getNextSeekPosition(long targetGranule, ExtractorInput input)
+      throws IOException, InterruptedException {
+    Assertions.checkState(audioDataLength != C.LENGTH_UNBOUNDED && totalSamples != 0);
+    OggUtil.populatePageHeader(input, pageHeader, headerArray, false);
+    long granuleDistance = targetGranule - pageHeader.granulePosition;
+    if (granuleDistance <= 0 || granuleDistance > MATCH_RANGE) {
+      // estimated position too high or too low
+      long offset = (pageHeader.bodySize + pageHeader.headerSize)
+          * (granuleDistance <= 0 ? 2 : 1);
+      return input.getPosition() - offset + (granuleDistance * audioDataLength / totalSamples);
+    }
+    // position accepted (below target granule and within MATCH_RANGE)
+    input.resetPeekPosition();
+    return -1;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggUtil.java b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggUtil.java
new file mode 100644
index 0000000000..d62ba6ef42
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggUtil.java
@@ -0,0 +1,209 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ogg;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.util.ParsableByteArray;
+import com.google.android.exoplayer.util.Util;
+
+import java.io.EOFException;
+import java.io.IOException;
+
+/**
+ * Utility methods for reading ogg streams.
+ */
+/* package */ final class OggUtil {
+
+  private static final int TYPE_OGGS = Util.getIntegerCodeForString("OggS");
+
+  /**
+   * Reads an int of {@code length} bits from {@code src} starting at
+   * {@code leastSignificantBitIndex}.
+   *
+   * @param src the {@code byte} to read from.
+   * @param length the length in bits of the int to read.
+   * @param leastSignificantBitIndex the index of the least significant bit of the int to read.
+   * @return the int value read.
+   */
+  public static int readBits(byte src, int length, int leastSignificantBitIndex) {
+    return (src >> leastSignificantBitIndex) & (255 >>> (8 - length));
+  }
+
+  /**
+   * Skips to the next page.
+   *
+   * @param input The {@code ExtractorInput} to skip to the next page.
+   * @throws IOException thrown if peeking/reading from the input fails.
+   * @throws InterruptedException thrown if interrupted while peeking/reading from the input.
+   */
+  public static void skipToNextPage(ExtractorInput input)
+      throws IOException, InterruptedException {
+
+    byte[] buffer = new byte[2048];
+    int peekLength = buffer.length;
+    while (true) {
+      if (input.getLength() != C.LENGTH_UNBOUNDED
+          && input.getPosition() + peekLength > input.getLength()) {
+        // Make sure to not peek beyond the end of the input.
+        peekLength = (int) (input.getLength() - input.getPosition());
+        if (peekLength < 4) {
+          // Not found until eof.
+          throw new EOFException();
+        }
+      }
+      input.peekFully(buffer, 0, peekLength, false);
+      for (int i = 0; i < peekLength - 3; i++) {
+        if (buffer[i] == 'O' && buffer[i + 1] == 'g' && buffer[i + 2] == 'g'
+            && buffer[i + 3] == 'S') {
+          // Match! Skip to the start of the pattern.
+          input.skipFully(i);
+          return;
+        }
+      }
+      // Overlap by not skipping the entire peekLength.
+      input.skipFully(peekLength - 3);
+    }
+  }
+
+  /**
+   * Peeks an Ogg page header and stores the data in the {@code header} object passed
+   * as argument.
+   *
+   * @param input the {@link ExtractorInput} to read from.
+   * @param header the {@link PageHeader} to read from.
+   * @param scratch a scratch array temporary use.
+   * @param quite if {@code true} no Exceptions are thrown but {@code false} is return if something
+   *     goes wrong.
+   * @return {@code true} if the read was successful. {@code false} if the end of the
+   *     input was encountered having read no data.
+   * @throws IOException thrown if reading data fails or the stream is invalid.
+   * @throws InterruptedException thrown if thread is interrupted when reading/peeking.
+   */
+  public static boolean populatePageHeader(ExtractorInput input, PageHeader header,
+      ParsableByteArray scratch, boolean quite) throws IOException, InterruptedException {
+
+    scratch.reset();
+    header.reset();
+    boolean hasEnoughBytes = input.getLength() == C.LENGTH_UNBOUNDED
+        || input.getLength() - input.getPeekPosition() >= 27;
+    if (!hasEnoughBytes || !input.peekFully(scratch.data, 0, 27, true)) {
+      if (quite) {
+        return false;
+      } else {
+        throw new EOFException();
+      }
+    }
+    if (scratch.readUnsignedInt() != TYPE_OGGS) {
+      if (quite) {
+        return false;
+      } else {
+        throw new ParserException("expected OggS capture pattern at begin of page");
+      }
+    }
+
+    header.revision = scratch.readUnsignedByte();
+    if (header.revision != 0x00) {
+      if (quite) {
+        return false;
+      } else {
+        throw new ParserException("unsupported bit stream revision");
+      }
+    }
+    header.type = scratch.readUnsignedByte();
+
+    header.granulePosition = scratch.readLittleEndianLong();
+    header.streamSerialNumber = scratch.readLittleEndianUnsignedInt();
+    header.pageSequenceNumber = scratch.readLittleEndianUnsignedInt();
+    header.pageChecksum = scratch.readLittleEndianUnsignedInt();
+    header.pageSegmentCount = scratch.readUnsignedByte();
+
+    scratch.reset();
+    // calculate total size of header including laces
+    header.headerSize = 27 + header.pageSegmentCount;
+    input.peekFully(scratch.data, 0, header.pageSegmentCount);
+    for (int i = 0; i < header.pageSegmentCount; i++) {
+      header.laces[i] = scratch.readUnsignedByte();
+      header.bodySize += header.laces[i];
+    }
+    return true;
+  }
+
+  /**
+   * Calculates the size of the packet starting from {@code startSegmentIndex}.
+   *
+   * @param header the {@link PageHeader} with laces.
+   * @param startSegmentIndex the index of the first segment of the packet.
+   * @param holder a position holder to store the resulting size value.
+   */
+  public static void calculatePacketSize(PageHeader header, int startSegmentIndex,
+      PacketInfoHolder holder) {
+    holder.segmentCount = 0;
+    holder.size = 0;
+    while (startSegmentIndex + holder.segmentCount < header.pageSegmentCount) {
+      int segmentLength = header.laces[startSegmentIndex + holder.segmentCount++];
+      holder.size += segmentLength;
+      if (segmentLength != 255) {
+        // packets end at first lace < 255
+        break;
+      }
+    }
+  }
+
+  /**
+   * Data object to store header information. Be aware that {@code laces.length} is always 255.
+   * Instead use {@code pageSegmentCount} to iterate.
+   */
+  public static final class PageHeader {
+
+    public int revision;
+    public int type;
+    public long granulePosition;
+    public long streamSerialNumber;
+    public long pageSequenceNumber;
+    public long pageChecksum;
+    public int pageSegmentCount;
+    public int headerSize;
+    public int bodySize;
+    public final int[] laces = new int[255];
+
+    /**
+     * Resets all primitive member fields to zero.
+     */
+    public void reset() {
+      revision = 0;
+      type = 0;
+      granulePosition = 0;
+      streamSerialNumber = 0;
+      pageSequenceNumber = 0;
+      pageChecksum = 0;
+      pageSegmentCount = 0;
+      headerSize = 0;
+      bodySize = 0;
+    }
+
+  }
+
+  /**
+   * Holds size and number of segments of a packet.
+   */
+  public static class PacketInfoHolder {
+    public int size;
+    public int segmentCount;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggVorbisExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggVorbisExtractor.java
new file mode 100644
index 0000000000..94124048ab
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/OggVorbisExtractor.java
@@ -0,0 +1,279 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ogg;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.ExtractorOutput;
+import com.google.android.exoplayer.extractor.PositionHolder;
+import com.google.android.exoplayer.extractor.SeekMap;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.extractor.ogg.VorbisUtil.Mode;
+import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+/**
+ * {@link Extractor} to extract Vorbis data out of Ogg byte stream.
+ */
+public final class OggVorbisExtractor implements Extractor, SeekMap {
+
+  private final ParsableByteArray scratch = new ParsableByteArray(
+      new byte[OggReader.OGG_MAX_SEGMENT_SIZE * 255], 0);
+
+  private final OggReader oggReader = new OggReader();
+
+  private TrackOutput trackOutput;
+  private VorbisSetup vorbisSetup;
+  private int previousPacketBlockSize;
+  private long elapsedSamples;
+  private boolean seenFirstAudioPacket;
+
+  private final OggSeeker oggSeeker = new OggSeeker();
+  private long targetGranule = -1;
+
+  private ExtractorOutput extractorOutput;
+  private VorbisUtil.VorbisIdHeader vorbisIdHeader;
+  private VorbisUtil.CommentHeader commentHeader;
+  private long inputLength;
+  private long audioStartPosition;
+  private long totalSamples;
+  private long duration;
+
+  @Override
+  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+    try {
+      OggUtil.PageHeader header = new OggUtil.PageHeader();
+      if (!OggUtil.populatePageHeader(input, header, scratch, true)
+          || (header.type & 0x02) != 0x02 || header.bodySize < 7) {
+        return false;
+      }
+      scratch.reset();
+      input.peekFully(scratch.data, 0, 7);
+      return VorbisUtil.verifyVorbisHeaderCapturePattern(0x01, scratch, true);
+    } catch (ParserException e) {
+      // does not happen
+    } finally {
+      scratch.reset();
+    }
+    return false;
+  }
+
+  @Override
+  public void init(ExtractorOutput output) {
+    trackOutput = output.track(0);
+    output.endTracks();
+    extractorOutput = output;
+  }
+
+  @Override
+  public void seek() {
+    oggReader.reset();
+    previousPacketBlockSize = 0;
+    elapsedSamples = 0;
+    seenFirstAudioPacket = false;
+    scratch.reset();
+  }
+
+  @Override
+  public void release() {
+    // Do nothing
+  }
+
+  @Override
+  public int read(ExtractorInput input, PositionHolder seekPosition)
+      throws IOException, InterruptedException {
+
+    // setup
+    if (totalSamples == 0) {
+      if (vorbisSetup == null) {
+        inputLength = input.getLength();
+        vorbisSetup = readSetupHeaders(input, scratch);
+        audioStartPosition = input.getPosition();
+        extractorOutput.seekMap(this);
+        if (inputLength != C.LENGTH_UNBOUNDED) {
+          // seek to the end just before the last page of stream to get the duration
+          seekPosition.position = input.getLength() - 8000;
+          return RESULT_SEEK;
+        }
+      }
+      totalSamples = inputLength == C.LENGTH_UNBOUNDED ? -1
+          : oggReader.readGranuleOfLastPage(input);
+
+      ArrayList<byte[]> codecInitialisationData = new ArrayList<>();
+      codecInitialisationData.add(vorbisSetup.idHeader.data);
+      codecInitialisationData.add(vorbisSetup.setupHeaderData);
+
+      duration = inputLength == C.LENGTH_UNBOUNDED ? C.UNKNOWN_TIME_US
+          : totalSamples * C.MICROS_PER_SECOND / vorbisSetup.idHeader.sampleRate;
+      trackOutput.format(MediaFormat.createAudioFormat(null, MimeTypes.AUDIO_VORBIS,
+          this.vorbisSetup.idHeader.bitrateNominal, OggReader.OGG_MAX_SEGMENT_SIZE * 255, duration,
+          this.vorbisSetup.idHeader.channels, (int) this.vorbisSetup.idHeader.sampleRate,
+          codecInitialisationData, null));
+
+      if (inputLength != C.LENGTH_UNBOUNDED) {
+        oggSeeker.setup(inputLength - audioStartPosition, totalSamples);
+        // seek back to resume from where we finished reading vorbis headers
+        seekPosition.position = audioStartPosition;
+        return RESULT_SEEK;
+      }
+    }
+
+    // seeking requested
+    if (!seenFirstAudioPacket && targetGranule > -1) {
+      OggUtil.skipToNextPage(input);
+      long position = oggSeeker.getNextSeekPosition(targetGranule, input);
+      if (position != -1) {
+        seekPosition.position = position;
+        return RESULT_SEEK;
+      } else {
+        elapsedSamples = oggReader.skipToPageOfGranule(input, targetGranule);
+        previousPacketBlockSize = vorbisIdHeader.blockSize0;
+        // we're never at the first packet after seeking
+        seenFirstAudioPacket = true;
+        oggSeeker.reset();
+      }
+    }
+
+    // playback
+    if (oggReader.readPacket(input, scratch)) {
+      // if this is an audio packet...
+      if ((scratch.data[0] & 0x01) != 1) {
+        // ... we need to decode the block size
+        int packetBlockSize = decodeBlockSize(scratch.data[0], vorbisSetup);
+        // a packet contains samples produced from overlapping the previous and current frame data
+        // (https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-350001.3.2)
+        int samplesInPacket = seenFirstAudioPacket ? (packetBlockSize + previousPacketBlockSize) / 4
+            : 0;
+        if (elapsedSamples + samplesInPacket >= targetGranule) {
+          // codec expects the number of samples appended to audio data
+          appendNumberOfSamples(scratch, samplesInPacket);
+          // calculate time and send audio data to codec
+          long timeUs = elapsedSamples * C.MICROS_PER_SECOND / vorbisSetup.idHeader.sampleRate;
+          trackOutput.sampleData(scratch, scratch.limit());
+          trackOutput.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, scratch.limit(), 0, null);
+          targetGranule = -1;
+        }
+        // update state in members for next iteration
+        seenFirstAudioPacket = true;
+        elapsedSamples += samplesInPacket;
+        previousPacketBlockSize = packetBlockSize;
+      }
+      scratch.reset();
+      return RESULT_CONTINUE;
+    }
+    return RESULT_END_OF_INPUT;
+  }
+
+  //@VisibleForTesting
+  /* package */ VorbisSetup readSetupHeaders(ExtractorInput input,  ParsableByteArray scratch)
+      throws IOException, InterruptedException {
+
+    if (vorbisIdHeader == null) {
+      oggReader.readPacket(input, scratch);
+      vorbisIdHeader = VorbisUtil.readVorbisIdentificationHeader(scratch);
+      scratch.reset();
+    }
+
+    if (commentHeader == null) {
+      oggReader.readPacket(input, scratch);
+      commentHeader = VorbisUtil.readVorbisCommentHeader(scratch);
+      scratch.reset();
+    }
+
+    oggReader.readPacket(input, scratch);
+    // the third packet contains the setup header
+    byte[] setupHeaderData = new byte[scratch.limit()];
+    // raw data of vorbis setup header has to be passed to decoder as CSD buffer #2
+    System.arraycopy(scratch.data, 0, setupHeaderData, 0, scratch.limit());
+    // partially decode setup header to get the modes
+    Mode[] modes = VorbisUtil.readVorbisModes(scratch, vorbisIdHeader.channels);
+    // we need the ilog of modes all the time when extracting, so we compute it once
+    int iLogModes = VorbisUtil.iLog(modes.length - 1);
+    scratch.reset();
+
+    return new VorbisSetup(vorbisIdHeader, commentHeader, setupHeaderData, modes, iLogModes);
+  }
+
+  //@VisibleForTesting
+  /* package */ static void appendNumberOfSamples(ParsableByteArray buffer,
+      long packetSampleCount) {
+
+    buffer.setLimit(buffer.limit() + 4);
+    // The vorbis decoder expects the number of samples in the packet
+    // to be appended to the audio data as an int32
+    buffer.data[buffer.limit() - 4] = (byte) ((packetSampleCount) & 0xFF);
+    buffer.data[buffer.limit() - 3] = (byte) ((packetSampleCount >>> 8) & 0xFF);
+    buffer.data[buffer.limit() - 2] = (byte) ((packetSampleCount >>> 16) & 0xFF);
+    buffer.data[buffer.limit() - 1] = (byte) ((packetSampleCount >>> 24) & 0xFF);
+  }
+
+  private static int decodeBlockSize(byte firstByteOfAudioPacket, VorbisSetup vorbisSetup) {
+    // read modeNumber (https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-730004.3.1)
+    int modeNumber = OggUtil.readBits(firstByteOfAudioPacket, vorbisSetup.iLogModes, 1);
+    int currentBlockSize;
+    if (!vorbisSetup.modes[modeNumber].blockFlag) {
+      currentBlockSize = vorbisSetup.idHeader.blockSize0;
+    } else {
+      currentBlockSize = vorbisSetup.idHeader.blockSize1;
+    }
+    return currentBlockSize;
+  }
+
+  @Override
+  public boolean isSeekable() {
+    return vorbisSetup != null && inputLength != C.LENGTH_UNBOUNDED;
+  }
+
+  @Override
+  public long getPosition(long timeUs) {
+    if (timeUs == 0) {
+      targetGranule = -1;
+      return audioStartPosition;
+    }
+    targetGranule = vorbisSetup.idHeader.sampleRate * timeUs / C.MICROS_PER_SECOND;
+    return Math.max(audioStartPosition, ((inputLength - audioStartPosition) * timeUs
+        / duration) - 4000);
+  }
+
+  /**
+   * Class to hold all data read from Vorbis setup headers.
+   */
+  /* package */ static final class VorbisSetup {
+
+    public final VorbisUtil.VorbisIdHeader idHeader;
+    public final VorbisUtil.CommentHeader commentHeader;
+    public final byte[] setupHeaderData;
+    public final Mode[] modes;
+    public final int iLogModes;
+
+    public VorbisSetup(VorbisUtil.VorbisIdHeader idHeader, VorbisUtil.CommentHeader
+        commentHeader, byte[] setupHeaderData, Mode[] modes, int iLogModes) {
+      this.idHeader = idHeader;
+      this.commentHeader = commentHeader;
+      this.setupHeaderData = setupHeaderData;
+      this.modes = modes;
+      this.iLogModes = iLogModes;
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ogg/VorbisBitArray.java b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/VorbisBitArray.java
new file mode 100644
index 0000000000..95ae0eb789
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/VorbisBitArray.java
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ogg;
+
+import com.google.android.exoplayer.util.Assertions;
+
+/**
+ * Wraps a byte array, providing methods that allow it to be read as a vorbis bitstream.
+ *
+ * @see <a href="https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-360002">Vorbis bitpacking
+ *     specification</a>
+ */
+/* package */ final class VorbisBitArray {
+
+  public final byte[] data;
+  private int limit;
+  private int byteOffset;
+  private int bitOffset;
+
+  /**
+   * Creates a new instance that wraps an existing array.
+   *
+   * @param data the array to wrap.
+   */
+  public VorbisBitArray(byte[] data) {
+    this(data, data.length);
+  }
+
+  /**
+   * Creates a new instance that wraps an existing array.
+   *
+   * @param data the array to wrap.
+   * @param limit the limit in bytes.
+   */
+  public VorbisBitArray(byte[] data, int limit) {
+    this.data = data;
+    this.limit = limit * 8;
+  }
+
+  /** Resets the reading position to zero. */
+  public void reset() {
+    byteOffset = 0;
+    bitOffset = 0;
+  }
+
+  /**
+   * Reads a single bit.
+   *
+   * @return {@code true} if the bit is set, {@code false} otherwise.
+   */
+  public boolean readBit() {
+    return readBits(1) == 1;
+  }
+
+  /**
+   * Reads up to 32 bits.
+   *
+   * @param numBits The number of bits to read.
+   * @return An int whose bottom {@code numBits} bits hold the read data.
+   */
+  public int readBits(int numBits) {
+    Assertions.checkState(getPosition() + numBits <= limit);
+    if (numBits == 0) {
+      return 0;
+    }
+    int result = 0;
+    int bitCount = 0;
+    if (bitOffset != 0) {
+      bitCount = Math.min(numBits, 8 - bitOffset);
+      int mask = 0xFF >>> (8 - bitCount);
+      result = (data[byteOffset] >>> bitOffset) & mask;
+      bitOffset += bitCount;
+      if (bitOffset == 8) {
+        byteOffset++;
+        bitOffset = 0;
+      }
+    }
+
+    if (numBits - bitCount > 7) {
+      int numBytes = (numBits - bitCount) / 8;
+      for (int i = 0; i < numBytes; i++) {
+        result |= (data[byteOffset++] & 0xFFL) << bitCount;
+        bitCount += 8;
+      }
+    }
+
+    if (numBits > bitCount) {
+      int bitsOnNextByte = numBits - bitCount;
+      int mask = 0xFF >>> (8 - bitsOnNextByte);
+      result |= (data[byteOffset] & mask) << bitCount;
+      bitOffset += bitsOnNextByte;
+    }
+    return result;
+  }
+
+  /**
+   * Skips {@code numberOfBits} bits.
+   *
+   * @param numberOfBits the number of bits to skip.
+   */
+  public void skipBits(int numberOfBits) {
+    Assertions.checkState(getPosition() + numberOfBits <= limit);
+    byteOffset += numberOfBits / 8;
+    bitOffset += numberOfBits % 8;
+    if (bitOffset > 7) {
+      byteOffset++;
+      bitOffset -= 8;
+    }
+  }
+
+  /**
+   * Gets the current reading position in bits.
+   *
+   * @return the current reading position in bits.
+   */
+  public int getPosition() {
+    return byteOffset * 8 + bitOffset;
+  }
+
+  /**
+   * Sets the index of the current reading position in bits.
+   *
+   * @param position the new reading position in bits.
+   */
+  public void setPosition(int position) {
+    Assertions.checkArgument(position < limit && position >= 0);
+    byteOffset = position / 8;
+    bitOffset = position - (byteOffset * 8);
+  }
+
+  /**
+   * Gets the number of remaining bits.
+   *
+   * @return number of remaining bits.
+   */
+  public int bitsLeft() {
+    return limit - getPosition();
+  }
+
+  /**
+   * Returns the limit in bits.
+   *
+   * @return the limit in bits.
+   **/
+  public int limit() {
+    return limit;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ogg/VorbisUtil.java b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/VorbisUtil.java
new file mode 100644
index 0000000000..a325e4e03e
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ogg/VorbisUtil.java
@@ -0,0 +1,489 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ogg;
+
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import android.util.Log;
+
+import java.util.Arrays;
+
+/**
+ * Utility methods for parsing vorbis streams.
+ */
+/* package */ final class VorbisUtil {
+
+  private static final String TAG = "VorbisUtil";
+
+  /**
+   * Returns ilog(x), which is the index of the highest set bit in {@code x}.
+   *
+   * @see <a href="https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-1190009.2.1">
+   *     Vorbis spec</a>
+   * @param x the value of which the ilog should be calculated.
+   * @return ilog(x)
+   */
+  public static int iLog(int x) {
+    int val = 0;
+    while (x > 0) {
+      val++;
+      x >>>= 1;
+    }
+    return val;
+  }
+
+  /**
+   * Reads a vorbis identification header from {@code headerData}.
+   *
+   * @see <a href="https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-630004.2.2">Vorbis
+   *     spec/Identification header</a>
+   * @param headerData a {@link ParsableByteArray} wrapping the header data.
+   * @return a {@link VorbisUtil.VorbisIdHeader} with meta data.
+   * @throws ParserException thrown if invalid capture pattern is detected.
+   */
+  public static VorbisIdHeader readVorbisIdentificationHeader(ParsableByteArray headerData)
+      throws ParserException {
+
+    verifyVorbisHeaderCapturePattern(0x01, headerData, false);
+
+    long version = headerData.readLittleEndianUnsignedInt();
+    int channels = headerData.readUnsignedByte();
+    long sampleRate = headerData.readLittleEndianUnsignedInt();
+    int bitrateMax = headerData.readLittleEndianInt();
+    int bitrateNominal = headerData.readLittleEndianInt();
+    int bitrateMin = headerData.readLittleEndianInt();
+
+    int blockSize = headerData.readUnsignedByte();
+    int blockSize0 = (int) Math.pow(2, blockSize & 0x0F);
+    int blockSize1 = (int) Math.pow(2, (blockSize & 0xF0) >> 4);
+
+    boolean framingFlag = (headerData.readUnsignedByte() & 0x01) > 0;
+    // raw data of vorbis setup header has to be passed to decoder as CSD buffer #1
+    byte[] data = Arrays.copyOf(headerData.data, headerData.limit());
+
+    return new VorbisIdHeader(version, channels, sampleRate, bitrateMax, bitrateNominal, bitrateMin,
+        blockSize0, blockSize1, framingFlag, data);
+  }
+
+  /**
+   * Reads a vorbis comment header.
+   *
+   * @see <a href="https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3">
+   *     Vorbis spec/Comment header</a>
+   * @param headerData a {@link ParsableByteArray} wrapping the header data.
+   * @return a {@link VorbisUtil.CommentHeader} with all the comments.
+   * @throws ParserException thrown if invalid capture pattern is detected.
+   */
+  public static CommentHeader readVorbisCommentHeader(ParsableByteArray headerData)
+      throws ParserException {
+
+    verifyVorbisHeaderCapturePattern(0x03, headerData, false);
+    int length = 7;
+
+    int len = (int) headerData.readLittleEndianUnsignedInt();
+    length += 4;
+    String vendor = headerData.readString(len);
+    length += vendor.length();
+
+    long commentListLen = headerData.readLittleEndianUnsignedInt();
+    String[] comments = new String[(int) commentListLen];
+    length += 4;
+    for (int i = 0; i < commentListLen; i++) {
+      len = (int) headerData.readLittleEndianUnsignedInt();
+      length += 4;
+      comments[i] = headerData.readString(len);
+      length += comments[i].length();
+    }
+    if ((headerData.readUnsignedByte() & 0x01) == 0) {
+      throw new ParserException("framing bit expected to be set");
+    }
+    length += 1;
+    return new CommentHeader(vendor, comments, length);
+  }
+
+  /**
+   * Verifies whether the next bytes in {@code header} are a vorbis header of the given
+   * {@code headerType}.
+   *
+   * @param headerType the type of the header expected.
+   * @param header the alleged header bytes.
+   * @param quite if {@code true} no exceptions are thrown. Instead {@code false} is returned.
+   * @return the number of bytes read.
+   * @throws ParserException thrown if header type or capture pattern is not as expected.
+   */
+  public static boolean verifyVorbisHeaderCapturePattern(int headerType, ParsableByteArray header,
+      boolean quite)
+      throws ParserException {
+    if (header.readUnsignedByte() != headerType) {
+      if (quite) {
+        return false;
+      } else {
+        throw new ParserException("expected header type " + Integer.toHexString(headerType));
+      }
+    }
+
+    if (!(header.readUnsignedByte() == 'v'
+        && header.readUnsignedByte() == 'o'
+        && header.readUnsignedByte() == 'r'
+        && header.readUnsignedByte() == 'b'
+        && header.readUnsignedByte() == 'i'
+        && header.readUnsignedByte() == 's')) {
+      if (quite) {
+        return false;
+      } else {
+        throw new ParserException("expected characters 'vorbis'");
+      }
+    }
+    return true;
+  }
+
+  /**
+   * This method reads the modes which are located at the very end of the vorbis setup header.
+   * That's why we need to partially decode or at least read the entire setup header to know
+   * where to start reading the modes.
+   *
+   * @see <a href="https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-650004.2.4">
+   *     Vorbis spec/Setup header</a>
+   * @param headerData a {@link ParsableByteArray} containing setup header data.
+   * @param channels the number of channels.
+   * @return an array of {@link Mode}s.
+   * @throws ParserException thrown if bit stream is invalid.
+   */
+  public static Mode[] readVorbisModes(ParsableByteArray headerData, int channels)
+      throws ParserException {
+
+    verifyVorbisHeaderCapturePattern(0x05, headerData, false);
+
+    int numberOfBooks = headerData.readUnsignedByte() + 1;
+
+    VorbisBitArray bitArray  = new VorbisBitArray(headerData.data);
+    bitArray.skipBits(headerData.getPosition() * 8);
+
+    for (int i = 0; i < numberOfBooks; i++) {
+      readBook(bitArray);
+    }
+
+    int timeCount = bitArray.readBits(6) + 1;
+    for (int i = 0; i < timeCount; i++) {
+      if (bitArray.readBits(16) != 0x00) {
+        throw new ParserException("placeholder of time domain transforms not zeroed out");
+      }
+    }
+    readFloors(bitArray);
+    readResidues(bitArray);
+    readMappings(channels, bitArray);
+
+    Mode[] modes = readModes(bitArray);
+    if (!bitArray.readBit()) {
+      throw new ParserException("framing bit after modes not set as expected");
+    }
+    return modes;
+  }
+
+  private static Mode[] readModes(VorbisBitArray bitArray) {
+    int modeCount = bitArray.readBits(6) + 1;
+    Mode[] modes = new Mode[modeCount];
+    for (int i = 0; i < modeCount; i++) {
+      boolean blockFlag = bitArray.readBit();
+      int windowType = bitArray.readBits(16);
+      int transformType = bitArray.readBits(16);
+      int mapping = bitArray.readBits(8);
+      modes[i] = new Mode(blockFlag, windowType, transformType, mapping);
+    }
+    return modes;
+  }
+
+  private static void readMappings(int channels, VorbisBitArray bitArray)
+      throws ParserException {
+    int mappingsCount = bitArray.readBits(6) + 1;
+    for (int i = 0; i < mappingsCount; i++) {
+      int mappingType = bitArray.readBits(16);
+      switch (mappingType) {
+        case 0:
+          int submaps;
+          if (bitArray.readBit()) {
+            submaps = bitArray.readBits(4) + 1;
+          } else {
+            submaps = 1;
+          }
+          int couplingSteps;
+          if (bitArray.readBit()) {
+            couplingSteps = bitArray.readBits(8) + 1;
+            for (int j = 0; j < couplingSteps; j++) {
+              bitArray.skipBits(iLog(channels - 1)); // magnitude
+              bitArray.skipBits(iLog(channels - 1)); // angle
+            }
+          } /*else {
+            couplingSteps = 0;
+          }*/
+          if (bitArray.readBits(2) != 0x00) {
+            throw new ParserException("to reserved bits must be zero after mapping coupling steps");
+          }
+          if (submaps > 1) {
+            for (int j = 0; j < channels; j++) {
+              bitArray.skipBits(4); // mappingMux
+            }
+          }
+          for (int j = 0; j < submaps; j++) {
+            bitArray.skipBits(8); // discard
+            bitArray.skipBits(8); // submapFloor
+            bitArray.skipBits(8); // submapResidue
+          }
+          break;
+        default:
+          Log.e(TAG, "mapping type other than 0 not supported: " + mappingType);
+      }
+    }
+  }
+
+  private static void readResidues(VorbisBitArray bitArray) throws ParserException {
+    int residueCount = bitArray.readBits(6) + 1;
+    for (int i = 0; i < residueCount; i++) {
+      int residueType = bitArray.readBits(16);
+      if (residueType > 2) {
+        throw new ParserException("residueType greater than 2 is not decodable");
+      } else {
+        bitArray.skipBits(24); // begin
+        bitArray.skipBits(24); // end
+        bitArray.skipBits(24); // partitionSize (add one)
+        int classifications = bitArray.readBits(6) + 1;
+        bitArray.skipBits(8); // classbook
+        int[] cascade = new int[classifications];
+        for (int j = 0; j < classifications; j++) {
+          int highBits = 0;
+          int lowBits = bitArray.readBits(3);
+          if (bitArray.readBit()) {
+            highBits = bitArray.readBits(5);
+          }
+          cascade[j] = highBits * 8 + lowBits;
+        }
+        for (int j = 0; j < classifications; j++) {
+          for (int k = 0; k < 8; k++) {
+            if ((cascade[j] & (0x01 << k)) != 0) {
+              bitArray.skipBits(8); // discard
+            }
+          }
+        }
+      }
+    }
+  }
+
+  private static void readFloors(VorbisBitArray bitArray) throws ParserException {
+    int floorCount = bitArray.readBits(6) + 1;
+    for (int i = 0; i < floorCount; i++) {
+      int floorType = bitArray.readBits(16);
+      switch (floorType) {
+        case 0:
+          bitArray.skipBits(8); //order
+          bitArray.skipBits(16); // rate
+          bitArray.skipBits(16); // barkMapSize
+          bitArray.skipBits(6); // amplitudeBits
+          bitArray.skipBits(8); // amplitudeOffset
+          int floorNumberOfBooks = bitArray.readBits(4) + 1;
+          for (int j = 0; j < floorNumberOfBooks; j++) {
+            bitArray.skipBits(8);
+          }
+          break;
+        case 1:
+          int partitions = bitArray.readBits(5);
+          int maximumClass = -1;
+          int[] partitionClassList = new int[partitions];
+          for (int j = 0; j < partitions; j++) {
+            partitionClassList[j] = bitArray.readBits(4);
+            if (partitionClassList[j] > maximumClass) {
+              maximumClass = partitionClassList[j];
+            }
+          }
+          int[] classDimensions = new int[maximumClass + 1];
+          for (int j = 0; j < classDimensions.length; j++) {
+            classDimensions[j] = bitArray.readBits(3) + 1;
+            int classSubclasses = bitArray.readBits(2);
+            if (classSubclasses > 0) {
+              bitArray.skipBits(8); // classMasterbooks
+            }
+            for (int k = 0; k < (1 << classSubclasses); k++) {
+              bitArray.skipBits(8); // subclassBook (subtract 1)
+            }
+          }
+          bitArray.skipBits(2); // multiplier (add one)
+          int rangeBits = bitArray.readBits(4);
+          int count = 0;
+          for (int j = 0, k = 0; j < partitions; j++) {
+            int idx = partitionClassList[j];
+            count += classDimensions[idx];
+            for (; k < count; k++) {
+              bitArray.skipBits(rangeBits); // floorValue
+            }
+          }
+          break;
+        default:
+          throw new ParserException("floor type greater than 1 not decodable: " + floorType);
+      }
+    }
+  }
+
+  private static CodeBook readBook(VorbisBitArray bitArray) throws ParserException {
+    if (bitArray.readBits(24) != 0x564342) {
+      throw new ParserException("expected code book to start with [0x56, 0x43, 0x42] at "
+          + bitArray.getPosition());
+    }
+    int dimensions = bitArray.readBits(16);
+    int entries = bitArray.readBits(24);
+    long[] lengthMap = new long[entries];
+
+    boolean isOrdered = bitArray.readBit();
+    if (!isOrdered) {
+      boolean isSparse = bitArray.readBit();
+      for (int i = 0; i < lengthMap.length; i++) {
+        if (isSparse) {
+          if (bitArray.readBit()) {
+            lengthMap[i] = bitArray.readBits(5) + 1;
+          } else { // entry unused
+            lengthMap[i] = 0;
+          }
+        } else { // not sparse
+          lengthMap[i] = bitArray.readBits(5) + 1;
+        }
+      }
+    } else {
+      int length = bitArray.readBits(5) + 1;
+      for (int i = 0; i < lengthMap.length;) {
+        int num = bitArray.readBits(iLog(entries - i));
+        for (int j = 0; j < num && i < lengthMap.length; i++, j++) {
+          lengthMap[i] = length;
+        }
+        length++;
+      }
+    }
+
+    int lookupType = bitArray.readBits(4);
+    if (lookupType > 2) {
+      throw new ParserException("lookup type greater than 2 not decodable: " + lookupType);
+    } else if (lookupType == 1 || lookupType == 2) {
+      bitArray.skipBits(32); // minimumValue
+      bitArray.skipBits(32); // deltaValue
+      int valueBits = bitArray.readBits(4) + 1;
+      bitArray.skipBits(1); // sequenceP
+      long lookupValuesCount;
+      if (lookupType == 1) {
+        if (dimensions != 0) {
+          lookupValuesCount = mapType1QuantValues(entries, dimensions);
+        } else {
+          // TODO no sample file found yet
+          lookupValuesCount = 0;
+        }
+      } else {
+        // TODO no sample file found yet
+        lookupValuesCount = entries * dimensions;
+      }
+      // discard (no decoding required yet)
+      bitArray.skipBits((int) (lookupValuesCount * valueBits));
+    }
+    return new CodeBook(dimensions, entries, lengthMap, lookupType, isOrdered);
+  }
+
+  /**
+   * @see <a href="http://svn.xiph.org/trunk/vorbis/lib/sharedbook.c">_book_maptype1_quantvals</a>
+   */
+  private static long mapType1QuantValues(long entries, long dimension) {
+    return (long) Math.floor(Math.pow(entries, 1.d / dimension));
+  }
+
+  public static final class CodeBook {
+
+    public final int dimensions;
+    public final int entries;
+    public final long[] lengthMap;
+    public final int lookupType;
+    public final boolean isOrdered;
+
+    public CodeBook(int dimensions, int entries, long[] lengthMap, int lookupType,
+        boolean isOrdered) {
+      this.dimensions = dimensions;
+      this.entries = entries;
+      this.lengthMap = lengthMap;
+      this.lookupType = lookupType;
+      this.isOrdered = isOrdered;
+    }
+
+  }
+
+  public static final class CommentHeader {
+
+    public final String vendor;
+    public final String[] comments;
+    public final int length;
+
+    public CommentHeader(String vendor, String[] comments, int length) {
+      this.vendor = vendor;
+      this.comments = comments;
+      this.length = length;
+    }
+
+  }
+
+  public static final class VorbisIdHeader {
+
+    public final long version;
+    public final int channels;
+    public final long sampleRate;
+    public final int bitrateMax;
+    public final int bitrateNominal;
+    public final int bitrateMin;
+    public final int blockSize0;
+    public final int blockSize1;
+    public final boolean framingFlag;
+    public final byte[] data;
+
+    public VorbisIdHeader(long version, int channels, long sampleRate, int bitrateMax,
+        int bitrateNominal, int bitrateMin, int blockSize0, int blockSize1, boolean framingFlag,
+        byte[] data) {
+      this.version = version;
+      this.channels = channels;
+      this.sampleRate = sampleRate;
+      this.bitrateMax = bitrateMax;
+      this.bitrateNominal = bitrateNominal;
+      this.bitrateMin = bitrateMin;
+      this.blockSize0 = blockSize0;
+      this.blockSize1 = blockSize1;
+      this.framingFlag = framingFlag;
+      this.data = data;
+    }
+
+    public int getApproximateBitrate() {
+      return bitrateNominal == 0 ? (bitrateMin + bitrateMax) / 2 : bitrateNominal;
+    }
+
+  }
+
+  public static final class Mode {
+
+    public final boolean blockFlag;
+    public final int windowType;
+    public final int transformType;
+    public final int mapping;
+
+    public Mode(boolean blockFlag, int windowType, int transformType, int mapping) {
+      this.blockFlag = blockFlag;
+      this.windowType = windowType;
+      this.transformType = transformType;
+      this.mapping = mapping;
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsExtractor.java
index 8c35de4002..2ae8e24560 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsExtractor.java
@@ -120,6 +120,11 @@ public void seek() {
     adtsReader.seek();
   }
 
+  @Override
+  public void release() {
+    // Do nothing
+  }
+
   @Override
   public int read(ExtractorInput input, PositionHolder seekPosition)
       throws IOException, InterruptedException {
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
index ead08da623..a39d02bd00 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
@@ -23,6 +23,7 @@
 import com.google.android.exoplayer.util.ParsableBitArray;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
+import android.util.Log;
 import android.util.Pair;
 
 import java.util.Arrays;
@@ -33,6 +34,8 @@
  */
 /* package */ final class AdtsReader extends ElementaryStreamReader {
 
+  private static final String TAG = "AdtsReader";
+
   private static final int STATE_FINDING_SAMPLE = 0;
   private static final int STATE_READING_ID3_HEADER = 1;
   private static final int STATE_READING_ADTS_HEADER = 2;
@@ -251,6 +254,16 @@ private void parseAdtsHeader() {
 
     if (!hasOutputFormat) {
       int audioObjectType = adtsScratch.readBits(2) + 1;
+      if (audioObjectType == 1) {
+        // The stream indicates AAC Main but it's more likely that the stream contains HE-AAC.
+        // HE-AAC cannot be represented correctly in the ADTS header because it has an
+        // audioObjectType value of 5 whereas an ADTS header can only represent values up to 4.
+        // Since most Android devices don't support AAC Main anyway, we pretend that we're dealing
+        // with AAC LC and hope for the best. In practice this often works.
+        Log.w(TAG, "Detected AAC Main audio, but assuming AAC LC.");
+        audioObjectType = 2;
+      }
+
       int sampleRateIndex = adtsScratch.readBits(4);
       adtsScratch.skipBits(1);
       int channelConfig = adtsScratch.readBits(3);
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H262Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H262Reader.java
index 5ebcf025d0..47a5aa05d4 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H262Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H262Reader.java
@@ -53,7 +53,7 @@
 
   // Per packet state that gets reset at the start of each packet.
   private long pesTimeUs;
-  private boolean foundFirstFrameInPacket;
+  private boolean pesPtsUsAvailable;
 
   // Per sample state that gets reset at the start of each frame.
   private boolean isKeyframe;
@@ -70,15 +70,17 @@ public H262Reader(TrackOutput output) {
   public void seek() {
     NalUnitUtil.clearPrefixFlags(prefixFlags);
     csdBuffer.reset();
-    foundFirstFrameInPacket = false;
+    pesPtsUsAvailable = false;
     foundFirstFrameInGroup = false;
     totalBytesWritten = 0;
   }
 
   @Override
   public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
-    this.pesTimeUs = pesTimeUs;
-    foundFirstFrameInPacket = false;
+    pesPtsUsAvailable = pesTimeUs != C.UNKNOWN_TIME_US;
+    if (pesPtsUsAvailable) {
+      this.pesTimeUs = pesTimeUs;
+    }
   }
 
   @Override
@@ -138,9 +140,9 @@ public void consume(ParsableByteArray data) {
             foundFirstFrameInGroup = false;
             isKeyframe = true;
           } else /* startCode == START_PICTURE */ {
-            frameTimeUs = !foundFirstFrameInPacket ? pesTimeUs : (frameTimeUs + frameDurationUs);
+            frameTimeUs = pesPtsUsAvailable ? pesTimeUs : (frameTimeUs + frameDurationUs);
             framePosition = totalBytesWritten - bytesWrittenPastStartCode;
-            foundFirstFrameInPacket = true;
+            pesPtsUsAvailable = false;
             foundFirstFrameInGroup = true;
           }
         }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java
index e20781adb5..e29a25605e 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java
@@ -18,13 +18,14 @@
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.extractor.TrackOutput;
-import com.google.android.exoplayer.util.CodecSpecificDataUtil;
-import com.google.android.exoplayer.util.CodecSpecificDataUtil.SpsData;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.NalUnitUtil;
+import com.google.android.exoplayer.util.NalUnitUtil.SpsData;
 import com.google.android.exoplayer.util.ParsableBitArray;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
+import android.util.SparseArray;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -34,15 +35,9 @@
  */
 /* package */ final class H264Reader extends ElementaryStreamReader {
 
-  private static final int FRAME_TYPE_I = 2;
-  private static final int FRAME_TYPE_ALL_I = 7;
-
-  private static final int NAL_UNIT_TYPE_IFR = 1; // Coded slice of a non-IDR picture
-  private static final int NAL_UNIT_TYPE_IDR = 5; // Coded slice of an IDR picture
   private static final int NAL_UNIT_TYPE_SEI = 6; // Supplemental enhancement information
   private static final int NAL_UNIT_TYPE_SPS = 7; // Sequence parameter set
   private static final int NAL_UNIT_TYPE_PPS = 8; // Picture parameter set
-  private static final int NAL_UNIT_TYPE_AUD = 9; // Access unit delimiter
 
   // State that should not be reset on seek.
   private boolean hasOutputFormat;
@@ -50,29 +45,32 @@
   // State that should be reset on seek.
   private final SeiReader seiReader;
   private final boolean[] prefixFlags;
-  private final IfrParserBuffer ifrParserBuffer;
+  private final SampleReader sampleReader;
   private final NalUnitTargetBuffer sps;
   private final NalUnitTargetBuffer pps;
   private final NalUnitTargetBuffer sei;
-  private boolean foundFirstSample;
   private long totalBytesWritten;
 
   // Per packet state that gets reset at the start of each packet.
   private long pesTimeUs;
 
-  // Per sample state that gets reset at the start of each sample.
-  private boolean isKeyframe;
-  private long samplePosition;
-  private long sampleTimeUs;
-
   // Scratch variables to avoid allocations.
   private final ParsableByteArray seiWrapper;
 
-  public H264Reader(TrackOutput output, SeiReader seiReader, boolean allowNonIdrKeyframes) {
+  /**
+   * @param output A {@link TrackOutput} to which H.264 samples should be written.
+   * @param seiReader A reader for EIA-608 samples in SEI NAL units.
+   * @param allowNonIdrKeyframes Whether to treat samples consisting of non-IDR I slices as
+   *     synchronization samples (key-frames).
+   * @param detectAccessUnits Whether to split the input stream into access units (samples) based on
+   *     slice headers. Pass {@code false} if the stream contains access unit delimiters (AUDs).
+   */
+  public H264Reader(TrackOutput output, SeiReader seiReader, boolean allowNonIdrKeyframes,
+      boolean detectAccessUnits) {
     super(output);
     this.seiReader = seiReader;
     prefixFlags = new boolean[3];
-    ifrParserBuffer = allowNonIdrKeyframes ? new IfrParserBuffer() : null;
+    sampleReader = new SampleReader(output, allowNonIdrKeyframes, detectAccessUnits);
     sps = new NalUnitTargetBuffer(NAL_UNIT_TYPE_SPS, 128);
     pps = new NalUnitTargetBuffer(NAL_UNIT_TYPE_PPS, 128);
     sei = new NalUnitTargetBuffer(NAL_UNIT_TYPE_SEI, 128);
@@ -85,10 +83,7 @@ public void seek() {
     sps.reset();
     pps.reset();
     sei.reset();
-    if (ifrParserBuffer != null) {
-      ifrParserBuffer.reset();
-    }
-    foundFirstSample = false;
+    sampleReader.reset();
     totalBytesWritten = 0;
   }
 
@@ -114,7 +109,7 @@ public void consume(ParsableByteArray data) {
 
         if (nalUnitOffset == limit) {
           // We've scanned to the end of the data without finding the start of another NAL unit.
-          feedNalUnitTargetBuffersData(dataArray, offset, limit);
+          nalUnitData(dataArray, offset, limit);
           return;
         }
 
@@ -125,42 +120,17 @@ public void consume(ParsableByteArray data) {
         // It may be negative if the NAL unit started in the previously consumed data.
         int lengthToNalUnit = nalUnitOffset - offset;
         if (lengthToNalUnit > 0) {
-          feedNalUnitTargetBuffersData(dataArray, offset, nalUnitOffset);
-        }
-
-        switch (nalUnitType) {
-          case NAL_UNIT_TYPE_IDR:
-            isKeyframe = true;
-            break;
-          case NAL_UNIT_TYPE_AUD:
-            int bytesWrittenPastNalUnit = limit - nalUnitOffset;
-            if (foundFirstSample) {
-              if (ifrParserBuffer != null && ifrParserBuffer.isCompleted()) {
-                int sliceType = ifrParserBuffer.getSliceType();
-                isKeyframe |= (sliceType == FRAME_TYPE_I || sliceType == FRAME_TYPE_ALL_I);
-                ifrParserBuffer.reset();
-              }
-              if (isKeyframe && !hasOutputFormat && sps.isCompleted() && pps.isCompleted()) {
-                output.format(parseMediaFormat(sps, pps));
-                hasOutputFormat = true;
-              }
-              int flags = isKeyframe ? C.SAMPLE_FLAG_SYNC : 0;
-              int size = (int) (totalBytesWritten - samplePosition) - bytesWrittenPastNalUnit;
-              output.sampleMetadata(sampleTimeUs, flags, size, bytesWrittenPastNalUnit, null);
-            }
-            foundFirstSample = true;
-            samplePosition = totalBytesWritten - bytesWrittenPastNalUnit;
-            sampleTimeUs = pesTimeUs;
-            isKeyframe = false;
-            break;
+          nalUnitData(dataArray, offset, nalUnitOffset);
         }
-
+        int bytesWrittenPastPosition = limit - nalUnitOffset;
+        long absolutePosition = totalBytesWritten - bytesWrittenPastPosition;
         // Indicate the end of the previous NAL unit. If the length to the start of the next unit
         // is negative then we wrote too many bytes to the NAL buffers. Discard the excess bytes
         // when notifying that the unit has ended.
-        feedNalUnitTargetEnd(pesTimeUs, lengthToNalUnit < 0 ? -lengthToNalUnit : 0);
+        endNalUnit(absolutePosition, bytesWrittenPastPosition,
+            lengthToNalUnit < 0 ? -lengthToNalUnit : 0, pesTimeUs);
         // Indicate the start of the next NAL unit.
-        feedNalUnitTargetBuffersStart(nalUnitType);
+        startNalUnit(absolutePosition, nalUnitType, pesTimeUs);
         // Continue scanning the data.
         offset = nalUnitOffset + 3;
       }
@@ -172,99 +142,153 @@ public void packetFinished() {
     // Do nothing.
   }
 
-  private void feedNalUnitTargetBuffersStart(int nalUnitType) {
-    if (ifrParserBuffer != null) {
-      ifrParserBuffer.startNalUnit(nalUnitType);
-    }
-    if (!hasOutputFormat) {
+  private void startNalUnit(long position, int nalUnitType, long pesTimeUs) {
+    if (!hasOutputFormat || sampleReader.needsSpsPps()) {
       sps.startNalUnit(nalUnitType);
       pps.startNalUnit(nalUnitType);
     }
     sei.startNalUnit(nalUnitType);
+    sampleReader.startNalUnit(position, nalUnitType, pesTimeUs);
   }
 
-  private void feedNalUnitTargetBuffersData(byte[] dataArray, int offset, int limit) {
-    if (ifrParserBuffer != null) {
-      ifrParserBuffer.appendToNalUnit(dataArray, offset, limit);
-    }
-    if (!hasOutputFormat) {
+  private void nalUnitData(byte[] dataArray, int offset, int limit) {
+    if (!hasOutputFormat || sampleReader.needsSpsPps()) {
       sps.appendToNalUnit(dataArray, offset, limit);
       pps.appendToNalUnit(dataArray, offset, limit);
     }
     sei.appendToNalUnit(dataArray, offset, limit);
+    sampleReader.appendToNalUnit(dataArray, offset, limit);
   }
 
-  private void feedNalUnitTargetEnd(long pesTimeUs, int discardPadding) {
-    sps.endNalUnit(discardPadding);
-    pps.endNalUnit(discardPadding);
+  private void endNalUnit(long position, int offset, int discardPadding, long pesTimeUs) {
+    if (!hasOutputFormat || sampleReader.needsSpsPps()) {
+      sps.endNalUnit(discardPadding);
+      pps.endNalUnit(discardPadding);
+      if (!hasOutputFormat) {
+        if (sps.isCompleted() && pps.isCompleted()) {
+          List<byte[]> initializationData = new ArrayList<>();
+          initializationData.add(Arrays.copyOf(sps.nalData, sps.nalLength));
+          initializationData.add(Arrays.copyOf(pps.nalData, pps.nalLength));
+          NalUnitUtil.SpsData spsData = NalUnitUtil.parseSpsNalUnit(unescape(sps));
+          NalUnitUtil.PpsData ppsData = NalUnitUtil.parsePpsNalUnit(unescape(pps));
+          output.format(MediaFormat.createVideoFormat(null, MimeTypes.VIDEO_H264,
+              MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US, spsData.width,
+              spsData.height, initializationData, MediaFormat.NO_VALUE,
+              spsData.pixelWidthAspectRatio));
+          hasOutputFormat = true;
+          sampleReader.putSps(spsData);
+          sampleReader.putPps(ppsData);
+          sps.reset();
+          pps.reset();
+        }
+      } else if (sps.isCompleted()) {
+        NalUnitUtil.SpsData spsData = NalUnitUtil.parseSpsNalUnit(unescape(sps));
+        sampleReader.putSps(spsData);
+        sps.reset();
+      } else if (pps.isCompleted()) {
+        NalUnitUtil.PpsData ppsData = NalUnitUtil.parsePpsNalUnit(unescape(pps));
+        sampleReader.putPps(ppsData);
+        pps.reset();
+      }
+    }
     if (sei.endNalUnit(discardPadding)) {
       int unescapedLength = NalUnitUtil.unescapeStream(sei.nalData, sei.nalLength);
       seiWrapper.reset(sei.nalData, unescapedLength);
       seiWrapper.setPosition(4); // NAL prefix and nal_unit() header.
       seiReader.consume(pesTimeUs, seiWrapper);
     }
+    sampleReader.endNalUnit(position, offset);
   }
 
-  private static MediaFormat parseMediaFormat(NalUnitTargetBuffer sps, NalUnitTargetBuffer pps) {
-    List<byte[]> initializationData = new ArrayList<>();
-    initializationData.add(Arrays.copyOf(sps.nalData, sps.nalLength));
-    initializationData.add(Arrays.copyOf(pps.nalData, pps.nalLength));
-
-    // Unescape and parse the SPS unit.
-    NalUnitUtil.unescapeStream(sps.nalData, sps.nalLength);
-    ParsableBitArray bitArray = new ParsableBitArray(sps.nalData);
+  private static ParsableBitArray unescape(NalUnitTargetBuffer buffer) {
+    int length = NalUnitUtil.unescapeStream(buffer.nalData, buffer.nalLength);
+    ParsableBitArray bitArray = new ParsableBitArray(buffer.nalData, length);
     bitArray.skipBits(32); // NAL header
-    SpsData parsedSpsData = CodecSpecificDataUtil.parseSpsNalUnit(bitArray);
-
-    return MediaFormat.createVideoFormat(null, MimeTypes.VIDEO_H264, MediaFormat.NO_VALUE,
-        MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US, parsedSpsData.width, parsedSpsData.height,
-        initializationData, MediaFormat.NO_VALUE, parsedSpsData.pixelWidthAspectRatio);
+    return bitArray;
   }
 
   /**
-   * A buffer specifically for IFR units that can be used to parse the IFR's slice type.
+   * Consumes a stream of NAL units and outputs samples.
    */
-  private static final class IfrParserBuffer {
+  private static final class SampleReader {
 
     private static final int DEFAULT_BUFFER_SIZE = 128;
-    private static final int NOT_SET = -1;
 
-    private final ParsableBitArray scratchSliceType;
+    private static final int NAL_UNIT_TYPE_NON_IDR = 1; // Coded slice of a non-IDR picture
+    private static final int NAL_UNIT_TYPE_PARTITION_A = 2; // Coded slice data partition A
+    private static final int NAL_UNIT_TYPE_IDR = 5; // Coded slice of an IDR picture
+    private static final int NAL_UNIT_TYPE_AUD = 9; // Access unit delimiter
 
-    private byte[] ifrData;
-    private int ifrLength;
-    private boolean isFilling;
-    private int sliceType;
+    private final TrackOutput output;
+    private final boolean allowNonIdrKeyframes;
+    private final boolean detectAccessUnits;
+    private final ParsableBitArray scratch;
+    private final SparseArray<NalUnitUtil.SpsData> sps;
+    private final SparseArray<NalUnitUtil.PpsData> pps;
+
+    private byte[] buffer;
+    private int bufferLength;
 
-    public IfrParserBuffer() {
-      ifrData = new byte[DEFAULT_BUFFER_SIZE];
-      scratchSliceType = new ParsableBitArray(ifrData);
+    // Per NAL unit state. A sample consists of one or more NAL units.
+    private int nalUnitType;
+    private long nalUnitStartPosition;
+    private boolean isFilling;
+    private long nalUnitTimeUs;
+    private SliceHeaderData previousSliceHeader;
+    private SliceHeaderData sliceHeader;
+
+    // Per sample state that gets reset at the start of each sample.
+    private boolean readingSample;
+    private long samplePosition;
+    private long sampleTimeUs;
+    private boolean sampleIsKeyframe;
+
+    public SampleReader(TrackOutput output, boolean allowNonIdrKeyframes,
+        boolean detectAccessUnits) {
+      this.output = output;
+      this.allowNonIdrKeyframes = allowNonIdrKeyframes;
+      this.detectAccessUnits = detectAccessUnits;
+      sps = new SparseArray<>();
+      pps = new SparseArray<>();
+      previousSliceHeader = new SliceHeaderData();
+      sliceHeader = new SliceHeaderData();
+      scratch = new ParsableBitArray();
+      buffer = new byte[DEFAULT_BUFFER_SIZE];
       reset();
     }
 
-    /**
-     * Resets the buffer, clearing any data that it holds.
-     */
-    public void reset() {
-      isFilling = false;
-      ifrLength = 0;
-      sliceType = NOT_SET;
+    public boolean needsSpsPps() {
+      return detectAccessUnits;
     }
 
-    /**
-     * True if enough data was added to the buffer that the slice type was determined.
-     */
-    public boolean isCompleted() {
-      return sliceType != NOT_SET;
+    public void putSps(NalUnitUtil.SpsData spsData) {
+      sps.append(spsData.seqParameterSetId, spsData);
     }
 
-    /**
-     * Invoked to indicate that a NAL unit has started, and if it is an IFR then the buffer will
-     * start.
-     */
-    public void startNalUnit(int nalUnitType) {
-      if (nalUnitType == NAL_UNIT_TYPE_IFR) {
-        reset();
+    public void putPps(NalUnitUtil.PpsData ppsData) {
+      pps.append(ppsData.picParameterSetId, ppsData);
+    }
+
+    public void reset() {
+      isFilling = false;
+      readingSample = false;
+      sliceHeader.clear();
+    }
+
+    public void startNalUnit(long position, int type, long pesTimeUs) {
+      nalUnitType = type;
+      nalUnitTimeUs = pesTimeUs;
+      nalUnitStartPosition = position;
+      if ((allowNonIdrKeyframes && nalUnitType == NAL_UNIT_TYPE_NON_IDR)
+          || (detectAccessUnits && (nalUnitType == NAL_UNIT_TYPE_IDR
+              || nalUnitType == NAL_UNIT_TYPE_NON_IDR
+              || nalUnitType == NAL_UNIT_TYPE_PARTITION_A))) {
+        // Store the previous header and prepare to populate the new one.
+        SliceHeaderData newSliceHeader = previousSliceHeader;
+        previousSliceHeader = sliceHeader;
+        sliceHeader = newSliceHeader;
+        sliceHeader.clear();
+        bufferLength = 0;
         isFilling = true;
       }
     }
@@ -281,38 +305,214 @@ public void appendToNalUnit(byte[] data, int offset, int limit) {
         return;
       }
       int readLength = limit - offset;
-      if (ifrData.length < ifrLength + readLength) {
-        ifrData = Arrays.copyOf(ifrData, (ifrLength + readLength) * 2);
+      if (buffer.length < bufferLength + readLength) {
+        buffer = Arrays.copyOf(buffer, (bufferLength + readLength) * 2);
       }
-      System.arraycopy(data, offset, ifrData, ifrLength, readLength);
-      ifrLength += readLength;
-
-      scratchSliceType.reset(ifrData, ifrLength);
-      scratchSliceType.skipBits(8);
-      // first_mb_in_slice
-      int len = scratchSliceType.peekExpGolombCodedNumLength();
-      if ((len == -1) || (len > scratchSliceType.bitsLeft())) {
-        // Not enough yet
+      System.arraycopy(data, offset, buffer, bufferLength, readLength);
+      bufferLength += readLength;
+
+      scratch.reset(buffer, bufferLength);
+      if (scratch.bitsLeft() < 8) {
         return;
       }
+      scratch.skipBits(1); // forbidden_zero_bit
+      int nalRefIdc = scratch.readBits(2);
+      scratch.skipBits(5); // nal_unit_type
 
-      scratchSliceType.skipBits(len);
-      // slice_type
-      len = scratchSliceType.peekExpGolombCodedNumLength();
-      if ((len == -1) || (len > scratchSliceType.bitsLeft())) {
-        // Not enough yet
+      // Read the slice header using the syntax defined in ITU-T Recommendation H.264 (2013)
+      // subsection 7.3.3.
+      if (!scratch.canReadExpGolombCodedNum()) {
         return;
       }
-      sliceType = scratchSliceType.readUnsignedExpGolombCodedInt();
-
+      scratch.readUnsignedExpGolombCodedInt(); // first_mb_in_slice
+      if (!scratch.canReadExpGolombCodedNum()) {
+        return;
+      }
+      int sliceType = scratch.readUnsignedExpGolombCodedInt();
+      if (!detectAccessUnits) {
+        // There are AUDs in the stream so the rest of the header can be ignored.
+        isFilling = false;
+        sliceHeader.setSliceType(sliceType);
+        return;
+      }
+      if (!scratch.canReadExpGolombCodedNum()) {
+        return;
+      }
+      int picParameterSetId = scratch.readUnsignedExpGolombCodedInt();
+      if (pps.indexOfKey(picParameterSetId) < 0) {
+        // We have not seen the PPS yet, so don't try to parse the slice header.
+        isFilling = false;
+        return;
+      }
+      NalUnitUtil.PpsData ppsData = pps.get(picParameterSetId);
+      NalUnitUtil.SpsData spsData = sps.get(ppsData.seqParameterSetId);
+      if (spsData.separateColorPlaneFlag) {
+        if (scratch.bitsLeft() < 2) {
+          return;
+        }
+        scratch.skipBits(2); // colour_plane_id
+      }
+      if (scratch.bitsLeft() < spsData.frameNumLength) {
+        return;
+      }
+      boolean fieldPicFlag = false;
+      boolean bottomFieldFlagPresent = false;
+      boolean bottomFieldFlag = false;
+      int frameNum = scratch.readBits(spsData.frameNumLength);
+      if (!spsData.frameMbsOnlyFlag) {
+        if (scratch.bitsLeft() < 1) {
+          return;
+        }
+        fieldPicFlag = scratch.readBit();
+        if (fieldPicFlag) {
+          if (scratch.bitsLeft() < 1) {
+            return;
+          }
+          bottomFieldFlag = scratch.readBit();
+          bottomFieldFlagPresent = true;
+        }
+      }
+      boolean idrPicFlag = nalUnitType == NAL_UNIT_TYPE_IDR;
+      int idrPicId = 0;
+      if (idrPicFlag) {
+        if (!scratch.canReadExpGolombCodedNum()) {
+          return;
+        }
+        idrPicId = scratch.readUnsignedExpGolombCodedInt();
+      }
+      int picOrderCntLsb = 0;
+      int deltaPicOrderCntBottom = 0;
+      int deltaPicOrderCnt0 = 0;
+      int deltaPicOrderCnt1 = 0;
+      if (spsData.picOrderCountType == 0) {
+        if (scratch.bitsLeft() < spsData.picOrderCntLsbLength) {
+          return;
+        }
+        picOrderCntLsb = scratch.readBits(spsData.picOrderCntLsbLength);
+        if (ppsData.bottomFieldPicOrderInFramePresentFlag && !fieldPicFlag) {
+          if (!scratch.canReadExpGolombCodedNum()) {
+            return;
+          }
+          deltaPicOrderCntBottom = scratch.readSignedExpGolombCodedInt();
+        }
+      } else if (spsData.picOrderCountType == 1
+          && !spsData.deltaPicOrderAlwaysZeroFlag) {
+        if (!scratch.canReadExpGolombCodedNum()) {
+          return;
+        }
+        deltaPicOrderCnt0 = scratch.readSignedExpGolombCodedInt();
+        if (ppsData.bottomFieldPicOrderInFramePresentFlag && !fieldPicFlag) {
+          if (!scratch.canReadExpGolombCodedNum()) {
+            return;
+          }
+          deltaPicOrderCnt1 = scratch.readSignedExpGolombCodedInt();
+        }
+      }
+      sliceHeader.setAll(spsData, nalRefIdc, sliceType, frameNum, picParameterSetId, fieldPicFlag,
+          bottomFieldFlagPresent, bottomFieldFlag, idrPicFlag, idrPicId, picOrderCntLsb,
+          deltaPicOrderCntBottom, deltaPicOrderCnt0, deltaPicOrderCnt1);
       isFilling = false;
     }
 
-    /**
-     * @return the slice type of the IFR.
-     */
-    public int getSliceType() {
-      return sliceType;
+    public void endNalUnit(long position, int offset) {
+      if (nalUnitType == NAL_UNIT_TYPE_AUD
+          || (detectAccessUnits && sliceHeader.isFirstVclNalUnitOfPicture(previousSliceHeader))) {
+        // If the NAL unit ending is the start of a new sample, output the previous one.
+        if (readingSample) {
+          int nalUnitLength = (int) (position - nalUnitStartPosition);
+          outputSample(offset + nalUnitLength);
+        }
+        samplePosition = nalUnitStartPosition;
+        sampleTimeUs = nalUnitTimeUs;
+        sampleIsKeyframe = false;
+        readingSample = true;
+      }
+      sampleIsKeyframe |= nalUnitType == NAL_UNIT_TYPE_IDR || (allowNonIdrKeyframes
+          && nalUnitType == NAL_UNIT_TYPE_NON_IDR && sliceHeader.isISlice());
+    }
+
+    private void outputSample(int offset) {
+      int flags = sampleIsKeyframe ? C.SAMPLE_FLAG_SYNC : 0;
+      int size = (int) (nalUnitStartPosition - samplePosition);
+      output.sampleMetadata(sampleTimeUs, flags, size, offset, null);
+    }
+
+    private static final class SliceHeaderData {
+
+      private static final int SLICE_TYPE_I = 2;
+      private static final int SLICE_TYPE_ALL_I = 7;
+
+      private boolean isComplete;
+      private boolean hasSliceType;
+
+      private SpsData spsData;
+      private int nalRefIdc;
+      private int sliceType;
+      private int frameNum;
+      private int picParameterSetId;
+      private boolean fieldPicFlag;
+      private boolean bottomFieldFlagPresent;
+      private boolean bottomFieldFlag;
+      private boolean idrPicFlag;
+      private int idrPicId;
+      private int picOrderCntLsb;
+      private int deltaPicOrderCntBottom;
+      private int deltaPicOrderCnt0;
+      private int deltaPicOrderCnt1;
+
+      public void clear() {
+        hasSliceType = false;
+        isComplete = false;
+      }
+
+      public void setSliceType(int sliceType) {
+        this.sliceType = sliceType;
+        hasSliceType = true;
+      }
+
+      public void setAll(SpsData spsData, int nalRefIdc, int sliceType, int frameNum,
+          int picParameterSetId, boolean fieldPicFlag, boolean bottomFieldFlagPresent,
+          boolean bottomFieldFlag, boolean idrPicFlag, int idrPicId, int picOrderCntLsb,
+          int deltaPicOrderCntBottom, int deltaPicOrderCnt0, int deltaPicOrderCnt1) {
+        this.spsData = spsData;
+        this.nalRefIdc = nalRefIdc;
+        this.sliceType = sliceType;
+        this.frameNum = frameNum;
+        this.picParameterSetId = picParameterSetId;
+        this.fieldPicFlag = fieldPicFlag;
+        this.bottomFieldFlagPresent = bottomFieldFlagPresent;
+        this.bottomFieldFlag = bottomFieldFlag;
+        this.idrPicFlag = idrPicFlag;
+        this.idrPicId = idrPicId;
+        this.picOrderCntLsb = picOrderCntLsb;
+        this.deltaPicOrderCntBottom = deltaPicOrderCntBottom;
+        this.deltaPicOrderCnt0 = deltaPicOrderCnt0;
+        this.deltaPicOrderCnt1 = deltaPicOrderCnt1;
+        isComplete = true;
+        hasSliceType = true;
+      }
+
+      public boolean isISlice() {
+        return hasSliceType && (sliceType == SLICE_TYPE_ALL_I || sliceType == SLICE_TYPE_I);
+      }
+
+      private boolean isFirstVclNalUnitOfPicture(SliceHeaderData other) {
+        // See ISO 14496-10 subsection 7.4.1.2.4.
+        return isComplete && (!other.isComplete || frameNum != other.frameNum
+            || picParameterSetId != other.picParameterSetId || fieldPicFlag != other.fieldPicFlag
+            || (bottomFieldFlagPresent && other.bottomFieldFlagPresent
+                && bottomFieldFlag != other.bottomFieldFlag)
+            || (nalRefIdc != other.nalRefIdc && (nalRefIdc == 0 || other.nalRefIdc == 0))
+            || (spsData.picOrderCountType == 0 && other.spsData.picOrderCountType == 0
+                && (picOrderCntLsb != other.picOrderCntLsb
+                    || deltaPicOrderCntBottom != other.deltaPicOrderCntBottom))
+            || (spsData.picOrderCountType == 1 && other.spsData.picOrderCountType == 1
+                && (deltaPicOrderCnt0 != other.deltaPicOrderCnt0
+                    || deltaPicOrderCnt1 != other.deltaPicOrderCnt1))
+            || idrPicFlag != other.idrPicFlag
+            || (idrPicFlag && other.idrPicFlag && idrPicId != other.idrPicId));
+      }
+
     }
 
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java
index 6031dc7a01..2c1e6e0635 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java
@@ -64,6 +64,10 @@
   // Scratch variables to avoid allocations.
   private final ParsableByteArray seiWrapper;
 
+  /**
+   * @param output A {@link TrackOutput} to which H.265 samples should be written.
+   * @param seiReader A reader for EIA-608 samples in SEI NAL units.
+   */
   public H265Reader(TrackOutput output, SeiReader seiReader) {
     super(output);
     this.seiReader = seiReader;
@@ -130,7 +134,7 @@ public void consume(ParsableByteArray data) {
         // Indicate the end of the previous NAL unit. If the length to the start of the next unit
         // is negative then we wrote too many bytes to the NAL buffers. Discard the excess bytes
         // when notifying that the unit has ended.
-        nalUnitEnd(absolutePosition, bytesWrittenPastPosition,
+        endNalUnit(absolutePosition, bytesWrittenPastPosition,
             lengthToNalUnit < 0 ? -lengthToNalUnit : 0, pesTimeUs);
         // Indicate the start of the next NAL unit.
         startNalUnit(absolutePosition, bytesWrittenPastPosition, nalUnitType, pesTimeUs);
@@ -168,7 +172,7 @@ private void nalUnitData(byte[] dataArray, int offset, int limit) {
     suffixSei.appendToNalUnit(dataArray, offset, limit);
   }
 
-  private void nalUnitEnd(long position, int offset, int discardPadding, long pesTimeUs) {
+  private void endNalUnit(long position, int offset, int discardPadding, long pesTimeUs) {
     if (hasOutputFormat) {
       sampleReader.endNalUnit(position, offset);
     } else {
@@ -218,10 +222,10 @@ private static MediaFormat parseMediaFormat(NalUnitTargetBuffer vps, NalUnitTarg
     bitArray.skipBits(8); // general_level_idc
     int toSkip = 0;
     for (int i = 0; i < maxSubLayersMinus1; i++) {
-      if (bitArray.readBits(1) == 1) { // sub_layer_profile_present_flag[i]
+      if (bitArray.readBit()) { // sub_layer_profile_present_flag[i]
         toSkip += 89;
       }
-      if (bitArray.readBits(1) == 1) { // sub_layer_level_present_flag[i]
+      if (bitArray.readBit()) { // sub_layer_level_present_flag[i]
         toSkip += 8;
       }
     }
@@ -309,7 +313,9 @@ private static MediaFormat parseMediaFormat(NalUnitTargetBuffer vps, NalUnitTarg
         Collections.singletonList(csd), MediaFormat.NO_VALUE, pixelWidthHeightRatio);
   }
 
-  /** Skips scaling_list_data(). See H.265/HEVC (2014) 7.3.4. */
+  /**
+   * Skips scaling_list_data(). See H.265/HEVC (2014) 7.3.4.
+   */
   private static void skipScalingList(ParsableBitArray bitArray) {
     for (int sizeId = 0; sizeId < 4; sizeId++) {
       for (int matrixId = 0; matrixId < 6; matrixId += sizeId == 3 ? 3 : 1) {
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/PsExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/PsExtractor.java
index 59059f3122..7a2f5997fc 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/PsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/PsExtractor.java
@@ -119,6 +119,11 @@ public void seek() {
     }
   }
 
+  @Override
+  public void release() {
+    // Do nothing
+  }
+
   @Override
   public int read(ExtractorInput input, PositionHolder seekPosition)
       throws IOException, InterruptedException {
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
index 675c626272..4156fe61ca 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer.extractor.ts;
 
+import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.extractor.DummyTrackOutput;
 import com.google.android.exoplayer.extractor.Extractor;
 import com.google.android.exoplayer.extractor.ExtractorInput;
@@ -39,6 +40,7 @@
   public static final int WORKAROUND_ALLOW_NON_IDR_KEYFRAMES = 1;
   public static final int WORKAROUND_IGNORE_AAC_STREAM = 2;
   public static final int WORKAROUND_IGNORE_H264_STREAM = 4;
+  public static final int WORKAROUND_DETECT_ACCESS_UNITS = 8;
 
   private static final String TAG = "TsExtractor";
 
@@ -121,6 +123,11 @@ public void seek() {
     }
   }
 
+  @Override
+  public void release() {
+    // Do nothing
+  }
+
   @Override
   public int read(ExtractorInput input, PositionHolder seekPosition)
       throws IOException, InterruptedException {
@@ -361,7 +368,8 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
             pesPayloadReader = (workaroundFlags & WORKAROUND_IGNORE_H264_STREAM) != 0 ? null
                 : new H264Reader(output.track(TS_STREAM_TYPE_H264),
                     new SeiReader(output.track(TS_STREAM_TYPE_EIA608)),
-                    (workaroundFlags & WORKAROUND_ALLOW_NON_IDR_KEYFRAMES) != 0);
+                    (workaroundFlags & WORKAROUND_ALLOW_NON_IDR_KEYFRAMES) != 0,
+                    (workaroundFlags & WORKAROUND_DETECT_ACCESS_UNITS) != 0);
             break;
           case TS_STREAM_TYPE_H265:
             pesPayloadReader = new H265Reader(output.track(TS_STREAM_TYPE_H265),
@@ -599,7 +607,7 @@ private boolean parseHeader() {
 
     private void parseHeaderExtension() {
       pesScratch.setPosition(0);
-      timeUs = 0;
+      timeUs = C.UNKNOWN_TIME_US;
       if (ptsFlag) {
         pesScratch.skipBits(4); // '0010' or '0011'
         long pts = (long) pesScratch.readBits(3) << 30;
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavExtractor.java
new file mode 100644
index 0000000000..c83da2f6d8
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavExtractor.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.wav;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.ExtractorOutput;
+import com.google.android.exoplayer.extractor.PositionHolder;
+import com.google.android.exoplayer.extractor.SeekMap;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.MimeTypes;
+
+import java.io.IOException;
+
+/** {@link Extractor} to extract samples from a WAV byte stream. */
+public final class WavExtractor implements Extractor, SeekMap {
+
+  /** Arbitrary maximum input size of 32KB, which is ~170ms of 16-bit stereo PCM audio at 48KHz. */
+  private static final int MAX_INPUT_SIZE = 32 * 1024;
+
+  private ExtractorOutput extractorOutput;
+  private TrackOutput trackOutput;
+  private WavHeader wavHeader;
+  private int bytesPerFrame;
+  private int pendingBytes;
+
+  @Override
+  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+    return WavHeaderReader.peek(input) != null;
+  }
+
+  @Override
+  public void init(ExtractorOutput output) {
+    extractorOutput = output;
+    trackOutput = output.track(0);
+    wavHeader = null;
+    output.endTracks();
+  }
+
+  @Override
+  public void seek() {
+    pendingBytes = 0;
+  }
+
+  @Override
+  public void release() {
+    // Do nothing
+  }
+
+  @Override
+  public int read(ExtractorInput input, PositionHolder seekPosition)
+      throws IOException, InterruptedException {
+
+    if (wavHeader == null) {
+      wavHeader = WavHeaderReader.peek(input);
+      if (wavHeader == null) {
+        // Someone tried to read a non-WAV or unsupported WAV without sniffing first.
+        throw new ParserException("Error initializing WavHeader. Did you sniff first?");
+      }
+      bytesPerFrame = wavHeader.getBytesPerFrame();
+    }
+
+    // If we haven't read in the data start and size, read and store them.
+    if (!wavHeader.hasDataBounds()) {
+      WavHeaderReader.skipToData(input, wavHeader);
+
+      trackOutput.format(
+          MediaFormat.createAudioFormat(
+              null,
+              MimeTypes.AUDIO_RAW,
+              wavHeader.getBitrate(),
+              MAX_INPUT_SIZE,
+              wavHeader.getDurationUs(),
+              wavHeader.getNumChannels(),
+              wavHeader.getSampleRateHz(),
+              null,
+              null));
+      extractorOutput.seekMap(this);
+    }
+
+    int bytesAppended = trackOutput.sampleData(input, MAX_INPUT_SIZE - pendingBytes, true);
+
+    if (bytesAppended != RESULT_END_OF_INPUT) {
+      pendingBytes += bytesAppended;
+    }
+
+    // Round down the pending number of bytes to the nearest frame.
+    int frameBytes = pendingBytes / bytesPerFrame * bytesPerFrame;
+    if (frameBytes > 0) {
+      long sampleStartPosition = input.getPosition() - pendingBytes;
+      pendingBytes -= frameBytes;
+      trackOutput.sampleMetadata(
+          wavHeader.getTimeUs(sampleStartPosition),
+          C.SAMPLE_FLAG_SYNC,
+          frameBytes,
+          pendingBytes,
+          null);
+    }
+
+    if (bytesAppended == RESULT_END_OF_INPUT) {
+      return RESULT_END_OF_INPUT;
+    }
+
+    return RESULT_CONTINUE;
+  }
+
+  // SeekMap implementation.
+
+  @Override
+  public boolean isSeekable() {
+    return true;
+  }
+
+  @Override
+  public long getPosition(long timeUs) {
+    return wavHeader.getPosition(timeUs);
+  }
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeader.java b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeader.java
new file mode 100644
index 0000000000..24fb83ecd8
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeader.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.wav;
+
+import com.google.android.exoplayer.C;
+
+/** Header for a WAV file. */
+/*package*/ final class WavHeader {
+
+  /** Number of audio chanels. */
+  private final int numChannels;
+  /** Sample rate in Hertz. */
+  private final int sampleRateHz;
+  /** Average bytes per second for the sample data. */
+  private final int averageBytesPerSecond;
+  /** Alignment for frames of audio data; should equal {@code numChannels * bitsPerSample / 8}. */
+  private final int blockAlignment;
+  /** Bits per sample for the audio data. */
+  private final int bitsPerSample;
+  /** Offset to the start of sample data. */
+  private long dataStartPosition;
+  /** Total size in bytes of the sample data. */
+  private long dataSize;
+
+  public WavHeader(
+      int numChannels,
+      int sampleRateHz,
+      int averageBytesPerSecond,
+      int blockAlignment,
+      int bitsPerSample) {
+    this.numChannels = numChannels;
+    this.sampleRateHz = sampleRateHz;
+    this.averageBytesPerSecond = averageBytesPerSecond;
+    this.blockAlignment = blockAlignment;
+    this.bitsPerSample = bitsPerSample;
+  }
+
+  /** Returns the duration in microseconds of this WAV. */
+  public long getDurationUs() {
+    return (getNumFrames() * C.MICROS_PER_SECOND) / sampleRateHz;
+  }
+
+  /** Returns the number of samples in this WAV. */
+  public long getNumSamples() {
+    return dataSize / getBytesPerSample();
+  }
+
+  /** Returns the number of frames in this WAV. */
+  public long getNumFrames() {
+    return getNumSamples() / getNumChannels();
+  }
+
+  /** Returns the bytes per sample of this WAV. */
+  public int getBytesPerSample() {
+    return blockAlignment / numChannels;
+  }
+
+  /** Returns the bytes per frame of this WAV. */
+  public int getBytesPerFrame() {
+    return blockAlignment;
+  }
+
+  /** Returns the bitrate of this WAV. */
+  public int getBitrate() {
+    return sampleRateHz * bitsPerSample * numChannels;
+  }
+
+  /** Returns the sample rate in Hertz of this WAV. */
+  public int getSampleRateHz() {
+    return sampleRateHz;
+  }
+
+  /** Returns the number of audio channels in this WAV. */
+  public int getNumChannels() {
+    return numChannels;
+  }
+
+  /** Returns the position in bytes in this WAV for the given time in microseconds. */
+  public long getPosition(long timeUs) {
+    long unroundedPosition = (timeUs * averageBytesPerSecond) / C.MICROS_PER_SECOND;
+    // Round down to nearest frame.
+    return (unroundedPosition / numChannels) * numChannels + dataStartPosition;
+  }
+
+  /** Returns the time in microseconds for the given position in bytes in this WAV. */
+  public long getTimeUs(long position) {
+    return position * C.MICROS_PER_SECOND / averageBytesPerSecond;
+  }
+
+  /** Returns true if the data start position and size have been set. */
+  public boolean hasDataBounds() {
+    return dataStartPosition != 0 && dataSize != 0;
+  }
+
+  /** Sets the start position and size in bytes of sample data in this WAV. */
+  public void setDataBounds(long dataStartPosition, long dataSize) {
+    this.dataStartPosition = dataStartPosition;
+    this.dataSize = dataSize;
+  }
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeaderReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeaderReader.java
new file mode 100644
index 0000000000..3a0ab83265
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeaderReader.java
@@ -0,0 +1,187 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.wav;
+
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.ParsableByteArray;
+import com.google.android.exoplayer.util.Util;
+
+import android.util.Log;
+
+import java.io.IOException;
+
+/** Reads a {@code WavHeader} from an input stream; supports resuming from input failures. */
+/*package*/ final class WavHeaderReader {
+
+  private static final String TAG = "WavHeaderReader";
+
+  /** Integer PCM audio data. */
+  private static final int TYPE_PCM = 0x0001;
+  /** Extended WAVE format. */
+  private static final int TYPE_WAVE_FORMAT_EXTENSIBLE = 0xFFFE;
+
+  /**
+   * Peeks and returns a {@code WavHeader}.
+   *
+   * @param input Input stream to peek the WAV header from.
+   * @throws IOException If peeking from the input fails.
+   * @throws InterruptedException If interrupted while peeking from input.
+   * @throws ParserException If the input file is an incorrect RIFF WAV.
+   * @return A new {@code WavHeader} peeked from {@code input}, or null if the input is not a
+   *     supported WAV format.
+   */
+  public static WavHeader peek(ExtractorInput input)
+      throws IOException, InterruptedException, ParserException {
+    Assertions.checkNotNull(input);
+
+    // Allocate a scratch buffer large enough to store the format chunk.
+    ParsableByteArray scratch = new ParsableByteArray(16);
+
+    // Attempt to read the RIFF chunk.
+    ChunkHeader riffChunkHeader = ChunkHeader.peek(input, scratch);
+    if (riffChunkHeader.id != Util.getIntegerCodeForString("RIFF")) {
+      return null;
+    }
+
+    input.peekFully(scratch.data, 0, 4);
+    scratch.setPosition(0);
+    int riffFormat = scratch.readInt();
+    if (riffFormat != Util.getIntegerCodeForString("WAVE")) {
+      Log.e(TAG, "Unsupported RIFF format: " + riffFormat);
+      return null;
+    }
+
+    // Attempt to read the format chunk.
+    ChunkHeader formatChunkHeader = ChunkHeader.peek(input, scratch);
+    if (formatChunkHeader.id != Util.getIntegerCodeForString("fmt ")) {
+      throw new ParserException(
+          "Second chunk in RIFF WAV should be format; got: " + formatChunkHeader.id);
+    }
+    Assertions.checkState(formatChunkHeader.size >= 16);
+
+    input.peekFully(scratch.data, 0, 16);
+    scratch.setPosition(0);
+    int type = scratch.readLittleEndianUnsignedShort();
+    int numChannels = scratch.readLittleEndianUnsignedShort();
+    int sampleRateHz = scratch.readLittleEndianUnsignedIntToInt();
+    int averageBytesPerSecond = scratch.readLittleEndianUnsignedIntToInt();
+    int blockAlignment = scratch.readLittleEndianUnsignedShort();
+    int bitsPerSample = scratch.readLittleEndianUnsignedShort();
+
+    int expectedBlockAlignment = numChannels * bitsPerSample / 8;
+    if (blockAlignment != expectedBlockAlignment) {
+      throw new ParserException(
+          "Expected WAV block alignment of: "
+              + expectedBlockAlignment
+              + "; got: "
+              + blockAlignment);
+    }
+    if (bitsPerSample != 16) {
+      Log.e(TAG, "Only 16-bit WAVs are supported; got: " + bitsPerSample);
+      return null;
+    }
+
+    if (type != TYPE_PCM && type != TYPE_WAVE_FORMAT_EXTENSIBLE) {
+      Log.e(TAG, "Unsupported WAV format type: " + type);
+      return null;
+    }
+
+    // If present, skip extensionSize, validBitsPerSample, channelMask, subFormatGuid, ...
+    input.advancePeekPosition((int) formatChunkHeader.size - 16);
+
+    return new WavHeader(
+        numChannels, sampleRateHz, averageBytesPerSecond, blockAlignment, bitsPerSample);
+  }
+
+  /**
+   * Skips to the data in the given WAV input stream and returns its data size. After calling, the
+   * input stream's position will point to the start of sample data in the WAV.
+   * <p>
+   * If an exception is thrown, the input position will be left pointing to a chunk header.
+   *
+   * @param input Input stream to skip to the data chunk in. Its peek position must be pointing to
+   *     a valid chunk header.
+   * @param wavHeader WAV header to populate with data bounds.
+   * @throws IOException If reading from the input fails.
+   * @throws InterruptedException If interrupted while reading from input.
+   * @throws ParserException If an error occurs parsing chunks.
+   */
+  public static void skipToData(ExtractorInput input, WavHeader wavHeader)
+      throws IOException, InterruptedException, ParserException {
+    Assertions.checkNotNull(input);
+    Assertions.checkNotNull(wavHeader);
+
+    ParsableByteArray scratch = new ParsableByteArray(ChunkHeader.SIZE_IN_BYTES);
+    // Skip all chunks until we hit the data header.
+    ChunkHeader chunkHeader = ChunkHeader.peek(input, scratch);
+    while (chunkHeader.id != Util.getIntegerCodeForString("data")) {
+      Log.w(TAG, "Ignoring unknown WAV chunk: " + chunkHeader.id);
+      long bytesToSkip = ChunkHeader.SIZE_IN_BYTES + chunkHeader.size;
+      // Override size of RIFF chunk, since it describes its size as the entire file.
+      if (chunkHeader.id == Util.getIntegerCodeForString("RIFF")) {
+        bytesToSkip = ChunkHeader.SIZE_IN_BYTES + 4;
+      }
+      if (bytesToSkip > Integer.MAX_VALUE) {
+        throw new ParserException("Chunk is too large (~2GB+) to skip; id: " + chunkHeader.id);
+      }
+      input.skipFully((int) bytesToSkip);
+      chunkHeader = ChunkHeader.peek(input, scratch);
+    }
+    // Skip past the "data" header.
+    input.skipFully(ChunkHeader.SIZE_IN_BYTES);
+
+    wavHeader.setDataBounds(input.getPosition(), chunkHeader.size);
+  }
+
+  /** Container for a WAV chunk header. */
+  private static final class ChunkHeader {
+
+    /** Size in bytes of a WAV chunk header. */
+    public static final int SIZE_IN_BYTES = 8;
+
+    /** 4-character identifier, stored as an integer, for this chunk. */
+    public final int id;
+    /** Size of this chunk in bytes. */
+    public final long size;
+
+    private ChunkHeader(int id, long size) {
+      this.id = id;
+      this.size = size;
+    }
+
+    /**
+     * Peeks and returns a {@link ChunkHeader}.
+     *
+     * @param input Input stream to peek the chunk header from.
+     * @param scratch Buffer for temporary use.
+     * @throws IOException If peeking from the input fails.
+     * @throws InterruptedException If interrupted while peeking from input.
+     * @return A new {@code ChunkHeader} peeked from {@code input}.
+     */
+    public static ChunkHeader peek(ExtractorInput input, ParsableByteArray scratch)
+        throws IOException, InterruptedException {
+      input.peekFully(scratch.data, 0, SIZE_IN_BYTES);
+      scratch.setPosition(0);
+
+      int id = scratch.readInt();
+      long size = scratch.readLittleEndianUnsignedInt();
+
+      return new ChunkHeader(id, size);
+    }
+  }
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReader.java
index 1f036f8d27..fd1de76aaa 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReader.java
@@ -147,15 +147,14 @@ public boolean read(ExtractorInput input) throws IOException, InterruptedExcepti
    */
   private long maybeResyncToNextLevel1Element(ExtractorInput input) throws EOFException,
       IOException, InterruptedException {
+    input.resetPeekPosition();
     while (true) {
-      input.resetPeekPosition();
       input.peekFully(scratch, 0, MAX_ID_BYTES);
       int varintLength = VarintReader.parseUnsignedVarintLength(scratch[0]);
       if (varintLength != -1 && varintLength <= MAX_ID_BYTES) {
         int potentialId = (int) VarintReader.assembleVarint(scratch, varintLength, false);
         if (output.isLevel1Element(potentialId)) {
           input.skipFully(varintLength);
-          input.resetPeekPosition();
           return potentialId;
         }
       }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
index 96ce99a638..eacb3199a5 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
@@ -44,6 +44,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Locale;
+import java.util.UUID;
 
 /**
  * An extractor to facilitate data retrieval from the WebM container format.
@@ -70,6 +71,7 @@
   private static final String CODEC_ID_MPEG4_AP = "V_MPEG4/ISO/AP";
   private static final String CODEC_ID_H264 = "V_MPEG4/ISO/AVC";
   private static final String CODEC_ID_H265 = "V_MPEGH/ISO/HEVC";
+  private static final String CODEC_ID_FOURCC = "V_MS/VFW/FOURCC";
   private static final String CODEC_ID_VORBIS = "A_VORBIS";
   private static final String CODEC_ID_OPUS = "A_OPUS";
   private static final String CODEC_ID_AAC = "A_AAC";
@@ -80,7 +82,12 @@
   private static final String CODEC_ID_DTS = "A_DTS";
   private static final String CODEC_ID_DTS_EXPRESS = "A_DTS/EXPRESS";
   private static final String CODEC_ID_DTS_LOSSLESS = "A_DTS/LOSSLESS";
+  private static final String CODEC_ID_FLAC = "A_FLAC";
+  private static final String CODEC_ID_ACM = "A_MS/ACM";
+  private static final String CODEC_ID_PCM_INT_LIT = "A_PCM/INT/LIT";
   private static final String CODEC_ID_SUBRIP = "S_TEXT/UTF8";
+  private static final String CODEC_ID_VOBSUB = "S_VOBSUB";
+  private static final String CODEC_ID_PGS = "S_HDMV/PGS";
 
   private static final int VORBIS_MAX_INPUT_SIZE = 8192;
   private static final int OPUS_MAX_INPUT_SIZE = 5760;
@@ -121,8 +128,12 @@
   private static final int ID_VIDEO = 0xE0;
   private static final int ID_PIXEL_WIDTH = 0xB0;
   private static final int ID_PIXEL_HEIGHT = 0xBA;
+  private static final int ID_DISPLAY_WIDTH = 0x54B0;
+  private static final int ID_DISPLAY_HEIGHT = 0x54BA;
+  private static final int ID_DISPLAY_UNIT = 0x54B2;
   private static final int ID_AUDIO = 0xE1;
   private static final int ID_CHANNELS = 0x9F;
+  private static final int ID_AUDIO_BIT_DEPTH = 0x6264;
   private static final int ID_SAMPLING_FREQUENCY = 0xB5;
   private static final int ID_CONTENT_ENCODINGS = 0x6D80;
   private static final int ID_CONTENT_ENCODING = 0x6240;
@@ -148,6 +159,8 @@
   private static final int LACING_FIXED_SIZE = 2;
   private static final int LACING_EBML = 3;
 
+  private static final int FOURCC_COMPRESSION_VC1 = 0x31435657;
+
   /**
    * A template for the prefix that must be added to each subrip sample. The 12 byte end timecode
    * starting at {@link #SUBRIP_PREFIX_END_TIMECODE_OFFSET} is set to a dummy value, and must be
@@ -174,6 +187,23 @@
    */
   private static final int SUBRIP_TIMECODE_LENGTH = 12;
 
+  /**
+   * The length in bytes of a WAVEFORMATEX structure.
+   */
+  private static final int WAVE_FORMAT_SIZE = 18;
+  /**
+   * Format tag indicating a WAVEFORMATEXTENSIBLE structure.
+   */
+  private static final int WAVE_FORMAT_EXTENSIBLE = 0xFFFE;
+  /**
+   * Format tag for PCM.
+   */
+  private static final int WAVE_FORMAT_PCM = 1;
+  /**
+   * Sub format for PCM.
+   */
+  private static final UUID WAVE_SUBFORMAT_PCM = new UUID(0x0100000000001000L, 0x800000AA00389B71L);
+
   private final EbmlReader reader;
   private final VarintReader varintReader;
   private final SparseArray<Track> tracks;
@@ -272,6 +302,11 @@ public void seek() {
     resetSample();
   }
 
+  @Override
+  public void release() {
+    // Do nothing
+  }
+
   @Override
   public int read(ExtractorInput input, PositionHolder seekPosition) throws IOException,
       InterruptedException {
@@ -316,12 +351,16 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       case ID_BLOCK_DURATION:
       case ID_PIXEL_WIDTH:
       case ID_PIXEL_HEIGHT:
+      case ID_DISPLAY_WIDTH:
+      case ID_DISPLAY_HEIGHT:
+      case ID_DISPLAY_UNIT:
       case ID_TRACK_NUMBER:
       case ID_TRACK_TYPE:
       case ID_DEFAULT_DURATION:
       case ID_CODEC_DELAY:
       case ID_SEEK_PRE_ROLL:
       case ID_CHANNELS:
+      case ID_AUDIO_BIT_DEPTH:
       case ID_CONTENT_ENCODING_ORDER:
       case ID_CONTENT_ENCODING_SCOPE:
       case ID_CONTENT_COMPRESSION_ALGORITHM:
@@ -510,6 +549,15 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       case ID_PIXEL_HEIGHT:
         currentTrack.height = (int) value;
         return;
+      case ID_DISPLAY_WIDTH:
+        currentTrack.displayWidth = (int) value;
+        return;
+      case ID_DISPLAY_HEIGHT:
+        currentTrack.displayHeight = (int) value;
+        return;
+      case ID_DISPLAY_UNIT:
+        currentTrack.displayUnit = (int) value;
+        return;
       case ID_TRACK_NUMBER:
         currentTrack.number = (int) value;
         return;
@@ -518,7 +566,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
         return;
       case ID_DEFAULT_DURATION:
         currentTrack.defaultSampleDurationNs = (int) value;
-        break;
+        return;
       case ID_CODEC_DELAY:
         currentTrack.codecDelayNs = value;
         return;
@@ -528,6 +576,9 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       case ID_CHANNELS:
         currentTrack.channelCount = (int) value;
         return;
+      case ID_AUDIO_BIT_DEPTH:
+        currentTrack.audioBitDepth = (int) value;
+        return;
       case ID_REFERENCE_BLOCK:
         sampleSeenReferenceBlock = true;
         return;
@@ -1041,6 +1092,7 @@ private static boolean isCodecSupported(String codecId) {
         || CODEC_ID_MPEG4_AP.equals(codecId)
         || CODEC_ID_H264.equals(codecId)
         || CODEC_ID_H265.equals(codecId)
+        || CODEC_ID_FOURCC.equals(codecId)
         || CODEC_ID_OPUS.equals(codecId)
         || CODEC_ID_VORBIS.equals(codecId)
         || CODEC_ID_AAC.equals(codecId)
@@ -1051,7 +1103,12 @@ private static boolean isCodecSupported(String codecId) {
         || CODEC_ID_DTS.equals(codecId)
         || CODEC_ID_DTS_EXPRESS.equals(codecId)
         || CODEC_ID_DTS_LOSSLESS.equals(codecId)
-        || CODEC_ID_SUBRIP.equals(codecId);
+        || CODEC_ID_FLAC.equals(codecId)
+        || CODEC_ID_ACM.equals(codecId)
+        || CODEC_ID_PCM_INT_LIT.equals(codecId)
+        || CODEC_ID_SUBRIP.equals(codecId)
+        || CODEC_ID_VOBSUB.equals(codecId)
+        || CODEC_ID_PGS.equals(codecId);
   }
 
   /**
@@ -1120,6 +1177,8 @@ public void binaryElement(int id, int contentsSize, ExtractorInput input)
 
   private static final class Track {
 
+    private static final int DISPLAY_UNIT_PIXELS = 0;
+
     // Common elements.
     public String codecId;
     public int number;
@@ -1133,9 +1192,13 @@ public void binaryElement(int id, int contentsSize, ExtractorInput input)
     // Video elements.
     public int width = MediaFormat.NO_VALUE;
     public int height = MediaFormat.NO_VALUE;
+    public int displayWidth = MediaFormat.NO_VALUE;
+    public int displayHeight = MediaFormat.NO_VALUE;
+    public int displayUnit = DISPLAY_UNIT_PIXELS;
 
     // Audio elements. Initially set to their default values.
     public int channelCount = 1;
+    public int audioBitDepth = -1;
     public int sampleRate = 8000;
     public long codecDelayNs = 0;
     public long seekPreRollNs = 0;
@@ -1186,6 +1249,10 @@ public void initializeOutput(ExtractorOutput output, int trackId, long durationU
           initializationData = hevcData.first;
           nalUnitLengthFieldLength = hevcData.second;
           break;
+        case CODEC_ID_FOURCC:
+          mimeType = MimeTypes.VIDEO_VC1;
+          initializationData = parseFourCcVc1Private(new ParsableByteArray(codecPrivate));
+          break;
         case CODEC_ID_VORBIS:
           mimeType = MimeTypes.AUDIO_VORBIS;
           maxInputSize = VORBIS_MAX_INPUT_SIZE;
@@ -1225,9 +1292,35 @@ public void initializeOutput(ExtractorOutput output, int trackId, long durationU
         case CODEC_ID_DTS_LOSSLESS:
           mimeType = MimeTypes.AUDIO_DTS_HD;
           break;
+        case CODEC_ID_FLAC:
+          mimeType = MimeTypes.AUDIO_FLAC;
+          initializationData = Collections.singletonList(codecPrivate);
+          break;
+        case CODEC_ID_ACM:
+          mimeType = MimeTypes.AUDIO_RAW;
+          if (!parseMsAcmCodecPrivate(new ParsableByteArray(codecPrivate))) {
+            throw new ParserException("Non-PCM MS/ACM is unsupported");
+          }
+          if (audioBitDepth != 16) {
+            throw new ParserException("Unsupported PCM bit depth: " + audioBitDepth);
+          }
+          break;
+        case CODEC_ID_PCM_INT_LIT:
+          mimeType = MimeTypes.AUDIO_RAW;
+          if (audioBitDepth != 16) {
+            throw new ParserException("Unsupported PCM bit depth: " + audioBitDepth);
+          }
+          break;
         case CODEC_ID_SUBRIP:
           mimeType = MimeTypes.APPLICATION_SUBRIP;
           break;
+        case CODEC_ID_VOBSUB:
+          mimeType = MimeTypes.APPLICATION_VOBSUB;
+          initializationData = Collections.singletonList(codecPrivate);
+          break;
+        case CODEC_ID_PGS:
+          mimeType = MimeTypes.APPLICATION_PGS;
+          break;
         default:
           throw new ParserException("Unrecognized codec identifier.");
       }
@@ -1240,11 +1333,24 @@ public void initializeOutput(ExtractorOutput output, int trackId, long durationU
             MediaFormat.NO_VALUE, maxInputSize, durationUs, channelCount, sampleRate,
             initializationData, language);
       } else if (MimeTypes.isVideo(mimeType)) {
+        if (displayUnit == Track.DISPLAY_UNIT_PIXELS) {
+          displayWidth = displayWidth == MediaFormat.NO_VALUE ? width : displayWidth;
+          displayHeight = displayHeight == MediaFormat.NO_VALUE ? height : displayHeight;
+        }
+        float pixelWidthHeightRatio = MediaFormat.NO_VALUE;
+        if (displayWidth != MediaFormat.NO_VALUE && displayHeight != MediaFormat.NO_VALUE) {
+          pixelWidthHeightRatio = ((float) (height * displayWidth)) / (width * displayHeight);
+        }
         format = MediaFormat.createVideoFormat(Integer.toString(trackId), mimeType,
-            MediaFormat.NO_VALUE, maxInputSize, durationUs, width, height, initializationData);
+            MediaFormat.NO_VALUE, maxInputSize, durationUs, width, height, initializationData,
+            MediaFormat.NO_VALUE, pixelWidthHeightRatio);
       } else if (MimeTypes.APPLICATION_SUBRIP.equals(mimeType)) {
         format = MediaFormat.createTextFormat(Integer.toString(trackId), mimeType,
             MediaFormat.NO_VALUE, durationUs, language);
+      } else if (MimeTypes.APPLICATION_VOBSUB.equals(mimeType)
+          || MimeTypes.APPLICATION_PGS.equals(mimeType)) {
+        format = MediaFormat.createImageFormat(Integer.toString(trackId), mimeType,
+            MediaFormat.NO_VALUE, durationUs, initializationData, language);
       } else {
         throw new ParserException("Unexpected MIME type.");
       }
@@ -1253,6 +1359,42 @@ public void initializeOutput(ExtractorOutput output, int trackId, long durationU
       this.output.format(format);
     }
 
+    /**
+     * Builds initialization data for a {@link MediaFormat} from FourCC codec private data.
+     * <p>
+     * VC1 is the only supported compression type.
+     *
+     * @return The initialization data for the {@link MediaFormat}.
+     * @throws ParserException If the initialization data could not be built.
+     */
+    private static List<byte[]> parseFourCcVc1Private(ParsableByteArray buffer)
+        throws ParserException {
+      try {
+        buffer.skipBytes(16); // size(4), width(4), height(4), planes(2), bitcount(2).
+        long compression = buffer.readLittleEndianUnsignedInt();
+        if (compression != FOURCC_COMPRESSION_VC1) {
+          throw new ParserException("Unsupported FourCC compression type: " + compression);
+        }
+
+        // Search for the initialization data from the end of the BITMAPINFOHEADER. The last 20
+        // bytes of which are: sizeImage(4), xPel/m (4), yPel/m (4), clrUsed(4), clrImportant(4).
+        int startOffset = buffer.getPosition() + 20;
+        byte[] bufferData = buffer.data;
+        for (int offset = startOffset; offset < bufferData.length - 4; offset++) {
+          if (bufferData[offset] == 0x00 && bufferData[offset + 1] == 0x00
+              && bufferData[offset + 2] == 0x01 && bufferData[offset + 3] == 0x0F) {
+            // We've found the initialization data.
+            byte[] initializationData = Arrays.copyOfRange(bufferData, offset, bufferData.length);
+            return Collections.singletonList(initializationData);
+          }
+        }
+
+        throw new ParserException("Failed to find FourCC VC1 initialization data");
+      } catch (ArrayIndexOutOfBoundsException e) {
+        throw new ParserException("Error parsing FourCC VC1 codec private");
+      }
+    }
+
     /**
      * Builds initialization data for a {@link MediaFormat} from H.264 (AVC) codec private data.
      *
@@ -1387,6 +1529,29 @@ public void initializeOutput(ExtractorOutput output, int trackId, long durationU
       }
     }
 
+    /**
+     * Parses an MS/ACM codec private, returning whether it indicates PCM audio.
+     *
+     * @return True if the codec private indicates PCM audio. False otherwise.
+     * @throws ParserException If a parsing error occurs.
+     */
+    private static boolean parseMsAcmCodecPrivate(ParsableByteArray buffer) throws ParserException {
+      try {
+        int formatTag = buffer.readLittleEndianUnsignedShort();
+        if (formatTag == WAVE_FORMAT_PCM) {
+          return true;
+        } else if (formatTag == WAVE_FORMAT_EXTENSIBLE) {
+          buffer.setPosition(WAVE_FORMAT_SIZE + 6); // unionSamples(2), channelMask(4)
+          return buffer.readLong() == WAVE_SUBFORMAT_PCM.getMostSignificantBits()
+              && buffer.readLong() == WAVE_SUBFORMAT_PCM.getLeastSignificantBits();
+        } else {
+          return false;
+        }
+      } catch (ArrayIndexOutOfBoundsException e) {
+        throw new ParserException("Error parsing MS/ACM codec private");
+      }
+    }
+
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/DefaultHlsTrackSelector.java b/library/src/main/java/com/google/android/exoplayer/hls/DefaultHlsTrackSelector.java
index 86dbc6f3fb..9ab999a94d 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/DefaultHlsTrackSelector.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/DefaultHlsTrackSelector.java
@@ -30,7 +30,8 @@
 public final class DefaultHlsTrackSelector implements HlsTrackSelector {
 
   private static final int TYPE_DEFAULT = 0;
-  private static final int TYPE_VTT = 1;
+  private static final int TYPE_AUDIO = 1;
+  private static final int TYPE_SUBTITLE = 2;
 
   private final Context context;
   private final int type;
@@ -45,13 +46,22 @@ public static DefaultHlsTrackSelector newDefaultInstance(Context context) {
     return new DefaultHlsTrackSelector(context, TYPE_DEFAULT);
   }
 
+  /**
+   * Creates a {@link DefaultHlsTrackSelector} that selects alternate audio renditions.
+   *
+   * @return The selector instance.
+   */
+  public static DefaultHlsTrackSelector newAudioInstance() {
+    return new DefaultHlsTrackSelector(null, TYPE_AUDIO);
+  }
+
   /**
    * Creates a {@link DefaultHlsTrackSelector} that selects subtitle renditions.
    *
    * @return The selector instance.
    */
-  public static DefaultHlsTrackSelector newVttInstance() {
-    return new DefaultHlsTrackSelector(null, TYPE_VTT);
+  public static DefaultHlsTrackSelector newSubtitleInstance() {
+    return new DefaultHlsTrackSelector(null, TYPE_SUBTITLE);
   }
 
   private DefaultHlsTrackSelector(Context context, int type) {
@@ -61,11 +71,11 @@ private DefaultHlsTrackSelector(Context context, int type) {
 
   @Override
   public void selectTracks(HlsMasterPlaylist playlist, Output output) throws IOException {
-    if (type == TYPE_VTT) {
-      List<Variant> subtitleVariants = playlist.subtitles;
-      if (subtitleVariants != null && !subtitleVariants.isEmpty()) {
-        for (int i = 0; i < subtitleVariants.size(); i++) {
-          output.fixedTrack(playlist, subtitleVariants.get(i));
+    if (type == TYPE_AUDIO || type == TYPE_SUBTITLE) {
+      List<Variant> variants = type == TYPE_AUDIO ? playlist.audios : playlist.subtitles;
+      if (variants != null && !variants.isEmpty()) {
+        for (int i = 0; i < variants.size(); i++) {
+          output.fixedTrack(playlist, variants.get(i));
         }
       }
       return;
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
index 39288400ff..853f6b3c67 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
@@ -227,7 +227,7 @@ public HlsChunkSource(boolean isMaster, DataSource dataSource, String playlistUr
       List<Variant> variants = new ArrayList<>();
       variants.add(new Variant(playlistUrl, format));
       masterPlaylist = new HlsMasterPlaylist(playlistUrl, variants,
-          Collections.<Variant>emptyList());
+          Collections.<Variant>emptyList(), Collections.<Variant>emptyList(), null, null);
     }
   }
 
@@ -308,6 +308,23 @@ public Variant getFixedTrackVariant(int index) {
     return variants.length == 1 ? variants[0] : null;
   }
 
+  /**
+   * Returns the language of the audio muxed into variants, or null if unknown.
+   *
+   * @return The language of the audio muxed into variants, or null if unknown.
+   */
+  public String getMuxedAudioLanguage() {
+    return masterPlaylist.muxedAudioLanguage;
+  }
+
+  /**
+   * Returns the language of the captions muxed into variants, or null if unknown.
+   *
+   * @return The language of the captions muxed into variants, or null if unknown.
+   */
+  public String getMuxedCaptionLanguage() {
+    return masterPlaylist.muxedCaptionLanguage;
+  }
 
   /**
    * Returns the currently selected track index.
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsMasterPlaylist.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsMasterPlaylist.java
index 4222c5ab5b..dbff520752 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsMasterPlaylist.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsMasterPlaylist.java
@@ -24,12 +24,21 @@
 public final class HlsMasterPlaylist extends HlsPlaylist {
 
   public final List<Variant> variants;
+  public final List<Variant> audios;
   public final List<Variant> subtitles;
 
-  public HlsMasterPlaylist(String baseUri, List<Variant> variants, List<Variant> subtitles) {
+  public final String muxedAudioLanguage;
+  public final String muxedCaptionLanguage;
+
+  public HlsMasterPlaylist(String baseUri, List<Variant> variants,
+      List<Variant> audios, List<Variant> subtitles, String muxedAudioLanguage,
+      String muxedCaptionLanguage) {
     super(baseUri, HlsPlaylist.TYPE_MASTER);
     this.variants = Collections.unmodifiableList(variants);
+    this.audios = Collections.unmodifiableList(audios);
     this.subtitles = Collections.unmodifiableList(subtitles);
+    this.muxedAudioLanguage = muxedAudioLanguage;
+    this.muxedCaptionLanguage = muxedCaptionLanguage;
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsMediaPlaylist.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsMediaPlaylist.java
index 44c760bccf..acf21d21f4 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsMediaPlaylist.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsMediaPlaylist.java
@@ -36,12 +36,12 @@
     public final boolean isEncrypted;
     public final String encryptionKeyUri;
     public final String encryptionIV;
-    public final int byterangeOffset;
-    public final int byterangeLength;
+    public final long byterangeOffset;
+    public final long byterangeLength;
 
     public Segment(String uri, double durationSecs, int discontinuitySequenceNumber,
         long startTimeUs, boolean isEncrypted, String encryptionKeyUri, String encryptionIV,
-        int byterangeOffset, int byterangeLength) {
+        long byterangeOffset, long byterangeLength) {
       this.url = uri;
       this.durationSecs = durationSecs;
       this.discontinuitySequenceNumber = discontinuitySequenceNumber;
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java
index 432229fb28..a873d30783 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java
@@ -59,6 +59,7 @@
   private static final String METHOD_ATTR = "METHOD";
   private static final String URI_ATTR = "URI";
   private static final String IV_ATTR = "IV";
+  private static final String INSTREAM_ID_ATTR = "INSTREAM-ID";
 
   private static final String AUDIO_TYPE = "AUDIO";
   private static final String VIDEO_TYPE = "VIDEO";
@@ -98,6 +99,8 @@
       Pattern.compile(LANGUAGE_ATTR + "=\"(.+?)\"");
   private static final Pattern NAME_ATTR_REGEX =
       Pattern.compile(NAME_ATTR + "=\"(.+?)\"");
+  private static final Pattern INSTREAM_ID_ATTR_REGEX =
+      Pattern.compile(INSTREAM_ID_ATTR + "=\"(.+?)\"");
   // private static final Pattern AUTOSELECT_ATTR_REGEX =
   //     HlsParserUtil.compileBooleanAttrPattern(AUTOSELECT_ATTR);
   // private static final Pattern DEFAULT_ATTR_REGEX =
@@ -140,12 +143,15 @@ public HlsPlaylist parse(String connectionUrl, InputStream inputStream)
   private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, String baseUri)
       throws IOException {
     ArrayList<Variant> variants = new ArrayList<>();
+    ArrayList<Variant> audios = new ArrayList<>();
     ArrayList<Variant> subtitles = new ArrayList<>();
     int bitrate = 0;
     String codecs = null;
     int width = -1;
     int height = -1;
     String name = null;
+    String muxedAudioLanguage = null;
+    String muxedCaptionLanguage = null;
 
     boolean expectingStreamInfUrl = false;
     String line;
@@ -153,7 +159,13 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
       line = iterator.next();
       if (line.startsWith(MEDIA_TAG)) {
         String type = HlsParserUtil.parseStringAttr(line, TYPE_ATTR_REGEX, TYPE_ATTR);
-        if (SUBTITLES_TYPE.equals(type)) {
+        if (CLOSED_CAPTIONS_TYPE.equals(type)) {
+          String instreamId = HlsParserUtil.parseStringAttr(line, INSTREAM_ID_ATTR_REGEX,
+              INSTREAM_ID_ATTR);
+          if ("CC1".equals(instreamId)) {
+            muxedCaptionLanguage = HlsParserUtil.parseOptionalStringAttr(line, LANGUAGE_ATTR_REGEX);
+          }
+        } else if (SUBTITLES_TYPE.equals(type)) {
           // We assume all subtitles belong to the same group.
           String subtitleName = HlsParserUtil.parseStringAttr(line, NAME_ATTR_REGEX, NAME_ATTR);
           String uri = HlsParserUtil.parseStringAttr(line, URI_ATTR_REGEX, URI_ATTR);
@@ -161,8 +173,18 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
           Format format = new Format(subtitleName, MimeTypes.APPLICATION_M3U8, -1, -1, -1, -1, -1,
               -1, language, codecs);
           subtitles.add(new Variant(uri, format));
-        } else {
-          // TODO: Support other types of media tag.
+        } else if (AUDIO_TYPE.equals(type)) {
+          // We assume all audios belong to the same group.
+          String language = HlsParserUtil.parseOptionalStringAttr(line, LANGUAGE_ATTR_REGEX);
+          String uri = HlsParserUtil.parseOptionalStringAttr(line, URI_ATTR_REGEX);
+          if (uri != null) {
+            String audioName = HlsParserUtil.parseStringAttr(line, NAME_ATTR_REGEX, NAME_ATTR);
+            Format format = new Format(audioName, MimeTypes.APPLICATION_M3U8, -1, -1, -1, -1, -1,
+                -1, language, codecs);
+            audios.add(new Variant(uri, format));
+          } else {
+            muxedAudioLanguage = language;
+          }
         }
       } else if (line.startsWith(STREAM_INF_TAG)) {
         bitrate = HlsParserUtil.parseIntAttr(line, BANDWIDTH_ATTR_REGEX, BANDWIDTH_ATTR);
@@ -202,7 +224,8 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
         expectingStreamInfUrl = false;
       }
     }
-    return new HlsMasterPlaylist(baseUri, variants, subtitles);
+    return new HlsMasterPlaylist(baseUri, variants, audios, subtitles, muxedAudioLanguage,
+        muxedCaptionLanguage);
   }
 
   private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String baseUri)
@@ -216,8 +239,8 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
     double segmentDurationSecs = 0.0;
     int discontinuitySequenceNumber = 0;
     long segmentStartTimeUs = 0;
-    int segmentByterangeOffset = 0;
-    int segmentByterangeLength = C.LENGTH_UNBOUNDED;
+    long segmentByterangeOffset = 0;
+    long segmentByterangeLength = C.LENGTH_UNBOUNDED;
     int segmentMediaSequence = 0;
 
     boolean isEncrypted = false;
@@ -251,9 +274,9 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
       } else if (line.startsWith(BYTERANGE_TAG)) {
         String byteRange = HlsParserUtil.parseStringAttr(line, BYTERANGE_REGEX, BYTERANGE_TAG);
         String[] splitByteRange = byteRange.split("@");
-        segmentByterangeLength = Integer.parseInt(splitByteRange[0]);
+        segmentByterangeLength = Long.parseLong(splitByteRange[0]);
         if (splitByteRange.length > 1) {
-          segmentByterangeOffset = Integer.parseInt(splitByteRange[1]);
+          segmentByterangeOffset = Long.parseLong(splitByteRange[1]);
         }
       } else if (line.startsWith(DISCONTINUITY_SEQUENCE_TAG)) {
         discontinuitySequenceNumber = Integer.parseInt(line.substring(line.indexOf(':') + 1));
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
index 63b0740418..1ed68da072 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
@@ -542,18 +542,24 @@ private void buildTracks(HlsExtractorWrapper extractor) {
     int trackIndex = 0;
     for (int i = 0; i < extractorTrackCount; i++) {
       MediaFormat format = extractor.getMediaFormat(i).copyWithDurationUs(durationUs);
+      String language = null;
+      if (MimeTypes.isAudio(format.mimeType)) {
+        language = chunkSource.getMuxedAudioLanguage();
+      } else if (MimeTypes.APPLICATION_EIA608.equals(format.mimeType)) {
+        language = chunkSource.getMuxedCaptionLanguage();
+      }
       if (i == primaryExtractorTrackIndex) {
         for (int j = 0; j < chunkSourceTrackCount; j++) {
           extractorTrackIndices[trackIndex] = i;
           chunkSourceTrackIndices[trackIndex] = j;
           Variant fixedTrackVariant = chunkSource.getFixedTrackVariant(j);
           trackFormats[trackIndex++] = fixedTrackVariant == null ? format.copyAsAdaptive(null)
-              : copyWithFixedTrackInfo(format, fixedTrackVariant.format);
+              : copyWithFixedTrackInfo(format, fixedTrackVariant.format, language);
         }
       } else {
         extractorTrackIndices[trackIndex] = i;
         chunkSourceTrackIndices[trackIndex] = -1;
-        trackFormats[trackIndex++] = format;
+        trackFormats[trackIndex++] = format.copyWithLanguage(language);
       }
     }
   }
@@ -575,17 +581,19 @@ private void setTrackEnabledState(int track, boolean enabledState) {
 
   /**
    * Copies a provided {@link MediaFormat}, incorporating information from the {@link Format} of
-   * a fixed (i.e. non-adaptive) track.
+   * a fixed (i.e. non-adaptive) track, as well as a language.
    *
    * @param format The {@link MediaFormat} to copy.
    * @param fixedTrackFormat The {@link Format} to incorporate into the copy.
+   * @param language The language to incorporate into the copy.
    * @return The copied {@link MediaFormat}.
    */
-  private static MediaFormat copyWithFixedTrackInfo(MediaFormat format, Format fixedTrackFormat) {
+  private static MediaFormat copyWithFixedTrackInfo(MediaFormat format, Format fixedTrackFormat,
+      String language) {
     int width = fixedTrackFormat.width == -1 ? MediaFormat.NO_VALUE : fixedTrackFormat.width;
     int height = fixedTrackFormat.height == -1 ? MediaFormat.NO_VALUE : fixedTrackFormat.height;
     return format.copyWithFixedTrackInfo(fixedTrackFormat.id, fixedTrackFormat.bitrate, width,
-        height, fixedTrackFormat.language);
+        height, language);
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/WebvttExtractor.java b/library/src/main/java/com/google/android/exoplayer/hls/WebvttExtractor.java
index 1406807ede..25b97b17c1 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/WebvttExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/WebvttExtractor.java
@@ -84,6 +84,11 @@ public void seek() {
     throw new IllegalStateException();
   }
 
+  @Override
+  public void release() {
+    // Do nothing
+  }
+
   @Override
   public int read(ExtractorInput input, PositionHolder seekPosition)
       throws IOException, InterruptedException {
diff --git a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingChunkSource.java b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingChunkSource.java
index 79405466f6..be1051b30a 100644
--- a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingChunkSource.java
@@ -426,14 +426,13 @@ private MediaFormat initManifestTrack(SmoothStreamingManifest manifest, int elem
         throw new IllegalStateException("Invalid type: " + element.type);
     }
 
-    // Build the extractor.
-    FragmentedMp4Extractor mp4Extractor = new FragmentedMp4Extractor(
-        FragmentedMp4Extractor.WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME
-        | FragmentedMp4Extractor.WORKAROUND_IGNORE_TFDT_BOX);
     Track mp4Track = new Track(trackIndex, mp4TrackType, element.timescale, C.UNKNOWN_TIME_US,
         durationUs, mediaFormat, trackEncryptionBoxes, mp4TrackType == Track.TYPE_vide ? 4 : -1,
         null, null);
-    mp4Extractor.setTrack(mp4Track);
+    // Build the extractor.
+    FragmentedMp4Extractor mp4Extractor = new FragmentedMp4Extractor(
+        FragmentedMp4Extractor.FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME
+        | FragmentedMp4Extractor.FLAG_WORKAROUND_IGNORE_TFDT_BOX, mp4Track);
 
     // Store the format and a wrapper around the extractor.
     mediaFormats.put(manifestTrackKey, mediaFormat);
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/UdpDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/UdpDataSource.java
index c9a41e3aa3..4dc4a68398 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/UdpDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/UdpDataSource.java
@@ -23,6 +23,7 @@
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.MulticastSocket;
+import java.net.SocketException;
 
 /**
  * A UDP {@link DataSource}.
@@ -49,8 +50,14 @@ public UdpDataSourceException(IOException cause) {
    */
   public static final int DEFAULT_MAX_PACKET_SIZE = 2000;
 
+  /**
+   * The default socket timeout, in milliseconds.
+   */
+  public static final int DEAFULT_SOCKET_TIMEOUT_MILLIS = 8 * 1000;
+
   private final TransferListener listener;
   private final DatagramPacket packet;
+  private final int socketTimeoutMillis;
 
   private DataSpec dataSpec;
   private DatagramSocket socket;
@@ -74,7 +81,18 @@ public UdpDataSource(TransferListener listener) {
    * @param maxPacketSize The maximum datagram packet size, in bytes.
    */
   public UdpDataSource(TransferListener listener, int maxPacketSize) {
+    this(listener, maxPacketSize, DEAFULT_SOCKET_TIMEOUT_MILLIS);
+  }
+
+  /**
+   * @param listener An optional listener.
+   * @param maxPacketSize The maximum datagram packet size, in bytes.
+   * @param socketTimeoutMillis The socket timeout in milliseconds. A timeout of zero is interpreted
+   *     as an infinite timeout.
+   */
+  public UdpDataSource(TransferListener listener, int maxPacketSize, int socketTimeoutMillis) {
     this.listener = listener;
+    this.socketTimeoutMillis = socketTimeoutMillis;
     packetBuffer = new byte[maxPacketSize];
     packet = new DatagramPacket(packetBuffer, 0, maxPacketSize);
   }
@@ -82,9 +100,8 @@ public UdpDataSource(TransferListener listener, int maxPacketSize) {
   @Override
   public long open(DataSpec dataSpec) throws UdpDataSourceException {
     this.dataSpec = dataSpec;
-    String uri = dataSpec.uri.toString();
-    String host = uri.substring(0, uri.indexOf(':'));
-    int port = Integer.parseInt(uri.substring(uri.indexOf(':') + 1));
+    String host = dataSpec.uri.getHost();
+    int port = dataSpec.uri.getPort();
 
     try {
       address = InetAddress.getByName(host);
@@ -100,6 +117,12 @@ public long open(DataSpec dataSpec) throws UdpDataSourceException {
       throw new UdpDataSourceException(e);
     }
 
+    try {
+      socket.setSoTimeout(socketTimeoutMillis);
+    } catch (SocketException e) {
+      throw new UdpDataSourceException(e);
+    }
+
     opened = true;
     if (listener != null) {
       listener.onTransferStart();
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheSpan.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheSpan.java
index ddde6b003c..37d620c38b 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheSpan.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheSpan.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer.upstream.cache;
 
+import com.google.android.exoplayer.util.Util;
 
 import java.io.File;
 import java.util.regex.Matcher;
@@ -25,10 +26,11 @@
  */
 public final class CacheSpan implements Comparable<CacheSpan> {
 
-  private static final String SUFFIX = ".v1.exo";
-  private static final String SUFFIX_ESCAPED = "\\.v1\\.exo";
-  private static final Pattern cacheFilePattern =
-      Pattern.compile("^(.+)\\.(\\d+)\\.(\\d+)(" + SUFFIX_ESCAPED + ")$");
+  private static final String SUFFIX = ".v2.exo";
+  private static final Pattern CACHE_FILE_PATTERN_V1 =
+      Pattern.compile("^(.+)\\.(\\d+)\\.(\\d+)\\.v1\\.exo$");
+  private static final Pattern CACHE_FILE_PATTERN_V2 =
+      Pattern.compile("^(.+)\\.(\\d+)\\.(\\d+)\\.v2\\.exo$");
 
   /**
    * The cache key that uniquely identifies the original stream.
@@ -57,7 +59,8 @@
 
   public static File getCacheFileName(File cacheDir, String key, long offset,
       long lastAccessTimestamp) {
-    return new File(cacheDir, key + "." + offset + "." + lastAccessTimestamp + SUFFIX);
+    return new File(cacheDir,
+        Util.escapeFileName(key) + "." + offset + "." + lastAccessTimestamp + SUFFIX);
   }
 
   public static CacheSpan createLookup(String key, long position) {
@@ -79,12 +82,25 @@ public static CacheSpan createClosedHole(String key, long position, long length)
    * @return The span, or null if the file name is not correctly formatted.
    */
   public static CacheSpan createCacheEntry(File file) {
-    Matcher matcher = cacheFilePattern.matcher(file.getName());
+    Matcher matcher = CACHE_FILE_PATTERN_V2.matcher(file.getName());
     if (!matcher.matches()) {
       return null;
     }
-    return CacheSpan.createCacheEntry(matcher.group(1), Long.parseLong(matcher.group(2)),
-        Long.parseLong(matcher.group(3)), file);
+    String key = Util.unescapeFileName(matcher.group(1));
+    return key == null ? null : createCacheEntry(
+        key, Long.parseLong(matcher.group(2)), Long.parseLong(matcher.group(3)), file);
+  }
+
+  static File upgradeIfNeeded(File file) {
+    Matcher matcher = CACHE_FILE_PATTERN_V1.matcher(file.getName());
+    if (!matcher.matches()) {
+      return file;
+    }
+    String key = matcher.group(1); // Keys were not escaped in version 1.
+    File newCacheFile = getCacheFileName(file.getParentFile(), key,
+        Long.parseLong(matcher.group(2)), Long.parseLong(matcher.group(3)));
+    file.renameTo(newCacheFile);
+    return newCacheFile;
   }
 
   private static CacheSpan createCacheEntry(String key, long position, long lastAccessTimestamp,
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCache.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCache.java
index 649e555dc3..86fc1b6129 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCache.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCache.java
@@ -245,6 +245,7 @@ private void initialize() {
       if (file.length() == 0) {
         file.delete();
       } else {
+        file = CacheSpan.upgradeIfNeeded(file);
         CacheSpan span = CacheSpan.createCacheEntry(file);
         if (span == null) {
           file.delete();
diff --git a/library/src/main/java/com/google/android/exoplayer/util/CodecSpecificDataUtil.java b/library/src/main/java/com/google/android/exoplayer/util/CodecSpecificDataUtil.java
index 70a80d7b11..6ba16f0ee1 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/CodecSpecificDataUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/CodecSpecificDataUtil.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer.util;
 
-import android.util.Log;
 import android.util.Pair;
 
 import java.util.ArrayList;
@@ -26,23 +25,6 @@
  */
 public final class CodecSpecificDataUtil {
 
-  /**
-   * Holds data parsed from a sequence parameter set NAL unit.
-   */
-  public static final class SpsData {
-
-    public final int width;
-    public final int height;
-    public final float pixelWidthAspectRatio;
-
-    public SpsData(int width, int height, float pixelWidthAspectRatio) {
-      this.width = width;
-      this.height = height;
-      this.pixelWidthAspectRatio = pixelWidthAspectRatio;
-    }
-
-  }
-
   private static final byte[] NAL_START_CODE = new byte[] {0, 0, 0, 1};
 
   private static final int AUDIO_SPECIFIC_CONFIG_FREQUENCY_INDEX_ARBITRARY = 0xF;
@@ -94,8 +76,6 @@ public SpsData(int width, int height, float pixelWidthAspectRatio) {
   // Parametric Stereo.
   private static final int AUDIO_OBJECT_TYPE_PS = 29;
 
-  private static final String TAG = "CodecSpecificDataUtil";
-
   private CodecSpecificDataUtil() {}
 
   /**
@@ -267,121 +247,4 @@ private static boolean isNalStartCode(byte[] data, int index) {
     return true;
   }
 
-  /**
-   * Parses an SPS NAL unit.
-   *
-   * @param bitArray A {@link ParsableBitArray} containing the SPS data. The position must to set
-   *     to the start of the data (i.e. the first bit of the profile_idc field).
-   * @return A parsed representation of the SPS data.
-   */
-  public static SpsData parseSpsNalUnit(ParsableBitArray bitArray) {
-    int profileIdc = bitArray.readBits(8);
-    bitArray.skipBits(16); // constraint bits (6), reserved (2) and level_idc (8)
-    bitArray.readUnsignedExpGolombCodedInt(); // seq_parameter_set_id
-
-    int chromaFormatIdc = 1; // Default is 4:2:0
-    if (profileIdc == 100 || profileIdc == 110 || profileIdc == 122 || profileIdc == 244
-        || profileIdc == 44 || profileIdc == 83 || profileIdc == 86 || profileIdc == 118
-        || profileIdc == 128 || profileIdc == 138) {
-      chromaFormatIdc = bitArray.readUnsignedExpGolombCodedInt();
-      if (chromaFormatIdc == 3) {
-        bitArray.skipBits(1); // separate_colour_plane_flag
-      }
-      bitArray.readUnsignedExpGolombCodedInt(); // bit_depth_luma_minus8
-      bitArray.readUnsignedExpGolombCodedInt(); // bit_depth_chroma_minus8
-      bitArray.skipBits(1); // qpprime_y_zero_transform_bypass_flag
-      boolean seqScalingMatrixPresentFlag = bitArray.readBit();
-      if (seqScalingMatrixPresentFlag) {
-        int limit = (chromaFormatIdc != 3) ? 8 : 12;
-        for (int i = 0; i < limit; i++) {
-          boolean seqScalingListPresentFlag = bitArray.readBit();
-          if (seqScalingListPresentFlag) {
-            skipScalingList(bitArray, i < 6 ? 16 : 64);
-          }
-        }
-      }
-    }
-
-    bitArray.readUnsignedExpGolombCodedInt(); // log2_max_frame_num_minus4
-    long picOrderCntType = bitArray.readUnsignedExpGolombCodedInt();
-    if (picOrderCntType == 0) {
-      bitArray.readUnsignedExpGolombCodedInt(); // log2_max_pic_order_cnt_lsb_minus4
-    } else if (picOrderCntType == 1) {
-      bitArray.skipBits(1); // delta_pic_order_always_zero_flag
-      bitArray.readSignedExpGolombCodedInt(); // offset_for_non_ref_pic
-      bitArray.readSignedExpGolombCodedInt(); // offset_for_top_to_bottom_field
-      long numRefFramesInPicOrderCntCycle = bitArray.readUnsignedExpGolombCodedInt();
-      for (int i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
-        bitArray.readUnsignedExpGolombCodedInt(); // offset_for_ref_frame[i]
-      }
-    }
-    bitArray.readUnsignedExpGolombCodedInt(); // max_num_ref_frames
-    bitArray.skipBits(1); // gaps_in_frame_num_value_allowed_flag
-
-    int picWidthInMbs = bitArray.readUnsignedExpGolombCodedInt() + 1;
-    int picHeightInMapUnits = bitArray.readUnsignedExpGolombCodedInt() + 1;
-    boolean frameMbsOnlyFlag = bitArray.readBit();
-    int frameHeightInMbs = (2 - (frameMbsOnlyFlag ? 1 : 0)) * picHeightInMapUnits;
-    if (!frameMbsOnlyFlag) {
-      bitArray.skipBits(1); // mb_adaptive_frame_field_flag
-    }
-
-    bitArray.skipBits(1); // direct_8x8_inference_flag
-    int frameWidth = picWidthInMbs * 16;
-    int frameHeight = frameHeightInMbs * 16;
-    boolean frameCroppingFlag = bitArray.readBit();
-    if (frameCroppingFlag) {
-      int frameCropLeftOffset = bitArray.readUnsignedExpGolombCodedInt();
-      int frameCropRightOffset = bitArray.readUnsignedExpGolombCodedInt();
-      int frameCropTopOffset = bitArray.readUnsignedExpGolombCodedInt();
-      int frameCropBottomOffset = bitArray.readUnsignedExpGolombCodedInt();
-      int cropUnitX, cropUnitY;
-      if (chromaFormatIdc == 0) {
-        cropUnitX = 1;
-        cropUnitY = 2 - (frameMbsOnlyFlag ? 1 : 0);
-      } else {
-        int subWidthC = (chromaFormatIdc == 3) ? 1 : 2;
-        int subHeightC = (chromaFormatIdc == 1) ? 2 : 1;
-        cropUnitX = subWidthC;
-        cropUnitY = subHeightC * (2 - (frameMbsOnlyFlag ? 1 : 0));
-      }
-      frameWidth -= (frameCropLeftOffset + frameCropRightOffset) * cropUnitX;
-      frameHeight -= (frameCropTopOffset + frameCropBottomOffset) * cropUnitY;
-    }
-
-    float pixelWidthHeightRatio = 1;
-    boolean vuiParametersPresentFlag = bitArray.readBit();
-    if (vuiParametersPresentFlag) {
-      boolean aspectRatioInfoPresentFlag = bitArray.readBit();
-      if (aspectRatioInfoPresentFlag) {
-        int aspectRatioIdc = bitArray.readBits(8);
-        if (aspectRatioIdc == NalUnitUtil.EXTENDED_SAR) {
-          int sarWidth = bitArray.readBits(16);
-          int sarHeight = bitArray.readBits(16);
-          if (sarWidth != 0 && sarHeight != 0) {
-            pixelWidthHeightRatio = (float) sarWidth / sarHeight;
-          }
-        } else if (aspectRatioIdc < NalUnitUtil.ASPECT_RATIO_IDC_VALUES.length) {
-          pixelWidthHeightRatio = NalUnitUtil.ASPECT_RATIO_IDC_VALUES[aspectRatioIdc];
-        } else {
-          Log.w(TAG, "Unexpected aspect_ratio_idc value: " + aspectRatioIdc);
-        }
-      }
-    }
-
-    return new SpsData(frameWidth, frameHeight, pixelWidthHeightRatio);
-  }
-
-  private static void skipScalingList(ParsableBitArray bitArray, int size) {
-    int lastScale = 8;
-    int nextScale = 8;
-    for (int i = 0; i < size; i++) {
-      if (nextScale != 0) {
-        int deltaScale = bitArray.readSignedExpGolombCodedInt();
-        nextScale = (lastScale + deltaScale + 256) % 256;
-      }
-      lastScale = (nextScale == 0) ? lastScale : nextScale;
-    }
-  }
-
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java b/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
index 02d5685e98..8fe7a87bdb 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
@@ -35,6 +35,7 @@
   public static final String VIDEO_VP9 = BASE_TYPE_VIDEO + "/x-vnd.on2.vp9";
   public static final String VIDEO_MP4V = BASE_TYPE_VIDEO + "/mp4v-es";
   public static final String VIDEO_MPEG2 = BASE_TYPE_VIDEO + "/mpeg2";
+  public static final String VIDEO_VC1 = BASE_TYPE_VIDEO + "/wvc1";
 
   public static final String AUDIO_UNKNOWN = BASE_TYPE_AUDIO + "/x-unknown";
   public static final String AUDIO_MP4 = BASE_TYPE_AUDIO + "/mp4";
@@ -54,6 +55,7 @@
   public static final String AUDIO_OPUS = BASE_TYPE_AUDIO + "/opus";
   public static final String AUDIO_AMR_NB = BASE_TYPE_AUDIO + "/3gpp";
   public static final String AUDIO_AMR_WB = BASE_TYPE_AUDIO + "/amr-wb";
+  public static final String AUDIO_FLAC = BASE_TYPE_AUDIO + "/x-flac";
 
   public static final String TEXT_UNKNOWN = BASE_TYPE_TEXT + "/x-unknown";
   public static final String TEXT_VTT = BASE_TYPE_TEXT + "/vtt";
@@ -67,6 +69,8 @@
   public static final String APPLICATION_M3U8 = BASE_TYPE_APPLICATION + "/x-mpegURL";
   public static final String APPLICATION_TX3G = BASE_TYPE_APPLICATION + "/x-quicktime-tx3g";
   public static final String APPLICATION_MP4VTT = BASE_TYPE_APPLICATION + "/x-mp4vtt";
+  public static final String APPLICATION_VOBSUB = BASE_TYPE_APPLICATION + "/vobsub";
+  public static final String APPLICATION_PGS = BASE_TYPE_APPLICATION + "/pgs";
 
   private MimeTypes() {}
 
diff --git a/library/src/main/java/com/google/android/exoplayer/util/NalUnitUtil.java b/library/src/main/java/com/google/android/exoplayer/util/NalUnitUtil.java
index 7b4caae880..00a9f27ade 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/NalUnitUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/NalUnitUtil.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer.util;
 
+import android.util.Log;
+
 import java.nio.ByteBuffer;
 import java.util.Arrays;
 
@@ -23,6 +25,59 @@
  */
 public final class NalUnitUtil {
 
+  private static final String TAG = "NalUnitUtil";
+
+  /**
+   * Holds data parsed from a sequence parameter set NAL unit.
+   */
+  public static final class SpsData {
+
+    public final int seqParameterSetId;
+    public final int width;
+    public final int height;
+    public final float pixelWidthAspectRatio;
+    public final boolean separateColorPlaneFlag;
+    public final boolean frameMbsOnlyFlag;
+    public final int frameNumLength;
+    public final int picOrderCountType;
+    public final int picOrderCntLsbLength;
+    public final boolean deltaPicOrderAlwaysZeroFlag;
+
+    public SpsData(int seqParameterSetId, int width, int height, float pixelWidthAspectRatio,
+        boolean separateColorPlaneFlag, boolean frameMbsOnlyFlag, int frameNumLength,
+        int picOrderCountType, int picOrderCntLsbLength, boolean deltaPicOrderAlwaysZeroFlag) {
+      this.seqParameterSetId = seqParameterSetId;
+      this.width = width;
+      this.height = height;
+      this.pixelWidthAspectRatio = pixelWidthAspectRatio;
+      this.separateColorPlaneFlag = separateColorPlaneFlag;
+      this.frameMbsOnlyFlag = frameMbsOnlyFlag;
+      this.frameNumLength = frameNumLength;
+      this.picOrderCountType = picOrderCountType;
+      this.picOrderCntLsbLength = picOrderCntLsbLength;
+      this.deltaPicOrderAlwaysZeroFlag = deltaPicOrderAlwaysZeroFlag;
+    }
+
+  }
+
+  /**
+   * Holds data parsed from a picture parameter set NAL unit.
+   */
+  public static final class PpsData {
+
+    public final int picParameterSetId;
+    public final int seqParameterSetId;
+    public final boolean bottomFieldPicOrderInFramePresentFlag;
+
+    public PpsData(int picParameterSetId, int seqParameterSetId,
+        boolean bottomFieldPicOrderInFramePresentFlag) {
+      this.picParameterSetId = picParameterSetId;
+      this.seqParameterSetId = seqParameterSetId;
+      this.bottomFieldPicOrderInFramePresentFlag = bottomFieldPicOrderInFramePresentFlag;
+    }
+
+  }
+
   /** Four initial bytes that must prefix NAL units for decoding. */
   public static final byte[] NAL_START_CODE = new byte[] {0, 0, 0, 1};
 
@@ -177,6 +232,134 @@ public static int getH265NalUnitType(byte[] data, int offset) {
     return (data[offset + 3] & 0x7E) >> 1;
   }
 
+  /**
+   * Parses an SPS NAL unit using the syntax defined in ITU-T Recommendation H.264 (2013) subsection
+   * 7.3.2.1.1.
+   *
+   * @param data A {@link ParsableBitArray} containing the SPS data. The position must to set to the
+   *     start of the data (i.e. the first bit of the profile_idc field).
+   * @return A parsed representation of the SPS data.
+   */
+  public static SpsData parseSpsNalUnit(ParsableBitArray data) {
+    int profileIdc = data.readBits(8);
+    data.skipBits(16); // constraint bits (6), reserved (2) and level_idc (8)
+    int seqParameterSetId = data.readUnsignedExpGolombCodedInt();
+
+    int chromaFormatIdc = 1; // Default is 4:2:0
+    boolean separateColorPlaneFlag = false;
+    if (profileIdc == 100 || profileIdc == 110 || profileIdc == 122 || profileIdc == 244
+        || profileIdc == 44 || profileIdc == 83 || profileIdc == 86 || profileIdc == 118
+        || profileIdc == 128 || profileIdc == 138) {
+      chromaFormatIdc = data.readUnsignedExpGolombCodedInt();
+      if (chromaFormatIdc == 3) {
+        separateColorPlaneFlag = data.readBit();
+      }
+      data.readUnsignedExpGolombCodedInt(); // bit_depth_luma_minus8
+      data.readUnsignedExpGolombCodedInt(); // bit_depth_chroma_minus8
+      data.skipBits(1); // qpprime_y_zero_transform_bypass_flag
+      boolean seqScalingMatrixPresentFlag = data.readBit();
+      if (seqScalingMatrixPresentFlag) {
+        int limit = (chromaFormatIdc != 3) ? 8 : 12;
+        for (int i = 0; i < limit; i++) {
+          boolean seqScalingListPresentFlag = data.readBit();
+          if (seqScalingListPresentFlag) {
+            skipScalingList(data, i < 6 ? 16 : 64);
+          }
+        }
+      }
+    }
+
+    int frameNumLength = data.readUnsignedExpGolombCodedInt() + 4; // log2_max_frame_num_minus4 + 4
+    int picOrderCntType = data.readUnsignedExpGolombCodedInt();
+    int picOrderCntLsbLength = 0;
+    boolean deltaPicOrderAlwaysZeroFlag = false;
+    if (picOrderCntType == 0) {
+      // log2_max_pic_order_cnt_lsb_minus4 + 4
+      picOrderCntLsbLength = data.readUnsignedExpGolombCodedInt() + 4;
+    } else if (picOrderCntType == 1) {
+      deltaPicOrderAlwaysZeroFlag = data.readBit(); // delta_pic_order_always_zero_flag
+      data.readSignedExpGolombCodedInt(); // offset_for_non_ref_pic
+      data.readSignedExpGolombCodedInt(); // offset_for_top_to_bottom_field
+      long numRefFramesInPicOrderCntCycle = data.readUnsignedExpGolombCodedInt();
+      for (int i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
+        data.readUnsignedExpGolombCodedInt(); // offset_for_ref_frame[i]
+      }
+    }
+    data.readUnsignedExpGolombCodedInt(); // max_num_ref_frames
+    data.skipBits(1); // gaps_in_frame_num_value_allowed_flag
+
+    int picWidthInMbs = data.readUnsignedExpGolombCodedInt() + 1;
+    int picHeightInMapUnits = data.readUnsignedExpGolombCodedInt() + 1;
+    boolean frameMbsOnlyFlag = data.readBit();
+    int frameHeightInMbs = (2 - (frameMbsOnlyFlag ? 1 : 0)) * picHeightInMapUnits;
+    if (!frameMbsOnlyFlag) {
+      data.skipBits(1); // mb_adaptive_frame_field_flag
+    }
+
+    data.skipBits(1); // direct_8x8_inference_flag
+    int frameWidth = picWidthInMbs * 16;
+    int frameHeight = frameHeightInMbs * 16;
+    boolean frameCroppingFlag = data.readBit();
+    if (frameCroppingFlag) {
+      int frameCropLeftOffset = data.readUnsignedExpGolombCodedInt();
+      int frameCropRightOffset = data.readUnsignedExpGolombCodedInt();
+      int frameCropTopOffset = data.readUnsignedExpGolombCodedInt();
+      int frameCropBottomOffset = data.readUnsignedExpGolombCodedInt();
+      int cropUnitX, cropUnitY;
+      if (chromaFormatIdc == 0) {
+        cropUnitX = 1;
+        cropUnitY = 2 - (frameMbsOnlyFlag ? 1 : 0);
+      } else {
+        int subWidthC = (chromaFormatIdc == 3) ? 1 : 2;
+        int subHeightC = (chromaFormatIdc == 1) ? 2 : 1;
+        cropUnitX = subWidthC;
+        cropUnitY = subHeightC * (2 - (frameMbsOnlyFlag ? 1 : 0));
+      }
+      frameWidth -= (frameCropLeftOffset + frameCropRightOffset) * cropUnitX;
+      frameHeight -= (frameCropTopOffset + frameCropBottomOffset) * cropUnitY;
+    }
+
+    float pixelWidthHeightRatio = 1;
+    boolean vuiParametersPresentFlag = data.readBit();
+    if (vuiParametersPresentFlag) {
+      boolean aspectRatioInfoPresentFlag = data.readBit();
+      if (aspectRatioInfoPresentFlag) {
+        int aspectRatioIdc = data.readBits(8);
+        if (aspectRatioIdc == NalUnitUtil.EXTENDED_SAR) {
+          int sarWidth = data.readBits(16);
+          int sarHeight = data.readBits(16);
+          if (sarWidth != 0 && sarHeight != 0) {
+            pixelWidthHeightRatio = (float) sarWidth / sarHeight;
+          }
+        } else if (aspectRatioIdc < NalUnitUtil.ASPECT_RATIO_IDC_VALUES.length) {
+          pixelWidthHeightRatio = NalUnitUtil.ASPECT_RATIO_IDC_VALUES[aspectRatioIdc];
+        } else {
+          Log.w(TAG, "Unexpected aspect_ratio_idc value: " + aspectRatioIdc);
+        }
+      }
+    }
+
+    return new SpsData(seqParameterSetId, frameWidth, frameHeight, pixelWidthHeightRatio,
+        separateColorPlaneFlag, frameMbsOnlyFlag, frameNumLength, picOrderCntType,
+        picOrderCntLsbLength, deltaPicOrderAlwaysZeroFlag);
+  }
+
+  /**
+   * Parses a PPS NAL unit using the syntax defined in ITU-T Recommendation H.264 (2013) subsection
+   * 7.3.2.2.
+   *
+   * @param data A {@link ParsableBitArray} containing the PPS data. The position must to set to the
+   *     start of the data (i.e. the first bit of the pic_parameter_set_id field).
+   * @return A parsed representation of the PPS data.
+   */
+  public static PpsData parsePpsNalUnit(ParsableBitArray data) {
+    int picParameterSetId = data.readUnsignedExpGolombCodedInt();
+    int seqParameterSetId = data.readUnsignedExpGolombCodedInt();
+    data.skipBits(1); // entropy_coding_mode_flag
+    boolean bottomFieldPicOrderInFramePresentFlag = data.readBit();
+    return new PpsData(picParameterSetId, seqParameterSetId, bottomFieldPicOrderInFramePresentFlag);
+  }
+
   /**
    * Finds the first NAL unit in {@code data}.
    * <p>
@@ -276,6 +459,18 @@ private static int findNextUnescapeIndex(byte[] bytes, int offset, int limit) {
     return limit;
   }
 
+  private static void skipScalingList(ParsableBitArray bitArray, int size) {
+    int lastScale = 8;
+    int nextScale = 8;
+    for (int i = 0; i < size; i++) {
+      if (nextScale != 0) {
+        int deltaScale = bitArray.readSignedExpGolombCodedInt();
+        nextScale = (lastScale + deltaScale + 256) % 256;
+      }
+      lastScale = (nextScale == 0) ? lastScale : nextScale;
+    }
+  }
+
   private NalUnitUtil() {
     // Prevent instantiation.
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ParsableBitArray.java b/library/src/main/java/com/google/android/exoplayer/util/ParsableBitArray.java
index ff47655598..443bfee406 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/ParsableBitArray.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/ParsableBitArray.java
@@ -178,12 +178,12 @@ public int readBits(int numBits) {
   }
 
   /**
-   * Peeks the length of an Exp-Golomb-coded integer (signed or unsigned) starting from the current
-   * offset, returning the length or -1 if the limit is reached.
+   * Returns whether it is possible to read an Exp-Golomb-coded integer starting from the current
+   * offset. The offset is not modified.
    *
-   * @return The length of the Exp-Golob-coded integer, or -1.
+   * @return Whether it is possible to read an Exp-Golomb-coded integer.
    */
-  public int peekExpGolombCodedNumLength() {
+  public boolean canReadExpGolombCodedNum() {
     int initialByteOffset = byteOffset;
     int initialBitOffset = bitOffset;
     int leadingZeros = 0;
@@ -193,7 +193,7 @@ public int peekExpGolombCodedNumLength() {
     boolean hitLimit = byteOffset == byteLimit;
     byteOffset = initialByteOffset;
     bitOffset = initialBitOffset;
-    return hitLimit ? -1 : leadingZeros * 2 + 1;
+    return !hitLimit && bitsLeft() >= leadingZeros * 2 + 1;
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java b/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
index 8beff5f9cb..f54de76066 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
@@ -194,6 +194,13 @@ public int readUnsignedInt24() {
         | (data[position++] & 0xFF);
   }
 
+  /** Reads the next three bytes as a signed value in little endian order. */
+  public int readLittleEndianInt24() {
+    return (data[position++] & 0xFF)
+        | (data[position++] & 0xFF) << 8
+        | (data[position++] & 0xFF) << 16;
+  }
+
   /**  Reads the next three bytes as an unsigned value in little endian order. */
   public int readLittleEndianUnsignedInt24() {
     return (data[position++] & 0xFF)
@@ -294,6 +301,20 @@ public int readUnsignedIntToInt() {
     return result;
   }
 
+  /**
+   * Reads the next four bytes as a little endian unsigned integer into an integer, if the top bit
+   * is a zero.
+   *
+   * @throws IllegalStateException Thrown if the top bit of the input data is set.
+   */
+  public int readLittleEndianUnsignedIntToInt() {
+    int result = readLittleEndianInt();
+    if (result < 0) {
+      throw new IllegalStateException("Top bit not zero: " + result);
+    }
+    return result;
+  }
+
   /**
    * Reads the next eight bytes as an unsigned long into a long, if the top bit is a zero.
    *
diff --git a/library/src/main/java/com/google/android/exoplayer/util/Util.java b/library/src/main/java/com/google/android/exoplayer/util/Util.java
index bd057cfbf8..73accd5ad8 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/Util.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/Util.java
@@ -114,6 +114,8 @@
       Pattern.compile("^(-)?P(([0-9]*)Y)?(([0-9]*)M)?(([0-9]*)D)?"
           + "(T(([0-9]*)H)?(([0-9]*)M)?(([0-9.]*)S)?)?$");
 
+  private static final Pattern ESCAPED_CHARACTER_PATTERN = Pattern.compile("%([A-Fa-f0-9]{2})");
+
   private static final long MAX_BYTES_TO_DRAIN = 2048;
 
   private Util() {}
@@ -786,4 +788,103 @@ public static int inferContentType(String fileName) {
       return TYPE_OTHER;
     }
   }
+
+  /**
+   * Escapes a string so that it's safe for use as a file or directory name on at least FAT32
+   * filesystems. FAT32 is the most restrictive of all filesystems still commonly used today.
+   *
+   * <p>For simplicity, this only handles common characters known to be illegal on FAT32:
+   * <, >, :, ", /, \, |, ?, and *. % is also escaped since it is used as the escape character.
+   * Escaping is performed in a consistent way so that no collisions occur and
+   * {@link #unescapeFileName(String)} can be used to retrieve the original file name.
+   *
+   * @param fileName File name to be escaped.
+   * @return An escaped file name which will be safe for use on at least FAT32 filesystems.
+   */
+  public static String escapeFileName(String fileName) {
+    int length = fileName.length();
+    int charactersToEscapeCount = 0;
+    for (int i = 0; i < length; i++) {
+      if (shouldEscapeCharacter(fileName.charAt(i))) {
+        charactersToEscapeCount++;
+      }
+    }
+    if (charactersToEscapeCount == 0) {
+      return fileName;
+    }
+
+    int i = 0;
+    StringBuilder builder = new StringBuilder(length + charactersToEscapeCount * 2);
+    while (charactersToEscapeCount > 0) {
+      char c = fileName.charAt(i++);
+      if (shouldEscapeCharacter(c)) {
+        builder.append('%').append(Integer.toHexString(c));
+        charactersToEscapeCount--;
+      } else {
+        builder.append(c);
+      }
+    }
+    if (i < length) {
+      builder.append(fileName, i, length);
+    }
+    return builder.toString();
+  }
+
+  private static boolean shouldEscapeCharacter(char c) {
+    switch (c) {
+      case '<':
+      case '>':
+      case ':':
+      case '"':
+      case '/':
+      case '\\':
+      case '|':
+      case '?':
+      case '*':
+      case '%':
+        return true;
+      default:
+        return false;
+    }
+  }
+
+  /**
+   * Unescapes an escaped file or directory name back to its original value.
+   *
+   * <p>See {@link #escapeFileName(String)} for more information.
+   *
+   * @param fileName File name to be unescaped.
+   * @return The original value of the file name before it was escaped,
+   *    or null if the escaped fileName seems invalid.
+   */
+  public static String unescapeFileName(String fileName) {
+    int length = fileName.length();
+    int percentCharacterCount = 0;
+    for (int i = 0; i < length; i++) {
+      if (fileName.charAt(i) == '%') {
+        percentCharacterCount++;
+      }
+    }
+    if (percentCharacterCount == 0) {
+      return fileName;
+    }
+
+    int expectedLength = length - percentCharacterCount * 2;
+    StringBuilder builder = new StringBuilder(expectedLength);
+    Matcher matcher = ESCAPED_CHARACTER_PATTERN.matcher(fileName);
+    int endOfLastMatch = 0;
+    while (percentCharacterCount > 0 && matcher.find()) {
+      char unescapedCharacter = (char) Integer.parseInt(matcher.group(1), 16);
+      builder.append(fileName, endOfLastMatch, matcher.start()).append(unescapedCharacter);
+      endOfLastMatch = matcher.end();
+      percentCharacterCount--;
+    }
+    if (endOfLastMatch < length) {
+      builder.append(fileName, endOfLastMatch, length);
+    }
+    if (builder.length() != expectedLength) {
+      return null;
+    }
+    return builder.toString();
+  }
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/util/extensions/Buffer.java b/library/src/main/java/com/google/android/exoplayer/util/extensions/Buffer.java
new file mode 100644
index 0000000000..241a02327b
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/util/extensions/Buffer.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util.extensions;
+
+/**
+ * Base class for {@link Decoder} buffers with flags.
+ */
+public abstract class Buffer {
+
+  /**
+   * Flag for empty input/output buffers that signal that the end of the stream was reached.
+   */
+  public static final int FLAG_END_OF_STREAM = 1;
+  /**
+   * Flag for non-empty input buffers which signals that the decoder must be reset before decoding.
+   */
+  public static final int FLAG_RESET = 2;
+  /**
+   * Flag for non-empty input/output buffers that should only be decoded (not rendered).
+   */
+  public static final int FLAG_DECODE_ONLY = 4;
+
+  private int flags;
+
+  public void reset() {
+    flags = 0;
+  }
+
+  public final void setFlag(int flag) {
+    flags |= flag;
+  }
+
+  public final boolean getFlag(int flag) {
+    return (flags & flag) == flag;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/util/extensions/Decoder.java b/library/src/main/java/com/google/android/exoplayer/util/extensions/Decoder.java
new file mode 100644
index 0000000000..55f7727ab3
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/util/extensions/Decoder.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util.extensions;
+
+/**
+ * A media decoder.
+ *
+ * @param <I> The type of buffer input to the decoder.
+ * @param <O> The type of buffer output from the decoder.
+ * @param <E> The type of exception thrown from the decoder.
+ */
+public interface Decoder<I, O, E extends Exception> {
+
+  /**
+   * Dequeues the next input buffer to be filled and queued to the decoder.
+   *
+   * @return The input buffer, or null if an input buffer isn't available.
+   * @throws E If a decoder error has occurred.
+   */
+  I dequeueInputBuffer() throws E;
+
+  /**
+   * Queues an input buffer to the decoder.
+   *
+   * @param inputBuffer The input buffer.
+   * @throws E If a decoder error has occurred.
+   */
+  void queueInputBuffer(I inputBuffer) throws E;
+
+  /**
+   * Dequeues the next output buffer from the decoder.
+   *
+   * @return The output buffer, or null if an output buffer isn't available.
+   * @throws E If a decoder error has occurred.
+   */
+  O dequeueOutputBuffer() throws E;
+
+  /**
+   * Flushes input/output buffers that have not been dequeued yet and returns ownership of any
+   * dequeued input buffer to the decoder. Flushes any pending output currently in the decoder. The
+   * caller is still responsible for releasing any dequeued output buffers.
+   */
+  void flush();
+
+  /**
+   * Releases the decoder. Must be called when the decoder is no longer needed.
+   */
+  void release();
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/util/extensions/InputBuffer.java b/library/src/main/java/com/google/android/exoplayer/util/extensions/InputBuffer.java
new file mode 100644
index 0000000000..917e90bad7
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/util/extensions/InputBuffer.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util.extensions;
+
+import com.google.android.exoplayer.SampleHolder;
+
+/**
+ * Input buffer to be decoded by a {@link Decoder}.
+ */
+public class InputBuffer extends Buffer {
+
+  public final SampleHolder sampleHolder;
+
+  public InputBuffer() {
+    sampleHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_DIRECT);
+  }
+
+  @Override
+  public void reset() {
+    super.reset();
+    sampleHolder.clearData();
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/util/extensions/OutputBuffer.java b/library/src/main/java/com/google/android/exoplayer/util/extensions/OutputBuffer.java
new file mode 100644
index 0000000000..c5ec800003
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/util/extensions/OutputBuffer.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util.extensions;
+
+/**
+ * Output buffer decoded by a {@link Decoder}.
+ */
+public abstract class OutputBuffer extends Buffer {
+
+  /**
+   * The presentation timestamp for the buffer, in microseconds.
+   */
+  public long timestampUs;
+
+  /**
+   * Releases the output buffer for reuse. Must be called when the buffer is no longer needed.
+   */
+  public abstract void release();
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/util/extensions/SimpleDecoder.java b/library/src/main/java/com/google/android/exoplayer/util/extensions/SimpleDecoder.java
new file mode 100644
index 0000000000..b8455611aa
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/util/extensions/SimpleDecoder.java
@@ -0,0 +1,280 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util.extensions;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.util.Assertions;
+
+import java.util.LinkedList;
+
+/**
+ * Base class for {@link Decoder}s that use their own decode thread.
+ */
+public abstract class SimpleDecoder<I extends InputBuffer, O extends OutputBuffer,
+    E extends Exception> extends Thread implements Decoder<I, O, E> {
+
+  /**
+   * Listener for {@link SimpleDecoder} events.
+   */
+  public interface EventListener<E> {
+
+    /**
+     * Invoked when the decoder encounters an error.
+     *
+     * @param e The corresponding exception.
+     */
+    void onDecoderError(E e);
+
+  }
+
+  private final Object lock;
+  private final LinkedList<I> queuedInputBuffers;
+  private final LinkedList<O> queuedOutputBuffers;
+  private final I[] availableInputBuffers;
+  private final O[] availableOutputBuffers;
+
+  private int availableInputBufferCount;
+  private int availableOutputBufferCount;
+  private I dequeuedInputBuffer;
+
+  private E exception;
+  private boolean flushDecodedOutputBuffer;
+  private boolean released;
+
+  /**
+   * @param inputBuffers An array of nulls that will be used to store references to input buffers.
+   * @param outputBuffers An array of nulls that will be used to store references to output buffers.
+   */
+  protected SimpleDecoder(I[] inputBuffers, O[] outputBuffers) {
+    lock = new Object();
+    queuedInputBuffers = new LinkedList<>();
+    queuedOutputBuffers = new LinkedList<>();
+    availableInputBuffers = inputBuffers;
+    availableInputBufferCount = inputBuffers.length;
+    for (int i = 0; i < availableInputBufferCount; i++) {
+      availableInputBuffers[i] = createInputBuffer();
+    }
+    availableOutputBuffers = outputBuffers;
+    availableOutputBufferCount = outputBuffers.length;
+    for (int i = 0; i < availableOutputBufferCount; i++) {
+      availableOutputBuffers[i] = createOutputBuffer();
+    }
+  }
+
+  /**
+   * Sets the initial size of each input buffer.
+   * <p>
+   * This method should only be called before the decoder is used (i.e. before the first call to
+   * {@link #dequeueInputBuffer()}.
+   *
+   * @param size The required input buffer size.
+   */
+  protected final void setInitialInputBufferSize(int size) {
+    Assertions.checkState(availableInputBufferCount == availableInputBuffers.length);
+    for (int i = 0; i < availableInputBuffers.length; i++) {
+      availableInputBuffers[i].sampleHolder.ensureSpaceForWrite(size);
+    }
+  }
+
+  @Override
+  public final I dequeueInputBuffer() throws E {
+    synchronized (lock) {
+      maybeThrowException();
+      Assertions.checkState(dequeuedInputBuffer == null);
+      if (availableInputBufferCount == 0) {
+        return null;
+      }
+      I inputBuffer = availableInputBuffers[--availableInputBufferCount];
+      inputBuffer.reset();
+      dequeuedInputBuffer = inputBuffer;
+      return inputBuffer;
+    }
+  }
+
+  @Override
+  public final void queueInputBuffer(I inputBuffer) throws E {
+    synchronized (lock) {
+      maybeThrowException();
+      Assertions.checkArgument(inputBuffer == dequeuedInputBuffer);
+      queuedInputBuffers.addLast(inputBuffer);
+      maybeNotifyDecodeLoop();
+      dequeuedInputBuffer = null;
+    }
+  }
+
+  @Override
+  public final O dequeueOutputBuffer() throws E {
+    synchronized (lock) {
+      maybeThrowException();
+      if (queuedOutputBuffers.isEmpty()) {
+        return null;
+      }
+      return queuedOutputBuffers.removeFirst();
+    }
+  }
+
+  /**
+   * Releases an output buffer back to the decoder.
+   *
+   * @param outputBuffer The output buffer being released.
+   */
+  protected void releaseOutputBuffer(O outputBuffer) {
+    synchronized (lock) {
+      availableOutputBuffers[availableOutputBufferCount++] = outputBuffer;
+      maybeNotifyDecodeLoop();
+    }
+  }
+
+  @Override
+  public final void flush() {
+    synchronized (lock) {
+      flushDecodedOutputBuffer = true;
+      if (dequeuedInputBuffer != null) {
+        availableInputBuffers[availableInputBufferCount++] = dequeuedInputBuffer;
+        dequeuedInputBuffer = null;
+      }
+      while (!queuedInputBuffers.isEmpty()) {
+        availableInputBuffers[availableInputBufferCount++] = queuedInputBuffers.removeFirst();
+      }
+      while (!queuedOutputBuffers.isEmpty()) {
+        availableOutputBuffers[availableOutputBufferCount++] = queuedOutputBuffers.removeFirst();
+      }
+    }
+  }
+
+  @Override
+  public void release() {
+    synchronized (lock) {
+      released = true;
+      lock.notify();
+    }
+    try {
+      join();
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+    }
+  }
+
+  /**
+   * Throws a decode exception, if there is one.
+   *
+   * @throws E The decode exception.
+   */
+  private void maybeThrowException() throws E {
+    if (exception != null) {
+      throw exception;
+    }
+  }
+
+  /**
+   * Notifies the decode loop if there exists a queued input buffer and an available output buffer
+   * to decode into.
+   * <p>
+   * Should only be called whilst synchronized on the lock object.
+   */
+  private void maybeNotifyDecodeLoop() {
+    if (canDecodeBuffer()) {
+      lock.notify();
+    }
+  }
+
+  @Override
+  public final void run() {
+    try {
+      while (decode()) {
+        // Do nothing.
+      }
+    } catch (InterruptedException e) {
+      // Not expected.
+      throw new IllegalStateException(e);
+    }
+  }
+
+  private boolean decode() throws InterruptedException {
+    I inputBuffer;
+    O outputBuffer;
+
+    // Wait until we have an input buffer to decode, and an output buffer to decode into.
+    synchronized (lock) {
+      while (!released && !canDecodeBuffer()) {
+        lock.wait();
+      }
+      if (released) {
+        return false;
+      }
+      inputBuffer = queuedInputBuffers.removeFirst();
+      outputBuffer = availableOutputBuffers[--availableOutputBufferCount];
+      flushDecodedOutputBuffer = false;
+    }
+
+    outputBuffer.reset();
+    if (inputBuffer.getFlag(Buffer.FLAG_END_OF_STREAM)) {
+      outputBuffer.setFlag(Buffer.FLAG_END_OF_STREAM);
+    } else {
+      if (inputBuffer.getFlag(C.SAMPLE_FLAG_DECODE_ONLY)) {
+        outputBuffer.setFlag(C.SAMPLE_FLAG_DECODE_ONLY);
+      }
+      exception = decode(inputBuffer, outputBuffer);
+      if (exception != null) {
+        // Memory barrier to ensure that the decoder exception is visible from the playback thread.
+        synchronized (lock) {}
+        return false;
+      }
+    }
+
+    synchronized (lock) {
+      if (flushDecodedOutputBuffer || outputBuffer.getFlag(Buffer.FLAG_DECODE_ONLY)) {
+        // If a flush occurred while decoding or the buffer was only for decoding (not presentation)
+        // then make the output buffer available again rather than queueing it to be consumed.
+        availableOutputBuffers[availableOutputBufferCount++] = outputBuffer;
+      } else {
+        // Queue the decoded output buffer to be consumed.
+        queuedOutputBuffers.addLast(outputBuffer);
+      }
+      // Make the input buffer available again.
+      availableInputBuffers[availableInputBufferCount++] = inputBuffer;
+    }
+
+    return true;
+  }
+
+  private boolean canDecodeBuffer() {
+    return !queuedInputBuffers.isEmpty() && availableOutputBufferCount > 0;
+  }
+
+  /**
+   * Creates a new input buffer.
+   */
+  protected abstract I createInputBuffer();
+
+  /**
+   * Creates a new output buffer.
+   */
+  protected abstract O createOutputBuffer();
+
+  /**
+   * Decodes the {@code inputBuffer} and stores any decoded output in {@code outputBuffer}.
+   *
+   * @param inputBuffer The buffer to decode.
+   * @param outputBuffer The output buffer to store decoded data. The flag
+   *     {@link Buffer#FLAG_DECODE_ONLY} will be set if the same flag is set on {@code inputBuffer},
+   *     but the decoder may set/unset the flag if required. If the flag is set after this method
+   *     returns, any output should not be presented.
+   * @return A decoder exception if an error occurred, or null if decoding was successful.
+   */
+  protected abstract E decode(I inputBuffer, O outputBuffer);
+
+}
diff --git a/playbacktests/src/main/AndroidManifest.xml b/playbacktests/src/main/AndroidManifest.xml
index d272843d37..2963ca5be6 100644
--- a/playbacktests/src/main/AndroidManifest.xml
+++ b/playbacktests/src/main/AndroidManifest.xml
@@ -17,8 +17,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer.playbacktests"
-    android:versionCode="1506"
-    android:versionName="1.5.6">
+    android:versionCode="1507"
+    android:versionName="1.5.7">
 
   <uses-permission android:name="android.permission.INTERNET"/>
   <uses-permission android:name="android.permission.WAKE_LOCK"/>
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java
index eaaef4aaa2..8f9ce937ec 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java
@@ -76,13 +76,13 @@
   private static final int MIN_LOADABLE_RETRY_COUNT = 10;
 
   private static final String MANIFEST_URL_PREFIX = "https://storage.googleapis.com/exoplayer-test-"
-      + "media-1/gen-2/screens/dash-vod-single-segment/";
+      + "media-1/gen-3/screens/dash-vod-single-segment/";
   private static final String H264_MANIFEST = "manifest-h264.mpd";
   private static final String H265_MANIFEST = "manifest-h265.mpd";
   private static final String VP9_MANIFEST = "manifest-vp9.mpd";
-  private static final int AAC_AUDIO_FRAME_COUNT = 5524;
-  private static final int VIDEO_FRAME_COUNT = 3841;
-  private static final int VORBIS_AUDIO_FRAME_COUNT = 7773;
+  private static final String H264_23_MANIFEST = "manifest-h264-23.mpd";
+  private static final String H264_24_MANIFEST = "manifest-h264-24.mpd";
+  private static final String H264_29_MANIFEST = "manifest-h264-29.mpd";
 
   private static final String AAC_AUDIO_REPRESENTATION_ID = "141";
   private static final String H264_BASELINE_240P_VIDEO_REPRESENTATION_ID = "avc-baseline-240";
@@ -103,6 +103,13 @@
           H264_MAIN_240P_VIDEO_REPRESENTATION_ID,
           H264_MAIN_480P_VIDEO_REPRESENTATION_ID};
 
+  private static final String H264_BASELINE_480P_23FPS_VIDEO_REPRESENTATION_ID =
+      "avc-baseline-480-23";
+  private static final String H264_BASELINE_480P_24FPS_VIDEO_REPRESENTATION_ID =
+      "avc-baseline-480-24";
+  private static final String H264_BASELINE_480P_29FPS_VIDEO_REPRESENTATION_ID =
+      "avc-baseline-480-29";
+
   private static final String H265_BASELINE_288P_VIDEO_REPRESENTATION_ID = "hevc-main-288";
   private static final String H265_BASELINE_360P_VIDEO_REPRESENTATION_ID = "hevc-main-360";
   // The highest quality H265 format mandated by the Android CDD.
@@ -113,7 +120,7 @@
           H265_BASELINE_288P_VIDEO_REPRESENTATION_ID,
           H265_BASELINE_360P_VIDEO_REPRESENTATION_ID};
 
-  private static final String VORBIS_AUDIO_REPRESENTATION_ID = "2";
+  private static final String VORBIS_AUDIO_REPRESENTATION_ID = "4";
   private static final String VP9_180P_VIDEO_REPRESENTATION_ID = "0";
   private static final String VP9_360P_VIDEO_REPRESENTATION_ID = "1";
   // The highest quality VP9 format mandated by the Android CDD.
@@ -126,16 +133,16 @@
 
   // Whether adaptive tests should enable video formats beyond those mandated by the Android CDD
   // if the device advertises support for them.
-  private static final boolean ALLOW_ADDITIONAL_VIDEO_FORMATS = Util.SDK_INT >= 21;
+  private static final boolean ALLOW_ADDITIONAL_VIDEO_FORMATS = Util.SDK_INT >= 23;
 
   private static final ActionSchedule SEEKING_SCHEDULE = new ActionSchedule.Builder(TAG)
       .delay(10000).seek(15000)
       .delay(10000).seek(30000).seek(31000).seek(32000).seek(33000).seek(34000)
       .delay(1000).pause().delay(1000).play()
-      .delay(1000).pause().seek(100000).delay(1000).play()
+      .delay(1000).pause().seek(120000).delay(1000).play()
       .build();
   private static final ActionSchedule RENDERER_DISABLING_SCHEDULE = new ActionSchedule.Builder(TAG)
-      // Wait 10 seconds, disable the video renderer, wait another 5 seconds and enable it again.
+      // Wait 10 seconds, disable the video renderer, wait another 10 seconds and enable it again.
       .delay(10000).disableRenderer(DashHostedTest.VIDEO_RENDERER_INDEX)
       .delay(10000).enableRenderer(DashHostedTest.VIDEO_RENDERER_INDEX)
       // Ditto for the audio renderer.
@@ -163,6 +170,7 @@
           .enableRenderer(DashHostedTest.AUDIO_RENDERER_INDEX)
           .disableRenderer(DashHostedTest.AUDIO_RENDERER_INDEX)
           .enableRenderer(DashHostedTest.AUDIO_RENDERER_INDEX)
+      .delay(10000).seek(120000)
       .build();
 
   public DashTest() {
@@ -177,8 +185,8 @@ public void testH264Fixed() throws IOException {
       return;
     }
     String testName = "testH264Fixed";
-    testDashPlayback(getActivity(), testName, AAC_AUDIO_FRAME_COUNT, VIDEO_FRAME_COUNT,
-        H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false, H264_CDD_FIXED);
+    testDashPlayback(getActivity(), testName, H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false,
+        H264_CDD_FIXED);
   }
 
   public void testH264Adaptive() throws IOException {
@@ -187,9 +195,8 @@ public void testH264Adaptive() throws IOException {
       return;
     }
     String testName = "testH264Adaptive";
-    testDashPlayback(getActivity(), testName, AAC_AUDIO_FRAME_COUNT, VIDEO_FRAME_COUNT,
-        H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS,
-        H264_CDD_ADAPTIVE);
+    testDashPlayback(getActivity(), testName, H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
+        ALLOW_ADDITIONAL_VIDEO_FORMATS, H264_CDD_ADAPTIVE);
   }
 
   public void testH264AdaptiveWithSeeking() throws IOException {
@@ -198,9 +205,8 @@ public void testH264AdaptiveWithSeeking() throws IOException {
       return;
     }
     String testName = "testH264AdaptiveWithSeeking";
-    testDashPlayback(getActivity(), testName, SEEKING_SCHEDULE, false, AAC_AUDIO_FRAME_COUNT,
-        VIDEO_FRAME_COUNT, H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
-        ALLOW_ADDITIONAL_VIDEO_FORMATS, H264_CDD_ADAPTIVE);
+    testDashPlayback(getActivity(), testName, SEEKING_SCHEDULE, false, H264_MANIFEST,
+        AAC_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS, H264_CDD_ADAPTIVE);
   }
 
   public void testH264AdaptiveWithRendererDisabling() throws IOException {
@@ -209,122 +215,149 @@ public void testH264AdaptiveWithRendererDisabling() throws IOException {
       return;
     }
     String testName = "testH264AdaptiveWithRendererDisabling";
-    testDashPlayback(getActivity(), testName, RENDERER_DISABLING_SCHEDULE, false,
-        AAC_AUDIO_FRAME_COUNT, VIDEO_FRAME_COUNT, H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
-        ALLOW_ADDITIONAL_VIDEO_FORMATS, H264_CDD_ADAPTIVE);
+    testDashPlayback(getActivity(), testName, RENDERER_DISABLING_SCHEDULE, false, H264_MANIFEST,
+        AAC_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS, H264_CDD_ADAPTIVE);
   }
 
   // H265 CDD.
 
   public void testH265Fixed() throws IOException {
-    if (Util.SDK_INT < 21) {
+    if (Util.SDK_INT < 23) {
       // Pass.
       return;
     }
     String testName = "testH265Fixed";
-    testDashPlayback(getActivity(), testName, AAC_AUDIO_FRAME_COUNT, VIDEO_FRAME_COUNT,
-        H265_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false, H265_CDD_FIXED);
+    testDashPlayback(getActivity(), testName, H265_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false,
+        H265_CDD_FIXED);
   }
 
   public void testH265Adaptive() throws IOException {
-    if (Util.SDK_INT < 21 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H265)) {
+    if (Util.SDK_INT < 23 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H265)) {
       // Pass.
       return;
     }
     String testName = "testH265Adaptive";
-    testDashPlayback(getActivity(), testName, AAC_AUDIO_FRAME_COUNT, VIDEO_FRAME_COUNT,
-        H265_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS,
-        H265_CDD_ADAPTIVE);
+    testDashPlayback(getActivity(), testName, H265_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
+        ALLOW_ADDITIONAL_VIDEO_FORMATS, H265_CDD_ADAPTIVE);
   }
 
   public void testH265AdaptiveWithSeeking() throws IOException {
-    if (Util.SDK_INT < 21 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H265)) {
+    if (Util.SDK_INT < 23 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H265)) {
       // Pass.
       return;
     }
     String testName = "testH265AdaptiveWithSeeking";
-    testDashPlayback(getActivity(), testName, SEEKING_SCHEDULE, false, AAC_AUDIO_FRAME_COUNT,
-        VIDEO_FRAME_COUNT, H265_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
-        ALLOW_ADDITIONAL_VIDEO_FORMATS, H265_CDD_ADAPTIVE);
+    testDashPlayback(getActivity(), testName, SEEKING_SCHEDULE, false, H265_MANIFEST,
+        AAC_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS, H265_CDD_ADAPTIVE);
   }
 
   public void testH265AdaptiveWithRendererDisabling() throws IOException {
-    if (Util.SDK_INT < 21 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H265)) {
+    if (Util.SDK_INT < 23 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H265)) {
       // Pass.
       return;
     }
     String testName = "testH265AdaptiveWithRendererDisabling";
     testDashPlayback(getActivity(), testName, RENDERER_DISABLING_SCHEDULE, false,
-        AAC_AUDIO_FRAME_COUNT, VIDEO_FRAME_COUNT, H265_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
-        ALLOW_ADDITIONAL_VIDEO_FORMATS, H265_CDD_ADAPTIVE);
+        H265_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS,
+        H265_CDD_ADAPTIVE);
     }
 
   // VP9 (CDD).
 
   public void testVp9Fixed360p() throws IOException {
-    if (Util.SDK_INT < 16) {
+    if (Util.SDK_INT < 23) {
       // Pass.
       return;
     }
     String testName = "testVp9Fixed360p";
-    testDashPlayback(getActivity(), testName, VORBIS_AUDIO_FRAME_COUNT, VIDEO_FRAME_COUNT,
-        VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID, false, VP9_CDD_FIXED);
+    testDashPlayback(getActivity(), testName, VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID, false,
+        VP9_CDD_FIXED);
   }
 
   public void testVp9Adaptive() throws IOException {
-    if (Util.SDK_INT < 16 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_VP9)) {
+    if (Util.SDK_INT < 23 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_VP9)) {
       // Pass.
       return;
     }
     String testName = "testVp9Adaptive";
-    testDashPlayback(getActivity(), testName, VORBIS_AUDIO_FRAME_COUNT, VIDEO_FRAME_COUNT,
-        VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS,
-        VP9_CDD_ADAPTIVE);
+    testDashPlayback(getActivity(), testName, VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID,
+        ALLOW_ADDITIONAL_VIDEO_FORMATS, VP9_CDD_ADAPTIVE);
   }
 
   public void testVp9AdaptiveWithSeeking() throws IOException {
-    if (Util.SDK_INT < 16 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_VP9)) {
+    if (Util.SDK_INT < 23 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_VP9)) {
       // Pass.
       return;
     }
     String testName = "testVp9AdaptiveWithSeeking";
-    testDashPlayback(getActivity(), testName, SEEKING_SCHEDULE, false, VORBIS_AUDIO_FRAME_COUNT,
-        VIDEO_FRAME_COUNT, VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID,
-        ALLOW_ADDITIONAL_VIDEO_FORMATS, VP9_CDD_ADAPTIVE);
+    testDashPlayback(getActivity(), testName, SEEKING_SCHEDULE, false, VP9_MANIFEST,
+        VORBIS_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS, VP9_CDD_ADAPTIVE);
   }
 
   public void testVp9AdaptiveWithRendererDisabling() throws IOException {
-    if (Util.SDK_INT < 16 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_VP9)) {
+    if (Util.SDK_INT < 23 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_VP9)) {
       // Pass.
       return;
     }
     String testName = "testVp9AdaptiveWithRendererDisabling";
     testDashPlayback(getActivity(), testName, RENDERER_DISABLING_SCHEDULE, false,
-        VORBIS_AUDIO_FRAME_COUNT, VIDEO_FRAME_COUNT, VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID,
-        ALLOW_ADDITIONAL_VIDEO_FORMATS, VP9_CDD_ADAPTIVE);
+        VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS,
+        VP9_CDD_ADAPTIVE);
+  }
+
+  // H264: Other frame-rates for output buffer count assertions.
+
+  // 23.976 fps.
+  public void test23FpsH264Fixed() throws IOException {
+    if (Util.SDK_INT < 23) {
+      // Pass.
+      return;
+    }
+    String testName = "test23FpsH264Fixed";
+    testDashPlayback(getActivity(), testName, H264_23_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false,
+        H264_BASELINE_480P_23FPS_VIDEO_REPRESENTATION_ID);
+  }
+
+  // 24 fps.
+  public void test24FpsH264Fixed() throws IOException {
+    if (Util.SDK_INT < 23) {
+      // Pass.
+      return;
+    }
+    String testName = "test24FpsH264Fixed";
+    testDashPlayback(getActivity(), testName, H264_24_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false,
+        H264_BASELINE_480P_24FPS_VIDEO_REPRESENTATION_ID);
+  }
+
+  // 29.97 fps.
+  public void test29FpsH264Fixed() throws IOException {
+    if (Util.SDK_INT < 23) {
+      // Pass.
+      return;
+    }
+    String testName = "test29FpsH264Fixed";
+    testDashPlayback(getActivity(), testName, H264_29_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false,
+        H264_BASELINE_480P_29FPS_VIDEO_REPRESENTATION_ID);
   }
 
   // Internal.
 
-  private void testDashPlayback(HostActivity activity, String testName,
-      int sourceAudioFrameCount, int sourceVideoFrameCount, String manifestFileName,
+  private void testDashPlayback(HostActivity activity, String testName, String manifestFileName,
       String audioFormat, boolean includeAdditionalVideoFormats, String... videoFormats)
       throws IOException {
-    testDashPlayback(activity, testName, null, true, sourceAudioFrameCount,
-        sourceVideoFrameCount, manifestFileName, audioFormat, includeAdditionalVideoFormats,
-        videoFormats);
+    testDashPlayback(activity, testName, null, true, manifestFileName, audioFormat,
+        includeAdditionalVideoFormats, videoFormats);
   }
 
   private void testDashPlayback(HostActivity activity, String testName,
-      ActionSchedule actionSchedule, boolean fullPlaybackNoSeeking, int sourceAudioFrameCount,
-      int sourceVideoFrameCount, String manifestFileName, String audioFormat,
-      boolean includeAdditionalVideoFormats, String... videoFormats) throws IOException {
+      ActionSchedule actionSchedule, boolean fullPlaybackNoSeeking, String manifestFileName,
+      String audioFormat, boolean includeAdditionalVideoFormats, String... videoFormats)
+      throws IOException {
     MediaPresentationDescription mpd = TestUtil.loadManifest(activity,
         MANIFEST_URL_PREFIX + manifestFileName, new MediaPresentationDescriptionParser());
     MetricsLogger metricsLogger = MetricsLogger.Factory.createDefault(getInstrumentation(), TAG);
     DashHostedTest test = new DashHostedTest(testName, mpd, metricsLogger, fullPlaybackNoSeeking,
-        sourceAudioFrameCount, sourceVideoFrameCount, audioFormat, includeAdditionalVideoFormats,
-        videoFormats);
+        audioFormat, includeAdditionalVideoFormats, videoFormats);
     if (actionSchedule != null) {
       test.setSchedule(actionSchedule);
     }
@@ -359,8 +392,6 @@ private boolean shouldSkipAdaptiveTest(String mimeType) throws IOException {
     private final MediaPresentationDescription mpd;
     private final MetricsLogger metricsLogger;
     private final boolean fullPlaybackNoSeeking;
-    private final int sourceAudioFrameCount;
-    private final int sourceVideoFrameCount;
     private final boolean includeAdditionalVideoFormats;
     private final String[] audioFormats;
     private final String[] videoFormats;
@@ -374,24 +405,19 @@ private boolean shouldSkipAdaptiveTest(String mimeType) throws IOException {
      * @param metricsLogger Logger to log metrics from the test.
      * @param fullPlaybackNoSeeking True if the test will play the entire source with no seeking.
      *     False otherwise.
-     * @param sourceAudioFrameCount The number of audio frames in the source.
-     * @param sourceVideoFrameCount The number of video frames in the source.
      * @param audioFormat The audio format.
      * @param includeAdditionalVideoFormats Whether to use video formats in addition to
      *     those listed in the videoFormats argument, if the device is capable of playing them.
      * @param videoFormats The video formats.
      */
     public DashHostedTest(String testName, MediaPresentationDescription mpd,
-        MetricsLogger metricsLogger, boolean fullPlaybackNoSeeking, int sourceAudioFrameCount,
-        int sourceVideoFrameCount, String audioFormat, boolean includeAdditionalVideoFormats,
-        String... videoFormats) {
+        MetricsLogger metricsLogger, boolean fullPlaybackNoSeeking, String audioFormat,
+        boolean includeAdditionalVideoFormats, String... videoFormats) {
       super(RENDERER_COUNT);
       this.testName = testName;
       this.mpd = Assertions.checkNotNull(mpd);
       this.metricsLogger = metricsLogger;
       this.fullPlaybackNoSeeking = fullPlaybackNoSeeking;
-      this.sourceAudioFrameCount = sourceAudioFrameCount;
-      this.sourceVideoFrameCount = sourceVideoFrameCount;
       this.audioFormats = new String[] {audioFormat};
       this.includeAdditionalVideoFormats = includeAdditionalVideoFormats;
       this.videoFormats = videoFormats;
@@ -461,9 +487,9 @@ protected void assertPassed() {
         // We allow one fewer output buffer due to the way that MediaCodecTrackRenderer and the
         // underlying decoders handle the end of stream. This should be tightened up in the future.
         CodecCountersUtil.assertTotalOutputBufferCount(AUDIO_TAG, audioCounters,
-            sourceAudioFrameCount - 1, sourceAudioFrameCount);
+            audioCounters.inputBufferCount - 1, audioCounters.inputBufferCount);
         CodecCountersUtil.assertTotalOutputBufferCount(VIDEO_TAG, videoCounters,
-            sourceVideoFrameCount - 1, sourceVideoFrameCount);
+            videoCounters.inputBufferCount - 1, videoCounters.inputBufferCount);
 
         // The total playing time should match the source duration.
         long sourceDuration = mpd.duration;
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/DebugMediaCodecVideoTrackRenderer.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/DebugMediaCodecVideoTrackRenderer.java
index 62f351d999..bee732187b 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/DebugMediaCodecVideoTrackRenderer.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/DebugMediaCodecVideoTrackRenderer.java
@@ -24,6 +24,8 @@
 import android.content.Context;
 import android.os.Handler;
 
+import java.nio.ByteBuffer;
+
 /**
  * Decodes and renders video using {@link MediaCodecVideoTrackRenderer}. Provides buffer timestamp
  * assertions.
@@ -51,7 +53,8 @@ public DebugMediaCodecVideoTrackRenderer(Context context, SampleSource source,
   }
 
   @Override
-  protected void onQueuedInputBuffer(long presentationTimeUs) {
+  protected void onQueuedInputBuffer(
+      long presentationTimeUs, ByteBuffer buffer, int bufferSize, boolean sampleEncrypted) {
     if (enableBufferTimestampAssertions) {
       insertTimestamp(presentationTimeUs);
       maybeShiftTimestampsList();
diff --git a/settings.gradle b/settings.gradle
index 8d0d2823bf..89fc5741cc 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -13,13 +13,15 @@
 // limitations under the License.
 include ':library'
 include ':demo'
-include ':demo-misc-vp9-opus-sw'
+include ':demo-ext'
 include ':playbacktests'
 include ':extension-opus'
 include ':extension-vp9'
 include ':extension-okhttp'
+include ':extension-flac'
 
-project(':demo-misc-vp9-opus-sw').projectDir = new File(settingsDir, 'demo_misc/vp9_opus_sw')
+project(':demo-ext').projectDir = new File(settingsDir, 'demo_ext')
 project(':extension-opus').projectDir = new File(settingsDir, 'extensions/opus')
 project(':extension-vp9').projectDir = new File(settingsDir, 'extensions/vp9')
 project(':extension-okhttp').projectDir = new File(settingsDir, 'extensions/okhttp')
+project(':extension-flac').projectDir = new File(settingsDir, 'extensions/flac')
