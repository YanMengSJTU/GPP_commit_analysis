diff --git a/.gitignore b/.gitignore
index 16f7e8aec9..8ad7cdb8d0 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,6 +1,8 @@
 # Android generated
 bin
 gen
+libs
+obj
 lint.xml
 
 # IntelliJ IDEA
@@ -16,6 +18,7 @@ gen-external-apklibs
 .classpath
 .settings
 .checkstyle
+.cproject
 
 # Gradle
 .gradle
@@ -37,3 +40,11 @@ proguard-project.txt
 .DS_Store
 dist
 tmp
+
+# VP9 Extension
+extensions/vp9/src/main/jni/libvpx
+extensions/vp9/src/main/jni/libvpx_android_configs
+extensions/vp9/src/main/jni/libyuv
+
+# Opus Extension
+extensions/opus/src/main/jni/libopus
diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 0c1009f791..dc6823e4b2 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,5 +1,21 @@
 # Release notes #
 
+### r1.4.0 ###
+
+* Support for extracting Matroska streams (implemented by WebmExtractor).
+* Support for tx3g captions in MP4 streams.
+* Support for H.265 in MPEG-TS streams on supported devices.
+* HLS: Added support for MPEG audio (e.g. MP3).
+* HLS: Improved robustness against missing chunks and variants.
+* MP4: Added support for embedded MPEG audio (e.g. MP3).
+* TTML: Improved handling of whitespace.
+* DASH: Support Mpd.Location element.
+* Add option to TsExtractor to allow non-IDR keyframes.
+* Added MulticastDataSource for connecting to multicast streams.
+* (WorkInProgress) - First steps to supporting seeking in DASH DVR window.
+* (WorkInProgress) - First steps to supporting styled + positioned subtitles.
+* Misc bug fixes.
+
 ### r1.3.3 ###
 
 * HLS: Fix failure when playing HLS AAC streams.
diff --git a/demo/src/main/.settings/org.eclipse.jdt.core.prefs b/demo/src/main/.settings/org.eclipse.jdt.core.prefs
index b080d2ddc8..64cef5023a 100644
--- a/demo/src/main/.settings/org.eclipse.jdt.core.prefs
+++ b/demo/src/main/.settings/org.eclipse.jdt.core.prefs
@@ -1,4 +1,4 @@
 eclipse.preferences.version=1
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
-org.eclipse.jdt.core.compiler.compliance=1.6
-org.eclipse.jdt.core.compiler.source=1.6
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.7
+org.eclipse.jdt.core.compiler.compliance=1.7
+org.eclipse.jdt.core.compiler.source=1.7
diff --git a/demo/src/main/AndroidManifest.xml b/demo/src/main/AndroidManifest.xml
index 6ee2474b80..d825df355b 100644
--- a/demo/src/main/AndroidManifest.xml
+++ b/demo/src/main/AndroidManifest.xml
@@ -16,14 +16,12 @@
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer.demo"
-    android:versionCode="1303"
-    android:versionName="1.3.3"
+    android:versionCode="1400"
+    android:versionName="1.4.0"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
-  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
-  <uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/>
-  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
 
   <uses-sdk android:minSdkVersion="16" android:targetSdkVersion="22"/>
 
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/DemoUtil.java b/demo/src/main/java/com/google/android/exoplayer/demo/DemoUtil.java
deleted file mode 100644
index 558b294f09..0000000000
--- a/demo/src/main/java/com/google/android/exoplayer/demo/DemoUtil.java
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.demo;
-
-import java.io.BufferedInputStream;
-import java.io.BufferedOutputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.CookieHandler;
-import java.net.CookieManager;
-import java.net.CookiePolicy;
-import java.net.HttpURLConnection;
-import java.net.URL;
-import java.util.Map;
-
-/**
- * Utility methods for the demo application.
- */
-public class DemoUtil {
-
-  public static final int TYPE_DASH = 0;
-  public static final int TYPE_SS = 1;
-  public static final int TYPE_HLS = 2;
-  public static final int TYPE_MP4 = 3;
-  public static final int TYPE_MP3 = 4;
-  public static final int TYPE_M4A = 5;
-  public static final int TYPE_WEBM = 6;
-  public static final int TYPE_TS = 7;
-  public static final int TYPE_AAC = 8;
-
-  private static final CookieManager defaultCookieManager;
-
-  static {
-    defaultCookieManager = new CookieManager();
-    defaultCookieManager.setCookiePolicy(CookiePolicy.ACCEPT_ORIGINAL_SERVER);
-  }
-
-  public static byte[] executePost(String url, byte[] data, Map<String, String> requestProperties)
-      throws IOException {
-    HttpURLConnection urlConnection = null;
-    try {
-      urlConnection = (HttpURLConnection) new URL(url).openConnection();
-      urlConnection.setRequestMethod("POST");
-      urlConnection.setDoOutput(data != null);
-      urlConnection.setDoInput(true);
-      if (requestProperties != null) {
-        for (Map.Entry<String, String> requestProperty : requestProperties.entrySet()) {
-          urlConnection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());
-        }
-      }
-      if (data != null) {
-        OutputStream out = new BufferedOutputStream(urlConnection.getOutputStream());
-        out.write(data);
-        out.close();
-      }
-      InputStream in = new BufferedInputStream(urlConnection.getInputStream());
-      return convertInputStreamToByteArray(in);
-    } finally {
-      if (urlConnection != null) {
-        urlConnection.disconnect();
-      }
-    }
-  }
-
-  private static byte[] convertInputStreamToByteArray(InputStream inputStream) throws IOException {
-    byte[] bytes = null;
-    ByteArrayOutputStream bos = new ByteArrayOutputStream();
-    byte data[] = new byte[1024];
-    int count;
-    while ((count = inputStream.read(data)) != -1) {
-      bos.write(data, 0, count);
-    }
-    bos.flush();
-    bos.close();
-    inputStream.close();
-    bytes = bos.toByteArray();
-    return bytes;
-  }
-
-  public static void setDefaultCookieManager() {
-    CookieHandler currentHandler = CookieHandler.getDefault();
-    if (currentHandler != defaultCookieManager) {
-      CookieHandler.setDefault(defaultCookieManager);
-    }
-  }
-
-}
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/EventLogger.java b/demo/src/main/java/com/google/android/exoplayer/demo/EventLogger.java
index ffdf43a4d2..d0201fbc61 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/EventLogger.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/EventLogger.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer.ExoPlayer;
 import com.google.android.exoplayer.MediaCodecTrackRenderer.DecoderInitializationException;
+import com.google.android.exoplayer.TimeRange;
 import com.google.android.exoplayer.audio.AudioTrack;
 import com.google.android.exoplayer.chunk.Format;
 import com.google.android.exoplayer.demo.player.DemoPlayer;
@@ -46,6 +47,7 @@
 
   private long sessionStartTimeMs;
   private long[] loadStartTimeMs;
+  private long[] seekRangeValuesUs;
 
   public EventLogger() {
     loadStartTimeMs = new long[DemoPlayer.RENDERER_COUNT];
@@ -163,7 +165,14 @@ public void onCryptoError(CryptoException e) {
   @Override
   public void onDecoderInitialized(String decoderName, long elapsedRealtimeMs,
       long initializationDurationMs) {
-    Log.d(TAG, "decoderInitialized [" + getSessionTimeString() + "]");
+    Log.d(TAG, "decoderInitialized [" + getSessionTimeString() + ", " + decoderName + "]");
+  }
+
+  @Override
+  public void onSeekRangeChanged(TimeRange seekRange) {
+    seekRangeValuesUs = seekRange.getCurrentBoundsUs(seekRangeValuesUs);
+    Log.d(TAG, "seekRange [ " + seekRange.type + ", " + seekRangeValuesUs[0] + ", "
+        + seekRangeValuesUs[1] + "]");
   }
 
   private void printInternalError(String type, Exception e) {
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java b/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
index 5dd1eb8d32..f54dcfae58 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
@@ -15,8 +15,8 @@
  */
 package com.google.android.exoplayer.demo;
 
+import com.google.android.exoplayer.AspectRatioFrameLayout;
 import com.google.android.exoplayer.ExoPlayer;
-import com.google.android.exoplayer.VideoSurfaceView;
 import com.google.android.exoplayer.audio.AudioCapabilities;
 import com.google.android.exoplayer.audio.AudioCapabilitiesReceiver;
 import com.google.android.exoplayer.demo.player.DashRendererBuilder;
@@ -25,8 +25,9 @@
 import com.google.android.exoplayer.demo.player.ExtractorRendererBuilder;
 import com.google.android.exoplayer.demo.player.HlsRendererBuilder;
 import com.google.android.exoplayer.demo.player.SmoothStreamingRendererBuilder;
-import com.google.android.exoplayer.demo.player.UnsupportedDrmException;
+import com.google.android.exoplayer.drm.UnsupportedDrmException;
 import com.google.android.exoplayer.extractor.mp3.Mp3Extractor;
+import com.google.android.exoplayer.extractor.mp4.FragmentedMp4Extractor;
 import com.google.android.exoplayer.extractor.mp4.Mp4Extractor;
 import com.google.android.exoplayer.extractor.ts.AdtsExtractor;
 import com.google.android.exoplayer.extractor.ts.TsExtractor;
@@ -35,7 +36,9 @@
 import com.google.android.exoplayer.metadata.PrivMetadata;
 import com.google.android.exoplayer.metadata.TxxxMetadata;
 import com.google.android.exoplayer.text.CaptionStyleCompat;
-import com.google.android.exoplayer.text.SubtitleView;
+import com.google.android.exoplayer.text.Cue;
+import com.google.android.exoplayer.text.SubtitleLayout;
+import com.google.android.exoplayer.util.DebugTextViewHelper;
 import com.google.android.exoplayer.util.Util;
 import com.google.android.exoplayer.util.VerboseLogUtil;
 
@@ -43,22 +46,20 @@
 import android.app.Activity;
 import android.content.Context;
 import android.content.Intent;
-import android.graphics.Point;
 import android.net.Uri;
 import android.os.Bundle;
 import android.text.TextUtils;
 import android.util.Log;
-import android.view.Display;
 import android.view.KeyEvent;
 import android.view.Menu;
 import android.view.MenuItem;
 import android.view.MotionEvent;
 import android.view.SurfaceHolder;
+import android.view.SurfaceView;
 import android.view.View;
 import android.view.View.OnClickListener;
 import android.view.View.OnKeyListener;
 import android.view.View.OnTouchListener;
-import android.view.WindowManager;
 import android.view.accessibility.CaptioningManager;
 import android.widget.Button;
 import android.widget.MediaController;
@@ -67,38 +68,60 @@
 import android.widget.TextView;
 import android.widget.Toast;
 
+import java.net.CookieHandler;
+import java.net.CookieManager;
+import java.net.CookiePolicy;
+import java.util.List;
 import java.util.Map;
 
 /**
  * An activity that plays media using {@link DemoPlayer}.
  */
 public class PlayerActivity extends Activity implements SurfaceHolder.Callback, OnClickListener,
-    DemoPlayer.Listener, DemoPlayer.TextListener, DemoPlayer.Id3MetadataListener,
+    DemoPlayer.Listener, DemoPlayer.CaptionListener, DemoPlayer.Id3MetadataListener,
     AudioCapabilitiesReceiver.Listener {
 
+  public static final int TYPE_DASH = 0;
+  public static final int TYPE_SS = 1;
+  public static final int TYPE_HLS = 2;
+  public static final int TYPE_MP4 = 3;
+  public static final int TYPE_MP3 = 4;
+  public static final int TYPE_FMP4 = 5;
+  public static final int TYPE_WEBM = 6;
+  public static final int TYPE_MKV = 7;
+  public static final int TYPE_TS = 8;
+  public static final int TYPE_AAC = 9;
+  public static final int TYPE_M4A = 10;
+
   public static final String CONTENT_TYPE_EXTRA = "content_type";
   public static final String CONTENT_ID_EXTRA = "content_id";
 
   private static final String TAG = "PlayerActivity";
-
-  private static final float CAPTION_LINE_HEIGHT_RATIO = 0.0533f;
   private static final int MENU_GROUP_TRACKS = 1;
   private static final int ID_OFFSET = 2;
 
+  private static final CookieManager defaultCookieManager;
+  static {
+    defaultCookieManager = new CookieManager();
+    defaultCookieManager.setCookiePolicy(CookiePolicy.ACCEPT_ORIGINAL_SERVER);
+  }
+
   private EventLogger eventLogger;
   private MediaController mediaController;
   private View debugRootView;
   private View shutterView;
-  private VideoSurfaceView surfaceView;
+  private AspectRatioFrameLayout videoFrame;
+  private SurfaceView surfaceView;
   private TextView debugTextView;
   private TextView playerStateTextView;
-  private SubtitleView subtitleView;
+  private SubtitleLayout subtitleLayout;
   private Button videoButton;
   private Button audioButton;
   private Button textButton;
   private Button retryButton;
 
   private DemoPlayer player;
+  private DebugTextViewHelper debugViewHelper;
   private boolean playerNeedsPrepare;
 
   private long playerPosition;
@@ -149,12 +172,13 @@ public boolean onKey(View v, int keyCode, KeyEvent event) {
     shutterView = findViewById(R.id.shutter);
     debugRootView = findViewById(R.id.controls_root);
 
-    surfaceView = (VideoSurfaceView) findViewById(R.id.surface_view);
+    videoFrame = (AspectRatioFrameLayout) findViewById(R.id.video_frame);
+    surfaceView = (SurfaceView) findViewById(R.id.surface_view);
     surfaceView.getHolder().addCallback(this);
     debugTextView = (TextView) findViewById(R.id.debug_text_view);
 
     playerStateTextView = (TextView) findViewById(R.id.player_state_view);
-    subtitleView = (SubtitleView) findViewById(R.id.subtitles);
+    subtitleLayout = (SubtitleLayout) findViewById(R.id.subtitles);
 
     mediaController = new MediaController(this);
     mediaController.setAnchorView(root);
@@ -164,7 +188,10 @@ public boolean onKey(View v, int keyCode, KeyEvent event) {
     audioButton = (Button) findViewById(R.id.audio_controls);
     textButton = (Button) findViewById(R.id.text_controls);
 
-    DemoUtil.setDefaultCookieManager();
+    CookieHandler currentHandler = CookieHandler.getDefault();
+    if (currentHandler != defaultCookieManager) {
+      CookieHandler.setDefault(defaultCookieManager);
+    }
   }
 
   @Override
@@ -222,31 +249,30 @@ public void onAudioCapabilitiesChanged(AudioCapabilities audioCapabilities) {
   private RendererBuilder getRendererBuilder() {
     String userAgent = Util.getUserAgent(this, "ExoPlayerDemo");
     switch (contentType) {
-      case DemoUtil.TYPE_SS:
+      case TYPE_SS:
         return new SmoothStreamingRendererBuilder(this, userAgent, contentUri.toString(),
-            new SmoothStreamingTestMediaDrmCallback(), debugTextView);
-      case DemoUtil.TYPE_DASH:
+            new SmoothStreamingTestMediaDrmCallback());
+      case TYPE_DASH:
         return new DashRendererBuilder(this, userAgent, contentUri.toString(),
-            new WidevineTestMediaDrmCallback(contentId), debugTextView, audioCapabilities);
-      case DemoUtil.TYPE_HLS:
-        return new HlsRendererBuilder(this, userAgent, contentUri.toString(), debugTextView,
-            audioCapabilities);
-      case DemoUtil.TYPE_M4A: // There are no file format differences between M4A and MP4.
-      case DemoUtil.TYPE_MP4:
-        return new ExtractorRendererBuilder(this, userAgent, contentUri, debugTextView,
-            new Mp4Extractor());
-      case DemoUtil.TYPE_MP3:
-        return new ExtractorRendererBuilder(this, userAgent, contentUri, debugTextView,
-            new Mp3Extractor());
-      case DemoUtil.TYPE_TS:
-        return new ExtractorRendererBuilder(this, userAgent, contentUri, debugTextView,
+            new WidevineTestMediaDrmCallback(contentId), audioCapabilities);
+      case TYPE_HLS:
+        return new HlsRendererBuilder(this, userAgent, contentUri.toString(), audioCapabilities);
+      case TYPE_M4A: // There are no file format differences between M4A and MP4.
+      case TYPE_MP4:
+        return new ExtractorRendererBuilder(this, userAgent, contentUri, new Mp4Extractor());
+      case TYPE_MP3:
+        return new ExtractorRendererBuilder(this, userAgent, contentUri, new Mp3Extractor());
+      case TYPE_TS:
+        return new ExtractorRendererBuilder(this, userAgent, contentUri,
             new TsExtractor(0, audioCapabilities));
-      case DemoUtil.TYPE_AAC:
-        return new ExtractorRendererBuilder(this, userAgent, contentUri, debugTextView,
-            new AdtsExtractor());
-      case DemoUtil.TYPE_WEBM:
-        return new ExtractorRendererBuilder(this, userAgent, contentUri, debugTextView,
-            new WebmExtractor());
+      case TYPE_AAC:
+        return new ExtractorRendererBuilder(this, userAgent, contentUri, new AdtsExtractor());
+      case TYPE_FMP4:
+        return new ExtractorRendererBuilder(this, userAgent, contentUri,
+            new FragmentedMp4Extractor());
+      case TYPE_WEBM:
+      case TYPE_MKV:
+        return new ExtractorRendererBuilder(this, userAgent, contentUri, new WebmExtractor());
       default:
         throw new IllegalStateException("Unsupported type: " + contentType);
     }
@@ -256,7 +282,7 @@ private void preparePlayer() {
     if (player == null) {
       player = new DemoPlayer(getRendererBuilder());
       player.addListener(this);
-      player.setTextListener(this);
+      player.setCaptionListener(this);
       player.setMetadataListener(this);
       player.seekTo(playerPosition);
       playerNeedsPrepare = true;
@@ -267,6 +293,8 @@ private void preparePlayer() {
       player.addListener(eventLogger);
       player.setInfoListener(eventLogger);
       player.setInternalErrorListener(eventLogger);
+      debugViewHelper = new DebugTextViewHelper(player, debugTextView);
+      debugViewHelper.start();
     }
     if (playerNeedsPrepare) {
       player.prepare();
@@ -279,6 +307,8 @@ private void preparePlayer() {
 
   private void releasePlayer() {
     if (player != null) {
+      debugViewHelper.stop();
+      debugViewHelper = null;
       playerPosition = player.getCurrentPosition();
       player.release();
       player = null;
@@ -324,11 +354,9 @@ public void onError(Exception e) {
     if (e instanceof UnsupportedDrmException) {
       // Special case DRM failures.
       UnsupportedDrmException unsupportedDrmException = (UnsupportedDrmException) e;
-      int stringId = unsupportedDrmException.reason == UnsupportedDrmException.REASON_NO_DRM
-          ? R.string.drm_error_not_supported
+      int stringId = Util.SDK_INT < 18 ? R.string.drm_error_not_supported
           : unsupportedDrmException.reason == UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME
-          ? R.string.drm_error_unsupported_scheme
-          : R.string.drm_error_unknown;
+              ? R.string.drm_error_unsupported_scheme : R.string.drm_error_unknown;
       Toast.makeText(getApplicationContext(), stringId, Toast.LENGTH_LONG).show();
     }
     playerNeedsPrepare = true;
@@ -339,7 +367,7 @@ public void onError(Exception e) {
   @Override
   public void onVideoSizeChanged(int width, int height, float pixelWidthAspectRatio) {
     shutterView.setVisibility(View.GONE);
-    surfaceView.setVideoWidthHeightRatio(
+    videoFrame.setAspectRatio(
         height == 0 ? 1 : (width * pixelWidthAspectRatio) / height);
   }
 
@@ -353,7 +381,7 @@ private void updateButtonVisibilities() {
   }
 
   private boolean haveTracks(int type) {
-    return player != null && player.getTracks(type) != null;
+    return player != null && player.getTrackCount(type) > 0;
   }
 
   public void showVideoPopup(View v) {
@@ -416,8 +444,8 @@ private void configurePopupWithTracks(PopupMenu popup,
     if (player == null) {
       return;
     }
-    String[] tracks = player.getTracks(trackType);
-    if (tracks == null) {
+    int trackCount = player.getTrackCount(trackType);
+    if (trackCount == 0) {
       return;
     }
     popup.setOnMenuItemClickListener(new OnMenuItemClickListener() {
@@ -431,11 +459,11 @@ public boolean onMenuItemClick(MenuItem item) {
     Menu menu = popup.getMenu();
     // ID_OFFSET ensures we avoid clashing with Menu.NONE (which equals 0)
     menu.add(MENU_GROUP_TRACKS, DemoPlayer.DISABLED_TRACK + ID_OFFSET, Menu.NONE, R.string.off);
-    if (tracks.length == 1 && TextUtils.isEmpty(tracks[0])) {
+    if (trackCount == 1 && TextUtils.isEmpty(player.getTrackName(trackType, 0))) {
       menu.add(MENU_GROUP_TRACKS, DemoPlayer.PRIMARY_TRACK + ID_OFFSET, Menu.NONE, R.string.on);
     } else {
-      for (int i = 0; i < tracks.length; i++) {
-        menu.add(MENU_GROUP_TRACKS, i + ID_OFFSET, Menu.NONE, tracks[i]);
+      for (int i = 0; i < trackCount; i++) {
+        menu.add(MENU_GROUP_TRACKS, i + ID_OFFSET, Menu.NONE, player.getTrackName(trackType, i));
       }
     }
     menu.setGroupCheckable(MENU_GROUP_TRACKS, true, true);
@@ -464,16 +492,11 @@ private void showControls() {
     debugRootView.setVisibility(View.VISIBLE);
   }
 
-  // DemoPlayer.TextListener implementation
+  // DemoPlayer.CaptionListener implementation
 
   @Override
-  public void onText(String text) {
-    if (TextUtils.isEmpty(text)) {
-      subtitleView.setVisibility(View.INVISIBLE);
-    } else {
-      subtitleView.setVisibility(View.VISIBLE);
-      subtitleView.setText(text);
-    }
+  public void onCues(List<Cue> cues) {
+    subtitleLayout.setCues(cues);
   }
 
   // DemoPlayer.MetadataListener implementation
@@ -523,24 +546,16 @@ public void surfaceDestroyed(SurfaceHolder holder) {
 
   private void configureSubtitleView() {
     CaptionStyleCompat captionStyle;
-    float captionTextSize = getCaptionFontSize();
+    float captionFontScale;
     if (Util.SDK_INT >= 19) {
       captionStyle = getUserCaptionStyleV19();
-      captionTextSize *= getUserCaptionFontScaleV19();
+      captionFontScale = getUserCaptionFontScaleV19();
     } else {
       captionStyle = CaptionStyleCompat.DEFAULT;
+      captionFontScale = 1.0f;
     }
-    subtitleView.setStyle(captionStyle);
-    subtitleView.setTextSize(captionTextSize);
-  }
-
-  private float getCaptionFontSize() {
-    Display display = ((WindowManager) getSystemService(Context.WINDOW_SERVICE))
-        .getDefaultDisplay();
-    Point displaySize = new Point();
-    display.getSize(displaySize);
-    return Math.max(getResources().getDimension(R.dimen.subtitle_minimum_font_size),
-        CAPTION_LINE_HEIGHT_RATIO * Math.min(displaySize.x, displaySize.y));
+    subtitleLayout.setStyle(captionStyle);
+    subtitleLayout.setFontScale(captionFontScale);
   }
 
   @TargetApi(19)
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java b/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
index f68bb58892..551513161f 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
@@ -47,12 +47,12 @@ public Sample(String name, String contentId, String uri, int type) {
         "http://www.youtube.com/api/manifest/dash/id/bf5bb2419360daf1/source/youtube?"
         + "as=fmp4_audio_clear,fmp4_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&"
         + "ipbits=0&expire=19000000000&signature=51AF5F39AB0CEC3E5497CD9C900EBFEAECCCB5C7."
-        + "8506521BFC350652163895D4C26DEE124209AA9E&key=ik0", DemoUtil.TYPE_DASH),
+        + "8506521BFC350652163895D4C26DEE124209AA9E&key=ik0", PlayerActivity.TYPE_DASH),
     new Sample("Google Play",
         "http://www.youtube.com/api/manifest/dash/id/3aa39fa2cc27967f/source/youtube?"
         + "as=fmp4_audio_clear,fmp4_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&"
         + "ipbits=0&expire=19000000000&signature=A2716F75795F5D2AF0E88962FFCD10DB79384F29."
-        + "84308FF04844498CE6FBCE4731507882B8307798&key=ik0", DemoUtil.TYPE_DASH),
+        + "84308FF04844498CE6FBCE4731507882B8307798&key=ik0", PlayerActivity.TYPE_DASH),
   };
 
   public static final Sample[] YOUTUBE_DASH_WEBM = new Sample[] {
@@ -60,21 +60,21 @@ public Sample(String name, String contentId, String uri, int type) {
         "http://www.youtube.com/api/manifest/dash/id/bf5bb2419360daf1/source/youtube?"
         + "as=fmp4_audio_clear,webm2_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&"
         + "ipbits=0&expire=19000000000&signature=249B04F79E984D7F86B4D8DB48AE6FAF41C17AB3."
-        + "7B9F0EC0505E1566E59B8E488E9419F253DDF413&key=ik0", DemoUtil.TYPE_DASH),
+        + "7B9F0EC0505E1566E59B8E488E9419F253DDF413&key=ik0", PlayerActivity.TYPE_DASH),
     new Sample("Google Play",
         "http://www.youtube.com/api/manifest/dash/id/3aa39fa2cc27967f/source/youtube?"
         + "as=fmp4_audio_clear,webm2_sd_hd_clear&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0&"
         + "ipbits=0&expire=19000000000&signature=B1C2A74783AC1CC4865EB312D7DD2D48230CC9FD."
-        + "BD153B9882175F1F94BFE5141A5482313EA38E8D&key=ik0", DemoUtil.TYPE_DASH),
+        + "BD153B9882175F1F94BFE5141A5482313EA38E8D&key=ik0", PlayerActivity.TYPE_DASH),
   };
 
   public static final Sample[] SMOOTHSTREAMING = new Sample[] {
     new Sample("Super speed",
         "http://playready.directtaps.net/smoothstreaming/SSWSS720H264/SuperSpeedway_720.ism",
-        DemoUtil.TYPE_SS),
+        PlayerActivity.TYPE_SS),
     new Sample("Super speed (PlayReady)",
         "http://playready.directtaps.net/smoothstreaming/SSWSS720H264PR/SuperSpeedway_720.ism",
-        DemoUtil.TYPE_SS),
+        PlayerActivity.TYPE_SS),
   };
 
   public static final Sample[] WIDEVINE_GTS = new Sample[] {
@@ -82,72 +82,74 @@ public Sample(String name, String contentId, String uri, int type) {
         "http://www.youtube.com/api/manifest/dash/id/d286538032258a1c/source/youtube?"
         + "as=fmp4_audio_cenc,fmp4_sd_hd_cenc&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0"
         + "&ipbits=0&expire=19000000000&signature=477CF7D478BE26C205045D507E9358F85F84C065."
-        + "8971631EB657BC33EC2F48A2FF4211956760C3E9&key=ik0", DemoUtil.TYPE_DASH),
+        + "8971631EB657BC33EC2F48A2FF4211956760C3E9&key=ik0", PlayerActivity.TYPE_DASH),
     new Sample("WV: HDCP not required", "48fcc369939ac96c",
         "http://www.youtube.com/api/manifest/dash/id/48fcc369939ac96c/source/youtube?"
         + "as=fmp4_audio_cenc,fmp4_sd_hd_cenc&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0"
         + "&ipbits=0&expire=19000000000&signature=171DAE48D00B5BE7434BC1A9F84DAE0463C7EA7A."
-        + "0925B4DBB5605BEE9F5D088C48F25F5108E96191&key=ik0", DemoUtil.TYPE_DASH),
+        + "0925B4DBB5605BEE9F5D088C48F25F5108E96191&key=ik0", PlayerActivity.TYPE_DASH),
     new Sample("WV: HDCP required", "e06c39f1151da3df",
         "http://www.youtube.com/api/manifest/dash/id/e06c39f1151da3df/source/youtube?"
         + "as=fmp4_audio_cenc,fmp4_sd_hd_cenc&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0"
         + "&ipbits=0&expire=19000000000&signature=8D3B8AF4E3F72B7F127C8D0D39B7AFCF37B30519."
-        + "A118BADEBF3582AD2CC257B0EE6E579C6955D8AA&key=ik0", DemoUtil.TYPE_DASH),
+        + "A118BADEBF3582AD2CC257B0EE6E579C6955D8AA&key=ik0", PlayerActivity.TYPE_DASH),
     new Sample("WV: Secure video path required", "0894c7c8719b28a0",
         "http://www.youtube.com/api/manifest/dash/id/0894c7c8719b28a0/source/youtube?"
         + "as=fmp4_audio_cenc,fmp4_sd_hd_cenc&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0"
         + "&ipbits=0&expire=19000000000&signature=A41D835C7387885A4A820628F57E481E00095931."
-        + "9D50DBEEB5E37344647EE11BDA129A7FCDE8B7B9&key=ik0", DemoUtil.TYPE_DASH),
+        + "9D50DBEEB5E37344647EE11BDA129A7FCDE8B7B9&key=ik0", PlayerActivity.TYPE_DASH),
     new Sample("WV: HDCP + secure video path required", "efd045b1eb61888a",
-        "http://www.youtube.com/api/manifest/dash/id/efd045b1eb61888a/source/youtube"
+        "http://www.youtube.com/api/manifest/dash/id/efd045b1eb61888a/source/youtube?"
         + "as=fmp4_audio_cenc,fmp4_sd_hd_cenc&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0"
         + "&ipbits=0&expire=19000000000&signature=A97C9032C9D0C74F1643DB17C178873887C229E4."
-        + "0A657BF6F23C8BC1538F276137383478330B76DE&key=ik0", DemoUtil.TYPE_DASH),
+        + "0A657BF6F23C8BC1538F276137383478330B76DE&key=ik0", PlayerActivity.TYPE_DASH),
     new Sample("WV: 30s license duration (fails at ~30s)", "f9a34cab7b05881a",
         "http://www.youtube.com/api/manifest/dash/id/f9a34cab7b05881a/source/youtube?"
         + "as=fmp4_audio_cenc,fmp4_sd_hd_cenc&sparams=ip,ipbits,expire,source,id,as&ip=0.0.0.0"
         + "&ipbits=0&expire=19000000000&signature=80648A12A7D5FC1FA02B52B4250E4EB74CF0C5FD."
-        + "66A261130CA137AA5C541EA9CED2DBF240829EE6&key=ik0", DemoUtil.TYPE_DASH),
+        + "66A261130CA137AA5C541EA9CED2DBF240829EE6&key=ik0", PlayerActivity.TYPE_DASH),
   };
 
   public static final Sample[] HLS = new Sample[] {
     new Sample("Apple master playlist",
         "https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/"
-        + "bipbop_4x3_variant.m3u8", DemoUtil.TYPE_HLS),
+        + "bipbop_4x3_variant.m3u8", PlayerActivity.TYPE_HLS),
     new Sample("Apple master playlist advanced",
         "https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_16x9/"
-        + "bipbop_16x9_variant.m3u8", DemoUtil.TYPE_HLS),
+        + "bipbop_16x9_variant.m3u8", PlayerActivity.TYPE_HLS),
     new Sample("Apple TS media playlist",
         "https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/gear1/"
-        + "prog_index.m3u8", DemoUtil.TYPE_HLS),
+        + "prog_index.m3u8", PlayerActivity.TYPE_HLS),
     new Sample("Apple AAC media playlist",
         "https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/gear0/"
-        + "prog_index.m3u8", DemoUtil.TYPE_HLS),
+        + "prog_index.m3u8", PlayerActivity.TYPE_HLS),
     new Sample("Apple ID3 metadata", "http://devimages.apple.com/samplecode/adDemo/ad.m3u8",
-        DemoUtil.TYPE_HLS),
+        PlayerActivity.TYPE_HLS),
   };
 
   public static final Sample[] MISC = new Sample[] {
     new Sample("Dizzy", "http://html5demos.com/assets/dizzy.mp4",
-        DemoUtil.TYPE_MP4),
+        PlayerActivity.TYPE_MP4),
     new Sample("Apple AAC 10s", "https://devimages.apple.com.edgekey.net/"
         + "streaming/examples/bipbop_4x3/gear0/fileSequence0.aac",
-        DemoUtil.TYPE_AAC),
+        PlayerActivity.TYPE_AAC),
     new Sample("Apple TS 10s", "https://devimages.apple.com.edgekey.net/streaming/examples/"
         + "bipbop_4x3/gear1/fileSequence0.ts",
-        DemoUtil.TYPE_TS),
+        PlayerActivity.TYPE_TS),
+    new Sample("Android screens (Matroska)", "http://storage.googleapis.com/exoplayer-test-media-1/"
+        + "mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv", PlayerActivity.TYPE_MKV),
     new Sample("Big Buck Bunny (MP4 Video)",
         "http://redirector.c.youtube.com/videoplayback?id=604ed5ce52eda7ee&itag=22&source=youtube&"
         + "sparams=ip,ipbits,expire,source,id&ip=0.0.0.0&ipbits=0&expire=19000000000&signature="
         + "513F28C7FDCBEC60A66C86C9A393556C99DC47FB.04C88036EEE12565A1ED864A875A58F15D8B5300"
         + "&key=ik0",
-        DemoUtil.TYPE_MP4),
+        PlayerActivity.TYPE_MP4),
     new Sample("Google Play (MP3 Audio)",
         "http://storage.googleapis.com/exoplayer-test-media-0/play.mp3",
-        DemoUtil.TYPE_MP3),
+        PlayerActivity.TYPE_MP3),
     new Sample("Google Glass (WebM Video with Vorbis Audio)",
         "http://demos.webmproject.org/exoplayer/glass_vp9_vorbis.webm",
-        DemoUtil.TYPE_WEBM),
+        PlayerActivity.TYPE_WEBM),
   };
 
   private Samples() {}
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/SmoothStreamingTestMediaDrmCallback.java b/demo/src/main/java/com/google/android/exoplayer/demo/SmoothStreamingTestMediaDrmCallback.java
index ace3f1ee08..257b0cac2e 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/SmoothStreamingTestMediaDrmCallback.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/SmoothStreamingTestMediaDrmCallback.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer.drm.MediaDrmCallback;
 import com.google.android.exoplayer.drm.StreamingDrmSessionManager;
+import com.google.android.exoplayer.util.Util;
 
 import android.annotation.TargetApi;
 import android.media.MediaDrm.KeyRequest;
@@ -38,7 +39,7 @@
       "http://playready.directtaps.net/pr/svc/rightsmanager.asmx";
   private static final Map<String, String> KEY_REQUEST_PROPERTIES;
   static {
-    HashMap<String, String> keyRequestProperties = new HashMap<String, String>();
+    HashMap<String, String> keyRequestProperties = new HashMap<>();
     keyRequestProperties.put("Content-Type", "text/xml");
     keyRequestProperties.put("SOAPAction",
         "http://schemas.microsoft.com/DRM/2007/03/protocols/AcquireLicense");
@@ -48,7 +49,7 @@
   @Override
   public byte[] executeProvisionRequest(UUID uuid, ProvisionRequest request) throws IOException {
     String url = request.getDefaultUrl() + "&signedRequest=" + new String(request.getData());
-    return DemoUtil.executePost(url, null, null);
+    return Util.executePost(url, null, null);
   }
 
   @Override
@@ -57,7 +58,7 @@
     if (TextUtils.isEmpty(url)) {
       url = PLAYREADY_TEST_DEFAULT_URI;
     }
-    return DemoUtil.executePost(url, request.getData(), KEY_REQUEST_PROPERTIES);
+    return Util.executePost(url, request.getData(), KEY_REQUEST_PROPERTIES);
   }
 
 }
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/WidevineTestMediaDrmCallback.java b/demo/src/main/java/com/google/android/exoplayer/demo/WidevineTestMediaDrmCallback.java
index 1f29f6b7a1..bffd5fcb1f 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/WidevineTestMediaDrmCallback.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/WidevineTestMediaDrmCallback.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer.demo;
 
 import com.google.android.exoplayer.drm.MediaDrmCallback;
+import com.google.android.exoplayer.util.Util;
 
 import android.annotation.TargetApi;
 import android.media.MediaDrm.KeyRequest;
@@ -43,7 +44,7 @@ public WidevineTestMediaDrmCallback(String videoId) {
   @Override
   public byte[] executeProvisionRequest(UUID uuid, ProvisionRequest request) throws IOException {
     String url = request.getDefaultUrl() + "&signedRequest=" + new String(request.getData());
-    return DemoUtil.executePost(url, null, null);
+    return Util.executePost(url, null, null);
   }
 
   @Override
@@ -52,7 +53,7 @@ public WidevineTestMediaDrmCallback(String videoId) {
     if (TextUtils.isEmpty(url)) {
       url = defaultUri;
     }
-    return DemoUtil.executePost(url, request.getData(), null);
+    return Util.executePost(url, request.getData(), null);
   }
 
 }
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/DashRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/DashRendererBuilder.java
index bde74928a0..8f1d738064 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/DashRendererBuilder.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/DashRendererBuilder.java
@@ -42,9 +42,9 @@
 import com.google.android.exoplayer.dash.mpd.UtcTimingElementResolver.UtcTimingCallback;
 import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilder;
 import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilderCallback;
-import com.google.android.exoplayer.drm.DrmSessionManager;
 import com.google.android.exoplayer.drm.MediaDrmCallback;
 import com.google.android.exoplayer.drm.StreamingDrmSessionManager;
+import com.google.android.exoplayer.drm.UnsupportedDrmException;
 import com.google.android.exoplayer.text.TextTrackRenderer;
 import com.google.android.exoplayer.text.ttml.TtmlParser;
 import com.google.android.exoplayer.text.webvtt.WebvttParser;
@@ -57,14 +57,10 @@
 import com.google.android.exoplayer.util.ManifestFetcher.ManifestCallback;
 import com.google.android.exoplayer.util.Util;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.media.MediaCodec;
-import android.media.UnsupportedSchemeException;
 import android.os.Handler;
 import android.util.Log;
-import android.util.Pair;
-import android.widget.TextView;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -104,7 +100,6 @@
   private final String userAgent;
   private final String url;
   private final MediaDrmCallback drmCallback;
-  private final TextView debugTextView;
   private final AudioCapabilities audioCapabilities;
 
   private DemoPlayer player;
@@ -116,12 +111,11 @@
   private long elapsedRealtimeOffset;
 
   public DashRendererBuilder(Context context, String userAgent, String url,
-      MediaDrmCallback drmCallback, TextView debugTextView, AudioCapabilities audioCapabilities) {
+      MediaDrmCallback drmCallback, AudioCapabilities audioCapabilities) {
     this.context = context;
     this.userAgent = userAgent;
     this.url = url;
     this.drmCallback = drmCallback;
-    this.debugTextView = debugTextView;
     this.audioCapabilities = audioCapabilities;
   }
 
@@ -131,8 +125,7 @@ public void buildRenderers(DemoPlayer player, RendererBuilderCallback callback)
     this.callback = callback;
     MediaPresentationDescriptionParser parser = new MediaPresentationDescriptionParser();
     manifestDataSource = new DefaultUriDataSource(context, userAgent);
-    manifestFetcher = new ManifestFetcher<MediaPresentationDescription>(url, manifestDataSource,
-        parser);
+    manifestFetcher = new ManifestFetcher<>(url, manifestDataSource, parser);
     manifestFetcher.singleLoad(player.getMainHandler().getLooper(), this);
   }
 
@@ -193,20 +186,18 @@ private void buildRenderers() {
 
     // Check drm support if necessary.
     boolean filterHdContent = false;
-    DrmSessionManager drmSessionManager = null;
+    StreamingDrmSessionManager drmSessionManager = null;
     if (hasContentProtection) {
       if (Util.SDK_INT < 18) {
         callback.onRenderersError(
-            new UnsupportedDrmException(UnsupportedDrmException.REASON_NO_DRM));
+            new UnsupportedDrmException(UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME));
         return;
       }
       try {
-        Pair<DrmSessionManager, Boolean> drmSessionManagerData =
-            V18Compat.getDrmSessionManagerData(player, drmCallback);
-        drmSessionManager = drmSessionManagerData.first;
-        // HD streams require L1 security.
+        drmSessionManager = StreamingDrmSessionManager.newWidevineInstance(
+            player.getPlaybackLooper(), drmCallback, null, player.getMainHandler(), player);
         filterHdContent = videoAdaptationSet != null && videoAdaptationSet.hasContentProtection()
-            && !drmSessionManagerData.second;
+            && getWidevineSecurityLevel(drmSessionManager) != SECURITY_LEVEL_1;
       } catch (UnsupportedDrmException e) {
         callback.onRenderersError(e);
         return;
@@ -227,39 +218,36 @@ private void buildRenderers() {
 
     // Build the video renderer.
     final MediaCodecVideoTrackRenderer videoRenderer;
-    final TrackRenderer debugRenderer;
     if (videoRepresentationIndices == null || videoRepresentationIndices.length == 0) {
       videoRenderer = null;
-      debugRenderer = null;
     } else {
       DataSource videoDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
       ChunkSource videoChunkSource = new DashChunkSource(manifestFetcher,
           videoAdaptationSetIndex, videoRepresentationIndices, videoDataSource,
-          new AdaptiveEvaluator(bandwidthMeter), LIVE_EDGE_LATENCY_MS, elapsedRealtimeOffset);
+          new AdaptiveEvaluator(bandwidthMeter), LIVE_EDGE_LATENCY_MS, elapsedRealtimeOffset,
+          mainHandler, player);
       ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,
           VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,
           DemoPlayer.TYPE_VIDEO);
       videoRenderer = new MediaCodecVideoTrackRenderer(videoSampleSource, drmSessionManager, true,
           MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000, null, mainHandler, player, 50);
-      debugRenderer = debugTextView != null
-          ? new DebugTrackRenderer(debugTextView, player, videoRenderer) : null;
     }
 
     // Build the audio chunk sources.
-    List<ChunkSource> audioChunkSourceList = new ArrayList<ChunkSource>();
-    List<String> audioTrackNameList = new ArrayList<String>();
+    List<ChunkSource> audioChunkSourceList = new ArrayList<>();
+    List<String> audioTrackNameList = new ArrayList<>();
     if (audioAdaptationSet != null) {
       DataSource audioDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
       FormatEvaluator audioEvaluator = new FormatEvaluator.FixedEvaluator();
       List<Representation> audioRepresentations = audioAdaptationSet.representations;
-      List<String> codecs = new ArrayList<String>();
+      List<String> codecs = new ArrayList<>();
       for (int i = 0; i < audioRepresentations.size(); i++) {
         Format format = audioRepresentations.get(i).format;
         audioTrackNameList.add(format.id + " (" + format.numChannels + "ch, " +
             format.audioSamplingRate + "Hz)");
         audioChunkSourceList.add(new DashChunkSource(manifestFetcher, audioAdaptationSetIndex,
             new int[] {i}, audioDataSource, audioEvaluator, LIVE_EDGE_LATENCY_MS,
-            elapsedRealtimeOffset));
+            elapsedRealtimeOffset, mainHandler, player));
         codecs.add(format.codecs);
       }
 
@@ -306,8 +294,8 @@ private void buildRenderers() {
     // Build the text chunk sources.
     DataSource textDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
     FormatEvaluator textEvaluator = new FormatEvaluator.FixedEvaluator();
-    List<ChunkSource> textChunkSourceList = new ArrayList<ChunkSource>();
-    List<String> textTrackNameList = new ArrayList<String>();
+    List<ChunkSource> textChunkSourceList = new ArrayList<>();
+    List<String> textTrackNameList = new ArrayList<>();
     for (int i = 0; i < period.adaptationSets.size(); i++) {
       AdaptationSet adaptationSet = period.adaptationSets.get(i);
       if (adaptationSet.type == AdaptationSet.TYPE_TEXT) {
@@ -316,7 +304,8 @@ private void buildRenderers() {
           Representation representation = representations.get(j);
           textTrackNameList.add(representation.format.id);
           textChunkSourceList.add(new DashChunkSource(manifestFetcher, i, new int[] {j},
-              textDataSource, textEvaluator, LIVE_EDGE_LATENCY_MS, elapsedRealtimeOffset));
+              textDataSource, textEvaluator, LIVE_EDGE_LATENCY_MS, elapsedRealtimeOffset,
+              mainHandler, player));
         }
       }
     }
@@ -354,34 +343,13 @@ private void buildRenderers() {
     renderers[DemoPlayer.TYPE_VIDEO] = videoRenderer;
     renderers[DemoPlayer.TYPE_AUDIO] = audioRenderer;
     renderers[DemoPlayer.TYPE_TEXT] = textRenderer;
-    renderers[DemoPlayer.TYPE_DEBUG] = debugRenderer;
-    callback.onRenderers(trackNames, multiTrackChunkSources, renderers);
+    callback.onRenderers(trackNames, multiTrackChunkSources, renderers, bandwidthMeter);
   }
 
-  @TargetApi(18)
-  private static class V18Compat {
-
-    public static Pair<DrmSessionManager, Boolean> getDrmSessionManagerData(DemoPlayer player,
-        MediaDrmCallback drmCallback) throws UnsupportedDrmException {
-      try {
-        StreamingDrmSessionManager streamingDrmSessionManager =
-            StreamingDrmSessionManager.newWidevineInstance(player.getPlaybackLooper(), drmCallback,
-            null, player.getMainHandler(), player);
-        return Pair.create((DrmSessionManager) streamingDrmSessionManager,
-            getWidevineSecurityLevel(streamingDrmSessionManager) == SECURITY_LEVEL_1);
-      } catch (UnsupportedSchemeException e) {
-        throw new UnsupportedDrmException(UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME);
-      } catch (Exception e) {
-        throw new UnsupportedDrmException(UnsupportedDrmException.REASON_UNKNOWN, e);
-      }
-    }
-
-    private static int getWidevineSecurityLevel(StreamingDrmSessionManager sessionManager) {
-      String securityLevelProperty = sessionManager.getPropertyString("securityLevel");
-      return securityLevelProperty.equals("L1") ? SECURITY_LEVEL_1 : securityLevelProperty
-          .equals("L3") ? SECURITY_LEVEL_3 : SECURITY_LEVEL_UNKNOWN;
-    }
-
+  private static int getWidevineSecurityLevel(StreamingDrmSessionManager sessionManager) {
+    String securityLevelProperty = sessionManager.getPropertyString("securityLevel");
+    return securityLevelProperty.equals("L1") ? SECURITY_LEVEL_1 : securityLevelProperty
+        .equals("L3") ? SECURITY_LEVEL_3 : SECURITY_LEVEL_UNKNOWN;
   }
 
 }
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/DebugTrackRenderer.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/DebugTrackRenderer.java
deleted file mode 100644
index 2a846f46b2..0000000000
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/DebugTrackRenderer.java
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.demo.player;
-
-import com.google.android.exoplayer.ExoPlaybackException;
-import com.google.android.exoplayer.MediaCodecTrackRenderer;
-import com.google.android.exoplayer.TrackRenderer;
-import com.google.android.exoplayer.chunk.Format;
-
-import android.widget.TextView;
-
-/**
- * A {@link TrackRenderer} that periodically updates debugging information displayed by a
- * {@link TextView}.
- */
-/* package */ class DebugTrackRenderer extends TrackRenderer implements Runnable {
-
-  private final TextView textView;
-  private final DemoPlayer player;
-  private final MediaCodecTrackRenderer renderer;
-
-  private volatile boolean pendingFailure;
-  private volatile long currentPositionUs;
-
-  public DebugTrackRenderer(TextView textView, DemoPlayer player,
-      MediaCodecTrackRenderer renderer) {
-    this.textView = textView;
-    this.player = player;
-    this.renderer = renderer;
-  }
-
-  public void injectFailure() {
-    pendingFailure = true;
-  }
-
-  @Override
-  protected boolean isEnded() {
-    return true;
-  }
-
-  @Override
-  protected boolean isReady() {
-    return true;
-  }
-
-  @Override
-  protected int doPrepare(long positionUs) throws ExoPlaybackException {
-    maybeFail();
-    return STATE_PREPARED;
-  }
-
-  @Override
-  protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
-    maybeFail();
-    if (positionUs < currentPositionUs || positionUs > currentPositionUs + 1000000) {
-      currentPositionUs = positionUs;
-      textView.post(this);
-    }
-  }
-
-  @Override
-  public void run() {
-    textView.setText(getRenderString());
-  }
-
-  private String getRenderString() {
-    return getQualityString() + " " + renderer.codecCounters.getDebugString();
-  }
-
-  private String getQualityString() {
-    Format format = player.getVideoFormat();
-    return format == null ? "id:? br:? h:?"
-        : "id:" + format.id + " br:" + format.bitrate + " h:" + format.height;
-  }
-
-  @Override
-  protected long getCurrentPositionUs() {
-    return currentPositionUs;
-  }
-
-  @Override
-  protected long getDurationUs() {
-    return TrackRenderer.MATCH_LONGEST_US;
-  }
-
-  @Override
-  protected long getBufferedPositionUs() {
-    return TrackRenderer.END_OF_TRACK_US;
-  }
-
-  @Override
-  protected void seekTo(long timeUs) {
-    currentPositionUs = timeUs;
-  }
-
-  private void maybeFail() throws ExoPlaybackException {
-    if (pendingFailure) {
-      pendingFailure = false;
-      throw new ExoPlaybackException("fail() was called on DebugTrackRenderer");
-    }
-  }
-
-}
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
index dd83694659..1dcb2f31e8 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
@@ -15,22 +15,29 @@
  */
 package com.google.android.exoplayer.demo.player;
 
+import com.google.android.exoplayer.CodecCounters;
 import com.google.android.exoplayer.DummyTrackRenderer;
 import com.google.android.exoplayer.ExoPlaybackException;
 import com.google.android.exoplayer.ExoPlayer;
 import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
+import com.google.android.exoplayer.MediaCodecTrackRenderer;
 import com.google.android.exoplayer.MediaCodecTrackRenderer.DecoderInitializationException;
 import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
+import com.google.android.exoplayer.TimeRange;
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.audio.AudioTrack;
 import com.google.android.exoplayer.chunk.ChunkSampleSource;
 import com.google.android.exoplayer.chunk.Format;
 import com.google.android.exoplayer.chunk.MultiTrackChunkSource;
+import com.google.android.exoplayer.dash.DashChunkSource;
 import com.google.android.exoplayer.drm.StreamingDrmSessionManager;
 import com.google.android.exoplayer.hls.HlsSampleSource;
-import com.google.android.exoplayer.metadata.MetadataTrackRenderer;
+import com.google.android.exoplayer.metadata.MetadataTrackRenderer.MetadataRenderer;
+import com.google.android.exoplayer.text.Cue;
 import com.google.android.exoplayer.text.TextRenderer;
+import com.google.android.exoplayer.upstream.BandwidthMeter;
 import com.google.android.exoplayer.upstream.DefaultBandwidthMeter;
+import com.google.android.exoplayer.util.DebugTextViewHelper;
 import com.google.android.exoplayer.util.PlayerControl;
 
 import android.media.MediaCodec.CryptoException;
@@ -39,6 +46,8 @@
 import android.view.Surface;
 
 import java.io.IOException;
+import java.util.Collections;
+import java.util.List;
 import java.util.Map;
 import java.util.concurrent.CopyOnWriteArrayList;
 
@@ -50,7 +59,8 @@
 public class DemoPlayer implements ExoPlayer.Listener, ChunkSampleSource.EventListener,
     HlsSampleSource.EventListener, DefaultBandwidthMeter.EventListener,
     MediaCodecVideoTrackRenderer.EventListener, MediaCodecAudioTrackRenderer.EventListener,
-    StreamingDrmSessionManager.EventListener, TextRenderer {
+    StreamingDrmSessionManager.EventListener, DashChunkSource.EventListener, TextRenderer,
+    MetadataRenderer<Map<String, Object>>, DebugTextViewHelper.Provider {
 
   /**
    * Builds renderers for the player.
@@ -80,9 +90,10 @@
      *     multiple tracks. An individual element may be null if it does not have multiple tracks.
      * @param renderers Renderers indexed by {@link DemoPlayer} TYPE_* constants. An individual
      *     element may be null if there do not exist tracks of the corresponding type.
+     * @param bandwidthMeter Provides an estimate of the currently available bandwidth. May be null.
      */
     void onRenderers(String[][] trackNames, MultiTrackChunkSource[] multiTrackSources,
-        TrackRenderer[] renderers);
+        TrackRenderer[] renderers, BandwidthMeter bandwidthMeter);
     /**
      * Invoked if a {@link RendererBuilder} encounters an error.
      *
@@ -132,13 +143,14 @@ void onLoadCompleted(int sourceId, long bytesLoaded, int type, int trigger, Form
         int mediaStartTimeMs, int mediaEndTimeMs, long elapsedRealtimeMs, long loadDurationMs);
     void onDecoderInitialized(String decoderName, long elapsedRealtimeMs,
         long initializationDurationMs);
+    void onSeekRangeChanged(TimeRange seekRange);
   }
 
   /**
    * A listener for receiving notifications of timed text.
    */
-  public interface TextListener {
-    void onText(String text);
+  public interface CaptionListener {
+    void onCues(List<Cue> cues);
   }
 
   /**
@@ -158,12 +170,11 @@ void onDecoderInitialized(String decoderName, long elapsedRealtimeMs,
   public static final int DISABLED_TRACK = -1;
   public static final int PRIMARY_TRACK = 0;
 
-  public static final int RENDERER_COUNT = 5;
+  public static final int RENDERER_COUNT = 4;
   public static final int TYPE_VIDEO = 0;
   public static final int TYPE_AUDIO = 1;
   public static final int TYPE_TEXT = 2;
-  public static final int TYPE_TIMED_METADATA = 3;
-  public static final int TYPE_DEBUG = 4;
+  public static final int TYPE_METADATA = 3;
 
   private static final int RENDERER_BUILDING_STATE_IDLE = 1;
   private static final int RENDERER_BUILDING_STATE_BUILDING = 2;
@@ -182,15 +193,17 @@ void onDecoderInitialized(String decoderName, long elapsedRealtimeMs,
   private Surface surface;
   private InternalRendererBuilderCallback builderCallback;
   private TrackRenderer videoRenderer;
+  private CodecCounters codecCounters;
   private Format videoFormat;
   private int videoTrackToRestore;
 
+  private BandwidthMeter bandwidthMeter;
   private MultiTrackChunkSource[] multiTrackSources;
   private String[][] trackNames;
   private int[] selectedTracks;
   private boolean backgrounded;
 
-  private TextListener textListener;
+  private CaptionListener captionListener;
   private Id3MetadataListener id3MetadataListener;
   private InternalErrorListener internalErrorListener;
   private InfoListener infoListener;
@@ -201,7 +214,7 @@ public DemoPlayer(RendererBuilder rendererBuilder) {
     player.addListener(this);
     playerControl = new PlayerControl(player);
     mainHandler = new Handler();
-    listeners = new CopyOnWriteArrayList<Listener>();
+    listeners = new CopyOnWriteArrayList<>();
     lastReportedPlaybackState = STATE_IDLE;
     rendererBuildingState = RENDERER_BUILDING_STATE_IDLE;
     selectedTracks = new int[RENDERER_COUNT];
@@ -229,8 +242,8 @@ public void setInfoListener(InfoListener listener) {
     infoListener = listener;
   }
 
-  public void setTextListener(TextListener listener) {
-    textListener = listener;
+  public void setCaptionListener(CaptionListener listener) {
+    captionListener = listener;
   }
 
   public void setMetadataListener(Id3MetadataListener listener) {
@@ -251,8 +264,12 @@ public void blockingClearSurface() {
     pushSurface(true);
   }
 
-  public String[] getTracks(int type) {
-    return trackNames == null ? null : trackNames[type];
+  public int getTrackCount(int type) {
+    return !player.getRendererHasMedia(type) ? 0 : trackNames[type].length;
+  }
+
+  public String getTrackName(int type, int index) {
+    return trackNames[type][index];
   }
 
   public int getSelectedTrackIndex(int type) {
@@ -265,15 +282,11 @@ public void selectTrack(int type, int index) {
     }
     selectedTracks[type] = index;
     pushTrackSelection(type, true);
-    if (type == TYPE_TEXT && index == DISABLED_TRACK && textListener != null) {
-      textListener.onText(null);
+    if (type == TYPE_TEXT && index == DISABLED_TRACK && captionListener != null) {
+      captionListener.onCues(Collections.<Cue>emptyList());
     }
   }
 
-  public Format getVideoFormat() {
-    return videoFormat;
-  }
-
   public void setBackgrounded(boolean backgrounded) {
     if (this.backgrounded == backgrounded) {
       return;
@@ -305,7 +318,8 @@ public void prepare() {
   }
 
   /* package */ void onRenderers(String[][] trackNames,
-      MultiTrackChunkSource[] multiTrackSources, TrackRenderer[] renderers) {
+      MultiTrackChunkSource[] multiTrackSources, TrackRenderer[] renderers,
+      BandwidthMeter bandwidthMeter) {
     builderCallback = null;
     // Normalize the results.
     if (trackNames == null) {
@@ -314,21 +328,27 @@ public void prepare() {
     if (multiTrackSources == null) {
       multiTrackSources = new MultiTrackChunkSource[RENDERER_COUNT];
     }
-    for (int i = 0; i < RENDERER_COUNT; i++) {
-      if (renderers[i] == null) {
+    for (int rendererIndex = 0; rendererIndex < RENDERER_COUNT; rendererIndex++) {
+      if (renderers[rendererIndex] == null) {
         // Convert a null renderer to a dummy renderer.
-        renderers[i] = new DummyTrackRenderer();
-      } else if (trackNames[i] == null) {
-        // We have a renderer so we must have at least one track, but the names are unknown.
-        // Initialize the correct number of null track names.
-        int trackCount = multiTrackSources[i] == null ? 1 : multiTrackSources[i].getTrackCount();
-        trackNames[i] = new String[trackCount];
+        renderers[rendererIndex] = new DummyTrackRenderer();
+      }
+      if (trackNames[rendererIndex] == null) {
+        // Convert a null trackNames to an array of suitable length.
+        int trackCount = multiTrackSources[rendererIndex] != null
+            ? multiTrackSources[rendererIndex].getTrackCount() : 1;
+        trackNames[rendererIndex] = new String[trackCount];
       }
     }
     // Complete preparation.
     this.trackNames = trackNames;
     this.videoRenderer = renderers[TYPE_VIDEO];
+    this.codecCounters = videoRenderer instanceof MediaCodecTrackRenderer
+        ? ((MediaCodecTrackRenderer) videoRenderer).codecCounters
+        : renderers[TYPE_AUDIO] instanceof MediaCodecTrackRenderer
+        ? ((MediaCodecTrackRenderer) renderers[TYPE_AUDIO]).codecCounters : null;
     this.multiTrackSources = multiTrackSources;
+    this.bandwidthMeter = bandwidthMeter;
     pushSurface(false);
     pushTrackSelection(TYPE_VIDEO, true);
     pushTrackSelection(TYPE_AUDIO, true);
@@ -382,6 +402,22 @@ public int getPlaybackState() {
     return playerState;
   }
 
+  @Override
+  public Format getFormat() {
+    return videoFormat;
+  }
+
+  @Override
+  public BandwidthMeter getBandwidthMeter() {
+    return bandwidthMeter;
+  }
+
+  @Override
+  public CodecCounters getCodecCounters() {
+    return codecCounters;
+  }
+
+  @Override
   public long getCurrentPosition() {
     return player.getCurrentPosition();
   }
@@ -489,9 +525,7 @@ public void onCryptoError(CryptoException e) {
   }
 
   @Override
-  public void onDecoderInitialized(
-      String decoderName,
-      long elapsedRealtimeMs,
+  public void onDecoderInitialized(String decoderName, long elapsedRealtimeMs,
       long initializationDurationMs) {
     if (infoListener != null) {
       infoListener.onDecoderInitialized(decoderName, elapsedRealtimeMs, initializationDurationMs);
@@ -506,20 +540,24 @@ public void onLoadError(int sourceId, IOException e) {
   }
 
   @Override
-  public void onText(String text) {
-    processText(text);
-  }
-
-  /* package */ MetadataTrackRenderer.MetadataRenderer<Map<String, Object>>
-      getId3MetadataRenderer() {
-    return new MetadataTrackRenderer.MetadataRenderer<Map<String, Object>>() {
-      @Override
-      public void onMetadata(Map<String, Object> metadata) {
-        if (id3MetadataListener != null) {
-          id3MetadataListener.onId3Metadata(metadata);
-        }
-      }
-    };
+  public void onCues(List<Cue> cues) {
+    if (captionListener != null && selectedTracks[TYPE_TEXT] != DISABLED_TRACK) {
+      captionListener.onCues(cues);
+    }
+  }
+
+  @Override
+  public void onMetadata(Map<String, Object> metadata) {
+    if (id3MetadataListener != null && selectedTracks[TYPE_METADATA] != DISABLED_TRACK) {
+      id3MetadataListener.onId3Metadata(metadata);
+    }
+  }
+
+  @Override
+  public void onSeekRangeChanged(TimeRange seekRange) {
+    if (infoListener != null) {
+      infoListener.onSeekRangeChanged(seekRange);
+    }
   }
 
   @Override
@@ -607,13 +645,6 @@ private void pushTrackSelection(int type, boolean allowRendererEnable) {
     }
   }
 
-  /* package */ void processText(String text) {
-    if (textListener == null || selectedTracks[TYPE_TEXT] == DISABLED_TRACK) {
-      return;
-    }
-    textListener.onText(text);
-  }
-
   private class InternalRendererBuilderCallback implements RendererBuilderCallback {
 
     private boolean canceled;
@@ -624,9 +655,9 @@ public void cancel() {
 
     @Override
     public void onRenderers(String[][] trackNames, MultiTrackChunkSource[] multiTrackSources,
-        TrackRenderer[] renderers) {
+        TrackRenderer[] renderers, BandwidthMeter bandwidthMeter) {
       if (!canceled) {
-        DemoPlayer.this.onRenderers(trackNames, multiTrackSources, renderers);
+        DemoPlayer.this.onRenderers(trackNames, multiTrackSources, renderers, bandwidthMeter);
       }
     }
 
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/ExtractorRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/ExtractorRendererBuilder.java
index 3437678e04..68f0645750 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/ExtractorRendererBuilder.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/ExtractorRendererBuilder.java
@@ -22,58 +22,62 @@
 import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilderCallback;
 import com.google.android.exoplayer.extractor.Extractor;
 import com.google.android.exoplayer.extractor.ExtractorSampleSource;
+import com.google.android.exoplayer.text.TextTrackRenderer;
+import com.google.android.exoplayer.text.tx3g.Tx3gParser;
+import com.google.android.exoplayer.upstream.Allocator;
 import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.upstream.DefaultAllocator;
+import com.google.android.exoplayer.upstream.DefaultBandwidthMeter;
 import com.google.android.exoplayer.upstream.DefaultUriDataSource;
 
 import android.content.Context;
 import android.media.MediaCodec;
 import android.net.Uri;
-import android.widget.TextView;
 
 /**
  * A {@link RendererBuilder} for streams that can be read using an {@link Extractor}.
  */
 public class ExtractorRendererBuilder implements RendererBuilder {
 
-  private static final int BUFFER_SIZE = 10 * 1024 * 1024;
+  private static final int BUFFER_SEGMENT_SIZE = 64 * 1024;
+  private static final int BUFFER_SEGMENT_COUNT = 160;
 
   private final Context context;
   private final String userAgent;
   private final Uri uri;
-  private final TextView debugTextView;
   private final Extractor extractor;
 
-  public ExtractorRendererBuilder(Context context, String userAgent, Uri uri,
-      TextView debugTextView, Extractor extractor) {
+  public ExtractorRendererBuilder(Context context, String userAgent, Uri uri, Extractor extractor) {
     this.context = context;
     this.userAgent = userAgent;
     this.uri = uri;
-    this.debugTextView = debugTextView;
     this.extractor = extractor;
   }
 
   @Override
   public void buildRenderers(DemoPlayer player, RendererBuilderCallback callback) {
+    Allocator allocator = new DefaultAllocator(BUFFER_SEGMENT_SIZE);
+
     // Build the video and audio renderers.
-    DataSource dataSource = new DefaultUriDataSource(context, userAgent);
-    ExtractorSampleSource sampleSource = new ExtractorSampleSource(uri, dataSource, extractor, 2,
-        BUFFER_SIZE);
+    DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter(player.getMainHandler(),
+        null);
+    DataSource dataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
+    ExtractorSampleSource sampleSource = new ExtractorSampleSource(uri, dataSource, extractor,
+        allocator, BUFFER_SEGMENT_COUNT * BUFFER_SEGMENT_SIZE);
     MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(sampleSource,
         null, true, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000, null, player.getMainHandler(),
         player, 50);
     MediaCodecAudioTrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer(sampleSource,
         null, true, player.getMainHandler(), player);
-
-    // Build the debug renderer.
-    TrackRenderer debugRenderer = debugTextView != null
-        ? new DebugTrackRenderer(debugTextView, player, videoRenderer) : null;
+    TrackRenderer textRenderer = new TextTrackRenderer(sampleSource, player,
+        player.getMainHandler().getLooper(), new Tx3gParser());
 
     // Invoke the callback.
     TrackRenderer[] renderers = new TrackRenderer[DemoPlayer.RENDERER_COUNT];
     renderers[DemoPlayer.TYPE_VIDEO] = videoRenderer;
     renderers[DemoPlayer.TYPE_AUDIO] = audioRenderer;
-    renderers[DemoPlayer.TYPE_DEBUG] = debugRenderer;
-    callback.onRenderers(null, null, renderers);
+    renderers[DemoPlayer.TYPE_TEXT] = textRenderer;
+    callback.onRenderers(null, null, renderers, bandwidthMeter);
   }
 
 }
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
index 8eb762e218..454d4848c2 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer.demo.player;
 
+import com.google.android.exoplayer.DefaultLoadControl;
+import com.google.android.exoplayer.LoadControl;
 import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
 import com.google.android.exoplayer.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
@@ -32,6 +34,7 @@
 import com.google.android.exoplayer.metadata.MetadataTrackRenderer;
 import com.google.android.exoplayer.text.eia608.Eia608TrackRenderer;
 import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.upstream.DefaultAllocator;
 import com.google.android.exoplayer.upstream.DefaultBandwidthMeter;
 import com.google.android.exoplayer.upstream.DefaultUriDataSource;
 import com.google.android.exoplayer.util.ManifestFetcher;
@@ -40,7 +43,6 @@
 import android.content.Context;
 import android.media.MediaCodec;
 import android.os.Handler;
-import android.widget.TextView;
 
 import java.io.IOException;
 import java.util.Map;
@@ -50,24 +52,22 @@
  */
 public class HlsRendererBuilder implements RendererBuilder, ManifestCallback<HlsPlaylist> {
 
-  private static final int REQUESTED_BUFFER_SIZE = 18 * 1024 * 1024;
-  private static final long REQUESTED_BUFFER_DURATION_MS = 40000;
+  private static final int BUFFER_SEGMENT_SIZE = 256 * 1024;
+  private static final int BUFFER_SEGMENTS = 64;
 
   private final Context context;
   private final String userAgent;
   private final String url;
-  private final TextView debugTextView;
   private final AudioCapabilities audioCapabilities;
 
   private DemoPlayer player;
   private RendererBuilderCallback callback;
 
-  public HlsRendererBuilder(Context context, String userAgent, String url, TextView debugTextView,
+  public HlsRendererBuilder(Context context, String userAgent, String url,
       AudioCapabilities audioCapabilities) {
     this.context = context;
     this.userAgent = userAgent;
     this.url = url;
-    this.debugTextView = debugTextView;
     this.audioCapabilities = audioCapabilities;
   }
 
@@ -76,7 +76,7 @@ public void buildRenderers(DemoPlayer player, RendererBuilderCallback callback)
     this.player = player;
     this.callback = callback;
     HlsPlaylistParser parser = new HlsPlaylistParser();
-    ManifestFetcher<HlsPlaylist> playlistFetcher = new ManifestFetcher<HlsPlaylist>(url,
+    ManifestFetcher<HlsPlaylist> playlistFetcher = new ManifestFetcher<>(url,
         new DefaultUriDataSource(context, userAgent), parser);
     playlistFetcher.singleLoad(player.getMainHandler().getLooper(), this);
   }
@@ -89,6 +89,7 @@ public void onSingleManifestError(IOException e) {
   @Override
   public void onSingleManifest(HlsPlaylist manifest) {
     Handler mainHandler = player.getMainHandler();
+    LoadControl loadControl = new DefaultLoadControl(new DefaultAllocator(BUFFER_SEGMENT_SIZE));
     DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter();
 
     int[] variantIndices = null;
@@ -106,30 +107,24 @@ public void onSingleManifest(HlsPlaylist manifest) {
     DataSource dataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
     HlsChunkSource chunkSource = new HlsChunkSource(dataSource, url, manifest, bandwidthMeter,
         variantIndices, HlsChunkSource.ADAPTIVE_MODE_SPLICE, audioCapabilities);
-    HlsSampleSource sampleSource = new HlsSampleSource(chunkSource, true, 3, REQUESTED_BUFFER_SIZE,
-        REQUESTED_BUFFER_DURATION_MS, mainHandler, player, DemoPlayer.TYPE_VIDEO);
+    HlsSampleSource sampleSource = new HlsSampleSource(chunkSource, loadControl,
+        BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player, DemoPlayer.TYPE_VIDEO);
     MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(sampleSource,
         MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000, mainHandler, player, 50);
     MediaCodecAudioTrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer(sampleSource);
 
     MetadataTrackRenderer<Map<String, Object>> id3Renderer =
-        new MetadataTrackRenderer<Map<String, Object>>(sampleSource, new Id3Parser(),
-            player.getId3MetadataRenderer(), mainHandler.getLooper());
+        new MetadataTrackRenderer<>(sampleSource, new Id3Parser(), player, mainHandler.getLooper());
 
     Eia608TrackRenderer closedCaptionRenderer = new Eia608TrackRenderer(sampleSource, player,
         mainHandler.getLooper());
 
-    // Build the debug renderer.
-    TrackRenderer debugRenderer = debugTextView != null
-        ? new DebugTrackRenderer(debugTextView, player, videoRenderer) : null;
-
     TrackRenderer[] renderers = new TrackRenderer[DemoPlayer.RENDERER_COUNT];
     renderers[DemoPlayer.TYPE_VIDEO] = videoRenderer;
     renderers[DemoPlayer.TYPE_AUDIO] = audioRenderer;
-    renderers[DemoPlayer.TYPE_TIMED_METADATA] = id3Renderer;
+    renderers[DemoPlayer.TYPE_METADATA] = id3Renderer;
     renderers[DemoPlayer.TYPE_TEXT] = closedCaptionRenderer;
-    renderers[DemoPlayer.TYPE_DEBUG] = debugRenderer;
-    callback.onRenderers(null, null, renderers);
+    callback.onRenderers(null, null, renderers, bandwidthMeter);
   }
 
 }
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/SmoothStreamingRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/SmoothStreamingRendererBuilder.java
index ec4f35b019..faea15473a 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/SmoothStreamingRendererBuilder.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/SmoothStreamingRendererBuilder.java
@@ -32,6 +32,7 @@
 import com.google.android.exoplayer.drm.DrmSessionManager;
 import com.google.android.exoplayer.drm.MediaDrmCallback;
 import com.google.android.exoplayer.drm.StreamingDrmSessionManager;
+import com.google.android.exoplayer.drm.UnsupportedDrmException;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingChunkSource;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.StreamElement;
@@ -46,16 +47,12 @@
 import com.google.android.exoplayer.util.ManifestFetcher;
 import com.google.android.exoplayer.util.Util;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.media.MediaCodec;
-import android.media.UnsupportedSchemeException;
 import android.os.Handler;
-import android.widget.TextView;
 
 import java.io.IOException;
 import java.util.Arrays;
-import java.util.UUID;
 
 /**
  * A {@link RendererBuilder} for SmoothStreaming.
@@ -73,19 +70,17 @@
   private final String userAgent;
   private final String url;
   private final MediaDrmCallback drmCallback;
-  private final TextView debugTextView;
 
   private DemoPlayer player;
   private RendererBuilderCallback callback;
   private ManifestFetcher<SmoothStreamingManifest> manifestFetcher;
 
   public SmoothStreamingRendererBuilder(Context context, String userAgent, String url,
-      MediaDrmCallback drmCallback, TextView debugTextView) {
+      MediaDrmCallback drmCallback) {
     this.context = context;
     this.userAgent = userAgent;
     this.url = url;
     this.drmCallback = drmCallback;
-    this.debugTextView = debugTextView;
   }
 
   @Override
@@ -97,7 +92,7 @@ public void buildRenderers(DemoPlayer player, RendererBuilderCallback callback)
       manifestUrl += "/Manifest";
     }
     SmoothStreamingManifestParser parser = new SmoothStreamingManifestParser();
-    manifestFetcher = new ManifestFetcher<SmoothStreamingManifest>(manifestUrl,
+    manifestFetcher = new ManifestFetcher<>(manifestUrl,
         new DefaultHttpDataSource(userAgent, null), parser);
     manifestFetcher.singleLoad(player.getMainHandler().getLooper(), this);
   }
@@ -118,12 +113,12 @@ public void onSingleManifest(SmoothStreamingManifest manifest) {
     if (manifest.protectionElement != null) {
       if (Util.SDK_INT < 18) {
         callback.onRenderersError(
-            new UnsupportedDrmException(UnsupportedDrmException.REASON_NO_DRM));
+            new UnsupportedDrmException(UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME));
         return;
       }
       try {
-        drmSessionManager = V18Compat.getDrmSessionManager(manifest.protectionElement.uuid, player,
-            drmCallback);
+        drmSessionManager = new StreamingDrmSessionManager(manifest.protectionElement.uuid,
+            player.getPlaybackLooper(), drmCallback, null, player.getMainHandler(), player);
       } catch (UnsupportedDrmException e) {
         callback.onRenderersError(e);
         return;
@@ -159,10 +154,8 @@ public void onSingleManifest(SmoothStreamingManifest manifest) {
 
     // Build the video renderer.
     final MediaCodecVideoTrackRenderer videoRenderer;
-    final TrackRenderer debugRenderer;
     if (videoTrackIndices == null || videoTrackIndices.length == 0) {
       videoRenderer = null;
-      debugRenderer = null;
     } else {
       DataSource videoDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
       ChunkSource videoChunkSource = new SmoothStreamingChunkSource(manifestFetcher,
@@ -173,8 +166,6 @@ public void onSingleManifest(SmoothStreamingManifest manifest) {
           DemoPlayer.TYPE_VIDEO);
       videoRenderer = new MediaCodecVideoTrackRenderer(videoSampleSource, drmSessionManager, true,
           MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000, null, mainHandler, player, 50);
-      debugRenderer = debugTextView != null
-          ? new DebugTrackRenderer(debugTextView, player, videoRenderer) : null;
     }
 
     // Build the audio renderer.
@@ -252,25 +243,7 @@ public void onSingleManifest(SmoothStreamingManifest manifest) {
     renderers[DemoPlayer.TYPE_VIDEO] = videoRenderer;
     renderers[DemoPlayer.TYPE_AUDIO] = audioRenderer;
     renderers[DemoPlayer.TYPE_TEXT] = textRenderer;
-    renderers[DemoPlayer.TYPE_DEBUG] = debugRenderer;
-    callback.onRenderers(trackNames, multiTrackChunkSources, renderers);
-  }
-
-  @TargetApi(18)
-  private static class V18Compat {
-
-    public static DrmSessionManager getDrmSessionManager(UUID uuid, DemoPlayer player,
-        MediaDrmCallback drmCallback) throws UnsupportedDrmException {
-      try {
-        return new StreamingDrmSessionManager(uuid, player.getPlaybackLooper(), drmCallback, null,
-            player.getMainHandler(), player);
-      } catch (UnsupportedSchemeException e) {
-        throw new UnsupportedDrmException(UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME);
-      } catch (Exception e) {
-        throw new UnsupportedDrmException(UnsupportedDrmException.REASON_UNKNOWN, e);
-      }
-    }
-
+    callback.onRenderers(trackNames, multiTrackChunkSources, renderers, bandwidthMeter);
   }
 
 }
diff --git a/demo/src/main/res/layout/player_activity.xml b/demo/src/main/res/layout/player_activity.xml
index 2480897ca0..9b8925cce6 100644
--- a/demo/src/main/res/layout/player_activity.xml
+++ b/demo/src/main/res/layout/player_activity.xml
@@ -21,24 +21,26 @@
     android:layout_height="match_parent"
     android:keepScreenOn="true">
 
-  <com.google.android.exoplayer.VideoSurfaceView android:id="@+id/surface_view"
+  <com.google.android.exoplayer.AspectRatioFrameLayout android:id="@+id/video_frame"
       android:layout_width="match_parent"
       android:layout_height="match_parent"
-      android:layout_gravity="center"/>
+      android:layout_gravity="center">
 
-  <com.google.android.exoplayer.text.SubtitleView android:id="@+id/subtitles"
-      android:layout_width="wrap_content"
-      android:layout_height="wrap_content"
-      android:layout_gravity="bottom|center_horizontal"
-      android:layout_marginLeft="16dp"
-      android:layout_marginRight="16dp"
-      android:layout_marginBottom="32dp"
-      android:visibility="invisible"/>
+    <SurfaceView android:id="@+id/surface_view"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:layout_gravity="center"/>
 
-  <View android:id="@+id/shutter"
-      android:layout_width="match_parent"
-      android:layout_height="match_parent"
-      android:background="@android:color/black"/>
+    <com.google.android.exoplayer.text.SubtitleLayout android:id="@+id/subtitles"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"/>
+
+    <View android:id="@+id/shutter"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:background="@android:color/black"/>
+
+  </com.google.android.exoplayer.AspectRatioFrameLayout>
 
   <LinearLayout
       android:layout_width="match_parent"
diff --git a/demo_misc/webm_sw_decoder/README.md b/demo_misc/webm_sw_decoder/README.md
new file mode 100644
index 0000000000..4714d34084
--- /dev/null
+++ b/demo_misc/webm_sw_decoder/README.md
@@ -0,0 +1,5 @@
+# WebM (VP9/Opus) Software Decoder Demo #
+
+A demo app that shows how to use the ExoPlayer [VP9](../../extensions/vp9) and [Opus](../../extensions/opus) Extensions to enable VP9 and Opus playback in your app by bundling native libraries along with it.
+
+The demo app depends on the VP9 and Opus Extensions being configured built correctly.
diff --git a/demo_misc/webm_sw_decoder/build.gradle b/demo_misc/webm_sw_decoder/build.gradle
new file mode 100644
index 0000000000..7c57b342a7
--- /dev/null
+++ b/demo_misc/webm_sw_decoder/build.gradle
@@ -0,0 +1,40 @@
+// Copyright (C) 2014 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion 22
+    buildToolsVersion "22.0.1"
+
+    defaultConfig {
+        minSdkVersion 16
+        targetSdkVersion 22
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
+        }
+    }
+
+    lintOptions {
+        abortOnError false
+    }
+}
+
+dependencies {
+    compile project(':library')
+    compile project(':opus-extension')
+    compile project(':vp9-extension')
+}
diff --git a/demo_misc/webm_sw_decoder/src/main/.classpath b/demo_misc/webm_sw_decoder/src/main/.classpath
new file mode 100644
index 0000000000..be2dd156ff
--- /dev/null
+++ b/demo_misc/webm_sw_decoder/src/main/.classpath
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="src" path="java"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/demo_misc/webm_sw_decoder/src/main/.project b/demo_misc/webm_sw_decoder/src/main/.project
new file mode 100644
index 0000000000..4a01439be8
--- /dev/null
+++ b/demo_misc/webm_sw_decoder/src/main/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>ExoPlayerExt-WebMDemo</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/demo_misc/webm_sw_decoder/src/main/AndroidManifest.xml b/demo_misc/webm_sw_decoder/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..77da59ed7b
--- /dev/null
+++ b/demo_misc/webm_sw_decoder/src/main/AndroidManifest.xml
@@ -0,0 +1,57 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2014 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    package="com.google.android.exoplayer.demo.webm"
+    android:versionCode="1400"
+    android:versionName="1.4.0"
+    android:theme="@style/RootTheme">
+
+  <uses-permission android:name="android.permission.INTERNET"/>
+  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
+
+  <uses-feature android:glEsVersion="0x00020000"></uses-feature>
+
+  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="22"/>
+
+  <application
+      tools:ignore="UnusedAttribute"
+      android:label="@string/app_name"
+      android:largeHeap="true"
+      android:allowBackup="false"
+      android:icon="@drawable/ic_launcher">
+
+    <activity android:name="com.google.android.exoplayer.demo.webm.SampleChooserActivity"
+        android:label="@string/app_name"
+        android:configChanges="keyboardHidden">
+      <intent-filter>
+        <action android:name="android.intent.action.MAIN"/>
+        <category android:name="android.intent.category.LAUNCHER"/>
+      </intent-filter>
+    </activity>
+
+    <activity android:name="com.google.android.exoplayer.demo.webm.VideoPlayer"
+        android:configChanges="keyboardHidden|orientation|screenSize"
+        android:label="@string/app_name"
+        android:theme="@style/PlayerTheme"/>
+
+    <activity android:name="com.google.android.exoplayer.demo.webm.FilePickerActivity"
+        android:theme="@android:style/Theme.Dialog"/>
+
+  </application>
+
+</manifest>
diff --git a/demo_misc/webm_sw_decoder/src/main/java/com/google/android/exoplayer/demo/webm/DashRendererBuilder.java b/demo_misc/webm_sw_decoder/src/main/java/com/google/android/exoplayer/demo/webm/DashRendererBuilder.java
new file mode 100644
index 0000000000..afafc1e639
--- /dev/null
+++ b/demo_misc/webm_sw_decoder/src/main/java/com/google/android/exoplayer/demo/webm/DashRendererBuilder.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.demo.webm;
+
+import com.google.android.exoplayer.DefaultLoadControl;
+import com.google.android.exoplayer.LoadControl;
+import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
+import com.google.android.exoplayer.SampleSource;
+import com.google.android.exoplayer.TrackRenderer;
+import com.google.android.exoplayer.chunk.ChunkSampleSource;
+import com.google.android.exoplayer.chunk.ChunkSource;
+import com.google.android.exoplayer.chunk.FormatEvaluator;
+import com.google.android.exoplayer.chunk.FormatEvaluator.AdaptiveEvaluator;
+import com.google.android.exoplayer.chunk.MultiTrackChunkSource;
+import com.google.android.exoplayer.dash.DashChunkSource;
+import com.google.android.exoplayer.dash.mpd.AdaptationSet;
+import com.google.android.exoplayer.dash.mpd.MediaPresentationDescription;
+import com.google.android.exoplayer.dash.mpd.MediaPresentationDescriptionParser;
+import com.google.android.exoplayer.dash.mpd.Period;
+import com.google.android.exoplayer.dash.mpd.Representation;
+import com.google.android.exoplayer.ext.opus.LibopusAudioTrackRenderer;
+import com.google.android.exoplayer.ext.vp9.LibvpxVideoTrackRenderer;
+import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.upstream.DefaultAllocator;
+import com.google.android.exoplayer.upstream.DefaultBandwidthMeter;
+import com.google.android.exoplayer.upstream.DefaultHttpDataSource;
+import com.google.android.exoplayer.upstream.DefaultUriDataSource;
+import com.google.android.exoplayer.util.ManifestFetcher;
+import com.google.android.exoplayer.util.ManifestFetcher.ManifestCallback;
+import com.google.android.exoplayer.util.MimeTypes;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+/**
+ * Helper class that parses the manifest and builds the track renderers.
+ */
+public class DashRendererBuilder implements ManifestCallback<MediaPresentationDescription> {
+
+  private static final int BUFFER_SEGMENT_SIZE = 64 * 1024;
+  private static final int VIDEO_BUFFER_SEGMENTS = 200;
+  private static final int AUDIO_BUFFER_SEGMENTS = 60;
+
+  private final String manifestUrl;
+  private final String userAgent;
+  private final VideoPlayer player;
+
+  public DashRendererBuilder(String manifestUrl, String userAgent, VideoPlayer player) {
+    this.manifestUrl = manifestUrl;
+    this.userAgent = userAgent;
+    this.player = player;
+  }
+
+  public void build() {
+    MediaPresentationDescriptionParser parser = new MediaPresentationDescriptionParser();
+    ManifestFetcher<MediaPresentationDescription> manifestFetcher =
+        new ManifestFetcher<>(manifestUrl, new DefaultHttpDataSource(userAgent, null), parser);
+    manifestFetcher.singleLoad(player.getMainHandler().getLooper(), this);
+  }
+
+  @Override
+  public void onSingleManifestError(IOException e) {
+    // TODO: do something meaningful here.
+    e.printStackTrace();
+  }
+
+  @Override
+  public void onSingleManifest(MediaPresentationDescription manifest) {
+    LoadControl loadControl = new DefaultLoadControl(new DefaultAllocator(BUFFER_SEGMENT_SIZE));
+    DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter(null, null);
+
+    // Obtain Representations for playback.
+    ArrayList<Representation> audioRepresentationsList = new ArrayList<>();
+    ArrayList<Representation> videoRepresentationsList = new ArrayList<>();
+    Period period = manifest.periods.get(0);
+    for (int i = 0; i < period.adaptationSets.size(); i++) {
+      AdaptationSet adaptationSet = period.adaptationSets.get(i);
+      int adaptationSetType = adaptationSet.type;
+      for (int j = 0; j < adaptationSet.representations.size(); j++) {
+        Representation representation = adaptationSet.representations.get(j);
+        if (adaptationSetType == AdaptationSet.TYPE_AUDIO) {
+          audioRepresentationsList.add(representation);
+        } else if (adaptationSetType == AdaptationSet.TYPE_VIDEO) {
+          videoRepresentationsList.add(representation);
+        }
+      }
+    }
+    Representation[] videoRepresentations = new Representation[videoRepresentationsList.size()];
+    videoRepresentationsList.toArray(videoRepresentations);
+
+    // Build the video renderer.
+    LibvpxVideoTrackRenderer videoRenderer = null;
+    if (!videoRepresentationsList.isEmpty()) {
+      DataSource videoDataSource = new DefaultUriDataSource(player, bandwidthMeter, userAgent);
+      ChunkSource videoChunkSource;
+      String mimeType = videoRepresentations[0].format.mimeType;
+      if (mimeType.equals(MimeTypes.VIDEO_WEBM)) {
+        videoChunkSource = new DashChunkSource(videoDataSource,
+            new AdaptiveEvaluator(bandwidthMeter), videoRepresentations);
+      } else {
+        throw new IllegalStateException("Unexpected mime type: " + mimeType);
+      }
+      ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,
+          VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true);
+      videoRenderer = new LibvpxVideoTrackRenderer(videoSampleSource,
+          true, player.getMainHandler(), player, 50);
+    }
+
+    // Build the audio renderer.
+    MultiTrackChunkSource audioChunkSource = null;
+    TrackRenderer audioRenderer = null;
+    if (!audioRepresentationsList.isEmpty()) {
+      DataSource audioDataSource = new DefaultUriDataSource(player, bandwidthMeter, userAgent);
+      ChunkSource[] audioChunkSources = new ChunkSource[audioRepresentationsList.size()];
+      FormatEvaluator audioEvaluator = new FormatEvaluator.FixedEvaluator();
+      for (int i = 0; i < audioRepresentationsList.size(); i++) {
+        Representation representation = audioRepresentationsList.get(i);
+        audioChunkSources[i] = new DashChunkSource(audioDataSource,
+            audioEvaluator, representation);
+      }
+      audioChunkSource = new MultiTrackChunkSource(audioChunkSources);
+      SampleSource audioSampleSource = new ChunkSampleSource(audioChunkSource, loadControl,
+          AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true);
+      if (manifestUrl.contains("opus")) { // TODO: Need a better logic here.
+        audioRenderer = new LibopusAudioTrackRenderer(audioSampleSource);
+      } else {
+        audioRenderer = new MediaCodecAudioTrackRenderer(audioSampleSource);
+      }
+    }
+
+    TrackRenderer[] renderers = new TrackRenderer[(audioRenderer == null) ? 1 : 2];
+    renderers[0] = videoRenderer;
+    if (audioRenderer != null) {
+      renderers[1] = audioRenderer;
+    }
+    player.onRenderersBuilt(renderers);
+  }
+
+}
diff --git a/demo_misc/webm_sw_decoder/src/main/java/com/google/android/exoplayer/demo/webm/FilePickerActivity.java b/demo_misc/webm_sw_decoder/src/main/java/com/google/android/exoplayer/demo/webm/FilePickerActivity.java
new file mode 100644
index 0000000000..c7e5817d19
--- /dev/null
+++ b/demo_misc/webm_sw_decoder/src/main/java/com/google/android/exoplayer/demo/webm/FilePickerActivity.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.demo.webm;
+
+import android.app.Activity;
+import android.app.ListActivity;
+import android.content.Intent;
+import android.os.Bundle;
+import android.os.Environment;
+import android.view.View;
+import android.widget.ArrayAdapter;
+import android.widget.ListView;
+import android.widget.TextView;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * A simple file picker.
+ */
+public class FilePickerActivity extends ListActivity {
+
+  public static final String FILENAME_EXTRA_ID = "filename";
+
+  private List<String> listItems;
+  private List<File> itemPaths;
+  private TextView currentPathView;
+  private File root;
+
+  @Override
+  public void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.file_picker_activity);
+    setResult(Activity.RESULT_CANCELED);
+    currentPathView = (TextView) findViewById(R.id.path);
+    root = new File(Environment.getExternalStorageDirectory().getPath());
+    setDirectory(root);
+  }
+
+  private void setDirectory(File directory) {
+    currentPathView.setText(getString(R.string.current_path, directory.getAbsolutePath()));
+    listItems = new ArrayList<>();
+    itemPaths = new ArrayList<>();
+    File[] files = directory.listFiles();
+
+    if (!directory.getAbsolutePath().equals(root.getAbsolutePath())) {
+      listItems.add(root.getAbsolutePath());
+      itemPaths.add(root);
+      listItems.add("../");
+      itemPaths.add(new File(directory.getParent()));
+    }
+
+    if (files != null) {
+      for (File file : files) {
+        if (!file.isHidden() && file.canRead()) {
+          itemPaths.add(file);
+          if (file.isDirectory()) {
+            listItems.add(file.getName() + File.separator);
+          } else {
+            listItems.add(file.getName());
+          }
+        }
+      }
+    }
+
+    setListAdapter(new ArrayAdapter<>(this, R.layout.rows, listItems));
+  }
+
+  @Override
+  protected void onListItemClick(ListView l, View v, int position, long id) {
+    File file = itemPaths.get(position);
+    if (file.isDirectory() && file.canRead()) {
+      setDirectory(itemPaths.get(position));
+    } else {
+      Intent intent = new Intent();
+      intent.putExtra(FILENAME_EXTRA_ID, file.getAbsolutePath());
+      setResult(Activity.RESULT_OK, intent);
+      finish();
+    }
+  }
+}
diff --git a/demo_misc/webm_sw_decoder/src/main/java/com/google/android/exoplayer/demo/webm/SampleChooserActivity.java b/demo_misc/webm_sw_decoder/src/main/java/com/google/android/exoplayer/demo/webm/SampleChooserActivity.java
new file mode 100644
index 0000000000..7f1fa98e5f
--- /dev/null
+++ b/demo_misc/webm_sw_decoder/src/main/java/com/google/android/exoplayer/demo/webm/SampleChooserActivity.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.demo.webm;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AdapterView;
+import android.widget.AdapterView.OnItemClickListener;
+import android.widget.ArrayAdapter;
+import android.widget.ListView;
+import android.widget.TextView;
+
+/**
+ * An activity for selecting from a number of samples.
+ */
+public class SampleChooserActivity extends Activity {
+
+  @Override
+  public void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.sample_chooser_activity);
+
+    ListView sampleList = (ListView) findViewById(R.id.sample_list);
+    final SampleAdapter sampleAdapter = new SampleAdapter(this);
+
+    sampleAdapter.add(new Header("Local VP9 Video only"));
+    sampleAdapter.add(new Sample("S/W Color Conversion - upto 720p", false));
+    sampleAdapter.add(new Sample("OpenGL", true));
+    sampleAdapter.add(new Header("DASH - VP9 Only"));
+    sampleAdapter.add(new Sample("Google Glass",
+          "http://demos.webmproject.org/dash/201410/vp9_glass/manifest_vp9.mpd"));
+    sampleAdapter.add(new Header("DASH - VP9 and Opus"));
+    sampleAdapter.add(new Sample("Google Glass",
+          "http://demos.webmproject.org/dash/201410/vp9_glass/manifest_vp9_opus.mpd"));
+    sampleAdapter.add(new Header("DASH - VP9 and Vorbis"));
+    sampleAdapter.add(new Sample("Google Glass",
+          "http://demos.webmproject.org/dash/201410/vp9_glass/manifest_vp9_vorbis.mpd"));
+
+    sampleList.setAdapter(sampleAdapter);
+    sampleList.setOnItemClickListener(new OnItemClickListener() {
+      @Override
+      public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
+        Object item = sampleAdapter.getItem(position);
+        if (item instanceof Sample) {
+          onSampleSelected((Sample) item);
+        }
+      }
+    });
+  }
+
+  private void onSampleSelected(Sample sample) {
+    Intent playerIntent = new Intent(this, VideoPlayer.class)
+        .putExtra(VideoPlayer.DASH_MANIFEST_URL_ID_EXTRA, sample.uri)
+        .putExtra(VideoPlayer.USE_OPENGL_ID_EXTRA, sample.useOpenGL);
+    startActivity(playerIntent);
+  }
+
+  private static class SampleAdapter extends ArrayAdapter<Object> {
+
+    public SampleAdapter(Context context) {
+      super(context, 0);
+    }
+
+    @Override
+    public View getView(int position, View convertView, ViewGroup parent) {
+      View view = convertView;
+      if (view == null) {
+        int layoutId = getItemViewType(position) == 1 ? android.R.layout.simple_list_item_1
+            : R.layout.sample_chooser_inline_header;
+        view = LayoutInflater.from(getContext()).inflate(layoutId, null, false);
+      }
+      Object item = getItem(position);
+      String name = null;
+      if (item instanceof Sample) {
+        name = ((Sample) item).description;
+      } else if (item instanceof Header) {
+        name = ((Header) item).name;
+      }
+      ((TextView) view).setText(name);
+      return view;
+    }
+
+    @Override
+    public int getItemViewType(int position) {
+      return (getItem(position) instanceof Sample) ? 1 : 0;
+    }
+
+    @Override
+    public int getViewTypeCount() {
+      return 2;
+    }
+
+  }
+
+  private static class Sample {
+
+    public final String description;
+    public final String uri;
+    public final boolean useOpenGL;
+
+    public Sample(String description, boolean useOpenGL) {
+      this(description, null, useOpenGL);
+    }
+
+    public Sample(String description, String uri) {
+      this(description, uri, true); // always use OpenGL for DASH playbacks.
+    }
+
+    public Sample(String description, String uri, boolean useOpenGL) {
+      this.description = description;
+      this.uri = uri;
+      this.useOpenGL = useOpenGL;
+    }
+
+  }
+
+  private static class Header {
+
+    public final String name;
+
+    public Header(String name) {
+      this.name = name;
+    }
+
+  }
+
+}
diff --git a/demo_misc/webm_sw_decoder/src/main/java/com/google/android/exoplayer/demo/webm/VideoPlayer.java b/demo_misc/webm_sw_decoder/src/main/java/com/google/android/exoplayer/demo/webm/VideoPlayer.java
new file mode 100644
index 0000000000..01a6a0dd5c
--- /dev/null
+++ b/demo_misc/webm_sw_decoder/src/main/java/com/google/android/exoplayer/demo/webm/VideoPlayer.java
@@ -0,0 +1,286 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.demo.webm;
+
+import com.google.android.exoplayer.AspectRatioFrameLayout;
+import com.google.android.exoplayer.ExoPlaybackException;
+import com.google.android.exoplayer.ExoPlayer;
+import com.google.android.exoplayer.TrackRenderer;
+import com.google.android.exoplayer.ext.opus.LibopusAudioTrackRenderer;
+import com.google.android.exoplayer.ext.vp9.LibvpxVideoTrackRenderer;
+import com.google.android.exoplayer.ext.vp9.VpxDecoderException;
+import com.google.android.exoplayer.ext.vp9.VpxVideoSurfaceView;
+import com.google.android.exoplayer.extractor.ExtractorSampleSource;
+import com.google.android.exoplayer.extractor.webm.WebmExtractor;
+import com.google.android.exoplayer.upstream.DefaultAllocator;
+import com.google.android.exoplayer.upstream.DefaultUriDataSource;
+import com.google.android.exoplayer.util.PlayerControl;
+import com.google.android.exoplayer.util.Util;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.view.MotionEvent;
+import android.view.Surface;
+import android.view.SurfaceView;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.View.OnTouchListener;
+import android.widget.Button;
+import android.widget.MediaController;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import java.io.File;
+
+/**
+ * Sample player that shows how to use ExoPlayer Extensions to playback VP9 Video and Opus Audio.
+ */
+public class VideoPlayer extends Activity implements OnClickListener,
+       LibvpxVideoTrackRenderer.EventListener, ExoPlayer.Listener {
+
+  public static final String DASH_MANIFEST_URL_ID_EXTRA = "manifest_url";
+  public static final String USE_OPENGL_ID_EXTRA = "use_opengl";
+
+  private static final int FILE_PICKER_REQUEST = 1;
+  private static final int BUFFER_SEGMENT_SIZE = 64 * 1024;
+  private static final int BUFFER_SEGMENT_COUNT = 160;
+
+
+  private boolean isDash;
+  private String manifestUrl;
+  private boolean useOpenGL;
+  private String filename;
+
+  private ExoPlayer player;
+  private Handler handler;
+  private MediaController mediaController;
+  private AspectRatioFrameLayout videoFrame;
+  private SurfaceView surfaceView;
+  private VpxVideoSurfaceView vpxVideoSurfaceView;
+  private TextView debugInfoView;
+  private TextView playerStateView;
+
+  @Override
+  public void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+
+    Intent intent = getIntent();
+    manifestUrl = intent.getStringExtra(DASH_MANIFEST_URL_ID_EXTRA);
+    isDash = manifestUrl != null;
+    useOpenGL = intent.getBooleanExtra(USE_OPENGL_ID_EXTRA, true);
+
+    handler = new Handler();
+
+    setContentView(R.layout.activity_video_player);
+    View root = findViewById(R.id.root);
+    root.setOnTouchListener(new OnTouchListener() {
+      @Override
+      public boolean onTouch(View view, MotionEvent motionEvent) {
+        if (motionEvent.getAction() == MotionEvent.ACTION_DOWN) {
+          toggleControlsVisibility();
+        } else if (motionEvent.getAction() == MotionEvent.ACTION_UP) {
+          view.performClick();
+        }
+        return true;
+      }
+    });
+
+    mediaController = new MediaController(this);
+    mediaController.setAnchorView(root);
+    videoFrame = (AspectRatioFrameLayout) findViewById(R.id.video_frame);
+    surfaceView = (SurfaceView) findViewById(R.id.surface_view);
+    vpxVideoSurfaceView = (VpxVideoSurfaceView) findViewById(R.id.vpx_surface_view);
+    debugInfoView = (TextView) findViewById(R.id.debug_info);
+    playerStateView = (TextView) findViewById(R.id.player_state);
+
+    // Set the buttons' onclick listeners.
+    ((Button) findViewById(R.id.choose_file)).setOnClickListener(this);
+    ((Button) findViewById(R.id.play)).setOnClickListener(this);
+
+    // In case of DASH, start playback right away.
+    if (isDash) {
+      findViewById(R.id.buttons).setVisibility(View.GONE);
+      ((TextView) findViewById(R.id.filename)).setVisibility(View.GONE);
+      startDashPlayback();
+    }
+  }
+
+  @Override
+  public void onPause() {
+    super.onPause();
+    stopPlayback();
+  }
+
+  @Override
+  public void onClick(View v) {
+    switch (v.getId()) {
+      case R.id.choose_file:
+        Intent intent = new Intent();
+        intent.setClass(this, FilePickerActivity.class);
+        startActivityForResult(intent, FILE_PICKER_REQUEST);
+        break;
+      case R.id.play:
+        startBasicPlayback();
+        break;
+    }
+  }
+
+  @Override
+  protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+    switch (requestCode) {
+      case FILE_PICKER_REQUEST:
+        if (resultCode == Activity.RESULT_OK) {
+          filename = data.getStringExtra(FilePickerActivity.FILENAME_EXTRA_ID);
+          ((TextView) findViewById(R.id.filename)).setText(
+              getString(R.string.current_path, filename));
+        }
+        break;
+    }
+  }
+
+  private void startBasicPlayback() {
+    if (filename == null) {
+      Toast.makeText(this, "Choose a file!", Toast.LENGTH_SHORT).show();
+      return;
+    }
+    findViewById(R.id.buttons).setVisibility(View.GONE);
+    player = ExoPlayer.Factory.newInstance(2);
+    player.addListener(this);
+    mediaController.setMediaPlayer(new PlayerControl(player));
+    mediaController.setEnabled(true);
+    ExtractorSampleSource sampleSource = new ExtractorSampleSource(
+        Uri.fromFile(new File(filename)),
+        new DefaultUriDataSource(this, Util.getUserAgent(this, "ExoPlayerExtWebMDemo")),
+        new WebmExtractor(), new DefaultAllocator(BUFFER_SEGMENT_SIZE),
+        BUFFER_SEGMENT_SIZE * BUFFER_SEGMENT_COUNT);
+    TrackRenderer videoRenderer =
+        new LibvpxVideoTrackRenderer(sampleSource, true, handler, this, 50);
+    if (useOpenGL) {
+      player.sendMessage(videoRenderer, LibvpxVideoTrackRenderer.MSG_SET_VPX_SURFACE_VIEW,
+          vpxVideoSurfaceView);
+      surfaceView.setVisibility(View.GONE);
+    } else {
+      player.sendMessage(
+          videoRenderer, LibvpxVideoTrackRenderer.MSG_SET_SURFACE,
+          surfaceView.getHolder().getSurface());
+      vpxVideoSurfaceView.setVisibility(View.GONE);
+    }
+    TrackRenderer audioRenderer = new LibopusAudioTrackRenderer(sampleSource);
+    player.prepare(videoRenderer, audioRenderer);
+    player.setPlayWhenReady(true);
+  }
+
+  private void startDashPlayback() {
+    playerStateView.setText("Initializing");
+    final String userAgent = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like"
+        + " Gecko) Chrome/38.0.2125.104 Safari/537.36";
+    DashRendererBuilder rendererBuilder = new DashRendererBuilder(manifestUrl, userAgent, this);
+    rendererBuilder.build();
+  }
+
+  public void onRenderersBuilt(TrackRenderer[] renderers) {
+    surfaceView.setVisibility(View.GONE);
+    player = ExoPlayer.Factory.newInstance(renderers.length);
+    player.addListener(this);
+    mediaController.setMediaPlayer(new PlayerControl(player));
+    mediaController.setEnabled(true);
+    player.sendMessage(renderers[0], LibvpxVideoTrackRenderer.MSG_SET_VPX_SURFACE_VIEW,
+        vpxVideoSurfaceView);
+    player.prepare(renderers);
+    player.setPlayWhenReady(true);
+  }
+
+  @Override
+  public void onDroppedFrames(int count, long elapsed) {
+    // do nothing.
+  }
+
+  @Override
+  public void onVideoSizeChanged(int width, int height) {
+    videoFrame.setAspectRatio(height == 0 ? 1 : (width * 1.0f) / height);
+    debugInfoView.setText("Video: " + width + " x " + height);
+  }
+
+  @Override
+  public void onDrawnToSurface(Surface surface) {
+    // do nothing.
+  }
+
+  @Override
+  public void onDecoderError(VpxDecoderException e) {
+    debugInfoView.setText("Libvpx decode failure. Giving up.");
+  }
+
+  @Override
+  public void onPlayerStateChanged(boolean playWhenReady, int state) {
+    String playerState = "";
+    switch (player.getPlaybackState()) {
+      case ExoPlayer.STATE_BUFFERING:
+        playerState = "buffering";
+        break;
+      case ExoPlayer.STATE_ENDED:
+        playerState = "ended";
+        break;
+      case ExoPlayer.STATE_IDLE:
+        playerState = "idle";
+        break;
+      case ExoPlayer.STATE_PREPARING:
+        playerState = "preparing";
+        break;
+      case ExoPlayer.STATE_READY:
+        playerState = "ready";
+        break;
+    }
+    playerStateView.setText("Player State: " + playerState);
+  }
+
+  @Override
+  public void onPlayerError(ExoPlaybackException exception) {
+    debugInfoView.setText("Exoplayer Playback error. Giving up.");
+    // TODO: show a retry button here.
+  }
+
+  @Override
+  public void onPlayWhenReadyCommitted() {
+    // Do nothing.
+  }
+
+  public Handler getMainHandler() {
+    return handler;
+  }
+
+  private void stopPlayback() {
+    if (player != null) {
+      player.stop();
+      player.release();
+      player = null;
+    }
+  }
+
+  private void toggleControlsVisibility()  {
+    if (mediaController != null) {
+      if (mediaController.isShowing()) {
+        mediaController.hide();
+      } else {
+        mediaController.show(0);
+      }
+    }
+  }
+
+}
diff --git a/demo_misc/webm_sw_decoder/src/main/project.properties b/demo_misc/webm_sw_decoder/src/main/project.properties
new file mode 100644
index 0000000000..ca0c2d0867
--- /dev/null
+++ b/demo_misc/webm_sw_decoder/src/main/project.properties
@@ -0,0 +1,17 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-22
+android.library.reference.1=../../../../library/src/main
+android.library.reference.2=../../../../extensions/opus/src/main
+android.library.reference.3=../../../../extensions/vp9/src/main
diff --git a/demo_misc/webm_sw_decoder/src/main/res/drawable-hdpi/ic_launcher.png b/demo_misc/webm_sw_decoder/src/main/res/drawable-hdpi/ic_launcher.png
new file mode 100644
index 0000000000..3e5716b8ad
Binary files /dev/null and b/demo_misc/webm_sw_decoder/src/main/res/drawable-hdpi/ic_launcher.png differ
diff --git a/demo_misc/webm_sw_decoder/src/main/res/drawable-mdpi/ic_launcher.png b/demo_misc/webm_sw_decoder/src/main/res/drawable-mdpi/ic_launcher.png
new file mode 100644
index 0000000000..a5d2a53b13
Binary files /dev/null and b/demo_misc/webm_sw_decoder/src/main/res/drawable-mdpi/ic_launcher.png differ
diff --git a/demo_misc/webm_sw_decoder/src/main/res/drawable-xhdpi/ic_launcher.png b/demo_misc/webm_sw_decoder/src/main/res/drawable-xhdpi/ic_launcher.png
new file mode 100644
index 0000000000..1d00268635
Binary files /dev/null and b/demo_misc/webm_sw_decoder/src/main/res/drawable-xhdpi/ic_launcher.png differ
diff --git a/demo_misc/webm_sw_decoder/src/main/res/drawable-xxhdpi/ic_launcher.png b/demo_misc/webm_sw_decoder/src/main/res/drawable-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..ef2f312fd4
Binary files /dev/null and b/demo_misc/webm_sw_decoder/src/main/res/drawable-xxhdpi/ic_launcher.png differ
diff --git a/demo_misc/webm_sw_decoder/src/main/res/drawable-xxxhdpi/ic_launcher.png b/demo_misc/webm_sw_decoder/src/main/res/drawable-xxxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..0acebb43c1
Binary files /dev/null and b/demo_misc/webm_sw_decoder/src/main/res/drawable-xxxhdpi/ic_launcher.png differ
diff --git a/demo_misc/webm_sw_decoder/src/main/res/layout/activity_video_player.xml b/demo_misc/webm_sw_decoder/src/main/res/layout/activity_video_player.xml
new file mode 100644
index 0000000000..f6f841b014
--- /dev/null
+++ b/demo_misc/webm_sw_decoder/src/main/res/layout/activity_video_player.xml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2014 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/root"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical"
+    android:keepScreenOn="true">
+
+  <com.google.android.exoplayer.AspectRatioFrameLayout android:id="@+id/video_frame"
+      android:layout_width="match_parent"
+      android:layout_height="match_parent"
+      android:layout_gravity="center">
+
+    <SurfaceView
+        android:id="@+id/surface_view"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:layout_gravity="center|center_vertical"/>
+
+    <com.google.android.exoplayer.ext.vp9.VpxVideoSurfaceView
+        android:id="@+id/vpx_surface_view"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:layout_gravity="center|center_vertical"/>
+
+  </com.google.android.exoplayer.AspectRatioFrameLayout>
+
+  <LinearLayout
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:orientation="vertical"
+      android:background="#88000000">
+
+    <LinearLayout
+        android:id="@+id/buttons"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content">
+
+      <Button
+          android:id="@+id/choose_file"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:text="@string/choose_file"/>
+
+      <Button
+          android:id="@+id/play"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:text="@string/play"/>
+
+    </LinearLayout>
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content">
+
+      <TextView
+          android:id="@+id/filename"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"
+          android:paddingRight="10dp"/>
+
+      <TextView
+          android:id="@+id/player_state"
+          android:paddingRight="10dp"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"/>
+
+      <TextView
+          android:id="@+id/debug_info"
+          android:layout_width="wrap_content"
+          android:layout_height="wrap_content"/>
+
+    </LinearLayout>
+
+  </LinearLayout>
+
+</FrameLayout>
diff --git a/demo_misc/webm_sw_decoder/src/main/res/layout/file_picker_activity.xml b/demo_misc/webm_sw_decoder/src/main/res/layout/file_picker_activity.xml
new file mode 100644
index 0000000000..a478458d9a
--- /dev/null
+++ b/demo_misc/webm_sw_decoder/src/main/res/layout/file_picker_activity.xml
@@ -0,0 +1,32 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2014 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical">
+
+    <TextView
+        android:id="@+id/path"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"/>
+
+    <ListView
+        android:id="@android:id/list"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"/>
+
+</LinearLayout>
diff --git a/demo_misc/webm_sw_decoder/src/main/res/layout/rows.xml b/demo_misc/webm_sw_decoder/src/main/res/layout/rows.xml
new file mode 100644
index 0000000000..e645abd266
--- /dev/null
+++ b/demo_misc/webm_sw_decoder/src/main/res/layout/rows.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2014 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<TextView xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/rowtext"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:textSize="25sp"/>
diff --git a/demo_misc/webm_sw_decoder/src/main/res/layout/sample_chooser_activity.xml b/demo_misc/webm_sw_decoder/src/main/res/layout/sample_chooser_activity.xml
new file mode 100644
index 0000000000..ae9be53796
--- /dev/null
+++ b/demo_misc/webm_sw_decoder/src/main/res/layout/sample_chooser_activity.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- Copyright (C) 2014 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical">
+
+  <ListView android:id="@+id/sample_list"
+      android:layout_width="match_parent"
+      android:layout_height="match_parent"/>
+
+</LinearLayout>
diff --git a/demo_misc/webm_sw_decoder/src/main/res/layout/sample_chooser_inline_header.xml b/demo_misc/webm_sw_decoder/src/main/res/layout/sample_chooser_inline_header.xml
new file mode 100644
index 0000000000..8df32d76a1
--- /dev/null
+++ b/demo_misc/webm_sw_decoder/src/main/res/layout/sample_chooser_inline_header.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- Copyright (C) 2014 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<TextView xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:textStyle="bold"
+    android:textAllCaps="true"
+    android:textColor="@android:color/white"
+    android:textSize="14sp"
+    android:padding="8dp"
+    android:focusable="true"
+    android:background="#339999FF"/>
diff --git a/demo_misc/webm_sw_decoder/src/main/res/values-v11/styles.xml b/demo_misc/webm_sw_decoder/src/main/res/values-v11/styles.xml
new file mode 100644
index 0000000000..b7b29d5e5c
--- /dev/null
+++ b/demo_misc/webm_sw_decoder/src/main/res/values-v11/styles.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2014 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android">
+
+  <style name="RootTheme" parent="android:Theme.Holo"/>
+
+</resources>
diff --git a/demo_misc/webm_sw_decoder/src/main/res/values/strings.xml b/demo_misc/webm_sw_decoder/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..45c9da513c
--- /dev/null
+++ b/demo_misc/webm_sw_decoder/src/main/res/values/strings.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2014 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+
+  <string name="app_name">WebM ExoPlayer Demo</string>
+  <string name="choose_file">Choose File</string>
+  <string name="play">Play</string>
+  <string name="current_path">
+    Path: <xliff:g id="path" example="/sdcard/test.webm">%1$s</xliff:g>
+  </string>
+
+</resources>
diff --git a/demo_misc/webm_sw_decoder/src/main/res/values/styles.xml b/demo_misc/webm_sw_decoder/src/main/res/values/styles.xml
new file mode 100644
index 0000000000..bdae888f4d
--- /dev/null
+++ b/demo_misc/webm_sw_decoder/src/main/res/values/styles.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2014 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android">
+
+  <style name="RootTheme" parent="android:Theme"/>
+
+  <style name="PlayerTheme" parent="@style/RootTheme">
+    <item name="android:windowNoTitle">true</item>
+    <item name="android:windowBackground">@android:color/black</item>
+  </style>
+
+</resources>
diff --git a/extensions/opus/README.md b/extensions/opus/README.md
new file mode 100644
index 0000000000..661aed2cf2
--- /dev/null
+++ b/extensions/opus/README.md
@@ -0,0 +1,131 @@
+# ExoPlayer Opus Extension #
+
+## Description ##
+
+The Opus Extension is a [Track Renderer][] implementation that helps you bundle libopus (the Opus decoding library) into your app and use it along with ExoPlayer to play Opus audio on Android devices.
+
+[Track Renderer]: http://google.github.io/ExoPlayer/doc/reference/com/google/android/exoplayer/TrackRenderer.html
+
+## Build Instructions (Android Studio and Eclipse) ##
+
+Building the Opus Extension involves building libopus and JNI bindings using the Android NDK and linking it into your app. The following steps will tell you how to do that using Android Studio or Eclipse.
+
+* Checkout ExoPlayer along with Extensions
+
+```
+git clone https://github.com/google/ExoPlayer.git
+```
+
+* Set the following environment variables:
+
+```
+cd "<path to exoplayer checkout>"
+EXOPLAYER_ROOT="$(pwd)"
+OPUS_EXT_PATH="${EXOPLAYER_ROOT}/extensions/opus/src/main"
+```
+
+* Download the [Android NDK][] and set its location in an environment variable:
+
+```
+NDK_PATH="<path to Android NDK>"
+```
+
+* Fetch libopus
+
+```
+cd "${OPUS_EXT_PATH}/jni" && \
+git clone git://git.opus-codec.org/opus.git libopus
+```
+
+* Run the script to convert arm assembly to NDK compatible format
+
+```
+cd ${OPUS_EXT_PATH}/jni && ./convert_android_asm.sh
+```
+
+### Android Studio ###
+
+For Android Studio, we build the native libraries from the command line and then Gradle will pick it up when building your app using Android Studio.
+
+* Build the JNI native libraries
+
+```
+cd "${OPUS_EXT_PATH}"/jni && \
+${NDK_PATH}/ndk-build APP_ABI=all -j4
+```
+
+* In your project, you can add a dependency to the Opus Extension by using a rule like this:
+
+```
+// in settings.gradle
+include ':..:ExoPlayer:library'
+include ':..:ExoPlayer:opus-extension'
+
+// in build.gradle
+dependencies {
+    compile project(':..:ExoPlayer:library')
+    compile project(':..:ExoPlayer:opus-extension')
+}
+```
+
+* Now, when you build your app, the Opus extension will be built and the native libraries will be packaged along with the APK.
+
+### Eclipse ###
+
+* The following steps assume that you have installed Eclipse and configured it with the [Android SDK][] and [Android NDK ][]:
+  * Navigate to File->Import->General->Existing Projects into Workspace
+  * Select the root directory of the repository
+  * Import the following projects:
+    * ExoPlayerLib
+    * ExoPlayerExt-Opus
+    * If you are able to build ExoPlayerExt-Opus project, then you're all set.
+    * (Optional) To speed up the NDK build:
+      * Right click on ExoPlayerExt-Opus in the Project Explorer pane and choose Properties
+      * Click on C/C++ Build
+      * Uncheck `Use default build command`
+      * In `Build Command` enter: `ndk-build -j4` (adjust 4 to a reasonable number depending on the number of cores in your computer)
+      * Click Apply
+
+You can now create your own Android App project and add ExoPlayerLib along with ExoPlayerExt-Opus as a dependencies to use ExoPlayer along with the Opus Extension.
+
+
+[Android NDK]: https://developer.android.com/tools/sdk/ndk/index.html
+<!---
+Work around to point to two different links for the same text.
+-->
+[Android NDK ]: http://tools.android.com/recent/usingthendkplugin
+[Android SDK]: http://developer.android.com/sdk/installing/index.html?pkg=tools
+
+## Building for various Architectures ##
+
+### Android Studio ###
+
+The manual invocation of `ndk-build` will build the library for all architectures and the correct one will be picked up from the APK based on the device its running on.
+
+### Eclipse  ###
+
+libopus can be built for the following architectures:
+
+* armeabi (the default - does not include neon optimizations)
+* armeabi-v7a (choose this to enable neon optimizations)
+* mips
+* x86
+* all (will result in a larger binary but will cover all architectures)
+
+You can build for a specific architecture in two ways:
+
+* Method 1 (edit `Application.mk`)
+  * Edit `${OPUS_EXT_PATH}/jni/Application.mk` and add the following line `APP_ABI := <arch>` (where `<arch>` is one of the above 4 architectures)
+* Method 2 (pass NDK build flag)
+  * Right click on ExoPlayerExt-Opus in the Project Explorer pane and choose Properties
+  * Click on C/C++ Build
+  * Uncheck `Use default build command`
+  * In `Build Command` enter: `ndk-build APP_ABI=<arch>` (where `<arch>` is one of the above 4 architectures)
+  * Click Apply
+
+## Other Things to Note ##
+
+* Every time there is a change to the libopus checkout:
+  * Arm assembly should be converted by running `convert_android_asm.sh`
+  * Clean and re-build the project.
+* If you want to use your own version of libopus, place it in `${OPUS_EXT_PATH}/jni/libopus`.
diff --git a/extensions/opus/build.gradle b/extensions/opus/build.gradle
new file mode 100644
index 0000000000..443d0d6601
--- /dev/null
+++ b/extensions/opus/build.gradle
@@ -0,0 +1,45 @@
+// Copyright (C) 2014 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion 22
+    buildToolsVersion "22.0.1"
+
+    defaultConfig {
+        minSdkVersion 9
+        targetSdkVersion 22
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
+        }
+    }
+
+    lintOptions {
+        abortOnError false
+    }
+
+    sourceSets.main {
+        jniLibs.srcDir 'src/main/libs'
+        jni.srcDirs = [] // Disable the automatic ndk-build call by Android Studio.
+    }
+}
+
+dependencies {
+    compile project(':library')
+}
+
diff --git a/extensions/opus/src/main/.classpath b/extensions/opus/src/main/.classpath
new file mode 100644
index 0000000000..503bb38b67
--- /dev/null
+++ b/extensions/opus/src/main/.classpath
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="src" path="java"/>
+	<classpathentry kind="src" path="/ExoPlayerLib"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/extensions/opus/src/main/.cproject b/extensions/opus/src/main/.cproject
new file mode 100644
index 0000000000..22cc11ab57
--- /dev/null
+++ b/extensions/opus/src/main/.cproject
@@ -0,0 +1,57 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<?fileVersion 4.0.0?><cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptionStorage">
+	<storageModule moduleId="org.eclipse.cdt.core.settings">
+		<cconfiguration id="com.android.toolchain.gcc.423224913">
+			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="com.android.toolchain.gcc.423224913" moduleId="org.eclipse.cdt.core.settings" name="Default">
+				<externalSettings/>
+				<extensions>
+					<extension id="org.eclipse.cdt.core.VCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GmakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.CWDLocator" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.MakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GCCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GASErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GLDErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.ELF" point="org.eclipse.cdt.core.BinaryParser"/>
+				</extensions>
+			</storageModule>
+			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+				<configuration artifactName="${ProjName}" buildProperties="" description="" id="com.android.toolchain.gcc.423224913" name="Default" parent="org.eclipse.cdt.build.core.emptycfg">
+					<folderInfo id="com.android.toolchain.gcc.423224913.1376674556" name="/" resourcePath="">
+						<toolChain id="com.android.toolchain.gcc.1798416430" name="Android GCC" superClass="com.android.toolchain.gcc">
+							<targetPlatform binaryParser="org.eclipse.cdt.core.ELF" id="com.android.targetPlatform.1132129264" isAbstract="false" superClass="com.android.targetPlatform"/>
+							<builder buildPath="${workspace_loc:/ExoPlayerExt-Opus}/jni" id="com.android.builder.532503968" keepEnvironmentInBuildfile="false" managedBuildOn="false" name="Android Builder" superClass="com.android.builder">
+								<outputEntries>
+									<entry flags="VALUE_WORKSPACE_PATH|RESOLVED" kind="outputPath" name="obj"/>
+									<entry flags="VALUE_WORKSPACE_PATH|RESOLVED" kind="outputPath" name="libs"/>
+								</outputEntries>
+							</builder>
+							<tool id="com.android.gcc.compiler.906450637" name="Android GCC Compiler" superClass="com.android.gcc.compiler">
+								<inputType id="com.android.gcc.inputType.835889068" superClass="com.android.gcc.inputType"/>
+							</tool>
+						</toolChain>
+					</folderInfo>
+					<sourceEntries>
+						<entry flags="VALUE_WORKSPACE_PATH|RESOLVED" kind="sourcePath" name="jni"/>
+					</sourceEntries>
+				</configuration>
+			</storageModule>
+			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
+		</cconfiguration>
+	</storageModule>
+	<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+		<project id="ExoPlayerExt-Opus.null.1840202624" name="ExoPlayerExt-Opus"/>
+	</storageModule>
+	<storageModule moduleId="org.eclipse.cdt.core.LanguageSettingsProviders"/>
+	<storageModule moduleId="scannerConfiguration">
+		<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId=""/>
+		<scannerConfigBuildInfo instanceId="com.android.toolchain.gcc.423224913;com.android.toolchain.gcc.423224913.1376674556;com.android.gcc.compiler.906450637;com.android.gcc.inputType.835889068">
+			<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId="com.android.AndroidPerProjectProfile"/>
+		</scannerConfigBuildInfo>
+	</storageModule>
+	<storageModule moduleId="refreshScope" versionNumber="2">
+		<configuration configurationName="Default">
+			<resource resourceType="PROJECT" workspacePath="/ExoPlayerExt-Opus"/>
+		</configuration>
+	</storageModule>
+</cproject>
diff --git a/extensions/opus/src/main/.project b/extensions/opus/src/main/.project
new file mode 100644
index 0000000000..9b65339b9c
--- /dev/null
+++ b/extensions/opus/src/main/.project
@@ -0,0 +1,97 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>ExoPlayerExt-Opus</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
+			<triggers>clean,full,incremental,</triggers>
+			<arguments>
+				<dictionary>
+					<key>?children?</key>
+					<value>?name?=outputEntries\|?children?=?name?=entry\\\\\\\|\\\|?name?=entry\\\\\\\|\\\|\||</value>
+				</dictionary>
+				<dictionary>
+					<key>?name?</key>
+					<value></value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.append_environment</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildArguments</key>
+					<value></value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildCommand</key>
+					<value>ndk-build</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.cleanBuildTarget</key>
+					<value>clean</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.contents</key>
+					<value>org.eclipse.cdt.make.core.activeConfigSettings</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableAutoBuild</key>
+					<value>false</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableCleanBuild</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableFullBuild</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.stopOnError</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.useDefaultBuildCmd</key>
+					<value>true</value>
+				</dictionary>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</name>
+			<triggers>full,incremental,</triggers>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+		<nature>org.eclipse.cdt.core.cnature</nature>
+		<nature>org.eclipse.cdt.core.ccnature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
+	</natures>
+</projectDescription>
diff --git a/extensions/opus/src/main/.settings/org.eclipse.jdt.core.prefs b/extensions/opus/src/main/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000000..d17b6724d1
--- /dev/null
+++ b/extensions/opus/src/main/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,12 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.methodParameters=do not generate
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.7
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.7
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.7
diff --git a/extensions/opus/src/main/AndroidManifest.xml b/extensions/opus/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..22c75aa76b
--- /dev/null
+++ b/extensions/opus/src/main/AndroidManifest.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2014 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.google.android.exoplayer.ext.opus">
+
+    <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="22"/>
+
+</manifest>
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
new file mode 100644
index 0000000000..96ce46f4f2
--- /dev/null
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
@@ -0,0 +1,447 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.opus;
+
+import com.google.android.exoplayer.ExoPlaybackException;
+import com.google.android.exoplayer.ExoPlayer;
+import com.google.android.exoplayer.MediaClock;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.MediaFormatHolder;
+import com.google.android.exoplayer.SampleSource;
+import com.google.android.exoplayer.SampleSource.SampleSourceReader;
+import com.google.android.exoplayer.TrackRenderer;
+import com.google.android.exoplayer.audio.AudioTrack;
+import com.google.android.exoplayer.ext.opus.OpusDecoderWrapper.InputBuffer;
+import com.google.android.exoplayer.ext.opus.OpusDecoderWrapper.OutputBuffer;
+import com.google.android.exoplayer.util.MimeTypes;
+
+import android.os.Handler;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.List;
+
+/**
+ * Decodes and renders audio using the native Opus decoder.
+ *
+ * @author vigneshv@google.com (Vignesh Venkatasubramanian)
+ */
+public class LibopusAudioTrackRenderer extends TrackRenderer implements MediaClock {
+
+  /**
+   * Interface definition for a callback to be notified of {@link LibopusAudioTrackRenderer} events.
+   */
+  public interface EventListener {
+
+    /**
+     * Invoked when the {@link AudioTrack} fails to initialize.
+     *
+     * @param e The corresponding exception.
+     */
+    void onAudioTrackInitializationError(AudioTrack.InitializationException e);
+
+    /**
+     * Invoked when an {@link AudioTrack} write fails.
+     *
+     * @param e The corresponding exception.
+     */
+    void onAudioTrackWriteError(AudioTrack.WriteException e);
+
+    /**
+     * Invoked when decoding fails.
+     *
+     * @param e The corresponding exception.
+     */
+    void onDecoderError(OpusDecoderException e);
+
+  }
+
+  /**
+   * The type of a message that can be passed to an instance of this class via
+   * {@link ExoPlayer#sendMessage} or {@link ExoPlayer#blockingSendMessage}. The message object
+   * should be a {@link Float} with 0 being silence and 1 being unity gain.
+   */
+  public static final int MSG_SET_VOLUME = 1;
+
+  private final SampleSourceReader source;
+  private final Handler eventHandler;
+  private final EventListener eventListener;
+  private final MediaFormatHolder formatHolder;
+
+  private MediaFormat format;
+  private OpusDecoderWrapper decoder;
+  private InputBuffer inputBuffer;
+  private OutputBuffer outputBuffer;
+
+  private int trackIndex;
+  private long currentPositionUs;
+  private boolean allowPositionDiscontinuity;
+  private boolean inputStreamEnded;
+  private boolean outputStreamEnded;
+  private boolean sourceIsReady;
+  private boolean notifyDiscontinuityToDecoder;
+
+  private AudioTrack audioTrack;
+  private int audioSessionId;
+
+  /**
+   * @param source The upstream source from which the renderer obtains samples.
+   */
+  public LibopusAudioTrackRenderer(SampleSource source) {
+    this(source, null, null);
+  }
+
+  /**
+   * @param source The upstream source from which the renderer obtains samples.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   */
+  public LibopusAudioTrackRenderer(SampleSource source, Handler eventHandler,
+      EventListener eventListener) {
+    this.source = source.register();
+    this.eventHandler = eventHandler;
+    this.eventListener = eventListener;
+    this.audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
+    this.audioTrack = new AudioTrack();
+    formatHolder = new MediaFormatHolder();
+  }
+
+  @Override
+  protected MediaClock getMediaClock() {
+    return this;
+  }
+
+  @Override
+  protected int doPrepare(long positionUs) throws ExoPlaybackException {
+    try {
+      boolean sourcePrepared = source.prepare(positionUs);
+      if (!sourcePrepared) {
+        return TrackRenderer.STATE_UNPREPARED;
+      }
+    } catch (IOException e) {
+      throw new ExoPlaybackException(e);
+    }
+
+    for (int i = 0; i < source.getTrackCount(); i++) {
+      if (source.getTrackInfo(i).mimeType.equalsIgnoreCase(MimeTypes.AUDIO_OPUS)
+          || source.getTrackInfo(i).mimeType.equalsIgnoreCase(MimeTypes.AUDIO_WEBM)) {
+        trackIndex = i;
+        return TrackRenderer.STATE_PREPARED;
+      }
+    }
+
+    return TrackRenderer.STATE_IGNORE;
+  }
+
+  @Override
+  protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
+    if (outputStreamEnded) {
+      return;
+    }
+    try {
+      sourceIsReady = source.continueBuffering(trackIndex, positionUs);
+      checkForDiscontinuity();
+      if (format == null) {
+        readFormat();
+      } else {
+        // Create the decoder.
+        if (decoder == null) {
+          // For opus, the format can contain upto 3 entries in initializationData in the following
+          // exact order:
+          // 1) Opus Header Information (required)
+          // 2) Codec Delay in nanoseconds (required if Seek Preroll is present)
+          // 3) Seek Preroll in nanoseconds (required if Codec Delay is present)
+          List<byte[]> initializationData = format.initializationData;
+          if (initializationData.size() < 1) {
+            throw new ExoPlaybackException("Missing initialization data");
+          }
+          long codecDelayNs = -1;
+          long seekPreRollNs = -1;
+          if (initializationData.size() == 3) {
+            if (initializationData.get(1).length != Long.SIZE
+                || initializationData.get(2).length != Long.SIZE) {
+              throw new ExoPlaybackException("Invalid Codec Delay or Seek Preroll");
+            }
+            codecDelayNs = ByteBuffer.wrap(initializationData.get(1)).getLong();
+            seekPreRollNs = ByteBuffer.wrap(initializationData.get(2)).getLong();
+          }
+          decoder =
+              new OpusDecoderWrapper(initializationData.get(0), codecDelayNs, seekPreRollNs);
+          decoder.start();
+        }
+        renderBuffer();
+
+        // Queue input buffers.
+        while (feedInputBuffer()) {}
+      }
+    } catch (AudioTrack.InitializationException e) {
+      notifyAudioTrackInitializationError(e);
+      throw new ExoPlaybackException(e);
+    } catch (AudioTrack.WriteException e) {
+      notifyAudioTrackWriteError(e);
+      throw new ExoPlaybackException(e);
+    } catch (OpusDecoderException e) {
+      notifyDecoderError(e);
+      throw new ExoPlaybackException(e);
+    } catch (IOException e) {
+      throw new ExoPlaybackException(e);
+    }
+  }
+
+  private void renderBuffer() throws OpusDecoderException, AudioTrack.InitializationException,
+      AudioTrack.WriteException {
+    if (outputStreamEnded) {
+      return;
+    }
+
+    if (outputBuffer == null) {
+      outputBuffer = decoder.dequeueOutputBuffer();
+      if (outputBuffer == null) {
+        return;
+      }
+    }
+
+    if (outputBuffer.getFlag(OpusDecoderWrapper.FLAG_END_OF_STREAM)) {
+      outputStreamEnded = true;
+      decoder.releaseOutputBuffer(outputBuffer);
+      outputBuffer = null;
+      return;
+    }
+
+    if (!audioTrack.isInitialized()) {
+      if (audioSessionId != AudioTrack.SESSION_ID_NOT_SET) {
+        audioTrack.initialize(audioSessionId);
+      } else {
+        audioSessionId = audioTrack.initialize();
+      }
+      if (getState() == TrackRenderer.STATE_STARTED) {
+        audioTrack.play();
+      }
+    }
+
+    int handleBufferResult;
+    handleBufferResult = audioTrack.handleBuffer(outputBuffer.data,
+        outputBuffer.data.position(), outputBuffer.size, outputBuffer.timestampUs);
+
+    // If we are out of sync, allow currentPositionUs to jump backwards.
+    if ((handleBufferResult & AudioTrack.RESULT_POSITION_DISCONTINUITY) != 0) {
+      allowPositionDiscontinuity = true;
+    }
+
+    // Release the buffer if it was consumed.
+    if ((handleBufferResult & AudioTrack.RESULT_BUFFER_CONSUMED) != 0) {
+      decoder.releaseOutputBuffer(outputBuffer);
+      outputBuffer = null;
+    }
+  }
+
+  private boolean feedInputBuffer() throws IOException, OpusDecoderException {
+    if (inputStreamEnded) {
+      return false;
+    }
+
+    if (inputBuffer == null) {
+      inputBuffer = decoder.getInputBuffer();
+      if (inputBuffer == null) {
+        return false;
+      }
+    }
+
+    int result = source.readData(trackIndex, currentPositionUs, formatHolder,
+        inputBuffer.sampleHolder, false);
+    if (result == SampleSource.NOTHING_READ) {
+      return false;
+    }
+    if (result == SampleSource.DISCONTINUITY_READ) {
+      flushDecoder();
+      return true;
+    }
+    if (result == SampleSource.FORMAT_READ) {
+      format = formatHolder.format;
+      return true;
+    }
+    if (result == SampleSource.END_OF_STREAM) {
+      inputBuffer.setFlag(OpusDecoderWrapper.FLAG_END_OF_STREAM);
+      decoder.queueInputBuffer(inputBuffer);
+      inputBuffer = null;
+      inputStreamEnded = true;
+      return false;
+    }
+    if (notifyDiscontinuityToDecoder) {
+      notifyDiscontinuityToDecoder = false;
+      inputBuffer.setFlag(OpusDecoderWrapper.FLAG_RESET_DECODER);
+    }
+
+    decoder.queueInputBuffer(inputBuffer);
+    inputBuffer = null;
+    return true;
+  }
+
+  private void checkForDiscontinuity() throws IOException {
+    if (decoder == null) {
+      return;
+    }
+    int result = source.readData(trackIndex, currentPositionUs, formatHolder, null, true);
+    if (result == SampleSource.DISCONTINUITY_READ) {
+      flushDecoder();
+    }
+  }
+
+  private void flushDecoder() {
+    inputBuffer = null;
+    outputBuffer = null;
+    decoder.flush();
+    notifyDiscontinuityToDecoder = true;
+  }
+
+  @Override
+  protected boolean isEnded() {
+    return outputStreamEnded && (!audioTrack.hasPendingData()
+        || !audioTrack.hasEnoughDataToBeginPlayback());
+  }
+
+  @Override
+  protected boolean isReady() {
+    return audioTrack.hasPendingData() || (format != null && sourceIsReady);
+  }
+
+  @Override
+  protected long getDurationUs() {
+    return source.getTrackInfo(trackIndex).durationUs;
+  }
+
+  @Override
+  public long getPositionUs() {
+    long newCurrentPositionUs = audioTrack.getCurrentPositionUs(isEnded());
+    if (newCurrentPositionUs != AudioTrack.CURRENT_POSITION_NOT_SET) {
+      currentPositionUs = allowPositionDiscontinuity ? newCurrentPositionUs
+          : Math.max(currentPositionUs, newCurrentPositionUs);
+      allowPositionDiscontinuity = false;
+    }
+    return currentPositionUs;
+  }
+
+  @Override
+  protected long getBufferedPositionUs() {
+    return source.getBufferedPositionUs();
+  }
+
+  @Override
+  protected void seekTo(long positionUs) throws ExoPlaybackException {
+    source.seekToUs(positionUs);
+    seekToInternal(positionUs);
+  }
+
+  private void seekToInternal(long positionUs) {
+    audioTrack.reset();
+    currentPositionUs = positionUs;
+    allowPositionDiscontinuity = true;
+    source.seekToUs(positionUs);
+    inputStreamEnded = false;
+    outputStreamEnded = false;
+    sourceIsReady = false;
+  }
+
+  @Override
+  protected void onEnabled(long positionUs, boolean joining) {
+    source.enable(trackIndex, positionUs);
+    seekToInternal(positionUs);
+  }
+
+  @Override
+  protected void onStarted() {
+    audioTrack.play();
+  }
+
+  @Override
+  protected void onStopped() {
+    audioTrack.pause();
+  }
+
+  @Override
+  protected void onReleased() {
+    source.release();
+  }
+
+  @Override
+  protected void onDisabled() {
+    if (decoder != null) {
+      decoder.release();
+      decoder = null;
+    }
+    audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
+    try {
+      audioTrack.release();
+    } finally {
+      inputBuffer = null;
+      outputBuffer = null;
+      format = null;
+      source.disable(trackIndex);
+    }
+  }
+
+  private void readFormat() throws IOException {
+    int result = source.readData(trackIndex, currentPositionUs, formatHolder, null, false);
+    if (result == SampleSource.FORMAT_READ) {
+      format = formatHolder.format;
+      audioTrack.reconfigure(format.getFrameworkMediaFormatV16());
+    }
+  }
+
+  @Override
+  public void handleMessage(int messageType, Object message) throws ExoPlaybackException {
+    if (messageType == MSG_SET_VOLUME) {
+      audioTrack.setVolume((Float) message);
+    } else {
+      super.handleMessage(messageType, message);
+    }
+  }
+
+  private void notifyAudioTrackInitializationError(final AudioTrack.InitializationException e) {
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable()  {
+        @Override
+        public void run() {
+          eventListener.onAudioTrackInitializationError(e);
+        }
+      });
+    }
+  }
+
+  private void notifyAudioTrackWriteError(final AudioTrack.WriteException e) {
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable()  {
+        @Override
+        public void run() {
+          eventListener.onAudioTrackWriteError(e);
+        }
+      });
+    }
+  }
+
+  private void notifyDecoderError(final OpusDecoderException e) {
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable()  {
+        @Override
+        public void run() {
+          eventListener.onDecoderError(e);
+        }
+      });
+    }
+  }
+
+}
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java
new file mode 100644
index 0000000000..6de3481c2a
--- /dev/null
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.opus;
+
+import com.google.android.exoplayer.ext.opus.OpusDecoderWrapper.OpusHeader;
+
+import java.nio.ByteBuffer;
+
+/**
+ * JNI Wrapper for the libopus Opus decoder.
+ *
+ * @author vigneshv@google.com (Vignesh Venkatasubramanian)
+ */
+/* package */ class OpusDecoder {
+
+  private final long nativeDecoderContext;
+
+  static {
+    System.loadLibrary("opus");
+    System.loadLibrary("opusJNI");
+  }
+
+  /**
+   * Creates the Opus Decoder.
+   *
+   * @param opusHeader OpusHeader used to initialize the decoder.
+   * @throws OpusDecoderException if the decoder initialization fails.
+   */
+  public OpusDecoder(OpusHeader opusHeader) throws OpusDecoderException {
+    nativeDecoderContext = opusInit(
+        opusHeader.sampleRate, opusHeader.channelCount, opusHeader.numStreams,
+        opusHeader.numCoupled, opusHeader.gain, opusHeader.streamMap);
+    if (nativeDecoderContext == 0) {
+      throw new OpusDecoderException("failed to initialize opus decoder");
+    }
+  }
+
+  /**
+   * Decodes an Opus Encoded Stream.
+   *
+   * @param inputBuffer buffer containing the encoded data. Must be allocated using allocateDirect.
+   * @param inputSize size of the input buffer.
+   * @param outputBuffer buffer to write the decoded data. Must be allocated using allocateDirect.
+   * @param outputSize Maximum capacity of the output buffer.
+   * @return number of decoded bytes.
+   * @throws OpusDecoderException if decode fails.
+   */
+  public int decode(ByteBuffer inputBuffer, int inputSize, ByteBuffer outputBuffer,
+      int outputSize) throws OpusDecoderException {
+    int result = opusDecode(nativeDecoderContext, inputBuffer, inputSize, outputBuffer, outputSize);
+    if (result < 0) {
+      throw new OpusDecoderException(opusGetErrorMessage(result));
+    }
+    return result;
+  }
+
+  /**
+   * Closes the native decoder.
+   */
+  public void close() {
+    opusClose(nativeDecoderContext);
+  }
+
+  /**
+   * Resets the native decode on discontinuity (during seek for example).
+   */
+  public void reset() {
+    opusReset(nativeDecoderContext);
+  }
+
+  private native long opusInit(int sampleRate, int channelCount, int numStreams, int numCoupled,
+      int gain, byte[] streamMap);
+  private native int opusDecode(long decoder, ByteBuffer inputBuffer, int inputSize,
+      ByteBuffer outputBuffer, int outputSize);
+  private native void opusClose(long decoder);
+  private native void opusReset(long decoder);
+  private native String opusGetErrorMessage(int errorCode);
+
+}
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoderException.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoderException.java
new file mode 100644
index 0000000000..13e7739df9
--- /dev/null
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoderException.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.opus;
+
+/**
+ * Thrown when an Opus decoder error occurs.
+ */
+public class OpusDecoderException extends Exception {
+
+    public OpusDecoderException(String message) {
+      super(message);
+    }
+
+}
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoderWrapper.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoderWrapper.java
new file mode 100644
index 0000000000..074fc43f7d
--- /dev/null
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoderWrapper.java
@@ -0,0 +1,383 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.opus;
+
+import com.google.android.exoplayer.SampleHolder;
+
+import java.nio.ByteBuffer;
+import java.util.LinkedList;
+
+/**
+ * Wraps {@link OpusDecoder}, exposing a higher level decoder interface.
+ *
+ * @author vigneshv@google.com (Vignesh Venkatasubramanian)
+ */
+/* package */ class OpusDecoderWrapper extends Thread {
+
+  public static final int FLAG_END_OF_STREAM = 1;
+  public static final int FLAG_RESET_DECODER = 2;
+
+  private static final int INPUT_BUFFER_SIZE = 960 * 6;
+  private static final int OUTPUT_BUFFER_SIZE = 960 * 6 * 2;
+  private static final int NUM_BUFFERS = 16;
+  private static final int DEFAULT_SEEK_PRE_ROLL = 3840;
+
+  private final Object lock;
+  private final OpusHeader opusHeader;
+
+  private final LinkedList<InputBuffer> queuedInputBuffers;
+  private final LinkedList<OutputBuffer> queuedOutputBuffers;
+  private final InputBuffer[] availableInputBuffers;
+  private final OutputBuffer[] availableOutputBuffers;
+  private int availableInputBufferCount;
+  private int availableOutputBufferCount;
+
+  private int skipSamples;
+  private boolean flushDecodedOutputBuffer;
+  private boolean released;
+
+  private int seekPreRoll;
+
+  private OpusDecoderException decoderException;
+
+  /**
+   * @param headerBytes Opus header data that is used to initialize the decoder. For WebM Container,
+   *    this comes from the CodecPrivate Track element.
+   * @param codecDelayNs Delay in nanoseconds added by the codec at the beginning. For WebM
+   *    Container, this comes from the CodecDelay Track Element. Can be -1 in which case the value
+   *    from the codec header will be used.
+   * @param seekPreRollNs Duration in nanoseconds of samples to discard when there is a
+   *    discontinuity. For WebM Container, this comes from the SeekPreRoll Track Element. Can be -1
+   *    in which case the default value of 80ns will be used.
+   * @throws OpusDecoderException if an exception occurs when initializing the decoder.
+   */
+  public OpusDecoderWrapper(byte[] headerBytes, long codecDelayNs,
+      long seekPreRollNs) throws OpusDecoderException {
+    lock = new Object();
+    opusHeader = parseOpusHeader(headerBytes);
+    skipSamples = (codecDelayNs == -1) ? opusHeader.skipSamples : nsToSamples(codecDelayNs);
+    seekPreRoll = (seekPreRoll == -1) ? DEFAULT_SEEK_PRE_ROLL : nsToSamples(seekPreRollNs);
+    queuedInputBuffers = new LinkedList<>();
+    queuedOutputBuffers = new LinkedList<>();
+    availableInputBuffers = new InputBuffer[NUM_BUFFERS];
+    availableOutputBuffers = new OutputBuffer[NUM_BUFFERS];
+    availableInputBufferCount = NUM_BUFFERS;
+    availableOutputBufferCount = NUM_BUFFERS;
+    for (int i = 0; i < NUM_BUFFERS; i++) {
+      availableInputBuffers[i] = new InputBuffer();
+      availableOutputBuffers[i] = new OutputBuffer();
+    }
+  }
+
+  public InputBuffer getInputBuffer() throws OpusDecoderException {
+    synchronized (lock) {
+      maybeThrowDecoderError();
+      if (availableInputBufferCount == 0) {
+        return null;
+      }
+      InputBuffer inputBuffer = availableInputBuffers[--availableInputBufferCount];
+      inputBuffer.reset();
+      return inputBuffer;
+    }
+  }
+
+  public void queueInputBuffer(InputBuffer inputBuffer) throws OpusDecoderException {
+    synchronized (lock) {
+      maybeThrowDecoderError();
+      queuedInputBuffers.addLast(inputBuffer);
+      maybeNotifyDecodeLoop();
+    }
+  }
+
+  public OutputBuffer dequeueOutputBuffer() throws OpusDecoderException {
+    synchronized (lock) {
+      maybeThrowDecoderError();
+      if (queuedOutputBuffers.isEmpty()) {
+        return null;
+      }
+      return queuedOutputBuffers.removeFirst();
+    }
+  }
+
+  public void releaseOutputBuffer(OutputBuffer outputBuffer) throws OpusDecoderException {
+    synchronized (lock) {
+      maybeThrowDecoderError();
+      outputBuffer.reset();
+      availableOutputBuffers[availableOutputBufferCount++] = outputBuffer;
+      maybeNotifyDecodeLoop();
+    }
+  }
+
+  public void flush() {
+    synchronized (lock) {
+      flushDecodedOutputBuffer = true;
+      while (!queuedInputBuffers.isEmpty()) {
+        availableInputBuffers[availableInputBufferCount++] = queuedInputBuffers.removeFirst();
+      }
+      while (!queuedOutputBuffers.isEmpty()) {
+        availableOutputBuffers[availableOutputBufferCount++] = queuedOutputBuffers.removeFirst();
+      }
+    }
+  }
+
+  public void release() {
+    synchronized (lock) {
+      released = true;
+      lock.notify();
+    }
+    try {
+      join();
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+    }
+  }
+
+  private void maybeThrowDecoderError() throws OpusDecoderException {
+    if (decoderException != null) {
+      throw decoderException;
+    }
+  }
+
+  /**
+   * Notifies the decode loop if there exists a queued input buffer and an available output buffer
+   * to decode into.
+   * <p>
+   * Should only be called whilst synchronized on the lock object.
+   */
+  private void maybeNotifyDecodeLoop() {
+    if (!queuedInputBuffers.isEmpty() && availableOutputBufferCount > 0) {
+      lock.notify();
+    }
+  }
+
+  @Override
+  public void run() {
+    OpusDecoder decoder = null;
+    try {
+      decoder = new OpusDecoder(opusHeader);
+      while (decodeBuffer(decoder)) {
+        // Do nothing.
+      }
+    } catch (OpusDecoderException e) {
+      synchronized (lock) {
+        decoderException = e;
+      }
+    } catch (InterruptedException e) {
+      // Shouldn't ever happen.
+    } finally {
+      if (decoder != null) {
+        decoder.close();
+      }
+    }
+  }
+
+  private boolean decodeBuffer(OpusDecoder decoder) throws InterruptedException,
+      OpusDecoderException {
+    InputBuffer inputBuffer;
+    OutputBuffer outputBuffer;
+
+    // Wait until we have an input buffer to decode, and an output buffer to decode into.
+    synchronized (lock) {
+      while (!released && (queuedInputBuffers.isEmpty() || availableOutputBufferCount == 0)) {
+        lock.wait();
+      }
+      if (released) {
+        return false;
+      }
+      inputBuffer = queuedInputBuffers.removeFirst();
+      outputBuffer = availableOutputBuffers[--availableOutputBufferCount];
+      flushDecodedOutputBuffer = false;
+    }
+
+    // Decode.
+    if (inputBuffer.getFlag(FLAG_END_OF_STREAM)) {
+      outputBuffer.setFlag(FLAG_END_OF_STREAM);
+    } else {
+      if (inputBuffer.getFlag(FLAG_RESET_DECODER)) {
+        decoder.reset();
+        // When seeking to 0, skip number of samples as specified in opus header. When seeking to
+        // any other time, skip number of samples as specified by seek preroll.
+        skipSamples = (inputBuffer.sampleHolder.timeUs == 0) ? opusHeader.skipSamples : seekPreRoll;
+      }
+      SampleHolder sampleHolder = inputBuffer.sampleHolder;
+      sampleHolder.data.position(sampleHolder.data.position() - sampleHolder.size);
+      outputBuffer.timestampUs = sampleHolder.timeUs;
+      outputBuffer.size = decoder.decode(sampleHolder.data, sampleHolder.size,
+          outputBuffer.data, outputBuffer.data.capacity());
+      outputBuffer.data.position(0);
+      if (skipSamples > 0) {
+        int bytesPerSample = opusHeader.channelCount * 2;
+        int skipBytes = skipSamples * bytesPerSample;
+        if (outputBuffer.size < skipBytes) {
+          skipSamples -= outputBuffer.size / bytesPerSample;
+          outputBuffer.size = 0;
+        } else {
+          skipSamples = 0;
+          outputBuffer.data.position(skipBytes);
+          outputBuffer.size -= skipBytes;
+        }
+      }
+    }
+
+    synchronized (lock) {
+      if (flushDecodedOutputBuffer
+          || inputBuffer.sampleHolder.isDecodeOnly()
+          || outputBuffer.size == 0) {
+        // In the following cases, we make the output buffer available again rather than queuing it
+        // to be consumed:
+        // 1) A flush occured whilst we were decoding.
+        // 2) The input sample has decodeOnly flag set.
+        // 3) We skip the entire buffer due to skipSamples being greater than bytes decoded.
+        outputBuffer.reset();
+        availableOutputBuffers[availableOutputBufferCount++] = outputBuffer;
+      } else {
+        // Queue the decoded output buffer to be consumed.
+        queuedOutputBuffers.addLast(outputBuffer);
+      }
+      // Make the input buffer available again.
+      availableInputBuffers[availableInputBufferCount++] = inputBuffer;
+    }
+
+    return true;
+  }
+
+  private OpusHeader parseOpusHeader(byte[] headerBytes) throws OpusDecoderException {
+    final int maxChannelCount = 8;
+    final int maxChannelCountWithDefaultLayout = 2;
+    final int headerSize = 19;
+    final int headerChannelCountOffset = 9;
+    final int headerSkipSamplesOffset = 10;
+    final int headerGainOffset = 16;
+    final int headerChannelMappingOffset = 18;
+    final int headerNumStreamsOffset = headerSize;
+    final int headerNumCoupledOffset = headerNumStreamsOffset + 1;
+    final int headerStreamMapOffset = headerNumStreamsOffset + 2;
+    OpusHeader opusHeader = new OpusHeader();
+    try {
+      // Opus streams are always decoded at 48000 hz.
+      opusHeader.sampleRate = 48000;
+      opusHeader.channelCount = headerBytes[headerChannelCountOffset];
+      if (opusHeader.channelCount > maxChannelCount) {
+        throw new OpusDecoderException("Invalid channel count: " + opusHeader.channelCount);
+      }
+      opusHeader.skipSamples = readLittleEndian16(headerBytes, headerSkipSamplesOffset);
+      opusHeader.gain = readLittleEndian16(headerBytes, headerGainOffset);
+      opusHeader.channelMapping = headerBytes[headerChannelMappingOffset];
+
+      if (opusHeader.channelMapping == 0) {
+        // If there is no channel mapping, use the defaults.
+        if (opusHeader.channelCount > maxChannelCountWithDefaultLayout) {
+          throw new OpusDecoderException("Invalid Header, missing stream map.");
+        }
+        opusHeader.numStreams = 1;
+        opusHeader.numCoupled = (opusHeader.channelCount > 1) ? 1 : 0;
+        opusHeader.streamMap[0] = 0;
+        opusHeader.streamMap[1] = 1;
+      } else {
+        // Read the channel mapping.
+        opusHeader.numStreams = headerBytes[headerNumStreamsOffset];
+        opusHeader.numCoupled = headerBytes[headerNumCoupledOffset];
+        for (int i = 0; i < opusHeader.channelCount; i++) {
+          opusHeader.streamMap[i] = headerBytes[headerStreamMapOffset + i];
+        }
+      }
+      return opusHeader;
+    } catch (ArrayIndexOutOfBoundsException e) {
+      throw new OpusDecoderException("Header size is too small.");
+    }
+  }
+
+  private int readLittleEndian16(byte[] input, int offset) {
+    int value = input[offset];
+    value |= input[offset + 1] << 8;
+    return value;
+  }
+
+  private int nsToSamples(long ns) {
+    return (int) (ns * opusHeader.sampleRate / 1000000000);
+  }
+
+  /* package */ static final class InputBuffer {
+
+    public final SampleHolder sampleHolder;
+
+    public int flags;
+
+    public InputBuffer() {
+      sampleHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_DIRECT);
+      sampleHolder.data = ByteBuffer.allocateDirect(INPUT_BUFFER_SIZE);
+    }
+
+    public void reset() {
+      sampleHolder.data.clear();
+      flags = 0;
+    }
+
+    public void setFlag(int flag) {
+      flags |= flag;
+    }
+
+    public boolean getFlag(int flag) {
+      return (flags & flag) == flag;
+    }
+
+  }
+
+  /* package */ static final class OutputBuffer {
+
+    public ByteBuffer data;
+    public int size;
+    public long timestampUs;
+    public int flags;
+
+    public OutputBuffer() {
+      data = ByteBuffer.allocateDirect(OUTPUT_BUFFER_SIZE);
+    }
+
+    public void reset() {
+      data.clear();
+      size = 0;
+      flags = 0;
+    }
+
+    public void setFlag(int flag) {
+      flags |= flag;
+    }
+
+    public boolean getFlag(int flag) {
+      return (flags & flag) == flag;
+    }
+
+  }
+
+  /* package */ static final class OpusHeader {
+
+    public int sampleRate;
+    public int channelCount;
+    public int skipSamples;
+    public int gain;
+    public int channelMapping;
+    public int numStreams;
+    public int numCoupled;
+    public byte[] streamMap;
+
+    public OpusHeader() {
+      streamMap = new byte[8];
+    }
+
+  }
+
+}
diff --git a/extensions/opus/src/main/jni/Android.mk b/extensions/opus/src/main/jni/Android.mk
new file mode 100644
index 0000000000..7ca8300316
--- /dev/null
+++ b/extensions/opus/src/main/jni/Android.mk
@@ -0,0 +1,34 @@
+#
+# Copyright (C) 2014 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+WORKING_DIR := $(call my-dir)
+include $(CLEAR_VARS)
+APP_PLATFORM := android-10
+
+# build libopus.so
+LOCAL_PATH := $(WORKING_DIR)
+include libopus.mk
+
+# build libopusJNI.so
+include $(CLEAR_VARS)
+LOCAL_PATH := $(WORKING_DIR)
+LOCAL_MODULE := libopusJNI
+LOCAL_ARM_MODE := arm
+LOCAL_CPP_EXTENSION := .cc
+LOCAL_SRC_FILES := opus_jni.cc
+LOCAL_LDLIBS := -llog -lz -lm
+LOCAL_SHARED_LIBRARIES := libopus
+include $(BUILD_SHARED_LIBRARY)
diff --git a/extensions/opus/src/main/jni/Application.mk b/extensions/opus/src/main/jni/Application.mk
new file mode 100644
index 0000000000..6563af0f50
--- /dev/null
+++ b/extensions/opus/src/main/jni/Application.mk
@@ -0,0 +1,19 @@
+#
+# Copyright (C) 2014 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+APP_OPTIM := release
+APP_STL := gnustl_static
+APP_CPPFLAGS := -frtti
diff --git a/extensions/opus/src/main/jni/convert_android_asm.sh b/extensions/opus/src/main/jni/convert_android_asm.sh
new file mode 100755
index 0000000000..6d75f094ae
--- /dev/null
+++ b/extensions/opus/src/main/jni/convert_android_asm.sh
@@ -0,0 +1,47 @@
+#!/bin/bash
+#
+# Copyright (C) 2014 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+set -e
+ASM_CONVERTER="./libopus/celt/arm/arm2gnu.pl"
+
+if [[ ! -x "${ASM_CONVERTER}" ]]; then
+  echo "Please make sure you have checked out libopus."
+  exit
+fi
+
+while read file; do
+  # This check is required because the ASM conversion script doesn't seem to be
+  # idempotent.
+  if [[ ! "${file}" =~ .*_gnu\.s$ ]]; then
+    gnu_file="${file%.s}_gnu.s"
+    ${ASM_CONVERTER} "${file}" > "${gnu_file}"
+    # The ASM conversion script replaces includes with *_gnu.S. So, replace
+    # occurences of "*-gnu.S" with "*_gnu.s".
+    sed -i "s/-gnu\.S/_gnu\.s/g" "${gnu_file}"
+    rm -f "${file}"
+  fi
+done < <(find . -iname '*.s')
+
+# Generate armopts.s from armopts.s.in
+sed \
+  -e "s/@OPUS_ARM_MAY_HAVE_EDSP@/1/g" \
+  -e "s/@OPUS_ARM_MAY_HAVE_MEDIA@/1/g" \
+  -e "s/@OPUS_ARM_MAY_HAVE_NEON@/1/g" \
+  libopus/celt/arm/armopts.s.in > libopus/celt/arm/armopts.s.temp
+${ASM_CONVERTER} "libopus/celt/arm/armopts.s.temp" > "libopus/celt/arm/armopts_gnu.s"
+rm "libopus/celt/arm/armopts.s.temp"
+echo "Converted all ASM files and generated armopts.s successfully."
diff --git a/extensions/opus/src/main/jni/libopus.mk b/extensions/opus/src/main/jni/libopus.mk
new file mode 100644
index 0000000000..2eb5476e66
--- /dev/null
+++ b/extensions/opus/src/main/jni/libopus.mk
@@ -0,0 +1,50 @@
+#
+# Copyright (C) 2014 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+LOCAL_PATH := $(call my-dir)/libopus
+
+include $(CLEAR_VARS)
+
+include $(LOCAL_PATH)/celt_headers.mk
+include $(LOCAL_PATH)/celt_sources.mk
+include $(LOCAL_PATH)/opus_headers.mk
+include $(LOCAL_PATH)/opus_sources.mk
+include $(LOCAL_PATH)/silk_headers.mk
+include $(LOCAL_PATH)/silk_sources.mk
+
+LOCAL_MODULE := libopus
+LOCAL_ARM_MODE := arm
+LOCAL_CFLAGS := -DOPUS_BUILD -DFIXED_POINT -DUSE_ALLOCA -DHAVE_LRINT \
+                -DHAVE_LRINTF
+LOCAL_C_INCLUDES := $(LOCAL_PATH)/include $(LOCAL_PATH)/src \
+                    $(LOCAL_PATH)/silk $(LOCAL_PATH)/celt \
+                    $(LOCAL_PATH)/silk/fixed
+LOCAL_SRC_FILES := $(CELT_SOURCES) $(OPUS_SOURCES) $(OPUS_SOURCES_FLOAT) \
+                   $(SILK_SOURCES) $(SILK_SOURCES_FIXED)
+
+ifneq ($(findstring armeabi-v7a, $(TARGET_ARCH_ABI)),)
+LOCAL_SRC_FILES += $(CELT_SOURCES_ARM)
+LOCAL_SRC_FILES += celt/arm/armopts_gnu.s.neon
+LOCAL_SRC_FILES += $(subst .s,_gnu.s.neon,$(CELT_SOURCES_ARM_ASM))
+LOCAL_CFLAGS += -DOPUS_ARM_ASM -DOPUS_ARM_INLINE_ASM -DOPUS_ARM_INLINE_EDSP \
+                -DOPUS_ARM_INLINE_MEDIA -DOPUS_ARM_INLINE_NEON \
+                -DOPUS_ARM_MAY_HAVE_NEON -DOPUS_ARM_MAY_HAVE_MEDIA \
+                -DOPUS_ARM_MAY_HAVE_EDSP
+endif
+
+LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/include
+
+include $(BUILD_SHARED_LIBRARY)
diff --git a/extensions/opus/src/main/jni/opus_jni.cc b/extensions/opus/src/main/jni/opus_jni.cc
new file mode 100644
index 0000000000..0259592c94
--- /dev/null
+++ b/extensions/opus/src/main/jni/opus_jni.cc
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <jni.h>
+
+#include <android/log.h>
+
+#include <cstdlib>
+
+#include "opus.h"  // NOLINT
+#include "opus_multistream.h"  // NOLINT
+
+#define LOG_TAG "libopus_native"
+#define LOGE(...) ((void)__android_log_print(ANDROID_LOG_ERROR, LOG_TAG, \
+                                             __VA_ARGS__))
+
+#define FUNC(RETURN_TYPE, NAME, ...) \
+  extern "C" { \
+  JNIEXPORT RETURN_TYPE \
+    Java_com_google_android_exoplayer_ext_opus_OpusDecoder_ ## NAME \
+      (JNIEnv* env, jobject thiz, ##__VA_ARGS__);\
+  } \
+  JNIEXPORT RETURN_TYPE \
+    Java_com_google_android_exoplayer_ext_opus_OpusDecoder_ ## NAME \
+      (JNIEnv* env, jobject thiz, ##__VA_ARGS__)\
+
+jint JNI_OnLoad(JavaVM* vm, void* reserved) {
+  JNIEnv* env;
+  if (vm->GetEnv(reinterpret_cast<void**>(&env), JNI_VERSION_1_6) != JNI_OK) {
+    return -1;
+  }
+  return JNI_VERSION_1_6;
+}
+
+static int channelCount;
+
+FUNC(jlong, opusInit, jint sampleRate, jint channelCount, jint numStreams,
+     jint numCoupled, jint gain, jbyteArray jStreamMap) {
+  int status = OPUS_INVALID_STATE;
+  ::channelCount = channelCount;
+  jbyte* streamMapBytes = env->GetByteArrayElements(jStreamMap, 0);
+  uint8_t* streamMap = reinterpret_cast<uint8_t*>(streamMapBytes);
+  OpusMSDecoder* decoder = opus_multistream_decoder_create(
+      sampleRate, channelCount, numStreams, numCoupled, streamMap, &status);
+  env->ReleaseByteArrayElements(jStreamMap, streamMapBytes, 0);
+  if (!decoder || status != OPUS_OK) {
+    LOGE("Failed to create Opus Decoder; status=%s", opus_strerror(status));
+    return 0;
+  }
+  status = opus_multistream_decoder_ctl(decoder, OPUS_SET_GAIN(gain));
+  if (status != OPUS_OK) {
+    LOGE("Failed to set Opus header gain; status=%s", opus_strerror(status));
+    return 0;
+  }
+  return reinterpret_cast<intptr_t>(decoder);
+}
+
+FUNC(jint, opusDecode, jlong jDecoder, jobject jInputBuffer, jint inputSize,
+     jobject jOutputBuffer, jint outputSize) {
+  OpusMSDecoder* decoder = reinterpret_cast<OpusMSDecoder*>(jDecoder);
+  const uint8_t* inputBuffer =
+      reinterpret_cast<const uint8_t*>(
+          env->GetDirectBufferAddress(jInputBuffer));
+  int16_t* outputBuffer = reinterpret_cast<int16_t*>(
+      env->GetDirectBufferAddress(jOutputBuffer));
+  int numFrames = opus_multistream_decode(decoder, inputBuffer, inputSize,
+                                          outputBuffer, outputSize, 0);
+  return (numFrames < 0) ? numFrames : numFrames * 2 * channelCount;
+}
+
+FUNC(void, opusClose, jlong jDecoder) {
+  OpusMSDecoder* decoder = reinterpret_cast<OpusMSDecoder*>(jDecoder);
+  opus_multistream_decoder_destroy(decoder);
+}
+
+FUNC(void, opusReset, jlong jDecoder) {
+  OpusMSDecoder* decoder = reinterpret_cast<OpusMSDecoder*>(jDecoder);
+  opus_multistream_decoder_ctl(decoder, OPUS_RESET_STATE);
+}
+
+FUNC(jstring, opusGetErrorMessage, jint errorCode) {
+  return env->NewStringUTF(opus_strerror(errorCode));
+}
diff --git a/extensions/opus/src/main/project.properties b/extensions/opus/src/main/project.properties
new file mode 100644
index 0000000000..2ed62fbfcf
--- /dev/null
+++ b/extensions/opus/src/main/project.properties
@@ -0,0 +1,16 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-22
+android.library=true
+android.library.reference.1=../../../../library/src/main
diff --git a/extensions/opus/src/main/res/.README.txt b/extensions/opus/src/main/res/.README.txt
new file mode 100644
index 0000000000..c27147ce56
--- /dev/null
+++ b/extensions/opus/src/main/res/.README.txt
@@ -0,0 +1,2 @@
+This file is needed to make sure the res directory is present.
+The file is ignored by the Android toolchain because its name starts with a dot.
diff --git a/extensions/vp9/README.md b/extensions/vp9/README.md
new file mode 100644
index 0000000000..0250cfc8a5
--- /dev/null
+++ b/extensions/vp9/README.md
@@ -0,0 +1,134 @@
+# ExoPlayer VP9 Extension #
+
+## Description ##
+
+The VP9 Extension is a [Track Renderer][] implementation that helps you bundle libvpx (the VP9 decoding library) into your app and use it along with ExoPlayer to play VP9 video on Android devices.
+
+[Track Renderer]: http://google.github.io/ExoPlayer/doc/reference/com/google/android/exoplayer/TrackRenderer.html
+
+## Build Instructions (Android Studio and Eclipse) ##
+
+Building the VP9 Extension involves building libvpx and JNI bindings using the Android NDK and linking it into your app. The following steps will tell you how to do that using Android Studio or Eclipse.
+
+* Checkout ExoPlayer along with Extensions
+
+```
+git clone https://github.com/google/ExoPlayer.git
+```
+
+* Set the following environment variables:
+
+```
+cd "<path to exoplayer checkout>"
+EXOPLAYER_ROOT="$(pwd)"
+VP9_EXT_PATH="${EXOPLAYER_ROOT}/extensions/vp9/src/main"
+```
+
+* Download the [Android NDK][] and set its location in an environment variable:
+
+```
+NDK_PATH="<path to Android NDK>"
+```
+
+* Fetch libvpx and libyuv
+
+```
+cd "${VP9_EXT_PATH}/jni" && \
+git clone https://chromium.googlesource.com/webm/libvpx libvpx && \
+git clone https://git.chromium.org/external/libyuv.git libyuv
+```
+
+* Run a script that generates necessary configuration files for libvpx
+
+```
+cd ${VP9_EXT_PATH}/jni && \
+./generate_libvpx_android_configs.sh "${NDK_PATH}"
+```
+
+### Android Studio ###
+
+For Android Studio, we build the native libraries from the command line and then Gradle will pick it up when building your app using Android Studio.
+
+* Build the JNI native libraries
+
+```
+cd "${VP9_EXT_PATH}"/jni && \
+${NDK_PATH}/ndk-build APP_ABI=all -j4
+```
+
+* In your project, you can add a dependency to the VP9 Extension by using a the following rule
+
+```
+// in settings.gradle
+include ':..:ExoPlayer:library'
+include ':..:ExoPlayer:vp9-extension'
+
+// in build.gradle
+dependencies {
+    compile project(':..:ExoPlayer:library')
+    compile project(':..:ExoPlayer:vp9-extension')
+}
+```
+
+* Now, when you build your app, the VP9 extension will be built and the native libraries will be packaged along with the APK.
+
+### Eclipse ###
+
+* The following steps assume that you have installed Eclipse and configured it with the [Android SDK][] and [Android NDK ][]:
+  * Navigate to File->Import->General->Existing Projects into Workspace
+  * Select the root directory of the repository
+  * Import the following projects:
+    * ExoPlayerLib
+    * ExoPlayerExt-VP9
+    * If you are able to build ExoPlayerExt-VP9 project, then you're all set.
+    * (Optional) To speed up the NDK build:
+      * Right click on ExoPlayerExt-VP9 in the Project Explorer pane and choose Properties
+      * Click on C/C++ Build
+      * Uncheck `Use default build command`
+      * In `Build Command` enter: `ndk-build -j4` (adjust 4 to a reasonable number depending on the number of cores in your computer)
+      * Click Apply
+
+You can now create your own Android App project and add ExoPlayerLib along with ExoPlayerExt-VP9 as a dependencies to use ExoPlayer along with the VP9 Extension.
+
+
+[Android NDK]: https://developer.android.com/tools/sdk/ndk/index.html
+<!---
+Work around to point to two different links for the same text.
+-->
+[Android NDK ]: http://tools.android.com/recent/usingthendkplugin
+[Android SDK]: http://developer.android.com/sdk/installing/index.html?pkg=tools
+
+## Building for various Architectures ##
+
+### Android Studio ###
+
+The manual invocation of `ndk-build` will build the library for all architectures and the correct one will be picked up from the APK based on the device its running on.
+
+### Eclipse  ###
+
+libvpx is optimized for various architectures (like neon, x86, etc.). The `generate_libvpx_android_configs.sh` script generates Android configurations for the following architectures:
+
+* armeabi (the default - does not include neon optimizations)
+* armeabi-v7a (choose this to enable neon optimizations)
+* mips
+* x86
+* all (will result in a larger binary but will cover all architectures)
+
+You can build for a specific architecture in two ways:
+
+* Method 1 (edit `Application.mk`)
+  * Edit `${VP9_EXT_PATH}/jni/Application.mk` and add the following line `APP_ABI := <arch>` (where `<arch>` is one of the above 4 architectures)
+* Method 2 (pass NDK build flag)
+  * Right click on ExoPlayerExt-VP9 in the Project Explorer pane and choose Properties
+  * Click on C/C++ Build
+  * Uncheck `Use default build command`
+  * In `Build Command` enter: `ndk-build APP_ABI=<arch>` (where `<arch>` is one of the above 4 architectures)
+  * Click Apply
+
+## Other Things to Note ##
+
+* Every time there is a change to the libvpx checkout:
+  * Android config scripts should be re-generated by running `generate_libvpx_android_configs.sh`
+  * Clean and re-build the project.
+* If you want to use your own version of libvpx or libyuv, place it in `${VP9_EXT_PATH}/jni/libvpx` or `${VP9_EXT_PATH}/jni/libyuv` respectively.
+
diff --git a/extensions/vp9/build.gradle b/extensions/vp9/build.gradle
new file mode 100644
index 0000000000..443d0d6601
--- /dev/null
+++ b/extensions/vp9/build.gradle
@@ -0,0 +1,45 @@
+// Copyright (C) 2014 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion 22
+    buildToolsVersion "22.0.1"
+
+    defaultConfig {
+        minSdkVersion 9
+        targetSdkVersion 22
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
+        }
+    }
+
+    lintOptions {
+        abortOnError false
+    }
+
+    sourceSets.main {
+        jniLibs.srcDir 'src/main/libs'
+        jni.srcDirs = [] // Disable the automatic ndk-build call by Android Studio.
+    }
+}
+
+dependencies {
+    compile project(':library')
+}
+
diff --git a/extensions/vp9/src/main/.classpath b/extensions/vp9/src/main/.classpath
new file mode 100644
index 0000000000..fd895b0917
--- /dev/null
+++ b/extensions/vp9/src/main/.classpath
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
+	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
+	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
+	<classpathentry kind="src" path="java"/>
+	<classpathentry kind="src" path="gen"/>
+	<classpathentry kind="src" path="/ExoPlayerLib"/>
+	<classpathentry kind="output" path="bin/classes"/>
+</classpath>
diff --git a/extensions/vp9/src/main/.cproject b/extensions/vp9/src/main/.cproject
new file mode 100644
index 0000000000..8548e48eb9
--- /dev/null
+++ b/extensions/vp9/src/main/.cproject
@@ -0,0 +1,57 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<?fileVersion 4.0.0?><cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptionStorage">
+	<storageModule moduleId="org.eclipse.cdt.core.settings">
+		<cconfiguration id="com.android.toolchain.gcc.367693784">
+			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="com.android.toolchain.gcc.367693784" moduleId="org.eclipse.cdt.core.settings" name="Default">
+				<externalSettings/>
+				<extensions>
+					<extension id="org.eclipse.cdt.core.VCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GmakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.CWDLocator" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.MakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GCCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GASErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GLDErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.ELF" point="org.eclipse.cdt.core.BinaryParser"/>
+				</extensions>
+			</storageModule>
+			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+				<configuration artifactName="${ProjName}" buildProperties="" description="" id="com.android.toolchain.gcc.367693784" name="Default" parent="org.eclipse.cdt.build.core.emptycfg">
+					<folderInfo id="com.android.toolchain.gcc.367693784.1582606005" name="/" resourcePath="">
+						<toolChain id="com.android.toolchain.gcc.2090539093" name="Android GCC" superClass="com.android.toolchain.gcc">
+							<targetPlatform binaryParser="org.eclipse.cdt.core.ELF" id="com.android.targetPlatform.1021581688" isAbstract="false" superClass="com.android.targetPlatform"/>
+							<builder buildPath="${workspace_loc:/ExoPlayerExt-VP9}/jni" id="com.android.builder.1955717109" keepEnvironmentInBuildfile="false" managedBuildOn="false" name="Android Builder" superClass="com.android.builder">
+								<outputEntries>
+									<entry flags="VALUE_WORKSPACE_PATH|RESOLVED" kind="outputPath" name="obj"/>
+									<entry flags="VALUE_WORKSPACE_PATH|RESOLVED" kind="outputPath" name="libs"/>
+								</outputEntries>
+							</builder>
+							<tool id="com.android.gcc.compiler.162335776" name="Android GCC Compiler" superClass="com.android.gcc.compiler">
+								<inputType id="com.android.gcc.inputType.78164988" superClass="com.android.gcc.inputType"/>
+							</tool>
+						</toolChain>
+					</folderInfo>
+					<sourceEntries>
+						<entry flags="VALUE_WORKSPACE_PATH|RESOLVED" kind="sourcePath" name="jni"/>
+					</sourceEntries>
+				</configuration>
+			</storageModule>
+			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
+		</cconfiguration>
+	</storageModule>
+	<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+		<project id="ExoPlayerExt-VP9.null.410683598" name="ExoPlayerExt-VP9"/>
+	</storageModule>
+	<storageModule moduleId="org.eclipse.cdt.core.LanguageSettingsProviders"/>
+	<storageModule moduleId="scannerConfiguration">
+		<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId=""/>
+		<scannerConfigBuildInfo instanceId="com.android.toolchain.gcc.367693784;com.android.toolchain.gcc.367693784.1582606005;com.android.gcc.compiler.162335776;com.android.gcc.inputType.78164988">
+			<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId="com.android.AndroidPerProjectProfile"/>
+		</scannerConfigBuildInfo>
+	</storageModule>
+	<storageModule moduleId="refreshScope" versionNumber="2">
+		<configuration configurationName="Default">
+			<resource resourceType="PROJECT" workspacePath="/ExoPlayerExt-VP9"/>
+		</configuration>
+	</storageModule>
+</cproject>
diff --git a/extensions/vp9/src/main/.project b/extensions/vp9/src/main/.project
new file mode 100644
index 0000000000..3811626cb3
--- /dev/null
+++ b/extensions/vp9/src/main/.project
@@ -0,0 +1,97 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>ExoPlayerExt-VP9</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
+			<triggers>clean,full,incremental,</triggers>
+			<arguments>
+				<dictionary>
+					<key>?children?</key>
+					<value>?name?=outputEntries\|?children?=?name?=entry\\\\\\\|\\\|?name?=entry\\\\\\\|\\\|\||</value>
+				</dictionary>
+				<dictionary>
+					<key>?name?</key>
+					<value></value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.append_environment</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildArguments</key>
+					<value></value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.buildCommand</key>
+					<value>ndk-build</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.cleanBuildTarget</key>
+					<value>clean</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.contents</key>
+					<value>org.eclipse.cdt.make.core.activeConfigSettings</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableAutoBuild</key>
+					<value>false</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableCleanBuild</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.enableFullBuild</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.stopOnError</key>
+					<value>true</value>
+				</dictionary>
+				<dictionary>
+					<key>org.eclipse.cdt.make.core.useDefaultBuildCmd</key>
+					<value>true</value>
+				</dictionary>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</name>
+			<triggers>full,incremental,</triggers>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+		<nature>org.eclipse.cdt.core.cnature</nature>
+		<nature>org.eclipse.cdt.core.ccnature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
+	</natures>
+</projectDescription>
diff --git a/extensions/vp9/src/main/.settings/org.eclipse.jdt.core.prefs b/extensions/vp9/src/main/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000000..d17b6724d1
--- /dev/null
+++ b/extensions/vp9/src/main/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,12 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.methodParameters=do not generate
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.7
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.7
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.7
diff --git a/extensions/vp9/src/main/AndroidManifest.xml b/extensions/vp9/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..3e21f70510
--- /dev/null
+++ b/extensions/vp9/src/main/AndroidManifest.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2014 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.google.android.exoplayer.ext.vp9">
+
+    <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="22"/>
+    <uses-feature android:glEsVersion="0x00020000"/>
+
+</manifest>
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
new file mode 100644
index 0000000000..b6b3cc06a1
--- /dev/null
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
@@ -0,0 +1,496 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.vp9;
+
+import com.google.android.exoplayer.ExoPlaybackException;
+import com.google.android.exoplayer.ExoPlayer;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.MediaFormatHolder;
+import com.google.android.exoplayer.SampleSource;
+import com.google.android.exoplayer.SampleSource.SampleSourceReader;
+import com.google.android.exoplayer.TrackRenderer;
+import com.google.android.exoplayer.ext.vp9.VpxDecoderWrapper.InputBuffer;
+import com.google.android.exoplayer.ext.vp9.VpxDecoderWrapper.OutputBuffer;
+import com.google.android.exoplayer.util.MimeTypes;
+
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.os.Handler;
+import android.os.SystemClock;
+import android.view.Surface;
+
+import java.io.IOException;
+
+/**
+ * Decodes and renders video using the native VP9 decoder.
+ */
+public class LibvpxVideoTrackRenderer extends TrackRenderer {
+
+  /**
+   * Interface definition for a callback to be notified of {@link LibvpxVideoTrackRenderer} events.
+   */
+  public interface EventListener {
+
+    /**
+     * Invoked to report the number of frames dropped by the renderer. Dropped frames are reported
+     * whenever the renderer is stopped having dropped frames, and optionally, whenever the count
+     * reaches a specified threshold whilst the renderer is started.
+     *
+     * @param count The number of dropped frames.
+     * @param elapsed The duration in milliseconds over which the frames were dropped. This
+     *     duration is timed from when the renderer was started or from when dropped frames were
+     *     last reported (whichever was more recent), and not from when the first of the reported
+     *     drops occurred.
+     */
+    void onDroppedFrames(int count, long elapsed);
+
+    /**
+     * Invoked each time there's a change in the size of the video being rendered.
+     *
+     * @param width The video width in pixels.
+     * @param height The video height in pixels.
+     */
+    void onVideoSizeChanged(int width, int height);
+
+    /**
+     * Invoked when a frame is rendered to a surface for the first time following that surface
+     * having been set as the target for the renderer.
+     *
+     * @param surface The surface to which a first frame has been rendered.
+     */
+    void onDrawnToSurface(Surface surface);
+
+    /**
+     * Invoked when one of the following happens: libvpx initialization failure, decoder error,
+     * renderer error.
+     *
+     * @param e The corresponding exception.
+     */
+    void onDecoderError(VpxDecoderException e);
+
+  }
+
+  /**
+   * The type of a message that can be passed to an instance of this class via
+   * {@link ExoPlayer#sendMessage} or {@link ExoPlayer#blockingSendMessage}. The message object
+   * should be the target {@link Surface}, or null.
+   */
+  public static final int MSG_SET_SURFACE = 1;
+  public static final int MSG_SET_VPX_SURFACE_VIEW = 2;
+
+  private final SampleSourceReader source;
+  private final boolean scaleToFit;
+  private final Handler eventHandler;
+  private final EventListener eventListener;
+  private final int maxDroppedFrameCountToNotify;
+  private final MediaFormatHolder formatHolder;
+
+  private MediaFormat format;
+  private VpxDecoderWrapper decoder;
+  private InputBuffer inputBuffer;
+  private OutputBuffer outputBuffer;
+
+  private Bitmap bitmap;
+  private boolean drawnToSurface;
+  private boolean renderedFirstFrame;
+  private Surface surface;
+  private VpxVideoSurfaceView vpxVideoSurfaceView;
+  private boolean outputRgb;
+
+  private int trackIndex;
+  private boolean inputStreamEnded;
+  private boolean outputStreamEnded;
+  private boolean sourceIsReady;
+  private int previousWidth;
+  private int previousHeight;
+
+  private int droppedFrameCount;
+  private long droppedFrameAccumulationStartTimeMs;
+
+  /**
+   * @param source The upstream source from which the renderer obtains samples.
+   * @param scaleToFit Boolean that indicates if video frames should be scaled to fit when
+   *     rendering.
+   */
+  public LibvpxVideoTrackRenderer(SampleSource source, boolean scaleToFit) {
+    this(source, scaleToFit, null, null, 0);
+  }
+
+  /**
+   * @param source The upstream source from which the renderer obtains samples.
+   * @param scaleToFit Boolean that indicates if video frames should be scaled to fit when
+   *     rendering.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param maxDroppedFrameCountToNotify The maximum number of frames that can be dropped between
+   *     invocations of {@link EventListener#onDroppedFrames(int, long)}.
+   */
+  public LibvpxVideoTrackRenderer(SampleSource source, boolean scaleToFit,
+      Handler eventHandler, EventListener eventListener, int maxDroppedFrameCountToNotify) {
+    this.source = source.register();
+    this.scaleToFit = scaleToFit;
+    this.eventHandler = eventHandler;
+    this.eventListener = eventListener;
+    this.maxDroppedFrameCountToNotify = maxDroppedFrameCountToNotify;
+    previousWidth = -1;
+    previousHeight = -1;
+    formatHolder = new MediaFormatHolder();
+  }
+
+  @Override
+  protected int doPrepare(long positionUs) throws ExoPlaybackException {
+    try {
+      boolean sourcePrepared = source.prepare(positionUs);
+      if (!sourcePrepared) {
+        return TrackRenderer.STATE_UNPREPARED;
+      }
+    } catch (IOException e) {
+      throw new ExoPlaybackException(e);
+    }
+
+    for (int i = 0; i < source.getTrackCount(); i++) {
+      if (source.getTrackInfo(i).mimeType.equalsIgnoreCase(MimeTypes.VIDEO_VP9)
+          || source.getTrackInfo(i).mimeType.equalsIgnoreCase(MimeTypes.VIDEO_WEBM)) {
+        trackIndex = i;
+        return TrackRenderer.STATE_PREPARED;
+      }
+    }
+
+    return TrackRenderer.STATE_IGNORE;
+  }
+
+  @Override
+  protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
+    if (outputStreamEnded) {
+      return;
+    }
+    try {
+      sourceIsReady = source.continueBuffering(trackIndex, positionUs);
+      checkForDiscontinuity(positionUs);
+      if (format == null) {
+        readFormat(positionUs);
+      } else {
+        // TODO: Add support for dynamic switching between one type of surface to another.
+        // Create the decoder.
+        if (decoder == null) {
+          decoder = new VpxDecoderWrapper(outputRgb);
+          decoder.start();
+        }
+        processOutputBuffer(positionUs, elapsedRealtimeUs);
+
+        // Queue input buffers.
+        while (feedInputBuffer(positionUs)) {}
+      }
+    } catch (VpxDecoderException e) {
+      notifyDecoderError(e);
+      throw new ExoPlaybackException(e);
+    } catch (IOException e) {
+      throw new ExoPlaybackException(e);
+    }
+  }
+
+  private void processOutputBuffer(long positionUs, long elapsedRealtimeUs)
+      throws VpxDecoderException {
+    if (outputStreamEnded) {
+      return;
+    }
+
+    if (outputBuffer == null) {
+      outputBuffer = decoder.dequeueOutputBuffer();
+      if (outputBuffer == null) {
+        return;
+      }
+    }
+
+    if (outputBuffer.flags == VpxDecoderWrapper.FLAG_END_OF_STREAM) {
+      outputStreamEnded = true;
+      releaseOutputBuffer();
+      return;
+    }
+
+    long elapsedSinceStartOfLoop = SystemClock.elapsedRealtime() * 1000 - elapsedRealtimeUs;
+    long timeToRenderUs = outputBuffer.timestampUs - positionUs - elapsedSinceStartOfLoop;
+
+    if (timeToRenderUs < -30000 || outputBuffer.timestampUs < positionUs) {
+      // Drop frame if we are too late.
+      droppedFrameCount++;
+      if (droppedFrameCount == maxDroppedFrameCountToNotify) {
+        notifyAndResetDroppedFrameCount();
+      }
+      releaseOutputBuffer();
+      return;
+    }
+
+    // If we have not renderered any frame so far (either initially or immediately following a
+    // seek), render one frame irresepective of the state.
+    if (!renderedFirstFrame) {
+      renderBuffer();
+      renderedFirstFrame = true;
+      return;
+    }
+
+    // Do nothing if we are not playing or if we are too early to render the next frame.
+    if (getState() != TrackRenderer.STATE_STARTED || timeToRenderUs > 30000) {
+      return;
+    }
+
+    if (timeToRenderUs > 11000) {
+      try {
+        // Subtracting 10000 rather than 11000 ensures that the sleep time
+        // will be at least 1ms.
+        Thread.sleep((timeToRenderUs - 10000) / 1000);
+      } catch (InterruptedException e) {
+        Thread.currentThread().interrupt();
+      }
+    }
+    renderBuffer();
+  }
+
+  private void renderBuffer() throws VpxDecoderException {
+    notifyIfVideoSizeChanged(outputBuffer);
+    if (outputRgb) {
+      renderRgbFrame(outputBuffer, scaleToFit);
+    } else {
+      vpxVideoSurfaceView.renderFrame(outputBuffer);
+    }
+    if (!drawnToSurface) {
+      drawnToSurface = true;
+      notifyDrawnToSurface(surface);
+    }
+    releaseOutputBuffer();
+  }
+
+  private void releaseOutputBuffer() throws VpxDecoderException {
+    decoder.releaseOutputBuffer(outputBuffer);
+    outputBuffer = null;
+  }
+
+  private void renderRgbFrame(OutputBuffer outputBuffer, boolean scale) {
+    if (bitmap == null || bitmap.getWidth() != outputBuffer.width
+        || bitmap.getHeight() != outputBuffer.height) {
+      bitmap = Bitmap.createBitmap(outputBuffer.width, outputBuffer.height, Bitmap.Config.RGB_565);
+    }
+    bitmap.copyPixelsFromBuffer(outputBuffer.data);
+    Canvas canvas = surface.lockCanvas(null);
+    if (scale) {
+      canvas.scale(((float) canvas.getWidth()) / outputBuffer.width,
+          ((float) canvas.getHeight()) / outputBuffer.height);
+    }
+    canvas.drawBitmap(bitmap, 0, 0, null);
+    surface.unlockCanvasAndPost(canvas);
+  }
+
+  private boolean feedInputBuffer(long positionUs) throws IOException, VpxDecoderException {
+    if (inputStreamEnded) {
+      return false;
+    }
+
+    if (inputBuffer == null) {
+      inputBuffer = decoder.getInputBuffer();
+      if (inputBuffer == null) {
+        return false;
+      }
+    }
+
+    int result = source.readData(trackIndex, positionUs, formatHolder, inputBuffer.sampleHolder,
+        false);
+    if (result == SampleSource.NOTHING_READ) {
+      return false;
+    }
+    if (result == SampleSource.DISCONTINUITY_READ) {
+      flushDecoder();
+      return true;
+    }
+    if (result == SampleSource.FORMAT_READ) {
+      format = formatHolder.format;
+      return true;
+    }
+    if (result == SampleSource.END_OF_STREAM) {
+      inputBuffer.flags = VpxDecoderWrapper.FLAG_END_OF_STREAM;
+      decoder.queueInputBuffer(inputBuffer);
+      inputBuffer = null;
+      inputStreamEnded = true;
+      return false;
+    }
+
+    inputBuffer.width = format.width;
+    inputBuffer.height = format.height;
+    decoder.queueInputBuffer(inputBuffer);
+    inputBuffer = null;
+    return true;
+  }
+
+  private void checkForDiscontinuity(long positionUs) throws IOException {
+    if (decoder == null) {
+      return;
+    }
+    int result = source.readData(trackIndex, positionUs, formatHolder, null, true);
+    if (result == SampleSource.DISCONTINUITY_READ) {
+      flushDecoder();
+    }
+  }
+
+  private void flushDecoder() {
+    inputBuffer = null;
+    outputBuffer = null;
+    decoder.flush();
+  }
+
+  @Override
+  protected boolean isEnded() {
+    return outputStreamEnded;
+  }
+
+  @Override
+  protected boolean isReady() {
+    return format != null && sourceIsReady;
+  }
+
+  @Override
+  protected long getDurationUs() {
+    return source.getTrackInfo(trackIndex).durationUs;
+  }
+
+  @Override
+  protected long getBufferedPositionUs() {
+    return source.getBufferedPositionUs();
+  }
+
+  @Override
+  protected void seekTo(long positionUs) throws ExoPlaybackException {
+    source.seekToUs(positionUs);
+    seekToInternal();
+  }
+
+  @Override
+  protected void onEnabled(long positionUs, boolean joining) {
+    source.enable(trackIndex, positionUs);
+    seekToInternal();
+  }
+
+  private void seekToInternal() {
+    sourceIsReady = false;
+    inputStreamEnded = false;
+    outputStreamEnded = false;
+    renderedFirstFrame = false;
+  }
+
+  @Override
+  protected void onStarted() {
+    droppedFrameCount = 0;
+    droppedFrameAccumulationStartTimeMs = SystemClock.elapsedRealtime();
+  }
+
+  @Override
+  protected void onStopped() {
+    notifyAndResetDroppedFrameCount();
+  }
+
+  @Override
+  protected void onReleased() {
+    source.release();
+  }
+
+  @Override
+  protected void onDisabled() {
+    if (decoder != null) {
+      decoder.release();
+      decoder = null;
+    }
+    inputBuffer = null;
+    outputBuffer = null;
+    format = null;
+    source.disable(trackIndex);
+  }
+
+  private void readFormat(long positionUs) throws IOException {
+    int result = source.readData(trackIndex, positionUs, formatHolder, null, false);
+    if (result == SampleSource.FORMAT_READ) {
+      format = formatHolder.format;
+    }
+  }
+
+  @Override
+  public void handleMessage(int messageType, Object message) throws ExoPlaybackException {
+    if (messageType == MSG_SET_SURFACE) {
+      surface = (Surface) message;
+      vpxVideoSurfaceView = null;
+      outputRgb = true;
+    } else if (messageType == MSG_SET_VPX_SURFACE_VIEW) {
+      vpxVideoSurfaceView = (VpxVideoSurfaceView) message;
+      surface = null;
+      outputRgb = false;
+    } else {
+      super.handleMessage(messageType, message);
+    }
+  }
+
+  private void notifyIfVideoSizeChanged(final OutputBuffer outputBuffer) {
+    if (previousWidth == -1 || previousHeight == -1
+        || previousWidth != outputBuffer.width || previousHeight != outputBuffer.height) {
+      previousWidth = outputBuffer.width;
+      previousHeight = outputBuffer.height;
+      if (eventHandler != null && eventListener != null) {
+        eventHandler.post(new Runnable()  {
+          @Override
+          public void run() {
+            eventListener.onVideoSizeChanged(outputBuffer.width, outputBuffer.height);
+          }
+        });
+      }
+    }
+  }
+
+  private void notifyAndResetDroppedFrameCount() {
+    if (eventHandler != null && eventListener != null && droppedFrameCount > 0) {
+      long now = SystemClock.elapsedRealtime();
+      final int countToNotify = droppedFrameCount;
+      final long elapsedToNotify = now - droppedFrameAccumulationStartTimeMs;
+      droppedFrameCount = 0;
+      droppedFrameAccumulationStartTimeMs = now;
+      eventHandler.post(new Runnable()  {
+        @Override
+        public void run() {
+          eventListener.onDroppedFrames(countToNotify, elapsedToNotify);
+        }
+      });
+    }
+  }
+
+  private void notifyDrawnToSurface(final Surface surface) {
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable()  {
+        @Override
+        public void run() {
+          eventListener.onDrawnToSurface(surface);
+        }
+      });
+    }
+  }
+
+  private void notifyDecoderError(final VpxDecoderException e) {
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable()  {
+        @Override
+        public void run() {
+          eventListener.onDecoderError(e);
+        }
+      });
+    }
+  }
+
+}
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
new file mode 100644
index 0000000000..3a65c9cf77
--- /dev/null
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.vp9;
+
+import com.google.android.exoplayer.ext.vp9.VpxDecoderWrapper.OutputBuffer;
+
+import java.nio.ByteBuffer;
+
+/**
+ * JNI Wrapper for the libvpx VP9 decoder.
+ */
+/* package */ class VpxDecoder {
+
+  private final long vpxDecContext;
+
+  static {
+    System.loadLibrary("vpx");
+    System.loadLibrary("vpxJNI");
+  }
+
+  /**
+   * Creates the VP9 Decoder.
+   *
+   * @throws VpxDecoderException if the decoder fails to initialize.
+   */
+  public VpxDecoder() throws VpxDecoderException {
+    vpxDecContext = vpxInit();
+    if (vpxDecContext == 0) {
+      throw new VpxDecoderException("libvpx initialization error: failed to initialize decoder");
+    }
+  }
+
+  /**
+   * Decodes a vp9 encoded frame and converts it to RGB565.
+   *
+   * @param encoded The encoded buffer.
+   * @param size Size of the encoded buffer.
+   * @param outputBuffer The buffer into which the decoded frame should be written.
+   * @param outputRgb True if the buffer should be converted to RGB color format. False if YUV
+   *     format should be retained.
+   * @return 0 on success with a frame to render. 1 on success without a frame to render.
+   * @throws VpxDecoderException on decode failure.
+   */
+  public int decode(ByteBuffer encoded, int size, OutputBuffer outputBuffer, boolean outputRgb) 
+      throws VpxDecoderException {
+    if (vpxDecode(vpxDecContext, encoded, size) != 0) {
+      throw new VpxDecoderException("libvpx decode error: " + vpxGetErrorMessage(vpxDecContext));
+    }
+    return vpxGetFrame(vpxDecContext, outputBuffer, outputRgb);
+  }
+
+  /**
+   * Destroys the decoder.
+   */
+  public void close() {
+    vpxClose(vpxDecContext);
+  }
+
+  private native long vpxInit();
+  private native long vpxClose(long context);
+  private native long vpxDecode(long context, ByteBuffer encoded, int length);
+  private native int vpxGetFrame(long context, OutputBuffer outputBuffer, boolean outputRgb);
+  private native String vpxGetErrorMessage(long context);
+
+}
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderException.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderException.java
new file mode 100644
index 0000000000..1afa01a6c7
--- /dev/null
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderException.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.vp9;
+
+/**
+ * Thrown when a libvpx decoder error occurs.
+ */
+public class VpxDecoderException extends Exception {
+
+    public VpxDecoderException(String message) {
+      super(message);
+    }
+
+}
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderWrapper.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderWrapper.java
new file mode 100644
index 0000000000..b108ca7eb2
--- /dev/null
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoderWrapper.java
@@ -0,0 +1,299 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.vp9;
+
+import com.google.android.exoplayer.SampleHolder;
+
+import java.nio.ByteBuffer;
+import java.util.LinkedList;
+
+/**
+ * Wraps {@link VpxDecoder}, exposing a higher level decoder interface.
+ */
+/* package */ class VpxDecoderWrapper extends Thread {
+
+  public static final int FLAG_END_OF_STREAM = 1;
+
+  private static final int INPUT_BUFFER_SIZE = 768 * 1024; // Value based on cs/SoftVpx.cpp.
+  private static final int NUM_BUFFERS = 16;
+
+  private final Object lock;
+  private final boolean outputRgb;
+
+  private final LinkedList<InputBuffer> queuedInputBuffers;
+  private final LinkedList<OutputBuffer> queuedOutputBuffers;
+  private final InputBuffer[] availableInputBuffers;
+  private final OutputBuffer[] availableOutputBuffers;
+  private int availableInputBufferCount;
+  private int availableOutputBufferCount;
+
+  private boolean flushDecodedOutputBuffer;
+  private boolean released;
+
+  private VpxDecoderException decoderException;
+
+  /**
+   * @param outputRgb True if the decoded output is in RGB color format. False if it is in YUV
+   *     color format.
+   */
+  public VpxDecoderWrapper(boolean outputRgb) {
+    lock = new Object();
+    this.outputRgb = outputRgb;
+    queuedInputBuffers = new LinkedList<>();
+    queuedOutputBuffers = new LinkedList<>();
+    availableInputBuffers = new InputBuffer[NUM_BUFFERS];
+    availableOutputBuffers = new OutputBuffer[NUM_BUFFERS];
+    availableInputBufferCount = NUM_BUFFERS;
+    availableOutputBufferCount = NUM_BUFFERS;
+    for (int i = 0; i < NUM_BUFFERS; i++) {
+      availableInputBuffers[i] = new InputBuffer();
+      availableOutputBuffers[i] = new OutputBuffer();
+    }
+  }
+
+  public InputBuffer getInputBuffer() throws VpxDecoderException {
+    synchronized (lock) {
+      maybeThrowDecoderError();
+      if (availableInputBufferCount == 0) {
+        return null;
+      }
+      InputBuffer inputBuffer = availableInputBuffers[--availableInputBufferCount];
+      inputBuffer.flags = 0;
+      inputBuffer.sampleHolder.data.clear();
+      return inputBuffer;
+    }
+  }
+
+  public void queueInputBuffer(InputBuffer inputBuffer) throws VpxDecoderException {
+    synchronized (lock) {
+      maybeThrowDecoderError();
+      queuedInputBuffers.addLast(inputBuffer);
+      maybeNotifyDecodeLoop();
+    }
+  }
+
+  public OutputBuffer dequeueOutputBuffer() throws VpxDecoderException {
+    synchronized (lock) {
+      maybeThrowDecoderError();
+      if (queuedOutputBuffers.isEmpty()) {
+        return null;
+      }
+      return queuedOutputBuffers.removeFirst();
+    }
+  }
+
+  public void releaseOutputBuffer(OutputBuffer outputBuffer) throws VpxDecoderException {
+    synchronized (lock) {
+      maybeThrowDecoderError();
+      availableOutputBuffers[availableOutputBufferCount++] = outputBuffer;
+      maybeNotifyDecodeLoop();
+    }
+  }
+
+  public void flush() {
+    synchronized (lock) {
+      flushDecodedOutputBuffer = true;
+      while (!queuedInputBuffers.isEmpty()) {
+        availableInputBuffers[availableInputBufferCount++] = queuedInputBuffers.removeFirst();
+      }
+      while (!queuedOutputBuffers.isEmpty()) {
+        availableOutputBuffers[availableOutputBufferCount++] = queuedOutputBuffers.removeFirst();
+      }
+    }
+  }
+
+  public void release() {
+    synchronized (lock) {
+      released = true;
+      lock.notify();
+    }
+    try {
+      join();
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+    }
+  }
+
+  private void maybeThrowDecoderError() throws VpxDecoderException {
+    if (decoderException != null) {
+      throw decoderException;
+    }
+  }
+
+  /**
+   * Notifies the decode loop if there exists a queued input buffer and an available output buffer
+   * to decode into.
+   * <p>
+   * Should only be called whilst synchronized on the lock object.
+   */
+  private void maybeNotifyDecodeLoop() {
+    if (!queuedInputBuffers.isEmpty() && availableOutputBufferCount > 0) {
+      lock.notify();
+    }
+  }
+
+  @Override
+  public void run() {
+    VpxDecoder decoder = null;
+    try {
+      decoder = new VpxDecoder();
+      while (decodeBuffer(decoder)) {
+        // Do nothing.
+      }
+    } catch (VpxDecoderException e) {
+      synchronized (lock) {
+        decoderException = e;
+      }
+    } catch (InterruptedException e) {
+      // Shouldn't ever happen.
+    } finally {
+      if (decoder != null) {
+        decoder.close();
+      }
+    }
+  }
+
+  private boolean decodeBuffer(VpxDecoder decoder) throws InterruptedException,
+      VpxDecoderException {
+    InputBuffer inputBuffer;
+    OutputBuffer outputBuffer;
+
+    // Wait until we have an input buffer to decode, and an output buffer to decode into.
+    synchronized (lock) {
+      while (!released && (queuedInputBuffers.isEmpty() || availableOutputBufferCount == 0)) {
+        lock.wait();
+      }
+      if (released) {
+        return false;
+      }
+      inputBuffer = queuedInputBuffers.removeFirst();
+      outputBuffer = availableOutputBuffers[--availableOutputBufferCount];
+      flushDecodedOutputBuffer = false;
+    }
+
+    // Decode.
+    int decodeResult = -1;
+    if (inputBuffer.flags == FLAG_END_OF_STREAM) {
+      outputBuffer.flags = FLAG_END_OF_STREAM;
+    } else {
+      SampleHolder sampleHolder = inputBuffer.sampleHolder;
+      outputBuffer.timestampUs = sampleHolder.timeUs;
+      outputBuffer.flags = 0;
+      sampleHolder.data.position(sampleHolder.data.position() - sampleHolder.size);
+      decodeResult = decoder.decode(sampleHolder.data, sampleHolder.size, outputBuffer, outputRgb);
+    }
+
+    synchronized (lock) {
+      if (flushDecodedOutputBuffer
+          || inputBuffer.sampleHolder.isDecodeOnly()
+          || decodeResult == 1) {
+        // In the following cases, we make the output buffer available again rather than queuing it
+        // to be consumed:
+        // 1) A flush occured whilst we were decoding.
+        // 2) The input sample has decodeOnly flag set.
+        // 3) The decode succeeded, but we did not get any frame back for rendering (happens in case
+        // of an unpacked altref frame).
+        availableOutputBuffers[availableOutputBufferCount++] = outputBuffer;
+      } else {
+        // Queue the decoded output buffer to be consumed.
+        queuedOutputBuffers.addLast(outputBuffer);
+      }
+      // Make the input buffer available again.
+      availableInputBuffers[availableInputBufferCount++] = inputBuffer;
+    }
+
+    return true;
+  }
+
+  /* package */ static final class InputBuffer {
+
+    public final SampleHolder sampleHolder;
+
+    public int width;
+    public int height;
+    public int flags;
+
+    public InputBuffer() {
+      sampleHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_DIRECT);
+      sampleHolder.data = ByteBuffer.allocateDirect(INPUT_BUFFER_SIZE);
+    }
+
+  }
+
+  /* package */ static final class OutputBuffer {
+
+    public ByteBuffer data;
+    public long timestampUs;
+    public int width;
+    public int height;
+    public int flags;
+    public ByteBuffer[] yuvPlanes;
+    public int[] yuvStrides;
+
+    /**
+     * This method is called from C++ through JNI after decoding is done. It will resize the
+     * buffer based on the given dimensions.
+     */
+    public void initForRgbFrame(int width, int height) {
+      this.width = width;
+      this.height = height;
+      int minimumRgbSize = width * height * 2;
+      if (data == null || data.capacity() < minimumRgbSize) {
+        data = ByteBuffer.allocateDirect(minimumRgbSize);
+        yuvPlanes = null;
+      }
+      data.position(0);
+      data.limit(minimumRgbSize);
+    }
+
+    /**
+     * This method is called from C++ through JNI after decoding is done. It will resize the
+     * buffer based on the given stride.
+     */
+    public void initForYuvFrame(int width, int height, int yStride, int uvStride) {
+      this.width = width;
+      this.height = height;
+      int yLength = yStride * height;
+      int uvLength = uvStride * ((height + 1) / 2);
+      int minimumYuvSize = yLength + (uvLength * 2);
+      if (data == null || data.capacity() < minimumYuvSize) {
+        data = ByteBuffer.allocateDirect(minimumYuvSize);
+      }
+      data.limit(minimumYuvSize);
+      if (yuvPlanes == null) {
+        yuvPlanes = new ByteBuffer[3];
+      }
+      // Rewrapping has to be done on every frame since the stride might have changed.
+      data.position(0);
+      yuvPlanes[0] = data.slice();
+      yuvPlanes[0].limit(yLength);
+      data.position(yLength);
+      yuvPlanes[1] = data.slice();
+      yuvPlanes[1].limit(uvLength);
+      data.position(yLength + uvLength);
+      yuvPlanes[2] = data.slice();
+      yuvPlanes[2].limit(uvLength);
+      if (yuvStrides == null) {
+        yuvStrides = new int[3];
+      }
+      yuvStrides[0] = yStride;
+      yuvStrides[1] = uvStride;
+      yuvStrides[2] = uvStride;
+    }
+
+  }
+
+}
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxRenderer.java
new file mode 100644
index 0000000000..c78619594f
--- /dev/null
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxRenderer.java
@@ -0,0 +1,210 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.vp9;
+
+import com.google.android.exoplayer.ext.vp9.VpxDecoderWrapper.OutputBuffer;
+
+import android.opengl.GLES20;
+import android.opengl.GLSurfaceView;
+
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.FloatBuffer;
+
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.opengles.GL10;
+
+/**
+ * GLSurfaceView.Renderer implementation that can render YUV Frames returned by libvpx after
+ * decoding. It does the YUV to RGB color conversion in the Fragment Shader.
+ */
+/* package */ class VpxRenderer implements GLSurfaceView.Renderer {
+
+  private static final String VERTEX_SHADER =
+      "varying vec2 interp_tc;\n"
+      + "attribute vec4 in_pos;\n"
+      + "attribute vec2 in_tc;\n"
+      + "void main() {\n"
+      + "  gl_Position = in_pos;\n"
+      + "  interp_tc = in_tc;\n"
+      + "}\n";
+  private static final String[] TEXTURE_UNIFORMS = {"y_tex", "u_tex", "v_tex"};
+  private static final String FRAGMENT_SHADER =
+      "precision mediump float;\n"
+      + "varying vec2 interp_tc;\n"
+      + "uniform sampler2D y_tex;\n"
+      + "uniform sampler2D u_tex;\n"
+      + "uniform sampler2D v_tex;\n"
+      + "void main() {\n"
+      + "  float y = 1.164 * (texture2D(y_tex, interp_tc).r - 0.0625);\n"
+      + "  float u = texture2D(u_tex, interp_tc).r - 0.5;\n"
+      + "  float v = texture2D(v_tex, interp_tc).r - 0.5;\n"
+      + "  gl_FragColor = vec4(y + 1.596 * v, "
+      + "                      y - 0.391 * u - 0.813 * v, "
+      + "                      y + 2.018 * u, "
+      + "                      1.0);\n"
+      + "}\n";
+  private static final FloatBuffer TEXTURE_VERTICES = nativeFloatBuffer(
+      -1.0f, 1.0f,
+      -1.0f, -1.0f,
+      1.0f, 1.0f,
+      1.0f, -1.0f);
+  private final int[] yuvTextures = new int[3];
+
+  private int program;
+  private int texLocation;
+  private FloatBuffer textureCoords;
+  private volatile OutputBuffer outputBuffer;
+  private int previousWidth;
+  private int previousStride;
+
+  public VpxRenderer() {
+    previousWidth = -1;
+    previousStride = -1;
+  }
+
+  /**
+   * Set a frame to be rendered. This should be followed by a call to
+   * VpxVideoSurfaceView.requestRender() to actually render the frame.
+   *
+   * @param outputBuffer OutputBuffer containing the YUV Frame to be rendered
+   */
+  public void setFrame(OutputBuffer outputBuffer) {
+    this.outputBuffer = outputBuffer;
+  }
+
+  @Override
+  public void onSurfaceCreated(GL10 unused, EGLConfig config) {
+    // Create the GL program.
+    program = GLES20.glCreateProgram();
+
+    // Add the vertex and fragment shaders.
+    addShader(GLES20.GL_VERTEX_SHADER, VERTEX_SHADER, program);
+    addShader(GLES20.GL_FRAGMENT_SHADER, FRAGMENT_SHADER, program);
+
+    // Link the GL program.
+    GLES20.glLinkProgram(program);
+    int[] result = new int[] {
+        GLES20.GL_FALSE
+    };
+    result[0] = GLES20.GL_FALSE;
+    GLES20.glGetProgramiv(program, GLES20.GL_LINK_STATUS, result, 0);
+    abortUnless(result[0] == GLES20.GL_TRUE, GLES20.glGetProgramInfoLog(program));
+    GLES20.glUseProgram(program);
+    int posLocation = GLES20.glGetAttribLocation(program, "in_pos");
+    GLES20.glEnableVertexAttribArray(posLocation);
+    GLES20.glVertexAttribPointer(
+        posLocation, 2, GLES20.GL_FLOAT, false, 0, TEXTURE_VERTICES);
+    texLocation = GLES20.glGetAttribLocation(program, "in_tc");
+    GLES20.glEnableVertexAttribArray(texLocation);
+    setupTextures();
+    checkNoGLES2Error();
+  }
+
+  @Override
+  public void onSurfaceChanged(GL10 unused, int width, int height) {
+    GLES20.glViewport(0, 0, width, height);
+  }
+
+  @Override
+  public void onDrawFrame(GL10 unused) {
+    OutputBuffer outputBuffer = this.outputBuffer;
+    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
+    if (outputBuffer == null) {
+      // Nothing to render yet.
+      return;
+    }
+    for (int i = 0; i < 3; i++) {
+      int h = (i == 0) ? outputBuffer.height : (outputBuffer.height + 1) / 2;
+      GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + i);
+      GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, yuvTextures[i]);
+      GLES20.glPixelStorei(GLES20.GL_UNPACK_ALIGNMENT, 1);
+      GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_LUMINANCE, outputBuffer.yuvStrides[i],
+          h, 0, GLES20.GL_LUMINANCE, GLES20.GL_UNSIGNED_BYTE, outputBuffer.yuvPlanes[i]);
+    }
+    // Set cropping of stride if either width or stride has changed.
+    if (previousWidth != outputBuffer.width || previousStride != outputBuffer.yuvStrides[0]) {
+      float crop = (float) outputBuffer.width / outputBuffer.yuvStrides[0];
+      textureCoords = nativeFloatBuffer(
+          0.0f, 0.0f,
+          0.0f, 1.0f,
+          crop, 0.0f,
+          crop, 1.0f);
+      GLES20.glVertexAttribPointer(
+          texLocation, 2, GLES20.GL_FLOAT, false, 0, textureCoords);
+      previousWidth = outputBuffer.width;
+      previousStride = outputBuffer.yuvStrides[0];
+    }
+    GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4);
+    checkNoGLES2Error();
+  }
+
+  private void addShader(int type, String source, int program) {
+    int[] result = new int[] {
+        GLES20.GL_FALSE
+    };
+    int shader = GLES20.glCreateShader(type);
+    GLES20.glShaderSource(shader, source);
+    GLES20.glCompileShader(shader);
+    GLES20.glGetShaderiv(shader, GLES20.GL_COMPILE_STATUS, result, 0);
+    abortUnless(result[0] == GLES20.GL_TRUE,
+        GLES20.glGetShaderInfoLog(shader) + ", source: " + source);
+    GLES20.glAttachShader(program, shader);
+    GLES20.glDeleteShader(shader);
+
+    checkNoGLES2Error();
+  }
+
+  private void setupTextures() {
+    GLES20.glGenTextures(3, yuvTextures, 0);
+    for (int i = 0; i < 3; i++)  {
+      GLES20.glUniform1i(GLES20.glGetUniformLocation(program, TEXTURE_UNIFORMS[i]), i);
+      GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + i);
+      GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, yuvTextures[i]);
+      GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+          GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
+      GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+          GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
+      GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+          GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
+      GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+          GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
+    }
+    checkNoGLES2Error();
+  }
+
+  private void abortUnless(boolean condition, String msg) {
+    if (!condition) {
+      throw new RuntimeException(msg);
+    }
+  }
+
+  private void checkNoGLES2Error() {
+    int error = GLES20.glGetError();
+    if (error != GLES20.GL_NO_ERROR) {
+      throw new RuntimeException("GLES20 error: " + error);
+    }
+  }
+
+  private static FloatBuffer nativeFloatBuffer(float... array) {
+    FloatBuffer buffer = ByteBuffer.allocateDirect(array.length * 4).order(
+        ByteOrder.nativeOrder()).asFloatBuffer();
+    buffer.put(array);
+    buffer.flip();
+    return buffer;
+  }
+
+}
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxVideoSurfaceView.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxVideoSurfaceView.java
new file mode 100644
index 0000000000..1b8046a6d2
--- /dev/null
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxVideoSurfaceView.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.vp9;
+
+import com.google.android.exoplayer.ext.vp9.VpxDecoderWrapper.OutputBuffer;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.opengl.GLSurfaceView;
+import android.util.AttributeSet;
+
+/**
+ * A GLSurfaceView extension that scales itself to the given aspect ratio.
+ */
+@TargetApi(11)
+public class VpxVideoSurfaceView extends GLSurfaceView {
+
+  private final VpxRenderer renderer;
+
+  public VpxVideoSurfaceView(Context context) {
+    this(context, null);
+  }
+
+  public VpxVideoSurfaceView(Context context, AttributeSet attrs) {
+    super(context, attrs);
+    renderer = new VpxRenderer();
+    setPreserveEGLContextOnPause(true);
+    setEGLContextClientVersion(2);
+    setRenderer(renderer);
+    setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
+  }
+
+  public void renderFrame(OutputBuffer outputBuffer) {
+    renderer.setFrame(outputBuffer);
+    requestRender();
+  }
+
+}
diff --git a/extensions/vp9/src/main/jni/Android.mk b/extensions/vp9/src/main/jni/Android.mk
new file mode 100644
index 0000000000..fa566dbb50
--- /dev/null
+++ b/extensions/vp9/src/main/jni/Android.mk
@@ -0,0 +1,43 @@
+#
+# Copyright (C) 2014 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+WORKING_DIR := $(call my-dir)
+include $(CLEAR_VARS)
+APP_PLATFORM := android-10
+LIBVPX_ROOT := $(WORKING_DIR)/libvpx
+LIBYUV_ROOT := $(WORKING_DIR)/libyuv
+
+# build libyuv_static.a
+LOCAL_PATH := $(WORKING_DIR)
+include $(LIBYUV_ROOT)/Android.mk
+
+# build libvpx.so
+LOCAL_PATH := $(WORKING_DIR)
+include libvpx.mk
+
+# build libvpxJNI.so
+include $(CLEAR_VARS)
+LOCAL_PATH := $(WORKING_DIR)
+LOCAL_MODULE := libvpxJNI
+LOCAL_ARM_MODE := arm
+LOCAL_CPP_EXTENSION := .cc
+LOCAL_SRC_FILES := vpx_jni.cc
+LOCAL_LDLIBS := -llog -lz -lm
+LOCAL_SHARED_LIBRARIES := libvpx
+LOCAL_STATIC_LIBRARIES := libyuv_static cpufeatures
+include $(BUILD_SHARED_LIBRARY)
+
+$(call import-module,android/cpufeatures)
diff --git a/extensions/vp9/src/main/jni/Application.mk b/extensions/vp9/src/main/jni/Application.mk
new file mode 100644
index 0000000000..6563af0f50
--- /dev/null
+++ b/extensions/vp9/src/main/jni/Application.mk
@@ -0,0 +1,19 @@
+#
+# Copyright (C) 2014 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+APP_OPTIM := release
+APP_STL := gnustl_static
+APP_CPPFLAGS := -frtti
diff --git a/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh b/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh
new file mode 100755
index 0000000000..d86978bd18
--- /dev/null
+++ b/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh
@@ -0,0 +1,106 @@
+#!/bin/bash
+#
+# Copyright (C) 2014 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+# a bash script that generates the necessary config files for libvpx android ndk
+# builds.
+
+set -e
+
+if [ $# -ne 1 ]; then
+  echo "Usage: ${0} <path_to_android_ndk>"
+  exit
+fi
+
+ndk="${1}"
+shift 1
+
+# configuration parameters common to all architectures
+common_params="--disable-examples --disable-docs --enable-realtime-only"
+common_params+=" --disable-vp8 --disable-vp9-encoder --disable-webm-io"
+common_params+=" --disable-libyuv --disable-runtime-cpu-detect"
+
+# configuration parameters for various architectures
+arch[0]="armeabi-v7a"
+config[0]="--target=armv7-android-gcc --sdk-path=$ndk --enable-neon"
+config[0]+=" --enable-neon-asm"
+
+arch[1]="armeabi"
+config[1]="--target=armv7-android-gcc --sdk-path=$ndk --disable-neon"
+config[1]+=" --disable-neon-asm"
+
+arch[2]="mips"
+config[2]="--force-target=mips32-android-gcc --sdk-path=$ndk"
+
+arch[3]="x86"
+config[3]="--force-target=x86-android-gcc --sdk-path=$ndk --disable-sse3"
+config[3]+=" --disable-ssse3 --disable-sse4_1 --disable-avx --disable-avx2"
+config[3]+=" --enable-pic"
+
+limit=$((${#arch[@]} - 1))
+
+# list of files allowed after running configure in each arch directory.
+# everything else will be removed.
+allowed_files="libvpx_srcs.txt vpx_config.c vpx_config.h vpx_scale_rtcd.h"
+allowed_files+=" vp8_rtcd.h vp9_rtcd.h vpx_version.h vpx_config.asm"
+
+remove_trailing_whitespace() {
+  sed -i 's/\s\+$//' "$@"
+}
+
+convert_asm() {
+  for i in $(seq 0 ${limit}); do
+    while read file; do
+      case "${file}" in
+        *.asm.s)
+          asm_file="libvpx/${file%.s}"
+          cat "${asm_file}" | libvpx/build/make/ads2gas.pl > "libvpx/${file}"
+          remove_trailing_whitespace "libvpx/${file}"
+          rm "${asm_file}"
+          ;;
+      esac
+    done < libvpx_android_configs/${arch[${i}]}/libvpx_srcs.txt
+  done
+}
+
+extglob_status="$(shopt extglob | cut -f2)"
+shopt -s extglob
+for i in $(seq 0 ${limit}); do
+  mkdir -p "libvpx_android_configs/${arch[${i}]}"
+  cd "libvpx_android_configs/${arch[${i}]}"
+
+  # configure and make
+  echo "build_android_configs: "
+  echo "configure ${config[${i}]} ${common_params}"
+  ../../libvpx/configure ${config[${i}]} ${common_params}
+  rm -f libvpx_srcs.txt
+  make libvpx_srcs.txt
+
+  # remove files that aren't needed
+  rm -rf !(${allowed_files// /|})
+  remove_trailing_whitespace *
+
+  cd ../..
+done
+
+# restore extglob status as it was before
+if [[ "${extglob_status}" == "off" ]]; then
+  shopt -u extglob
+fi
+
+convert_asm
+
+echo "Generated android config files."
diff --git a/extensions/vp9/src/main/jni/libvpx.mk b/extensions/vp9/src/main/jni/libvpx.mk
new file mode 100644
index 0000000000..369b3b7f94
--- /dev/null
+++ b/extensions/vp9/src/main/jni/libvpx.mk
@@ -0,0 +1,51 @@
+#
+# Copyright (C) 2014 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+CONFIG_DIR := $(LOCAL_PATH)/libvpx_android_configs/$(TARGET_ARCH_ABI)
+libvpx_source_dir := $(LOCAL_PATH)/libvpx
+
+LOCAL_MODULE := libvpx
+LOCAL_MODULE_CLASS := STATIC_LIBRARIES
+LOCAL_CFLAGS := -DHAVE_CONFIG_H=vpx_config.h
+LOCAL_ARM_MODE := arm
+LOCAL_CFLAGS += -O3
+
+# config specific include should go first to pick up the config specific rtcd.
+LOCAL_C_INCLUDES := $(CONFIG_DIR) $(libvpx_source_dir)
+
+# generate source file list
+libvpx_codec_srcs := $(sort $(shell cat $(CONFIG_DIR)/libvpx_srcs.txt))
+LOCAL_SRC_FILES := libvpx_android_configs/$(TARGET_ARCH_ABI)/vpx_config.c
+LOCAL_SRC_FILES += $(addprefix libvpx/, $(filter-out vpx_config.c, \
+                     $(filter %.c, $(libvpx_codec_srcs))))
+
+# include assembly files if they exist
+# "%.asm.s" covers neon assembly and "%.asm" covers x86 assembly
+LOCAL_SRC_FILES += $(addprefix libvpx/, \
+                     $(filter %.asm.s %.asm, $(libvpx_codec_srcs)))
+
+ifneq ($(findstring armeabi-v7a, $(TARGET_ARCH_ABI)),)
+# append .neon to *_neon.c and *.s
+LOCAL_SRC_FILES := $(subst _neon.c,_neon.c.neon,$(LOCAL_SRC_FILES))
+LOCAL_SRC_FILES := $(subst .s,.s.neon,$(LOCAL_SRC_FILES))
+endif
+
+LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/libvpx \
+                           $(LOCAL_PATH)/libvpx/vpx
+
+include $(BUILD_SHARED_LIBRARY)
diff --git a/extensions/vp9/src/main/jni/vpx_jni.cc b/extensions/vp9/src/main/jni/vpx_jni.cc
new file mode 100644
index 0000000000..21a845d779
--- /dev/null
+++ b/extensions/vp9/src/main/jni/vpx_jni.cc
@@ -0,0 +1,149 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <cpu-features.h>
+#include <jni.h>
+
+#include <android/log.h>
+
+#include <algorithm>
+#include <cstdlib>
+#include <cstdio>
+#include <new>
+
+#include "libyuv.h"  // NOLINT
+
+#define VPX_CODEC_DISABLE_COMPAT 1
+#include "vpx/vpx_decoder.h"
+#include "vpx/vp8dx.h"
+
+#define LOG_TAG "LIBVPX_DEC"
+#define LOGE(...) ((void)__android_log_print(ANDROID_LOG_ERROR, LOG_TAG, \
+                                             __VA_ARGS__))
+
+#define FUNC(RETURN_TYPE, NAME, ...) \
+  extern "C" { \
+  JNIEXPORT RETURN_TYPE \
+    Java_com_google_android_exoplayer_ext_vp9_VpxDecoder_ ## NAME \
+      (JNIEnv* env, jobject thiz, ##__VA_ARGS__);\
+  } \
+  JNIEXPORT RETURN_TYPE \
+    Java_com_google_android_exoplayer_ext_vp9_VpxDecoder_ ## NAME \
+      (JNIEnv* env, jobject thiz, ##__VA_ARGS__)\
+
+// JNI references for OutputBuffer class.
+static jmethodID initForRgbFrame;
+static jmethodID initForYuvFrame;
+static jfieldID dataField;
+
+jint JNI_OnLoad(JavaVM* vm, void* reserved) {
+  JNIEnv* env;
+  if (vm->GetEnv(reinterpret_cast<void**>(&env), JNI_VERSION_1_6) != JNI_OK) {
+    return -1;
+  }
+  return JNI_VERSION_1_6;
+}
+
+FUNC(jlong, vpxInit) {
+  vpx_codec_ctx_t* context = new vpx_codec_ctx_t();
+  vpx_codec_dec_cfg_t cfg = {0};
+  cfg.threads = android_getCpuCount();
+  if (vpx_codec_dec_init(context, &vpx_codec_vp9_dx_algo, &cfg, 0)) {
+    LOGE("ERROR: Fail to initialize libvpx decoder.");
+    return 0;
+  }
+
+  // Populate JNI References.
+  const jclass outputBufferClass = env->FindClass(
+      "com/google/android/exoplayer/ext/vp9/VpxDecoderWrapper$OutputBuffer");
+  initForYuvFrame = env->GetMethodID(outputBufferClass, "initForYuvFrame",
+                                     "(IIII)V");
+  initForRgbFrame = env->GetMethodID(outputBufferClass, "initForRgbFrame",
+                                     "(II)V");
+  dataField = env->GetFieldID(outputBufferClass, "data",
+                              "Ljava/nio/ByteBuffer;");
+
+  return reinterpret_cast<intptr_t>(context);
+}
+
+FUNC(jlong, vpxDecode, jlong jContext, jobject encoded, jint len) {
+  vpx_codec_ctx_t* const context = reinterpret_cast<vpx_codec_ctx_t*>(jContext);
+  const uint8_t* const buffer =
+      reinterpret_cast<const uint8_t*>(env->GetDirectBufferAddress(encoded));
+  const vpx_codec_err_t status =
+      vpx_codec_decode(context, buffer, len, NULL, 0);
+  if (status != VPX_CODEC_OK) {
+    LOGE("ERROR: vpx_codec_decode() failed, status= %d", status);
+    return -1;
+  }
+  return 0;
+}
+
+FUNC(jlong, vpxClose, jlong jContext) {
+  vpx_codec_ctx_t* const context = reinterpret_cast<vpx_codec_ctx_t*>(jContext);
+  vpx_codec_destroy(context);
+  delete context;
+  return 0;
+}
+
+FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer, jboolean isRGB) {
+  vpx_codec_ctx_t* const context = reinterpret_cast<vpx_codec_ctx_t*>(jContext);
+  vpx_codec_iter_t iter = NULL;
+  const vpx_image_t* const img = vpx_codec_get_frame(context, &iter);
+
+  if (img == NULL) {
+    return 1;
+  }
+
+  if (isRGB == JNI_TRUE) {
+    // resize buffer if required.
+    env->CallVoidMethod(jOutputBuffer, initForRgbFrame, img->d_w, img->d_h);
+
+    // get pointer to the data buffer.
+    const jobject dataObject = env->GetObjectField(jOutputBuffer, dataField);
+    uint8_t* const dst =
+        reinterpret_cast<uint8_t*>(env->GetDirectBufferAddress(dataObject));
+
+    libyuv::I420ToRGB565(img->planes[VPX_PLANE_Y], img->stride[VPX_PLANE_Y],
+                         img->planes[VPX_PLANE_U], img->stride[VPX_PLANE_U],
+                         img->planes[VPX_PLANE_V], img->stride[VPX_PLANE_V],
+                         dst, img->d_w * 2, img->d_w, img->d_h);
+  } else {
+    // resize buffer if required.
+    env->CallVoidMethod(jOutputBuffer, initForYuvFrame, img->d_w, img->d_h,
+                        img->stride[VPX_PLANE_Y], img->stride[VPX_PLANE_U]);
+
+    // get pointer to the data buffer.
+    const jobject dataObject = env->GetObjectField(jOutputBuffer, dataField);
+    jbyte* const data =
+        reinterpret_cast<jbyte*>(env->GetDirectBufferAddress(dataObject));
+
+    // TODO: This copy can be eliminated by using external frame buffers. NOLINT
+    // This is insignificant for smaller videos but takes ~1.5ms for 1080p
+    // clips. So this should eventually be gotten rid of.
+    const uint64_t y_length = img->stride[VPX_PLANE_Y] * img->d_h;
+    const uint64_t uv_length = img->stride[VPX_PLANE_U] * ((img->d_h + 1) / 2);
+    memcpy(data, img->planes[VPX_PLANE_Y], y_length);
+    memcpy(data + y_length, img->planes[VPX_PLANE_U], uv_length);
+    memcpy(data + y_length + uv_length, img->planes[VPX_PLANE_V], uv_length);
+  }
+  return 0;
+}
+
+FUNC(jstring, vpxGetErrorMessage, jlong jContext) {
+  vpx_codec_ctx_t* const context = reinterpret_cast<vpx_codec_ctx_t*>(jContext);
+  return env->NewStringUTF(vpx_codec_error(context));
+}
diff --git a/extensions/vp9/src/main/project.properties b/extensions/vp9/src/main/project.properties
new file mode 100644
index 0000000000..2ed62fbfcf
--- /dev/null
+++ b/extensions/vp9/src/main/project.properties
@@ -0,0 +1,16 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-22
+android.library=true
+android.library.reference.1=../../../../library/src/main
diff --git a/extensions/vp9/src/main/res/.README.txt b/extensions/vp9/src/main/res/.README.txt
new file mode 100644
index 0000000000..c27147ce56
--- /dev/null
+++ b/extensions/vp9/src/main/res/.README.txt
@@ -0,0 +1,2 @@
+This file is needed to make sure the res directory is present.
+The file is ignored by the Android toolchain because its name starts with a dot.
diff --git a/library/build.gradle b/library/build.gradle
index 6673253faa..c63edeef99 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -38,9 +38,19 @@ android {
     lintOptions {
         abortOnError false
     }
+
+    sourceSets {
+        androidTest {
+            assets.srcDirs = ['src/test/assets']
+            java.srcDirs = ['src/test/java']
+        }
+    }
 }
 
 dependencies {
+    androidTestCompile 'com.google.dexmaker:dexmaker:1.2'
+    androidTestCompile 'com.google.dexmaker:dexmaker-mockito:1.2'
+    androidTestCompile 'org.mockito:mockito-core:1.9.5'
 }
 
 android.libraryVariants.all { variant ->
@@ -62,7 +72,7 @@ android.libraryVariants.all { variant ->
         classpath = files(variant.javaCompile.classpath.files, project.android.getBootClasspath())
         options {
             links "http://docs.oracle.com/javase/7/docs/api/"
-            linksOffline "https://d.android.com/reference","${android.sdkDirectory}/docs/reference"
+            linksOffline "https://developer.android.com/reference","${android.sdkDirectory}/docs/reference"
         }
         exclude '**/BuildConfig.java'
         exclude '**/R.java'
@@ -74,7 +84,7 @@ publish {
     userOrg = 'google'
     groupId = 'com.google.android.exoplayer'
     artifactId = 'exoplayer'
-    version = 'r1.3.3'
+    version = 'r1.4.0'
     description = 'The ExoPlayer library.'
     website = 'https://github.com/google/ExoPlayer'
 }
diff --git a/library/src/main/.settings/org.eclipse.jdt.core.prefs b/library/src/main/.settings/org.eclipse.jdt.core.prefs
index b080d2ddc8..64cef5023a 100644
--- a/library/src/main/.settings/org.eclipse.jdt.core.prefs
+++ b/library/src/main/.settings/org.eclipse.jdt.core.prefs
@@ -1,4 +1,4 @@
 eclipse.preferences.version=1
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
-org.eclipse.jdt.core.compiler.compliance=1.6
-org.eclipse.jdt.core.compiler.source=1.6
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.7
+org.eclipse.jdt.core.compiler.compliance=1.7
+org.eclipse.jdt.core.compiler.source=1.7
diff --git a/library/src/main/AndroidManifest.xml b/library/src/main/AndroidManifest.xml
index 6327960ac1..b36ae95abe 100644
--- a/library/src/main/AndroidManifest.xml
+++ b/library/src/main/AndroidManifest.xml
@@ -17,9 +17,11 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer">
 
+  <!-- For streaming media over the network. -->
   <uses-permission android:name="android.permission.INTERNET"/>
-  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
-  <uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/>
+  <!-- For reading media from external storage. -->
+  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
+  <!-- For writing media to external storage. -->
   <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
 
   <!--
diff --git a/library/src/main/java/com/google/android/exoplayer/AspectRatioFrameLayout.java b/library/src/main/java/com/google/android/exoplayer/AspectRatioFrameLayout.java
new file mode 100644
index 0000000000..92e9a1f798
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/AspectRatioFrameLayout.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.widget.FrameLayout;
+
+/**
+ * A {@link FrameLayout} that resizes itself to match a specified aspect ratio.
+ */
+public final class AspectRatioFrameLayout extends FrameLayout {
+
+  /**
+   * The {@link FrameLayout} will not resize itself if the fractional difference between its natural
+   * aspect ratio and the requested aspect ratio falls below this threshold.
+   * <p>
+   * This tolerance allows the view to occupy the whole of the screen when the requested aspect
+   * ratio is very close, but not exactly equal to, the aspect ratio of the screen. This may reduce
+   * the number of view layers that need to be composited by the underlying system, which can help
+   * to reduce power consumption.
+   */
+  private static final float MAX_ASPECT_RATIO_DEFORMATION_FRACTION = 0.01f;
+
+  private float videoAspectRatio;
+
+  public AspectRatioFrameLayout(Context context) {
+    super(context);
+  }
+
+  public AspectRatioFrameLayout(Context context, AttributeSet attrs) {
+    super(context, attrs);
+  }
+
+  /**
+   * Set the aspect ratio that this view should satisfy.
+   *
+   * @param widthHeightRatio The width to height ratio.
+   */
+  public void setAspectRatio(float widthHeightRatio) {
+    if (this.videoAspectRatio != widthHeightRatio) {
+      this.videoAspectRatio = widthHeightRatio;
+      requestLayout();
+    }
+  }
+
+  @Override
+  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+    if (videoAspectRatio == 0) {
+      // Aspect ratio not set.
+      return;
+    }
+
+    int width = getMeasuredWidth();
+    int height = getMeasuredHeight();
+    float viewAspectRatio = (float) width / height;
+    float aspectDeformation = videoAspectRatio / viewAspectRatio - 1;
+    if (Math.abs(aspectDeformation) <= MAX_ASPECT_RATIO_DEFORMATION_FRACTION) {
+      // We're within the allowed tolerance.
+      return;
+    }
+
+    if (aspectDeformation > 0) {
+      height = (int) (width / videoAspectRatio);
+    } else {
+      width = (int) (height * videoAspectRatio);
+    }
+    super.onMeasure(MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY),
+        MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY));
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/C.java b/library/src/main/java/com/google/android/exoplayer/C.java
index 3c9c679000..933dd55bae 100644
--- a/library/src/main/java/com/google/android/exoplayer/C.java
+++ b/library/src/main/java/com/google/android/exoplayer/C.java
@@ -29,6 +29,12 @@
    */
   public static final long UNKNOWN_TIME_US = -1L;
 
+  /**
+   * Represents a microsecond duration whose exact value is unknown, but which should match the
+   * longest of some other known durations.
+   */
+  public static final long MATCH_LONGEST_US = -2L;
+
   /**
    * The number of microseconds in one second.
    */
@@ -84,6 +90,22 @@
    */
   public static final int RESULT_END_OF_INPUT = -1;
 
+  /**
+   * A prefix for custom ExoPlayer WebVTT headers.
+   *
+   * @hide
+   */
+  public static final String WEBVTT_EXO_HEADER = "EXO-HEADER";
+
+  /**
+   * An element of a custom ExoPlayer WebVTT header. An {@code WEBVTT_OFFSET + value} element can
+   * be added to a custom ExoPlayer WebVTT header to specify an offset time (in microseconds) that
+   * should be added to the embedded MPEGTS value.
+   *
+   * @hide
+   */
+  public static final String WEBVTT_EXO_HEADER_OFFSET = "OFFSET:";
+
   private C() {}
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/DefaultLoadControl.java b/library/src/main/java/com/google/android/exoplayer/DefaultLoadControl.java
index 4c9b9f15f5..b494e990fe 100644
--- a/library/src/main/java/com/google/android/exoplayer/DefaultLoadControl.java
+++ b/library/src/main/java/com/google/android/exoplayer/DefaultLoadControl.java
@@ -127,8 +127,8 @@ public DefaultLoadControl(Allocator allocator, Handler eventHandler, EventListen
     this.allocator = allocator;
     this.eventHandler = eventHandler;
     this.eventListener = eventListener;
-    this.loaders = new ArrayList<Object>();
-    this.loaderStates = new HashMap<Object, LoaderState>();
+    this.loaders = new ArrayList<>();
+    this.loaderStates = new HashMap<>();
     this.lowWatermarkUs = lowWatermarkMs * 1000L;
     this.highWatermarkUs = highWatermarkMs * 1000L;
     this.lowBufferLoad = lowBufferLoad;
diff --git a/library/src/main/java/com/google/android/exoplayer/DummyTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/DummyTrackRenderer.java
index 39aec48781..f926073740 100644
--- a/library/src/main/java/com/google/android/exoplayer/DummyTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/DummyTrackRenderer.java
@@ -59,9 +59,4 @@ protected long getBufferedPositionUs() {
     throw new IllegalStateException();
   }
 
-  @Override
-  protected long getCurrentPositionUs() {
-    throw new IllegalStateException();
-  }
-
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayer.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayer.java
index a0b544062a..e54645e095 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayer.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayer.java
@@ -261,21 +261,31 @@ public static ExoPlayer newInstance(int rendererCount) {
    */
   public void prepare(TrackRenderer... renderers);
 
+  /**
+   * Returns whether the renderer at the given index has media to play.
+   * <p>
+   * Always returns false whilst the player is in the {@link #STATE_PREPARING} state.
+   *
+   * @param rendererIndex The index of the renderer.
+   * @return True if the renderer has media to play, false otherwise.
+   */
+  public boolean getRendererHasMedia(int rendererIndex);
+
   /**
    * Sets whether the renderer at the given index is enabled.
    *
-   * @param index The index of the renderer.
+   * @param rendererIndex The index of the renderer.
    * @param enabled Whether the renderer at the given index should be enabled.
    */
-  public void setRendererEnabled(int index, boolean enabled);
+  public void setRendererEnabled(int rendererIndex, boolean enabled);
 
   /**
    * Whether the renderer at the given index is enabled.
    *
-   * @param index The index of the renderer.
+   * @param rendererIndex The index of the renderer.
    * @return Whether the renderer is enabled.
    */
-  public boolean getRendererEnabled(int index);
+  public boolean getRendererEnabled(int rendererIndex);
 
   /**
    * Sets whether playback should proceed when {@link #getPlaybackState()} == {@link #STATE_READY}.
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerImpl.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerImpl.java
index 3f5dc3cb0c..6729bfddd8 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerImpl.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerImpl.java
@@ -21,6 +21,7 @@
 import android.os.Message;
 import android.util.Log;
 
+import java.util.Arrays;
 import java.util.concurrent.CopyOnWriteArraySet;
 
 /**
@@ -33,6 +34,7 @@
   private final Handler eventHandler;
   private final ExoPlayerImplInternal internalPlayer;
   private final CopyOnWriteArraySet<Listener> listeners;
+  private final boolean[] rendererHasMediaFlags;
   private final boolean[] rendererEnabledFlags;
 
   private boolean playWhenReady;
@@ -55,7 +57,8 @@ public ExoPlayerImpl(int rendererCount, int minBufferMs, int minRebufferMs) {
     Log.i(TAG, "Init " + ExoPlayerLibraryInfo.VERSION);
     this.playWhenReady = false;
     this.playbackState = STATE_IDLE;
-    this.listeners = new CopyOnWriteArraySet<Listener>();
+    this.listeners = new CopyOnWriteArraySet<>();
+    this.rendererHasMediaFlags = new boolean[rendererCount];
     this.rendererEnabledFlags = new boolean[rendererCount];
     for (int i = 0; i < rendererEnabledFlags.length; i++) {
       rendererEnabledFlags[i] = true;
@@ -92,20 +95,26 @@ public int getPlaybackState() {
 
   @Override
   public void prepare(TrackRenderer... renderers) {
+    Arrays.fill(rendererHasMediaFlags, false);
     internalPlayer.prepare(renderers);
   }
 
   @Override
-  public void setRendererEnabled(int index, boolean enabled) {
-    if (rendererEnabledFlags[index] != enabled) {
-      rendererEnabledFlags[index] = enabled;
-      internalPlayer.setRendererEnabled(index, enabled);
+  public boolean getRendererHasMedia(int rendererIndex) {
+    return rendererHasMediaFlags[rendererIndex];
+  }
+
+  @Override
+  public void setRendererEnabled(int rendererIndex, boolean enabled) {
+    if (rendererEnabledFlags[rendererIndex] != enabled) {
+      rendererEnabledFlags[rendererIndex] = enabled;
+      internalPlayer.setRendererEnabled(rendererIndex, enabled);
     }
   }
 
   @Override
-  public boolean getRendererEnabled(int index) {
-    return rendererEnabledFlags[index];
+  public boolean getRendererEnabled(int rendererIndex) {
+    return rendererEnabledFlags[rendererIndex];
   }
 
   @Override
@@ -182,6 +191,16 @@ public int getBufferedPercentage() {
   // Not private so it can be called from an inner class without going through a thunk method.
   /* package */ void handleEvent(Message msg) {
     switch (msg.what) {
+      case ExoPlayerImplInternal.MSG_PREPARED: {
+        boolean[] rendererHasMediaFlags = (boolean[]) msg.obj;
+        System.arraycopy(rendererHasMediaFlags, 0, this.rendererHasMediaFlags, 0,
+            rendererHasMediaFlags.length);
+        playbackState = msg.arg1;
+        for (Listener listener : listeners) {
+          listener.onPlayerStateChanged(playWhenReady, playbackState);
+        }
+        break;
+      }
       case ExoPlayerImplInternal.MSG_STATE_CHANGED: {
         playbackState = msg.arg1;
         for (Listener listener : listeners) {
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java
index 2c87cd7133..17e69bf1b7 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java
@@ -40,9 +40,10 @@
   private static final String TAG = "ExoPlayerImplInternal";
 
   // External messages
-  public static final int MSG_STATE_CHANGED = 1;
-  public static final int MSG_SET_PLAY_WHEN_READY_ACK = 2;
-  public static final int MSG_ERROR = 3;
+  public static final int MSG_PREPARED = 1;
+  public static final int MSG_STATE_CHANGED = 2;
+  public static final int MSG_SET_PLAY_WHEN_READY_ACK = 3;
+  public static final int MSG_ERROR = 4;
 
   // Internal messages
   private static final int MSG_PREPARE = 1;
@@ -62,14 +63,15 @@
   private final Handler handler;
   private final HandlerThread internalPlaybackThread;
   private final Handler eventHandler;
-  private final MediaClock mediaClock;
+  private final StandaloneMediaClock standaloneMediaClock;
   private final boolean[] rendererEnabledFlags;
   private final long minBufferUs;
   private final long minRebufferUs;
 
   private final List<TrackRenderer> enabledRenderers;
   private TrackRenderer[] renderers;
-  private TrackRenderer timeSourceTrackRenderer;
+  private TrackRenderer rendererMediaClockSource;
+  private MediaClock rendererMediaClock;
 
   private boolean released;
   private boolean playWhenReady;
@@ -98,8 +100,8 @@ public ExoPlayerImplInternal(Handler eventHandler, boolean playWhenReady,
     this.durationUs = TrackRenderer.UNKNOWN_TIME_US;
     this.bufferedPositionUs = TrackRenderer.UNKNOWN_TIME_US;
 
-    mediaClock = new MediaClock();
-    enabledRenderers = new ArrayList<TrackRenderer>(rendererEnabledFlags.length);
+    standaloneMediaClock = new StandaloneMediaClock();
+    enabledRenderers = new ArrayList<>(rendererEnabledFlags.length);
     // Note: The documentation for Process.THREAD_PRIORITY_AUDIO that states "Applications can
     // not normally change to this priority" is incorrect.
     internalPlaybackThread = new PriorityHandlerThread(getClass().getSimpleName() + ":Handler",
@@ -246,17 +248,19 @@ private void setState(int state) {
     }
   }
 
-  private void prepareInternal(TrackRenderer[] renderers) {
+  private void prepareInternal(TrackRenderer[] renderers) throws ExoPlaybackException {
     resetInternal();
     this.renderers = renderers;
     for (int i = 0; i < renderers.length; i++) {
-      if (renderers[i].isTimeSource()) {
-        Assertions.checkState(timeSourceTrackRenderer == null);
-        timeSourceTrackRenderer = renderers[i];
+      MediaClock mediaClock = renderers[i].getMediaClock();
+      if (mediaClock != null) {
+        Assertions.checkState(rendererMediaClock == null);
+        rendererMediaClock = mediaClock;
+        rendererMediaClockSource = renderers[i];
       }
     }
     setState(ExoPlayer.STATE_PREPARING);
-    handler.sendEmptyMessage(MSG_INCREMENTAL_PREPARE);
+    incrementalPrepareInternal();
   }
 
   private void incrementalPrepareInternal() throws ExoPlaybackException {
@@ -278,15 +282,13 @@ private void incrementalPrepareInternal() throws ExoPlaybackException {
     }
 
     long durationUs = 0;
-    boolean isEnded = true;
+    boolean allRenderersEnded = true;
     boolean allRenderersReadyOrEnded = true;
-    for (int i = 0; i < renderers.length; i++) {
-      TrackRenderer renderer = renderers[i];
-      if (rendererEnabledFlags[i] && renderer.getState() == TrackRenderer.STATE_PREPARED) {
-        renderer.enable(positionUs, false);
-        enabledRenderers.add(renderer);
-        isEnded = isEnded && renderer.isEnded();
-        allRenderersReadyOrEnded = allRenderersReadyOrEnded && rendererReadyOrEnded(renderer);
+    boolean[] rendererHasMediaFlags = new boolean[renderers.length];
+    for (int rendererIndex = 0; rendererIndex < renderers.length; rendererIndex++) {
+      TrackRenderer renderer = renderers[rendererIndex];
+      rendererHasMediaFlags[rendererIndex] = renderer.getState() == TrackRenderer.STATE_PREPARED;
+      if (rendererHasMediaFlags[rendererIndex]) {
         if (durationUs == TrackRenderer.UNKNOWN_TIME_US) {
           // We've already encountered a track for which the duration is unknown, so the media
           // duration is unknown regardless of the duration of this track.
@@ -300,20 +302,32 @@ private void incrementalPrepareInternal() throws ExoPlaybackException {
             durationUs = Math.max(durationUs, trackDurationUs);
           }
         }
+        if (rendererEnabledFlags[rendererIndex]) {
+          renderer.enable(positionUs, false);
+          enabledRenderers.add(renderer);
+          allRenderersEnded = allRenderersEnded && renderer.isEnded();
+          allRenderersReadyOrEnded = allRenderersReadyOrEnded && rendererReadyOrEnded(renderer);
+        }
       }
     }
     this.durationUs = durationUs;
 
-    if (isEnded) {
+    if (allRenderersEnded
+        && (durationUs == TrackRenderer.UNKNOWN_TIME_US || durationUs <= positionUs)) {
       // We don't expect this case, but handle it anyway.
-      setState(ExoPlayer.STATE_ENDED);
+      state = ExoPlayer.STATE_ENDED;
     } else {
-      setState(allRenderersReadyOrEnded ? ExoPlayer.STATE_READY : ExoPlayer.STATE_BUFFERING);
-      if (playWhenReady && state == ExoPlayer.STATE_READY) {
-        startRenderers();
-      }
+      state = allRenderersReadyOrEnded ? ExoPlayer.STATE_READY : ExoPlayer.STATE_BUFFERING;
     }
 
+    // Fire an event indicating that the player has been prepared, passing the initial state and
+    // renderer media flags.
+    eventHandler.obtainMessage(MSG_PREPARED, state, 0, rendererHasMediaFlags).sendToTarget();
+
+    // Start the renderers if required, and schedule the first piece of work.
+    if (playWhenReady && state == ExoPlayer.STATE_READY) {
+      startRenderers();
+    }
     handler.sendEmptyMessage(MSG_DO_SOME_WORK);
   }
 
@@ -361,26 +375,26 @@ private void setPlayWhenReadyInternal(boolean playWhenReady) throws ExoPlaybackE
 
   private void startRenderers() throws ExoPlaybackException {
     rebuffering = false;
-    mediaClock.start();
+    standaloneMediaClock.start();
     for (int i = 0; i < enabledRenderers.size(); i++) {
       enabledRenderers.get(i).start();
     }
   }
 
   private void stopRenderers() throws ExoPlaybackException {
-    mediaClock.stop();
+    standaloneMediaClock.stop();
     for (int i = 0; i < enabledRenderers.size(); i++) {
       ensureStopped(enabledRenderers.get(i));
     }
   }
 
   private void updatePositionUs() {
-    if (timeSourceTrackRenderer != null && enabledRenderers.contains(timeSourceTrackRenderer)
-        && !timeSourceTrackRenderer.isEnded()) {
-      positionUs = timeSourceTrackRenderer.getCurrentPositionUs();
-      mediaClock.setPositionUs(positionUs);
+    if (rendererMediaClock != null && enabledRenderers.contains(rendererMediaClockSource)
+        && !rendererMediaClockSource.isEnded()) {
+      positionUs = rendererMediaClock.getPositionUs();
+      standaloneMediaClock.setPositionUs(positionUs);
     } else {
-      positionUs = mediaClock.getPositionUs();
+      positionUs = standaloneMediaClock.getPositionUs();
     }
     elapsedRealtimeUs = SystemClock.elapsedRealtime() * 1000;
   }
@@ -390,7 +404,7 @@ private void doSomeWork() throws ExoPlaybackException {
     long operationStartTimeMs = SystemClock.elapsedRealtime();
     long bufferedPositionUs = durationUs != TrackRenderer.UNKNOWN_TIME_US ? durationUs
         : Long.MAX_VALUE;
-    boolean isEnded = true;
+    boolean allRenderersEnded = true;
     boolean allRenderersReadyOrEnded = true;
     updatePositionUs();
     for (int i = 0; i < enabledRenderers.size(); i++) {
@@ -399,7 +413,7 @@ private void doSomeWork() throws ExoPlaybackException {
       // invoked again. The minimum of these values should then be used as the delay before the next
       // invocation of this method.
       renderer.doSomeWork(positionUs, elapsedRealtimeUs);
-      isEnded = isEnded && renderer.isEnded();
+      allRenderersEnded = allRenderersEnded && renderer.isEnded();
       allRenderersReadyOrEnded = allRenderersReadyOrEnded && rendererReadyOrEnded(renderer);
 
       if (bufferedPositionUs == TrackRenderer.UNKNOWN_TIME_US) {
@@ -422,7 +436,8 @@ private void doSomeWork() throws ExoPlaybackException {
     }
     this.bufferedPositionUs = bufferedPositionUs;
 
-    if (isEnded) {
+    if (allRenderersEnded
+        && (durationUs == TrackRenderer.UNKNOWN_TIME_US || durationUs <= positionUs)) {
       setState(ExoPlayer.STATE_ENDED);
       stopRenderers();
     } else if (state == ExoPlayer.STATE_BUFFERING && allRenderersReadyOrEnded) {
@@ -460,8 +475,8 @@ private void scheduleNextOperation(int operationType, long thisOperationStartTim
   private void seekToInternal(long positionMs) throws ExoPlaybackException {
     rebuffering = false;
     positionUs = positionMs * 1000L;
-    mediaClock.stop();
-    mediaClock.setPositionUs(positionUs);
+    standaloneMediaClock.stop();
+    standaloneMediaClock.setPositionUs(positionUs);
     if (state == ExoPlayer.STATE_IDLE || state == ExoPlayer.STATE_PREPARING) {
       return;
     }
@@ -492,7 +507,7 @@ private void resetInternal() {
     handler.removeMessages(MSG_DO_SOME_WORK);
     handler.removeMessages(MSG_INCREMENTAL_PREPARE);
     rebuffering = false;
-    mediaClock.stop();
+    standaloneMediaClock.stop();
     if (renderers == null) {
       return;
     }
@@ -502,7 +517,8 @@ private void resetInternal() {
       release(renderer);
     }
     renderers = null;
-    timeSourceTrackRenderer = null;
+    rendererMediaClock = null;
+    rendererMediaClockSource = null;
     enabledRenderers.clear();
   }
 
@@ -551,18 +567,18 @@ private void release(TrackRenderer renderer) {
     }
   }
 
-  private void setRendererEnabledInternal(int index, boolean enabled)
+  private void setRendererEnabledInternal(int rendererIndex, boolean enabled)
       throws ExoPlaybackException {
-    if (rendererEnabledFlags[index] == enabled) {
+    if (rendererEnabledFlags[rendererIndex] == enabled) {
       return;
     }
 
-    rendererEnabledFlags[index] = enabled;
+    rendererEnabledFlags[rendererIndex] = enabled;
     if (state == ExoPlayer.STATE_IDLE || state == ExoPlayer.STATE_PREPARING) {
       return;
     }
 
-    TrackRenderer renderer = renderers[index];
+    TrackRenderer renderer = renderers[rendererIndex];
     int rendererState = renderer.getState();
     if (rendererState != TrackRenderer.STATE_PREPARED &&
         rendererState != TrackRenderer.STATE_ENABLED &&
@@ -579,10 +595,10 @@ private void setRendererEnabledInternal(int index, boolean enabled)
       }
       handler.sendEmptyMessage(MSG_DO_SOME_WORK);
     } else {
-      if (renderer == timeSourceTrackRenderer) {
-        // We've been using timeSourceTrackRenderer to advance the current position, but it's
-        // being disabled. Sync mediaClock so that it can take over timing responsibilities.
-        mediaClock.setPositionUs(renderer.getCurrentPositionUs());
+      if (renderer == rendererMediaClockSource) {
+        // We've been using rendererMediaClockSource to advance the current position, but it's being
+        // disabled. Sync standaloneMediaClock so that it can take over timing responsibilities.
+        standaloneMediaClock.setPositionUs(rendererMediaClock.getPositionUs());
       }
       ensureStopped(renderer);
       enabledRenderers.remove(renderer);
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
index 6830b3f33b..2b15f7f9f8 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
@@ -26,7 +26,7 @@ private ExoPlayerLibraryInfo() {}
   /**
    * The version of the library, expressed as a string.
    */
-  public static final String VERSION = "1.3.3";
+  public static final String VERSION = "1.4.0";
 
   /**
    * The version of the library, expressed as an integer.
@@ -34,7 +34,7 @@ private ExoPlayerLibraryInfo() {}
    * Three digits are used for each component of {@link #VERSION}. For example "1.2.3" has the
    * corresponding integer version 001002003.
    */
-  public static final int VERSION_INT = 001003003;
+  public static final int VERSION_INT = 001004000;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer.util.Assertions}
diff --git a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
index 8eab665aa8..02d599aca4 100644
--- a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
@@ -15,9 +15,11 @@
  */
 package com.google.android.exoplayer;
 
+import com.google.android.exoplayer.SampleSource.SampleSourceReader;
 import com.google.android.exoplayer.drm.DrmInitData;
 import com.google.android.exoplayer.extractor.ExtractorSampleSource;
 import com.google.android.exoplayer.extractor.mp4.Mp4Extractor;
+import com.google.android.exoplayer.extractor.mp4.PsshAtomUtil;
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.Util;
@@ -48,6 +50,7 @@
  * <li>Playing media whose container format is unknown and so needs to be inferred automatically.
  * </li>
  * </ul>
+ * <p>
  * Over time we hope to enhance {@link ExtractorSampleSource} to support these use cases, and hence
  * make use of this class unnecessary.
  */
@@ -55,7 +58,7 @@
 // through use of a background thread, or through changes to the framework's MediaExtractor API).
 @Deprecated
 @TargetApi(16)
-public final class FrameworkSampleSource implements SampleSource {
+public final class FrameworkSampleSource implements SampleSource, SampleSourceReader {
 
   private static final int ALLOWED_FLAGS_MASK = C.SAMPLE_FLAG_SYNC | C.SAMPLE_FLAG_ENCRYPTED;
 
@@ -88,17 +91,12 @@
    * @param context Context for resolving {@code uri}.
    * @param uri The content URI from which to extract data.
    * @param headers Headers to send with requests for data.
-   * @param downstreamRendererCount Number of track renderers dependent on this sample source.
    */
-  public FrameworkSampleSource(Context context, Uri uri, Map<String, String> headers,
-      int downstreamRendererCount) {
+  public FrameworkSampleSource(Context context, Uri uri, Map<String, String> headers) {
     Assertions.checkState(Util.SDK_INT >= 16);
-    this.remainingReleaseCount = downstreamRendererCount;
-
     this.context = Assertions.checkNotNull(context);
     this.uri = Assertions.checkNotNull(uri);
     this.headers = headers;
-
     fileDescriptor = null;
     fileDescriptorOffset = 0;
     fileDescriptorLength = 0;
@@ -109,22 +107,24 @@ public FrameworkSampleSource(Context context, Uri uri, Map<String, String> heade
    * The caller is responsible for releasing the file descriptor.
    *
    * @param fileDescriptor File descriptor from which to read.
-   * @param offset The offset in bytes into the file where the data to be extracted starts.
-   * @param length The length in bytes of the data to be extracted.
-   * @param downstreamRendererCount Number of track renderers dependent on this sample source.
+   * @param fileDescriptorOffset The offset in bytes where the data to be extracted starts.
+   * @param fileDescriptorLength The length in bytes of the data to be extracted.
    */
-  public FrameworkSampleSource(FileDescriptor fileDescriptor, long offset, long length,
-      int downstreamRendererCount) {
+  public FrameworkSampleSource(FileDescriptor fileDescriptor, long fileDescriptorOffset,
+      long fileDescriptorLength) {
     Assertions.checkState(Util.SDK_INT >= 16);
-    this.remainingReleaseCount = downstreamRendererCount;
-
+    this.fileDescriptor = Assertions.checkNotNull(fileDescriptor);
+    this.fileDescriptorOffset = fileDescriptorOffset;
+    this.fileDescriptorLength = fileDescriptorLength;
     context = null;
     uri = null;
     headers = null;
+  }
 
-    this.fileDescriptor = Assertions.checkNotNull(fileDescriptor);
-    fileDescriptorOffset = offset;
-    fileDescriptorLength = length;
+  @Override
+  public SampleSourceReader register() {
+    remainingReleaseCount++;
+    return this;
   }
 
   @Override
@@ -174,7 +174,7 @@ public void enable(int track, long positionUs) {
   }
 
   @Override
-  public boolean continueBuffering(long positionUs) {
+  public boolean continueBuffering(int track, long positionUs) {
     // MediaExtractor takes care of buffering and blocks until it has samples, so we can always
     // return true here. Although note that the blocking behavior is itself as bug, as per the
     // TODO further up this file. This method will need to return something else as part of fixing
@@ -267,7 +267,10 @@ private DrmInitData getDrmInitDataV18() {
       return null;
     }
     DrmInitData.Mapped drmInitData = new DrmInitData.Mapped(MimeTypes.VIDEO_MP4);
-    drmInitData.putAll(psshInfo);
+    for (UUID uuid : psshInfo.keySet()) {
+      byte[] psshAtom = PsshAtomUtil.buildPsshAtom(uuid, psshInfo.get(uuid));
+      drmInitData.put(uuid, psshAtom);
+    }
     return drmInitData;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaClock.java b/library/src/main/java/com/google/android/exoplayer/MediaClock.java
index c2696e3b74..6cfe50e156 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaClock.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaClock.java
@@ -15,65 +15,14 @@
  */
 package com.google.android.exoplayer;
 
-import android.os.SystemClock;
-
 /**
- * A simple clock for tracking the progression of media time. The clock can be started, stopped and
- * its time can be set and retrieved. When started, this clock is based on
- * {@link SystemClock#elapsedRealtime()}.
+ * Tracks the progression of media time.
  */
-/* package */ class MediaClock {
-
-  private boolean started;
-
-  /**
-   * The media time when the clock was last set or stopped.
-   */
-  private long positionUs;
-
-  /**
-   * The difference between {@link SystemClock#elapsedRealtime()} and {@link #positionUs}
-   * when the clock was last set or started.
-   */
-  private long deltaUs;
-
-  /**
-   * Starts the clock. Does nothing if the clock is already started.
-   */
-  public void start() {
-    if (!started) {
-      started = true;
-      deltaUs = elapsedRealtimeMinus(positionUs);
-    }
-  }
-
-  /**
-   * Stops the clock. Does nothing if the clock is already stopped.
-   */
-  public void stop() {
-    if (started) {
-      positionUs = elapsedRealtimeMinus(deltaUs);
-      started = false;
-    }
-  }
+public interface MediaClock {
 
   /**
-   * @param timeUs The position to set in microseconds.
+   * @return The current media position in microseconds.
    */
-  public void setPositionUs(long timeUs) {
-    this.positionUs = timeUs;
-    deltaUs = elapsedRealtimeMinus(timeUs);
-  }
-
-  /**
-   * @return The current position in microseconds.
-   */
-  public long getPositionUs() {
-    return started ? elapsedRealtimeMinus(deltaUs) : positionUs;
-  }
-
-  private long elapsedRealtimeMinus(long toSubtractUs) {
-    return SystemClock.elapsedRealtime() * 1000 - toSubtractUs;
-  }
+  long getPositionUs();
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
index 48b54db597..510313c787 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
@@ -31,7 +31,7 @@
  * Decodes and renders audio using {@link MediaCodec} and {@link android.media.AudioTrack}.
  */
 @TargetApi(16)
-public class MediaCodecAudioTrackRenderer extends MediaCodecTrackRenderer {
+public class MediaCodecAudioTrackRenderer extends MediaCodecTrackRenderer implements MediaClock {
 
   /**
    * Interface definition for a callback to be notified of {@link MediaCodecAudioTrackRenderer}
@@ -72,6 +72,7 @@
 
   private int audioSessionId;
   private long currentPositionUs;
+  private boolean allowPositionDiscontinuity;
 
   /**
    * @param source The upstream source from which the renderer obtains samples.
@@ -151,8 +152,8 @@ protected void configureCodec(MediaCodec codec, String codecName,
   }
 
   @Override
-  protected boolean isTimeSource() {
-    return true;
+  protected MediaClock getMediaClock() {
+    return this;
   }
 
   @Override
@@ -163,7 +164,7 @@ protected boolean handlesMimeType(String mimeType) {
   @Override
   protected void onEnabled(long positionUs, boolean joining) {
     super.onEnabled(positionUs, joining);
-    currentPositionUs = Long.MIN_VALUE;
+    seekToInternal(positionUs);
   }
 
   @Override
@@ -219,14 +220,12 @@ protected boolean isReady() {
   }
 
   @Override
-  protected long getCurrentPositionUs() {
-    long audioTrackCurrentPositionUs = audioTrack.getCurrentPositionUs(isEnded());
-    if (audioTrackCurrentPositionUs == AudioTrack.CURRENT_POSITION_NOT_SET) {
-      // Use the super class position before audio playback starts.
-      currentPositionUs = Math.max(currentPositionUs, super.getCurrentPositionUs());
-    } else {
-      // Make sure we don't ever report time moving backwards.
-      currentPositionUs = Math.max(currentPositionUs, audioTrackCurrentPositionUs);
+  public long getPositionUs() {
+    long newCurrentPositionUs = audioTrack.getCurrentPositionUs(isEnded());
+    if (newCurrentPositionUs != AudioTrack.CURRENT_POSITION_NOT_SET) {
+      currentPositionUs = allowPositionDiscontinuity ? newCurrentPositionUs
+          : Math.max(currentPositionUs, newCurrentPositionUs);
+      allowPositionDiscontinuity = false;
     }
     return currentPositionUs;
   }
@@ -244,9 +243,14 @@ protected void onDisabled() {
   @Override
   protected void seekTo(long positionUs) throws ExoPlaybackException {
     super.seekTo(positionUs);
+    seekToInternal(positionUs);
+  }
+
+  private void seekToInternal(long positionUs) {
     // TODO: Try and re-use the same AudioTrack instance once [Internal: b/7941810] is fixed.
     audioTrack.reset();
-    currentPositionUs = Long.MIN_VALUE;
+    currentPositionUs = positionUs;
+    allowPositionDiscontinuity = true;
   }
 
   @Override
@@ -290,7 +294,8 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
 
     // If we are out of sync, allow currentPositionUs to jump backwards.
     if ((handleBufferResult & AudioTrack.RESULT_POSITION_DISCONTINUITY) != 0) {
-      currentPositionUs = Long.MIN_VALUE;
+      handleDiscontinuity();
+      allowPositionDiscontinuity = true;
     }
 
     // Release the buffer if it was consumed.
@@ -303,6 +308,10 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
     return false;
   }
 
+  protected void handleDiscontinuity() {
+    // Do nothing
+  }
+
   @Override
   public void handleMessage(int messageType, Object message) throws ExoPlaybackException {
     if (messageType == MSG_SET_VOLUME) {
@@ -314,7 +323,7 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
 
   private void notifyAudioTrackInitializationError(final AudioTrack.InitializationException e) {
     if (eventHandler != null && eventListener != null) {
-      eventHandler.post(new Runnable()  {
+      eventHandler.post(new Runnable() {
         @Override
         public void run() {
           eventListener.onAudioTrackInitializationError(e);
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
index 6f8dcbd6be..7ebfd795e9 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
@@ -16,9 +16,11 @@
 package com.google.android.exoplayer;
 
 import com.google.android.exoplayer.MediaCodecUtil.DecoderQueryException;
+import com.google.android.exoplayer.SampleSource.SampleSourceReader;
 import com.google.android.exoplayer.drm.DrmInitData;
 import com.google.android.exoplayer.drm.DrmSessionManager;
 import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.TraceUtil;
 import com.google.android.exoplayer.util.Util;
 
 import android.annotation.TargetApi;
@@ -181,7 +183,7 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
 
   private final DrmSessionManager drmSessionManager;
   private final boolean playClearSamplesWithoutKeys;
-  private final SampleSource source;
+  private final SampleSourceReader source;
   private final SampleHolder sampleHolder;
   private final MediaFormatHolder formatHolder;
   private final List<Long> decodeOnlyPresentationTimestamps;
@@ -193,6 +195,7 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   private DrmInitData drmInitData;
   private MediaCodec codec;
   private boolean codecIsAdaptive;
+  private boolean codecNeedsEndOfStreamWorkaround;
   private ByteBuffer[] inputBuffers;
   private ByteBuffer[] outputBuffers;
   private long codecHotswapTimeMs;
@@ -210,7 +213,6 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   private boolean outputStreamEnded;
   private boolean waitingForKeys;
   private boolean waitingForFirstSyncFrame;
-  private long currentPositionUs;
 
   /**
    * @param source The upstream source from which the renderer obtains samples.
@@ -228,7 +230,7 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   public MediaCodecTrackRenderer(SampleSource source, DrmSessionManager drmSessionManager,
       boolean playClearSamplesWithoutKeys, Handler eventHandler, EventListener eventListener) {
     Assertions.checkState(Util.SDK_INT >= 16);
-    this.source = source;
+    this.source = source.register();
     this.drmSessionManager = drmSessionManager;
     this.playClearSamplesWithoutKeys = playClearSamplesWithoutKeys;
     this.eventHandler = eventHandler;
@@ -236,7 +238,7 @@ public MediaCodecTrackRenderer(SampleSource source, DrmSessionManager drmSession
     codecCounters = new CodecCounters();
     sampleHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_DISABLED);
     formatHolder = new MediaFormatHolder();
-    decodeOnlyPresentationTimestamps = new ArrayList<Long>();
+    decodeOnlyPresentationTimestamps = new ArrayList<>();
     outputBufferInfo = new MediaCodec.BufferInfo();
     codecReconfigurationState = RECONFIGURATION_STATE_NONE;
     codecReinitializationState = REINITIALIZATION_STATE_NONE;
@@ -281,11 +283,7 @@ protected boolean handlesMimeType(String mimeType) {
   @Override
   protected void onEnabled(long positionUs, boolean joining) {
     source.enable(trackIndex, positionUs);
-    sourceState = SOURCE_STATE_NOT_READY;
-    inputStreamEnded = false;
-    outputStreamEnded = false;
-    waitingForKeys = false;
-    currentPositionUs = positionUs;
+    seekToInternal();
   }
 
   /**
@@ -360,11 +358,18 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
 
     String decoderName = decoderInfo.name;
     codecIsAdaptive = decoderInfo.adaptive;
+    codecNeedsEndOfStreamWorkaround = codecNeedsEndOfStreamWorkaround(decoderName);
     try {
       long codecInitializingTimestamp = SystemClock.elapsedRealtime();
+      TraceUtil.beginSection("createByCodecName(" + decoderName + ")");
       codec = MediaCodec.createByCodecName(decoderName);
+      TraceUtil.endSection();
+      TraceUtil.beginSection("configureCodec");
       configureCodec(codec, decoderName, format.getFrameworkMediaFormatV16(), mediaCrypto);
+      TraceUtil.endSection();
+      TraceUtil.beginSection("codec.start()");
       codec.start();
+      TraceUtil.endSection();
       long codecInitializedTimestamp = SystemClock.elapsedRealtime();
       notifyDecoderInitialized(decoderName, codecInitializedTimestamp,
           codecInitializedTimestamp - codecInitializingTimestamp);
@@ -429,6 +434,7 @@ protected void releaseCodec() {
       codecReconfigured = false;
       codecHasQueuedBuffers = false;
       codecIsAdaptive = false;
+      codecNeedsEndOfStreamWorkaround = false;
       codecReconfigurationState = RECONFIGURATION_STATE_NONE;
       codecReinitializationState = REINITIALIZATION_STATE_NONE;
       codecCounters.codecReleaseCount++;
@@ -449,11 +455,6 @@ protected void onReleased() {
     source.release();
   }
 
-  @Override
-  protected long getCurrentPositionUs() {
-    return currentPositionUs;
-  }
-
   @Override
   protected long getDurationUs() {
     return source.getTrackInfo(trackIndex).durationUs;
@@ -461,15 +462,16 @@ protected long getDurationUs() {
 
   @Override
   protected long getBufferedPositionUs() {
-    long sourceBufferedPosition = source.getBufferedPositionUs();
-    return sourceBufferedPosition == UNKNOWN_TIME_US || sourceBufferedPosition == END_OF_TRACK_US
-        ? sourceBufferedPosition : Math.max(sourceBufferedPosition, getCurrentPositionUs());
+    return source.getBufferedPositionUs();
   }
 
   @Override
   protected void seekTo(long positionUs) throws ExoPlaybackException {
-    currentPositionUs = positionUs;
     source.seekToUs(positionUs);
+    seekToInternal();
+  }
+
+  private void seekToInternal() {
     sourceState = SOURCE_STATE_NOT_READY;
     inputStreamEnded = false;
     outputStreamEnded = false;
@@ -488,21 +490,23 @@ protected void onStopped() {
   @Override
   protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
     try {
-      sourceState = source.continueBuffering(positionUs)
+      sourceState = source.continueBuffering(trackIndex, positionUs)
           ? (sourceState == SOURCE_STATE_NOT_READY ? SOURCE_STATE_READY : sourceState)
           : SOURCE_STATE_NOT_READY;
-      checkForDiscontinuity();
+      checkForDiscontinuity(positionUs);
       if (format == null) {
-        readFormat();
+        readFormat(positionUs);
       }
       if (codec == null && shouldInitCodec()) {
         maybeInitCodec();
       }
       if (codec != null) {
+        TraceUtil.beginSection("drainAndFeed");
         while (drainOutputBuffer(positionUs, elapsedRealtimeUs)) {}
-        if (feedInputBuffer(true)) {
-          while (feedInputBuffer(false)) {}
+        if (feedInputBuffer(positionUs, true)) {
+          while (feedInputBuffer(positionUs, false)) {}
         }
+        TraceUtil.endSection();
       }
       codecCounters.ensureUpdated();
     } catch (IOException e) {
@@ -510,18 +514,18 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPla
     }
   }
 
-  private void readFormat() throws IOException, ExoPlaybackException {
-    int result = source.readData(trackIndex, currentPositionUs, formatHolder, sampleHolder, false);
+  private void readFormat(long positionUs) throws IOException, ExoPlaybackException {
+    int result = source.readData(trackIndex, positionUs, formatHolder, sampleHolder, false);
     if (result == SampleSource.FORMAT_READ) {
       onInputFormatChanged(formatHolder);
     }
   }
 
-  private void checkForDiscontinuity() throws IOException, ExoPlaybackException {
+  private void checkForDiscontinuity(long positionUs) throws IOException, ExoPlaybackException {
     if (codec == null) {
       return;
     }
-    int result = source.readData(trackIndex, currentPositionUs, formatHolder, sampleHolder, true);
+    int result = source.readData(trackIndex, positionUs, formatHolder, sampleHolder, true);
     if (result == SampleSource.DISCONTINUITY_READ) {
       flushCodec();
     }
@@ -551,13 +555,16 @@ private void flushCodec() throws ExoPlaybackException {
   }
 
   /**
+   * @param positionUs The current media time in microseconds, measured at the start of the
+   *     current iteration of the rendering loop.
    * @param firstFeed True if this is the first call to this method from the current invocation of
    *     {@link #doSomeWork(long, long)}. False otherwise.
    * @return True if it may be possible to feed more input data. False otherwise.
    * @throws IOException If an error occurs reading data from the upstream source.
    * @throws ExoPlaybackException If an error occurs feeding the input buffer.
    */
-  private boolean feedInputBuffer(boolean firstFeed) throws IOException, ExoPlaybackException {
+  private boolean feedInputBuffer(long positionUs, boolean firstFeed)
+      throws IOException, ExoPlaybackException {
     if (inputStreamEnded
         || codecReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM) {
       // The input stream has ended, or we need to re-initialize the codec but are still waiting
@@ -577,8 +584,12 @@ private boolean feedInputBuffer(boolean firstFeed) throws IOException, ExoPlayba
     if (codecReinitializationState == REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM) {
       // We need to re-initialize the codec. Send an end of stream signal to the existing codec so
       // that it outputs any remaining buffers before we release it.
-      codec.queueInputBuffer(inputIndex, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
-      inputIndex = -1;
+      if (codecNeedsEndOfStreamWorkaround) {
+        // Do nothing.
+      } else {
+        codec.queueInputBuffer(inputIndex, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
+        inputIndex = -1;
+      }
       codecReinitializationState = REINITIALIZATION_STATE_WAIT_END_OF_STREAM;
       return false;
     }
@@ -597,7 +608,7 @@ private boolean feedInputBuffer(boolean firstFeed) throws IOException, ExoPlayba
         }
         codecReconfigurationState = RECONFIGURATION_STATE_QUEUE_PENDING;
       }
-      result = source.readData(trackIndex, currentPositionUs, formatHolder, sampleHolder, false);
+      result = source.readData(trackIndex, positionUs, formatHolder, sampleHolder, false);
       if (firstFeed && sourceState == SOURCE_STATE_READY && result == SampleSource.NOTHING_READ) {
         sourceState = SOURCE_STATE_READY_READ_MAY_FAIL;
       }
@@ -630,8 +641,12 @@ private boolean feedInputBuffer(boolean firstFeed) throws IOException, ExoPlayba
       }
       inputStreamEnded = true;
       try {
-        codec.queueInputBuffer(inputIndex, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
-        inputIndex = -1;
+        if (codecNeedsEndOfStreamWorkaround) {
+          // Do nothing.
+        } else {
+          codec.queueInputBuffer(inputIndex, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
+          inputIndex = -1;
+        }
       } catch (CryptoException e) {
         notifyCryptoError(e);
         throw new ExoPlaybackException(e);
@@ -828,17 +843,16 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
       codecCounters.outputBuffersChangedCount++;
       return true;
     } else if (outputIndex < 0) {
+      if (codecNeedsEndOfStreamWorkaround && (inputStreamEnded
+          || codecReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM)) {
+        processEndOfStream();
+        return true;
+      }
       return false;
     }
 
     if ((outputBufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
-      if (codecReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM) {
-        // We're waiting to re-initialize the codec, and have now received all final output buffers.
-        releaseCodec();
-        maybeInitCodec();
-      } else {
-        outputStreamEnded = true;
-      }
+      processEndOfStream();
       return false;
     }
 
@@ -847,8 +861,6 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
         outputBufferInfo, outputIndex, decodeOnlyIndex != -1)) {
       if (decodeOnlyIndex != -1) {
         decodeOnlyPresentationTimestamps.remove(decodeOnlyIndex);
-      } else {
-        currentPositionUs = outputBufferInfo.presentationTimeUs;
       }
       outputIndex = -1;
       return true;
@@ -868,6 +880,21 @@ protected abstract boolean processOutputBuffer(long positionUs, long elapsedReal
       MediaCodec codec, ByteBuffer buffer, MediaCodec.BufferInfo bufferInfo, int bufferIndex,
       boolean shouldSkip) throws ExoPlaybackException;
 
+  /**
+   * Processes an end of stream signal.
+   *
+   * @throws ExoPlaybackException If an error occurs processing the signal.
+   */
+  private void processEndOfStream() throws ExoPlaybackException {
+    if (codecReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM) {
+      // We're waiting to re-initialize the codec, and have now processed all final buffers.
+      releaseCodec();
+      maybeInitCodec();
+    } else {
+      outputStreamEnded = true;
+    }
+  }
+
   private void notifyDecoderInitializationError(final DecoderInitializationException e) {
     if (eventHandler != null && eventListener != null) {
       eventHandler.post(new Runnable()  {
@@ -913,4 +940,20 @@ private int getDecodeOnlyIndex(long presentationTimeUs) {
     return -1;
   }
 
+  /**
+   * Returns whether the decoder is known to handle {@link MediaCodec#BUFFER_FLAG_END_OF_STREAM}
+   * incorrectly on the host device.
+   * <p>
+   * If true is returned, the renderer will work around the issue by approximating end of stream
+   * behavior without involvement of the underlying decoder.
+   *
+   * @param name The name of the decoder.
+   * @return True if the decoder is known to handle {@link MediaCodec#BUFFER_FLAG_END_OF_STREAM}
+   *     incorrectly on the host device. False otherwise.
+   */
+  private static boolean codecNeedsEndOfStreamWorkaround(String name) {
+    return Util.SDK_INT <= 17 && "ht7s3".equals(Util.DEVICE) // Tesco HUDL
+        && "OMX.rk.video_decoder.avc".equals(name);
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
index 5dbe3c5a11..ff3a453b16 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
@@ -52,8 +52,7 @@ private DecoderQueryException(Throwable cause) {
 
   private static final String TAG = "MediaCodecUtil";
 
-  private static final HashMap<CodecKey, Pair<String, CodecCapabilities>> codecs =
-      new HashMap<CodecKey, Pair<String, CodecCapabilities>>();
+  private static final HashMap<CodecKey, Pair<String, CodecCapabilities>> codecs = new HashMap<>();
 
   /**
    * Get information about the decoder that will be used for a given mime type.
@@ -135,8 +134,7 @@ public static synchronized void warmCodec(String mimeType, boolean secure) {
     for (int i = 0; i < numberOfCodecs; i++) {
       MediaCodecInfo info = mediaCodecList.getCodecInfoAt(i);
       String codecName = info.getName();
-      if (!info.isEncoder() && codecName.startsWith("OMX.")
-          && (secureDecodersExplicit || !codecName.endsWith(".secure"))) {
+      if (isCodecUsableDecoder(info, codecName, secureDecodersExplicit)) {
         String[] supportedTypes = info.getSupportedTypes();
         for (int j = 0; j < supportedTypes.length; j++) {
           String supportedType = supportedTypes[j];
@@ -167,6 +165,35 @@ public static synchronized void warmCodec(String mimeType, boolean secure) {
     return null;
   }
 
+  /**
+   * Returns whether the specified codec is usable for decoding on the current device.
+   */
+  private static boolean isCodecUsableDecoder(MediaCodecInfo info, String name,
+      boolean secureDecodersExplicit) {
+    if (info.isEncoder() || !name.startsWith("OMX.")
+        || (!secureDecodersExplicit && name.endsWith(".secure"))) {
+      return false;
+    }
+
+    // Work around an issue where creating a particular MP3 decoder on some devices on platform API
+    // version 16 crashes mediaserver.
+    if (Util.SDK_INT == 16
+        && ("dlxu".equals(Util.DEVICE) // HTC Butterfly
+            || "protou".equals(Util.DEVICE) // HTC Desire X
+            || "C6602".equals(Util.DEVICE) || "C6603".equals(Util.DEVICE)) // Sony Xperia Z
+        && name.equals("OMX.qcom.audio.decoder.mp3")) {
+      return false;
+    }
+
+    // Work around an issue where the VP8 decoder on Samsung Galaxy S4 Mini does not render video.
+    if (Util.SDK_INT <= 19 && Util.DEVICE != null && Util.DEVICE.startsWith("serrano")
+        && "samsung".equals(Util.MANUFACTURER) && name.equals("OMX.SEC.vp8.dec")) {
+      return false;
+    }
+
+    return true;
+  }
+
   private static boolean isAdaptive(CodecCapabilities capabilities) {
     if (Util.SDK_INT >= 19) {
       return isAdaptiveV19(capabilities);
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
index 49949f91a2..736e20fbe1 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
@@ -132,6 +132,7 @@
   private int currentWidth;
   private int currentHeight;
   private float currentPixelWidthHeightRatio;
+  private float pendingPixelWidthHeightRatio;
   private int lastReportedWidth;
   private int lastReportedHeight;
   private float lastReportedPixelWidthHeightRatio;
@@ -248,6 +249,7 @@ public MediaCodecVideoTrackRenderer(SampleSource source, DrmSessionManager drmSe
     currentWidth = -1;
     currentHeight = -1;
     currentPixelWidthHeightRatio = -1;
+    pendingPixelWidthHeightRatio = -1;
     lastReportedWidth = -1;
     lastReportedHeight = -1;
     lastReportedPixelWidthHeightRatio = -1;
@@ -316,6 +318,7 @@ public void onDisabled() {
     currentWidth = -1;
     currentHeight = -1;
     currentPixelWidthHeightRatio = -1;
+    pendingPixelWidthHeightRatio = -1;
     lastReportedWidth = -1;
     lastReportedHeight = -1;
     lastReportedPixelWidthHeightRatio = -1;
@@ -367,9 +370,7 @@ protected void configureCodec(MediaCodec codec, String codecName,
   @Override
   protected void onInputFormatChanged(MediaFormatHolder holder) throws ExoPlaybackException {
     super.onInputFormatChanged(holder);
-    // TODO: Ideally this would be read in onOutputFormatChanged, but there doesn't seem
-    // to be a way to pass a custom key/value pair value through to the output format.
-    currentPixelWidthHeightRatio = holder.format.pixelWidthHeightRatio == MediaFormat.NO_VALUE ? 1
+    pendingPixelWidthHeightRatio = holder.format.pixelWidthHeightRatio == MediaFormat.NO_VALUE ? 1
         : holder.format.pixelWidthHeightRatio;
   }
 
@@ -392,6 +393,7 @@ protected void onOutputFormatChanged(MediaFormat inputFormat,
     currentHeight = hasCrop
         ? outputFormat.getInteger(KEY_CROP_BOTTOM) - outputFormat.getInteger(KEY_CROP_TOP) + 1
         : outputFormat.getInteger(android.media.MediaFormat.KEY_HEIGHT);
+    currentPixelWidthHeightRatio = pendingPixelWidthHeightRatio;
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
index f98ea72f8a..898223969f 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer;
 
-import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.Util;
 
 import android.annotation.SuppressLint;
@@ -94,16 +93,8 @@ public static MediaFormat createAudioFormat(String mimeType, int maxInputSize, l
         channelCount, sampleRate, initializationData);
   }
 
-  public static MediaFormat createId3Format() {
-    return createFormatForMimeType(MimeTypes.APPLICATION_ID3);
-  }
-
-  public static MediaFormat createEia608Format() {
-    return createFormatForMimeType(MimeTypes.APPLICATION_EIA608);
-  }
-
-  public static MediaFormat createTtmlFormat() {
-    return createFormatForMimeType(MimeTypes.APPLICATION_TTML);
+  public static MediaFormat createTextFormat(String mimeType) {
+    return createFormatForMimeType(mimeType);
   }
 
   public static MediaFormat createFormatForMimeType(String mimeType) {
@@ -121,7 +112,7 @@ private MediaFormat(android.media.MediaFormat format) {
     channelCount = getOptionalIntegerV16(format, android.media.MediaFormat.KEY_CHANNEL_COUNT);
     sampleRate = getOptionalIntegerV16(format, android.media.MediaFormat.KEY_SAMPLE_RATE);
     pixelWidthHeightRatio = getOptionalFloatV16(format, KEY_PIXEL_WIDTH_HEIGHT_RATIO);
-    initializationData = new ArrayList<byte[]>();
+    initializationData = new ArrayList<>();
     for (int i = 0; format.containsKey("csd-" + i); i++) {
       ByteBuffer buffer = format.getByteBuffer("csd-" + i);
       byte[] data = new byte[buffer.limit()];
diff --git a/library/src/main/java/com/google/android/exoplayer/SampleSource.java b/library/src/main/java/com/google/android/exoplayer/SampleSource.java
index b7a93e3f65..3463dc9fcf 100644
--- a/library/src/main/java/com/google/android/exoplayer/SampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/SampleSource.java
@@ -21,8 +21,8 @@
  * A source of media samples.
  * <p>
  * A {@link SampleSource} may expose one or multiple tracks. The number of tracks and information
- * about each can be queried using {@link #getTrackCount()}  and {@link #getTrackInfo(int)}
- * respectively.
+ * about each can be queried using {@link SampleSourceReader#getTrackCount()} and
+ * {@link SampleSourceReader#getTrackInfo(int)} respectively.
  */
 public interface SampleSource {
 
@@ -51,111 +51,134 @@
   public static final int DISCONTINUITY_READ = -5;
 
   /**
-   * Prepares the source.
+   * A consumer of samples should call this method to register themselves and gain access to the
+   * source through the returned {@link SampleSourceReader}.
    * <p>
-   * Preparation may require reading from the data source (e.g. to determine the available tracks
-   * and formats). If insufficient data is available then the call will return {@code false} rather
-   * than block. The method can be called repeatedly until the return value indicates success.
+   * {@link SampleSourceReader#release()} should be called on the returned object when access is no
+   * longer required.
    *
-   * @param positionUs The player's current playback position.
-   * @return True if the source was prepared successfully, false otherwise.
-   * @throws IOException If an error occurred preparing the source.
+   * @return A {@link SampleSourceReader} that provides access to the source.
    */
-  public boolean prepare(long positionUs) throws IOException;
+  public SampleSourceReader register();
 
   /**
-   * Returns the number of tracks exposed by the source.
-   *
-   * @return The number of tracks.
+   * An interface providing read access to a {@link SampleSource}.
    */
-  public int getTrackCount();
+  public interface SampleSourceReader {
 
-  /**
-   * Returns information about the specified track.
-   * <p>
-   * This method should not be called until after the source has been successfully prepared.
-   *
-   * @return Information about the specified track.
-   */
-  public TrackInfo getTrackInfo(int track);
+    /**
+     * Prepares the source.
+     * <p>
+     * Preparation may require reading from the data source (e.g. to determine the available tracks
+     * and formats). If insufficient data is available then the call will return {@code false}
+     * rather than block. The method can be called repeatedly until the return value indicates
+     * success.
+     *
+     * @param positionUs The player's current playback position.
+     * @return True if the source was prepared successfully, false otherwise.
+     * @throws IOException If an error occurred preparing the source.
+     */
+    public boolean prepare(long positionUs) throws IOException;
 
-  /**
-   * Enable the specified track. This allows the track's format and samples to be read from
-   * {@link #readData(int, long, MediaFormatHolder, SampleHolder, boolean)}.
-   * <p>
-   * This method should not be called until after the source has been successfully prepared.
-   *
-   * @param track The track to enable.
-   * @param positionUs The player's current playback position.
-   */
-  public void enable(int track, long positionUs);
+    /**
+     * Returns the number of tracks exposed by the source.
+     *
+     * @return The number of tracks.
+     */
+    public int getTrackCount();
 
-  /**
-   * Disable the specified track.
-   * <p>
-   * This method should not be called until after the source has been successfully prepared.
-   *
-   * @param track The track to disable.
-   */
-  public void disable(int track);
+    /**
+     * Returns information about the specified track.
+     * <p>
+     * This method should not be called until after the source has been successfully prepared.
+     *
+     * @return Information about the specified track.
+     */
+    public TrackInfo getTrackInfo(int track);
 
-  /**
-   * Indicates to the source that it should still be buffering data.
-   *
-   * @param positionUs The current playback position.
-   * @return True if the source has available samples, or if the end of the stream has been reached.
-   *     False if more data needs to be buffered for samples to become available.
-   * @throws IOException If an error occurred reading from the source.
-   */
-  public boolean continueBuffering(long positionUs) throws IOException;
+    /**
+     * Enable the specified track. This allows the track's format and samples to be read from
+     * {@link #readData(int, long, MediaFormatHolder, SampleHolder, boolean)}.
+     * <p>
+     * This method should not be called until after the source has been successfully prepared.
+     *
+     * @param track The track to enable.
+     * @param positionUs The player's current playback position.
+     */
+    public void enable(int track, long positionUs);
 
-  /**
-   * Attempts to read either a sample, a new format or or a discontinuity from the source.
-   * <p>
-   * This method should not be called until after the source has been successfully prepared.
-   * <p>
-   * Note that where multiple tracks are enabled, {@link #NOTHING_READ} may be returned if the
-   * next piece of data to be read from the {@link SampleSource} corresponds to a different track
-   * than the one for which data was requested.
-   *
-   * @param track The track from which to read.
-   * @param positionUs The current playback position.
-   * @param formatHolder A {@link MediaFormatHolder} object to populate in the case of a new format.
-   * @param sampleHolder A {@link SampleHolder} object to populate in the case of a new sample. If
-   *     the caller requires the sample data then it must ensure that {@link SampleHolder#data}
-   *     references a valid output buffer.
-   * @param onlyReadDiscontinuity Whether to only read a discontinuity. If true, only
-   *     {@link #DISCONTINUITY_READ} or {@link #NOTHING_READ} can be returned.
-   * @return The result, which can be {@link #SAMPLE_READ}, {@link #FORMAT_READ},
-   *     {@link #DISCONTINUITY_READ}, {@link #NOTHING_READ} or {@link #END_OF_STREAM}.
-   * @throws IOException If an error occurred reading from the source.
-   */
-  public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
-      SampleHolder sampleHolder, boolean onlyReadDiscontinuity) throws IOException;
+    /**
+     * Disable the specified track.
+     * <p>
+     * This method should not be called until after the source has been successfully prepared.
+     *
+     * @param track The track to disable.
+     */
+    public void disable(int track);
 
-  /**
-   * Seeks to the specified time in microseconds.
-   * <p>
-   * This method should not be called until after the source has been successfully prepared.
-   *
-   * @param positionUs The seek position in microseconds.
-   */
-  public void seekToUs(long positionUs);
+    /**
+     * Indicates to the source that it should still be buffering data for the specified track.
+     *
+     * @param track The track to continue buffering.
+     * @param positionUs The current playback position.
+     * @return True if the track has available samples, or if the end of the stream has been
+     *     reached. False if more data needs to be buffered for samples to become available.
+     * @throws IOException If an error occurred reading from the source.
+     */
+    public boolean continueBuffering(int track, long positionUs) throws IOException;
 
-  /**
-   * Returns an estimate of the position up to which data is buffered.
-   * <p>
-   * This method should not be called until after the source has been successfully prepared.
-   *
-   * @return An estimate of the absolute position in microseconds up to which data is buffered,
-   *     or {@link TrackRenderer#END_OF_TRACK_US} if data is buffered to the end of the stream, or
-   *     {@link TrackRenderer#UNKNOWN_TIME_US} if no estimate is available.
-   */
-  public long getBufferedPositionUs();
+    /**
+     * Attempts to read either a sample, a new format or or a discontinuity from the source.
+     * <p>
+     * This method should not be called until after the source has been successfully prepared.
+     * <p>
+     * Note that where multiple tracks are enabled, {@link #NOTHING_READ} may be returned if the
+     * next piece of data to be read from the {@link SampleSource} corresponds to a different track
+     * than the one for which data was requested.
+     *
+     * @param track The track from which to read.
+     * @param positionUs The current playback position.
+     * @param formatHolder A {@link MediaFormatHolder} object to populate in the case of a new
+     *     format.
+     * @param sampleHolder A {@link SampleHolder} object to populate in the case of a new sample.
+     *     If the caller requires the sample data then it must ensure that {@link SampleHolder#data}
+     *     references a valid output buffer.
+     * @param onlyReadDiscontinuity Whether to only read a discontinuity. If true, only
+     *     {@link #DISCONTINUITY_READ} or {@link #NOTHING_READ} can be returned.
+     * @return The result, which can be {@link #SAMPLE_READ}, {@link #FORMAT_READ},
+     *     {@link #DISCONTINUITY_READ}, {@link #NOTHING_READ} or {@link #END_OF_STREAM}.
+     * @throws IOException If an error occurred reading from the source.
+     */
+    public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
+        SampleHolder sampleHolder, boolean onlyReadDiscontinuity) throws IOException;
 
-  /**
-   * Releases the {@link SampleSource}.
-   */
-  public void release();
+    /**
+     * Seeks to the specified time in microseconds.
+     * <p>
+     * This method should not be called until after the source has been successfully prepared.
+     *
+     * @param positionUs The seek position in microseconds.
+     */
+    public void seekToUs(long positionUs);
+
+    /**
+     * Returns an estimate of the position up to which data is buffered.
+     * <p>
+     * This method should not be called until after the source has been successfully prepared.
+     *
+     * @return An estimate of the absolute position in microseconds up to which data is buffered,
+     *     or {@link TrackRenderer#END_OF_TRACK_US} if data is buffered to the end of the stream,
+     *     or {@link TrackRenderer#UNKNOWN_TIME_US} if no estimate is available.
+     */
+    public long getBufferedPositionUs();
+
+    /**
+     * Releases the {@link SampleSourceReader}.
+     * <p>
+     * This method should be called when access to the {@link SampleSource} is no longer required.
+     */
+    public void release();
+
+  }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/StandaloneMediaClock.java b/library/src/main/java/com/google/android/exoplayer/StandaloneMediaClock.java
new file mode 100644
index 0000000000..f4b85b0d35
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/StandaloneMediaClock.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer;
+
+import android.os.SystemClock;
+
+/**
+ * A standalone {@link MediaClock}. The clock can be started, stopped and its time can be set and
+ * retrieved. When started, this clock is based on {@link SystemClock#elapsedRealtime()}.
+ */
+/* package */ class StandaloneMediaClock implements MediaClock {
+
+  private boolean started;
+
+  /**
+   * The media time when the clock was last set or stopped.
+   */
+  private long positionUs;
+
+  /**
+   * The difference between {@link SystemClock#elapsedRealtime()} and {@link #positionUs}
+   * when the clock was last set or started.
+   */
+  private long deltaUs;
+
+  /**
+   * Starts the clock. Does nothing if the clock is already started.
+   */
+  public void start() {
+    if (!started) {
+      started = true;
+      deltaUs = elapsedRealtimeMinus(positionUs);
+    }
+  }
+
+  /**
+   * Stops the clock. Does nothing if the clock is already stopped.
+   */
+  public void stop() {
+    if (started) {
+      positionUs = elapsedRealtimeMinus(deltaUs);
+      started = false;
+    }
+  }
+
+  /**
+   * @param timeUs The position to set in microseconds.
+   */
+  public void setPositionUs(long timeUs) {
+    this.positionUs = timeUs;
+    deltaUs = elapsedRealtimeMinus(timeUs);
+  }
+
+  @Override
+  public long getPositionUs() {
+    return started ? elapsedRealtimeMinus(deltaUs) : positionUs;
+  }
+
+  private long elapsedRealtimeMinus(long toSubtractUs) {
+    return SystemClock.elapsedRealtime() * 1000 - toSubtractUs;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/TimeRange.java b/library/src/main/java/com/google/android/exoplayer/TimeRange.java
new file mode 100644
index 0000000000..03bc528749
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/TimeRange.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer;
+
+/**
+ * A container to store a start and end time in microseconds.
+ */
+public final class TimeRange {
+
+  /**
+   * Represents a range of time whose bounds change in bulk increments rather than smoothly over
+   * time.
+   */
+  public static final int TYPE_SNAPSHOT = 0;
+
+  /**
+   * The type of this time range.
+   */
+  public final int type;
+
+  private final long startTimeUs;
+  private final long endTimeUs;
+
+  /**
+   * Create a new {@link TimeRange} of the appropriate type.
+   *
+   * @param type The type of the TimeRange.
+   * @param startTimeUs The beginning of the TimeRange.
+   * @param endTimeUs The end of the TimeRange.
+   */
+  public TimeRange(int type, long startTimeUs, long endTimeUs) {
+    this.type = type;
+    this.startTimeUs = startTimeUs;
+    this.endTimeUs = endTimeUs;
+  }
+
+  /**
+   * Returns the start and end times (in milliseconds) of the TimeRange in the provided array,
+   * or creates a new one.
+   *
+   * @param out An array to store the start and end times; can be null.
+   * @return An array containing the start time (index 0) and end time (index 1) in milliseconds.
+   */
+  public long[] getCurrentBoundsMs(long[] out) {
+    out = getCurrentBoundsUs(out);
+    out[0] /= 1000;
+    out[1] /= 1000;
+    return out;
+  }
+
+  /**
+   * Returns the start and end times (in microseconds) of the TimeRange in the provided array,
+   * or creates a new one.
+   *
+   * @param out An array to store the start and end times; can be null.
+   * @return An array containing the start time (index 0) and end time (index 1) in microseconds.
+   */
+  public long[] getCurrentBoundsUs(long[] out) {
+    if (out == null || out.length < 2) {
+      out = new long[2];
+    }
+    out[0] = startTimeUs;
+    out[1] = endTimeUs;
+    return out;
+  }
+
+  @Override
+  public int hashCode() {
+    int hashCode = 0;
+    hashCode |= type << 30;
+    hashCode |= (((startTimeUs + endTimeUs) / 1000) & 0x3FFFFFFF);
+    return hashCode;
+  }
+
+  @Override
+  public boolean equals(Object other) {
+    if (other == this) {
+      return true;
+    }
+    if (other instanceof TimeRange) {
+      TimeRange otherTimeRange = (TimeRange) other;
+      return (otherTimeRange.type == type) && (otherTimeRange.startTimeUs == startTimeUs)
+          && (otherTimeRange.endTimeUs == endTimeUs);
+    } else {
+      return false;
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/TrackInfo.java b/library/src/main/java/com/google/android/exoplayer/TrackInfo.java
index 72487a0cdf..f0ac31ac22 100644
--- a/library/src/main/java/com/google/android/exoplayer/TrackInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer/TrackInfo.java
@@ -26,14 +26,17 @@
   public final String mimeType;
 
   /**
-   * The duration in microseconds, or {@link C#UNKNOWN_TIME_US} if the duration is unknown.
+   * The duration in microseconds, or {@link C#UNKNOWN_TIME_US} if the duration is unknown, or
+   * {@link C#MATCH_LONGEST_US} if the duration should match the duration of the longest track whose
+   * duration is known.
    */
   public final long durationUs;
 
   /**
    * @param mimeType The mime type.
    * @param durationUs The duration in microseconds, or {@link C#UNKNOWN_TIME_US} if the duration
-   *     is unknown.
+   *     is unknown, or {@link C#MATCH_LONGEST_US} if the duration should match the duration of the
+   *     longest track whose duration is known.
    */
   public TrackInfo(String mimeType, long durationUs) {
     this.mimeType = mimeType;
diff --git a/library/src/main/java/com/google/android/exoplayer/TrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/TrackRenderer.java
index 3b8b4f372b..cb4b866f15 100644
--- a/library/src/main/java/com/google/android/exoplayer/TrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/TrackRenderer.java
@@ -70,9 +70,9 @@
   public static final long UNKNOWN_TIME_US = C.UNKNOWN_TIME_US; // -1
   /**
    * Represents a time or duration that should match the duration of the longest track whose
-   * duration is known.
+   * duration is known. Equal to {@link C#MATCH_LONGEST_US}.
    */
-  public static final long MATCH_LONGEST_US = -2;
+  public static final long MATCH_LONGEST_US = C.MATCH_LONGEST_US; // -2
   /**
    * Represents the time of the end of the track.
    */
@@ -81,18 +81,15 @@
   private int state;
 
   /**
-   * A time source renderer is a renderer that, when started, advances its own playback position.
-   * This means that {@link #getCurrentPositionUs()} will return increasing positions independently
-   * to increasing values being passed to {@link #doSomeWork(long, long)}. A player may have at most
-   * one time source renderer. If provided, the player will use such a renderer as its source of
-   * time during playback.
-   * <p>
-   * This method may be called when the renderer is in any state.
+   * If the renderer advances its own playback position then this method returns a corresponding
+   * {@link MediaClock}. If provided, the player will use the returned {@link MediaClock} as its
+   * source of time during playback. A player may have at most one renderer that returns a
+   * {@link MediaClock} from this method.
    *
-   * @return True if the renderer should be considered a time source. False otherwise.
+   * @return The {@link MediaClock} tracking the playback position of the renderer, or null.
    */
-  protected boolean isTimeSource() {
-    return false;
+  protected MediaClock getMediaClock() {
+    return null;
   }
 
   /**
@@ -312,16 +309,6 @@ protected abstract void doSomeWork(long positionUs, long elapsedRealtimeUs)
    */
   protected abstract long getDurationUs();
 
-  /**
-   * Returns the current playback position.
-   * <p>
-   * This method may be called when the renderer is in the following states:
-   * {@link #STATE_ENABLED}, {@link #STATE_STARTED}
-   *
-   * @return The current playback position in microseconds.
-   */
-  protected abstract long getCurrentPositionUs();
-
   /**
    * Returns an estimate of the absolute position in microseconds up to which data is buffered.
    * <p>
diff --git a/library/src/main/java/com/google/android/exoplayer/VideoSurfaceView.java b/library/src/main/java/com/google/android/exoplayer/VideoSurfaceView.java
deleted file mode 100644
index 9923e2ae5d..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/VideoSurfaceView.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer;
-
-import android.content.Context;
-import android.util.AttributeSet;
-import android.view.SurfaceView;
-
-/**
- * A SurfaceView that resizes itself to match a specified aspect ratio.
- */
-public class VideoSurfaceView extends SurfaceView {
-
-  /**
-   * The surface view will not resize itself if the fractional difference between its default
-   * aspect ratio and the aspect ratio of the video falls below this threshold.
-   * <p>
-   * This tolerance is useful for fullscreen playbacks, since it ensures that the surface will
-   * occupy the whole of the screen when playing content that has the same (or virtually the same)
-   * aspect ratio as the device. This typically reduces the number of view layers that need to be
-   * composited by the underlying system, which can help to reduce power consumption.
-   */
-  private static final float MAX_ASPECT_RATIO_DEFORMATION_PERCENT = 0.01f;
-
-  private float videoAspectRatio;
-
-  public VideoSurfaceView(Context context) {
-    super(context);
-  }
-
-  public VideoSurfaceView(Context context, AttributeSet attrs) {
-    super(context, attrs);
-  }
-
-  /**
-   * Set the aspect ratio that this {@link VideoSurfaceView} should satisfy.
-   *
-   * @param widthHeightRatio The width to height ratio.
-   */
-  public void setVideoWidthHeightRatio(float widthHeightRatio) {
-    if (this.videoAspectRatio != widthHeightRatio) {
-      this.videoAspectRatio = widthHeightRatio;
-      requestLayout();
-    }
-  }
-
-  @Override
-  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
-    int width = getMeasuredWidth();
-    int height = getMeasuredHeight();
-    if (videoAspectRatio != 0) {
-      float viewAspectRatio = (float) width / height;
-      float aspectDeformation = videoAspectRatio / viewAspectRatio - 1;
-      if (aspectDeformation > MAX_ASPECT_RATIO_DEFORMATION_PERCENT) {
-        height = (int) (width / videoAspectRatio);
-      } else if (aspectDeformation < -MAX_ASPECT_RATIO_DEFORMATION_PERCENT) {
-        width = (int) (height * videoAspectRatio);
-      }
-    }
-    setMeasuredDimension(width, height);
-  }
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/audio/AudioCapabilitiesReceiver.java b/library/src/main/java/com/google/android/exoplayer/audio/AudioCapabilitiesReceiver.java
index 18e8d2a281..90273e434b 100644
--- a/library/src/main/java/com/google/android/exoplayer/audio/AudioCapabilitiesReceiver.java
+++ b/library/src/main/java/com/google/android/exoplayer/audio/AudioCapabilitiesReceiver.java
@@ -68,7 +68,12 @@ public AudioCapabilitiesReceiver(Context context, Listener listener) {
   @TargetApi(21)
   public void register() {
     if (receiver != null) {
-      context.registerReceiver(receiver, new IntentFilter(AudioManager.ACTION_HDMI_AUDIO_PLUG));
+      Intent initialStickyIntent =
+          context.registerReceiver(receiver, new IntentFilter(AudioManager.ACTION_HDMI_AUDIO_PLUG));
+      if (initialStickyIntent != null) {
+        receiver.onReceive(context, initialStickyIntent);
+        return;
+      }
     }
 
     listener.onAudioCapabilitiesChanged(DEFAULT_AUDIO_CAPABILITIES);
@@ -86,6 +91,10 @@ public void unregister() {
 
     @Override
     public void onReceive(Context context, Intent intent) {
+      if (isInitialStickyBroadcast()) {
+        return;
+      }
+
       String action = intent.getAction();
       if (!action.equals(AudioManager.ACTION_HDMI_AUDIO_PLUG)) {
         return;
diff --git a/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java b/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
index c973a2cd2f..1931e34e01 100644
--- a/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
+++ b/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
@@ -55,7 +55,7 @@
   /**
    * Thrown when a failure occurs instantiating an {@link android.media.AudioTrack}.
    */
-  public static class InitializationException extends Exception {
+  public static final class InitializationException extends Exception {
 
     /** The state as reported by {@link android.media.AudioTrack#getState()}. */
     public final int audioTrackState;
@@ -72,7 +72,7 @@ public InitializationException(
   /**
    * Thrown when a failure occurs writing to an {@link android.media.AudioTrack}.
    */
-  public static class WriteException extends Exception {
+  public static final class WriteException extends Exception {
 
     /** The value returned from {@link android.media.AudioTrack#write(byte[], int, int)}. */
     public final int errorCode;
@@ -84,6 +84,18 @@ public WriteException(int errorCode) {
 
   }
 
+  /**
+   * Thrown when {@link android.media.AudioTrack#getTimestamp} returns a spurious timestamp, if
+   * {@code AudioTrack#failOnSpuriousAudioTimestamp} is set.
+   */
+  private static final class InvalidAudioTrackTimestampException extends RuntimeException {
+
+    public InvalidAudioTrackTimestampException(String message) {
+      super(message);
+    }
+
+  }
+
   /** Returned in the result of {@link #handleBuffer} if the buffer was discontinuous. */
   public static final int RESULT_POSITION_DISCONTINUITY = 1;
   /** Returned in the result of {@link #handleBuffer} if the buffer can be released. */
@@ -134,12 +146,22 @@ public WriteException(int errorCode) {
   private static final int MIN_TIMESTAMP_SAMPLE_INTERVAL_US = 500000;
 
   /**
-   * Set to {@code true} to enable a workaround for an issue where an audio effect does not keep its
-   * session active across releasing/initializing a new audio track, on platform API version < 21.
-   * The flag must be set before creating the player.
+   * Whether to enable a workaround for an issue where an audio effect does not keep its session
+   * active across releasing/initializing a new audio track, on platform API version < 21.
+   * <p>
+   * The flag must be set before creating a player.
    */
   public static boolean enablePreV21AudioSessionWorkaround = false;
 
+  /**
+   * Whether to throw an {@link InvalidAudioTrackTimestampException} when a spurious timestamp is
+   * reported from {@link android.media.AudioTrack#getTimestamp}.
+   * <p>
+   * The flag must be set before creating a player. Should be set to {@code true} for testing and
+   * debugging purposes only.
+   */
+  public static boolean failOnSpuriousAudioTimestamp = false;
+
   private final ConditionVariable releasingConditionVariable;
   private final long[] playheadOffsets;
   private final AudioTrackUtil audioTrackUtil;
@@ -626,7 +648,9 @@ private boolean hasCurrentPositionUs() {
     return isInitialized() && startMediaTimeState != START_NOT_SET;
   }
 
-  /** Updates the audio track latency and playback position parameters. */
+  /**
+   * Updates the audio track latency and playback position parameters.
+   */
   private void maybeSampleSyncParams() {
     long playbackPositionUs = audioTrackUtil.getPlaybackHeadPositionUs();
     if (playbackPositionUs == 0) {
@@ -661,17 +685,25 @@ private void maybeSampleSyncParams() {
           audioTimestampSet = false;
         } else if (Math.abs(audioTimestampUs - systemClockUs) > MAX_AUDIO_TIMESTAMP_OFFSET_US) {
           // The timestamp time base is probably wrong.
-          audioTimestampSet = false;
-          Log.w(TAG, "Spurious audio timestamp (system clock mismatch): "
+          String message = "Spurious audio timestamp (system clock mismatch): "
               + audioTimestampFramePosition + ", " + audioTimestampUs + ", " + systemClockUs + ", "
-              + playbackPositionUs);
+              + playbackPositionUs;
+          if (failOnSpuriousAudioTimestamp) {
+            throw new InvalidAudioTrackTimestampException(message);
+          }
+          Log.w(TAG, message);
+          audioTimestampSet = false;
         } else if (Math.abs(framesToDurationUs(audioTimestampFramePosition) - playbackPositionUs)
             > MAX_AUDIO_TIMESTAMP_OFFSET_US) {
           // The timestamp frame position is probably wrong.
-          audioTimestampSet = false;
-          Log.w(TAG, "Spurious audio timestamp (frame position mismatch): "
+          String message = "Spurious audio timestamp (frame position mismatch): "
               + audioTimestampFramePosition + ", " + audioTimestampUs + ", " + systemClockUs + ", "
-              + playbackPositionUs);
+              + playbackPositionUs;
+          if (failOnSpuriousAudioTimestamp) {
+            throw new InvalidAudioTrackTimestampException(message);
+          }
+          Log.w(TAG, message);
+          audioTimestampSet = false;
         }
       }
       if (getLatencyMethod != null) {
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/BaseChunkSampleSourceEventListener.java b/library/src/main/java/com/google/android/exoplayer/chunk/BaseChunkSampleSourceEventListener.java
index c155928020..9b27d4c560 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/BaseChunkSampleSourceEventListener.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/BaseChunkSampleSourceEventListener.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.SampleSource;
+import com.google.android.exoplayer.SampleSource.SampleSourceReader;
 
 import java.io.IOException;
 
@@ -90,7 +91,7 @@ void onLoadCompleted(int sourceId, long bytesLoaded, int type, int trigger, Form
 
   /**
    * Invoked when the downstream format changes (i.e. when the format being supplied to the
-   * caller of {@link SampleSource#readData} changes).
+   * caller of {@link SampleSourceReader#readData} changes).
    *
    * @param sourceId The id of the reporting {@link SampleSource}.
    * @param format The format.
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/BaseMediaChunk.java b/library/src/main/java/com/google/android/exoplayer/chunk/BaseMediaChunk.java
index 73db1785d1..04f8a084cd 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/BaseMediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/BaseMediaChunk.java
@@ -33,7 +33,7 @@
    * obtain the chunk's media format and drm initialization data. If false, these methods are only
    * guaranteed to return correct data after the first sample data has been output from the chunk.
    */
-  public final boolean isFormatFinal;
+  public final boolean isMediaFormatFinal;
 
   private DefaultTrackOutput output;
   private int firstSampleIndex;
@@ -47,16 +47,16 @@
    * @param endTimeUs The end time of the media contained by the chunk, in microseconds.
    * @param chunkIndex The index of the chunk.
    * @param isLastChunk True if this is the last chunk in the media. False otherwise.
-   * @param isFormatFinal True if {@link #getMediaFormat()} and {@link #getDrmInitData()} can be
-   *     called at any time to obtain the media format and drm initialization data. False if these
-   *     methods are only guaranteed to return correct data after the first sample data has been
-   *     output from the chunk.
+   * @param isMediaFormatFinal True if {@link #getMediaFormat()} and {@link #getDrmInitData()} can
+   *     be called at any time to obtain the media format and drm initialization data. False if
+   *     these methods are only guaranteed to return correct data after the first sample data has
+   *     been output from the chunk.
    */
   public BaseMediaChunk(DataSource dataSource, DataSpec dataSpec, int trigger, Format format,
       long startTimeUs, long endTimeUs, int chunkIndex, boolean isLastChunk,
-      boolean isFormatFinal) {
+      boolean isMediaFormatFinal) {
     super(dataSource, dataSpec, trigger, format, startTimeUs, endTimeUs, chunkIndex, isLastChunk);
-    this.isFormatFinal = isFormatFinal;
+    this.isMediaFormatFinal = isMediaFormatFinal;
   }
 
   /**
@@ -81,7 +81,7 @@ public final int getFirstSampleIndex() {
   /**
    * Gets the {@link MediaFormat} corresponding to the chunk.
    * <p>
-   * See {@link #isFormatFinal} for information about when this method is guaranteed to return
+   * See {@link #isMediaFormatFinal} for information about when this method is guaranteed to return
    * correct data.
    *
    * @return The {@link MediaFormat} corresponding to this chunk.
@@ -91,7 +91,7 @@ public final int getFirstSampleIndex() {
   /**
    * Gets the {@link DrmInitData} corresponding to the chunk.
    * <p>
-   * See {@link #isFormatFinal} for information about when this method is guaranteed to return
+   * See {@link #isMediaFormatFinal} for information about when this method is guaranteed to return
    * correct data.
    *
    * @return The {@link DrmInitData} corresponding to this chunk.
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/Chunk.java b/library/src/main/java/com/google/android/exoplayer/chunk/Chunk.java
index e0bd379b5f..e42c2331fd 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/Chunk.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/Chunk.java
@@ -67,6 +67,10 @@
    * Value of {@link #trigger} for a load triggered by an adaptive format selection.
    */
   public static final int TRIGGER_ADAPTIVE = 3;
+  /**
+   * Value of {@link #trigger} for a load triggered whilst in a trick play mode.
+   */
+  public static final int TRIGGER_TRICK_PLAY = 4;
   /**
    * Implementations may define custom {@link #trigger} codes greater than or equal to this value.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
index a023a31244..4837f0a5d5 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
@@ -21,6 +21,7 @@
 import com.google.android.exoplayer.MediaFormatHolder;
 import com.google.android.exoplayer.SampleHolder;
 import com.google.android.exoplayer.SampleSource;
+import com.google.android.exoplayer.SampleSource.SampleSourceReader;
 import com.google.android.exoplayer.TrackInfo;
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.extractor.DefaultTrackOutput;
@@ -40,7 +41,7 @@
  * A {@link SampleSource} that loads media in {@link Chunk}s, which are themselves obtained from a
  * {@link ChunkSource}.
  */
-public class ChunkSampleSource implements SampleSource, Loader.Callback {
+public class ChunkSampleSource implements SampleSource, SampleSourceReader, Loader.Callback {
 
   /**
    * Interface definition for a callback to be notified of {@link ChunkSampleSource} events.
@@ -52,9 +53,10 @@
    */
   public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT = 3;
 
-  private static final int STATE_UNPREPARED = 0;
-  private static final int STATE_PREPARED = 1;
-  private static final int STATE_ENABLED = 2;
+  private static final int STATE_IDLE = 0;
+  private static final int STATE_INITIALIZED = 1;
+  private static final int STATE_PREPARED = 2;
+  private static final int STATE_ENABLED = 3;
 
   private static final int NO_RESET_PENDING = -1;
 
@@ -81,7 +83,6 @@
   private Loader loader;
   private boolean loadingFinished;
   private IOException currentLoadableException;
-  private boolean currentLoadableExceptionFatal;
   private int currentLoadableExceptionCount;
   private long currentLoadableExceptionTimestamp;
   private long currentLoadStartTimeMs;
@@ -113,16 +114,26 @@ public ChunkSampleSource(ChunkSource chunkSource, LoadControl loadControl,
     this.eventSourceId = eventSourceId;
     this.minLoadableRetryCount = minLoadableRetryCount;
     currentLoadableHolder = new ChunkOperationHolder();
-    mediaChunks = new LinkedList<BaseMediaChunk>();
+    mediaChunks = new LinkedList<>();
     readOnlyMediaChunks = Collections.unmodifiableList(mediaChunks);
     sampleQueue = new DefaultTrackOutput(loadControl.getAllocator());
-    state = STATE_UNPREPARED;
+    state = STATE_IDLE;
     pendingResetPositionUs = NO_RESET_PENDING;
   }
 
+  @Override
+  public SampleSourceReader register() {
+    Assertions.checkState(state == STATE_IDLE);
+    state = STATE_INITIALIZED;
+    return this;
+  }
+
   @Override
   public boolean prepare(long positionUs) {
-    Assertions.checkState(state == STATE_UNPREPARED);
+    Assertions.checkState(state == STATE_INITIALIZED || state == STATE_PREPARED);
+    if (state == STATE_PREPARED) {
+      return true;
+    }
     loader = new Loader("Loader:" + chunkSource.getTrackInfo().mimeType);
     state = STATE_PREPARED;
     return true;
@@ -130,13 +141,13 @@ public boolean prepare(long positionUs) {
 
   @Override
   public int getTrackCount() {
-    Assertions.checkState(state != STATE_UNPREPARED);
+    Assertions.checkState(state == STATE_PREPARED || state == STATE_ENABLED);
     return 1;
   }
 
   @Override
   public TrackInfo getTrackInfo(int track) {
-    Assertions.checkState(state != STATE_UNPREPARED);
+    Assertions.checkState(state == STATE_PREPARED || state == STATE_ENABLED);
     Assertions.checkState(track == 0);
     return chunkSource.getTrackInfo();
   }
@@ -152,6 +163,7 @@ public void enable(int track, long positionUs) {
     downstreamMediaFormat = null;
     downstreamPositionUs = positionUs;
     lastSeekPositionUs = positionUs;
+    pendingDiscontinuity = false;
     restartFrom(positionUs);
   }
 
@@ -159,7 +171,6 @@ public void enable(int track, long positionUs) {
   public void disable(int track) {
     Assertions.checkState(state == STATE_ENABLED);
     Assertions.checkState(track == 0);
-    pendingDiscontinuity = false;
     state = STATE_PREPARED;
     try {
       chunkSource.disable(mediaChunks);
@@ -177,8 +188,9 @@ public void disable(int track) {
   }
 
   @Override
-  public boolean continueBuffering(long positionUs) throws IOException {
+  public boolean continueBuffering(int track, long positionUs) throws IOException {
     Assertions.checkState(state == STATE_ENABLED);
+    Assertions.checkState(track == 0);
     downstreamPositionUs = positionUs;
     chunkSource.continueBuffering(positionUs);
     updateLoadControl();
@@ -225,9 +237,9 @@ public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
       downstreamFormat = currentChunk.format;
     }
 
-    if (haveSamples || currentChunk.isFormatFinal) {
+    if (haveSamples || currentChunk.isMediaFormatFinal) {
       MediaFormat mediaFormat = currentChunk.getMediaFormat();
-      if (mediaFormat != null && !mediaFormat.equals(downstreamMediaFormat, true)) {
+      if (!mediaFormat.equals(downstreamMediaFormat, true)) {
         chunkSource.getMaxVideoDimensions(mediaFormat);
         formatHolder.format = mediaFormat;
         formatHolder.drmInitData = currentChunk.getDrmInitData();
@@ -258,12 +270,14 @@ public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
   @Override
   public void seekToUs(long positionUs) {
     Assertions.checkState(state == STATE_ENABLED);
+
+    long currentPositionUs = isPendingReset() ? pendingResetPositionUs : downstreamPositionUs;
+    downstreamPositionUs = positionUs;
     lastSeekPositionUs = positionUs;
-    if ((isPendingReset() ? pendingResetPositionUs : downstreamPositionUs) == positionUs) {
+    if (currentPositionUs == positionUs) {
       return;
     }
 
-    downstreamPositionUs = positionUs;
     // If we're not pending a reset, see if we can seek within the sample queue.
     boolean seekInsideBuffer = !isPendingReset() && sampleQueue.skipToKeyframeBefore(positionUs);
     if (seekInsideBuffer) {
@@ -282,8 +296,7 @@ public void seekToUs(long positionUs) {
   }
 
   private void maybeThrowLoadableException() throws IOException {
-    if (currentLoadableException != null && (currentLoadableExceptionFatal
-        || currentLoadableExceptionCount > minLoadableRetryCount)) {
+    if (currentLoadableException != null && currentLoadableExceptionCount > minLoadableRetryCount) {
       throw currentLoadableException;
     }
     if (sampleQueue.isEmpty() && currentLoadableHolder.chunk == null) {
@@ -315,7 +328,7 @@ public void release() {
       loader.release();
       loader = null;
     }
-    state = STATE_UNPREPARED;
+    state = STATE_IDLE;
   }
 
   @Override
@@ -394,16 +407,9 @@ private void clearCurrentLoadable() {
   private void clearCurrentLoadableException() {
     currentLoadableException = null;
     currentLoadableExceptionCount = 0;
-    currentLoadableExceptionFatal = false;
   }
 
   private void updateLoadControl() {
-    if (currentLoadableExceptionFatal) {
-      // We've failed, but we still need to update the control with our current state.
-      loadControl.update(this, downstreamPositionUs, -1, false, true);
-      return;
-    }
-
     long now = SystemClock.elapsedRealtime();
     long nextLoadPositionUs = getNextLoadPositionUs();
     boolean isBackedOff = currentLoadableException != null;
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/ContainerMediaChunk.java b/library/src/main/java/com/google/android/exoplayer/chunk/ContainerMediaChunk.java
index d1145ff91b..031495e306 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/ContainerMediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/ContainerMediaChunk.java
@@ -62,15 +62,15 @@
    *     known to define its own format.
    * @param drmInitData The {@link DrmInitData} for the chunk. Null if the media is not drm
    *     protected. May also be null if the data is known to define its own initialization data.
-   * @param isFormatFinal True if {@code mediaFormat} and {@code drmInitData} are known to be
+   * @param isMediaFormatFinal True if {@code mediaFormat} and {@code drmInitData} are known to be
    *     correct and final. False if the data may define its own format or initialization data.
    */
   public ContainerMediaChunk(DataSource dataSource, DataSpec dataSpec, int trigger, Format format,
       long startTimeUs, long endTimeUs, int chunkIndex, boolean isLastChunk, long sampleOffsetUs,
       ChunkExtractorWrapper extractorWrapper, MediaFormat mediaFormat, DrmInitData drmInitData,
-      boolean isFormatFinal) {
+      boolean isMediaFormatFinal) {
     super(dataSource, dataSpec, trigger, format, startTimeUs, endTimeUs, chunkIndex, isLastChunk,
-        isFormatFinal);
+        isMediaFormatFinal);
     this.extractorWrapper = extractorWrapper;
     this.sampleOffsetUs = sampleOffsetUs;
     this.mediaFormat = mediaFormat;
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/FormatEvaluator.java b/library/src/main/java/com/google/android/exoplayer/chunk/FormatEvaluator.java
index 7c88ff68a0..d9fa1985fc 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/FormatEvaluator.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/FormatEvaluator.java
@@ -115,6 +115,13 @@ public RandomEvaluator() {
       this.random = new Random();
     }
 
+    /**
+     * @param seed A seed for the underlying random number generator.
+     */
+    public RandomEvaluator(int seed) {
+      this.random = new Random(seed);
+    }
+
     @Override
     public void enable() {
       // Do nothing.
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleChunkSource.java b/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleChunkSource.java
index 5c6ca99989..8ee6c9adad 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleChunkSource.java
@@ -44,7 +44,8 @@
    * @param dataSpec Defines the location of the sample.
    * @param format The format of the sample.
    * @param durationUs The duration of the sample in microseconds, or {@link C#UNKNOWN_TIME_US} if
-   *     the duration is unknown.
+   *     the duration is unknown, or {@link C#MATCH_LONGEST_US} if the duration should match the
+   *     duration of the longest track whose duration is known.
    * @param mediaFormat The sample media format. May be null.
    */
   public SingleSampleChunkSource(DataSource dataSource, DataSpec dataSpec, Format format,
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java b/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
index 03adf45819..0866382fc7 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
@@ -94,7 +94,7 @@
       String[] allowedContainerMimeTypes, boolean filterHdFormats, boolean orientationMayChange,
       int viewportWidth, int viewportHeight) throws DecoderQueryException {
     int maxVideoPixelsToRetain = Integer.MAX_VALUE;
-    ArrayList<Integer> selectedIndexList = new ArrayList<Integer>();
+    ArrayList<Integer> selectedIndexList = new ArrayList<>();
     int maxDecodableFrameSize = MediaCodecUtil.maxH264DecodableFrameSize();
 
     // First pass to filter out formats that individually fail to meet the selection criteria.
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java b/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
index 226c1237c3..0b0da1e8f4 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
@@ -16,7 +16,9 @@
 package com.google.android.exoplayer.dash;
 
 import com.google.android.exoplayer.BehindLiveWindowException;
+import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.TimeRange;
 import com.google.android.exoplayer.TrackInfo;
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.chunk.Chunk;
@@ -42,7 +44,6 @@
 import com.google.android.exoplayer.extractor.Extractor;
 import com.google.android.exoplayer.extractor.mp4.FragmentedMp4Extractor;
 import com.google.android.exoplayer.extractor.webm.WebmExtractor;
-import com.google.android.exoplayer.text.webvtt.WebvttParser;
 import com.google.android.exoplayer.upstream.DataSource;
 import com.google.android.exoplayer.upstream.DataSpec;
 import com.google.android.exoplayer.util.Clock;
@@ -50,6 +51,8 @@
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.SystemClock;
 
+import android.os.Handler;
+
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collections;
@@ -63,6 +66,20 @@
  */
 public class DashChunkSource implements ChunkSource {
 
+  /**
+   * Interface definition for a callback to be notified of {@link DashChunkSource} events.
+   */
+  public interface EventListener {
+
+    /**
+     * Invoked when the available seek range of the stream has changed.
+     *
+     * @param seekRange The range which specifies available content that can be seeked to.
+     */
+    public void onSeekRangeChanged(TimeRange seekRange);
+
+  }
+
   /**
    * Thrown when an AdaptationSet is missing from the MPD.
    */
@@ -79,9 +96,12 @@ public NoAdaptationSetException(String message) {
    */
   public static final int USE_ALL_TRACKS = -1;
 
+  private final Handler eventHandler;
+  private final EventListener eventListener;
+
   private final TrackInfo trackInfo;
   private final DataSource dataSource;
-  private final FormatEvaluator evaluator;
+  private final FormatEvaluator formatEvaluator;
   private final Evaluation evaluation;
   private final Clock systemClock;
   private final StringBuilder headerBuilder;
@@ -97,10 +117,16 @@ public NoAdaptationSetException(String message) {
   private final int adaptationSetIndex;
   private final int[] representationIndices;
 
-  private DrmInitData drmInitData;
   private MediaPresentationDescription currentManifest;
   private boolean finishedCurrentManifest;
 
+  private DrmInitData drmInitData;
+  private TimeRange seekRange;
+  private long[] seekRangeValues;
+  private int firstAvailableSegmentNum;
+  private int lastAvailableSegmentNum;
+
+  private boolean startAtLiveEdge;
   private boolean lastChunkWasInitialization;
   private IOException fatalError;
 
@@ -142,7 +168,7 @@ public DashChunkSource(DataSource dataSource, FormatEvaluator formatEvaluator,
   public DashChunkSource(MediaPresentationDescription manifest, int adaptationSetIndex,
       int[] representationIndices, DataSource dataSource, FormatEvaluator formatEvaluator) {
     this(null, manifest, adaptationSetIndex, representationIndices, dataSource, formatEvaluator,
-        new SystemClock(), 0, 0);
+        new SystemClock(), 0, 0, false, null, null);
   }
 
   /**
@@ -165,32 +191,75 @@ public DashChunkSource(MediaPresentationDescription manifest, int adaptationSetI
    *     note that the value sets an upper bound on the length of media that the player can buffer.
    *     Hence a small value may increase the probability of rebuffering and playback failures.
    * @param elapsedRealtimeOffsetMs If known, an estimate of the instantaneous difference between
-   *    server-side unix time and {@link SystemClock#elapsedRealtime()} in milliseconds, specified
-   *    as the server's unix time minus the local elapsed time. It unknown, set to 0.
+   *     server-side unix time and {@link SystemClock#elapsedRealtime()} in milliseconds, specified
+   *     as the server's unix time minus the local elapsed time. It unknown, set to 0.
+   * @param eventHandler A handler to use when delivering events to {@code EventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
    */
   public DashChunkSource(ManifestFetcher<MediaPresentationDescription> manifestFetcher,
       int adaptationSetIndex, int[] representationIndices, DataSource dataSource,
-      FormatEvaluator formatEvaluator, long liveEdgeLatencyMs, long elapsedRealtimeOffsetMs) {
+      FormatEvaluator formatEvaluator, long liveEdgeLatencyMs, long elapsedRealtimeOffsetMs,
+      Handler eventHandler, EventListener eventListener) {
     this(manifestFetcher, manifestFetcher.getManifest(), adaptationSetIndex, representationIndices,
         dataSource, formatEvaluator, new SystemClock(), liveEdgeLatencyMs * 1000,
-        elapsedRealtimeOffsetMs * 1000);
+        elapsedRealtimeOffsetMs * 1000, true, eventHandler, eventListener);
+  }
+
+  /**
+   * Constructor to use for live DVR streaming.
+   *
+   * @param manifestFetcher A fetcher for the manifest, which must have already successfully
+   *     completed an initial load.
+   * @param adaptationSetIndex The index of the adaptation set that should be used.
+   * @param representationIndices The indices of the representations within the adaptations set
+   *     that should be used. May be null if all representations within the adaptation set should
+   *     be considered.
+   * @param dataSource A {@link DataSource} suitable for loading the media data.
+   * @param formatEvaluator Selects from the available formats.
+   * @param liveEdgeLatencyMs For live streams, the number of milliseconds that the playback should
+   *     lag behind the "live edge" (i.e. the end of the most recently defined media in the
+   *     manifest). Choosing a small value will minimize latency introduced by the player, however
+   *     note that the value sets an upper bound on the length of media that the player can buffer.
+   *     Hence a small value may increase the probability of rebuffering and playback failures.
+   * @param elapsedRealtimeOffsetMs If known, an estimate of the instantaneous difference between
+   *     server-side unix time and {@link SystemClock#elapsedRealtime()} in milliseconds, specified
+   *     as the server's unix time minus the local elapsed time. It unknown, set to 0.
+   * @param startAtLiveEdge True if the stream should start at the live edge; false if it should
+   *     at the beginning of the live window.
+   * @param eventHandler A handler to use when delivering events to {@code EventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   */
+  public DashChunkSource(ManifestFetcher<MediaPresentationDescription> manifestFetcher,
+      int adaptationSetIndex, int[] representationIndices, DataSource dataSource,
+      FormatEvaluator formatEvaluator, long liveEdgeLatencyMs, long elapsedRealtimeOffsetMs,
+      boolean startAtLiveEdge, Handler eventHandler, EventListener eventListener) {
+    this(manifestFetcher, manifestFetcher.getManifest(), adaptationSetIndex, representationIndices,
+        dataSource, formatEvaluator, new SystemClock(), liveEdgeLatencyMs * 1000,
+        elapsedRealtimeOffsetMs * 1000, startAtLiveEdge, eventHandler, eventListener);
   }
 
   /* package */ DashChunkSource(ManifestFetcher<MediaPresentationDescription> manifestFetcher,
       MediaPresentationDescription initialManifest, int adaptationSetIndex,
       int[] representationIndices, DataSource dataSource, FormatEvaluator formatEvaluator,
-      Clock systemClock, long liveEdgeLatencyUs, long elapsedRealtimeOffsetUs) {
+      Clock systemClock, long liveEdgeLatencyUs, long elapsedRealtimeOffsetUs,
+      boolean startAtLiveEdge, Handler eventHandler, EventListener eventListener) {
     this.manifestFetcher = manifestFetcher;
     this.currentManifest = initialManifest;
     this.adaptationSetIndex = adaptationSetIndex;
     this.representationIndices = representationIndices;
     this.dataSource = dataSource;
-    this.evaluator = formatEvaluator;
+    this.formatEvaluator = formatEvaluator;
     this.systemClock = systemClock;
     this.liveEdgeLatencyUs = liveEdgeLatencyUs;
     this.elapsedRealtimeOffsetUs = elapsedRealtimeOffsetUs;
+    this.startAtLiveEdge = startAtLiveEdge;
+    this.eventHandler = eventHandler;
+    this.eventListener = eventListener;
     this.evaluation = new Evaluation();
     this.headerBuilder = new StringBuilder();
+    this.seekRangeValues = new long[2];
 
     drmInitData = getDrmInitData(currentManifest, adaptationSetIndex);
     Representation[] representations = getFilteredRepresentations(currentManifest,
@@ -200,7 +269,7 @@ public DashChunkSource(ManifestFetcher<MediaPresentationDescription> manifestFet
     this.trackInfo = new TrackInfo(representations[0].format.mimeType, periodDurationUs);
 
     this.formats = new Format[representations.length];
-    this.representationHolders = new HashMap<String, RepresentationHolder>();
+    this.representationHolders = new HashMap<>();
     int maxWidth = 0;
     int maxHeight = 0;
     for (int i = 0; i < representations.length; i++) {
@@ -229,20 +298,37 @@ public final TrackInfo getTrackInfo() {
     return trackInfo;
   }
 
+  // VisibleForTesting
+  /* package */ TimeRange getSeekRange() {
+    return seekRange;
+  }
+
   @Override
   public void enable() {
-    evaluator.enable();
+    fatalError = null;
+    formatEvaluator.enable();
     if (manifestFetcher != null) {
       manifestFetcher.enable();
     }
+    DashSegmentIndex segmentIndex =
+        representationHolders.get(formats[0].id).representation.getIndex();
+    if (segmentIndex == null) {
+      seekRange = new TimeRange(TimeRange.TYPE_SNAPSHOT, 0, currentManifest.duration * 1000);
+      notifySeekRangeChanged(seekRange);
+    } else {
+      long nowUs = getNowUs();
+      updateAvailableSegmentBounds(segmentIndex, nowUs);
+      updateSeekRange(segmentIndex, nowUs);
+    }
   }
 
   @Override
   public void disable(List<? extends MediaChunk> queue) {
-    evaluator.disable();
+    formatEvaluator.disable();
     if (manifestFetcher != null) {
       manifestFetcher.disable();
     }
+    seekRange = null;
   }
 
   @Override
@@ -259,15 +345,35 @@ public void continueBuffering(long playbackPositionUs) {
         RepresentationHolder representationHolder =
             representationHolders.get(representation.format.id);
         DashSegmentIndex oldIndex = representationHolder.segmentIndex;
+        int oldIndexLastSegmentNum = oldIndex.getLastSegmentNum();
+        long oldIndexEndTimeUs = oldIndex.getTimeUs(oldIndexLastSegmentNum)
+            + oldIndex.getDurationUs(oldIndexLastSegmentNum);
         DashSegmentIndex newIndex = representation.getIndex();
-        int newFirstSegmentNum = newIndex.getFirstSegmentNum();
-        int segmentNumShift = oldIndex.getSegmentNum(newIndex.getTimeUs(newFirstSegmentNum))
-            - newFirstSegmentNum;
+        int newIndexFirstSegmentNum = newIndex.getFirstSegmentNum();
+        long newIndexStartTimeUs = newIndex.getTimeUs(newIndexFirstSegmentNum);
+        if (oldIndexEndTimeUs < newIndexStartTimeUs) {
+          // There's a gap between the old manifest and the new one which means we've slipped behind
+          // the live window and can't proceed.
+          fatalError = new BehindLiveWindowException();
+          return;
+        }
+        int segmentNumShift;
+        if (oldIndexEndTimeUs == newIndexStartTimeUs) {
+          // The new manifest continues where the old one ended, with no overlap.
+          segmentNumShift = oldIndex.getLastSegmentNum() + 1 - newIndexFirstSegmentNum;
+        } else {
+          // The new manifest overlaps with the old one.
+          segmentNumShift = oldIndex.getSegmentNum(newIndexStartTimeUs) - newIndexFirstSegmentNum;
+        }
         representationHolder.segmentNumShift += segmentNumShift;
         representationHolder.segmentIndex = newIndex;
       }
       currentManifest = newManifest;
       finishedCurrentManifest = false;
+
+      long nowUs = getNowUs();
+      updateAvailableSegmentBounds(newRepresentations[0].getIndex(), nowUs);
+      updateSeekRange(newRepresentations[0].getIndex(), nowUs);
     }
 
     // TODO: This is a temporary hack to avoid constantly refreshing the MPD in cases where
@@ -295,7 +401,7 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long seekP
 
     evaluation.queueSize = queue.size();
     if (evaluation.format == null || !lastChunkWasInitialization) {
-      evaluator.evaluate(queue, playbackPositionUs, formats, evaluation);
+      formatEvaluator.evaluate(queue, playbackPositionUs, formats, evaluation);
     }
     Format selectedFormat = evaluation.format;
     out.queueSize = evaluation.queueSize;
@@ -310,6 +416,9 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long seekP
       return;
     }
 
+    // In all cases where we return before instantiating a new chunk, we want out.chunk to be null.
+    out.chunk = null;
+
     RepresentationHolder representationHolder = representationHolders.get(selectedFormat.id);
     Representation selectedRepresentation = representationHolder.representation;
     DashSegmentIndex segmentIndex = representationHolder.segmentIndex;
@@ -334,36 +443,41 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long seekP
       return;
     }
 
-    long nowUs;
-    if (elapsedRealtimeOffsetUs != 0) {
-      nowUs = (systemClock.elapsedRealtime() * 1000) + elapsedRealtimeOffsetUs;
-    } else {
-      nowUs = System.currentTimeMillis() * 1000;
-    }
-
-    int firstAvailableSegmentNum = segmentIndex.getFirstSegmentNum();
-    int lastAvailableSegmentNum = segmentIndex.getLastSegmentNum();
-    boolean indexUnbounded = lastAvailableSegmentNum == DashSegmentIndex.INDEX_UNBOUNDED;
+    int segmentNum;
+    boolean indexUnbounded = segmentIndex.getLastSegmentNum() == DashSegmentIndex.INDEX_UNBOUNDED;
     if (indexUnbounded) {
-      // The index is itself unbounded. We need to use the current time to calculate the range of
-      // available segments.
-      long liveEdgeTimestampUs = nowUs - currentManifest.availabilityStartTime * 1000;
-      if (currentManifest.timeShiftBufferDepth != -1) {
-        long bufferDepthUs = currentManifest.timeShiftBufferDepth * 1000;
-        firstAvailableSegmentNum = Math.max(firstAvailableSegmentNum,
-            segmentIndex.getSegmentNum(liveEdgeTimestampUs - bufferDepthUs));
+      // Manifests with unbounded indexes aren't updated regularly, so we need to update the
+      // segment bounds before use to ensure that they are accurate to the current time; also if
+      // the bounds have changed, we should update the seek range
+      long nowUs = getNowUs();
+      int oldFirstAvailableSegmentNum = firstAvailableSegmentNum;
+      int oldLastAvailableSegmentNum = lastAvailableSegmentNum;
+      updateAvailableSegmentBounds(segmentIndex, nowUs);
+      if (oldFirstAvailableSegmentNum != firstAvailableSegmentNum
+          || oldLastAvailableSegmentNum != lastAvailableSegmentNum) {
+        updateSeekRange(segmentIndex, nowUs);
       }
-      // getSegmentNum(liveEdgeTimestampUs) will not be completed yet, so subtract one to get the
-      // index of the last completed segment.
-      lastAvailableSegmentNum = segmentIndex.getSegmentNum(liveEdgeTimestampUs) - 1;
     }
-
-    int segmentNum;
     if (queue.isEmpty()) {
       if (currentManifest.dynamic) {
-        seekPositionUs = getLiveSeekPosition(nowUs, indexUnbounded, segmentIndex.isExplicit());
+        seekRangeValues = seekRange.getCurrentBoundsUs(seekRangeValues);
+        if (startAtLiveEdge) {
+          // We want live streams to start at the live edge instead of the beginning of the
+          // manifest
+          startAtLiveEdge = false;
+          seekPositionUs = seekRangeValues[1];
+        } else {
+          seekPositionUs = Math.max(seekPositionUs, seekRangeValues[0]);
+          seekPositionUs = Math.min(seekPositionUs, seekRangeValues[1]);
+        }
       }
       segmentNum = segmentIndex.getSegmentNum(seekPositionUs);
+
+      // if the index is unbounded then the result of getSegmentNum isn't clamped to ensure that
+      // it doesn't exceed the last available segment. Clamp it here.
+      if (indexUnbounded) {
+        segmentNum = Math.min(segmentNum, lastAvailableSegmentNum);
+      }
     } else {
       MediaChunk previous = queue.get(out.queueSize - 1);
       segmentNum = previous.isLastChunk ? -1
@@ -389,7 +503,7 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long seekP
     }
 
     if (segmentNum == -1) {
-      out.chunk = null;
+      // We've reached the end of the stream.
       return;
     }
 
@@ -417,7 +531,8 @@ public void onChunkLoadCompleted(Chunk chunk) {
       if (initializationChunk.hasSeekMap()) {
         representationHolder.segmentIndex = new DashWrappingSegmentIndex(
             (ChunkIndex) initializationChunk.getSeekMap(),
-            initializationChunk.dataSpec.uri.toString());
+            initializationChunk.dataSpec.uri.toString(),
+            representationHolder.representation.periodStartMs * 1000);
       }
       // The null check avoids overwriting drmInitData obtained from the manifest with drmInitData
       // obtained from the stream, as per DASH IF Interoperability Recommendations V3.0, 7.5.3.
@@ -432,6 +547,59 @@ public void onChunkLoadError(Chunk chunk, Exception e) {
     // Do nothing.
   }
 
+  private void updateAvailableSegmentBounds(DashSegmentIndex segmentIndex, long nowUs) {
+    int indexFirstAvailableSegmentNum = segmentIndex.getFirstSegmentNum();
+    int indexLastAvailableSegmentNum = segmentIndex.getLastSegmentNum();
+    if (indexLastAvailableSegmentNum == DashSegmentIndex.INDEX_UNBOUNDED) {
+      // The index is itself unbounded. We need to use the current time to calculate the range of
+      // available segments.
+      long liveEdgeTimestampUs = nowUs - currentManifest.availabilityStartTime * 1000;
+      if (currentManifest.timeShiftBufferDepth != -1) {
+        long bufferDepthUs = currentManifest.timeShiftBufferDepth * 1000;
+        indexFirstAvailableSegmentNum = Math.max(indexFirstAvailableSegmentNum,
+            segmentIndex.getSegmentNum(liveEdgeTimestampUs - bufferDepthUs));
+      }
+      // getSegmentNum(liveEdgeTimestampUs) will not be completed yet, so subtract one to get the
+      // index of the last completed segment.
+      indexLastAvailableSegmentNum = segmentIndex.getSegmentNum(liveEdgeTimestampUs) - 1;
+    }
+    firstAvailableSegmentNum = indexFirstAvailableSegmentNum;
+    lastAvailableSegmentNum = indexLastAvailableSegmentNum;
+  }
+
+  private void updateSeekRange(DashSegmentIndex segmentIndex, long nowUs) {
+    long earliestSeekPosition = segmentIndex.getTimeUs(firstAvailableSegmentNum);
+    long latestSeekPosition = segmentIndex.getTimeUs(lastAvailableSegmentNum)
+        + segmentIndex.getDurationUs(lastAvailableSegmentNum);
+    if (currentManifest.dynamic) {
+      long liveEdgeTimestampUs;
+      if (segmentIndex.getLastSegmentNum() == DashSegmentIndex.INDEX_UNBOUNDED) {
+        liveEdgeTimestampUs = nowUs - currentManifest.availabilityStartTime * 1000;
+      } else {
+        liveEdgeTimestampUs = segmentIndex.getTimeUs(segmentIndex.getLastSegmentNum())
+            + segmentIndex.getDurationUs(segmentIndex.getLastSegmentNum());
+        if (!segmentIndex.isExplicit()) {
+          // Some segments defined by the index may not be available yet. Bound the calculated live
+          // edge based on the elapsed time since the manifest became available.
+          liveEdgeTimestampUs = Math.min(liveEdgeTimestampUs,
+              nowUs - currentManifest.availabilityStartTime * 1000);
+        }
+      }
+
+      // it's possible that the live edge latency actually puts our latest position before
+      // the earliest position in the case of a DVR-like stream that's just starting up, so
+      // in that case just return the earliest position instead
+      latestSeekPosition = Math.max(earliestSeekPosition, liveEdgeTimestampUs - liveEdgeLatencyUs);
+    }
+
+    TimeRange newSeekRange = new TimeRange(TimeRange.TYPE_SNAPSHOT, earliestSeekPosition,
+        latestSeekPosition);
+    if (seekRange == null || !seekRange.equals(newSeekRange)) {
+      seekRange = newSeekRange;
+      notifySeekRangeChanged(seekRange);
+    }
+  }
+
   private static boolean mimeTypeIsWebm(String mimeType) {
     return mimeType.startsWith(MimeTypes.VIDEO_WEBM) || mimeType.startsWith(MimeTypes.AUDIO_WEBM);
   }
@@ -471,56 +639,34 @@ private Chunk newMediaChunk(RepresentationHolder representationHolder, DataSourc
     DataSpec dataSpec = new DataSpec(segmentUri.getUri(), segmentUri.start, segmentUri.length,
         representation.getCacheKey());
 
-    long presentationTimeOffsetUs = representation.presentationTimeOffsetUs;
+    long sampleOffsetUs = representation.periodStartMs * 1000
+        - representation.presentationTimeOffsetUs;
     if (representation.format.mimeType.equals(MimeTypes.TEXT_VTT)) {
-      if (representationHolder.vttHeaderOffsetUs != presentationTimeOffsetUs) {
+      if (representationHolder.vttHeaderOffsetUs != sampleOffsetUs) {
         // Update the VTT header.
         headerBuilder.setLength(0);
-        headerBuilder.append(WebvttParser.EXO_HEADER).append("=")
-            .append(WebvttParser.OFFSET).append(presentationTimeOffsetUs).append("\n");
+        headerBuilder.append(C.WEBVTT_EXO_HEADER).append("=")
+            .append(C.WEBVTT_EXO_HEADER_OFFSET).append(sampleOffsetUs)
+            .append("\n");
         representationHolder.vttHeader = headerBuilder.toString().getBytes();
-        representationHolder.vttHeaderOffsetUs = presentationTimeOffsetUs;
+        representationHolder.vttHeaderOffsetUs = sampleOffsetUs;
       }
       return new SingleSampleMediaChunk(dataSource, dataSpec, Chunk.TRIGGER_INITIAL,
-          representation.format, startTimeUs, endTimeUs, absoluteSegmentNum, isLastSegment, null,
-          null, representationHolder.vttHeader);
+          representation.format, startTimeUs, endTimeUs, absoluteSegmentNum, isLastSegment,
+          MediaFormat.createTextFormat(MimeTypes.TEXT_VTT), null, representationHolder.vttHeader);
     } else {
       return new ContainerMediaChunk(dataSource, dataSpec, trigger, representation.format,
-          startTimeUs, endTimeUs, absoluteSegmentNum, isLastSegment, 0,
+          startTimeUs, endTimeUs, absoluteSegmentNum, isLastSegment, sampleOffsetUs,
           representationHolder.extractorWrapper, representationHolder.format, drmInitData, true);
     }
   }
 
-  /**
-   * For live playbacks, determines the seek position that snaps playback to be
-   * {@link #liveEdgeLatencyUs} behind the live edge of the current manifest
-   *
-   * @param nowUs An estimate of the current server time, in microseconds.
-   * @param indexUnbounded True if the segment index for this source is unbounded. False otherwise.
-   * @param indexExplicit True if the segment index is explicit. False otherwise.
-   * @return The seek position in microseconds.
-   */
-  private long getLiveSeekPosition(long nowUs, boolean indexUnbounded, boolean indexExplicit) {
-    long liveEdgeTimestampUs;
-    if (indexUnbounded) {
-      liveEdgeTimestampUs = nowUs - currentManifest.availabilityStartTime * 1000;
+  private long getNowUs() {
+    if (elapsedRealtimeOffsetUs != 0) {
+      return (systemClock.elapsedRealtime() * 1000) + elapsedRealtimeOffsetUs;
     } else {
-      liveEdgeTimestampUs = Long.MIN_VALUE;
-      for (RepresentationHolder representationHolder : representationHolders.values()) {
-        DashSegmentIndex segmentIndex = representationHolder.segmentIndex;
-        int lastSegmentNum = segmentIndex.getLastSegmentNum();
-        long indexLiveEdgeTimestampUs = segmentIndex.getTimeUs(lastSegmentNum)
-            + segmentIndex.getDurationUs(lastSegmentNum);
-        liveEdgeTimestampUs = Math.max(liveEdgeTimestampUs, indexLiveEdgeTimestampUs);
-      }
-      if (!indexExplicit) {
-        // Some segments defined by the index may not be available yet. Bound the calculated live
-        // edge based on the elapsed time since the manifest became available.
-        liveEdgeTimestampUs = Math.min(liveEdgeTimestampUs,
-            nowUs - currentManifest.availabilityStartTime * 1000);
-      }
+      return System.currentTimeMillis() * 1000;
     }
-    return liveEdgeTimestampUs - liveEdgeLatencyUs;
   }
 
   private static Representation[] getFilteredRepresentations(MediaPresentationDescription manifest,
@@ -567,10 +713,21 @@ private static MediaPresentationDescription buildManifest(List<Representation> r
     Period period = new Period(null, firstRepresentation.periodStartMs,
         firstRepresentation.periodDurationMs, Collections.singletonList(adaptationSet));
     long duration = firstRepresentation.periodDurationMs - firstRepresentation.periodStartMs;
-    return new MediaPresentationDescription(-1, duration, -1, false, -1, -1, null,
+    return new MediaPresentationDescription(-1, duration, -1, false, -1, -1, null, null,
         Collections.singletonList(period));
   }
 
+  private void notifySeekRangeChanged(final TimeRange seekRange) {
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable() {
+        @Override
+        public void run() {
+          eventListener.onSeekRangeChanged(seekRange);
+        }
+      });
+    }
+  }
+
   private static class RepresentationHolder {
 
     public final Representation representation;
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/DashWrappingSegmentIndex.java b/library/src/main/java/com/google/android/exoplayer/dash/DashWrappingSegmentIndex.java
index 8856b9e438..441cad6194 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/DashWrappingSegmentIndex.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/DashWrappingSegmentIndex.java
@@ -26,14 +26,17 @@
 
   private final ChunkIndex chunkIndex;
   private final String uri;
+  private final long startTimeUs;
 
   /**
    * @param chunkIndex The {@link ChunkIndex} to wrap.
    * @param uri The URI where the data is located.
+   * @param startTimeUs The start time of the index, in microseconds.
    */
-  public DashWrappingSegmentIndex(ChunkIndex chunkIndex, String uri) {
+  public DashWrappingSegmentIndex(ChunkIndex chunkIndex, String uri, long startTimeUs) {
     this.chunkIndex = chunkIndex;
     this.uri = uri;
+    this.startTimeUs = startTimeUs;
   }
 
   @Override
@@ -48,7 +51,7 @@ public int getLastSegmentNum() {
 
   @Override
   public long getTimeUs(int segmentNum) {
-    return chunkIndex.timesUs[segmentNum];
+    return chunkIndex.timesUs[segmentNum] + startTimeUs;
   }
 
   @Override
@@ -63,7 +66,7 @@ public RangedUri getSegmentUrl(int segmentNum) {
 
   @Override
   public int getSegmentNum(long timeUs) {
-    return chunkIndex.getChunkIndex(timeUs);
+    return chunkIndex.getChunkIndex(timeUs - startTimeUs);
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescription.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescription.java
index b1946645c7..f3c2cf4ae2 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescription.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescription.java
@@ -15,13 +15,15 @@
  */
 package com.google.android.exoplayer.dash.mpd;
 
+import com.google.android.exoplayer.util.ManifestFetcher.RedirectingManifest;
+
 import java.util.Collections;
 import java.util.List;
 
 /**
  * Represents a DASH media presentation description (mpd).
  */
-public class MediaPresentationDescription {
+public class MediaPresentationDescription implements RedirectingManifest {
 
   public final long availabilityStartTime;
 
@@ -35,13 +37,15 @@
 
   public final long timeShiftBufferDepth;
 
-  public final List<Period> periods;
-
   public final UtcTimingElement utcTiming;
 
+  public final String location;
+
+  public final List<Period> periods;
+
   public MediaPresentationDescription(long availabilityStartTime, long duration, long minBufferTime,
       boolean dynamic, long minUpdatePeriod, long timeShiftBufferDepth, UtcTimingElement utcTiming,
-      List<Period> periods) {
+      String location, List<Period> periods) {
     this.availabilityStartTime = availabilityStartTime;
     this.duration = duration;
     this.minBufferTime = minBufferTime;
@@ -49,7 +53,13 @@ public MediaPresentationDescription(long availabilityStartTime, long duration, l
     this.minUpdatePeriod = minUpdatePeriod;
     this.timeShiftBufferDepth = timeShiftBufferDepth;
     this.utcTiming = utcTiming;
+    this.location = location;
     this.periods = Collections.unmodifiableList(periods);
   }
 
+  @Override
+  public String getNextManifestUri() {
+    return location;
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
index e509ffeefe..0f0c8a5058 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
@@ -21,10 +21,10 @@
 import com.google.android.exoplayer.dash.mpd.SegmentBase.SegmentTemplate;
 import com.google.android.exoplayer.dash.mpd.SegmentBase.SegmentTimelineElement;
 import com.google.android.exoplayer.dash.mpd.SegmentBase.SingleSegmentBase;
+import com.google.android.exoplayer.extractor.mp4.PsshAtomUtil;
 import com.google.android.exoplayer.upstream.UriLoadable;
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.MimeTypes;
-import com.google.android.exoplayer.util.ParsableByteArray;
 import com.google.android.exoplayer.util.UriUtil;
 import com.google.android.exoplayer.util.Util;
 
@@ -53,7 +53,7 @@
 public class MediaPresentationDescriptionParser extends DefaultHandler
     implements UriLoadable.Parser<MediaPresentationDescription> {
 
-  private static final Pattern FRAME_RATE_PATTERN = Pattern.compile("(\\d+)(?:/(\\d+))??");
+  private static final Pattern FRAME_RATE_PATTERN = Pattern.compile("(\\d+)(?:/(\\d+))?");
 
   private final String contentId;
   private final XmlPullParserFactory xmlParserFactory;
@@ -111,8 +111,9 @@ protected MediaPresentationDescription parseMediaPresentationDescription(XmlPull
     long timeShiftBufferDepthMs = (dynamic) ? parseDuration(xpp, "timeShiftBufferDepth", -1)
         : -1;
     UtcTimingElement utcTiming = null;
+    String location = null;
 
-    List<Period> periods = new ArrayList<Period>();
+    List<Period> periods = new ArrayList<>();
     do {
       xpp.next();
       if (isStartTag(xpp, "BaseURL")) {
@@ -121,19 +122,21 @@ protected MediaPresentationDescription parseMediaPresentationDescription(XmlPull
         utcTiming = parseUtcTiming(xpp);
       } else if (isStartTag(xpp, "Period")) {
         periods.add(parsePeriod(xpp, baseUrl, durationMs));
+      } else if (isStartTag(xpp, "Location")) {
+        location = xpp.nextText();
       }
     } while (!isEndTag(xpp, "MPD"));
 
     return buildMediaPresentationDescription(availabilityStartTime, durationMs, minBufferTimeMs,
-        dynamic, minUpdateTimeMs, timeShiftBufferDepthMs, utcTiming, periods);
+        dynamic, minUpdateTimeMs, timeShiftBufferDepthMs, utcTiming, location, periods);
   }
 
   protected MediaPresentationDescription buildMediaPresentationDescription(
       long availabilityStartTime, long durationMs, long minBufferTimeMs, boolean dynamic,
       long minUpdateTimeMs, long timeShiftBufferDepthMs, UtcTimingElement utcTiming,
-      List<Period> periods) {
+      String location, List<Period> periods) {
     return new MediaPresentationDescription(availabilityStartTime, durationMs, minBufferTimeMs,
-        dynamic, minUpdateTimeMs, timeShiftBufferDepthMs, utcTiming, periods);
+        dynamic, minUpdateTimeMs, timeShiftBufferDepthMs, utcTiming, location, periods);
   }
 
   protected UtcTimingElement parseUtcTiming(XmlPullParser xpp) {
@@ -152,7 +155,7 @@ protected Period parsePeriod(XmlPullParser xpp, String baseUrl, long mpdDuration
     long startMs = parseDuration(xpp, "start", 0);
     long durationMs = parseDuration(xpp, "duration", mpdDurationMs);
     SegmentBase segmentBase = null;
-    List<AdaptationSet> adaptationSets = new ArrayList<AdaptationSet>();
+    List<AdaptationSet> adaptationSets = new ArrayList<>();
     do {
       xpp.next();
       if (isStartTag(xpp, "BaseURL")) {
@@ -182,13 +185,16 @@ protected Period buildPeriod(
   protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl, long periodStartMs,
       long periodDurationMs, SegmentBase segmentBase) throws XmlPullParserException, IOException {
 
+    int id = parseInt(xpp, "id", -1);
     String mimeType = xpp.getAttributeValue(null, "mimeType");
     String language = xpp.getAttributeValue(null, "lang");
-    int contentType = parseAdaptationSetTypeFromMimeType(mimeType);
+    int contentType = parseAdaptationSetType(xpp.getAttributeValue(null, "contentType"));
+    if (contentType == AdaptationSet.TYPE_UNKNOWN) {
+      contentType = parseAdaptationSetTypeFromMimeType(xpp.getAttributeValue(null, "mimeType"));
+    }
 
-    int id = -1;
     ContentProtectionsBuilder contentProtectionsBuilder = new ContentProtectionsBuilder();
-    List<Representation> representations = new ArrayList<Representation>();
+    List<Representation> representations = new ArrayList<>();
     do {
       xpp.next();
       if (isStartTag(xpp, "BaseURL")) {
@@ -196,7 +202,7 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl, lo
       } else if (isStartTag(xpp, "ContentProtection")) {
         contentProtectionsBuilder.addAdaptationSetProtection(parseContentProtection(xpp));
       } else if (isStartTag(xpp, "ContentComponent")) {
-        id = Integer.parseInt(xpp.getAttributeValue(null, "id"));
+        language = checkLanguageConsistency(language, xpp.getAttributeValue(null, "lang"));
         contentType = checkAdaptationSetTypeConsistency(contentType,
             parseAdaptationSetType(xpp.getAttributeValue(null, "contentType")));
       } else if (isStartTag(xpp, "Representation")) {
@@ -242,28 +248,6 @@ protected int parseAdaptationSetTypeFromMimeType(String mimeType) {
         : AdaptationSet.TYPE_UNKNOWN;
   }
 
-  /**
-   * Checks two adaptation set types for consistency, returning the consistent type, or throwing an
-   * {@link IllegalStateException} if the types are inconsistent.
-   * <p>
-   * Two types are consistent if they are equal, or if one is {@link AdaptationSet#TYPE_UNKNOWN}.
-   * Where one of the types is {@link AdaptationSet#TYPE_UNKNOWN}, the other is returned.
-   *
-   * @param firstType The first type.
-   * @param secondType The second type.
-   * @return The consistent type.
-   */
-  private int checkAdaptationSetTypeConsistency(int firstType, int secondType) {
-    if (firstType == AdaptationSet.TYPE_UNKNOWN) {
-      return secondType;
-    } else if (secondType == AdaptationSet.TYPE_UNKNOWN) {
-      return firstType;
-    } else {
-      Assertions.checkState(firstType == secondType);
-      return firstType;
-    }
-  }
-
   /**
    * Parses a ContentProtection element.
    *
@@ -274,22 +258,20 @@ protected ContentProtection parseContentProtection(XmlPullParser xpp)
       throws XmlPullParserException, IOException {
     String schemeIdUri = xpp.getAttributeValue(null, "schemeIdUri");
     UUID uuid = null;
-    byte[] data = null;
+    byte[] psshAtom = null;
     do {
       xpp.next();
       // The cenc:pssh element is defined in 23001-7:2015
       if (isStartTag(xpp, "cenc:pssh") && xpp.next() == XmlPullParser.TEXT) {
-        byte[] decodedData = Base64.decode(xpp.getText(), Base64.DEFAULT);
-        ParsableByteArray psshAtom = new ParsableByteArray(decodedData);
-        psshAtom.skipBytes(12);
-        uuid = new UUID(psshAtom.readLong(), psshAtom.readLong());
-        int dataSize = psshAtom.readInt();
-        data = new byte[dataSize];
-        psshAtom.readBytes(data, 0, dataSize);
+        psshAtom = Base64.decode(xpp.getText(), Base64.DEFAULT);
+        uuid = PsshAtomUtil.parseUuid(psshAtom);
+        if (uuid == null) {
+          throw new ParserException("Invalid pssh atom in cenc:pssh element");
+        }
       }
     } while (!isEndTag(xpp, "ContentProtection"));
 
-    return buildContentProtection(schemeIdUri, uuid, data);
+    return buildContentProtection(schemeIdUri, uuid, psshAtom);
   }
 
   protected ContentProtection buildContentProtection(String schemeIdUri, UUID uuid, byte[] data) {
@@ -432,7 +414,7 @@ protected SegmentList parseSegmentList(XmlPullParser xpp, String baseUrl, Segmen
         timeline = parseSegmentTimeline(xpp);
       } else if (isStartTag(xpp, "SegmentURL")) {
         if (segments == null) {
-          segments = new ArrayList<RangedUri>();
+          segments = new ArrayList<>();
         }
         segments.add(parseSegmentUrl(xpp, baseUrl));
       }
@@ -499,7 +481,7 @@ protected SegmentTemplate buildSegmentTemplate(RangedUri initialization, long ti
 
   protected List<SegmentTimelineElement> parseSegmentTimeline(XmlPullParser xpp)
       throws XmlPullParserException, IOException {
-    List<SegmentTimelineElement> segmentTimeline = new ArrayList<SegmentTimelineElement>();
+    List<SegmentTimelineElement> segmentTimeline = new ArrayList<>();
     long elapsedTime = 0;
     do {
       xpp.next();
@@ -546,7 +528,9 @@ protected RangedUri parseRangedUrl(XmlPullParser xpp, String baseUrl, String url
     if (rangeText != null) {
       String[] rangeTextArray = rangeText.split("-");
       rangeStart = Long.parseLong(rangeTextArray[0]);
-      rangeLength = Long.parseLong(rangeTextArray[1]) - rangeStart + 1;
+      if (rangeTextArray.length == 2) {
+        rangeLength = Long.parseLong(rangeTextArray[1]) - rangeStart + 1;
+      }
     }
     return buildRangedUri(baseUrl, urlText, rangeStart, rangeLength);
   }
@@ -558,6 +542,49 @@ protected RangedUri buildRangedUri(String baseUrl, String urlText, long rangeSta
 
   // Utility methods.
 
+  /**
+   * Checks two languages for consistency, returning the consistent language, or throwing an
+   * {@link IllegalStateException} if the languages are inconsistent.
+   * <p>
+   * Two languages are consistent if they are equal, or if one is null.
+   *
+   * @param firstLanguage The first language.
+   * @param secondLanguage The second language.
+   * @return The consistent language.
+   */
+  private static String checkLanguageConsistency(String firstLanguage, String secondLanguage) {
+    if (firstLanguage == null) {
+      return secondLanguage;
+    } else if (secondLanguage == null) {
+      return firstLanguage;
+    } else {
+      Assertions.checkState(firstLanguage.equals(secondLanguage));
+      return firstLanguage;
+    }
+  }
+
+  /**
+   * Checks two adaptation set types for consistency, returning the consistent type, or throwing an
+   * {@link IllegalStateException} if the types are inconsistent.
+   * <p>
+   * Two types are consistent if they are equal, or if one is {@link AdaptationSet#TYPE_UNKNOWN}.
+   * Where one of the types is {@link AdaptationSet#TYPE_UNKNOWN}, the other is returned.
+   *
+   * @param firstType The first type.
+   * @param secondType The second type.
+   * @return The consistent type.
+   */
+  private static int checkAdaptationSetTypeConsistency(int firstType, int secondType) {
+    if (firstType == AdaptationSet.TYPE_UNKNOWN) {
+      return secondType;
+    } else if (secondType == AdaptationSet.TYPE_UNKNOWN) {
+      return firstType;
+    } else {
+      Assertions.checkState(firstType == secondType);
+      return firstType;
+    }
+  }
+
   protected static boolean isEndTag(XmlPullParser xpp, String name) throws XmlPullParserException {
     return xpp.getEventType() == XmlPullParser.END_TAG && name.equals(xpp.getName());
   }
@@ -642,7 +669,7 @@ protected static String parseString(XmlPullParser xpp, String name, String defau
      */
     public void addAdaptationSetProtection(ContentProtection contentProtection) {
       if (adaptationSetProtections == null) {
-        adaptationSetProtections = new ArrayList<ContentProtection>();
+        adaptationSetProtections = new ArrayList<>();
       }
       maybeAddContentProtection(adaptationSetProtections, contentProtection);
     }
@@ -654,7 +681,7 @@ public void addAdaptationSetProtection(ContentProtection contentProtection) {
      */
     public void addRepresentationProtection(ContentProtection contentProtection) {
       if (currentRepresentationProtections == null) {
-        currentRepresentationProtections = new ArrayList<ContentProtection>();
+        currentRepresentationProtections = new ArrayList<>();
       }
       maybeAddContentProtection(currentRepresentationProtections, contentProtection);
     }
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/Representation.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/Representation.java
index d63dd77f14..f5eb289fd5 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/Representation.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/Representation.java
@@ -266,12 +266,12 @@ public RangedUri getSegmentUrl(int segmentIndex) {
 
     @Override
     public int getSegmentNum(long timeUs) {
-      return segmentBase.getSegmentNum(timeUs);
+      return segmentBase.getSegmentNum(timeUs - periodStartMs * 1000);
     }
 
     @Override
     public long getTimeUs(int segmentIndex) {
-      return segmentBase.getSegmentTimeUs(segmentIndex);
+      return segmentBase.getSegmentTimeUs(segmentIndex) + periodStartMs * 1000;
     }
 
     @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/UrlTemplate.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/UrlTemplate.java
index c055b460b2..1439ee6ec6 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/UrlTemplate.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/UrlTemplate.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer.dash.mpd;
 
+import java.util.Locale;
+
 /**
  * A template from which URLs can be built.
  * <p>
@@ -85,11 +87,11 @@ public String buildUri(String representationId, int segmentNumber, int bandwidth
       if (identifiers[i] == REPRESENTATION_ID) {
         builder.append(representationId);
       } else if (identifiers[i] == NUMBER_ID) {
-        builder.append(String.format(identifierFormatTags[i], segmentNumber));
+        builder.append(String.format(Locale.US, identifierFormatTags[i], segmentNumber));
       } else if (identifiers[i] == BANDWIDTH_ID) {
-        builder.append(String.format(identifierFormatTags[i], bandwidth));
+        builder.append(String.format(Locale.US, identifierFormatTags[i], bandwidth));
       } else if (identifiers[i] == TIME_ID) {
-        builder.append(String.format(identifierFormatTags[i], time));
+        builder.append(String.format(Locale.US, identifierFormatTags[i], time));
       }
     }
     builder.append(urlPieces[identifierCount]);
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/UtcTimingElementResolver.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/UtcTimingElementResolver.java
index c530bafe84..c275faebd7 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/UtcTimingElementResolver.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/UtcTimingElementResolver.java
@@ -124,7 +124,7 @@ private void resolveDirect() {
 
   private void resolveHttp(UriLoadable.Parser<Long> parser) {
     singleUseLoader = new Loader("utctiming");
-    singleUseLoadable = new UriLoadable<Long>(timingElement.value, uriDataSource, parser);
+    singleUseLoadable = new UriLoadable<>(timingElement.value, uriDataSource, parser);
     singleUseLoader.startLoading(singleUseLoadable, this);
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/drm/DrmInitData.java b/library/src/main/java/com/google/android/exoplayer/drm/DrmInitData.java
index ae862d0bc9..bdb4565fc3 100644
--- a/library/src/main/java/com/google/android/exoplayer/drm/DrmInitData.java
+++ b/library/src/main/java/com/google/android/exoplayer/drm/DrmInitData.java
@@ -52,7 +52,7 @@ public DrmInitData(String mimeType) {
 
     public Mapped(String mimeType) {
       super(mimeType);
-      schemeData = new HashMap<UUID, byte[]>();
+      schemeData = new HashMap<>();
     }
 
     @Override
@@ -70,15 +70,6 @@ public void put(UUID schemeUuid, byte[] data) {
       schemeData.put(schemeUuid, data);
     }
 
-    /**
-     * Inserts scheme specific initialization data.
-     *
-     * @param data A mapping from scheme UUID to initialization data.
-     */
-    public void putAll(Map<UUID, byte[]> data) {
-      schemeData.putAll(data);
-    }
-
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/drm/StreamingDrmSessionManager.java b/library/src/main/java/com/google/android/exoplayer/drm/StreamingDrmSessionManager.java
index 3187aa4788..519a2b6987 100644
--- a/library/src/main/java/com/google/android/exoplayer/drm/StreamingDrmSessionManager.java
+++ b/library/src/main/java/com/google/android/exoplayer/drm/StreamingDrmSessionManager.java
@@ -15,6 +15,9 @@
  */
 package com.google.android.exoplayer.drm;
 
+import com.google.android.exoplayer.extractor.mp4.PsshAtomUtil;
+import com.google.android.exoplayer.util.Util;
+
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.media.DeniedByServerException;
@@ -96,7 +99,7 @@
   private MediaCrypto mediaCrypto;
   private Exception lastException;
   private String mimeType;
-  private byte[] schemePsshData;
+  private byte[] schemeData;
   private byte[] sessionId;
 
   /**
@@ -110,11 +113,11 @@
    * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
-   * @throws UnsupportedSchemeException If the specified DRM scheme is not supported.
+   * @throws UnsupportedDrmException If the specified DRM scheme is not supported.
    */
   public static StreamingDrmSessionManager newWidevineInstance(Looper playbackLooper,
       MediaDrmCallback callback, HashMap<String, String> optionalKeyRequestParameters,
-      Handler eventHandler, EventListener eventListener) throws UnsupportedSchemeException {
+      Handler eventHandler, EventListener eventListener) throws UnsupportedDrmException {
     return new StreamingDrmSessionManager(WIDEVINE_UUID, playbackLooper, callback,
         optionalKeyRequestParameters, eventHandler, eventListener);
   }
@@ -132,14 +135,14 @@ public static StreamingDrmSessionManager newWidevineInstance(Looper playbackLoop
    * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
-   * @throws UnsupportedSchemeException If the specified DRM scheme is not supported.
+   * @throws UnsupportedDrmException If the specified DRM scheme is not supported.
    */
   public static StreamingDrmSessionManager newPlayReadyInstance(Looper playbackLooper,
       MediaDrmCallback callback, String customData, Handler eventHandler,
-      EventListener eventListener) throws UnsupportedSchemeException {
+      EventListener eventListener) throws UnsupportedDrmException {
     HashMap<String, String> optionalKeyRequestParameters;
     if (!TextUtils.isEmpty(customData)) {
-      optionalKeyRequestParameters = new HashMap<String, String>();
+      optionalKeyRequestParameters = new HashMap<>();
       optionalKeyRequestParameters.put(PLAYREADY_CUSTOM_DATA_KEY, customData);
     } else {
       optionalKeyRequestParameters = null;
@@ -158,17 +161,23 @@ public static StreamingDrmSessionManager newPlayReadyInstance(Looper playbackLoo
    * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
-   * @throws UnsupportedSchemeException If the specified DRM scheme is not supported.
+   * @throws UnsupportedDrmException If the specified DRM scheme is not supported.
    */
   public StreamingDrmSessionManager(UUID uuid, Looper playbackLooper, MediaDrmCallback callback,
       HashMap<String, String> optionalKeyRequestParameters, Handler eventHandler,
-      EventListener eventListener) throws UnsupportedSchemeException {
+      EventListener eventListener) throws UnsupportedDrmException {
     this.uuid = uuid;
     this.callback = callback;
     this.optionalKeyRequestParameters = optionalKeyRequestParameters;
     this.eventHandler = eventHandler;
     this.eventListener = eventListener;
-    mediaDrm = new MediaDrm(uuid);
+    try {
+      mediaDrm = new MediaDrm(uuid);
+    } catch (UnsupportedSchemeException e) {
+      throw new UnsupportedDrmException(UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME, e);
+    } catch (Exception e) {
+      throw new UnsupportedDrmException(UnsupportedDrmException.REASON_INSTANTIATION_ERROR, e);
+    }
     mediaDrm.setOnEventListener(new MediaDrmEventListener());
     mediaDrmHandler = new MediaDrmHandler(playbackLooper);
     postResponseHandler = new PostResponseHandler(playbackLooper);
@@ -176,12 +185,12 @@ public StreamingDrmSessionManager(UUID uuid, Looper playbackLooper, MediaDrmCall
   }
 
   @Override
-  public int getState() {
+  public final int getState() {
     return state;
   }
 
   @Override
-  public MediaCrypto getMediaCrypto() {
+  public final MediaCrypto getMediaCrypto() {
     if (state != STATE_OPENED && state != STATE_OPENED_WITH_KEYS) {
       throw new IllegalStateException();
     }
@@ -197,7 +206,7 @@ public boolean requiresSecureDecoderComponent(String mimeType) {
   }
 
   @Override
-  public Exception getError() {
+  public final Exception getError() {
     return state == STATE_ERROR ? lastException : null;
   }
 
@@ -217,7 +226,7 @@ public final String getPropertyString(String key) {
    * Provides access to {@link MediaDrm#setPropertyString(String, String)}.
    * <p>
    * This method may be called when the manager is in any state.
-   * 
+   *
    * @param key The property to write.
    * @param value The value to write.
    */
@@ -250,7 +259,7 @@ public final void setPropertyByteArray(String key, byte[] value) {
   }
 
   @Override
-  public void open(DrmInitData drmInitData) {
+  public final void open(DrmInitData drmInitData) {
     if (++openCount != 1) {
       return;
     }
@@ -259,20 +268,29 @@ public void open(DrmInitData drmInitData) {
       requestHandlerThread.start();
       postRequestHandler = new PostRequestHandler(requestHandlerThread.getLooper());
     }
-    if (this.schemePsshData == null) {
+    if (schemeData == null) {
       mimeType = drmInitData.mimeType;
-      schemePsshData = drmInitData.get(uuid);
-      if (schemePsshData == null) {
+      schemeData = drmInitData.get(uuid);
+      if (schemeData == null) {
         onError(new IllegalStateException("Media does not support uuid: " + uuid));
         return;
       }
+      if (Util.SDK_INT < 21) {
+        // Prior to L the Widevine CDM required data to be extracted from the PSSH atom.
+        byte[] psshData = PsshAtomUtil.parseSchemeSpecificData(schemeData, WIDEVINE_UUID);
+        if (psshData == null) {
+          // Extraction failed. schemeData isn't a Widevine PSSH atom, so leave it unchanged.
+        } else {
+          schemeData = psshData;
+        }
+      }
     }
     state = STATE_OPENING;
     openInternal(true);
   }
 
   @Override
-  public void close() {
+  public final void close() {
     if (--openCount != 0) {
       return;
     }
@@ -284,7 +302,7 @@ public void close() {
     postRequestHandler = null;
     requestHandlerThread.quit();
     requestHandlerThread = null;
-    schemePsshData = null;
+    schemeData = null;
     mediaCrypto = null;
     lastException = null;
     if (sessionId != null) {
@@ -346,7 +364,7 @@ private void onProvisionResponse(Object response) {
   private void postKeyRequest() {
     KeyRequest keyRequest;
     try {
-      keyRequest = mediaDrm.getKeyRequest(sessionId, schemePsshData, mimeType,
+      keyRequest = mediaDrm.getKeyRequest(sessionId, schemeData, mimeType,
           MediaDrm.KEY_TYPE_STREAMING, optionalKeyRequestParameters);
       postRequestHandler.obtainMessage(MSG_KEYS, keyRequest).sendToTarget();
     } catch (NotProvisionedException e) {
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/UnsupportedDrmException.java b/library/src/main/java/com/google/android/exoplayer/drm/UnsupportedDrmException.java
similarity index 70%
rename from demo/src/main/java/com/google/android/exoplayer/demo/player/UnsupportedDrmException.java
rename to library/src/main/java/com/google/android/exoplayer/drm/UnsupportedDrmException.java
index e71e1b04d3..b5f2d12211 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/UnsupportedDrmException.java
+++ b/library/src/main/java/com/google/android/exoplayer/drm/UnsupportedDrmException.java
@@ -13,16 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.demo.player;
+package com.google.android.exoplayer.drm;
 
 /**
- * Exception thrown when the required level of DRM is not supported.
+ * Thrown when the requested DRM scheme is not supported.
  */
 public final class UnsupportedDrmException extends Exception {
 
-  public static final int REASON_NO_DRM = 0;
+  /**
+   * The requested DRM scheme is unsupported by the device.
+   */
   public static final int REASON_UNSUPPORTED_SCHEME = 1;
-  public static final int REASON_UNKNOWN = 2;
+  /**
+   * There device advertises support for the requested DRM scheme, but there was an error
+   * instantiating it. The cause can be retrieved using {@link #getCause()}.
+   */
+  public static final int REASON_INSTANTIATION_ERROR = 2;
 
   public final int reason;
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/Extractor.java
index c38a62a688..9b803a9e34 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/Extractor.java
@@ -52,9 +52,10 @@
   /**
    * Extracts data read from a provided {@link ExtractorInput}.
    * <p>
-   * Each read will extract at most one sample from the stream before returning.
+   * A single call to this method will block until some progress has been made, but will not block
+   * for longer than this. Hence each call will consume only a small amount of input data.
    * <p>
-   * In the common case, {@link #RESULT_CONTINUE} is returned to indicate that
+   * In the common case, {@link #RESULT_CONTINUE} is returned to indicate that the
    * {@link ExtractorInput} passed to the next read is required to provide data continuing from the
    * position in the stream reached by the returning call. If the extractor requires data to be
    * provided from a different position, then that position is set in {@code seekPosition} and
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
index b84401eb76..37e2ccba18 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
@@ -20,6 +20,7 @@
 import com.google.android.exoplayer.MediaFormatHolder;
 import com.google.android.exoplayer.SampleHolder;
 import com.google.android.exoplayer.SampleSource;
+import com.google.android.exoplayer.SampleSource.SampleSourceReader;
 import com.google.android.exoplayer.TrackInfo;
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.drm.DrmInitData;
@@ -40,7 +41,8 @@
 /**
  * A {@link SampleSource} that extracts sample data using an {@link Extractor}
  */
-public class ExtractorSampleSource implements SampleSource, ExtractorOutput, Loader.Callback {
+public class ExtractorSampleSource implements SampleSource, SampleSourceReader, ExtractorOutput,
+    Loader.Callback {
 
   /**
    * The default minimum number of times to retry loading prior to failing for on-demand streams.
@@ -52,12 +54,11 @@
    */
   public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT_LIVE = 6;
 
-  private static final int BUFFER_FRAGMENT_LENGTH = 256 * 1024;
   private static final int MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA = -1;
   private static final int NO_RESET_PENDING = -1;
 
   private final Extractor extractor;
-  private final DefaultAllocator allocator;
+  private final Allocator allocator;
   private final int requestedBufferSize;
   private final SparseArray<InternalTrackOutput> sampleQueues;
   private final int minLoadableRetryCount;
@@ -89,7 +90,6 @@
   private Loader loader;
   private ExtractingLoadable loadable;
   private IOException currentLoadableException;
-  private boolean currentLoadableExceptionFatal;
   // TODO: Set this back to 0 in the correct place (some place indicative of making progress).
   private int currentLoadableExceptionCount;
   private long currentLoadableExceptionTimestamp;
@@ -102,13 +102,26 @@
    * @param uri The {@link Uri} of the media stream.
    * @param dataSource A data source to read the media stream.
    * @param extractor An {@link Extractor} to extract the media stream.
-   * @param downstreamRendererCount Number of track renderers dependent on this sample source.
    * @param requestedBufferSize The requested total buffer size for storing sample data, in bytes.
    *     The actual allocated size may exceed the value passed in if the implementation requires it.
    */
+  @Deprecated
   public ExtractorSampleSource(Uri uri, DataSource dataSource, Extractor extractor,
-      int downstreamRendererCount, int requestedBufferSize) {
-    this(uri, dataSource, extractor, downstreamRendererCount, requestedBufferSize,
+      int requestedBufferSize) {
+    this(uri, dataSource, extractor, new DefaultAllocator(64 * 1024), requestedBufferSize);
+  }
+
+  /**
+   * @param uri The {@link Uri} of the media stream.
+   * @param dataSource A data source to read the media stream.
+   * @param extractor An {@link Extractor} to extract the media stream.
+   * @param allocator An {@link Allocator} from which to obtain memory allocations.
+   * @param requestedBufferSize The requested total buffer size for storing sample data, in bytes.
+   *     The actual allocated size may exceed the value passed in if the implementation requires it.
+   */
+  public ExtractorSampleSource(Uri uri, DataSource dataSource, Extractor extractor,
+      Allocator allocator, int requestedBufferSize) {
+    this(uri, dataSource, extractor, allocator, requestedBufferSize,
         MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA);
   }
 
@@ -116,27 +129,48 @@ public ExtractorSampleSource(Uri uri, DataSource dataSource, Extractor extractor
    * @param uri The {@link Uri} of the media stream.
    * @param dataSource A data source to read the media stream.
    * @param extractor An {@link Extractor} to extract the media stream.
-   * @param downstreamRendererCount Number of track renderers dependent on this sample source.
+   * @param requestedBufferSize The requested total buffer size for storing sample data, in bytes.
+   *     The actual allocated size may exceed the value passed in if the implementation requires it.
+   * @param minLoadableRetryCount The minimum number of times that the sample source will retry
+   *     if a loading error occurs.
+   */
+  @Deprecated
+  public ExtractorSampleSource(Uri uri, DataSource dataSource, Extractor extractor,
+      int requestedBufferSize, int minLoadableRetryCount) {
+    this(uri, dataSource, extractor, new DefaultAllocator(64 * 1024), requestedBufferSize,
+        minLoadableRetryCount);
+  }
+
+  /**
+   * @param uri The {@link Uri} of the media stream.
+   * @param dataSource A data source to read the media stream.
+   * @param extractor An {@link Extractor} to extract the media stream.
+   * @param allocator An {@link Allocator} from which to obtain memory allocations.
    * @param requestedBufferSize The requested total buffer size for storing sample data, in bytes.
    *     The actual allocated size may exceed the value passed in if the implementation requires it.
    * @param minLoadableRetryCount The minimum number of times that the sample source will retry
    *     if a loading error occurs.
    */
   public ExtractorSampleSource(Uri uri, DataSource dataSource, Extractor extractor,
-      int downstreamRendererCount, int requestedBufferSize, int minLoadableRetryCount) {
+      Allocator allocator, int requestedBufferSize, int minLoadableRetryCount) {
     this.uri = uri;
     this.dataSource = dataSource;
     this.extractor = extractor;
-    this.remainingReleaseCount = downstreamRendererCount;
+    this.allocator = allocator;
     this.requestedBufferSize = requestedBufferSize;
     this.minLoadableRetryCount = minLoadableRetryCount;
-    sampleQueues = new SparseArray<InternalTrackOutput>();
-    allocator = new DefaultAllocator(BUFFER_FRAGMENT_LENGTH);
+    sampleQueues = new SparseArray<>();
     pendingResetPositionUs = NO_RESET_PENDING;
     frameAccurateSeeking = true;
     extractor.init(this);
   }
 
+  @Override
+  public SampleSourceReader register() {
+    remainingReleaseCount++;
+    return this;
+  }
+
   @Override
   public boolean prepare(long positionUs) throws IOException {
     if (prepared) {
@@ -146,11 +180,8 @@ public boolean prepare(long positionUs) throws IOException {
       loader = new Loader("Loader:ExtractorSampleSource");
     }
 
-    continueBufferingInternal();
+    maybeStartLoading();
 
-    // TODO: Support non-seekable content? Or at least avoid getting stuck here if a seekMap doesn't
-    // arrive (we may end up filling the sample buffers whilst we're still not prepared, and then
-    // getting stuck).
     if (seekMap != null && tracksBuilt && haveFormatsForAllTracks()) {
       int trackCount = sampleQueues.size();
       trackEnabledStates = new boolean[trackCount];
@@ -194,6 +225,7 @@ public void enable(int track, long positionUs) {
     if (enabledTrackCount == 1) {
       seekToUs(positionUs);
     }
+    pendingDiscontinuities[track] = false;
   }
 
   @Override
@@ -202,8 +234,8 @@ public void disable(int track) {
     Assertions.checkState(trackEnabledStates[track]);
     enabledTrackCount--;
     trackEnabledStates[track] = false;
-    pendingDiscontinuities[track] = false;
     if (enabledTrackCount == 0) {
+      downstreamPositionUs = Long.MIN_VALUE;
       if (loader.isLoading()) {
         loader.cancelLoading();
       } else {
@@ -214,12 +246,23 @@ public void disable(int track) {
   }
 
   @Override
-  public boolean continueBuffering(long playbackPositionUs) throws IOException {
+  public boolean continueBuffering(int track, long playbackPositionUs) throws IOException {
     Assertions.checkState(prepared);
-    Assertions.checkState(enabledTrackCount > 0);
+    Assertions.checkState(trackEnabledStates[track]);
     downstreamPositionUs = playbackPositionUs;
     discardSamplesForDisabledTracks(downstreamPositionUs);
-    return loadingFinished || continueBufferingInternal();
+    if (loadingFinished) {
+      return true;
+    }
+    maybeStartLoading();
+    if (isPendingReset()) {
+      return false;
+    }
+    if (sampleQueues.valueAt(track).isEmpty()) {
+      maybeThrowLoadableException();
+      return false;
+    }
+    return true;
   }
 
   @Override
@@ -274,13 +317,13 @@ public void seekToUs(long positionUs) {
       positionUs = 0;
     }
 
+    long currentPositionUs = isPendingReset() ? pendingResetPositionUs : downstreamPositionUs;
+    downstreamPositionUs = positionUs;
     lastSeekPositionUs = positionUs;
-    if ((isPendingReset() ? pendingResetPositionUs : downstreamPositionUs) == positionUs) {
+    if (currentPositionUs == positionUs) {
       return;
     }
 
-    downstreamPositionUs = positionUs;
-
     // If we're not pending a reset, see if we can seek within the sample queues.
     boolean seekInsideBuffer = !isPendingReset();
     for (int i = 0; seekInsideBuffer && i < sampleQueues.size(); i++) {
@@ -379,18 +422,6 @@ public void drmInitData(DrmInitData drmInitData) {
 
   // Internal stuff.
 
-  private boolean continueBufferingInternal() throws IOException {
-    maybeStartLoading();
-    if (isPendingReset()) {
-      return false;
-    }
-    boolean haveSamples = prepared && haveSampleForOneEnabledTrack();
-    if (!haveSamples) {
-      maybeThrowLoadableException();
-    }
-    return haveSamples;
-  }
-
   private void restartFrom(long positionUs) {
     pendingResetPositionUs = positionUs;
     loadingFinished = false;
@@ -403,7 +434,7 @@ private void restartFrom(long positionUs) {
   }
 
   private void maybeStartLoading() {
-    if (currentLoadableExceptionFatal || loadingFinished || loader.isLoading()) {
+    if (loadingFinished || loader.isLoading()) {
       return;
     }
 
@@ -469,9 +500,6 @@ private void maybeThrowLoadableException() throws IOException {
     if (currentLoadableException == null) {
       return;
     }
-    if (currentLoadableExceptionFatal) {
-      throw currentLoadableException;
-    }
     int minLoadableRetryCountForMedia;
     if (minLoadableRetryCount != MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA) {
       minLoadableRetryCountForMedia = minLoadableRetryCount;
@@ -503,15 +531,6 @@ private boolean haveFormatsForAllTracks() {
     return true;
   }
 
-  private boolean haveSampleForOneEnabledTrack() {
-    for (int i = 0; i < trackEnabledStates.length; i++) {
-      if (trackEnabledStates[i] && !sampleQueues.valueAt(i).isEmpty()) {
-        return true;
-      }
-    }
-    return false;
-  }
-
   private void discardSamplesForDisabledTracks(long timeUs) {
     for (int i = 0; i < trackEnabledStates.length; i++) {
       if (!trackEnabledStates[i]) {
@@ -527,7 +546,6 @@ private void clearState() {
     loadable = null;
     currentLoadableException = null;
     currentLoadableExceptionCount = 0;
-    currentLoadableExceptionFatal = false;
   }
 
   private boolean isPendingReset() {
@@ -564,7 +582,7 @@ public void sampleMetadata(long timeUs, int flags, int size, int offset, byte[]
     private final Uri uri;
     private final DataSource dataSource;
     private final Extractor extractor;
-    private final DefaultAllocator allocator;
+    private final Allocator allocator;
     private final int requestedBufferSize;
     private final PositionHolder positionHolder;
 
@@ -573,7 +591,7 @@ public void sampleMetadata(long timeUs, int flags, int size, int offset, byte[]
     private boolean pendingExtractorSeek;
 
     public ExtractingLoadable(Uri uri, DataSource dataSource, Extractor extractor,
-        DefaultAllocator allocator, int requestedBufferSize, long position) {
+        Allocator allocator, int requestedBufferSize, long position) {
       this.uri = Assertions.checkNotNull(uri);
       this.dataSource = Assertions.checkNotNull(dataSource);
       this.extractor = Assertions.checkNotNull(extractor);
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java b/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java
index a2926d275e..4cc229d847 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java
@@ -57,7 +57,7 @@ public RollingSampleBuffer(Allocator allocator) {
     this.allocator = allocator;
     allocationLength = allocator.getIndividualAllocationLength();
     infoQueue = new InfoQueue();
-    dataQueue = new LinkedBlockingDeque<Allocation>();
+    dataQueue = new LinkedBlockingDeque<>();
     extrasHolder = new SampleExtrasHolder();
     scratch = new ParsableByteArray(INITIAL_SCRATCH_SIZE);
     lastAllocationOffset = allocationLength;
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
index 0b82bede91..fc9ee215cb 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
@@ -24,13 +24,12 @@
 import com.google.android.exoplayer.extractor.PositionHolder;
 import com.google.android.exoplayer.extractor.SeekMap;
 import com.google.android.exoplayer.extractor.TrackOutput;
-import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.MpegAudioHeader;
 import com.google.android.exoplayer.util.ParsableByteArray;
 import com.google.android.exoplayer.util.Util;
 
 import java.io.EOFException;
 import java.io.IOException;
-import java.util.Collections;
 
 /**
  * Extracts data from an MP3 file.
@@ -43,20 +42,10 @@
   /** Mask that includes the audio header values that must match between frames. */
   private static final int HEADER_MASK = 0xFFFE0C00;
   private static final int ID3_TAG = Util.getIntegerCodeForString("ID3");
-  private static final String[] MIME_TYPE_BY_LAYER =
-      new String[] {MimeTypes.AUDIO_MPEG_L1, MimeTypes.AUDIO_MPEG_L2, MimeTypes.AUDIO_MPEG};
   private static final int XING_HEADER = Util.getIntegerCodeForString("Xing");
   private static final int INFO_HEADER = Util.getIntegerCodeForString("Info");
   private static final int VBRI_HEADER = Util.getIntegerCodeForString("VBRI");
 
-  /**
-   * Theoretical maximum frame size for an MPEG audio stream, which occurs when playing a Layer 2
-   * MPEG 2.5 audio stream at 16 kb/s (with padding). The size is 1152 sample/frame *
-   * 160000 bit/s / (8000 sample/s * 8 bit/byte) + 1 padding byte/frame = 2881 byte/frame.
-   * The next power of two size is 4 KiB.
-   */
-  private static final int MAX_FRAME_SIZE_BYTES = 4096;
-
   private final BufferingInput inputBuffer;
   private final ParsableByteArray scratch;
   private final MpegAudioHeader synchronizedHeader;
@@ -74,7 +63,7 @@
 
   /** Constructs a new {@link Mp3Extractor}. */
   public Mp3Extractor() {
-    inputBuffer = new BufferingInput(MAX_FRAME_SIZE_BYTES * 3);
+    inputBuffer = new BufferingInput(MpegAudioHeader.MAX_FRAME_SIZE_BYTES * 3);
     scratch = new ParsableByteArray(4);
     synchronizedHeader = new MpegAudioHeader();
   }
@@ -255,10 +244,9 @@ private long synchronize(ExtractorInput extractorInput) throws IOException, Inte
     if (seeker == null) {
       setupSeeker(extractorInput, headerPosition);
       extractorOutput.seekMap(seeker);
-      trackOutput.format(MediaFormat.createAudioFormat(
-          MIME_TYPE_BY_LAYER[synchronizedHeader.layerIndex], MAX_FRAME_SIZE_BYTES,
-          seeker.getDurationUs(), synchronizedHeader.channels, synchronizedHeader.sampleRate,
-          Collections.<byte[]>emptyList()));
+      trackOutput.format(MediaFormat.createAudioFormat(synchronizedHeader.mimeType,
+          MpegAudioHeader.MAX_FRAME_SIZE_BYTES, seeker.getDurationUs(), synchronizedHeader.channels,
+          synchronizedHeader.sampleRate, null));
     }
 
     return headerPosition;
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/VbriSeeker.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/VbriSeeker.java
index 9d096607cb..49cb846cd7 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/VbriSeeker.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/VbriSeeker.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer.extractor.mp3;
 
+import com.google.android.exoplayer.util.MpegAudioHeader;
 import com.google.android.exoplayer.util.ParsableByteArray;
 import com.google.android.exoplayer.util.Util;
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/XingSeeker.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/XingSeeker.java
index 7ddb006705..fd02971a96 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/XingSeeker.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/XingSeeker.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer.extractor.mp3;
 
 import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.util.MpegAudioHeader;
 import com.google.android.exoplayer.util.ParsableByteArray;
 import com.google.android.exoplayer.util.Util;
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
index e87f71f885..3a4a114a82 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
@@ -39,7 +39,8 @@
   public static final int TYPE_ftyp = Util.getIntegerCodeForString("ftyp");
   public static final int TYPE_avc1 = Util.getIntegerCodeForString("avc1");
   public static final int TYPE_avc3 = Util.getIntegerCodeForString("avc3");
-  public static final int TYPE_esds = Util.getIntegerCodeForString("esds");
+  public static final int TYPE_hvc1 = Util.getIntegerCodeForString("hvc1");
+  public static final int TYPE_hev1 = Util.getIntegerCodeForString("hev1");
   public static final int TYPE_mdat = Util.getIntegerCodeForString("mdat");
   public static final int TYPE_mp4a = Util.getIntegerCodeForString("mp4a");
   public static final int TYPE_ac_3 = Util.getIntegerCodeForString("ac-3");
@@ -58,6 +59,8 @@
   public static final int TYPE_minf = Util.getIntegerCodeForString("minf");
   public static final int TYPE_stbl = Util.getIntegerCodeForString("stbl");
   public static final int TYPE_avcC = Util.getIntegerCodeForString("avcC");
+  public static final int TYPE_hvcC = Util.getIntegerCodeForString("hvcC");
+  public static final int TYPE_esds = Util.getIntegerCodeForString("esds");
   public static final int TYPE_moof = Util.getIntegerCodeForString("moof");
   public static final int TYPE_traf = Util.getIntegerCodeForString("traf");
   public static final int TYPE_mvex = Util.getIntegerCodeForString("mvex");
@@ -88,6 +91,7 @@
   public static final int TYPE_stsz = Util.getIntegerCodeForString("stsz");
   public static final int TYPE_stco = Util.getIntegerCodeForString("stco");
   public static final int TYPE_co64 = Util.getIntegerCodeForString("co64");
+  public static final int TYPE_tx3g = Util.getIntegerCodeForString("tx3g");
 
   public final int type;
 
@@ -122,8 +126,8 @@ public LeafAtom(int type, ParsableByteArray data) {
     public ContainerAtom(int type, long endByteOffset) {
       super(type);
 
-      leafChildren = new ArrayList<LeafAtom>();
-      containerChildren = new ArrayList<ContainerAtom>();
+      leafChildren = new ArrayList<>();
+      containerChildren = new ArrayList<>();
       this.endByteOffset = endByteOffset;
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
index 42c3f2e70e..37ed98d3cc 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
@@ -20,8 +20,8 @@
 import com.google.android.exoplayer.util.Ac3Util;
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.CodecSpecificDataUtil;
-import com.google.android.exoplayer.util.H264Util;
 import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.NalUnitUtil;
 import com.google.android.exoplayer.util.ParsableByteArray;
 import com.google.android.exoplayer.util.Util;
 
@@ -64,8 +64,9 @@ public static Track parseTrak(Atom.ContainerAtom trak, Atom.LeafAtom mvhd) {
 
     long mediaTimescale = parseMdhd(mdia.getLeafAtomOfType(Atom.TYPE_mdhd).data);
     StsdDataHolder stsdData = parseStsd(stbl.getLeafAtomOfType(Atom.TYPE_stsd).data, durationUs);
-    return new Track(id, trackType, mediaTimescale, durationUs, stsdData.mediaFormat,
-        stsdData.trackEncryptionBoxes, stsdData.nalUnitLengthFieldLength);
+    return stsdData.mediaFormat == null ? null
+        : new Track(id, trackType, mediaTimescale, durationUs, stsdData.mediaFormat,
+            stsdData.trackEncryptionBoxes, stsdData.nalUnitLengthFieldLength);
   }
 
   /**
@@ -102,10 +103,13 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
     int fixedSampleSize = stsz.readUnsignedIntToInt();
     int sampleCount = stsz.readUnsignedIntToInt();
 
+    long[] offsets = new long[sampleCount];
     int[] sizes = new int[sampleCount];
     long[] timestamps = new long[sampleCount];
-    long[] offsets = new long[sampleCount];
     int[] flags = new int[sampleCount];
+    if (sampleCount == 0) {
+      return new TrackSampleTable(offsets, sizes, timestamps, flags);
+    }
 
     // Prepare to read chunk offsets.
     chunkOffsets.setPosition(Atom.FULL_HEADER_SIZE);
@@ -331,25 +335,24 @@ private static StsdDataHolder parseStsd(ParsableByteArray stsd, long durationUs)
       Assertions.checkArgument(childAtomSize > 0, "childAtomSize should be positive");
       int childAtomType = stsd.readInt();
       if (childAtomType == Atom.TYPE_avc1 || childAtomType == Atom.TYPE_avc3
-          || childAtomType == Atom.TYPE_encv) {
-        parseAvcFromParent(stsd, childStartPosition, childAtomSize, durationUs, holder, i);
+          || childAtomType == Atom.TYPE_encv || childAtomType == Atom.TYPE_mp4v
+          || childAtomType == Atom.TYPE_hvc1 || childAtomType == Atom.TYPE_hev1) {
+        parseVideoSampleEntry(stsd, childStartPosition, childAtomSize, durationUs, holder, i);
       } else if (childAtomType == Atom.TYPE_mp4a || childAtomType == Atom.TYPE_enca
           || childAtomType == Atom.TYPE_ac_3) {
         parseAudioSampleEntry(stsd, childAtomType, childStartPosition, childAtomSize, durationUs,
             holder, i);
       } else if (childAtomType == Atom.TYPE_TTML) {
-        holder.mediaFormat = MediaFormat.createTtmlFormat();
-      } else if (childAtomType == Atom.TYPE_mp4v) {
-        holder.mediaFormat = parseMp4vFromParent(stsd, childStartPosition, childAtomSize,
-            durationUs);
+        holder.mediaFormat = MediaFormat.createTextFormat(MimeTypes.APPLICATION_TTML);
+      } else if (childAtomType == Atom.TYPE_tx3g) {
+        holder.mediaFormat = MediaFormat.createTextFormat(MimeTypes.APPLICATION_TX3G);
       }
       stsd.setPosition(childStartPosition + childAtomSize);
     }
     return holder;
   }
 
-  /** Returns the media format for an avc1 box. */
-  private static void parseAvcFromParent(ParsableByteArray parent, int position, int size,
+  private static void parseVideoSampleEntry(ParsableByteArray parent, int position, int size,
       long durationUs, StsdDataHolder out, int entryIndex) {
     parent.setPosition(position + Atom.HEADER_SIZE);
 
@@ -361,6 +364,7 @@ private static void parseAvcFromParent(ParsableByteArray parent, int position, i
 
     List<byte[]> initializationData = null;
     int childPosition = parent.getPosition();
+    String mimeType = null;
     while (childPosition - position < size) {
       parent.setPosition(childPosition);
       int childStartPosition = parent.getPosition();
@@ -372,9 +376,23 @@ private static void parseAvcFromParent(ParsableByteArray parent, int position, i
       Assertions.checkArgument(childAtomSize > 0, "childAtomSize should be positive");
       int childAtomType = parent.readInt();
       if (childAtomType == Atom.TYPE_avcC) {
+        Assertions.checkState(mimeType == null);
+        mimeType = MimeTypes.VIDEO_H264;
         Pair<List<byte[]>, Integer> avcCData = parseAvcCFromParent(parent, childStartPosition);
         initializationData = avcCData.first;
         out.nalUnitLengthFieldLength = avcCData.second;
+      } else if (childAtomType == Atom.TYPE_hvcC) {
+        Assertions.checkState(mimeType == null);
+        mimeType = MimeTypes.VIDEO_H265;
+        Pair<List<byte[]>, Integer> hvcCData = parseHvcCFromParent(parent, childStartPosition);
+        initializationData = hvcCData.first;
+        out.nalUnitLengthFieldLength = hvcCData.second;
+      } else if (childAtomType == Atom.TYPE_esds) {
+        Assertions.checkState(mimeType == null);
+        Pair<String, byte[]> mimeTypeAndInitializationData =
+            parseEsdsFromParent(parent, childStartPosition);
+        mimeType = mimeTypeAndInitializationData.first;
+        initializationData = Collections.singletonList(mimeTypeAndInitializationData.second);
       } else if (childAtomType == Atom.TYPE_sinf) {
         out.trackEncryptionBoxes[entryIndex] =
             parseSinfFromParent(parent, childStartPosition, childAtomSize);
@@ -384,8 +402,13 @@ private static void parseAvcFromParent(ParsableByteArray parent, int position, i
       childPosition += childAtomSize;
     }
 
-    out.mediaFormat = MediaFormat.createVideoFormat(MimeTypes.VIDEO_H264, MediaFormat.NO_VALUE,
-        durationUs, width, height, pixelWidthHeightRatio, initializationData);
+    // If the media type was not recognized, ignore the track.
+    if (mimeType == null) {
+      return;
+    }
+
+    out.mediaFormat = MediaFormat.createVideoFormat(mimeType, MediaFormat.NO_VALUE, durationUs,
+        width, height, pixelWidthHeightRatio, initializationData);
   }
 
   private static Pair<List<byte[]>, Integer> parseAvcCFromParent(ParsableByteArray parent,
@@ -396,20 +419,62 @@ private static void parseAvcFromParent(ParsableByteArray parent, int position, i
     if (nalUnitLengthFieldLength == 3) {
       throw new IllegalStateException();
     }
-    List<byte[]> initializationData = new ArrayList<byte[]>();
+    List<byte[]> initializationData = new ArrayList<>();
     // TODO: We should try and parse these using CodecSpecificDataUtil.parseSpsNalUnit, and
     // expose the AVC profile and level somewhere useful; Most likely in MediaFormat.
     int numSequenceParameterSets = parent.readUnsignedByte() & 0x1F;
     for (int j = 0; j < numSequenceParameterSets; j++) {
-      initializationData.add(H264Util.parseChildNalUnit(parent));
+      initializationData.add(NalUnitUtil.parseChildNalUnit(parent));
     }
     int numPictureParameterSets = parent.readUnsignedByte();
     for (int j = 0; j < numPictureParameterSets; j++) {
-      initializationData.add(H264Util.parseChildNalUnit(parent));
+      initializationData.add(NalUnitUtil.parseChildNalUnit(parent));
     }
     return Pair.create(initializationData, nalUnitLengthFieldLength);
   }
 
+  private static Pair<List<byte[]>, Integer> parseHvcCFromParent(ParsableByteArray parent,
+      int position) {
+    // Skip to the NAL unit length size field.
+    parent.setPosition(position + Atom.HEADER_SIZE + 21);
+    int lengthSizeMinusOne = parent.readUnsignedByte() & 0x03;
+
+    // Calculate the combined size of all VPS/SPS/PPS bitstreams.
+    int numberOfArrays = parent.readUnsignedByte();
+    int csdLength = 0;
+    int csdStartPosition = parent.getPosition();
+    for (int i = 0; i < numberOfArrays; i++) {
+      parent.skipBytes(1); // completeness (1), nal_unit_type (7)
+      int numberOfNalUnits = parent.readUnsignedShort();
+      for (int j = 0; j < numberOfNalUnits; j++) {
+        int nalUnitLength = parent.readUnsignedShort();
+        csdLength += 4 + nalUnitLength; // Start code and NAL unit.
+        parent.skipBytes(nalUnitLength);
+      }
+    }
+
+    // Concatenate the codec-specific data into a single buffer.
+    parent.setPosition(csdStartPosition);
+    byte[] buffer = new byte[csdLength];
+    int bufferPosition = 0;
+    for (int i = 0; i < numberOfArrays; i++) {
+      parent.skipBytes(1); // completeness (1), nal_unit_type (7)
+      int numberOfNalUnits = parent.readUnsignedShort();
+      for (int j = 0; j < numberOfNalUnits; j++) {
+        int nalUnitLength = parent.readUnsignedShort();
+        System.arraycopy(NalUnitUtil.NAL_START_CODE, 0, buffer, bufferPosition,
+            NalUnitUtil.NAL_START_CODE.length);
+        bufferPosition += NalUnitUtil.NAL_START_CODE.length;
+        System.arraycopy(parent.data, parent.getPosition(), buffer, bufferPosition, nalUnitLength);
+        bufferPosition += nalUnitLength;
+        parent.skipBytes(nalUnitLength);
+      }
+    }
+
+    List<byte[]> initializationData = csdLength == 0 ? null : Collections.singletonList(buffer);
+    return Pair.create(initializationData, lengthSizeMinusOne + 1);
+  }
+
   private static TrackEncryptionBox parseSinfFromParent(ParsableByteArray parent, int position,
       int size) {
     int childPosition = position + Atom.HEADER_SIZE;
@@ -462,34 +527,6 @@ private static TrackEncryptionBox parseSchiFromParent(ParsableByteArray parent,
     return null;
   }
 
-  /** Returns the media format for an mp4v box. */
-  private static MediaFormat parseMp4vFromParent(ParsableByteArray parent, int position, int size,
-      long durationUs) {
-    parent.setPosition(position + Atom.HEADER_SIZE);
-
-    parent.skipBytes(24);
-    int width = parent.readUnsignedShort();
-    int height = parent.readUnsignedShort();
-    parent.skipBytes(50);
-
-    List<byte[]> initializationData = new ArrayList<byte[]>(1);
-    int childPosition = parent.getPosition();
-    while (childPosition - position < size) {
-      parent.setPosition(childPosition);
-      int childStartPosition = parent.getPosition();
-      int childAtomSize = parent.readInt();
-      Assertions.checkArgument(childAtomSize > 0, "childAtomSize should be positive");
-      int childAtomType = parent.readInt();
-      if (childAtomType == Atom.TYPE_esds) {
-        initializationData.add(parseEsdsFromParent(parent, childStartPosition));
-      }
-      childPosition += childAtomSize;
-    }
-
-    return MediaFormat.createVideoFormat(
-        MimeTypes.VIDEO_MP4V, MediaFormat.NO_VALUE, durationUs, width, height, initializationData);
-  }
-
   private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType, int position,
       int size, long durationUs, StsdDataHolder out, int entryIndex) {
     parent.setPosition(position + Atom.HEADER_SIZE);
@@ -499,6 +536,14 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
     parent.skipBytes(4);
     int sampleRate = parent.readUnsignedFixedPoint1616();
 
+    // If the atom type determines a MIME type, set it immediately.
+    String mimeType = null;
+    if (atomType == Atom.TYPE_ac_3) {
+      mimeType = MimeTypes.AUDIO_AC3;
+    } else if (atomType == Atom.TYPE_ec_3) {
+      mimeType = MimeTypes.AUDIO_EC3;
+    }
+
     byte[] initializationData = null;
     int childPosition = parent.getPosition();
     while (childPosition - position < size) {
@@ -509,13 +554,18 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
       int childAtomType = parent.readInt();
       if (atomType == Atom.TYPE_mp4a || atomType == Atom.TYPE_enca) {
         if (childAtomType == Atom.TYPE_esds) {
-          initializationData = parseEsdsFromParent(parent, childStartPosition);
-          // TODO: Do we really need to do this? See [Internal: b/10903778]
-          // Update sampleRate and channelCount from the AudioSpecificConfig initialization data.
-          Pair<Integer, Integer> audioSpecificConfig =
-              CodecSpecificDataUtil.parseAudioSpecificConfig(initializationData);
-          sampleRate = audioSpecificConfig.first;
-          channelCount = audioSpecificConfig.second;
+          Pair<String, byte[]> mimeTypeAndInitializationData =
+              parseEsdsFromParent(parent, childStartPosition);
+          mimeType = mimeTypeAndInitializationData.first;
+          initializationData = mimeTypeAndInitializationData.second;
+          if (MimeTypes.AUDIO_AAC.equals(mimeType)) {
+            // TODO: Do we really need to do this? See [Internal: b/10903778]
+            // Update sampleRate and channelCount from the AudioSpecificConfig initialization data.
+            Pair<Integer, Integer> audioSpecificConfig =
+                CodecSpecificDataUtil.parseAacAudioSpecificConfig(initializationData);
+            sampleRate = audioSpecificConfig.first;
+            channelCount = audioSpecificConfig.second;
+          }
         } else if (childAtomType == Atom.TYPE_sinf) {
           out.trackEncryptionBoxes[entryIndex] = parseSinfFromParent(parent, childStartPosition,
               childAtomSize);
@@ -534,14 +584,9 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
       childPosition += childAtomSize;
     }
 
-    // Set the MIME type for ac-3/ec-3 atoms even if the dac3/dec3 child atom is missing.
-    String mimeType;
-    if (atomType == Atom.TYPE_ac_3) {
-      mimeType = MimeTypes.AUDIO_AC3;
-    } else if (atomType == Atom.TYPE_ec_3) {
-      mimeType = MimeTypes.AUDIO_EC3;
-    } else {
-      mimeType = MimeTypes.AUDIO_AAC;
+    // If the media type was not recognized, ignore the track.
+    if (mimeType == null) {
+      return;
     }
 
     out.mediaFormat = MediaFormat.createAudioFormat(mimeType, sampleSize, durationUs, channelCount,
@@ -550,7 +595,7 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
   }
 
   /** Returns codec-specific initialization data contained in an esds box. */
-  private static byte[] parseEsdsFromParent(ParsableByteArray parent, int position) {
+  private static Pair<String, byte[]> parseEsdsFromParent(ParsableByteArray parent, int position) {
     parent.setPosition(position + Atom.HEADER_SIZE + 4);
     // Start of the ES_Descriptor (defined in 14496-1)
     parent.skipBytes(1); // ES_Descriptor tag
@@ -577,9 +622,41 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
     while (varIntByte > 127) {
       varIntByte = parent.readUnsignedByte();
     }
-    parent.skipBytes(13);
 
-    // Start of AudioSpecificConfig (defined in 14496-3)
+    // Set the MIME type based on the object type indication (14496-1 table 5).
+    int objectTypeIndication = parent.readUnsignedByte();
+    String mimeType;
+    switch (objectTypeIndication) {
+      case 0x6B:
+        mimeType = MimeTypes.AUDIO_MPEG;
+        // Don't extract codec-specific data for MPEG audio tracks, as it is not needed.
+        return Pair.create(mimeType, null);
+      case 0x20:
+        mimeType = MimeTypes.VIDEO_MP4V;
+        break;
+      case 0x21:
+        mimeType = MimeTypes.VIDEO_H264;
+        break;
+      case 0x23:
+        mimeType = MimeTypes.VIDEO_H265;
+        break;
+      case 0x40:
+        mimeType = MimeTypes.AUDIO_AAC;
+        break;
+      case 0xA5:
+        mimeType = MimeTypes.AUDIO_AC3;
+        break;
+      case 0xA6:
+        mimeType = MimeTypes.AUDIO_EC3;
+        break;
+      default:
+        mimeType = null;
+        break;
+    }
+
+    parent.skipBytes(12);
+
+    // Start of the AudioSpecificConfig.
     parent.skipBytes(1); // AudioSpecificConfig tag
     varIntByte = parent.readUnsignedByte();
     int varInt = varIntByte & 0x7F;
@@ -590,7 +667,7 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
     }
     byte[] initializationData = new byte[varInt];
     parent.readBytes(initializationData, 0, varInt);
-    return initializationData;
+    return Pair.create(mimeType, initializationData);
   }
 
   private AtomParsers() {
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
index 92543f3493..6469462394 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
@@ -26,8 +26,8 @@
 import com.google.android.exoplayer.extractor.mp4.Atom.ContainerAtom;
 import com.google.android.exoplayer.extractor.mp4.Atom.LeafAtom;
 import com.google.android.exoplayer.util.Assertions;
-import com.google.android.exoplayer.util.H264Util;
 import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.NalUnitUtil;
 import com.google.android.exoplayer.util.ParsableByteArray;
 import com.google.android.exoplayer.util.Util;
 
@@ -35,7 +35,6 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.Stack;
-import java.util.UUID;
 
 /**
  * Facilitates the extraction of data from the fragmented mp4 container format.
@@ -106,11 +105,11 @@ public FragmentedMp4Extractor() {
   public FragmentedMp4Extractor(int workaroundFlags) {
     this.workaroundFlags = workaroundFlags;
     atomHeader = new ParsableByteArray(Atom.HEADER_SIZE);
-    nalStartCode = new ParsableByteArray(H264Util.NAL_START_CODE);
+    nalStartCode = new ParsableByteArray(NalUnitUtil.NAL_START_CODE);
     nalLength = new ParsableByteArray(4);
     encryptionSignalByte = new ParsableByteArray(1);
     extendedTypeScratch = new byte[16];
-    containerAtoms = new Stack<ContainerAtom>();
+    containerAtoms = new Stack<>();
     fragmentRun = new TrackFragment();
     parserState = STATE_READING_ATOM_HEADER;
   }
@@ -250,16 +249,11 @@ private void onMoovContainerAtomRead(ContainerAtom moov) {
     for (int i = 0; i < moovChildrenSize; i++) {
       LeafAtom child = moovChildren.get(i);
       if (child.type == Atom.TYPE_pssh) {
-        ParsableByteArray psshAtom = child.data;
-        psshAtom.setPosition(Atom.FULL_HEADER_SIZE);
-        UUID uuid = new UUID(psshAtom.readLong(), psshAtom.readLong());
-        int dataSize = psshAtom.readInt();
-        byte[] data = new byte[dataSize];
-        psshAtom.readBytes(data, 0, dataSize);
         if (drmInitData == null) {
           drmInitData = new DrmInitData.Mapped(MimeTypes.VIDEO_MP4);
         }
-        drmInitData.put(uuid, data);
+        byte[] psshData = child.data.data;
+        drmInitData.put(PsshAtomUtil.parseUuid(psshData), psshData);
       }
     }
     if (drmInitData != null) {
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
index 06e333d9b6..9ea68fa2ec 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
@@ -23,7 +23,7 @@
 import com.google.android.exoplayer.extractor.TrackOutput;
 import com.google.android.exoplayer.extractor.mp4.Atom.ContainerAtom;
 import com.google.android.exoplayer.util.Assertions;
-import com.google.android.exoplayer.util.H264Util;
+import com.google.android.exoplayer.util.NalUnitUtil;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
 import java.io.IOException;
@@ -71,8 +71,8 @@
 
   public Mp4Extractor() {
     atomHeader = new ParsableByteArray(Atom.LONG_HEADER_SIZE);
-    containerAtoms = new Stack<Atom.ContainerAtom>();
-    nalStartCode = new ParsableByteArray(H264Util.NAL_START_CODE);
+    containerAtoms = new Stack<>();
+    nalStartCode = new ParsableByteArray(NalUnitUtil.NAL_START_CODE);
     nalLength = new ParsableByteArray(4);
     parserState = STATE_READING_ATOM_HEADER;
   }
@@ -216,7 +216,7 @@ private boolean readAtomPayload(ExtractorInput input, PositionHolder positionHol
 
   /** Updates the stored track metadata to reflect the contents of the specified moov atom. */
   private void processMoovAtom(ContainerAtom moov) {
-    List<Mp4Track> tracks = new ArrayList<Mp4Track>();
+    List<Mp4Track> tracks = new ArrayList<>();
     long earliestSampleOffset = Long.MAX_VALUE;
     for (int i = 0; i < moov.containerChildren.size(); i++) {
       Atom.ContainerAtom atom = moov.containerChildren.get(i);
@@ -225,7 +225,8 @@ private void processMoovAtom(ContainerAtom moov) {
       }
 
       Track track = AtomParsers.parseTrak(atom, moov.getLeafAtomOfType(Atom.TYPE_mvhd));
-      if (track == null || (track.type != Track.TYPE_AUDIO && track.type != Track.TYPE_VIDEO)) {
+      if (track == null || (track.type != Track.TYPE_AUDIO && track.type != Track.TYPE_VIDEO
+          && track.type != Track.TYPE_TEXT)) {
         continue;
       }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/PsshAtomUtil.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/PsshAtomUtil.java
new file mode 100644
index 0000000000..03b910d7f7
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/PsshAtomUtil.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.mp4;
+
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.nio.ByteBuffer;
+import java.util.UUID;
+
+/**
+ * Utility methods for handling PSSH atoms.
+ */
+public final class PsshAtomUtil {
+
+  private PsshAtomUtil() {}
+
+  /**
+   * Builds a PSSH atom for a given {@link UUID} containing the given scheme specific data.
+   *
+   * @param uuid The UUID of the scheme.
+   * @param data The scheme specific data.
+   * @return The PSSH atom.
+   */
+  public static byte[] buildPsshAtom(UUID uuid, byte[] data) {
+    int psshBoxLength = Atom.FULL_HEADER_SIZE + 16 /* UUID */ + 4 /* DataSize */ + data.length;
+    ByteBuffer psshBox = ByteBuffer.allocate(psshBoxLength);
+    psshBox.putInt(psshBoxLength);
+    psshBox.putInt(Atom.TYPE_pssh);
+    psshBox.putInt(0 /* version=0, flags=0 */);
+    psshBox.putLong(uuid.getMostSignificantBits());
+    psshBox.putLong(uuid.getLeastSignificantBits());
+    psshBox.putInt(data.length);
+    psshBox.put(data);
+    return psshBox.array();
+  }
+
+  /**
+   * Parses the UUID from a PSSH atom.
+   * <p>
+   * The UUID is only parsed if the data is a valid PSSH atom.
+   *
+   * @param atom The atom to parse.
+   * @return The parsed UUID. Null if the data is not a valid PSSH atom.
+   */
+  public static UUID parseUuid(byte[] atom) {
+    ParsableByteArray atomData = new ParsableByteArray(atom);
+    if (!isPsshAtom(atomData, null)) {
+      return null;
+    }
+    atomData.setPosition(Atom.FULL_HEADER_SIZE);
+    return new UUID(atomData.readLong(), atomData.readLong());
+  }
+
+  /**
+   * Parses the scheme specific data from a PSSH atom.
+   * <p>
+   * The scheme specific data is only parsed if the data is a valid PSSH atom matching the given
+   * UUID, or if the data is a valid PSSH atom of any type in the case that the passed UUID is null.
+   *
+   * @param atom The atom to parse.
+   * @param uuid The required UUID of the PSSH atom, or null to accept any UUID.
+   * @return The parsed scheme specific data. Null if the data is not a valid PSSH atom or if its
+   *     UUID does not match the one provided.
+   */
+  public static byte[] parseSchemeSpecificData(byte[] atom, UUID uuid) {
+    ParsableByteArray atomData = new ParsableByteArray(atom);
+    if (!isPsshAtom(atomData, uuid)) {
+      return null;
+    }
+    atomData.setPosition(Atom.FULL_HEADER_SIZE + 16 /* UUID */);
+    int dataSize = atomData.readInt();
+    byte[] data = new byte[dataSize];
+    atomData.readBytes(data, 0, dataSize);
+    return data;
+  }
+
+  private static boolean isPsshAtom(ParsableByteArray atomData, UUID uuid) {
+    if (atomData.limit() < Atom.FULL_HEADER_SIZE + 16 /* UUID */ + 4 /* DataSize */) {
+      // Data too short.
+      return false;
+    }
+    atomData.setPosition(0);
+    int atomSize = atomData.readInt();
+    if (atomSize != atomData.bytesLeft() + 4) {
+      // Not an atom, or incorrect atom size.
+      return false;
+    }
+    int atomType = atomData.readInt();
+    if (atomType != Atom.TYPE_pssh) {
+      // Not an atom, or incorrect atom type.
+      return false;
+    }
+    atomData.setPosition(Atom.FULL_HEADER_SIZE);
+    if (uuid == null) {
+      atomData.skipBytes(16);
+    } else if (atomData.readLong() != uuid.getMostSignificantBits()
+        || atomData.readLong() != uuid.getLeastSignificantBits()) {
+      // UUID doesn't match.
+      return false;
+    }
+    int dataSize = atomData.readInt();
+    if (dataSize != atomData.bytesLeft()) {
+      // Incorrect dataSize.
+      return false;
+    }
+    return true;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
index fa4fd51dd2..8121c54901 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
@@ -165,9 +165,9 @@ private void parseHeader() {
       adtsScratch.skipBits(1);
       int channelConfig = adtsScratch.readBits(3);
 
-      byte[] audioSpecificConfig = CodecSpecificDataUtil.buildAudioSpecificConfig(
+      byte[] audioSpecificConfig = CodecSpecificDataUtil.buildAacAudioSpecificConfig(
           audioObjectType, sampleRateIndex, channelConfig);
-      Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAudioSpecificConfig(
+      Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAacAudioSpecificConfig(
           audioSpecificConfig);
 
       MediaFormat mediaFormat = MediaFormat.createAudioFormat(MimeTypes.AUDIO_AAC,
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java
index c8b023e8dc..776adb5bc9 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java
@@ -18,9 +18,8 @@
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.extractor.TrackOutput;
-import com.google.android.exoplayer.util.Assertions;
-import com.google.android.exoplayer.util.H264Util;
 import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.NalUnitUtil;
 import com.google.android.exoplayer.util.ParsableBitArray;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
@@ -37,31 +36,15 @@
 
   private static final String TAG = "H264Reader";
 
-  private static final int NAL_UNIT_TYPE_IDR = 5;
-  private static final int NAL_UNIT_TYPE_SEI = 6;
-  private static final int NAL_UNIT_TYPE_SPS = 7;
-  private static final int NAL_UNIT_TYPE_PPS = 8;
-  private static final int NAL_UNIT_TYPE_AUD = 9;
-  private static final int EXTENDED_SAR = 0xFF;
-  private static final float[] ASPECT_RATIO_IDC_VALUES = new float[] {
-    1f /* Unspecified. Assume square */,
-    1f,
-    12f / 11f,
-    10f / 11f,
-    16f / 11f,
-    40f / 33f,
-    24f / 11f,
-    20f / 11f,
-    32f / 11f,
-    80f / 33f,
-    18f / 11f,
-    15f / 11f,
-    64f / 33f,
-    160f / 99f,
-    4f / 3f,
-    3f / 2f,
-    2f
-  };
+  private static final int FRAME_TYPE_I = 2;
+  private static final int FRAME_TYPE_ALL_I = 7;
+
+  private static final int NAL_UNIT_TYPE_IFR = 1; // Coded slice of a non-IDR picture
+  private static final int NAL_UNIT_TYPE_IDR = 5; // Coded slice of an IDR picture
+  private static final int NAL_UNIT_TYPE_SEI = 6; // Supplemental enhancement information
+  private static final int NAL_UNIT_TYPE_SPS = 7; // Sequence parameter set
+  private static final int NAL_UNIT_TYPE_PPS = 8; // Picture parameter set
+  private static final int NAL_UNIT_TYPE_AUD = 9; // Access unit delimiter
 
   // State that should not be reset on seek.
   private boolean hasOutputFormat;
@@ -69,10 +52,11 @@
   // State that should be reset on seek.
   private final SeiReader seiReader;
   private final boolean[] prefixFlags;
+  private final IfrParserBuffer ifrParserBuffer;
   private final NalUnitTargetBuffer sps;
   private final NalUnitTargetBuffer pps;
   private final NalUnitTargetBuffer sei;
-  private boolean writingSample;
+  private boolean foundFirstSample;
   private long totalBytesWritten;
 
   // Per sample state that gets reset at the start of each sample.
@@ -82,27 +66,29 @@
 
   // Scratch variables to avoid allocations.
   private final ParsableByteArray seiWrapper;
-  private int[] scratchEscapePositions;
 
-  public H264Reader(TrackOutput output, SeiReader seiReader) {
+  public H264Reader(TrackOutput output, SeiReader seiReader, boolean idrKeyframesOnly) {
     super(output);
     this.seiReader = seiReader;
     prefixFlags = new boolean[3];
+    ifrParserBuffer = (idrKeyframesOnly) ? null : new IfrParserBuffer();
     sps = new NalUnitTargetBuffer(NAL_UNIT_TYPE_SPS, 128);
     pps = new NalUnitTargetBuffer(NAL_UNIT_TYPE_PPS, 128);
     sei = new NalUnitTargetBuffer(NAL_UNIT_TYPE_SEI, 128);
     seiWrapper = new ParsableByteArray();
-    scratchEscapePositions = new int[10];
   }
 
   @Override
   public void seek() {
     seiReader.seek();
-    H264Util.clearPrefixFlags(prefixFlags);
+    NalUnitUtil.clearPrefixFlags(prefixFlags);
     sps.reset();
     pps.reset();
     sei.reset();
-    writingSample = false;
+    if (ifrParserBuffer != null) {
+      ifrParserBuffer.reset();
+    }
+    foundFirstSample = false;
     totalBytesWritten = 0;
   }
 
@@ -119,7 +105,7 @@ public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacke
 
       // Scan the appended data, processing NAL units as they are encountered
       while (offset < limit) {
-        int nextNalUnitOffset = H264Util.findNalUnit(dataArray, offset, limit, prefixFlags);
+        int nextNalUnitOffset = NalUnitUtil.findNalUnit(dataArray, offset, limit, prefixFlags);
         if (nextNalUnitOffset < limit) {
           // We've seen the start of a NAL unit.
 
@@ -130,24 +116,31 @@ public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacke
             feedNalUnitTargetBuffersData(dataArray, offset, nextNalUnitOffset);
           }
 
-          int nalUnitType = H264Util.getNalUnitType(dataArray, nextNalUnitOffset);
+          int nalUnitType = NalUnitUtil.getNalUnitType(dataArray, nextNalUnitOffset);
           int bytesWrittenPastNalUnit = limit - nextNalUnitOffset;
-          if (nalUnitType == NAL_UNIT_TYPE_AUD) {
-            if (writingSample) {
-              if (isKeyframe && !hasOutputFormat && sps.isCompleted() && pps.isCompleted()) {
-                parseMediaFormat(sps, pps);
+          switch (nalUnitType) {
+            case NAL_UNIT_TYPE_IDR:
+              isKeyframe = true;
+              break;
+            case NAL_UNIT_TYPE_AUD:
+              if (foundFirstSample) {
+                if (ifrParserBuffer != null && ifrParserBuffer.isCompleted()) {
+                  int sliceType = ifrParserBuffer.getSliceType();
+                  isKeyframe |= (sliceType == FRAME_TYPE_I || sliceType == FRAME_TYPE_ALL_I);
+                  ifrParserBuffer.reset();
+                }
+                if (isKeyframe && !hasOutputFormat && sps.isCompleted() && pps.isCompleted()) {
+                  parseMediaFormat(sps, pps);
+                }
+                int flags = isKeyframe ? C.SAMPLE_FLAG_SYNC : 0;
+                int size = (int) (totalBytesWritten - samplePosition) - bytesWrittenPastNalUnit;
+                output.sampleMetadata(sampleTimeUs, flags, size, bytesWrittenPastNalUnit, null);
               }
-              int flags = isKeyframe ? C.SAMPLE_FLAG_SYNC : 0;
-              int size = (int) (totalBytesWritten - samplePosition) - bytesWrittenPastNalUnit;
-              output.sampleMetadata(sampleTimeUs, flags, size, bytesWrittenPastNalUnit, null);
-              writingSample = false;
-            }
-            writingSample = true;
-            isKeyframe = false;
-            sampleTimeUs = pesTimeUs;
-            samplePosition = totalBytesWritten - bytesWrittenPastNalUnit;
-          } else if (nalUnitType == NAL_UNIT_TYPE_IDR) {
-            isKeyframe = true;
+              foundFirstSample = true;
+              samplePosition = totalBytesWritten - bytesWrittenPastNalUnit;
+              sampleTimeUs = pesTimeUs;
+              isKeyframe = false;
+              break;
           }
 
           // If the length to the start of the unit is negative then we wrote too many bytes to the
@@ -156,7 +149,7 @@ public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacke
           // Notify the start of the next NAL unit.
           feedNalUnitTargetBuffersStart(nalUnitType);
           // Continue scanning the data.
-          offset = nextNalUnitOffset + 4;
+          offset = nextNalUnitOffset + 3;
         } else {
           feedNalUnitTargetBuffersData(dataArray, offset, limit);
           offset = limit;
@@ -171,6 +164,9 @@ public void packetFinished() {
   }
 
   private void feedNalUnitTargetBuffersStart(int nalUnitType) {
+    if (ifrParserBuffer != null) {
+      ifrParserBuffer.startNalUnit(nalUnitType);
+    }
     if (!hasOutputFormat) {
       sps.startNalUnit(nalUnitType);
       pps.startNalUnit(nalUnitType);
@@ -179,6 +175,9 @@ private void feedNalUnitTargetBuffersStart(int nalUnitType) {
   }
 
   private void feedNalUnitTargetBuffersData(byte[] dataArray, int offset, int limit) {
+    if (ifrParserBuffer != null) {
+      ifrParserBuffer.appendToNalUnit(dataArray, offset, limit);
+    }
     if (!hasOutputFormat) {
       sps.appendToNalUnit(dataArray, offset, limit);
       pps.appendToNalUnit(dataArray, offset, limit);
@@ -190,8 +189,9 @@ private void feedNalUnitTargetEnd(long pesTimeUs, int discardPadding) {
     sps.endNalUnit(discardPadding);
     pps.endNalUnit(discardPadding);
     if (sei.endNalUnit(discardPadding)) {
-      int unescapedLength = unescapeStream(sei.nalData, sei.nalLength);
+      int unescapedLength = NalUnitUtil.unescapeStream(sei.nalData, sei.nalLength);
       seiWrapper.reset(sei.nalData, unescapedLength);
+      seiWrapper.setPosition(4); // NAL prefix and nal_unit() header.
       seiReader.consume(seiWrapper, pesTimeUs, true);
     }
   }
@@ -201,12 +201,12 @@ private void parseMediaFormat(NalUnitTargetBuffer sps, NalUnitTargetBuffer pps)
     byte[] ppsData = new byte[pps.nalLength];
     System.arraycopy(sps.nalData, 0, spsData, 0, sps.nalLength);
     System.arraycopy(pps.nalData, 0, ppsData, 0, pps.nalLength);
-    List<byte[]> initializationData = new ArrayList<byte[]>();
+    List<byte[]> initializationData = new ArrayList<>();
     initializationData.add(spsData);
     initializationData.add(ppsData);
 
     // Unescape and then parse the SPS unit.
-    unescapeStream(sps.nalData, sps.nalLength);
+    NalUnitUtil.unescapeStream(sps.nalData, sps.nalLength);
     ParsableBitArray bitArray = new ParsableBitArray(sps.nalData);
     bitArray.skipBits(32); // NAL header
     int profileIdc = bitArray.readBits(8);
@@ -289,14 +289,14 @@ private void parseMediaFormat(NalUnitTargetBuffer sps, NalUnitTargetBuffer pps)
       boolean aspectRatioInfoPresentFlag = bitArray.readBit();
       if (aspectRatioInfoPresentFlag) {
         int aspectRatioIdc = bitArray.readBits(8);
-        if (aspectRatioIdc == EXTENDED_SAR) {
+        if (aspectRatioIdc == NalUnitUtil.EXTENDED_SAR) {
           int sarWidth = bitArray.readBits(16);
           int sarHeight = bitArray.readBits(16);
           if (sarWidth != 0 && sarHeight != 0) {
             pixelWidthHeightRatio = (float) sarWidth / sarHeight;
           }
-        } else if (aspectRatioIdc < ASPECT_RATIO_IDC_VALUES.length) {
-          pixelWidthHeightRatio = ASPECT_RATIO_IDC_VALUES[aspectRatioIdc];
+        } else if (aspectRatioIdc < NalUnitUtil.ASPECT_RATIO_IDC_VALUES.length) {
+          pixelWidthHeightRatio = NalUnitUtil.ASPECT_RATIO_IDC_VALUES[aspectRatioIdc];
         } else {
           Log.w(TAG, "Unexpected aspect_ratio_idc value: " + aspectRatioIdc);
         }
@@ -321,76 +321,24 @@ private void skipScalingList(ParsableBitArray bitArray, int size) {
   }
 
   /**
-   * Unescapes {@code data} up to the specified limit, replacing occurrences of [0, 0, 3] with
-   * [0, 0]. The unescaped data is returned in-place, with the return value indicating its length.
-   * <p>
-   * See ISO/IEC 14496-10:2005(E) page 36 for more information.
-   *
-   * @param data The data to unescape.
-   * @param limit The limit (exclusive) of the data to unescape.
-   * @return The length of the unescaped data.
+   * A buffer specifically for IFR units that can be used to parse the IFR's slice type.
    */
-  private int unescapeStream(byte[] data, int limit) {
-    int position = 0;
-    int scratchEscapeCount = 0;
-    while (position < limit) {
-      position = findNextUnescapeIndex(data, position, limit);
-      if (position < limit) {
-        if (scratchEscapePositions.length <= scratchEscapeCount) {
-          // Grow scratchEscapePositions to hold a larger number of positions.
-          scratchEscapePositions = Arrays.copyOf(scratchEscapePositions,
-              scratchEscapePositions.length * 2);
-        }
-        scratchEscapePositions[scratchEscapeCount++] = position;
-        position += 3;
-      }
-    }
-
-    int unescapedLength = limit - scratchEscapeCount;
-    int escapedPosition = 0; // The position being read from.
-    int unescapedPosition = 0; // The position being written to.
-    for (int i = 0; i < scratchEscapeCount; i++) {
-      int nextEscapePosition = scratchEscapePositions[i];
-      int copyLength = nextEscapePosition - escapedPosition;
-      System.arraycopy(data, escapedPosition, data, unescapedPosition, copyLength);
-      escapedPosition += copyLength + 3;
-      unescapedPosition += copyLength + 2;
-    }
-
-    int remainingLength = unescapedLength - unescapedPosition;
-    System.arraycopy(data, escapedPosition, data, unescapedPosition, remainingLength);
-    return unescapedLength;
-  }
-
-  private int findNextUnescapeIndex(byte[] bytes, int offset, int limit) {
-    for (int i = offset; i < limit - 2; i++) {
-      if (bytes[i] == 0x00 && bytes[i + 1] == 0x00 && bytes[i + 2] == 0x03) {
-        return i;
-      }
-    }
-    return limit;
-  }
+  private static final class IfrParserBuffer {
 
-  /**
-   * A buffer that fills itself with data corresponding to a specific NAL unit, as it is
-   * encountered in the stream.
-   */
-  private static final class NalUnitTargetBuffer {
+    private static final int DEFAULT_BUFFER_SIZE = 128;
+    private static final int NOT_SET = -1;
 
-    private final int targetType;
+    private final ParsableBitArray scratchSliceType;
 
+    private byte[] ifrData;
+    private int ifrLength;
     private boolean isFilling;
-    private boolean isCompleted;
+    private int sliceType;
 
-    public byte[] nalData;
-    public int nalLength;
-
-    public NalUnitTargetBuffer(int targetType, int initialCapacity) {
-      this.targetType = targetType;
-      // Initialize data, writing the known NAL prefix into the first four bytes.
-      nalData = new byte[4 + initialCapacity];
-      nalData[2] = 1;
-      nalData[3] = (byte) targetType;
+    public IfrParserBuffer() {
+      ifrData = new byte[DEFAULT_BUFFER_SIZE];
+      scratchSliceType = new ParsableBitArray(ifrData);
+      reset();
     }
 
     /**
@@ -398,28 +346,25 @@ public NalUnitTargetBuffer(int targetType, int initialCapacity) {
      */
     public void reset() {
       isFilling = false;
-      isCompleted = false;
+      ifrLength = 0;
+      sliceType = NOT_SET;
     }
 
     /**
-     * True if the buffer currently holds a complete NAL unit of the target type.
+     * True if enough data was added to the buffer that the slice type was determined.
      */
     public boolean isCompleted() {
-      return isCompleted;
+      return sliceType != NOT_SET;
     }
 
     /**
-     * Invoked to indicate that a NAL unit has started.
-     *
-     * @param type The type of the NAL unit.
+     * Invoked to indicate that a NAL unit has started, and if it is an IFR then the buffer will
+     * start.
      */
-    public void startNalUnit(int type) {
-      Assertions.checkState(!isFilling);
-      isFilling = type == targetType;
-      if (isFilling) {
-        // Length is initially the length of the NAL prefix.
-        nalLength = 4;
-        isCompleted = false;
+    public void startNalUnit(int nalUnitType) {
+      if (nalUnitType == NAL_UNIT_TYPE_IFR) {
+        reset();
+        isFilling = true;
       }
     }
 
@@ -435,28 +380,37 @@ public void appendToNalUnit(byte[] data, int offset, int limit) {
         return;
       }
       int readLength = limit - offset;
-      if (nalData.length < nalLength + readLength) {
-        nalData = Arrays.copyOf(nalData, (nalLength + readLength) * 2);
+      if (ifrData.length < ifrLength + readLength) {
+        ifrData = Arrays.copyOf(ifrData, (ifrLength + readLength) * 2);
       }
-      System.arraycopy(data, offset, nalData, nalLength, readLength);
-      nalLength += readLength;
+      System.arraycopy(data, offset, ifrData, ifrLength, readLength);
+      ifrLength += readLength;
+
+      scratchSliceType.reset(ifrData, ifrLength);
+      // first_mb_in_slice
+      int len = scratchSliceType.peekExpGolombCodedNumLength();
+      if ((len == -1) || (len > scratchSliceType.bitsLeft())) {
+        // Not enough yet
+        return;
+      }
+
+      scratchSliceType.skipBits(len);
+      // slice_type
+      len = scratchSliceType.peekExpGolombCodedNumLength();
+      if ((len == -1) || (len > scratchSliceType.bitsLeft())) {
+        // Not enough yet
+        return;
+      }
+      sliceType = scratchSliceType.readUnsignedExpGolombCodedInt();
+
+      isFilling = false;
     }
 
     /**
-     * Invoked to indicate that a NAL unit has ended.
-     *
-     * @param discardPadding The number of excess bytes that were passed to
-     *     {@link #appendToNalUnit(byte[], int, int)}, which should be discarded.
-     * @return True if the ended NAL unit is of the target type. False otherwise.
+     * @return the slice type of the IFR.
      */
-    public boolean endNalUnit(int discardPadding) {
-      if (!isFilling) {
-        return false;
-      }
-      nalLength -= discardPadding;
-      isFilling = false;
-      isCompleted = true;
-      return true;
+    public int getSliceType() {
+      return sliceType;
     }
 
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java
new file mode 100644
index 0000000000..1631700911
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java
@@ -0,0 +1,402 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ts;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.NalUnitUtil;
+import com.google.android.exoplayer.util.ParsableBitArray;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import android.util.Log;
+
+import java.util.Collections;
+
+/**
+ * Parses a continuous H.265 byte stream and extracts individual frames.
+ */
+/* package */ class H265Reader extends ElementaryStreamReader {
+
+  private static final String TAG = "H265Reader";
+
+  // nal_unit_type values from H.265/HEVC (2014) Table 7-1.
+  private static final int RASL_R = 9;
+  private static final int BLA_W_LP = 16;
+  private static final int BLA_W_RADL = 17;
+  private static final int BLA_N_LP = 18;
+  private static final int IDR_W_RADL = 19;
+  private static final int IDR_N_LP = 20;
+  private static final int CRA_NUT = 21;
+  private static final int VPS_NUT = 32;
+  private static final int SPS_NUT = 33;
+  private static final int PPS_NUT = 34;
+  private static final int PREFIX_SEI_NUT = 39;
+  private static final int SUFFIX_SEI_NUT = 40;
+
+  // State that should not be reset on seek.
+  private boolean hasOutputFormat;
+
+  // State that should be reset on seek.
+  private final SeiReader seiReader;
+  private final boolean[] prefixFlags;
+  private final NalUnitTargetBuffer vps;
+  private final NalUnitTargetBuffer sps;
+  private final NalUnitTargetBuffer pps;
+  private final NalUnitTargetBuffer prefixSei;
+  private final NalUnitTargetBuffer suffixSei; // TODO: Are both needed?
+  private boolean foundFirstSample;
+  private long totalBytesWritten;
+
+  // Per sample state that gets reset at the start of each sample.
+  private boolean isKeyframe;
+  private long samplePosition;
+  private long sampleTimeUs;
+
+  // Scratch variables to avoid allocations.
+  private final ParsableByteArray seiWrapper;
+
+  public H265Reader(TrackOutput output, SeiReader seiReader) {
+    super(output);
+    this.seiReader = seiReader;
+    prefixFlags = new boolean[3];
+    vps = new NalUnitTargetBuffer(VPS_NUT, 128);
+    sps = new NalUnitTargetBuffer(SPS_NUT, 128);
+    pps = new NalUnitTargetBuffer(PPS_NUT, 128);
+    prefixSei = new NalUnitTargetBuffer(PREFIX_SEI_NUT, 128);
+    suffixSei = new NalUnitTargetBuffer(SUFFIX_SEI_NUT, 128);
+    seiWrapper = new ParsableByteArray();
+  }
+
+  @Override
+  public void seek() {
+    seiReader.seek();
+    NalUnitUtil.clearPrefixFlags(prefixFlags);
+    vps.reset();
+    sps.reset();
+    pps.reset();
+    prefixSei.reset();
+    suffixSei.reset();
+    foundFirstSample = false;
+    totalBytesWritten = 0;
+  }
+
+  @Override
+  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
+    while (data.bytesLeft() > 0) {
+      int offset = data.getPosition();
+      int limit = data.limit();
+      byte[] dataArray = data.data;
+
+      // Append the data to the buffer.
+      totalBytesWritten += data.bytesLeft();
+      output.sampleData(data, data.bytesLeft());
+
+      // Scan the appended data, processing NAL units as they are encountered
+      while (offset < limit) {
+        int nextNalUnitOffset = NalUnitUtil.findNalUnit(dataArray, offset, limit, prefixFlags);
+        if (nextNalUnitOffset < limit) {
+          // We've seen the start of a NAL unit.
+
+          // This is the length to the start of the unit. It may be negative if the NAL unit
+          // actually started in previously consumed data.
+          int lengthToNalUnit = nextNalUnitOffset - offset;
+          if (lengthToNalUnit > 0) {
+            feedNalUnitTargetBuffersData(dataArray, offset, nextNalUnitOffset);
+          }
+
+          int nalUnitType = NalUnitUtil.getH265NalUnitType(dataArray, nextNalUnitOffset);
+          int bytesWrittenPastNalUnit = limit - nextNalUnitOffset;
+          if (isFirstSliceSegmentInPic(dataArray, nextNalUnitOffset)) {
+            if (foundFirstSample) {
+              if (isKeyframe && !hasOutputFormat && vps.isCompleted() && sps.isCompleted()
+                  && pps.isCompleted()) {
+                parseMediaFormat(vps, sps, pps);
+              }
+              int flags = isKeyframe ? C.SAMPLE_FLAG_SYNC : 0;
+              int size = (int) (totalBytesWritten - samplePosition) - bytesWrittenPastNalUnit;
+              output.sampleMetadata(sampleTimeUs, flags, size, bytesWrittenPastNalUnit, null);
+            }
+            foundFirstSample = true;
+            samplePosition = totalBytesWritten - bytesWrittenPastNalUnit;
+            sampleTimeUs = pesTimeUs;
+            isKeyframe = isRandomAccessPoint(nalUnitType);
+          }
+
+          // If the length to the start of the unit is negative then we wrote too many bytes to the
+          // NAL buffers. Discard the excess bytes when notifying that the unit has ended.
+          feedNalUnitTargetEnd(pesTimeUs, lengthToNalUnit < 0 ? -lengthToNalUnit : 0);
+          // Notify the start of the next NAL unit.
+          feedNalUnitTargetBuffersStart(nalUnitType);
+          // Continue scanning the data.
+          offset = nextNalUnitOffset + 3;
+        } else {
+          feedNalUnitTargetBuffersData(dataArray, offset, limit);
+          offset = limit;
+        }
+      }
+    }
+  }
+
+  @Override
+  public void packetFinished() {
+    // Do nothing.
+  }
+
+  private void feedNalUnitTargetBuffersStart(int nalUnitType) {
+    if (!hasOutputFormat) {
+      vps.startNalUnit(nalUnitType);
+      sps.startNalUnit(nalUnitType);
+      pps.startNalUnit(nalUnitType);
+    }
+    prefixSei.startNalUnit(nalUnitType);
+    suffixSei.startNalUnit(nalUnitType);
+  }
+
+  private void feedNalUnitTargetBuffersData(byte[] dataArray, int offset, int limit) {
+    if (!hasOutputFormat) {
+      vps.appendToNalUnit(dataArray, offset, limit);
+      sps.appendToNalUnit(dataArray, offset, limit);
+      pps.appendToNalUnit(dataArray, offset, limit);
+    }
+    prefixSei.appendToNalUnit(dataArray, offset, limit);
+    suffixSei.appendToNalUnit(dataArray, offset, limit);
+  }
+
+  private void feedNalUnitTargetEnd(long pesTimeUs, int discardPadding) {
+    vps.endNalUnit(discardPadding);
+    sps.endNalUnit(discardPadding);
+    pps.endNalUnit(discardPadding);
+    if (prefixSei.endNalUnit(discardPadding)) {
+      int unescapedLength = NalUnitUtil.unescapeStream(prefixSei.nalData, prefixSei.nalLength);
+      seiWrapper.reset(prefixSei.nalData, unescapedLength);
+
+      // Skip the NAL prefix and type.
+      seiWrapper.skipBytes(5);
+      seiReader.consume(seiWrapper, pesTimeUs, true);
+    }
+    if (suffixSei.endNalUnit(discardPadding)) {
+      int unescapedLength = NalUnitUtil.unescapeStream(suffixSei.nalData, suffixSei.nalLength);
+      seiWrapper.reset(suffixSei.nalData, unescapedLength);
+
+      // Skip the NAL prefix and type.
+      seiWrapper.skipBytes(5);
+      seiReader.consume(seiWrapper, pesTimeUs, true);
+    }
+  }
+
+  private void parseMediaFormat(NalUnitTargetBuffer vps, NalUnitTargetBuffer sps,
+      NalUnitTargetBuffer pps) {
+    // Build codec-specific data.
+    byte[] csd = new byte[vps.nalLength + sps.nalLength + pps.nalLength];
+    System.arraycopy(vps.nalData, 0, csd, 0, vps.nalLength);
+    System.arraycopy(sps.nalData, 0, csd, vps.nalLength, sps.nalLength);
+    System.arraycopy(pps.nalData, 0, csd, vps.nalLength + sps.nalLength, pps.nalLength);
+
+    // Unescape and then parse the SPS NAL unit, as per H.265/HEVC (2014) 7.3.2.2.1.
+    NalUnitUtil.unescapeStream(sps.nalData, sps.nalLength);
+    ParsableBitArray bitArray = new ParsableBitArray(sps.nalData);
+    bitArray.skipBits(40 + 4); // NAL header, sps_video_parameter_set_id
+    int maxSubLayersMinus1 = bitArray.readBits(3);
+    bitArray.skipBits(1); // sps_temporal_id_nesting_flag
+
+    // profile_tier_level(1, sps_max_sub_layers_minus1)
+    bitArray.skipBits(88); // if (profilePresentFlag) {...}
+    bitArray.skipBits(8); // general_level_idc
+    int toSkip = 0;
+    for (int i = 0; i < maxSubLayersMinus1; i++) {
+      if (bitArray.readBits(1) == 1) { // sub_layer_profile_present_flag[i]
+        toSkip += 89;
+      }
+      if (bitArray.readBits(1) == 1) { // sub_layer_level_present_flag[i]
+        toSkip += 8;
+      }
+    }
+    bitArray.skipBits(toSkip);
+    if (maxSubLayersMinus1 > 0) {
+      bitArray.skipBits(2 * (8 - maxSubLayersMinus1));
+    }
+
+    bitArray.readUnsignedExpGolombCodedInt(); // sps_seq_parameter_set_id
+    int chromaFormatIdc = bitArray.readUnsignedExpGolombCodedInt();
+    if (chromaFormatIdc == 3) {
+      bitArray.skipBits(1); // separate_colour_plane_flag
+    }
+    int picWidthInLumaSamples = bitArray.readUnsignedExpGolombCodedInt();
+    int picHeightInLumaSamples = bitArray.readUnsignedExpGolombCodedInt();
+    if (bitArray.readBit()) { // conformance_window_flag
+      int confWinLeftOffset = bitArray.readUnsignedExpGolombCodedInt();
+      int confWinRightOffset = bitArray.readUnsignedExpGolombCodedInt();
+      int confWinTopOffset = bitArray.readUnsignedExpGolombCodedInt();
+      int confWinBottomOffset = bitArray.readUnsignedExpGolombCodedInt();
+      // H.265/HEVC (2014) Table 6-1
+      int subWidthC = chromaFormatIdc == 1 || chromaFormatIdc == 2 ? 2 : 1;
+      int subHeightC = chromaFormatIdc == 1 ? 2 : 1;
+      picWidthInLumaSamples -= subWidthC * (confWinLeftOffset + confWinRightOffset);
+      picHeightInLumaSamples -= subHeightC * (confWinTopOffset + confWinBottomOffset);
+    }
+    bitArray.readUnsignedExpGolombCodedInt(); // bit_depth_luma_minus8
+    bitArray.readUnsignedExpGolombCodedInt(); // bit_depth_chroma_minus8
+    int log2MaxPicOrderCntLsbMinus4 = bitArray.readUnsignedExpGolombCodedInt();
+    // for (i = sps_sub_layer_ordering_info_present_flag ? 0 : sps_max_sub_layers_minus1; ...)
+    for (int i = bitArray.readBit() ? 0 : maxSubLayersMinus1; i <= maxSubLayersMinus1; i++) {
+      bitArray.readUnsignedExpGolombCodedInt(); // sps_max_dec_pic_buffering_minus1[i]
+      bitArray.readUnsignedExpGolombCodedInt(); // sps_max_num_reorder_pics[i]
+      bitArray.readUnsignedExpGolombCodedInt(); // sps_max_latency_increase_plus1[i]
+    }
+    bitArray.readUnsignedExpGolombCodedInt(); // log2_min_luma_coding_block_size_minus3
+    bitArray.readUnsignedExpGolombCodedInt(); // log2_diff_max_min_luma_coding_block_size
+    bitArray.readUnsignedExpGolombCodedInt(); // log2_min_luma_transform_block_size_minus2
+    bitArray.readUnsignedExpGolombCodedInt(); // log2_diff_max_min_luma_transform_block_size
+    bitArray.readUnsignedExpGolombCodedInt(); // max_transform_hierarchy_depth_inter
+    bitArray.readUnsignedExpGolombCodedInt(); // max_transform_hierarchy_depth_intra
+    // if (scaling_list_enabled_flag) { if (sps_scaling_list_data_present_flag) {...}}
+    if (bitArray.readBit() && bitArray.readBit()) {
+      skipScalingList(bitArray);
+    }
+    bitArray.skipBits(2); // amp_enabled_flag (1), sample_adaptive_offset_enabled_flag (1)
+    if (bitArray.readBit()) { // pcm_enabled_flag
+      // pcm_sample_bit_depth_luma_minus1 (4), pcm_sample_bit_depth_chroma_minus1 (4)
+      bitArray.skipBits(4);
+      bitArray.readUnsignedExpGolombCodedInt(); // log2_min_pcm_luma_coding_block_size_minus3
+      bitArray.readUnsignedExpGolombCodedInt(); // log2_diff_max_min_pcm_luma_coding_block_size
+      bitArray.skipBits(1); // pcm_loop_filter_disabled_flag
+    }
+    // Skips all short term reference picture sets.
+    skipShortTermRefPicSets(bitArray);
+    if (bitArray.readBit()) { // long_term_ref_pics_present_flag
+      // num_long_term_ref_pics_sps
+      for (int i = 0; i < bitArray.readUnsignedExpGolombCodedInt(); i++) {
+        int ltRefPicPocLsbSpsLength = log2MaxPicOrderCntLsbMinus4 + 4;
+        // lt_ref_pic_poc_lsb_sps[i], used_by_curr_pic_lt_sps_flag[i]
+        bitArray.skipBits(ltRefPicPocLsbSpsLength + 1);
+      }
+    }
+    bitArray.skipBits(2); // sps_temporal_mvp_enabled_flag, strong_intra_smoothing_enabled_flag
+    float pixelWidthHeightRatio = 1;
+    if (bitArray.readBit()) { // vui_parameters_present_flag
+      if (bitArray.readBit()) { // aspect_ratio_info_present_flag
+        int aspectRatioIdc = bitArray.readBits(8);
+        if (aspectRatioIdc == NalUnitUtil.EXTENDED_SAR) {
+          int sarWidth = bitArray.readBits(16);
+          int sarHeight = bitArray.readBits(16);
+          if (sarWidth != 0 && sarHeight != 0) {
+            pixelWidthHeightRatio = (float) sarWidth / sarHeight;
+          }
+        } else if (aspectRatioIdc < NalUnitUtil.ASPECT_RATIO_IDC_VALUES.length) {
+          pixelWidthHeightRatio = NalUnitUtil.ASPECT_RATIO_IDC_VALUES[aspectRatioIdc];
+        } else {
+          Log.w(TAG, "Unexpected aspect_ratio_idc value: " + aspectRatioIdc);
+        }
+      }
+    }
+
+    output.format(MediaFormat.createVideoFormat(MimeTypes.VIDEO_H265, MediaFormat.NO_VALUE,
+        C.UNKNOWN_TIME_US, picWidthInLumaSamples, picHeightInLumaSamples, pixelWidthHeightRatio,
+        Collections.singletonList(csd)));
+    hasOutputFormat = true;
+  }
+
+  /** Skips scaling_list_data(). See H.265/HEVC (2014) 7.3.4. */
+  private void skipScalingList(ParsableBitArray bitArray) {
+    for (int sizeId = 0; sizeId < 4; sizeId++) {
+      for (int matrixId = 0; matrixId < 6; matrixId += sizeId == 3 ? 3 : 1) {
+        if (!bitArray.readBit()) { // scaling_list_pred_mode_flag[sizeId][matrixId]
+          // scaling_list_pred_matrix_id_delta[sizeId][matrixId]
+          bitArray.readUnsignedExpGolombCodedInt();
+        } else {
+          int coefNum = Math.min(64, 1 << (4 + sizeId << 1));
+          if (sizeId > 1) {
+            // scaling_list_dc_coef_minus8[sizeId - 2][matrixId]
+            bitArray.readSignedExpGolombCodedInt();
+          }
+          for (int i = 0; i < coefNum; i++) {
+            bitArray.readSignedExpGolombCodedInt(); // scaling_list_delta_coef
+          }
+        }
+      }
+    }
+  }
+
+  /**
+   * Reads the number of short term reference picture sets in a SPS as ue(v), then skips all of
+   * them. See H.265/HEVC (2014) 7.3.7.
+   */
+  private static void skipShortTermRefPicSets(ParsableBitArray bitArray) {
+    int numShortTermRefPicSets = bitArray.readUnsignedExpGolombCodedInt();
+    boolean interRefPicSetPredictionFlag = false;
+    int numNegativePics = 0;
+    int numPositivePics = 0;
+    // As this method applies in a SPS, the only element of NumDeltaPocs accessed is the previous
+    // one, so we just keep track of that rather than storing the whole array.
+    // RefRpsIdx = stRpsIdx - (delta_idx_minus1 + 1) and delta_idx_minus1 is always zero in SPS.
+    int previousNumDeltaPocs = 0;
+    for (int stRpsIdx = 0; stRpsIdx < numShortTermRefPicSets; stRpsIdx++) {
+      if (stRpsIdx != 0) {
+        interRefPicSetPredictionFlag = bitArray.readBit();
+      }
+      if (interRefPicSetPredictionFlag) {
+        bitArray.skipBits(1); // delta_rps_sign
+        bitArray.readUnsignedExpGolombCodedInt(); // abs_delta_rps_minus1
+        for (int j = 0; j <= previousNumDeltaPocs; j++) {
+          if (bitArray.readBit()) { // used_by_curr_pic_flag[j]
+            bitArray.skipBits(1); // use_delta_flag[j]
+          }
+        }
+      } else {
+        numNegativePics = bitArray.readUnsignedExpGolombCodedInt();
+        numPositivePics = bitArray.readUnsignedExpGolombCodedInt();
+        previousNumDeltaPocs = numNegativePics + numPositivePics;
+        for (int i = 0; i < numNegativePics; i++) {
+          bitArray.readUnsignedExpGolombCodedInt(); // delta_poc_s0_minus1[i]
+          bitArray.skipBits(1); // used_by_curr_pic_s0_flag[i]
+        }
+        for (int i = 0; i < numPositivePics; i++) {
+          bitArray.readUnsignedExpGolombCodedInt(); // delta_poc_s1_minus1[i]
+          bitArray.skipBits(1); // used_by_curr_pic_s1_flag[i]
+        }
+      }
+    }
+  }
+
+  /**
+   * Returns whether the NAL unit is a random access point.
+   */
+  private static boolean isRandomAccessPoint(int nalUnitType) {
+    return nalUnitType == BLA_W_LP || nalUnitType == BLA_W_RADL || nalUnitType == BLA_N_LP
+        || nalUnitType == IDR_W_RADL || nalUnitType == IDR_N_LP || nalUnitType == CRA_NUT;
+  }
+
+  /**
+   * Returns whether the NAL unit in {@code data} starting at {@code offset} contains the first
+   * slice in a picture.
+   *
+   * @param data The data to read.
+   * @param offset The start offset of a NAL unit. Must lie between {@code -3} (inclusive) and
+   *     {@code data.length - 3} (exclusive).
+   * @return Whether the NAL unit contains the first slice in a picture.
+   */
+  public static boolean isFirstSliceSegmentInPic(byte[] data, int offset) {
+    int nalUnitType = NalUnitUtil.getH265NalUnitType(data, offset);
+    // Check the flag in NAL units that contain a slice_segment_layer_rbsp RBSP.
+    if ((nalUnitType <= RASL_R) || (nalUnitType >= BLA_W_LP && nalUnitType <= CRA_NUT)) {
+      return (data[offset + 5] & 0x80) != 0;
+    }
+    return false;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java
index 04fe15481e..28c4fe71d1 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java
@@ -18,6 +18,7 @@
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
 /**
@@ -34,7 +35,7 @@
 
   public Id3Reader(TrackOutput output) {
     super(output);
-    output.format(MediaFormat.createId3Format());
+    output.format(MediaFormat.createTextFormat(MimeTypes.APPLICATION_ID3));
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpegAudioReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpegAudioReader.java
new file mode 100644
index 0000000000..b2ee4ec7a9
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpegAudioReader.java
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ts;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.MpegAudioHeader;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+/**
+ * Parses a continuous MPEG Audio byte stream and extracts individual frames.
+ */
+/* package */ class MpegAudioReader extends ElementaryStreamReader {
+
+  private static final int STATE_FINDING_HEADER = 0;
+  private static final int STATE_READING_HEADER = 1;
+  private static final int STATE_READING_FRAME = 2;
+
+  private static final int HEADER_SIZE = 4;
+
+  private final ParsableByteArray headerScratch;
+  private final MpegAudioHeader header;
+
+  private int state;
+  private int frameBytesRead;
+  private boolean hasOutputFormat;
+
+  // Used when finding the frame header.
+  private boolean lastByteWasFF;
+
+  // Parsed from the frame header.
+  private long frameDurationUs;
+  private int frameSize;
+
+  // The timestamp to attach to the next sample in the current packet.
+  private long timeUs;
+
+  public MpegAudioReader(TrackOutput output) {
+    super(output);
+    state = STATE_FINDING_HEADER;
+    // The first byte of an MPEG Audio frame header is always 0xFF.
+    headerScratch = new ParsableByteArray(4);
+    headerScratch.data[0] = (byte) 0xFF;
+    header = new MpegAudioHeader();
+  }
+
+  @Override
+  public void seek() {
+    state = STATE_FINDING_HEADER;
+    frameBytesRead = 0;
+    lastByteWasFF = false;
+  }
+
+  @Override
+  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
+    if (startOfPacket) {
+      timeUs = pesTimeUs;
+    }
+    while (data.bytesLeft() > 0) {
+      switch (state) {
+        case STATE_FINDING_HEADER:
+          findHeader(data);
+          break;
+        case STATE_READING_HEADER:
+          readHeaderRemainder(data);
+          break;
+        case STATE_READING_FRAME:
+          readFrameRemainder(data);
+          break;
+      }
+    }
+  }
+
+  @Override
+  public void packetFinished() {
+    // Do nothing.
+  }
+
+  /**
+   * Attempts to locate the start of the next frame header.
+   * <p>
+   * If a frame header is located then the state is changed to {@link #STATE_READING_HEADER}, the
+   * first two bytes of the header are written into {@link #headerScratch}, and the position of the
+   * source is advanced to the byte that immediately follows these two bytes.
+   * <p>
+   * If a frame header is not located then the position of the source is advanced to the limit, and
+   * the method should be called again with the next source to continue the search.
+   *
+   * @param source The source from which to read.
+   */
+  private void findHeader(ParsableByteArray source) {
+    byte[] data = source.data;
+    int startOffset = source.getPosition();
+    int endOffset = source.limit();
+    for (int i = startOffset; i < endOffset; i++) {
+      boolean byteIsFF = (data[i] & 0xFF) == 0xFF;
+      boolean found = lastByteWasFF && (data[i] & 0xE0) == 0xE0;
+      lastByteWasFF = byteIsFF;
+      if (found) {
+        source.setPosition(i + 1);
+        // Reset lastByteWasFF for next time.
+        lastByteWasFF = false;
+        headerScratch.data[1] = data[i];
+        frameBytesRead = 2;
+        state = STATE_READING_HEADER;
+        return;
+      }
+    }
+    source.setPosition(endOffset);
+  }
+
+  /**
+   * Attempts to read the remaining two bytes of the frame header.
+   * <p>
+   * If a frame header is read in full then the state is changed to {@link #STATE_READING_FRAME},
+   * the media format is output if this has not previously occurred, the four header bytes are
+   * output as sample data, and the position of the source is advanced to the byte that immediately
+   * follows the header.
+   * <p>
+   * If a frame header is read in full but cannot be parsed then the state is changed to
+   * {@link #STATE_READING_HEADER}.
+   * <p>
+   * If a frame header is not read in full then the position of the source is advanced to the limit,
+   * and the method should be called again with the next source to continue the read.
+   *
+   * @param source The source from which to read.
+   */
+  private void readHeaderRemainder(ParsableByteArray source) {
+    int bytesToRead = Math.min(source.bytesLeft(), HEADER_SIZE - frameBytesRead);
+    source.readBytes(headerScratch.data, frameBytesRead, bytesToRead);
+    frameBytesRead += bytesToRead;
+    if (frameBytesRead < HEADER_SIZE) {
+      // We haven't read the whole header yet.
+      return;
+    }
+
+    headerScratch.setPosition(0);
+    boolean parsedHeader = MpegAudioHeader.populateHeader(headerScratch.readInt(), header);
+    if (!parsedHeader) {
+      // We thought we'd located a frame header, but we hadn't.
+      frameBytesRead = 0;
+      state = STATE_READING_HEADER;
+      return;
+    }
+
+    frameSize = header.frameSize;
+    if (!hasOutputFormat) {
+      frameDurationUs = (C.MICROS_PER_SECOND * header.samplesPerFrame) / header.sampleRate;
+      MediaFormat mediaFormat = MediaFormat.createAudioFormat(header.mimeType,
+          MpegAudioHeader.MAX_FRAME_SIZE_BYTES, C.UNKNOWN_TIME_US, header.channels,
+          header.sampleRate, null);
+      output.format(mediaFormat);
+      hasOutputFormat = true;
+    }
+
+    headerScratch.setPosition(0);
+    output.sampleData(headerScratch, HEADER_SIZE);
+    state = STATE_READING_FRAME;
+  }
+
+  /**
+   * Attempts to read the remainder of the frame.
+   * <p>
+   * If a frame is read in full then true is returned. The frame will have been output, and the
+   * position of the source will have been advanced to the byte that immediately follows the end of
+   * the frame.
+   * <p>
+   * If a frame is not read in full then the position of the source will have been advanced to the
+   * limit, and the method should be called again with the next source to continue the read.
+   *
+   * @param source The source from which to read.
+   */
+  private void readFrameRemainder(ParsableByteArray source) {
+    int bytesToRead = Math.min(source.bytesLeft(), frameSize - frameBytesRead);
+    output.sampleData(source, bytesToRead);
+    frameBytesRead += bytesToRead;
+    if (frameBytesRead < frameSize) {
+      // We haven't read the whole of the frame yet.
+      return;
+    }
+
+    output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, frameSize, 0, null);
+    timeUs += frameDurationUs;
+    frameBytesRead = 0;
+    state = STATE_FINDING_HEADER;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/NalUnitTargetBuffer.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/NalUnitTargetBuffer.java
new file mode 100644
index 0000000000..9b8895082c
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/NalUnitTargetBuffer.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.ts;
+
+import com.google.android.exoplayer.util.Assertions;
+
+import java.util.Arrays;
+
+/**
+ * A buffer that fills itself with data corresponding to a specific NAL unit, as it is
+ * encountered in the stream.
+ */
+/* package */ final class NalUnitTargetBuffer {
+
+  private final int targetType;
+
+  private boolean isFilling;
+  private boolean isCompleted;
+
+  public byte[] nalData;
+  public int nalLength;
+
+  public NalUnitTargetBuffer(int targetType, int initialCapacity) {
+    this.targetType = targetType;
+
+    // Initialize data with a start code in the first three bytes.
+    nalData = new byte[3 + initialCapacity];
+    nalData[2] = 1;
+  }
+
+  /**
+   * Resets the buffer, clearing any data that it holds.
+   */
+  public void reset() {
+    isFilling = false;
+    isCompleted = false;
+  }
+
+  /**
+   * Returns whether the buffer currently holds a complete NAL unit of the target type.
+   */
+  public boolean isCompleted() {
+    return isCompleted;
+  }
+
+  /**
+   * Invoked to indicate that a NAL unit has started.
+   *
+   * @param type The type of the NAL unit.
+   */
+  public void startNalUnit(int type) {
+    Assertions.checkState(!isFilling);
+    isFilling = type == targetType;
+    if (isFilling) {
+      // Skip the three byte start code when writing data.
+      nalLength = 3;
+      isCompleted = false;
+    }
+  }
+
+  /**
+   * Invoked to pass stream data. The data passed should not include the 3 byte start code.
+   *
+   * @param data Holds the data being passed.
+   * @param offset The offset of the data in {@code data}.
+   * @param limit The limit (exclusive) of the data in {@code data}.
+   */
+  public void appendToNalUnit(byte[] data, int offset, int limit) {
+    if (!isFilling) {
+      return;
+    }
+    int readLength = limit - offset;
+    if (nalData.length < nalLength + readLength) {
+      nalData = Arrays.copyOf(nalData, (nalLength + readLength) * 2);
+    }
+    System.arraycopy(data, offset, nalData, nalLength, readLength);
+    nalLength += readLength;
+  }
+
+  /**
+   * Invoked to indicate that a NAL unit has ended.
+   *
+   * @param discardPadding The number of excess bytes that were passed to
+   *     {@link #appendToNalUnit(byte[], int, int)}, which should be discarded.
+   * @return True if the ended NAL unit is of the target type. False otherwise.
+   */
+  public boolean endNalUnit(int discardPadding) {
+    if (!isFilling) {
+      return false;
+    }
+    nalLength -= discardPadding;
+    isFilling = false;
+    isCompleted = true;
+    return true;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/SeiReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/SeiReader.java
index 1bd169d544..3aa57557cc 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/SeiReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/SeiReader.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.extractor.TrackOutput;
 import com.google.android.exoplayer.text.eia608.Eia608Parser;
+import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
 /**
@@ -31,7 +32,7 @@
 
   public SeiReader(TrackOutput output) {
     super(output);
-    output.format(MediaFormat.createEia608Format());
+    output.format(MediaFormat.createTextFormat(MimeTypes.APPLICATION_EIA608));
   }
 
   @Override
@@ -41,9 +42,6 @@ public void seek() {
 
   @Override
   public void consume(ParsableByteArray seiBuffer, long pesTimeUs, boolean startOfPacket) {
-    // Skip the NAL prefix and type.
-    seiBuffer.skipBytes(4);
-
     int b;
     while (seiBuffer.bytesLeft() > 1 /* last byte will be rbsp_trailing_bits */) {
       // Parse payload type.
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
index 684ada760f..9d30be0f0c 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
@@ -42,10 +42,13 @@
   private static final int TS_SYNC_BYTE = 0x47; // First byte of each TS packet.
   private static final int TS_PAT_PID = 0;
 
+  private static final int TS_STREAM_TYPE_MPA = 0x03;
+  private static final int TS_STREAM_TYPE_MPA_LSF = 0x04;
   private static final int TS_STREAM_TYPE_AAC = 0x0F;
   private static final int TS_STREAM_TYPE_ATSC_AC3 = 0x81;
   private static final int TS_STREAM_TYPE_ATSC_E_AC3 = 0x87;
   private static final int TS_STREAM_TYPE_H264 = 0x1B;
+  private static final int TS_STREAM_TYPE_H265 = 0x24;
   private static final int TS_STREAM_TYPE_ID3 = 0x15;
   private static final int TS_STREAM_TYPE_EIA608 = 0x100; // 0xFF + 1
 
@@ -53,6 +56,7 @@
 
   private final ParsableByteArray tsPacketBuffer;
   private final ParsableBitArray tsScratch;
+  private final boolean idrKeyframesOnly;
   private final long firstSampleTimestampUs;
   /* package */ final SparseBooleanArray streamTypes;
   /* package */ final SparseBooleanArray allowedPassthroughStreamTypes;
@@ -65,16 +69,26 @@
   /* package */ Id3Reader id3Reader;
 
   public TsExtractor() {
-    this(0, null);
+    this(0);
+  }
+
+  public TsExtractor(long firstSampleTimestampUs) {
+    this(firstSampleTimestampUs, null);
   }
 
   public TsExtractor(long firstSampleTimestampUs, AudioCapabilities audioCapabilities) {
+    this(firstSampleTimestampUs, audioCapabilities, true);
+  }
+
+  public TsExtractor(long firstSampleTimestampUs, AudioCapabilities audioCapabilities,
+      boolean idrKeyframesOnly) {
     this.firstSampleTimestampUs = firstSampleTimestampUs;
+    this.idrKeyframesOnly = idrKeyframesOnly;
     tsScratch = new ParsableBitArray(new byte[3]);
     tsPacketBuffer = new ParsableByteArray(TS_PACKET_SIZE);
     streamTypes = new SparseBooleanArray();
     allowedPassthroughStreamTypes = getPassthroughStreamTypes(audioCapabilities);
-    tsPayloadReaders = new SparseArray<TsPayloadReader>();
+    tsPayloadReaders = new SparseArray<>();
     tsPayloadReaders.put(TS_PAT_PID, new PatReader());
     lastPts = Long.MIN_VALUE;
   }
@@ -103,6 +117,8 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
       return RESULT_END_OF_INPUT;
     }
 
+    // Note: see ISO/IEC 13818-1, section 2.4.3.2 for detailed information on the format of
+    // the header.
     tsPacketBuffer.setPosition(0);
     tsPacketBuffer.setLimit(TS_PACKET_SIZE);
     int syncByte = tsPacketBuffer.readUnsignedByte();
@@ -292,6 +308,8 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
         data.skipBytes(pointerField);
       }
 
+      // Note: see ISO/IEC 13818-1, section 2.4.4.8 for detailed information on the format of
+      // the header.
       data.readBytes(pmtScratch, 3);
       pmtScratch.skipBits(12); // table_id (8), section_syntax_indicator (1), '0' (1), reserved (2)
       int sectionLength = pmtScratch.readBits(12);
@@ -335,6 +353,12 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
         // TODO: Detect and read DVB AC-3 streams with Ac3Reader.
         ElementaryStreamReader pesPayloadReader = null;
         switch (streamType) {
+          case TS_STREAM_TYPE_MPA:
+            pesPayloadReader = new MpegAudioReader(output.track(TS_STREAM_TYPE_MPA));
+            break;
+          case TS_STREAM_TYPE_MPA_LSF:
+            pesPayloadReader = new MpegAudioReader(output.track(TS_STREAM_TYPE_MPA_LSF));
+            break;
           case TS_STREAM_TYPE_AAC:
             pesPayloadReader = new AdtsReader(output.track(TS_STREAM_TYPE_AAC));
             break;
@@ -346,8 +370,12 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
             pesPayloadReader = new Ac3Reader(output.track(streamType));
             break;
           case TS_STREAM_TYPE_H264:
-            SeiReader seiReader = new SeiReader(output.track(TS_STREAM_TYPE_EIA608));
-            pesPayloadReader = new H264Reader(output.track(TS_STREAM_TYPE_H264), seiReader);
+            pesPayloadReader = new H264Reader(output.track(TS_STREAM_TYPE_H264),
+                new SeiReader(output.track(TS_STREAM_TYPE_EIA608)), idrKeyframesOnly);
+            break;
+          case TS_STREAM_TYPE_H265:
+            pesPayloadReader = new H265Reader(output.track(TS_STREAM_TYPE_H265),
+                new SeiReader(output.track(TS_STREAM_TYPE_EIA608)));
             break;
           case TS_STREAM_TYPE_ID3:
             pesPayloadReader = id3Reader;
@@ -502,6 +530,8 @@ private boolean continueRead(ParsableByteArray source, byte[] target, int target
     }
 
     private boolean parseHeader() {
+      // Note: see ISO/IEC 13818-1, section 2.4.3.6 for detailed information on the format of
+      // the header.
       pesScratch.setPosition(0);
       int startCodePrefix = pesScratch.readBits(24);
       if (startCodePrefix != 0x000001) {
@@ -534,7 +564,7 @@ private void parseHeaderExtension() {
       pesScratch.setPosition(0);
       timeUs = 0;
       if (ptsFlag) {
-        pesScratch.skipBits(4); // '0010'
+        pesScratch.skipBits(4); // '0010' or '0011'
         long pts = (long) pesScratch.readBits(3) << 30;
         pesScratch.skipBits(1); // marker_bit
         pts |= pesScratch.readBits(15) << 15;
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReader.java
index f99c115ec9..83435f0e77 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReader.java
@@ -37,7 +37,7 @@
   private static final int VALID_FLOAT64_ELEMENT_SIZE_BYTES = 8;
 
   private final byte[] scratch = new byte[8];
-  private final Stack<MasterElement> masterElementsStack = new Stack<MasterElement>();
+  private final Stack<MasterElement> masterElementsStack = new Stack<>();
   private final VarintReader varintReader = new VarintReader();
 
   private EbmlReaderOutput output;
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
index f0ed882255..9623e676ea 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
@@ -25,14 +25,20 @@
 import com.google.android.exoplayer.extractor.ExtractorOutput;
 import com.google.android.exoplayer.extractor.PositionHolder;
 import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.LongArray;
 import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.NalUnitUtil;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
+import android.util.Pair;
+
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
 import java.util.concurrent.TimeUnit;
 
 /**
@@ -46,21 +52,27 @@
  */
 public final class WebmExtractor implements Extractor {
 
-  private static final int SAMPLE_STATE_START = 0;
-  private static final int SAMPLE_STATE_HEADER = 1;
-  private static final int SAMPLE_STATE_DATA = 2;
+  private static final int BLOCK_STATE_START = 0;
+  private static final int BLOCK_STATE_HEADER = 1;
+  private static final int BLOCK_STATE_DATA = 2;
 
   private static final int CUES_STATE_NOT_BUILT = 0;
   private static final int CUES_STATE_BUILDING = 1;
   private static final int CUES_STATE_BUILT = 2;
 
   private static final String DOC_TYPE_WEBM = "webm";
+  private static final String DOC_TYPE_MATROSKA = "matroska";
   private static final String CODEC_ID_VP8 = "V_VP8";
   private static final String CODEC_ID_VP9 = "V_VP9";
+  private static final String CODEC_ID_H264 = "V_MPEG4/ISO/AVC";
   private static final String CODEC_ID_VORBIS = "A_VORBIS";
   private static final String CODEC_ID_OPUS = "A_OPUS";
+  private static final String CODEC_ID_AAC = "A_AAC";
+  private static final String CODEC_ID_MP3 = "A_MPEG/L3";
+  private static final String CODEC_ID_AC3 = "A_AC3";
   private static final int VORBIS_MAX_INPUT_SIZE = 8192;
   private static final int OPUS_MAX_INPUT_SIZE = 5760;
+  private static final int MP3_MAX_INPUT_SIZE = 4096;
   private static final int ENCRYPTION_IV_SIZE = 8;
   private static final int TRACK_TYPE_AUDIO = 2;
   private static final int TRACK_TYPE_VIDEO = 1;
@@ -88,6 +100,7 @@
   private static final int ID_TRACK_ENTRY = 0xAE;
   private static final int ID_TRACK_NUMBER = 0xD7;
   private static final int ID_TRACK_TYPE = 0x83;
+  private static final int ID_DEFAULT_DURATION = 0x23E383;
   private static final int ID_CODEC_ID = 0x86;
   private static final int ID_CODEC_PRIVATE = 0x63A2;
   private static final int ID_CODEC_DELAY = 0x56AA;
@@ -102,7 +115,9 @@
   private static final int ID_CONTENT_ENCODING = 0x6240;
   private static final int ID_CONTENT_ENCODING_ORDER = 0x5031;
   private static final int ID_CONTENT_ENCODING_SCOPE = 0x5032;
-  private static final int ID_CONTENT_ENCODING_TYPE = 0x5033;
+  private static final int ID_CONTENT_COMPRESSION = 0x5034;
+  private static final int ID_CONTENT_COMPRESSION_ALGORITHM = 0x4254;
+  private static final int ID_CONTENT_COMPRESSION_SETTINGS = 0x4255;
   private static final int ID_CONTENT_ENCRYPTION = 0x5035;
   private static final int ID_CONTENT_ENCRYPTION_ALGORITHM = 0x47E1;
   private static final int ID_CONTENT_ENCRYPTION_KEY_ID = 0x47E2;
@@ -115,12 +130,20 @@
   private static final int ID_CUE_CLUSTER_POSITION = 0xF1;
 
   private static final int LACING_NONE = 0;
+  private static final int LACING_XIPH = 1;
+  private static final int LACING_FIXED_SIZE = 2;
+  private static final int LACING_EBML = 3;
 
   private final EbmlReader reader;
   private final VarintReader varintReader;
-  private final ParsableByteArray sampleHeaderScratch;
+
+  // Temporary arrays.
+  private final ParsableByteArray nalStartCode;
+  private final ParsableByteArray nalLength;
+  private final ParsableByteArray scratch;
   private final ParsableByteArray vorbisNumPageSamples;
   private final ParsableByteArray seekEntryIdBytes;
+  private final ParsableByteArray sampleStrippedBytes;
 
   private long segmentContentPosition = UNKNOWN;
   private long segmentContentSize = UNKNOWN;
@@ -147,13 +170,22 @@
   private LongArray cueClusterPositions;
   private boolean seenClusterPositionForCurrentCuePoint;
 
+  // Block reading state.
+  private int blockState;
+  private long blockTimeUs;
+  private int blockLacingSampleIndex;
+  private int blockLacingSampleCount;
+  private int[] blockLacingSampleSizes;
+  private int blockTrackNumber;
+  private int blockTrackNumberLength;
+  private int blockFlags;
+  private byte[] blockEncryptionKeyId;
+
   // Sample reading state.
-  private int blockBytesRead;
-  private int sampleState;
-  private int sampleSize;
-  private int sampleTrackNumber;
-  private int sampleFlags;
-  private long sampleTimeUs;
+  private int sampleBytesRead;
+  private boolean sampleEncodingHandled;
+  private int sampleCurrentNalBytesRemaining;
+  private int sampleBytesWritten;
   private boolean sampleRead;
   private boolean sampleSeenReferenceBlock;
 
@@ -168,9 +200,12 @@ public WebmExtractor() {
     this.reader = reader;
     this.reader.init(new InnerEbmlReaderOutput());
     varintReader = new VarintReader();
-    sampleHeaderScratch = new ParsableByteArray(4);
+    scratch = new ParsableByteArray(4);
     vorbisNumPageSamples = new ParsableByteArray(ByteBuffer.allocate(4).putInt(-1).array());
     seekEntryIdBytes = new ParsableByteArray(4);
+    nalStartCode = new ParsableByteArray(NalUnitUtil.NAL_START_CODE);
+    nalLength = new ParsableByteArray(4);
+    sampleStrippedBytes = new ParsableByteArray();
   }
 
   @Override
@@ -181,9 +216,10 @@ public void init(ExtractorOutput output) {
   @Override
   public void seek() {
     clusterTimecodeUs = UNKNOWN;
-    sampleState = SAMPLE_STATE_START;
+    blockState = BLOCK_STATE_START;
     reader.reset();
     varintReader.reset();
+    resetSample();
   }
 
   @Override
@@ -214,6 +250,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       case ID_VIDEO:
       case ID_CONTENT_ENCODINGS:
       case ID_CONTENT_ENCODING:
+      case ID_CONTENT_COMPRESSION:
       case ID_CONTENT_ENCRYPTION:
       case ID_CONTENT_ENCRYPTION_AES_SETTINGS:
       case ID_CUES:
@@ -230,12 +267,13 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       case ID_PIXEL_HEIGHT:
       case ID_TRACK_NUMBER:
       case ID_TRACK_TYPE:
+      case ID_DEFAULT_DURATION:
       case ID_CODEC_DELAY:
       case ID_SEEK_PRE_ROLL:
       case ID_CHANNELS:
       case ID_CONTENT_ENCODING_ORDER:
       case ID_CONTENT_ENCODING_SCOPE:
-      case ID_CONTENT_ENCODING_TYPE:
+      case ID_CONTENT_COMPRESSION_ALGORITHM:
       case ID_CONTENT_ENCRYPTION_ALGORITHM:
       case ID_CONTENT_ENCRYPTION_AES_SETTINGS_CIPHER_MODE:
       case ID_CUE_TIME:
@@ -246,6 +284,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       case ID_CODEC_ID:
         return EbmlReader.TYPE_STRING;
       case ID_SEEK_ID:
+      case ID_CONTENT_COMPRESSION_SETTINGS:
       case ID_CONTENT_ENCRYPTION_KEY_ID:
       case ID_SIMPLE_BLOCK:
       case ID_BLOCK:
@@ -263,7 +302,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       throws ParserException {
     switch (id) {
       case ID_SEGMENT:
-        if (segmentContentPosition != UNKNOWN) {
+        if (segmentContentPosition != UNKNOWN && segmentContentPosition != contentPosition) {
           throw new ParserException("Multiple Segment elements not supported");
         }
         segmentContentPosition = contentPosition;
@@ -323,30 +362,34 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
         }
         return;
       case ID_BLOCK_GROUP:
-        if (sampleState != SAMPLE_STATE_DATA) {
-          // We've skipped this sample (due to incompatible track number).
+        if (blockState != BLOCK_STATE_DATA) {
+          // We've skipped this block (due to incompatible track number).
           return;
         }
         // If the ReferenceBlock element was not found for this sample, then it is a keyframe.
         if (!sampleSeenReferenceBlock) {
-          sampleFlags |= C.SAMPLE_FLAG_SYNC;
+          blockFlags |= C.SAMPLE_FLAG_SYNC;
         }
         outputSampleMetadata(
-            (audioTrackFormat != null && sampleTrackNumber == audioTrackFormat.number)
-                ? audioTrackFormat.trackOutput : videoTrackFormat.trackOutput);
+            (audioTrackFormat != null && blockTrackNumber == audioTrackFormat.number)
+                ? audioTrackFormat.trackOutput : videoTrackFormat.trackOutput, blockTimeUs);
+        blockState = BLOCK_STATE_START;
         return;
       case ID_CONTENT_ENCODING:
-        if (!trackFormat.hasContentEncryption) {
-          // We found a ContentEncoding other than Encryption.
-          throw new ParserException("Found an unsupported ContentEncoding");
-        }
-        if (trackFormat.encryptionKeyId == null) {
-          throw new ParserException("Encrypted Track found but ContentEncKeyID was not found");
+        if (trackFormat.hasContentEncryption) {
+          if (trackFormat.encryptionKeyId == null) {
+            throw new ParserException("Encrypted Track found but ContentEncKeyID was not found");
+          }
+          if (!sentDrmInitData) {
+            extractorOutput.drmInitData(
+                new DrmInitData.Universal(MimeTypes.VIDEO_WEBM, trackFormat.encryptionKeyId));
+            sentDrmInitData = true;
+          }
         }
-        if (!sentDrmInitData) {
-          extractorOutput.drmInitData(
-              new DrmInitData.Universal(MimeTypes.VIDEO_WEBM, trackFormat.encryptionKeyId));
-          sentDrmInitData = true;
+        return;
+      case ID_CONTENT_ENCODINGS:
+        if (trackFormat.hasContentEncryption && trackFormat.sampleStrippedBytes != null) {
+          throw new ParserException("Combining encryption and compression is not supported");
         }
         return;
       case ID_TRACK_ENTRY:
@@ -362,11 +405,11 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
         if (trackFormat.type == TRACK_TYPE_AUDIO && isCodecSupported(trackFormat.codecId)) {
           audioTrackFormat = trackFormat;
           audioTrackFormat.trackOutput = extractorOutput.track(audioTrackFormat.number);
-          audioTrackFormat.trackOutput.format(buildAudioFormat());
+          audioTrackFormat.trackOutput.format(audioTrackFormat.getMediaFormat(durationUs));
         } else if (trackFormat.type == TRACK_TYPE_VIDEO && isCodecSupported(trackFormat.codecId)) {
           videoTrackFormat = trackFormat;
           videoTrackFormat.trackOutput = extractorOutput.track(videoTrackFormat.number);
-          videoTrackFormat.trackOutput.format(buildVideoFormat());
+          videoTrackFormat.trackOutput.format(videoTrackFormat.getMediaFormat(durationUs));
         } else {
           // Unsupported track type. Do nothing.
         }
@@ -417,6 +460,9 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       case ID_TRACK_TYPE:
         trackFormat.type = (int) value;
         return;
+      case ID_DEFAULT_DURATION:
+        trackFormat.defaultSampleDurationNs = (int) value;
+        break;
       case ID_CODEC_DELAY:
         trackFormat.codecDelayNs = value;
         return;
@@ -436,16 +482,15 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
         }
         return;
       case ID_CONTENT_ENCODING_SCOPE:
-        // This extractor only supports the scope of all frames (since that's the only scope used
-        // for Encryption).
+        // This extractor only supports the scope of all frames.
         if (value != 1) {
           throw new ParserException("ContentEncodingScope " + value + " not supported");
         }
         return;
-      case ID_CONTENT_ENCODING_TYPE:
-        // This extractor only supports Encrypted ContentEncodingType.
-        if (value != 1) {
-          throw new ParserException("ContentEncodingType " + value + " not supported");
+      case ID_CONTENT_COMPRESSION_ALGORITHM:
+        // This extractor only supports header stripping.
+        if (value != 3) {
+          throw new ParserException("ContentCompAlgo " + value + " not supported");
         }
         return;
       case ID_CONTENT_ENCRYPTION_ALGORITHM:
@@ -496,8 +541,8 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
   /* package */ void stringElement(int id, String value) throws ParserException {
     switch (id) {
       case ID_DOC_TYPE:
-        // Validate that DocType is supported. This extractor only supports "webm".
-        if (!DOC_TYPE_WEBM.equals(value)) {
+        // Validate that DocType is supported.
+        if (!DOC_TYPE_WEBM.equals(value) && !DOC_TYPE_MATROSKA.equals(value)) {
           throw new ParserException("DocType " + value + " not supported");
         }
         return;
@@ -522,6 +567,11 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
         trackFormat.codecPrivate = new byte[contentSize];
         input.readFully(trackFormat.codecPrivate, 0, contentSize);
         return;
+      case ID_CONTENT_COMPRESSION_SETTINGS:
+        // This extractor only supports header stripping, so the payload is the stripped bytes.
+        trackFormat.sampleStrippedBytes = new byte[contentSize];
+        input.readFully(trackFormat.sampleStrippedBytes, 0, contentSize);
+        return;
       case ID_CONTENT_ENCRYPTION_KEY_ID:
         trackFormat.encryptionKeyId = new byte[contentSize];
         input.readFully(trackFormat.encryptionKeyId, 0, contentSize);
@@ -533,150 +583,285 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
         // for info about how data is organized in SimpleBlock and Block elements respectively. They
         // differ only in the way flags are specified.
 
-        if (sampleState == SAMPLE_STATE_START) {
-          sampleTrackNumber = (int) varintReader.readUnsignedVarint(input, false, true);
-          blockBytesRead = varintReader.getLastLength();
-          sampleState = SAMPLE_STATE_HEADER;
+        if (blockState == BLOCK_STATE_START) {
+          blockTrackNumber = (int) varintReader.readUnsignedVarint(input, false, true);
+          blockTrackNumberLength = varintReader.getLastLength();
+          blockState = BLOCK_STATE_HEADER;
+          scratch.reset();
         }
 
-        // Ignore the frame if the track number equals neither the audio track nor the video track.
+        // Ignore the block if the track number equals neither the audio track nor the video track.
         if ((audioTrackFormat != null && videoTrackFormat != null
-                && audioTrackFormat.number != sampleTrackNumber
-                && videoTrackFormat.number != sampleTrackNumber)
+                && audioTrackFormat.number != blockTrackNumber
+                && videoTrackFormat.number != blockTrackNumber)
             || (audioTrackFormat != null && videoTrackFormat == null
-                && audioTrackFormat.number != sampleTrackNumber)
+                && audioTrackFormat.number != blockTrackNumber)
             || (audioTrackFormat == null && videoTrackFormat != null
-                && videoTrackFormat.number != sampleTrackNumber)) {
-          input.skipFully(contentSize - blockBytesRead);
-          sampleState = SAMPLE_STATE_START;
+                && videoTrackFormat.number != blockTrackNumber)) {
+          input.skipFully(contentSize - blockTrackNumberLength);
+          blockState = BLOCK_STATE_START;
           return;
         }
 
         TrackFormat sampleTrackFormat =
-            (audioTrackFormat != null && sampleTrackNumber == audioTrackFormat.number)
+            (audioTrackFormat != null && blockTrackNumber == audioTrackFormat.number)
                 ? audioTrackFormat : videoTrackFormat;
         TrackOutput trackOutput = sampleTrackFormat.trackOutput;
 
-        if (sampleState == SAMPLE_STATE_HEADER) {
-          byte[] sampleHeaderScratchData = sampleHeaderScratch.data;
-          // Next 3 bytes have timecode and flags. If encrypted, the 4th byte is a signal byte.
-          int remainingHeaderLength = sampleTrackFormat.hasContentEncryption ? 4 : 3;
-          input.readFully(sampleHeaderScratchData, 0, remainingHeaderLength);
-          blockBytesRead += remainingHeaderLength;
-
-          // First two bytes are the relative timecode.
-          int timecode = (sampleHeaderScratchData[0] << 8)
-              | (sampleHeaderScratchData[1] & 0xFF);
-          sampleTimeUs = clusterTimecodeUs + scaleTimecodeToUs(timecode);
-
-          // Third byte contains the lacing value and some flags.
-          int lacing = (sampleHeaderScratchData[2] & 0x06) >> 1;
-          if (lacing != LACING_NONE) {
-            throw new ParserException("Lacing mode not supported: " + lacing);
-          }
-          boolean isInvisible = (sampleHeaderScratchData[2] & 0x08) == 0x08;
-          boolean isKeyframe =
-              (id == ID_SIMPLE_BLOCK && (sampleHeaderScratchData[2] & 0x80) == 0x80);
-          boolean isEncrypted = false;
-
-          // If encrypted, the fourth byte is an encryption signal byte.
-          if (sampleTrackFormat.hasContentEncryption) {
-            if ((sampleHeaderScratchData[3] & 0x80) == 0x80) {
-              throw new ParserException("Extension bit is set in signal byte");
+        if (blockState == BLOCK_STATE_HEADER) {
+          // Read the relative timecode (2 bytes) and flags (1 byte).
+          readScratch(input, 3);
+          int lacing = (scratch.data[2] & 0x06) >> 1;
+          if (lacing == LACING_NONE) {
+            blockLacingSampleCount = 1;
+            blockLacingSampleSizes = ensureArrayCapacity(blockLacingSampleSizes, 1);
+            blockLacingSampleSizes[0] = contentSize - blockTrackNumberLength - 3;
+          } else {
+            if (id != ID_SIMPLE_BLOCK) {
+              throw new ParserException("Lacing only supported in SimpleBlocks.");
             }
-            isEncrypted = (sampleHeaderScratchData[3] & 0x01) == 0x01;
-          }
 
-          sampleFlags = (isKeyframe ? C.SAMPLE_FLAG_SYNC : 0)
-              | (isInvisible ? C.SAMPLE_FLAG_DECODE_ONLY : 0)
-              | (isEncrypted ? C.SAMPLE_FLAG_ENCRYPTED : 0);
-          sampleSize = contentSize - blockBytesRead;
-          if (isEncrypted) {
-            // Write the vector size.
-            sampleHeaderScratch.data[0] = (byte) ENCRYPTION_IV_SIZE;
-            sampleHeaderScratch.setPosition(0);
-            trackOutput.sampleData(sampleHeaderScratch, 1);
-            sampleSize++;
+            // Read the sample count (1 byte).
+            readScratch(input, 4);
+            blockLacingSampleCount = (scratch.data[3] & 0xFF) + 1;
+            blockLacingSampleSizes =
+                ensureArrayCapacity(blockLacingSampleSizes, blockLacingSampleCount);
+            if (lacing == LACING_FIXED_SIZE) {
+              int blockLacingSampleSize =
+                  (contentSize - blockTrackNumberLength - 4) / blockLacingSampleCount;
+              Arrays.fill(blockLacingSampleSizes, 0, blockLacingSampleCount, blockLacingSampleSize);
+            } else if (lacing == LACING_XIPH) {
+              int totalSamplesSize = 0;
+              int headerSize = 4;
+              for (int sampleIndex = 0; sampleIndex < blockLacingSampleCount - 1; sampleIndex++) {
+                blockLacingSampleSizes[sampleIndex] = 0;
+                int byteValue;
+                do {
+                  readScratch(input, ++headerSize);
+                  byteValue = scratch.data[headerSize - 1] & 0xFF;
+                  blockLacingSampleSizes[sampleIndex] += byteValue;
+                } while (byteValue == 0xFF);
+                totalSamplesSize += blockLacingSampleSizes[sampleIndex];
+              }
+              blockLacingSampleSizes[blockLacingSampleCount - 1] =
+                  contentSize - blockTrackNumberLength - headerSize - totalSamplesSize;
+            } else if (lacing == LACING_EBML) {
+              int totalSamplesSize = 0;
+              int headerSize = 4;
+              for (int sampleIndex = 0; sampleIndex < blockLacingSampleCount - 1; sampleIndex++) {
+                blockLacingSampleSizes[sampleIndex] = 0;
+                readScratch(input, ++headerSize);
+                if (scratch.data[headerSize - 1] == 0) {
+                  throw new ParserException("No valid varint length mask found");
+                }
+                long readValue = 0;
+                for (int i = 0; i < 8; i++) {
+                  int lengthMask = 1 << (7 - i);
+                  if ((scratch.data[headerSize - 1] & lengthMask) != 0) {
+                    int readPosition = headerSize - 1;
+                    headerSize += i;
+                    readScratch(input, headerSize);
+                    readValue = (scratch.data[readPosition++] & 0xFF) & ~lengthMask;
+                    while (readPosition < headerSize) {
+                      readValue <<= 8;
+                      readValue |= (scratch.data[readPosition++] & 0xFF);
+                    }
+                    // The first read value is the first size. Later values are signed offsets.
+                    if (sampleIndex > 0) {
+                      readValue -= (1L << 6 + i * 7) - 1;
+                    }
+                    break;
+                  }
+                }
+                if (readValue < Integer.MIN_VALUE || readValue > Integer.MAX_VALUE) {
+                  throw new ParserException("EBML lacing sample size out of range.");
+                }
+                int intReadValue = (int) readValue;
+                blockLacingSampleSizes[sampleIndex] = sampleIndex == 0
+                    ? intReadValue : blockLacingSampleSizes[sampleIndex - 1] + intReadValue;
+                totalSamplesSize += blockLacingSampleSizes[sampleIndex];
+              }
+              blockLacingSampleSizes[blockLacingSampleCount - 1] =
+                  contentSize - blockTrackNumberLength - headerSize - totalSamplesSize;
+            } else {
+              // Lacing is always in the range 0--3.
+              throw new IllegalStateException("Unexpected lacing value: " + lacing);
+            }
           }
-          sampleState = SAMPLE_STATE_DATA;
-        }
-
-        while (blockBytesRead < contentSize) {
-          blockBytesRead += trackOutput.sampleData(input, contentSize - blockBytesRead);
-        }
 
-        if (CODEC_ID_VORBIS.equals(sampleTrackFormat.codecId)) {
-          // Vorbis decoder in android MediaCodec [1] expects the last 4 bytes of the sample to be
-          // the number of samples in the current page. This definition holds good only for Ogg and
-          // irrelevant for WebM. So we always set this to -1 (the decoder will ignore this value if
-          // we set it to -1). The android platform media extractor [2] does the same.
-          // [1] https://android.googlesource.com/platform/frameworks/av/+/lollipop-release/media/libstagefright/codecs/vorbis/dec/SoftVorbis.cpp#314
-          // [2] https://android.googlesource.com/platform/frameworks/av/+/lollipop-release/media/libstagefright/NuMediaExtractor.cpp#474
-          vorbisNumPageSamples.setPosition(0);
-          trackOutput.sampleData(vorbisNumPageSamples, 4);
-          sampleSize += 4;
+          int timecode = (scratch.data[0] << 8) | (scratch.data[1] & 0xFF);
+          blockTimeUs = clusterTimecodeUs + scaleTimecodeToUs(timecode);
+          boolean isInvisible = (scratch.data[2] & 0x08) == 0x08;
+          boolean isKeyframe = (id == ID_SIMPLE_BLOCK && (scratch.data[2] & 0x80) == 0x80);
+          blockFlags = (isKeyframe ? C.SAMPLE_FLAG_SYNC : 0)
+              | (isInvisible ? C.SAMPLE_FLAG_DECODE_ONLY : 0);
+          blockEncryptionKeyId = sampleTrackFormat.encryptionKeyId;
+          blockState = BLOCK_STATE_DATA;
+          blockLacingSampleIndex = 0;
         }
 
-        // For SimpleBlock, we send the metadata here as we have all the information. For Block, we
-        // send the metadata at the end of the BlockGroup element since we'll know if the frame is a
-        // keyframe or not only at that point.
         if (id == ID_SIMPLE_BLOCK) {
-          outputSampleMetadata(trackOutput);
+          // For SimpleBlock, we have metadata for each sample here.
+          while (blockLacingSampleIndex < blockLacingSampleCount) {
+            writeSampleData(input, trackOutput, sampleTrackFormat,
+                blockLacingSampleSizes[blockLacingSampleIndex]);
+            long sampleTimeUs = this.blockTimeUs
+                + (blockLacingSampleIndex * sampleTrackFormat.defaultSampleDurationNs) / 1000;
+            outputSampleMetadata(trackOutput, sampleTimeUs);
+            blockLacingSampleIndex++;
+          }
+          blockState = BLOCK_STATE_START;
+        } else {
+          // For Block, we send the metadata at the end of the BlockGroup element since we'll know
+          // if the sample is a keyframe or not only at that point.
+          writeSampleData(input, trackOutput, sampleTrackFormat, blockLacingSampleSizes[0]);
         }
+
         return;
       default:
-        throw new IllegalStateException("Unexpected id: " + id);
+        throw new ParserException("Unexpected id: " + id);
     }
   }
 
-  private void outputSampleMetadata(TrackOutput trackOutput) {
-    trackOutput.sampleMetadata(sampleTimeUs, sampleFlags, sampleSize, 0, null);
-    sampleState = SAMPLE_STATE_START;
+  private void outputSampleMetadata(TrackOutput trackOutput, long timeUs) {
+    trackOutput.sampleMetadata(timeUs, blockFlags, sampleBytesWritten, 0, blockEncryptionKeyId);
     sampleRead = true;
+    resetSample();
+  }
+
+  private void resetSample() {
+    sampleBytesRead = 0;
+    sampleBytesWritten = 0;
+    sampleCurrentNalBytesRemaining = 0;
+    sampleEncodingHandled = false;
+    sampleStrippedBytes.reset();
   }
 
   /**
-   * Builds an video {@link MediaFormat} containing recently gathered Video information.
-   *
-   * @return The built {@link MediaFormat}.
-   * @throws ParserException If the codec is unsupported.
+   * Ensures {@link #scratch} contains at least {@code requiredLength} bytes of data, reading from
+   * the extractor input if necessary.
    */
-  private MediaFormat buildVideoFormat() throws ParserException {
-    if (videoTrackFormat != null && CODEC_ID_VP8.equals(videoTrackFormat.codecId)) {
-      return MediaFormat.createVideoFormat(MimeTypes.VIDEO_VP8, MediaFormat.NO_VALUE, durationUs,
-          videoTrackFormat.pixelWidth, videoTrackFormat.pixelHeight, null);
-    } else if (videoTrackFormat != null && CODEC_ID_VP9.equals(videoTrackFormat.codecId)) {
-      return MediaFormat.createVideoFormat(MimeTypes.VIDEO_VP9, MediaFormat.NO_VALUE, durationUs,
-          videoTrackFormat.pixelWidth, videoTrackFormat.pixelHeight, null);
+  private void readScratch(ExtractorInput input, int requiredLength)
+      throws IOException, InterruptedException {
+    if (scratch.limit() >= requiredLength) {
+      return;
+    }
+    if (scratch.capacity() < requiredLength) {
+      scratch.reset(Arrays.copyOf(scratch.data, Math.max(scratch.data.length * 2, requiredLength)),
+          scratch.limit());
+    }
+    input.readFully(scratch.data, scratch.limit(), requiredLength - scratch.limit());
+    scratch.setLimit(requiredLength);
+  }
+
+  private void writeSampleData(ExtractorInput input, TrackOutput output, TrackFormat format,
+      int size) throws IOException, InterruptedException {
+    if (!sampleEncodingHandled) {
+      if (format.hasContentEncryption) {
+        // If the sample is encrypted, read its encryption signal byte and set the IV size.
+        // Clear the encrypted flag.
+        blockFlags &= ~C.SAMPLE_FLAG_ENCRYPTED;
+        input.readFully(scratch.data, 0, 1);
+        sampleBytesRead++;
+        if ((scratch.data[0] & 0x80) == 0x80) {
+          throw new ParserException("Extension bit is set in signal byte");
+        }
+        if ((scratch.data[0] & 0x01) == 0x01) {
+          scratch.data[0] = (byte) ENCRYPTION_IV_SIZE;
+          scratch.setPosition(0);
+          output.sampleData(scratch, 1);
+          sampleBytesWritten++;
+          blockFlags |= C.SAMPLE_FLAG_ENCRYPTED;
+        }
+      } else if (format.sampleStrippedBytes != null) {
+        // If the sample has header stripping, prepare to read/output the stripped bytes first.
+        sampleStrippedBytes.reset(format.sampleStrippedBytes, format.sampleStrippedBytes.length);
+      }
+      sampleEncodingHandled = true;
+    }
+    size += sampleStrippedBytes.limit();
+
+    if (CODEC_ID_H264.equals(format.codecId)) {
+      // TODO: Deduplicate with Mp4Extractor.
+
+      // Zero the top three bytes of the array that we'll use to parse nal unit lengths, in case
+      // they're only 1 or 2 bytes long.
+      byte[] nalLengthData = nalLength.data;
+      nalLengthData[0] = 0;
+      nalLengthData[1] = 0;
+      nalLengthData[2] = 0;
+      int nalUnitLengthFieldLength = format.nalUnitLengthFieldLength;
+      int nalUnitLengthFieldLengthDiff = 4 - format.nalUnitLengthFieldLength;
+      // NAL units are length delimited, but the decoder requires start code delimited units.
+      // Loop until we've written the sample to the track output, replacing length delimiters with
+      // start codes as we encounter them.
+      while (sampleBytesRead < size) {
+        if (sampleCurrentNalBytesRemaining == 0) {
+          // Read the NAL length so that we know where we find the next one.
+          readToTarget(input, nalLengthData, nalUnitLengthFieldLengthDiff,
+              nalUnitLengthFieldLength);
+          nalLength.setPosition(0);
+          sampleCurrentNalBytesRemaining = nalLength.readUnsignedIntToInt();
+          // Write a start code for the current NAL unit.
+          nalStartCode.setPosition(0);
+          output.sampleData(nalStartCode, 4);
+          sampleBytesWritten += 4;
+        } else {
+          // Write the payload of the NAL unit.
+          sampleCurrentNalBytesRemaining -=
+              readToOutput(input, output, sampleCurrentNalBytesRemaining);
+        }
+      }
     } else {
-      throw new ParserException("Unable to build format");
+      while (sampleBytesRead < size) {
+        readToOutput(input, output, size - sampleBytesRead);
+      }
+    }
+
+    if (CODEC_ID_VORBIS.equals(format.codecId)) {
+      // Vorbis decoder in android MediaCodec [1] expects the last 4 bytes of the sample to be the
+      // number of samples in the current page. This definition holds good only for Ogg and
+      // irrelevant for WebM. So we always set this to -1 (the decoder will ignore this value if we
+      // set it to -1). The android platform media extractor [2] does the same.
+      // [1] https://android.googlesource.com/platform/frameworks/av/+/lollipop-release/media/libstagefright/codecs/vorbis/dec/SoftVorbis.cpp#314
+      // [2] https://android.googlesource.com/platform/frameworks/av/+/lollipop-release/media/libstagefright/NuMediaExtractor.cpp#474
+      vorbisNumPageSamples.setPosition(0);
+      output.sampleData(vorbisNumPageSamples, 4);
+      sampleBytesWritten += 4;
     }
   }
 
   /**
-   * Builds an audio {@link MediaFormat} containing recently gathered Audio information.
-   *
-   * @return The built {@link MediaFormat}.
-   * @throws ParserException If the codec is unsupported.
+   * Writes {@code length} bytes of sample data into {@code target} at {@code offset}, consisting of
+   * pending {@link #sampleStrippedBytes} and any remaining data read from {@code input}.
+   */
+  private void readToTarget(ExtractorInput input, byte[] target, int offset, int length)
+      throws IOException, InterruptedException {
+    int pendingStrippedBytes = Math.min(length, sampleStrippedBytes.bytesLeft());
+    input.readFully(target, offset + pendingStrippedBytes, length - pendingStrippedBytes);
+    if (pendingStrippedBytes > 0) {
+      sampleStrippedBytes.readBytes(target, offset, pendingStrippedBytes);
+    }
+    sampleBytesRead += length;
+  }
+
+  /**
+   * Outputs up to {@code length} bytes of sample data to {@code output}, consisting of either
+   * {@link #sampleStrippedBytes} or data read from {@code input}.
    */
-  private MediaFormat buildAudioFormat() throws ParserException {
-    if (audioTrackFormat != null && CODEC_ID_VORBIS.equals(audioTrackFormat.codecId)) {
-      return MediaFormat.createAudioFormat(MimeTypes.AUDIO_VORBIS, VORBIS_MAX_INPUT_SIZE,
-          durationUs, audioTrackFormat.channelCount, audioTrackFormat.sampleRate,
-          parseVorbisCodecPrivate());
-    } else if (audioTrackFormat != null && CODEC_ID_OPUS.equals(audioTrackFormat.codecId)) {
-      ArrayList<byte[]> opusInitializationData = new ArrayList<byte[]>(3);
-      opusInitializationData.add(audioTrackFormat.codecPrivate);
-      opusInitializationData.add(
-          ByteBuffer.allocate(Long.SIZE).putLong(audioTrackFormat.codecDelayNs).array());
-      opusInitializationData.add(
-          ByteBuffer.allocate(Long.SIZE).putLong(audioTrackFormat.seekPreRollNs).array());
-      return MediaFormat.createAudioFormat(MimeTypes.AUDIO_OPUS, OPUS_MAX_INPUT_SIZE,
-          durationUs, audioTrackFormat.channelCount, audioTrackFormat.sampleRate,
-          opusInitializationData);
+  private int readToOutput(ExtractorInput input, TrackOutput output, int length)
+      throws IOException, InterruptedException {
+    int bytesRead;
+    int strippedBytesLeft = sampleStrippedBytes.bytesLeft();
+    if (strippedBytesLeft > 0) {
+      bytesRead = Math.min(length, strippedBytesLeft);
+      output.sampleData(sampleStrippedBytes, bytesRead);
     } else {
-      throw new ParserException("Unable to build format");
+      bytesRead = output.sampleData(input, length);
     }
+    sampleBytesRead += bytesRead;
+    sampleBytesWritten += bytesRead;
+    return bytesRead;
   }
 
   /**
@@ -715,57 +900,6 @@ private ChunkIndex buildCues() throws ParserException {
     return new ChunkIndex(sizes, offsets, durationsUs, timesUs);
   }
 
-  /**
-   * Builds initialization data for a {@link MediaFormat} from Vorbis codec private data.
-   *
-   * @return The initialization data for the {@link MediaFormat}.
-   * @throws ParserException If the initialization data could not be built.
-   */
-  private ArrayList<byte[]> parseVorbisCodecPrivate() throws ParserException {
-    try {
-      byte[] codecPrivate = audioTrackFormat.codecPrivate;
-      if (codecPrivate[0] != 0x02) {
-        throw new ParserException("Error parsing vorbis codec private");
-      }
-      int offset = 1;
-      int vorbisInfoLength = 0;
-      while (codecPrivate[offset] == (byte) 0xFF) {
-        vorbisInfoLength += 0xFF;
-        offset++;
-      }
-      vorbisInfoLength += codecPrivate[offset++];
-
-      int vorbisSkipLength = 0;
-      while (codecPrivate[offset] == (byte) 0xFF) {
-        vorbisSkipLength += 0xFF;
-        offset++;
-      }
-      vorbisSkipLength += codecPrivate[offset++];
-
-      if (codecPrivate[offset] != 0x01) {
-        throw new ParserException("Error parsing vorbis codec private");
-      }
-      byte[] vorbisInfo = new byte[vorbisInfoLength];
-      System.arraycopy(codecPrivate, offset, vorbisInfo, 0, vorbisInfoLength);
-      offset += vorbisInfoLength;
-      if (codecPrivate[offset] != 0x03) {
-        throw new ParserException("Error parsing vorbis codec private");
-      }
-      offset += vorbisSkipLength;
-      if (codecPrivate[offset] != 0x05) {
-        throw new ParserException("Error parsing vorbis codec private");
-      }
-      byte[] vorbisBooks = new byte[codecPrivate.length - offset];
-      System.arraycopy(codecPrivate, offset, vorbisBooks, 0, codecPrivate.length - offset);
-      ArrayList<byte[]> initializationData = new ArrayList<byte[]>(2);
-      initializationData.add(vorbisInfo);
-      initializationData.add(vorbisBooks);
-      return initializationData;
-    } catch (ArrayIndexOutOfBoundsException e) {
-      throw new ParserException("Error parsing vorbis codec private");
-    }
-  }
-
   /**
    * Updates the position of the holder to Cues element's position if the extractor configuration
    * permits use of master seek entry. After building Cues sets the holder's position back to where
@@ -797,11 +931,30 @@ private long scaleTimecodeToUs(long unscaledTimecode) {
     return TimeUnit.NANOSECONDS.toMicros(unscaledTimecode * timecodeScale);
   }
 
-  private boolean isCodecSupported(String codecId) {
+  private static boolean isCodecSupported(String codecId) {
     return CODEC_ID_VP8.equals(codecId)
         || CODEC_ID_VP9.equals(codecId)
+        || CODEC_ID_H264.equals(codecId)
         || CODEC_ID_OPUS.equals(codecId)
-        || CODEC_ID_VORBIS.equals(codecId);
+        || CODEC_ID_VORBIS.equals(codecId)
+        || CODEC_ID_AAC.equals(codecId)
+        || CODEC_ID_MP3.equals(codecId)
+        || CODEC_ID_AC3.equals(codecId);
+  }
+
+  /**
+   * Returns an array that can store (at least) {@code length} elements, which will be either a new
+   * array or {@code array} if it's not null and large enough.
+   */
+  private static int[] ensureArrayCapacity(int[] array, int length) {
+    if (array == null) {
+      return new int[length];
+    } else if (array.length >= length) {
+      return array;
+    } else {
+      // Double the size to avoid allocating constantly if the required length increases gradually.
+      return new int[Math.max(array.length * 2, length)];
+    }
   }
 
   /**
@@ -854,22 +1007,162 @@ public void binaryElement(int id, int contentsSize, ExtractorInput input)
     public String codecId;
     public int number = UNKNOWN;
     public int type = UNKNOWN;
+    public int defaultSampleDurationNs = UNKNOWN;
     public boolean hasContentEncryption;
+    public byte[] sampleStrippedBytes;
     public byte[] encryptionKeyId;
+    public byte[] codecPrivate;
 
     // Video track related elements.
     public int pixelWidth = UNKNOWN;
     public int pixelHeight = UNKNOWN;
+    public int nalUnitLengthFieldLength = UNKNOWN;
 
     // Audio track related elements.
     public int channelCount = UNKNOWN;
     public int sampleRate = UNKNOWN;
-    public byte[] codecPrivate;
     public long codecDelayNs = UNKNOWN;
     public long seekPreRollNs = UNKNOWN;
 
     public TrackOutput trackOutput;
 
+    /** Returns a {@link MediaFormat} built using the information in this instance. */
+    public MediaFormat getMediaFormat(long durationUs) throws ParserException {
+      String mimeType;
+      List<byte[]> initializationData = null;
+      int maxInputSize = UNKNOWN;
+      switch (codecId) {
+        case CODEC_ID_VP8:
+          mimeType = MimeTypes.VIDEO_VP8;
+          break;
+        case CODEC_ID_VP9:
+          mimeType = MimeTypes.VIDEO_VP9;
+          break;
+        case CODEC_ID_H264:
+          mimeType = MimeTypes.VIDEO_H264;
+          Pair<List<byte[]>, Integer> h264Data = parseH264CodecPrivate(
+              new ParsableByteArray(codecPrivate));
+          initializationData = h264Data.first;
+          nalUnitLengthFieldLength = h264Data.second;
+          break;
+        case CODEC_ID_VORBIS:
+          mimeType = MimeTypes.AUDIO_VORBIS;
+          maxInputSize = VORBIS_MAX_INPUT_SIZE;
+          initializationData = parseVorbisCodecPrivate(codecPrivate);
+          break;
+        case CODEC_ID_OPUS:
+          mimeType = MimeTypes.AUDIO_OPUS;
+          maxInputSize = OPUS_MAX_INPUT_SIZE;
+          initializationData = new ArrayList<>(3);
+          initializationData.add(codecPrivate);
+          initializationData.add(ByteBuffer.allocate(Long.SIZE).putLong(codecDelayNs).array());
+          initializationData.add(ByteBuffer.allocate(Long.SIZE).putLong(seekPreRollNs).array());
+          break;
+        case CODEC_ID_AAC:
+          mimeType = MimeTypes.AUDIO_AAC;
+          initializationData = Collections.singletonList(codecPrivate);
+          break;
+        case CODEC_ID_MP3:
+          maxInputSize = MP3_MAX_INPUT_SIZE;
+          mimeType = MimeTypes.AUDIO_MPEG;
+          break;
+        case CODEC_ID_AC3:
+          mimeType = MimeTypes.AUDIO_AC3;
+          break;
+        default:
+          throw new ParserException("Unrecognized codec identifier.");
+      }
+
+      if (MimeTypes.isAudio(mimeType)) {
+        return MediaFormat.createAudioFormat(mimeType, maxInputSize, durationUs, channelCount,
+            sampleRate, initializationData);
+      } else if (MimeTypes.isVideo(mimeType)) {
+        return MediaFormat.createVideoFormat(mimeType, maxInputSize, durationUs, pixelWidth,
+            pixelHeight, initializationData);
+      } else {
+        throw new ParserException("Unexpected MIME type.");
+      }
+    }
+
+    /**
+     * Builds initialization data for a {@link MediaFormat} from H.264 codec private data.
+     *
+     * @return The initialization data for the {@link MediaFormat}.
+     * @throws ParserException If the initialization data could not be built.
+     */
+    private static Pair<List<byte[]>, Integer> parseH264CodecPrivate(ParsableByteArray buffer)
+        throws ParserException {
+      try {
+        // TODO: Deduplicate with AtomParsers.parseAvcCFromParent.
+        buffer.setPosition(4);
+        int nalUnitLengthFieldLength = (buffer.readUnsignedByte() & 0x03) + 1;
+        Assertions.checkState(nalUnitLengthFieldLength != 3);
+        List<byte[]> initializationData = new ArrayList<>();
+        int numSequenceParameterSets = buffer.readUnsignedByte() & 0x1F;
+        for (int i = 0; i < numSequenceParameterSets; i++) {
+          initializationData.add(NalUnitUtil.parseChildNalUnit(buffer));
+        }
+        int numPictureParameterSets = buffer.readUnsignedByte();
+        for (int j = 0; j < numPictureParameterSets; j++) {
+          initializationData.add(NalUnitUtil.parseChildNalUnit(buffer));
+        }
+        return Pair.create(initializationData, nalUnitLengthFieldLength);
+      } catch (ArrayIndexOutOfBoundsException e) {
+        throw new ParserException("Error parsing vorbis codec private");
+      }
+    }
+
+    /**
+     * Builds initialization data for a {@link MediaFormat} from Vorbis codec private data.
+     *
+     * @return The initialization data for the {@link MediaFormat}.
+     * @throws ParserException If the initialization data could not be built.
+     */
+    private static List<byte[]> parseVorbisCodecPrivate(byte[] codecPrivate)
+        throws ParserException {
+      try {
+        if (codecPrivate[0] != 0x02) {
+          throw new ParserException("Error parsing vorbis codec private");
+        }
+        int offset = 1;
+        int vorbisInfoLength = 0;
+        while (codecPrivate[offset] == (byte) 0xFF) {
+          vorbisInfoLength += 0xFF;
+          offset++;
+        }
+        vorbisInfoLength += codecPrivate[offset++];
+
+        int vorbisSkipLength = 0;
+        while (codecPrivate[offset] == (byte) 0xFF) {
+          vorbisSkipLength += 0xFF;
+          offset++;
+        }
+        vorbisSkipLength += codecPrivate[offset++];
+
+        if (codecPrivate[offset] != 0x01) {
+          throw new ParserException("Error parsing vorbis codec private");
+        }
+        byte[] vorbisInfo = new byte[vorbisInfoLength];
+        System.arraycopy(codecPrivate, offset, vorbisInfo, 0, vorbisInfoLength);
+        offset += vorbisInfoLength;
+        if (codecPrivate[offset] != 0x03) {
+          throw new ParserException("Error parsing vorbis codec private");
+        }
+        offset += vorbisSkipLength;
+        if (codecPrivate[offset] != 0x05) {
+          throw new ParserException("Error parsing vorbis codec private");
+        }
+        byte[] vorbisBooks = new byte[codecPrivate.length - offset];
+        System.arraycopy(codecPrivate, offset, vorbisBooks, 0, codecPrivate.length - offset);
+        List<byte[]> initializationData = new ArrayList<>(2);
+        initializationData.add(vorbisInfo);
+        initializationData.add(vorbisBooks);
+        return initializationData;
+      } catch (ArrayIndexOutOfBoundsException e) {
+        throw new ParserException("Error parsing vorbis codec private");
+      }
+    }
+
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
index 2873dfcad0..6816f77c20 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java
@@ -43,7 +43,7 @@
 import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
+import java.util.Comparator;
 import java.util.List;
 import java.util.Locale;
 
@@ -117,8 +117,6 @@
 
   private final DataSource dataSource;
   private final HlsPlaylistParser playlistParser;
-  private final List<Variant> variants;
-  private final Format[] enabledFormats;
   private final BandwidthMeter bandwidthMeter;
   private final int adaptiveMode;
   private final String baseUri;
@@ -128,14 +126,21 @@
   private final long maxBufferDurationToSwitchDownUs;
   private final AudioCapabilities audioCapabilities;
 
-  /* package */ byte[] scratchSpace;
-  /* package */ final HlsMediaPlaylist[] mediaPlaylists;
-  /* package */ final long[] mediaPlaylistBlacklistTimesMs;
-  /* package */ final long[] lastMediaPlaylistLoadTimesMs;
-  /* package */ boolean live;
-  /* package */ long durationUs;
+  // A list of variants considered during playback, ordered by decreasing bandwidth. The following
+  // three arrays are of the same length and are ordered in the same way (i.e. variantPlaylists[i],
+  // variantLastPlaylistLoadTimesMs[i] and variantBlacklistTimes[i] all correspond to variants[i]).
+  private final Variant[] variants;
+  private final HlsMediaPlaylist[] variantPlaylists;
+  private final long[] variantLastPlaylistLoadTimesMs;
+  private final long[] variantBlacklistTimes;
+
+  // The index in variants of the currently selected variant.
+  private int selectedVariantIndex;
+
+  private byte[] scratchSpace;
+  private boolean live;
+  private long durationUs;
 
-  private int formatIndex;
   private Uri encryptionKeyUri;
   private byte[] encryptionKey;
   private String encryptionIvString;
@@ -181,38 +186,45 @@ public HlsChunkSource(DataSource dataSource, String playlistUrl, HlsPlaylist pla
     playlistParser = new HlsPlaylistParser();
 
     if (playlist.type == HlsPlaylist.TYPE_MEDIA) {
-      variants = Collections.singletonList(new Variant(0, playlistUrl, 0, null, -1, -1));
-      variantIndices = null;
-      mediaPlaylists = new HlsMediaPlaylist[1];
-      mediaPlaylistBlacklistTimesMs = new long[1];
-      lastMediaPlaylistLoadTimesMs = new long[1];
+      variants = new Variant[] {new Variant(0, playlistUrl, 0, null, -1, -1)};
+      variantPlaylists = new HlsMediaPlaylist[1];
+      variantLastPlaylistLoadTimesMs = new long[1];
+      variantBlacklistTimes = new long[1];
       setMediaPlaylist(0, (HlsMediaPlaylist) playlist);
+      // We won't be adapting between different variants.
+      maxWidth = -1;
+      maxHeight = -1;
     } else {
-      variants = ((HlsMasterPlaylist) playlist).variants;
-      int variantCount = variants.size();
-      mediaPlaylists = new HlsMediaPlaylist[variantCount];
-      mediaPlaylistBlacklistTimesMs = new long[variantCount];
-      lastMediaPlaylistLoadTimesMs = new long[variantCount];
-    }
-
-    enabledFormats = buildEnabledFormats(variants, variantIndices);
-
-    int maxWidth = -1;
-    int maxHeight = -1;
-    // Select the first variant from the master playlist that's enabled.
-    int minEnabledVariantIndex = Integer.MAX_VALUE;
-    for (int i = 0; i < enabledFormats.length; i++) {
-      int variantIndex = getVariantIndex(enabledFormats[i]);
-      if (variantIndex < minEnabledVariantIndex) {
-        minEnabledVariantIndex = variantIndex;
-        formatIndex = i;
+      List<Variant> masterPlaylistVariants = ((HlsMasterPlaylist) playlist).variants;
+      variants = buildOrderedVariants(masterPlaylistVariants, variantIndices);
+      variantPlaylists = new HlsMediaPlaylist[variants.length];
+      variantLastPlaylistLoadTimesMs = new long[variants.length];
+      variantBlacklistTimes = new long[variants.length];
+      int maxWidth = -1;
+      int maxHeight = -1;
+      // Select the variant that comes first in their original order in the master playlist.
+      int minOriginalVariantIndex = Integer.MAX_VALUE;
+      for (int i = 0; i < variants.length; i++) {
+        int originalVariantIndex = masterPlaylistVariants.indexOf(variants[i]);
+        if (originalVariantIndex < minOriginalVariantIndex) {
+          minOriginalVariantIndex = originalVariantIndex;
+          selectedVariantIndex = i;
+        }
+        Format variantFormat = variants[i].format;
+        maxWidth = Math.max(variantFormat.width, maxWidth);
+        maxHeight = Math.max(variantFormat.height, maxHeight);
+      }
+      if (variants.length <= 1 || adaptiveMode == ADAPTIVE_MODE_NONE) {
+        // We won't be adapting between different variants.
+        this.maxWidth = -1;
+        this.maxHeight = -1;
+      } else {
+        // We will be adapting between different variants.
+        // TODO: We should allow the default values to be passed through the constructor.
+        this.maxWidth = maxWidth > 0 ? maxWidth : 1920;
+        this.maxHeight = maxHeight > 0 ? maxHeight : 1080;
       }
-      maxWidth = Math.max(enabledFormats[i].width, maxWidth);
-      maxHeight = Math.max(enabledFormats[i].height, maxHeight);
     }
-    // TODO: We should allow the default values to be passed through the constructor.
-    this.maxWidth = maxWidth > 0 ? maxWidth : 1920;
-    this.maxHeight = maxHeight > 0 ? maxHeight : 1080;
   }
 
   public long getDurationUs() {
@@ -228,6 +240,10 @@ public long getDurationUs() {
    * @param out The {@link MediaFormat} on which the maximum video dimensions should be set.
    */
   public void getMaxVideoDimensions(MediaFormat out) {
+    if (maxWidth == -1 || maxHeight == -1) {
+      // Not adaptive.
+      return;
+    }
     out.setMaxVideoDimensions(maxWidth, maxHeight);
   }
 
@@ -242,36 +258,36 @@ public void getMaxVideoDimensions(MediaFormat out) {
    */
   public Chunk getChunkOperation(TsChunk previousTsChunk, long seekPositionUs,
       long playbackPositionUs) {
-    int nextFormatIndex;
+    int nextVariantIndex;
     boolean switchingVariantSpliced;
     if (adaptiveMode == ADAPTIVE_MODE_NONE) {
-      nextFormatIndex = formatIndex;
+      nextVariantIndex = selectedVariantIndex;
       switchingVariantSpliced = false;
     } else {
-      nextFormatIndex = getNextFormatIndex(previousTsChunk, playbackPositionUs);
-      switchingVariantSpliced = nextFormatIndex != formatIndex
+      nextVariantIndex = getNextVariantIndex(previousTsChunk, playbackPositionUs);
+      switchingVariantSpliced = previousTsChunk != null
+          && !variants[nextVariantIndex].format.equals(previousTsChunk.format)
           && adaptiveMode == ADAPTIVE_MODE_SPLICE;
     }
 
-    int variantIndex = getVariantIndex(enabledFormats[nextFormatIndex]);
-    HlsMediaPlaylist mediaPlaylist = mediaPlaylists[variantIndex];
+    HlsMediaPlaylist mediaPlaylist = variantPlaylists[nextVariantIndex];
     if (mediaPlaylist == null) {
       // We don't have the media playlist for the next variant. Request it now.
-      return newMediaPlaylistChunk(variantIndex);
+      return newMediaPlaylistChunk(nextVariantIndex);
     }
 
-    formatIndex = nextFormatIndex;
+    selectedVariantIndex = nextVariantIndex;
     int chunkMediaSequence = 0;
     boolean liveDiscontinuity = false;
     if (live) {
       if (previousTsChunk == null) {
-        chunkMediaSequence = getLiveStartChunkMediaSequence(variantIndex);
+        chunkMediaSequence = getLiveStartChunkMediaSequence(nextVariantIndex);
       } else {
         chunkMediaSequence = switchingVariantSpliced
             ? previousTsChunk.chunkIndex : previousTsChunk.chunkIndex + 1;
         if (chunkMediaSequence < mediaPlaylist.mediaSequence) {
           // If the chunk is no longer in the playlist. Skip ahead and start again.
-          chunkMediaSequence = getLiveStartChunkMediaSequence(variantIndex);
+          chunkMediaSequence = getLiveStartChunkMediaSequence(nextVariantIndex);
           liveDiscontinuity = true;
         }
       }
@@ -288,8 +304,8 @@ public Chunk getChunkOperation(TsChunk previousTsChunk, long seekPositionUs,
 
     int chunkIndex = chunkMediaSequence - mediaPlaylist.mediaSequence;
     if (chunkIndex >= mediaPlaylist.segments.size()) {
-      if (mediaPlaylist.live && shouldRerequestMediaPlaylist(variantIndex)) {
-        return newMediaPlaylistChunk(variantIndex);
+      if (mediaPlaylist.live && shouldRerequestMediaPlaylist(nextVariantIndex)) {
+        return newMediaPlaylistChunk(nextVariantIndex);
       } else {
         return null;
       }
@@ -303,7 +319,7 @@ public Chunk getChunkOperation(TsChunk previousTsChunk, long seekPositionUs,
       Uri keyUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.encryptionKeyUri);
       if (!keyUri.equals(encryptionKeyUri)) {
         // Encryption is specified and the key has changed.
-        Chunk toReturn = newEncryptionKeyChunk(keyUri, segment.encryptionIV);
+        Chunk toReturn = newEncryptionKeyChunk(keyUri, segment.encryptionIV, selectedVariantIndex);
         return toReturn;
       }
       if (!Util.areEqual(segment.encryptionIV, encryptionIvString)) {
@@ -333,7 +349,7 @@ public Chunk getChunkOperation(TsChunk previousTsChunk, long seekPositionUs,
     long endTimeUs = startTimeUs + (long) (segment.durationSecs * C.MICROS_PER_SECOND);
     boolean isLastChunk = !mediaPlaylist.live && chunkIndex == mediaPlaylist.segments.size() - 1;
     int trigger = Chunk.TRIGGER_UNSPECIFIED;
-    Format format = enabledFormats[formatIndex];
+    Format format = variants[selectedVariantIndex].format;
 
     // Configure the extractor that will read the chunk.
     HlsExtractorWrapper extractorWrapper;
@@ -381,23 +397,41 @@ public void onChunkLoadCompleted(Chunk chunk) {
    * @return True if the error was handled by the source. False otherwise.
    */
   public boolean onChunkLoadError(Chunk chunk, IOException e) {
-    if (chunk.bytesLoaded() == 0 && (chunk instanceof MediaPlaylistChunk)
+    if (chunk.bytesLoaded() == 0
+        && (chunk instanceof TsChunk || chunk instanceof MediaPlaylistChunk
+            || chunk instanceof EncryptionKeyChunk)
         && (e instanceof InvalidResponseCodeException)) {
       InvalidResponseCodeException responseCodeException = (InvalidResponseCodeException) e;
       int responseCode = responseCodeException.responseCode;
       if (responseCode == 404 || responseCode == 410) {
-        MediaPlaylistChunk playlistChunk = (MediaPlaylistChunk) chunk;
-        mediaPlaylistBlacklistTimesMs[playlistChunk.variantIndex] = SystemClock.elapsedRealtime();
-        if (!allPlaylistsBlacklisted()) {
-          // We've handled the 404/410 by blacklisting the playlist.
-          Log.w(TAG, "Blacklisted playlist (" + responseCode + "): "
-              + playlistChunk.dataSpec.uri);
+        int variantIndex;
+        if (chunk instanceof TsChunk) {
+          TsChunk tsChunk = (TsChunk) chunk;
+          variantIndex = getVariantIndex(tsChunk.format);
+        } else if (chunk instanceof MediaPlaylistChunk) {
+          MediaPlaylistChunk playlistChunk = (MediaPlaylistChunk) chunk;
+          variantIndex = playlistChunk.variantIndex;
+        } else {
+          EncryptionKeyChunk encryptionChunk = (EncryptionKeyChunk) chunk;
+          variantIndex = encryptionChunk.variantIndex;
+        }
+        boolean alreadyBlacklisted = variantBlacklistTimes[variantIndex] != 0;
+        variantBlacklistTimes[variantIndex] = SystemClock.elapsedRealtime();
+        if (alreadyBlacklisted) {
+          // The playlist was already blacklisted.
+          Log.w(TAG, "Already blacklisted variant (" + responseCode + "): "
+              + chunk.dataSpec.uri);
+          return false;
+        } else if (!allVariantsBlacklisted()) {
+          // We've handled the 404/410 by blacklisting the variant.
+          Log.w(TAG, "Blacklisted variant (" + responseCode + "): "
+              + chunk.dataSpec.uri);
           return true;
         } else {
           // This was the last non-blacklisted playlist. Don't blacklist it.
-          Log.w(TAG, "Final playlist not blacklisted (" + responseCode + "): "
-              + playlistChunk.dataSpec.uri);
-          mediaPlaylistBlacklistTimesMs[playlistChunk.variantIndex] = 0;
+          Log.w(TAG, "Final variant not blacklisted (" + responseCode + "): "
+              + chunk.dataSpec.uri);
+          variantBlacklistTimes[variantIndex] = 0;
           return false;
         }
       }
@@ -405,83 +439,90 @@ public boolean onChunkLoadError(Chunk chunk, IOException e) {
     return false;
   }
 
-  private int getNextFormatIndex(TsChunk previousTsChunk, long playbackPositionUs) {
-    clearStaleBlacklistedPlaylists();
+  private int getNextVariantIndex(TsChunk previousTsChunk, long playbackPositionUs) {
+    clearStaleBlacklistedVariants();
+    long bitrateEstimate = bandwidthMeter.getBitrateEstimate();
+    if (variantBlacklistTimes[selectedVariantIndex] != 0) {
+      // The current variant has been blacklisted, so we have no choice but to re-evaluate.
+      return getVariantIndexForBandwidth(bitrateEstimate);
+    }
     if (previousTsChunk == null) {
       // Don't consider switching if we don't have a previous chunk.
-      return formatIndex;
+      return selectedVariantIndex;
     }
-    long bitrateEstimate = bandwidthMeter.getBitrateEstimate();
     if (bitrateEstimate == BandwidthMeter.NO_ESTIMATE) {
       // Don't consider switching if we don't have a bandwidth estimate.
-      return formatIndex;
+      return selectedVariantIndex;
     }
-    int idealFormatIndex = getFormatIndexForBandwidth(
-        (int) (bitrateEstimate * BANDWIDTH_FRACTION));
-    if (idealFormatIndex == formatIndex) {
-      // We're already using the ideal format.
-      return formatIndex;
+    int idealIndex = getVariantIndexForBandwidth(bitrateEstimate);
+    if (idealIndex == selectedVariantIndex) {
+      // We're already using the ideal variant.
+      return selectedVariantIndex;
     }
-    // We're not using the ideal format for the available bandwidth, but only switch if the
+    // We're not using the ideal variant for the available bandwidth, but only switch if the
     // conditions are appropriate.
     long bufferedPositionUs = adaptiveMode == ADAPTIVE_MODE_SPLICE ? previousTsChunk.startTimeUs
         : previousTsChunk.endTimeUs;
     long bufferedUs = bufferedPositionUs - playbackPositionUs;
-    if (mediaPlaylistBlacklistTimesMs[formatIndex] != 0
-        || (idealFormatIndex > formatIndex && bufferedUs < maxBufferDurationToSwitchDownUs)
-        || (idealFormatIndex < formatIndex && bufferedUs > minBufferDurationToSwitchUpUs)) {
-      // Switch format.
-      return idealFormatIndex;
-    }
-    // Stick with the current format for now.
-    return formatIndex;
+    if (variantBlacklistTimes[selectedVariantIndex] != 0
+        || (idealIndex > selectedVariantIndex && bufferedUs < maxBufferDurationToSwitchDownUs)
+        || (idealIndex < selectedVariantIndex && bufferedUs > minBufferDurationToSwitchUpUs)) {
+      // Switch variant.
+      return idealIndex;
+    }
+    // Stick with the current variant for now.
+    return selectedVariantIndex;
   }
 
-  private int getFormatIndexForBandwidth(int bitrate) {
-    int lowestQualityEnabledFormatIndex = -1;
-    for (int i = 0; i < enabledFormats.length; i++) {
-      int variantIndex = getVariantIndex(enabledFormats[i]);
-      if (mediaPlaylistBlacklistTimesMs[variantIndex] == 0) {
-        if (enabledFormats[i].bitrate <= bitrate) {
+  private int getVariantIndexForBandwidth(long bitrateEstimate) {
+    if (bitrateEstimate == BandwidthMeter.NO_ESTIMATE) {
+      // Select the lowest quality.
+      bitrateEstimate = 0;
+    }
+    int effectiveBitrate = (int) (bitrateEstimate * BANDWIDTH_FRACTION);
+    int lowestQualityEnabledVariantIndex = -1;
+    for (int i = 0; i < variants.length; i++) {
+      if (variantBlacklistTimes[i] == 0) {
+        if (variants[i].format.bitrate <= effectiveBitrate) {
           return i;
         }
-        lowestQualityEnabledFormatIndex = i;
+        lowestQualityEnabledVariantIndex = i;
       }
     }
-    // At least one format should always be enabled.
-    Assertions.checkState(lowestQualityEnabledFormatIndex != -1);
-    return lowestQualityEnabledFormatIndex;
+    // At least one variant should always be enabled.
+    Assertions.checkState(lowestQualityEnabledVariantIndex != -1);
+    return lowestQualityEnabledVariantIndex;
   }
 
-  private boolean shouldRerequestMediaPlaylist(int variantIndex) {
+  private boolean shouldRerequestMediaPlaylist(int nextVariantIndex) {
     // Don't re-request media playlist more often than one-half of the target duration.
-    HlsMediaPlaylist mediaPlaylist = mediaPlaylists[variantIndex];
+    HlsMediaPlaylist mediaPlaylist = variantPlaylists[nextVariantIndex];
     long timeSinceLastMediaPlaylistLoadMs =
-        SystemClock.elapsedRealtime() - lastMediaPlaylistLoadTimesMs[variantIndex];
+        SystemClock.elapsedRealtime() - variantLastPlaylistLoadTimesMs[nextVariantIndex];
     return timeSinceLastMediaPlaylistLoadMs >= (mediaPlaylist.targetDurationSecs * 1000) / 2;
   }
 
   private int getLiveStartChunkMediaSequence(int variantIndex) {
     // For live start playback from the third chunk from the end.
-    HlsMediaPlaylist mediaPlaylist = mediaPlaylists[variantIndex];
+    HlsMediaPlaylist mediaPlaylist = variantPlaylists[variantIndex];
     int chunkIndex = mediaPlaylist.segments.size() > 3 ? mediaPlaylist.segments.size() - 3 : 0;
     return chunkIndex + mediaPlaylist.mediaSequence;
   }
 
   private MediaPlaylistChunk newMediaPlaylistChunk(int variantIndex) {
-    Uri mediaPlaylistUri = UriUtil.resolveToUri(baseUri, variants.get(variantIndex).url);
+    Uri mediaPlaylistUri = UriUtil.resolveToUri(baseUri, variants[variantIndex].url);
     DataSpec dataSpec = new DataSpec(mediaPlaylistUri, 0, C.LENGTH_UNBOUNDED, null,
         DataSpec.FLAG_ALLOW_GZIP);
     return new MediaPlaylistChunk(dataSource, dataSpec, scratchSpace, playlistParser, variantIndex,
         mediaPlaylistUri.toString());
   }
 
-  private EncryptionKeyChunk newEncryptionKeyChunk(Uri keyUri, String iv) {
+  private EncryptionKeyChunk newEncryptionKeyChunk(Uri keyUri, String iv, int variantIndex) {
     DataSpec dataSpec = new DataSpec(keyUri, 0, C.LENGTH_UNBOUNDED, null, DataSpec.FLAG_ALLOW_GZIP);
-    return new EncryptionKeyChunk(dataSource, dataSpec, scratchSpace, iv);
+    return new EncryptionKeyChunk(dataSource, dataSpec, scratchSpace, iv, variantIndex);
   }
 
-  /* package */ void setEncryptionData(Uri keyUri, String iv, byte[] secretKey) {
+  private void setEncryptionData(Uri keyUri, String iv, byte[] secretKey) {
     String trimmedIv;
     if (iv.toLowerCase(Locale.getDefault()).startsWith("0x")) {
       trimmedIv = iv.substring(2);
@@ -508,28 +549,37 @@ private void clearEncryptionData() {
     encryptionIv = null;
   }
 
-  /* package */ void setMediaPlaylist(int variantIndex, HlsMediaPlaylist mediaPlaylist) {
-    lastMediaPlaylistLoadTimesMs[variantIndex] = SystemClock.elapsedRealtime();
-    mediaPlaylists[variantIndex] = mediaPlaylist;
+  private void setMediaPlaylist(int variantIndex, HlsMediaPlaylist mediaPlaylist) {
+    variantLastPlaylistLoadTimesMs[variantIndex] = SystemClock.elapsedRealtime();
+    variantPlaylists[variantIndex] = mediaPlaylist;
     live |= mediaPlaylist.live;
     durationUs = mediaPlaylist.durationUs;
   }
 
-  private static Format[] buildEnabledFormats(List<Variant> variants, int[] variantIndices) {
-    ArrayList<Variant> enabledVariants = new ArrayList<Variant>();
-    if (variantIndices != null) {
-      for (int i = 0; i < variantIndices.length; i++) {
-        enabledVariants.add(variants.get(variantIndices[i]));
+  /**
+   * Selects a list of variants to use, returning them in order of decreasing bandwidth.
+   *
+   * @param originalVariants The original list of variants.
+   * @param originalVariantIndices Indices of variants that in the original list that can be
+   *     considered, or null to allow all variants to be considered.
+   * @return The set of enabled variants in decreasing bandwidth order.
+   */
+  private static Variant[] buildOrderedVariants(List<Variant> originalVariants,
+      int[] originalVariantIndices) {
+    ArrayList<Variant> enabledVariantList = new ArrayList<>();
+    if (originalVariantIndices != null) {
+      for (int i = 0; i < originalVariantIndices.length; i++) {
+        enabledVariantList.add(originalVariants.get(originalVariantIndices[i]));
       }
     } else {
       // If variantIndices is null then all variants are initially considered.
-      enabledVariants.addAll(variants);
+      enabledVariantList.addAll(originalVariants);
     }
 
-    ArrayList<Variant> definiteVideoVariants = new ArrayList<Variant>();
-    ArrayList<Variant> definiteAudioOnlyVariants = new ArrayList<Variant>();
-    for (int i = 0; i < enabledVariants.size(); i++) {
-      Variant variant = enabledVariants.get(i);
+    ArrayList<Variant> definiteVideoVariants = new ArrayList<>();
+    ArrayList<Variant> definiteAudioOnlyVariants = new ArrayList<>();
+    for (int i = 0; i < enabledVariantList.size(); i++) {
+      Variant variant = enabledVariantList.get(i);
       if (variant.format.height > 0 || variantHasExplicitCodecWithPrefix(variant, "avc")) {
         definiteVideoVariants.add(variant);
       } else if (variantHasExplicitCodecWithPrefix(variant, "mp4a")) {
@@ -541,22 +591,27 @@ private void clearEncryptionData() {
       // We've identified some variants as definitely containing video. Assume variants within the
       // master playlist are marked consistently, and hence that we have the full set. Filter out
       // any other variants, which are likely to be audio only.
-      enabledVariants = definiteVideoVariants;
-    } else if (definiteAudioOnlyVariants.size() < enabledVariants.size()) {
+      enabledVariantList = definiteVideoVariants;
+    } else if (definiteAudioOnlyVariants.size() < enabledVariantList.size()) {
       // We've identified some variants, but not all, as being audio only. Filter them out to leave
       // the remaining variants, which are likely to contain video.
-      enabledVariants.removeAll(definiteAudioOnlyVariants);
+      enabledVariantList.removeAll(definiteAudioOnlyVariants);
     } else {
       // Leave the enabled variants unchanged. They're likely either all video or all audio.
     }
 
-    Format[] enabledFormats = new Format[enabledVariants.size()];
-    for (int i = 0; i < enabledFormats.length; i++) {
-      enabledFormats[i] = enabledVariants.get(i).format;
-    }
+    Variant[] enabledVariants = new Variant[enabledVariantList.size()];
+    enabledVariantList.toArray(enabledVariants);
+    Arrays.sort(enabledVariants, new Comparator<Variant>() {
+      private final Comparator<Format> formatComparator =
+          new Format.DecreasingBandwidthComparator();
+      @Override
+      public int compare(Variant first, Variant second) {
+        return formatComparator.compare(first.format, second.format);
+      }
+    });
 
-    Arrays.sort(enabledFormats, new Format.DecreasingBandwidthComparator());
-    return enabledFormats;
+    return enabledVariants;
   }
 
   private static boolean variantHasExplicitCodecWithPrefix(Variant variant, String prefix) {
@@ -573,28 +628,28 @@ private static boolean variantHasExplicitCodecWithPrefix(Variant variant, String
     return false;
   }
 
-  private boolean allPlaylistsBlacklisted() {
-    for (int i = 0; i < mediaPlaylistBlacklistTimesMs.length; i++) {
-      if (mediaPlaylistBlacklistTimesMs[i] == 0) {
+  private boolean allVariantsBlacklisted() {
+    for (int i = 0; i < variantBlacklistTimes.length; i++) {
+      if (variantBlacklistTimes[i] == 0) {
         return false;
       }
     }
     return true;
   }
 
-  private void clearStaleBlacklistedPlaylists() {
+  private void clearStaleBlacklistedVariants() {
     long currentTime = SystemClock.elapsedRealtime();
-    for (int i = 0; i < mediaPlaylistBlacklistTimesMs.length; i++) {
-      if (mediaPlaylistBlacklistTimesMs[i] != 0
-          && currentTime - mediaPlaylistBlacklistTimesMs[i] > DEFAULT_PLAYLIST_BLACKLIST_MS) {
-        mediaPlaylistBlacklistTimesMs[i] = 0;
+    for (int i = 0; i < variantBlacklistTimes.length; i++) {
+      if (variantBlacklistTimes[i] != 0
+          && currentTime - variantBlacklistTimes[i] > DEFAULT_PLAYLIST_BLACKLIST_MS) {
+        variantBlacklistTimes[i] = 0;
       }
     }
   }
 
   private int getVariantIndex(Format format) {
-    for (int i = 0; i < variants.size(); i++) {
-      if (variants.get(i).format.equals(format)) {
+    for (int i = 0; i < variants.length; i++) {
+      if (variants[i].format.equals(format)) {
         return i;
       }
     }
@@ -635,13 +690,15 @@ public HlsMediaPlaylist getResult() {
   private static class EncryptionKeyChunk extends DataChunk {
 
     public final String iv;
+    public final int variantIndex;
 
     private byte[] result;
 
     public EncryptionKeyChunk(DataSource dataSource, DataSpec dataSpec, byte[] scratchSpace,
-        String iv) {
+        String iv, int variantIndex) {
       super(dataSource, dataSpec, Chunk.TYPE_DRM, Chunk.TRIGGER_UNSPECIFIED, null, scratchSpace);
       this.iv = iv;
+      this.variantIndex = variantIndex;
     }
 
     @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsExtractorWrapper.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsExtractorWrapper.java
index f6c784a5e3..b1d1a8e10e 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsExtractorWrapper.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsExtractorWrapper.java
@@ -60,7 +60,7 @@ public HlsExtractorWrapper(int trigger, Format format, long startTimeUs, Extract
     this.startTimeUs = startTimeUs;
     this.extractor = extractor;
     this.shouldSpliceIn = shouldSpliceIn;
-    sampleQueues = new SparseArray<DefaultTrackOutput>();
+    sampleQueues = new SparseArray<>();
   }
 
   /**
@@ -70,7 +70,47 @@ public HlsExtractorWrapper(int trigger, Format format, long startTimeUs, Extract
    */
   public void init(Allocator allocator) {
     this.allocator = allocator;
-    this.extractor.init(this);
+    extractor.init(this);
+  }
+
+  /**
+   * Whether the extractor is prepared.
+   *
+   * @return True if the extractor is prepared. False otherwise.
+   */
+  public boolean isPrepared() {
+    if (!prepared && tracksBuilt) {
+      for (int i = 0; i < sampleQueues.size(); i++) {
+        if (!sampleQueues.valueAt(i).hasFormat()) {
+          return false;
+        }
+      }
+      prepared = true;
+    }
+    return prepared;
+  }
+
+  /**
+   * Clears queues for all tracks, returning all allocations to the allocator.
+   */
+  public void clear() {
+    for (int i = 0; i < sampleQueues.size(); i++) {
+      sampleQueues.valueAt(i).clear();
+    }
+  }
+
+  /**
+   * Gets the largest timestamp of any sample parsed by the extractor.
+   *
+   * @return The largest timestamp, or {@link Long#MIN_VALUE} if no samples have been parsed.
+   */
+  public long getLargestParsedTimestampUs() {
+    long largestParsedTimestampUs = Long.MIN_VALUE;
+    for (int i = 0; i < sampleQueues.size(); i++) {
+      largestParsedTimestampUs = Math.max(largestParsedTimestampUs,
+          sampleQueues.valueAt(i).getLargestParsedTimestampUs());
+    }
+    return largestParsedTimestampUs;
   }
 
   /**
@@ -84,10 +124,13 @@ public void init(Allocator allocator) {
    * splice to be performed. Calling this method is a noop if the splice has already been
    * configured. Hence this method should be called repeatedly during the window within which a
    * splice can be performed.
+   * <p>
+   * This method must only be called after the extractor has been prepared.
    *
    * @param nextExtractor The extractor being spliced to.
    */
   public final void configureSpliceTo(HlsExtractorWrapper nextExtractor) {
+    Assertions.checkState(isPrepared());
     if (spliceConfigured || !nextExtractor.shouldSpliceIn || !nextExtractor.isPrepared()) {
       // The splice is already configured, or the next extractor doesn't want to be spliced in, or
       // the next extractor isn't ready to be spliced in.
@@ -107,11 +150,12 @@ public final void configureSpliceTo(HlsExtractorWrapper nextExtractor) {
   /**
    * Gets the number of available tracks.
    * <p>
-   * This method should only be called after the extractor has been prepared.
+   * This method must only be called after the extractor has been prepared.
    *
    * @return The number of available tracks.
    */
   public int getTrackCount() {
+    Assertions.checkState(isPrepared());
     return sampleQueues.size();
   }
 
@@ -124,51 +168,14 @@ public int getTrackCount() {
    * @return The corresponding format.
    */
   public MediaFormat getMediaFormat(int track) {
+    Assertions.checkState(isPrepared());
     return sampleQueues.valueAt(track).getFormat();
   }
 
-  /**
-   * Whether the extractor is prepared.
-   *
-   * @return True if the extractor is prepared. False otherwise.
-   */
-  public boolean isPrepared() {
-    if (!prepared && tracksBuilt) {
-      for (int i = 0; i < sampleQueues.size(); i++) {
-        if (!sampleQueues.valueAt(i).hasFormat()) {
-          return false;
-        }
-      }
-      prepared = true;
-    }
-    return prepared;
-  }
-
-  /**
-   * Clears queues for all tracks, returning all allocations to the allocator.
-   */
-  public void clear() {
-    for (int i = 0; i < sampleQueues.size(); i++) {
-      sampleQueues.valueAt(i).clear();
-    }
-  }
-
-  /**
-   * Gets the largest timestamp of any sample parsed by the extractor.
-   *
-   * @return The largest timestamp, or {@link Long#MIN_VALUE} if no samples have been parsed.
-   */
-  public long getLargestParsedTimestampUs() {
-    long largestParsedTimestampUs = Long.MIN_VALUE;
-    for (int i = 0; i < sampleQueues.size(); i++) {
-      largestParsedTimestampUs = Math.max(largestParsedTimestampUs,
-          sampleQueues.valueAt(i).getLargestParsedTimestampUs());
-    }
-    return largestParsedTimestampUs;
-  }
-
   /**
    * Gets the next sample for the specified track.
+   * <p>
+   * This method must only be called after the extractor has been prepared.
    *
    * @param track The track from which to read.
    * @param holder A {@link SampleHolder} into which the sample should be read.
@@ -181,6 +188,8 @@ public boolean getSample(int track, SampleHolder holder) {
 
   /**
    * Discards samples for the specified track up to the specified time.
+   * <p>
+   * This method must only be called after the extractor has been prepared.
    *
    * @param track The track from which samples should be discarded.
    * @param timeUs The time up to which samples should be discarded, in microseconds.
@@ -193,6 +202,8 @@ public void discardUntil(int track, long timeUs) {
   /**
    * Whether samples are available for reading from {@link #getSample(int, SampleHolder)} for the
    * specified track.
+   * <p>
+   * This method must only be called after the extractor has been prepared.
    *
    * @return True if samples are available for reading from {@link #getSample(int, SampleHolder)}
    *     for the specified track. False otherwise.
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsParserUtil.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsParserUtil.java
index 2ddfdd081b..23a64163ad 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsParserUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsParserUtil.java
@@ -36,7 +36,7 @@ public static String parseStringAttr(String line, Pattern pattern, String tag)
     if (matcher.find() && matcher.groupCount() == 1) {
       return matcher.group(1);
     }
-    throw new ParserException(String.format("Couldn't match %s tag in %s", tag, line));
+    throw new ParserException("Couldn't match " + tag + " tag in " + line);
   }
 
   public static int parseIntAttr(String line, Pattern pattern, String tag)
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylist.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylist.java
index b6cd9dac9a..4faddf3342 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylist.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylist.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer.hls;
 
-
 /**
  * Represents an HLS playlist.
  */
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java
index 3ac98a07af..78b9d06648 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java
@@ -106,7 +106,7 @@
   public HlsPlaylist parse(String connectionUrl, InputStream inputStream)
       throws IOException, ParserException {
     BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
-    Queue<String> extraLines = new LinkedList<String>();
+    Queue<String> extraLines = new LinkedList<>();
     String line;
     try {
       while ((line = reader.readLine()) != null) {
@@ -137,8 +137,8 @@ public HlsPlaylist parse(String connectionUrl, InputStream inputStream)
 
   private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, String baseUri)
       throws IOException {
-    ArrayList<Variant> variants = new ArrayList<Variant>();
-    ArrayList<Subtitle> subtitles = new ArrayList<Subtitle>();
+    ArrayList<Variant> variants = new ArrayList<>();
+    ArrayList<Subtitle> subtitles = new ArrayList<>();
     int bitrate = 0;
     String codecs = null;
     int width = -1;
@@ -202,7 +202,7 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
     int targetDurationSecs = 0;
     int version = 1; // Default version == 1.
     boolean live = true;
-    List<Segment> segments = new ArrayList<Segment>();
+    List<Segment> segments = new ArrayList<>();
 
     double segmentDurationSecs = 0.0;
     boolean segmentDiscontinuity = false;
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
index d78b23be67..b3a2dbdc34 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
@@ -16,17 +16,17 @@
 package com.google.android.exoplayer.hls;
 
 import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.LoadControl;
 import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.MediaFormatHolder;
 import com.google.android.exoplayer.SampleHolder;
 import com.google.android.exoplayer.SampleSource;
+import com.google.android.exoplayer.SampleSource.SampleSourceReader;
 import com.google.android.exoplayer.TrackInfo;
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.chunk.BaseChunkSampleSourceEventListener;
 import com.google.android.exoplayer.chunk.Chunk;
 import com.google.android.exoplayer.chunk.Format;
-import com.google.android.exoplayer.upstream.Allocator;
-import com.google.android.exoplayer.upstream.DefaultAllocator;
 import com.google.android.exoplayer.upstream.Loader;
 import com.google.android.exoplayer.upstream.Loader.Loadable;
 import com.google.android.exoplayer.util.Assertions;
@@ -40,7 +40,7 @@
 /**
  * A {@link SampleSource} for HLS streams.
  */
-public class HlsSampleSource implements SampleSource, Loader.Callback {
+public class HlsSampleSource implements SampleSource, SampleSourceReader, Loader.Callback {
 
   /**
    * Interface definition for a callback to be notified of {@link HlsSampleSource} events.
@@ -52,23 +52,22 @@
    */
   public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT = 3;
 
-  private static final int BUFFER_FRAGMENT_LENGTH = 256 * 1024;
   private static final int NO_RESET_PENDING = -1;
 
   private final HlsChunkSource chunkSource;
   private final LinkedList<HlsExtractorWrapper> extractors;
-  private final Allocator allocator;
   private final boolean frameAccurateSeeking;
   private final int minLoadableRetryCount;
-  private final int requestedBufferSize;
-  private final long requestedBufferDurationUs;
+  private final int bufferSizeContribution;
 
   private final int eventSourceId;
+  private final LoadControl loadControl;
   private final Handler eventHandler;
   private final EventListener eventListener;
 
   private int remainingReleaseCount;
   private boolean prepared;
+  private boolean loadControlRegistered;
   private int trackCount;
   private int enabledTrackCount;
   private boolean[] trackEnabledStates;
@@ -81,47 +80,48 @@
   private long lastSeekPositionUs;
   private long pendingResetPositionUs;
 
-  private TsChunk previousTsLoadable;
-  private Chunk currentLoadable;
   private boolean loadingFinished;
+  private Chunk currentLoadable;
+  private TsChunk currentTsLoadable;
+  private TsChunk previousTsLoadable;
 
   private Loader loader;
   private IOException currentLoadableException;
-  private boolean currentLoadableExceptionFatal;
   private int currentLoadableExceptionCount;
   private long currentLoadableExceptionTimestamp;
   private long currentLoadStartTimeMs;
 
-  public HlsSampleSource(HlsChunkSource chunkSource, boolean frameAccurateSeeking,
-      int downstreamRendererCount, int requestedBufferSize, long requestedBufferDurationMs) {
-    this(chunkSource, frameAccurateSeeking, downstreamRendererCount, requestedBufferSize,
-        requestedBufferDurationMs, null, null, 0);
+  public HlsSampleSource(HlsChunkSource chunkSource, LoadControl loadControl,
+      int bufferSizeContribution, boolean frameAccurateSeeking) {
+    this(chunkSource, loadControl, bufferSizeContribution, frameAccurateSeeking, null, null, 0);
   }
 
-  public HlsSampleSource(HlsChunkSource chunkSource, boolean frameAccurateSeeking,
-      int downstreamRendererCount, int requestedBufferSize, long requestedBufferDurationMs,
-      Handler eventHandler, EventListener eventListener, int eventSourceId) {
-    this(chunkSource, frameAccurateSeeking, downstreamRendererCount, requestedBufferSize,
-        requestedBufferDurationMs, eventHandler, eventListener, eventSourceId,
-        DEFAULT_MIN_LOADABLE_RETRY_COUNT);
+  public HlsSampleSource(HlsChunkSource chunkSource, LoadControl loadControl,
+      int bufferSizeContribution, boolean frameAccurateSeeking, Handler eventHandler,
+      EventListener eventListener, int eventSourceId) {
+    this(chunkSource, loadControl, bufferSizeContribution, frameAccurateSeeking, eventHandler,
+        eventListener, eventSourceId, DEFAULT_MIN_LOADABLE_RETRY_COUNT);
   }
 
-  public HlsSampleSource(HlsChunkSource chunkSource, boolean frameAccurateSeeking,
-      int downstreamRendererCount, int requestedBufferSize, long requestedBufferDurationMs,
-      Handler eventHandler, EventListener eventListener,
-      int eventSourceId, int minLoadableRetryCount) {
+  public HlsSampleSource(HlsChunkSource chunkSource, LoadControl loadControl,
+      int bufferSizeContribution, boolean frameAccurateSeeking, Handler eventHandler,
+      EventListener eventListener, int eventSourceId, int minLoadableRetryCount) {
     this.chunkSource = chunkSource;
+    this.loadControl = loadControl;
+    this.bufferSizeContribution = bufferSizeContribution;
     this.frameAccurateSeeking = frameAccurateSeeking;
-    this.remainingReleaseCount = downstreamRendererCount;
-    this.requestedBufferSize = requestedBufferSize;
-    this.requestedBufferDurationUs = requestedBufferDurationMs * 1000;
     this.minLoadableRetryCount = minLoadableRetryCount;
     this.eventHandler = eventHandler;
     this.eventListener = eventListener;
     this.eventSourceId = eventSourceId;
     this.pendingResetPositionUs = NO_RESET_PENDING;
-    extractors = new LinkedList<HlsExtractorWrapper>();
-    allocator = new DefaultAllocator(BUFFER_FRAGMENT_LENGTH);
+    extractors = new LinkedList<>();
+  }
+
+  @Override
+  public SampleSourceReader register() {
+    remainingReleaseCount++;
+    return this;
   }
 
   @Override
@@ -131,7 +131,7 @@ public boolean prepare(long positionUs) throws IOException {
     }
     if (!extractors.isEmpty()) {
       // We're not prepared, but we might have loaded what we need.
-      HlsExtractorWrapper extractor = extractors.getFirst();
+      HlsExtractorWrapper extractor = getCurrentExtractor();
       if (extractor.isPrepared()) {
         trackCount = extractor.getTrackCount();
         trackEnabledStates = new boolean[trackCount];
@@ -150,6 +150,10 @@ public boolean prepare(long positionUs) throws IOException {
     if (loader == null) {
       loader = new Loader("Loader:HLS");
     }
+    if (!loadControlRegistered) {
+      loadControl.register(this, bufferSizeContribution);
+      loadControlRegistered = true;
+    }
     if (!loader.isLoading()) {
       // We're going to have to start loading a chunk to get what we need for preparation. We should
       // attempt to load the chunk at positionUs, so that we'll already be loading the correct chunk
@@ -182,9 +186,14 @@ public void enable(int track, long positionUs) {
     trackEnabledStates[track] = true;
     downstreamMediaFormats[track] = null;
     downstreamFormat = null;
+    if (!loadControlRegistered) {
+      loadControl.register(this, bufferSizeContribution);
+      loadControlRegistered = true;
+    }
     if (enabledTrackCount == 1) {
       seekToUs(positionUs);
     }
+    pendingDiscontinuities[track] = false;
   }
 
   @Override
@@ -193,38 +202,48 @@ public void disable(int track) {
     Assertions.checkState(trackEnabledStates[track]);
     enabledTrackCount--;
     trackEnabledStates[track] = false;
-    pendingDiscontinuities[track] = false;
     if (enabledTrackCount == 0) {
+      downstreamPositionUs = Long.MIN_VALUE;
+      if (loadControlRegistered) {
+        loadControl.unregister(this);
+        loadControlRegistered = false;
+      }
       if (loader.isLoading()) {
         loader.cancelLoading();
       } else {
         clearState();
-        allocator.trim(0);
+        loadControl.trimAllocator();
       }
     }
   }
 
   @Override
-  public boolean continueBuffering(long playbackPositionUs) throws IOException {
+  public boolean continueBuffering(int track, long playbackPositionUs) throws IOException {
     Assertions.checkState(prepared);
-    Assertions.checkState(enabledTrackCount > 0);
+    Assertions.checkState(trackEnabledStates[track]);
     downstreamPositionUs = playbackPositionUs;
     if (!extractors.isEmpty()) {
-      discardSamplesForDisabledTracks(extractors.getFirst(), downstreamPositionUs);
+      discardSamplesForDisabledTracks(getCurrentExtractor(), downstreamPositionUs);
+    }
+    if (loadingFinished) {
+      return true;
     }
-    return loadingFinished || continueBufferingInternal();
-  }
-
-  private boolean continueBufferingInternal() throws IOException {
     maybeStartLoading();
     if (isPendingReset() || extractors.isEmpty()) {
       return false;
     }
-    boolean haveSamples = prepared && haveSamplesForEnabledTracks(getCurrentExtractor());
-    if (!haveSamples) {
-      maybeThrowLoadableException();
+
+    for (int extractorIndex = 0; extractorIndex < extractors.size(); extractorIndex++) {
+      HlsExtractorWrapper extractor = extractors.get(extractorIndex);
+      if (!extractor.isPrepared()) {
+        break;
+      }
+      if (extractor.hasSamples(track)) {
+        return true;
+      }
     }
-    return haveSamples;
+    maybeThrowLoadableException();
+    return false;
   }
 
   @Override
@@ -248,6 +267,10 @@ public int readData(int track, long playbackPositionUs, MediaFormatHolder format
     }
 
     HlsExtractorWrapper extractor = getCurrentExtractor();
+    if (!extractor.isPrepared()) {
+      maybeThrowLoadableException();
+      return NOTHING_READ;
+    }
 
     if (downstreamFormat == null || !downstreamFormat.equals(extractor.format)) {
       // Notify a change in the downstream format.
@@ -266,11 +289,10 @@ public int readData(int track, long playbackPositionUs, MediaFormatHolder format
       // We're finished reading from the extractor for this particular track, so advance to the
       // next one for the current read.
       extractor = extractors.get(++extractorIndex);
-    }
-
-    if (!extractor.isPrepared()) {
-      maybeThrowLoadableException();
-      return NOTHING_READ;
+      if (!extractor.isPrepared()) {
+        maybeThrowLoadableException();
+        return NOTHING_READ;
+      }
     }
 
     MediaFormat mediaFormat = extractor.getMediaFormat(track);
@@ -299,8 +321,11 @@ public int readData(int track, long playbackPositionUs, MediaFormatHolder format
   public void seekToUs(long positionUs) {
     Assertions.checkState(prepared);
     Assertions.checkState(enabledTrackCount > 0);
+
+    long currentPositionUs = isPendingReset() ? pendingResetPositionUs : downstreamPositionUs;
+    downstreamPositionUs = positionUs;
     lastSeekPositionUs = positionUs;
-    if ((isPendingReset() ? pendingResetPositionUs : downstreamPositionUs) == positionUs) {
+    if (currentPositionUs == positionUs) {
       return;
     }
 
@@ -338,26 +363,24 @@ public void release() {
 
   @Override
   public void onLoadCompleted(Loadable loadable) {
+    Assertions.checkState(loadable == currentLoadable);
     long now = SystemClock.elapsedRealtime();
     long loadDurationMs = now - currentLoadStartTimeMs;
     chunkSource.onChunkLoadCompleted(currentLoadable);
     if (isTsChunk(currentLoadable)) {
-      TsChunk tsChunk = (TsChunk) loadable;
-      loadingFinished = tsChunk.isLastChunk;
-      notifyLoadCompleted(currentLoadable.bytesLoaded(), tsChunk.type, tsChunk.trigger,
-          tsChunk.format, tsChunk.startTimeUs, tsChunk.endTimeUs, now, loadDurationMs);
+      Assertions.checkState(currentLoadable == currentTsLoadable);
+      loadingFinished = currentTsLoadable.isLastChunk;
+      previousTsLoadable = currentTsLoadable;
+      notifyLoadCompleted(currentLoadable.bytesLoaded(), currentTsLoadable.type,
+          currentTsLoadable.trigger, currentTsLoadable.format, currentTsLoadable.startTimeUs,
+          currentTsLoadable.endTimeUs, now, loadDurationMs);
     } else {
       notifyLoadCompleted(currentLoadable.bytesLoaded(), currentLoadable.type,
           currentLoadable.trigger, currentLoadable.format, -1, -1, now, loadDurationMs);
     }
-    if (!currentLoadableExceptionFatal) {
-      clearCurrentLoadable();
-    }
-    if (enabledTrackCount > 0) {
+    clearCurrentLoadable();
+    if (enabledTrackCount > 0 || !prepared) {
       maybeStartLoading();
-    } else {
-      clearState();
-      allocator.trim(0);
     }
   }
 
@@ -368,7 +391,7 @@ public void onLoadCanceled(Loadable loadable) {
       restartFrom(pendingResetPositionUs);
     } else {
       clearState();
-      allocator.trim(0);
+      loadControl.trimAllocator();
     }
   }
 
@@ -376,6 +399,9 @@ public void onLoadCanceled(Loadable loadable) {
   public void onLoadError(Loadable loadable, IOException e) {
     if (chunkSource.onChunkLoadError(currentLoadable, e)) {
       // Error handled by source.
+      if (previousTsLoadable == null && !isPendingReset()) {
+        pendingResetPositionUs = lastSeekPositionUs;
+      }
       clearCurrentLoadable();
     } else {
       currentLoadableException = e;
@@ -430,8 +456,7 @@ private boolean haveSamplesForEnabledTracks(HlsExtractorWrapper extractor) {
   }
 
   private void maybeThrowLoadableException() throws IOException {
-    if (currentLoadableException != null && (currentLoadableExceptionFatal
-        || currentLoadableExceptionCount > minLoadableRetryCount)) {
+    if (currentLoadableException != null && currentLoadableExceptionCount > minLoadableRetryCount) {
       throw currentLoadableException;
     }
   }
@@ -457,20 +482,24 @@ private void clearState() {
   }
 
   private void clearCurrentLoadable() {
+    currentTsLoadable = null;
     currentLoadable = null;
     currentLoadableException = null;
     currentLoadableExceptionCount = 0;
-    currentLoadableExceptionFatal = false;
   }
 
   private void maybeStartLoading() {
-    if (currentLoadableExceptionFatal || loadingFinished || loader.isLoading()) {
-      return;
-    }
-
+    long now = SystemClock.elapsedRealtime();
+    long nextLoadPositionUs = getNextLoadPositionUs();
     boolean isBackedOff = currentLoadableException != null;
+    boolean loadingOrBackedOff = loader.isLoading() || isBackedOff;
+
+    // Update the control with our current state, and determine whether we're the next loader.
+    boolean nextLoader = loadControl.update(this, downstreamPositionUs, nextLoadPositionUs,
+        loadingOrBackedOff, false);
+
     if (isBackedOff) {
-      long elapsedMillis = SystemClock.elapsedRealtime() - currentLoadableExceptionTimestamp;
+      long elapsedMillis = now - currentLoadableExceptionTimestamp;
       if (elapsedMillis >= getRetryDelayMillis(currentLoadableExceptionCount)) {
         currentLoadableException = null;
         loader.startLoading(currentLoadable, this);
@@ -478,20 +507,17 @@ private void maybeStartLoading() {
       return;
     }
 
-    if (previousTsLoadable != null
-        && (previousTsLoadable.endTimeUs - downstreamPositionUs >= requestedBufferDurationUs
-        || allocator.getTotalBytesAllocated() >= requestedBufferSize)) {
-      // We already have the target amount of data or time buffered.
+    if (loader.isLoading() || !nextLoader) {
       return;
     }
 
-    Chunk nextLoadable = chunkSource.getChunkOperation(previousTsLoadable,
-        pendingResetPositionUs, downstreamPositionUs);
+    Chunk nextLoadable = chunkSource.getChunkOperation(previousTsLoadable, pendingResetPositionUs,
+        downstreamPositionUs);
     if (nextLoadable == null) {
       return;
     }
 
-    currentLoadStartTimeMs = SystemClock.elapsedRealtime();
+    currentLoadStartTimeMs = now;
     currentLoadable = nextLoadable;
     if (isTsChunk(currentLoadable)) {
       TsChunk tsChunk = (TsChunk) currentLoadable;
@@ -500,12 +526,12 @@ private void maybeStartLoading() {
       }
       HlsExtractorWrapper extractorWrapper = tsChunk.extractorWrapper;
       if (extractors.isEmpty() || extractors.getLast() != extractorWrapper) {
-        extractorWrapper.init(allocator);
+        extractorWrapper.init(loadControl.getAllocator());
         extractors.addLast(extractorWrapper);
       }
       notifyLoadStarted(tsChunk.dataSpec.length, tsChunk.type, tsChunk.trigger, tsChunk.format,
           tsChunk.startTimeUs, tsChunk.endTimeUs);
-      previousTsLoadable = tsChunk;
+      currentTsLoadable = tsChunk;
     } else {
       notifyLoadStarted(currentLoadable.dataSpec.length, currentLoadable.type,
           currentLoadable.trigger, currentLoadable.format, -1, -1);
@@ -513,6 +539,20 @@ private void maybeStartLoading() {
     loader.startLoading(currentLoadable, this);
   }
 
+  /**
+   * Gets the next load time, assuming that the next load starts where the previous chunk ended (or
+   * from the pending reset time, if there is one).
+   */
+  private long getNextLoadPositionUs() {
+    if (isPendingReset()) {
+      return pendingResetPositionUs;
+    } else {
+      return currentTsLoadable != null
+          ? (currentTsLoadable.isLastChunk ? -1 : currentTsLoadable.endTimeUs)
+          : (previousTsLoadable.isLastChunk ? -1 : previousTsLoadable.endTimeUs);
+    }
+  }
+
   private boolean isTsChunk(Chunk chunk) {
     return chunk instanceof TsChunk;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/Id3Parser.java b/library/src/main/java/com/google/android/exoplayer/metadata/Id3Parser.java
index 836ec7f8f6..f306c5d6e8 100644
--- a/library/src/main/java/com/google/android/exoplayer/metadata/Id3Parser.java
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/Id3Parser.java
@@ -22,6 +22,7 @@
 import java.io.UnsupportedEncodingException;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.Locale;
 import java.util.Map;
 
 /**
@@ -42,7 +43,7 @@ public boolean canParse(String mimeType) {
   @Override
   public Map<String, Object> parse(byte[] data, int size)
       throws UnsupportedEncodingException, ParserException {
-    Map<String, Object> metadata = new HashMap<String, Object>();
+    Map<String, Object> metadata = new HashMap<>();
     ParsableByteArray id3Data = new ParsableByteArray(data, size);
     int id3Size = parseId3Header(id3Data);
 
@@ -108,7 +109,7 @@ public boolean canParse(String mimeType) {
         metadata.put(GeobMetadata.TYPE, new GeobMetadata(mimeType, filename,
             description, objectData));
       } else {
-        String type = String.format("%c%c%c%c", frameId0, frameId1, frameId2, frameId3);
+        String type = String.format(Locale.US, "%c%c%c%c", frameId0, frameId1, frameId2, frameId3);
         byte[] frame = new byte[frameSize];
         id3Data.readBytes(frame, 0, frameSize);
         metadata.put(type, frame);
@@ -165,7 +166,7 @@ private static int parseId3Header(ParsableByteArray id3Buffer) throws ParserExce
     int id2 = id3Buffer.readUnsignedByte();
     int id3 = id3Buffer.readUnsignedByte();
     if (id1 != 'I' || id2 != 'D' || id3 != '3') {
-      throw new ParserException(String.format(
+      throw new ParserException(String.format(Locale.US,
           "Unexpected ID3 file identifier, expected \"ID3\", actual \"%c%c%c\".", id1, id2, id3));
     }
     id3Buffer.skipBytes(2); // Skip version.
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/MetadataTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/metadata/MetadataTrackRenderer.java
index c6cd9aa458..38db32746b 100644
--- a/library/src/main/java/com/google/android/exoplayer/metadata/MetadataTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/MetadataTrackRenderer.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer.MediaFormatHolder;
 import com.google.android.exoplayer.SampleHolder;
 import com.google.android.exoplayer.SampleSource;
+import com.google.android.exoplayer.SampleSource.SampleSourceReader;
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.util.Assertions;
 
@@ -54,7 +55,7 @@
 
   private static final int MSG_INVOKE_RENDERER = 0;
 
-  private final SampleSource source;
+  private final SampleSourceReader source;
   private final MetadataParser<T> metadataParser;
   private final MetadataRenderer<T> metadataRenderer;
   private final Handler metadataHandler;
@@ -62,7 +63,6 @@
   private final SampleHolder sampleHolder;
 
   private int trackIndex;
-  private long currentPositionUs;
   private boolean inputStreamEnded;
 
   private long pendingMetadataTimestamp;
@@ -80,7 +80,7 @@
    */
   public MetadataTrackRenderer(SampleSource source, MetadataParser<T> metadataParser,
       MetadataRenderer<T> metadataRenderer, Looper metadataRendererLooper) {
-    this.source = Assertions.checkNotNull(source);
+    this.source = source.register();
     this.metadataParser = Assertions.checkNotNull(metadataParser);
     this.metadataRenderer = Assertions.checkNotNull(metadataRenderer);
     this.metadataHandler = metadataRendererLooper == null ? null
@@ -111,17 +111,16 @@ protected int doPrepare(long positionUs) throws ExoPlaybackException {
   @Override
   protected void onEnabled(long positionUs, boolean joining) {
     source.enable(trackIndex, positionUs);
-    seekToInternal(positionUs);
+    seekToInternal();
   }
 
   @Override
   protected void seekTo(long positionUs) throws ExoPlaybackException {
     source.seekToUs(positionUs);
-    seekToInternal(positionUs);
+    seekToInternal();
   }
 
-  private void seekToInternal(long positionUs) {
-    currentPositionUs = positionUs;
+  private void seekToInternal() {
     pendingMetadata = null;
     inputStreamEnded = false;
   }
@@ -129,9 +128,8 @@ private void seekToInternal(long positionUs) {
   @Override
   protected void doSomeWork(long positionUs, long elapsedRealtimeUs)
       throws ExoPlaybackException {
-    currentPositionUs = positionUs;
     try {
-      source.continueBuffering(positionUs);
+      source.continueBuffering(trackIndex, positionUs);
     } catch (IOException e) {
       throw new ExoPlaybackException(e);
     }
@@ -147,11 +145,13 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs)
           inputStreamEnded = true;
         }
       } catch (IOException e) {
-        throw new ExoPlaybackException(e);
+        // TODO: This should be propagated, but in the current design propagation may occur too
+        // early. See [Internal b/22291244].
+        // throw new ExoPlaybackException(e);
       }
     }
 
-    if (pendingMetadata != null && pendingMetadataTimestamp <= currentPositionUs) {
+    if (pendingMetadata != null && pendingMetadataTimestamp <= positionUs) {
       invokeRenderer(pendingMetadata);
       pendingMetadata = null;
     }
@@ -168,11 +168,6 @@ protected long getDurationUs() {
     return source.getTrackInfo(trackIndex).durationUs;
   }
 
-  @Override
-  protected long getCurrentPositionUs() {
-    return currentPositionUs;
-  }
-
   @Override
   protected long getBufferedPositionUs() {
     return TrackRenderer.END_OF_TRACK_US;
diff --git a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingChunkSource.java b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingChunkSource.java
index 14292cbb67..91121c59fd 100644
--- a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingChunkSource.java
@@ -59,14 +59,11 @@
   private static final int MINIMUM_MANIFEST_REFRESH_PERIOD_MS = 5000;
   private static final int INITIALIZATION_VECTOR_SIZE = 8;
 
-  private final ManifestFetcher<SmoothStreamingManifest> manifestFetcher;
-  private final int streamElementIndex;
   private final TrackInfo trackInfo;
   private final DataSource dataSource;
   private final FormatEvaluator formatEvaluator;
   private final Evaluation evaluation;
   private final long liveEdgeLatencyUs;
-
   private final int maxWidth;
   private final int maxHeight;
 
@@ -75,6 +72,9 @@
   private final DrmInitData drmInitData;
   private final Format[] formats;
 
+  private final ManifestFetcher<SmoothStreamingManifest> manifestFetcher;
+  private final int streamElementIndex;
+
   private SmoothStreamingManifest currentManifest;
   private int currentManifestChunkOffset;
   private boolean finishedCurrentManifest;
@@ -153,8 +153,8 @@ private SmoothStreamingChunkSource(ManifestFetcher<SmoothStreamingManifest> mani
 
     int trackCount = trackIndices != null ? trackIndices.length : streamElement.tracks.length;
     formats = new Format[trackCount];
-    extractorWrappers = new SparseArray<ChunkExtractorWrapper>();
-    mediaFormats = new SparseArray<MediaFormat>();
+    extractorWrappers = new SparseArray<>();
+    mediaFormats = new SparseArray<>();
     int maxWidth = 0;
     int maxHeight = 0;
     for (int i = 0; i < trackCount; i++) {
@@ -174,8 +174,8 @@ private SmoothStreamingChunkSource(ManifestFetcher<SmoothStreamingManifest> mani
       extractorWrappers.put(trackIndex, new ChunkExtractorWrapper(extractor));
       mediaFormats.put(trackIndex, mediaFormat);
     }
-    this.maxHeight = maxHeight;
     this.maxWidth = maxWidth;
+    this.maxHeight = maxHeight;
     Arrays.sort(formats, new DecreasingBandwidthComparator());
   }
 
@@ -194,6 +194,7 @@ public final TrackInfo getTrackInfo() {
   @Override
   public void enable() {
     fatalError = null;
+    formatEvaluator.enable();
     if (manifestFetcher != null) {
       manifestFetcher.enable();
     }
@@ -201,6 +202,7 @@ public void enable() {
 
   @Override
   public void disable(List<? extends MediaChunk> queue) {
+    formatEvaluator.disable();
     if (manifestFetcher != null) {
       manifestFetcher.disable();
     }
@@ -215,11 +217,22 @@ public void continueBuffering(long playbackPositionUs) {
     SmoothStreamingManifest newManifest = manifestFetcher.getManifest();
     if (currentManifest != newManifest && newManifest != null) {
       StreamElement currentElement = getElement(currentManifest);
+      int currentElementChunkCount = currentElement.chunkCount;
       StreamElement newElement = getElement(newManifest);
-      if (newElement.chunkCount == 0) {
-        currentManifestChunkOffset += currentElement.chunkCount;
-      } else if (currentElement.chunkCount > 0) {
-        currentManifestChunkOffset += currentElement.getChunkIndex(newElement.getStartTimeUs(0));
+      if (currentElementChunkCount == 0 || newElement.chunkCount == 0) {
+        // There's no overlap between the old and new elements because at least one is empty.
+        currentManifestChunkOffset += currentElementChunkCount;
+      } else {
+        long currentElementEndTimeUs = currentElement.getStartTimeUs(currentElementChunkCount - 1)
+            + currentElement.getChunkDurationUs(currentElementChunkCount - 1);
+        long newElementStartTimeUs = newElement.getStartTimeUs(0);
+        if (currentElementEndTimeUs <= newElementStartTimeUs) {
+          // There's no overlap between the old and new elements.
+          currentManifestChunkOffset += currentElementChunkCount;
+        } else {
+          // The new element overlaps with the old one.
+          currentManifestChunkOffset += currentElement.getChunkIndex(newElementStartTimeUs);
+        }
       }
       currentManifest = newManifest;
       finishedCurrentManifest = false;
@@ -248,14 +261,13 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long seekP
       out.chunk = null;
       return;
     } else if (out.queueSize == queue.size() && out.chunk != null
-        && out.chunk.format.equals(evaluation.format)) {
+        && out.chunk.format.equals(selectedFormat)) {
       // We already have a chunk, and the evaluation hasn't changed either the format or the size
-      // of the queue. Do nothing.
+      // of the queue. Leave unchanged.
       return;
     }
 
-    // In all cases where we return before instantiating a new chunk at the bottom of this method,
-    // we want out.chunk to be null.
+    // In all cases where we return before instantiating a new chunk, we want out.chunk to be null.
     out.chunk = null;
 
     StreamElement streamElement = getElement(currentManifest);
@@ -290,7 +302,9 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long seekP
         // but continue to return the final chunk.
         finishedCurrentManifest = true;
       }
-    } else if (chunkIndex == -1) {
+    }
+
+    if (chunkIndex == -1) {
       // We've reached the end of the stream.
       return;
     }
@@ -374,14 +388,14 @@ private static MediaFormat getMediaFormat(StreamElement streamElement, int track
       if (trackElement.csd != null) {
         csd = Arrays.asList(trackElement.csd);
       } else {
-        csd = Collections.singletonList(CodecSpecificDataUtil.buildAudioSpecificConfig(
+        csd = Collections.singletonList(CodecSpecificDataUtil.buildAacAudioSpecificConfig(
             trackFormat.audioSamplingRate, trackFormat.numChannels));
       }
       MediaFormat format = MediaFormat.createAudioFormat(mimeType, MediaFormat.NO_VALUE,
           trackFormat.numChannels, trackFormat.audioSamplingRate, csd);
       return format;
     } else if (streamElement.type == StreamElement.TYPE_TEXT) {
-      return MediaFormat.createFormatForMimeType(trackFormat.mimeType);
+      return MediaFormat.createTextFormat(trackFormat.mimeType);
     }
     return null;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifestParser.java b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifestParser.java
index c2b4e567eb..a0bc0e7926 100644
--- a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifestParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifestParser.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer.smoothstreaming;
 
 import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.extractor.mp4.PsshAtomUtil;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.ProtectionElement;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.StreamElement;
 import com.google.android.exoplayer.smoothstreaming.SmoothStreamingManifest.TrackElement;
@@ -96,7 +97,7 @@ public ElementParser(ElementParser parent, String baseUri, String tag) {
       this.parent = parent;
       this.baseUri = baseUri;
       this.tag = tag;
-      this.normalizedAttributes = new LinkedList<Pair<String, Object>>();
+      this.normalizedAttributes = new LinkedList<>();
     }
 
     public final Object parse(XmlPullParser xmlParser) throws XmlPullParserException, IOException,
@@ -343,7 +344,7 @@ public SmoothStreamMediaParser(ElementParser parent, String baseUri) {
       super(parent, baseUri, TAG);
       lookAheadCount = -1;
       protectionElement = null;
-      streamElements = new LinkedList<StreamElement>();
+      streamElements = new LinkedList<>();
     }
 
     @Override
@@ -423,7 +424,7 @@ public void parseEndTag(XmlPullParser parser) {
 
     @Override
     public Object build() {
-      return new ProtectionElement(uuid, initData);
+      return new ProtectionElement(uuid, PsshAtomUtil.buildPsshAtom(uuid, initData));
     }
 
   }
@@ -473,7 +474,7 @@ public Object build() {
     public StreamElementParser(ElementParser parent, String baseUri) {
       super(parent, baseUri, TAG);
       this.baseUri = baseUri;
-      tracks = new LinkedList<TrackElement>();
+      tracks = new LinkedList<>();
     }
 
     @Override
@@ -539,7 +540,7 @@ private void parseStreamElementStartTag(XmlPullParser parser) throws ParserExcep
       if (timescale == -1) {
         timescale = (Long) getNormalizedAttribute(KEY_TIME_SCALE);
       }
-      startTimes = new ArrayList<Long>();
+      startTimes = new ArrayList<>();
     }
 
     private int parseType(XmlPullParser parser) throws ParserException {
@@ -602,7 +603,7 @@ public Object build() {
 
     public TrackElementParser(ElementParser parent, String baseUri) {
       super(parent, baseUri, TAG);
-      this.csd = new LinkedList<byte[]>();
+      this.csd = new LinkedList<>();
     }
 
     @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/text/Cue.java b/library/src/main/java/com/google/android/exoplayer/text/Cue.java
new file mode 100644
index 0000000000..f9476b5a5a
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/text/Cue.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text;
+
+import android.text.Layout.Alignment;
+
+/**
+ * Contains information about a specific cue, including textual content and formatting data.
+ */
+public class Cue {
+
+  /**
+   * Used by some methods to indicate that no value is set.
+   */
+  public static final int UNSET_VALUE = -1;
+
+  public final CharSequence text;
+
+  public final int line;
+  public final int position;
+  public final Alignment alignment;
+  public final int size;
+
+  public Cue() {
+    this(null);
+  }
+
+  public Cue(CharSequence text) {
+    this(text, UNSET_VALUE, UNSET_VALUE, null, UNSET_VALUE);
+  }
+
+  public Cue(CharSequence text, int line, int position, Alignment alignment, int size) {
+    this.text = text;
+    this.line = line;
+    this.position = position;
+    this.alignment = alignment;
+    this.size = size;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/text/CuePainter.java b/library/src/main/java/com/google/android/exoplayer/text/CuePainter.java
new file mode 100644
index 0000000000..b88711f333
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/text/CuePainter.java
@@ -0,0 +1,298 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text;
+
+import com.google.android.exoplayer.util.Util;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.Paint.Join;
+import android.graphics.Paint.Style;
+import android.graphics.RectF;
+import android.text.Layout.Alignment;
+import android.text.StaticLayout;
+import android.text.TextPaint;
+import android.text.TextUtils;
+import android.util.DisplayMetrics;
+import android.util.Log;
+
+/**
+ * Draws {@link Cue}s.
+ */
+/* package */ final class CuePainter {
+
+  private static final String TAG = "CuePainter";
+
+  /**
+   * Ratio of inner padding to font size.
+   */
+  private static final float INNER_PADDING_RATIO = 0.125f;
+
+  /**
+   * Use the same line height ratio as WebVtt to match the display with the preview.
+   * WebVtt specifies line height as 5.3% of the viewport height.
+   */
+  private static final float LINE_HEIGHT_FRACTION = 0.0533f;
+
+  /**
+   * The default bottom padding to apply when {@link Cue#line} is {@link Cue#UNSET_VALUE}, as a
+   * fraction of the viewport height.
+   */
+  private static final float DEFAULT_BOTTOM_PADDING_FRACTION = 0.08f;
+
+  /**
+   * Temporary rectangle used for computing line bounds.
+   */
+  private final RectF lineBounds = new RectF();
+
+  // Styled dimensions.
+  private final float cornerRadius;
+  private final float outlineWidth;
+  private final float shadowRadius;
+  private final float shadowOffset;
+  private final float spacingMult;
+  private final float spacingAdd;
+
+  private final TextPaint textPaint;
+  private final Paint paint;
+
+  // Previous input variables.
+  private CharSequence cueText;
+  private int cuePosition;
+  private Alignment cueAlignment;
+  private int foregroundColor;
+  private int backgroundColor;
+  private int windowColor;
+  private int edgeColor;
+  private int edgeType;
+  private int parentLeft;
+  private int parentTop;
+  private int parentRight;
+  private int parentBottom;
+
+  // Derived drawing variables.
+  private StaticLayout textLayout;
+  private int textLeft;
+  private int textTop;
+  private int textPaddingX;
+
+  public CuePainter(Context context) {
+    int[] viewAttr = {android.R.attr.lineSpacingExtra, android.R.attr.lineSpacingMultiplier};
+    TypedArray styledAttributes = context.obtainStyledAttributes(null, viewAttr, 0, 0);
+    spacingAdd = styledAttributes.getDimensionPixelSize(0, 0);
+    spacingMult = styledAttributes.getFloat(1, 1);
+    styledAttributes.recycle();
+
+    Resources resources = context.getResources();
+    DisplayMetrics displayMetrics = resources.getDisplayMetrics();
+    int twoDpInPx = Math.round((2f * displayMetrics.densityDpi) / DisplayMetrics.DENSITY_DEFAULT);
+    cornerRadius = twoDpInPx;
+    outlineWidth = twoDpInPx;
+    shadowRadius = twoDpInPx;
+    shadowOffset = twoDpInPx;
+
+    textPaint = new TextPaint();
+    textPaint.setAntiAlias(true);
+    textPaint.setSubpixelText(true);
+
+    paint = new Paint();
+    paint.setAntiAlias(true);
+    paint.setStyle(Style.FILL);
+  }
+
+  /**
+   * Draws the provided {@link Cue} into a canvas with the specified styling.
+   * <p>
+   * A call to this method is able to use cached results of calculations made during the previous
+   * call, and so an instance of this class is able to optimize repeated calls to this method in
+   * which the same parameters are passed.
+   *
+   * @param cue The cue to draw.
+   * @param style The style to use when drawing the cue text.
+   * @param fontScale The font scale.
+   * @param canvas The canvas into which to draw.
+   * @param cueBoxLeft The left position of the enclosing cue box.
+   * @param cueBoxTop The top position of the enclosing cue box.
+   * @param cueBoxRight The right position of the enclosing cue box.
+   * @param cueBoxBottom The bottom position of the enclosing cue box.
+   */
+  public void draw(Cue cue, CaptionStyleCompat style, float fontScale, Canvas canvas,
+      int cueBoxLeft, int cueBoxTop, int cueBoxRight, int cueBoxBottom) {
+    if (TextUtils.isEmpty(cue.text)) {
+      // Nothing to draw;
+      return;
+    }
+
+    if (TextUtils.equals(cueText, cue.text)
+        && cuePosition == cue.position
+        && Util.areEqual(cueAlignment, cue.alignment)
+        && foregroundColor == style.foregroundColor
+        && backgroundColor == style.backgroundColor
+        && windowColor == style.windowColor
+        && edgeType == style.edgeType
+        && edgeColor == style.edgeColor
+        && Util.areEqual(textPaint.getTypeface(), style.typeface)
+        && parentLeft == cueBoxLeft
+        && parentTop == cueBoxTop
+        && parentRight == cueBoxRight
+        && parentBottom == cueBoxBottom) {
+      // We can use the cached layout.
+      drawLayout(canvas);
+      return;
+    }
+
+    cueText = cue.text;
+    cuePosition = cue.position;
+    cueAlignment = cue.alignment;
+    foregroundColor = style.foregroundColor;
+    backgroundColor = style.backgroundColor;
+    windowColor = style.windowColor;
+    edgeType = style.edgeType;
+    edgeColor = style.edgeColor;
+    textPaint.setTypeface(style.typeface);
+    parentLeft = cueBoxLeft;
+    parentTop = cueBoxTop;
+    parentRight = cueBoxRight;
+    parentBottom = cueBoxBottom;
+
+    int parentWidth = parentRight - parentLeft;
+    int parentHeight = parentBottom - parentTop;
+
+    float textSize = LINE_HEIGHT_FRACTION * parentHeight * fontScale;
+    textPaint.setTextSize(textSize);
+    int textPaddingX = (int) (textSize * INNER_PADDING_RATIO + 0.5f);
+    int availableWidth = parentWidth - textPaddingX * 2;
+    if (availableWidth <= 0) {
+      Log.w(TAG, "Skipped drawing subtitle cue (insufficient space)");
+      return;
+    }
+
+    Alignment layoutAlignment = cueAlignment == null ? Alignment.ALIGN_CENTER : cueAlignment;
+    textLayout = new StaticLayout(cueText, textPaint, availableWidth, layoutAlignment, spacingMult,
+        spacingAdd, true);
+
+    int textHeight = textLayout.getHeight();
+    int textWidth = 0;
+    int lineCount = textLayout.getLineCount();
+    for (int i = 0; i < lineCount; i++) {
+      textWidth = Math.max((int) Math.ceil(textLayout.getLineWidth(i)), textWidth);
+    }
+    textWidth += textPaddingX * 2;
+
+    int textLeft = (parentWidth - textWidth) / 2;
+    int textRight = textLeft + textWidth;
+    int textTop = parentBottom - textHeight
+        - (int) (parentHeight * DEFAULT_BOTTOM_PADDING_FRACTION);
+    int textBottom = textTop + textHeight;
+
+    if (cue.position != Cue.UNSET_VALUE) {
+      if (cue.alignment == Alignment.ALIGN_OPPOSITE) {
+        textRight = (parentWidth * cue.position) / 100 + parentLeft;
+        textLeft = Math.max(textRight - textWidth, parentLeft);
+      } else {
+        textLeft = (parentWidth * cue.position) / 100 + parentLeft;
+        textRight = Math.min(textLeft + textWidth, parentRight);
+      }
+    }
+    if (cue.line != Cue.UNSET_VALUE) {
+      textTop = (parentHeight * cue.line) / 100 + parentTop;
+      textBottom = textTop + textHeight;
+      if (textBottom > parentBottom) {
+        textTop = parentBottom - textHeight;
+        textBottom = parentBottom;
+      }
+    }
+    textWidth = textRight - textLeft;
+
+    // Update the derived drawing variables.
+    this.textLayout = new StaticLayout(cueText, textPaint, textWidth, layoutAlignment, spacingMult,
+        spacingAdd, true);
+    this.textLeft = textLeft;
+    this.textTop = textTop;
+    this.textPaddingX = textPaddingX;
+
+    drawLayout(canvas);
+  }
+
+  /**
+   * Draws {@link #textLayout} into the provided canvas.
+   *
+   * @param canvas The canvas into which to draw.
+   */
+  private void drawLayout(Canvas canvas) {
+    final StaticLayout layout = textLayout;
+    if (layout == null) {
+      // Nothing to draw.
+      return;
+    }
+
+    int saveCount = canvas.save();
+    canvas.translate(textLeft, textTop);
+
+    if (Color.alpha(windowColor) > 0) {
+      paint.setColor(windowColor);
+      canvas.drawRect(-textPaddingX, 0, layout.getWidth() + textPaddingX, layout.getHeight(),
+          paint);
+    }
+
+    if (Color.alpha(backgroundColor) > 0) {
+      paint.setColor(backgroundColor);
+      float previousBottom = layout.getLineTop(0);
+      int lineCount = layout.getLineCount();
+      for (int i = 0; i < lineCount; i++) {
+        lineBounds.left = layout.getLineLeft(i) - textPaddingX;
+        lineBounds.right = layout.getLineRight(i) + textPaddingX;
+        lineBounds.top = previousBottom;
+        lineBounds.bottom = layout.getLineBottom(i);
+        previousBottom = lineBounds.bottom;
+        canvas.drawRoundRect(lineBounds, cornerRadius, cornerRadius, paint);
+      }
+    }
+
+    if (edgeType == CaptionStyleCompat.EDGE_TYPE_OUTLINE) {
+      textPaint.setStrokeJoin(Join.ROUND);
+      textPaint.setStrokeWidth(outlineWidth);
+      textPaint.setColor(edgeColor);
+      textPaint.setStyle(Style.FILL_AND_STROKE);
+      layout.draw(canvas);
+    } else if (edgeType == CaptionStyleCompat.EDGE_TYPE_DROP_SHADOW) {
+      textPaint.setShadowLayer(shadowRadius, shadowOffset, shadowOffset, edgeColor);
+    } else if (edgeType == CaptionStyleCompat.EDGE_TYPE_RAISED
+        || edgeType == CaptionStyleCompat.EDGE_TYPE_DEPRESSED) {
+      boolean raised = edgeType == CaptionStyleCompat.EDGE_TYPE_RAISED;
+      int colorUp = raised ? Color.WHITE : edgeColor;
+      int colorDown = raised ? edgeColor : Color.WHITE;
+      float offset = shadowRadius / 2f;
+      textPaint.setColor(foregroundColor);
+      textPaint.setStyle(Style.FILL);
+      textPaint.setShadowLayer(shadowRadius, -offset, -offset, colorUp);
+      layout.draw(canvas);
+      textPaint.setShadowLayer(shadowRadius, offset, offset, colorDown);
+    }
+
+    textPaint.setColor(foregroundColor);
+    textPaint.setStyle(Style.FILL);
+    layout.draw(canvas);
+    textPaint.setShadowLayer(0, 0, 0, 0);
+
+    canvas.restoreToCount(saveCount);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/text/Subtitle.java b/library/src/main/java/com/google/android/exoplayer/text/Subtitle.java
index ff542cfb96..2b2e1ad44b 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/Subtitle.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/Subtitle.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer.text;
 
+import java.util.List;
+
 /**
  * A subtitle that contains textual data associated with time indices.
  */
@@ -39,8 +41,8 @@
   public int getNextEventTimeIndex(long timeUs);
 
   /**
-   * Gets the number of event times, where events are defined as points in time at which the text
-   * returned by {@link #getText(long)} changes.
+   * Gets the number of event times, where events are defined as points in time at which the cues
+   * returned by {@link #getCues(long)} changes.
    *
    * @return The number of event times.
    */
@@ -62,11 +64,11 @@
   public long getLastEventTime();
 
   /**
-   * Retrieve the subtitle text that should be displayed at a given time.
+   * Retrieve the subtitle cues that should be displayed at a given time.
    *
    * @param timeUs The time in microseconds.
-   * @return The text that should be displayed, or null.
+   * @return A list of cues that should be displayed, possibly empty.
    */
-  public String getText(long timeUs);
+  public List<Cue> getCues(long timeUs);
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/text/SubtitleLayout.java b/library/src/main/java/com/google/android/exoplayer/text/SubtitleLayout.java
new file mode 100644
index 0000000000..690e7056e7
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/text/SubtitleLayout.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.util.AttributeSet;
+import android.view.View;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * A view for rendering rich-formatted captions.
+ */
+public final class SubtitleLayout extends View {
+
+  private final List<CuePainter> painters;
+
+  private List<Cue> cues;
+  private float fontScale;
+  private CaptionStyleCompat style;
+
+  public SubtitleLayout(Context context) {
+    this(context, null);
+  }
+
+  public SubtitleLayout(Context context, AttributeSet attrs) {
+    super(context, attrs);
+    painters = new ArrayList<>();
+    fontScale = 1;
+    style = CaptionStyleCompat.DEFAULT;
+  }
+
+  /**
+   * Sets the cues to be displayed by the view.
+   *
+   * @param cues The cues to display.
+   */
+  public void setCues(List<Cue> cues) {
+    if (this.cues == cues) {
+      return;
+    }
+    this.cues = cues;
+    // Ensure we have sufficient painters.
+    int cueCount = (cues == null) ? 0 : cues.size();
+    while (painters.size() < cueCount) {
+      painters.add(new CuePainter(getContext()));
+    }
+    // Invalidate to trigger drawing.
+    invalidate();
+  }
+
+  /**
+   * Sets the scale of the font.
+   *
+   * @param fontScale The scale of the font.
+   */
+  public void setFontScale(float fontScale) {
+    if (this.fontScale == fontScale) {
+      return;
+    }
+    this.fontScale = fontScale;
+    // Invalidate to trigger drawing.
+    invalidate();
+  }
+
+  /**
+   * Configures the view according to the given style.
+   *
+   * @param style A style for the view.
+   */
+  public void setStyle(CaptionStyleCompat style) {
+    if (this.style == style) {
+      return;
+    }
+    this.style = style;
+    // Invalidate to trigger drawing.
+    invalidate();
+  }
+
+  @Override
+  public void dispatchDraw(Canvas canvas) {
+    int cueCount = (cues == null) ? 0 : cues.size();
+    for (int i = 0; i < cueCount; i++) {
+      painters.get(i).draw(cues.get(i), style, fontScale, canvas, getLeft(), getTop(), getRight(),
+          getBottom());
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/text/SubtitleView.java b/library/src/main/java/com/google/android/exoplayer/text/SubtitleView.java
deleted file mode 100644
index 7b977aa7cc..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/text/SubtitleView.java
+++ /dev/null
@@ -1,297 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.text;
-
-import com.google.android.exoplayer.util.Util;
-
-import android.annotation.TargetApi;
-import android.content.Context;
-import android.content.res.Resources;
-import android.content.res.TypedArray;
-import android.graphics.Canvas;
-import android.graphics.Color;
-import android.graphics.Paint;
-import android.graphics.Paint.Join;
-import android.graphics.Paint.Style;
-import android.graphics.RectF;
-import android.graphics.Typeface;
-import android.text.StaticLayout;
-import android.text.TextPaint;
-import android.util.AttributeSet;
-import android.util.DisplayMetrics;
-import android.view.View;
-
-/**
- * A view for rendering captions.
- * <p>
- * The caption style and text size can be configured using {@link #setStyle(CaptionStyleCompat)} and
- * {@link #setTextSize(float)} respectively.
- */
-public class SubtitleView extends View {
-
-  /**
-   * Ratio of inner padding to font size.
-   */
-  private static final float INNER_PADDING_RATIO = 0.125f;
-
-  /**
-   * Temporary rectangle used for computing line bounds.
-   */
-  private final RectF lineBounds = new RectF();
-
-  /**
-   * Reusable string builder used for holding text.
-   */
-  private final StringBuilder textBuilder = new StringBuilder();
-
-  // Styled dimensions.
-  private final float cornerRadius;
-  private final float outlineWidth;
-  private final float shadowRadius;
-  private final float shadowOffset;
-
-  private TextPaint textPaint;
-  private Paint paint;
-
-  private int foregroundColor;
-  private int backgroundColor;
-  private int edgeColor;
-  private int edgeType;
-
-  private boolean hasMeasurements;
-  private int lastMeasuredWidth;
-  private StaticLayout layout;
-
-  private float spacingMult;
-  private float spacingAdd;
-  private int innerPaddingX;
-
-  public SubtitleView(Context context, AttributeSet attrs) {
-    this(context, attrs, 0);
-  }
-
-  public SubtitleView(Context context, AttributeSet attrs, int defStyleAttr) {
-    super(context, attrs, defStyleAttr);
-
-    int[] viewAttr = {android.R.attr.text, android.R.attr.textSize,
-        android.R.attr.lineSpacingExtra, android.R.attr.lineSpacingMultiplier};
-    TypedArray a = context.obtainStyledAttributes(attrs, viewAttr, defStyleAttr, 0);
-    CharSequence text = a.getText(0);
-    int textSize = a.getDimensionPixelSize(1, 15);
-    spacingAdd = a.getDimensionPixelSize(2, 0);
-    spacingMult = a.getFloat(3, 1);
-    a.recycle();
-
-    Resources resources = getContext().getResources();
-    DisplayMetrics displayMetrics = resources.getDisplayMetrics();
-    int twoDpInPx = Math.round((2f * displayMetrics.densityDpi) / DisplayMetrics.DENSITY_DEFAULT);
-    cornerRadius = twoDpInPx;
-    outlineWidth = twoDpInPx;
-    shadowRadius = twoDpInPx;
-    shadowOffset = twoDpInPx;
-
-    textPaint = new TextPaint();
-    textPaint.setAntiAlias(true);
-    textPaint.setSubpixelText(true);
-
-    paint = new Paint();
-    paint.setAntiAlias(true);
-
-    innerPaddingX = 0;
-    setText(text);
-    setTextSize(textSize);
-    setStyle(CaptionStyleCompat.DEFAULT);
-  }
-
-  public SubtitleView(Context context) {
-    this(context, null);
-  }
-
-  @Override
-  public void setBackgroundColor(int color) {
-    backgroundColor = color;
-    forceUpdate(false);
-  }
-
-  /**
-   * Sets the text to be displayed by the view.
-   *
-   * @param text The text to display.
-   */
-  public void setText(CharSequence text) {
-    textBuilder.setLength(0);
-    textBuilder.append(text);
-    forceUpdate(true);
-  }
-
-  /**
-   * Sets the text size in pixels.
-   *
-   * @param size The text size in pixels.
-   */
-  public void setTextSize(float size) {
-    if (textPaint.getTextSize() != size) {
-      textPaint.setTextSize(size);
-      innerPaddingX = (int) (size * INNER_PADDING_RATIO + 0.5f);
-      forceUpdate(true);
-    }
-  }
-
-  /**
-   * Configures the view according to the given style.
-   *
-   * @param style A style for the view.
-   */
-  public void setStyle(CaptionStyleCompat style) {
-    foregroundColor = style.foregroundColor;
-    backgroundColor = style.backgroundColor;
-    edgeType = style.edgeType;
-    edgeColor = style.edgeColor;
-    setTypeface(style.typeface);
-    super.setBackgroundColor(style.windowColor);
-    forceUpdate(true);
-  }
-
-  private void setTypeface(Typeface typeface) {
-    if (textPaint.getTypeface() != typeface) {
-      textPaint.setTypeface(typeface);
-      forceUpdate(true);
-    }
-  }
-
-  private void forceUpdate(boolean needsLayout) {
-    if (needsLayout) {
-      hasMeasurements = false;
-      requestLayout();
-    }
-    invalidate();
-  }
-
-  @Override
-  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-    final int widthSpec = MeasureSpec.getSize(widthMeasureSpec);
-
-    if (computeMeasurements(widthSpec)) {
-      final StaticLayout layout = this.layout;
-      final int paddingX = getPaddingLeft() + getPaddingRight() + innerPaddingX * 2;
-      final int height = layout.getHeight() + getPaddingTop() + getPaddingBottom();
-      int width = 0;
-      int lineCount = layout.getLineCount();
-      for (int i = 0; i < lineCount; i++) {
-        width = Math.max((int) Math.ceil(layout.getLineWidth(i)), width);
-      }
-      width += paddingX;
-      setMeasuredDimension(width, height);
-    } else if (Util.SDK_INT >= 11) {
-      setTooSmallMeasureDimensionV11();
-    } else {
-      setMeasuredDimension(0, 0);
-    }
-  }
-
-  @TargetApi(11)
-  private void setTooSmallMeasureDimensionV11() {
-    setMeasuredDimension(MEASURED_STATE_TOO_SMALL, MEASURED_STATE_TOO_SMALL);
-  }
-
-  @Override
-  public void onLayout(boolean changed, int l, int t, int r, int b) {
-    final int width = r - l;
-    computeMeasurements(width);
-  }
-
-  private boolean computeMeasurements(int maxWidth) {
-    if (hasMeasurements && maxWidth == lastMeasuredWidth) {
-      return true;
-    }
-
-    // Account for padding.
-    final int paddingX = getPaddingLeft() + getPaddingRight() + innerPaddingX * 2;
-    maxWidth -= paddingX;
-    if (maxWidth <= 0) {
-      return false;
-    }
-
-    hasMeasurements = true;
-    lastMeasuredWidth = maxWidth;
-    layout = new StaticLayout(textBuilder, textPaint, maxWidth, null, spacingMult, spacingAdd,
-        true);
-    return true;
-  }
-
-  @Override
-  protected void onDraw(Canvas c) {
-    final StaticLayout layout = this.layout;
-    if (layout == null) {
-      return;
-    }
-
-    final int saveCount = c.save();
-    final int innerPaddingX = this.innerPaddingX;
-    c.translate(getPaddingLeft() + innerPaddingX, getPaddingTop());
-
-    final int lineCount = layout.getLineCount();
-    final Paint textPaint = this.textPaint;
-    final Paint paint = this.paint;
-    final RectF bounds = lineBounds;
-
-    if (Color.alpha(backgroundColor) > 0) {
-      final float cornerRadius = this.cornerRadius;
-      float previousBottom = layout.getLineTop(0);
-
-      paint.setColor(backgroundColor);
-      paint.setStyle(Style.FILL);
-
-      for (int i = 0; i < lineCount; i++) {
-        bounds.left = layout.getLineLeft(i) - innerPaddingX;
-        bounds.right = layout.getLineRight(i) + innerPaddingX;
-        bounds.top = previousBottom;
-        bounds.bottom = layout.getLineBottom(i);
-        previousBottom = bounds.bottom;
-
-        c.drawRoundRect(bounds, cornerRadius, cornerRadius, paint);
-      }
-    }
-
-    if (edgeType == CaptionStyleCompat.EDGE_TYPE_OUTLINE) {
-      textPaint.setStrokeJoin(Join.ROUND);
-      textPaint.setStrokeWidth(outlineWidth);
-      textPaint.setColor(edgeColor);
-      textPaint.setStyle(Style.FILL_AND_STROKE);
-      layout.draw(c);
-    } else if (edgeType == CaptionStyleCompat.EDGE_TYPE_DROP_SHADOW) {
-      textPaint.setShadowLayer(shadowRadius, shadowOffset, shadowOffset, edgeColor);
-    } else if (edgeType == CaptionStyleCompat.EDGE_TYPE_RAISED
-        || edgeType == CaptionStyleCompat.EDGE_TYPE_DEPRESSED) {
-      boolean raised = edgeType == CaptionStyleCompat.EDGE_TYPE_RAISED;
-      int colorUp = raised ? Color.WHITE : edgeColor;
-      int colorDown = raised ? edgeColor : Color.WHITE;
-      float offset = shadowRadius / 2f;
-      textPaint.setColor(foregroundColor);
-      textPaint.setStyle(Style.FILL);
-      textPaint.setShadowLayer(shadowRadius, -offset, -offset, colorUp);
-      layout.draw(c);
-      textPaint.setShadowLayer(shadowRadius, offset, offset, colorDown);
-    }
-
-    textPaint.setColor(foregroundColor);
-    textPaint.setStyle(Style.FILL);
-    layout.draw(c);
-    textPaint.setShadowLayer(0, 0, 0, 0);
-    c.restoreToCount(saveCount);
-  }
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/text/TextRenderer.java b/library/src/main/java/com/google/android/exoplayer/text/TextRenderer.java
index 8b0b1ae6dc..03899c0b0c 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/TextRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/TextRenderer.java
@@ -15,16 +15,18 @@
  */
 package com.google.android.exoplayer.text;
 
+import java.util.List;
+
 /**
  * An interface for components that render text.
  */
 public interface TextRenderer {
 
   /**
-   * Invoked each time there is a change in the text to be rendered.
+   * Invoked each time there is a change in the {@link Cue}s to be rendered.
    *
-   * @param text The text to render, or null if no text is to be rendered.
+   * @param cues The {@link Cue}s to be rendered, or an empty list if no cues are to be rendered.
    */
-  void onText(String text);
+  void onCues(List<Cue> cues);
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/text/TextTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/text/TextTrackRenderer.java
index 3827e88a26..ef0195d6e3 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/TextTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/TextTrackRenderer.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer.MediaFormatHolder;
 import com.google.android.exoplayer.SampleHolder;
 import com.google.android.exoplayer.SampleSource;
+import com.google.android.exoplayer.SampleSource.SampleSourceReader;
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.util.Assertions;
 
@@ -30,6 +31,8 @@
 import android.os.Message;
 
 import java.io.IOException;
+import java.util.Collections;
+import java.util.List;
 
 /**
  * A {@link TrackRenderer} for textual subtitles. The actual rendering of each line of text to a
@@ -42,21 +45,20 @@
 
   private final Handler textRendererHandler;
   private final TextRenderer textRenderer;
-  private final SampleSource source;
+  private final SampleSourceReader source;
   private final MediaFormatHolder formatHolder;
   private final SubtitleParser[] subtitleParsers;
 
   private int parserIndex;
   private int trackIndex;
 
-  private long currentPositionUs;
   private boolean inputStreamEnded;
 
   private Subtitle subtitle;
+  private Subtitle nextSubtitle;
   private SubtitleParserHelper parserHelper;
   private HandlerThread parserThread;
   private int nextSubtitleEventIndex;
-  private boolean textRendererNeedsUpdate;
 
   /**
    * @param source A source from which samples containing subtitle data can be read.
@@ -71,7 +73,7 @@
    */
   public TextTrackRenderer(SampleSource source, TextRenderer textRenderer,
       Looper textRendererLooper, SubtitleParser... subtitleParsers) {
-    this.source = Assertions.checkNotNull(source);
+    this.source = source.register();
     this.textRenderer = Assertions.checkNotNull(textRenderer);
     this.textRendererHandler = textRendererLooper == null ? null
         : new Handler(textRendererLooper, this);
@@ -107,81 +109,74 @@ protected void onEnabled(long positionUs, boolean joining) {
     parserThread = new HandlerThread("textParser");
     parserThread.start();
     parserHelper = new SubtitleParserHelper(parserThread.getLooper(), subtitleParsers[parserIndex]);
-    seekToInternal(positionUs);
+    seekToInternal();
   }
 
   @Override
   protected void seekTo(long positionUs) {
     source.seekToUs(positionUs);
-    seekToInternal(positionUs);
+    seekToInternal();
   }
 
-  private void seekToInternal(long positionUs) {
+  private void seekToInternal() {
     inputStreamEnded = false;
-    currentPositionUs = positionUs;
-    source.seekToUs(positionUs);
-    if (subtitle != null && (positionUs < subtitle.getStartTime()
-        || subtitle.getLastEventTime() <= positionUs)) {
-      subtitle = null;
-    }
+    subtitle = null;
+    nextSubtitle = null;
     parserHelper.flush();
     clearTextRenderer();
-    syncNextEventIndex(positionUs);
-    textRendererNeedsUpdate = subtitle != null;
   }
 
   @Override
   protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
-    currentPositionUs = positionUs;
     try {
-      source.continueBuffering(positionUs);
+      source.continueBuffering(trackIndex, positionUs);
     } catch (IOException e) {
       throw new ExoPlaybackException(e);
     }
 
-    if (parserHelper.isParsing()) {
-      return;
-    }
-
-    Subtitle dequeuedSubtitle = null;
-    if (subtitle == null) {
+    if (nextSubtitle == null) {
       try {
-        dequeuedSubtitle = parserHelper.getAndClearResult();
+        nextSubtitle = parserHelper.getAndClearResult();
       } catch (IOException e) {
         throw new ExoPlaybackException(e);
       }
     }
 
-    if (subtitle == null && dequeuedSubtitle != null) {
-      // We've dequeued a new subtitle. Sync the event index and update the subtitle.
-      subtitle = dequeuedSubtitle;
-      syncNextEventIndex(positionUs);
-      textRendererNeedsUpdate = true;
-    } else if (subtitle != null) {
+    boolean textRendererNeedsUpdate = false;
+    long subtitleNextEventTimeUs = Long.MAX_VALUE;
+    if (subtitle != null) {
       // We're iterating through the events in a subtitle. Set textRendererNeedsUpdate if we
       // advance to the next event.
-      long nextEventTimeUs = getNextEventTime();
-      while (nextEventTimeUs <= positionUs) {
+      subtitleNextEventTimeUs = getNextEventTime();
+      while (subtitleNextEventTimeUs <= positionUs) {
         nextSubtitleEventIndex++;
-        nextEventTimeUs = getNextEventTime();
+        subtitleNextEventTimeUs = getNextEventTime();
         textRendererNeedsUpdate = true;
       }
-      if (nextEventTimeUs == Long.MAX_VALUE) {
-        // We've finished processing the subtitle.
-        subtitle = null;
-      }
     }
 
-    // We don't have a subtitle. Try and read the next one from the source, and if we succeed then
-    // sync and set textRendererNeedsUpdate.
-    if (!inputStreamEnded && subtitle == null) {
+    if (subtitleNextEventTimeUs == Long.MAX_VALUE && nextSubtitle != null
+        && nextSubtitle.getStartTime() <= positionUs) {
+      // Advance to the next subtitle. Sync the next event index and trigger an update.
+      subtitle = nextSubtitle;
+      nextSubtitle = null;
+      nextSubtitleEventIndex = subtitle.getNextEventTimeIndex(positionUs);
+      textRendererNeedsUpdate = true;
+    }
+
+    if (textRendererNeedsUpdate && getState() == TrackRenderer.STATE_STARTED) {
+      // textRendererNeedsUpdate is set and we're playing. Update the renderer.
+      updateTextRenderer(subtitle.getCues(positionUs));
+    }
+
+    if (!inputStreamEnded && nextSubtitle == null && !parserHelper.isParsing()) {
+      // Try and read the next subtitle from the source.
       try {
         SampleHolder sampleHolder = parserHelper.getSampleHolder();
         sampleHolder.clearData();
         int result = source.readData(trackIndex, positionUs, formatHolder, sampleHolder, false);
         if (result == SampleSource.SAMPLE_READ) {
           parserHelper.startParseOperation();
-          textRendererNeedsUpdate = false;
         } else if (result == SampleSource.END_OF_STREAM) {
           inputStreamEnded = true;
         }
@@ -189,21 +184,12 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPla
         throw new ExoPlaybackException(e);
       }
     }
-
-    // Update the text renderer if we're both playing and textRendererNeedsUpdate is set.
-    if (textRendererNeedsUpdate && getState() == TrackRenderer.STATE_STARTED) {
-      textRendererNeedsUpdate = false;
-      if (subtitle == null) {
-        clearTextRenderer();
-      } else {
-        updateTextRenderer(positionUs);
-      }
-    }
   }
 
   @Override
   protected void onDisabled() {
     subtitle = null;
+    nextSubtitle = null;
     parserThread.quit();
     parserThread = null;
     parserHelper = null;
@@ -216,11 +202,6 @@ protected void onReleased() {
     source.release();
   }
 
-  @Override
-  protected long getCurrentPositionUs() {
-    return currentPositionUs;
-  }
-
   @Override
   protected long getDurationUs() {
     return source.getTrackInfo(trackIndex).durationUs;
@@ -234,7 +215,7 @@ protected long getBufferedPositionUs() {
 
   @Override
   protected boolean isEnded() {
-    return inputStreamEnded && subtitle == null;
+    return inputStreamEnded && (subtitle == null || getNextEventTime() == Long.MAX_VALUE);
   }
 
   @Override
@@ -244,45 +225,37 @@ protected boolean isReady() {
     return true;
   }
 
-  private void syncNextEventIndex(long positionUs) {
-    nextSubtitleEventIndex = subtitle == null ? -1 : subtitle.getNextEventTimeIndex(positionUs);
-  }
-
   private long getNextEventTime() {
     return ((nextSubtitleEventIndex == -1)
         || (nextSubtitleEventIndex >= subtitle.getEventTimeCount())) ? Long.MAX_VALUE
         : (subtitle.getEventTime(nextSubtitleEventIndex));
   }
 
-  private void updateTextRenderer(long positionUs) {
-    String text = subtitle.getText(positionUs);
+  private void updateTextRenderer(List<Cue> cues) {
     if (textRendererHandler != null) {
-      textRendererHandler.obtainMessage(MSG_UPDATE_OVERLAY, text).sendToTarget();
+      textRendererHandler.obtainMessage(MSG_UPDATE_OVERLAY, cues).sendToTarget();
     } else {
-      invokeRendererInternal(text);
+      invokeRendererInternalCues(cues);
     }
   }
 
   private void clearTextRenderer() {
-    if (textRendererHandler != null) {
-      textRendererHandler.obtainMessage(MSG_UPDATE_OVERLAY, null).sendToTarget();
-    } else {
-      invokeRendererInternal(null);
-    }
+    updateTextRenderer(Collections.<Cue>emptyList());
   }
 
+  @SuppressWarnings("unchecked")
   @Override
   public boolean handleMessage(Message msg) {
     switch (msg.what) {
       case MSG_UPDATE_OVERLAY:
-        invokeRendererInternal((String) msg.obj);
+        invokeRendererInternalCues((List<Cue>) msg.obj);
         return true;
     }
     return false;
   }
 
-  private void invokeRendererInternal(String text) {
-    textRenderer.onText(text);
+  private void invokeRendererInternalCues(List<Cue> cues) {
+    textRenderer.onCues(cues);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608Parser.java b/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608Parser.java
index 4beede6eed..9fdf41ba08 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608Parser.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608Parser.java
@@ -109,7 +109,7 @@
   /* package */ Eia608Parser() {
     seiBuffer = new ParsableBitArray();
     stringBuilder = new StringBuilder();
-    captions = new ArrayList<ClosedCaption>();
+    captions = new ArrayList<>();
   }
 
   /* package */ boolean canParse(String mimeType) {
diff --git a/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608TrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608TrackRenderer.java
index 48438ce1b4..3dd37ab51a 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608TrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608TrackRenderer.java
@@ -20,7 +20,9 @@
 import com.google.android.exoplayer.MediaFormatHolder;
 import com.google.android.exoplayer.SampleHolder;
 import com.google.android.exoplayer.SampleSource;
+import com.google.android.exoplayer.SampleSource.SampleSourceReader;
 import com.google.android.exoplayer.TrackRenderer;
+import com.google.android.exoplayer.text.Cue;
 import com.google.android.exoplayer.text.TextRenderer;
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.Util;
@@ -31,6 +33,7 @@
 import android.os.Message;
 
 import java.io.IOException;
+import java.util.Collections;
 import java.util.TreeSet;
 
 /**
@@ -50,7 +53,7 @@
   // The maximum duration that captions are parsed ahead of the current position.
   private static final int MAX_SAMPLE_READAHEAD_US = 5000000;
 
-  private final SampleSource source;
+  private final SampleSourceReader source;
   private final Eia608Parser eia608Parser;
   private final TextRenderer textRenderer;
   private final Handler textRendererHandler;
@@ -60,7 +63,6 @@
   private final TreeSet<ClosedCaptionList> pendingCaptionLists;
 
   private int trackIndex;
-  private long currentPositionUs;
   private boolean inputStreamEnded;
 
   private int captionMode;
@@ -79,14 +81,14 @@
    */
   public Eia608TrackRenderer(SampleSource source, TextRenderer textRenderer,
       Looper textRendererLooper) {
-    this.source = Assertions.checkNotNull(source);
+    this.source = source.register();
     this.textRenderer = Assertions.checkNotNull(textRenderer);
     textRendererHandler = textRendererLooper == null ? null : new Handler(textRendererLooper, this);
     eia608Parser = new Eia608Parser();
     formatHolder = new MediaFormatHolder();
     sampleHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_NORMAL);
     captionStringBuilder = new StringBuilder();
-    pendingCaptionLists = new TreeSet<ClosedCaptionList>();
+    pendingCaptionLists = new TreeSet<>();
   }
 
   @Override
@@ -111,17 +113,16 @@ protected int doPrepare(long positionUs) throws ExoPlaybackException {
   @Override
   protected void onEnabled(long positionUs, boolean joining) {
     source.enable(trackIndex, positionUs);
-    seekToInternal(positionUs);
+    seekToInternal();
   }
 
   @Override
   protected void seekTo(long positionUs) throws ExoPlaybackException {
     source.seekToUs(positionUs);
-    seekToInternal(positionUs);
+    seekToInternal();
   }
 
-  private void seekToInternal(long positionUs) {
-    currentPositionUs = positionUs;
+  private void seekToInternal() {
     inputStreamEnded = false;
     pendingCaptionLists.clear();
     clearPendingSample();
@@ -131,17 +132,15 @@ private void seekToInternal(long positionUs) {
   }
 
   @Override
-  protected void doSomeWork(long positionUs, long elapsedRealtimeUs)
-      throws ExoPlaybackException {
-    currentPositionUs = positionUs;
+  protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
     try {
-      source.continueBuffering(positionUs);
+      source.continueBuffering(trackIndex, positionUs);
     } catch (IOException e) {
       throw new ExoPlaybackException(e);
     }
 
     if (isSamplePending()) {
-      maybeParsePendingSample();
+      maybeParsePendingSample(positionUs);
     }
 
     int result = inputStreamEnded ? SampleSource.END_OF_STREAM : SampleSource.SAMPLE_READ;
@@ -149,17 +148,19 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs)
       try {
         result = source.readData(trackIndex, positionUs, formatHolder, sampleHolder, false);
         if (result == SampleSource.SAMPLE_READ) {
-          maybeParsePendingSample();
+          maybeParsePendingSample(positionUs);
         } else if (result == SampleSource.END_OF_STREAM) {
           inputStreamEnded = true;
         }
       } catch (IOException e) {
-        throw new ExoPlaybackException(e);
+        // TODO: This should be propagated, but in the current design propagation may occur too
+        // early. See [Internal b/22291244].
+        // throw new ExoPlaybackException(e);
       }
     }
 
     while (!pendingCaptionLists.isEmpty()) {
-      if (pendingCaptionLists.first().timeUs > currentPositionUs) {
+      if (pendingCaptionLists.first().timeUs > positionUs) {
         // We're too early to render any of the pending caption lists.
         return;
       }
@@ -183,11 +184,6 @@ protected long getDurationUs() {
     return source.getTrackInfo(trackIndex).durationUs;
   }
 
-  @Override
-  protected long getCurrentPositionUs() {
-    return currentPositionUs;
-  }
-
   @Override
   protected long getBufferedPositionUs() {
     return TrackRenderer.END_OF_TRACK_US;
@@ -227,12 +223,16 @@ public boolean handleMessage(Message msg) {
     return false;
   }
 
-  private void invokeRendererInternal(String text) {
-    textRenderer.onText(text);
+  private void invokeRendererInternal(String cueText) {
+    if (cueText == null) {
+      textRenderer.onCues(Collections.<Cue>emptyList());
+    } else {
+      textRenderer.onCues(Collections.singletonList(new Cue(cueText)));
+    }
   }
 
-  private void maybeParsePendingSample() {
-    if (sampleHolder.timeUs > currentPositionUs + MAX_SAMPLE_READAHEAD_US) {
+  private void maybeParsePendingSample(long positionUs) {
+    if (sampleHolder.timeUs > positionUs + MAX_SAMPLE_READAHEAD_US) {
       // We're too early to parse the sample.
       return;
     }
diff --git a/library/src/main/java/com/google/android/exoplayer/text/subrip/SubripParser.java b/library/src/main/java/com/google/android/exoplayer/text/subrip/SubripParser.java
new file mode 100644
index 0000000000..bfd04df251
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/text/subrip/SubripParser.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text.subrip;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.text.Cue;
+import com.google.android.exoplayer.text.SubtitleParser;
+import com.google.android.exoplayer.util.LongArray;
+import com.google.android.exoplayer.util.MimeTypes;
+
+import android.text.Html;
+import android.text.Spanned;
+import android.text.TextUtils;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.ArrayList;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * A simple SubRip parser.
+ */
+public final class SubripParser implements SubtitleParser {
+
+  private static final Pattern SUBRIP_TIMING_LINE = Pattern.compile("(.*)\\s+-->\\s+(.*)");
+  private static final Pattern SUBRIP_TIMESTAMP =
+      Pattern.compile("(?:(\\d+):)?(\\d+):(\\d+),(\\d+)");
+
+  private final StringBuilder textBuilder;
+
+  public SubripParser() {
+    textBuilder = new StringBuilder();
+  }
+
+  @Override
+  public SubripSubtitle parse(InputStream inputStream, String inputEncoding, long startTimeUs)
+      throws IOException {
+    ArrayList<Cue> cues = new ArrayList<>();
+    LongArray cueTimesUs = new LongArray();
+    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, C.UTF8_NAME));
+    String currentLine;
+
+    while ((currentLine = reader.readLine()) != null) {
+      // Parse the numeric counter as a sanity check.
+      try {
+        Integer.parseInt(currentLine);
+      } catch (NumberFormatException e) {
+        throw new ParserException("Expected numeric counter: " + currentLine);
+      }
+
+      // Read and parse the timing line.
+      currentLine = reader.readLine();
+      Matcher matcher = SUBRIP_TIMING_LINE.matcher(currentLine);
+      if (matcher.find()) {
+        cueTimesUs.add(startTimeUs + parseTimestampUs(matcher.group(1)));
+        cueTimesUs.add(startTimeUs + parseTimestampUs(matcher.group(2)));
+      } else {
+        throw new ParserException("Expected timing line: " + currentLine);
+      }
+
+      // Read and parse the text.
+      textBuilder.setLength(0);
+      while (!TextUtils.isEmpty(currentLine = reader.readLine())) {
+        if (textBuilder.length() > 0) {
+          textBuilder.append("<br>");
+        }
+        textBuilder.append(currentLine.trim());
+      }
+
+      Spanned text = Html.fromHtml(textBuilder.toString());
+      cues.add(new Cue(text));
+    }
+
+    Cue[] cuesArray = new Cue[cues.size()];
+    cues.toArray(cuesArray);
+    long[] cueTimesUsArray = cueTimesUs.toArray();
+    return new SubripSubtitle(startTimeUs, cuesArray, cueTimesUsArray);
+  }
+
+  @Override
+  public boolean canParse(String mimeType) {
+    return MimeTypes.APPLICATION_SUBRIP.equals(mimeType);
+  }
+
+  private static long parseTimestampUs(String s) throws NumberFormatException {
+    Matcher matcher = SUBRIP_TIMESTAMP.matcher(s);
+    if (!matcher.matches()) {
+      throw new NumberFormatException("has invalid format");
+    }
+    long timestampMs = Long.parseLong(matcher.group(1)) * 60 * 60 * 1000;
+    timestampMs += Long.parseLong(matcher.group(2)) * 60 * 1000;
+    timestampMs += Long.parseLong(matcher.group(3)) * 1000;
+    timestampMs += Long.parseLong(matcher.group(4));
+    return timestampMs * 1000;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/text/subrip/SubripSubtitle.java b/library/src/main/java/com/google/android/exoplayer/text/subrip/SubripSubtitle.java
new file mode 100644
index 0000000000..9931a1490f
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/text/subrip/SubripSubtitle.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text.subrip;
+
+import com.google.android.exoplayer.text.Cue;
+import com.google.android.exoplayer.text.Subtitle;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.Util;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * A representation of a SubRip subtitle.
+ */
+/* package */ final class SubripSubtitle implements Subtitle {
+
+  private final long startTimeUs;
+
+  private final Cue[] cues;
+  private final long[] cueTimesUs;
+
+  /**
+   * @param startTimeUs The start time of the subtitle, in microseconds.
+   * @param cues The cues in the subtitle.
+   * @param cueTimesUs Interleaved cue start and end times, in microseconds.
+   */
+  public SubripSubtitle(long startTimeUs, Cue[] cues, long[] cueTimesUs) {
+    this.startTimeUs = startTimeUs;
+    this.cues = cues;
+    this.cueTimesUs = cueTimesUs;
+  }
+
+  @Override
+  public long getStartTime() {
+    return startTimeUs;
+  }
+
+  @Override
+  public int getNextEventTimeIndex(long timeUs) {
+    int index = Util.binarySearchCeil(cueTimesUs, timeUs, false, false);
+    return index < cueTimesUs.length ? index : -1;
+  }
+
+  @Override
+  public int getEventTimeCount() {
+    return cueTimesUs.length;
+  }
+
+  @Override
+  public long getEventTime(int index) {
+    Assertions.checkArgument(index >= 0);
+    Assertions.checkArgument(index < cueTimesUs.length);
+    return cueTimesUs[index];
+  }
+
+  @Override
+  public long getLastEventTime() {
+    if (getEventTimeCount() == 0) {
+      return -1;
+    }
+    return cueTimesUs[cueTimesUs.length - 1];
+  }
+
+  @Override
+  public List<Cue> getCues(long timeUs) {
+    int index = Util.binarySearchFloor(cueTimesUs, timeUs, true, false);
+    if (index == -1 || index % 2 == 1) {
+      // timeUs is earlier than the start of the first cue, or corresponds to a gap between cues.
+      return Collections.<Cue>emptyList();
+    } else {
+      return Collections.singletonList(cues[index / 2]);
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlNode.java b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlNode.java
index 4ee1726b91..f476dde013 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlNode.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlNode.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer.text.ttml;
 
+import android.text.SpannableStringBuilder;
+
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
@@ -44,15 +46,15 @@
   public static final String TAG_SMPTE_INFORMATION = "smpte:information";
 
   public final String tag;
-  public final boolean isTextNode;
   public final String text;
+  public final boolean isTextNode;
   public final long startTimeUs;
   public final long endTimeUs;
 
   private List<TtmlNode> children;
 
   public static TtmlNode buildTextNode(String text) {
-    return new TtmlNode(null, applySpacePolicy(text, true), UNDEFINED_TIME, UNDEFINED_TIME);
+    return new TtmlNode(null, applyTextElementSpacePolicy(text), UNDEFINED_TIME, UNDEFINED_TIME);
   }
 
   public static TtmlNode buildNode(String tag, long startTimeUs, long endTimeUs) {
@@ -76,7 +78,7 @@ public boolean isActive(long timeUs) {
 
   public void addChild(TtmlNode child) {
     if (children == null) {
-      children = new ArrayList<TtmlNode>();
+      children = new ArrayList<>();
     }
     children.add(child);
   }
@@ -93,7 +95,7 @@ public int getChildCount() {
   }
 
   public long[] getEventTimesUs() {
-    TreeSet<Long> eventTimeSet = new TreeSet<Long>();
+    TreeSet<Long> eventTimeSet = new TreeSet<>();
     getEventTimes(eventTimeSet, false);
     long[] eventTimes = new long[eventTimeSet.size()];
     Iterator<Long> eventTimeIterator = eventTimeSet.iterator();
@@ -123,47 +125,104 @@ private void getEventTimes(TreeSet<Long> out, boolean descendsPNode) {
     }
   }
 
-  public String getText(long timeUs) {
-    StringBuilder builder = new StringBuilder();
-    getText(timeUs, builder, false);
-    return applySpacePolicy(builder.toString().replaceAll("\n$", ""), false);
+  public CharSequence getText(long timeUs) {
+    SpannableStringBuilder builder = getText(timeUs, new SpannableStringBuilder(), false);
+    // Having joined the text elements, we need to do some final cleanup on the result.
+    // 1. Collapse multiple consecutive spaces into a single space.
+    int builderLength = builder.length();
+    for (int i = 0; i < builderLength; i++) {
+      if (builder.charAt(i) == ' ') {
+        int j = i + 1;
+        while (j < builder.length() && builder.charAt(j) == ' ') {
+          j++;
+        }
+        int spacesToDelete = j - (i + 1);
+        if (spacesToDelete > 0) {
+          builder.delete(i, i + spacesToDelete);
+          builderLength -= spacesToDelete;
+        }
+      }
+    }
+    // 2. Remove any spaces from the start of each line.
+    if (builderLength > 0 && builder.charAt(0) == ' ') {
+      builder.delete(0, 1);
+      builderLength--;
+    }
+    for (int i = 0; i < builderLength - 1; i++) {
+      if (builder.charAt(i) == '\n' && builder.charAt(i + 1) == ' ') {
+        builder.delete(i + 1, i + 2);
+        builderLength--;
+      }
+    }
+    // 3. Remove any spaces from the end of each line.
+    if (builderLength > 0 && builder.charAt(builderLength - 1) == ' ') {
+      builder.delete(builderLength - 1, builderLength);
+      builderLength--;
+    }
+    for (int i = 0; i < builderLength - 1; i++) {
+      if (builder.charAt(i) == ' ' && builder.charAt(i + 1) == '\n') {
+        builder.delete(i, i + 1);
+        builderLength--;
+      }
+    }
+    // 4. Trim a trailing newline, if there is one.
+    if (builderLength > 0 && builder.charAt(builderLength - 1) == '\n') {
+      builder.delete(builderLength - 1, builderLength);
+      builderLength--;
+    }
+    return builder.subSequence(0, builderLength);
   }
 
-  private void getText(long timeUs, StringBuilder builder, boolean descendsPNode) {
+  private SpannableStringBuilder getText(long timeUs, SpannableStringBuilder builder,
+      boolean descendsPNode) {
     if (isTextNode && descendsPNode) {
       builder.append(text);
     } else if (TAG_BR.equals(tag) && descendsPNode) {
-      builder.append("\n");
+      builder.append('\n');
     } else if (TAG_METADATA.equals(tag)) {
       // Do nothing.
     } else if (isActive(timeUs)) {
       boolean isPNode = TAG_P.equals(tag);
-      int length = builder.length();
       for (int i = 0; i < getChildCount(); ++i) {
         getChild(i).getText(timeUs, builder, descendsPNode || isPNode);
       }
-      if (isPNode && length != builder.length()) {
-        builder.append("\n");
+      if (isPNode) {
+        endParagraph(builder);
       }
     }
+    return builder;
+  }
+
+  /**
+   * Invoked when the end of a paragraph is encountered. Adds a newline if there are one or more
+   * non-space characters since the previous newline.
+   *
+   * @param builder The builder.
+   */
+  private static void endParagraph(SpannableStringBuilder builder) {
+    int position = builder.length() - 1;
+    while (position >= 0 && builder.charAt(position) == ' ') {
+      position--;
+    }
+    if (position >= 0 && builder.charAt(position) != '\n') {
+      builder.append('\n');
+    }
   }
 
   /**
-   * Applies the space policy to the given string. See:
-   * <a href src="http://www.w3.org/TR/ttaf1-dfxp/#content-attribute-space">The default space
-   * policy</a>
+   * Applies the appropriate space policy to the given text element.
    *
-   * @param in A string to apply the policy.
-   * @param treatLineFeedAsSpace Whether to convert line feeds to spaces.
+   * @param in The text element to which the policy should be applied.
+   * @return The result of applying the policy to the text element.
    */
-  private static String applySpacePolicy(String in, boolean treatLineFeedAsSpace) {
+  private static String applyTextElementSpacePolicy(String in) {
     // Removes carriage return followed by line feed. See: http://www.w3.org/TR/xml/#sec-line-ends
     String out = in.replaceAll("\r\n", "\n");
     // Apply suppress-at-line-break="auto" and
     // white-space-treatment="ignore-if-surrounding-linefeed"
     out = out.replaceAll(" *\n *", "\n");
     // Apply linefeed-treatment="treat-as-space"
-    out = treatLineFeedAsSpace ? out.replaceAll("\n", " ") : out;
+    out = out.replaceAll("\n", " ");
     // Apply white-space-collapse="true"
     out = out.replaceAll("[ \t\\x0B\f\r]+", " ");
     return out;
diff --git a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java
index 46fd26cd01..d93f99fea0 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java
@@ -77,15 +77,15 @@
   private final boolean strictParsing;
 
   /**
-   * Equivalent to {@code TtmlParser(true)}.
+   * Equivalent to {@code TtmlParser(false)}.
    */
   public TtmlParser() {
-    this(true);
+    this(false);
   }
 
   /**
    * @param strictParsing If true, {@link #parse(InputStream, String, long)} will throw a
-   *     {@link ParserException} if the stream contains invalid ttml. If false, the parser will
+   *     {@link ParserException} if the stream contains invalid data. If false, the parser will
    *     make a best effort to ignore minor errors in the stream. Note however that a
    *     {@link ParserException} will still be thrown when this is not possible.
    */
@@ -105,7 +105,7 @@ public Subtitle parse(InputStream inputStream, String inputEncoding, long startT
       XmlPullParser xmlParser = xmlParserFactory.newPullParser();
       xmlParser.setInput(inputStream, inputEncoding);
       TtmlSubtitle ttmlSubtitle = null;
-      LinkedList<TtmlNode> nodeStack = new LinkedList<TtmlNode>();
+      LinkedList<TtmlNode> nodeStack = new LinkedList<>();
       int unsupportedNodeDepth = 0;
       int eventType = xmlParser.getEventType();
       while (eventType != XmlPullParser.END_DOCUMENT) {
diff --git a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlSubtitle.java b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlSubtitle.java
index a0c4da091e..cfcd657082 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlSubtitle.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlSubtitle.java
@@ -15,9 +15,13 @@
  */
 package com.google.android.exoplayer.text.ttml;
 
+import com.google.android.exoplayer.text.Cue;
 import com.google.android.exoplayer.text.Subtitle;
 import com.google.android.exoplayer.util.Util;
 
+import java.util.Collections;
+import java.util.List;
+
 /**
  * A representation of a TTML subtitle.
  */
@@ -60,8 +64,14 @@ public long getLastEventTime() {
   }
 
   @Override
-  public String getText(long timeUs) {
-    return root.getText(timeUs - startTimeUs);
+  public List<Cue> getCues(long timeUs) {
+    CharSequence cueText = root.getText(timeUs - startTimeUs);
+    if (cueText == null) {
+      return Collections.<Cue>emptyList();
+    } else {
+      Cue cue = new Cue(cueText);
+      return Collections.singletonList(cue);
+    }
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/text/tx3g/Tx3gParser.java b/library/src/main/java/com/google/android/exoplayer/text/tx3g/Tx3gParser.java
new file mode 100644
index 0000000000..2d4d04079b
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/text/tx3g/Tx3gParser.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text.tx3g;
+
+import com.google.android.exoplayer.text.Cue;
+import com.google.android.exoplayer.text.Subtitle;
+import com.google.android.exoplayer.text.SubtitleParser;
+import com.google.android.exoplayer.util.MimeTypes;
+
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * A {@link SubtitleParser} for tx3g.
+ * <p>
+ * Currently only supports parsing of a single text track.
+ */
+public final class Tx3gParser implements SubtitleParser {
+
+  @Override
+  public Subtitle parse(InputStream inputStream, String inputEncoding, long startTimeUs)
+      throws IOException {
+    DataInputStream dataInputStream  = new DataInputStream(inputStream);
+    String cueText = dataInputStream.readUTF();
+    return new Tx3gSubtitle(startTimeUs, new Cue(cueText));
+  }
+
+  @Override
+  public boolean canParse(String mimeType) {
+    return MimeTypes.APPLICATION_TX3G.equals(mimeType);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/text/tx3g/Tx3gSubtitle.java b/library/src/main/java/com/google/android/exoplayer/text/tx3g/Tx3gSubtitle.java
new file mode 100644
index 0000000000..dfcaf98863
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/text/tx3g/Tx3gSubtitle.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text.tx3g;
+
+import com.google.android.exoplayer.text.Cue;
+import com.google.android.exoplayer.text.Subtitle;
+import com.google.android.exoplayer.util.Assertions;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * A representation of a tx3g subtitle.
+ */
+/* package */ final class Tx3gSubtitle implements Subtitle {
+
+  private final long startTimeUs;
+  private final List<Cue> cues;
+
+  public Tx3gSubtitle(long startTimeUs, Cue cue) {
+    this.startTimeUs = startTimeUs;
+    this.cues = Collections.singletonList(cue);
+  }
+
+  @Override
+  public long getStartTime() {
+    return startTimeUs;
+  }
+
+  @Override
+  public int getNextEventTimeIndex(long timeUs) {
+    return timeUs < startTimeUs ? 0 : -1;
+  }
+
+  @Override
+  public int getEventTimeCount() {
+    return 1;
+  }
+
+  @Override
+  public long getEventTime(int index) {
+    Assertions.checkArgument(index == 0);
+    return startTimeUs;
+  }
+
+  @Override
+  public long getLastEventTime() {
+    return startTimeUs;
+  }
+
+  @Override
+  public List<Cue> getCues(long timeUs) {
+    return timeUs >= startTimeUs ? cues : Collections.<Cue>emptyList();
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttCue.java b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttCue.java
new file mode 100644
index 0000000000..1d6d3c554a
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttCue.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text.webvtt;
+
+import com.google.android.exoplayer.text.Cue;
+
+import android.text.Layout.Alignment;
+
+/**
+ * A representation of a WebVTT cue.
+ */
+/* package */ final class WebvttCue extends Cue {
+
+  public final long startTime;
+  public final long endTime;
+
+  public WebvttCue(CharSequence text) {
+    this(Cue.UNSET_VALUE, Cue.UNSET_VALUE, text);
+  }
+
+  public WebvttCue(long startTime, long endTime, CharSequence text) {
+    this(startTime, endTime, text, Cue.UNSET_VALUE, Cue.UNSET_VALUE, null, Cue.UNSET_VALUE);
+  }
+
+  public WebvttCue(long startTime, long endTime, CharSequence text, int line, int position,
+      Alignment alignment, int size) {
+    super(text, line, position, alignment, size);
+    this.startTime = startTime;
+    this.endTime = endTime;
+  }
+
+  /**
+   * Returns whether or not this cue should be placed in the default position and rolled-up with
+   * the other "normal" cues.
+   *
+   * @return True if this cue should be placed in the default position; false otherwise.
+   */
+  public boolean isNormalCue() {
+    return (line == UNSET_VALUE && position == UNSET_VALUE);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParser.java b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParser.java
index 5d331a78b2..0503eb2299 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParser.java
@@ -17,9 +17,14 @@
 
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.text.Cue;
 import com.google.android.exoplayer.text.SubtitleParser;
 import com.google.android.exoplayer.util.MimeTypes;
 
+import android.text.Html;
+import android.text.Layout.Alignment;
+import android.util.Log;
+
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStream;
@@ -35,23 +40,14 @@
  */
 public class WebvttParser implements SubtitleParser {
 
-  /**
-   * This parser allows a custom header to be prepended to the WebVTT data, in the form of a text
-   * line starting with this string.
-   *
-   * @hide
-   */
-  public static final String EXO_HEADER = "EXO-HEADER";
-  /**
-   * A {@code OFFSET + value} element can be added to the custom header to specify an offset time
-   * (in microseconds) that should be subtracted from the embedded MPEGTS value.
-   *
-   * @hide
-   */
-  public static final String OFFSET = "OFFSET:";
+  private static final String TAG = "WebvttParser";
 
   private static final long SAMPLING_RATE = 90;
 
+  private static final String WEBVTT_FILE_HEADER_STRING = "^\uFEFF?WEBVTT((\\u0020|\u0009).*)?$";
+  private static final Pattern WEBVTT_FILE_HEADER =
+      Pattern.compile(WEBVTT_FILE_HEADER_STRING);
+
   private static final String WEBVTT_METADATA_HEADER_STRING = "\\S*[:=]\\S*";
   private static final Pattern WEBVTT_METADATA_HEADER =
       Pattern.compile(WEBVTT_METADATA_HEADER_STRING);
@@ -63,27 +59,41 @@
   private static final String WEBVTT_TIMESTAMP_STRING = "(\\d+:)?[0-5]\\d:[0-5]\\d\\.\\d{3}";
   private static final Pattern WEBVTT_TIMESTAMP = Pattern.compile(WEBVTT_TIMESTAMP_STRING);
 
-  private static final Pattern MEDIA_TIMESTAMP_OFFSET = Pattern.compile(OFFSET + "\\d+");
+  private static final String WEBVTT_CUE_SETTING_STRING = "\\S*:\\S*";
+  private static final Pattern WEBVTT_CUE_SETTING = Pattern.compile(WEBVTT_CUE_SETTING_STRING);
+
+  private static final Pattern MEDIA_TIMESTAMP_OFFSET =
+      Pattern.compile(C.WEBVTT_EXO_HEADER_OFFSET + "\\-?\\d+");
   private static final Pattern MEDIA_TIMESTAMP = Pattern.compile("MPEGTS:\\d+");
 
-  private static final String WEBVTT_CUE_TAG_STRING = "\\<.*?>";
+  private static final String NON_NUMERIC_STRING = ".*[^0-9].*";
+
+  private final StringBuilder textBuilder;
 
   private final boolean strictParsing;
-  private final boolean filterTags;
 
+  /**
+   * Equivalent to {@code WebvttParser(false)}.
+   */
   public WebvttParser() {
-    this(true, true);
+    this(false);
   }
 
-  public WebvttParser(boolean strictParsing, boolean filterTags) {
+  /**
+   * @param strictParsing If true, {@link #parse(InputStream, String, long)} will throw a
+   *     {@link ParserException} if the stream contains invalid data. If false, the parser will
+   *     make a best effort to ignore minor errors in the stream. Note however that a
+   *     {@link ParserException} will still be thrown when this is not possible.
+   */
+  public WebvttParser(boolean strictParsing) {
     this.strictParsing = strictParsing;
-    this.filterTags = filterTags;
+    textBuilder = new StringBuilder();
   }
 
   @Override
   public WebvttSubtitle parse(InputStream inputStream, String inputEncoding, long startTimeUs)
       throws IOException {
-    ArrayList<WebvttCue> subtitles = new ArrayList<WebvttCue>();
+    ArrayList<WebvttCue> subtitles = new ArrayList<>();
     long mediaTimestampUs = startTimeUs;
     long mediaTimestampOffsetUs = 0;
 
@@ -96,7 +106,7 @@ public WebvttSubtitle parse(InputStream inputStream, String inputEncoding, long
       throw new ParserException("Expected WEBVTT or EXO-HEADER. Got null");
     }
 
-    if (line.startsWith(EXO_HEADER)) {
+    if (line.startsWith(C.WEBVTT_EXO_HEADER)) {
       // parse the timestamp offset, if present
       Matcher matcher = MEDIA_TIMESTAMP_OFFSET.matcher(line);
       if (matcher.find()) {
@@ -110,7 +120,7 @@ public WebvttSubtitle parse(InputStream inputStream, String inputEncoding, long
       }
     }
 
-    if (!line.equals("WEBVTT") && !line.equals("\uFEFFWEBVTT")) {
+    if (!WEBVTT_FILE_HEADER.matcher(line).matches()) {
       throw new ParserException("Expected WEBVTT. Got " + line);
     }
 
@@ -137,7 +147,7 @@ public WebvttSubtitle parse(InputStream inputStream, String inputEncoding, long
           throw new ParserException("X-TIMESTAMP-MAP doesn't contain media timestamp: " + line);
         } else {
           mediaTimestampUs = (Long.parseLong(timestampMatcher.group().substring(7)) * 1000)
-              / SAMPLING_RATE - mediaTimestampOffsetUs;
+              / SAMPLING_RATE + mediaTimestampOffsetUs;
         }
         mediaTimestampUs = getAdjustedStartTime(mediaTimestampUs);
       }
@@ -145,6 +155,7 @@ public WebvttSubtitle parse(InputStream inputStream, String inputEncoding, long
 
     // process the cues and text
     while ((line = webvttData.readLine()) != null) {
+
       // parse the cue identifier (if present) {
       Matcher matcher = WEBVTT_CUE_IDENTIFIER.matcher(line);
       if (matcher.find()) {
@@ -152,11 +163,16 @@ public WebvttSubtitle parse(InputStream inputStream, String inputEncoding, long
         line = webvttData.readLine();
       }
 
+      long startTime = Cue.UNSET_VALUE;
+      long endTime = Cue.UNSET_VALUE;
+      CharSequence text = null;
+      int lineNum = Cue.UNSET_VALUE;
+      int position = Cue.UNSET_VALUE;
+      Alignment alignment = null;
+      int size = Cue.UNSET_VALUE;
+
       // parse the cue timestamps
       matcher = WEBVTT_TIMESTAMP.matcher(line);
-      long startTime;
-      long endTime;
-      String text = "";
 
       // parse start timestamp
       if (!matcher.find()) {
@@ -166,37 +182,74 @@ public WebvttSubtitle parse(InputStream inputStream, String inputEncoding, long
       }
 
       // parse end timestamp
+      String endTimeString;
       if (!matcher.find()) {
         throw new ParserException("Expected cue end time: " + line);
       } else {
-        endTime = parseTimestampUs(matcher.group()) + mediaTimestampUs;
+        endTimeString = matcher.group();
+        endTime = parseTimestampUs(endTimeString) + mediaTimestampUs;
+      }
+
+      // parse the (optional) cue setting list
+      line = line.substring(line.indexOf(endTimeString) + endTimeString.length());
+      matcher = WEBVTT_CUE_SETTING.matcher(line);
+      while (matcher.find()) {
+        String match = matcher.group();
+        String[] parts = match.split(":", 2);
+        String name = parts[0];
+        String value = parts[1];
+
+        try {
+          if ("line".equals(name)) {
+            if (value.endsWith("%")) {
+              lineNum = parseIntPercentage(value);
+            } else if (value.matches(NON_NUMERIC_STRING)) {
+              Log.w(TAG, "Invalid line value: " + value);
+            } else {
+              lineNum = Integer.parseInt(value);
+            }
+          } else if ("align".equals(name)) {
+            // TODO: handle for RTL languages
+            if ("start".equals(value)) {
+              alignment = Alignment.ALIGN_NORMAL;
+            } else if ("middle".equals(value)) {
+              alignment = Alignment.ALIGN_CENTER;
+            } else if ("end".equals(value)) {
+              alignment = Alignment.ALIGN_OPPOSITE;
+            } else if ("left".equals(value)) {
+              alignment = Alignment.ALIGN_NORMAL;
+            } else if ("right".equals(value)) {
+              alignment = Alignment.ALIGN_OPPOSITE;
+            } else {
+              Log.w(TAG, "Invalid align value: " + value);
+            }
+          } else if ("position".equals(name)) {
+            position = parseIntPercentage(value);
+          } else if ("size".equals(name)) {
+            size = parseIntPercentage(value);
+          } else {
+            Log.w(TAG, "Unknown cue setting " + name + ":" + value);
+          }
+        } catch (NumberFormatException e) {
+          Log.w(TAG, name + " contains an invalid value " + value, e);
+        }
       }
 
       // parse text
+      textBuilder.setLength(0);
       while (((line = webvttData.readLine()) != null) && (!line.isEmpty())) {
-        text += processCueText(line.trim()) + "\n";
+        if (textBuilder.length() > 0) {
+          textBuilder.append("<br>");
+        }
+        textBuilder.append(line.trim());
       }
+      text = Html.fromHtml(textBuilder.toString());
 
-      WebvttCue cue = new WebvttCue(startTime, endTime, text);
+      WebvttCue cue = new WebvttCue(startTime, endTime, text, lineNum, position, alignment, size);
       subtitles.add(cue);
     }
 
-    webvttData.close();
-    inputStream.close();
-
-    // copy WebvttCue data into arrays for WebvttSubtitle constructor
-    String[] cueText = new String[subtitles.size()];
-    long[] cueTimesUs = new long[2 * subtitles.size()];
-    for (int subtitleIndex = 0; subtitleIndex < subtitles.size(); subtitleIndex++) {
-      int arrayIndex = subtitleIndex * 2;
-      WebvttCue cue = subtitles.get(subtitleIndex);
-      cueTimesUs[arrayIndex] = cue.startTime;
-      cueTimesUs[arrayIndex + 1] = cue.endTime;
-      cueText[subtitleIndex] = cue.text;
-    }
-
-    WebvttSubtitle subtitle = new WebvttSubtitle(cueText, mediaTimestampUs, cueTimesUs);
-    return subtitle;
+    return new WebvttSubtitle(subtitles, mediaTimestampUs);
   }
 
   @Override
@@ -208,25 +261,29 @@ protected long getAdjustedStartTime(long startTimeUs) {
     return startTimeUs;
   }
 
-  protected String processCueText(String line) {
-    if (filterTags) {
-      line = line.replaceAll(WEBVTT_CUE_TAG_STRING, "");
-      line = line.replaceAll("&lt;", "<");
-      line = line.replaceAll("&gt;", ">");
-      line = line.replaceAll("&nbsp;", " ");
-      line = line.replaceAll("&amp;", "&");
-      return line;
-    } else {
-      return line;
-    }
-  }
-
   protected void handleNoncompliantLine(String line) throws ParserException {
     if (strictParsing) {
       throw new ParserException("Unexpected line: " + line);
     }
   }
 
+  private static int parseIntPercentage(String s) throws NumberFormatException {
+    if (!s.endsWith("%")) {
+      throw new NumberFormatException(s + " doesn't end with '%'");
+    }
+
+    s = s.substring(0, s.length() - 1);
+    if (s.matches(NON_NUMERIC_STRING)) {
+      throw new NumberFormatException(s + " contains an invalid character");
+    }
+
+    int value = Integer.parseInt(s);
+    if (value < 0 || value > 100) {
+      throw new NumberFormatException(value + " is out of range [0-100]");
+    }
+    return value;
+  }
+
   private static long parseTimestampUs(String s) throws NumberFormatException {
     if (!s.matches(WEBVTT_TIMESTAMP_STRING)) {
       throw new NumberFormatException("has invalid format");
@@ -240,16 +297,4 @@ private static long parseTimestampUs(String s) throws NumberFormatException {
     return (value * 1000 + Long.parseLong(parts[1])) * 1000;
   }
 
-  private static class WebvttCue {
-    public final long startTime;
-    public final long endTime;
-    public final String text;
-
-    public WebvttCue(long startTime, long endTime, String text) {
-      this.startTime = startTime;
-      this.endTime = endTime;
-      this.text = text;
-    }
-  }
-
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttSubtitle.java b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttSubtitle.java
index cc6bdc4ef4..3ca64cdc21 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttSubtitle.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttSubtitle.java
@@ -15,33 +15,46 @@
  */
 package com.google.android.exoplayer.text.webvtt;
 
+import com.google.android.exoplayer.text.Cue;
 import com.google.android.exoplayer.text.Subtitle;
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.Util;
 
+import android.text.SpannableStringBuilder;
+
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
 
 /**
  * A representation of a WebVTT subtitle.
  */
 public class WebvttSubtitle implements Subtitle {
 
-  private final String[] cueText;
+  private final List<WebvttCue> cues;
+  private final int numCues;
   private final long startTimeUs;
   private final long[] cueTimesUs;
   private final long[] sortedCueTimesUs;
 
   /**
-   * @param cueText Text to be displayed during each cue.
+   * @param cues A list of the cues in this subtitle.
    * @param startTimeUs The start time of the subtitle.
-   * @param cueTimesUs Cue event times, where cueTimesUs[2 * i] and cueTimesUs[(2 * i) + 1] are
-   *     the start and end times, respectively, corresponding to cueText[i].
    */
-  public WebvttSubtitle(String[] cueText, long startTimeUs, long[] cueTimesUs) {
-    this.cueText = cueText;
+  public WebvttSubtitle(List<WebvttCue> cues, long startTimeUs) {
+    this.cues = cues;
     this.startTimeUs = startTimeUs;
-    this.cueTimesUs = cueTimesUs;
-    this.sortedCueTimesUs = Arrays.copyOf(cueTimesUs, cueTimesUs.length);
+
+    numCues = cues.size();
+    cueTimesUs = new long[2 * numCues];
+    for (int cueIndex = 0; cueIndex < numCues; cueIndex++) {
+      WebvttCue cue = cues.get(cueIndex);
+      int arrayIndex = cueIndex * 2;
+      cueTimesUs[arrayIndex] = cue.startTime;
+      cueTimesUs[arrayIndex + 1] = cue.endTime;
+    }
+    sortedCueTimesUs = Arrays.copyOf(cueTimesUs, cueTimesUs.length);
     Arrays.sort(sortedCueTimesUs);
   }
 
@@ -78,22 +91,47 @@ public long getLastEventTime() {
   }
 
   @Override
-  public String getText(long timeUs) {
-    StringBuilder stringBuilder = new StringBuilder();
+  public List<Cue> getCues(long timeUs) {
+    ArrayList<Cue> list = null;
+    WebvttCue firstNormalCue = null;
+    SpannableStringBuilder normalCueTextBuilder = null;
 
-    for (int i = 0; i < cueTimesUs.length; i += 2) {
-      if ((cueTimesUs[i] <= timeUs) && (timeUs < cueTimesUs[i + 1])) {
-        stringBuilder.append(cueText[i / 2]);
+    for (int i = 0; i < numCues; i++) {
+      if ((cueTimesUs[i * 2] <= timeUs) && (timeUs < cueTimesUs[i * 2 + 1])) {
+        if (list == null) {
+          list = new ArrayList<>();
+        }
+        WebvttCue cue = cues.get(i);
+        if (cue.isNormalCue()) {
+          // we want to merge all of the normal cues into a single cue to ensure they are drawn
+          // correctly (i.e. don't overlap) and to emulate roll-up, but only if there are multiple
+          // normal cues, otherwise we can just append the single normal cue
+          if (firstNormalCue == null) {
+            firstNormalCue = cue;
+          } else if (normalCueTextBuilder == null) {
+            normalCueTextBuilder = new SpannableStringBuilder();
+            normalCueTextBuilder.append(firstNormalCue.text).append("\n").append(cue.text);
+          } else {
+            normalCueTextBuilder.append("\n").append(cue.text);
+          }
+        } else {
+          list.add(cue);
+        }
       }
     }
-
-    int stringLength = stringBuilder.length();
-    if (stringLength > 0 && stringBuilder.charAt(stringLength - 1) == '\n') {
-      // Adjust the length to remove the trailing newline character.
-      stringLength -= 1;
+    if (normalCueTextBuilder != null) {
+      // there were multiple normal cues, so create a new cue with all of the text
+      list.add(new WebvttCue(normalCueTextBuilder));
+    } else if (firstNormalCue != null) {
+      // there was only a single normal cue, so just add it to the list
+      list.add(firstNormalCue);
     }
 
-    return stringLength == 0 ? null : stringBuilder.substring(0, stringLength);
+    if (list != null) {
+      return list;
+    } else {
+      return Collections.<Cue>emptyList();
+    }
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/Allocator.java b/library/src/main/java/com/google/android/exoplayer/upstream/Allocator.java
index b51217f591..db575441b6 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/Allocator.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/Allocator.java
@@ -45,6 +45,15 @@
    */
   void trim(int targetSize);
 
+  /**
+   * Blocks execution until the number of bytes allocated is not greater than the limit, or the
+   * thread is interrupted.
+   *
+   * @param limit The limit in bytes.
+   * @throws InterruptedException If the thread is interrupted.
+   */
+  void blockWhileTotalBytesAllocatedExceeds(int limit) throws InterruptedException;
+
   /**
    * Returns the total number of bytes currently allocated.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultAllocator.java b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultAllocator.java
index 1d1b8f4054..2327e909f1 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultAllocator.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultAllocator.java
@@ -25,41 +25,72 @@
  */
 public final class DefaultAllocator implements Allocator {
 
-  private static final int INITIAL_RECYCLED_ALLOCATION_CAPACITY = 100;
+  private static final int AVAILABLE_EXTRA_CAPACITY = 100;
 
   private final int individualAllocationSize;
+  private final byte[] initialAllocationBlock;
 
   private int allocatedCount;
-  private int recycledCount;
-  private Allocation[] recycledAllocations;
+  private int availableCount;
+  private Allocation[] availableAllocations;
 
   /**
-   * Constructs an empty pool.
+   * Constructs an initially empty pool.
    *
    * @param individualAllocationSize The length of each individual allocation.
    */
   public DefaultAllocator(int individualAllocationSize) {
+    this(individualAllocationSize, 0);
+  }
+
+  /**
+   * Constructs a pool with some {@link Allocation}s created up front.
+   * <p>
+   * Note: Initial {@link Allocation}s will never be discarded by {@link #trim(int)}.
+   *
+   * @param individualAllocationSize The length of each individual allocation.
+   * @param initialAllocationCount The number of allocations to create up front.
+   */
+  public DefaultAllocator(int individualAllocationSize, int initialAllocationCount) {
     Assertions.checkArgument(individualAllocationSize > 0);
+    Assertions.checkArgument(initialAllocationCount >= 0);
     this.individualAllocationSize = individualAllocationSize;
-    this.recycledAllocations = new Allocation[INITIAL_RECYCLED_ALLOCATION_CAPACITY];
+    this.availableCount = initialAllocationCount;
+    this.availableAllocations = new Allocation[initialAllocationCount + AVAILABLE_EXTRA_CAPACITY];
+    if (initialAllocationCount > 0) {
+      initialAllocationBlock = new byte[initialAllocationCount * individualAllocationSize];
+      for (int i = 0; i < initialAllocationCount; i++) {
+        int allocationOffset = i * individualAllocationSize;
+        availableAllocations[i] = new Allocation(initialAllocationBlock, allocationOffset);
+      }
+    } else {
+      initialAllocationBlock = null;
+    }
   }
 
   @Override
   public synchronized Allocation allocate() {
     allocatedCount++;
-    return recycledCount > 0 ? recycledAllocations[--recycledCount]
-        : new Allocation(new byte[individualAllocationSize], 0);
+    Allocation allocation;
+    if (availableCount > 0) {
+      allocation = availableAllocations[--availableCount];
+      availableAllocations[availableCount] = null;
+    } else {
+      allocation = new Allocation(new byte[individualAllocationSize], 0);
+    }
+    return allocation;
   }
 
   @Override
   public synchronized void release(Allocation allocation) {
     // Weak sanity check that the allocation probably originated from this pool.
-    Assertions.checkArgument(allocation.data.length == individualAllocationSize);
+    Assertions.checkArgument(allocation.data == initialAllocationBlock
+        || allocation.data.length == individualAllocationSize);
     allocatedCount--;
-    if (recycledCount == recycledAllocations.length) {
-      recycledAllocations = Arrays.copyOf(recycledAllocations, recycledAllocations.length * 2);
+    if (availableCount == availableAllocations.length) {
+      availableAllocations = Arrays.copyOf(availableAllocations, availableAllocations.length * 2);
     }
-    recycledAllocations[recycledCount++] = allocation;
+    availableAllocations[availableCount++] = allocation;
     // Wake up threads waiting for the allocated size to drop.
     notifyAll();
   }
@@ -67,11 +98,43 @@ public synchronized void release(Allocation allocation) {
   @Override
   public synchronized void trim(int targetSize) {
     int targetAllocationCount = Util.ceilDivide(targetSize, individualAllocationSize);
-    int targetRecycledAllocationCount = Math.max(0, targetAllocationCount - allocatedCount);
-    if (targetRecycledAllocationCount < recycledCount) {
-      Arrays.fill(recycledAllocations, targetRecycledAllocationCount, recycledCount, null);
-      recycledCount = targetRecycledAllocationCount;
+    int targetAvailableCount = Math.max(0, targetAllocationCount - allocatedCount);
+    if (targetAvailableCount >= availableCount) {
+      // We're already at or below the target.
+      return;
     }
+
+    if (initialAllocationBlock != null) {
+      // Some allocations are backed by an initial block. We need to make sure that we hold onto all
+      // such allocations. Re-order the available allocations so that the ones backed by the initial
+      // block come first.
+      int lowIndex = 0;
+      int highIndex = availableCount - 1;
+      while (lowIndex <= highIndex) {
+        Allocation lowAllocation = availableAllocations[lowIndex];
+        if (lowAllocation.data == initialAllocationBlock) {
+          lowIndex++;
+        } else {
+          Allocation highAllocation = availableAllocations[lowIndex];
+          if (highAllocation.data != initialAllocationBlock) {
+            highIndex--;
+          } else {
+            availableAllocations[lowIndex++] = highAllocation;
+            availableAllocations[highIndex--] = lowAllocation;
+          }
+        }
+      }
+      // lowIndex is the index of the first allocation not backed by an initial block.
+      targetAvailableCount = Math.max(targetAvailableCount, lowIndex);
+      if (targetAvailableCount >= availableCount) {
+        // We're already at or below the target.
+        return;
+      }
+    }
+
+    // Discard allocations beyond the target.
+    Arrays.fill(availableAllocations, targetAvailableCount, availableCount, null);
+    availableCount = targetAvailableCount;
   }
 
   @Override
@@ -80,14 +143,6 @@ public synchronized int getTotalBytesAllocated() {
   }
 
   @Override
-  public int getIndividualAllocationLength() {
-    return individualAllocationSize;
-  }
-
-  /**
-   * Blocks execution until the allocated number of bytes allocated is not greater than the
-   * threshold, or the thread is interrupted.
-   */
   public synchronized void blockWhileTotalBytesAllocatedExceeds(int limit)
       throws InterruptedException {
     while (getTotalBytesAllocated() > limit) {
@@ -95,4 +150,9 @@ public synchronized void blockWhileTotalBytesAllocatedExceeds(int limit)
     }
   }
 
+  @Override
+  public int getIndividualAllocationLength() {
+    return individualAllocationSize;
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultHttpDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultHttpDataSource.java
index 621c49b32a..f06e280288 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultHttpDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultHttpDataSource.java
@@ -61,7 +61,7 @@
   private static final String TAG = "HttpDataSource";
   private static final Pattern CONTENT_RANGE_HEADER =
       Pattern.compile("^bytes (\\d+)-(\\d+)/(\\d+)$");
-  private static final AtomicReference<byte[]> skipBufferReference = new AtomicReference<byte[]>();
+  private static final AtomicReference<byte[]> skipBufferReference = new AtomicReference<>();
 
   private final boolean allowCrossProtocolRedirects;
   private final int connectTimeoutMillis;
@@ -141,7 +141,7 @@ public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePred
     this.userAgent = Assertions.checkNotEmpty(userAgent);
     this.contentTypePredicate = contentTypePredicate;
     this.listener = listener;
-    this.requestProperties = new HashMap<String, String>();
+    this.requestProperties = new HashMap<>();
     this.connectTimeoutMillis = connectTimeoutMillis;
     this.readTimeoutMillis = readTimeoutMillis;
     this.allowCrossProtocolRedirects = allowCrossProtocolRedirects;
@@ -152,6 +152,11 @@ public String getUri() {
     return connection == null ? null : connection.getURL().toString();
   }
 
+  @Override
+  public Map<String, List<String>> getResponseHeaders() {
+    return connection == null ? null : connection.getHeaderFields();
+  }
+
   @Override
   public void setRequestProperty(String name, String value) {
     Assertions.checkNotNull(name);
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/HttpDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/HttpDataSource.java
index 6009a837a5..c9d977cd87 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/HttpDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/HttpDataSource.java
@@ -145,4 +145,11 @@ public InvalidResponseCodeException(int responseCode, Map<String, List<String>>
    */
   void clearAllRequestProperties();
 
+  /**
+   * Gets the headers provided in the response.
+   *
+   * @return The response headers, or {@code null} if response headers are unavailable.
+   */
+  Map<String, List<String>> getResponseHeaders();
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/Loader.java b/library/src/main/java/com/google/android/exoplayer/upstream/Loader.java
index 6eb477fd0d..24d8b78c62 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/Loader.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/Loader.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer.upstream;
 
 import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.TraceUtil;
 import com.google.android.exoplayer.util.Util;
 
 import android.annotation.SuppressLint;
@@ -128,21 +129,6 @@ public void startLoading(Loadable loadable, Callback callback) {
     startLoading(myLooper, loadable, callback);
   }
 
-  /**
-   * Invokes {@link #startLoading(Looper, Loadable, Callback)}, using the {@link Looper}
-   * associated with the calling thread. Loading is delayed by {@code delayMs}.
-   *
-   * @param loadable The {@link Loadable} to load.
-   * @param callback A callback to invoke when the load ends.
-   * @param delayMs Number of milliseconds to wait before calling {@link Loadable#load()}.
-   * @throws IllegalStateException If the calling thread does not have an associated {@link Looper}.
-   */
-  public void startLoading(Loadable loadable, Callback callback, int delayMs) {
-    Looper myLooper = Looper.myLooper();
-    Assertions.checkState(myLooper != null);
-    startLoading(myLooper, loadable, callback, delayMs);
-  }
-
   /**
    * Start loading a {@link Loadable}.
    * <p>
@@ -154,24 +140,9 @@ public void startLoading(Loadable loadable, Callback callback, int delayMs) {
    * @param callback A callback to invoke when the load ends.
    */
   public void startLoading(Looper looper, Loadable loadable, Callback callback) {
-    startLoading(looper, loadable, callback, 0);
-  }
-
-  /**
-   * Start loading a {@link Loadable} after {@code delayMs} has elapsed.
-   * <p>
-   * A {@link Loader} instance can only load one {@link Loadable} at a time, and so this method
-   * must not be called when another load is in progress.
-   *
-   * @param looper The looper of the thread on which the callback should be invoked.
-   * @param loadable The {@link Loadable} to load.
-   * @param callback A callback to invoke when the load ends.
-   * @param delayMs Number of milliseconds to wait before calling {@link Loadable#load()}.
-   */
-  public void startLoading(Looper looper, Loadable loadable, Callback callback, int delayMs) {
     Assertions.checkState(!loading);
     loading = true;
-    currentTask = new LoadTask(looper, loadable, callback, delayMs);
+    currentTask = new LoadTask(looper, loadable, callback);
     downloadExecutorService.submit(currentTask);
   }
 
@@ -213,15 +184,13 @@ public void release() {
 
     private final Loadable loadable;
     private final Loader.Callback callback;
-    private final int delayMs;
 
     private volatile Thread executorThread;
 
-    public LoadTask(Looper looper, Loadable loadable, Loader.Callback callback, int delayMs) {
+    public LoadTask(Looper looper, Loadable loadable, Loader.Callback callback) {
       super(looper);
       this.loadable = loadable;
       this.callback = callback;
-      this.delayMs = delayMs;
     }
 
     public void quit() {
@@ -235,11 +204,10 @@ public void quit() {
     public void run() {
       try {
         executorThread = Thread.currentThread();
-        if (delayMs > 0) {
-          Thread.sleep(delayMs);
-        }
         if (!loadable.isLoadCanceled()) {
+          TraceUtil.beginSection(loadable.getClass().getSimpleName() + ".load()");
           loadable.load();
+          TraceUtil.endSection();
         }
         sendEmptyMessage(MSG_END_OF_SOURCE);
       } catch (IOException e) {
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/NetworkLock.java b/library/src/main/java/com/google/android/exoplayer/upstream/NetworkLock.java
index 2576fff1cd..b8c6aa1f65 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/NetworkLock.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/NetworkLock.java
@@ -62,7 +62,7 @@ public PriorityTooLowException(int priority, int highestPriority) {
   private int highestPriority;
 
   private NetworkLock() {
-    queue = new PriorityQueue<Integer>();
+    queue = new PriorityQueue<>();
     highestPriority = Integer.MAX_VALUE;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheSpan.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheSpan.java
index 4d2ce48afb..ddde6b003c 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheSpan.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheSpan.java
@@ -92,7 +92,8 @@ private static CacheSpan createCacheEntry(String key, long position, long lastAc
     return new CacheSpan(key, position, file.length(), true, lastAccessTimestamp, file);
   }
 
-  private CacheSpan(String key, long position, long length, boolean isCached,
+  // Visible for testing.
+  CacheSpan(String key, long position, long length, boolean isCached,
       long lastAccessTimestamp, File file) {
     this.key = key;
     this.position = position;
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/LeastRecentlyUsedCacheEvictor.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/LeastRecentlyUsedCacheEvictor.java
index 0c34154a59..577d7b3bbf 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/LeastRecentlyUsedCacheEvictor.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/LeastRecentlyUsedCacheEvictor.java
@@ -30,7 +30,7 @@
 
   public LeastRecentlyUsedCacheEvictor(long maxBytes) {
     this.maxBytes = maxBytes;
-    this.leastRecentlyUsed = new TreeSet<CacheSpan>(this);
+    this.leastRecentlyUsed = new TreeSet<>(this);
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCache.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCache.java
index 448645b648..ed2001b371 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCache.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCache.java
@@ -50,9 +50,9 @@
   public SimpleCache(File cacheDir, CacheEvictor evictor) {
     this.cacheDir = cacheDir;
     this.evictor = evictor;
-    this.lockedSpans = new HashMap<String, CacheSpan>();
-    this.cachedSpans = new HashMap<String, TreeSet<CacheSpan>>();
-    this.listeners = new HashMap<String, ArrayList<Listener>>();
+    this.lockedSpans = new HashMap<>();
+    this.cachedSpans = new HashMap<>();
+    this.listeners = new HashMap<>();
     // Start cache initialization.
     final ConditionVariable conditionVariable = new ConditionVariable();
     new Thread() {
@@ -71,7 +71,7 @@ public void run() {
   public synchronized NavigableSet<CacheSpan> addListener(String key, Listener listener) {
     ArrayList<Listener> listenersForKey = listeners.get(key);
     if (listenersForKey == null) {
-      listenersForKey = new ArrayList<Listener>();
+      listenersForKey = new ArrayList<>();
       listeners.put(key, listenersForKey);
     }
     listenersForKey.add(listener);
@@ -92,12 +92,12 @@ public synchronized void removeListener(String key, Listener listener) {
   @Override
   public synchronized NavigableSet<CacheSpan> getCachedSpans(String key) {
     TreeSet<CacheSpan> spansForKey = cachedSpans.get(key);
-    return spansForKey == null ? null : new TreeSet<CacheSpan>(spansForKey);
+    return spansForKey == null ? null : new TreeSet<>(spansForKey);
   }
 
   @Override
   public synchronized Set<String> getKeys() {
-    return new HashSet<String>(cachedSpans.keySet());
+    return new HashSet<>(cachedSpans.keySet());
   }
 
   @Override
@@ -263,7 +263,7 @@ private void initialize() {
   private void addSpan(CacheSpan span) {
     TreeSet<CacheSpan> spansForKey = cachedSpans.get(span.key);
     if (spansForKey == null) {
-      spansForKey = new TreeSet<CacheSpan>();
+      spansForKey = new TreeSet<>();
       cachedSpans.put(span.key, spansForKey);
     }
     spansForKey.add(span);
diff --git a/library/src/main/java/com/google/android/exoplayer/util/Ac3Util.java b/library/src/main/java/com/google/android/exoplayer/util/Ac3Util.java
index e96db51361..01647e22ca 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/Ac3Util.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/Ac3Util.java
@@ -17,8 +17,6 @@
 
 import com.google.android.exoplayer.MediaFormat;
 
-import java.util.Collections;
-
 /**
  * Utility methods for parsing AC-3 headers.
  */
@@ -51,7 +49,7 @@ public static MediaFormat parseAnnexFAc3Format(ParsableByteArray data) {
       channelCount++;
     }
     return MediaFormat.createAudioFormat(MimeTypes.AUDIO_AC3, MediaFormat.NO_VALUE,
-        MediaFormat.NO_VALUE, channelCount, sampleRate, Collections.<byte[]>emptyList());
+        channelCount, sampleRate, null);
   }
 
   /**
@@ -74,7 +72,7 @@ public static MediaFormat parseAnnexFEAc3Format(ParsableByteArray data) {
       channelCount++;
     }
     return MediaFormat.createAudioFormat(MimeTypes.AUDIO_EC3, MediaFormat.NO_VALUE,
-        channelCount, sampleRate, Collections.<byte[]>emptyList());
+        channelCount, sampleRate, null);
   }
 
   /**
@@ -102,8 +100,7 @@ public static MediaFormat parseFrameAc3Format(ParsableBitArray data) {
     }
     boolean lfeon = data.readBit();
     return MediaFormat.createAudioFormat(MimeTypes.AUDIO_AC3, MediaFormat.NO_VALUE,
-        MediaFormat.NO_VALUE, CHANNEL_COUNTS[acmod] + (lfeon ? 1 : 0), SAMPLE_RATES[fscod],
-        Collections.<byte[]>emptyList());
+        CHANNEL_COUNTS[acmod] + (lfeon ? 1 : 0), SAMPLE_RATES[fscod], null);
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/util/CodecSpecificDataUtil.java b/library/src/main/java/com/google/android/exoplayer/util/CodecSpecificDataUtil.java
index 019f7459c0..fa212d2a19 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/CodecSpecificDataUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/CodecSpecificDataUtil.java
@@ -47,7 +47,7 @@ private CodecSpecificDataUtil() {}
    * @param audioSpecificConfig The AudioSpecificConfig to parse.
    * @return A pair consisting of the sample rate in Hz and the channel count.
    */
-  public static Pair<Integer, Integer> parseAudioSpecificConfig(byte[] audioSpecificConfig) {
+  public static Pair<Integer, Integer> parseAacAudioSpecificConfig(byte[] audioSpecificConfig) {
     int audioObjectType = (audioSpecificConfig[0] >> 3) & 0x1F;
     int byteOffset = audioObjectType == 5 || audioObjectType == 29 ? 1 : 0;
     int frequencyIndex = (audioSpecificConfig[byteOffset] & 0x7) << 1
@@ -66,7 +66,7 @@ private CodecSpecificDataUtil() {}
    * @param channelConfig The channel configuration.
    * @return The AudioSpecificConfig.
    */
-  public static byte[] buildAudioSpecificConfig(int audioObjectType, int sampleRateIndex,
+  public static byte[] buildAacAudioSpecificConfig(int audioObjectType, int sampleRateIndex,
       int channelConfig) {
     byte[] audioSpecificConfig = new byte[2];
     audioSpecificConfig[0] = (byte) ((audioObjectType << 3) & 0xF8 | (sampleRateIndex >> 1) & 0x07);
@@ -81,7 +81,7 @@ private CodecSpecificDataUtil() {}
    * @param numChannels The number of channels.
    * @return The AudioSpecificConfig.
    */
-  public static byte[] buildAudioSpecificConfig(int sampleRate, int numChannels) {
+  public static byte[] buildAacAudioSpecificConfig(int sampleRate, int numChannels) {
     int sampleRateIndex = -1;
     for (int i = 0; i < AUDIO_SPECIFIC_CONFIG_SAMPLING_RATE_TABLE.length; ++i) {
       if (sampleRate == AUDIO_SPECIFIC_CONFIG_SAMPLING_RATE_TABLE[i]) {
@@ -132,7 +132,7 @@ private CodecSpecificDataUtil() {}
       // data does not consist of NAL start code delimited units.
       return null;
     }
-    List<Integer> starts = new ArrayList<Integer>();
+    List<Integer> starts = new ArrayList<>();
     int nalUnitIndex = 0;
     do {
       starts.add(nalUnitIndex);
diff --git a/library/src/main/java/com/google/android/exoplayer/util/DebugTextViewHelper.java b/library/src/main/java/com/google/android/exoplayer/util/DebugTextViewHelper.java
new file mode 100644
index 0000000000..134b40e744
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/util/DebugTextViewHelper.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util;
+
+import com.google.android.exoplayer.CodecCounters;
+import com.google.android.exoplayer.chunk.Format;
+import com.google.android.exoplayer.upstream.BandwidthMeter;
+
+import android.widget.TextView;
+
+/**
+ * A helper class for periodically updating debug information displayed by a {@link TextView}.
+ */
+public final class DebugTextViewHelper implements Runnable {
+
+  /**
+   * Provides debug information about an ongoing playback.
+   */
+  public interface Provider {
+
+    /**
+     * Returns the current playback position, in milliseconds.
+     */
+    long getCurrentPosition();
+
+    /**
+     * Returns a format whose information should be displayed, or null.
+     */
+    Format getFormat();
+
+    /**
+     * Returns a {@link BandwidthMeter} whose estimate should be displayed, or null.
+     */
+    BandwidthMeter getBandwidthMeter();
+
+    /**
+     * Returns a {@link CodecCounters} whose information should be displayed, or null.
+     */
+    CodecCounters getCodecCounters();
+
+  }
+
+  private static final int REFRESH_INTERVAL_MS = 1000;
+
+  private final TextView textView;
+  private final Provider debuggable;
+
+  /**
+   * @param debuggable The {@link Provider} from which debug information should be obtained.
+   * @param textView The {@link TextView} that should be updated to display the information.
+   */
+  public DebugTextViewHelper(Provider debuggable, TextView textView) {
+    this.debuggable = debuggable;
+    this.textView = textView;
+  }
+
+  /**
+   * Starts periodic updates of the {@link TextView}.
+   * <p>
+   * Should be called from the application's main thread.
+   */
+  public void start() {
+    stop();
+    run();
+  }
+
+  /**
+   * Stops periodic updates of the {@link TextView}.
+   * <p>
+   * Should be called from the application's main thread.
+   */
+  public void stop() {
+    textView.removeCallbacks(this);
+  }
+
+  @Override
+  public void run() {
+    textView.setText(getRenderString());
+    textView.postDelayed(this, REFRESH_INTERVAL_MS);
+  }
+
+  private String getRenderString() {
+    return getTimeString() + " " + getQualityString() + " " + getBandwidthString() + " "
+        + getVideoCodecCountersString();
+  }
+
+  private String getTimeString() {
+    return "ms(" + debuggable.getCurrentPosition() + ")";
+  }
+
+  private String getQualityString() {
+    Format format = debuggable.getFormat();
+    return format == null ? "id:? br:? h:?"
+        : "id:" + format.id + " br:" + format.bitrate + " h:" + format.height;
+  }
+
+  private String getBandwidthString() {
+    BandwidthMeter bandwidthMeter = debuggable.getBandwidthMeter();
+    if (bandwidthMeter == null
+        || bandwidthMeter.getBitrateEstimate() == BandwidthMeter.NO_ESTIMATE) {
+      return "bw:?";
+    } else {
+      return "bw:" + (bandwidthMeter.getBitrateEstimate() / 1000);
+    }
+  }
+
+  private String getVideoCodecCountersString() {
+    CodecCounters codecCounters = debuggable.getCodecCounters();
+    return codecCounters == null ? "" : codecCounters.getDebugString();
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/util/LongArray.java b/library/src/main/java/com/google/android/exoplayer/util/LongArray.java
index a88b2f3e6d..dee3fc61d0 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/LongArray.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/LongArray.java
@@ -20,7 +20,7 @@
 /**
  * An append-only, auto-growing {@code long[]}.
  */
-public class LongArray {
+public final class LongArray {
 
   private static final int DEFAULT_INITIAL_CAPACITY = 32;
 
@@ -74,4 +74,13 @@ public int size() {
     return size;
   }
 
+  /**
+   * Copies the current values into a newly allocated primitive array.
+   *
+   * @return The primitive array containing the copied values.
+   */
+  public long[] toArray() {
+    return Arrays.copyOf(values, size);
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ManifestFetcher.java b/library/src/main/java/com/google/android/exoplayer/util/ManifestFetcher.java
index a626ec20c3..267d8ff6ae 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/ManifestFetcher.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/ManifestFetcher.java
@@ -23,6 +23,7 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.SystemClock;
+import android.text.TextUtils;
 import android.util.Pair;
 
 import java.io.IOException;
@@ -83,12 +84,26 @@
 
   }
 
+  /**
+   * Interface for manifests that are able to specify that subsequent loads should use a different
+   * URI.
+   */
+  public interface RedirectingManifest {
+
+    /**
+     * Returns the URI from which subsequent manifests should be requested, or null to continue
+     * using the current URI.
+     */
+    public String getNextManifestUri();
+
+  }
+
   private final UriLoadable.Parser<T> parser;
   private final UriDataSource uriDataSource;
   private final Handler eventHandler;
   private final EventListener eventListener;
 
-  /* package */ volatile String manifestUrl;
+  /* package */ volatile String manifestUri;
 
   private int enabledCount;
   private Loader loader;
@@ -102,27 +117,27 @@
   private volatile long manifestLoadTimestamp;
 
   /**
-   * @param manifestUrl The manifest location.
+   * @param manifestUri The manifest location.
    * @param uriDataSource The {@link UriDataSource} to use when loading the manifest.
    * @param parser A parser to parse the loaded manifest data.
    */
-  public ManifestFetcher(String manifestUrl, UriDataSource uriDataSource,
+  public ManifestFetcher(String manifestUri, UriDataSource uriDataSource,
       UriLoadable.Parser<T> parser) {
-    this(manifestUrl, uriDataSource, parser, null, null);
+    this(manifestUri, uriDataSource, parser, null, null);
   }
 
   /**
-   * @param manifestUrl The manifest location.
+   * @param manifestUri The manifest location.
    * @param uriDataSource The {@link UriDataSource} to use when loading the manifest.
    * @param parser A parser to parse the loaded manifest data.
    * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    */
-  public ManifestFetcher(String manifestUrl, UriDataSource uriDataSource,
+  public ManifestFetcher(String manifestUri, UriDataSource uriDataSource,
       UriLoadable.Parser<T> parser, Handler eventHandler, EventListener eventListener) {
     this.parser = parser;
-    this.manifestUrl = manifestUrl;
+    this.manifestUri = manifestUri;
     this.uriDataSource = uriDataSource;
     this.eventHandler = eventHandler;
     this.eventListener = eventListener;
@@ -131,10 +146,10 @@ public ManifestFetcher(String manifestUrl, UriDataSource uriDataSource,
   /**
    * Updates the manifest location.
    *
-   * @param manifestUrl The manifest location.
+   * @param manifestUri The manifest location.
    */
-  public void updateManifestUrl(String manifestUrl) {
-    this.manifestUrl = manifestUrl;
+  public void updateManifestUri(String manifestUri) {
+    this.manifestUri = manifestUri;
   }
 
   /**
@@ -146,7 +161,7 @@ public void updateManifestUrl(String manifestUrl) {
    */
   public void singleLoad(Looper callbackLooper, final ManifestCallback<T> callback) {
     SingleFetchHelper fetchHelper = new SingleFetchHelper(
-        new UriLoadable<T>(manifestUrl, uriDataSource, parser), callbackLooper, callback);
+        new UriLoadable<>(manifestUri, uriDataSource, parser), callbackLooper, callback);
     fetchHelper.startLoading();
   }
 
@@ -219,7 +234,7 @@ public void requestRefresh() {
       loader = new Loader("manifestLoader");
     }
     if (!loader.isLoading()) {
-      currentLoadable = new UriLoadable<T>(manifestUrl, uriDataSource, parser);
+      currentLoadable = new UriLoadable<>(manifestUri, uriDataSource, parser);
       loader.startLoading(currentLoadable, this);
       notifyManifestRefreshStarted();
     }
@@ -237,6 +252,14 @@ public void onLoadCompleted(Loadable loadable) {
     loadExceptionCount = 0;
     loadException = null;
 
+    if (manifest instanceof RedirectingManifest) {
+      RedirectingManifest redirectingManifest = (RedirectingManifest) manifest;
+      String nextLocation = redirectingManifest.getNextManifestUri();
+      if (!TextUtils.isEmpty(nextLocation)) {
+        manifestUri = nextLocation;
+      }
+    }
+
     notifyManifestRefreshed();
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java b/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
index 3a6ea01c6f..66e44b905a 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
@@ -33,6 +33,7 @@
   public static final String VIDEO_MP4 = BASE_TYPE_VIDEO + "/mp4";
   public static final String VIDEO_WEBM = BASE_TYPE_VIDEO + "/webm";
   public static final String VIDEO_H264 = BASE_TYPE_VIDEO + "/avc";
+  public static final String VIDEO_H265 = BASE_TYPE_VIDEO + "/hevc";
   public static final String VIDEO_VP8 = BASE_TYPE_VIDEO + "/x-vnd.on2.vp8";
   public static final String VIDEO_VP9 = BASE_TYPE_VIDEO + "/x-vnd.on2.vp9";
   public static final String VIDEO_MP4V = BASE_TYPE_VIDEO + "/mp4v-es";
@@ -55,8 +56,10 @@
 
   public static final String APPLICATION_ID3 = BASE_TYPE_APPLICATION + "/id3";
   public static final String APPLICATION_EIA608 = BASE_TYPE_APPLICATION + "/eia-608";
+  public static final String APPLICATION_SUBRIP = BASE_TYPE_APPLICATION + "/x-subrip";
   public static final String APPLICATION_TTML = BASE_TYPE_APPLICATION + "/ttml+xml";
   public static final String APPLICATION_M3U8 = BASE_TYPE_APPLICATION + "/x-mpegURL";
+  public static final String APPLICATION_TX3G = BASE_TYPE_APPLICATION + "/x-quicktime-tx3g";
 
   private MimeTypes() {}
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/MpegAudioHeader.java b/library/src/main/java/com/google/android/exoplayer/util/MpegAudioHeader.java
similarity index 76%
rename from library/src/main/java/com/google/android/exoplayer/extractor/mp3/MpegAudioHeader.java
rename to library/src/main/java/com/google/android/exoplayer/util/MpegAudioHeader.java
index 9f05d0e3a6..2606235883 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/MpegAudioHeader.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/MpegAudioHeader.java
@@ -13,11 +13,23 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.extractor.mp3;
+package com.google.android.exoplayer.util;
 
-/** Parsed MPEG audio frame header. */
-/* package */ final class MpegAudioHeader {
+/**
+ * Representation of an MPEG audio frame header.
+ */
+public final class MpegAudioHeader {
+
+  /**
+   * Theoretical maximum frame size for an MPEG audio stream, which occurs when playing a Layer 2
+   * MPEG 2.5 audio stream at 16 kb/s (with padding). The size is 1152 sample/frame *
+   * 160000 bit/s / (8000 sample/s * 8 bit/byte) + 1 padding byte/frame = 2881 byte/frame.
+   * The next power of two size is 4 KiB.
+   */
+  public static final int MAX_FRAME_SIZE_BYTES = 4096;
 
+  private static final String[] MIME_TYPE_BY_LAYER =
+      new String[] {MimeTypes.AUDIO_MPEG_L1, MimeTypes.AUDIO_MPEG_L2, MimeTypes.AUDIO_MPEG};
   private static final int[] SAMPLING_RATE_V1 = {44100, 48000, 32000};
   private static final int[] BITRATE_V1_L1 =
       {32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448};
@@ -30,7 +42,9 @@
   private static final int[] BITRATE_V2 =
       {8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160};
 
-  /** Returns the size of the frame associated with {@code header}, or -1 if it is invalid. */
+  /**
+   * Returns the size of the frame associated with {@code header}, or -1 if it is invalid.
+   */
   public static int getFrameSize(int header) {
     if ((header & 0xFFE00000) != 0xFFE00000) {
       return -1;
@@ -92,35 +106,37 @@ public static int getFrameSize(int header) {
   }
 
   /**
-   * Returns the header represented by {@code header}, if it is valid; {@code null} otherwise.
+   * Parses {@code headerData}, populating {@code header} with the parsed data.
    *
    * @param headerData Header data to parse.
    * @param header Header to populate with data from {@code headerData}.
+   * @return True if the header was populated. False otherwise, indicating that {@code headerData}
+   *     is not a valid MPEG audio header.
    */
-  public static void populateHeader(int headerData, MpegAudioHeader header) {
+  public static boolean populateHeader(int headerData, MpegAudioHeader header) {
     if ((headerData & 0xFFE00000) != 0xFFE00000) {
-      return;
+      return false;
     }
 
     int version = (headerData >>> 19) & 3;
     if (version == 1) {
-      return;
+      return false;
     }
 
     int layer = (headerData >>> 17) & 3;
     if (layer == 0) {
-      return;
+      return false;
     }
 
     int bitrateIndex = (headerData >>> 12) & 15;
     if (bitrateIndex == 0 || bitrateIndex == 0xF) {
       // Disallow "free" bitrate.
-      return;
+      return false;
     }
 
     int samplingRateIndex = (headerData >>> 10) & 3;
     if (samplingRateIndex == 3) {
-      return;
+      return false;
     }
 
     int sampleRate = SAMPLING_RATE_V1[samplingRateIndex];
@@ -154,16 +170,16 @@ public static void populateHeader(int headerData, MpegAudioHeader header) {
       }
     }
 
+    String mimeType = MIME_TYPE_BY_LAYER[3 - layer];
     int channels = ((headerData >> 6) & 3) == 3 ? 1 : 2;
-    int layerIndex = 3 - layer;
-    header.setValues(
-        version, layerIndex, frameSize, sampleRate, channels, bitrate, samplesPerFrame);
+    header.setValues(version, mimeType, frameSize, sampleRate, channels, bitrate, samplesPerFrame);
+    return true;
   }
 
   /** MPEG audio header version. */
   public int version;
-  /** MPEG audio layer index, starting at zero. */
-  public int layerIndex;
+  /** The mime type. */
+  public String mimeType;
   /** Size of the frame associated with this header, in bytes. */
   public int frameSize;
   /** Sample rate in samples per second. */
@@ -175,10 +191,10 @@ public static void populateHeader(int headerData, MpegAudioHeader header) {
   /** Number of samples stored in the frame. */
   public int samplesPerFrame;
 
-  private void setValues(int version, int layerIndex, int frameSize, int sampleRate, int channels,
-      int bitrate, int samplesPerFrame) {
+  private void setValues(int version, String mimeType, int frameSize,
+      int sampleRate, int channels, int bitrate, int samplesPerFrame) {
     this.version = version;
-    this.layerIndex = layerIndex;
+    this.mimeType = mimeType;
     this.frameSize = frameSize;
     this.sampleRate = sampleRate;
     this.channels = channels;
diff --git a/library/src/main/java/com/google/android/exoplayer/util/H264Util.java b/library/src/main/java/com/google/android/exoplayer/util/NalUnitUtil.java
similarity index 56%
rename from library/src/main/java/com/google/android/exoplayer/util/H264Util.java
rename to library/src/main/java/com/google/android/exoplayer/util/NalUnitUtil.java
index 0cde8b472f..75830c9cc9 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/H264Util.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/NalUnitUtil.java
@@ -15,31 +15,92 @@
  */
 package com.google.android.exoplayer.util;
 
-import java.nio.ByteBuffer;
+import java.util.Arrays;
 
 /**
- * Utility methods for handling H264 data.
+ * Utility methods for handling H.264/AVC and H.265/HEVC NAL units.
  */
-public final class H264Util {
+public final class NalUnitUtil {
 
-  /** Four initial bytes that must prefix H.264/AVC NAL units for decoding. */
+  /** Four initial bytes that must prefix NAL units for decoding. */
   public static final byte[] NAL_START_CODE = new byte[] {0, 0, 0, 1};
 
+  /** Value for aspect_ratio_idc indicating an extended aspect ratio, in H.264 and H.265 SPSs. */
+  public static final int EXTENDED_SAR = 0xFF;
+  /** Aspect ratios indexed by aspect_ratio_idc, in H.264 and H.265 SPSs. */
+  public static final float[] ASPECT_RATIO_IDC_VALUES = new float[] {
+    1f /* Unspecified. Assume square */,
+    1f,
+    12f / 11f,
+    10f / 11f,
+    16f / 11f,
+    40f / 33f,
+    24f / 11f,
+    20f / 11f,
+    32f / 11f,
+    80f / 33f,
+    18f / 11f,
+    15f / 11f,
+    64f / 33f,
+    160f / 99f,
+    4f / 3f,
+    3f / 2f,
+    2f
+  };
+
+  private static final Object scratchEscapePositionsLock = new Object();
+
   /**
-   * Replaces length prefixes of NAL units in {@code buffer} with start code prefixes, within the
-   * {@code size} bytes preceding the buffer's position.
+   * Temporary store for positions of escape codes in {@link #unescapeStream(byte[], int)}. Guarded
+   * by {@link #scratchEscapePositionsLock}.
    */
-  public static void replaceLengthPrefixesWithAvcStartCodes(ByteBuffer buffer, int size) {
-    int sampleOffset = buffer.position() - size;
-    int position = sampleOffset;
-    while (position < sampleOffset + size) {
-      buffer.position(position);
-      int length = readUnsignedIntToInt(buffer);
-      buffer.position(position);
-      buffer.put(NAL_START_CODE);
-      position += length + 4;
+  private static int[] scratchEscapePositions = new int[10];
+
+  /**
+   * Unescapes {@code data} up to the specified limit, replacing occurrences of [0, 0, 3] with
+   * [0, 0]. The unescaped data is returned in-place, with the return value indicating its length.
+   * <p>
+   * Executions of this method are mutually exclusive, so it should not be called with very large
+   * buffers.
+   *
+   * @param data The data to unescape.
+   * @param limit The limit (exclusive) of the data to unescape.
+   * @return The length of the unescaped data.
+   */
+  public static int unescapeStream(byte[] data, int limit) {
+    synchronized (scratchEscapePositionsLock) {
+      int position = 0;
+      int scratchEscapeCount = 0;
+      while (position < limit) {
+        position = findNextUnescapeIndex(data, position, limit);
+        if (position < limit) {
+          if (scratchEscapePositions.length <= scratchEscapeCount) {
+            // Grow scratchEscapePositions to hold a larger number of positions.
+            scratchEscapePositions = Arrays.copyOf(scratchEscapePositions,
+                scratchEscapePositions.length * 2);
+          }
+          scratchEscapePositions[scratchEscapeCount++] = position;
+          position += 3;
+        }
+      }
+
+      int unescapedLength = limit - scratchEscapeCount;
+      int escapedPosition = 0; // The position being read from.
+      int unescapedPosition = 0; // The position being written to.
+      for (int i = 0; i < scratchEscapeCount; i++) {
+        int nextEscapePosition = scratchEscapePositions[i];
+        int copyLength = nextEscapePosition - escapedPosition;
+        System.arraycopy(data, escapedPosition, data, unescapedPosition, copyLength);
+        unescapedPosition += copyLength;
+        data[unescapedPosition++] = 0;
+        data[unescapedPosition++] = 0;
+        escapedPosition += copyLength + 3;
+      }
+
+      int remainingLength = unescapedLength - unescapedPosition;
+      System.arraycopy(data, escapedPosition, data, unescapedPosition, remainingLength);
+      return unescapedLength;
     }
-    buffer.position(sampleOffset + size);
   }
 
   /**
@@ -64,10 +125,22 @@ public static int getNalUnitType(byte[] data, int offset) {
     return data[offset + 3] & 0x1F;
   }
 
+  /**
+   * Gets the type of the H.265 NAL unit in {@code data} that starts at {@code offset}.
+   *
+   * @param data The data to search.
+   * @param offset The start offset of a NAL unit. Must lie between {@code -3} (inclusive) and
+   *     {@code data.length - 3} (exclusive).
+   * @return The type of the unit.
+   */
+  public static int getH265NalUnitType(byte[] data, int offset) {
+    return (data[offset + 3] & 0x7E) >> 1;
+  }
+
   /**
    * Finds the first NAL unit in {@code data}.
    * <p>
-   * If {@code prefixFlags} is null then the first four bytes of a NAL unit must be entirely
+   * If {@code prefixFlags} is null then the first three bytes of a NAL unit must be entirely
    * contained within the part of the array being searched in order for it to be found.
    * <p>
    * When {@code prefixFlags} is non-null, this method supports finding NAL units whose first four
@@ -109,9 +182,8 @@ public static int findNalUnit(byte[] data, int startOffset, int endOffset,
     }
 
     int limit = endOffset - 1;
-    // We're looking for the NAL unit start code prefix 0x000001, followed by a byte that matches
-    // the specified type. The value of i tracks the index of the third byte in the four bytes
-    // being examined.
+    // We're looking for the NAL unit start code prefix 0x000001. The value of i tracks the index of
+    // the third byte.
     for (int i = startOffset + 2; i < limit; i += 3) {
       if ((data[i] & 0xFE) != 0) {
         // There isn't a NAL prefix here, or at the next two positions. Do nothing and let the
@@ -134,10 +206,10 @@ public static int findNalUnit(byte[] data, int startOffset, int endOffset,
           ? (data[endOffset - 3] == 0 && data[endOffset - 2] == 0 && data[endOffset - 1] == 1)
           : length == 2 ? (prefixFlags[2] && data[endOffset - 2] == 0 && data[endOffset - 1] == 1)
           : (prefixFlags[1] && data[endOffset - 1] == 1);
-      // True if the last three bytes in the data seen so far are {0,0}.
+      // True if the last two bytes in the data seen so far are {0,0}.
       prefixFlags[1] = length > 1 ? data[endOffset - 2] == 0 && data[endOffset - 1] == 0
           : prefixFlags[2] && data[endOffset - 1] == 0;
-      // True if the last three bytes in the data seen so far are {0}.
+      // True if the last byte in the data seen so far is {0}.
       prefixFlags[2] = data[endOffset - 1] == 0;
     }
 
@@ -155,25 +227,16 @@ public static void clearPrefixFlags(boolean[] prefixFlags) {
     prefixFlags[2] = false;
   }
 
-  /**
-   * Reads an unsigned integer into an integer. This method is suitable for use when it can be
-   * assumed that the top bit will always be set to zero.
-   *
-   * @throws IllegalArgumentException If the top bit of the input data is set.
-   */
-  private static int readUnsignedIntToInt(ByteBuffer data) {
-    int result = 0xFF & data.get();
-    for (int i = 1; i < 4; i++) {
-      result <<= 8;
-      result |= 0xFF & data.get();
-    }
-    if (result < 0) {
-      throw new IllegalArgumentException("Top bit not zero: " + result);
+  private static int findNextUnescapeIndex(byte[] bytes, int offset, int limit) {
+    for (int i = offset; i < limit - 2; i++) {
+      if (bytes[i] == 0x00 && bytes[i + 1] == 0x00 && bytes[i + 2] == 0x03) {
+        return i;
+      }
     }
-    return result;
+    return limit;
   }
 
-  private H264Util() {
+  private NalUnitUtil() {
     // Prevent instantiation.
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ParsableBitArray.java b/library/src/main/java/com/google/android/exoplayer/util/ParsableBitArray.java
index b8dd63228a..a2407d7c64 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/ParsableBitArray.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/ParsableBitArray.java
@@ -26,6 +26,7 @@
   // byte (from 0 to 7).
   private int byteOffset;
   private int bitOffset;
+  private int byteLimit;
 
   /** Creates a new instance that initially has no backing data. */
   public ParsableBitArray() {}
@@ -36,7 +37,18 @@ public ParsableBitArray() {}
    * @param data The data to wrap.
    */
   public ParsableBitArray(byte[] data) {
+    this(data, data.length);
+  }
+
+  /**
+   * Creates a new instance that wraps an existing array.
+   *
+   * @param data The data to wrap.
+   * @param limit The limit in bytes.
+   */
+  public ParsableBitArray(byte[] data, int limit) {
     this.data = data;
+    byteLimit = limit;
   }
 
   /**
@@ -45,9 +57,27 @@ public ParsableBitArray(byte[] data) {
    * @param data The array to wrap.
    */
   public void reset(byte[] data) {
+    reset(data, data.length);
+  }
+
+  /**
+   * Updates the instance to wrap {@code data}, and resets the position to zero.
+   *
+   * @param data The array to wrap.
+   * @param limit The limit in bytes.
+   */
+  public void reset(byte[] data, int limit) {
     this.data = data;
     byteOffset = 0;
     bitOffset = 0;
+    byteLimit = limit;
+  }
+
+  /**
+   * Returns the number of bits yet to be read.
+   */
+  public int bitsLeft() {
+    return (byteLimit - byteOffset) * 8 - bitOffset;
   }
 
   /**
@@ -67,6 +97,7 @@ public int getPosition() {
   public void setPosition(int position) {
     byteOffset = position / 8;
     bitOffset = position - (byteOffset * 8);
+    assertValidOffset();
   }
 
   /**
@@ -81,6 +112,7 @@ public void skipBits(int n) {
       byteOffset++;
       bitOffset -= 8;
     }
+    assertValidOffset();
   }
 
   /**
@@ -103,12 +135,20 @@ public int readBits(int n) {
       return 0;
     }
 
-    int retval = 0;
+    int returnValue = 0;
 
     // While n >= 8, read whole bytes.
     while (n >= 8) {
+      int byteValue;
+      if (bitOffset != 0) {
+        byteValue = ((data[byteOffset] & 0xFF) << bitOffset)
+            | ((data[byteOffset + 1] & 0xFF) >>> (8 - bitOffset));
+      } else {
+        byteValue = data[byteOffset];
+      }
       n -= 8;
-      retval |= (readUnsignedByte() << n);
+      returnValue |= (byteValue & 0xFF) << n;
+      byteOffset++;
     }
 
     if (n > 0) {
@@ -117,12 +157,12 @@ public int readBits(int n) {
 
       if (nextBit > 8) {
         // Combine bits from current byte and next byte.
-        retval |= (((getUnsignedByte(byteOffset) << (nextBit - 8)
-            | (getUnsignedByte(byteOffset + 1) >> (16 - nextBit))) & writeMask));
+        returnValue |= ((((data[byteOffset] & 0xFF) << (nextBit - 8)
+            | ((data[byteOffset + 1] & 0xFF) >> (16 - nextBit))) & writeMask));
         byteOffset++;
       } else {
         // Bits to be read only within current byte.
-        retval |= ((getUnsignedByte(byteOffset) >> (8 - nextBit)) & writeMask);
+        returnValue |= (((data[byteOffset] & 0xFF) >> (8 - nextBit)) & writeMask);
         if (nextBit == 8) {
           byteOffset++;
         }
@@ -131,7 +171,27 @@ public int readBits(int n) {
       bitOffset = nextBit % 8;
     }
 
-    return retval;
+    assertValidOffset();
+    return returnValue;
+  }
+
+  /**
+   * Peeks the length of an Exp-Golomb-coded integer (signed or unsigned) starting from the current
+   * offset, returning the length or -1 if the limit is reached.
+   *
+   * @return The length of the Exp-Golob-coded integer, or -1.
+   */
+  public int peekExpGolombCodedNumLength() {
+    int initialByteOffset = byteOffset;
+    int initialBitOffset = bitOffset;
+    int leadingZeros = 0;
+    while (byteOffset < byteLimit && !readBit()) {
+      leadingZeros++;
+    }
+    boolean hitLimit = byteOffset == byteLimit;
+    byteOffset = initialByteOffset;
+    bitOffset = initialBitOffset;
+    return hitLimit ? -1 : leadingZeros * 2 + 1;
   }
 
   /**
@@ -153,22 +213,6 @@ public int readSignedExpGolombCodedInt() {
     return ((codeNum % 2) == 0 ? -1 : 1) * ((codeNum + 1) / 2);
   }
 
-  private int readUnsignedByte() {
-    int value;
-    if (bitOffset != 0) {
-      value = ((data[byteOffset] & 0xFF) << bitOffset)
-          | ((data[byteOffset + 1] & 0xFF) >>> (8 - bitOffset));
-    } else {
-      value = data[byteOffset];
-    }
-    byteOffset++;
-    return value & 0xFF;
-  }
-
-  private int getUnsignedByte(int offset) {
-    return data[offset] & 0xFF;
-  }
-
   private int readExpGolombCodeNum() {
     int leadingZeros = 0;
     while (!readBit()) {
@@ -177,4 +221,11 @@ private int readExpGolombCodeNum() {
     return (1 << leadingZeros) - 1 + (leadingZeros > 0 ? readBits(leadingZeros) : 0);
   }
 
+  private void assertValidOffset() {
+    // It is fine for position to be at the end of the array, but no further.
+    Assertions.checkState(byteOffset >= 0
+        && (bitOffset >= 0 && bitOffset < 8)
+        && (byteOffset < byteLimit || (byteOffset == byteLimit && bitOffset == 0)));
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/util/SlidingPercentile.java b/library/src/main/java/com/google/android/exoplayer/util/SlidingPercentile.java
index 961f4d8935..77294f4562 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/SlidingPercentile.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/SlidingPercentile.java
@@ -67,7 +67,7 @@ public int compare(Sample a, Sample b) {
   public SlidingPercentile(int maxWeight) {
     this.maxWeight = maxWeight;
     recycledSamples = new Sample[MAX_RECYCLED_SAMPLES];
-    samples = new ArrayList<Sample>();
+    samples = new ArrayList<>();
     currentSortOrder = SORT_ORDER_NONE;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/util/Util.java b/library/src/main/java/com/google/android/exoplayer/util/Util.java
index c2b19c6d99..2e90c4abba 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/Util.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/Util.java
@@ -20,12 +20,15 @@
 import com.google.android.exoplayer.upstream.DataSource;
 import com.google.android.exoplayer.upstream.DataSpec;
 
+import android.annotation.SuppressLint;
 import android.content.Context;
 import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
 import android.os.Build;
 import android.text.TextUtils;
 
+import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -40,6 +43,7 @@
 import java.util.GregorianCalendar;
 import java.util.List;
 import java.util.Locale;
+import java.util.Map;
 import java.util.TimeZone;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -59,6 +63,18 @@
    */
   public static final int SDK_INT = android.os.Build.VERSION.SDK_INT;
 
+  /**
+   * Like {@link android.os.Build#DEVICE}, but in a place where it can be conveniently overridden
+   * for local testing.
+   */
+  public static final String DEVICE = android.os.Build.DEVICE;
+
+  /**
+   * Like {@link android.os.Build#MANUFACTURER}, but in a place where it can be conveniently
+   * overridden for local testing.
+   */
+  public static final String MANUFACTURER = android.os.Build.MANUFACTURER;
+
   private static final Pattern XS_DATE_TIME_PATTERN = Pattern.compile(
       "(\\d\\d\\d\\d)\\-(\\d\\d)\\-(\\d\\d)[Tt]"
       + "(\\d\\d):(\\d\\d):(\\d\\d)(\\.(\\d+))?"
@@ -72,6 +88,17 @@
 
   private Util() {}
 
+  /**
+   * Returns whether the device is an AndroidTV.
+   *
+   * @param context A context.
+   * @return True if the device is an AndroidTV. False otherwise.
+   */
+  @SuppressLint("InlinedApi")
+  public static boolean isAndroidTv(Context context) {
+    return context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);
+  }
+
   /**
    * Returns true if the URL points to a file on the local device
    *
@@ -541,6 +568,22 @@ public static int getIntegerCodeForString(String string) {
     return result;
   }
 
+  /**
+   * Returns a hex string representation of the data provided.
+   *
+   * @param data The byte array containing the data to be turned into a hex string.
+   * @param beginIndex The begin index, inclusive.
+   * @param endIndex The end index, exclusive.
+   * @return A string containing the hex representation of the data provided.
+   */
+  public static String getHexStringFromBytes(byte[] data, int beginIndex, int endIndex) {
+    StringBuffer dataStringBuffer = new StringBuffer(endIndex - beginIndex);
+    for (int i = beginIndex; i < endIndex; i++) {
+      dataStringBuffer.append(String.format(Locale.US, "%02X", data[i]));
+    }
+    return dataStringBuffer.toString();
+  }
+
   /**
    * Returns a user agent string based on the given application name and the library version.
    *
@@ -561,4 +604,56 @@ public static String getUserAgent(Context context, String applicationName) {
         + ") " + "ExoPlayerLib/" + ExoPlayerLibraryInfo.VERSION;
   }
 
+  /**
+   * Executes a post request using {@link HttpURLConnection}.
+   *
+   * @param url The request URL.
+   * @param data The request body, or null.
+   * @param requestProperties Request properties, or null.
+   * @return The response body.
+   * @throws IOException If an error occurred making the request.
+   */
+  // TODO: Remove this and use HttpDataSource once DataSpec supports inclusion of a POST body.
+  public static byte[] executePost(String url, byte[] data, Map<String, String> requestProperties)
+      throws IOException {
+    HttpURLConnection urlConnection = null;
+    try {
+      urlConnection = (HttpURLConnection) new URL(url).openConnection();
+      urlConnection.setRequestMethod("POST");
+      urlConnection.setDoOutput(data != null);
+      urlConnection.setDoInput(true);
+      if (requestProperties != null) {
+        for (Map.Entry<String, String> requestProperty : requestProperties.entrySet()) {
+          urlConnection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());
+        }
+      }
+      // Write the request body, if there is one.
+      if (data != null) {
+        OutputStream out = urlConnection.getOutputStream();
+        try {
+          out.write(data);
+        } finally {
+          out.close();
+        }
+      }
+      // Read and return the response body.
+      InputStream inputStream = urlConnection.getInputStream();
+      try {
+        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+        byte scratch[] = new byte[1024];
+        int bytesRead;
+        while ((bytesRead = inputStream.read(scratch)) != -1) {
+          byteArrayOutputStream.write(scratch, 0, bytesRead);
+        }
+        return byteArrayOutputStream.toByteArray();
+      } finally {
+        inputStream.close();
+      }
+    } finally {
+      if (urlConnection != null) {
+        urlConnection.disconnect();
+      }
+    }
+  }
+
 }
diff --git a/library/src/test/.classpath b/library/src/test/.classpath
index 171a8c3ec8..be2dd156ff 100644
--- a/library/src/test/.classpath
+++ b/library/src/test/.classpath
@@ -5,6 +5,5 @@
 	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
 	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
 	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry combineaccessrules="false" kind="src" path="/ExoPlayerDemo"/>
 	<classpathentry kind="output" path="bin/classes"/>
 </classpath>
diff --git a/library/src/test/.project b/library/src/test/.project
index d63886b065..888dce8656 100644
--- a/library/src/test/.project
+++ b/library/src/test/.project
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <projectDescription>
-	<name>ExoPlayerTests</name>
+	<name>ExoPlayerLibTests</name>
 	<comment></comment>
 	<projects>
 		<project>ExoPlayerLib</project>
diff --git a/library/src/test/.settings/org.eclipse.jdt.core.prefs b/library/src/test/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000000..64cef5023a
--- /dev/null
+++ b/library/src/test/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,4 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.7
+org.eclipse.jdt.core.compiler.compliance=1.7
+org.eclipse.jdt.core.compiler.source=1.7
diff --git a/library/src/test/AndroidManifest.xml b/library/src/test/AndroidManifest.xml
index 71bb5c3a66..c9c12992a1 100644
--- a/library/src/test/AndroidManifest.xml
+++ b/library/src/test/AndroidManifest.xml
@@ -15,16 +15,19 @@
 -->
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer.tests">
 
   <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="22"/>
 
-  <application>
+  <application android:debuggable="true"
+      android:allowBackup="false"
+      tools:ignore="MissingApplicationIcon,HardcodedDebugMode">
     <uses-library android:name="android.test.runner"/>
   </application>
 
   <instrumentation
-      android:targetPackage="com.google.android.exoplayer.demo"
+      android:targetPackage="com.google.android.exoplayer.tests"
       android:name="android.test.InstrumentationTestRunner"/>
 
 </manifest>
diff --git a/library/src/test/assets/subrip/empty b/library/src/test/assets/subrip/empty
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/library/src/test/assets/subrip/typical b/library/src/test/assets/subrip/typical
new file mode 100644
index 0000000000..800b0678c5
--- /dev/null
+++ b/library/src/test/assets/subrip/typical
@@ -0,0 +1,8 @@
+1
+00:00:00,000 --> 00:00:01,234
+This is the first subtitle.
+
+2
+00:00:02,345 --> 00:00:03,456
+This is the second subtitle.
+Second subtitle with second line.
\ No newline at end of file
diff --git a/library/src/test/assets/webvtt/live_typical b/library/src/test/assets/webvtt/live_typical
new file mode 100644
index 0000000000..9f4864b690
--- /dev/null
+++ b/library/src/test/assets/webvtt/live_typical
@@ -0,0 +1,9 @@
+EXO-HEADER=OFFSET:-5000000
+WEBVTT
+X-TIMESTAMP-MAP=LOCAL:00:00.000,MPEGTS:450000
+
+00:00.000 --> 00:01.234
+This is the first subtitle.
+
+00:02.345 --> 00:03.456
+This is the second subtitle.
diff --git a/library/src/test/assets/webvtt/typical b/library/src/test/assets/webvtt/typical
index d1395efe1b..7bd3ca9198 100644
--- a/library/src/test/assets/webvtt/typical
+++ b/library/src/test/assets/webvtt/typical
@@ -1,4 +1,4 @@
-WEBVTT
+WEBVTT # This comment is allowed
 X-TIMESTAMP-MAP=LOCAL:00:00.000,MPEGTS:450000
 
 00:00.000 --> 00:01.234
diff --git a/library/src/test/assets/webvtt/typical_with_tags b/library/src/test/assets/webvtt/typical_with_tags
index 36e630e240..aecf1cb2b7 100644
--- a/library/src/test/assets/webvtt/typical_with_tags
+++ b/library/src/test/assets/webvtt/typical_with_tags
@@ -11,4 +11,4 @@ This is the <b><i>second</b></i> subtitle.
 This is the <c.red.caps>third</c> subtitle.
 
 00:06.000 --> 00:07.000
-This is&nbsp;the &lt;fourth&gt; &amp;subtitle.
+This is the &lt;fourth&gt; &amp;subtitle.
diff --git a/library/src/test/java/com/google/android/exoplayer/MediaFormatTest.java b/library/src/test/java/com/google/android/exoplayer/MediaFormatTest.java
index 6da52e50f9..62e4ce044f 100644
--- a/library/src/test/java/com/google/android/exoplayer/MediaFormatTest.java
+++ b/library/src/test/java/com/google/android/exoplayer/MediaFormatTest.java
@@ -37,7 +37,7 @@ public void testConversionToFrameworkFormat() {
 
     byte[] initData1 = new byte[] {1, 2, 3};
     byte[] initData2 = new byte[] {4, 5, 6};
-    List<byte[]> initData = new ArrayList<byte[]>();
+    List<byte[]> initData = new ArrayList<>();
     initData.add(initData1);
     initData.add(initData2);
 
diff --git a/library/src/test/java/com/google/android/exoplayer/TimeRangeTest.java b/library/src/test/java/com/google/android/exoplayer/TimeRangeTest.java
new file mode 100644
index 0000000000..5c93130de6
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/TimeRangeTest.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer;
+
+import junit.framework.TestCase;
+
+/**
+ * Unit test for {@link TimeRange}.
+ */
+public class TimeRangeTest extends TestCase {
+
+  public void testEquals() {
+    TimeRange timeRange1 = new TimeRange(TimeRange.TYPE_SNAPSHOT, 0, 30000000);
+    assertTrue(timeRange1.equals(timeRange1));
+    
+    TimeRange timeRange2 = new TimeRange(TimeRange.TYPE_SNAPSHOT, 0, 30000000);
+    assertTrue(timeRange1.equals(timeRange2));
+    
+    TimeRange timeRange3 = new TimeRange(TimeRange.TYPE_SNAPSHOT, 0, 60000000);
+    assertFalse(timeRange1.equals(timeRange3));
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java b/library/src/test/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java
index fc343bbc41..70d3b195db 100644
--- a/library/src/test/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java
+++ b/library/src/test/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java
@@ -15,9 +15,11 @@
  */
 package com.google.android.exoplayer.dash;
 
+import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
 import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.TimeRange;
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.chunk.ChunkOperationHolder;
 import com.google.android.exoplayer.chunk.Format;
@@ -35,7 +37,7 @@
 import com.google.android.exoplayer.dash.mpd.SegmentBase.SegmentTimelineElement;
 import com.google.android.exoplayer.dash.mpd.SegmentBase.SingleSegmentBase;
 import com.google.android.exoplayer.dash.mpd.UrlTemplate;
-import com.google.android.exoplayer.testutil.Util;
+import com.google.android.exoplayer.testutil.TestUtil;
 import com.google.android.exoplayer.upstream.DataSource;
 import com.google.android.exoplayer.util.FakeClock;
 import com.google.android.exoplayer.util.ManifestFetcher;
@@ -55,12 +57,19 @@
 
   private static final FormatEvaluator EVALUATOR = new FixedEvaluator();
 
-  private static final long AVAILABILITY_START_TIME = 0;
-  private static final long AVAILABILITY_LATENCY = 5000;
-  private static final long AVAILABILITY_REALTIME_OFFSET = 1000;
-  private static final long AVAILABILITY_CURRENT_TIME =
-      AVAILABILITY_START_TIME + AVAILABILITY_LATENCY - AVAILABILITY_REALTIME_OFFSET;
-  private static final FakeClock AVAILABILITY_CLOCK = new FakeClock(AVAILABILITY_CURRENT_TIME);
+  private static final long VOD_DURATION_MS = 30000;
+
+  private static final long LIVE_SEGMENT_COUNT = 5;
+  private static final long LIVE_SEGMENT_DURATION_MS = 1000;
+  private static final long LIVE_DURATION_MS = LIVE_SEGMENT_COUNT * LIVE_SEGMENT_DURATION_MS;
+  private static final long LIVE_TIMESHIFT_BUFFER_DEPTH_MS = LIVE_DURATION_MS;
+
+  private static final long AVAILABILITY_START_TIME_MS = 60000;
+  private static final long AVAILABILITY_REALTIME_OFFSET_MS = 1000;
+  private static final long AVAILABILITY_CURRENT_TIME_MS =
+      AVAILABILITY_START_TIME_MS + LIVE_TIMESHIFT_BUFFER_DEPTH_MS - AVAILABILITY_REALTIME_OFFSET_MS;
+
+  private static final long LIVE_SEEK_BEYOND_EDGE_MS = 60000;
 
   private static final int TALL_HEIGHT = 200;
   private static final int WIDE_WIDTH = 400;
@@ -77,7 +86,7 @@
 
   @Override
   public void setUp() throws Exception {
-    Util.setUpMockito(this);
+    TestUtil.setUpMockito(this);
   }
 
   public void testMaxVideoDimensions() {
@@ -90,6 +99,19 @@ public void testMaxVideoDimensions() {
     assertEquals(TALL_HEIGHT, out.getMaxVideoHeight());
   }
 
+  public void testGetSeekRangeOnVod() {
+    DashChunkSource chunkSource = new DashChunkSource(generateVodMpd(), AdaptationSet.TYPE_VIDEO,
+        null, null, mock(FormatEvaluator.class));
+    chunkSource.enable();
+    TimeRange seekRange = chunkSource.getSeekRange();
+
+    checkSeekRange(seekRange, 0, VOD_DURATION_MS * 1000);
+
+    long[] seekRangeValuesMs = seekRange.getCurrentBoundsMs(null);
+    assertEquals(0, seekRangeValuesMs[0]);
+    assertEquals(VOD_DURATION_MS, seekRangeValuesMs[1]);
+  }
+
   public void testMaxVideoDimensionsLegacy() {
     SingleSegmentBase segmentBase1 = new SingleSegmentBase("https://example.com/1.mp4");
     Representation representation1 =
@@ -107,221 +129,338 @@ public void testMaxVideoDimensionsLegacy() {
     assertEquals(TALL_HEIGHT, out.getMaxVideoHeight());
   }
 
-  public void testLiveEdgeNoLatencyWithTimeline() {
-    DashChunkSource chunkSource = setupLiveEdgeTimelineTest(0L);
-    List<MediaChunk> queue = new ArrayList<MediaChunk>();
-    ChunkOperationHolder out = new ChunkOperationHolder();
-    chunkSource.getChunkOperation(queue, 0, 0, out);
-
-    assertEquals(4000000L, ((MediaChunk) out.chunk).startTimeUs);
-    assertEquals(5000000L, ((MediaChunk) out.chunk).endTimeUs);
+  public void testLiveEdgeNoLatency() {
+    long startTimeMs = 0;
+    long liveEdgeLatencyMs = 0;
+    long seekPositionMs = LIVE_SEEK_BEYOND_EDGE_MS;
+    long seekRangeStartMs = 0;
+    long seekRangeEndMs = LIVE_DURATION_MS - liveEdgeLatencyMs;
+    long chunkStartTimeMs = 4000;
+    long chunkEndTimeMs = 5000;
+
+    checkLiveTimelineConsistency(startTimeMs, liveEdgeLatencyMs, seekPositionMs,
+        seekRangeStartMs, seekRangeEndMs, chunkStartTimeMs, chunkEndTimeMs);
   }
 
-  public void testLiveEdge500msLatencyWithTimeline() {
-    DashChunkSource chunkSource = setupLiveEdgeTimelineTest(500L);
-    List<MediaChunk> queue = new ArrayList<MediaChunk>();
-    ChunkOperationHolder out = new ChunkOperationHolder();
-    chunkSource.getChunkOperation(queue, 0, 0, out);
-
-    assertEquals(4000000L, ((MediaChunk) out.chunk).startTimeUs);
-    assertEquals(5000000L, ((MediaChunk) out.chunk).endTimeUs);
+  public void testLiveEdgeAlmostNoLatency() {
+    long startTimeMs = 0;
+    long liveEdgeLatencyMs = 1;
+    long seekPositionMs = LIVE_SEEK_BEYOND_EDGE_MS;
+    long seekRangeStartMs = 0;
+    long seekRangeEndMs = LIVE_DURATION_MS - liveEdgeLatencyMs;
+    long chunkStartTimeMs = 4000;
+    long chunkEndTimeMs = 5000;
+
+    checkLiveTimelineConsistency(startTimeMs, liveEdgeLatencyMs, seekPositionMs,
+        seekRangeStartMs, seekRangeEndMs, chunkStartTimeMs, chunkEndTimeMs);
   }
 
-  public void testLiveEdge1000msLatencyWithTimeline() {
-    DashChunkSource chunkSource = setupLiveEdgeTimelineTest(1000L);
-    List<MediaChunk> queue = new ArrayList<MediaChunk>();
-    ChunkOperationHolder out = new ChunkOperationHolder();
-    chunkSource.getChunkOperation(queue, 0, 0, out);
-
-    assertEquals(4000000L, ((MediaChunk) out.chunk).startTimeUs);
-    assertEquals(5000000L, ((MediaChunk) out.chunk).endTimeUs);
+  public void testLiveEdge500msLatency() {
+    long startTimeMs = 0;
+    long liveEdgeLatencyMs = 500;
+    long seekPositionMs = LIVE_SEEK_BEYOND_EDGE_MS;
+    long seekRangeStartMs = 0;
+    long seekRangeEndMs = LIVE_DURATION_MS - liveEdgeLatencyMs;
+    long chunkStartTimeMs = 4000;
+    long chunkEndTimeMs = 5000;
+
+    checkLiveTimelineConsistency(startTimeMs, liveEdgeLatencyMs, seekPositionMs,
+        seekRangeStartMs, seekRangeEndMs, chunkStartTimeMs, chunkEndTimeMs);
   }
 
-  public void testLiveEdge1001msLatencyWithTimeline() {
-    DashChunkSource chunkSource = setupLiveEdgeTimelineTest(1001L);
-    List<MediaChunk> queue = new ArrayList<MediaChunk>();
-    ChunkOperationHolder out = new ChunkOperationHolder();
-    chunkSource.getChunkOperation(queue, 0, 0, out);
-
-    assertEquals(3000000L, ((MediaChunk) out.chunk).startTimeUs);
-    assertEquals(4000000L, ((MediaChunk) out.chunk).endTimeUs);
+  public void testLiveEdge1000msLatency() {
+    long startTimeMs = 0;
+    long liveEdgeLatencyMs = 1000;
+    long seekPositionMs = LIVE_SEEK_BEYOND_EDGE_MS;
+    long seekRangeStartMs = 0;
+    long seekRangeEndMs = LIVE_DURATION_MS - liveEdgeLatencyMs;
+    long chunkStartTimeMs = 4000;
+    long chunkEndTimeMs = 5000;
+
+    checkLiveTimelineConsistency(startTimeMs, liveEdgeLatencyMs, seekPositionMs,
+        seekRangeStartMs, seekRangeEndMs, chunkStartTimeMs, chunkEndTimeMs);
   }
 
-  public void testLiveEdge2500msLatencyWithTimeline() {
-    DashChunkSource chunkSource = setupLiveEdgeTimelineTest(2500L);
-    List<MediaChunk> queue = new ArrayList<MediaChunk>();
-    ChunkOperationHolder out = new ChunkOperationHolder();
-    chunkSource.getChunkOperation(queue, 0, 0, out);
-
-    assertEquals(2000000L, ((MediaChunk) out.chunk).startTimeUs);
-    assertEquals(3000000L, ((MediaChunk) out.chunk).endTimeUs);
+  public void testLiveEdge1001msLatency() {
+    long startTimeMs = 0;
+    long liveEdgeLatencyMs = 1001;
+    long seekPositionMs = LIVE_SEEK_BEYOND_EDGE_MS;
+    long seekRangeStartMs = 0;
+    long seekRangeEndMs = LIVE_DURATION_MS - liveEdgeLatencyMs;
+    long chunkStartTimeMs = 3000;
+    long chunkEndTimeMs = 4000;
+
+    checkLiveTimelineConsistency(startTimeMs, liveEdgeLatencyMs, seekPositionMs,
+        seekRangeStartMs, seekRangeEndMs, chunkStartTimeMs, chunkEndTimeMs);
   }
 
-  public void testLiveEdgeVeryHighLatencyWithTimeline() {
-    DashChunkSource chunkSource = setupLiveEdgeTimelineTest(10000L);
-    List<MediaChunk> queue = new ArrayList<MediaChunk>();
-    ChunkOperationHolder out = new ChunkOperationHolder();
-    chunkSource.getChunkOperation(queue, 0, 0, out);
-
-    assertEquals(0L, ((MediaChunk) out.chunk).startTimeUs);
-    assertEquals(1000000L, ((MediaChunk) out.chunk).endTimeUs);
+  public void testLiveEdge2500msLatency() {
+    long startTimeMs = 0;
+    long liveEdgeLatencyMs = 2500;
+    long seekPositionMs = LIVE_SEEK_BEYOND_EDGE_MS;
+    long seekRangeStartMs = 0;
+    long seekRangeEndMs = LIVE_DURATION_MS - liveEdgeLatencyMs;
+    long chunkStartTimeMs = 2000;
+    long chunkEndTimeMs = 3000;
+
+    checkLiveTimelineConsistency(startTimeMs, liveEdgeLatencyMs, seekPositionMs,
+        seekRangeStartMs, seekRangeEndMs, chunkStartTimeMs, chunkEndTimeMs);
   }
 
-  public void testLiveEdgeNoLatencyWithTemplate() {
-    DashChunkSource chunkSource = setupLiveEdgeTemplateTest(0L);
-    List<MediaChunk> queue = new ArrayList<MediaChunk>();
-    ChunkOperationHolder out = new ChunkOperationHolder();
-    chunkSource.getChunkOperation(queue, 0, 0, out);
-
-    // this should actually return the "5th" segment, but it currently returns the "6th", which
-    // doesn't actually exist yet; this will be resolved in a subsequent cl (cl/87518875).
-    //assertEquals(4000000L, ((MediaChunk) out.chunk).startTimeUs);
-    //assertEquals(5000000L, ((MediaChunk) out.chunk).endTimeUs);
+  public void testLiveEdgeVeryHighLatency() {
+    long startTimeMs = 0;
+    long liveEdgeLatencyMs = 10000;
+    long seekPositionMs = LIVE_SEEK_BEYOND_EDGE_MS;
+    long seekRangeStartMs = 0;
+    long seekRangeEndMs = 0;
+    long chunkStartTimeMs = 0;
+    long chunkEndTimeMs = 1000;
+
+    checkLiveTimelineConsistency(startTimeMs, liveEdgeLatencyMs, seekPositionMs,
+        seekRangeStartMs, seekRangeEndMs, chunkStartTimeMs, chunkEndTimeMs);
   }
 
-  public void testLiveEdgeAlmostNoLatencyWithTemplate() {
-    DashChunkSource chunkSource = setupLiveEdgeTemplateTest(1L);
-    List<MediaChunk> queue = new ArrayList<MediaChunk>();
-    ChunkOperationHolder out = new ChunkOperationHolder();
-    chunkSource.getChunkOperation(queue, 0, 0, out);
-
-    assertEquals(4000000L, ((MediaChunk) out.chunk).startTimeUs);
-    assertEquals(5000000L, ((MediaChunk) out.chunk).endTimeUs);
+  public void testLiveEdgeNoLatencyInProgress() {
+    long startTimeMs = 3000;
+    long liveEdgeLatencyMs = 0;
+    long seekPositionMs = LIVE_SEEK_BEYOND_EDGE_MS;
+    long seekRangeStartMs = 3000;
+    long seekRangeEndMs = 3000 + LIVE_DURATION_MS - liveEdgeLatencyMs;
+    long chunkStartTimeMs = 7000;
+    long chunkEndTimeMs = 8000;
+
+    checkLiveTimelineConsistency(startTimeMs, liveEdgeLatencyMs, seekPositionMs,
+        seekRangeStartMs, seekRangeEndMs, chunkStartTimeMs, chunkEndTimeMs);
   }
 
-  public void testLiveEdge500msLatencyWithTemplate() {
-    DashChunkSource chunkSource = setupLiveEdgeTemplateTest(500L);
-    List<MediaChunk> queue = new ArrayList<MediaChunk>();
-    ChunkOperationHolder out = new ChunkOperationHolder();
-    chunkSource.getChunkOperation(queue, 0, 0, out);
-
-    assertEquals(4000000L, ((MediaChunk) out.chunk).startTimeUs);
-    assertEquals(5000000L, ((MediaChunk) out.chunk).endTimeUs);
+  public void testLiveEdgeAlmostNoLatencyInProgress() {
+    long startTimeMs = 3000;
+    long liveEdgeLatencyMs = 1;
+    long seekPositionMs = LIVE_SEEK_BEYOND_EDGE_MS;
+    long seekRangeStartMs = 3000;
+    long seekRangeEndMs = 3000 + LIVE_DURATION_MS - liveEdgeLatencyMs;
+    long chunkStartTimeMs = 7000;
+    long chunkEndTimeMs = 8000;
+
+    checkLiveTimelineConsistency(startTimeMs, liveEdgeLatencyMs, seekPositionMs,
+        seekRangeStartMs, seekRangeEndMs, chunkStartTimeMs, chunkEndTimeMs);
   }
 
-  public void testLiveEdge1000msLatencyWithTemplate() {
-    DashChunkSource chunkSource = setupLiveEdgeTemplateTest(1000L);
-    List<MediaChunk> queue = new ArrayList<MediaChunk>();
-    ChunkOperationHolder out = new ChunkOperationHolder();
-    chunkSource.getChunkOperation(queue, 0, 0, out);
-
-    assertEquals(4000000L, ((MediaChunk) out.chunk).startTimeUs);
-    assertEquals(5000000L, ((MediaChunk) out.chunk).endTimeUs);
+  public void testLiveEdge500msLatencyInProgress() {
+    long startTimeMs = 3000;
+    long liveEdgeLatencyMs = 500;
+    long seekPositionMs = LIVE_SEEK_BEYOND_EDGE_MS;
+    long seekRangeStartMs = 3000;
+    long seekRangeEndMs = 3000 + LIVE_DURATION_MS - liveEdgeLatencyMs;
+    long chunkStartTimeMs = 7000;
+    long chunkEndTimeMs = 8000;
+
+    checkLiveTimelineConsistency(startTimeMs, liveEdgeLatencyMs, seekPositionMs,
+        seekRangeStartMs, seekRangeEndMs, chunkStartTimeMs, chunkEndTimeMs);
   }
 
-  public void testLiveEdge1001msLatencyWithTemplate() {
-    DashChunkSource chunkSource = setupLiveEdgeTemplateTest(1001L);
-    List<MediaChunk> queue = new ArrayList<MediaChunk>();
-    ChunkOperationHolder out = new ChunkOperationHolder();
-    chunkSource.getChunkOperation(queue, 0, 0, out);
+  public void testLiveEdge1000msLatencyInProgress() {
+    long startTimeMs = 3000;
+    long liveEdgeLatencyMs = 1000;
+    long seekPositionMs = LIVE_SEEK_BEYOND_EDGE_MS;
+    long seekRangeStartMs = 3000;
+    long seekRangeEndMs = 3000 + LIVE_DURATION_MS - liveEdgeLatencyMs;
+    long chunkStartTimeMs = 7000;
+    long chunkEndTimeMs = 8000;
+
+    checkLiveTimelineConsistency(startTimeMs, liveEdgeLatencyMs, seekPositionMs,
+        seekRangeStartMs, seekRangeEndMs, chunkStartTimeMs, chunkEndTimeMs);
+  }
 
-    assertEquals(3000000L, ((MediaChunk) out.chunk).startTimeUs);
-    assertEquals(4000000L, ((MediaChunk) out.chunk).endTimeUs);
+  public void testLiveEdge1001msLatencyInProgress() {
+    long startTimeMs = 3000;
+    long liveEdgeLatencyMs = 1001;
+    long seekPositionMs = LIVE_SEEK_BEYOND_EDGE_MS;
+    long seekRangeStartMs = 3000;
+    long seekRangeEndMs = 3000 + LIVE_DURATION_MS - liveEdgeLatencyMs;
+    long chunkStartTimeMs = 6000;
+    long chunkEndTimeMs = 7000;
+
+    checkLiveTimelineConsistency(startTimeMs, liveEdgeLatencyMs, seekPositionMs,
+        seekRangeStartMs, seekRangeEndMs, chunkStartTimeMs, chunkEndTimeMs);
   }
 
-  public void testLiveEdge2500msLatencyWithTemplate() {
-    DashChunkSource chunkSource = setupLiveEdgeTemplateTest(2500L);
-    List<MediaChunk> queue = new ArrayList<MediaChunk>();
-    ChunkOperationHolder out = new ChunkOperationHolder();
-    chunkSource.getChunkOperation(queue, 0, 0, out);
+  public void testLiveEdge2500msLatencyInProgress() {
+    long startTimeMs = 3000;
+    long liveEdgeLatencyMs = 2500;
+    long seekPositionMs = LIVE_SEEK_BEYOND_EDGE_MS;
+    long seekRangeStartMs = 3000;
+    long seekRangeEndMs = 3000 + LIVE_DURATION_MS - liveEdgeLatencyMs;
+    long chunkStartTimeMs = 5000;
+    long chunkEndTimeMs = 6000;
+
+    checkLiveTimelineConsistency(startTimeMs, liveEdgeLatencyMs, seekPositionMs,
+        seekRangeStartMs, seekRangeEndMs, chunkStartTimeMs, chunkEndTimeMs);
+  }
 
-    assertEquals(2000000L, ((MediaChunk) out.chunk).startTimeUs);
-    assertEquals(3000000L, ((MediaChunk) out.chunk).endTimeUs);
+  public void testLiveEdgeVeryHighLatencyInProgress() {
+    long startTimeMs = 3000;
+    long liveEdgeLatencyMs = 10000;
+    long seekPositionMs = LIVE_SEEK_BEYOND_EDGE_MS;
+    long seekRangeStartMs = 3000;
+    long seekRangeEndMs = 3000;
+    long chunkStartTimeMs = 3000;
+    long chunkEndTimeMs = 4000;
+
+    checkLiveEdgeLatencyWithTimeline(startTimeMs, 0, liveEdgeLatencyMs, seekPositionMs,
+        seekRangeStartMs, seekRangeEndMs, chunkStartTimeMs, chunkEndTimeMs);
+    checkLiveEdgeLatencyWithTemplateAndUnlimitedTimeshift(startTimeMs, liveEdgeLatencyMs,
+        seekPositionMs, 0, 0, 1000);
+    checkLiveEdgeLatencyWithTemplateAndLimitedTimeshift(startTimeMs, liveEdgeLatencyMs,
+        seekPositionMs, seekRangeStartMs, seekRangeEndMs, chunkStartTimeMs, chunkEndTimeMs);
   }
 
-  public void testLiveEdgeVeryHighLatencyWithTemplate() {
-    DashChunkSource chunkSource = setupLiveEdgeTemplateTest(10000L);
-    List<MediaChunk> queue = new ArrayList<MediaChunk>();
-    ChunkOperationHolder out = new ChunkOperationHolder();
-    chunkSource.getChunkOperation(queue, 0, 0, out);
+  private static Representation generateVodRepresentation(long startTimeMs, long duration,
+      Format format) {
+    SingleSegmentBase segmentBase = new SingleSegmentBase("https://example.com/1.mp4");
+    return Representation.newInstance(startTimeMs, duration, null, 0, format, segmentBase);
+  }
 
-    assertEquals(0L, ((MediaChunk) out.chunk).startTimeUs);
-    assertEquals(1000000L, ((MediaChunk) out.chunk).endTimeUs);
+  private static Representation generateSegmentTimelineRepresentation(long segmentStartMs,
+      long periodStartMs, long duration) {
+    List<SegmentTimelineElement> segmentTimeline = new ArrayList<>();
+    List<RangedUri> mediaSegments = new ArrayList<>();
+    long segmentStartTimeMs = segmentStartMs;
+    long byteStart = 0;
+    for (int i = 0; i < (duration / LIVE_SEGMENT_DURATION_MS); i++) {
+      segmentTimeline.add(new SegmentTimelineElement(segmentStartTimeMs, LIVE_SEGMENT_DURATION_MS));
+      mediaSegments.add(new RangedUri("", "", byteStart, 500L));
+      segmentStartTimeMs += LIVE_SEGMENT_DURATION_MS;
+      byteStart += 500;
+    }
+
+    int startNumber = (int) ((periodStartMs + segmentStartMs) / LIVE_SEGMENT_DURATION_MS);
+    MultiSegmentBase segmentBase = new SegmentList(null, 1000, 0,
+        TrackRenderer.UNKNOWN_TIME_US, startNumber, TrackRenderer.UNKNOWN_TIME_US, segmentTimeline,
+        mediaSegments);
+    return Representation.newInstance(periodStartMs, TrackRenderer.UNKNOWN_TIME_US, null, 0,
+        REGULAR_VIDEO, segmentBase);
   }
 
   private static MediaPresentationDescription generateMpd(boolean live,
-      List<Representation> representations) {
+      List<Representation> representations, boolean limitTimeshiftBuffer) {
     Representation firstRepresentation = representations.get(0);
     AdaptationSet adaptationSet = new AdaptationSet(0, AdaptationSet.TYPE_UNKNOWN, representations);
     Period period = new Period(null, firstRepresentation.periodStartMs,
         firstRepresentation.periodDurationMs, Collections.singletonList(adaptationSet));
     long duration = (live) ? TrackRenderer.UNKNOWN_TIME_US
         : firstRepresentation.periodDurationMs - firstRepresentation.periodStartMs;
-    return new MediaPresentationDescription(AVAILABILITY_START_TIME, duration, -1, live, -1, -1,
-        null, Collections.singletonList(period));
+    return new MediaPresentationDescription(AVAILABILITY_START_TIME_MS, duration, -1, live, -1,
+        (limitTimeshiftBuffer) ? LIVE_TIMESHIFT_BUFFER_DEPTH_MS : -1, null, null,
+        Collections.singletonList(period));
   }
 
   private static MediaPresentationDescription generateVodMpd() {
-    List<Representation> representations = new ArrayList<Representation>();
-
-    SingleSegmentBase segmentBase1 = new SingleSegmentBase("https://example.com/1.mp4");
-    Representation representation1 =
-        Representation.newInstance(0, 0, null, 0, TALL_VIDEO, segmentBase1);
-    representations.add(representation1);
+    List<Representation> representations = new ArrayList<>();
 
-    SingleSegmentBase segmentBase2 = new SingleSegmentBase("https://example.com/2.mp4");
-    Representation representation2 =
-        Representation.newInstance(0, 0, null, 0, WIDE_VIDEO, segmentBase2);
-    representations.add(representation2);
+    representations.add(generateVodRepresentation(0, VOD_DURATION_MS, TALL_VIDEO));
+    representations.add(generateVodRepresentation(0, VOD_DURATION_MS, WIDE_VIDEO));
 
-    return generateMpd(false, representations);
+    return generateMpd(false, representations, false);
   }
 
-  private static MediaPresentationDescription generateLiveMpdWithTimeline() {
-    List<Representation> representations = new ArrayList<Representation>();
-
-    List<SegmentTimelineElement> segmentTimeline = new ArrayList<SegmentTimelineElement>();
-    segmentTimeline.add(new SegmentTimelineElement(0L, 1000L));
-    segmentTimeline.add(new SegmentTimelineElement(1000L, 1000L));
-    segmentTimeline.add(new SegmentTimelineElement(2000L, 1000L));
-    segmentTimeline.add(new SegmentTimelineElement(3000L, 1000L));
-    segmentTimeline.add(new SegmentTimelineElement(4000L, 1000L));
-    List<RangedUri> mediaSegments = new ArrayList<RangedUri>();
-    mediaSegments.add(new RangedUri("", "", 0L, 500L));
-    mediaSegments.add(new RangedUri("", "", 500L, 500L));
-    mediaSegments.add(new RangedUri("", "", 1000L, 500L));
-    mediaSegments.add(new RangedUri("", "", 1500L, 500L));
-    mediaSegments.add(new RangedUri("", "", 2000L, 500L));
-
-    MultiSegmentBase segmentBase = new SegmentList(null, 1000, 0,
-        TrackRenderer.UNKNOWN_TIME_US, 1, TrackRenderer.UNKNOWN_TIME_US, segmentTimeline,
-        mediaSegments);
-    Representation representation = Representation.newInstance(0, TrackRenderer.UNKNOWN_TIME_US,
-        null, 0, REGULAR_VIDEO, segmentBase);
-    representations.add(representation);
-
-    return generateMpd(true, representations);
+  private static MediaPresentationDescription generateLiveMpdWithTimeline(long segmentStartMs,
+      long periodStartMs, long durationMs) {
+    return generateMpd(true, Collections.singletonList(generateSegmentTimelineRepresentation(
+        segmentStartMs, periodStartMs, durationMs)), false);
   }
 
-  private static MediaPresentationDescription generateLiveMpdWithTemplate() {
-    List<Representation> representations = new ArrayList<Representation>();
+  private static MediaPresentationDescription generateLiveMpdWithTemplate(
+      boolean limitTimeshiftBuffer) {
+    List<Representation> representations = new ArrayList<>();
 
     UrlTemplate initializationTemplate = null;
     UrlTemplate mediaTemplate = UrlTemplate.compile("$RepresentationID$/$Number$");
     MultiSegmentBase segmentBase = new SegmentTemplate(null, 1000, 0,
-        TrackRenderer.UNKNOWN_TIME_US, 1, 1000, null,
+        TrackRenderer.UNKNOWN_TIME_US, 0, LIVE_SEGMENT_DURATION_MS, null,
         initializationTemplate, mediaTemplate, "http://www.youtube.com");
     Representation representation = Representation.newInstance(0, TrackRenderer.UNKNOWN_TIME_US,
         null, 0, REGULAR_VIDEO, segmentBase);
     representations.add(representation);
 
-    return generateMpd(true, representations);
+    return generateMpd(true, representations, limitTimeshiftBuffer);
+  }
+
+  private DashChunkSource setupDashChunkSource(MediaPresentationDescription mpd, long periodStartMs,
+      long liveEdgeLatencyMs) {
+    @SuppressWarnings("unchecked")
+    ManifestFetcher<MediaPresentationDescription> manifestFetcher = mock(ManifestFetcher.class);
+    when(manifestFetcher.getManifest()).thenReturn(mpd);
+    DashChunkSource chunkSource = new DashChunkSource(manifestFetcher, mpd,
+        AdaptationSet.TYPE_VIDEO, null, mockDataSource, EVALUATOR,
+        new FakeClock(AVAILABILITY_CURRENT_TIME_MS + periodStartMs), liveEdgeLatencyMs * 1000,
+        AVAILABILITY_REALTIME_OFFSET_MS * 1000, false, null, null);
+    chunkSource.enable();
+    return chunkSource;
+  }
+
+  private void checkSeekRange(TimeRange seekRange, long startTimeUs, long endTimeUs) {
+    long[] seekRangeValuesUs = seekRange.getCurrentBoundsUs(null);
+    assertEquals(startTimeUs, seekRangeValuesUs[0]);
+    assertEquals(endTimeUs, seekRangeValuesUs[1]);
+  }
+
+  private void checkLiveEdgeLatency(DashChunkSource chunkSource, List<MediaChunk> queue,
+      ChunkOperationHolder out, long seekPositionMs, long seekRangeStartMs, long seekRangeEndMs,
+      long chunkStartTimeMs, long chunkEndTimeMs) {
+    chunkSource.getChunkOperation(queue, seekPositionMs * 1000, 0, out);
+    TimeRange seekRange = chunkSource.getSeekRange();
+
+    assertNotNull(out.chunk);
+    checkSeekRange(seekRange, seekRangeStartMs * 1000, seekRangeEndMs * 1000);
+    assertEquals(chunkStartTimeMs * 1000, ((MediaChunk) out.chunk).startTimeUs);
+    assertEquals(chunkEndTimeMs * 1000, ((MediaChunk) out.chunk).endTimeUs);
+  }
+
+  private void checkLiveEdgeLatency(MediaPresentationDescription mpd, long periodStartMs,
+      long liveEdgeLatencyMs, long seekPositionMs, long seekRangeStartMs, long seekRangeEndMs,
+      long chunkStartTimeMs, long chunkEndTimeMs) {
+    DashChunkSource chunkSource = setupDashChunkSource(mpd, periodStartMs, liveEdgeLatencyMs);
+    List<MediaChunk> queue = new ArrayList<>();
+    ChunkOperationHolder out = new ChunkOperationHolder();
+    checkLiveEdgeLatency(chunkSource, queue, out, seekPositionMs, seekRangeStartMs, seekRangeEndMs,
+        chunkStartTimeMs, chunkEndTimeMs);
+  }
+
+  private void checkLiveEdgeLatencyWithTimeline(long segmentStartMs, long periodStartMs,
+      long liveEdgeLatencyMs, long seekPositionMs, long seekRangeStartMs, long seekRangeEndMs,
+      long chunkStartTimeMs, long chunkEndTimeMs) {
+    MediaPresentationDescription mpd = generateLiveMpdWithTimeline(segmentStartMs, periodStartMs,
+        LIVE_DURATION_MS);
+    checkLiveEdgeLatency(mpd, periodStartMs, liveEdgeLatencyMs, seekPositionMs, seekRangeStartMs,
+        seekRangeEndMs, chunkStartTimeMs, chunkEndTimeMs);
+  }
+
+  private void checkLiveEdgeLatencyWithTemplateAndUnlimitedTimeshift(long startTimeMs,
+      long liveEdgeLatencyMs, long seekPositionMs, long seekRangeEndMs,
+      long chunkStartTimeMs, long chunkEndTimeMs) {
+    MediaPresentationDescription mpd = generateLiveMpdWithTemplate(false);
+    checkLiveEdgeLatency(mpd, startTimeMs, liveEdgeLatencyMs, seekPositionMs, 0, seekRangeEndMs,
+        chunkStartTimeMs, chunkEndTimeMs);
   }
 
-  private DashChunkSource setupLiveEdgeTimelineTest(long liveEdgeLatencyMs) {
-    MediaPresentationDescription manifest = generateLiveMpdWithTimeline();
-    when(mockManifestFetcher.getManifest()).thenReturn(manifest);
-    return new DashChunkSource(mockManifestFetcher, manifest, AdaptationSet.TYPE_VIDEO, null,
-        mockDataSource, EVALUATOR, AVAILABILITY_CLOCK, liveEdgeLatencyMs * 1000,
-        AVAILABILITY_REALTIME_OFFSET * 1000);
+  private void checkLiveEdgeLatencyWithTemplateAndLimitedTimeshift(long startTimeMs,
+      long liveEdgeLatencyMs, long seekPositionMs, long seekRangeStartMs, long seekRangeEndMs,
+      long chunkStartTimeMs, long chunkEndTimeMs) {
+    MediaPresentationDescription mpd = generateLiveMpdWithTemplate(true);
+    checkLiveEdgeLatency(mpd, startTimeMs, liveEdgeLatencyMs, seekPositionMs, seekRangeStartMs,
+        seekRangeEndMs, chunkStartTimeMs, chunkEndTimeMs);
   }
 
-  private DashChunkSource setupLiveEdgeTemplateTest(long liveEdgeLatencyMs) {
-    MediaPresentationDescription manifest = generateLiveMpdWithTemplate();
-    when(mockManifestFetcher.getManifest()).thenReturn(manifest);
-    return new DashChunkSource(mockManifestFetcher, manifest, AdaptationSet.TYPE_VIDEO, null,
-        mockDataSource, EVALUATOR, AVAILABILITY_CLOCK, liveEdgeLatencyMs * 1000,
-        AVAILABILITY_REALTIME_OFFSET * 1000);
+  private void checkLiveTimelineConsistency(long startTimeMs, long liveEdgeLatencyMs,
+      long seekPositionMs, long seekRangeStartMs, long seekRangeEndMs, long chunkStartTimeMs,
+      long chunkEndTimeMs) {
+    checkLiveEdgeLatencyWithTimeline(startTimeMs, 0, liveEdgeLatencyMs, seekPositionMs,
+        seekRangeStartMs, seekRangeEndMs, chunkStartTimeMs, chunkEndTimeMs);
+    checkLiveEdgeLatencyWithTemplateAndUnlimitedTimeshift(startTimeMs, liveEdgeLatencyMs,
+        seekPositionMs, seekRangeEndMs, chunkStartTimeMs, chunkEndTimeMs);
+    checkLiveEdgeLatencyWithTemplateAndLimitedTimeshift(startTimeMs, liveEdgeLatencyMs,
+        seekPositionMs, seekRangeStartMs, seekRangeEndMs, chunkStartTimeMs, chunkEndTimeMs);
   }
 
 }
diff --git a/library/src/test/java/com/google/android/exoplayer/extractor/mp3/BufferingInputTest.java b/library/src/test/java/com/google/android/exoplayer/extractor/mp3/BufferingInputTest.java
index d6668f94c6..6b140c9ab2 100644
--- a/library/src/test/java/com/google/android/exoplayer/extractor/mp3/BufferingInputTest.java
+++ b/library/src/test/java/com/google/android/exoplayer/extractor/mp3/BufferingInputTest.java
@@ -24,7 +24,7 @@
 import com.google.android.exoplayer.extractor.ExtractorInput;
 import com.google.android.exoplayer.extractor.TrackOutput;
 import com.google.android.exoplayer.testutil.FakeDataSource;
-import com.google.android.exoplayer.testutil.Util;
+import com.google.android.exoplayer.testutil.TestUtil;
 import com.google.android.exoplayer.upstream.DataSpec;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
@@ -52,7 +52,7 @@
 
   @Override
   public void setUp() throws Exception {
-    Util.setUpMockito(this);
+    TestUtil.setUpMockito(this);
 
     FakeDataSource.Builder builder = new FakeDataSource.Builder();
     builder.appendReadData(STREAM_DATA);
diff --git a/library/src/test/java/com/google/android/exoplayer/extractor/mp4/Mp4ExtractorTest.java b/library/src/test/java/com/google/android/exoplayer/extractor/mp4/Mp4ExtractorTest.java
index 9e6c290bec..d3480164e2 100644
--- a/library/src/test/java/com/google/android/exoplayer/extractor/mp4/Mp4ExtractorTest.java
+++ b/library/src/test/java/com/google/android/exoplayer/extractor/mp4/Mp4ExtractorTest.java
@@ -17,35 +17,26 @@
 
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
-import com.google.android.exoplayer.MediaFormatHolder;
-import com.google.android.exoplayer.SampleHolder;
-import com.google.android.exoplayer.SampleSource;
-import com.google.android.exoplayer.extractor.ExtractorSampleSource;
-import com.google.android.exoplayer.upstream.ByteArrayDataSource;
-import com.google.android.exoplayer.upstream.DataSource;
-import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.extractor.SeekMap;
+import com.google.android.exoplayer.testutil.FakeExtractorOutput;
+import com.google.android.exoplayer.testutil.FakeTrackOutput;
+import com.google.android.exoplayer.testutil.TestUtil;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.Util;
 
-import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
-import android.net.Uri;
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
 
 import junit.framework.TestCase;
 
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.concurrent.CountDownLatch;
 
 /**
  * Tests for {@link Mp4Extractor}.
  */
 @TargetApi(16)
-public class Mp4ExtractorTest extends TestCase {
+public final class Mp4ExtractorTest extends TestCase {
 
   /** String of hexadecimal bytes containing the video stsd payload from an AVC video. */
   private static final byte[] VIDEO_STSD_PAYLOAD = getByteArray(
@@ -94,161 +85,124 @@
   /** Video frame sizes in bytes, including a very large sample. */
   private static final int[] SAMPLE_SIZES = {100, 20, 20, 44, 100, 1 * 1024 * 1024};
   /** Indices of key-frames. */
-  private static final int[] SYNCHRONIZATION_SAMPLE_INDICES = {0, 4, 5};
+  private static final boolean[] SAMPLE_IS_SYNC = {true, false, false, false, true, true};
   /** Indices of video frame chunk offsets. */
   private static final int[] CHUNK_OFFSETS = {1080, 2000, 3000, 4000};
   /** Numbers of video frames in each chunk. */
   private static final int[] SAMPLES_IN_CHUNK = {2, 2, 1, 1};
   /** The mdat box must be large enough to avoid reading chunk sample data out of bounds. */
   private static final int MDAT_SIZE = 10 * 1024 * 1024;
-  /** Fake HTTP URI that can't be opened. */
-  private static final Uri FAKE_URI = Uri.parse("http://");
   /** Empty byte array. */
   private static final byte[] EMPTY = new byte[0];
 
-  public void testParsesValidMp4File() throws Exception {
-    // Given an extractor with an AVC/AAC file
-    Mp4ExtractorWrapper extractor =
-        prepareSampleExtractor(getFakeDataSource(true /* includeStss */, false /* mp4vFormat */));
-
-    // The MIME type and metadata are set correctly.
-    assertEquals(MimeTypes.VIDEO_H264, extractor.mediaFormats[0].mimeType);
-    assertEquals(MimeTypes.AUDIO_AAC, extractor.mediaFormats[1].mimeType);
+  private Mp4Extractor extractor;
+  private FakeExtractorOutput extractorOutput;
 
-    assertEquals(VIDEO_WIDTH, extractor.selectedTrackMediaFormat.width);
-    assertEquals(VIDEO_HEIGHT, extractor.selectedTrackMediaFormat.height);
+  @Override
+  public void setUp() {
+    extractor = new Mp4Extractor();
+    extractorOutput = new FakeExtractorOutput();
+    extractor.init(extractorOutput);
   }
 
-  public void testParsesValidMp4vFile() throws Exception {
-    // Given an extractor with an mp4v file
-    Mp4ExtractorWrapper extractor =
-        prepareSampleExtractor(getFakeDataSource(true /* includeStss */, true /* mp4vFormat */));
-
-    // The MIME type and metadata are set correctly.
-    assertEquals(MimeTypes.VIDEO_MP4V, extractor.selectedTrackMediaFormat.mimeType);
-    assertEquals(VIDEO_MP4V_WIDTH, extractor.selectedTrackMediaFormat.width);
-    assertEquals(VIDEO_MP4V_HEIGHT, extractor.selectedTrackMediaFormat.height);
+  @Override
+  public void tearDown() {
+    extractor = null;
+    extractorOutput = null;
   }
 
-  public void testSampleTimestampsMatch() throws Exception {
-    // Given an extractor
-    Mp4ExtractorWrapper extractor =
-        prepareSampleExtractor(getFakeDataSource(true /* includeStss */, false /* mp4vFormat */));
-
-    // The timestamps are set correctly.
-    SampleHolder sampleHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_NORMAL);
+  public void testParsesValidMp4File() throws Exception {
+    TestUtil.consumeTestData(extractor,
+        getTestInputData(true /* includeStss */, false /* mp4vFormat */));
+
+    // The seek map is correct.
+    assertSeekMap(extractorOutput.seekMap, true);
+
+    // The video and audio formats are set correctly.
+    assertEquals(2, extractorOutput.trackOutputs.size());
+    MediaFormat videoFormat = extractorOutput.trackOutputs.get(0).format;
+    MediaFormat audioFormat = extractorOutput.trackOutputs.get(1).format;
+    assertEquals(MimeTypes.VIDEO_H264, videoFormat.mimeType);
+    assertEquals(VIDEO_WIDTH, videoFormat.width);
+    assertEquals(VIDEO_HEIGHT, videoFormat.height);
+    assertEquals(MimeTypes.AUDIO_AAC, audioFormat.mimeType);
+
+    // The timestamps and sizes are set correctly.
+    FakeTrackOutput videoTrackOutput = extractorOutput.trackOutputs.get(0);
+    videoTrackOutput.assertSampleCount(SAMPLE_TIMESTAMPS.length);
     for (int i = 0; i < SAMPLE_TIMESTAMPS.length; i++) {
-      extractor.readSample(0, sampleHolder);
-      assertEquals(getVideoTimestampUs(SAMPLE_TIMESTAMPS[i]), sampleHolder.timeUs);
+      byte[] sampleData = getOutputSampleData(i, true);
+      int sampleFlags = SAMPLE_IS_SYNC[i] ? C.SAMPLE_FLAG_SYNC : 0;
+      long sampleTimestampUs = getVideoTimestampUs(SAMPLE_TIMESTAMPS[i]);
+      videoTrackOutput.assertSample(i, sampleData, sampleTimestampUs, sampleFlags, null);
     }
-    assertEquals(SampleSource.END_OF_STREAM, extractor.readSample(0, sampleHolder));
-  }
-
-  public void testSeekToStart() throws Exception {
-    // When seeking to the start
-    int timestampTimeUnits = SAMPLE_TIMESTAMPS[0];
-    long sampleTimestampUs =
-        getTimestampUsResultingFromSeek(getVideoTimestampUs(timestampTimeUnits));
-
-    // The timestamp is at the start.
-    assertEquals(getVideoTimestampUs(timestampTimeUnits), sampleTimestampUs);
   }
 
-  public void testSeekToEnd() throws Exception {
-    // When seeking to the end
-    int timestampTimeUnits = SAMPLE_TIMESTAMPS[SAMPLE_TIMESTAMPS.length - 1];
-    long sampleTimestampUs =
-        getTimestampUsResultingFromSeek(getVideoTimestampUs(timestampTimeUnits));
+  public void testParsesValidMp4FileWithoutStss() throws Exception {
+    TestUtil.consumeTestData(extractor,
+        getTestInputData(false /* includeStss */, false /* mp4vFormat */));
 
-    // The timestamp is at the end.
-    assertEquals(getVideoTimestampUs(timestampTimeUnits), sampleTimestampUs);
-  }
-
-  public void testSeekToNearStart() throws Exception {
-    // When seeking to just after the start
-    int timestampTimeUnits = SAMPLE_TIMESTAMPS[0];
-    long sampleTimestampUs =
-        getTimestampUsResultingFromSeek(getVideoTimestampUs(timestampTimeUnits) + 1);
-
-    // The timestamp is at the start.
-    assertEquals(getVideoTimestampUs(timestampTimeUnits), sampleTimestampUs);
-  }
+    // The seek map is correct.
+    assertSeekMap(extractorOutput.seekMap, false);
 
-  public void testSeekToBeforeLastSynchronizationSample() throws Exception {
-    // When seeking to just after the start
-    long sampleTimestampUs =
-        getTimestampUsResultingFromSeek(getVideoTimestampUs(SAMPLE_TIMESTAMPS[4]) - 1);
-
-    // The timestamp is at the start.
-    assertEquals(getVideoTimestampUs(SAMPLE_TIMESTAMPS[0]), sampleTimestampUs);
-  }
-
-  public void testAllSamplesAreSynchronizationSamplesWhenStssIsMissing() throws Exception {
-    // Given an extractor without an stss box
-    Mp4ExtractorWrapper extractor =
-        prepareSampleExtractor(getFakeDataSource(false /* includeStss */, false /* mp4vFormat */));
-    // All samples are synchronization samples.
-    SampleHolder sampleHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_NORMAL);
-    int sampleIndex = 0;
-    while (true) {
-      int result = extractor.readSample(0, sampleHolder);
-      if (result == SampleSource.SAMPLE_READ) {
-        assertTrue(sampleHolder.isSyncFrame());
-        sampleHolder.clearData();
-        sampleIndex++;
-      } else if (result == SampleSource.END_OF_STREAM) {
-        break;
-      }
+    // The timestamps and sizes are set correctly, and all samples are synchronization samples.
+    FakeTrackOutput videoTrackOutput = extractorOutput.trackOutputs.get(0);
+    videoTrackOutput.assertSampleCount(SAMPLE_TIMESTAMPS.length);
+    for (int i = 0; i < SAMPLE_TIMESTAMPS.length; i++) {
+      byte[] sampleData = getOutputSampleData(i, true);
+      int sampleFlags = C.SAMPLE_FLAG_SYNC;
+      long sampleTimestampUs = getVideoTimestampUs(SAMPLE_TIMESTAMPS[i]);
+      videoTrackOutput.assertSample(i, sampleData, sampleTimestampUs, sampleFlags, null);
     }
-    assertTrue(sampleIndex == SAMPLE_SIZES.length);
   }
 
-  public void testReadAllSamplesSucceeds() throws Exception {
-    // Given an extractor
-    Mp4ExtractorWrapper extractor =
-        prepareSampleExtractor(getFakeDataSource(true /* includeStss */, false /* mp4vFormat */));
-
-    // The sample sizes are set correctly.
-    SampleHolder sampleHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_NORMAL);
-    int sampleIndex = 0;
-    while (true) {
-      int result = extractor.readSample(0, sampleHolder);
-      if (result == SampleSource.SAMPLE_READ) {
-        assertEquals(SAMPLE_SIZES[sampleIndex], sampleHolder.size);
-        sampleHolder.clearData();
-        sampleIndex++;
-      } else if (result == SampleSource.END_OF_STREAM) {
-        break;
-      }
+  public void testParsesValidMp4vFile() throws Exception {
+    TestUtil.consumeTestData(extractor,
+        getTestInputData(true /* includeStss */, true /* mp4vFormat */));
+
+    // The seek map is correct.
+    assertSeekMap(extractorOutput.seekMap, true);
+
+    // The video and audio formats are set correctly.
+    assertEquals(2, extractorOutput.trackOutputs.size());
+    MediaFormat videoFormat = extractorOutput.trackOutputs.get(0).format;
+    MediaFormat audioFormat = extractorOutput.trackOutputs.get(1).format;
+    assertEquals(MimeTypes.VIDEO_MP4V, videoFormat.mimeType);
+    assertEquals(VIDEO_MP4V_WIDTH, videoFormat.width);
+    assertEquals(VIDEO_MP4V_HEIGHT, videoFormat.height);
+    assertEquals(MimeTypes.AUDIO_AAC, audioFormat.mimeType);
+
+    // The timestamps and sizes are set correctly.
+    FakeTrackOutput videoTrackOutput = extractorOutput.trackOutputs.get(0);
+    videoTrackOutput.assertSampleCount(SAMPLE_TIMESTAMPS.length);
+    for (int i = 0; i < SAMPLE_TIMESTAMPS.length; i++) {
+      byte[] sampleData = getOutputSampleData(i, false);
+      int sampleFlags = SAMPLE_IS_SYNC[i] ? C.SAMPLE_FLAG_SYNC : 0;
+      long sampleTimestampUs = getVideoTimestampUs(SAMPLE_TIMESTAMPS[i]);
+      videoTrackOutput.assertSample(i, sampleData, sampleTimestampUs, sampleFlags, null);
     }
-    assertEquals(SAMPLE_SIZES.length, sampleIndex);
   }
 
-  /** Returns the sample time read after seeking to {@code timestampTimeUnits}. */
-  private static long getTimestampUsResultingFromSeek(long timestampTimeUnits) throws Exception {
-    Mp4ExtractorWrapper extractor =
-        prepareSampleExtractor(getFakeDataSource(true /* includeStss */, false /* mp4vFormat */));
-
-    extractor.seekTo(timestampTimeUnits);
-
-    SampleHolder sampleHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_NORMAL);
-    while (true) {
-      int result = extractor.readSample(0, sampleHolder);
-      if (result == SampleSource.SAMPLE_READ) {
-        return sampleHolder.timeUs;
-      } else if (result == SampleSource.END_OF_STREAM) {
-        return -1;
+  private static void assertSeekMap(SeekMap seekMap, boolean haveStss) {
+    assertNotNull(seekMap);
+    int expectedSeekPosition = getSampleOffset(0);
+    for (int i = 0; i < SAMPLE_TIMESTAMPS.length; i++) {
+      // Seek to just before the current sample.
+      long seekPositionUs = getVideoTimestampUs(SAMPLE_TIMESTAMPS[i]) - 1;
+      assertEquals(expectedSeekPosition, seekMap.getPosition(seekPositionUs));
+      // If the current sample is a sync sample, the expected seek position will change.
+      if (SAMPLE_IS_SYNC[i] || !haveStss) {
+        expectedSeekPosition = getSampleOffset(i);
       }
+      // Seek to the current sample.
+      seekPositionUs = getVideoTimestampUs(SAMPLE_TIMESTAMPS[i]);
+      assertEquals(expectedSeekPosition, seekMap.getPosition(seekPositionUs));
+      // Seek to just after the current sample.
+      seekPositionUs = getVideoTimestampUs(SAMPLE_TIMESTAMPS[i]) + 1;
+      assertEquals(expectedSeekPosition, seekMap.getPosition(seekPositionUs));
     }
   }
 
-  private static Mp4ExtractorWrapper prepareSampleExtractor(DataSource dataSource)
-      throws Exception {
-    Mp4ExtractorWrapper extractor = new Mp4ExtractorWrapper(dataSource);
-    extractor.prepare();
-    return extractor;
-  }
-
   /** Returns a video timestamp in microseconds corresponding to {@code timeUnits}. */
   private static long getVideoTimestampUs(int timeUnits) {
     return Util.scaleLargeTimestamp(timeUnits, C.MICROS_PER_SECOND, TIMESCALE);
@@ -267,7 +221,7 @@ private static long getVideoTimestampUs(int timeUnits) {
 
   private static byte[] getStsc() {
     int samplesPerChunk = -1;
-    List<Integer> samplesInChunkChangeIndices = new ArrayList<Integer>();
+    List<Integer> samplesInChunkChangeIndices = new ArrayList<>();
     for (int i = 0; i < SAMPLES_IN_CHUNK.length; i++) {
       if (SAMPLES_IN_CHUNK[i] != samplesPerChunk) {
         samplesInChunkChangeIndices.add(i);
@@ -300,12 +254,20 @@ private static long getVideoTimestampUs(int timeUnits) {
   }
 
   private static byte[] getStss() {
-    byte[] result = new byte[4 + 4 + 4 * SYNCHRONIZATION_SAMPLE_INDICES.length];
+    int synchronizationSampleCount = 0;
+    for (int i = 0; i < SAMPLE_IS_SYNC.length; i++) {
+      if (SAMPLE_IS_SYNC[i]) {
+        synchronizationSampleCount++;
+      }
+    }
+    byte[] result = new byte[4 + 4 + 4 * synchronizationSampleCount];
     ByteBuffer buffer = ByteBuffer.wrap(result);
     buffer.putInt(0); // Version (skipped)
-    buffer.putInt(SYNCHRONIZATION_SAMPLE_INDICES.length);
-    for (int synchronizationSampleIndex : SYNCHRONIZATION_SAMPLE_INDICES) {
-      buffer.putInt(synchronizationSampleIndex + 1);
+    buffer.putInt(synchronizationSampleCount);
+    for (int i = 0; i < SAMPLE_IS_SYNC.length; i++) {
+      if (SAMPLE_IS_SYNC[i]) {
+        buffer.putInt(i + 1);
+      }
     }
     return result;
   }
@@ -342,23 +304,64 @@ private static long getVideoTimestampUs(int timeUnits) {
     return result;
   }
 
-  private static byte[] getMdat(int mdatOffset) {
+  private static byte[] getMdat(int mdatOffset, boolean isH264) {
     ByteBuffer mdat = ByteBuffer.allocate(MDAT_SIZE);
     int sampleIndex = 0;
     for (int chunk = 0; chunk < CHUNK_OFFSETS.length; chunk++) {
-      int sampleOffset = CHUNK_OFFSETS[chunk];
+      mdat.position(CHUNK_OFFSETS[chunk] - mdatOffset);
       for (int sample = 0; sample < SAMPLES_IN_CHUNK[chunk]; sample++) {
-        int sampleSize = SAMPLE_SIZES[sampleIndex++];
-        mdat.putInt(sampleOffset - mdatOffset, sampleSize);
-        sampleOffset += sampleSize;
+        mdat.put(getInputSampleData(sampleIndex++, isH264));
       }
     }
     return mdat.array();
   }
 
-  private static final DataSource getFakeDataSource(boolean includeStss, boolean mp4vFormat) {
-    return new ByteArrayDataSource(includeStss
-        ? getTestMp4File(mp4vFormat) : getTestMp4FileWithoutSynchronizationData(mp4vFormat));
+  private static byte[] getInputSampleData(int index, boolean isH264) {
+    ByteBuffer sample = ByteBuffer.allocate(SAMPLE_SIZES[index]);
+    for (int i = 0; i < SAMPLE_SIZES[index]; i++) {
+      sample.put((byte) i);
+    }
+    if (isH264) {
+      // First four bytes should specify the remaining length of the sample. This assumes that the
+      // sample consists of a single length delimited NAL unit.
+      sample.position(0);
+      sample.putInt(SAMPLE_SIZES[index] - 4);
+    }
+    return sample.array();
+  }
+
+  private static byte[] getOutputSampleData(int index, boolean isH264) {
+    byte[] sampleData = getInputSampleData(index, isH264);
+    if (isH264) {
+      // The output sample should begin with a NAL start code.
+      sampleData[0] = 0;
+      sampleData[1] = 0;
+      sampleData[2] = 0;
+      sampleData[3] = 1;
+    }
+    return sampleData;
+  }
+
+  private static int getSampleOffset(int index) {
+    int sampleCount = 0;
+    int chunkIndex = 0;
+    int samplesLeftInChunk = SAMPLES_IN_CHUNK[chunkIndex];
+    int offsetInChunk = 0;
+    while (sampleCount < index) {
+      offsetInChunk += SAMPLE_SIZES[sampleCount++];
+      samplesLeftInChunk--;
+      if (samplesLeftInChunk == 0) {
+        chunkIndex++;
+        samplesLeftInChunk = SAMPLES_IN_CHUNK[chunkIndex];
+        offsetInChunk = 0;
+      }
+    }
+    return CHUNK_OFFSETS[chunkIndex] + offsetInChunk;
+  }
+
+  private static final byte[] getTestInputData(boolean includeStss, boolean mp4vFormat) {
+    return includeStss ? getTestMp4File(mp4vFormat)
+        : getTestMp4FileWithoutSynchronizationData(mp4vFormat);
   }
 
   /** Gets a valid MP4 file with audio/video tracks and synchronization data. */
@@ -396,7 +399,7 @@ private static final DataSource getFakeDataSource(boolean includeStss, boolean m
                             atom(Atom.TYPE_stsc, getStsc()),
                             atom(Atom.TYPE_stsz, getStsz()),
                             atom(Atom.TYPE_stco, getStco())))))),
-        atom(Atom.TYPE_mdat, getMdat(mp4vFormat ? 1048 : 1038)));
+        atom(Atom.TYPE_mdat, getMdat(mp4vFormat ? 1048 : 1038, !mp4vFormat)));
   }
 
   /** Gets a valid MP4 file with audio/video tracks and without a synchronization table. */
@@ -432,7 +435,7 @@ private static final DataSource getFakeDataSource(boolean includeStss, boolean m
                             atom(Atom.TYPE_stsc, getStsc()),
                             atom(Atom.TYPE_stsz, getStsz()),
                             atom(Atom.TYPE_stco, getStco())))))),
-        atom(Atom.TYPE_mdat, getMdat(mp4vFormat ? 992 : 982)));
+        atom(Atom.TYPE_mdat, getMdat(mp4vFormat ? 992 : 982, !mp4vFormat)));
   }
 
   private static Mp4Atom atom(int type, Mp4Atom... containedMp4Atoms) {
@@ -452,7 +455,9 @@ private static Mp4Atom atom(int type, byte[] payload) {
     return result;
   }
 
-  /** MP4 atom that can be serialized as a byte array. */
+  /**
+   * MP4 atom that can be serialized as a byte array.
+   */
   private static final class Mp4Atom {
 
     public static byte[] serialize(Mp4Atom... atoms) {
@@ -512,122 +517,4 @@ private void getData(ByteBuffer byteBuffer) {
 
   }
 
-  /**
-   * Creates a {@link Mp4Extractor} on a separate thread with a looper, so that it can use a handler
-   * for loading, and provides blocking operations like {@link #seekTo} and {@link #readSample}.
-   */
-  private static final class Mp4ExtractorWrapper extends Thread {
-
-    private static final int MSG_PREPARE = 0;
-    private static final int MSG_SEEK_TO = 1;
-    private static final int MSG_READ_SAMPLE = 2;
-    private final DataSource dataSource;
-
-    // Written by the handler's thread and read by the main thread.
-    public volatile MediaFormat[] mediaFormats;
-    public volatile MediaFormat selectedTrackMediaFormat;
-    private volatile Handler handler;
-    private volatile int readSampleResult;
-    private volatile Exception exception;
-    private volatile CountDownLatch pendingOperationLatch;
-
-    public Mp4ExtractorWrapper(DataSource dataSource) {
-      super("Mp4ExtractorTest");
-      this.dataSource = Assertions.checkNotNull(dataSource);
-      pendingOperationLatch = new CountDownLatch(1);
-      start();
-    }
-
-    public void prepare() throws Exception {
-      // Block until the handler has been created.
-      pendingOperationLatch.await();
-
-      // Block until the extractor has been prepared.
-      pendingOperationLatch = new CountDownLatch(1);
-      handler.sendEmptyMessage(MSG_PREPARE);
-      pendingOperationLatch.await();
-      if (exception != null) {
-        throw exception;
-      }
-    }
-
-    public void seekTo(long timestampUs) {
-      handler.obtainMessage(MSG_SEEK_TO, timestampUs).sendToTarget();
-    }
-
-    public int readSample(int trackIndex, SampleHolder sampleHolder) throws Exception {
-      // Block until the extractor has completed readSample.
-      pendingOperationLatch = new CountDownLatch(1);
-      handler.obtainMessage(MSG_READ_SAMPLE, trackIndex, 0, sampleHolder).sendToTarget();
-      pendingOperationLatch.await();
-      if (exception != null) {
-        throw exception;
-      }
-      return readSampleResult;
-    }
-
-    @SuppressLint("HandlerLeak")
-    @Override
-    public void run() {
-      final ExtractorSampleSource source = new ExtractorSampleSource(FAKE_URI, dataSource,
-          new Mp4Extractor(), 1, 2 * 1024 * 1024);
-      Looper.prepare();
-      handler = new Handler() {
-
-        @Override
-        public void handleMessage(Message message) {
-          try {
-            switch (message.what) {
-              case MSG_PREPARE:
-                if (!source.prepare(0)) {
-                  sendEmptyMessage(MSG_PREPARE);
-                } else {
-                  // Select the video track and get its metadata.
-                  mediaFormats = new MediaFormat[source.getTrackCount()];
-                  MediaFormatHolder mediaFormatHolder = new MediaFormatHolder();
-                  for (int track = 0; track < source.getTrackCount(); track++) {
-                    source.enable(track, 0);
-                    source.readData(track, 0, mediaFormatHolder, null, false);
-                    MediaFormat mediaFormat = mediaFormatHolder.format;
-                    mediaFormats[track] = mediaFormat;
-                    if (MimeTypes.isVideo(mediaFormat.mimeType)) {
-                      selectedTrackMediaFormat = mediaFormat;
-                    } else {
-                      source.disable(track);
-                    }
-                  }
-                  pendingOperationLatch.countDown();
-                }
-                break;
-              case MSG_SEEK_TO:
-                long timestampUs = (Long) message.obj;
-                source.seekToUs(timestampUs);
-                break;
-              case MSG_READ_SAMPLE:
-                int trackIndex = message.arg1;
-                SampleHolder sampleHolder = (SampleHolder) message.obj;
-                sampleHolder.clearData();
-                readSampleResult = source.readData(trackIndex, 0, null, sampleHolder, false);
-                if (readSampleResult == SampleSource.NOTHING_READ) {
-                  Message.obtain(message).sendToTarget();
-                  return;
-                }
-                pendingOperationLatch.countDown();
-                break;
-            }
-          } catch (Exception e) {
-            exception = e;
-            pendingOperationLatch.countDown();
-          }
-        }
-      };
-
-      // Unblock waiting for the handler.
-      pendingOperationLatch.countDown();
-
-      Looper.loop();
-    }
-
-  }
-
 }
diff --git a/library/src/test/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReaderTest.java b/library/src/test/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReaderTest.java
index 2642c71360..7225247290 100644
--- a/library/src/test/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReaderTest.java
+++ b/library/src/test/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReaderTest.java
@@ -173,7 +173,7 @@ private static ExtractorInput createTestInput(int... data) throws IOException {
     private static final int ID_DURATION = 0x4489;
     private static final int ID_SIMPLE_BLOCK = 0xA3;
 
-    private final List<String> events = new ArrayList<String>();
+    private final List<String> events = new ArrayList<>();
 
     @Override
     public int getElementType(int id) {
diff --git a/library/src/test/java/com/google/android/exoplayer/extractor/webm/StreamBuilder.java b/library/src/test/java/com/google/android/exoplayer/extractor/webm/StreamBuilder.java
new file mode 100644
index 0000000000..100904ed35
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/extractor/webm/StreamBuilder.java
@@ -0,0 +1,534 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.webm;
+
+import com.google.android.exoplayer.testutil.TestUtil;
+import com.google.android.exoplayer.util.Assertions;
+
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * Provides byte arrays containing WebM data for {@link WebmExtractorTest}.
+ */
+/* package */ final class StreamBuilder {
+
+  /** Used by {@link #addVp9Track} to create a track header with encryption/compression. */
+  public static final class ContentEncodingSettings {
+
+    private final int order;
+    private final int scope;
+    private final int type;
+    private final int algorithm;
+    private final int aesCipherMode;
+    private final byte[] strippedBytes;
+
+    public ContentEncodingSettings(int order, int scope, int algorithm, int aesCipherMode) {
+      this.order = order;
+      this.scope = scope;
+      this.type = 1; // Encryption
+      this.algorithm = algorithm;
+      this.aesCipherMode = aesCipherMode;
+      this.strippedBytes = null;
+    }
+
+    public ContentEncodingSettings(int order, int scope, int algorithm, byte[] strippedBytes) {
+      this.order = order;
+      this.scope = scope;
+      this.type = 0; // Compression
+      this.algorithm = algorithm;
+      this.aesCipherMode = 0;
+      this.strippedBytes = strippedBytes;
+    }
+
+  }
+
+  public static final byte[] TEST_ENCRYPTION_KEY_ID = { 0x00, 0x01, 0x02, 0x03 };
+  public static final byte[] TEST_INITIALIZATION_VECTOR = {
+      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
+  };
+
+  private static final int NO_VALUE = -1;
+
+  private EbmlElement header;
+  private EbmlElement info;
+  private List<EbmlElement> trackEntries;
+  private List<EbmlElement> mediaSegments;
+
+  public StreamBuilder() {
+    trackEntries = new LinkedList<>();
+    mediaSegments = new LinkedList<>();
+  }
+
+  public StreamBuilder setHeader(String docType) {
+    header = createEbmlElement(1, docType, 2);
+    return this;
+  }
+
+  public StreamBuilder setInfo(int timecodeScale, long durationUs) {
+    info = createInfoElement(timecodeScale, durationUs);
+    return this;
+  }
+
+  public StreamBuilder addVp9Track(int width, int height,
+      ContentEncodingSettings contentEncodingSettings) {
+    trackEntries.add(createVideoTrackEntry("V_VP9", width, height, contentEncodingSettings, null));
+    return this;
+  }
+
+  public StreamBuilder addH264Track(int width, int height, byte[] codecPrivate) {
+    trackEntries.add(createVideoTrackEntry("V_MPEG4/ISO/AVC", width, height, null, codecPrivate));
+    return this;
+  }
+
+  public StreamBuilder addOpusTrack(int channelCount, int sampleRate, int codecDelay,
+      int seekPreRoll, byte[] codecPrivate) {
+    trackEntries.add(createAudioTrackEntry("A_OPUS", channelCount, sampleRate, codecPrivate,
+        codecDelay, seekPreRoll, NO_VALUE));
+    return this;
+  }
+
+  public StreamBuilder addOpusTrack(int channelCount, int sampleRate, int codecDelay,
+      int seekPreRoll, byte[] codecPrivate, int defaultDurationNs) {
+    trackEntries.add(createAudioTrackEntry("A_OPUS", channelCount, sampleRate, codecPrivate,
+        codecDelay, seekPreRoll, defaultDurationNs));
+    return this;
+  }
+
+  public StreamBuilder addVorbisTrack(int channelCount, int sampleRate, byte[] codecPrivate) {
+    trackEntries.add(createAudioTrackEntry("A_VORBIS", channelCount, sampleRate, codecPrivate,
+        NO_VALUE, NO_VALUE, NO_VALUE));
+    return this;
+  }
+
+  public StreamBuilder addUnsupportedTrack() {
+    trackEntries.add(element(0xAE, // TrackEntry
+        element(0x86, "D_WEBVTT/metadata".getBytes()), // CodecID
+        element(0xD7, (byte) 0x03), // TrackNumber
+        element(0x83, (byte) 0x11))); // TrackType
+    return this;
+  }
+
+  public StreamBuilder addSimpleBlockEncryptedMedia(int trackNumber, int clusterTimecode,
+      int blockTimecode, boolean keyframe, boolean invisible, boolean validSignalByte,
+      byte[] data) {
+    byte flags = (byte) ((keyframe ? 0x80 : 0x00) | (invisible ? 0x08 : 0x00));
+    EbmlElement simpleBlockElement = createSimpleBlock(trackNumber, blockTimecode, flags,
+        true, validSignalByte, 1, data);
+    mediaSegments.add(createCluster(clusterTimecode, simpleBlockElement));
+    return this;
+  }
+
+
+  public StreamBuilder addSimpleBlockMedia(int trackNumber, int clusterTimecode,
+      int blockTimecode, boolean keyframe, boolean invisible, byte[] data) {
+    byte flags = (byte) ((keyframe ? 0x80 : 0x00) | (invisible ? 0x08 : 0x00));
+    EbmlElement simpleBlockElement = createSimpleBlock(trackNumber, blockTimecode, flags,
+        false, true, 1, data);
+    mediaSegments.add(createCluster(clusterTimecode, simpleBlockElement));
+    return this;
+  }
+
+  public StreamBuilder addSimpleBlockMediaWithFixedSizeLacing(int trackNumber, int clusterTimecode,
+      int blockTimecode, int lacingFrameCount, byte[] data) {
+    EbmlElement simpleBlockElement = createSimpleBlock(trackNumber, blockTimecode,
+        0x80 /* flags = keyframe */, false, true, lacingFrameCount, data);
+    mediaSegments.add(createCluster(clusterTimecode, simpleBlockElement));
+    return this;
+  }
+
+  public StreamBuilder addSimpleBlockMediaWithXiphLacing(int trackNumber, int clusterTimecode,
+      int blockTimecode, byte[] data, int... lacingFrameSizes) {
+    EbmlElement simpleBlockElement = createSimpleBlock(trackNumber, blockTimecode,
+        0x80 /* flags = keyframe */, false, true, data, lacingFrameSizes);
+    mediaSegments.add(createCluster(clusterTimecode, simpleBlockElement));
+    return this;
+  }
+
+  public StreamBuilder addBlockMedia(int trackNumber, int clusterTimecode, int blockTimecode,
+      boolean keyframe, boolean invisible, byte[] data) {
+    byte flags = (byte) (invisible ? 0x08 : 0x00);
+    EbmlElement blockElement =
+        createBlock(trackNumber, blockTimecode, keyframe, flags, data);
+    mediaSegments.add(createCluster(clusterTimecode, blockElement));
+    return this;
+  }
+
+  /**
+   * Serializes the constructed stream to a {@code byte[]} using the specified number of cue points.
+   */
+  public byte[] build(int cuePointCount) {
+    Assertions.checkNotNull(header);
+    Assertions.checkNotNull(info);
+
+    EbmlElement tracks = element(0x1654AE6B, trackEntries.toArray(new EbmlElement[0]));
+
+    // Get the size of the initialization segment.
+    EbmlElement[] cuePointElements = new EbmlElement[cuePointCount];
+    for (int i = 0; i < cuePointCount; i++) {
+      cuePointElements[i] = createCuePointElement(10 * i, 0);
+    }
+    EbmlElement cues = element(0x1C53BB6B, cuePointElements); // Cues
+    long initializationSegmentSize = info.getSize() + tracks.getSize() + cues.getSize();
+
+    // Recreate the initialization segment using its size as an offset.
+    for (int i = 0; i < cuePointCount; i++) {
+      cuePointElements[i] = createCuePointElement(10 * i, (int) initializationSegmentSize);
+    }
+    cues = element(0x1C53BB6B, cuePointElements); // Cues
+
+    // Build the top-level segment element.
+    EbmlElement[] children = new EbmlElement[3 + mediaSegments.size()];
+    System.arraycopy(mediaSegments.toArray(new EbmlElement[0]), 0, children, 3,
+        mediaSegments.size());
+    children[0] = info;
+    children[1] = tracks;
+    children[2] = cues;
+    EbmlElement segmentElement = element(0x18538067, children); // Segment
+
+    // Serialize the EBML header and the top-level segment element.
+    return EbmlElement.serialize(header, segmentElement);
+  }
+
+  private static EbmlElement createCuePointElement(int cueTime, int cueClusterPosition) {
+    byte[] positionBytes = getLongBytes(cueClusterPosition);
+    return element(0xBB, // CuePoint
+        element(0xB3, (byte) (cueTime & 0xFF)), // CueTime
+        element(0xB7, // CueTrackPositions
+            element(0xF1, positionBytes))); // CueClusterPosition
+  }
+
+  private static EbmlElement createEbmlElement(int ebmlReadVersion, String docType,
+      int docTypeReadVersion) {
+    return element(0x1A45DFA3, // EBML
+        element(0x42F7, (byte) (ebmlReadVersion & 0xFF)), // EBMLReadVersion
+        element(0x4282, docType.getBytes()), // DocType
+        element(0x4285, (byte) (docTypeReadVersion & 0xFF))); // DocTypeReadVersion
+  }
+
+  private EbmlElement createInfoElement(int timecodeScale, long durationUs) {
+    byte[] timecodeScaleBytes = getIntegerBytes(timecodeScale);
+    byte[] durationBytes = getLongBytes(Double.doubleToLongBits(durationUs / 1000.0));
+    return element(0x1549A966, // Info
+        element(0x2AD7B1, timecodeScaleBytes), // TimecodeScale
+        element(0x4489, durationBytes)); // Duration
+  }
+
+  private static EbmlElement createVideoTrackEntry(String codecId, int pixelWidth, int pixelHeight,
+      ContentEncodingSettings contentEncodingSettings, byte[] codecPrivate) {
+    byte[] widthBytes = getIntegerBytes(pixelWidth);
+    byte[] heightBytes = getIntegerBytes(pixelHeight);
+    EbmlElement contentEncodingSettingsElement;
+    if (contentEncodingSettings != null) {
+      EbmlElement encryptionOrCompressionElement;
+      if (contentEncodingSettings.type == 0) {
+        encryptionOrCompressionElement = element(0x5034, // ContentCompression
+            element(0x4254, (byte) (contentEncodingSettings.algorithm & 0xFF)), // ContentCompAlgo
+            element(0x4255, contentEncodingSettings.strippedBytes)); // ContentCompSettings
+      } else if (contentEncodingSettings.type == 1) {
+        encryptionOrCompressionElement = element(0x5035, // ContentEncryption
+            // ContentEncAlgo
+            element(0x47E1, (byte) (contentEncodingSettings.algorithm & 0xFF)),
+            element(0x47E2, TEST_ENCRYPTION_KEY_ID), // ContentEncKeyID
+            element(0x47E7, // ContentEncAESSettings
+                // AESSettingsCipherMode
+                element(0x47E8, (byte) (contentEncodingSettings.aesCipherMode & 0xFF))));
+      } else {
+        throw new IllegalArgumentException("Unexpected encoding type.");
+      }
+
+      contentEncodingSettingsElement =
+          element(0x6D80, // ContentEncodings
+            element(0x6240, // ContentEncoding
+                // ContentEncodingOrder
+                element(0x5031, (byte) (contentEncodingSettings.order & 0xFF)),
+                // ContentEncodingScope
+                element(0x5032, (byte) (contentEncodingSettings.scope & 0xFF)),
+                // ContentEncodingType
+                element(0x5033, (byte) (contentEncodingSettings.type & 0xFF)),
+                encryptionOrCompressionElement));
+    } else {
+      contentEncodingSettingsElement = empty();
+    }
+    EbmlElement codecPrivateElement;
+    if (codecPrivate != null) {
+      codecPrivateElement = element(0x63A2, codecPrivate); // CodecPrivate
+    } else {
+      codecPrivateElement = empty();
+    }
+
+    return element(0xAE, // TrackEntry
+        element(0x86, codecId.getBytes()), // CodecID
+        element(0xD7, (byte) 0x01), // TrackNumber
+        element(0x83, (byte) 0x01), // TrackType
+        contentEncodingSettingsElement,
+        element(0xE0, // Video
+            element(0xB0, widthBytes[2], widthBytes[3]),
+            element(0xBA, heightBytes[2], heightBytes[3])),
+        codecPrivateElement);
+  }
+
+  private static EbmlElement createAudioTrackEntry(String codecId, int channelCount, int sampleRate,
+      byte[] codecPrivate, int codecDelay, int seekPreRoll, int defaultDurationNs) {
+    byte channelCountByte = (byte) (channelCount & 0xFF);
+    byte[] sampleRateDoubleBytes = getLongBytes(Double.doubleToLongBits(sampleRate));
+    return element(0xAE, // TrackEntry
+        element(0x86, codecId.getBytes()), // CodecID
+        element(0xD7, (byte) 0x02), // TrackNumber
+        element(0x83, (byte) 0x02), // TrackType
+        // CodecDelay
+        codecDelay != NO_VALUE ? element(0x56AA, getIntegerBytes(codecDelay)) : empty(),
+        // SeekPreRoll
+        seekPreRoll != NO_VALUE ? element(0x56BB, getIntegerBytes(seekPreRoll)) : empty(),
+        element(0xE1, // Audio
+            element(0x9F, channelCountByte), // Channels
+            element(0xB5, sampleRateDoubleBytes)), // SamplingFrequency
+        // DefaultDuration
+        defaultDurationNs != NO_VALUE ? element(0x23E383, getIntegerBytes(defaultDurationNs))
+            : empty(),
+        element(0x63A2, codecPrivate)); // CodecPrivate
+  }
+
+  private static EbmlElement createCluster(int timecode, EbmlElement blockGroupOrSimpleBlock) {
+    return element(0x1F43B675, // Cluster
+        element(0xE7, getIntegerBytes(timecode)), // Timecode
+        blockGroupOrSimpleBlock);
+  }
+
+  private static EbmlElement createSimpleBlock(int trackNumber, int timecode, int flags,
+      boolean encrypted, boolean validSignalByte, int lacingFrameCount, byte[] data) {
+    byte[] trackNumberBytes = getIntegerBytes(trackNumber);
+    byte[] timeBytes = getIntegerBytes(timecode);
+    byte[] simpleBlockBytes;
+    if (lacingFrameCount > 1) {
+      flags |= 0x04; // Fixed-size lacing
+      simpleBlockBytes = TestUtil.createByteArray(
+          0x40, trackNumberBytes[3], // Track number size=2
+          timeBytes[2], timeBytes[3], flags, lacingFrameCount - 1); // Timecode, flags and lacing.
+    } else {
+      simpleBlockBytes = TestUtil.createByteArray(
+          0x40, trackNumberBytes[3], // Track number size=2
+          timeBytes[2], timeBytes[3], flags); // Timecode and flags
+    }
+    if (encrypted) {
+      simpleBlockBytes = TestUtil.joinByteArrays(
+          simpleBlockBytes, TestUtil.createByteArray(validSignalByte ? 0x01 : 0x80),
+          Arrays.copyOfRange(TEST_INITIALIZATION_VECTOR, 0, 8));
+    }
+    return element(0xA3, // SimpleBlock
+        TestUtil.joinByteArrays(simpleBlockBytes, data));
+  }
+
+  private static EbmlElement createSimpleBlock(int trackNumber, int timecode, int flags,
+      boolean encrypted, boolean validSignalByte, byte[] data, int... xiphLacingSampleSizes) {
+    byte[] trackNumberBytes = getIntegerBytes(trackNumber);
+    byte[] timeBytes = getIntegerBytes(timecode);
+    byte[] simpleBlockBytes;
+    flags |= 0x02; // Xiph lacing
+    simpleBlockBytes = TestUtil.createByteArray(
+        0x40, trackNumberBytes[3], // Track number size=2
+        timeBytes[2], timeBytes[3], // Timecode
+        flags, xiphLacingSampleSizes.length - 1); // Flags and lacing.
+    int lacingBufferSize = 0;
+    for (int sampleIndex = 0; sampleIndex < xiphLacingSampleSizes.length - 1; sampleIndex++) {
+      lacingBufferSize += (xiphLacingSampleSizes[sampleIndex] + 254) / 255;
+    }
+    ByteBuffer lacingBytes = ByteBuffer.allocate(lacingBufferSize);
+    for (int sampleIndex = 0; sampleIndex < xiphLacingSampleSizes.length - 1; sampleIndex++) {
+      int sampleSize = xiphLacingSampleSizes[sampleIndex];
+      while (sampleSize > 255) {
+        sampleSize -= 255;
+        lacingBytes.put((byte) 0xFF);
+      }
+      lacingBytes.put((byte) sampleSize);
+    }
+    simpleBlockBytes = TestUtil.joinByteArrays(simpleBlockBytes, lacingBytes.array());
+
+    if (encrypted) {
+      simpleBlockBytes = TestUtil.joinByteArrays(
+          simpleBlockBytes, TestUtil.createByteArray(validSignalByte ? 0x01 : 0x80),
+          Arrays.copyOfRange(TEST_INITIALIZATION_VECTOR, 0, 8));
+    }
+    return element(0xA3, // SimpleBlock
+        TestUtil.joinByteArrays(simpleBlockBytes, data));
+  }
+
+  private static EbmlElement createBlock(int trackNumber, int timecode, boolean keyframe, int flags,
+      byte[] data) {
+    byte[] trackNumberBytes = getIntegerBytes(trackNumber);
+    byte[] timeBytes = getIntegerBytes(timecode);
+    byte[] blockBytes = TestUtil.createByteArray(
+        0x40, trackNumberBytes[3], // Track number size=2
+        timeBytes[2], timeBytes[3], flags); // Timecode and flags
+    EbmlElement block = element(0xA1, // Block
+        TestUtil.joinByteArrays(blockBytes, data));
+    EbmlElement referenceBlock = keyframe ? empty() : element(0xFB, (byte) 0x00); // ReferenceBlock
+    return element(0xA0, // BlockGroup
+        referenceBlock,
+        block);
+  }
+
+  private static byte[] getIntegerBytes(int value) {
+    return TestUtil.createByteArray(
+        (value & 0xFF000000) >> 24,
+        (value & 0x00FF0000) >> 16,
+        (value & 0x0000FF00) >> 8,
+        (value & 0x000000FF));
+  }
+
+  private static byte[] getLongBytes(long value) {
+    byte[] result = new byte[8];
+    for (int i = 0; i < 8; i++) {
+      result[7 - i] = (byte) ((value >> (8 * i)) & 0xFF);
+    }
+    return result;
+  }
+
+  /** @see EbmlElement#EbmlElement(int, EbmlElement...) */
+  private static EbmlElement element(int type, EbmlElement... childElements) {
+    return new EbmlElement(type, childElements);
+  }
+
+  /** @see EbmlElement#EbmlElement(int, byte...) */
+  private static EbmlElement element(int type, byte... payload) {
+    return new EbmlElement(type, payload);
+  }
+
+  /** @see EbmlElement#EbmlElement() */
+  private static EbmlElement empty() {
+    return new EbmlElement();
+  }
+
+  /** Represents a WebM EBML element that can be serialized as a byte array. */
+  private static final class EbmlElement {
+
+    /** Returns a byte[] containing the concatenation of the data from all {@code elements}. */
+    public static byte[] serialize(EbmlElement... elements) {
+      int size = 0;
+      for (EbmlElement element : elements) {
+        size += element.getSize();
+      }
+      ByteBuffer buffer = ByteBuffer.allocate(size);
+      for (EbmlElement element : elements) {
+        element.getData(buffer);
+      }
+      return buffer.array();
+    }
+
+    private final int id;
+    private final EbmlElement[] childElements;
+    private final byte[] payload;
+
+    /** Creates an element containing the specified {@code childElements}. */
+    EbmlElement(int id, EbmlElement... childElements) {
+      this.id = id;
+      this.childElements = childElements;
+      payload = null;
+    }
+
+    /** Creates an element containing the specified {@code payload}. */
+    EbmlElement(int id, byte... payload) {
+      this.id = id;
+      this.payload = payload;
+      childElements = null;
+    }
+
+    /** Creates a completely empty element that will contribute no bytes to the output. */
+    EbmlElement() {
+      id = NO_VALUE;
+      payload = null;
+      childElements = null;
+    }
+
+    private long getSize() {
+      if (id == NO_VALUE) {
+        return 0;
+      }
+
+      long payloadSize = getPayloadSize();
+      return getIdLength() + getVIntLength(payloadSize) + payloadSize;
+    }
+
+    private long getPayloadSize() {
+      if (payload != null) {
+        return payload.length;
+      }
+
+      int payloadSize = 0;
+      for (EbmlElement element : childElements) {
+        payloadSize += element.getSize();
+      }
+      return payloadSize;
+    }
+
+    private void getData(ByteBuffer byteBuffer) {
+      if (id == NO_VALUE) {
+        return;
+      }
+
+      putId(byteBuffer);
+      putVInt(byteBuffer, getPayloadSize());
+      if (payload != null) {
+        byteBuffer.put(payload);
+      } else {
+        for (EbmlElement atom : childElements) {
+          atom.getData(byteBuffer);
+        }
+      }
+    }
+
+    private int getIdLength() {
+      if (id == NO_VALUE) {
+        return 0;
+      }
+
+      for (int i = 0; i < 4; i++) {
+        if (id < 1 << (7 * i + 8)) {
+          return i + 1;
+        }
+      }
+      throw new IllegalArgumentException();
+    }
+
+    private static int getVIntLength(long vInt) {
+      for (int i = 1; i < 9; i++) {
+        if (vInt < 1 << (7 * i)) {
+          return i;
+        }
+      }
+      throw new IllegalArgumentException();
+    }
+
+    private void putId(ByteBuffer byteBuffer) {
+      int length = getIdLength();
+      for (int i = length - 1; i >= 0; i--) {
+        byteBuffer.put((byte) ((id >> (i * 8)) & 0xFF));
+      }
+    }
+
+    private static void putVInt(ByteBuffer byteBuffer, long vInt) {
+      int vIntLength = getVIntLength(vInt);
+      vInt |= 1 << (vIntLength * 7);
+      for (int i = vIntLength - 1; i >= 0; i--) {
+        byteBuffer.put((byte) ((vInt >> (i * 8)) & 0xFF));
+      }
+    }
+
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java b/library/src/test/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java
index 8d51e13f61..aff52f091a 100644
--- a/library/src/test/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java
+++ b/library/src/test/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java
@@ -15,24 +15,19 @@
  */
 package com.google.android.exoplayer.extractor.webm;
 
+import static com.google.android.exoplayer.extractor.webm.StreamBuilder.TEST_ENCRYPTION_KEY_ID;
+
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.drm.DrmInitData;
 import com.google.android.exoplayer.extractor.ChunkIndex;
-import com.google.android.exoplayer.extractor.DefaultExtractorInput;
-import com.google.android.exoplayer.extractor.Extractor;
-import com.google.android.exoplayer.extractor.ExtractorInput;
-import com.google.android.exoplayer.extractor.ExtractorOutput;
-import com.google.android.exoplayer.extractor.SeekMap;
-import com.google.android.exoplayer.extractor.TrackOutput;
-import com.google.android.exoplayer.testutil.FakeDataSource;
-import com.google.android.exoplayer.upstream.DataSource;
-import com.google.android.exoplayer.upstream.DataSpec;
+import com.google.android.exoplayer.extractor.webm.StreamBuilder.ContentEncodingSettings;
+import com.google.android.exoplayer.testutil.FakeExtractorOutput;
+import com.google.android.exoplayer.testutil.FakeTrackOutput;
+import com.google.android.exoplayer.testutil.TestUtil;
 import com.google.android.exoplayer.util.MimeTypes;
-import com.google.android.exoplayer.util.ParsableByteArray;
 
-import android.net.Uri;
 import android.test.InstrumentationTestCase;
 
 import java.io.IOException;
@@ -43,46 +38,38 @@
 /**
  * Tests for {@link WebmExtractor}.
  */
-public class WebmExtractorTest extends InstrumentationTestCase {
-
-  private static final int CUE_POINT_ELEMENT_BYTE_SIZE = 31;
+public final class WebmExtractorTest extends InstrumentationTestCase {
 
   private static final int DEFAULT_TIMECODE_SCALE = 1000000;
-
   private static final long TEST_DURATION_US = 9920000L;
   private static final int TEST_WIDTH = 1280;
   private static final int TEST_HEIGHT = 720;
   private static final int TEST_CHANNEL_COUNT = 1;
   private static final int TEST_SAMPLE_RATE = 48000;
-  private static final long TEST_CODEC_DELAY = 6500000;
-  private static final long TEST_SEEK_PRE_ROLL = 80000000;
-  private static final int TEST_OPUS_CODEC_PRIVATE_SIZE = 2;
+  private static final int TEST_CODEC_DELAY = 6500000;
+  private static final int TEST_SEEK_PRE_ROLL = 80000000;
   private static final String TEST_VORBIS_CODEC_PRIVATE = "webm/vorbis_codec_private";
   private static final int TEST_VORBIS_INFO_SIZE = 30;
   private static final int TEST_VORBIS_BOOKS_SIZE = 4140;
-  private static final byte[] TEST_ENCRYPTION_KEY_ID = { 0x00, 0x01, 0x02, 0x03 };
+  private static final byte[] TEST_OPUS_CODEC_PRIVATE = new byte[] {0, 0};
+  private static final int TEST_DEFAULT_DURATION_NS = 33 * 1000 * 1000;
+  private static final byte[] TEST_H264_CODEC_PRIVATE = TestUtil.createByteArray(0x01, 0x4D,
+      0x40, 0x1E, 0xFF, 0xE1, 0x00, 0x17, 0x67, 0x4D, 0x40, 0x1E, 0xE8, 0x80, 0x50, 0x17, 0xFC,
+      0xB8, 0x08, 0x80, 0x00, 0x01, 0xF4, 0x80, 0x00, 0x75, 0x30, 0x07, 0x8B, 0x16, 0x89, 0x01,
+      0x00, 0x04, 0x68, 0xEB, 0xEF, 0x20);
+
   private static final UUID WIDEVINE_UUID = new UUID(0xEDEF8BA979D64ACEL, 0xA3C827DCD51D21EDL);
   private static final UUID ZERO_UUID = new UUID(0, 0);
-  private static final byte[] TEST_INITIALIZATION_VECTOR = {
-      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
-  };
-
-  private static final int ID_VP9 = 0;
-  private static final int ID_OPUS = 1;
-  private static final int ID_VORBIS = 2;
-  private static final int ID_DUMMY = 3;
+  private static final String WEBM_DOC_TYPE = "webm";
+  private static final String MATROSKA_DOC_TYPE = "matroska";
 
   private WebmExtractor extractor;
-  private TestExtractorOutput extractorOutput;
-  private TestTrackOutput audioOutput;
-  private TestTrackOutput videoOutput;
+  private FakeExtractorOutput extractorOutput;
 
   @Override
   public void setUp() {
     extractor = new WebmExtractor();
-    extractorOutput = new TestExtractorOutput();
-    audioOutput = new TestTrackOutput();
-    videoOutput = new TestTrackOutput();
+    extractorOutput = new FakeExtractorOutput();
     extractor.init(extractorOutput);
   }
 
@@ -90,73 +77,144 @@ public void setUp() {
   public void tearDown() {
     extractor = null;
     extractorOutput = null;
-    audioOutput = null;
-    videoOutput = null;
   }
 
   public void testReadInitializationSegment() throws IOException, InterruptedException {
-    consume(
-        createInitializationSegment(1, 0, true, DEFAULT_TIMECODE_SCALE,
-            new int[] {ID_VP9}, null));
-    assertVideoFormat();
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
+        .build(1);
+
+    TestUtil.consumeTestData(extractor, data);
+
+    assertVp9VideoFormat();
+    assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
+  }
+
+  public void testReadSegmentTwice() throws IOException, InterruptedException {
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
+        .build(1);
+
+    TestUtil.consumeTestData(extractor, data);
+    extractor.seek();
+    TestUtil.consumeTestData(extractor, data);
+
+    assertVp9VideoFormat();
     assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
   }
 
   public void testPrepareOpus() throws IOException, InterruptedException {
-    consume(
-        createInitializationSegment(1, 0, true, DEFAULT_TIMECODE_SCALE,
-            new int[] {ID_OPUS}, null));
-    assertAudioFormat(ID_OPUS);
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addOpusTrack(TEST_CHANNEL_COUNT, TEST_SAMPLE_RATE, TEST_CODEC_DELAY,
+            TEST_SEEK_PRE_ROLL, TEST_OPUS_CODEC_PRIVATE)
+        .build(1);
+
+    TestUtil.consumeTestData(extractor, data);
+
+    assertAudioFormat(MimeTypes.AUDIO_OPUS);
     assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
   }
 
   public void testPrepareVorbis() throws IOException, InterruptedException {
-    consume(
-        createInitializationSegment(1, 0, true, DEFAULT_TIMECODE_SCALE,
-            new int[] {ID_VORBIS}, null));
-    assertAudioFormat(ID_VORBIS);
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVorbisTrack(TEST_CHANNEL_COUNT, TEST_SAMPLE_RATE, getVorbisCodecPrivate())
+        .build(1);
+
+    TestUtil.consumeTestData(extractor, data);
+
+    assertAudioFormat(MimeTypes.AUDIO_VORBIS);
+    assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
+  }
+
+  public void testPrepareH264() throws IOException, InterruptedException {
+    byte[] data = new StreamBuilder()
+        .setHeader(MATROSKA_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addH264Track(TEST_WIDTH, TEST_HEIGHT, TEST_H264_CODEC_PRIVATE)
+        .build(1);
+
+    TestUtil.consumeTestData(extractor, data);
+
+    assertH264VideoFormat();
     assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
   }
 
   public void testPrepareTwoTracks() throws IOException, InterruptedException {
-    consume(
-        createInitializationSegment(1, 0, true, DEFAULT_TIMECODE_SCALE,
-            new int[] {ID_VP9, ID_OPUS}, null));
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
+        .addOpusTrack(TEST_CHANNEL_COUNT, TEST_SAMPLE_RATE, TEST_CODEC_DELAY,
+            TEST_SEEK_PRE_ROLL, TEST_OPUS_CODEC_PRIVATE)
+        .build(1);
+
+    TestUtil.consumeTestData(extractor, data);
+
     assertEquals(2, extractorOutput.numberOfTracks);
-    assertVideoFormat();
-    assertAudioFormat(ID_OPUS);
+    assertVp9VideoFormat();
+    assertAudioFormat(MimeTypes.AUDIO_OPUS);
     assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
   }
 
   public void testPrepareThreeTracks() throws IOException, InterruptedException {
-    consume(
-        createInitializationSegment(1, 0, true, DEFAULT_TIMECODE_SCALE,
-            new int[] {ID_VP9, ID_DUMMY, ID_OPUS}, null));
-    // Eventhough the input stream has 3 tracks, only 2 of them are supported and will be reported.
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
+        .addUnsupportedTrack()
+        .addOpusTrack(TEST_CHANNEL_COUNT, TEST_SAMPLE_RATE, TEST_CODEC_DELAY,
+            TEST_SEEK_PRE_ROLL, TEST_OPUS_CODEC_PRIVATE)
+        .build(1);
+
+    TestUtil.consumeTestData(extractor, data);
+
+    // Even though the input stream has 3 tracks, only 2 of them are supported and will be reported.
     assertEquals(2, extractorOutput.numberOfTracks);
-    assertVideoFormat();
-    assertAudioFormat(ID_OPUS);
+    assertVp9VideoFormat();
+    assertAudioFormat(MimeTypes.AUDIO_OPUS);
     assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
   }
 
   public void testPrepareFourTracks() throws IOException, InterruptedException {
-    consume(
-        createInitializationSegment(1, 0, true, DEFAULT_TIMECODE_SCALE,
-            new int[] {ID_VP9, ID_VORBIS, ID_VP9, ID_OPUS}, null));
-    // Eventhough the input stream has 4 supported tracks, only the first video and audio track will
-    // be reported.
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
+        .addVorbisTrack(TEST_CHANNEL_COUNT, TEST_SAMPLE_RATE, getVorbisCodecPrivate())
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
+        .addOpusTrack(TEST_CHANNEL_COUNT, TEST_SAMPLE_RATE, TEST_CODEC_DELAY,
+            TEST_SEEK_PRE_ROLL, TEST_OPUS_CODEC_PRIVATE)
+        .build(1);
+
+    TestUtil.consumeTestData(extractor, data);
+
+    // Even though the input stream has 4 supported tracks, only the first video and audio track
+    // will be reported.
     assertEquals(2, extractorOutput.numberOfTracks);
-    assertVideoFormat();
-    assertAudioFormat(ID_VORBIS);
+    assertVp9VideoFormat();
+    assertAudioFormat(MimeTypes.AUDIO_VORBIS);
     assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
   }
 
   public void testPrepareContentEncodingEncryption() throws IOException, InterruptedException {
-    ContentEncodingSettings settings = new ContentEncodingSettings(0, 1, 1, 5, 1);
-    consume(
-        createInitializationSegment(1, 0, true, DEFAULT_TIMECODE_SCALE,
-            new int[] {ID_VP9}, settings));
-    assertVideoFormat();
+    ContentEncodingSettings settings = new StreamBuilder.ContentEncodingSettings(0, 1, 5, 1);
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, settings)
+        .build(1);
+
+    TestUtil.consumeTestData(extractor, data);
+
+    assertVp9VideoFormat();
     assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
     DrmInitData drmInitData = extractorOutput.drmInitData;
     assertNotNull(drmInitData);
@@ -165,10 +223,15 @@ public void testPrepareContentEncodingEncryption() throws IOException, Interrupt
   }
 
   public void testPrepareThreeCuePoints() throws IOException, InterruptedException {
-    consume(
-        createInitializationSegment(3, 0, true, DEFAULT_TIMECODE_SCALE,
-            new int[] {ID_VP9}, null));
-    assertVideoFormat();
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
+        .build(3);
+
+    TestUtil.consumeTestData(extractor, data);
+
+    assertVp9VideoFormat();
     assertIndex(
         new IndexPoint(0, 0, 10000),
         new IndexPoint(10000, 0, 10000),
@@ -176,8 +239,15 @@ public void testPrepareThreeCuePoints() throws IOException, InterruptedException
   }
 
   public void testPrepareCustomTimecodeScale() throws IOException, InterruptedException {
-    consume(createInitializationSegment(3, 0, true, 1000, new int[] {ID_VP9}, null));
-    assertVideoFormat();
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(1000, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
+        .build(3);
+
+    TestUtil.consumeTestData(extractor, data);
+
+    assertVp9VideoFormat();
     assertIndex(
         new IndexPoint(0, 0, 10),
         new IndexPoint(10, 0, 10),
@@ -185,21 +255,49 @@ public void testPrepareCustomTimecodeScale() throws IOException, InterruptedExce
   }
 
   public void testPrepareNoCuePoints() throws IOException, InterruptedException {
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
+        .build(0);
     try {
-      consume(
-          createInitializationSegment(0, 0, true, DEFAULT_TIMECODE_SCALE,
-              new int[] {ID_VP9}, null));
+      TestUtil.consumeTestData(extractor, data);
       fail();
     } catch (ParserException exception) {
       assertEquals("Invalid/missing cue points", exception.getMessage());
     }
   }
 
+  public void testAcceptsWebmDocType() throws IOException, InterruptedException {
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
+        .build(1);
+
+    // No exception is thrown.
+    TestUtil.consumeTestData(extractor, data);
+  }
+
+  public void testAcceptsMatroskaDocType() throws IOException, InterruptedException {
+    byte[] data = new StreamBuilder()
+        .setHeader(MATROSKA_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
+        .build(1);
+
+    // No exception is thrown.
+    TestUtil.consumeTestData(extractor, data);
+  }
+
   public void testPrepareInvalidDocType() throws IOException, InterruptedException {
+    byte[] data = new StreamBuilder()
+        .setHeader("webB")
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
+        .build(1);
     try {
-      consume(
-          createInitializationSegment(1, 0, false, DEFAULT_TIMECODE_SCALE,
-              new int[] {ID_VP9}, null));
+      TestUtil.consumeTestData(extractor, data);
       fail();
     } catch (ParserException exception) {
       assertEquals("DocType webB not supported", exception.getMessage());
@@ -207,11 +305,14 @@ public void testPrepareInvalidDocType() throws IOException, InterruptedException
   }
 
   public void testPrepareInvalidContentEncodingOrder() throws IOException, InterruptedException {
-    ContentEncodingSettings settings = new ContentEncodingSettings(1, 1, 1, 5, 1);
+    ContentEncodingSettings settings = new ContentEncodingSettings(1, 1, 5, 1);
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, settings)
+        .build(1);
     try {
-      consume(
-          createInitializationSegment(1, 0, true, DEFAULT_TIMECODE_SCALE,
-              new int[] {ID_VP9}, settings));
+      TestUtil.consumeTestData(extractor, data);
       fail();
     } catch (ParserException exception) {
       assertEquals("ContentEncodingOrder 1 not supported", exception.getMessage());
@@ -219,35 +320,45 @@ public void testPrepareInvalidContentEncodingOrder() throws IOException, Interru
   }
 
   public void testPrepareInvalidContentEncodingScope() throws IOException, InterruptedException {
-    ContentEncodingSettings settings = new ContentEncodingSettings(0, 0, 1, 5, 1);
+    ContentEncodingSettings settings = new ContentEncodingSettings(0, 0, 5, 1);
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, settings)
+        .build(1);
     try {
-      consume(
-          createInitializationSegment(1, 0, true, DEFAULT_TIMECODE_SCALE,
-              new int[] {ID_VP9}, settings));
+      TestUtil.consumeTestData(extractor, data);
       fail();
     } catch (ParserException exception) {
       assertEquals("ContentEncodingScope 0 not supported", exception.getMessage());
     }
   }
 
-  public void testPrepareInvalidContentEncodingType() throws IOException, InterruptedException {
-    ContentEncodingSettings settings = new ContentEncodingSettings(0, 1, 0, 5, 1);
+  public void testPrepareInvalidContentCompAlgo()
+      throws IOException, InterruptedException {
+    ContentEncodingSettings settings = new ContentEncodingSettings(0, 1, 0, new byte[0]);
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, settings)
+        .build(1);
     try {
-      consume(
-          createInitializationSegment(1, 0, true, DEFAULT_TIMECODE_SCALE,
-              new int[] {ID_VP9}, settings));
+      TestUtil.consumeTestData(extractor, data);
       fail();
     } catch (ParserException exception) {
-      assertEquals("ContentEncodingType 0 not supported", exception.getMessage());
+      assertEquals("ContentCompAlgo 0 not supported", exception.getMessage());
     }
   }
 
   public void testPrepareInvalidContentEncAlgo() throws IOException, InterruptedException {
-    ContentEncodingSettings settings = new ContentEncodingSettings(0, 1, 1, 4, 1);
+    ContentEncodingSettings settings = new ContentEncodingSettings(0, 1, 4, 1);
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, settings)
+        .build(1);
     try {
-      consume(
-          createInitializationSegment(1, 0, true, DEFAULT_TIMECODE_SCALE,
-              new int[] {ID_VP9}, settings));
+      TestUtil.consumeTestData(extractor, data);
       fail();
     } catch (ParserException exception) {
       assertEquals("ContentEncAlgo 4 not supported", exception.getMessage());
@@ -255,11 +366,14 @@ public void testPrepareInvalidContentEncAlgo() throws IOException, InterruptedEx
   }
 
   public void testPrepareInvalidAESSettingsCipherMode() throws IOException, InterruptedException {
-    ContentEncodingSettings settings = new ContentEncodingSettings(0, 1, 1, 5, 0);
+    ContentEncodingSettings settings = new ContentEncodingSettings(0, 1, 5, 0);
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, settings)
+        .build(1);
     try {
-      consume(
-          createInitializationSegment(1, 0, true, DEFAULT_TIMECODE_SCALE,
-              new int[] {ID_VP9}, settings));
+      TestUtil.consumeTestData(extractor, data);
       fail();
     } catch (ParserException exception) {
       assertEquals("AESSettingsCipherMode 0 not supported", exception.getMessage());
@@ -267,110 +381,174 @@ public void testPrepareInvalidAESSettingsCipherMode() throws IOException, Interr
   }
 
   public void testReadSampleKeyframe() throws IOException, InterruptedException {
-    MediaSegment mediaSegment =
-        createMediaSegment(100, 0, 0, true, false, true, false, false, 1);
-    byte[] testInputData = joinByteArrays(
-        createInitializationSegment(
-            1, mediaSegment.clusterBytes.length, true, DEFAULT_TIMECODE_SCALE,
-            new int[] {ID_VP9}, null),
-        mediaSegment.clusterBytes);
-    consume(testInputData);
-    assertVideoFormat();
-    assertSample(mediaSegment, 0, true, false, false, videoOutput);
+    byte[] media = createFrameData(100);
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
+        .addSimpleBlockMedia(1 /* trackNumber */, 0 /* clusterTimecode */, 0 /* blockTimecode */,
+            true /* keyframe */, false /* invisible */, media)
+        .build(1);
+
+    TestUtil.consumeTestData(extractor, data);
+
+    assertVp9VideoFormat();
+    assertSample(0, media, 0, true, false, null, getVideoOutput());
+  }
+
+  public void testReadSampleKeyframeStripped() throws IOException, InterruptedException {
+    byte[] strippedBytes = new byte[] {-1, -1};
+    ContentEncodingSettings settings = new ContentEncodingSettings(0, 1, 3, strippedBytes);
+    byte[] sampleBytes = createFrameData(100);
+    byte[] unstrippedSampleBytes = TestUtil.joinByteArrays(strippedBytes, sampleBytes);
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, settings)
+        .addSimpleBlockMedia(1 /* trackNumber */, 0 /* clusterTimecode */, 0 /* blockTimecode */,
+            true /* keyframe */, false /* invisible */, sampleBytes)
+        .build(1);
+
+    TestUtil.consumeTestData(extractor, data);
+
+    assertVp9VideoFormat();
+    assertSample(0, unstrippedSampleBytes, 0, true, false, null, getVideoOutput());
+  }
+
+  public void testReadSampleKeyframeManyBytesStripped() throws IOException, InterruptedException {
+    byte[] strippedBytes = createFrameData(100);
+    ContentEncodingSettings settings = new ContentEncodingSettings(0, 1, 3, strippedBytes);
+    byte[] sampleBytes = createFrameData(5);
+    byte[] unstrippedSampleBytes = TestUtil.joinByteArrays(strippedBytes, sampleBytes);
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, settings)
+        .addSimpleBlockMedia(1 /* trackNumber */, 0 /* clusterTimecode */, 0 /* blockTimecode */,
+            true /* keyframe */, false /* invisible */, sampleBytes)
+        .build(1);
+
+    TestUtil.consumeTestData(extractor, data);
+
+    assertVp9VideoFormat();
+    assertSample(0, unstrippedSampleBytes, 0, true, false, null, getVideoOutput());
   }
 
   public void testReadTwoTrackSamples() throws IOException, InterruptedException {
-    MediaSegment mediaSegmentAudio =
-        createMediaSegment(100, 0, 0, true, false, true, false, false, 2);
-    MediaSegment mediaSegmentVideo =
-        createMediaSegment(100, 0, 0, true, false, true, false, false, 1);
-    byte[] testInputData = joinByteArrays(
-        createInitializationSegment(
-            1, mediaSegmentAudio.clusterBytes.length + mediaSegmentVideo.clusterBytes.length,
-            true, DEFAULT_TIMECODE_SCALE, new int[] {ID_VP9, ID_OPUS}, null),
-        mediaSegmentVideo.clusterBytes, mediaSegmentAudio.clusterBytes);
-    consume(testInputData);
+    byte[] media = createFrameData(100);
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
+        .addOpusTrack(TEST_CHANNEL_COUNT, TEST_SAMPLE_RATE, TEST_CODEC_DELAY,
+            TEST_SEEK_PRE_ROLL, TEST_OPUS_CODEC_PRIVATE)
+        .addSimpleBlockMedia(1 /* trackNumber */, 0 /* clusterTimecode */, 0 /* blockTimecode */,
+            true /* keyframe */, false /* invisible */, media)
+        .addSimpleBlockMedia(2 /* trackNumber */, 0 /* clusterTimecode */, 0 /* blockTimecode */,
+            true /* keyframe */, false /* invisible */, media)
+        .build(1);
+
+    TestUtil.consumeTestData(extractor, data);
+
     assertEquals(2, extractorOutput.numberOfTracks);
-    assertVideoFormat();
-    assertAudioFormat(ID_OPUS);
-    assertSample(mediaSegmentVideo, 0, true, false, false, videoOutput);
-    assertSample(mediaSegmentAudio, 0, true, false, false, audioOutput);
+    assertVp9VideoFormat();
+    assertAudioFormat(MimeTypes.AUDIO_OPUS);
+    assertSample(0, media, 0, true, false, null, getVideoOutput());
+    assertSample(0, media, 0, true, false, null, getAudioOutput());
   }
 
   public void testReadTwoTrackSamplesWithSkippedTrack() throws IOException, InterruptedException {
-    MediaSegment mediaSegmentAudio =
-        createMediaSegment(100, 0, 0, true, false, true, false, false, 2);
-    MediaSegment mediaSegmentVideo =
-        createMediaSegment(100, 0, 0, true, false, true, false, false, 1);
-    MediaSegment mediaSegmentDummy =
-        createMediaSegment(100, 0, 0, true, false, true, false, false, 17);
-    byte[] testInputData = joinByteArrays(
-        createInitializationSegment(
-            1,
-            mediaSegmentAudio.clusterBytes.length + mediaSegmentVideo.clusterBytes.length
-                + mediaSegmentDummy.clusterBytes.length,
-            true, DEFAULT_TIMECODE_SCALE, new int[] {ID_DUMMY, ID_VP9, ID_OPUS}, null),
-        mediaSegmentVideo.clusterBytes,
-        mediaSegmentDummy.clusterBytes,
-        mediaSegmentAudio.clusterBytes);
-    consume(testInputData);
+    byte[] media = createFrameData(100);
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addUnsupportedTrack()
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
+        .addOpusTrack(TEST_CHANNEL_COUNT, TEST_SAMPLE_RATE, TEST_CODEC_DELAY,
+            TEST_SEEK_PRE_ROLL, TEST_OPUS_CODEC_PRIVATE)
+        .addSimpleBlockMedia(1 /* trackNumber */, 0 /* clusterTimecode */, 0 /* blockTimecode */,
+            true /* keyframe */, false /* invisible */, media)
+        .addSimpleBlockMedia(2 /* trackNumber */, 0 /* clusterTimecode */, 0 /* blockTimecode */,
+            true /* keyframe */, false /* invisible */, media)
+        .addSimpleBlockMedia(17 /* trackNumber */, 0 /* clusterTimecode */, 0 /* blockTimecode */,
+            true /* keyframe */, false /* invisible */, media)
+        .build(1);
+
+    TestUtil.consumeTestData(extractor, data);
+
     assertEquals(2, extractorOutput.numberOfTracks);
-    assertVideoFormat();
-    assertAudioFormat(ID_OPUS);
-    assertSample(mediaSegmentVideo, 0, true, false, false, videoOutput);
-    assertSample(mediaSegmentAudio, 0, true, false, false, audioOutput);
+    assertVp9VideoFormat();
+    assertAudioFormat(MimeTypes.AUDIO_OPUS);
+    assertSample(0, media, 0, true, false, null, getVideoOutput());
+    assertSample(0, media, 0, true, false, null, getAudioOutput());
   }
 
   public void testReadBlock() throws IOException, InterruptedException {
-    MediaSegment mediaSegment =
-        createMediaSegment(100, 0, 0, true, false, false, false, false, 2);
-    byte[] testInputData = joinByteArrays(
-        createInitializationSegment(
-            1, mediaSegment.clusterBytes.length, true, DEFAULT_TIMECODE_SCALE,
-            new int[] {ID_OPUS}, null),
-        mediaSegment.clusterBytes);
-    consume(testInputData);
-    assertAudioFormat(ID_OPUS);
-    assertSample(mediaSegment, 0, true, false, false, audioOutput);
+    byte[] media = createFrameData(100);
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addOpusTrack(TEST_CHANNEL_COUNT, TEST_SAMPLE_RATE, TEST_CODEC_DELAY,
+            TEST_SEEK_PRE_ROLL, TEST_OPUS_CODEC_PRIVATE)
+        .addBlockMedia(2 /* trackNumber */, 0 /* clusterTimecode */, 0 /* blockTimecode */,
+            true /* keyframe */, false /* invisible */, media)
+        .build(1);
+
+    TestUtil.consumeTestData(extractor, data);
+
+    assertAudioFormat(MimeTypes.AUDIO_OPUS);
+    assertSample(0, media, 0, true, false, null, getAudioOutput());
   }
 
   public void testReadBlockNonKeyframe() throws IOException, InterruptedException {
-    MediaSegment mediaSegment =
-        createMediaSegment(100, 0, 0, false, false, false, false, false, 1);
-    byte[] testInputData = joinByteArrays(
-        createInitializationSegment(
-            1, mediaSegment.clusterBytes.length, true, DEFAULT_TIMECODE_SCALE,
-            new int[] { ID_VP9 }, null),
-        mediaSegment.clusterBytes);
-    consume(testInputData);
-    assertVideoFormat();
-    assertSample(mediaSegment, 0, false, false, false, videoOutput);
+    byte[] media = createFrameData(100);
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
+        .addBlockMedia(1 /* trackNumber */, 0 /* clusterTimecode */, 0 /* blockTimecode */,
+            false /* keyframe */, false /* invisible */, media)
+        .build(1);
+
+    TestUtil.consumeTestData(extractor, data);
+
+    assertVp9VideoFormat();
+    assertSample(0, media, 0, false, false, null, getVideoOutput());
   }
 
   public void testReadEncryptedFrame() throws IOException, InterruptedException {
-    MediaSegment mediaSegment = createMediaSegment(100, 0, 0, true, false, true, true, true, 1);
-    ContentEncodingSettings settings = new ContentEncodingSettings(0, 1, 1, 5, 1);
-    byte[] testInputData = joinByteArrays(
-        createInitializationSegment(
-            1, mediaSegment.clusterBytes.length, true, DEFAULT_TIMECODE_SCALE,
-            new int[] {ID_VP9}, settings),
-        mediaSegment.clusterBytes);
-    consume(testInputData);
-    assertVideoFormat();
-    assertSample(mediaSegment, 0, true, false, true, videoOutput);
+    byte[] media = createFrameData(100);
+    ContentEncodingSettings settings = new ContentEncodingSettings(0, 1, 5, 1);
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, settings)
+        .addSimpleBlockEncryptedMedia(1 /* trackNumber */, 0 /* clusterTimecode */,
+            0 /* blockTimecode */, true /* keyframe */, false /* invisible */,
+            true /* validSignalByte */, media)
+        .build(1);
+
+    TestUtil.consumeTestData(extractor, data);
+
+    assertVp9VideoFormat();
+    assertSample(0, media, 0, true, false, TEST_ENCRYPTION_KEY_ID, getVideoOutput());
   }
 
   public void testReadEncryptedFrameWithInvalidSignalByte()
       throws IOException, InterruptedException {
-    MediaSegment mediaSegment = createMediaSegment(100, 0, 0, true, false, true, true, false, 1);
-    ContentEncodingSettings settings = new ContentEncodingSettings(0, 1, 1, 5, 1);
-    byte[] testInputData = joinByteArrays(
-        createInitializationSegment(
-            1, mediaSegment.clusterBytes.length, true, DEFAULT_TIMECODE_SCALE,
-            new int[] {ID_VP9}, settings),
-        mediaSegment.clusterBytes);
+    byte[] media = createFrameData(100);
+    ContentEncodingSettings settings = new ContentEncodingSettings(0, 1, 5, 1);
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, settings)
+        .addSimpleBlockEncryptedMedia(1 /* trackNumber */, 0 /* clusterTimecode */,
+            0 /* blockTimecode */, true /* keyframe */, false /* invisible */,
+            false /* validSignalByte */, media)
+        .build(1);
+
     try {
-      consume(testInputData);
+      TestUtil.consumeTestData(extractor, data);
       fail();
     } catch (ParserException exception) {
       assertEquals("Extension bit is set in signal byte", exception.getMessage());
@@ -378,78 +556,132 @@ public void testReadEncryptedFrameWithInvalidSignalByte()
   }
 
   public void testReadSampleInvisible() throws IOException, InterruptedException {
-    MediaSegment mediaSegment =
-        createMediaSegment(100, 12, 13, false, true, true, false, false, 1);
-    byte[] testInputData = joinByteArrays(
-        createInitializationSegment(
-            1, mediaSegment.clusterBytes.length, true, DEFAULT_TIMECODE_SCALE,
-            new int[] {ID_VP9}, null),
-        mediaSegment.clusterBytes);
-    consume(testInputData);
-    assertVideoFormat();
-    assertSample(mediaSegment, 25000, false, true, false, videoOutput);
+    byte[] media = createFrameData(100);
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
+        .addSimpleBlockMedia(1 /* trackNumber */, 12 /* clusterTimecode */, 13 /* blockTimecode */,
+            false /* keyframe */, true /* invisible */, media)
+        .build(1);
+
+    TestUtil.consumeTestData(extractor, data);
+
+    assertVp9VideoFormat();
+    assertSample(0, media, 25000, false, true, null, getVideoOutput());
   }
 
   public void testReadSampleCustomTimescale() throws IOException, InterruptedException {
-    MediaSegment mediaSegment =
-        createMediaSegment(100, 12, 13, false, false, true, false, false, 1);
-    byte[] testInputData = joinByteArrays(
-        createInitializationSegment(
-            1, mediaSegment.clusterBytes.length, true, 1000, new int[] {ID_VP9}, null),
-        mediaSegment.clusterBytes);
-    consume(testInputData);
-    assertVideoFormat();
-    assertSample(mediaSegment, 25, false, false, false, videoOutput);
+    byte[] media = createFrameData(100);
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(1000, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
+        .addSimpleBlockMedia(1 /* trackNumber */, 12 /* clusterTimecode */, 13 /* blockTimecode */,
+            false /* keyframe */, false /* invisible */, media)
+        .build(1);
+
+    TestUtil.consumeTestData(extractor, data);
+
+    assertVp9VideoFormat();
+    assertSample(0, media, 25, false, false, null, getVideoOutput());
   }
 
   public void testReadSampleNegativeSimpleBlockTimecode() throws IOException, InterruptedException {
-    MediaSegment mediaSegment =
-        createMediaSegment(100, 13, -12, true, true, true, false, false, 1);
-    byte[] testInputData = joinByteArrays(
-        createInitializationSegment(
-            1, mediaSegment.clusterBytes.length, true, DEFAULT_TIMECODE_SCALE,
-            new int[] {ID_VP9}, null),
-        mediaSegment.clusterBytes);
-    consume(testInputData);
-    assertVideoFormat();
-    assertSample(mediaSegment, 1000, true, true, false, videoOutput);
-  }
-
-  private void consume(byte[] data) throws IOException, InterruptedException {
-    ExtractorInput input = createTestInput(data);
-    int readResult = Extractor.RESULT_CONTINUE;
-    while (readResult == Extractor.RESULT_CONTINUE) {
-      readResult = extractor.read(input, null);
+    byte[] media = createFrameData(100);
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
+        .addSimpleBlockMedia(1 /* trackNumber */, 13 /* clusterTimecode */, -12 /* blockTimecode */,
+            true /* keyframe */, true /* invisible */, media)
+        .build(1);
+
+    TestUtil.consumeTestData(extractor, data);
+
+    assertVp9VideoFormat();
+    assertSample(0, media, 1000, true, true, null, getVideoOutput());
+  }
+
+  public void testReadSampleWithFixedSizeLacing() throws IOException, InterruptedException {
+    byte[] media = createFrameData(100);
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addOpusTrack(TEST_CHANNEL_COUNT, TEST_SAMPLE_RATE, TEST_CODEC_DELAY, TEST_SEEK_PRE_ROLL,
+            TEST_OPUS_CODEC_PRIVATE, TEST_DEFAULT_DURATION_NS)
+        .addSimpleBlockMediaWithFixedSizeLacing(2 /* trackNumber */, 0 /* clusterTimecode */,
+            0 /* blockTimecode */, 20, media)
+        .build(1);
+
+    TestUtil.consumeTestData(extractor, data);
+
+    assertAudioFormat(MimeTypes.AUDIO_OPUS);
+    for (int i = 0; i < 20; i++) {
+      long expectedTimeUs = i * TEST_DEFAULT_DURATION_NS / 1000;
+      assertSample(i, Arrays.copyOfRange(media, i * 5, i * 5 + 5), expectedTimeUs, true, false,
+          null, getAudioOutput());
     }
-    assertEquals(Extractor.RESULT_END_OF_INPUT, readResult);
   }
 
-  private static ExtractorInput createTestInput(byte[] data) throws IOException {
-    DataSource dataSource = new FakeDataSource.Builder().appendReadData(data).build();
-    dataSource.open(new DataSpec(Uri.parse("http://www.google.com")));
-    ExtractorInput input = new DefaultExtractorInput(dataSource, 0, C.LENGTH_UNBOUNDED);
-    return input;
+  public void testReadSampleWithXiphLacing() throws IOException, InterruptedException {
+    byte[] media = createFrameData(300);
+    byte[] data = new StreamBuilder()
+        .setHeader(WEBM_DOC_TYPE)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .addOpusTrack(TEST_CHANNEL_COUNT, TEST_SAMPLE_RATE, TEST_CODEC_DELAY, TEST_SEEK_PRE_ROLL,
+            TEST_OPUS_CODEC_PRIVATE, TEST_DEFAULT_DURATION_NS)
+        .addSimpleBlockMediaWithXiphLacing(2 /* trackNumber */, 0 /* clusterTimecode */,
+            0 /* blockTimecode */, media, 256, 1, 243)
+        .build(1);
+
+    TestUtil.consumeTestData(extractor, data);
+
+    assertAudioFormat(MimeTypes.AUDIO_OPUS);
+    assertSample(0, Arrays.copyOfRange(media, 0, 256), 0 * TEST_DEFAULT_DURATION_NS / 1000, true,
+        false, null, getAudioOutput());
+    assertSample(1, Arrays.copyOfRange(media, 256, 257), 1 * TEST_DEFAULT_DURATION_NS / 1000, true,
+        false, null, getAudioOutput());
+    assertSample(2, Arrays.copyOfRange(media, 257, 300), 2 * TEST_DEFAULT_DURATION_NS / 1000, true,
+        false, null, getAudioOutput());
   }
 
-  private void assertVideoFormat() {
-    MediaFormat format = videoOutput.format;
+  private FakeTrackOutput getVideoOutput() {
+    // In the sample data the video track has id 1.
+    return extractorOutput.trackOutputs.get(1);
+  }
+
+  private FakeTrackOutput getAudioOutput() {
+    // In the sample data the video track has id 2.
+    return extractorOutput.trackOutputs.get(2);
+  }
+
+  private void assertVp9VideoFormat() {
+    MediaFormat format = getVideoOutput().format;
     assertEquals(TEST_WIDTH, format.width);
     assertEquals(TEST_HEIGHT, format.height);
     assertEquals(MimeTypes.VIDEO_VP9, format.mimeType);
   }
 
-  private void assertAudioFormat(int codecId) {
-    MediaFormat format = audioOutput.format;
+  private void assertH264VideoFormat() {
+    MediaFormat format = getVideoOutput().format;
+    assertEquals(TEST_WIDTH, format.width);
+    assertEquals(TEST_HEIGHT, format.height);
+    assertEquals(MimeTypes.VIDEO_H264, format.mimeType);
+  }
+
+  private void assertAudioFormat(String expectedMimeType) {
+    MediaFormat format = getAudioOutput().format;
     assertEquals(TEST_CHANNEL_COUNT, format.channelCount);
     assertEquals(TEST_SAMPLE_RATE, format.sampleRate);
-    if (codecId == ID_OPUS) {
-      assertEquals(MimeTypes.AUDIO_OPUS, format.mimeType);
+    assertEquals(expectedMimeType, format.mimeType);
+    if (MimeTypes.AUDIO_OPUS.equals(expectedMimeType)) {
       assertEquals(3, format.initializationData.size());
-      assertEquals(TEST_OPUS_CODEC_PRIVATE_SIZE, format.initializationData.get(0).length);
+      android.test.MoreAsserts.assertEquals(TEST_OPUS_CODEC_PRIVATE,
+          format.initializationData.get(0));
       assertEquals(TEST_CODEC_DELAY, ByteBuffer.wrap(format.initializationData.get(1)).getLong());
       assertEquals(TEST_SEEK_PRE_ROLL, ByteBuffer.wrap(format.initializationData.get(2)).getLong());
-    } else if (codecId == ID_VORBIS) {
-      assertEquals(MimeTypes.AUDIO_VORBIS, format.mimeType);
+    } else if (MimeTypes.AUDIO_VORBIS.equals(expectedMimeType)) {
       assertEquals(2, format.initializationData.size());
       assertEquals(TEST_VORBIS_INFO_SIZE, format.initializationData.get(0).length);
       assertEquals(TEST_VORBIS_BOOKS_SIZE, format.initializationData.get(1).length);
@@ -467,237 +699,21 @@ private void assertIndex(IndexPoint... indexPoints) {
     }
   }
 
-  private void assertSample(MediaSegment mediaSegment, int timeUs, boolean keyframe,
-      boolean invisible, boolean encrypted, TestTrackOutput output) {
-    byte[] expectedOutput = mediaSegment.data;
-    if (encrypted) {
-      expectedOutput = joinByteArrays(new byte[] {(byte) TEST_INITIALIZATION_VECTOR.length},
-          TEST_INITIALIZATION_VECTOR, expectedOutput);
-    }
-    assertTrue(Arrays.equals(expectedOutput, output.sampleData));
-    assertEquals(timeUs, output.sampleTimeUs);
-    assertEquals(keyframe, (output.sampleFlags & C.SAMPLE_FLAG_SYNC) != 0);
-    assertEquals(invisible, (output.sampleFlags & C.SAMPLE_FLAG_DECODE_ONLY) != 0);
-    assertEquals(encrypted, (output.sampleFlags & C.SAMPLE_FLAG_ENCRYPTED) != 0);
-  }
-
-  private byte[] createInitializationSegment(int cuePoints, int mediaSegmentSize,
-      boolean docTypeIsWebm, int timecodeScale, int[] codecIds,
-      ContentEncodingSettings contentEncodingSettings) {
-    byte[] tracksElement = createTracksElement(codecIds, contentEncodingSettings);
-    byte[] infoElement = createInfoElement(timecodeScale);
-    byte[] cuesElement = createCuesElement(CUE_POINT_ELEMENT_BYTE_SIZE * cuePoints);
-    int initalizationSegmentSize = infoElement.length + tracksElement.length
-        + cuesElement.length + CUE_POINT_ELEMENT_BYTE_SIZE * cuePoints;
-    byte[] segmentElement = createSegmentElement(initalizationSegmentSize + mediaSegmentSize);
-    byte[] bytes = joinByteArrays(createEbmlElement(1, docTypeIsWebm, 2),
-        segmentElement, infoElement, tracksElement, cuesElement);
-    for (int i = 0; i < cuePoints; i++) {
-      bytes = joinByteArrays(bytes, createCuePointElement(10 * i, initalizationSegmentSize));
-    }
-    return bytes;
-  }
-
-  private byte[] createTracksElement(int[] codecIds,
-      ContentEncodingSettings contentEncodingSettings) {
-    byte[] trackBytes = new byte[0];
-    for (int codecId : codecIds) {
-      switch (codecId) {
-        case ID_VP9:
-          trackBytes = joinByteArrays(trackBytes,
-              createVideoTrackEntry(true, TEST_WIDTH, TEST_HEIGHT, contentEncodingSettings));
-          break;
-        case ID_OPUS:
-          trackBytes = joinByteArrays(trackBytes, createOpusAudioTrackEntry(TEST_CHANNEL_COUNT));
-          break;
-        case ID_VORBIS:
-          trackBytes = joinByteArrays(trackBytes, createVorbisAudioTrackEntry(TEST_CHANNEL_COUNT));
-          break;
-        case ID_DUMMY:
-          trackBytes = joinByteArrays(trackBytes, createUnsupportedTrackEntry());
-          break;
-      }
-    }
-    byte[] tracksSize = getIntegerBytes(trackBytes.length);
-    byte[] tracksHeader = createByteArray(
-        0x16, 0x54, 0xAE, 0x6B, // Tracks
-        0x01, 0x00, 0x00, 0x00, tracksSize[0], tracksSize[1], tracksSize[2], tracksSize[3]);
-    return joinByteArrays(tracksHeader, trackBytes);
-  }
-
-  private static MediaSegment createMediaSegment(int dataLength, int clusterTimecode,
-      int blockTimecode, boolean keyframe, boolean invisible, boolean simple,
-      boolean encrypted, boolean validSignalByte, int trackNumber) {
-    byte[] data = createFrameData(dataLength);
-    byte[] blockBytes;
-    if (simple) {
-      blockBytes = createSimpleBlockElement(data.length, blockTimecode,
-          keyframe, invisible, true, encrypted, validSignalByte, trackNumber);
-    } else {
-      blockBytes = createBlockElement(data.length, blockTimecode,
-          keyframe, invisible, true, trackNumber);
-    }
-    byte[] clusterBytes =
-        createClusterElement(blockBytes.length + data.length, clusterTimecode);
-    return new MediaSegment(joinByteArrays(clusterBytes, blockBytes, data), data);
-  }
-
-  private static byte[] joinByteArrays(byte[]... byteArrays) {
-    int length = 0;
-    for (byte[] byteArray : byteArrays) {
-      length += byteArray.length;
-    }
-    byte[] joined = new byte[length];
-    length = 0;
-    for (byte[] byteArray : byteArrays) {
-      System.arraycopy(byteArray, 0, joined, length, byteArray.length);
-      length += byteArray.length;
-    }
-    return joined;
-  }
-
-  private static byte[] createEbmlElement(
-      int ebmlReadVersion, boolean docTypeIsWebm, int docTypeReadVersion) {
-    return createByteArray(
-        0x1A, 0x45, 0xDF, 0xA3, // EBML
-        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, // size=15
-        0x42, 0xF7, // EBMLReadVersion
-        0x81, ebmlReadVersion, // size=1
-        0x42, 0x82, // DocType
-        0x84, 0x77, 0x65, 0x62, docTypeIsWebm ? 0x6D : 0x42, // size=4 value=webm/B
-        0x42, 0x85, // DocTypeReadVersion
-        0x81, docTypeReadVersion); // size=1
-  }
-
-  private static byte[] createSegmentElement(int size) {
-    byte[] sizeBytes = getIntegerBytes(size);
-    return createByteArray(
-        0x18, 0x53, 0x80, 0x67, // Segment
-        0x01, 0x00, 0x00, 0x00, sizeBytes[0], sizeBytes[1], sizeBytes[2], sizeBytes[3]);
-  }
-
-  private static byte[] createInfoElement(int timecodeScale) {
-    byte[] scaleBytes = getIntegerBytes(timecodeScale);
-    return createByteArray(
-        0x15, 0x49, 0xA9, 0x66, // Info
-        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, // size=19
-        0x2A, 0xD7, 0xB1, // TimecodeScale
-        0x84, scaleBytes[0], scaleBytes[1], scaleBytes[2], scaleBytes[3], // size=4
-        0x44, 0x89, // Duration
-        0x88, 0x40, 0xC3, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00); // size=8 value=9920.0
-  }
-
-  private static byte[] createVideoTrackEntry(
-      boolean codecIsVp9, int pixelWidth, int pixelHeight,
-      ContentEncodingSettings contentEncodingSettings) {
-    byte[] widthBytes = getIntegerBytes(pixelWidth);
-    byte[] heightBytes = getIntegerBytes(pixelHeight);
-    if (contentEncodingSettings != null) {
-      byte[] orderBytes = getIntegerBytes(contentEncodingSettings.order);
-      byte[] scopeBytes = getIntegerBytes(contentEncodingSettings.scope);
-      byte[] typeBytes = getIntegerBytes(contentEncodingSettings.type);
-      byte[] algorithmBytes = getIntegerBytes(contentEncodingSettings.algorithm);
-      byte[] cipherModeBytes = getIntegerBytes(contentEncodingSettings.aesCipherMode);
-      return createByteArray(
-          0xAE, // TrackEntry
-          0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, // size=69
-          0x86, // CodecID
-          0x85, 0x56, 0x5F, 0x56, 0x50, codecIsVp9 ? 0x39 : 0x30, // size=5 value=V_VP9/0
-          0xD7, // TrackNumber
-          0x81, 0x01, // size=1 value=1
-          0x83, // TrackType
-          0x81, 0x01, // size=1 value=1
-          0x6D, 0x80, // ContentEncodings
-          0xA4, // size=36
-          0x62, 0x40, // ContentEncoding
-          0xA1, // size=33
-          0x50, 0x31, // ContentEncodingOrder
-          0x81, orderBytes[3],
-          0x50, 0x32, // ContentEncodingScope
-          0x81, scopeBytes[3],
-          0x50, 0x33, // ContentEncodingType
-          0x81, typeBytes[3],
-          0x50, 0x35, // ContentEncryption
-          0x92, // size=18
-          0x47, 0xE1, // ContentEncAlgo
-          0x81, algorithmBytes[3],
-          0x47, 0xE2, // ContentEncKeyID
-          0x84, // size=4
-          TEST_ENCRYPTION_KEY_ID[0], TEST_ENCRYPTION_KEY_ID[1],
-          TEST_ENCRYPTION_KEY_ID[2], TEST_ENCRYPTION_KEY_ID[3], // value=binary
-          0x47, 0xE7, // ContentEncAESSettings
-          0x84, // size=4
-          0x47, 0xE8, // AESSettingsCipherMode
-          0x81, cipherModeBytes[3],
-          0xE0, // Video
-          0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, // size=8
-          0xB0, // PixelWidth
-          0x82, widthBytes[2], widthBytes[3], // size=2
-          0xBA, // PixelHeight
-          0x82, heightBytes[2], heightBytes[3]); // size=2
-    } else {
-      return createByteArray(
-          0xAE, // TrackEntry
-          0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, // size=30
-          0x86, // CodecID
-          0x85, 0x56, 0x5F, 0x56, 0x50, codecIsVp9 ? 0x39 : 0x30, // size=5 value=V_VP9/0
-          0xD7, // TrackNumber
-          0x81, 0x01, // size=1 value=1
-          0x83, // TrackType
-          0x81, 0x01, // size=1 value=1
-          0xE0, // Video
-          0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, // size=8
-          0xB0, // PixelWidth
-          0x82, widthBytes[2], widthBytes[3], // size=2
-          0xBA, // PixelHeight
-          0x82, heightBytes[2], heightBytes[3]); // size=2
+  private void assertSample(int index, byte[] expectedMedia, long timeUs, boolean keyframe,
+      boolean invisible, byte[] encryptionKey, FakeTrackOutput output) {
+    if (encryptionKey != null) {
+      expectedMedia = TestUtil.joinByteArrays(
+          new byte[] {(byte) StreamBuilder.TEST_INITIALIZATION_VECTOR.length},
+          StreamBuilder.TEST_INITIALIZATION_VECTOR, expectedMedia);
     }
+    int flags = 0;
+    flags |= keyframe ? C.SAMPLE_FLAG_SYNC : 0;
+    flags |= invisible ? C.SAMPLE_FLAG_DECODE_ONLY : 0;
+    flags |= encryptionKey != null ? C.SAMPLE_FLAG_ENCRYPTED : 0;
+    output.assertSample(index, expectedMedia, timeUs, flags, encryptionKey);
   }
 
-  private static byte[] createOpusAudioTrackEntry(int channelCount) {
-    byte[] channelCountBytes = getIntegerBytes(channelCount);
-    return createByteArray(
-        0xAE, // TrackEntry
-        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, // size=54
-        0x86, // CodecID
-        0x86, 0x41, 0x5F, 0x4F, 0x50, 0x55, 0x53, // size=6 value=A_OPUS
-        0xD7, // TrackNumber
-        0x81, 0x02, // size=1 value=2
-        0x83, // TrackType
-        0x81, 0x02, // size=1 value=2
-        0x56, 0xAA, // CodecDelay
-        0x83, 0x63, 0x2E, 0xA0, // size=3 value=6500000
-        0x56, 0xBB, // SeekPreRoll
-        0x84, 0x04, 0xC4, 0xB4, 0x00, // size=4 value=80000000
-        0xE1, // Audio
-        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, // size=13
-        0x9F, // Channels
-        0x81, channelCountBytes[3], // size=1
-        0xB5, // SamplingFrequency
-        0x88, 0x40, 0xE7, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, // size=8 value=48000
-        0x63, 0xA2, // CodecPrivate
-        0x82, 0x00, 0x00); // size=2
-  }
-
-  private byte[] createVorbisAudioTrackEntry(int channelCount) {
-    byte[] channelCountBytes = getIntegerBytes(channelCount);
-    byte[] tracksElement = createByteArray(
-        0xAE, // TrackEntry
-        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x99, // size=4249 (42+4207)
-        0x86, // CodecID
-        0x88, 0x41, 0x5f, 0x56, 0x4f, 0x52, 0x42, 0x49, 0x53, // size=8 value=A_VORBIS
-        0xD7, // TrackNumber
-        0x81, 0x02, // size=1 value=2
-        0x83, // TrackType
-        0x81, 0x02, // size=1 value=2
-        0xE1, // Audio
-        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, // size=13
-        0x9F, // Channels
-        0x81, channelCountBytes[3], // size=1
-        0xB5, // SamplingFrequency
-        0x88, 0x40, 0xE7, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, // size=8 value=48000
-        0x63, 0xA2, // CodecPrivate
-        0x50, 0x6F); // size=4207
+  private byte[] getVorbisCodecPrivate() {
     byte[] codecPrivate = new byte[4207];
     try {
       getInstrumentation().getContext().getResources().getAssets().open(TEST_VORBIS_CODEC_PRIVATE)
@@ -705,99 +721,7 @@ private static MediaSegment createMediaSegment(int dataLength, int clusterTimeco
     } catch (IOException e) {
       fail(); // should never happen
     }
-    return joinByteArrays(tracksElement, codecPrivate);
-  }
-
-  private static byte[] createUnsupportedTrackEntry() {
-    return createByteArray(
-        0xAE, // TrackEntry
-        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, // size=32
-        0x86, // CodecID
-        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, // size =17
-        0x44, 0x5f, 0x57, 0x45, 0x42, 0x56, 0x54, 0x54,
-        0x2f, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, // value=D_WEBVTT/metadata
-        0xD7, // TrackNumber
-        0x81, 0x03, // size=1 value=3
-        0x83, // TrackType
-        0x81, 0x11); // size=1 value=11
-  }
-
-  private static byte[] createCuesElement(int size) {
-    byte[] sizeBytes = getIntegerBytes(size);
-    return createByteArray(
-        0x1C, 0x53, 0xBB, 0x6B, // Cues
-        0x01, 0x00, 0x00, 0x00, sizeBytes[0], sizeBytes[1], sizeBytes[2], sizeBytes[3]);
-  }
-
-  private static byte[] createCuePointElement(int cueTime, int cueClusterPosition) {
-    byte[] positionBytes = getIntegerBytes(cueClusterPosition);
-    return createByteArray(
-        0xBB, // CuePoint
-        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, // size=22
-        0xB3, // CueTime
-        0x81, cueTime, // size=1
-        0xB7, // CueTrackPositions
-        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, // size=10
-        0xF1, // CueClusterPosition
-        0x88, 0x00, 0x00, 0x00, 0x00, positionBytes[0], positionBytes[1],
-        positionBytes[2], positionBytes[3]); // size=8
-  }
-
-  private static byte[] createClusterElement(int size, int timecode) {
-    byte[] sizeBytes = getIntegerBytes(size);
-    byte[] timeBytes = getIntegerBytes(timecode);
-    return createByteArray(
-        0x1F, 0x43, 0xB6, 0x75, // Cluster
-        0x01, 0x00, 0x00, 0x00, sizeBytes[0], sizeBytes[1], sizeBytes[2], sizeBytes[3],
-        0xE7, // Timecode
-        0x84, timeBytes[0], timeBytes[1], timeBytes[2], timeBytes[3]); // size=4
-  }
-
-  private static byte[] createSimpleBlockElement(
-      int size, int timecode, boolean keyframe, boolean invisible, boolean noLacing,
-      boolean encrypted, boolean validSignalByte, int trackNumber) {
-    byte[] sizeBytes = getIntegerBytes(size + 5 + (encrypted ? 9 : 0));
-    byte[] timeBytes = getIntegerBytes(timecode);
-    byte[] trackNumberBytes = getIntegerBytes(trackNumber);
-    byte flags = (byte)
-        ((keyframe ? 0x80 : 0x00) | (invisible ? 0x08 : 0x00) | (noLacing ? 0x00 : 0x06));
-    byte[] simpleBlock = createByteArray(
-        0xA3, // SimpleBlock
-        0x01, 0x00, 0x00, 0x00, sizeBytes[0], sizeBytes[1], sizeBytes[2], sizeBytes[3],
-        0x40, trackNumberBytes[3], // Track number size=2
-        timeBytes[2], timeBytes[3], flags); // Timecode and flags
-    if (encrypted) {
-      simpleBlock = joinByteArrays(
-          simpleBlock, createByteArray(validSignalByte ? 0x01 : 0x80),
-          Arrays.copyOfRange(TEST_INITIALIZATION_VECTOR, 0, 8));
-    }
-    return simpleBlock;
-  }
-
-  private static byte[] createBlockElement(
-      int size, int timecode, boolean keyframe, boolean invisible, boolean noLacing,
-      int trackNumber) {
-    int blockSize = size + 5;
-    byte[] blockSizeBytes = getIntegerBytes(blockSize);
-    byte[] timeBytes = getIntegerBytes(timecode);
-    byte[] trackNumberBytes = getIntegerBytes(trackNumber);
-    // Size of blockgroup = id + size + size of reference block + length of data.
-    int blockGroupElementSize = 1 + 8 + (keyframe ? 0 : 3) +  blockSize;
-    byte[] sizeBytes = getIntegerBytes(blockGroupElementSize);
-    byte flags = (byte) ((invisible ? 0x08 : 0x00) | (noLacing ? 0x00 : 0x06));
-    byte[] blockGroupHeader = createByteArray(
-        0xA0, // BlockGroup
-        0x01, 0x00, 0x00, 0x00, sizeBytes[0], sizeBytes[1], sizeBytes[2], sizeBytes[3]);
-    byte[] referenceBlock = keyframe ? new byte[0] : createByteArray(
-        0xFB, // ReferenceBlock
-        0x81, 0x00); // size=1 value=0
-    byte[] blockData = createByteArray(
-        0xA1, // Block
-        0x01, 0x00, 0x00, 0x00,
-        blockSizeBytes[0], blockSizeBytes[1], blockSizeBytes[2], blockSizeBytes[3],
-        0x40, trackNumberBytes[3], // Track number size=2
-        timeBytes[2], timeBytes[3], flags); // Timecode and flags
-    return joinByteArrays(blockGroupHeader, referenceBlock, blockData);
+    return codecPrivate;
   }
 
   private static byte[] createFrameData(int size) {
@@ -808,35 +732,6 @@ private static MediaSegment createMediaSegment(int dataLength, int clusterTimeco
     return data;
   }
 
-  private static byte[] getIntegerBytes(int value) {
-    return createByteArray(
-        (value & 0xFF000000) >> 24,
-        (value & 0x00FF0000) >> 16,
-        (value & 0x0000FF00) >> 8,
-        (value & 0x000000FF));
-  }
-
-  private static byte[] createByteArray(int... intArray) {
-    byte[] byteArray = new byte[intArray.length];
-    for (int i = 0; i < byteArray.length; i++) {
-      byteArray[i] = (byte) intArray[i];
-    }
-    return byteArray;
-  }
-
-  /** Used by {@link #createMediaSegment} to return both cluster and video bytes together. */
-  private static final class MediaSegment {
-
-    private final byte[] clusterBytes;
-    private final byte[] data;
-
-    private MediaSegment(byte[] clusterBytes, byte[] data) {
-      this.clusterBytes = clusterBytes;
-      this.data = data;
-    }
-
-  }
-
   /** Used by {@link #assertIndex(IndexPoint...)} to validate index elements. */
   private static final class IndexPoint {
 
@@ -852,93 +747,4 @@ private IndexPoint(long timeUs, int size, long durationUs) {
 
   }
 
-  /** Used by {@link #createVideoTrackEntry} to create a Track header with Encryption. */
-  private static final class ContentEncodingSettings {
-
-    private final int order;
-    private final int scope;
-    private final int type;
-    private final int algorithm;
-    private final int aesCipherMode;
-
-    private ContentEncodingSettings(int order, int scope, int type, int algorithm,
-        int aesCipherMode) {
-      this.order = order;
-      this.scope = scope;
-      this.type = type;
-      this.algorithm = algorithm;
-      this.aesCipherMode = aesCipherMode;
-    }
-
-  }
-
-  /** Implements {@link ExtractorOutput} for test purposes. */
-  public class TestExtractorOutput implements ExtractorOutput {
-
-    public boolean tracksEnded;
-    public SeekMap seekMap;
-    public DrmInitData drmInitData;
-    public int numberOfTracks;
-
-    @Override
-    public TrackOutput track(int trackId) {
-      numberOfTracks++;
-      // In the test samples, track number 1 is always video and track number 2 is always audio.
-      return (trackId == 1) ? videoOutput : audioOutput;
-    }
-
-    @Override
-    public void endTracks() {
-      tracksEnded = true;
-    }
-
-    @Override
-    public void seekMap(SeekMap seekMap) {
-      this.seekMap = seekMap;
-    }
-
-    @Override
-    public void drmInitData(DrmInitData drmInitData) {
-      this.drmInitData = drmInitData;
-    }
-
-  }
-
-  /** Implements {@link TrackOutput} for test purposes. */
-  public static class TestTrackOutput implements TrackOutput {
-
-    public MediaFormat format;
-    private long sampleTimeUs;
-    private int sampleFlags;
-    private byte[] sampleData;
-
-    @Override
-    public void format(MediaFormat format) {
-      this.format = format;
-    }
-
-    @Override
-    public int sampleData(ExtractorInput input, int length) throws IOException,
-        InterruptedException {
-      byte[] newData = new byte[length];
-      input.readFully(newData, 0, length);
-      sampleData = sampleData == null ? newData : joinByteArrays(sampleData, newData);
-      return length;
-    }
-
-    @Override
-    public void sampleData(ParsableByteArray data, int length) {
-      byte[] newData = new byte[length];
-      data.readBytes(newData, 0, length);
-      sampleData = sampleData == null ? newData : joinByteArrays(sampleData, newData);
-    }
-
-    @Override
-    public void sampleMetadata(long timeUs, int flags, int size, int offset, byte[] encryptionKey) {
-      this.sampleTimeUs = timeUs;
-      this.sampleFlags = flags;
-    }
-
-  }
-
 }
diff --git a/library/src/test/java/com/google/android/exoplayer/testutil/FakeDataSource.java b/library/src/test/java/com/google/android/exoplayer/testutil/FakeDataSource.java
index 1312ab2255..e128159ef9 100644
--- a/library/src/test/java/com/google/android/exoplayer/testutil/FakeDataSource.java
+++ b/library/src/test/java/com/google/android/exoplayer/testutil/FakeDataSource.java
@@ -169,7 +169,7 @@ public boolean isErrorSegment() {
     private boolean simulateUnknownLength;
 
     public Builder() {
-      segments = new ArrayList<Segment>();
+      segments = new ArrayList<>();
     }
 
     /**
diff --git a/library/src/test/java/com/google/android/exoplayer/testutil/FakeExtractorOutput.java b/library/src/test/java/com/google/android/exoplayer/testutil/FakeExtractorOutput.java
new file mode 100644
index 0000000000..6dbab04e7d
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/testutil/FakeExtractorOutput.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.testutil;
+
+import com.google.android.exoplayer.drm.DrmInitData;
+import com.google.android.exoplayer.extractor.ExtractorOutput;
+import com.google.android.exoplayer.extractor.SeekMap;
+
+import android.util.SparseArray;
+
+import junit.framework.TestCase;
+
+/**
+ * A fake {@link ExtractorOutput}.
+ */
+public final class FakeExtractorOutput implements ExtractorOutput {
+
+  private final boolean allowDuplicateTrackIds;
+
+  public final SparseArray<FakeTrackOutput> trackOutputs;
+
+  public boolean tracksEnded;
+  public SeekMap seekMap;
+  public DrmInitData drmInitData;
+  public int numberOfTracks;
+
+  public FakeExtractorOutput() {
+    this(false);
+  }
+
+  public FakeExtractorOutput(boolean allowDuplicateTrackIds) {
+    this.allowDuplicateTrackIds = allowDuplicateTrackIds;
+    trackOutputs = new SparseArray<>();
+  }
+
+  @Override
+  public FakeTrackOutput track(int trackId) {
+    FakeTrackOutput output = trackOutputs.get(trackId);
+    if (output == null) {
+      numberOfTracks++;
+      output = new FakeTrackOutput();
+      trackOutputs.put(trackId, output);
+    } else {
+      TestCase.assertTrue("Duplicate track id: " + trackId, allowDuplicateTrackIds);
+    }
+    return output;
+  }
+
+  @Override
+  public void endTracks() {
+    tracksEnded = true;
+  }
+
+  @Override
+  public void seekMap(SeekMap seekMap) {
+    this.seekMap = seekMap;
+  }
+
+  @Override
+  public void drmInitData(DrmInitData drmInitData) {
+    this.drmInitData = drmInitData;
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/testutil/FakeTrackOutput.java b/library/src/test/java/com/google/android/exoplayer/testutil/FakeTrackOutput.java
new file mode 100644
index 0000000000..f673c06f00
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/testutil/FakeTrackOutput.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.testutil;
+
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import android.test.MoreAsserts;
+
+import junit.framework.TestCase;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+
+/**
+ * A fake {@link TrackOutput}.
+ */
+public final class FakeTrackOutput implements TrackOutput {
+
+  private final ArrayList<Long> sampleTimesUs;
+  private final ArrayList<Integer> sampleFlags;
+  private final ArrayList<Integer> sampleStartOffsets;
+  private final ArrayList<Integer> sampleEndOffsets;
+  private final ArrayList<byte[]> sampleEncryptionKeys;
+
+  private byte[] sampleData;
+  public MediaFormat format;
+
+  public FakeTrackOutput() {
+    sampleData = new byte[0];
+    sampleTimesUs = new ArrayList<>();
+    sampleFlags = new ArrayList<>();
+    sampleStartOffsets = new ArrayList<>();
+    sampleEndOffsets = new ArrayList<>();
+    sampleEncryptionKeys = new ArrayList<>();
+  }
+
+  @Override
+  public void format(MediaFormat format) {
+    this.format = format;
+  }
+
+  @Override
+  public int sampleData(ExtractorInput input, int length) throws IOException,
+      InterruptedException {
+    byte[] newData = new byte[length];
+    input.readFully(newData, 0, length);
+    sampleData = TestUtil.joinByteArrays(sampleData, newData);
+    return length;
+  }
+
+  @Override
+  public void sampleData(ParsableByteArray data, int length) {
+    byte[] newData = new byte[length];
+    data.readBytes(newData, 0, length);
+    sampleData = TestUtil.joinByteArrays(sampleData, newData);
+  }
+
+  @Override
+  public void sampleMetadata(long timeUs, int flags, int size, int offset, byte[] encryptionKey) {
+    sampleTimesUs.add(timeUs);
+    sampleFlags.add(flags);
+    sampleStartOffsets.add(sampleData.length - offset - size);
+    sampleEndOffsets.add(sampleData.length - offset);
+    sampleEncryptionKeys.add(encryptionKey);
+  }
+
+  public void assertSampleCount(int count) {
+    TestCase.assertEquals(count, sampleTimesUs.size());
+  }
+
+  public void assertSample(int index, byte[] data, long timeUs, int flags, byte[] encryptionKey) {
+    byte[] actualData = Arrays.copyOfRange(sampleData, sampleStartOffsets.get(index),
+        sampleEndOffsets.get(index));
+    MoreAsserts.assertEquals(data, actualData);
+    TestCase.assertEquals(timeUs, (long) sampleTimesUs.get(index));
+    TestCase.assertEquals(flags, (int) sampleFlags.get(index));
+    byte[] sampleEncryptionKey = sampleEncryptionKeys.get(index);
+    if (encryptionKey == null) {
+      TestCase.assertEquals(null, sampleEncryptionKey);
+    } else {
+      MoreAsserts.assertEquals(encryptionKey, sampleEncryptionKey);
+    }
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/testutil/TestUtil.java b/library/src/test/java/com/google/android/exoplayer/testutil/TestUtil.java
new file mode 100644
index 0000000000..77fc5fa12a
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/testutil/TestUtil.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.testutil;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.extractor.DefaultExtractorInput;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.PositionHolder;
+import com.google.android.exoplayer.upstream.DataSpec;
+
+import android.net.Uri;
+import android.test.InstrumentationTestCase;
+
+import org.mockito.MockitoAnnotations;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Random;
+
+/**
+ * Utility methods for tests.
+ */
+public class TestUtil {
+
+  private TestUtil() {}
+
+  public static void consumeTestData(Extractor extractor, byte[] data)
+      throws IOException, InterruptedException {
+    ExtractorInput input = createTestExtractorInput(data);
+    PositionHolder seekPositionHolder = new PositionHolder();
+    int readResult = Extractor.RESULT_CONTINUE;
+    while (readResult != Extractor.RESULT_END_OF_INPUT) {
+      readResult = extractor.read(input, seekPositionHolder);
+      if (readResult == Extractor.RESULT_SEEK) {
+        input = createTestExtractorInput(data, (int) seekPositionHolder.position);
+      }
+    }
+  }
+
+  public static ExtractorInput createTestExtractorInput(byte[] data) throws IOException {
+    return createTestExtractorInput(data, 0);
+  }
+
+  public static ExtractorInput createTestExtractorInput(byte[] data, int offset)
+      throws IOException {
+    if (offset != 0) {
+      data = Arrays.copyOfRange(data, offset, data.length);
+    }
+    FakeDataSource dataSource = new FakeDataSource.Builder().appendReadData(data).build();
+    dataSource.open(new DataSpec(Uri.parse("http://www.google.com")));
+    ExtractorInput input = new DefaultExtractorInput(dataSource, offset, C.LENGTH_UNBOUNDED);
+    return input;
+  }
+
+  public static byte[] buildTestData(int length) {
+    return buildTestData(length, length);
+  }
+
+  public static byte[] buildTestData(int length, int seed) {
+    Random random = new Random(seed);
+    byte[] source = new byte[length];
+    random.nextBytes(source);
+    return source;
+  }
+
+  public static byte[] createByteArray(int... intArray) {
+    byte[] byteArray = new byte[intArray.length];
+    for (int i = 0; i < byteArray.length; i++) {
+      byteArray[i] = (byte) intArray[i];
+    }
+    return byteArray;
+  }
+
+  public static byte[] joinByteArrays(byte[]... byteArrays) {
+    int length = 0;
+    for (byte[] byteArray : byteArrays) {
+      length += byteArray.length;
+    }
+    byte[] joined = new byte[length];
+    length = 0;
+    for (byte[] byteArray : byteArrays) {
+      System.arraycopy(byteArray, 0, joined, length, byteArray.length);
+      length += byteArray.length;
+    }
+    return joined;
+  }
+
+  public static void setUpMockito(InstrumentationTestCase instrumentationTestCase) {
+    // Workaround for https://code.google.com/p/dexmaker/issues/detail?id=2.
+    System.setProperty("dexmaker.dexcache",
+        instrumentationTestCase.getInstrumentation().getTargetContext().getCacheDir().getPath());
+    MockitoAnnotations.initMocks(instrumentationTestCase);
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/testutil/Util.java b/library/src/test/java/com/google/android/exoplayer/testutil/Util.java
deleted file mode 100644
index 4d2897e7a4..0000000000
--- a/library/src/test/java/com/google/android/exoplayer/testutil/Util.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.testutil;
-
-import android.test.InstrumentationTestCase;
-
-import org.mockito.MockitoAnnotations;
-
-import java.util.Random;
-
-/**
- * Utility methods for tests.
- */
-public class Util {
-
-  private Util() {}
-
-  public static byte[] buildTestData(int length) {
-    return buildTestData(length, length);
-  }
-
-  public static byte[] buildTestData(int length, int seed) {
-    Random random = new Random(seed);
-    byte[] source = new byte[length];
-    random.nextBytes(source);
-    return source;
-  }
-
-  public static void setUpMockito(InstrumentationTestCase instrumentationTestCase) {
-    // Workaround for https://code.google.com/p/dexmaker/issues/detail?id=2.
-    System.setProperty("dexmaker.dexcache",
-        instrumentationTestCase.getInstrumentation().getTargetContext().getCacheDir().getPath());
-    MockitoAnnotations.initMocks(instrumentationTestCase);
-  }
-
-}
diff --git a/library/src/test/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java b/library/src/test/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java
new file mode 100644
index 0000000000..7459442fb2
--- /dev/null
+++ b/library/src/test/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.text.subrip;
+
+import com.google.android.exoplayer.C;
+
+import android.test.InstrumentationTestCase;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Unit test for {@link SubripParser}.
+ */
+public final class SubripParserTest extends InstrumentationTestCase {
+
+  private static final String TYPICAL_SUBRIP_FILE = "subrip/typical";
+  private static final String EMPTY_SUBRIP_FILE = "subrip/empty";
+
+  public void testParseNullSubripFile() throws IOException {
+    SubripParser parser = new SubripParser();
+    InputStream inputStream =
+        getInstrumentation().getContext().getResources().getAssets().open(EMPTY_SUBRIP_FILE);
+    SubripSubtitle subtitle = parser.parse(inputStream, C.UTF8_NAME, 0);
+    // Assert that the subtitle is empty.
+    assertEquals(0, subtitle.getEventTimeCount());
+    assertTrue(subtitle.getCues(0).isEmpty());
+  }
+
+  public void testParseTypicalSubripFile() throws IOException {
+    SubripParser parser = new SubripParser();
+    InputStream inputStream =
+        getInstrumentation().getContext().getResources().getAssets().open(TYPICAL_SUBRIP_FILE);
+    SubripSubtitle subtitle = parser.parse(inputStream, C.UTF8_NAME, 0);
+
+    // Test start time and event count.
+    assertEquals(0, subtitle.getStartTime());
+    assertEquals(4, subtitle.getEventTimeCount());
+
+    // Test first cue.
+    assertEquals(0, subtitle.getEventTime(0));
+    assertEquals("This is the first subtitle.",
+        subtitle.getCues(subtitle.getEventTime(0)).get(0).text.toString());
+    assertEquals(1234000, subtitle.getEventTime(1));
+
+    // Test second cue.
+    assertEquals(2345000, subtitle.getEventTime(2));
+    assertEquals("This is the second subtitle.\nSecond subtitle with second line.",
+        subtitle.getCues(subtitle.getEventTime(2)).get(0).text.toString());
+    assertEquals(3456000, subtitle.getEventTime(3));
+  }
+
+}
diff --git a/library/src/test/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java b/library/src/test/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java
index 426c5152df..e8bb58ed9f 100644
--- a/library/src/test/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java
+++ b/library/src/test/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java
@@ -30,6 +30,7 @@
   private static final String TYPICAL_WEBVTT_FILE = "webvtt/typical";
   private static final String TYPICAL_WITH_IDS_WEBVTT_FILE = "webvtt/typical_with_identifiers";
   private static final String TYPICAL_WITH_TAGS_WEBVTT_FILE = "webvtt/typical_with_tags";
+  private static final String LIVE_TYPICAL_WEBVTT_FILE = "webvtt/live_typical";
   private static final String EMPTY_WEBVTT_FILE = "webvtt/empty";
 
   public void testParseNullWebvttFile() throws IOException {
@@ -59,13 +60,13 @@ public void testParseTypicalWebvttFile() throws IOException {
     // test first cue
     assertEquals(startTimeUs, subtitle.getEventTime(0));
     assertEquals("This is the first subtitle.",
-        subtitle.getText(subtitle.getEventTime(0)));
+        subtitle.getCues(subtitle.getEventTime(0)).get(0).text.toString());
     assertEquals(startTimeUs + 1234000, subtitle.getEventTime(1));
 
     // test second cue
     assertEquals(startTimeUs + 2345000, subtitle.getEventTime(2));
     assertEquals("This is the second subtitle.",
-        subtitle.getText(subtitle.getEventTime(2)));
+        subtitle.getCues(subtitle.getEventTime(2)).get(0).text.toString());
     assertEquals(startTimeUs + 3456000, subtitle.getEventTime(3));
   }
 
@@ -84,13 +85,13 @@ public void testParseTypicalWithIdsWebvttFile() throws IOException {
     // test first cue
     assertEquals(startTimeUs, subtitle.getEventTime(0));
     assertEquals("This is the first subtitle.",
-        subtitle.getText(subtitle.getEventTime(0)));
+        subtitle.getCues(subtitle.getEventTime(0)).get(0).text.toString());
     assertEquals(startTimeUs + 1234000, subtitle.getEventTime(1));
 
     // test second cue
     assertEquals(startTimeUs + 2345000, subtitle.getEventTime(2));
     assertEquals("This is the second subtitle.",
-        subtitle.getText(subtitle.getEventTime(2)));
+        subtitle.getCues(subtitle.getEventTime(2)).get(0).text.toString());
     assertEquals(startTimeUs + 3456000, subtitle.getEventTime(3));
   }
 
@@ -109,26 +110,50 @@ public void testParseTypicalWithTagsWebvttFile() throws IOException {
     // test first cue
     assertEquals(startTimeUs, subtitle.getEventTime(0));
     assertEquals("This is the first subtitle.",
-        subtitle.getText(subtitle.getEventTime(0)));
+        subtitle.getCues(subtitle.getEventTime(0)).get(0).text.toString());
     assertEquals(startTimeUs + 1234000, subtitle.getEventTime(1));
 
     // test second cue
     assertEquals(startTimeUs + 2345000, subtitle.getEventTime(2));
     assertEquals("This is the second subtitle.",
-        subtitle.getText(subtitle.getEventTime(2)));
+        subtitle.getCues(subtitle.getEventTime(2)).get(0).text.toString());
     assertEquals(startTimeUs + 3456000, subtitle.getEventTime(3));
 
     // test third cue
     assertEquals(startTimeUs + 4000000, subtitle.getEventTime(4));
     assertEquals("This is the third subtitle.",
-        subtitle.getText(subtitle.getEventTime(4)));
+        subtitle.getCues(subtitle.getEventTime(4)).get(0).text.toString());
     assertEquals(startTimeUs + 5000000, subtitle.getEventTime(5));
 
     // test fourth cue
     assertEquals(startTimeUs + 6000000, subtitle.getEventTime(6));
     assertEquals("This is the <fourth> &subtitle.",
-        subtitle.getText(subtitle.getEventTime(6)));
+        subtitle.getCues(subtitle.getEventTime(6)).get(0).text.toString());
     assertEquals(startTimeUs + 7000000, subtitle.getEventTime(7));
   }
 
+  public void testParseLiveTypicalWebvttFile() throws IOException {
+    WebvttParser parser = new WebvttParser();
+    InputStream inputStream =
+        getInstrumentation().getContext().getResources().getAssets().open(LIVE_TYPICAL_WEBVTT_FILE);
+    WebvttSubtitle subtitle = parser.parse(inputStream, C.UTF8_NAME, 0);
+
+    // test start time and event count
+    long startTimeUs = 0;
+    assertEquals(startTimeUs, subtitle.getStartTime());
+    assertEquals(4, subtitle.getEventTimeCount());
+
+    // test first cue
+    assertEquals(startTimeUs, subtitle.getEventTime(0));
+    assertEquals("This is the first subtitle.",
+        subtitle.getCues(subtitle.getEventTime(0)).get(0).text.toString());
+    assertEquals(startTimeUs + 1234000, subtitle.getEventTime(1));
+
+    // test second cue
+    assertEquals(startTimeUs + 2345000, subtitle.getEventTime(2));
+    assertEquals("This is the second subtitle.",
+        subtitle.getCues(subtitle.getEventTime(2)).get(0).text.toString());
+    assertEquals(startTimeUs + 3456000, subtitle.getEventTime(3));
+  }
+
 }
diff --git a/library/src/test/java/com/google/android/exoplayer/text/webvtt/WebvttSubtitleTest.java b/library/src/test/java/com/google/android/exoplayer/text/webvtt/WebvttSubtitleTest.java
index e95482f0fb..e8ce0b387c 100644
--- a/library/src/test/java/com/google/android/exoplayer/text/webvtt/WebvttSubtitleTest.java
+++ b/library/src/test/java/com/google/android/exoplayer/text/webvtt/WebvttSubtitleTest.java
@@ -15,8 +15,13 @@
  */
 package com.google.android.exoplayer.text.webvtt;
 
+import com.google.android.exoplayer.text.Cue;
+
 import junit.framework.TestCase;
 
+import java.util.ArrayList;
+import java.util.List;
+
 /**
  * Unit test for {@link WebvttSubtitle}.
  */
@@ -25,21 +30,39 @@
   private static final String FIRST_SUBTITLE_STRING = "This is the first subtitle.";
   private static final String SECOND_SUBTITLE_STRING = "This is the second subtitle.";
   private static final String FIRST_AND_SECOND_SUBTITLE_STRING =
-      FIRST_SUBTITLE_STRING + SECOND_SUBTITLE_STRING;
+      FIRST_SUBTITLE_STRING + "\n" + SECOND_SUBTITLE_STRING;
+
+  private WebvttSubtitle emptySubtitle = new WebvttSubtitle(new ArrayList<WebvttCue>(), 0);
+
+  private ArrayList<WebvttCue> simpleSubtitleCues = new ArrayList<>();
+  {
+    WebvttCue firstCue = new WebvttCue(1000000, 2000000, FIRST_SUBTITLE_STRING);
+    simpleSubtitleCues.add(firstCue);
+
+    WebvttCue secondCue = new WebvttCue(3000000, 4000000, SECOND_SUBTITLE_STRING);
+    simpleSubtitleCues.add(secondCue);
+  }
+  private WebvttSubtitle simpleSubtitle = new WebvttSubtitle(simpleSubtitleCues, 0);
 
-  private WebvttSubtitle emptySubtitle = new WebvttSubtitle(new String[] {}, 0, new long[] {});
+  private ArrayList<WebvttCue> overlappingSubtitleCues = new ArrayList<>();
+  {
+    WebvttCue firstCue = new WebvttCue(1000000, 3000000, FIRST_SUBTITLE_STRING);
+    overlappingSubtitleCues.add(firstCue);
 
-  private WebvttSubtitle simpleSubtitle = new WebvttSubtitle(
-      new String[] {FIRST_SUBTITLE_STRING, SECOND_SUBTITLE_STRING}, 0,
-      new long[] {1000000, 2000000, 3000000, 4000000});
+    WebvttCue secondCue = new WebvttCue(2000000, 4000000, SECOND_SUBTITLE_STRING);
+    overlappingSubtitleCues.add(secondCue);
+  }
+  private WebvttSubtitle overlappingSubtitle = new WebvttSubtitle(overlappingSubtitleCues, 0);
 
-  private WebvttSubtitle overlappingSubtitle = new WebvttSubtitle(
-      new String[] {FIRST_SUBTITLE_STRING, SECOND_SUBTITLE_STRING}, 0,
-      new long[] {1000000, 3000000, 2000000, 4000000});
+  private ArrayList<WebvttCue> nestedSubtitleCues = new ArrayList<>();
+  {
+    WebvttCue firstCue = new WebvttCue(1000000, 4000000, FIRST_SUBTITLE_STRING);
+    nestedSubtitleCues.add(firstCue);
 
-  private WebvttSubtitle nestedSubtitle = new WebvttSubtitle(
-      new String[] {FIRST_SUBTITLE_STRING, SECOND_SUBTITLE_STRING}, 0,
-      new long[] {1000000, 4000000, 2000000, 3000000});
+    WebvttCue secondCue = new WebvttCue(2000000, 3000000, SECOND_SUBTITLE_STRING);
+    nestedSubtitleCues.add(secondCue);
+  }
+  private WebvttSubtitle nestedSubtitle = new WebvttSubtitle(nestedSubtitleCues, 0);
 
   public void testEventCount() {
     assertEquals(0, emptySubtitle.getEventTimeCount());
@@ -72,29 +95,29 @@ public void testSimpleSubtitleEventIndices() {
 
   public void testSimpleSubtitleText() {
     // Test before first subtitle
-    assertNull(simpleSubtitle.getText(0));
-    assertNull(simpleSubtitle.getText(500000));
-    assertNull(simpleSubtitle.getText(999999));
+    assertSingleCueEmpty(simpleSubtitle.getCues(0));
+    assertSingleCueEmpty(simpleSubtitle.getCues(500000));
+    assertSingleCueEmpty(simpleSubtitle.getCues(999999));
 
     // Test first subtitle
-    assertEquals(FIRST_SUBTITLE_STRING, simpleSubtitle.getText(1000000));
-    assertEquals(FIRST_SUBTITLE_STRING, simpleSubtitle.getText(1500000));
-    assertEquals(FIRST_SUBTITLE_STRING, simpleSubtitle.getText(1999999));
+    assertSingleCueTextEquals(FIRST_SUBTITLE_STRING, simpleSubtitle.getCues(1000000));
+    assertSingleCueTextEquals(FIRST_SUBTITLE_STRING, simpleSubtitle.getCues(1500000));
+    assertSingleCueTextEquals(FIRST_SUBTITLE_STRING, simpleSubtitle.getCues(1999999));
 
     // Test after first subtitle, before second subtitle
-    assertNull(simpleSubtitle.getText(2000000));
-    assertNull(simpleSubtitle.getText(2500000));
-    assertNull(simpleSubtitle.getText(2999999));
+    assertSingleCueEmpty(simpleSubtitle.getCues(2000000));
+    assertSingleCueEmpty(simpleSubtitle.getCues(2500000));
+    assertSingleCueEmpty(simpleSubtitle.getCues(2999999));
 
     // Test second subtitle
-    assertEquals(SECOND_SUBTITLE_STRING, simpleSubtitle.getText(3000000));
-    assertEquals(SECOND_SUBTITLE_STRING, simpleSubtitle.getText(3500000));
-    assertEquals(SECOND_SUBTITLE_STRING, simpleSubtitle.getText(3999999));
+    assertSingleCueTextEquals(SECOND_SUBTITLE_STRING, simpleSubtitle.getCues(3000000));
+    assertSingleCueTextEquals(SECOND_SUBTITLE_STRING, simpleSubtitle.getCues(3500000));
+    assertSingleCueTextEquals(SECOND_SUBTITLE_STRING, simpleSubtitle.getCues(3999999));
 
     // Test after second subtitle
-    assertNull(simpleSubtitle.getText(4000000));
-    assertNull(simpleSubtitle.getText(4500000));
-    assertNull(simpleSubtitle.getText(Long.MAX_VALUE));
+    assertSingleCueEmpty(simpleSubtitle.getCues(4000000));
+    assertSingleCueEmpty(simpleSubtitle.getCues(4500000));
+    assertSingleCueEmpty(simpleSubtitle.getCues(Long.MAX_VALUE));
   }
 
   public void testOverlappingSubtitleEventTimes() {
@@ -107,29 +130,32 @@ public void testOverlappingSubtitleEventIndices() {
 
   public void testOverlappingSubtitleText() {
     // Test before first subtitle
-    assertNull(overlappingSubtitle.getText(0));
-    assertNull(overlappingSubtitle.getText(500000));
-    assertNull(overlappingSubtitle.getText(999999));
+    assertSingleCueEmpty(overlappingSubtitle.getCues(0));
+    assertSingleCueEmpty(overlappingSubtitle.getCues(500000));
+    assertSingleCueEmpty(overlappingSubtitle.getCues(999999));
 
     // Test first subtitle
-    assertEquals(FIRST_SUBTITLE_STRING, overlappingSubtitle.getText(1000000));
-    assertEquals(FIRST_SUBTITLE_STRING, overlappingSubtitle.getText(1500000));
-    assertEquals(FIRST_SUBTITLE_STRING, overlappingSubtitle.getText(1999999));
+    assertSingleCueTextEquals(FIRST_SUBTITLE_STRING, overlappingSubtitle.getCues(1000000));
+    assertSingleCueTextEquals(FIRST_SUBTITLE_STRING, overlappingSubtitle.getCues(1500000));
+    assertSingleCueTextEquals(FIRST_SUBTITLE_STRING, overlappingSubtitle.getCues(1999999));
 
     // Test after first and second subtitle
-    assertEquals(FIRST_AND_SECOND_SUBTITLE_STRING, overlappingSubtitle.getText(2000000));
-    assertEquals(FIRST_AND_SECOND_SUBTITLE_STRING, overlappingSubtitle.getText(2500000));
-    assertEquals(FIRST_AND_SECOND_SUBTITLE_STRING, overlappingSubtitle.getText(2999999));
+    assertSingleCueTextEquals(FIRST_AND_SECOND_SUBTITLE_STRING,
+        overlappingSubtitle.getCues(2000000));
+    assertSingleCueTextEquals(FIRST_AND_SECOND_SUBTITLE_STRING,
+        overlappingSubtitle.getCues(2500000));
+    assertSingleCueTextEquals(FIRST_AND_SECOND_SUBTITLE_STRING,
+        overlappingSubtitle.getCues(2999999));
 
     // Test second subtitle
-    assertEquals(SECOND_SUBTITLE_STRING, overlappingSubtitle.getText(3000000));
-    assertEquals(SECOND_SUBTITLE_STRING, overlappingSubtitle.getText(3500000));
-    assertEquals(SECOND_SUBTITLE_STRING, overlappingSubtitle.getText(3999999));
+    assertSingleCueTextEquals(SECOND_SUBTITLE_STRING, overlappingSubtitle.getCues(3000000));
+    assertSingleCueTextEquals(SECOND_SUBTITLE_STRING, overlappingSubtitle.getCues(3500000));
+    assertSingleCueTextEquals(SECOND_SUBTITLE_STRING, overlappingSubtitle.getCues(3999999));
 
     // Test after second subtitle
-    assertNull(overlappingSubtitle.getText(4000000));
-    assertNull(overlappingSubtitle.getText(4500000));
-    assertNull(overlappingSubtitle.getText(Long.MAX_VALUE));
+    assertSingleCueEmpty(overlappingSubtitle.getCues(4000000));
+    assertSingleCueEmpty(overlappingSubtitle.getCues(4500000));
+    assertSingleCueEmpty(overlappingSubtitle.getCues(Long.MAX_VALUE));
   }
 
   public void testNestedSubtitleEventTimes() {
@@ -142,29 +168,29 @@ public void testNestedSubtitleEventIndices() {
 
   public void testNestedSubtitleText() {
     // Test before first subtitle
-    assertNull(nestedSubtitle.getText(0));
-    assertNull(nestedSubtitle.getText(500000));
-    assertNull(nestedSubtitle.getText(999999));
+    assertSingleCueEmpty(nestedSubtitle.getCues(0));
+    assertSingleCueEmpty(nestedSubtitle.getCues(500000));
+    assertSingleCueEmpty(nestedSubtitle.getCues(999999));
 
     // Test first subtitle
-    assertEquals(FIRST_SUBTITLE_STRING, nestedSubtitle.getText(1000000));
-    assertEquals(FIRST_SUBTITLE_STRING, nestedSubtitle.getText(1500000));
-    assertEquals(FIRST_SUBTITLE_STRING, nestedSubtitle.getText(1999999));
+    assertSingleCueTextEquals(FIRST_SUBTITLE_STRING, nestedSubtitle.getCues(1000000));
+    assertSingleCueTextEquals(FIRST_SUBTITLE_STRING, nestedSubtitle.getCues(1500000));
+    assertSingleCueTextEquals(FIRST_SUBTITLE_STRING, nestedSubtitle.getCues(1999999));
 
     // Test after first and second subtitle
-    assertEquals(FIRST_AND_SECOND_SUBTITLE_STRING, nestedSubtitle.getText(2000000));
-    assertEquals(FIRST_AND_SECOND_SUBTITLE_STRING, nestedSubtitle.getText(2500000));
-    assertEquals(FIRST_AND_SECOND_SUBTITLE_STRING, nestedSubtitle.getText(2999999));
+    assertSingleCueTextEquals(FIRST_AND_SECOND_SUBTITLE_STRING, nestedSubtitle.getCues(2000000));
+    assertSingleCueTextEquals(FIRST_AND_SECOND_SUBTITLE_STRING, nestedSubtitle.getCues(2500000));
+    assertSingleCueTextEquals(FIRST_AND_SECOND_SUBTITLE_STRING, nestedSubtitle.getCues(2999999));
 
     // Test first subtitle
-    assertEquals(FIRST_SUBTITLE_STRING, nestedSubtitle.getText(3000000));
-    assertEquals(FIRST_SUBTITLE_STRING, nestedSubtitle.getText(3500000));
-    assertEquals(FIRST_SUBTITLE_STRING, nestedSubtitle.getText(3999999));
+    assertSingleCueTextEquals(FIRST_SUBTITLE_STRING, nestedSubtitle.getCues(3000000));
+    assertSingleCueTextEquals(FIRST_SUBTITLE_STRING, nestedSubtitle.getCues(3500000));
+    assertSingleCueTextEquals(FIRST_SUBTITLE_STRING, nestedSubtitle.getCues(3999999));
 
     // Test after second subtitle
-    assertNull(nestedSubtitle.getText(4000000));
-    assertNull(nestedSubtitle.getText(4500000));
-    assertNull(nestedSubtitle.getText(Long.MAX_VALUE));
+    assertSingleCueEmpty(nestedSubtitle.getCues(4000000));
+    assertSingleCueEmpty(nestedSubtitle.getCues(4500000));
+    assertSingleCueEmpty(nestedSubtitle.getCues(Long.MAX_VALUE));
   }
 
   private void testSubtitleEventTimesHelper(WebvttSubtitle subtitle) {
@@ -201,4 +227,13 @@ private void testSubtitleEventIndicesHelper(WebvttSubtitle subtitle) {
     assertEquals(-1, subtitle.getNextEventTimeIndex(Long.MAX_VALUE));
   }
 
+  private void assertSingleCueEmpty(List<Cue> cues) {
+    assertTrue(cues.size() == 0);
+  }
+
+  private void assertSingleCueTextEquals(String expected, List<Cue> cues) {
+    assertTrue(cues.size() == 1);
+    assertEquals(expected, cues.get(0).text.toString());
+  }
+
 }
diff --git a/library/src/test/java/com/google/android/exoplayer/util/H264UtilTest.java b/library/src/test/java/com/google/android/exoplayer/util/NalUnitUtilTest.java
similarity index 59%
rename from library/src/test/java/com/google/android/exoplayer/util/H264UtilTest.java
rename to library/src/test/java/com/google/android/exoplayer/util/NalUnitUtilTest.java
index 78bfa0c3fb..0a10c1794c 100644
--- a/library/src/test/java/com/google/android/exoplayer/util/H264UtilTest.java
+++ b/library/src/test/java/com/google/android/exoplayer/util/NalUnitUtilTest.java
@@ -20,9 +20,9 @@
 import java.util.Arrays;
 
 /**
- * Tests for {@link H264Util}.
+ * Tests for {@link NalUnitUtil}.
  */
-public class H264UtilTest extends TestCase {
+public class NalUnitUtilTest extends TestCase {
 
   private static final int TEST_PARTIAL_NAL_POSITION = 4;
   private static final int TEST_NAL_POSITION = 10;
@@ -31,19 +31,19 @@ public void testFindNalUnit() {
     byte[] data = buildTestData();
 
     // Should find NAL unit.
-    int result = H264Util.findNalUnit(data, 0, data.length, null);
+    int result = NalUnitUtil.findNalUnit(data, 0, data.length, null);
     assertEquals(TEST_NAL_POSITION, result);
     // Should find NAL unit whose prefix ends one byte before the limit.
-    result = H264Util.findNalUnit(data, 0, TEST_NAL_POSITION + 4, null);
+    result = NalUnitUtil.findNalUnit(data, 0, TEST_NAL_POSITION + 4, null);
     assertEquals(TEST_NAL_POSITION, result);
     // Shouldn't find NAL unit whose prefix ends at the limit (since the limit is exclusive).
-    result = H264Util.findNalUnit(data, 0, TEST_NAL_POSITION + 3, null);
+    result = NalUnitUtil.findNalUnit(data, 0, TEST_NAL_POSITION + 3, null);
     assertEquals(TEST_NAL_POSITION + 3, result);
     // Should find NAL unit whose prefix starts at the offset.
-    result = H264Util.findNalUnit(data, TEST_NAL_POSITION, data.length, null);
+    result = NalUnitUtil.findNalUnit(data, TEST_NAL_POSITION, data.length, null);
     assertEquals(TEST_NAL_POSITION, result);
     // Shouldn't find NAL unit whose prefix starts one byte past the offset.
-    result = H264Util.findNalUnit(data, TEST_NAL_POSITION + 1, data.length, null);
+    result = NalUnitUtil.findNalUnit(data, TEST_NAL_POSITION + 1, data.length, null);
     assertEquals(data.length, result);
   }
 
@@ -54,9 +54,9 @@ public void testFindNalUnitWithPrefix() {
     boolean[] prefixFlags = new boolean[3];
     byte[] data1 = Arrays.copyOfRange(data, 0, TEST_NAL_POSITION + 1);
     byte[] data2 = Arrays.copyOfRange(data, TEST_NAL_POSITION + 1, data.length);
-    int result = H264Util.findNalUnit(data1, 0, data1.length, prefixFlags);
+    int result = NalUnitUtil.findNalUnit(data1, 0, data1.length, prefixFlags);
     assertEquals(data1.length, result);
-    result = H264Util.findNalUnit(data2, 0, data2.length, prefixFlags);
+    result = NalUnitUtil.findNalUnit(data2, 0, data2.length, prefixFlags);
     assertEquals(-1, result);
     assertPrefixFlagsCleared(prefixFlags);
 
@@ -64,9 +64,9 @@ public void testFindNalUnitWithPrefix() {
     prefixFlags = new boolean[3];
     data1 = Arrays.copyOfRange(data, 0, TEST_NAL_POSITION + 3);
     data2 = Arrays.copyOfRange(data, TEST_NAL_POSITION + 3, data.length);
-    result = H264Util.findNalUnit(data1, 0, data1.length, prefixFlags);
+    result = NalUnitUtil.findNalUnit(data1, 0, data1.length, prefixFlags);
     assertEquals(data1.length, result);
-    result = H264Util.findNalUnit(data2, 0, data2.length, prefixFlags);
+    result = NalUnitUtil.findNalUnit(data2, 0, data2.length, prefixFlags);
     assertEquals(-3, result);
     assertPrefixFlagsCleared(prefixFlags);
 
@@ -75,11 +75,11 @@ public void testFindNalUnitWithPrefix() {
     data1 = Arrays.copyOfRange(data, 0, TEST_NAL_POSITION + 1);
     data2 = Arrays.copyOfRange(data, TEST_NAL_POSITION + 1, TEST_NAL_POSITION + 2);
     byte[] data3 = Arrays.copyOfRange(data, TEST_NAL_POSITION + 2, data.length);
-    result = H264Util.findNalUnit(data1, 0, data1.length, prefixFlags);
+    result = NalUnitUtil.findNalUnit(data1, 0, data1.length, prefixFlags);
     assertEquals(data1.length, result);
-    result = H264Util.findNalUnit(data2, 0, data2.length, prefixFlags);
+    result = NalUnitUtil.findNalUnit(data2, 0, data2.length, prefixFlags);
     assertEquals(data2.length, result);
-    result = H264Util.findNalUnit(data3, 0, data3.length, prefixFlags);
+    result = NalUnitUtil.findNalUnit(data3, 0, data3.length, prefixFlags);
     assertEquals(-2, result);
     assertPrefixFlagsCleared(prefixFlags);
 
@@ -89,13 +89,13 @@ public void testFindNalUnitWithPrefix() {
     data2 = Arrays.copyOfRange(data, TEST_NAL_POSITION + 1, TEST_NAL_POSITION + 2);
     data3 = Arrays.copyOfRange(data, TEST_NAL_POSITION + 2, TEST_NAL_POSITION + 3);
     byte[] data4 = Arrays.copyOfRange(data, TEST_NAL_POSITION + 2, data.length);
-    result = H264Util.findNalUnit(data1, 0, data1.length, prefixFlags);
+    result = NalUnitUtil.findNalUnit(data1, 0, data1.length, prefixFlags);
     assertEquals(data1.length, result);
-    result = H264Util.findNalUnit(data2, 0, data2.length, prefixFlags);
+    result = NalUnitUtil.findNalUnit(data2, 0, data2.length, prefixFlags);
     assertEquals(data2.length, result);
-    result = H264Util.findNalUnit(data3, 0, data3.length, prefixFlags);
+    result = NalUnitUtil.findNalUnit(data3, 0, data3.length, prefixFlags);
     assertEquals(data3.length, result);
-    result = H264Util.findNalUnit(data4, 0, data4.length, prefixFlags);
+    result = NalUnitUtil.findNalUnit(data4, 0, data4.length, prefixFlags);
     assertEquals(-3, result);
     assertPrefixFlagsCleared(prefixFlags);
 
@@ -103,13 +103,25 @@ public void testFindNalUnitWithPrefix() {
     prefixFlags = new boolean[3];
     data1 = Arrays.copyOfRange(data, 0, TEST_PARTIAL_NAL_POSITION + 2);
     data2 = Arrays.copyOfRange(data, TEST_PARTIAL_NAL_POSITION + 2, data.length);
-    result = H264Util.findNalUnit(data1, 0, data1.length, prefixFlags);
+    result = NalUnitUtil.findNalUnit(data1, 0, data1.length, prefixFlags);
     assertEquals(data1.length, result);
-    result = H264Util.findNalUnit(data2, 0, data2.length, prefixFlags);
+    result = NalUnitUtil.findNalUnit(data2, 0, data2.length, prefixFlags);
     assertEquals(4, result);
     assertPrefixFlagsCleared(prefixFlags);
   }
 
+  public void testUnescapeDoesNotModifyBuffersWithoutStartCodes() {
+    assertUnescapeDoesNotModify("");
+    assertUnescapeDoesNotModify("0000");
+    assertUnescapeDoesNotModify("172BF38A3C");
+    assertUnescapeDoesNotModify("000004");
+  }
+
+  public void testUnescapeModifiesBuffersWithStartCodes() {
+    assertUnescapeMatchesExpected("00000301", "000001");
+    assertUnescapeMatchesExpected("0000030200000300", "000002000000");
+  }
+
   private static byte[] buildTestData() {
     byte[] data = new byte[20];
     for (int i = 0; i < data.length; i++) {
@@ -130,4 +142,29 @@ private static void assertPrefixFlagsCleared(boolean[] flags) {
     assertEquals(false, flags[0] || flags[1] || flags[2]);
   }
 
+  private static void assertUnescapeDoesNotModify(String input) {
+    assertUnescapeMatchesExpected(input, input);
+  }
+
+  private static void assertUnescapeMatchesExpected(String input, String expectedOutput) {
+    byte[] bitstream = getByteArrayForHexString(input);
+    byte[] expectedOutputBitstream = getByteArrayForHexString(expectedOutput);
+    int count = NalUnitUtil.unescapeStream(bitstream, bitstream.length);
+    assertEquals(expectedOutputBitstream.length, count);
+    byte[] outputBitstream = new byte[count];
+    System.arraycopy(bitstream, 0, outputBitstream, 0, count);
+    assertTrue(Arrays.equals(expectedOutputBitstream, outputBitstream));
+  }
+
+  private static byte[] getByteArrayForHexString(String hexString) {
+    int length = hexString.length();
+    Assertions.checkArgument(length % 2 == 0);
+    byte[] result = new byte[length / 2];
+    for (int i = 0; i < result.length; i++) {
+      result[i] = (byte) ((Character.digit(hexString.charAt(i * 2), 16) << 4)
+          + Character.digit(hexString.charAt(i * 2 + 1), 16));
+    }
+    return result;
+  }
+
 }
diff --git a/library/src/test/java/com/google/android/exoplayer/util/UtilTest.java b/library/src/test/java/com/google/android/exoplayer/util/UtilTest.java
index 351e93c339..00d4a60fe4 100644
--- a/library/src/test/java/com/google/android/exoplayer/util/UtilTest.java
+++ b/library/src/test/java/com/google/android/exoplayer/util/UtilTest.java
@@ -53,7 +53,7 @@ public void testArrayBinarySearchFloor() {
   }
 
   public void testListBinarySearchFloor() {
-    List<Integer> values = new ArrayList<Integer>();
+    List<Integer> values = new ArrayList<>();
     assertEquals(-1, Util.binarySearchFloor(values, 0, false, false));
     assertEquals(0, Util.binarySearchFloor(values, 0, false, true));
 
@@ -107,7 +107,7 @@ public void testArrayBinarySearchCeil() {
   }
 
   public void testListBinarySearchCeil() {
-    List<Integer> values = new ArrayList<Integer>();
+    List<Integer> values = new ArrayList<>();
     assertEquals(0, Util.binarySearchCeil(values, 0, false, false));
     assertEquals(-1, Util.binarySearchCeil(values, 0, false, true));
 
diff --git a/library/src/test/project.properties b/library/src/test/project.properties
index 00cf62bacc..0031332ec9 100644
--- a/library/src/test/project.properties
+++ b/library/src/test/project.properties
@@ -12,3 +12,5 @@
 
 # Project target.
 target=android-22
+android.library=false
+android.library.reference.1=../main
diff --git a/settings.gradle b/settings.gradle
index 63dd803377..7441d135d4 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -13,3 +13,10 @@
 // limitations under the License.
 include ':library'
 include ':demo'
+include ':opus-extension'
+include ':vp9-extension'
+include ':webm-sw-demo'
+
+project(':opus-extension').projectDir = new File(settingsDir, 'extensions/opus')
+project(':vp9-extension').projectDir = new File(settingsDir, 'extensions/vp9')
+project(':webm-sw-demo').projectDir = new File(settingsDir, 'demo_misc/webm_sw_decoder')
