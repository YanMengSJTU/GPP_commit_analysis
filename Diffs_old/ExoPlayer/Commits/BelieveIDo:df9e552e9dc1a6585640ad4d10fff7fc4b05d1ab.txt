diff --git a/build.gradle b/build.gradle
index 4cf5e94806..2864587d3f 100644
--- a/build.gradle
+++ b/build.gradle
@@ -17,9 +17,11 @@
 buildscript {
     repositories {
         mavenCentral()
+        jcenter()
     }
     dependencies {
         classpath 'com.android.tools.build:gradle:1.0.0'
+        classpath 'com.novoda:bintray-release:0.2.7'
     }
 }
 
diff --git a/demo/src/main/AndroidManifest.xml b/demo/src/main/AndroidManifest.xml
index 8737b25a7a..39588b6fc9 100644
--- a/demo/src/main/AndroidManifest.xml
+++ b/demo/src/main/AndroidManifest.xml
@@ -16,8 +16,8 @@
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer.demo"
-    android:versionCode="1203"
-    android:versionName="1.2.3"
+    android:versionCode="1204"
+    android:versionName="1.2.4"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
diff --git a/library/build.gradle b/library/build.gradle
index 7c66a11161..417d627767 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -12,6 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 apply plugin: 'com.android.library'
+apply plugin: 'bintray-release'
 
 android {
     compileSdkVersion 21
@@ -47,3 +48,13 @@ android.libraryVariants.all { variant ->
     task.from variant.javaCompile.destinationDir
     artifacts.add('archives', task);
 }
+
+publish {
+    repoName = 'exoplayer'
+    userOrg = 'google'
+    groupId = 'com.google.android.exoplayer'
+    artifactId = 'exoplayer'
+    version = 'r1.2.4'
+    description = 'The ExoPlayer library.'
+    website = 'https://github.com/google/ExoPlayer'
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
index e2e620d1ff..30ee20645b 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
@@ -26,7 +26,7 @@ private ExoPlayerLibraryInfo() {}
   /**
    * The version of the library, expressed as a string.
    */
-  public static final String VERSION = "1.2.3";
+  public static final String VERSION = "1.2.4";
 
   /**
    * The version of the library, expressed as an integer.
@@ -34,7 +34,7 @@ private ExoPlayerLibraryInfo() {}
    * Three digits are used for each component of {@link #VERSION}. For example "1.2.3" has the
    * corresponding integer version 001002003.
    */
-  public static final int VERSION_INT = 001002003;
+  public static final int VERSION_INT = 001002004;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer.util.Assertions}
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/ContentProtection.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/ContentProtection.java
index c8f7cfb501..d0aec44861 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/ContentProtection.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/ContentProtection.java
@@ -15,6 +15,9 @@
  */
 package com.google.android.exoplayer.dash.mpd;
 
+import com.google.android.exoplayer.util.Util;
+
+import java.util.Arrays;
 import java.util.UUID;
 
 /**
@@ -48,4 +51,33 @@ public ContentProtection(String schemeUriId, UUID uuid, byte[] data) {
     this.data = data;
   }
 
+  @Override
+  public boolean equals(Object obj) {
+    if (!(obj instanceof ContentProtection)) {
+      return false;
+    }
+    if (obj == this) {
+      return true;
+    }
+
+    ContentProtection other = (ContentProtection) obj;
+    return schemeUriId.equals(other.schemeUriId)
+        && Util.areEqual(uuid, other.uuid)
+        && Arrays.equals(data, other.data);
+  }
+
+  @Override
+  public int hashCode() {
+    int hashCode = 1;
+
+    hashCode = hashCode * 37 + schemeUriId.hashCode();
+    if (uuid != null) {
+      hashCode = hashCode * 37 + uuid.hashCode();
+    }
+    if (data != null) {
+      hashCode = hashCode * 37 + Arrays.hashCode(data);
+    }
+    return hashCode;
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
index 67806bbb68..7135b77829 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
@@ -38,6 +38,8 @@
 import java.io.InputStream;
 import java.text.ParseException;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
 import java.util.List;
 
 /**
@@ -165,24 +167,22 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String contentId,
     int contentType = parseAdaptationSetTypeFromMimeType(mimeType);
 
     int id = -1;
-    List<ContentProtection> contentProtections = null;
+    ContentProtectionsBuilder contentProtectionsBuilder = new ContentProtectionsBuilder();
     List<Representation> representations = new ArrayList<Representation>();
     do {
       xpp.next();
       if (isStartTag(xpp, "BaseURL")) {
         baseUrl = parseBaseUrl(xpp, baseUrl);
       } else if (isStartTag(xpp, "ContentProtection")) {
-        if (contentProtections == null) {
-          contentProtections = new ArrayList<ContentProtection>();
-        }
-        contentProtections.add(parseContentProtection(xpp));
+        contentProtectionsBuilder.addAdaptationSetProtection(parseContentProtection(xpp));
       } else if (isStartTag(xpp, "ContentComponent")) {
         id = Integer.parseInt(xpp.getAttributeValue(null, "id"));
         contentType = checkAdaptationSetTypeConsistency(contentType,
             parseAdaptationSetType(xpp.getAttributeValue(null, "contentType")));
       } else if (isStartTag(xpp, "Representation")) {
         Representation representation = parseRepresentation(xpp, contentId, baseUrl, periodStartMs,
-            periodDurationMs, mimeType, language, segmentBase);
+            periodDurationMs, mimeType, language, segmentBase, contentProtectionsBuilder);
+        contentProtectionsBuilder.endRepresentation();
         contentType = checkAdaptationSetTypeConsistency(contentType,
             parseAdaptationSetTypeFromMimeType(representation.format.mimeType));
         representations.add(representation);
@@ -198,7 +198,7 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String contentId,
       }
     } while (!isEndTag(xpp, "AdaptationSet"));
 
-    return buildAdaptationSet(id, contentType, representations, contentProtections);
+    return buildAdaptationSet(id, contentType, representations, contentProtectionsBuilder.build());
   }
 
   protected AdaptationSet buildAdaptationSet(int id, int contentType,
@@ -276,7 +276,8 @@ protected void parseAdaptationSetChild(XmlPullParser xpp)
 
   protected Representation parseRepresentation(XmlPullParser xpp, String contentId, Uri baseUrl,
       long periodStartMs, long periodDurationMs, String mimeType, String language,
-      SegmentBase segmentBase) throws XmlPullParserException, IOException {
+      SegmentBase segmentBase, ContentProtectionsBuilder contentProtectionsBuilder)
+      throws XmlPullParserException, IOException {
     String id = xpp.getAttributeValue(null, "id");
     int bandwidth = parseInt(xpp, "bandwidth");
     int audioSamplingRate = parseInt(xpp, "audioSamplingRate");
@@ -299,6 +300,8 @@ protected Representation parseRepresentation(XmlPullParser xpp, String contentId
       } else if (isStartTag(xpp, "SegmentTemplate")) {
         segmentBase = parseSegmentTemplate(xpp, baseUrl, (SegmentTemplate) segmentBase,
             periodDurationMs);
+      } else if (isStartTag(xpp, "ContentProtection")) {
+        contentProtectionsBuilder.addRepresentationProtection(parseContentProtection(xpp));
       }
     } while (!isEndTag(xpp, "Representation"));
 
@@ -569,4 +572,120 @@ protected static String parseString(XmlPullParser xpp, String name, String defau
     return value == null ? defaultValue : value;
   }
 
+  /**
+   * Builds a list of {@link ContentProtection} elements for an {@link AdaptationSet}.
+   * <p>
+   * If child Representation elements contain ContentProtection elements, then it is required that
+   * they all define the same ones. If they do, the ContentProtection elements are bubbled up to the
+   * AdaptationSet. Child Representation elements defining different ContentProtection elements is
+   * considered an error.
+   */
+  protected static final class ContentProtectionsBuilder implements Comparator<ContentProtection> {
+
+    private ArrayList<ContentProtection> adaptationSetProtections;
+    private ArrayList<ContentProtection> representationProtections;
+    private ArrayList<ContentProtection> currentRepresentationProtections;
+
+    private boolean representationProtectionsSet;
+
+    /**
+     * Adds a {@link ContentProtection} found in the AdaptationSet element.
+     *
+     * @param contentProtection The {@link ContentProtection} to add.
+     */
+    public void addAdaptationSetProtection(ContentProtection contentProtection) {
+      if (adaptationSetProtections == null) {
+        adaptationSetProtections = new ArrayList<ContentProtection>();
+      }
+      maybeAddContentProtection(adaptationSetProtections, contentProtection);
+    }
+
+    /**
+     * Adds a {@link ContentProtection} found in a child Representation element.
+     *
+     * @param contentProtection The {@link ContentProtection} to add.
+     */
+    public void addRepresentationProtection(ContentProtection contentProtection) {
+      if (currentRepresentationProtections == null) {
+        currentRepresentationProtections = new ArrayList<ContentProtection>();
+      }
+      maybeAddContentProtection(currentRepresentationProtections, contentProtection);
+    }
+
+    /**
+     * Should be invoked after processing each child Representation element, in order to apply
+     * consistency checks.
+     */
+    public void endRepresentation() {
+      if (!representationProtectionsSet) {
+        if (currentRepresentationProtections != null) {
+          Collections.sort(currentRepresentationProtections, this);
+        }
+        representationProtections = currentRepresentationProtections;
+        representationProtectionsSet = true;
+      } else {
+        // Assert that each Representation element defines the same ContentProtection elements.
+        if (currentRepresentationProtections == null) {
+          Assertions.checkState(representationProtections == null);
+        } else {
+          Collections.sort(currentRepresentationProtections, this);
+          Assertions.checkState(currentRepresentationProtections.equals(representationProtections));
+        }
+      }
+      currentRepresentationProtections = null;
+    }
+
+    /**
+     * Returns the final list of consistent {@link ContentProtection} elements.
+     */
+    public ArrayList<ContentProtection> build() {
+      if (adaptationSetProtections == null) {
+        return representationProtections;
+      } else if (representationProtections == null) {
+        return adaptationSetProtections;
+      } else {
+        // Bubble up ContentProtection elements found in the child Representation elements.
+        for (int i = 0; i < representationProtections.size(); i++) {
+          maybeAddContentProtection(adaptationSetProtections, representationProtections.get(i));
+        }
+        return adaptationSetProtections;
+      }
+    }
+
+    /**
+     * Checks a ContentProtection for consistency with the given list, adding it if necessary.
+     * <ul>
+     * <li>If the new ContentProtection matches another in the list, it's consistent and is not
+     *     added to the list.
+     * <li>If the new ContentProtection has the same schemeUriId as another ContentProtection in the
+     *     list, but its other attributes do not match, then it's inconsistent and an
+     *     {@link IllegalStateException} is thrown.
+     * <li>Else the new ContentProtection has a unique schemeUriId, it's consistent and is added.
+     * </ul>
+     *
+     * @param contentProtections The list of ContentProtection elements currently known.
+     * @param contentProtection The ContentProtection to add.
+     */
+    private void maybeAddContentProtection(List<ContentProtection> contentProtections,
+        ContentProtection contentProtection) {
+      if (!contentProtections.contains(contentProtection)) {
+        for (int i = 0; i < contentProtections.size(); i++) {
+          // If contains returned false (no complete match), but find a matching schemeUriId, then
+          // the MPD contains inconsistent ContentProtection data.
+          Assertions.checkState(
+              !contentProtections.get(i).schemeUriId.equals(contentProtection.schemeUriId));
+        }
+        contentProtections.add(contentProtection);
+      }
+    }
+
+    // Comparator implementation.
+
+    @Override
+    public int compare(ContentProtection first, ContentProtection second) {
+      return first.schemeUriId.compareTo(second.schemeUriId);
+    }
+
+  }
+
 }
