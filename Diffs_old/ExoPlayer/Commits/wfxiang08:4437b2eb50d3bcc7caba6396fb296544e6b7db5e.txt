diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java b/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
index a2a6a7e6ca..f5244a72b4 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
@@ -275,12 +275,18 @@ private void initializePlayer() {
               : SimpleExoPlayer.EXTENSION_RENDERER_MODE_OFF;
 
 
+      // 自适应的TrackSelector算法
       TrackSelection.Factory videoTrackSelectionFactory =
           new AdaptiveVideoTrackSelection.Factory(BANDWIDTH_METER);
+
+      // 作为一个Component来注入
       trackSelector = new DefaultTrackSelector(videoTrackSelectionFactory);
+
+
       trackSelectionHelper = new TrackSelectionHelper(trackSelector, videoTrackSelectionFactory);
 
 
+      // LoadControl策略的依赖注入
       player = ExoPlayerFactory.newSimpleInstance(this, trackSelector, new DefaultLoadControl(),
           drmSessionManager, extensionRendererMode);
       player.addListener(this);
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java b/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java
index ee4fb12d80..7346a238a3 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java
@@ -43,6 +43,7 @@
 
 /**
  * Helper class for displaying track selection dialogs.
+ *
  */
 final class TrackSelectionHelper implements View.OnClickListener,
     DialogInterface.OnClickListener {
diff --git a/library/src/main/java/com/google/android/exoplayer2/C.java b/library/src/main/java/com/google/android/exoplayer2/C.java
index 88d7b837bf..86a661ea96 100644
--- a/library/src/main/java/com/google/android/exoplayer2/C.java
+++ b/library/src/main/java/com/google/android/exoplayer2/C.java
@@ -27,6 +27,7 @@
 
 /**
  * Defines constants used by the library.
+ * 定义各种常量
  */
 public final class C {
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java b/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
index e6a39d8a27..ee8c6f4343 100644
--- a/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
+++ b/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
@@ -23,6 +23,7 @@
 
 /**
  * The default {@link LoadControl} implementation.
+ * 注意这个策略，也许服务器的ts做了很多优化，但是最终不符合Cache管理策略，最终失败
  */
 public final class DefaultLoadControl implements LoadControl {
 
@@ -40,6 +41,8 @@
   /**
    * The default duration of media that must be buffered for playback to start or resume following a
    * user action such as a seek, in milliseconds.
+   *
+   * 至少需要Buffer 2.5s, 如果ts文件太小，则不符合这个要求
    */
   public static final int DEFAULT_BUFFER_FOR_PLAYBACK_MS = 2500;
 
@@ -50,6 +53,7 @@
    */
   public static final int DEFAULT_BUFFER_FOR_PLAYBACK_AFTER_REBUFFER_MS  = 5000;
 
+  // 当前Buffer的情况
   private static final int ABOVE_HIGH_WATERMARK = 0;
   private static final int BETWEEN_WATERMARKS = 1;
   private static final int BELOW_LOW_WATERMARK = 2;
@@ -98,9 +102,22 @@ public DefaultLoadControl(DefaultAllocator allocator) {
   public DefaultLoadControl(DefaultAllocator allocator, int minBufferMs, int maxBufferMs,
       long bufferForPlaybackMs, long bufferForPlaybackAfterRebufferMs) {
     this.allocator = allocator;
+
+    // 15s
     minBufferUs = minBufferMs * 1000L;
+    // 30s
     maxBufferUs = maxBufferMs * 1000L;
+
+    // 2.5s
     bufferForPlaybackUs = bufferForPlaybackMs * 1000L;
+
+    // 几个常数之间的关系:
+    // bufferForPlaybackUs 达到了就可以播放; 但是如果cache时间小于 minBufferUs, 则认为是 BELOW_LOW_WATERMARK 需要不管下载数据
+    // 如果 >= maxBufferUs, 则认为比较安全，可以暂停下载；如果在两者之间BETWEEN_WATERMARKS，则遵循"惯性"原则
+
+
+    // rebuffering 是什么概念呢?
+    // 5s
     bufferForPlaybackAfterRebufferUs = bufferForPlaybackAfterRebufferMs * 1000L;
   }
 
@@ -112,6 +129,8 @@ public void onPrepared() {
   @Override
   public void onTracksSelected(Renderer[] renderers, TrackGroupArray trackGroups,
       TrackSelectionArray trackSelections) {
+
+    // 确保: allocator中有足够的内存
     targetBufferSize = 0;
     for (int i = 0; i < renderers.length; i++) {
       if (trackSelections.get(i) != null) {
@@ -138,14 +157,23 @@ public Allocator getAllocator() {
 
   @Override
   public boolean shouldStartPlayback(long bufferedDurationUs, boolean rebuffering) {
+    // 是否开始Playback?
     long minBufferDurationUs = rebuffering ? bufferForPlaybackAfterRebufferUs : bufferForPlaybackUs;
+
+    // 如果不要求Buffer, 或者达到Buffer的要求，则开始播放
     return minBufferDurationUs <= 0 || bufferedDurationUs >= minBufferDurationUs;
   }
 
   @Override
   public boolean shouldContinueLoading(long bufferedDurationUs) {
+    // 当前的数据必须至少Cache 2.5s还开始播放
+    // 1. 当前Buffer的数据的时长: bufferedDurationUs
     int bufferTimeState = getBufferTimeState(bufferedDurationUs);
+
     boolean targetBufferSizeReached = allocator.getTotalBytesAllocated() >= targetBufferSize;
+
+    // 如果数据缓存: BELOW_LOW_WATERMARK
+    //             BETWEEN_WATERMARKS，并还有足够的空间，并且之前在Buffering, 则就继续
     isBuffering = bufferTimeState == BELOW_LOW_WATERMARK
         || (bufferTimeState == BETWEEN_WATERMARKS && isBuffering && !targetBufferSizeReached);
     return isBuffering;
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
index 88ad0c1137..1038d82b9e 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
@@ -117,6 +117,7 @@ public static SimpleExoPlayer newSimpleInstance(Context context, TrackSelector t
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    */
   public static ExoPlayer newInstance(Renderer[] renderers, TrackSelector trackSelector) {
+    // 使用默认的LoadControl
     return newInstance(renderers, trackSelector, new DefaultLoadControl());
   }
 
@@ -130,6 +131,7 @@ public static ExoPlayer newInstance(Renderer[] renderers, TrackSelector trackSel
    */
   public static ExoPlayer newInstance(Renderer[] renderers, TrackSelector trackSelector,
       LoadControl loadControl) {
+
     // 这个实现和 SimpleExoPlayer 关系?
     return new ExoPlayerImpl(renderers, trackSelector, loadControl);
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
index 545c86b142..19686f7551 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
@@ -96,6 +96,7 @@ public ExoPlayerImpl(Renderer[] renderers, TrackSelector trackSelector, LoadCont
     period = new Timeline.Period();
     trackGroups = TrackGroupArray.EMPTY;
     trackSelections = emptyTrackSelections;
+
     eventHandler = new Handler() {
       @Override
       public void handleMessage(Message msg) {
@@ -103,6 +104,8 @@ public void handleMessage(Message msg) {
       }
     };
     playbackInfo = new ExoPlayerImplInternal.PlaybackInfo(0, 0);
+
+    // 初始的状态
     internalPlayer = new ExoPlayerImplInternal(renderers, trackSelector, loadControl, playWhenReady,
             eventHandler, playbackInfo, this);
   }
@@ -122,14 +125,17 @@ public int getPlaybackState() {
     return playbackState;
   }
 
+  // 开始准备播放
   @Override
   public void prepare(MediaSource mediaSource) {
     prepare(mediaSource, true, true);
   }
 
+  // 开始准备播放
   @Override
   public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
     if (resetState) {
+      // 重置状态
       if (!timeline.isEmpty() || manifest != null) {
         timeline = Timeline.EMPTY;
         manifest = null;
@@ -149,6 +155,8 @@ public void prepare(MediaSource mediaSource, boolean resetPosition, boolean rese
     }
 
     // 内部播放器
+    // 例如: HlsMediaSource
+    //
     internalPlayer.prepare(mediaSource, resetPosition);
   }
 
@@ -157,6 +165,8 @@ public void setPlayWhenReady(boolean playWhenReady) {
     if (this.playWhenReady != playWhenReady) {
       this.playWhenReady = playWhenReady;
       internalPlayer.setPlayWhenReady(playWhenReady);
+
+      // 通知listeners
       for (EventListener listener : listeners) {
         listener.onPlayerStateChanged(playWhenReady, playbackState);
       }
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
index 00bd6a5b17..fb430a40a7 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
@@ -214,12 +214,16 @@ public ExoPlayerImplInternal(Renderer[] renderers, TrackSelector trackSelector,
     handler = new Handler(internalPlaybackThread.getLooper(), this);
   }
 
+  //
+  // MediaSource 有外部程序准备，例如:
+  //
   public void prepare(MediaSource mediaSource, boolean resetPosition) {
     handler.obtainMessage(MSG_PREPARE, resetPosition ? 1 : 0, 0, mediaSource)
             .sendToTarget();
   }
 
   public void setPlayWhenReady(boolean playWhenReady) {
+    // 开始播放
     handler.obtainMessage(MSG_SET_PLAY_WHEN_READY, playWhenReady ? 1 : 0, 0).sendToTarget();
   }
 
@@ -306,6 +310,7 @@ public boolean handleMessage(Message msg) {
     try {
       switch (msg.what) {
         case MSG_PREPARE: {
+          // 通过消息减少调用混乱
           prepareInternal((MediaSource) msg.obj, msg.arg1 != 0);
           return true;
         }
@@ -389,14 +394,18 @@ private void setIsLoading(boolean isLoading) {
 
   private void prepareInternal(MediaSource mediaSource, boolean resetPosition) {
     resetInternal(true);
+
+    // 清空loadControl的状态
     loadControl.onPrepared();
     if (resetPosition) {
       playbackInfo = new PlaybackInfo(0, C.TIME_UNSET);
     }
+
     // 内部准备
     // 设置mediaSource
     this.mediaSource = mediaSource;
     mediaSource.prepareSource(player, true, this);
+
     setState(ExoPlayer.STATE_BUFFERING);
     handler.sendEmptyMessage(MSG_DO_SOME_WORK);
   }
@@ -404,14 +413,17 @@ private void prepareInternal(MediaSource mediaSource, boolean resetPosition) {
   private void setPlayWhenReadyInternal(boolean playWhenReady) throws ExoPlaybackException {
     rebuffering = false;
     this.playWhenReady = playWhenReady;
+
     if (!playWhenReady) {
       stopRenderers();
       updatePlaybackPositions();
     } else {
+      // 如果Reader，则开始Renders
       if (state == ExoPlayer.STATE_READY) {
         startRenderers();
         handler.sendEmptyMessage(MSG_DO_SOME_WORK);
       } else if (state == ExoPlayer.STATE_BUFFERING) {
+
         handler.sendEmptyMessage(MSG_DO_SOME_WORK);
       }
     }
@@ -1288,10 +1300,15 @@ private void handleContinueLoadingRequested(MediaPeriod period) {
     maybeContinueLoading();
   }
 
+  // 播放器是否继续加载数据呢?
   private void maybeContinueLoading() {
+
     long nextLoadPositionUs = !loadingPeriodHolder.prepared ? 0
             : loadingPeriodHolder.mediaPeriod.getNextLoadPositionUs();
+
+
     if (nextLoadPositionUs == C.TIME_END_OF_SOURCE) {
+      // 文件加载完毕，则停止loading
       setIsLoading(false);
     } else {
       long loadingPeriodPositionUs = loadingPeriodHolder.toPeriodTime(rendererPositionUs);
@@ -1434,6 +1451,7 @@ public MediaPeriodHolder(Renderer[] renderers, RendererCapabilities[] rendererCa
       this.startPositionUs = startPositionUs;
       sampleStreams = new SampleStream[renderers.length];
       mayRetainStreamFlags = new boolean[renderers.length];
+
       mediaPeriod = mediaSource.createPeriod(periodIndex, loadControl.getAllocator(),
               startPositionUs);
     }
diff --git a/library/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java b/library/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
index 6871e20fb6..b590e90dd2 100644
--- a/library/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
@@ -57,6 +57,8 @@
 /**
  * An {@link ExoPlayer} implementation that uses default {@link Renderer} components. Instances can
  * be obtained from {@link ExoPlayerFactory}.
+ *
+ * SimpleExoPlayer vs. ExoPlayerImpl 两者的关系是什么样的呢?
  */
 @TargetApi(16)
 public class SimpleExoPlayer implements ExoPlayer {
@@ -135,8 +137,10 @@ void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
 
   private Surface surface;
   private boolean ownsSurface;
+
   @C.VideoScalingMode
-  private int videoScalingMode;
+  private int videoScalingMode; // 视频播放如何Scale?
+
   private SurfaceHolder surfaceHolder;
   private TextureView textureView;
   private TextRenderer.Output textOutput;
@@ -147,8 +151,10 @@ void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
   private DecoderCounters videoDecoderCounters;
   private DecoderCounters audioDecoderCounters;
   private int audioSessionId;
+
   @C.StreamType
   private int audioStreamType;
+
   private float audioVolume;
   private PlaybackParamsHolder playbackParamsHolder;
 
@@ -164,6 +170,8 @@ protected SimpleExoPlayer(Context context, TrackSelector trackSelector, LoadCont
     ArrayList<Renderer> renderersList = new ArrayList<>();
     buildRenderers(context, mainHandler, drmSessionManager, extensionRendererMode,
             allowedVideoJoiningTimeMs, renderersList);
+
+    // 这些Renders是否都是必须的呢?
     renderers = renderersList.toArray(new Renderer[renderersList.size()]);
 
     // 获取video/audio renders的数量
@@ -191,6 +199,8 @@ protected SimpleExoPlayer(Context context, TrackSelector trackSelector, LoadCont
 
     // Build the player and associated objects.
     // 实际的播放器，其他的工作都是为player准备
+    // trackSelector 选择Track的策略
+    // loadControl 流量控制策略
     player = new ExoPlayerImpl(renderers, trackSelector, loadControl);
   }
 
@@ -669,6 +679,7 @@ protected void buildVideoRenderers(Context context, Handler mainHandler,
                                      VideoRendererEventListener eventListener,
                                      long allowedVideoJoiningTimeMs, ArrayList<Renderer> out) {
 
+    // 默认的Render
     out.add(new MediaCodecVideoRenderer(context, MediaCodecSelector.DEFAULT,
             allowedVideoJoiningTimeMs, drmSessionManager, false, mainHandler, eventListener,
             MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY));
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorInput.java b/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorInput.java
index bca5ecf3bd..8d26a960a0 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorInput.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorInput.java
@@ -44,13 +44,19 @@
    */
   public DefaultExtractorInput(DataSource dataSource, long position, long length) {
     this.dataSource = dataSource;
+
+    // 从dataSource指定的区域读取数据
     this.position = position;
     this.streamLength = length;
+
+    // 8k的Buffer
     peekBuffer = new byte[8 * 1024];
   }
 
   @Override
   public int read(byte[] target, int offset, int length) throws IOException, InterruptedException {
+    // 首选从peekBuffer读取数据
+    // 如果读取失败，在从DataSource读取数据
     int bytesRead = readFromPeekBuffer(target, offset, length);
     if (bytesRead == 0) {
       bytesRead = readFromDataSource(target, offset, length, 0, true);
@@ -62,10 +68,13 @@ public int read(byte[] target, int offset, int length) throws IOException, Inter
   @Override
   public boolean readFully(byte[] target, int offset, int length, boolean allowEndOfInput)
       throws IOException, InterruptedException {
+
+    // 尽量保证length读取完毕
     int bytesRead = readFromPeekBuffer(target, offset, length);
     while (bytesRead < length && bytesRead != C.RESULT_END_OF_INPUT) {
       bytesRead = readFromDataSource(target, offset, length, bytesRead, allowEndOfInput);
     }
+
     commitBytesRead(bytesRead);
     return bytesRead != C.RESULT_END_OF_INPUT;
   }
@@ -123,7 +132,11 @@ public void peekFully(byte[] target, int offset, int length)
   @Override
   public boolean advancePeekPosition(int length, boolean allowEndOfInput)
       throws IOException, InterruptedException {
+
+    // 确保peekBuffer足够大
     ensureSpaceForPeek(length);
+
+    // 读取足够多的数据到peekBuffer中
     int bytesPeeked = Math.min(peekBufferLength - peekBufferPosition, length);
     while (bytesPeeked < length) {
       bytesPeeked = readFromDataSource(peekBuffer, peekBufferPosition, length, bytesPeeked,
@@ -218,6 +231,8 @@ private int readFromPeekBuffer(byte[] target, int offset, int length) {
   private void updatePeekBuffer(int bytesConsumed) {
     peekBufferLength -= bytesConsumed;
     peekBufferPosition = 0;
+
+    // 将peekBuffer整理好
     System.arraycopy(peekBuffer, bytesConsumed, peekBuffer, 0, peekBufferLength);
   }
 
@@ -251,6 +266,8 @@ private int readFromDataSource(byte[] target, int offset, int length, int bytesA
       }
       throw new EOFException();
     }
+
+    // 返回已经读取的数据
     return bytesAlreadyRead + bytesRead;
   }
 
@@ -260,6 +277,7 @@ private int readFromDataSource(byte[] target, int offset, int length, int bytesA
    * @param bytesRead The number of bytes read.
    */
   private void commitBytesRead(int bytesRead) {
+    // 更新position
     if (bytesRead != C.RESULT_END_OF_INPUT) {
       position += bytesRead;
     }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java
index 38b0325cba..f607aa4758 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java
@@ -20,6 +20,11 @@
 
 /**
  * Extracts media data from a container format.
+ * 用于处理不同容器(Container Format), 识别不同的文件格式
+ * 关注:
+ *    mp4 Extractor, 是否支持Range Request呢? 这样是否直接跳过ts这个技术呢？
+ *    ts Extractor
+ *    Mp4Extractor
  */
 public interface Extractor {
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Sniffer.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Sniffer.java
index 44d5824945..61568f1eb7 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Sniffer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Sniffer.java
@@ -70,6 +70,7 @@
    */
   public static boolean sniffFragmented(ExtractorInput input)
       throws IOException, InterruptedException {
+    // Peek数据，看是否为mp4格式
     return sniffInternal(input, true);
   }
 
@@ -89,6 +90,7 @@ public static boolean sniffUnfragmented(ExtractorInput input)
 
   private static boolean sniffInternal(ExtractorInput input, boolean fragmented)
       throws IOException, InterruptedException {
+
     long inputLength = input.getLength();
     int bytesToSearch = (int) (inputLength == C.LENGTH_UNSET || inputLength > SEARCH_LENGTH
         ? SEARCH_LENGTH : inputLength);
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
index bf5adac500..b806da8c48 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
@@ -128,6 +128,7 @@ public TsExtractor(TimestampAdjuster timestampAdjuster,
   public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
     byte[] buffer = tsPacketBuffer.data;
     input.peekFully(buffer, 0, BUFFER_SIZE);
+
     for (int j = 0; j < TS_PACKET_SIZE; j++) {
       for (int i = 0; true; i++) {
         if (i == BUFFER_PACKET_COUNT) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
index 68552c99ed..f08201329a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
@@ -29,6 +29,8 @@
 /**
  * Concatenates multiple {@link MediaSource}s. It is valid for the same {@link MediaSource} instance
  * to be present more than once in the concatenation.
+ *
+ * 多个MediaSource的合并（Concatenates)
  */
 public final class ConcatenatingMediaSource implements MediaSource {
 
@@ -47,6 +49,8 @@
    */
   public ConcatenatingMediaSource(MediaSource... mediaSources) {
     this.mediaSources = mediaSources;
+
+    // 时间上有先后关系，多个MediaSource的合并
     timelines = new Timeline[mediaSources.length];
     manifests = new Object[mediaSources.length];
     sourceIndexByMediaPeriod = new HashMap<>();
@@ -56,6 +60,8 @@ public ConcatenatingMediaSource(MediaSource... mediaSources) {
   @Override
   public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
     this.listener = listener;
+
+    // 每个MediaSources单独准备
     for (int i = 0; i < mediaSources.length; i++) {
       if (!duplicateFlags[i]) {
         final int index = i;
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/Aes128DataSource.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/Aes128DataSource.java
index 142b846a97..21274c3919 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/Aes128DataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/Aes128DataSource.java
@@ -16,17 +16,20 @@
 package com.google.android.exoplayer2.source.hls;
 
 import android.net.Uri;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSourceInputStream;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.util.Assertions;
+
 import java.io.IOException;
 import java.security.InvalidAlgorithmParameterException;
 import java.security.InvalidKeyException;
 import java.security.Key;
 import java.security.NoSuchAlgorithmException;
 import java.security.spec.AlgorithmParameterSpec;
+
 import javax.crypto.Cipher;
 import javax.crypto.CipherInputStream;
 import javax.crypto.NoSuchPaddingException;
@@ -41,7 +44,8 @@
  * designed specifically for reading whole files as defined in an HLS media playlist. For this
  * reason the implementation is private to the HLS package.
  */
-/* package */ final class Aes128DataSource implements DataSource {
+/* package */
+final class Aes128DataSource implements DataSource {
 
   private final DataSource upstream;
   private final byte[] encryptionKey;
@@ -50,9 +54,9 @@
   private CipherInputStream cipherInputStream;
 
   /**
-   * @param upstream The upstream {@link DataSource}.
+   * @param upstream      The upstream {@link DataSource}.
    * @param encryptionKey The encryption key.
-   * @param encryptionIv The encryption initialization vector.
+   * @param encryptionIv  The encryption initialization vector.
    */
   public Aes128DataSource(DataSource upstream, byte[] encryptionKey, byte[] encryptionIv) {
     this.upstream = upstream;
@@ -79,7 +83,7 @@ public long open(DataSpec dataSpec) throws IOException {
     }
 
     cipherInputStream = new CipherInputStream(
-        new DataSourceInputStream(upstream, dataSpec), cipher);
+            new DataSourceInputStream(upstream, dataSpec), cipher);
 
     return C.LENGTH_UNSET;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
index f9dba14e0e..960edf9e4a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.source.hls;
 
 import android.text.TextUtils;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.DefaultExtractorInput;
@@ -38,18 +39,20 @@
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
+
 import java.io.IOException;
 import java.util.concurrent.atomic.AtomicInteger;
 
 /**
  * An HLS {@link MediaChunk}.
  */
-/* package */ final class HlsMediaChunk extends MediaChunk {
+/* package */
+final class HlsMediaChunk extends MediaChunk {
 
   private static final AtomicInteger UID_SOURCE = new AtomicInteger();
 
   private static final String PRIV_TIMESTAMP_FRAME_OWNER =
-      "com.apple.streaming.transportStreamTimestamp";
+          "com.apple.streaming.transportStreamTimestamp";
 
   private static final String AAC_FILE_EXTENSION = ".aac";
   private static final String AC3_FILE_EXTENSION = ".ac3";
@@ -95,29 +98,29 @@
   private volatile boolean loadCompleted;
 
   /**
-   * @param dataSource The source from which the data should be loaded.
-   * @param dataSpec Defines the data to be loaded.
-   * @param initDataSpec Defines the initialization data to be fed to new extractors. May be null.
-   * @param hlsUrl The url of the playlist from which this chunk was obtained.
-   * @param trackSelectionReason See {@link #trackSelectionReason}.
-   * @param trackSelectionData See {@link #trackSelectionData}.
-   * @param startTimeUs The start time of the chunk in microseconds.
-   * @param endTimeUs The end time of the chunk in microseconds.
-   * @param chunkIndex The media sequence number of the chunk.
+   * @param dataSource                  The source from which the data should be loaded.
+   * @param dataSpec                    Defines the data to be loaded.
+   * @param initDataSpec                Defines the initialization data to be fed to new extractors. May be null.
+   * @param hlsUrl                      The url of the playlist from which this chunk was obtained.
+   * @param trackSelectionReason        See {@link #trackSelectionReason}.
+   * @param trackSelectionData          See {@link #trackSelectionData}.
+   * @param startTimeUs                 The start time of the chunk in microseconds.
+   * @param endTimeUs                   The end time of the chunk in microseconds.
+   * @param chunkIndex                  The media sequence number of the chunk.
    * @param discontinuitySequenceNumber The discontinuity sequence number of the chunk.
-   * @param isMasterTimestampSource True if the chunk can initialize the timestamp adjuster.
-   * @param timestampAdjuster Adjuster corresponding to the provided discontinuity sequence number.
-   * @param previousChunk The {@link HlsMediaChunk} that preceded this one. May be null.
-   * @param encryptionKey For AES encryption chunks, the encryption key.
-   * @param encryptionIv For AES encryption chunks, the encryption initialization vector.
+   * @param isMasterTimestampSource     True if the chunk can initialize the timestamp adjuster.
+   * @param timestampAdjuster           Adjuster corresponding to the provided discontinuity sequence number.
+   * @param previousChunk               The {@link HlsMediaChunk} that preceded this one. May be null.
+   * @param encryptionKey               For AES encryption chunks, the encryption key.
+   * @param encryptionIv                For AES encryption chunks, the encryption initialization vector.
    */
   public HlsMediaChunk(DataSource dataSource, DataSpec dataSpec, DataSpec initDataSpec,
-      HlsUrl hlsUrl, int trackSelectionReason, Object trackSelectionData, long startTimeUs,
-      long endTimeUs, int chunkIndex, int discontinuitySequenceNumber,
-      boolean isMasterTimestampSource, TimestampAdjuster timestampAdjuster,
-      HlsMediaChunk previousChunk, byte[] encryptionKey, byte[] encryptionIv) {
+                       HlsUrl hlsUrl, int trackSelectionReason, Object trackSelectionData, long startTimeUs,
+                       long endTimeUs, int chunkIndex, int discontinuitySequenceNumber,
+                       boolean isMasterTimestampSource, TimestampAdjuster timestampAdjuster,
+                       HlsMediaChunk previousChunk, byte[] encryptionKey, byte[] encryptionIv) {
     super(buildDataSource(dataSource, encryptionKey, encryptionIv), dataSpec, hlsUrl.format,
-        trackSelectionReason, trackSelectionData, startTimeUs, endTimeUs, chunkIndex);
+            trackSelectionReason, trackSelectionData, startTimeUs, endTimeUs, chunkIndex);
     this.initDataSpec = initDataSpec;
     this.hlsUrl = hlsUrl;
     this.isMasterTimestampSource = isMasterTimestampSource;
@@ -128,13 +131,13 @@ public HlsMediaChunk(DataSource dataSource, DataSpec dataSpec, DataSpec initData
     this.isEncrypted = this.dataSource instanceof Aes128DataSource;
     lastPathSegment = dataSpec.uri.getLastPathSegment();
     isPackedAudio = lastPathSegment.endsWith(AAC_FILE_EXTENSION)
-        || lastPathSegment.endsWith(AC3_FILE_EXTENSION)
-        || lastPathSegment.endsWith(EC3_FILE_EXTENSION)
-        || lastPathSegment.endsWith(MP3_FILE_EXTENSION);
+            || lastPathSegment.endsWith(AC3_FILE_EXTENSION)
+            || lastPathSegment.endsWith(EC3_FILE_EXTENSION)
+            || lastPathSegment.endsWith(MP3_FILE_EXTENSION);
     if (isPackedAudio) {
       id3Decoder = previousChunk != null ? previousChunk.id3Decoder : new Id3Decoder();
       id3Data = previousChunk != null ? previousChunk.id3Data
-          : new ParsableByteArray(Id3Decoder.ID3_HEADER_LENGTH);
+              : new ParsableByteArray(Id3Decoder.ID3_HEADER_LENGTH);
     } else {
       id3Decoder = null;
       id3Data = null;
@@ -192,13 +195,13 @@ public void load() throws IOException, InterruptedException {
 
   private void maybeLoadInitData() throws IOException, InterruptedException {
     if ((previousChunk != null && previousChunk.extractor == extractor) || initLoadCompleted
-        || initDataSpec == null) {
+            || initDataSpec == null) {
       return;
     }
     DataSpec initSegmentDataSpec = Util.getRemainderDataSpec(initDataSpec, initSegmentBytesLoaded);
     try {
       ExtractorInput input = new DefaultExtractorInput(initDataSource,
-          initSegmentDataSpec.absoluteStreamPosition, initDataSource.open(initSegmentDataSpec));
+              initSegmentDataSpec.absoluteStreamPosition, initDataSource.open(initSegmentDataSpec));
       try {
         int result = Extractor.RESULT_CONTINUE;
         while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
@@ -230,9 +233,12 @@ private void loadMedia() throws IOException, InterruptedException {
     if (!isMasterTimestampSource) {
       timestampAdjuster.waitUntilInitialized();
     }
+
+    // 如何加载文件呢?
     try {
       ExtractorInput input = new DefaultExtractorInput(dataSource,
-          loadDataSpec.absoluteStreamPosition, dataSource.open(loadDataSpec));
+              loadDataSpec.absoluteStreamPosition, dataSource.open(loadDataSpec));
+
       if (extractor == null) {
         // Media segment format is packed audio.
         long id3Timestamp = peekId3PrivTimestamp(input);
@@ -244,6 +250,7 @@ private void loadMedia() throws IOException, InterruptedException {
       if (skipLoadedBytes) {
         input.skipFully(bytesLoaded);
       }
+
       try {
         int result = Extractor.RESULT_CONTINUE;
         while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
@@ -265,7 +272,7 @@ private void loadMedia() throws IOException, InterruptedException {
    *
    * @param input The {@link ExtractorInput} to obtain the PRIV frame from.
    * @return The parsed, adjusted timestamp in microseconds
-   * @throws IOException If an error occurred peeking from the input.
+   * @throws IOException          If an error occurred peeking from the input.
    * @throws InterruptedException If the thread was interrupted.
    */
   private long peekId3PrivTimestamp(ExtractorInput input) throws IOException, InterruptedException {
@@ -315,7 +322,7 @@ private long peekId3PrivTimestamp(ExtractorInput input) throws IOException, Inte
    * order to decrypt the loaded data. Else returns the original.
    */
   private static DataSource buildDataSource(DataSource dataSource, byte[] encryptionKey,
-      byte[] encryptionIv) {
+                                            byte[] encryptionIv) {
     if (encryptionKey == null || encryptionIv == null) {
       return dataSource;
     }
@@ -326,11 +333,11 @@ private Extractor buildExtractorByExtension() {
     // Set the extractor that will read the chunk.
     Extractor extractor;
     boolean needNewExtractor = previousChunk == null
-        || previousChunk.discontinuitySequenceNumber != discontinuitySequenceNumber
-        || trackFormat != previousChunk.trackFormat;
+            || previousChunk.discontinuitySequenceNumber != discontinuitySequenceNumber
+            || trackFormat != previousChunk.trackFormat;
     boolean usingNewExtractor = true;
     if (lastPathSegment.endsWith(WEBVTT_FILE_EXTENSION)
-        || lastPathSegment.endsWith(VTT_FILE_EXTENSION)) {
+            || lastPathSegment.endsWith(VTT_FILE_EXTENSION)) {
       extractor = new WebvttExtractor(trackFormat.language, timestampAdjuster);
     } else if (!needNewExtractor) {
       // Only reuse TS and fMP4 extractors.
@@ -356,7 +363,7 @@ private Extractor buildExtractorByExtension() {
         }
       }
       extractor = new TsExtractor(timestampAdjuster,
-          new DefaultTsPayloadReaderFactory(esReaderFactoryFlags), true);
+              new DefaultTsPayloadReaderFactory(esReaderFactoryFlags), true);
     }
     if (usingNewExtractor) {
       extractor.init(extractorOutput);
@@ -369,7 +376,7 @@ private Extractor buildPackedAudioExtractor(long startTimeUs) {
     if (lastPathSegment.endsWith(AAC_FILE_EXTENSION)) {
       extractor = new AdtsExtractor(startTimeUs);
     } else if (lastPathSegment.endsWith(AC3_FILE_EXTENSION)
-        || lastPathSegment.endsWith(EC3_FILE_EXTENSION)) {
+            || lastPathSegment.endsWith(EC3_FILE_EXTENSION)) {
       extractor = new Ac3Extractor(startTimeUs);
     } else if (lastPathSegment.endsWith(MP3_FILE_EXTENSION)) {
       extractor = new Mp3Extractor(startTimeUs);
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
index fcd16ddd97..a4a5ddfe7a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
@@ -51,6 +51,8 @@
   private HlsPlaylistTracker playlistTracker;
   private Listener sourceListener;
 
+  // manifestUri masterHls文件等
+  // dataSourceFactory HttpDataSource网络控制
   public HlsMediaSource(Uri manifestUri, DataSource.Factory dataSourceFactory, Handler eventHandler,
       AdaptiveMediaSourceEventListener eventListener) {
     this(manifestUri, dataSourceFactory, DEFAULT_MIN_LOADABLE_RETRY_COUNT, eventHandler,
@@ -73,6 +75,7 @@ public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener l
     //       manifestUri = https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/gear1/prog_index.m3u8
     playlistTracker = new HlsPlaylistTracker(manifestUri, dataSourceFactory, eventDispatcher,
         minLoadableRetryCount, this);
+
     sourceListener = listener;
     playlistTracker.start();
   }
@@ -104,6 +107,7 @@ public void releaseSource() {
   @Override
   public void onPrimaryPlaylistRefreshed(HlsMediaPlaylist playlist) {
     SinglePeriodTimeline timeline;
+    // 直播
     if (playlistTracker.isLive()) {
       // TODO: fix windowPositionInPeriodUs when playlist is empty.
       List<HlsMediaPlaylist.Segment> segments = playlist.segments;
@@ -112,6 +116,7 @@ public void onPrimaryPlaylistRefreshed(HlsMediaPlaylist playlist) {
       timeline = new SinglePeriodTimeline(C.TIME_UNSET, playlist.durationUs,
           playlist.startTimeUs, windowDefaultStartPositionUs, true, !playlist.hasEndTag);
     } else /* not live */ {
+      // 这个是我们关注的信息
       timeline = new SinglePeriodTimeline(playlist.startTimeUs + playlist.durationUs,
           playlist.durationUs, playlist.startTimeUs, 0, true, false);
     }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylist.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylist.java
index 784ec0ea4a..88618ecb44 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylist.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylist.java
@@ -34,7 +34,10 @@
   public static final int TYPE_MASTER = 0;
   public static final int TYPE_MEDIA = 1;
 
+  // URL
   public final String baseUri;
+
+  // 类型
   @Type
   public final int type;
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
index c36cc4caae..95bfd85fae 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
@@ -150,8 +150,13 @@ public void removeListener(PlaylistEventListener listener) {
    * Starts tracking all the playlists related to the provided Uri.
    */
   public void start() {
+    // 下载: Playlist, 并且通过 playlistParser 来解析
+    // dataSourceFactory.createDataSource() 指定了网络请求
     ParsingLoadable<HlsPlaylist> masterPlaylistLoadable =
-            new ParsingLoadable<>(dataSourceFactory.createDataSource(), initialPlaylistUri, C.DATA_TYPE_MANIFEST, playlistParser);
+            new ParsingLoadable<>(dataSourceFactory.createDataSource(),
+                    initialPlaylistUri, C.DATA_TYPE_MANIFEST, playlistParser);
+
+    // this Loader callback
     initialPlaylistLoader.startLoading(masterPlaylistLoadable, this, minRetryCount);
   }
 
@@ -256,6 +261,7 @@ public void onLoadCompleted(ParsingLoadable<HlsPlaylist> loadable, long elapsedR
     // 如何处理: MediaPlaylistBundle ?
     // 1. 如果是MediaPlaylist, 则加载完毕
     // 2. 如果是MastPlaylist, 则加载Playlist
+    // 参考: createBundles
     MediaPlaylistBundle primaryBundle = playlistBundles.get(primaryHlsUrl);
     if (isMediaPlaylist) {
       // We don't need to load the playlist again. We can use the same result.
@@ -362,6 +368,7 @@ private void notifyPlaylistBlacklisting(HlsUrl url, long blacklistMs) {
    */
   private HlsMediaPlaylist adjustPlaylistTimestamps(HlsMediaPlaylist oldPlaylist,
       HlsMediaPlaylist newPlaylist) {
+    // 如何处理视频上的不连续性?
     if (newPlaylist.hasProgramDateTime) {
       if (newPlaylist.isNewerThan(oldPlaylist)) {
         return newPlaylist;
@@ -436,6 +443,7 @@ public void release() {
     }
 
     public void loadPlaylist() {
+      // 再次开始Loading
       blacklistUntilMs = 0;
       if (!mediaPlaylistLoader.isLoading()) {
         mediaPlaylistLoader.startLoading(mediaPlaylistLoadable, this, minRetryCount);
@@ -447,6 +455,7 @@ public void loadPlaylist() {
     @Override
     public void onLoadCompleted(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealtimeMs,
         long loadDurationMs) {
+      // 解析完毕
       processLoadedPlaylist((HlsMediaPlaylist) loadable.getResult());
 
       // 通知加载情况
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveVideoTrackSelection.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveVideoTrackSelection.java
index 868303cc5b..50cb125172 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveVideoTrackSelection.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveVideoTrackSelection.java
@@ -24,6 +24,7 @@
 import java.util.List;
 
 /**
+ * 基于带宽的自适应算法
  * A bandwidth based adaptive {@link TrackSelection} for video, whose selected track is updated to
  * be the one of highest quality given the current network conditions and the state of the buffer.
  */
@@ -80,6 +81,7 @@ public Factory(BandwidthMeter bandwidthMeter, int maxInitialBitrate,
 
     @Override
     public AdaptiveVideoTrackSelection createTrackSelection(TrackGroup group, int... tracks) {
+      // 如何选择一个合适的VideoTrack呢?
       return new AdaptiveVideoTrackSelection(group, tracks, bandwidthMeter, maxInitialBitrate,
           minDurationForQualityIncreaseMs, maxDurationForQualityDecreaseMs,
           minDurationToRetainAfterDiscardMs, bandwidthFraction);
@@ -87,7 +89,7 @@ public AdaptiveVideoTrackSelection createTrackSelection(TrackGroup group, int...
 
   }
 
-  public static final int DEFAULT_MAX_INITIAL_BITRATE = 800000;
+  public static final int DEFAULT_MAX_INITIAL_BITRATE = 800000; // 默认是: 800K
   public static final int DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS = 10000;
   public static final int DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS = 25000;
   public static final int DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS = 25000;
@@ -98,7 +100,7 @@ public AdaptiveVideoTrackSelection createTrackSelection(TrackGroup group, int...
   private final long minDurationForQualityIncreaseUs;
   private final long maxDurationForQualityDecreaseUs;
   private final long minDurationToRetainAfterDiscardUs;
-  private final float bandwidthFraction;
+  private final float bandwidthFraction; // 默认: 0.75
 
   private int selectedIndex;
   private int reason;
@@ -141,6 +143,7 @@ public AdaptiveVideoTrackSelection(TrackGroup group, int[] tracks, BandwidthMete
       long maxDurationForQualityDecreaseMs, long minDurationToRetainAfterDiscardMs,
       float bandwidthFraction) {
     super(group, tracks);
+
     this.bandwidthMeter = bandwidthMeter;
     this.maxInitialBitrate = maxInitialBitrate;
     this.minDurationForQualityIncreaseUs = minDurationForQualityIncreaseMs * 1000L;
@@ -153,16 +156,24 @@ public AdaptiveVideoTrackSelection(TrackGroup group, int[] tracks, BandwidthMete
 
   @Override
   public void updateSelectedTrack(long bufferedDurationUs) {
+    // 如何更新选中的额Track呢?
     long nowMs = SystemClock.elapsedRealtime();
+
     // Get the current and ideal selections.
     int currentSelectedIndex = selectedIndex;
     Format currentFormat = getSelectedFormat();
+
+    // 理想的Format
     int idealSelectedIndex = determineIdealSelectedIndex(nowMs);
     Format idealFormat = getFormat(idealSelectedIndex);
+
     // Assume we can switch to the ideal selection.
     selectedIndex = idealSelectedIndex;
+
     // Revert back to the current selection if conditions are not suitable for switching.
     if (currentFormat != null && !isBlacklisted(selectedIndex, nowMs)) {
+
+      // 如果birate升高了
       if (idealFormat.bitrate > currentFormat.bitrate
           && bufferedDurationUs < minDurationForQualityIncreaseUs) {
         // The ideal track is a higher quality, but we have insufficient buffer to safely switch
@@ -175,6 +186,8 @@ public void updateSelectedTrack(long bufferedDurationUs) {
         selectedIndex = currentSelectedIndex;
       }
     }
+
+    // 如果有变化，则标志位自适应变化
     // If we adapted, update the trigger.
     if (selectedIndex != currentSelectedIndex) {
       reason = C.SELECTION_REASON_ADAPTIVE;
@@ -230,16 +243,24 @@ public int evaluateQueueSize(long playbackPositionUs, List<? extends MediaChunk>
    *     {@link Long#MIN_VALUE} to ignore blacklisting.
    */
   private int determineIdealSelectedIndex(long nowMs) {
+
+    // 确定理想的Index
+    // 1. 估计的bitrate
     long bitrateEstimate = bandwidthMeter.getBitrateEstimate();
-    long effectiveBitrate = bitrateEstimate == BandwidthMeter.NO_ESTIMATE
-        ? maxInitialBitrate : (long) (bitrateEstimate * bandwidthFraction);
+    // 有效的Bitrate
+    // 最大的初始bitrate或者估算的: 0.75
+    long effectiveBitrate = bitrateEstimate == BandwidthMeter.NO_ESTIMATE ? maxInitialBitrate : (long) (bitrateEstimate * bandwidthFraction);
+
     int lowestBitrateNonBlacklistedIndex = 0;
     for (int i = 0; i < length; i++) {
       if (nowMs == Long.MIN_VALUE || !isBlacklisted(i, nowMs)) {
         Format format = getFormat(i);
+        // formats的码率从高到低变化
+        // 直到找到一个满足带宽需要的Format
         if (format.bitrate <= effectiveBitrate) {
           return i;
         } else {
+          // 满足条件的最小带宽的Format
           lowestBitrateNonBlacklistedIndex = i;
         }
       }
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/Allocator.java b/library/src/main/java/com/google/android/exoplayer2/upstream/Allocator.java
index 17b7dfd6e9..d57ce4efcd 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/Allocator.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/Allocator.java
@@ -17,6 +17,7 @@
 
 /**
  * A source of allocations.
+ * 分配管理Allocation, 带有offset的buffer
  */
 public interface Allocator {
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java
index 0ddf17cbe9..9539366a1d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java
@@ -20,7 +20,10 @@
 import java.io.IOException;
 
 /**
+ * 可读取的资源信息
  * A component from which streams of data can be read.
+ *
+ * FileDataSource：基于本地文件展示了DataSpec的意义，用法，以及DataSource接口的实现
  */
 public interface DataSource {
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultAllocator.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultAllocator.java
index d9bd5873f0..951f8b87a4 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultAllocator.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultAllocator.java
@@ -59,13 +59,23 @@ public DefaultAllocator(boolean trimOnReset, int individualAllocationSize) {
    */
   public DefaultAllocator(boolean trimOnReset, int individualAllocationSize,
       int initialAllocationCount) {
+
+    // 注意开发的各种Utils
     Assertions.checkArgument(individualAllocationSize > 0);
     Assertions.checkArgument(initialAllocationCount >= 0);
+
     this.trimOnReset = trimOnReset;
+    // 单个的Allocation的大小
     this.individualAllocationSize = individualAllocationSize;
     this.availableCount = initialAllocationCount;
+
+    // 内部管理一些: Allocation
+    // 这些Allocation没有分配内存
     this.availableAllocations = new Allocation[initialAllocationCount + AVAILABLE_EXTRA_CAPACITY];
+
+
     if (initialAllocationCount > 0) {
+      // 预先给一些Allocation分配内存
       initialAllocationBlock = new byte[initialAllocationCount * individualAllocationSize];
       for (int i = 0; i < initialAllocationCount; i++) {
         int allocationOffset = i * individualAllocationSize;
@@ -74,6 +84,8 @@ public DefaultAllocator(boolean trimOnReset, int individualAllocationSize,
     } else {
       initialAllocationBlock = null;
     }
+
+    // 用于做接口的Adapter, 单个元素到数组的转换
     singleAllocationReleaseHolder = new Allocation[1];
   }
 
@@ -86,6 +98,8 @@ public synchronized void reset() {
   public synchronized void setTargetBufferSize(int targetBufferSize) {
     boolean targetBufferSizeReduced = targetBufferSize < this.targetBufferSize;
     this.targetBufferSize = targetBufferSize;
+
+    // BufferSize是什么概念？
     if (targetBufferSizeReduced) {
       trim();
     }
@@ -95,10 +109,15 @@ public synchronized void setTargetBufferSize(int targetBufferSize) {
   public synchronized Allocation allocate() {
     allocatedCount++;
     Allocation allocation;
+
     if (availableCount > 0) {
+      // 直接从内存中拿出一个Allocation
       allocation = availableAllocations[--availableCount];
+
+      // 注意内存的管理
       availableAllocations[availableCount] = null;
     } else {
+      // 实在没有就删除
       allocation = new Allocation(new byte[individualAllocationSize], 0);
     }
     return allocation;
@@ -107,29 +126,41 @@ public synchronized Allocation allocate() {
   @Override
   public synchronized void release(Allocation allocation) {
     singleAllocationReleaseHolder[0] = allocation;
+    // 为了保持对release(Allocation[])的接口兼容
     release(singleAllocationReleaseHolder);
   }
 
   @Override
   public synchronized void release(Allocation[] allocations) {
+    // 1. 扩大 availableAllocations
     if (availableCount + allocations.length >= availableAllocations.length) {
       availableAllocations = Arrays.copyOf(availableAllocations,
           Math.max(availableAllocations.length * 2, availableCount + allocations.length));
     }
+
+    // 2. 将Allocations放回到: availableAllocations
     for (Allocation allocation : allocations) {
       // Weak sanity check that the allocation probably originated from this pool.
       Assertions.checkArgument(allocation.data == initialAllocationBlock
           || allocation.data.length == individualAllocationSize);
       availableAllocations[availableCount++] = allocation;
     }
+
+    // 3. 更新统计数据
     allocatedCount -= allocations.length;
+
     // Wake up threads waiting for the allocated size to drop.
     notifyAll();
   }
 
   @Override
   public synchronized void trim() {
+
+    // 总共的内存分配次数
     int targetAllocationCount = Util.ceilDivide(targetBufferSize, individualAllocationSize);
+
+    // 要做什么呢?
+    // 如果: targetAvailableCount < availableCount, 则需要删除多余的Allocation
     int targetAvailableCount = Math.max(0, targetAllocationCount - allocatedCount);
     if (targetAvailableCount >= availableCount) {
       // We're already at or below the target.
@@ -145,12 +176,16 @@ public synchronized void trim() {
       while (lowIndex <= highIndex) {
         Allocation lowAllocation = availableAllocations[lowIndex];
         if (lowAllocation.data == initialAllocationBlock) {
+          // 1. 直接跳过: lowIndex
           lowIndex++;
         } else {
+          // 2. loadIndex需要切换到后面
           Allocation highAllocation = availableAllocations[highIndex];
           if (highAllocation.data != initialAllocationBlock) {
+            // 2.1 如果highIndex也在后面排列，则暂时不管loadIndex
             highIndex--;
           } else {
+            // 2.2 交换
             availableAllocations[lowIndex++] = highAllocation;
             availableAllocations[highIndex--] = lowAllocation;
           }
@@ -165,17 +200,20 @@ public synchronized void trim() {
     }
 
     // Discard allocations beyond the target.
+    // 降低 availableCount 数量
     Arrays.fill(availableAllocations, targetAvailableCount, availableCount, null);
     availableCount = targetAvailableCount;
   }
 
   @Override
   public synchronized int getTotalBytesAllocated() {
+    // 总共分配的内存
     return allocatedCount * individualAllocationSize;
   }
 
   @Override
   public int getIndividualAllocationLength() {
+    // 单给Allocation的大小
     return individualAllocationSize;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java
index 20f28e7a7d..373af96cd5 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java
@@ -23,6 +23,8 @@
 /**
  * Estimates bandwidth by listening to data transfers. The bandwidth estimate is calculated using
  * a {@link SlidingPercentile} and is updated each time a transfer ends.
+ *
+ * 如何评估带宽呢?
  */
 public final class DefaultBandwidthMeter implements BandwidthMeter, TransferListener<Object> {
 
@@ -82,13 +84,18 @@ public synchronized void onBytesTransferred(Object source, int bytes) {
   @Override
   public synchronized void onTransferEnd(Object source) {
     Assertions.checkState(streamCount > 0);
+
+    // 统计传输时间 + 传输数据流（字节)
     long nowMs = SystemClock.elapsedRealtime();
     int sampleElapsedTimeMs = (int) (nowMs - sampleStartTimeMs);
     totalElapsedTimeMs += sampleElapsedTimeMs;
     totalBytesTransferred += sampleBytesTransferred;
+
     if (sampleElapsedTimeMs > 0) {
       float bitsPerSecond = (sampleBytesTransferred * 8000) / sampleElapsedTimeMs;
+
       slidingPercentile.addSample((int) Math.sqrt(sampleBytesTransferred), bitsPerSecond);
+
       if (totalElapsedTimeMs >= ELAPSED_MILLIS_FOR_ESTIMATE
           || totalBytesTransferred >= BYTES_TRANSFERRED_FOR_ESTIMATE) {
         float bitrateEstimateFloat = slidingPercentile.getPercentile(0.5f);
@@ -108,6 +115,7 @@ private void notifyBandwidthSample(final int elapsedMs, final long bytes, final
       eventHandler.post(new Runnable()  {
         @Override
         public void run() {
+          // 带宽变化了，如何处理呢?
           eventListener.onBandwidthSample(elapsedMs, bytes, bitrate);
         }
       });
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
index 94b649caa8..eba84a756c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
@@ -191,6 +191,8 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     this.bytesSkipped = 0;
 
     // 每次创建一个新的连接
+    // Http2.0 vs. Non-2.0
+    // 是否能服用Connection
     try {
       connection = makeConnection(dataSpec);
     } catch (IOException e) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java
index 898d2169b3..b058b3f8dd 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java
@@ -16,7 +16,9 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.net.Uri;
+
 import com.google.android.exoplayer2.C;
+
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.RandomAccessFile;
@@ -58,11 +60,19 @@ public FileDataSource(TransferListener<? super FileDataSource> listener) {
   @Override
   public long open(DataSpec dataSpec) throws FileDataSourceException {
     try {
+      // dataSpec中如何记录文件信息
       uri = dataSpec.uri;
+
+      // 随机访问的文件
       file = new RandomAccessFile(dataSpec.uri.getPath(), "r");
+
+      // seek
       file.seek(dataSpec.position);
+
+      // 文件(逻辑意义上的文件)
+      // min(file.length - dataSpec.position, dataSpec.length)
       bytesRemaining = dataSpec.length == C.LENGTH_UNSET ? file.length() - dataSpec.position
-          : dataSpec.length;
+              : dataSpec.length;
       if (bytesRemaining < 0) {
         throw new EOFException();
       }
@@ -85,6 +95,7 @@ public int read(byte[] buffer, int offset, int readLength) throws FileDataSource
     } else if (bytesRemaining == 0) {
       return C.RESULT_END_OF_INPUT;
     } else {
+      // 读取给定长度的数据
       int bytesRead;
       try {
         bytesRead = file.read(buffer, offset, (int) Math.min(bytesRemaining, readLength));
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
index f915ee4e24..7eb4da8c95 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
@@ -35,6 +35,7 @@
    */
   interface Factory extends DataSource.Factory {
 
+    // Factory的接口也升级了
     @Override
     HttpDataSource createDataSource();
 
@@ -140,6 +141,8 @@ public InvalidResponseCodeException(int responseCode, Map<String, List<String>>
 
   }
 
+  // Override的作用:
+  // throws的异常类型做了具体化
   @Override
   long open(DataSpec dataSpec) throws HttpDataSourceException;
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java
index 0b7b85b8c3..20c5bd0e32 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java
@@ -89,6 +89,7 @@ public RawResourceDataSource(Context context,
   @Override
   public long open(DataSpec dataSpec) throws RawResourceDataSourceException {
     try {
+      // rawresource://resource_id
       uri = dataSpec.uri;
       if (!TextUtils.equals(RAW_RESOURCE_SCHEME, uri.getScheme())) {
         throw new RawResourceDataSourceException("URI must use scheme " + RAW_RESOURCE_SCHEME);
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/UdpDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/UdpDataSource.java
index 68a04d9182..6e81225891 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/UdpDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/UdpDataSource.java
@@ -97,6 +97,8 @@ public UdpDataSource(TransferListener<? super UdpDataSource> listener, int maxPa
   @Override
   public long open(DataSpec dataSpec) throws UdpDataSourceException {
     uri = dataSpec.uri;
+
+    // 从DataSpec中获取host/port
     String host = uri.getHost();
     int port = uri.getPort();
 
@@ -108,12 +110,14 @@ public long open(DataSpec dataSpec) throws UdpDataSourceException {
         multicastSocket.joinGroup(address);
         socket = multicastSocket;
       } else {
+        // 创建: DatagramSocket
         socket = new DatagramSocket(socketAddress);
       }
     } catch (IOException e) {
       throw new UdpDataSourceException(e);
     }
 
+    // 设置Timeout
     try {
       socket.setSoTimeout(socketTimeoutMillis);
     } catch (SocketException e) {
@@ -124,6 +128,8 @@ public long open(DataSpec dataSpec) throws UdpDataSourceException {
     if (listener != null) {
       listener.onTransferStart(this, dataSpec);
     }
+
+    // 数据长度不确定
     return C.LENGTH_UNSET;
   }
 
@@ -136,6 +142,8 @@ public int read(byte[] buffer, int offset, int readLength) throws UdpDataSourceE
     if (packetRemaining == 0) {
       // We've read all of the data from the current packet. Get another.
       try {
+        // 处理模式:
+        // 先读取一帧数据，然后再分块返回给上层代码
         socket.receive(packet);
       } catch (IOException e) {
         throw new UdpDataSourceException(e);
