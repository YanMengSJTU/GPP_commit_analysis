diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index a468e72a7a..234c91daba 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,9 +1,69 @@
 # Release notes #
 
-### r2.1.1 ###
+### r2.2.0 ###
+
+* Demo app: Automatic recovery from BehindLiveWindowException, plus improved
+  handling of pausing and resuming live streams
+  ([#2344](https://github.com/google/ExoPlayer/issues/2344)).
+* AndroidTV: Added Support for tunneled video playback
+  ([#1688](https://github.com/google/ExoPlayer/issues/1688)).
+* DRM: Renamed StreamingDrmSessionManager to DefaultDrmSessionManager and
+  added support for using offline licenses
+  ([#876](https://github.com/google/ExoPlayer/issues/876)).
+* DRM: Introduce OfflineLicenseHelper to help with offline license acquisition,
+  renewal and release.
+* UI: Updated player control assets. Added vector drawables for use on API level
+  21 and above.
+* UI: Made player control seek bar work correctly with key events if focusable
+  ([#2278](https://github.com/google/ExoPlayer/issues/2278)).
+* HLS: Improved support for streams that use EXT-X-DISCONTINUITY without
+  EXT-X-DISCONTINUITY-SEQUENCE
+  ([#1789](https://github.com/google/ExoPlayer/issues/1789)).
+* HLS: Support for EXT-X-START tag
+  ([#1544](https://github.com/google/ExoPlayer/issues/1544)).
+* HLS: Check #EXTM3U header is present when parsing the playlist. Fail
+  gracefully if not ([#2301](https://github.com/google/ExoPlayer/issues/2301)).
+* HLS: Fix memory leak
+  ([#2319](https://github.com/google/ExoPlayer/issues/2319)).
+* HLS: Fix non-seamless first adaptation where master playlist omits resolution
+  tags ([#2096](https://github.com/google/ExoPlayer/issues/2096)).
+* HLS: Fix handling of WebVTT subtitle renditions with non-standard segment file
+  extensions ([#2025](https://github.com/google/ExoPlayer/issues/2025) and
+  [#2355](https://github.com/google/ExoPlayer/issues/2355)).
+* HLS: Better handle inconsistent HLS playlist update
+  ([#2249](https://github.com/google/ExoPlayer/issues/2249)).
+* DASH: Don't overflow when dealing with large segment numbers
+  ([#2311](https://github.com/google/ExoPlayer/issues/2311)).
+* DASH: Fix propagation of language from the manifest
+  ([#2335](https://github.com/google/ExoPlayer/issues/2335)).
+* SmoothStreaming: Work around "Offset to sample data was negative" failures
+  ([#2292](https://github.com/google/ExoPlayer/issues/2292),
+  [#2101](https://github.com/google/ExoPlayer/issues/2101) and
+  [#1152](https://github.com/google/ExoPlayer/issues/1152)).
+* MP3/ID3: Added support for parsing Chapter and URL link frames
+  ([#2316](https://github.com/google/ExoPlayer/issues/2316)).
+* MP3/ID3: Handle ID3 frames that end with empty text field
+  ([#2309](https://github.com/google/ExoPlayer/issues/2309)).
+* Added ClippingMediaSource for playing clipped portions of media
+  ([#1988](https://github.com/google/ExoPlayer/issues/1988)).
+* Added convenience methods to query whether the current window is dynamic and
+  seekable ([#2320](https://github.com/google/ExoPlayer/issues/2320)).
+* Support setting of default headers on HttpDataSource.Factory implementations
+  ([#2166](https://github.com/google/ExoPlayer/issues/2166)).
+* Fixed cache failures when using an encrypted cache content index.
+* Fix visual artifacts when switching output surface
+  ([#2093](https://github.com/google/ExoPlayer/issues/2093)).
+* Fix gradle + proguard configurations.
+* Fix player position when replacing the MediaSource
+  ([#2369](https://github.com/google/ExoPlayer/issues/2369)).
+* Misc bug fixes, including
+  [#2330](https://github.com/google/ExoPlayer/issues/2330),
+  [#2269](https://github.com/google/ExoPlayer/issues/2269),
+  [#2252](https://github.com/google/ExoPlayer/issues/2252),
+  [#2264](https://github.com/google/ExoPlayer/issues/2264) and
+  [#2290](https://github.com/google/ExoPlayer/issues/2290).
 
-Bugfix release only. Users of r2.1.0 and r2.0.x should proactively update to
-this version.
+### r2.1.1 ###
 
 * Fix some subtitle types (e.g. WebVTT) being displayed out of sync
   ([#2208](https://github.com/google/ExoPlayer/issues/2208)).
@@ -52,13 +112,13 @@ this version.
 * Improved flexibility of SimpleExoPlayer
   ([#2102](https://github.com/google/ExoPlayer/issues/2102)).
 * Fix issue where only the audio of a video would play due to capability
-  detection issues ([#2007](https://github.com/google/ExoPlayer/issues/2007))
-  ([#2034](https://github.com/google/ExoPlayer/issues/2034))
-  ([#2157](https://github.com/google/ExoPlayer/issues/2157)).
+  detection issues ([#2007](https://github.com/google/ExoPlayer/issues/2007),
+  [#2034](https://github.com/google/ExoPlayer/issues/2034) and
+  [#2157](https://github.com/google/ExoPlayer/issues/2157)).
 * Fix issues that could cause ExtractorMediaSource based playbacks to get stuck
   buffering ([#1962](https://github.com/google/ExoPlayer/issues/1962)).
 * Correctly set SimpleExoPlayerView surface aspect ratio when an active player
-  is attached ([#2077](https://github.com/google/ExoPlayer/issues/1976)).
+  is attached ([#2077](https://github.com/google/ExoPlayer/issues/2077)).
 * OGG: Fix playback of short OGG files
   ([#1976](https://github.com/google/ExoPlayer/issues/1976)).
 * MP4: Support `.mp3` tracks
@@ -74,11 +134,6 @@ this version.
 
 ### r2.0.3 ###
 
-* Fix crash on Jellybean devices when using playback controls
-  ([#1965](https://github.com/google/ExoPlayer/issues/1965)).
-
-### r2.0.3 ###
-
 * Fixed NullPointerException in ExtractorMediaSource
   ([#1914](https://github.com/google/ExoPlayer/issues/1914)).
 * Fixed NullPointerException in HlsMediaPeriod
@@ -191,6 +246,14 @@ in all V2 releases. This cannot be assumed for changes in r1.5.12 and later,
 however it can be assumed that all such changes are included in the most recent
 V2 release.
 
+### r1.5.14 ###
+
+* Fixed cache failures when using an encrypted cache content index.
+* SmoothStreaming: Work around "Offset to sample data was negative" failures
+  ([#2292](https://github.com/google/ExoPlayer/issues/2292),
+  [#2101](https://github.com/google/ExoPlayer/issues/2101) and
+  [#1152](https://github.com/google/ExoPlayer/issues/1152)).
+
 ### r1.5.13 ###
 
 * Improvements to the upstream cache package.
diff --git a/build.gradle b/build.gradle
index 5f6aa1c64e..b2dbca5572 100644
--- a/build.gradle
+++ b/build.gradle
@@ -36,7 +36,7 @@ allprojects {
         releaseRepoName = 'exoplayer'
         releaseUserOrg = 'google'
         releaseGroupId = 'com.google.android.exoplayer'
-        releaseVersion = 'r2.1.1'
+        releaseVersion = 'r2.2.0'
         releaseWebsite = 'https://github.com/google/ExoPlayer'
     }
 }
diff --git a/demo/assets/ic_launcher.svg b/demo/assets/ic_launcher.svg
deleted file mode 100644
index 5486b27e29..0000000000
--- a/demo/assets/ic_launcher.svg
+++ /dev/null
@@ -1,660 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:xlink="http://www.w3.org/1999/xlink"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   width="192"
-   height="192"
-   id="svg3089"
-   version="1.1"
-   inkscape:version="0.48.4 r9939"
-   sodipodi:docname="exoplayer.svg"
-   enable-background="new">
-  <sodipodi:namedview
-     id="base"
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1.0"
-     inkscape:pageopacity="0.0"
-     inkscape:pageshadow="2"
-     inkscape:zoom="2.0893424"
-     inkscape:cx="79.970323"
-     inkscape:cy="85.448985"
-     inkscape:current-layer="layer2"
-     showgrid="true"
-     inkscape:grid-bbox="true"
-     inkscape:document-units="px"
-     showguides="true"
-     inkscape:guide-bbox="true"
-     inkscape:window-width="1920"
-     inkscape:window-height="1176"
-     inkscape:window-x="1920"
-     inkscape:window-y="24"
-     inkscape:window-maximized="1" />
-  <defs
-     id="defs3091">
-    <linearGradient
-       inkscape:collect="always"
-       id="linearGradient4624">
-      <stop
-         style="stop-color:#ffffff;stop-opacity:1;"
-         offset="0"
-         id="stop4626" />
-      <stop
-         style="stop-color:#ffffff;stop-opacity:0;"
-         offset="1"
-         id="stop4628" />
-    </linearGradient>
-    <linearGradient
-       inkscape:collect="always"
-       id="linearGradient4498">
-      <stop
-         style="stop-color:#000000;stop-opacity:1;"
-         offset="0"
-         id="stop4500" />
-      <stop
-         style="stop-color:#000000;stop-opacity:0;"
-         offset="1"
-         id="stop4502" />
-    </linearGradient>
-    <linearGradient
-       id="linearGradient4511">
-      <stop
-         id="stop4513"
-         offset="0"
-         style="stop-color:#ffffff;stop-opacity:1;" />
-      <stop
-         id="stop4515"
-         offset="1"
-         style="stop-color:#ffffff;stop-opacity:0;" />
-    </linearGradient>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter4219">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.5"
-         id="feFlood4221" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4223" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="2"
-         in="composite"
-         id="feGaussianBlur4225" />
-      <feOffset
-         result="offset"
-         dy="4"
-         dx="4"
-         id="feOffset4227" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4229" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter4464">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4466" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4468" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur4470" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4472" />
-      <feComposite
-         result="fbSourceGraphic"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4474" />
-      <feColorMatrix
-         id="feColorMatrix4476"
-         values="0 0 0 -1 0 0 0 0 -1 0 0 0 0 -1 0 0 0 0 1 0"
-         in="fbSourceGraphic"
-         result="fbSourceGraphicAlpha" />
-      <feFlood
-         in="fbSourceGraphic"
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4478" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="fbSourceGraphic"
-         id="feComposite4480" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur4482" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4484" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="fbSourceGraphic"
-         in2="offset"
-         id="feComposite4486" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter4494">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4496" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4498" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur4500" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4502" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4504" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter4535">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4537" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4539" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur4541" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4543" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4545" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter4557">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4559" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4561" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur4563" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4565" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4567" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter4575">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4577" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4579" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur4581" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4583" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4585" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       id="filter4575-6"
-       color-interpolation-filters="sRGB">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4577-1" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4579-3" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         id="feGaussianBlur4581-3" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4583-6" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4585-9" />
-    </filter>
-    <filter
-       id="filter3896"
-       inkscape:collect="always">
-      <feBlend
-         id="feBlend3898"
-         in2="BackgroundImage"
-         mode="multiply"
-         inkscape:collect="always" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter3909">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood3911" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite3913" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur3915" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset3917" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite3919" />
-    </filter>
-    <linearGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient4498"
-       id="linearGradient4504"
-       x1="43.149372"
-       y1="63.20599"
-       x2="110.44475"
-       y2="130.50137"
-       gradientUnits="userSpaceOnUse" />
-    <linearGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient4498-7"
-       id="linearGradient4504-7"
-       x1="43.149372"
-       y1="63.20599"
-       x2="110.44475"
-       y2="130.50137"
-       gradientUnits="userSpaceOnUse" />
-    <linearGradient
-       inkscape:collect="always"
-       id="linearGradient4498-7">
-      <stop
-         style="stop-color:#000000;stop-opacity:1;"
-         offset="0"
-         id="stop4500-0" />
-      <stop
-         style="stop-color:#000000;stop-opacity:0;"
-         offset="1"
-         id="stop4502-0" />
-    </linearGradient>
-    <linearGradient
-       gradientTransform="translate(-0.12691481,66.675082)"
-       y2="130.50137"
-       x2="110.44475"
-       y1="63.20599"
-       x1="43.149372"
-       gradientUnits="userSpaceOnUse"
-       id="linearGradient4521"
-       xlink:href="#linearGradient4498-7"
-       inkscape:collect="always" />
-    <radialGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient4624"
-       id="radialGradient4630"
-       cx="17.483059"
-       cy="18.005892"
-       fx="17.483059"
-       fy="18.005892"
-       r="88.000001"
-       gradientTransform="matrix(-0.00420028,0.99999118,-1.888314,-0.00793148,51.557271,20.787508)"
-       gradientUnits="userSpaceOnUse" />
-    <filter
-       id="filter4680"
-       style="color-interpolation-filters:sRGB;"
-       inkscape:label="Drop Shadow"
-       width="1.4100000000000001"
-       height="1.4700000000000002"
-       x="-0.23000000000000009"
-       y="-0.23000000000000009">
-      <feFlood
-         id="feFlood4682"
-         flood-opacity="0.2"
-         flood-color="rgb(0,0,0)"
-         result="flood" />
-      <feComposite
-         id="feComposite4684"
-         in2="SourceGraphic"
-         in="flood"
-         operator="in"
-         result="composite1" />
-      <feGaussianBlur
-         id="feGaussianBlur4686"
-         in="composite"
-         stdDeviation="6"
-         result="blur" />
-      <feOffset
-         id="feOffset4688"
-         dx="0"
-         dy="6"
-         result="offset" />
-      <feComposite
-         id="feComposite4690"
-         in2="offset"
-         in="SourceGraphic"
-         operator="over"
-         result="composite2" />
-    </filter>
-    <filter
-       id="filter4692"
-       style="color-interpolation-filters:sRGB;"
-       inkscape:label="Drop Shadow"
-       width="1.3600000000000001"
-       x="-0.2400000000000001"
-       y="-0.070000000000000034"
-       height="1.3600000000000001">
-      <feFlood
-         id="feFlood4694"
-         flood-opacity="0.2"
-         flood-color="rgb(0,0,0)"
-         result="flood" />
-      <feComposite
-         id="feComposite4696"
-         in2="SourceGraphic"
-         in="flood"
-         operator="in"
-         result="composite1" />
-      <feGaussianBlur
-         id="feGaussianBlur4698"
-         in="composite"
-         stdDeviation="6"
-         result="blur" />
-      <feOffset
-         id="feOffset4700"
-         dx="0"
-         dy="6"
-         result="offset" />
-      <feComposite
-         id="feComposite4702"
-         in2="offset"
-         in="SourceGraphic"
-         operator="over"
-         result="composite2" />
-    </filter>
-    <filter
-       id="filter4710"
-       style="color-interpolation-filters:sRGB;"
-       inkscape:label="Drop Shadow">
-      <feFlood
-         id="feFlood4712"
-         flood-opacity="0.2"
-         flood-color="rgb(0,0,0)"
-         result="flood" />
-      <feComposite
-         id="feComposite4714"
-         in2="SourceGraphic"
-         in="flood"
-         operator="in"
-         result="composite1" />
-      <feGaussianBlur
-         id="feGaussianBlur4716"
-         in="composite"
-         stdDeviation="6"
-         result="blur" />
-      <feOffset
-         id="feOffset4718"
-         dx="0"
-         dy="6"
-         result="offset" />
-      <feComposite
-         id="feComposite4720"
-         in2="offset"
-         in="SourceGraphic"
-         operator="over"
-         result="composite2" />
-    </filter>
-  </defs>
-  <metadata
-     id="metadata3094">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <g
-     style="display:none"
-     sodipodi:insensitive="true"
-     transform="translate(0,176)"
-     inkscape:groupmode="layer"
-     inkscape:label="Layer 1"
-     id="layer1">
-    <image
-       width="192"
-       height="192"
-       xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAYAAABS3GwHAAAABHNCSVQICAgIfAhkiAAAIABJREFU eJztnVlXE1vax/9JZSBAAgljoAHbNBIwKHAOCsJSUZperr7qj3A+Tn+K8w2OV2fRx0YBFwioDEqE AA3vQRYUCCRQCZmH94KVLEBIatg1xfrdKVV771Sef2oPz6D797//nenr60MqlcKPTjgcBgCUlpZq /RU5er0e8/Pz0E1OTmZqamrQ3t4u95hk5+zsDABQVlam9VfkrKysIJFIQJ9KpdDe3g6v1yv3mGQn nU4jnU5r/RU5Xq8XHR0dSCaT0Gf/0+PxaCLQKHq8Xi88Hk/u3/qLf9REoFHMXDV+4IoAAE0EGsXJ dcYPXCMAQBOBRnFxk/EDNwgA+DFFYDabYTabtf6KiHzGDwCGfDdnRZCvATEJBAJYXl5GMBiEXq+H Xn+jXonAZ588O65EIgG/34/j42Po9XqUl5ejtLQUNptNUH8MwyAcDiMUCiGdTqOqqgoOhwNGo5Hz ro5U5wDZcVmtVnR2dsJut4va302wsd28AgDkEUEwGMTY2Bjq6+vR29sLi8UiSb9s98kjkQj29vbA MAxMJhNSqRQsFgt6e3tRWVkJiqKI9pcllUrh5OQEfr8fkUgEFEUhHo/DZrOhoaGh4HOS+hwgEolg aWkJ+/v7GB4ehtVqlaRfgJ3xAywEAEgrgqWlJdA0jX/961+i93WVm35NT05OsL29jVQqBZ1Oh8rK SrS0tMBgYPX4OPd3ExRFoaqqClVVVZf+P5lMYmdnBycnJ8hkMqAoCi0tLaisrBTUn1AsFgv6+/sB AKOjo3A6nejq6hK9Xy62qnvz5k1maGiIeMN8ePv2LRwOh2xTrmAwCIqiUFpaio2NDTAMAwCor69H Y2OjKP0BEOWXcXd3F/v7+wAAm82G1tZWhMNhpFIpSX+JL+L1euH3+/H48WNR+2BrP/Pz8+zeAFnE fBMsLS3JavwAsLGxgUgkApvNhjt37qh6wdjY2JgTbSwWw/LyMhiGgcViQU9PjyxjytrP0tKSKG8C PrbJ+R0uhgiCwSBomsaLFy+ItcmWr1+/4uDgACaTCc3NzSgrK5NszSEVZrMZnZ2diEQiODs7w6dP nxCPx1FXV4fm5mZJx+LxeDA6OgqXy0X0TcTXJnltq5DeIh0bG5PU+JPJJBYXFzE3N4eKigr09vbi /v37MJvNSCaTko1DapLJJMxmM+7fv4/e3l5UVFRgbm4Oi4uLkn7uFy9eYGxsjFh7Qn6Qea/iSL0J AoEA6uvrBbXBpS+fzwebzYbu7m5J+lQyFRUVePjwIQDgy5cvYBgGbrdbkm3L+vp6BAIBwX0JtUFB G+sk3gTLy8ui7wzQNI3Z2VkEAgH09/fj7t27ovanRu7evYv+/n4EAgHMzs6CpmlR++vq6sLy8rKg Nkj8AAs+WRIqgmAwKNqcm6ZpTE9PAwD6+vpw+/ZtUfopJm7fvo2+vj4AwPT0tGhCsFgsuV0wPpBa hxI5WhUiAjFOdwOBAN6+fQsAGBgYgNPpJN5HseN0OjEwMADgfHs6EAgQ74Pvd09yE4aY9fEVgdDD pIuk02nMz88jGAzi8ePHnA2/2H1z+PTndDrx+PFjBINBzM/PEz1M4/Pdk96B5HQQxoZ8A7zq22Mw GLC/v4/a2lre/WUyGRiNRqyuruLOnTugKIr3jkaxx+gK7c9gMCCVSmF9fR3t7e1IJBLQ6XS82spk Mjg9PUV5eTn0ej0r3yHSxj8/Pw+8efMmQ5rl5eVL/2YYJvPbb79l3r17lwmHw5f+9p///EdQX0dH R5mJiYlMNBoV1E4mk8mEQqFMKBQS3E6x9xeNRjMTExOZo6MjQe3Mzs5mYrFY7t/hcDjz7t27zG+/ /ZZhGObStVdtigQfP37MkJt/XODiFqmYvj2zs7OoqanBkydPiLQnta+MWvszm8148uQJNjc3sbGx kVs0cyWTyVwa002+Q2K64IjmX+zxePDrr7/CZDIRP+QKBAIYHx/HgwcP4HK5iLatwR6Xy4UHDx5g fHyc+CL5xYsXMJlM+PXXX0V1jxFNAEtLS7lDFpIsLi6CpmkMDQ2JHh+gURi9Xo+hoSHQNI3FxUXi 7T98+BBLS0vE280iigVlfXs6OjrQ0dFBxG0ilUrh9evXcLvd6OjoIDBKDZJ0dHTA7Xbj9evXRJKs ZVOXdHR0gKZpQWcG+RBFAFd9e4Qelh0fH2NqagrPnz8vOke1YsJiseD58+eYmZnB0dER73auzvlJ +w5dhLgAbvLt4SsCn8+Hw8NDYgtdDfEZHBzE0dERfD4f53tvWvBmfYdIQ1wA+Xx7uIpgamoKNTU1 cLvdpIanIRFutxs1NTWYmppifU++3R4SvkPXQVwAhXx72IpgbGwMDx8+/C78T0M9VFVV4eHDh6ym L4W2OoX6Dt0EcQGw2ZnJJ4JkMolXr15heHgYRqOR9PA0JMZoNGJ4eBivXr269oSeoijW+/xi7PoR b5Gtf4fH48H29val62OxGD58+ICRkRHSw2KFGnxz1NTfRUZGRvDhwwfEYrHc/5lMJvh8Ptb7/CT9 xrII8gUS6ttjMBjw7t079PX14fT0FAaDAWVlZbJlMFabb47S+7uKXq/H2dkZkskkKioq8PHjR3R3 d7PyJ8rw8B0qBOeg+Cz58vb88ccf+Mc//sG6rXQ6jdraWtjtdvz88898hkOMYs/Xr5T6AB8/fgRF URgeHsb9+/dhMplY3Tc3N4fu7u7c9STyDnEWAGnfntPTU9jtdpSXlxNpTwhq9c1Ran83UV5eDoZh cHp6ymlMbH2HuMBpDfD27VsYDAZivj2xWAwGgwE///wz3G73D5eL9EfE6/XC7XbjwYMHSCaTiMfj RNp98eIFDAZDLhCKLawFQDpvTzKZxMLCwqXX8Y+YkPdH4upuT3V1Nd6/f08sI4XH44HD4eDkO8RK AFnfHpJeeW/evEF/f/93r0BNBMXJdVudqVQKQ0NDePPmDbF+PB4PJ98hVgIgnbdnbGws71anJoLi It8+fyKRwMjICFFfHy6+QwUFQDpvz9TUFCu/Hk0ExQHbQ64nT55wcpsoBFvfoYICIJm3x+fzob29 nfUJryYCdcMlkstoNKK9vZ2XA911sPUdKigAUnl7jo+PAYCzb48mAnXCJ4wxaxtZWxECW9+hggIg 4X+RSqVy21980ESgLoTE8Ga3w0kE1bCxXUkEMDExIdifXxOBOiARwP7kyRNMTEwIHgsbFwvRg2oX Fxfx6NEjIm1pIlA2JLM3PHr0SHCMcUVFBaLRaN5rRBVAIBCA2WwmGsaoiUCZkE5dYrFYYDabBUWB yf4GWFpaEiWAXROBshArb09HR4eoGSEAEQUwOzsrahyvJgJlIHbduCdPnmB2dla09okLIJPJ4Pj4 GDU1NaLn7dFEIC9SVA7V6/WoqakRlGUib/ukGzQajfB6vZJlbNNEIA9S1o52uVzwer2ihMgSF8Dq 6irvXJF80UQgLVIXTgeA/v5+UdYDRAWQTqdlKy+qiUAa5DB+4Dyeua2tDZlMhmi7RAWwuLgIiqJI NskJTQTiIpfxZykpKSGef5SYAAKBAGpqamQvM6qJQBzkNn7gPIjKZrMRzRBHTADLy8uSF12+CU0E ZFGC8Wfp6OggmiGOiABomkZrayuJpoihZBGk02kEg0GcnZ3h7OwMwWBQMQHrV1GS8QNAPB5Ha2sr seqVRDINbW1t5SoKKglSxbz5sru7mwv8TyQSMBqNSKVSMJlMqKioyF2n0+lA0zTi8Tgoispdm63s 3tjYKMv4lWb8WZxOJ6anp4lU/xQsAJqmFV1/V0oRMAyDb9++Qa/Xw2g0oqGhIe+mQHZHo7y8/Ma0 MKlUCjs7O0gkErkcSjabTZTxX0Spxp/l9u3boGlasAgEC2B7e1vyfX+uiCmCZDKJzc1N6PV61NXV 4W9/+xvR9imKQlNTU+7fDMNgY2MD6XQaLpdLlHSBSjd+4PwtMDs7K68AAoGAoBKnUkJaBMFgELu7 u7BYLGhrayPSJhtsNlvuDbC9vY1IJILGxkZeWdGuQw3Gn6W2thaBQIB3akRA4CLY5/MpevpzFRIL 41AohNXVVSQSCbjdbrS0tBAaHXdaWlrgdruRSCSwurqKUCgkqD01GT9wPg0SGkPMWwDZPVm1IUQE Xq8XoVAI7e3tcDgchEfGH4fDgfb2doRCIUGfTU3Gn8Vmswk6e+ItgOXlZdy9e5d3x3LCVQQHBwdY W1uDx+MhmiKGNPX19fB4PFhbW8PBwQHr+9Rq/ABw9+5dQecCvAVAKqejXLAVwefPnyWf5wulra0N FosFnz9/Lnitmo0/ixBb5CWAr1+/FkXdrnwiiEajWFhYwL1791Q51bPZbLh37x4WFhZujIstBuMH zjNJfP36lde9vARwcHBw6SBHzVwVgU6ng9/vx+7uLnp6emQcGRl6enqwu7sLv99/KUa2WIwfOA9+ 5zLluwgvAbAtaKAWsiIwGAzY29tDLBaTLKBHClwuF2KxGPb29mAwGIrK+LPwtUlDOBzG2dnZtb4o ZrMZV/++sbGB5ubma7NuXXd9PrheLyYulwszMzNoamqC1WoVrTL5RbIVW6TAarUiFAphZmYG/f39 kny+QoTDYYRCISQSCcHXNzU1YWFh4ZJPWqH2w+EwtzcARVGIRCKyl9ghjU6nw87ODpqamkDTtKwx DWJBURRomkZTUxN2dnZYpQxREyUlJYhEIpy/O0NpaWleg776d5vNljfPT6H2hF4vBn6/H1arFVar FX/5y1+wubkp6RSB1CluPrxeL3p7e5FKpRAMBhGPx2U/yygtLUV5eTlKSkqIXG+z2S4VACx0fWlp Kbc3wMbGBu7cucPlFsUTjUYRCATgdDqRyWSQTCYV7UrNh+ycP5lMIpPJwOl0IhAIFMyapjbu3LmD jY0NTvdwEgDDMLLVmRWLlZWVaxe8xSKCmxa8LpcLKysrMoxIPMxmMxiG4XSP6LlBlcznz5/zbnWq XQSFdnt6enpYHZYVM6wFcHJyomg3AK4cHBzg1q1bBa9TqwjYbnXeunWL9x66Eqmvr8fJyQnr61kL YHt7W7bIJDE4OTlhfcKrNhFw2ee32WycDEbpNDY2Ynt7m/X1rAVAomCBUvB6vZx9e9QiAj6HXG1t bar4bGzhYqusBVAs+8ahUAjV1dW87lW6CISc8FZXVwuOJ1AKXGyVlQAikQgqKyt5D0hJ7OzsCFrL KFUEQt0b6uvrsbOzQ3BE8lFZWYlwOMzqWlYC2NvbuxSXqlaCwSDq6uoEt6M0EZDy7amrq1OEi4RQ mpqasLu7y+paVgJgGEaU4Gup2d3dJXb6qRQRkHRsczgcrA1HyRgMBjAMQ6ZCjF6vLwrvz2QySbRU EyC/CMTw6rRYLLKntySB2WwmVyWyGHaANjc3RQlgl0sEYrk0t7S0YHNzk3i7UpNKpcgIIJFIEP/l lAMxq9VILQKx/fnFruwjBSUlJaxCJQt+Ur/fL7vXoFAYhiGy+M2HVCKQIpilrq6Os0+N0nA4HPD7 /QWvKyiA4+Nj1W+Bfvv2TZK4XrFFIFUkl81mw7dv30TvR0wcDgerNOqs1gBqDxCR8pUulgikDmNU +zQoG7xViIKf8qakrWpCjOJq+SAtAjlieKV+ZmLAJtCmoAAuRtiokd3dXTQ0NEjeLykRyBXA3tDQ oPozATa2W1AAasyJc5FYLCbbFE6oCOTM3kBRFGKxmCx9k4KN7ap7oscCuU+w+YpACalL5H52QiEy BVI7bFNuiAlXESjB+AFlPDshsFnHFL0AlLKYYysCpRg/oJxnJyZFLwAluXEUEoGSjB9Q1rMTi6IW QDqdVpwj300iUJrxA+fpBuXO2Cc2RS2As7MzRSbxvZiLVMm5OisqKiRN3ygHeXODZk/TxMr1KXZu 0OyXl63GyPZ6KXC5XFhYWABwnp5EiblIxX4eJHOD8rm+YG5Qg8HA2ng0NNQI59yghVBablCdTsfZ nUOqXJ3ZpFxKzUWq0+mQyWREex6kc4NyvZ5zblC1UVZWhtPTU7mH8R0Xc3UqORfp6emp7ImLxaao BaDX6xVXy+ymBa8SRRCPx1XvFVqI4v50gKJcuQvt9ihNBEp6dmJR9AJQynE+261OJYlAKc9OTIpe AEo4zue6z68UESjh2QmBjYCLXgByp/jge8ilBBHI/eyEwqYASEEBqD042mw2y+bTIvSEV04RpFIp 1RdDYWO7BQXANseiUmlsbMTe3p7k/ZJyb5BLBHt7e6pPh8/GdgsKoBgyBku9mCPt2yOHCIphAUxk CpROp1XvFiulR6NYjm1Si0DtXqBsE7oVFEBVVZXqK4jU1tZKspYR26tTKhEwDIPa2lrR+xGTk5MT 2O32gtcVFADbDFtKxmaziV4HSyqXZilEcHBwoPpkCGwzGhYUgNFoZJVgSOmI+UqX2p9fbBGoffoD nM//2QRDsVoDFMORuMvl4lQ8jS1yBbOIJYLt7e1r6yarDYqiWAmZlQCU5lDGB4PBQPxNJncklxgi iEQiqk+HApzngyIiAOB8Dq32U0Hg/EyA1HpGbuPPQlIEfr9f9Xv/wPkJts1mYxXMxUoADQ0NRVFA zWq1ElkMK8X4s5ASwcHBgSTBQGKzs7PDWsisBGCxWFS/FZqlqakJ+/v7vO9XmvFnESqC/f39oiiE CJxvgbLNacvaGa5YYoPLy8txdHTE616lGn8WISI4OjoqikzgADdbZS2AYtgJyuLxeLC2tsbpHqUb fxY+IlhbW1PFZ2MLF1tlLYCWlhbVp8u+SGVlJevTYbUYfxYuImAYRvUVgC6yu7vLqRgiawFUVlYK mjsrjbq6Ovz5558Fr1Ob8WdhK4I///xT9PppUrK/v89J0EUfEJOPe/fu5ZJTXYdajT9LIREsLCzg 3r17Eo5IeXASgM1mU33RhKt0dHRcWxdX7caf5SYRbG5uoqOjQ4YRiUcsFuPsw8RJAK2trVhfX+fU gdIpKSmB3W4HTdPQ6XSKztXJl4u5SHU6HWiaht1uZ51gSi2sr6+jtbWV0z15c4Nezd1JURQYhkE4 HL42RkBpuUHZYjKZcHR0hFAoBJqm0dvbq8hcnUJwuVz48OEDnE5nLtubFJ8xHyRzfV5nm4Jzg14l lUrBYrGwirRRE5lMBk1NTdjZ2YHT6VR9ANB1pFIpOJ1O7OzsoKmpqWjOdbJEo1FYLBbO3x3n3KA9 PT349OkT7t+/z+r6QoidG5QtXq8X/f392NnZQTAYhNPplKxvKdwPaJpGJpNBf3+/5LlIb4Jkrs9P nz7lcq2ybZ93btBi8A69yMVcnQ0NDTCbzdcujNXK5uYmzGYzGhoaFJ2LVAh8bZKXAOrq6hSZdJYP Vxe8mUwGDocDjY2NebdI1cLCwgIaGxvhcDguTXuKSQSnp6e8zzJ4CaC5uRk+n49Xh0oi325PSUkJ enp68PnzZ1XmRmIYBp8/f0ZPT8+NU4BiEYHP50NzczOve3kfhCmt9hZX2G513rt3D5FIhLPvkJys ra0hEomwOuQqBhEIsUXeAujs7MSXL194dywnXPf56+rq0NbWBq/Xq2h3kP39fXi9XrS1tXGaEqhZ BF++fEFnZyfv+3kLwGAwqHJqIOSQy+PxoLy8HKurq4rKlOH3+7G6uory8nJBn02NImAYRlAIpyBf ILfbja2tLSFNSAqJE97y8nK0t7fDaDTC5/OJEmjPlu3tbfh8PhiNRrS3twv251ebCLa2tuB2uwW1 ISj62W63Y21tDbdv3xY0CCkg7d5gtVrhdruRTCaxtrYGvV6Puro60fPpMAyDg4MDpNNpuFwu4gHs WREo4ZygEN++fRNse4KfXktLC2ialvTgiCtifqEGgwFtbW0Azo3zf//7H/R6PYxGIxoaGgQHEqVS Kezt7SGRSCCdTqO2tpazvwtX1CACmqY5+f3fhGABOJ1OTE9PK1YAUn6RNpvt0htgd3cXsVgMBoMB iUQCRqMRqVQKJpPpUhFqnU6H09NTxONxUBSVuzaZTMJsNssSq6t0EWxtbWFgYEBwO0Ten7dv31bk W0DuL/CmzATpdPqSI1wmk4HT6VRcQTqlioCmaWLTbiJP3Ol0YmNjg0RTxFDiF5dFr9fDarWirKwM ZWVlsFqtijP+LEpbGJtMJmxsbBD7sSX21Ds7O/H161dSzQlCycavRpQkgpWVFUH7/lchJgC73Y7D w0PZ0+ppxi8OShBB9uyJTdpzthB973Z3d8vqS68Zv7jILYJoNIru7m6ibRIVgF6vx/r6uixxw5rx S4NcIojFYlhbW4NOpyPaLvGVV3t7O2ZnZ0k3mxfN+KVFDhHMzMygq6uLeLvEBZBIJODxeCQLKNGM Xx6kFEE2gk2Mwn3EBaDT6VBVVYXDw0PRA90145cXKUSQTqdxeHiI6upqUdoXbfO5r68Pk5OTYjWv Gb9CEFsEk5OT6OvrE619UU9furq6sLKyQrxdzfiVhVgiWFlZEWXefxFRBWC32xGLxYiWJtKMX5mQ FkEkEkEsFhO0589mx0j08/fu7m68e/eOSFua8SsbkiJ49+6d4D3/QCBQMOUKqyJ5Qnn69Kng9YBm /OqAhAgmJyfx9OlTwWMhUiOMhAAoioLH4+GdSUIzfnUhRAQ+nw8ej4dIQRYiVSKtViuROXxVVRUA 4Pj4mNN9mvGrEz4iyNpG1laEEIlEWGXcKyiAzs5OLC0tCR4QcB5DvLq6yvpAQzN+dcNFBIlEAqur q4JjfLMsLS2x8hotKAC73U40Fcjg4CCr9YBm/MUBWxFMTk5icHCQWL/7+/usdpBY7QINDw9jdHRU 8KAutvfq1asb/64Zf3GRTwRGoxGvXr3C8PAwsf5GR0dZt8dKAFarFU6nk+g+77NnzzAzM/NdJJRm /MXJdSKgKArj4+N49uwZsX68Xi+cTifrjNuszwG6urrg9/uJicBgMKCnp+dSbKxm/MXNVREcHR3h wYMHxIKovF4v/H4/p9NjTgdhjx8/RjKZJDYdMpvNSCaT+PjxY277S6O4yW6Hv3//HgaDgViO2dHR USSTSTx+/JjTfZyl19XVBZfLhZcvX6K+vh5dXV2wWCy5v3OtPFJRUZErb6PxY5BNZ8inPvHFKXMk EsHS0hL29/cxPDzMq9CI7s2bN5mhoSHONwLnR83Ly8sIBoPQ6/UwGAzw+/24desWKyGYTCb88ccf GB4exsnJCZLJJKqrq2ULqwyHwwDOK4do/ZGHoigcHR3ljH9ychIDAwOso7z29/dhNBqh1+uRTqdh tVrR2dnJ219ofn5eeGrEq6+c33//Hd3d3QVP4SiKgs/nQ3d3N+7fv490Oo14PI73799jaGhIlOCH QoRCIQAQnGNT6+97jEYjxsfHMTAwkJv2JJNJAMBPP/1U8EdPr9fjv//9L/75z38SHRfxFA56vZ7V vM7r9aKzsxN7e3u560tKSvD06VO8fv0aIyMjpIdWkKzopCofWuz9XeTVq1d49uzZpQWvTqfDTz/9 hLW1NVbrPzFyJxFvkY3/Rb7dHoPBgJGREYyNjcnyFtAgSyKRwNjYGEZGRq7d7UmlUqwPy8SIMCQu gEK+Q2y3OoeHhzE3N8fZd0hDORwfH2Nubo7VoVQhEbD17eEKcQHk8x3ius8/ODiIw8PDoqhH9qPh 8/lweHjIyb0hnwjY+vZwhbgAbvId4nvI5Xa7UV1djampKRLD05CAyclJ1NTU8HJsu0kEbH17uCJK RNhV3yGhJ7zV1dXo7+/H69eviYZXapAlEong9evXGBwcFOTSfFUEXHx7uCJKIs+s71A2IJ7ECS9F UXj+/DkWFxdhNpvR0dEhuE0NcqysrCAWi+H58+dE2vN4PDn74eLbwxXRYoK7urowNzdHvN3u7m44 nU6Mj4+LnndIozDpdBrj4+NwOp3E83YCwNzcnKiZIUQTgNfrxS+//IJ4PE7UlRo4X2cMDQ3h/fv3 kmWg0/iezc3N3MEl6fn56Ogo4vE4fvnlF1HzDokigItz/q6uLgwODuLly5eYmZn5bg7P1XfoIn19 faioqMDExIQsCXl/VGKxGCYmJlBRUSE4adVV356ZmRm8fPkSg4ODuV9+MZNvCfIFuo58C16hvkM3 YTQasbS0hLa2NpSUlOSO2LlS7L45QvszGAyIRqNYW1tDV1eX4INKrr49pN3l5+fnyQqAzwB///13 /P3vfycyn89kMlhcXITNZkNHRwfi8Tin+4vdN4dvfyaTCSsrK2AYBt3d3URSlPP17SEpAsHOcBfh OzC2vkNsefToEQKBAKamptDa2sqpllSx++bw6Y+maWxsbKCzs5N4vAYf3x7ShfuIrAGEDEiMnZyL XqrT09OgaZp4H8UOTdOYnp4GcB4IJcYhFN/vnuSaQLAAhKqRVN6h63A6nblasrOzs9ja2hKln2Ji a2srV+BkYGBAtNK3Qn17SIlAkABIvIpI5h26CafTib6+PtjtdszMzODLly+i9qdGvnz5gpmZGdjt dvT19Yle85mEbw8JEfBeA5Cah5HOO1Sor/7+fiSTSSwuLiIej8PtdqOiokKS/pXG6ekpfD4fTCYT Ojs7Ja3wub+/j/7+fsHtCF0T8PrEpLejsr5DL168INZmPgwGQ+7U8uvXr1hfX4fJZEJjYyPKysok GYMcGAwGnJ2dYWtrC/F4HHV1dXj48KHk4yDt2yNEBJwFIEbqkot5h6TODNHc3Izm5mYAwMLCAiKR CGw2G+7cuQOz2SzpWMQiFothfX0dDMPAYrGgp6dHtrFwzdvDFr4i4CQAMQ20q6sLb9++lTU3UGtr KyiKQmlpKTY2NnKZKurr69HY2CjLmPiyu7ubm1rabDZ0dnYiHA7LXsfZ7/dzTl3CFj4iYH0QJpVh Li0tgaZpyaZDFwkGgwDw3a/TyckJtre3kUqloNPpUFlZiaamJsFz5pv640oymcTOzg5OTk6QyWRA URRaWlq+SztCqj8+jI6Owul0il7yCGBvq6wPwqT8VS6Ud0gOKisrLxnlyVLcAAABS0lEQVRTOBzG //3f/4FhGJjNZqRSKZSUlMDhcKCyshJGo1GUcSQSCZycnMDv9yMajYKiKMRiMdhsNjQ2NuKvf/2r KP3yhUTeHj5weRMUfAPIOSW56juk0+lgt9sF+Q3lg6uvjE6ng16vh16vRzweh9/vRyAQQCQSQUlJ CUpLS2Gz2VBSUnKtKPL1l0gkEI1GwTAMwuEwotEoLBYL7HY7HA4HTCYT0uk00uk06+chtu+RTqdD IBBAJpMhkrdHKIVst+AbQO5cndflHYpGo6L1pxbfHCX3J0fKlZtg8ya4UQByG/9NiPmA1eCbo6b+ lEAhEVx7EqxU49fQ4EO+E+PvBKAZv0YxcpMILglAM36NYuY6EeQEoBm/xo/AVRHo9Xo9VlZWNOPX +GHIioCiKBjm5+fx/PlzzM/Pyz0u2VFbjK7S+1MyFEVhamoK/w+AyfN+zOygegAAAABJRU5ErkJg gg== "
-       id="image3116"
-       x="0"
-       y="-176" />
-  </g>
-  <g
-     style="display:inline"
-     inkscape:label="base"
-     id="layer2"
-     inkscape:groupmode="layer">
-    <g
-       id="g4704"
-       style="filter:url(#filter4710)">
-      <path
-         style="fill:#8097a2;fill-opacity:1;stroke:none;display:inline"
-         d="m 68,30.7 0,52 -60,0 0,24 60,0 0,52 107.9375,0 c 0.27869,0 0.57242,-0.0352 0.84375,-0.0625 4.06997,-0.41 7.21875,-3.79916 7.21875,-7.96875 l 0,-111.9375 C 184,34.283686 180.39647,30.7 175.9375,30.7 l -107.937501,0 z"
-         id="path3938-4"
-         inkscape:connector-curvature="0" />
-      <path
-         style="fill:#546e7a;fill-opacity:1;stroke:none;display:inline"
-         d="m 68,33.3 0,52 -60,0 0,24 60,0 0,52 107.9375,0 c 0.27869,0 0.57242,-0.0352 0.84375,-0.0625 4.06997,-0.41 7.21875,-3.79916 7.21875,-7.96875 l 0,-111.9375 C 184,36.883686 180.39647,33.3 175.9375,33.3 l -107.937501,0 z"
-         id="path3938-5"
-         inkscape:connector-curvature="0" />
-      <path
-         style="fill:#607d8b;fill-opacity:1;stroke:none"
-         d="m 68,32.000003 0,52 -60,0 L 8,108 l 60,0 0,52 107.9375,0 c 0.27869,0 0.57242,-0.0352 0.84375,-0.0625 4.06997,-0.41 7.21875,-3.79916 7.21875,-7.96875 l 0,-111.937497 c 0,-4.447564 -3.60353,-8.03125 -8.0625,-8.03125 l -107.937501,0 z"
-         id="path3938"
-         inkscape:connector-curvature="0" />
-      <path
-         sodipodi:nodetypes="cccc"
-         inkscape:connector-curvature="0"
-         d="m 107.07401,68.171344 0,55.657316 L 149.27466,96 z"
-         style="fill:#ffffff;stroke:none"
-         inkscape:label="Triangle"
-         id="path4262" />
-    </g>
-  </g>
-  <g
-     style="display:inline"
-     inkscape:label="Layer"
-     id="layer3"
-     inkscape:groupmode="layer"
-     sodipodi:insensitive="true">
-    <path
-       style="opacity:0.11522636;fill:url(#linearGradient4504);fill-opacity:1;stroke:none"
-       d="M 14.214274,89.623384 74.117285,35.304552 143.41187,104.59914 106.15739,181.5665 z"
-       id="path4488"
-       inkscape:connector-curvature="0" />
-    <path
-       style="opacity:0.11522636;fill:url(#linearGradient4521);fill-opacity:1;stroke:none;display:inline"
-       d="m 74,101.96875 -8.09375,7.34375 2.09375,0 0,49.375 0,1.3125 0,1.3125 65.3125,0 L 74,101.96875 z"
-       id="path4488-8"
-       inkscape:connector-curvature="0" />
-    <g
-       transform="translate(0,2.2931745)"
-       id="g4071"
-       style="filter:url(#filter4692)">
-      <path
-         style="fill:#08a0b5;fill-opacity:1;stroke:none;display:inline"
-         d="M 22.0625,154.3 C 17.60353,154.3 14,150.71631 14,146.26875 L 14,102.3 l 60,0 0,52 -51.9375,0 z"
-         id="rect3104-7-2-1"
-         inkscape:connector-curvature="0" />
-      <path
-         style="fill:#33c9dd;fill-opacity:1;stroke:none;display:inline"
-         d="M 22.0625,151.7 C 17.60353,151.7 14,148.11631 14,143.66875 L 14,99.7 l 60,0 0,52 -51.9375,0 z"
-         id="rect3104-7-2-8"
-         inkscape:connector-curvature="0" />
-      <path
-         style="fill:#00bcd4;fill-opacity:1;stroke:none"
-         d="M 22.0625,153 C 17.60353,153 14,149.41631 14,144.96875 L 14,101 l 60,0 0,52 -51.9375,0 z"
-         id="rect3104-7-2"
-         inkscape:connector-curvature="0" />
-    </g>
-    <g
-       transform="translate(-0.511613,5.6775255)"
-       id="g4111"
-       style="filter:url(#filter4680)">
-      <g
-         id="g4106">
-        <path
-           inkscape:connector-curvature="0"
-           id="rect3104-7-2-1-0"
-           d="m 22.574113,29.7293 c -4.45897,0 -8.0625,3.58369 -8.0625,8.03125 l 0,43.96875 60,0 0,-52 -51.9375,0 z"
-           style="fill:#35baf6;fill-opacity:1;stroke:none;display:inline" />
-        <path
-           inkscape:connector-curvature="0"
-           id="rect3104-7-2-8-8"
-           d="m 22.574113,32.3293 c -4.45897,0 -8.0625,3.58369 -8.0625,8.03125 l 0,43.96875 60,0 0,-52 -51.9375,0 z"
-           style="fill:#0a91ce;fill-opacity:1;stroke:none;display:inline" />
-        <path
-           inkscape:connector-curvature="0"
-           id="rect3104-7-2-2"
-           d="m 22.574113,31.0293 c -4.45897,0 -8.0625,3.58369 -8.0625,8.03125 l 0,43.96875 60,0 0,-52 -51.9375,0 z"
-           style="fill:#03a9f4;fill-opacity:1;stroke:none" />
-      </g>
-    </g>
-  </g>
-  <g
-     inkscape:groupmode="layer"
-     id="layer5"
-     inkscape:label="finish"
-     style="opacity:0.18656718;display:inline"
-     sodipodi:insensitive="true">
-    <path
-       inkscape:connector-curvature="0"
-       style="fill:url(#radialGradient4630);fill-opacity:1;stroke:none;display:inline"
-       d="m 67.999998,30.703125 0,1.28125 0,1.3125 0,2.09375 -45.937501,0 c -4.45897,0 -8.0625,3.58369 -8.0625,8.03125 l 0,1.3125 0,1.3125 0,36.65625 -5.9999995,0 0,1.28125 0,1.3125 0,21.406255 0,1.28125 0,1.3125 5.9999995,0 0,36.65624 0,1.3125 0,1.28125 c 0,4.44756 3.60353,8.03125 8.0625,8.03125 l 45.937501,0 0,2.125 0,1.28125 0,1.3125 107.937502,0 c 0.27869,0 0.57242,-0.0352 0.84375,-0.0625 4.06997,-0.41 7.21875,-3.79915 7.21875,-7.96875 l 0,-1.3125 0,-1.28125 0,-109.343745 0,-1.3125 0,-1.28125 c 0,-4.44757 -3.60353,-8.03125 -8.0625,-8.03125 l -107.937503,0 z"
-       id="path3938-4-0" />
-  </g>
-</svg>
diff --git a/demo/build.gradle b/demo/build.gradle
index 27180682fa..007dc70590 100644
--- a/demo/build.gradle
+++ b/demo/build.gradle
@@ -24,24 +24,19 @@ android {
 
     buildTypes {
         release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
+            shrinkResources true
+            minifyEnabled true
+            proguardFiles getDefaultProguardFile('proguard-android.txt')
         }
         debug {
             jniDebuggable = true
-            debuggable = true
         }
     }
 
-    lintOptions {
-        abortOnError false
-    }
-
     productFlavors {
         noExtensions
         withExtensions
     }
-
 }
 
 dependencies {
diff --git a/demo/src/main/AndroidManifest.xml b/demo/src/main/AndroidManifest.xml
index 4c6d832211..2f3dc0d1bf 100644
--- a/demo/src/main/AndroidManifest.xml
+++ b/demo/src/main/AndroidManifest.xml
@@ -16,8 +16,8 @@
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer2.demo"
-    android:versionCode="2101"
-    android:versionName="2.1.1">
+    android:versionCode="2200"
+    android:versionName="2.2.0">
 
   <uses-permission android:name="android.permission.INTERNET"/>
   <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
@@ -27,7 +27,7 @@
 
   <application
       android:label="@string/application_name"
-      android:icon="@drawable/ic_launcher"
+      android:icon="@mipmap/ic_launcher"
       android:banner="@drawable/ic_banner"
       android:largeHeap="true"
       android:allowBackup="false"
diff --git a/demo/src/main/assets/media.exolist.json b/demo/src/main/assets/media.exolist.json
index 6fa46d7451..6fba5bd65b 100644
--- a/demo/src/main/assets/media.exolist.json
+++ b/demo/src/main/assets/media.exolist.json
@@ -183,52 +183,52 @@
         "uri": "https://storage.googleapis.com/wvmedia/clear/vp9/tears/tears_uhd.mpd"
       },
       {
-        "name": "WV: Secure SD & HD (WebM,VP9)",
+        "name": "WV: Secure Fullsample SD & HD (WebM,VP9)",
         "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears.mpd",
         "drm_scheme": "widevine",
         "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
       },
       {
-        "name": "WV: Secure SD (WebM,VP9)",
+        "name": "WV: Secure Fullsample SD (WebM,VP9)",
         "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears_sd.mpd",
         "drm_scheme": "widevine",
         "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
       },
       {
-        "name": "WV: Secure HD (WebM,VP9)",
+        "name": "WV: Secure Fullsample HD (WebM,VP9)",
         "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears_hd.mpd",
         "drm_scheme": "widevine",
         "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
       },
       {
-        "name": "WV: Secure UHD (WebM,VP9)",
+        "name": "WV: Secure Fullsample UHD (WebM,VP9)",
         "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears_uhd.mpd",
         "drm_scheme": "widevine",
         "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
       },
       {
-        "name": "WV: Secure Subsample (WebM, VP9 with altref)",
-        "uri": "https://storage.googleapis.com/widevine_test/vp9/sintel_1080p_vp9_altref_subsample/sintel_1080p_vp9_altref_subsample.mpd",
+        "name": "WV: Secure Subsample SD & HD (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/subsample/24fps/tears/tears.mpd",
         "drm_scheme": "widevine",
-        "drm_license_url": "https://widevine-proxy.appspot.com/proxy"
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
       },
       {
-        "name": "WV: Secure Fullsample (WebM, VP9 with altref)",
-        "uri": "https://storage.googleapis.com/widevine_test/vp9/sintel_1080p_vp9_altref_fullsample/sintel_1080p_vp9_altref_fullsample.mpd",
+        "name": "WV: Secure Subsample SD (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/subsample/24fps/tears/tears_sd.mpd",
         "drm_scheme": "widevine",
-        "drm_license_url": "https://widevine-proxy.appspot.com/proxy"
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
       },
       {
-        "name": "WV: Secure Subsample (WebM, VP9 without altref)",
-        "uri": "https://storage.googleapis.com/widevine_test/vp9/sintel_1080p_vp9_noaltref_subsample/sintel_1080p_vp9_noaltref_subsample.mpd",
+        "name": "WV: Secure Subsample HD (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/subsample/24fps/tears/tears_hd.mpd",
         "drm_scheme": "widevine",
-        "drm_license_url": "https://widevine-proxy.appspot.com/proxy"
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
       },
       {
-        "name": "WV: Secure Fullsample (WebM, VP9 without altref)",
-        "uri": "https://storage.googleapis.com/widevine_test/vp9/sintel_1080p_vp9_noaltref_fullsample/sintel_1080p_vp9_noaltref_fullsample.mpd",
+        "name": "WV: Secure Subsample UHD (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/subsample/24fps/tears/tears_uhd.mpd",
         "drm_scheme": "widevine",
-        "drm_license_url": "https://widevine-proxy.appspot.com/proxy"
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
       }
     ]
   },
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java b/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
index 5ad28f9e72..edc268ddb9 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
@@ -26,16 +26,17 @@
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
-import com.google.android.exoplayer2.drm.StreamingDrmSessionManager;
+import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataRenderer;
+import com.google.android.exoplayer2.metadata.emsg.EventMessage;
 import com.google.android.exoplayer2.metadata.id3.ApicFrame;
 import com.google.android.exoplayer2.metadata.id3.CommentFrame;
 import com.google.android.exoplayer2.metadata.id3.GeobFrame;
 import com.google.android.exoplayer2.metadata.id3.Id3Frame;
 import com.google.android.exoplayer2.metadata.id3.PrivFrame;
 import com.google.android.exoplayer2.metadata.id3.TextInformationFrame;
-import com.google.android.exoplayer2.metadata.id3.TxxxFrame;
+import com.google.android.exoplayer2.metadata.id3.UrlLinkFrame;
 import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener;
 import com.google.android.exoplayer2.source.ExtractorMediaSource;
 import com.google.android.exoplayer2.source.TrackGroup;
@@ -55,7 +56,7 @@
  */
 /* package */ final class EventLogger implements ExoPlayer.EventListener,
     AudioRendererEventListener, VideoRendererEventListener, AdaptiveMediaSourceEventListener,
-    ExtractorMediaSource.EventListener, StreamingDrmSessionManager.EventListener,
+    ExtractorMediaSource.EventListener, DefaultDrmSessionManager.EventListener,
     MetadataRenderer.Output {
 
   private static final String TAG = "EventLogger";
@@ -153,7 +154,7 @@ public void onTracksChanged(TrackGroupArray ignored, TrackSelectionArray trackSe
             String formatSupport = getFormatSupportString(
                 mappedTrackInfo.getTrackFormatSupport(rendererIndex, groupIndex, trackIndex));
             Log.d(TAG, "      " + status + " Track:" + trackIndex + ", "
-                + getFormatString(trackGroup.getFormat(trackIndex))
+                + Format.toLogString(trackGroup.getFormat(trackIndex))
                 + ", supported=" + formatSupport);
           }
           Log.d(TAG, "    ]");
@@ -185,7 +186,7 @@ public void onTracksChanged(TrackGroupArray ignored, TrackSelectionArray trackSe
           String formatSupport = getFormatSupportString(
               RendererCapabilities.FORMAT_UNSUPPORTED_TYPE);
           Log.d(TAG, "      " + status + " Track:" + trackIndex + ", "
-              + getFormatString(trackGroup.getFormat(trackIndex))
+              + Format.toLogString(trackGroup.getFormat(trackIndex))
               + ", supported=" + formatSupport);
         }
         Log.d(TAG, "    ]");
@@ -224,7 +225,7 @@ public void onAudioDecoderInitialized(String decoderName, long elapsedRealtimeMs
 
   @Override
   public void onAudioInputFormatChanged(Format format) {
-    Log.d(TAG, "audioFormatChanged [" + getSessionTimeString() + ", " + getFormatString(format)
+    Log.d(TAG, "audioFormatChanged [" + getSessionTimeString() + ", " + Format.toLogString(format)
         + "]");
   }
 
@@ -254,7 +255,7 @@ public void onVideoDecoderInitialized(String decoderName, long elapsedRealtimeMs
 
   @Override
   public void onVideoInputFormatChanged(Format format) {
-    Log.d(TAG, "videoFormatChanged [" + getSessionTimeString() + ", " + getFormatString(format)
+    Log.d(TAG, "videoFormatChanged [" + getSessionTimeString() + ", " + Format.toLogString(format)
         + "]");
   }
 
@@ -279,13 +280,23 @@ public void onRenderedFirstFrame(Surface surface) {
     // Do nothing.
   }
 
-  // StreamingDrmSessionManager.EventListener
+  // DefaultDrmSessionManager.EventListener
 
   @Override
   public void onDrmSessionManagerError(Exception e) {
     printInternalError("drmSessionManagerError", e);
   }
 
+  @Override
+  public void onDrmKeysRestored() {
+    Log.d(TAG, "drmKeysRestored [" + getSessionTimeString() + "]");
+  }
+
+  @Override
+  public void onDrmKeysRemoved() {
+    Log.d(TAG, "drmKeysRemoved [" + getSessionTimeString() + "]");
+  }
+
   @Override
   public void onDrmKeysLoaded() {
     Log.d(TAG, "drmKeysLoaded [" + getSessionTimeString() + "]");
@@ -349,10 +360,13 @@ private void printInternalError(String type, Exception e) {
   private void printMetadata(Metadata metadata, String prefix) {
     for (int i = 0; i < metadata.length(); i++) {
       Metadata.Entry entry = metadata.get(i);
-      if (entry instanceof TxxxFrame) {
-        TxxxFrame txxxFrame = (TxxxFrame) entry;
-        Log.d(TAG, prefix + String.format("%s: description=%s, value=%s", txxxFrame.id,
-            txxxFrame.description, txxxFrame.value));
+      if (entry instanceof TextInformationFrame) {
+        TextInformationFrame textInformationFrame = (TextInformationFrame) entry;
+        Log.d(TAG, prefix + String.format("%s: value=%s", textInformationFrame.id,
+            textInformationFrame.value));
+      } else if (entry instanceof UrlLinkFrame) {
+        UrlLinkFrame urlLinkFrame = (UrlLinkFrame) entry;
+        Log.d(TAG, prefix + String.format("%s: url=%s", urlLinkFrame.id, urlLinkFrame.url));
       } else if (entry instanceof PrivFrame) {
         PrivFrame privFrame = (PrivFrame) entry;
         Log.d(TAG, prefix + String.format("%s: owner=%s", privFrame.id, privFrame.owner));
@@ -364,17 +378,17 @@ private void printMetadata(Metadata metadata, String prefix) {
         ApicFrame apicFrame = (ApicFrame) entry;
         Log.d(TAG, prefix + String.format("%s: mimeType=%s, description=%s",
             apicFrame.id, apicFrame.mimeType, apicFrame.description));
-      } else if (entry instanceof TextInformationFrame) {
-        TextInformationFrame textInformationFrame = (TextInformationFrame) entry;
-        Log.d(TAG, prefix + String.format("%s: description=%s", textInformationFrame.id,
-            textInformationFrame.description));
       } else if (entry instanceof CommentFrame) {
         CommentFrame commentFrame = (CommentFrame) entry;
-        Log.d(TAG, prefix + String.format("%s: language=%s description=%s", commentFrame.id,
+        Log.d(TAG, prefix + String.format("%s: language=%s, description=%s", commentFrame.id,
             commentFrame.language, commentFrame.description));
       } else if (entry instanceof Id3Frame) {
         Id3Frame id3Frame = (Id3Frame) entry;
         Log.d(TAG, prefix + String.format("%s", id3Frame.id));
+      } else if (entry instanceof EventMessage) {
+        EventMessage eventMessage = (EventMessage) entry;
+        Log.d(TAG, prefix + String.format("EMSG: scheme=%s, id=%d, value=%s",
+            eventMessage.schemeIdUri, eventMessage.id, eventMessage.value));
       }
     }
   }
@@ -433,33 +447,6 @@ private static String getAdaptiveSupportString(int trackCount, int adaptiveSuppo
     }
   }
 
-  private static String getFormatString(Format format) {
-    if (format == null) {
-      return "null";
-    }
-    StringBuilder builder = new StringBuilder();
-    builder.append("id=").append(format.id).append(", mimeType=").append(format.sampleMimeType);
-    if (format.bitrate != Format.NO_VALUE) {
-      builder.append(", bitrate=").append(format.bitrate);
-    }
-    if (format.width != Format.NO_VALUE && format.height != Format.NO_VALUE) {
-      builder.append(", res=").append(format.width).append("x").append(format.height);
-    }
-    if (format.frameRate != Format.NO_VALUE) {
-      builder.append(", fps=").append(format.frameRate);
-    }
-    if (format.channelCount != Format.NO_VALUE) {
-      builder.append(", channels=").append(format.channelCount);
-    }
-    if (format.sampleRate != Format.NO_VALUE) {
-      builder.append(", sample_rate=").append(format.sampleRate);
-    }
-    if (format.language != null) {
-      builder.append(", language=").append(format.language);
-    }
-    return builder.toString();
-  }
-
   private static String getTrackStatusString(TrackSelection selection, TrackGroup group,
       int trackIndex) {
     return getTrackStatusString(selection != null && selection.getTrackGroup() == group
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java b/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
index 243fcadce0..bbfadf34af 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
@@ -36,15 +36,16 @@
 import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.SimpleExoPlayer;
 import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
 import com.google.android.exoplayer2.drm.FrameworkMediaDrm;
 import com.google.android.exoplayer2.drm.HttpMediaDrmCallback;
-import com.google.android.exoplayer2.drm.StreamingDrmSessionManager;
 import com.google.android.exoplayer2.drm.UnsupportedDrmException;
 import com.google.android.exoplayer2.extractor.DefaultExtractorsFactory;
 import com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.DecoderInitializationException;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
+import com.google.android.exoplayer2.source.BehindLiveWindowException;
 import com.google.android.exoplayer2.source.ConcatenatingMediaSource;
 import com.google.android.exoplayer2.source.ExtractorMediaSource;
 import com.google.android.exoplayer2.source.MediaSource;
@@ -100,7 +101,6 @@
   }
 
   private Handler mainHandler;
-  private Timeline.Window window;
   private EventLogger eventLogger;
   private SimpleExoPlayerView simpleExoPlayerView;
   private LinearLayout debugRootView;
@@ -115,9 +115,8 @@
   private boolean playerNeedsSource;
 
   private boolean shouldAutoPlay;
-  private boolean isTimelineStatic;
-  private int playerWindow;
-  private long playerPosition;
+  private int resumeWindow;
+  private long resumePosition;
 
   // Activity lifecycle
 
@@ -125,9 +124,9 @@
   public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     shouldAutoPlay = true;
+    clearResumePosition();
     mediaDataSourceFactory = buildDataSourceFactory(true);
     mainHandler = new Handler();
-    window = new Timeline.Window();
     if (CookieHandler.getDefault() != DEFAULT_COOKIE_MANAGER) {
       CookieHandler.setDefault(DEFAULT_COOKIE_MANAGER);
     }
@@ -148,7 +147,8 @@ public void onCreate(Bundle savedInstanceState) {
   @Override
   public void onNewIntent(Intent intent) {
     releasePlayer();
-    isTimelineStatic = false;
+    shouldAutoPlay = true;
+    clearResumePosition();
     setIntent(intent);
   }
 
@@ -264,7 +264,7 @@ private void initializePlayer() {
       @SimpleExoPlayer.ExtensionRendererMode int extensionRendererMode =
           ((DemoApplication) getApplication()).useExtensionRenderers()
               ? (preferExtensionDecoders ? SimpleExoPlayer.EXTENSION_RENDERER_MODE_PREFER
-                  : SimpleExoPlayer.EXTENSION_RENDERER_MODE_ON)
+              : SimpleExoPlayer.EXTENSION_RENDERER_MODE_ON)
               : SimpleExoPlayer.EXTENSION_RENDERER_MODE_OFF;
       TrackSelection.Factory videoTrackSelectionFactory =
           new AdaptiveVideoTrackSelection.Factory(BANDWIDTH_METER);
@@ -278,16 +278,9 @@ private void initializePlayer() {
       player.addListener(eventLogger);
       player.setAudioDebugListener(eventLogger);
       player.setVideoDebugListener(eventLogger);
-      player.setId3Output(eventLogger);
+      player.setMetadataOutput(eventLogger);
 
       simpleExoPlayerView.setPlayer(player);
-      if (isTimelineStatic) {
-        if (playerPosition == C.TIME_UNSET) {
-          player.seekToDefaultPosition(playerWindow);
-        } else {
-          player.seekTo(playerWindow, playerPosition);
-        }
-      }
       player.setPlayWhenReady(shouldAutoPlay);
       debugViewHelper = new DebugTextViewHelper(player, debugTextView);
       debugViewHelper.start();
@@ -324,7 +317,11 @@ private void initializePlayer() {
       }
       MediaSource mediaSource = mediaSources.length == 1 ? mediaSources[0]
           : new ConcatenatingMediaSource(mediaSources);
-      player.prepare(mediaSource, !isTimelineStatic, !isTimelineStatic);
+      boolean haveResumePosition = resumeWindow != C.INDEX_UNSET;
+      if (haveResumePosition) {
+        player.seekTo(resumeWindow, resumePosition);
+      }
+      player.prepare(mediaSource, !haveResumePosition, false);
       playerNeedsSource = false;
       updateButtonVisibilities();
     }
@@ -358,7 +355,7 @@ private MediaSource buildMediaSource(Uri uri, String overrideExtension) {
     }
     HttpMediaDrmCallback drmCallback = new HttpMediaDrmCallback(licenseUrl,
         buildHttpDataSourceFactory(false), keyRequestProperties);
-    return new StreamingDrmSessionManager<>(uuid,
+    return new DefaultDrmSessionManager<>(uuid,
         FrameworkMediaDrm.newInstance(uuid), drmCallback, null, mainHandler, eventLogger);
   }
 
@@ -367,12 +364,7 @@ private void releasePlayer() {
       debugViewHelper.stop();
       debugViewHelper = null;
       shouldAutoPlay = player.getPlayWhenReady();
-      playerWindow = player.getCurrentWindowIndex();
-      playerPosition = C.TIME_UNSET;
-      Timeline timeline = player.getCurrentTimeline();
-      if (!timeline.isEmpty() && timeline.getWindow(playerWindow, window).isSeekable) {
-        playerPosition = player.getCurrentPosition();
-      }
+      updateResumePosition();
       player.release();
       player = null;
       trackSelector = null;
@@ -381,6 +373,17 @@ private void releasePlayer() {
     }
   }
 
+  private void updateResumePosition() {
+    resumeWindow = player.getCurrentWindowIndex();
+    resumePosition = player.isCurrentWindowSeekable() ? Math.max(0, player.getCurrentPosition())
+        : C.TIME_UNSET;
+  }
+
+  private void clearResumePosition() {
+    resumeWindow = C.INDEX_UNSET;
+    resumePosition = C.TIME_UNSET;
+  }
+
   /**
    * Returns a new DataSource factory.
    *
@@ -422,13 +425,17 @@ public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
 
   @Override
   public void onPositionDiscontinuity() {
-    // Do nothing.
+    if (playerNeedsSource) {
+      // This will only occur if the user has performed a seek whilst in the error state. Update the
+      // resume position so that if the user then retries, playback will resume from the position to
+      // which they seeked.
+      updateResumePosition();
+    }
   }
 
   @Override
   public void onTimelineChanged(Timeline timeline, Object manifest) {
-    isTimelineStatic = !timeline.isEmpty()
-        && !timeline.getWindow(timeline.getWindowCount() - 1, window).isDynamic;
+    // Do nothing.
   }
 
   @Override
@@ -460,8 +467,14 @@ public void onPlayerError(ExoPlaybackException e) {
       showToast(errorString);
     }
     playerNeedsSource = true;
-    updateButtonVisibilities();
-    showControls();
+    if (isBehindLiveWindow(e)) {
+      clearResumePosition();
+      initializePlayer();
+    } else {
+      updateResumePosition();
+      updateButtonVisibilities();
+      showControls();
+    }
   }
 
   @Override
@@ -535,4 +548,18 @@ private void showToast(String message) {
     Toast.makeText(getApplicationContext(), message, Toast.LENGTH_LONG).show();
   }
 
+  private static boolean isBehindLiveWindow(ExoPlaybackException e) {
+    if (e.type != ExoPlaybackException.TYPE_SOURCE) {
+      return false;
+    }
+    Throwable cause = e.getSourceException();
+    while (cause != null) {
+      if (cause instanceof BehindLiveWindowException) {
+        return true;
+      }
+      cause = cause.getCause();
+    }
+    return false;
+  }
+
 }
diff --git a/demo/src/main/res/drawable-hdpi/ic_launcher.png b/demo/src/main/res/drawable-hdpi/ic_launcher.png
deleted file mode 100644
index 3e5716b8ad..0000000000
Binary files a/demo/src/main/res/drawable-hdpi/ic_launcher.png and /dev/null differ
diff --git a/demo/src/main/res/drawable-mdpi/ic_launcher.png b/demo/src/main/res/drawable-mdpi/ic_launcher.png
deleted file mode 100644
index a5d2a53b13..0000000000
Binary files a/demo/src/main/res/drawable-mdpi/ic_launcher.png and /dev/null differ
diff --git a/demo/src/main/res/drawable-xhdpi/ic_banner.png b/demo/src/main/res/drawable-xhdpi/ic_banner.png
index dad9daa4de..520d83cc3b 100644
Binary files a/demo/src/main/res/drawable-xhdpi/ic_banner.png and b/demo/src/main/res/drawable-xhdpi/ic_banner.png differ
diff --git a/demo/src/main/res/drawable-xhdpi/ic_launcher.png b/demo/src/main/res/drawable-xhdpi/ic_launcher.png
deleted file mode 100644
index 1d00268635..0000000000
Binary files a/demo/src/main/res/drawable-xhdpi/ic_launcher.png and /dev/null differ
diff --git a/demo/src/main/res/drawable-xxhdpi/ic_launcher.png b/demo/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index ef2f312fd4..0000000000
Binary files a/demo/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/demo/src/main/res/drawable-xxxhdpi/ic_launcher.png b/demo/src/main/res/drawable-xxxhdpi/ic_launcher.png
deleted file mode 100644
index 0acebb43c1..0000000000
Binary files a/demo/src/main/res/drawable-xxxhdpi/ic_launcher.png and /dev/null differ
diff --git a/demo/src/main/res/mipmap-hdpi/ic_launcher.png b/demo/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100644
index 0000000000..6e8b5499de
Binary files /dev/null and b/demo/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/demo/src/main/res/mipmap-mdpi/ic_launcher.png b/demo/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100644
index 0000000000..26fe2f0782
Binary files /dev/null and b/demo/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/demo/src/main/res/mipmap-xhdpi/ic_launcher.png b/demo/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100644
index 0000000000..d3251491ce
Binary files /dev/null and b/demo/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/demo/src/main/res/mipmap-xxhdpi/ic_launcher.png b/demo/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..b5a12d35f3
Binary files /dev/null and b/demo/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/demo/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/demo/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..9c26192c32
Binary files /dev/null and b/demo/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/demo/src/main/res/values/strings.xml b/demo/src/main/res/values/strings.xml
index c0e1488fe5..ac17ad4443 100644
--- a/demo/src/main/res/values/strings.xml
+++ b/demo/src/main/res/values/strings.xml
@@ -16,8 +16,7 @@
 
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
 
-  <!-- The user visible name of the application. [CHAR LIMIT=20] -->
-  <string name="application_name">ExoPlayer2 Demo</string>
+  <string name="application_name">ExoPlayer</string>
 
   <string name="video">Video</string>
 
diff --git a/extensions/cronet/build.gradle b/extensions/cronet/build.gradle
index 3c9a36c891..a245133937 100644
--- a/extensions/cronet/build.gradle
+++ b/extensions/cronet/build.gradle
@@ -23,17 +23,6 @@ android {
         testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
     }
 
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
-        }
-    }
-
-    lintOptions {
-        abortOnError false
-    }
-
     sourceSets.main {
         jniLibs.srcDirs = ['jniLibs']
     }
diff --git a/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java b/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
index 7efc542dd0..31def44d36 100644
--- a/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
+++ b/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
@@ -57,8 +57,8 @@
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
 import org.chromium.net.CronetEngine;
+import org.chromium.net.NetworkException;
 import org.chromium.net.UrlRequest;
-import org.chromium.net.UrlRequestException;
 import org.chromium.net.UrlResponseInfo;
 import org.chromium.net.impl.UrlResponseInfoImpl;
 import org.junit.Before;
@@ -99,7 +99,7 @@
   @Mock
   private Executor mockExecutor;
   @Mock
-  private UrlRequestException mockUrlRequestException;
+  private NetworkException mockNetworkException;
   @Mock private CronetEngine mockCronetEngine;
 
   private CronetDataSource dataSourceUnderTest;
@@ -172,7 +172,7 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
         dataSourceUnderTest.onFailed(
             mockUrlRequest,
             testUrlResponseInfo,
-            mockUrlRequestException);
+            mockNetworkException);
         dataSourceUnderTest.onResponseStarted(
             mockUrlRequest2,
             testUrlResponseInfo);
@@ -245,8 +245,8 @@ public void testRequestOpenFail() {
   @Test
   public void testRequestOpenFailDueToDnsFailure() {
     mockResponseStartFailure();
-    when(mockUrlRequestException.getErrorCode()).thenReturn(
-        UrlRequestException.ERROR_HOSTNAME_NOT_RESOLVED);
+    when(mockNetworkException.getErrorCode()).thenReturn(
+        NetworkException.ERROR_HOSTNAME_NOT_RESOLVED);
 
     try {
       dataSourceUnderTest.open(testDataSpec);
@@ -728,7 +728,7 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
         dataSourceUnderTest.onFailed(
             mockUrlRequest,
             createUrlResponseInfo(500), // statusCode
-            mockUrlRequestException);
+            mockNetworkException);
         return null;
       }
     }).when(mockUrlRequest).start();
@@ -764,7 +764,7 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
         dataSourceUnderTest.onFailed(
             mockUrlRequest,
             createUrlResponseInfo(500), // statusCode
-            mockUrlRequestException);
+            mockNetworkException);
         return null;
       }
     }).when(mockUrlRequest).read(any(ByteBuffer.class));
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
index 83f46bd488..f6202c6e1e 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
@@ -40,9 +40,10 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import org.chromium.net.CronetEngine;
+import org.chromium.net.CronetException;
+import org.chromium.net.NetworkException;
 import org.chromium.net.UrlRequest;
 import org.chromium.net.UrlRequest.Status;
-import org.chromium.net.UrlRequestException;
 import org.chromium.net.UrlResponseInfo;
 
 /**
@@ -400,12 +401,17 @@ public synchronized void onSucceeded(UrlRequest request, UrlResponseInfo info) {
 
   @Override
   public synchronized void onFailed(UrlRequest request, UrlResponseInfo info,
-      UrlRequestException error) {
+      CronetException error) {
     if (request != currentUrlRequest) {
       return;
     }
-    exception = error.getErrorCode() == UrlRequestException.ERROR_HOSTNAME_NOT_RESOLVED
-        ? new UnknownHostException() : error;
+    if (error instanceof NetworkException
+        && ((NetworkException) error).getErrorCode()
+            == NetworkException.ERROR_HOSTNAME_NOT_RESOLVED) {
+      exception = new UnknownHostException();
+    } else {
+      exception = error;
+    }
     operation.open();
   }
 
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceFactory.java b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceFactory.java
index 0f94dad158..3df901ce59 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceFactory.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceFactory.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.ext.cronet;
 
 import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.HttpDataSource.BaseFactory;
 import com.google.android.exoplayer2.upstream.HttpDataSource.Factory;
 import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Predicate;
@@ -25,7 +26,7 @@
 /**
  * A {@link Factory} that produces {@link CronetDataSource}.
  */
-public final class CronetDataSourceFactory implements Factory {
+public final class CronetDataSourceFactory extends BaseFactory {
 
   /**
    * The default connection timeout, in milliseconds.
@@ -67,7 +68,7 @@ public CronetDataSourceFactory(CronetEngine cronetEngine,
   }
 
   @Override
-  public CronetDataSource createDataSource() {
+  protected CronetDataSource createDataSourceInternal() {
     return new CronetDataSource(cronetEngine, executor, contentTypePredicate, transferListener,
         connectTimeoutMs, readTimeoutMs, resetTimeoutOnRedirects);
   }
diff --git a/extensions/ffmpeg/README.md b/extensions/ffmpeg/README.md
index d7c5e21fcc..0d669f826d 100644
--- a/extensions/ffmpeg/README.md
+++ b/extensions/ffmpeg/README.md
@@ -63,6 +63,7 @@ git clone git://source.ffmpeg.org/ffmpeg ffmpeg && cd ffmpeg && \
     --enable-decoder=vorbis \
     --enable-decoder=opus \
     --enable-decoder=flac \
+    --enable-decoder=alac \
     && \
 make -j4 && \
 make install-libs
diff --git a/extensions/ffmpeg/build.gradle b/extensions/ffmpeg/build.gradle
index 579c663fe2..e0f6d900a0 100644
--- a/extensions/ffmpeg/build.gradle
+++ b/extensions/ffmpeg/build.gradle
@@ -20,17 +20,7 @@ android {
     defaultConfig {
         minSdkVersion 9
         targetSdkVersion project.ext.targetSdkVersion
-    }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
-        }
-    }
-
-    lintOptions {
-        abortOnError false
+        consumerProguardFiles 'proguard-rules.txt'
     }
 
     sourceSets.main {
diff --git a/extensions/ffmpeg/src/main/proguard.cfg b/extensions/ffmpeg/proguard-rules.txt
similarity index 100%
rename from extensions/ffmpeg/src/main/proguard.cfg
rename to extensions/ffmpeg/proguard-rules.txt
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java
index 1a70310a8d..0aac601045 100644
--- a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java
@@ -17,6 +17,7 @@
 
 import android.os.Handler;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.audio.AudioCapabilities;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
@@ -60,7 +61,7 @@ public FfmpegAudioRenderer(Handler eventHandler, AudioRendererEventListener even
   }
 
   @Override
-  public int supportsFormat(Format format) {
+  protected int supportsFormatInternal(Format format) {
     if (!FfmpegLibrary.isAvailable()) {
       return FORMAT_UNSUPPORTED_TYPE;
     }
@@ -69,6 +70,11 @@ public int supportsFormat(Format format) {
         : MimeTypes.isAudio(mimeType) ? FORMAT_UNSUPPORTED_SUBTYPE : FORMAT_UNSUPPORTED_TYPE;
   }
 
+  @Override
+  public final int supportsMixedMimeTypeAdaptation() throws ExoPlaybackException {
+    return ADAPTIVE_NOT_SEAMLESS;
+  }
+
   @Override
   protected FfmpegDecoder createDecoder(Format format, ExoMediaCrypto mediaCrypto)
       throws FfmpegDecoderException {
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
index 12f4bcf672..2af2101ee7 100644
--- a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.decoder.SimpleDecoder;
 import com.google.android.exoplayer2.decoder.SimpleOutputBuffer;
 import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.nio.ByteBuffer;
 import java.util.List;
 
@@ -88,6 +89,13 @@ public FfmpegDecoderException decode(DecoderInputBuffer inputBuffer,
     if (!hasOutputFormat) {
       channelCount = ffmpegGetChannelCount(nativeContext);
       sampleRate = ffmpegGetSampleRate(nativeContext);
+      if (sampleRate == 0 && "alac".equals(codecName)) {
+        // ALAC decoder did not set the sample rate in earlier versions of FFMPEG.
+        // See https://trac.ffmpeg.org/ticket/6096
+        ParsableByteArray parsableExtraData = new ParsableByteArray(extraData);
+        parsableExtraData.setPosition(extraData.length - 4);
+        sampleRate = parsableExtraData.readUnsignedIntToInt();
+      }
       hasOutputFormat = true;
     }
     outputBuffer.data.position(0);
@@ -123,6 +131,7 @@ public int getSampleRate() {
   private static byte[] getExtraData(String mimeType, List<byte[]> initializationData) {
     switch (mimeType) {
       case MimeTypes.AUDIO_AAC:
+      case MimeTypes.AUDIO_ALAC:
       case MimeTypes.AUDIO_OPUS:
         return initializationData.get(0);
       case MimeTypes.AUDIO_VORBIS:
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegLibrary.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegLibrary.java
index 90b42c01bb..4992bcbb3e 100644
--- a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegLibrary.java
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegLibrary.java
@@ -92,6 +92,8 @@ public static boolean supportsFormat(String mimeType) {
         return "amrwb";
       case MimeTypes.AUDIO_FLAC:
         return "flac";
+      case MimeTypes.AUDIO_ALAC:
+        return "alac";
       default:
         return null;
     }
diff --git a/extensions/flac/build.gradle b/extensions/flac/build.gradle
index a40a1adead..7f1a790dad 100644
--- a/extensions/flac/build.gradle
+++ b/extensions/flac/build.gradle
@@ -20,17 +20,7 @@ android {
     defaultConfig {
         minSdkVersion 9
         targetSdkVersion project.ext.targetSdkVersion
-    }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
-        }
-    }
-
-    lintOptions {
-        abortOnError false
+        consumerProguardFiles 'proguard-rules.txt'
     }
 
     sourceSets.main {
diff --git a/extensions/flac/src/main/proguard.cfg b/extensions/flac/proguard-rules.txt
similarity index 100%
rename from extensions/flac/src/main/proguard.cfg
rename to extensions/flac/proguard-rules.txt
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java
index 954a090ee9..eb7206c9cf 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java
@@ -56,7 +56,7 @@ public LibflacAudioRenderer(Handler eventHandler, AudioRendererEventListener eve
   }
 
   @Override
-  public int supportsFormat(Format format) {
+  protected int supportsFormatInternal(Format format) {
     return FlacLibrary.isAvailable() && MimeTypes.AUDIO_FLAC.equalsIgnoreCase(format.sampleMimeType)
         ? FORMAT_HANDLED : FORMAT_UNSUPPORTED_TYPE;
   }
diff --git a/extensions/okhttp/build.gradle b/extensions/okhttp/build.gradle
index 442f0f78dc..bbf69c60e4 100644
--- a/extensions/okhttp/build.gradle
+++ b/extensions/okhttp/build.gradle
@@ -22,17 +22,6 @@ android {
         minSdkVersion 9
         targetSdkVersion project.ext.targetSdkVersion
     }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
-        }
-    }
-
-    lintOptions {
-        abortOnError false
-    }
 }
 
 dependencies {
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
index 8577d33781..90a4728933 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
@@ -261,7 +261,7 @@ protected final long bytesRemaining() {
   private Request makeRequest(DataSpec dataSpec) {
     long position = dataSpec.position;
     long length = dataSpec.length;
-    boolean allowGzip = (dataSpec.flags & DataSpec.FLAG_ALLOW_GZIP) != 0;
+    boolean allowGzip = dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_GZIP);
 
     HttpUrl url = HttpUrl.parse(dataSpec.uri.toString());
     Request.Builder builder = new Request.Builder().url(url);
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java
index 33f204a6f3..8cbe295fa4 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.ext.okhttp;
 
 import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.HttpDataSource.BaseFactory;
 import com.google.android.exoplayer2.upstream.HttpDataSource.Factory;
 import com.google.android.exoplayer2.upstream.TransferListener;
 import okhttp3.CacheControl;
@@ -24,7 +25,7 @@
 /**
  * A {@link Factory} that produces {@link OkHttpDataSource}.
  */
-public final class OkHttpDataSourceFactory implements Factory {
+public final class OkHttpDataSourceFactory extends BaseFactory {
 
   private final Call.Factory callFactory;
   private final String userAgent;
@@ -58,7 +59,7 @@ public OkHttpDataSourceFactory(Call.Factory callFactory, String userAgent,
   }
 
   @Override
-  public OkHttpDataSource createDataSource() {
+  protected OkHttpDataSource createDataSourceInternal() {
     return new OkHttpDataSource(callFactory, userAgent, null, listener, cacheControl);
   }
 
diff --git a/extensions/opus/build.gradle b/extensions/opus/build.gradle
index 3bc06ddaf4..d354654c14 100644
--- a/extensions/opus/build.gradle
+++ b/extensions/opus/build.gradle
@@ -20,17 +20,7 @@ android {
     defaultConfig {
         minSdkVersion 9
         targetSdkVersion project.ext.targetSdkVersion
-    }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
-        }
-    }
-
-    lintOptions {
-        abortOnError false
+        consumerProguardFiles 'proguard-rules.txt'
     }
 
     sourceSets.main {
diff --git a/extensions/opus/src/main/proguard.cfg b/extensions/opus/proguard-rules.txt
similarity index 100%
rename from extensions/opus/src/main/proguard.cfg
rename to extensions/opus/proguard-rules.txt
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java
index 2dd2697aab..1850e68229 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java
@@ -72,7 +72,7 @@ public LibopusAudioRenderer(Handler eventHandler, AudioRendererEventListener eve
   }
 
   @Override
-  public int supportsFormat(Format format) {
+  protected int supportsFormatInternal(Format format) {
     return OpusLibrary.isAvailable() && MimeTypes.AUDIO_OPUS.equalsIgnoreCase(format.sampleMimeType)
         ? FORMAT_HANDLED : FORMAT_UNSUPPORTED_TYPE;
   }
diff --git a/extensions/vp9/build.gradle b/extensions/vp9/build.gradle
index 3bc06ddaf4..d354654c14 100644
--- a/extensions/vp9/build.gradle
+++ b/extensions/vp9/build.gradle
@@ -20,17 +20,7 @@ android {
     defaultConfig {
         minSdkVersion 9
         targetSdkVersion project.ext.targetSdkVersion
-    }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
-        }
-    }
-
-    lintOptions {
-        abortOnError false
+        consumerProguardFiles 'proguard-rules.txt'
     }
 
     sourceSets.main {
diff --git a/extensions/vp9/src/main/proguard.cfg b/extensions/vp9/proguard-rules.txt
similarity index 100%
rename from extensions/vp9/src/main/proguard.cfg
rename to extensions/vp9/proguard-rules.txt
diff --git a/library/build.gradle b/library/build.gradle
index 13e9c6905a..9a7b7e071d 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,5 +1,3 @@
-import com.android.builder.core.BuilderConstants
-
 // Copyright (C) 2016 The Android Open Source Project
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
@@ -13,6 +11,8 @@ import com.android.builder.core.BuilderConstants
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
+import com.android.builder.core.BuilderConstants
+
 apply plugin: 'com.android.library'
 //apply plugin: 'bintray-release'
 
@@ -28,13 +28,10 @@ android {
         // greater.
         minSdkVersion 9
         targetSdkVersion project.ext.targetSdkVersion
+        consumerProguardFiles 'proguard-rules.txt'
     }
 
     buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
-        }
         // Re-enable test coverage when the following issue is fixed:
         // https://code.google.com/p/android/issues/detail?id=226070
         // debug {
@@ -42,10 +39,6 @@ android {
         // }
     }
 
-    lintOptions {
-        abortOnError false
-    }
-
     sourceSets {
         androidTest {
             java.srcDirs += "../testutils/src/main/java/"
diff --git a/library/proguard-rules.txt b/library/proguard-rules.txt
new file mode 100644
index 0000000000..75f2d095be
--- /dev/null
+++ b/library/proguard-rules.txt
@@ -0,0 +1,7 @@
+# Accessed via reflection in SubtitleDecoderFactory.DEFAULT
+-keepclassmembers class com.google.android.exoplayer2.text.cea.Cea608Decoder {
+    public <init>(java.lang.String, int);
+}
+-keepclassmembers class com.google.android.exoplayer2.text.cea.Cea708Decoder {
+    public <init>(int);
+}
diff --git a/library/src/androidTest/assets/mp4/sample_fragmented_zero_size_atom.mp4 b/library/src/androidTest/assets/mp4/sample_fragmented_zero_size_atom.mp4
new file mode 100644
index 0000000000..3d3c63786e
Binary files /dev/null and b/library/src/androidTest/assets/mp4/sample_fragmented_zero_size_atom.mp4 differ
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/ExoPlayerTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/ExoPlayerTest.java
index be18d64195..1197139b01 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/ExoPlayerTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/ExoPlayerTest.java
@@ -21,7 +21,6 @@
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.SampleStream;
-import com.google.android.exoplayer2.source.SinglePeriodTimeline;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
@@ -29,8 +28,10 @@
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.MediaClock;
 import com.google.android.exoplayer2.util.MimeTypes;
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
@@ -48,12 +49,112 @@
    */
   private static final int TIMEOUT_MS = 10000;
 
-  public void testPlayToEnd() throws Exception {
+  private static final Format TEST_VIDEO_FORMAT = Format.createVideoSampleFormat(null,
+      MimeTypes.VIDEO_H264, null, Format.NO_VALUE, Format.NO_VALUE, 1280, 720, Format.NO_VALUE,
+      null, null);
+  private static final Format TEST_AUDIO_FORMAT =  Format.createAudioSampleFormat(null,
+      MimeTypes.AUDIO_AAC, null, Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, null);
+
+  /**
+   * Tests playback of a source that exposes an empty timeline. Playback is expected to end without
+   * error.
+   */
+  public void testPlayEmptyTimeline() throws Exception {
+    PlayerWrapper playerWrapper = new PlayerWrapper();
+    Timeline timeline = Timeline.EMPTY;
+    MediaSource mediaSource = new FakeMediaSource(timeline, null);
+    FakeRenderer renderer = new FakeRenderer(null);
+    playerWrapper.setup(mediaSource, renderer);
+    playerWrapper.blockUntilEnded(TIMEOUT_MS);
+    assertEquals(0, playerWrapper.positionDiscontinuityCount);
+    assertEquals(0, renderer.formatReadCount);
+    assertEquals(0, renderer.bufferReadCount);
+    assertFalse(renderer.isEnded);
+    assertEquals(timeline, playerWrapper.timeline);
+    assertNull(playerWrapper.manifest);
+  }
+
+  /**
+   * Tests playback of a source that exposes a single period.
+   */
+  public void testPlaySinglePeriodTimeline() throws Exception {
+    PlayerWrapper playerWrapper = new PlayerWrapper();
+    Timeline timeline = new FakeTimeline(new TimelineWindowDefinition(false, false, 0));
+    Object manifest = new Object();
+    MediaSource mediaSource = new FakeMediaSource(timeline, manifest, TEST_VIDEO_FORMAT);
+    FakeRenderer renderer = new FakeRenderer(TEST_VIDEO_FORMAT);
+    playerWrapper.setup(mediaSource, renderer);
+    playerWrapper.blockUntilEnded(TIMEOUT_MS);
+    assertEquals(0, playerWrapper.positionDiscontinuityCount);
+    assertEquals(1, renderer.formatReadCount);
+    assertEquals(1, renderer.bufferReadCount);
+    assertTrue(renderer.isEnded);
+    assertEquals(timeline, playerWrapper.timeline);
+    assertEquals(manifest, playerWrapper.manifest);
+    assertEquals(new TrackGroupArray(new TrackGroup(TEST_VIDEO_FORMAT)), playerWrapper.trackGroups);
+  }
+
+  /**
+   * Tests playback of a source that exposes three periods.
+   */
+  public void testPlayMultiPeriodTimeline() throws Exception {
     PlayerWrapper playerWrapper = new PlayerWrapper();
-    Format format = Format.createVideoSampleFormat(null, MimeTypes.VIDEO_H264, null,
-        Format.NO_VALUE, Format.NO_VALUE, 1280, 720, Format.NO_VALUE, null, null);
-    playerWrapper.setup(new SinglePeriodTimeline(0, false), new Object(), format);
-    playerWrapper.blockUntilEndedOrError(TIMEOUT_MS);
+    Timeline timeline = new FakeTimeline(
+        new TimelineWindowDefinition(false, false, 0),
+        new TimelineWindowDefinition(false, false, 0),
+        new TimelineWindowDefinition(false, false, 0));
+    MediaSource mediaSource = new FakeMediaSource(timeline, null, TEST_VIDEO_FORMAT);
+    FakeRenderer renderer = new FakeRenderer(TEST_VIDEO_FORMAT);
+    playerWrapper.setup(mediaSource, renderer);
+    playerWrapper.blockUntilEnded(TIMEOUT_MS);
+    assertEquals(2, playerWrapper.positionDiscontinuityCount);
+    assertEquals(3, renderer.formatReadCount);
+    assertEquals(1, renderer.bufferReadCount);
+    assertTrue(renderer.isEnded);
+    assertEquals(timeline, playerWrapper.timeline);
+    assertNull(playerWrapper.manifest);
+  }
+
+  /**
+   * Tests that the player does not unnecessarily reset renderers when playing a multi-period
+   * source.
+   */
+  public void testReadAheadToEndDoesNotResetRenderer() throws Exception {
+    final PlayerWrapper playerWrapper = new PlayerWrapper();
+    Timeline timeline = new FakeTimeline(
+        new TimelineWindowDefinition(false, false, 10),
+        new TimelineWindowDefinition(false, false, 10),
+        new TimelineWindowDefinition(false, false, 10));
+    MediaSource mediaSource = new FakeMediaSource(timeline, null, TEST_VIDEO_FORMAT,
+        TEST_AUDIO_FORMAT);
+
+    FakeRenderer videoRenderer = new FakeRenderer(TEST_VIDEO_FORMAT);
+    FakeMediaClockRenderer audioRenderer = new FakeMediaClockRenderer(TEST_AUDIO_FORMAT) {
+
+      @Override
+      public long getPositionUs() {
+        // Simulate the playback position lagging behind the reading position: the renderer media
+        // clock position will be the start of the timeline until the stream is set to be final, at
+        // which point it jumps to the end of the timeline allowing the playing period to advance.
+        // TODO: Avoid hard-coding ExoPlayerImplInternal.RENDERER_TIMESTAMP_OFFSET_US.
+        return isCurrentStreamFinal() ? 60000030 : 60000000;
+      }
+
+      @Override
+      public boolean isEnded() {
+        // Allow playback to end once the final period is playing.
+        return playerWrapper.positionDiscontinuityCount == 2;
+      }
+
+    };
+    playerWrapper.setup(mediaSource, videoRenderer, audioRenderer);
+    playerWrapper.blockUntilEnded(TIMEOUT_MS);
+    assertEquals(2, playerWrapper.positionDiscontinuityCount);
+    assertEquals(1, audioRenderer.positionResetCount);
+    assertTrue(videoRenderer.isEnded);
+    assertTrue(audioRenderer.isEnded);
+    assertEquals(timeline, playerWrapper.timeline);
+    assertNull(playerWrapper.manifest);
   }
 
   /**
@@ -65,12 +166,14 @@ public void testPlayToEnd() throws Exception {
     private final HandlerThread playerThread;
     private final Handler handler;
 
-    private Timeline expectedTimeline;
-    private Object expectedManifest;
-    private Format expectedFormat;
     private ExoPlayer player;
+    private Timeline timeline;
+    private Object manifest;
+    private TrackGroupArray trackGroups;
     private Exception exception;
-    private boolean seenPositionDiscontinuity;
+
+    // Written only on the main thread.
+    private volatile int positionDiscontinuityCount;
 
     public PlayerWrapper() {
       endedCountDownLatch = new CountDownLatch(1);
@@ -81,34 +184,28 @@ public PlayerWrapper() {
 
     // Called on the test thread.
 
-    public void blockUntilEndedOrError(long timeoutMs) throws Exception {
+    public void blockUntilEnded(long timeoutMs) throws Exception {
       if (!endedCountDownLatch.await(timeoutMs, TimeUnit.MILLISECONDS)) {
         exception = new TimeoutException("Test playback timed out.");
       }
       release();
-
       // Throw any pending exception (from playback, timing out or releasing).
       if (exception != null) {
         throw exception;
       }
     }
 
-    public void setup(final Timeline timeline, final Object manifest, final Format format) {
-      expectedTimeline = timeline;
-      expectedManifest = manifest;
-      expectedFormat = format;
+    public void setup(final MediaSource mediaSource, final Renderer... renderers) {
       handler.post(new Runnable() {
         @Override
         public void run() {
           try {
-            Renderer fakeRenderer = new FakeVideoRenderer(expectedFormat);
-            player = ExoPlayerFactory.newInstance(new Renderer[] {fakeRenderer},
-                new DefaultTrackSelector());
+            player = ExoPlayerFactory.newInstance(renderers, new DefaultTrackSelector());
             player.addListener(PlayerWrapper.this);
             player.setPlayWhenReady(true);
-            player.prepare(new FakeMediaSource(timeline, manifest, format));
+            player.prepare(mediaSource);
           } catch (Exception e) {
-            handlePlayerException(e);
+            handleError(e);
           }
         }
       });
@@ -123,7 +220,7 @@ public void run() {
               player.release();
             }
           } catch (Exception e) {
-            handlePlayerException(e);
+            handleError(e);
           } finally {
             playerThread.quit();
           }
@@ -132,7 +229,7 @@ public void run() {
       playerThread.join();
     }
 
-    private void handlePlayerException(Exception exception) {
+    private void handleError(Exception exception) {
       if (this.exception == null) {
         this.exception = exception;
       }
@@ -155,32 +252,83 @@ public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
 
     @Override
     public void onTimelineChanged(Timeline timeline, Object manifest) {
-      assertEquals(expectedTimeline, timeline);
-      assertEquals(expectedManifest, manifest);
+      this.timeline = timeline;
+      this.manifest = manifest;
     }
 
     @Override
-    public void onTracksChanged(TrackGroupArray trackGroups,
-        TrackSelectionArray trackSelections) {
-      assertEquals(new TrackGroupArray(new TrackGroup(expectedFormat)), trackGroups);
+    public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
+      this.trackGroups = trackGroups;
     }
 
     @Override
     public void onPlayerError(ExoPlaybackException exception) {
-      this.exception = exception;
-      endedCountDownLatch.countDown();
+      handleError(exception);
     }
 
+    @SuppressWarnings("NonAtomicVolatileUpdate")
     @Override
     public void onPositionDiscontinuity() {
-      assertFalse(seenPositionDiscontinuity);
-      assertEquals(0, player.getCurrentWindowIndex());
-      assertEquals(0, player.getCurrentPeriodIndex());
-      assertEquals(0, player.getCurrentPosition());
-      assertEquals(0, player.getBufferedPosition());
-      assertEquals(expectedTimeline, player.getCurrentTimeline());
-      assertEquals(expectedManifest, player.getCurrentManifest());
-      seenPositionDiscontinuity = true;
+      positionDiscontinuityCount++;
+    }
+
+  }
+
+  private static final class TimelineWindowDefinition {
+
+    public final boolean isSeekable;
+    public final boolean isDynamic;
+    public final long durationUs;
+
+    public TimelineWindowDefinition(boolean isSeekable, boolean isDynamic, long durationUs) {
+      this.isSeekable = isSeekable;
+      this.isDynamic = isDynamic;
+      this.durationUs = durationUs;
+    }
+
+  }
+
+  private static final class FakeTimeline extends Timeline {
+
+    private final TimelineWindowDefinition[] windowDefinitions;
+
+    public FakeTimeline(TimelineWindowDefinition... windowDefinitions) {
+      this.windowDefinitions = windowDefinitions;
+    }
+
+    @Override
+    public int getWindowCount() {
+      return windowDefinitions.length;
+    }
+
+    @Override
+    public Window getWindow(int windowIndex, Window window, boolean setIds,
+        long defaultPositionProjectionUs) {
+      TimelineWindowDefinition windowDefinition = windowDefinitions[windowIndex];
+      Object id = setIds ? windowIndex : null;
+      return window.set(id, C.TIME_UNSET, C.TIME_UNSET, windowDefinition.isSeekable,
+          windowDefinition.isDynamic, 0, windowDefinition.durationUs, windowIndex, windowIndex, 0);
+    }
+
+    @Override
+    public int getPeriodCount() {
+      return windowDefinitions.length;
+    }
+
+    @Override
+    public Period getPeriod(int periodIndex, Period period, boolean setIds) {
+      TimelineWindowDefinition windowDefinition = windowDefinitions[periodIndex];
+      Object id = setIds ? periodIndex : null;
+      return period.set(id, id, periodIndex, windowDefinition.durationUs, 0);
+    }
+
+    @Override
+    public int getIndexOfPeriod(Object uid) {
+      if (!(uid instanceof Integer)) {
+        return C.INDEX_UNSET;
+      }
+      int index = (Integer) uid;
+      return index >= 0 && index < windowDefinitions.length ? index : C.INDEX_UNSET;
     }
 
   }
@@ -193,18 +341,21 @@ public void onPositionDiscontinuity() {
 
     private final Timeline timeline;
     private final Object manifest;
-    private final Format format;
+    private final TrackGroupArray trackGroupArray;
+    private final ArrayList<FakeMediaPeriod> activeMediaPeriods;
 
-    private FakeMediaPeriod mediaPeriod;
     private boolean preparedSource;
-    private boolean releasedPeriod;
     private boolean releasedSource;
 
-    public FakeMediaSource(Timeline timeline, Object manifest, Format format) {
-      Assertions.checkArgument(timeline.getPeriodCount() == 1);
+    public FakeMediaSource(Timeline timeline, Object manifest, Format... formats) {
       this.timeline = timeline;
       this.manifest = manifest;
-      this.format = format;
+      TrackGroup[] trackGroups = new TrackGroup[formats.length];
+      for (int i = 0; i < formats.length; i++) {
+        trackGroups[i] = new TrackGroup(formats[i]);
+      }
+      trackGroupArray = new TrackGroupArray(trackGroups);
+      activeMediaPeriods = new ArrayList<>();
     }
 
     @Override
@@ -221,33 +372,29 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
 
     @Override
     public MediaPeriod createPeriod(int index, Allocator allocator, long positionUs) {
+      Assertions.checkIndex(index, 0, timeline.getPeriodCount());
       assertTrue(preparedSource);
-      assertNull(mediaPeriod);
-      assertFalse(releasedPeriod);
       assertFalse(releasedSource);
-      assertEquals(0, index);
       assertEquals(0, positionUs);
-      mediaPeriod = new FakeMediaPeriod(format);
+      FakeMediaPeriod mediaPeriod = new FakeMediaPeriod(trackGroupArray);
+      activeMediaPeriods.add(mediaPeriod);
       return mediaPeriod;
     }
 
     @Override
     public void releasePeriod(MediaPeriod mediaPeriod) {
       assertTrue(preparedSource);
-      assertNotNull(this.mediaPeriod);
-      assertFalse(releasedPeriod);
       assertFalse(releasedSource);
-      assertEquals(this.mediaPeriod, mediaPeriod);
-      this.mediaPeriod.release();
-      releasedPeriod = true;
+      FakeMediaPeriod fakeMediaPeriod = (FakeMediaPeriod) mediaPeriod;
+      assertTrue(activeMediaPeriods.remove(fakeMediaPeriod));
+      fakeMediaPeriod.release();
     }
 
     @Override
     public void releaseSource() {
       assertTrue(preparedSource);
-      assertNotNull(this.mediaPeriod);
-      assertTrue(releasedPeriod);
       assertFalse(releasedSource);
+      assertTrue(activeMediaPeriods.isEmpty());
       releasedSource = true;
     }
 
@@ -259,12 +406,12 @@ public void releaseSource() {
    */
   private static final class FakeMediaPeriod implements MediaPeriod {
 
-    private final TrackGroup trackGroup;
+    private final TrackGroupArray trackGroupArray;
 
     private boolean preparedPeriod;
 
-    public FakeMediaPeriod(Format format) {
-      trackGroup = new TrackGroup(format);
+    public FakeMediaPeriod(TrackGroupArray trackGroupArray) {
+      this.trackGroupArray = trackGroupArray;
     }
 
     public void release() {
@@ -286,26 +433,29 @@ public void maybeThrowPrepareError() throws IOException {
     @Override
     public TrackGroupArray getTrackGroups() {
       assertTrue(preparedPeriod);
-      return new TrackGroupArray(trackGroup);
+      return trackGroupArray;
     }
 
     @Override
     public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
         SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
       assertTrue(preparedPeriod);
-      assertEquals(1, selections.length);
-      assertEquals(1, mayRetainStreamFlags.length);
-      assertEquals(1, streams.length);
-      assertEquals(1, streamResetFlags.length);
-      assertEquals(0, positionUs);
-      if (streams[0] != null && (selections[0] == null || !mayRetainStreamFlags[0])) {
-        streams[0] = null;
+      int rendererCount = selections.length;
+      for (int i = 0; i < rendererCount; i++) {
+        if (streams[i] != null && (selections[i] == null || !mayRetainStreamFlags[i])) {
+          streams[i] = null;
+        }
       }
-      if (streams[0] == null && selections[0] != null) {
-        FakeSampleStream stream = new FakeSampleStream(trackGroup.getFormat(0));
-        assertEquals(trackGroup, selections[0].getTrackGroup());
-        streams[0] = stream;
-        streamResetFlags[0] = true;
+      for (int i = 0; i < rendererCount; i++) {
+        if (streams[i] == null && selections[i] != null) {
+          TrackSelection selection = selections[i];
+          assertEquals(1, selection.length());
+          assertEquals(0, selection.getIndexInTrackGroup(0));
+          TrackGroup trackGroup = selection.getTrackGroup();
+          assertTrue(trackGroupArray.indexOf(trackGroup) != C.INDEX_UNSET);
+          streams[i] = new FakeSampleStream(trackGroup.getFormat(0));
+          streamResetFlags[i] = true;
+        }
       }
       return 0;
     }
@@ -332,7 +482,7 @@ public long seekToUs(long positionUs) {
     @Override
     public long getNextLoadPositionUs() {
       assertTrue(preparedPeriod);
-      return 0;
+      return C.TIME_END_OF_SOURCE;
     }
 
     @Override
@@ -352,7 +502,6 @@ public boolean continueLoading(long positionUs) {
     private final Format format;
 
     private boolean readFormat;
-    private boolean readEndOfStream;
 
     public FakeSampleStream(Format format) {
       this.format = format;
@@ -365,15 +514,14 @@ public boolean isReady() {
 
     @Override
     public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer) {
-      Assertions.checkState(!readEndOfStream);
-      if (readFormat) {
+      if (buffer == null || !readFormat) {
+        formatHolder.format = format;
+        readFormat = true;
+        return C.RESULT_FORMAT_READ;
+      } else {
         buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
-        readEndOfStream = true;
         return C.RESULT_BUFFER_READ;
       }
-      formatHolder.format = format;
-      readFormat = true;
-      return C.RESULT_FORMAT_READ;
     }
 
     @Override
@@ -389,21 +537,30 @@ public void skipToKeyframeBefore(long timeUs) {
   }
 
   /**
-   * Fake {@link Renderer} that supports any video format. The renderer verifies that it reads a
-   * given {@link Format} then a buffer with the end of stream flag set.
+   * Fake {@link Renderer} that supports any format with the matching MIME type. The renderer
+   * verifies that it reads a given {@link Format}.
    */
-  private static final class FakeVideoRenderer extends BaseRenderer {
+  private static class FakeRenderer extends BaseRenderer {
 
     private final Format expectedFormat;
 
-    private boolean isEnded;
+    public int positionResetCount;
+    public int formatReadCount;
+    public int bufferReadCount;
+    public boolean isEnded;
 
-    public FakeVideoRenderer(Format expectedFormat) {
-      super(C.TRACK_TYPE_VIDEO);
-      Assertions.checkArgument(MimeTypes.isVideo(expectedFormat.sampleMimeType));
+    public FakeRenderer(Format expectedFormat) {
+      super(expectedFormat == null ? C.TRACK_TYPE_UNKNOWN
+          : MimeTypes.getTrackType(expectedFormat.sampleMimeType));
       this.expectedFormat = expectedFormat;
     }
 
+    @Override
+    protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {
+      positionResetCount++;
+      isEnded = false;
+    }
+
     @Override
     public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
       if (isEnded) {
@@ -412,20 +569,23 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
 
       // Verify the format matches the expected format.
       FormatHolder formatHolder = new FormatHolder();
-      readSource(formatHolder, null);
-      assertEquals(expectedFormat, formatHolder.format);
-
-      // Verify that we get an end-of-stream buffer.
       DecoderInputBuffer buffer =
           new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_NORMAL);
-      readSource(null, buffer);
-      assertTrue(buffer.isEndOfStream());
-      isEnded = true;
+      int result = readSource(formatHolder, buffer);
+      if (result == C.RESULT_FORMAT_READ) {
+        formatReadCount++;
+        assertEquals(expectedFormat, formatHolder.format);
+      } else if (result == C.RESULT_BUFFER_READ) {
+        bufferReadCount++;
+        if (buffer.isEndOfStream()) {
+          isEnded = true;
+        }
+      }
     }
 
     @Override
     public boolean isReady() {
-      return isEnded;
+      return isSourceReady();
     }
 
     @Override
@@ -435,7 +595,21 @@ public boolean isEnded() {
 
     @Override
     public int supportsFormat(Format format) throws ExoPlaybackException {
-      return MimeTypes.isVideo(format.sampleMimeType) ? FORMAT_HANDLED : FORMAT_UNSUPPORTED_TYPE;
+      return getTrackType() == MimeTypes.getTrackType(format.sampleMimeType) ? FORMAT_HANDLED
+          : FORMAT_UNSUPPORTED_TYPE;
+    }
+
+  }
+
+  private abstract static class FakeMediaClockRenderer extends FakeRenderer implements MediaClock {
+
+    public FakeMediaClockRenderer(Format expectedFormat) {
+      super(expectedFormat);
+    }
+
+    @Override
+    public MediaClock getMediaClock() {
+      return this;
     }
 
   }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/FormatTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/FormatTest.java
index c8c1b4ed93..e13afceb40 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/FormatTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/FormatTest.java
@@ -59,8 +59,8 @@ public void testParcelable() {
     DrmInitData drmInitData = new DrmInitData(DRM_DATA_1, DRM_DATA_2);
     byte[] projectionData = new byte[] {1, 2, 3};
     Metadata metadata = new Metadata(
-        new TextInformationFrame("id1", "description1"),
-        new TextInformationFrame("id2", "description2"));
+        new TextInformationFrame("id1", "description1", "value1"),
+        new TextInformationFrame("id2", "description2", "value2"));
 
     Format formatToParcel = new Format("id", MimeTypes.VIDEO_MP4, MimeTypes.VIDEO_H264, null,
         1024, 2048, 1920, 1080, 24, 90, 2, projectionData, C.STEREO_MODE_TOP_BOTTOM, 6, 44100,
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/drm/OfflineLicenseHelperTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/drm/OfflineLicenseHelperTest.java
new file mode 100644
index 0000000000..9eed8dfd3a
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/drm/OfflineLicenseHelperTest.java
@@ -0,0 +1,229 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.exoplayer2.drm;
+
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.when;
+
+import android.test.InstrumentationTestCase;
+import android.test.MoreAsserts;
+import android.util.Pair;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
+import com.google.android.exoplayer2.source.dash.manifest.AdaptationSet;
+import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
+import com.google.android.exoplayer2.source.dash.manifest.Period;
+import com.google.android.exoplayer2.source.dash.manifest.Representation;
+import com.google.android.exoplayer2.source.dash.manifest.SegmentBase.SingleSegmentBase;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.upstream.HttpDataSource;
+import java.util.Arrays;
+import java.util.HashMap;
+import org.mockito.Mock;
+
+/**
+ * Tests {@link OfflineLicenseHelper}.
+ */
+public class OfflineLicenseHelperTest extends InstrumentationTestCase {
+
+  private OfflineLicenseHelper<?> offlineLicenseHelper;
+  @Mock private HttpDataSource httpDataSource;
+  @Mock private MediaDrmCallback mediaDrmCallback;
+  @Mock private ExoMediaDrm<ExoMediaCrypto> mediaDrm;
+
+  @Override
+  protected void setUp() throws Exception {
+    TestUtil.setUpMockito(this);
+
+    when(mediaDrm.openSession()).thenReturn(new byte[] {1, 2, 3});
+
+    offlineLicenseHelper = new OfflineLicenseHelper<>(mediaDrm, mediaDrmCallback, null);
+  }
+
+  @Override
+  protected void tearDown() throws Exception {
+    offlineLicenseHelper.releaseResources();
+  }
+
+  public void testDownloadRenewReleaseKey() throws Exception {
+    DashManifest manifest = newDashManifestWithAllElements();
+    setStubLicenseAndPlaybackDurationValues(1000, 200);
+
+    byte[] keySetId = {2, 5, 8};
+    setStubKeySetId(keySetId);
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    assertOfflineLicenseKeySetIdEqual(keySetId, offlineLicenseKeySetId);
+
+    byte[] keySetId2 = {6, 7, 0, 1, 4};
+    setStubKeySetId(keySetId2);
+
+    byte[] offlineLicenseKeySetId2 = offlineLicenseHelper.renew(offlineLicenseKeySetId);
+
+    assertOfflineLicenseKeySetIdEqual(keySetId2, offlineLicenseKeySetId2);
+
+    offlineLicenseHelper.release(offlineLicenseKeySetId2);
+  }
+
+  public void testDownloadFailsIfThereIsNoInitData() throws Exception {
+    setDefaultStubValues();
+    DashManifest manifest =
+        newDashManifest(newPeriods(newAdaptationSets(newRepresentations(null /*no init data*/))));
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    assertNull(offlineLicenseKeySetId);
+  }
+
+  public void testDownloadFailsIfThereIsNoRepresentation() throws Exception {
+    setDefaultStubValues();
+    DashManifest manifest = newDashManifest(newPeriods(newAdaptationSets(/*no representation*/)));
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    assertNull(offlineLicenseKeySetId);
+  }
+
+  public void testDownloadFailsIfThereIsNoAdaptationSet() throws Exception {
+    setDefaultStubValues();
+    DashManifest manifest = newDashManifest(newPeriods(/*no adaptation set*/));
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    assertNull(offlineLicenseKeySetId);
+  }
+
+  public void testDownloadFailsIfThereIsNoPeriod() throws Exception {
+    setDefaultStubValues();
+    DashManifest manifest = newDashManifest(/*no periods*/);
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    assertNull(offlineLicenseKeySetId);
+  }
+
+  public void testDownloadFailsIfNoKeySetIdIsReturned() throws Exception {
+    setStubLicenseAndPlaybackDurationValues(1000, 200);
+    DashManifest manifest = newDashManifestWithAllElements();
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    assertNull(offlineLicenseKeySetId);
+  }
+
+  public void testDownloadDoesNotFailIfDurationNotAvailable() throws Exception {
+    setDefaultStubKeySetId();
+    DashManifest manifest = newDashManifestWithAllElements();
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    assertNotNull(offlineLicenseKeySetId);
+  }
+
+  public void testGetLicenseDurationRemainingSec() throws Exception {
+    long licenseDuration = 1000;
+    int playbackDuration = 200;
+    setStubLicenseAndPlaybackDurationValues(licenseDuration, playbackDuration);
+    setDefaultStubKeySetId();
+    DashManifest manifest = newDashManifestWithAllElements();
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    Pair<Long, Long> licenseDurationRemainingSec = offlineLicenseHelper
+        .getLicenseDurationRemainingSec(offlineLicenseKeySetId);
+
+    assertEquals(licenseDuration, (long) licenseDurationRemainingSec.first);
+    assertEquals(playbackDuration, (long) licenseDurationRemainingSec.second);
+  }
+
+  public void testGetLicenseDurationRemainingSecExpiredLicense() throws Exception {
+    long licenseDuration = 0;
+    int playbackDuration = 0;
+    setStubLicenseAndPlaybackDurationValues(licenseDuration, playbackDuration);
+    setDefaultStubKeySetId();
+    DashManifest manifest = newDashManifestWithAllElements();
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    Pair<Long, Long> licenseDurationRemainingSec = offlineLicenseHelper
+        .getLicenseDurationRemainingSec(offlineLicenseKeySetId);
+
+    assertEquals(licenseDuration, (long) licenseDurationRemainingSec.first);
+    assertEquals(playbackDuration, (long) licenseDurationRemainingSec.second);
+  }
+
+  private void setDefaultStubValues()
+      throws android.media.NotProvisionedException, android.media.DeniedByServerException {
+    setDefaultStubKeySetId();
+    setStubLicenseAndPlaybackDurationValues(1000, 200);
+  }
+
+  private void setDefaultStubKeySetId()
+      throws android.media.NotProvisionedException, android.media.DeniedByServerException {
+    setStubKeySetId(new byte[] {2, 5, 8});
+  }
+
+  private void setStubKeySetId(byte[] keySetId)
+      throws android.media.NotProvisionedException, android.media.DeniedByServerException {
+    when(mediaDrm.provideKeyResponse(any(byte[].class), any(byte[].class))).thenReturn(keySetId);
+  }
+
+  private static void assertOfflineLicenseKeySetIdEqual(
+      byte[] expectedKeySetId, byte[] actualKeySetId) throws Exception {
+    assertNotNull(actualKeySetId);
+    MoreAsserts.assertEquals(expectedKeySetId, actualKeySetId);
+  }
+
+  private void setStubLicenseAndPlaybackDurationValues(long licenseDuration,
+      long playbackDuration) {
+    HashMap<String, String> keyStatus = new HashMap<>();
+    keyStatus.put(WidevineUtil.PROPERTY_LICENSE_DURATION_REMAINING,
+        String.valueOf(licenseDuration));
+    keyStatus.put(WidevineUtil.PROPERTY_PLAYBACK_DURATION_REMAINING,
+        String.valueOf(playbackDuration));
+    when(mediaDrm.queryKeyStatus(any(byte[].class))).thenReturn(keyStatus);
+  }
+
+  private static DashManifest newDashManifestWithAllElements() {
+    return newDashManifest(newPeriods(newAdaptationSets(newRepresentations(newDrmInitData()))));
+  }
+
+  private static DashManifest newDashManifest(Period... periods) {
+    return new DashManifest(0, 0, 0, false, 0, 0, 0, null, null, Arrays.asList(periods));
+  }
+
+  private static Period newPeriods(AdaptationSet... adaptationSets) {
+    return new Period("", 0, Arrays.asList(adaptationSets));
+  }
+
+  private static AdaptationSet newAdaptationSets(Representation... representations) {
+    return new AdaptationSet(0, C.TRACK_TYPE_VIDEO, Arrays.asList(representations), null);
+  }
+
+  private static Representation newRepresentations(DrmInitData drmInitData) {
+    Format format = Format.createVideoSampleFormat("", "", "", 0, 0, 0, 0, 0, null, drmInitData);
+    return Representation.newInstance("", 0, format, "", new SingleSegmentBase());
+  }
+
+  private static DrmInitData newDrmInitData() {
+    return new DrmInitData(new SchemeData(C.WIDEVINE_UUID, "mimeType",
+        new byte[]{1, 4, 7, 0, 3, 6}));
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java
index c47614e4ee..9a8a1f7f27 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.extractor.mp4;
 
 import android.test.InstrumentationTestCase;
+import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.TestUtil;
 
@@ -24,13 +25,21 @@
  */
 public final class FragmentedMp4ExtractorTest extends InstrumentationTestCase {
 
+  private static final TestUtil.ExtractorFactory EXTRACTOR_FACTORY =
+      new TestUtil.ExtractorFactory() {
+        @Override
+        public Extractor create() {
+          return new FragmentedMp4Extractor();
+        }
+      };
+
   public void testSample() throws Exception {
-    TestUtil.assertOutput(new TestUtil.ExtractorFactory() {
-      @Override
-      public Extractor create() {
-        return new FragmentedMp4Extractor();
-      }
-    }, "mp4/sample_fragmented.mp4", getInstrumentation());
+    TestUtil.assertOutput(EXTRACTOR_FACTORY, "mp4/sample_fragmented.mp4", getInstrumentation());
+  }
+
+  public void testAtomWithZeroSize() throws Exception {
+    TestUtil.assertThrows(EXTRACTOR_FACTORY, "mp4/sample_fragmented_zero_size_atom.mp4",
+        getInstrumentation(), ParserException.class);
   }
 
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
index 453a33a521..c4d9de3100 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
@@ -16,9 +16,9 @@
 package com.google.android.exoplayer2.extractor.ts;
 
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.testutil.FakeExtractorOutput;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
index c9d6535164..2dce742158 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
@@ -21,7 +21,6 @@
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.PositionHolder;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.EsInfo;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
@@ -30,6 +29,7 @@
 import com.google.android.exoplayer2.testutil.FakeTrackOutput;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import java.io.ByteArrayOutputStream;
 import java.util.Random;
 
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java
new file mode 100644
index 0000000000..b33dfd1067
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.emsg;
+
+import android.test.MoreAsserts;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
+import java.nio.ByteBuffer;
+import junit.framework.TestCase;
+
+/**
+ * Test for {@link EventMessageDecoder}.
+ */
+public final class EventMessageDecoderTest extends TestCase {
+
+  public void testDecodeEventMessage() {
+    byte[] rawEmsgBody = new byte[] {
+        117, 114, 110, 58, 116, 101, 115, 116, 0, // scheme_id_uri = "urn:test"
+        49, 50, 51, 0, // value = "123"
+        0, 0, -69, -128, // timescale = 48000
+        0, 0, 0, 0, // presentation_time_delta (ignored) = 0
+        0, 2, 50, -128, // event_duration = 144000
+        0, 15, 67, -45, // id = 1000403
+        0, 1, 2, 3, 4}; // message_data = {0, 1, 2, 3, 4}
+    EventMessageDecoder decoder = new EventMessageDecoder();
+    MetadataInputBuffer buffer = new MetadataInputBuffer();
+    buffer.data = ByteBuffer.allocate(rawEmsgBody.length).put(rawEmsgBody);
+    Metadata metadata = decoder.decode(buffer);
+    assertEquals(1, metadata.length());
+    EventMessage eventMessage = (EventMessage) metadata.get(0);
+    assertEquals("urn:test", eventMessage.schemeIdUri);
+    assertEquals("123", eventMessage.value);
+    assertEquals(3000, eventMessage.durationMs);
+    assertEquals(1000403, eventMessage.id);
+    MoreAsserts.assertEquals(new byte[] {0, 1, 2, 3, 4}, eventMessage.messageData);
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java
new file mode 100644
index 0000000000..baafb6b18b
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.emsg;
+
+import android.os.Parcel;
+import junit.framework.TestCase;
+
+/**
+ * Test for {@link EventMessage}.
+ */
+public final class EventMessageTest extends TestCase {
+
+  public void testEventMessageParcelable() {
+    EventMessage eventMessage = new EventMessage("urn:test", "123", 3000, 1000403,
+        new byte[] {0, 1, 2, 3, 4});
+    // Write to parcel.
+    Parcel parcel = Parcel.obtain();
+    eventMessage.writeToParcel(parcel, 0);
+    // Create from parcel.
+    parcel.setDataPosition(0);
+    EventMessage fromParcelEventMessage = EventMessage.CREATOR.createFromParcel(parcel);
+    // Assert equals.
+    assertEquals(eventMessage, fromParcelEventMessage);
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/ChapterFrameTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/ChapterFrameTest.java
new file mode 100644
index 0000000000..182ae6f1c9
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/ChapterFrameTest.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.id3;
+
+import android.os.Parcel;
+import junit.framework.TestCase;
+
+/**
+ * Test for {@link ChapterFrame}.
+ */
+public final class ChapterFrameTest extends TestCase {
+
+  public void testParcelable() {
+    Id3Frame[] subFrames = new Id3Frame[] {
+      new TextInformationFrame("TIT2", null, "title"),
+      new UrlLinkFrame("WXXX", "description", "url")
+    };
+    ChapterFrame chapterFrameToParcel = new ChapterFrame("id", 0, 1, 2, 3, subFrames);
+
+    Parcel parcel = Parcel.obtain();
+    chapterFrameToParcel.writeToParcel(parcel, 0);
+    parcel.setDataPosition(0);
+
+    ChapterFrame chapterFrameFromParcel = ChapterFrame.CREATOR.createFromParcel(parcel);
+    assertEquals(chapterFrameToParcel, chapterFrameFromParcel);
+
+    parcel.recycle();
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrameTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrameTest.java
new file mode 100644
index 0000000000..9641de7669
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrameTest.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.id3;
+
+import android.os.Parcel;
+import junit.framework.TestCase;
+
+/**
+ * Test for {@link ChapterTocFrame}.
+ */
+public final class ChapterTocFrameTest extends TestCase {
+
+  public void testParcelable() {
+    String[] children = new String[] {"child0", "child1"};
+    Id3Frame[] subFrames = new Id3Frame[] {
+        new TextInformationFrame("TIT2", null, "title"),
+        new UrlLinkFrame("WXXX", "description", "url")
+    };
+    ChapterTocFrame chapterTocFrameToParcel = new ChapterTocFrame("id", false, true, children,
+        subFrames);
+
+    Parcel parcel = Parcel.obtain();
+    chapterTocFrameToParcel.writeToParcel(parcel, 0);
+    parcel.setDataPosition(0);
+
+    ChapterTocFrame chapterTocFrameFromParcel = ChapterTocFrame.CREATOR.createFromParcel(parcel);
+    assertEquals(chapterTocFrameToParcel, chapterTocFrameFromParcel);
+
+    parcel.recycle();
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java
index 6bfa6fccfc..e271108ce4 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java
@@ -21,9 +21,9 @@
 import junit.framework.TestCase;
 
 /**
- * Test for {@link Id3Decoder}
+ * Test for {@link Id3Decoder}.
  */
-public class Id3DecoderTest extends TestCase {
+public final class Id3DecoderTest extends TestCase {
 
   public void testDecodeTxxxFrame() throws MetadataDecoderException {
     byte[] rawId3 = new byte[] {73, 68, 51, 4, 0, 0, 0, 0, 0, 41, 84, 88, 88, 88, 0, 0, 0, 31, 0, 0,
@@ -32,9 +32,10 @@ public void testDecodeTxxxFrame() throws MetadataDecoderException {
     Id3Decoder decoder = new Id3Decoder();
     Metadata metadata = decoder.decode(rawId3, rawId3.length);
     assertEquals(1, metadata.length());
-    TxxxFrame txxxFrame = (TxxxFrame) metadata.get(0);
-    assertEquals("", txxxFrame.description);
-    assertEquals("mdialog_VINDICO1527664_start", txxxFrame.value);
+    TextInformationFrame textInformationFrame = (TextInformationFrame) metadata.get(0);
+    assertEquals("TXXX", textInformationFrame.id);
+    assertEquals("", textInformationFrame.description);
+    assertEquals("mdialog_VINDICO1527664_start", textInformationFrame.value);
   }
 
   public void testDecodeApicFrame() throws MetadataDecoderException {
@@ -60,7 +61,19 @@ public void testDecodeTextInformationFrame() throws MetadataDecoderException {
     assertEquals(1, metadata.length());
     TextInformationFrame textInformationFrame = (TextInformationFrame) metadata.get(0);
     assertEquals("TIT2", textInformationFrame.id);
-    assertEquals("Hello World", textInformationFrame.description);
+    assertNull(textInformationFrame.description);
+    assertEquals("Hello World", textInformationFrame.value);
+  }
+
+  public void testDecodePrivFrame() throws MetadataDecoderException {
+    byte[] rawId3 = new byte[] {73, 68, 51, 4, 0, 0, 0, 0, 0, 19, 80, 82, 73, 86, 0, 0, 0, 9, 0, 0,
+        116, 101, 115, 116, 0, 1, 2, 3, 4};
+    Id3Decoder decoder = new Id3Decoder();
+    Metadata metadata = decoder.decode(rawId3, rawId3.length);
+    assertEquals(1, metadata.length());
+    PrivFrame privFrame = (PrivFrame) metadata.get(0);
+    assertEquals("test", privFrame.owner);
+    MoreAsserts.assertEquals(new byte[] {1, 2, 3, 4}, privFrame.privateData);
   }
 
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java
new file mode 100644
index 0000000000..c50ff06699
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.scte35;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.MetadataDecoderException;
+import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
+import java.nio.ByteBuffer;
+import java.util.List;
+import junit.framework.TestCase;
+
+/**
+ * Test for {@link SpliceInfoDecoder}.
+ */
+public final class SpliceInfoDecoderTest extends TestCase {
+
+  private SpliceInfoDecoder decoder;
+  private MetadataInputBuffer inputBuffer;
+
+  @Override
+  public void setUp() {
+    decoder = new SpliceInfoDecoder();
+    inputBuffer = new MetadataInputBuffer();
+  }
+
+  public void testWrappedAroundTimeSignalCommand() throws MetadataDecoderException {
+    byte[] rawTimeSignalSection = new byte[] {
+        0, // table_id.
+        (byte) 0x80, // section_syntax_indicator, private_indicator, reserved, section_length(4).
+        0x14, // section_length(8).
+        0x00, // protocol_version.
+        0x00, // encrypted_packet, encryption_algorithm, pts_adjustment(1).
+        0x00, 0x00, 0x00, 0x00, // pts_adjustment(32).
+        0x00, // cw_index.
+        0x00, // tier(8).
+        0x00, // tier(4), splice_command_length(4).
+        0x05, // splice_command_length(8).
+        0x06, // splice_command_type = time_signal.
+        // Start of splice_time().
+        (byte) 0x80, // time_specified_flag, reserved, pts_time(1).
+        0x52, 0x03, 0x02, (byte) 0x8f, // pts_time(32). PTS for a second after playback position.
+        0x00, 0x00, 0x00, 0x00}; // CRC_32 (ignored, check happens at extraction).
+
+    // The playback position is 57:15:58.43 approximately.
+    // With this offset, the playback position pts before wrapping is 0x451ebf851.
+    Metadata metadata = feedInputBuffer(rawTimeSignalSection, 0x3000000000L, -0x50000L);
+    assertEquals(1, metadata.length());
+    assertEquals(removePtsConversionPrecisionError(0x3001000000L, inputBuffer.subsampleOffsetUs),
+        ((TimeSignalCommand) metadata.get(0)).playbackPositionUs);
+  }
+
+  public void test2SpliceInsertCommands() throws MetadataDecoderException {
+    byte[] rawSpliceInsertCommand1 = new byte[] {
+        0, // table_id.
+        (byte) 0x80, // section_syntax_indicator, private_indicator, reserved, section_length(4).
+        0x19, // section_length(8).
+        0x00, // protocol_version.
+        0x00, // encrypted_packet, encryption_algorithm, pts_adjustment(1).
+        0x00, 0x00, 0x00, 0x00, // pts_adjustment(32).
+        0x00, // cw_index.
+        0x00, // tier(8).
+        0x00, // tier(4), splice_command_length(4).
+        0x0e, // splice_command_length(8).
+        0x05, // splice_command_type = splice_insert.
+        // Start of splice_insert().
+        0x00, 0x00, 0x00, 0x42, // splice_event_id.
+        0x00, // splice_event_cancel_indicator, reserved.
+        0x40, // out_of_network_indicator, program_splice_flag, duration_flag,
+              // splice_immediate_flag, reserved.
+        // start of splice_time().
+        (byte) 0x80, // time_specified_flag, reserved, pts_time(1).
+        0x00, 0x00, 0x00, 0x00, // PTS for playback position 3s.
+        0x00, 0x10, // unique_program_id.
+        0x01, // avail_num.
+        0x02, // avails_expected.
+        0x00, 0x00, 0x00, 0x00}; // CRC_32 (ignored, check happens at extraction).
+
+    Metadata metadata = feedInputBuffer(rawSpliceInsertCommand1, 2000000, 3000000);
+    assertEquals(1, metadata.length());
+    SpliceInsertCommand command = (SpliceInsertCommand) metadata.get(0);
+    assertEquals(66, command.spliceEventId);
+    assertFalse(command.spliceEventCancelIndicator);
+    assertFalse(command.outOfNetworkIndicator);
+    assertTrue(command.programSpliceFlag);
+    assertFalse(command.spliceImmediateFlag);
+    assertEquals(3000000, command.programSplicePlaybackPositionUs);
+    assertEquals(C.TIME_UNSET, command.breakDuration);
+    assertEquals(16, command.uniqueProgramId);
+    assertEquals(1, command.availNum);
+    assertEquals(2, command.availsExpected);
+
+    byte[] rawSpliceInsertCommand2 = new byte[] {
+        0, // table_id.
+        (byte) 0x80, // section_syntax_indicator, private_indicator, reserved, section_length(4).
+        0x22, // section_length(8).
+        0x00, // protocol_version.
+        0x00, // encrypted_packet, encryption_algorithm, pts_adjustment(1).
+        0x00, 0x00, 0x00, 0x00, // pts_adjustment(32).
+        0x00, // cw_index.
+        0x00, // tier(8).
+        0x00, // tier(4), splice_command_length(4).
+        0x13, // splice_command_length(8).
+        0x05, // splice_command_type = splice_insert.
+        // Start of splice_insert().
+        (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, // splice_event_id.
+        0x00, // splice_event_cancel_indicator, reserved.
+        0x00, // out_of_network_indicator, program_splice_flag, duration_flag,
+              // splice_immediate_flag, reserved.
+        0x02, // component_count.
+        0x10, // component_tag.
+        // start of splice_time().
+        (byte) 0x81, // time_specified_flag, reserved, pts_time(1).
+        (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, // PTS for playback position 10s.
+        // start of splice_time().
+        0x11, // component_tag.
+        0x00, // time_specified_flag, reserved.
+        0x00, 0x20, // unique_program_id.
+        0x01, // avail_num.
+        0x02, // avails_expected.
+        0x00, 0x00, 0x00, 0x00}; // CRC_32 (ignored, check happens at extraction).
+
+    // By changing the subsample offset we force adjuster reconstruction.
+    long subsampleOffset = 1000011;
+    metadata = feedInputBuffer(rawSpliceInsertCommand2, 1000000, subsampleOffset);
+    assertEquals(1, metadata.length());
+    command = (SpliceInsertCommand) metadata.get(0);
+    assertEquals(0xffffffffL, command.spliceEventId);
+    assertFalse(command.spliceEventCancelIndicator);
+    assertFalse(command.outOfNetworkIndicator);
+    assertFalse(command.programSpliceFlag);
+    assertFalse(command.spliceImmediateFlag);
+    assertEquals(C.TIME_UNSET, command.programSplicePlaybackPositionUs);
+    assertEquals(C.TIME_UNSET, command.breakDuration);
+    List<SpliceInsertCommand.ComponentSplice> componentSplices = command.componentSpliceList;
+    assertEquals(2, componentSplices.size());
+    assertEquals(16, componentSplices.get(0).componentTag);
+    assertEquals(1000000, componentSplices.get(0).componentSplicePlaybackPositionUs);
+    assertEquals(17, componentSplices.get(1).componentTag);
+    assertEquals(C.TIME_UNSET, componentSplices.get(1).componentSplicePts);
+    assertEquals(32, command.uniqueProgramId);
+    assertEquals(1, command.availNum);
+    assertEquals(2, command.availsExpected);
+  }
+
+  private Metadata feedInputBuffer(byte[] data, long timeUs, long subsampleOffset)
+      throws MetadataDecoderException{
+    inputBuffer.clear();
+    inputBuffer.data = ByteBuffer.allocate(data.length).put(data);
+    inputBuffer.timeUs = timeUs;
+    inputBuffer.subsampleOffsetUs = subsampleOffset;
+    return decoder.decode(inputBuffer);
+  }
+
+  private static long removePtsConversionPrecisionError(long timeUs, long offsetUs) {
+    return TimestampAdjuster.ptsToUs(TimestampAdjuster.usToPts(timeUs - offsetUs)) + offsetUs;
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
index 944781b890..4de0ae4081 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
@@ -20,6 +20,8 @@
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import java.io.IOException;
+import java.util.Collections;
+import java.util.List;
 
 /**
  * Unit tests for {@link DashManifestParser}.
@@ -70,34 +72,57 @@ public void testParseMediaPresentationDescriptionWithSegmentTemplate() throws IO
   }
 
   public void testParseCea608AccessibilityChannel() {
-    assertEquals(1, DashManifestParser.parseCea608AccessibilityChannel("CC1=eng"));
-    assertEquals(2, DashManifestParser.parseCea608AccessibilityChannel("CC2=eng"));
-    assertEquals(3, DashManifestParser.parseCea608AccessibilityChannel("CC3=eng"));
-    assertEquals(4, DashManifestParser.parseCea608AccessibilityChannel("CC4=eng"));
+    assertEquals(1, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors("CC1=eng")));
+    assertEquals(2, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors("CC2=eng")));
+    assertEquals(3, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors("CC3=eng")));
+    assertEquals(4, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors("CC4=eng")));
 
-    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel(null));
-    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel(""));
-    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel("CC0=eng"));
-    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel("CC5=eng"));
-    assertEquals(Format.NO_VALUE,
-        DashManifestParser.parseCea608AccessibilityChannel("Wrong format"));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors(null)));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors("")));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors("CC0=eng")));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors("CC5=eng")));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors("Wrong format")));
   }
 
   public void testParseCea708AccessibilityChannel() {
-    assertEquals(1, DashManifestParser.parseCea708AccessibilityChannel("1=lang:eng"));
-    assertEquals(2, DashManifestParser.parseCea708AccessibilityChannel("2=lang:eng"));
-    assertEquals(3, DashManifestParser.parseCea708AccessibilityChannel("3=lang:eng"));
-    assertEquals(62, DashManifestParser.parseCea708AccessibilityChannel("62=lang:eng"));
-    assertEquals(63, DashManifestParser.parseCea708AccessibilityChannel("63=lang:eng"));
+    assertEquals(1, DashManifestParser.parseCea708AccessibilityChannel(
+        buildCea708AccessibilityDescriptors("1=lang:eng")));
+    assertEquals(2, DashManifestParser.parseCea708AccessibilityChannel(
+        buildCea708AccessibilityDescriptors("2=lang:eng")));
+    assertEquals(3, DashManifestParser.parseCea708AccessibilityChannel(
+        buildCea708AccessibilityDescriptors("3=lang:eng")));
+    assertEquals(62, DashManifestParser.parseCea708AccessibilityChannel(
+        buildCea708AccessibilityDescriptors("62=lang:eng")));
+    assertEquals(63, DashManifestParser.parseCea708AccessibilityChannel(
+        buildCea708AccessibilityDescriptors("63=lang:eng")));
 
-    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea708AccessibilityChannel(null));
-    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea708AccessibilityChannel(""));
-    assertEquals(Format.NO_VALUE,
-        DashManifestParser.parseCea708AccessibilityChannel("0=lang:eng"));
-    assertEquals(Format.NO_VALUE,
-        DashManifestParser.parseCea708AccessibilityChannel("64=lang:eng"));
-    assertEquals(Format.NO_VALUE,
-        DashManifestParser.parseCea708AccessibilityChannel("Wrong format"));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea708AccessibilityChannel(
+        buildCea708AccessibilityDescriptors(null)));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea708AccessibilityChannel(
+        buildCea708AccessibilityDescriptors("")));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea708AccessibilityChannel(
+            buildCea708AccessibilityDescriptors("0=lang:eng")));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea708AccessibilityChannel(
+            buildCea708AccessibilityDescriptors("64=lang:eng")));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea708AccessibilityChannel(
+            buildCea708AccessibilityDescriptors("Wrong format")));
+  }
+
+  private static List<SchemeValuePair> buildCea608AccessibilityDescriptors(String value) {
+    return Collections.singletonList(new SchemeValuePair("urn:scte:dash:cc:cea-608:2015", value));
+  }
+
+  private static List<SchemeValuePair> buildCea708AccessibilityDescriptors(String value) {
+    return Collections.singletonList(new SchemeValuePair("urn:scte:dash:cc:cea-708:2015", value));
   }
 
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java
index 008cd0e556..5d10aba1ae 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java
@@ -29,13 +29,13 @@ public void testGetCacheKey() {
     String uri = "http://www.google.com";
     SegmentBase base = new SingleSegmentBase(new RangedUri(null, 0, 1), 1, 0, 1, 1);
     Format format = Format.createVideoContainerFormat("0", MimeTypes.APPLICATION_MP4, null,
-        MimeTypes.VIDEO_H264, 2500000, 1920, 1080, Format.NO_VALUE, null);
+        MimeTypes.VIDEO_H264, 2500000, 1920, 1080, Format.NO_VALUE, null, 0);
     Representation representation = Representation.newInstance("test_stream_1", 3, format, uri,
         base);
     assertEquals("test_stream_1.0.3", representation.getCacheKey());
 
     format = Format.createVideoContainerFormat("150", MimeTypes.APPLICATION_MP4, null,
-        MimeTypes.VIDEO_H264, 2500000, 1920, 1080, Format.NO_VALUE, null);
+        MimeTypes.VIDEO_H264, 2500000, 1920, 1080, Format.NO_VALUE, null, 0);
     representation = Representation.newInstance("test_stream_1", Representation.REVISION_ID_DEFAULT,
         format, uri, base);
     assertEquals("test_stream_1.150.-1", representation.getCacheKey());
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
index 488341d4f3..f0adf274ee 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
@@ -18,6 +18,7 @@
 import android.net.Uri;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.ParserException;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.nio.charset.Charset;
@@ -29,70 +30,86 @@
  */
 public class HlsMasterPlaylistParserTest extends TestCase {
 
-  public void testParseMasterPlaylist() {
-    Uri playlistUri = Uri.parse("https://example.com/test.m3u8");
-    String playlistString = "#EXTM3U\n"
-        + "\n"
-        + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
-        + "http://example.com/low.m3u8\n"
-        + "\n"
-        + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2 , avc1.66.30 \"\n"
-        + "http://example.com/spaces_in_codecs.m3u8\n"
-        + "\n"
-        + "#EXT-X-STREAM-INF:BANDWIDTH=2560000,RESOLUTION=384x160\n"
-        + "http://example.com/mid.m3u8\n"
-        + "\n"
-        + "#EXT-X-STREAM-INF:BANDWIDTH=7680000\n"
-        + "http://example.com/hi.m3u8\n"
-        + "\n"
-        + "#EXT-X-STREAM-INF:BANDWIDTH=65000,CODECS=\"mp4a.40.5\"\n"
-        + "http://example.com/audio-only.m3u8";
-    ByteArrayInputStream inputStream = new ByteArrayInputStream(
-        playlistString.getBytes(Charset.forName(C.UTF8_NAME)));
+  private static final String PLAYLIST_URI = "https://example.com/test.m3u8";
+
+  private static final String MASTER_PLAYLIST = " #EXTM3U \n"
+      + "\n"
+      + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
+      + "http://example.com/low.m3u8\n"
+      + "\n"
+      + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2 , avc1.66.30 \"\n"
+      + "http://example.com/spaces_in_codecs.m3u8\n"
+      + "\n"
+      + "#EXT-X-STREAM-INF:BANDWIDTH=2560000,RESOLUTION=384x160\n"
+      + "http://example.com/mid.m3u8\n"
+      + "\n"
+      + "#EXT-X-STREAM-INF:BANDWIDTH=7680000\n"
+      + "http://example.com/hi.m3u8\n"
+      + "\n"
+      + "#EXT-X-STREAM-INF:BANDWIDTH=65000,CODECS=\"mp4a.40.5\"\n"
+      + "http://example.com/audio-only.m3u8";
+
+  private static final String PLAYLIST_WITH_INVALID_HEADER = "#EXTMU3\n"
+      + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
+      + "http://example.com/low.m3u8\n";
+
+  public void testParseMasterPlaylist() throws IOException{
+    HlsPlaylist playlist = parsePlaylist(PLAYLIST_URI, MASTER_PLAYLIST);
+    assertNotNull(playlist);
+    assertEquals(HlsPlaylist.TYPE_MASTER, playlist.type);
+
+    HlsMasterPlaylist masterPlaylist = (HlsMasterPlaylist) playlist;
+
+    List<HlsMasterPlaylist.HlsUrl> variants = masterPlaylist.variants;
+    assertNotNull(variants);
+    assertEquals(5, variants.size());
+
+    assertEquals(1280000, variants.get(0).format.bitrate);
+    assertNotNull(variants.get(0).format.codecs);
+    assertEquals("mp4a.40.2,avc1.66.30", variants.get(0).format.codecs);
+    assertEquals(304, variants.get(0).format.width);
+    assertEquals(128, variants.get(0).format.height);
+    assertEquals("http://example.com/low.m3u8", variants.get(0).url);
+
+    assertEquals(1280000, variants.get(1).format.bitrate);
+    assertNotNull(variants.get(1).format.codecs);
+    assertEquals("mp4a.40.2 , avc1.66.30 ", variants.get(1).format.codecs);
+    assertEquals("http://example.com/spaces_in_codecs.m3u8", variants.get(1).url);
+
+    assertEquals(2560000, variants.get(2).format.bitrate);
+    assertEquals(null, variants.get(2).format.codecs);
+    assertEquals(384, variants.get(2).format.width);
+    assertEquals(160, variants.get(2).format.height);
+    assertEquals("http://example.com/mid.m3u8", variants.get(2).url);
+
+    assertEquals(7680000, variants.get(3).format.bitrate);
+    assertEquals(null, variants.get(3).format.codecs);
+    assertEquals(Format.NO_VALUE, variants.get(3).format.width);
+    assertEquals(Format.NO_VALUE, variants.get(3).format.height);
+    assertEquals("http://example.com/hi.m3u8", variants.get(3).url);
+
+    assertEquals(65000, variants.get(4).format.bitrate);
+    assertNotNull(variants.get(4).format.codecs);
+    assertEquals("mp4a.40.5", variants.get(4).format.codecs);
+    assertEquals(Format.NO_VALUE, variants.get(4).format.width);
+    assertEquals(Format.NO_VALUE, variants.get(4).format.height);
+    assertEquals("http://example.com/audio-only.m3u8", variants.get(4).url);
+  }
+
+  public void testPlaylistWithInvalidHeader() throws IOException {
     try {
-      HlsPlaylist playlist = new HlsPlaylistParser().parse(playlistUri, inputStream);
-      assertNotNull(playlist);
-      assertEquals(HlsPlaylist.TYPE_MASTER, playlist.type);
-
-      HlsMasterPlaylist masterPlaylist = (HlsMasterPlaylist) playlist;
-
-      List<HlsMasterPlaylist.HlsUrl> variants = masterPlaylist.variants;
-      assertNotNull(variants);
-      assertEquals(5, variants.size());
-
-      assertEquals(1280000, variants.get(0).format.bitrate);
-      assertNotNull(variants.get(0).format.codecs);
-      assertEquals("mp4a.40.2,avc1.66.30", variants.get(0).format.codecs);
-      assertEquals(304, variants.get(0).format.width);
-      assertEquals(128, variants.get(0).format.height);
-      assertEquals("http://example.com/low.m3u8", variants.get(0).url);
-
-      assertEquals(1280000, variants.get(1).format.bitrate);
-      assertNotNull(variants.get(1).format.codecs);
-      assertEquals("mp4a.40.2 , avc1.66.30 ", variants.get(1).format.codecs);
-      assertEquals("http://example.com/spaces_in_codecs.m3u8", variants.get(1).url);
-
-      assertEquals(2560000, variants.get(2).format.bitrate);
-      assertEquals(null, variants.get(2).format.codecs);
-      assertEquals(384, variants.get(2).format.width);
-      assertEquals(160, variants.get(2).format.height);
-      assertEquals("http://example.com/mid.m3u8", variants.get(2).url);
-
-      assertEquals(7680000, variants.get(3).format.bitrate);
-      assertEquals(null, variants.get(3).format.codecs);
-      assertEquals(Format.NO_VALUE, variants.get(3).format.width);
-      assertEquals(Format.NO_VALUE, variants.get(3).format.height);
-      assertEquals("http://example.com/hi.m3u8", variants.get(3).url);
-
-      assertEquals(65000, variants.get(4).format.bitrate);
-      assertNotNull(variants.get(4).format.codecs);
-      assertEquals("mp4a.40.5", variants.get(4).format.codecs);
-      assertEquals(Format.NO_VALUE, variants.get(4).format.width);
-      assertEquals(Format.NO_VALUE, variants.get(4).format.height);
-      assertEquals("http://example.com/audio-only.m3u8", variants.get(4).url);
-    } catch (IOException exception) {
-      fail(exception.getMessage());
+      parsePlaylist(PLAYLIST_URI, PLAYLIST_WITH_INVALID_HEADER);
+      fail("Expected exception not thrown.");
+    } catch (ParserException e) {
+      // Expected due to invalid header.
     }
   }
 
+  private static HlsPlaylist parsePlaylist(String uri, String playlistString) throws IOException {
+    Uri playlistUri = Uri.parse(uri);
+    ByteArrayInputStream inputStream = new ByteArrayInputStream(
+        playlistString.getBytes(Charset.forName(C.UTF8_NAME)));
+    return new HlsPlaylistParser().parse(playlistUri, inputStream);
+  }
+
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java
index 67ec907d61..4286a283c0 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java
@@ -17,6 +17,7 @@
 
 import android.net.Uri;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist.Segment;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -34,6 +35,7 @@ public void testParseMediaPlaylist() {
     Uri playlistUri = Uri.parse("https://example.com/test.m3u8");
     String playlistString = "#EXTM3U\n"
         + "#EXT-X-VERSION:3\n"
+        + "#EXT-X-PLAYLIST-TYPE:VOD\n"
         + "#EXT-X-TARGETDURATION:8\n"
         + "#EXT-X-MEDIA-SEQUENCE:2679\n"
         + "#EXT-X-DISCONTINUITY-SEQUENCE:4\n"
@@ -70,62 +72,68 @@ public void testParseMediaPlaylist() {
       assertEquals(HlsPlaylist.TYPE_MEDIA, playlist.type);
 
       HlsMediaPlaylist mediaPlaylist = (HlsMediaPlaylist) playlist;
+      assertEquals(HlsMediaPlaylist.PLAYLIST_TYPE_VOD, mediaPlaylist.playlistType);
 
       assertEquals(2679, mediaPlaylist.mediaSequence);
       assertEquals(3, mediaPlaylist.version);
-      assertEquals(true, mediaPlaylist.hasEndTag);
-      List<HlsMediaPlaylist.Segment> segments = mediaPlaylist.segments;
+      assertTrue(mediaPlaylist.hasEndTag);
+      List<Segment> segments = mediaPlaylist.segments;
       assertNotNull(segments);
       assertEquals(5, segments.size());
 
-      assertEquals(4, segments.get(0).discontinuitySequenceNumber);
-      assertEquals(7975000, segments.get(0).durationUs);
-      assertEquals(false, segments.get(0).isEncrypted);
-      assertEquals(null, segments.get(0).encryptionKeyUri);
-      assertEquals(null, segments.get(0).encryptionIV);
-      assertEquals(51370, segments.get(0).byterangeLength);
-      assertEquals(0, segments.get(0).byterangeOffset);
-      assertEquals("https://priv.example.com/fileSequence2679.ts", segments.get(0).url);
+      Segment segment = segments.get(0);
+      assertEquals(4, mediaPlaylist.discontinuitySequence + segment.relativeDiscontinuitySequence);
+      assertEquals(7975000, segment.durationUs);
+      assertFalse(segment.isEncrypted);
+      assertEquals(null, segment.encryptionKeyUri);
+      assertEquals(null, segment.encryptionIV);
+      assertEquals(51370, segment.byterangeLength);
+      assertEquals(0, segment.byterangeOffset);
+      assertEquals("https://priv.example.com/fileSequence2679.ts", segment.url);
 
-      assertEquals(4, segments.get(1).discontinuitySequenceNumber);
-      assertEquals(7975000, segments.get(1).durationUs);
-      assertEquals(true, segments.get(1).isEncrypted);
-      assertEquals("https://priv.example.com/key.php?r=2680", segments.get(1).encryptionKeyUri);
-      assertEquals("0x1566B", segments.get(1).encryptionIV);
-      assertEquals(51501, segments.get(1).byterangeLength);
-      assertEquals(2147483648L, segments.get(1).byterangeOffset);
-      assertEquals("https://priv.example.com/fileSequence2680.ts", segments.get(1).url);
+      segment = segments.get(1);
+      assertEquals(0, segment.relativeDiscontinuitySequence);
+      assertEquals(7975000, segment.durationUs);
+      assertTrue(segment.isEncrypted);
+      assertEquals("https://priv.example.com/key.php?r=2680", segment.encryptionKeyUri);
+      assertEquals("0x1566B", segment.encryptionIV);
+      assertEquals(51501, segment.byterangeLength);
+      assertEquals(2147483648L, segment.byterangeOffset);
+      assertEquals("https://priv.example.com/fileSequence2680.ts", segment.url);
 
-      assertEquals(4, segments.get(2).discontinuitySequenceNumber);
-      assertEquals(7941000, segments.get(2).durationUs);
-      assertEquals(false, segments.get(2).isEncrypted);
-      assertEquals(null, segments.get(2).encryptionKeyUri);
-      assertEquals(null, segments.get(2).encryptionIV);
-      assertEquals(51501, segments.get(2).byterangeLength);
-      assertEquals(2147535149L, segments.get(2).byterangeOffset);
-      assertEquals("https://priv.example.com/fileSequence2681.ts", segments.get(2).url);
+      segment = segments.get(2);
+      assertEquals(0, segment.relativeDiscontinuitySequence);
+      assertEquals(7941000, segment.durationUs);
+      assertFalse(segment.isEncrypted);
+      assertEquals(null, segment.encryptionKeyUri);
+      assertEquals(null, segment.encryptionIV);
+      assertEquals(51501, segment.byterangeLength);
+      assertEquals(2147535149L, segment.byterangeOffset);
+      assertEquals("https://priv.example.com/fileSequence2681.ts", segment.url);
 
-      assertEquals(5, segments.get(3).discontinuitySequenceNumber);
-      assertEquals(7975000, segments.get(3).durationUs);
-      assertEquals(true, segments.get(3).isEncrypted);
-      assertEquals("https://priv.example.com/key.php?r=2682", segments.get(3).encryptionKeyUri);
+      segment = segments.get(3);
+      assertEquals(1, segment.relativeDiscontinuitySequence);
+      assertEquals(7975000, segment.durationUs);
+      assertTrue(segment.isEncrypted);
+      assertEquals("https://priv.example.com/key.php?r=2682", segment.encryptionKeyUri);
       // 0xA7A == 2682.
-      assertNotNull(segments.get(3).encryptionIV);
-      assertEquals("A7A", segments.get(3).encryptionIV.toUpperCase(Locale.getDefault()));
-      assertEquals(51740, segments.get(3).byterangeLength);
-      assertEquals(2147586650L, segments.get(3).byterangeOffset);
-      assertEquals("https://priv.example.com/fileSequence2682.ts", segments.get(3).url);
+      assertNotNull(segment.encryptionIV);
+      assertEquals("A7A", segment.encryptionIV.toUpperCase(Locale.getDefault()));
+      assertEquals(51740, segment.byterangeLength);
+      assertEquals(2147586650L, segment.byterangeOffset);
+      assertEquals("https://priv.example.com/fileSequence2682.ts", segment.url);
 
-      assertEquals(5, segments.get(4).discontinuitySequenceNumber);
-      assertEquals(7975000, segments.get(4).durationUs);
-      assertEquals(true, segments.get(4).isEncrypted);
-      assertEquals("https://priv.example.com/key.php?r=2682", segments.get(4).encryptionKeyUri);
+      segment = segments.get(4);
+      assertEquals(1, segment.relativeDiscontinuitySequence);
+      assertEquals(7975000, segment.durationUs);
+      assertTrue(segment.isEncrypted);
+      assertEquals("https://priv.example.com/key.php?r=2682", segment.encryptionKeyUri);
       // 0xA7B == 2683.
-      assertNotNull(segments.get(4).encryptionIV);
-      assertEquals("A7B", segments.get(4).encryptionIV.toUpperCase(Locale.getDefault()));
-      assertEquals(C.LENGTH_UNSET, segments.get(4).byterangeLength);
-      assertEquals(0, segments.get(4).byterangeOffset);
-      assertEquals("https://priv.example.com/fileSequence2683.ts", segments.get(4).url);
+      assertNotNull(segment.encryptionIV);
+      assertEquals("A7B", segment.encryptionIV.toUpperCase(Locale.getDefault()));
+      assertEquals(C.LENGTH_UNSET, segment.byterangeLength);
+      assertEquals(0, segment.byterangeOffset);
+      assertEquals("https://priv.example.com/fileSequence2683.ts", segment.url);
     } catch (IOException exception) {
       fail(exception.getMessage());
     }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
index 18e39be93c..067cfe4fcd 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
@@ -27,7 +27,9 @@
 import java.io.IOException;
 import java.util.Arrays;
 
-/** Unit tests for {@link CacheDataSource}. */
+/**
+ * Unit tests for {@link CacheDataSource}.
+ */
 public class CacheDataSourceTest extends InstrumentationTestCase {
 
   private static final byte[] TEST_DATA = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
@@ -117,6 +119,13 @@ public void testContentLengthEdgeCases() throws Exception {
         C.LENGTH_UNSET, KEY_2)));
   }
 
+  public void testIgnoreCacheForUnsetLengthRequests() throws Exception {
+    CacheDataSource cacheDataSource = createCacheDataSource(false, true,
+        CacheDataSource.FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS);
+    assertReadData(cacheDataSource, true, 0, C.LENGTH_UNSET);
+    MoreAsserts.assertEmpty(simpleCache.getKeys());
+  }
+
   private void assertCacheAndRead(boolean unboundedRequest, boolean simulateUnknownLength)
       throws IOException {
     // Read all data from upstream and cache
@@ -169,6 +178,12 @@ private void assertReadData(CacheDataSource cacheDataSource, boolean unknownLeng
 
   private CacheDataSource createCacheDataSource(boolean setReadException,
       boolean simulateUnknownLength) {
+    return createCacheDataSource(setReadException, simulateUnknownLength,
+        CacheDataSource.FLAG_BLOCK_ON_CACHE);
+  }
+
+  private CacheDataSource createCacheDataSource(boolean setReadException,
+      boolean simulateUnknownLength, @CacheDataSource.Flags int flags) {
     Builder builder = new Builder();
     if (setReadException) {
       builder.appendReadError(new IOException("Shouldn't read from upstream"));
@@ -176,8 +191,7 @@ private CacheDataSource createCacheDataSource(boolean setReadException,
     builder.setSimulateUnknownLength(simulateUnknownLength);
     builder.appendReadData(TEST_DATA);
     FakeDataSource upstream = builder.build();
-    return new CacheDataSource(simpleCache, upstream, CacheDataSource.FLAG_BLOCK_ON_CACHE,
-        MAX_CACHE_FILE_SIZE);
+    return new CacheDataSource(simpleCache, upstream, flags, MAX_CACHE_FILE_SIZE);
   }
 
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java
new file mode 100644
index 0000000000..70a7d797c1
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java
@@ -0,0 +1,181 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.cache;
+
+import android.content.Context;
+import android.net.Uri;
+import android.test.AndroidTestCase;
+import android.test.MoreAsserts;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.testutil.FakeDataSource;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.upstream.DataSink;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.FileDataSource;
+import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
+import com.google.android.exoplayer2.upstream.crypto.AesCipherDataSink;
+import com.google.android.exoplayer2.upstream.crypto.AesCipherDataSource;
+import com.google.android.exoplayer2.util.Util;
+import java.io.File;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Random;
+
+/**
+ * Additional tests for {@link CacheDataSource}.
+ */
+public class CacheDataSourceTest2 extends AndroidTestCase {
+
+  private static final String EXO_CACHE_DIR = "exo";
+  private static final int EXO_CACHE_MAX_FILESIZE = 128;
+
+  private static final Uri URI = Uri.parse("http://test.com/content");
+  private static final String KEY = "key";
+  private static final byte[] DATA = TestUtil.buildTestData(8 * EXO_CACHE_MAX_FILESIZE + 1);
+
+  // A DataSpec that covers the full file.
+  private static final DataSpec FULL = new DataSpec(URI, 0, DATA.length, KEY);
+
+  private static final int OFFSET_ON_BOUNDARY = EXO_CACHE_MAX_FILESIZE;
+  // A DataSpec that starts at 0 and extends to a cache file boundary.
+  private static final DataSpec END_ON_BOUNDARY = new DataSpec(URI, 0, OFFSET_ON_BOUNDARY, KEY);
+  // A DataSpec that starts on the same boundary and extends to the end of the file.
+  private static final DataSpec START_ON_BOUNDARY = new DataSpec(URI, OFFSET_ON_BOUNDARY,
+      DATA.length - OFFSET_ON_BOUNDARY, KEY);
+
+  private static final int OFFSET_OFF_BOUNDARY = EXO_CACHE_MAX_FILESIZE * 2 + 1;
+  // A DataSpec that starts at 0 and extends to just past a cache file boundary.
+  private static final DataSpec END_OFF_BOUNDARY = new DataSpec(URI, 0, OFFSET_OFF_BOUNDARY, KEY);
+  // A DataSpec that starts on the same boundary and extends to the end of the file.
+  private static final DataSpec START_OFF_BOUNDARY = new DataSpec(URI, OFFSET_OFF_BOUNDARY,
+      DATA.length - OFFSET_OFF_BOUNDARY, KEY);
+
+  public void testWithoutEncryption() throws IOException {
+    testReads(false);
+  }
+
+  public void testWithEncryption() throws IOException {
+    testReads(true);
+  }
+
+  private void testReads(boolean useEncryption) throws IOException {
+    FakeDataSource upstreamSource = buildFakeUpstreamSource();
+    CacheDataSource source = buildCacheDataSource(getContext(), upstreamSource, useEncryption);
+    // First read, should arrive from upstream.
+    testRead(END_ON_BOUNDARY, source);
+    assertSingleOpen(upstreamSource, 0, OFFSET_ON_BOUNDARY);
+    // Second read, should arrive from upstream.
+    testRead(START_OFF_BOUNDARY, source);
+    assertSingleOpen(upstreamSource, OFFSET_OFF_BOUNDARY, DATA.length);
+    // Second read, should arrive part from cache and part from upstream.
+    testRead(END_OFF_BOUNDARY, source);
+    assertSingleOpen(upstreamSource, OFFSET_ON_BOUNDARY, OFFSET_OFF_BOUNDARY);
+    // Third read, should arrive from cache.
+    testRead(FULL, source);
+    assertNoOpen(upstreamSource);
+    // Various reads, should all arrive from cache.
+    testRead(FULL, source);
+    assertNoOpen(upstreamSource);
+    testRead(START_ON_BOUNDARY, source);
+    assertNoOpen(upstreamSource);
+    testRead(END_ON_BOUNDARY, source);
+    assertNoOpen(upstreamSource);
+    testRead(START_OFF_BOUNDARY, source);
+    assertNoOpen(upstreamSource);
+    testRead(END_OFF_BOUNDARY, source);
+    assertNoOpen(upstreamSource);
+  }
+
+  private void testRead(DataSpec dataSpec, CacheDataSource source) throws IOException {
+    byte[] scratch = new byte[4096];
+    Random random = new Random(0);
+    source.open(dataSpec);
+    int position = (int) dataSpec.absoluteStreamPosition;
+    int bytesRead = 0;
+    while (bytesRead != C.RESULT_END_OF_INPUT) {
+      int maxBytesToRead = random.nextInt(scratch.length) + 1;
+      bytesRead = source.read(scratch, 0, maxBytesToRead);
+      if (bytesRead != C.RESULT_END_OF_INPUT) {
+        MoreAsserts.assertEquals(Arrays.copyOfRange(DATA, position, position + bytesRead),
+            Arrays.copyOf(scratch, bytesRead));
+        position += bytesRead;
+      }
+    }
+    source.close();
+  }
+
+  /**
+   * Asserts that a single {@link DataSource#open(DataSpec)} call has been made to the upstream
+   * source, with the specified start (inclusive) and end (exclusive) positions.
+   */
+  private void assertSingleOpen(FakeDataSource upstreamSource, int start, int end) {
+    DataSpec[] openedDataSpecs = upstreamSource.getAndClearOpenedDataSpecs();
+    assertEquals(1, openedDataSpecs.length);
+    assertEquals(start, openedDataSpecs[0].position);
+    assertEquals(start, openedDataSpecs[0].absoluteStreamPosition);
+    assertEquals(end - start, openedDataSpecs[0].length);
+  }
+
+  /**
+   * Asserts that the upstream source was not opened.
+   */
+  private void assertNoOpen(FakeDataSource upstreamSource) {
+    DataSpec[] openedDataSpecs = upstreamSource.getAndClearOpenedDataSpecs();
+    assertEquals(0, openedDataSpecs.length);
+  }
+
+  private static FakeDataSource buildFakeUpstreamSource() {
+    return new FakeDataSource.Builder().appendReadData(DATA).build();
+  }
+
+  private static CacheDataSource buildCacheDataSource(Context context, DataSource upstreamSource,
+      boolean useAesEncryption) throws CacheException {
+    File cacheDir = context.getExternalCacheDir();
+    Cache cache = new SimpleCache(new File(cacheDir, EXO_CACHE_DIR), new NoOpCacheEvictor());
+    emptyCache(cache);
+
+    // Source and cipher
+    final String secretKey = "testKey:12345678";
+    DataSource file = new FileDataSource();
+    DataSource cacheReadDataSource = useAesEncryption
+        ? new AesCipherDataSource(Util.getUtf8Bytes(secretKey), file) : file;
+
+    // Sink and cipher
+    CacheDataSink cacheSink = new CacheDataSink(cache, EXO_CACHE_MAX_FILESIZE);
+    byte[] scratch = new byte[3897];
+    DataSink cacheWriteDataSink = useAesEncryption
+        ? new AesCipherDataSink(Util.getUtf8Bytes(secretKey), cacheSink, scratch) : cacheSink;
+
+    return new CacheDataSource(cache,
+        upstreamSource,
+        cacheReadDataSource,
+        cacheWriteDataSink,
+        CacheDataSource.FLAG_BLOCK_ON_CACHE,
+        null); // eventListener
+  }
+
+  private static void emptyCache(Cache cache) throws CacheException {
+    for (String key : cache.getKeys()) {
+      for (CacheSpan span : cache.getCachedSpans(key)) {
+        cache.removeSpan(span);
+      }
+    }
+    // Sanity check that the cache really is empty now.
+    assertTrue(cache.getKeys().isEmpty());
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java
index dd4de7cce2..4fbcc92e3d 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java
@@ -163,7 +163,7 @@ public void testGetNewId() throws Exception {
 
   public void testEncryption() throws Exception {
     byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
-    byte[] key2 = "bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
+    byte[] key2 = "Foo12345Foo12345".getBytes(C.UTF8_NAME); // 128 bit key
 
     assertStoredAndLoadedEqual(new CachedContentIndex(cacheDir, key),
         new CachedContentIndex(cacheDir, key));
@@ -181,7 +181,7 @@ public void testEncryption() throws Exception {
     // Assert file content is different
     FileInputStream fis1 = new FileInputStream(file1);
     FileInputStream fis2 = new FileInputStream(file2);
-    for (int b; (b = fis1.read()) == fis2.read();) {
+    for (int b; (b = fis1.read()) == fis2.read(); ) {
       assertTrue(b != -1);
     }
 
@@ -205,6 +205,12 @@ public void testEncryption() throws Exception {
     // Non encrypted index file can be read even when encryption key provided.
     assertStoredAndLoadedEqual(new CachedContentIndex(cacheDir),
         new CachedContentIndex(cacheDir, key));
+
+    // Test multiple store() calls
+    CachedContentIndex index = new CachedContentIndex(cacheDir, key);
+    index.addNew(new CachedContent(15, "key3", 110));
+    index.store();
+    assertStoredAndLoadedEqual(index, new CachedContentIndex(cacheDir, key));
   }
 
   private void assertStoredAndLoadedEqual(CachedContentIndex index, CachedContentIndex index2)
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java
new file mode 100644
index 0000000000..799027f4b5
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.cache;
+
+import android.test.InstrumentationTestCase;
+import com.google.android.exoplayer2.extractor.ChunkIndex;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import java.io.File;
+import java.io.IOException;
+import org.mockito.Mock;
+
+/**
+ * Tests for {@link CachedRegionTracker}.
+ */
+public final class CachedRegionTrackerTest extends InstrumentationTestCase {
+
+  private static final String CACHE_KEY = "abc";
+  private static final long MS_IN_US = 1000;
+
+  // 5 chunks, each 20 bytes long and 100 ms long.
+  private static final ChunkIndex CHUNK_INDEX = new ChunkIndex(
+      new int[] {20, 20, 20, 20, 20},
+      new long[] {100, 120, 140, 160, 180},
+      new long[] {100 * MS_IN_US, 100 * MS_IN_US, 100 * MS_IN_US, 100 * MS_IN_US, 100 * MS_IN_US},
+      new long[] {0, 100 * MS_IN_US, 200 * MS_IN_US, 300 * MS_IN_US, 400 * MS_IN_US});
+
+  @Mock private Cache cache;
+  private CachedRegionTracker tracker;
+
+  private CachedContentIndex index;
+  private File cacheDir;
+
+  @Override
+  protected void setUp() throws Exception {
+    TestUtil.setUpMockito(this);
+
+    tracker = new CachedRegionTracker(cache, CACHE_KEY, CHUNK_INDEX);
+
+    cacheDir = TestUtil.createTempFolder(getInstrumentation().getContext());
+    index = new CachedContentIndex(cacheDir);
+  }
+
+  @Override
+  protected void tearDown() throws Exception {
+    TestUtil.recursiveDelete(cacheDir);
+  }
+
+  public void testGetRegion_noSpansInCache() {
+    assertEquals(CachedRegionTracker.NOT_CACHED, tracker.getRegionEndTimeMs(100));
+    assertEquals(CachedRegionTracker.NOT_CACHED, tracker.getRegionEndTimeMs(150));
+  }
+
+  public void testGetRegion_fullyCached() throws Exception {
+    tracker.onSpanAdded(
+        cache,
+        newCacheSpan(100, 100));
+
+    assertEquals(CachedRegionTracker.CACHED_TO_END, tracker.getRegionEndTimeMs(101));
+    assertEquals(CachedRegionTracker.CACHED_TO_END, tracker.getRegionEndTimeMs(121));
+  }
+
+  public void testGetRegion_partiallyCached() throws Exception {
+    tracker.onSpanAdded(
+        cache,
+        newCacheSpan(100, 40));
+
+    assertEquals(200, tracker.getRegionEndTimeMs(101));
+    assertEquals(200, tracker.getRegionEndTimeMs(121));
+  }
+
+  public void testGetRegion_multipleSpanAddsJoinedCorrectly() throws Exception {
+    tracker.onSpanAdded(
+        cache,
+        newCacheSpan(100, 20));
+    tracker.onSpanAdded(
+        cache,
+        newCacheSpan(120, 20));
+
+    assertEquals(200, tracker.getRegionEndTimeMs(101));
+    assertEquals(200, tracker.getRegionEndTimeMs(121));
+  }
+
+  public void testGetRegion_fullyCachedThenPartiallyRemoved() throws Exception {
+    // Start with the full stream in cache.
+    tracker.onSpanAdded(
+        cache,
+        newCacheSpan(100, 100));
+
+    // Remove the middle bit.
+    tracker.onSpanRemoved(
+        cache,
+        newCacheSpan(140, 40));
+
+    assertEquals(200, tracker.getRegionEndTimeMs(101));
+    assertEquals(200, tracker.getRegionEndTimeMs(121));
+
+    assertEquals(CachedRegionTracker.CACHED_TO_END, tracker.getRegionEndTimeMs(181));
+  }
+
+  public void testGetRegion_subchunkEstimation() throws Exception {
+    tracker.onSpanAdded(
+        cache,
+        newCacheSpan(100, 10));
+
+    assertEquals(50, tracker.getRegionEndTimeMs(101));
+    assertEquals(CachedRegionTracker.NOT_CACHED, tracker.getRegionEndTimeMs(111));
+  }
+
+  private CacheSpan newCacheSpan(int position, int length) throws IOException {
+    return SimpleCacheSpanTest.createCacheSpan(index, cacheDir, CACHE_KEY, position, length, 0);
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
index 5f539c6213..001c6adc87 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
@@ -16,12 +16,16 @@
 package com.google.android.exoplayer2.upstream.cache;
 
 import android.test.InstrumentationTestCase;
+import android.test.MoreAsserts;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.util.Util;
 import java.io.File;
+import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.util.NavigableSet;
+import java.util.Random;
 import java.util.Set;
 
 /**
@@ -46,9 +50,9 @@ protected void tearDown() throws Exception {
   public void testCommittingOneFile() throws Exception {
     SimpleCache simpleCache = getSimpleCache();
 
-    CacheSpan cacheSpan = simpleCache.startReadWrite(KEY_1, 0);
-    assertFalse(cacheSpan.isCached);
-    assertTrue(cacheSpan.isOpenEnded());
+    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
+    assertFalse(cacheSpan1.isCached);
+    assertTrue(cacheSpan1.isOpenEnded());
 
     assertNull(simpleCache.startReadWriteNonBlocking(KEY_1, 0));
 
@@ -58,20 +62,33 @@ public void testCommittingOneFile() throws Exception {
     assertEquals(0, simpleCache.getCacheSpace());
     assertEquals(0, cacheDir.listFiles().length);
 
-    addCache(simpleCache, 0, 15);
+    addCache(simpleCache, KEY_1, 0, 15);
 
     Set<String> cachedKeys = simpleCache.getKeys();
     assertEquals(1, cachedKeys.size());
     assertTrue(cachedKeys.contains(KEY_1));
     cachedSpans = simpleCache.getCachedSpans(KEY_1);
     assertEquals(1, cachedSpans.size());
-    assertTrue(cachedSpans.contains(cacheSpan));
+    assertTrue(cachedSpans.contains(cacheSpan1));
     assertEquals(15, simpleCache.getCacheSpace());
 
-    cacheSpan = simpleCache.startReadWrite(KEY_1, 0);
-    assertTrue(cacheSpan.isCached);
-    assertFalse(cacheSpan.isOpenEnded());
-    assertEquals(15, cacheSpan.length);
+    simpleCache.releaseHoleSpan(cacheSpan1);
+
+    CacheSpan cacheSpan2 = simpleCache.startReadWrite(KEY_1, 0);
+    assertTrue(cacheSpan2.isCached);
+    assertFalse(cacheSpan2.isOpenEnded());
+    assertEquals(15, cacheSpan2.length);
+    assertCachedDataReadCorrect(cacheSpan2);
+  }
+
+  public void testReadCacheWithoutReleasingWriteCacheSpan() throws Exception {
+    SimpleCache simpleCache = getSimpleCache();
+
+    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
+    addCache(simpleCache, KEY_1, 0, 15);
+    CacheSpan cacheSpan2 = simpleCache.startReadWrite(KEY_1, 0);
+    assertCachedDataReadCorrect(cacheSpan2);
+    simpleCache.releaseHoleSpan(cacheSpan1);
   }
 
   public void testSetGetLength() throws Exception {
@@ -83,12 +100,12 @@ public void testSetGetLength() throws Exception {
 
     simpleCache.startReadWrite(KEY_1, 0);
 
-    addCache(simpleCache, 0, 15);
+    addCache(simpleCache, KEY_1, 0, 15);
 
     simpleCache.setContentLength(KEY_1, 150);
     assertEquals(150, simpleCache.getContentLength(KEY_1));
 
-    addCache(simpleCache, 140, 10);
+    addCache(simpleCache, KEY_1, 140, 10);
 
     // Check if values are kept after cache is reloaded.
     SimpleCache simpleCache2 = getSimpleCache();
@@ -107,16 +124,109 @@ public void testSetGetLength() throws Exception {
     assertEquals(150, simpleCache2.getContentLength(KEY_1));
   }
 
+  public void testReloadCache() throws Exception {
+    SimpleCache simpleCache = getSimpleCache();
+
+    // write data
+    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
+    addCache(simpleCache, KEY_1, 0, 15);
+    simpleCache.releaseHoleSpan(cacheSpan1);
+
+    // Reload cache
+    simpleCache = getSimpleCache();
+
+    // read data back
+    CacheSpan cacheSpan2 = simpleCache.startReadWrite(KEY_1, 0);
+    assertCachedDataReadCorrect(cacheSpan2);
+  }
+
+  public void testEncryptedIndex() throws Exception {
+    byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
+    SimpleCache simpleCache = getEncryptedSimpleCache(key);
+
+    // write data
+    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
+    addCache(simpleCache, KEY_1, 0, 15);
+    simpleCache.releaseHoleSpan(cacheSpan1);
+
+    // Reload cache
+    simpleCache = getEncryptedSimpleCache(key);
+
+    // read data back
+    CacheSpan cacheSpan2 = simpleCache.startReadWrite(KEY_1, 0);
+    assertCachedDataReadCorrect(cacheSpan2);
+  }
+
+  public void testEncryptedIndexWrongKey() throws Exception {
+    byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
+    SimpleCache simpleCache = getEncryptedSimpleCache(key);
+
+    // write data
+    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
+    addCache(simpleCache, KEY_1, 0, 15);
+    simpleCache.releaseHoleSpan(cacheSpan1);
+
+    // Reload cache
+    byte[] key2 = "Foo12345Foo12345".getBytes(C.UTF8_NAME); // 128 bit key
+    simpleCache = getEncryptedSimpleCache(key2);
+
+    // Cache should be cleared
+    assertEquals(0, simpleCache.getKeys().size());
+    assertEquals(0, cacheDir.listFiles().length);
+  }
+
+  public void testEncryptedIndexLostKey() throws Exception {
+    byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
+    SimpleCache simpleCache = getEncryptedSimpleCache(key);
+
+    // write data
+    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
+    addCache(simpleCache, KEY_1, 0, 15);
+    simpleCache.releaseHoleSpan(cacheSpan1);
+
+    // Reload cache
+    simpleCache = getSimpleCache();
+
+    // Cache should be cleared
+    assertEquals(0, simpleCache.getKeys().size());
+    assertEquals(0, cacheDir.listFiles().length);
+  }
+
   private SimpleCache getSimpleCache() {
     return new SimpleCache(cacheDir, new NoOpCacheEvictor());
   }
 
-  private void addCache(SimpleCache simpleCache, int position, int length) throws IOException {
-    File file = simpleCache.startFile(KEY_1, position, length);
+  private SimpleCache getEncryptedSimpleCache(byte[] secretKey) {
+    return new SimpleCache(cacheDir, new NoOpCacheEvictor(), secretKey);
+  }
+
+  private static void addCache(SimpleCache simpleCache, String key, int position, int length)
+      throws IOException {
+    File file = simpleCache.startFile(key, position, length);
     FileOutputStream fos = new FileOutputStream(file);
-    fos.write(new byte[length]);
-    fos.close();
+    try {
+      fos.write(generateData(key, position, length));
+    } finally {
+      fos.close();
+    }
     simpleCache.commitFile(file);
   }
 
+  private static void assertCachedDataReadCorrect(CacheSpan cacheSpan) throws IOException {
+    assertTrue(cacheSpan.isCached);
+    byte[] expected = generateData(cacheSpan.key, (int) cacheSpan.position, (int) cacheSpan.length);
+    FileInputStream inputStream = new FileInputStream(cacheSpan.file);
+    try {
+      MoreAsserts.assertEquals(expected, Util.toByteArray(inputStream));
+    } finally {
+      inputStream.close();
+    }
+  }
+
+  private static byte[] generateData(String key, int position, int length) {
+    byte[] bytes = new byte[length];
+    new Random((long) (key.hashCode() ^ position)).nextBytes(bytes);
+    return bytes;
+  }
+
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java
new file mode 100644
index 0000000000..b4e7e6e7f6
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java
@@ -0,0 +1,186 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.crypto;
+
+import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.util.Util;
+import java.util.Random;
+import javax.crypto.Cipher;
+import junit.framework.TestCase;
+
+/**
+ * Unit tests for {@link AesFlushingCipher}.
+ */
+public class AesFlushingCipherTest extends TestCase {
+
+  private static final int DATA_LENGTH = 65536;
+  private static final byte[] KEY = Util.getUtf8Bytes("testKey:12345678");
+  private static final long NONCE = 0;
+  private static final long START_OFFSET = 11;
+  private static final long RANDOM_SEED = 0x12345678;
+
+  private AesFlushingCipher encryptCipher;
+  private AesFlushingCipher decryptCipher;
+
+  @Override
+  protected void setUp() {
+    encryptCipher = new AesFlushingCipher(Cipher.ENCRYPT_MODE, KEY, NONCE, START_OFFSET);
+    decryptCipher = new AesFlushingCipher(Cipher.DECRYPT_MODE, KEY, NONCE, START_OFFSET);
+  }
+
+  @Override
+  protected void tearDown() {
+    encryptCipher = null;
+    decryptCipher = null;
+  }
+
+  private long getMaxUnchangedBytesAllowedPostEncryption(long length) {
+    // Assuming that not more than 10% of the resultant bytes should be identical.
+    // The value of 10% is arbitrary, ciphers standards do not name a value.
+    return length / 10;
+  }
+
+  // Count the number of bytes that do not match.
+  private int getDifferingByteCount(byte[] data1, byte[] data2, int startOffset) {
+    int count = 0;
+    for (int i = startOffset; i < data1.length; i++) {
+      if (data1[i] != data2[i]) {
+        count++;
+      }
+    }
+    return count;
+  }
+
+  // Count the number of bytes that do not match.
+  private int getDifferingByteCount(byte[] data1, byte[] data2) {
+    return getDifferingByteCount(data1, data2, 0);
+  }
+
+  // Test a single encrypt and decrypt call
+  public void testSingle() {
+    byte[] reference = TestUtil.buildTestData(DATA_LENGTH);
+    byte[] data = reference.clone();
+
+    encryptCipher.updateInPlace(data, 0, data.length);
+    int unchangedByteCount = data.length - getDifferingByteCount(reference, data);
+    assertTrue(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length));
+
+    decryptCipher.updateInPlace(data, 0, data.length);
+    int differingByteCount = getDifferingByteCount(reference, data);
+    assertEquals(0, differingByteCount);
+  }
+
+  // Test several encrypt and decrypt calls, each aligned on a 16 byte block size
+  public void testAligned() {
+    byte[] reference = TestUtil.buildTestData(DATA_LENGTH);
+    byte[] data = reference.clone();
+    Random random = new Random(RANDOM_SEED);
+
+    int offset = 0;
+    while (offset < data.length) {
+      int bytes = (1 + random.nextInt(50)) * 16;
+      bytes = Math.min(bytes, data.length - offset);
+      assertEquals(0, bytes % 16);
+      encryptCipher.updateInPlace(data, offset, bytes);
+      offset += bytes;
+    }
+
+    int unchangedByteCount = data.length - getDifferingByteCount(reference, data);
+    assertTrue(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length));
+
+    offset = 0;
+    while (offset < data.length) {
+      int bytes = (1 + random.nextInt(50)) * 16;
+      bytes = Math.min(bytes, data.length - offset);
+      assertEquals(0, bytes % 16);
+      decryptCipher.updateInPlace(data, offset, bytes);
+      offset += bytes;
+    }
+
+    int differingByteCount = getDifferingByteCount(reference, data);
+    assertEquals(0, differingByteCount);
+  }
+
+  // Test several encrypt and decrypt calls, not aligned on block boundary
+  public void testUnAligned() {
+    byte[] reference = TestUtil.buildTestData(DATA_LENGTH);
+    byte[] data = reference.clone();
+    Random random = new Random(RANDOM_SEED);
+
+    // Encrypt
+    int offset = 0;
+    while (offset < data.length) {
+      int bytes = 1 + random.nextInt(4095);
+      bytes = Math.min(bytes, data.length - offset);
+      encryptCipher.updateInPlace(data, offset, bytes);
+      offset += bytes;
+    }
+
+    int unchangedByteCount = data.length - getDifferingByteCount(reference, data);
+    assertTrue(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length));
+
+    offset = 0;
+    while (offset < data.length) {
+      int bytes = 1 + random.nextInt(4095);
+      bytes = Math.min(bytes, data.length - offset);
+      decryptCipher.updateInPlace(data, offset, bytes);
+      offset += bytes;
+    }
+
+    int differingByteCount = getDifferingByteCount(reference, data);
+    assertEquals(0, differingByteCount);
+  }
+
+  // Test decryption starting from the middle of an encrypted block
+  public void testMidJoin() {
+    byte[] reference = TestUtil.buildTestData(DATA_LENGTH);
+    byte[] data = reference.clone();
+    Random random = new Random(RANDOM_SEED);
+
+    // Encrypt
+    int offset = 0;
+    while (offset < data.length) {
+      int bytes = 1 + random.nextInt(4095);
+      bytes = Math.min(bytes, data.length - offset);
+      encryptCipher.updateInPlace(data, offset, bytes);
+      offset += bytes;
+    }
+
+    // Verify
+    int unchangedByteCount = data.length - getDifferingByteCount(reference, data);
+    assertTrue(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length));
+
+    // Setup decryption from random location
+    offset = random.nextInt(4096);
+    decryptCipher = new AesFlushingCipher(Cipher.DECRYPT_MODE, KEY, NONCE, offset + START_OFFSET);
+    int remainingLength = data.length - offset;
+    int originalOffset = offset;
+
+    // Decrypt
+    while (remainingLength > 0) {
+      int bytes = 1 + random.nextInt(4095);
+      bytes = Math.min(bytes, remainingLength);
+      decryptCipher.updateInPlace(data, offset, bytes);
+      offset += bytes;
+      remainingLength -= bytes;
+    }
+
+    // Verify
+    int differingByteCount = getDifferingByteCount(reference, data, originalOffset);
+    assertEquals(0, differingByteCount);
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java
index a747930152..49719b95f7 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java
@@ -371,6 +371,73 @@ public void testReadEmptyString() {
     assertNull(parser.readLine());
   }
 
+  public void testReadNullTerminatedStringWithLengths() {
+    byte[] bytes = new byte[] {
+        'f', 'o', 'o', 0, 'b', 'a', 'r', 0
+    };
+    // Test with lengths that match NUL byte positions.
+    ParsableByteArray parser = new ParsableByteArray(bytes);
+    assertEquals("foo", parser.readNullTerminatedString(4));
+    assertEquals(4, parser.getPosition());
+    assertEquals("bar", parser.readNullTerminatedString(4));
+    assertEquals(8, parser.getPosition());
+    assertNull(parser.readNullTerminatedString());
+    // Test with lengths that do not match NUL byte positions.
+    parser = new ParsableByteArray(bytes);
+    assertEquals("fo", parser.readNullTerminatedString(2));
+    assertEquals(2, parser.getPosition());
+    assertEquals("o", parser.readNullTerminatedString(2));
+    assertEquals(4, parser.getPosition());
+    assertEquals("bar", parser.readNullTerminatedString(3));
+    assertEquals(7, parser.getPosition());
+    assertEquals("", parser.readNullTerminatedString(1));
+    assertEquals(8, parser.getPosition());
+    assertNull(parser.readNullTerminatedString());
+    // Test with limit at NUL
+    parser = new ParsableByteArray(bytes, 4);
+    assertEquals("foo", parser.readNullTerminatedString(4));
+    assertEquals(4, parser.getPosition());
+    assertNull(parser.readNullTerminatedString());
+    // Test with limit before NUL
+    parser = new ParsableByteArray(bytes, 3);
+    assertEquals("foo", parser.readNullTerminatedString(3));
+    assertEquals(3, parser.getPosition());
+    assertNull(parser.readNullTerminatedString());
+  }
+
+  public void testReadNullTerminatedString() {
+    byte[] bytes = new byte[] {
+        'f', 'o', 'o', 0, 'b', 'a', 'r', 0
+    };
+    // Test normal case.
+    ParsableByteArray parser = new ParsableByteArray(bytes);
+    assertEquals("foo", parser.readNullTerminatedString());
+    assertEquals(4, parser.getPosition());
+    assertEquals("bar", parser.readNullTerminatedString());
+    assertEquals(8, parser.getPosition());
+    assertNull(parser.readNullTerminatedString());
+    // Test with limit at NUL.
+    parser = new ParsableByteArray(bytes, 4);
+    assertEquals("foo", parser.readNullTerminatedString());
+    assertEquals(4, parser.getPosition());
+    assertNull(parser.readNullTerminatedString());
+    // Test with limit before NUL.
+    parser = new ParsableByteArray(bytes, 3);
+    assertEquals("foo", parser.readNullTerminatedString());
+    assertEquals(3, parser.getPosition());
+    assertNull(parser.readNullTerminatedString());
+  }
+
+  public void testReadNullTerminatedStringWithoutEndingNull() {
+    byte[] bytes = new byte[] {
+        'f', 'o', 'o', 0, 'b', 'a', 'r'
+    };
+    ParsableByteArray parser = new ParsableByteArray(bytes);
+    assertEquals("foo", parser.readNullTerminatedString());
+    assertEquals("bar", parser.readNullTerminatedString());
+    assertNull(parser.readNullTerminatedString());
+  }
+
   public void testReadSingleLineWithoutEndingTrail() {
     byte[] bytes = new byte[] {
       'f', 'o', 'o'
diff --git a/library/src/main/java/com/google/android/exoplayer2/BaseRenderer.java b/library/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
index 514bbca8f4..9973a50cff 100644
--- a/library/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
@@ -28,6 +28,7 @@
 
   private final int trackType;
 
+  private RendererConfiguration configuration;
   private int index;
   private int state;
   private SampleStream stream;
@@ -70,9 +71,11 @@ public final int getState() {
   }
 
   @Override
-  public final void enable(Format[] formats, SampleStream stream, long positionUs, boolean joining,
-      long offsetUs) throws ExoPlaybackException {
+  public final void enable(RendererConfiguration configuration, Format[] formats,
+      SampleStream stream, long positionUs, boolean joining, long offsetUs)
+      throws ExoPlaybackException {
     Assertions.checkState(state == STATE_DISABLED);
+    this.configuration = configuration;
     state = STATE_ENABLED;
     onEnabled(joining);
     replaceStream(formats, stream, offsetUs);
@@ -237,10 +240,15 @@ protected void onDisabled() {
 
   // Methods to be called by subclasses.
 
+  /**
+   * Returns the configuration set when the renderer was most recently enabled.
+   */
+  protected final RendererConfiguration getConfiguration() {
+    return configuration;
+  }
+
   /**
    * Returns the index of the renderer within the player.
-   *
-   * @return The index of the renderer within the player.
    */
   protected final int getIndex() {
     return index;
@@ -251,11 +259,11 @@ protected final int getIndex() {
    * {@link C#RESULT_BUFFER_READ} is only returned if {@link #setCurrentStreamFinal()} has been
    * called. {@link C#RESULT_NOTHING_READ} is returned otherwise.
    *
-   * @see SampleStream#readData(FormatHolder, DecoderInputBuffer)
    * @param formatHolder A {@link FormatHolder} to populate in the case of reading a format.
    * @param buffer A {@link DecoderInputBuffer} to populate in the case of reading a sample or the
    *     end of the stream. If the end of the stream has been reached, the
-   *     {@link C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer.
+   *     {@link C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer. May be null if the
+   *     caller requires that the format of the stream be read even if it's not changing.
    * @return The result, which can be {@link C#RESULT_NOTHING_READ}, {@link C#RESULT_FORMAT_READ} or
    *     {@link C#RESULT_BUFFER_READ}.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer2/C.java b/library/src/main/java/com/google/android/exoplayer2/C.java
index 3e6fac4a5e..0b1c33bfc9 100644
--- a/library/src/main/java/com/google/android/exoplayer2/C.java
+++ b/library/src/main/java/com/google/android/exoplayer2/C.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2;
 
+import android.annotation.TargetApi;
+import android.content.Context;
 import android.media.AudioFormat;
 import android.media.AudioManager;
 import android.media.MediaCodec;
@@ -96,6 +98,13 @@ private C() {}
   @SuppressWarnings("InlinedApi")
   public static final int CRYPTO_MODE_AES_CBC = MediaCodec.CRYPTO_MODE_AES_CBC;
 
+  /**
+   * Represents an unset {@link android.media.AudioTrack} session identifier. Equal to
+   * {@link AudioManager#AUDIO_SESSION_ID_GENERATE}.
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int AUDIO_SESSION_ID_UNSET = AudioManager.AUDIO_SESSION_ID_GENERATE;
+
   /**
    * Represents an audio encoding, or an invalid or unset value.
    */
@@ -543,4 +552,13 @@ public static long msToUs(long timeMs) {
     return timeMs == TIME_UNSET ? TIME_UNSET : (timeMs * 1000);
   }
 
+  /**
+   * Returns a newly generated {@link android.media.AudioTrack} session identifier.
+   */
+  @TargetApi(21)
+  public static int generateAudioSessionIdV21(Context context) {
+    return ((AudioManager) context.getSystemService(Context.AUDIO_SERVICE))
+        .generateAudioSessionId();
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java b/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
index e6a39d8a27..fe7015a942 100644
--- a/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
+++ b/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DefaultAllocator;
+import com.google.android.exoplayer2.util.PriorityTaskManager;
 import com.google.android.exoplayer2.util.Util;
 
 /**
@@ -50,6 +51,11 @@
    */
   public static final int DEFAULT_BUFFER_FOR_PLAYBACK_AFTER_REBUFFER_MS  = 5000;
 
+  /**
+   * Priority for media loading.
+   */
+  public static final int LOADING_PRIORITY = 0;
+
   private static final int ABOVE_HIGH_WATERMARK = 0;
   private static final int BETWEEN_WATERMARKS = 1;
   private static final int BELOW_LOW_WATERMARK = 2;
@@ -60,6 +66,7 @@
   private final long maxBufferUs;
   private final long bufferForPlaybackUs;
   private final long bufferForPlaybackAfterRebufferUs;
+  private final PriorityTaskManager priorityTaskManager;
 
   private int targetBufferSize;
   private boolean isBuffering;
@@ -97,11 +104,36 @@ public DefaultLoadControl(DefaultAllocator allocator) {
    */
   public DefaultLoadControl(DefaultAllocator allocator, int minBufferMs, int maxBufferMs,
       long bufferForPlaybackMs, long bufferForPlaybackAfterRebufferMs) {
+    this(allocator, minBufferMs, maxBufferMs, bufferForPlaybackMs, bufferForPlaybackAfterRebufferMs,
+        null);
+  }
+
+  /**
+   * Constructs a new instance.
+   *
+   * @param allocator The {@link DefaultAllocator} used by the loader.
+   * @param minBufferMs The minimum duration of media that the player will attempt to ensure is
+   *     buffered at all times, in milliseconds.
+   * @param maxBufferMs The maximum duration of media that the player will attempt buffer, in
+   *     milliseconds.
+   * @param bufferForPlaybackMs The duration of media that must be buffered for playback to start or
+   *     resume following a user action such as a seek, in milliseconds.
+   * @param bufferForPlaybackAfterRebufferMs The default duration of media that must be buffered for
+   *     playback to resume after a rebuffer, in milliseconds. A rebuffer is defined to be caused by
+   *     buffer depletion rather than a user action.
+   * @param priorityTaskManager If not null, registers itself as a task with priority
+   *     {@link #LOADING_PRIORITY} during loading periods, and unregisters itself during draining
+   *     periods.
+   */
+  public DefaultLoadControl(DefaultAllocator allocator, int minBufferMs, int maxBufferMs,
+      long bufferForPlaybackMs, long bufferForPlaybackAfterRebufferMs,
+      PriorityTaskManager priorityTaskManager) {
     this.allocator = allocator;
     minBufferUs = minBufferMs * 1000L;
     maxBufferUs = maxBufferMs * 1000L;
     bufferForPlaybackUs = bufferForPlaybackMs * 1000L;
     bufferForPlaybackAfterRebufferUs = bufferForPlaybackAfterRebufferMs * 1000L;
+    this.priorityTaskManager = priorityTaskManager;
   }
 
   @Override
@@ -146,8 +178,16 @@ public boolean shouldStartPlayback(long bufferedDurationUs, boolean rebuffering)
   public boolean shouldContinueLoading(long bufferedDurationUs) {
     int bufferTimeState = getBufferTimeState(bufferedDurationUs);
     boolean targetBufferSizeReached = allocator.getTotalBytesAllocated() >= targetBufferSize;
+    boolean wasBuffering = isBuffering;
     isBuffering = bufferTimeState == BELOW_LOW_WATERMARK
         || (bufferTimeState == BETWEEN_WATERMARKS && isBuffering && !targetBufferSizeReached);
+    if (priorityTaskManager != null && isBuffering != wasBuffering) {
+      if (isBuffering) {
+        priorityTaskManager.add(LOADING_PRIORITY);
+      } else {
+        priorityTaskManager.remove(LOADING_PRIORITY);
+      }
+    }
     return isBuffering;
   }
 
@@ -158,6 +198,9 @@ private int getBufferTimeState(long bufferedDurationUs) {
 
   private void reset(boolean resetAllocator) {
     targetBufferSize = 0;
+    if (priorityTaskManager != null && isBuffering) {
+      priorityTaskManager.remove(LOADING_PRIORITY);
+    }
     isBuffering = false;
     if (resetAllocator) {
       allocator.reset();
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayer.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
index 6c64d2c0f3..083569416c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
@@ -447,4 +447,20 @@ public ExoPlayerMessage(ExoPlayerComponent target, int messageType, Object messa
    */
   int getBufferedPercentage();
 
+  /**
+   * Returns whether the current window is dynamic, or {@code false} if the {@link Timeline} is
+   * empty.
+   *
+   * @see Timeline.Window#isDynamic
+   */
+  boolean isCurrentWindowDynamic();
+
+  /**
+   * Returns whether the current window is seekable, or {@code false} if the {@link Timeline} is
+   * empty.
+   *
+   * @see Timeline.Window#isSeekable
+   */
+  boolean isCurrentWindowSeekable();
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
index a7cbeb524c..d44d138091 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
@@ -22,12 +22,12 @@
 import android.util.Log;
 import com.google.android.exoplayer2.ExoPlayerImplInternal.PlaybackInfo;
 import com.google.android.exoplayer2.ExoPlayerImplInternal.SourceInfo;
-import com.google.android.exoplayer2.ExoPlayerImplInternal.TrackInfo;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.trackselection.TrackSelectorResult;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 import java.util.concurrent.CopyOnWriteArraySet;
@@ -271,6 +271,22 @@ public int getBufferedPercentage() {
         : (int) (duration == 0 ? 100 : (bufferedPosition * 100) / duration);
   }
 
+  @Override
+  public boolean isCurrentWindowDynamic() {
+    if (timeline.isEmpty()) {
+      return false;
+    }
+    return timeline.getWindow(getCurrentWindowIndex(), window).isDynamic;
+  }
+
+  @Override
+  public boolean isCurrentWindowSeekable() {
+    if (timeline.isEmpty()) {
+      return false;
+    }
+    return timeline.getWindow(getCurrentWindowIndex(), window).isSeekable;
+  }
+
   @Override
   public int getRendererCount() {
     return renderers.length;
@@ -319,11 +335,11 @@ public Object getCurrentManifest() {
         break;
       }
       case ExoPlayerImplInternal.MSG_TRACKS_CHANGED: {
-        TrackInfo trackInfo = (TrackInfo) msg.obj;
+        TrackSelectorResult trackSelectorResult = (TrackSelectorResult) msg.obj;
         tracksSelected = true;
-        trackGroups = trackInfo.groups;
-        trackSelections = trackInfo.selections;
-        trackSelector.onSelectionActivated(trackInfo.info);
+        trackGroups = trackSelectorResult.groups;
+        trackSelections = trackSelectorResult.selections;
+        trackSelector.onSelectionActivated(trackSelectorResult.info);
         for (EventListener listener : listeners) {
           listener.onTracksChanged(trackGroups, trackSelections);
         }
@@ -332,8 +348,10 @@ public Object getCurrentManifest() {
       case ExoPlayerImplInternal.MSG_SEEK_ACK: {
         if (--pendingSeekAcks == 0) {
           playbackInfo = (ExoPlayerImplInternal.PlaybackInfo) msg.obj;
-          for (EventListener listener : listeners) {
-            listener.onPositionDiscontinuity();
+          if (msg.arg1 != 0) {
+            for (EventListener listener : listeners) {
+              listener.onPositionDiscontinuity();
+            }
           }
         }
         break;
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
index 8866bb7c48..faf86087c9 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
@@ -26,16 +26,15 @@
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.SampleStream;
-import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.trackselection.TrackSelectorResult;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MediaClock;
 import com.google.android.exoplayer2.util.PriorityHandlerThread;
 import com.google.android.exoplayer2.util.StandaloneMediaClock;
 import com.google.android.exoplayer2.util.TraceUtil;
-import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 
 /**
@@ -72,20 +71,6 @@ public PlaybackInfo copyWithPeriodIndex(int periodIndex) {
 
   }
 
-  public static final class TrackInfo {
-
-    public final TrackGroupArray groups;
-    public final TrackSelectionArray selections;
-    public final Object info;
-
-    public TrackInfo(TrackGroupArray groups, TrackSelectionArray selections, Object info) {
-      this.groups = groups;
-      this.selections = selections;
-      this.info = info;
-    }
-
-  }
-
   public static final class SourceInfo {
 
     public final Timeline timeline;
@@ -559,7 +544,7 @@ private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackExcepti
       // The seek position was valid for the timeline that it was performed into, but the
       // timeline has changed and a suitable seek position could not be resolved in the new one.
       playbackInfo = new PlaybackInfo(0, 0);
-      eventHandler.obtainMessage(MSG_SEEK_ACK, playbackInfo).sendToTarget();
+      eventHandler.obtainMessage(MSG_SEEK_ACK, 1, 0, playbackInfo).sendToTarget();
       // Set the internal position to (0,TIME_UNSET) so that a subsequent seek to (0,0) isn't
       // ignored.
       playbackInfo = new PlaybackInfo(0, C.TIME_UNSET);
@@ -569,6 +554,7 @@ private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackExcepti
       return;
     }
 
+    boolean seekPositionAdjusted = seekPosition.windowPositionUs == C.TIME_UNSET;
     int periodIndex = periodPosition.first;
     long periodPositionUs = periodPosition.second;
 
@@ -578,10 +564,13 @@ private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackExcepti
         // Seek position equals the current position. Do nothing.
         return;
       }
-      periodPositionUs = seekToPeriodPosition(periodIndex, periodPositionUs);
+      long newPeriodPositionUs = seekToPeriodPosition(periodIndex, periodPositionUs);
+      seekPositionAdjusted |= periodPositionUs != newPeriodPositionUs;
+      periodPositionUs = newPeriodPositionUs;
     } finally {
       playbackInfo = new PlaybackInfo(periodIndex, periodPositionUs);
-      eventHandler.obtainMessage(MSG_SEEK_ACK, playbackInfo).sendToTarget();
+      eventHandler.obtainMessage(MSG_SEEK_ACK, seekPositionAdjusted ? 1 : 0, 0, playbackInfo)
+          .sendToTarget();
     }
   }
 
@@ -620,6 +609,7 @@ private long seekToPeriodPosition(int periodIndex, long periodPositionUs)
       enabledRenderers = new Renderer[0];
       rendererMediaClock = null;
       rendererMediaClockSource = null;
+      playingPeriodHolder = null;
     }
 
     // Update the holders.
@@ -795,7 +785,8 @@ private void reselectTracksInternal() throws ExoPlaybackException {
           }
         }
       }
-      eventHandler.obtainMessage(MSG_TRACKS_CHANGED, periodHolder.getTrackInfo()).sendToTarget();
+      eventHandler.obtainMessage(MSG_TRACKS_CHANGED, periodHolder.trackSelectorResult)
+          .sendToTarget();
       enableRenderers(rendererWasEnabledFlags, enabledRendererCount);
     } else {
       // Release and re-prepare/buffer periods after the one whose selection changed.
@@ -1134,33 +1125,38 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
     }
 
     if (readingPeriodHolder.isLast) {
-      for (Renderer renderer : enabledRenderers) {
+      for (int i = 0; i < renderers.length; i++) {
+        Renderer renderer = renderers[i];
+        SampleStream sampleStream = readingPeriodHolder.sampleStreams[i];
         // Defer setting the stream as final until the renderer has actually consumed the whole
         // stream in case of playlist changes that cause the stream to be no longer final.
-        if (renderer.hasReadStreamToEnd()) {
+        if (sampleStream != null && renderer.getStream() == sampleStream
+            && renderer.hasReadStreamToEnd()) {
           renderer.setCurrentStreamFinal();
         }
       }
       return;
     }
 
-    for (Renderer renderer : enabledRenderers) {
-      if (!renderer.hasReadStreamToEnd()) {
+    for (int i = 0; i < renderers.length; i++) {
+      Renderer renderer = renderers[i];
+      SampleStream sampleStream = readingPeriodHolder.sampleStreams[i];
+      if (renderer.getStream() != sampleStream
+          || (sampleStream != null && !renderer.hasReadStreamToEnd())) {
         return;
       }
     }
 
     if (readingPeriodHolder.next != null && readingPeriodHolder.next.prepared) {
-      TrackSelectionArray oldTrackSelections = readingPeriodHolder.trackSelections;
+      TrackSelectorResult oldTrackSelectorResult = readingPeriodHolder.trackSelectorResult;
       readingPeriodHolder = readingPeriodHolder.next;
-      TrackSelectionArray newTrackSelections = readingPeriodHolder.trackSelections;
+      TrackSelectorResult newTrackSelectorResult = readingPeriodHolder.trackSelectorResult;
 
       boolean initialDiscontinuity =
           readingPeriodHolder.mediaPeriod.readDiscontinuity() != C.TIME_UNSET;
       for (int i = 0; i < renderers.length; i++) {
         Renderer renderer = renderers[i];
-        TrackSelection oldSelection = oldTrackSelections.get(i);
-        TrackSelection newSelection = newTrackSelections.get(i);
+        TrackSelection oldSelection = oldTrackSelectorResult.selections.get(i);
         if (oldSelection == null) {
           // The renderer has no current stream and will be enabled when we play the next period.
         } else if (initialDiscontinuity) {
@@ -1168,9 +1164,12 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
           // be disabled and re-enabled when it starts playing the next period.
           renderer.setCurrentStreamFinal();
         } else if (!renderer.isCurrentStreamFinal()) {
-          if (newSelection != null) {
-            // Replace the renderer's SampleStream so the transition to playing the next period
-            // can be seamless.
+          TrackSelection newSelection = newTrackSelectorResult.selections.get(i);
+          RendererConfiguration oldConfig = oldTrackSelectorResult.rendererConfigurations[i];
+          RendererConfiguration newConfig = newTrackSelectorResult.rendererConfigurations[i];
+          if (newSelection != null && newConfig.equals(oldConfig)) {
+            // Replace the renderer's SampleStream so the transition to playing the next period can
+            // be seamless.
             Format[] formats = new Format[newSelection.length()];
             for (int j = 0; j < formats.length; j++) {
               formats[j] = newSelection.getFormat(j);
@@ -1178,8 +1177,9 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
             renderer.replaceStream(formats, readingPeriodHolder.sampleStreams[i],
                 readingPeriodHolder.getRendererOffset());
           } else {
-            // The renderer will be disabled when transitioning to playing the next period. Mark the
-            // SampleStream as final to play out any remaining data.
+            // The renderer will be disabled when transitioning to playing the next period, either
+            // because there's no new selection or because a configuration change is required. Mark
+            // the SampleStream as final to play out any remaining data.
             renderer.setCurrentStreamFinal();
           }
         }
@@ -1215,7 +1215,7 @@ private void maybeUpdateLoadingPeriod() throws IOException {
 
     long newLoadingPeriodStartPositionUs;
     if (loadingPeriodHolder == null) {
-      newLoadingPeriodStartPositionUs = playbackInfo.startPositionUs;
+      newLoadingPeriodStartPositionUs = playbackInfo.positionUs;
     } else {
       int newLoadingWindowIndex = timeline.getPeriod(newLoadingPeriodIndex, period).windowIndex;
       if (newLoadingPeriodIndex
@@ -1315,20 +1315,21 @@ private void setPlayingPeriodHolder(MediaPeriodHolder periodHolder) throws ExoPl
       return;
     }
 
-    playingPeriodHolder = periodHolder;
     int enabledRendererCount = 0;
     boolean[] rendererWasEnabledFlags = new boolean[renderers.length];
     for (int i = 0; i < renderers.length; i++) {
       Renderer renderer = renderers[i];
       rendererWasEnabledFlags[i] = renderer.getState() != Renderer.STATE_DISABLED;
-      TrackSelection newSelection = periodHolder.trackSelections.get(i);
+      TrackSelection newSelection = periodHolder.trackSelectorResult.selections.get(i);
       if (newSelection != null) {
         enabledRendererCount++;
       }
-      if (rendererWasEnabledFlags[i] && (newSelection == null || renderer.isCurrentStreamFinal())) {
+      if (rendererWasEnabledFlags[i] && (newSelection == null
+          || (renderer.isCurrentStreamFinal()
+          && renderer.getStream() == playingPeriodHolder.sampleStreams[i]))) {
         // The renderer should be disabled before playing the next period, either because it's not
-        // needed to play the next period, or because we need to disable and re-enable it because
-        // the renderer thinks that its current stream is final.
+        // needed to play the next period, or because we need to re-enable it as its current stream
+        // is final and it's not reading ahead.
         if (renderer == rendererMediaClockSource) {
           // Sync standaloneMediaClock so that it can take over timing responsibilities.
           standaloneMediaClock.setPositionUs(rendererMediaClock.getPositionUs());
@@ -1340,7 +1341,8 @@ private void setPlayingPeriodHolder(MediaPeriodHolder periodHolder) throws ExoPl
       }
     }
 
-    eventHandler.obtainMessage(MSG_TRACKS_CHANGED, periodHolder.getTrackInfo()).sendToTarget();
+    playingPeriodHolder = periodHolder;
+    eventHandler.obtainMessage(MSG_TRACKS_CHANGED, periodHolder.trackSelectorResult).sendToTarget();
     enableRenderers(rendererWasEnabledFlags, enabledRendererCount);
   }
 
@@ -1350,10 +1352,12 @@ private void enableRenderers(boolean[] rendererWasEnabledFlags, int enabledRende
     enabledRendererCount = 0;
     for (int i = 0; i < renderers.length; i++) {
       Renderer renderer = renderers[i];
-      TrackSelection newSelection = playingPeriodHolder.trackSelections.get(i);
+      TrackSelection newSelection = playingPeriodHolder.trackSelectorResult.selections.get(i);
       if (newSelection != null) {
         enabledRenderers[enabledRendererCount++] = renderer;
         if (renderer.getState() == Renderer.STATE_DISABLED) {
+          RendererConfiguration rendererConfiguration =
+              playingPeriodHolder.trackSelectorResult.rendererConfigurations[i];
           // The renderer needs enabling with its new track selection.
           boolean playing = playWhenReady && state == ExoPlayer.STATE_READY;
           // Consider as joining only if the renderer was previously disabled.
@@ -1364,8 +1368,8 @@ private void enableRenderers(boolean[] rendererWasEnabledFlags, int enabledRende
             formats[j] = newSelection.getFormat(j);
           }
           // Enable the renderer.
-          renderer.enable(formats, playingPeriodHolder.sampleStreams[i], rendererPositionUs,
-              joining, playingPeriodHolder.getRendererOffset());
+          renderer.enable(rendererConfiguration, formats, playingPeriodHolder.sampleStreams[i],
+              rendererPositionUs, joining, playingPeriodHolder.getRendererOffset());
           MediaClock mediaClock = renderer.getMediaClock();
           if (mediaClock != null) {
             if (rendererMediaClock != null) {
@@ -1402,6 +1406,7 @@ private void enableRenderers(boolean[] rendererWasEnabledFlags, int enabledRende
     public boolean hasEnabledTracks;
     public MediaPeriodHolder next;
     public boolean needsContinueLoading;
+    public TrackSelectorResult trackSelectorResult;
 
     private final Renderer[] renderers;
     private final RendererCapabilities[] rendererCapabilities;
@@ -1409,10 +1414,7 @@ private void enableRenderers(boolean[] rendererWasEnabledFlags, int enabledRende
     private final LoadControl loadControl;
     private final MediaSource mediaSource;
 
-    private Object trackSelectionsInfo;
-    private TrackGroupArray trackGroups;
-    private TrackSelectionArray trackSelections;
-    private TrackSelectionArray periodTrackSelections;
+    private TrackSelectorResult periodTrackSelectorResult;
 
     public MediaPeriodHolder(Renderer[] renderers, RendererCapabilities[] rendererCapabilities,
         long rendererPositionOffsetUs, TrackSelector trackSelector, LoadControl loadControl,
@@ -1458,20 +1460,17 @@ public boolean isFullyBuffered() {
 
     public void handlePrepared() throws ExoPlaybackException {
       prepared = true;
-      trackGroups = mediaPeriod.getTrackGroups();
       selectTracks();
       startPositionUs = updatePeriodTrackSelection(startPositionUs, false);
     }
 
     public boolean selectTracks() throws ExoPlaybackException {
-      Pair<TrackSelectionArray, Object> selectorResult = trackSelector.selectTracks(
-          rendererCapabilities, trackGroups);
-      TrackSelectionArray newTrackSelections = selectorResult.first;
-      if (newTrackSelections.equals(periodTrackSelections)) {
+      TrackSelectorResult selectorResult = trackSelector.selectTracks(rendererCapabilities,
+          mediaPeriod.getTrackGroups());
+      if (selectorResult.isEquivalent(periodTrackSelectorResult)) {
         return false;
       }
-      trackSelections = newTrackSelections;
-      trackSelectionsInfo = selectorResult.second;
+      trackSelectorResult = selectorResult;
       return true;
     }
 
@@ -1482,16 +1481,16 @@ public long updatePeriodTrackSelection(long positionUs, boolean forceRecreateStr
 
     public long updatePeriodTrackSelection(long positionUs, boolean forceRecreateStreams,
         boolean[] streamResetFlags) {
+      TrackSelectionArray trackSelections = trackSelectorResult.selections;
       for (int i = 0; i < trackSelections.length; i++) {
         mayRetainStreamFlags[i] = !forceRecreateStreams
-            && Util.areEqual(periodTrackSelections == null ? null : periodTrackSelections.get(i),
-            trackSelections.get(i));
+            && trackSelectorResult.isEquivalent(periodTrackSelectorResult, i);
       }
 
       // Disable streams on the period and get new streams for updated/newly-enabled tracks.
       positionUs = mediaPeriod.selectTracks(trackSelections.getAll(), mayRetainStreamFlags,
           sampleStreams, streamResetFlags, positionUs);
-      periodTrackSelections = trackSelections;
+      periodTrackSelectorResult = trackSelectorResult;
 
       // Update whether we have enabled tracks and sanity check the expected streams are non-null.
       hasEnabledTracks = false;
@@ -1505,14 +1504,10 @@ public long updatePeriodTrackSelection(long positionUs, boolean forceRecreateStr
       }
 
       // The track selection has changed.
-      loadControl.onTracksSelected(renderers, trackGroups, trackSelections);
+      loadControl.onTracksSelected(renderers, trackSelectorResult.groups, trackSelections);
       return positionUs;
     }
 
-    public TrackInfo getTrackInfo() {
-      return new TrackInfo(trackGroups, trackSelections, trackSelectionsInfo);
-    }
-
     public void release() {
       try {
         mediaSource.releasePeriod(mediaPeriod);
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
index ea522ac4c8..5100acbbd8 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
@@ -23,7 +23,7 @@
   /**
    * The version of the library, expressed as a string.
    */
-  String VERSION = "2.1.1";
+  String VERSION = "2.2.0";
 
   /**
    * The version of the library, expressed as an integer.
@@ -32,7 +32,7 @@
    * corresponding integer version 1002003 (001-002-003), and "123.45.6" has the corresponding
    * integer version 123045006 (123-045-006).
    */
-  int VERSION_INT = 2001001;
+  int VERSION_INT = 2002000;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer2.util.Assertions}
diff --git a/library/src/main/java/com/google/android/exoplayer2/Format.java b/library/src/main/java/com/google/android/exoplayer2/Format.java
index 14efb6a2c7..0b558153fd 100644
--- a/library/src/main/java/com/google/android/exoplayer2/Format.java
+++ b/library/src/main/java/com/google/android/exoplayer2/Format.java
@@ -183,20 +183,18 @@
    */
   public final int accessibilityChannel;
 
-  // Lazily initialized hashcode and framework media format.
-
+  // Lazily initialized hashcode.
   private int hashCode;
-  private MediaFormat frameworkMediaFormat;
 
   // Video.
 
   public static Format createVideoContainerFormat(String id, String containerMimeType,
       String sampleMimeType, String codecs, int bitrate, int width, int height,
-      float frameRate, List<byte[]> initializationData) {
+      float frameRate, List<byte[]> initializationData, @C.SelectionFlags int selectionFlags) {
     return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, NO_VALUE, width,
         height, frameRate, NO_VALUE, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, NO_VALUE, 0, null, NO_VALUE, OFFSET_SAMPLE_RELATIVE, initializationData, null,
-        null);
+        NO_VALUE, NO_VALUE, selectionFlags, null, NO_VALUE, OFFSET_SAMPLE_RELATIVE,
+        initializationData, null, null);
   }
 
   public static Format createVideoSampleFormat(String id, String sampleMimeType, String codecs,
@@ -289,8 +287,8 @@ public static Format createTextSampleFormat(String id, String sampleMimeType, St
   }
 
   public static Format createTextSampleFormat(String id, String sampleMimeType, String codecs,
-      int bitrate, @C.SelectionFlags int selectionFlags, String language,
-      int accessibilityChannel, DrmInitData drmInitData) {
+      int bitrate, @C.SelectionFlags int selectionFlags, String language, int accessibilityChannel,
+      DrmInitData drmInitData) {
     return createTextSampleFormat(id, sampleMimeType, codecs, bitrate, selectionFlags, language,
         accessibilityChannel, drmInitData, OFFSET_SAMPLE_RELATIVE);
   }
@@ -323,11 +321,20 @@ public static Format createImageSampleFormat(String id, String sampleMimeType, S
 
   // Generic.
 
-  public static Format createContainerFormat(String id, String containerMimeType, String codecs,
-      String sampleMimeType, int bitrate) {
+  public static Format createContainerFormat(String id, String containerMimeType,
+      String sampleMimeType, String codecs, int bitrate, @C.SelectionFlags int selectionFlags,
+      String language) {
     return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, NO_VALUE, 0, null, NO_VALUE, OFFSET_SAMPLE_RELATIVE, null, null, null);
+        NO_VALUE, NO_VALUE, selectionFlags, language, NO_VALUE, OFFSET_SAMPLE_RELATIVE, null, null,
+        null);
+  }
+
+  public static Format createSampleFormat(String id, String sampleMimeType,
+      long subsampleOffsetUs) {
+    return new Format(id, null, sampleMimeType, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
+        NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
+        NO_VALUE, 0, null, NO_VALUE, subsampleOffsetUs, null, null, null);
   }
 
   public static Format createSampleFormat(String id, String sampleMimeType, String codecs,
@@ -486,31 +493,28 @@ public int getPixelCount() {
   @SuppressLint("InlinedApi")
   @TargetApi(16)
   public final MediaFormat getFrameworkMediaFormatV16() {
-    if (frameworkMediaFormat == null) {
-      MediaFormat format = new MediaFormat();
-      format.setString(MediaFormat.KEY_MIME, sampleMimeType);
-      maybeSetStringV16(format, MediaFormat.KEY_LANGUAGE, language);
-      maybeSetIntegerV16(format, MediaFormat.KEY_MAX_INPUT_SIZE, maxInputSize);
-      maybeSetIntegerV16(format, MediaFormat.KEY_WIDTH, width);
-      maybeSetIntegerV16(format, MediaFormat.KEY_HEIGHT, height);
-      maybeSetFloatV16(format, MediaFormat.KEY_FRAME_RATE, frameRate);
-      maybeSetIntegerV16(format, "rotation-degrees", rotationDegrees);
-      maybeSetIntegerV16(format, MediaFormat.KEY_CHANNEL_COUNT, channelCount);
-      maybeSetIntegerV16(format, MediaFormat.KEY_SAMPLE_RATE, sampleRate);
-      maybeSetIntegerV16(format, "encoder-delay", encoderDelay);
-      maybeSetIntegerV16(format, "encoder-padding", encoderPadding);
-      for (int i = 0; i < initializationData.size(); i++) {
-        format.setByteBuffer("csd-" + i, ByteBuffer.wrap(initializationData.get(i)));
-      }
-      frameworkMediaFormat = format;
+    MediaFormat format = new MediaFormat();
+    format.setString(MediaFormat.KEY_MIME, sampleMimeType);
+    maybeSetStringV16(format, MediaFormat.KEY_LANGUAGE, language);
+    maybeSetIntegerV16(format, MediaFormat.KEY_MAX_INPUT_SIZE, maxInputSize);
+    maybeSetIntegerV16(format, MediaFormat.KEY_WIDTH, width);
+    maybeSetIntegerV16(format, MediaFormat.KEY_HEIGHT, height);
+    maybeSetFloatV16(format, MediaFormat.KEY_FRAME_RATE, frameRate);
+    maybeSetIntegerV16(format, "rotation-degrees", rotationDegrees);
+    maybeSetIntegerV16(format, MediaFormat.KEY_CHANNEL_COUNT, channelCount);
+    maybeSetIntegerV16(format, MediaFormat.KEY_SAMPLE_RATE, sampleRate);
+    maybeSetIntegerV16(format, "encoder-delay", encoderDelay);
+    maybeSetIntegerV16(format, "encoder-padding", encoderPadding);
+    for (int i = 0; i < initializationData.size(); i++) {
+      format.setByteBuffer("csd-" + i, ByteBuffer.wrap(initializationData.get(i)));
     }
-    return frameworkMediaFormat;
+    return format;
   }
 
   @Override
   public String toString() {
     return "Format(" + id + ", " + containerMimeType + ", " + sampleMimeType + ", " + bitrate + ", "
-        + ", " + language + ", [" + width + ", " + height + ", " + frameRate + "]"
+        + language + ", [" + width + ", " + height + ", " + frameRate + "]"
         + ", [" + channelCount + ", " + sampleRate + "])";
   }
 
@@ -593,6 +597,38 @@ private static void maybeSetFloatV16(MediaFormat format, String key, float value
     }
   }
 
+  // Utility methods
+
+  /**
+   * Returns a prettier {@link String} than {@link #toString()}, intended for logging.
+   */
+  public static String toLogString(Format format) {
+    if (format == null) {
+      return "null";
+    }
+    StringBuilder builder = new StringBuilder();
+    builder.append("id=").append(format.id).append(", mimeType=").append(format.sampleMimeType);
+    if (format.bitrate != Format.NO_VALUE) {
+      builder.append(", bitrate=").append(format.bitrate);
+    }
+    if (format.width != Format.NO_VALUE && format.height != Format.NO_VALUE) {
+      builder.append(", res=").append(format.width).append("x").append(format.height);
+    }
+    if (format.frameRate != Format.NO_VALUE) {
+      builder.append(", fps=").append(format.frameRate);
+    }
+    if (format.channelCount != Format.NO_VALUE) {
+      builder.append(", channels=").append(format.channelCount);
+    }
+    if (format.sampleRate != Format.NO_VALUE) {
+      builder.append(", sample_rate=").append(format.sampleRate);
+    }
+    if (format.language != null) {
+      builder.append(", language=").append(format.language);
+    }
+    return builder.toString();
+  }
+
   // Parcelable implementation.
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/Renderer.java b/library/src/main/java/com/google/android/exoplayer2/Renderer.java
index b610a64bea..e16caec980 100644
--- a/library/src/main/java/com/google/android/exoplayer2/Renderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/Renderer.java
@@ -92,6 +92,7 @@
    * This method may be called when the renderer is in the following states:
    * {@link #STATE_DISABLED}.
    *
+   * @param configuration The renderer configuration.
    * @param formats The enabled formats.
    * @param stream The {@link SampleStream} from which the renderer should consume.
    * @param positionUs The player's current position.
@@ -100,8 +101,8 @@
    *     before they are rendered.
    * @throws ExoPlaybackException If an error occurs.
    */
-  void enable(Format[] formats, SampleStream stream, long positionUs, boolean joining,
-      long offsetUs) throws ExoPlaybackException;
+  void enable(RendererConfiguration configuration, Format[] formats, SampleStream stream,
+      long positionUs, boolean joining, long offsetUs) throws ExoPlaybackException;
 
   /**
    * Starts the renderer, meaning that calls to {@link #render(long, long)} will cause media to be
diff --git a/library/src/main/java/com/google/android/exoplayer2/RendererCapabilities.java b/library/src/main/java/com/google/android/exoplayer2/RendererCapabilities.java
index 4312bff632..151453c12c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/RendererCapabilities.java
+++ b/library/src/main/java/com/google/android/exoplayer2/RendererCapabilities.java
@@ -79,6 +79,20 @@
    */
   int ADAPTIVE_NOT_SUPPORTED = 0b0000;
 
+  /**
+   * A mask to apply to the result of {@link #supportsFormat(Format)} to obtain one of
+   * {@link #TUNNELING_SUPPORTED} and {@link #TUNNELING_NOT_SUPPORTED}.
+   */
+  int TUNNELING_SUPPORT_MASK = 0b10000;
+  /**
+   * The {@link Renderer} supports tunneled output.
+   */
+  int TUNNELING_SUPPORTED = 0b10000;
+  /**
+   * The {@link Renderer} does not support tunneled output.
+   */
+  int TUNNELING_NOT_SUPPORTED = 0b00000;
+
   /**
    * Returns the track type that the {@link Renderer} handles. For example, a video renderer will
    * return {@link C#TRACK_TYPE_VIDEO}, an audio renderer will return {@link C#TRACK_TYPE_AUDIO}, a
@@ -91,7 +105,7 @@
 
   /**
    * Returns the extent to which the {@link Renderer} supports a given format. The returned value is
-   * the bitwise OR of two properties:
+   * the bitwise OR of three properties:
    * <ul>
    * <li>The level of support for the format itself. One of {@link #FORMAT_HANDLED},
    * {@link #FORMAT_EXCEEDS_CAPABILITIES}, {@link #FORMAT_UNSUPPORTED_SUBTYPE} and
@@ -99,9 +113,12 @@
    * <li>The level of support for adapting from the format to another format of the same mime type.
    * One of {@link #ADAPTIVE_SEAMLESS}, {@link #ADAPTIVE_NOT_SEAMLESS} and
    * {@link #ADAPTIVE_NOT_SUPPORTED}.</li>
+   * <li>The level of support for tunneling. One of {@link #TUNNELING_SUPPORTED} and
+   * {@link #TUNNELING_NOT_SUPPORTED}.</li>
    * </ul>
    * The individual properties can be retrieved by performing a bitwise AND with
-   * {@link #FORMAT_SUPPORT_MASK} and {@link #ADAPTIVE_SUPPORT_MASK} respectively.
+   * {@link #FORMAT_SUPPORT_MASK}, {@link #ADAPTIVE_SUPPORT_MASK} and
+   * {@link #TUNNELING_SUPPORT_MASK} respectively.
    *
    * @param format The format.
    * @return The extent to which the renderer is capable of supporting the given format.
diff --git a/library/src/main/java/com/google/android/exoplayer2/RendererConfiguration.java b/library/src/main/java/com/google/android/exoplayer2/RendererConfiguration.java
new file mode 100644
index 0000000000..93bbd1e4b6
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/RendererConfiguration.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+/**
+ * The configuration of a {@link Renderer}.
+ */
+public final class RendererConfiguration {
+
+  /**
+   * The default configuration.
+   */
+  public static final RendererConfiguration DEFAULT =
+      new RendererConfiguration(C.AUDIO_SESSION_ID_UNSET);
+
+  /**
+   * The audio session id to use for tunneling, or {@link C#AUDIO_SESSION_ID_UNSET} if tunneling
+   * should not be enabled.
+   */
+  public final int tunnelingAudioSessionId;
+
+  /**
+   * @param tunnelingAudioSessionId The audio session id to use for tunneling, or
+   *     {@link C#AUDIO_SESSION_ID_UNSET} if tunneling should not be enabled.
+   */
+  public RendererConfiguration(int tunnelingAudioSessionId) {
+    this.tunnelingAudioSessionId = tunnelingAudioSessionId;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    RendererConfiguration other = (RendererConfiguration) obj;
+    return tunnelingAudioSessionId == other.tunnelingAudioSessionId;
+  }
+
+  @Override
+  public int hashCode() {
+    return tunnelingAudioSessionId;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java b/library/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
index 36753309e2..298e528246 100644
--- a/library/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
@@ -29,7 +29,6 @@
 import android.view.TextureView;
 import com.google.android.exoplayer2.audio.AudioCapabilities;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
-import com.google.android.exoplayer2.audio.AudioTrack;
 import com.google.android.exoplayer2.audio.MediaCodecAudioRenderer;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
@@ -37,7 +36,6 @@
 import com.google.android.exoplayer2.mediacodec.MediaCodecSelector;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataRenderer;
-import com.google.android.exoplayer2.metadata.id3.Id3Decoder;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.text.Cue;
@@ -178,7 +176,7 @@ protected SimpleExoPlayer(Context context, TrackSelector trackSelector, LoadCont
 
     // Set initial values.
     audioVolume = 1;
-    audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
+    audioSessionId = C.AUDIO_SESSION_ID_UNSET;
     audioStreamType = C.STREAM_TYPE_DEFAULT;
     videoScalingMode = C.VIDEO_SCALING_MODE_DEFAULT;
 
@@ -393,7 +391,7 @@ public Format getAudioFormat() {
   }
 
   /**
-   * Returns the audio session identifier, or {@code AudioTrack.SESSION_ID_NOT_SET} if not set.
+   * Returns the audio session identifier, or {@link C#AUDIO_SESSION_ID_UNSET} if not set.
    */
   public int getAudioSessionId() {
     return audioSessionId;
@@ -449,15 +447,6 @@ public void setTextOutput(TextRenderer.Output output) {
     textOutput = output;
   }
 
-  /**
-   * @deprecated Use {@link #setMetadataOutput(MetadataRenderer.Output)} instead.
-   * @param output The output.
-   */
-  @Deprecated
-  public void setId3Output(MetadataRenderer.Output output) {
-    setMetadataOutput(output);
-  }
-
   /**
    * Sets a listener to receive metadata events.
    *
@@ -490,8 +479,8 @@ public void prepare(MediaSource mediaSource) {
   }
 
   @Override
-  public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetTimeline) {
-    player.prepare(mediaSource, resetPosition, resetTimeline);
+  public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
+    player.prepare(mediaSource, resetPosition, resetState);
   }
 
   @Override
@@ -557,63 +546,73 @@ public void blockingSendMessages(ExoPlayerMessage... messages) {
   }
 
   @Override
-  public int getCurrentPeriodIndex() {
-    return player.getCurrentPeriodIndex();
+  public int getRendererCount() {
+    return player.getRendererCount();
   }
 
   @Override
-  public int getCurrentWindowIndex() {
-    return player.getCurrentWindowIndex();
+  public int getRendererType(int index) {
+    return player.getRendererType(index);
   }
 
   @Override
-  public long getDuration() {
-    return player.getDuration();
+  public TrackGroupArray getCurrentTrackGroups() {
+    return player.getCurrentTrackGroups();
   }
 
   @Override
-  public long getCurrentPosition() {
-    return player.getCurrentPosition();
+  public TrackSelectionArray getCurrentTrackSelections() {
+    return player.getCurrentTrackSelections();
   }
 
   @Override
-  public long getBufferedPosition() {
-    return player.getBufferedPosition();
+  public Timeline getCurrentTimeline() {
+    return player.getCurrentTimeline();
   }
 
   @Override
-  public int getBufferedPercentage() {
-    return player.getBufferedPercentage();
+  public Object getCurrentManifest() {
+    return player.getCurrentManifest();
   }
 
   @Override
-  public int getRendererCount() {
-    return player.getRendererCount();
+  public int getCurrentPeriodIndex() {
+    return player.getCurrentPeriodIndex();
   }
 
   @Override
-  public int getRendererType(int index) {
-    return player.getRendererType(index);
+  public int getCurrentWindowIndex() {
+    return player.getCurrentWindowIndex();
   }
 
   @Override
-  public TrackGroupArray getCurrentTrackGroups() {
-    return player.getCurrentTrackGroups();
+  public long getDuration() {
+    return player.getDuration();
   }
 
   @Override
-  public TrackSelectionArray getCurrentTrackSelections() {
-    return player.getCurrentTrackSelections();
+  public long getCurrentPosition() {
+    return player.getCurrentPosition();
   }
 
   @Override
-  public Timeline getCurrentTimeline() {
-    return player.getCurrentTimeline();
+  public long getBufferedPosition() {
+    return player.getBufferedPosition();
   }
 
   @Override
-  public Object getCurrentManifest() {
-    return player.getCurrentManifest();
+  public int getBufferedPercentage() {
+    return player.getBufferedPercentage();
+  }
+
+  @Override
+  public boolean isCurrentWindowDynamic() {
+    return player.isCurrentWindowDynamic();
+  }
+
+  @Override
+  public boolean isCurrentWindowSeekable() {
+    return player.isCurrentWindowSeekable();
   }
 
   // Renderer building.
@@ -772,7 +771,7 @@ protected void buildTextRenderers(Context context, Handler mainHandler,
   protected void buildMetadataRenderers(Context context, Handler mainHandler,
       @ExtensionRendererMode int extensionRendererMode, MetadataRenderer.Output output,
       ArrayList<Renderer> out) {
-    out.add(new MetadataRenderer(output, mainHandler.getLooper(), new Id3Decoder()));
+    out.add(new MetadataRenderer(output, mainHandler.getLooper()));
   }
 
   /**
@@ -949,7 +948,7 @@ public void onAudioDisabled(DecoderCounters counters) {
       }
       audioFormat = null;
       audioDecoderCounters = null;
-      audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
+      audioSessionId = C.AUDIO_SESSION_ID_UNSET;
     }
 
     // TextRenderer.Output implementation
diff --git a/library/src/main/java/com/google/android/exoplayer2/audio/AudioTrack.java b/library/src/main/java/com/google/android/exoplayer2/audio/AudioTrack.java
index 8e6cf68dc8..71049c9de8 100644
--- a/library/src/main/java/com/google/android/exoplayer2/audio/AudioTrack.java
+++ b/library/src/main/java/com/google/android/exoplayer2/audio/AudioTrack.java
@@ -17,6 +17,7 @@
 
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
+import android.media.AudioAttributes;
 import android.media.AudioFormat;
 import android.media.AudioTimestamp;
 import android.media.PlaybackParams;
@@ -30,28 +31,32 @@
 import com.google.android.exoplayer2.util.Util;
 import java.lang.reflect.Method;
 import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
 
 /**
  * Plays audio data. The implementation delegates to an {@link android.media.AudioTrack} and handles
  * playback position smoothing, non-blocking writes and reconfiguration.
  * <p>
  * Before starting playback, specify the input format by calling
- * {@link #configure(String, int, int, int, int)}. Next call {@link #initialize(int)}, optionally
- * specifying an audio session.
+ * {@link #configure(String, int, int, int, int)}. Optionally call {@link #setAudioSessionId(int)},
+ * {@link #setStreamType(int)}, {@link #enableTunnelingV21(int)} and {@link #disableTunneling()}
+ * to configure audio playback. These methods may be called after writing data to the track, in
+ * which case it will be reinitialized as required.
  * <p>
  * Call {@link #handleBuffer(ByteBuffer, long)} to write data, and {@link #handleDiscontinuity()}
  * when the data being fed is discontinuous. Call {@link #play()} to start playing the written data.
  * <p>
- * Call {@link #configure(String, int, int, int, int)} whenever the input format changes. If
- * {@link #isInitialized()} returns {@code false} after the call, it is necessary to call
- * {@link #initialize(int)} before writing more data.
+ * Call {@link #configure(String, int, int, int, int)} whenever the input format changes. The track
+ * will be reinitialized on the next call to {@link #handleBuffer(ByteBuffer, long)}.
  * <p>
- * The underlying {@link android.media.AudioTrack} is created by {@link #initialize(int)} and
- * released by {@link #reset()} (and {@link #configure(String, int, int, int, int)} unless the input
- * format is unchanged). It is safe to call {@link #initialize(int)} after calling {@link #reset()}
- * without reconfiguration.
+ * Calling {@link #reset()} releases the underlying {@link android.media.AudioTrack} (and so does
+ * calling {@link #configure(String, int, int, int, int)} unless the format is unchanged). It is
+ * safe to call {@link #handleBuffer(ByteBuffer, long)} after {@link #reset()} without calling
+ * {@link #configure(String, int, int, int, int)}.
  * <p>
- * Call {@link #release()} when the instance is no longer required.
+ * Call {@link #handleEndOfStream()} to play out all data when no more input buffers will be
+ * provided via {@link #handleBuffer(ByteBuffer, long)} until the next {@link #reset}. Call
+ * {@link #release()} when the instance is no longer required.
  */
 public final class AudioTrack {
 
@@ -60,6 +65,19 @@
    */
   public interface Listener {
 
+    /**
+     * Called when the audio track has been initialized with a newly generated audio session id.
+     *
+     * @param audioSessionId The newly generated audio session id.
+     */
+    void onAudioSessionId(int audioSessionId);
+
+    /**
+     * Called when the audio track handles a buffer whose timestamp is discontinuous with the last
+     * buffer handled since it was reset.
+     */
+    void onPositionDiscontinuity();
+
     /**
      * Called when the audio track underruns.
      *
@@ -104,13 +122,15 @@ public InitializationException(int audioTrackState, int sampleRate, int channelC
   public static final class WriteException extends Exception {
 
     /**
-     * An error value returned from {@link android.media.AudioTrack#write(byte[], int, int)}.
+     * The error value returned from {@link android.media.AudioTrack#write(byte[], int, int)} or
+     *     {@link android.media.AudioTrack#write(ByteBuffer, int, int)}.
      */
     public final int errorCode;
 
     /**
-     * @param errorCode An error value returned from
-     *     {@link android.media.AudioTrack#write(byte[], int, int)}.
+     * @param errorCode The error value returned from
+     *     {@link android.media.AudioTrack#write(byte[], int, int)} or
+     *     {@link android.media.AudioTrack#write(ByteBuffer, int, int)}.
      */
     public WriteException(int errorCode) {
       super("AudioTrack write failed: " + errorCode);
@@ -134,20 +154,6 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
 
   }
 
-  /**
-   * Returned in the result of {@link #handleBuffer} if the buffer was discontinuous.
-   */
-  public static final int RESULT_POSITION_DISCONTINUITY = 1;
-  /**
-   * Returned in the result of {@link #handleBuffer} if the buffer can be released.
-   */
-  public static final int RESULT_BUFFER_CONSUMED = 2;
-
-  /**
-   * Represents an unset {@link android.media.AudioTrack} session identifier.
-   */
-  public static final int SESSION_ID_NOT_SET = 0;
-
   /**
    * Returned by {@link #getCurrentPositionUs} when the position is not set.
    */
@@ -210,15 +216,15 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
   /**
    * AudioTrack timestamps are deemed spurious if they are offset from the system clock by more
    * than this amount.
-   *
-   * <p>This is a fail safe that should not be required on correctly functioning devices.
+   * <p>
+   * This is a fail safe that should not be required on correctly functioning devices.
    */
   private static final long MAX_AUDIO_TIMESTAMP_OFFSET_US = 5 * C.MICROS_PER_SECOND;
 
   /**
    * AudioTrack latencies are deemed impossibly large if they are greater than this amount.
-   *
-   * <p>This is a fail safe that should not be required on correctly functioning devices.
+   * <p>
+   * This is a fail safe that should not be required on correctly functioning devices.
    */
   private static final long MAX_LATENCY_US = 5 * C.MICROS_PER_SECOND;
 
@@ -255,7 +261,7 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
   private final AudioTrackUtil audioTrackUtil;
 
   /**
-   * Used to keep the audio session active on pre-V21 builds (see {@link #initialize(int)}).
+   * Used to keep the audio session active on pre-V21 builds (see {@link #initialize()}).
    */
   private android.media.AudioTrack keepSessionIdAudioTrack;
 
@@ -273,6 +279,9 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
   private int bufferSize;
   private long bufferSizeUs;
 
+  private ByteBuffer avSyncHeader;
+  private int bytesUntilNextAvSync;
+
   private int nextPlayheadOffsetIndex;
   private int playheadOffsetCount;
   private long smoothedPlayheadOffsetUs;
@@ -297,6 +306,9 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
   private ByteBuffer resampledBuffer;
   private boolean useResampledBuffer;
 
+  private boolean playing;
+  private int audioSessionId;
+  private boolean tunneling;
   private boolean hasData;
   private long lastFeedElapsedRealtimeMs;
 
@@ -327,6 +339,7 @@ public AudioTrack(AudioCapabilities audioCapabilities, Listener listener) {
     volume = 1.0f;
     startMediaTimeState = START_NOT_SET;
     streamType = C.STREAM_TYPE_DEFAULT;
+    audioSessionId = C.AUDIO_SESSION_ID_UNSET;
   }
 
   /**
@@ -340,14 +353,6 @@ public boolean isPassthroughSupported(String mimeType) {
         && audioCapabilities.supportsEncoding(getEncodingForMimeType(mimeType));
   }
 
-  /**
-   * Returns whether the audio track has been successfully initialized via {@link #initialize} and
-   * not yet {@link #reset}.
-   */
-  public boolean isInitialized() {
-    return audioTrack != null;
-  }
-
   /**
    * Returns the playback position in the stream starting at zero, in microseconds, or
    * {@link #CURRENT_POSITION_NOT_SET} if it is not yet available.
@@ -385,7 +390,7 @@ public long getCurrentPositionUs(boolean sourceEnded) {
         // The AudioTrack has started, but we don't have any samples to compute a smoothed position.
         currentPositionUs = audioTrackUtil.getPlaybackHeadPositionUs() + startMediaTimeUs;
       } else {
-        // getPlayheadPositionUs() only has a granularity of ~20ms, so we base the position off the
+        // getPlayheadPositionUs() only has a granularity of ~20 ms, so we base the position off the
         // system clock (and a smoothed offset between it and the playhead position) so as to
         // prevent jitter in the reported positions.
         currentPositionUs = systemClockUs + smoothedPlayheadOffsetUs + startMediaTimeUs;
@@ -442,7 +447,29 @@ public void configure(String mimeType, int channelCount, int sampleRate,
         throw new IllegalArgumentException("Unsupported channel count: " + channelCount);
     }
 
+    // Workaround for overly strict channel configuration checks on nVidia Shield.
+    if (Util.SDK_INT <= 23 && "foster".equals(Util.DEVICE) && "NVIDIA".equals(Util.MANUFACTURER)) {
+      switch (channelCount) {
+        case 7:
+          channelConfig = C.CHANNEL_OUT_7POINT1_SURROUND;
+          break;
+        case 3:
+        case 5:
+          channelConfig = AudioFormat.CHANNEL_OUT_5POINT1;
+          break;
+        default:
+          break;
+      }
+    }
+
     boolean passthrough = !MimeTypes.AUDIO_RAW.equals(mimeType);
+
+    // Workaround for Nexus Player not reporting support for mono passthrough.
+    // (See [Internal: b/34268671].)
+    if (Util.SDK_INT <= 25 && "fugu".equals(Util.DEVICE) && passthrough && channelCount == 1) {
+      channelConfig = AudioFormat.CHANNEL_OUT_STEREO;
+    }
+
     @C.Encoding int sourceEncoding;
     if (passthrough) {
       sourceEncoding = getEncodingForMimeType(mimeType);
@@ -495,14 +522,7 @@ public void configure(String mimeType, int channelCount, int sampleRate,
     bufferSizeUs = passthrough ? C.TIME_UNSET : framesToDurationUs(pcmBytesToFrames(bufferSize));
   }
 
-  /**
-   * Initializes the audio track for writing new buffers using {@link #handleBuffer}.
-   *
-   * @param sessionId Audio track session identifier to re-use, or {@link #SESSION_ID_NOT_SET} to
-   *     create a new one.
-   * @return The new (or re-used) session identifier.
-   */
-  public int initialize(int sessionId) throws InitializationException {
+  private void initialize() throws InitializationException {
     // If we're asynchronously releasing a previous audio track then we block until it has been
     // released. This guarantees that we cannot end up in a state where we have multiple audio
     // track instances. Without this guarantee it would be possible, in extreme cases, to exhaust
@@ -510,23 +530,26 @@ public int initialize(int sessionId) throws InitializationException {
     // initialization of the audio track to fail.
     releasingConditionVariable.block();
 
-    if (sessionId == SESSION_ID_NOT_SET) {
+    if (tunneling) {
+      audioTrack = createHwAvSyncAudioTrackV21(sampleRate, channelConfig, targetEncoding,
+          bufferSize, audioSessionId);
+    } else if (audioSessionId == C.AUDIO_SESSION_ID_UNSET) {
       audioTrack = new android.media.AudioTrack(streamType, sampleRate, channelConfig,
           targetEncoding, bufferSize, MODE_STREAM);
     } else {
       // Re-attach to the same audio session.
       audioTrack = new android.media.AudioTrack(streamType, sampleRate, channelConfig,
-          targetEncoding, bufferSize, MODE_STREAM, sessionId);
+          targetEncoding, bufferSize, MODE_STREAM, audioSessionId);
     }
     checkAudioTrackInitialized();
 
-    sessionId = audioTrack.getAudioSessionId();
+    int audioSessionId = audioTrack.getAudioSessionId();
     if (enablePreV21AudioSessionWorkaround) {
       if (Util.SDK_INT < 21) {
         // The workaround creates an audio track with a two byte buffer on the same session, and
         // does not release it until this object is released, which keeps the session active.
         if (keepSessionIdAudioTrack != null
-            && sessionId != keepSessionIdAudioTrack.getAudioSessionId()) {
+            && audioSessionId != keepSessionIdAudioTrack.getAudioSessionId()) {
           releaseKeepSessionIdAudioTrack();
         }
         if (keepSessionIdAudioTrack == null) {
@@ -535,21 +558,25 @@ public int initialize(int sessionId) throws InitializationException {
           @C.PcmEncoding int encoding = C.ENCODING_PCM_16BIT;
           int bufferSize = 2; // Use a two byte buffer, as it is not actually used for playback.
           keepSessionIdAudioTrack = new android.media.AudioTrack(streamType, sampleRate,
-              channelConfig, encoding, bufferSize, MODE_STATIC, sessionId);
+              channelConfig, encoding, bufferSize, MODE_STATIC, audioSessionId);
         }
       }
     }
+    if (this.audioSessionId != audioSessionId) {
+      this.audioSessionId = audioSessionId;
+      listener.onAudioSessionId(audioSessionId);
+    }
 
     audioTrackUtil.reconfigure(audioTrack, needsPassthroughWorkarounds());
-    setAudioTrackVolume();
+    setVolumeInternal();
     hasData = false;
-    return sessionId;
   }
 
   /**
    * Starts or resumes playing audio if the audio track has been initialized.
    */
   public void play() {
+    playing = true;
     if (isInitialized()) {
       resumeSystemTimeUs = System.nanoTime() / 1000;
       audioTrack.play();
@@ -570,35 +597,42 @@ public void handleDiscontinuity() {
    * Attempts to write data from a {@link ByteBuffer} to the audio track, starting from its current
    * position and ending at its limit (exclusive). The position of the {@link ByteBuffer} is
    * advanced by the number of bytes that were successfully written.
+   * {@link Listener#onPositionDiscontinuity()} will be called if {@code presentationTimeUs} is
+   * discontinuous with the last buffer handled since the track was reset.
    * <p>
-   * Returns a bit field containing {@link #RESULT_BUFFER_CONSUMED} if the data was written in full,
-   * and {@link #RESULT_POSITION_DISCONTINUITY} if the buffer was discontinuous with previously
-   * written data.
-   * <p>
-   * If the data was not written in full then the same {@link ByteBuffer} must be provided to
-   * subsequent calls until it has been fully consumed, except in the case of an interleaving call
-   * to {@link #configure} or {@link #reset}.
+   * Returns whether the data was written in full. If the data was not written in full then the same
+   * {@link ByteBuffer} must be provided to subsequent calls until it has been fully consumed,
+   * except in the case of an interleaving call to {@link #reset()} (or an interleaving call to
+   * {@link #configure(String, int, int, int, int)} that caused the track to be reset).
    *
    * @param buffer The buffer containing audio data to play back.
    * @param presentationTimeUs Presentation timestamp of the next buffer in microseconds.
-   * @return A bit field with {@link #RESULT_BUFFER_CONSUMED} if the buffer can be released, and
-   *     {@link #RESULT_POSITION_DISCONTINUITY} if the buffer was not contiguous with previously
-   *     written data.
+   * @return Whether the buffer was consumed fully.
+   * @throws InitializationException If an error occurs initializing the track.
    * @throws WriteException If an error occurs writing the audio data.
    */
-  public int handleBuffer(ByteBuffer buffer, long presentationTimeUs) throws WriteException {
+  public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
+      throws InitializationException, WriteException {
+    if (!isInitialized()) {
+      initialize();
+      if (playing) {
+        play();
+      }
+    }
+
     boolean hadData = hasData;
     hasData = hasPendingData();
     if (hadData && !hasData && audioTrack.getPlayState() != PLAYSTATE_STOPPED) {
       long elapsedSinceLastFeedMs = SystemClock.elapsedRealtime() - lastFeedElapsedRealtimeMs;
       listener.onUnderrun(bufferSize, C.usToMs(bufferSizeUs), elapsedSinceLastFeedMs);
     }
-    int result = writeBuffer(buffer, presentationTimeUs);
+    boolean result = writeBuffer(buffer, presentationTimeUs);
     lastFeedElapsedRealtimeMs = SystemClock.elapsedRealtime();
     return result;
   }
 
-  private int writeBuffer(ByteBuffer buffer, long presentationTimeUs) throws WriteException {
+  @SuppressWarnings("ReferenceEquality")
+  private boolean writeBuffer(ByteBuffer buffer, long presentationTimeUs) throws WriteException {
     boolean isNewSourceBuffer = currentSourceBuffer == null;
     Assertions.checkState(isNewSourceBuffer || currentSourceBuffer == buffer);
     currentSourceBuffer = buffer;
@@ -607,7 +641,7 @@ private int writeBuffer(ByteBuffer buffer, long presentationTimeUs) throws Write
       // An AC-3 audio track continues to play data written while it is paused. Stop writing so its
       // buffer empties. See [Internal: b/18899620].
       if (audioTrack.getPlayState() == PLAYSTATE_PAUSED) {
-        return 0;
+        return false;
       }
 
       // A new AC-3 audio track's playback position continues to increase from the old track's
@@ -615,18 +649,17 @@ private int writeBuffer(ByteBuffer buffer, long presentationTimeUs) throws Write
       // head position actually returns to zero.
       if (audioTrack.getPlayState() == PLAYSTATE_STOPPED
           && audioTrackUtil.getPlaybackHeadPosition() != 0) {
-        return 0;
+        return false;
       }
     }
 
-    int result = 0;
     if (isNewSourceBuffer) {
       // We're seeing this buffer for the first time.
 
       if (!currentSourceBuffer.hasRemaining()) {
         // The buffer is empty.
         currentSourceBuffer = null;
-        return RESULT_BUFFER_CONSUMED;
+        return true;
       }
 
       useResampledBuffer = targetEncoding != sourceEncoding;
@@ -659,7 +692,7 @@ private int writeBuffer(ByteBuffer buffer, long presentationTimeUs) throws Write
           // number of bytes submitted.
           startMediaTimeUs += (presentationTimeUs - expectedPresentationTimeUs);
           startMediaTimeState = START_IN_SYNC;
-          result |= RESULT_POSITION_DISCONTINUITY;
+          listener.onPositionDiscontinuity();
         }
       }
       if (Util.SDK_INT < 21) {
@@ -692,7 +725,9 @@ private int writeBuffer(ByteBuffer buffer, long presentationTimeUs) throws Write
         buffer.position(buffer.position() + bytesWritten);
       }
     } else {
-      bytesWritten = writeNonBlockingV21(audioTrack, buffer, bytesRemaining);
+      bytesWritten = tunneling
+          ? writeNonBlockingWithAvSyncV21(audioTrack, buffer, bytesRemaining, presentationTimeUs)
+          : writeNonBlockingV21(audioTrack, buffer, bytesRemaining);
     }
 
     if (bytesWritten < 0) {
@@ -707,9 +742,9 @@ private int writeBuffer(ByteBuffer buffer, long presentationTimeUs) throws Write
         submittedEncodedFrames += framesPerEncodedSample;
       }
       currentSourceBuffer = null;
-      result |= RESULT_BUFFER_CONSUMED;
+      return true;
     }
-    return result;
+    return false;
   }
 
   /**
@@ -718,6 +753,7 @@ private int writeBuffer(ByteBuffer buffer, long presentationTimeUs) throws Write
   public void handleEndOfStream() {
     if (isInitialized()) {
       audioTrackUtil.handleEndOfStream(getSubmittedFrames());
+      bytesUntilNextAvSync = 0;
     }
   }
 
@@ -743,21 +779,65 @@ public void setPlaybackParams(PlaybackParams playbackParams) {
   }
 
   /**
-   * Sets the stream type for audio track. If the stream type has changed, {@link #isInitialized()}
-   * will return {@code false} and the caller must re-{@link #initialize(int)} the audio track
-   * before writing more data. The caller must not reuse the audio session identifier when
-   * re-initializing with a new stream type.
+   * Sets the stream type for audio track. If the stream type has changed and if the audio track
+   * is not configured for use with tunneling, then the audio track is reset and the audio session
+   * id is cleared.
+   * <p>
+   * If the audio track is configured for use with tunneling then the stream type is ignored, the
+   * audio track is not reset and the audio session id is not cleared. The passed stream type will
+   * be used if the audio track is later re-configured into non-tunneled mode.
    *
    * @param streamType The {@link C.StreamType} to use for audio output.
-   * @return Whether the stream type changed.
    */
-  public boolean setStreamType(@C.StreamType int streamType) {
+  public void setStreamType(@C.StreamType int streamType) {
     if (this.streamType == streamType) {
-      return false;
+      return;
     }
     this.streamType = streamType;
+    if (tunneling) {
+      // The stream type is ignored in tunneling mode, so no need to reset.
+      return;
+    }
     reset();
-    return true;
+    audioSessionId = C.AUDIO_SESSION_ID_UNSET;
+  }
+
+  /**
+   * Sets the audio session id. The audio track is reset if the audio session id has changed.
+   */
+  public void setAudioSessionId(int audioSessionId) {
+    if (this.audioSessionId != audioSessionId) {
+      this.audioSessionId = audioSessionId;
+      reset();
+    }
+  }
+
+  /**
+   * Enables tunneling. The audio track is reset if tunneling was previously disabled or if the
+   * audio session id has changed. Enabling tunneling requires platform API version 21 onwards.
+   *
+   * @param tunnelingAudioSessionId The audio session id to use.
+   * @throws IllegalStateException Thrown if enabling tunneling on platform API version < 21.
+   */
+  public void enableTunnelingV21(int tunnelingAudioSessionId) {
+    Assertions.checkState(Util.SDK_INT >= 21);
+    if (!tunneling || audioSessionId != tunnelingAudioSessionId) {
+      tunneling = true;
+      audioSessionId = tunnelingAudioSessionId;
+      reset();
+    }
+  }
+
+  /**
+   * Disables tunneling. If tunneling was previously enabled then the audio track is reset and the
+   * audio session id is cleared.
+   */
+  public void disableTunneling() {
+    if (tunneling) {
+      tunneling = false;
+      audioSessionId = C.AUDIO_SESSION_ID_UNSET;
+      reset();
+    }
   }
 
   /**
@@ -768,17 +848,17 @@ public boolean setStreamType(@C.StreamType int streamType) {
   public void setVolume(float volume) {
     if (this.volume != volume) {
       this.volume = volume;
-      setAudioTrackVolume();
+      setVolumeInternal();
     }
   }
 
-  private void setAudioTrackVolume() {
+  private void setVolumeInternal() {
     if (!isInitialized()) {
       // Do nothing.
     } else if (Util.SDK_INT >= 21) {
-      setAudioTrackVolumeV21(audioTrack, volume);
+      setVolumeInternalV21(audioTrack, volume);
     } else {
-      setAudioTrackVolumeV3(audioTrack, volume);
+      setVolumeInternalV3(audioTrack, volume);
     }
   }
 
@@ -786,6 +866,7 @@ private void setAudioTrackVolume() {
    * Pauses playback.
    */
   public void pause() {
+    playing = false;
     if (isInitialized()) {
       resetSyncParams();
       audioTrackUtil.pause();
@@ -795,9 +876,9 @@ public void pause() {
   /**
    * Releases the underlying audio track asynchronously.
    * <p>
-   * Calling {@link #initialize(int)} will block until the audio track has been released, so it is
-   * safe to initialize immediately after a reset. The audio session may remain active until
-   * {@link #release()} is called.
+   * Calling {@link #handleBuffer(ByteBuffer, long)} will block until the audio track has been
+   * released, so it is safe to use the audio track immediately after a reset. The audio session may
+   * remain active until {@link #release()} is called.
    */
   public void reset() {
     if (isInitialized()) {
@@ -805,6 +886,8 @@ public void reset() {
       submittedEncodedFrames = 0;
       framesPerEncodedSample = 0;
       currentSourceBuffer = null;
+      avSyncHeader = null;
+      bytesUntilNextAvSync = 0;
       startMediaTimeState = START_NOT_SET;
       latencyUs = 0;
       resetSyncParams();
@@ -837,6 +920,8 @@ public void run() {
   public void release() {
     reset();
     releaseKeepSessionIdAudioTrack();
+    audioSessionId = C.AUDIO_SESSION_ID_UNSET;
+    playing = false;
   }
 
   /**
@@ -974,6 +1059,10 @@ private void checkAudioTrackInitialized() throws InitializationException {
     throw new InitializationException(state, sampleRate, channelConfig, bufferSize);
   }
 
+  private boolean isInitialized() {
+    return audioTrack != null;
+  }
+
   private long pcmBytesToFrames(long byteCount) {
     return byteCount / pcmFrameSize;
   }
@@ -1020,6 +1109,26 @@ private boolean overrideHasPendingData() {
         && audioTrack.getPlaybackHeadPosition() == 0;
   }
 
+  /**
+   * Instantiates an {@link android.media.AudioTrack} to be used with tunneling video playback.
+   */
+  @TargetApi(21)
+  private static android.media.AudioTrack createHwAvSyncAudioTrackV21(int sampleRate,
+      int channelConfig, int encoding, int bufferSize, int sessionId) {
+    AudioAttributes attributesBuilder = new AudioAttributes.Builder()
+        .setUsage(AudioAttributes.USAGE_MEDIA)
+        .setContentType(AudioAttributes.CONTENT_TYPE_MOVIE)
+        .setFlags(AudioAttributes.FLAG_HW_AV_SYNC)
+        .build();
+    AudioFormat format = new AudioFormat.Builder()
+        .setChannelMask(channelConfig)
+        .setEncoding(encoding)
+        .setSampleRate(sampleRate)
+        .build();
+    return new android.media.AudioTrack(attributesBuilder, format, bufferSize, MODE_STREAM,
+        sessionId);
+  }
+
   /**
    * Converts the provided buffer into 16-bit PCM.
    *
@@ -1125,18 +1234,57 @@ private static int getFramesPerEncodedSample(@C.Encoding int encoding, ByteBuffe
   }
 
   @TargetApi(21)
-  private static int writeNonBlockingV21(
-      android.media.AudioTrack audioTrack, ByteBuffer buffer, int size) {
+  private static int writeNonBlockingV21(android.media.AudioTrack audioTrack, ByteBuffer buffer,
+      int size) {
     return audioTrack.write(buffer, size, WRITE_NON_BLOCKING);
   }
 
   @TargetApi(21)
-  private static void setAudioTrackVolumeV21(android.media.AudioTrack audioTrack, float volume) {
+  private int writeNonBlockingWithAvSyncV21(android.media.AudioTrack audioTrack,
+      ByteBuffer buffer, int size, long presentationTimeUs) {
+    // TODO: Uncomment this when [Internal ref b/33627517] is clarified or fixed.
+    // if (Util.SDK_INT >= 23) {
+    //   // The underlying platform AudioTrack writes AV sync headers directly.
+    //   return audioTrack.write(buffer, size, WRITE_NON_BLOCKING, presentationTimeUs * 1000);
+    // }
+    if (avSyncHeader == null) {
+      avSyncHeader = ByteBuffer.allocate(16);
+      avSyncHeader.order(ByteOrder.BIG_ENDIAN);
+      avSyncHeader.putInt(0x55550001);
+    }
+    if (bytesUntilNextAvSync == 0) {
+      avSyncHeader.putInt(4, size);
+      avSyncHeader.putLong(8, presentationTimeUs * 1000);
+      avSyncHeader.position(0);
+      bytesUntilNextAvSync = size;
+    }
+    int avSyncHeaderBytesRemaining = avSyncHeader.remaining();
+    if (avSyncHeaderBytesRemaining > 0) {
+      int result = audioTrack.write(avSyncHeader, avSyncHeaderBytesRemaining, WRITE_NON_BLOCKING);
+      if (result < 0) {
+        bytesUntilNextAvSync = 0;
+        return result;
+      }
+      if (result < avSyncHeaderBytesRemaining) {
+        return 0;
+      }
+    }
+    int result = writeNonBlockingV21(audioTrack, buffer, size);
+    if (result < 0) {
+      bytesUntilNextAvSync = 0;
+      return result;
+    }
+    bytesUntilNextAvSync -= result;
+    return result;
+  }
+
+  @TargetApi(21)
+  private static void setVolumeInternalV21(android.media.AudioTrack audioTrack, float volume) {
     audioTrack.setVolume(volume);
   }
 
   @SuppressWarnings("deprecation")
-  private static void setAudioTrackVolumeV3(android.media.AudioTrack audioTrack, float volume) {
+  private static void setVolumeInternalV3(android.media.AudioTrack audioTrack, float volume) {
     audioTrack.setStereoVolume(volume, volume);
   }
 
@@ -1385,7 +1533,7 @@ public void setPlaybackParams(PlaybackParams playbackParams) {
       playbackParams = (playbackParams != null ? playbackParams : new PlaybackParams())
           .allowDefaults();
       this.playbackParams = playbackParams;
-      this.playbackSpeed = playbackParams.getSpeed();
+      playbackSpeed = playbackParams.getSpeed();
       maybeApplyPlaybackParams();
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java b/library/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
index 4f78a894b7..2c9ef1cfb5 100644
--- a/library/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
@@ -41,8 +41,7 @@
  * Decodes and renders audio using {@link MediaCodec} and {@link AudioTrack}.
  */
 @TargetApi(16)
-public class MediaCodecAudioRenderer extends MediaCodecRenderer implements MediaClock,
-    AudioTrack.Listener {
+public class MediaCodecAudioRenderer extends MediaCodecRenderer implements MediaClock {
 
   private final EventDispatcher eventDispatcher;
   private final AudioTrack audioTrack;
@@ -50,7 +49,6 @@
   private boolean passthroughEnabled;
   private android.media.MediaFormat passthroughMediaFormat;
   private int pcmEncoding;
-  private int audioSessionId;
   private long currentPositionUs;
   private boolean allowPositionDiscontinuity;
 
@@ -129,8 +127,7 @@ public MediaCodecAudioRenderer(MediaCodecSelector mediaCodecSelector,
       boolean playClearSamplesWithoutKeys, Handler eventHandler,
       AudioRendererEventListener eventListener, AudioCapabilities audioCapabilities) {
     super(C.TRACK_TYPE_AUDIO, mediaCodecSelector, drmSessionManager, playClearSamplesWithoutKeys);
-    audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
-    audioTrack = new AudioTrack(audioCapabilities, this);
+    audioTrack = new AudioTrack(audioCapabilities, new AudioTrackListener());
     eventDispatcher = new EventDispatcher(eventHandler, eventListener);
   }
 
@@ -141,10 +138,11 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector, Format forma
     if (!MimeTypes.isAudio(mimeType)) {
       return FORMAT_UNSUPPORTED_TYPE;
     }
+    int tunnelingSupport = Util.SDK_INT >= 21 ? TUNNELING_SUPPORTED : TUNNELING_NOT_SUPPORTED;
     if (allowPassthrough(mimeType) && mediaCodecSelector.getPassthroughDecoderInfo() != null) {
-      return ADAPTIVE_NOT_SEAMLESS | FORMAT_HANDLED;
+      return ADAPTIVE_NOT_SEAMLESS | tunnelingSupport | FORMAT_HANDLED;
     }
-    MediaCodecInfo decoderInfo = mediaCodecSelector.getDecoderInfo(mimeType, false, false);
+    MediaCodecInfo decoderInfo = mediaCodecSelector.getDecoderInfo(mimeType, false);
     if (decoderInfo == null) {
       return FORMAT_UNSUPPORTED_SUBTYPE;
     }
@@ -158,7 +156,7 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector, Format forma
         || MimeTypes.AUDIO_MPEG_L2.equals(mimeType)
         ||  decoderInfo.isAudioChannelCountSupportedV21(format.channelCount)));
     int formatSupport = decoderCapable ? FORMAT_HANDLED : FORMAT_EXCEEDS_CAPABILITIES;
-    return ADAPTIVE_NOT_SEAMLESS | formatSupport;
+    return ADAPTIVE_NOT_SEAMLESS | tunnelingSupport | formatSupport;
   }
 
   @Override
@@ -188,7 +186,8 @@ protected boolean allowPassthrough(String mimeType) {
   }
 
   @Override
-  protected void configureCodec(MediaCodec codec, Format format, MediaCrypto crypto) {
+  protected void configureCodec(MediaCodecInfo codecInfo, MediaCodec codec, Format format,
+      MediaCrypto crypto) {
     if (passthroughEnabled) {
       // Override the MIME type used to configure the codec if we are using a passthrough decoder.
       passthroughMediaFormat = format.getFrameworkMediaFormatV16();
@@ -234,25 +233,42 @@ protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat)
   }
 
   /**
-   * Called when the audio session id becomes known. Once the id is known it will not change (and
-   * hence this method will not be called again) unless the renderer is disabled and then
-   * subsequently re-enabled.
-   * <p>
-   * The default implementation is a no-op. One reason for overriding this method would be to
-   * instantiate and enable a {@link Virtualizer} in order to spatialize the audio channels. For
-   * this use case, any {@link Virtualizer} instances should be released in {@link #onDisabled()}
-   * (if not before).
+   * Called when the audio session id becomes known. The default implementation is a no-op. One
+   * reason for overriding this method would be to instantiate and enable a {@link Virtualizer} in
+   * order to spatialize the audio channels. For this use case, any {@link Virtualizer} instances
+   * should be released in {@link #onDisabled()} (if not before).
    *
-   * @param audioSessionId The audio session id.
+   * @see AudioTrack.Listener#onAudioSessionId(int)
    */
   protected void onAudioSessionId(int audioSessionId) {
     // Do nothing.
   }
 
+  /**
+   * @see AudioTrack.Listener#onPositionDiscontinuity()
+   */
+  protected void onAudioTrackPositionDiscontinuity() {
+    // Do nothing.
+  }
+
+  /**
+   * @see AudioTrack.Listener#onUnderrun(int, long, long)
+   */
+  protected void onAudioTrackUnderrun(int bufferSize, long bufferSizeMs,
+      long elapsedSinceLastFeedMs) {
+    // Do nothing.
+  }
+
   @Override
   protected void onEnabled(boolean joining) throws ExoPlaybackException {
     super.onEnabled(joining);
     eventDispatcher.enabled(decoderCounters);
+    int tunnelingAudioSessionId = getConfiguration().tunnelingAudioSessionId;
+    if (tunnelingAudioSessionId != C.AUDIO_SESSION_ID_UNSET) {
+      audioTrack.enableTunnelingV21(tunnelingAudioSessionId);
+    } else {
+      audioTrack.disableTunneling();
+    }
   }
 
   @Override
@@ -277,7 +293,6 @@ protected void onStopped() {
 
   @Override
   protected void onDisabled() {
-    audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
     try {
       audioTrack.release();
     } finally {
@@ -328,44 +343,15 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
       return true;
     }
 
-    if (!audioTrack.isInitialized()) {
-      // Initialize the AudioTrack now.
-      try {
-        if (audioSessionId == AudioTrack.SESSION_ID_NOT_SET) {
-          audioSessionId = audioTrack.initialize(AudioTrack.SESSION_ID_NOT_SET);
-          eventDispatcher.audioSessionId(audioSessionId);
-          onAudioSessionId(audioSessionId);
-        } else {
-          audioTrack.initialize(audioSessionId);
-        }
-      } catch (AudioTrack.InitializationException e) {
-        throw ExoPlaybackException.createForRenderer(e, getIndex());
-      }
-      if (getState() == STATE_STARTED) {
-        audioTrack.play();
-      }
-    }
-
-    int handleBufferResult;
     try {
-      handleBufferResult = audioTrack.handleBuffer(buffer, bufferPresentationTimeUs);
-    } catch (AudioTrack.WriteException e) {
+      if (audioTrack.handleBuffer(buffer, bufferPresentationTimeUs)) {
+        codec.releaseOutputBuffer(bufferIndex, false);
+        decoderCounters.renderedOutputBufferCount++;
+        return true;
+      }
+    } catch (AudioTrack.InitializationException | AudioTrack.WriteException e) {
       throw ExoPlaybackException.createForRenderer(e, getIndex());
     }
-
-    // If we are out of sync, allow currentPositionUs to jump backwards.
-    if ((handleBufferResult & AudioTrack.RESULT_POSITION_DISCONTINUITY) != 0) {
-      handleAudioTrackDiscontinuity();
-      allowPositionDiscontinuity = true;
-    }
-
-    // Release the buffer if it was consumed.
-    if ((handleBufferResult & AudioTrack.RESULT_BUFFER_CONSUMED) != 0) {
-      codec.releaseOutputBuffer(bufferIndex, false);
-      decoderCounters.renderedOutputBufferCount++;
-      return true;
-    }
-
     return false;
   }
 
@@ -374,10 +360,6 @@ protected void onOutputStreamEnded() {
     audioTrack.handleEndOfStream();
   }
 
-  protected void handleAudioTrackDiscontinuity() {
-    // Do nothing
-  }
-
   @Override
   public void handleMessage(int messageType, Object message) throws ExoPlaybackException {
     switch (messageType) {
@@ -389,9 +371,7 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
         break;
       case C.MSG_SET_STREAM_TYPE:
         @C.StreamType int streamType = (Integer) message;
-        if (audioTrack.setStreamType(streamType)) {
-          audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
-        }
+        audioTrack.setStreamType(streamType);
         break;
       default:
         super.handleMessage(messageType, message);
@@ -399,11 +379,27 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
     }
   }
 
-  // AudioTrack.Listener implementation.
+  private final class AudioTrackListener implements AudioTrack.Listener {
+
+    @Override
+    public void onAudioSessionId(int audioSessionId) {
+      eventDispatcher.audioSessionId(audioSessionId);
+      MediaCodecAudioRenderer.this.onAudioSessionId(audioSessionId);
+    }
+
+    @Override
+    public void onPositionDiscontinuity() {
+      onAudioTrackPositionDiscontinuity();
+      // We are out of sync so allow currentPositionUs to jump backwards.
+      MediaCodecAudioRenderer.this.allowPositionDiscontinuity = true;
+    }
+
+    @Override
+    public void onUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {
+      eventDispatcher.audioTrackUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
+      onAudioTrackUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
+    }
 
-  @Override
-  public void onUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {
-    eventDispatcher.audioTrackUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java b/library/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
index 572f7b54c1..d23ee769dd 100644
--- a/library/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.audio;
 
 import android.media.PlaybackParams;
+import android.media.audiofx.Virtualizer;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.SystemClock;
@@ -43,8 +44,7 @@
 /**
  * Decodes and renders audio using a {@link SimpleDecoder}.
  */
-public abstract class SimpleDecoderAudioRenderer extends BaseRenderer implements MediaClock,
-    AudioTrack.Listener {
+public abstract class SimpleDecoderAudioRenderer extends BaseRenderer implements MediaClock {
 
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({REINITIALIZATION_STATE_NONE, REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM,
@@ -94,8 +94,6 @@
   private boolean outputStreamEnded;
   private boolean waitingForKeys;
 
-  private int audioSessionId;
-
   public SimpleDecoderAudioRenderer() {
     this(null, null);
   }
@@ -141,11 +139,10 @@ public SimpleDecoderAudioRenderer(Handler eventHandler,
       DrmSessionManager<ExoMediaCrypto> drmSessionManager, boolean playClearSamplesWithoutKeys) {
     super(C.TRACK_TYPE_AUDIO);
     eventDispatcher = new EventDispatcher(eventHandler, eventListener);
-    audioTrack = new AudioTrack(audioCapabilities, this);
+    audioTrack = new AudioTrack(audioCapabilities, new AudioTrackListener());
     this.drmSessionManager = drmSessionManager;
     formatHolder = new FormatHolder();
     this.playClearSamplesWithoutKeys = playClearSamplesWithoutKeys;
-    audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
     decoderReinitializationState = REINITIALIZATION_STATE_NONE;
     audioTrackNeedsConfigure = true;
   }
@@ -155,6 +152,25 @@ public MediaClock getMediaClock() {
     return this;
   }
 
+  @Override
+  public final int supportsFormat(Format format) {
+    int formatSupport = supportsFormatInternal(format);
+    if (formatSupport == FORMAT_UNSUPPORTED_TYPE || formatSupport == FORMAT_UNSUPPORTED_SUBTYPE) {
+      return formatSupport;
+    }
+    int tunnelingSupport = Util.SDK_INT >= 21 ? TUNNELING_SUPPORTED : TUNNELING_NOT_SUPPORTED;
+    return ADAPTIVE_NOT_SEAMLESS | tunnelingSupport | formatSupport;
+  }
+
+  /**
+   * Returns the {@link #FORMAT_SUPPORT_MASK} component of the return value for
+   * {@link #supportsFormat(Format)}.
+   *
+   * @param format The format.
+   * @return The extent to which the renderer supports the format itself.
+   */
+  protected abstract int supportsFormatInternal(Format format);
+
   @Override
   public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
     if (outputStreamEnded) {
@@ -185,6 +201,33 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
     }
   }
 
+  /**
+   * Called when the audio session id becomes known. The default implementation is a no-op. One
+   * reason for overriding this method would be to instantiate and enable a {@link Virtualizer} in
+   * order to spatialize the audio channels. For this use case, any {@link Virtualizer} instances
+   * should be released in {@link #onDisabled()} (if not before).
+   *
+   * @see AudioTrack.Listener#onAudioSessionId(int)
+   */
+  protected void onAudioSessionId(int audioSessionId) {
+    // Do nothing.
+  }
+
+  /**
+   * @see AudioTrack.Listener#onPositionDiscontinuity()
+   */
+  protected void onAudioTrackPositionDiscontinuity() {
+    // Do nothing.
+  }
+
+  /**
+   * @see AudioTrack.Listener#onUnderrun(int, long, long)
+   */
+  protected void onAudioTrackUnderrun(int bufferSize, long bufferSizeMs,
+      long elapsedSinceLastFeedMs) {
+    // Do nothing.
+  }
+
   /**
    * Creates a decoder for the given format.
    *
@@ -244,28 +287,7 @@ private boolean drainOutputBuffer() throws ExoPlaybackException, AudioDecoderExc
       audioTrackNeedsConfigure = false;
     }
 
-    if (!audioTrack.isInitialized()) {
-      if (audioSessionId == AudioTrack.SESSION_ID_NOT_SET) {
-        audioSessionId = audioTrack.initialize(AudioTrack.SESSION_ID_NOT_SET);
-        eventDispatcher.audioSessionId(audioSessionId);
-        onAudioSessionId(audioSessionId);
-      } else {
-        audioTrack.initialize(audioSessionId);
-      }
-      if (getState() == STATE_STARTED) {
-        audioTrack.play();
-      }
-    }
-
-    int handleBufferResult = audioTrack.handleBuffer(outputBuffer.data, outputBuffer.timeUs);
-
-    // If we are out of sync, allow currentPositionUs to jump backwards.
-    if ((handleBufferResult & AudioTrack.RESULT_POSITION_DISCONTINUITY) != 0) {
-      allowPositionDiscontinuity = true;
-    }
-
-    // Release the buffer if it was consumed.
-    if ((handleBufferResult & AudioTrack.RESULT_BUFFER_CONSUMED) != 0) {
+    if (audioTrack.handleBuffer(outputBuffer.data, outputBuffer.timeUs)) {
       decoderCounters.renderedOutputBufferCount++;
       outputBuffer.release();
       outputBuffer = null;
@@ -381,23 +403,16 @@ public long getPositionUs() {
     return currentPositionUs;
   }
 
-  /**
-   * Called when the audio session id becomes known. Once the id is known it will not change (and
-   * hence this method will not be called again) unless the renderer is disabled and then
-   * subsequently re-enabled.
-   * <p>
-   * The default implementation is a no-op.
-   *
-   * @param audioSessionId The audio session id.
-   */
-  protected void onAudioSessionId(int audioSessionId) {
-    // Do nothing.
-  }
-
   @Override
   protected void onEnabled(boolean joining) throws ExoPlaybackException {
     decoderCounters = new DecoderCounters();
     eventDispatcher.enabled(decoderCounters);
+    int tunnelingAudioSessionId = getConfiguration().tunnelingAudioSessionId;
+    if (tunnelingAudioSessionId != C.AUDIO_SESSION_ID_UNSET) {
+      audioTrack.enableTunnelingV21(tunnelingAudioSessionId);
+    } else {
+      audioTrack.disableTunneling();
+    }
   }
 
   @Override
@@ -425,7 +440,6 @@ protected void onStopped() {
   @Override
   protected void onDisabled() {
     inputFormat = null;
-    audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
     audioTrackNeedsConfigure = true;
     waitingForKeys = false;
     try {
@@ -537,6 +551,7 @@ private void onInputFormatChanged(Format newFormat) throws ExoPlaybackException
       // There aren't any final output buffers, so release the decoder immediately.
       releaseDecoder();
       maybeInitDecoder();
+      audioTrackNeedsConfigure = true;
     }
 
     eventDispatcher.inputFormatChanged(newFormat);
@@ -553,9 +568,7 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
         break;
       case C.MSG_SET_STREAM_TYPE:
         @C.StreamType int streamType = (Integer) message;
-        if (audioTrack.setStreamType(streamType)) {
-          audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
-        }
+        audioTrack.setStreamType(streamType);
         break;
       default:
         super.handleMessage(messageType, message);
@@ -563,11 +576,27 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
     }
   }
 
-  // AudioTrack.Listener implementation.
+  private final class AudioTrackListener implements AudioTrack.Listener {
+
+    @Override
+    public void onAudioSessionId(int audioSessionId) {
+      eventDispatcher.audioSessionId(audioSessionId);
+      SimpleDecoderAudioRenderer.this.onAudioSessionId(audioSessionId);
+    }
+
+    @Override
+    public void onPositionDiscontinuity() {
+      onAudioTrackPositionDiscontinuity();
+      // We are out of sync so allow currentPositionUs to jump backwards.
+      SimpleDecoderAudioRenderer.this.allowPositionDiscontinuity = true;
+    }
+
+    @Override
+    public void onUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {
+      eventDispatcher.audioTrackUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
+      onAudioTrackUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
+    }
 
-  @Override
-  public void onUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {
-    eventDispatcher.audioTrackUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/drm/StreamingDrmSessionManager.java b/library/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
similarity index 63%
rename from library/src/main/java/com/google/android/exoplayer2/drm/StreamingDrmSessionManager.java
rename to library/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
index 4e4845c70b..1cd8d8464d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/drm/StreamingDrmSessionManager.java
+++ b/library/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
@@ -24,7 +24,10 @@
 import android.os.HandlerThread;
 import android.os.Looper;
 import android.os.Message;
+import android.support.annotation.IntDef;
 import android.text.TextUtils;
+import android.util.Log;
+import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import com.google.android.exoplayer2.drm.ExoMediaDrm.KeyRequest;
@@ -33,18 +36,21 @@
 import com.google.android.exoplayer2.extractor.mp4.PsshAtomUtil;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.util.HashMap;
+import java.util.Map;
 import java.util.UUID;
 
 /**
- * A {@link DrmSessionManager} that supports streaming playbacks using {@link MediaDrm}.
+ * A {@link DrmSessionManager} that supports playbacks using {@link MediaDrm}.
  */
 @TargetApi(18)
-public class StreamingDrmSessionManager<T extends ExoMediaCrypto> implements DrmSessionManager<T>,
+public class DefaultDrmSessionManager<T extends ExoMediaCrypto> implements DrmSessionManager<T>,
     DrmSession<T> {
 
   /**
-   * Listener of {@link StreamingDrmSessionManager} events.
+   * Listener of {@link DefaultDrmSessionManager} events.
    */
   public interface EventListener {
 
@@ -60,6 +66,16 @@
      */
     void onDrmSessionManagerError(Exception e);
 
+    /**
+     * Called each time offline keys are restored.
+     */
+    void onDrmKeysRestored();
+
+    /**
+     * Called each time offline keys are removed.
+     */
+    void onDrmKeysRemoved();
+
   }
 
   /**
@@ -67,9 +83,32 @@
    */
   public static final String PLAYREADY_CUSTOM_DATA_KEY = "PRCustomData";
 
+  /** Determines the action to be done after a session acquired. */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({MODE_PLAYBACK, MODE_QUERY, MODE_DOWNLOAD, MODE_RELEASE})
+  public @interface Mode {}
+  /**
+   * Loads and refreshes (if necessary) a license for playback. Supports streaming and offline
+   * licenses.
+   */
+  public static final int MODE_PLAYBACK = 0;
+  /**
+   * Restores an offline license to allow its status to be queried. If the offline license is
+   * expired sets state to {@link #STATE_ERROR}.
+   */
+  public static final int MODE_QUERY = 1;
+  /** Downloads an offline license or renews an existing one. */
+  public static final int MODE_DOWNLOAD = 2;
+  /** Releases an existing offline license. */
+  public static final int MODE_RELEASE = 3;
+
+  private static final String TAG = "OfflineDrmSessionMngr";
+
   private static final int MSG_PROVISION = 0;
   private static final int MSG_KEYS = 1;
 
+  private static final int MAX_LICENSE_DURATION_TO_RENEW = 60;
+
   private final Handler eventHandler;
   private final EventListener eventListener;
   private final ExoMediaDrm<T> mediaDrm;
@@ -85,14 +124,17 @@
   private HandlerThread requestHandlerThread;
   private Handler postRequestHandler;
 
+  private int mode;
   private int openCount;
   private boolean provisioningInProgress;
   @DrmSession.State
   private int state;
   private T mediaCrypto;
-  private Exception lastException;
-  private SchemeData schemeData;
+  private DrmSessionException lastException;
+  private byte[] schemeInitData;
+  private String schemeMimeType;
   private byte[] sessionId;
+  private byte[] offlineLicenseKeySetId;
 
   /**
    * Instantiates a new instance using the Widevine scheme.
@@ -105,7 +147,7 @@
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @throws UnsupportedDrmException If the specified DRM scheme is not supported.
    */
-  public static StreamingDrmSessionManager<FrameworkMediaCrypto> newWidevineInstance(
+  public static DefaultDrmSessionManager<FrameworkMediaCrypto> newWidevineInstance(
       MediaDrmCallback callback, HashMap<String, String> optionalKeyRequestParameters,
       Handler eventHandler, EventListener eventListener) throws UnsupportedDrmException {
     return newFrameworkInstance(C.WIDEVINE_UUID, callback, optionalKeyRequestParameters,
@@ -125,7 +167,7 @@
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @throws UnsupportedDrmException If the specified DRM scheme is not supported.
    */
-  public static StreamingDrmSessionManager<FrameworkMediaCrypto> newPlayReadyInstance(
+  public static DefaultDrmSessionManager<FrameworkMediaCrypto> newPlayReadyInstance(
       MediaDrmCallback callback, String customData, Handler eventHandler,
       EventListener eventListener) throws UnsupportedDrmException {
     HashMap<String, String> optionalKeyRequestParameters;
@@ -151,10 +193,10 @@
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @throws UnsupportedDrmException If the specified DRM scheme is not supported.
    */
-  public static StreamingDrmSessionManager<FrameworkMediaCrypto> newFrameworkInstance(
+  public static DefaultDrmSessionManager<FrameworkMediaCrypto> newFrameworkInstance(
       UUID uuid, MediaDrmCallback callback, HashMap<String, String> optionalKeyRequestParameters,
       Handler eventHandler, EventListener eventListener) throws UnsupportedDrmException {
-    return new StreamingDrmSessionManager<>(uuid, FrameworkMediaDrm.newInstance(uuid), callback,
+    return new DefaultDrmSessionManager<>(uuid, FrameworkMediaDrm.newInstance(uuid), callback,
         optionalKeyRequestParameters, eventHandler, eventListener);
   }
 
@@ -168,7 +210,7 @@
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    */
-  public StreamingDrmSessionManager(UUID uuid, ExoMediaDrm<T> mediaDrm, MediaDrmCallback callback,
+  public DefaultDrmSessionManager(UUID uuid, ExoMediaDrm<T> mediaDrm, MediaDrmCallback callback,
       HashMap<String, String> optionalKeyRequestParameters, Handler eventHandler,
       EventListener eventListener) {
     this.uuid = uuid;
@@ -179,6 +221,7 @@ public StreamingDrmSessionManager(UUID uuid, ExoMediaDrm<T> mediaDrm, MediaDrmCa
     this.eventListener = eventListener;
     mediaDrm.setOnEventListener(new MediaDrmEventListener());
     state = STATE_CLOSED;
+    mode = MODE_PLAYBACK;
   }
 
   /**
@@ -229,6 +272,35 @@ public final void setPropertyByteArray(String key, byte[] value) {
     mediaDrm.setPropertyByteArray(key, value);
   }
 
+  /**
+   * Sets the mode, which determines the role of sessions acquired from the instance. This must be
+   * called before {@link #acquireSession(Looper, DrmInitData)} is called.
+   *
+   * <p>By default, the mode is {@link #MODE_PLAYBACK} and a streaming license is requested when
+   * required.
+   *
+   * <p>{@code mode} must be one of these:
+   * <li>{@link #MODE_PLAYBACK}: If {@code offlineLicenseKeySetId} is null, a streaming license is
+   *     requested otherwise the offline license is restored.
+   * <li>{@link #MODE_QUERY}: {@code offlineLicenseKeySetId} can not be null. The offline license
+   *     is restored.
+   * <li>{@link #MODE_DOWNLOAD}: If {@code offlineLicenseKeySetId} is null, an offline license is
+   *     requested otherwise the offline license is renewed.
+   * <li>{@link #MODE_RELEASE}: {@code offlineLicenseKeySetId} can not be null. The offline license
+   *     is released.
+   *
+   * @param mode The mode to be set.
+   * @param offlineLicenseKeySetId The key set id of the license to be used with the given mode.
+   */
+  public void setMode(@Mode int mode, byte[] offlineLicenseKeySetId) {
+    Assertions.checkState(openCount == 0);
+    if (mode == MODE_QUERY || mode == MODE_RELEASE) {
+      Assertions.checkNotNull(offlineLicenseKeySetId);
+    }
+    this.mode = mode;
+    this.offlineLicenseKeySetId = offlineLicenseKeySetId;
+  }
+
   // DrmSessionManager implementation.
 
   @Override
@@ -248,18 +320,22 @@ public final void setPropertyByteArray(String key, byte[] value) {
     requestHandlerThread.start();
     postRequestHandler = new PostRequestHandler(requestHandlerThread.getLooper());
 
-    schemeData = drmInitData.get(uuid);
-    if (schemeData == null) {
-      onError(new IllegalStateException("Media does not support uuid: " + uuid));
-      return this;
-    }
-    if (Util.SDK_INT < 21) {
-      // Prior to L the Widevine CDM required data to be extracted from the PSSH atom.
-      byte[] psshData = PsshAtomUtil.parseSchemeSpecificData(schemeData.data, C.WIDEVINE_UUID);
-      if (psshData == null) {
-        // Extraction failed. schemeData isn't a Widevine PSSH atom, so leave it unchanged.
-      } else {
-        schemeData = new SchemeData(C.WIDEVINE_UUID, schemeData.mimeType, psshData);
+    if (offlineLicenseKeySetId == null) {
+      SchemeData schemeData = drmInitData.get(uuid);
+      if (schemeData == null) {
+        onError(new IllegalStateException("Media does not support uuid: " + uuid));
+        return this;
+      }
+      schemeInitData = schemeData.data;
+      schemeMimeType = schemeData.mimeType;
+      if (Util.SDK_INT < 21) {
+        // Prior to L the Widevine CDM required data to be extracted from the PSSH atom.
+        byte[] psshData = PsshAtomUtil.parseSchemeSpecificData(schemeInitData, C.WIDEVINE_UUID);
+        if (psshData == null) {
+          // Extraction failed. schemeData isn't a Widevine PSSH atom, so leave it unchanged.
+        } else {
+          schemeInitData = psshData;
+        }
       }
     }
     state = STATE_OPENING;
@@ -280,7 +356,8 @@ public void releaseSession(DrmSession<T> session) {
     postRequestHandler = null;
     requestHandlerThread.quit();
     requestHandlerThread = null;
-    schemeData = null;
+    schemeInitData = null;
+    schemeMimeType = null;
     mediaCrypto = null;
     lastException = null;
     if (sessionId != null) {
@@ -314,10 +391,25 @@ public boolean requiresSecureDecoderComponent(String mimeType) {
   }
 
   @Override
-  public final Exception getError() {
+  public final DrmSessionException getError() {
     return state == STATE_ERROR ? lastException : null;
   }
 
+  @Override
+  public Map<String, String> queryKeyStatus() {
+    // User may call this method rightfully even if state == STATE_ERROR. So only check if there is
+    // a sessionId
+    if (sessionId == null) {
+      throw new IllegalStateException();
+    }
+    return mediaDrm.queryKeyStatus(sessionId);
+  }
+
+  @Override
+  public byte[] getOfflineLicenseKeySetId() {
+    return offlineLicenseKeySetId;
+  }
+
   // Internal methods.
 
   private void openInternal(boolean allowProvisioning) {
@@ -325,7 +417,7 @@ private void openInternal(boolean allowProvisioning) {
       sessionId = mediaDrm.openSession();
       mediaCrypto = mediaDrm.createMediaCrypto(uuid, sessionId);
       state = STATE_OPENED;
-      postKeyRequest();
+      doLicense();
     } catch (NotProvisionedException e) {
       if (allowProvisioning) {
         postProvisionRequest();
@@ -363,20 +455,86 @@ private void onProvisionResponse(Object response) {
       if (state == STATE_OPENING) {
         openInternal(false);
       } else {
-        postKeyRequest();
+        doLicense();
       }
     } catch (DeniedByServerException e) {
       onError(e);
     }
   }
 
-  private void postKeyRequest() {
-    KeyRequest keyRequest;
+  private void doLicense() {
+    switch (mode) {
+      case MODE_PLAYBACK:
+      case MODE_QUERY:
+        if (offlineLicenseKeySetId == null) {
+          postKeyRequest(sessionId, MediaDrm.KEY_TYPE_STREAMING);
+        } else {
+          if (restoreKeys()) {
+            long licenseDurationRemainingSec = getLicenseDurationRemainingSec();
+            if (mode == MODE_PLAYBACK
+                && licenseDurationRemainingSec <= MAX_LICENSE_DURATION_TO_RENEW) {
+              Log.d(TAG, "Offline license has expired or will expire soon. "
+                  + "Remaining seconds: " + licenseDurationRemainingSec);
+              postKeyRequest(sessionId, MediaDrm.KEY_TYPE_OFFLINE);
+            } else if (licenseDurationRemainingSec <= 0) {
+              onError(new KeysExpiredException());
+            } else {
+              state = STATE_OPENED_WITH_KEYS;
+              if (eventHandler != null && eventListener != null) {
+                eventHandler.post(new Runnable() {
+                  @Override
+                  public void run() {
+                    eventListener.onDrmKeysRestored();
+                  }
+                });
+              }
+            }
+          }
+        }
+        break;
+      case MODE_DOWNLOAD:
+        if (offlineLicenseKeySetId == null) {
+          postKeyRequest(sessionId, MediaDrm.KEY_TYPE_OFFLINE);
+        } else {
+          // Renew
+          if (restoreKeys()) {
+            postKeyRequest(sessionId, MediaDrm.KEY_TYPE_OFFLINE);
+          }
+        }
+        break;
+      case MODE_RELEASE:
+        if (restoreKeys()) {
+          postKeyRequest(offlineLicenseKeySetId, MediaDrm.KEY_TYPE_RELEASE);
+        }
+        break;
+    }
+  }
+
+  private boolean restoreKeys() {
+    try {
+      mediaDrm.restoreKeys(sessionId, offlineLicenseKeySetId);
+      return true;
+    } catch (Exception e) {
+      Log.e(TAG, "Error trying to restore Widevine keys.", e);
+      onError(e);
+    }
+    return false;
+  }
+
+  private long getLicenseDurationRemainingSec() {
+    if (!C.WIDEVINE_UUID.equals(uuid)) {
+      return Long.MAX_VALUE;
+    }
+    Pair<Long, Long> pair = WidevineUtil.getLicenseDurationRemainingSec(this);
+    return Math.min(pair.first, pair.second);
+  }
+
+  private void postKeyRequest(byte[] scope, int keyType) {
     try {
-      keyRequest = mediaDrm.getKeyRequest(sessionId, schemeData.data, schemeData.mimeType,
-          MediaDrm.KEY_TYPE_STREAMING, optionalKeyRequestParameters);
+      KeyRequest keyRequest = mediaDrm.getKeyRequest(scope, schemeInitData, schemeMimeType, keyType,
+          optionalKeyRequestParameters);
       postRequestHandler.obtainMessage(MSG_KEYS, keyRequest).sendToTarget();
-    } catch (NotProvisionedException e) {
+    } catch (Exception e) {
       onKeysError(e);
     }
   }
@@ -393,15 +551,31 @@ private void onKeyResponse(Object response) {
     }
 
     try {
-      mediaDrm.provideKeyResponse(sessionId, (byte[]) response);
-      state = STATE_OPENED_WITH_KEYS;
-      if (eventHandler != null && eventListener != null) {
-        eventHandler.post(new Runnable() {
-          @Override
-          public void run() {
-            eventListener.onDrmKeysLoaded();
-          }
-        });
+      if (mode == MODE_RELEASE) {
+        mediaDrm.provideKeyResponse(offlineLicenseKeySetId, (byte[]) response);
+        if (eventHandler != null && eventListener != null) {
+          eventHandler.post(new Runnable() {
+            @Override
+            public void run() {
+              eventListener.onDrmKeysRemoved();
+            }
+          });
+        }
+      } else {
+        byte[] keySetId = mediaDrm.provideKeyResponse(sessionId, (byte[]) response);
+        if ((mode == MODE_DOWNLOAD || (mode == MODE_PLAYBACK && offlineLicenseKeySetId != null))
+            && keySetId != null && keySetId.length != 0) {
+          offlineLicenseKeySetId = keySetId;
+        }
+        state = STATE_OPENED_WITH_KEYS;
+        if (eventHandler != null && eventListener != null) {
+          eventHandler.post(new Runnable() {
+            @Override
+            public void run() {
+              eventListener.onDrmKeysLoaded();
+            }
+          });
+        }
       }
     } catch (Exception e) {
       onKeysError(e);
@@ -417,7 +591,7 @@ private void onKeysError(Exception e) {
   }
 
   private void onError(final Exception e) {
-    lastException = e;
+    lastException = new DrmSessionException(e);
     if (eventHandler != null && eventListener != null) {
       eventHandler.post(new Runnable() {
         @Override
@@ -446,11 +620,16 @@ public void handleMessage(Message msg) {
       }
       switch (msg.what) {
         case MediaDrm.EVENT_KEY_REQUIRED:
-          postKeyRequest();
+          doLicense();
           break;
         case MediaDrm.EVENT_KEY_EXPIRED:
-          state = STATE_OPENED;
-          onError(new KeysExpiredException());
+          // When an already expired key is loaded MediaDrm sends this event immediately. Ignore
+          // this event if the state isn't STATE_OPENED_WITH_KEYS yet which means we're still
+          // waiting for key response.
+          if (state == STATE_OPENED_WITH_KEYS) {
+            state = STATE_OPENED;
+            onError(new KeysExpiredException());
+          }
           break;
         case MediaDrm.EVENT_PROVISION_REQUIRED:
           state = STATE_OPENED;
@@ -466,7 +645,9 @@ public void handleMessage(Message msg) {
     @Override
     public void onEvent(ExoMediaDrm<? extends T> md, byte[] sessionId, int event, int extra,
         byte[] data) {
-      mediaDrmHandler.sendEmptyMessage(event);
+      if (mode == MODE_PLAYBACK) {
+        mediaDrmHandler.sendEmptyMessage(event);
+      }
     }
 
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java b/library/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java
index 6f84395072..4d64187a8b 100644
--- a/library/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java
+++ b/library/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java
@@ -16,9 +16,11 @@
 package com.google.android.exoplayer2.drm;
 
 import android.annotation.TargetApi;
+import android.media.MediaDrm;
 import android.support.annotation.IntDef;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.util.Map;
 
 /**
  * A DRM session.
@@ -26,6 +28,15 @@
 @TargetApi(16)
 public interface DrmSession<T extends ExoMediaCrypto> {
 
+  /** Wraps the exception which is the cause of the error state. */
+  class DrmSessionException extends Exception {
+
+    DrmSessionException(Exception e) {
+      super(e);
+    }
+
+  }
+
   /**
    * The state of the DRM session.
    */
@@ -96,6 +107,26 @@
    *
    * @return An exception if the state is {@link #STATE_ERROR}. Null otherwise.
    */
-  Exception getError();
+  DrmSessionException getError();
+
+  /**
+   * Returns an informative description of the key status for the session. The status is in the form
+   * of {name, value} pairs.
+   *
+   * <p>Since DRM license policies vary by vendor, the specific status field names are determined by
+   * each DRM vendor. Refer to your DRM provider documentation for definitions of the field names
+   * for a particular DRM engine plugin.
+   *
+   * @return A map of key status.
+   * @throws IllegalStateException If called when the session isn't opened.
+   * @see MediaDrm#queryKeyStatus(byte[])
+   */
+  Map<String, String> queryKeyStatus();
+
+  /**
+   * Returns the key set id of the offline license loaded into this session, if there is one. Null
+   * otherwise.
+   */
+  byte[] getOfflineLicenseKeySetId();
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/drm/HttpMediaDrmCallback.java b/library/src/main/java/com/google/android/exoplayer2/drm/HttpMediaDrmCallback.java
index 65e41dd91e..e0c9ca5296 100644
--- a/library/src/main/java/com/google/android/exoplayer2/drm/HttpMediaDrmCallback.java
+++ b/library/src/main/java/com/google/android/exoplayer2/drm/HttpMediaDrmCallback.java
@@ -105,7 +105,7 @@ public HttpMediaDrmCallback(String defaultUrl, HttpDataSource.Factory dataSource
     try {
       return Util.toByteArray(inputStream);
     } finally {
-      inputStream.close();
+      Util.closeQuietly(inputStream);
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java b/library/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java
new file mode 100644
index 0000000000..a11d65d4d3
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java
@@ -0,0 +1,315 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.exoplayer2.drm;
+
+import android.media.MediaDrm;
+import android.net.Uri;
+import android.os.ConditionVariable;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.util.Pair;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.drm.DefaultDrmSessionManager.EventListener;
+import com.google.android.exoplayer2.drm.DefaultDrmSessionManager.Mode;
+import com.google.android.exoplayer2.drm.DrmSession.DrmSessionException;
+import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor;
+import com.google.android.exoplayer2.extractor.mp4.FragmentedMp4Extractor;
+import com.google.android.exoplayer2.source.chunk.ChunkExtractorWrapper;
+import com.google.android.exoplayer2.source.chunk.InitializationChunk;
+import com.google.android.exoplayer2.source.dash.manifest.AdaptationSet;
+import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
+import com.google.android.exoplayer2.source.dash.manifest.DashManifestParser;
+import com.google.android.exoplayer2.source.dash.manifest.Period;
+import com.google.android.exoplayer2.source.dash.manifest.RangedUri;
+import com.google.android.exoplayer2.source.dash.manifest.Representation;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSourceInputStream;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.HttpDataSource;
+import com.google.android.exoplayer2.upstream.HttpDataSource.Factory;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.MimeTypes;
+import java.io.IOException;
+import java.util.HashMap;
+
+/**
+ * Helper class to download, renew and release offline licenses. It utilizes {@link
+ * DefaultDrmSessionManager}.
+ */
+public final class OfflineLicenseHelper<T extends ExoMediaCrypto> {
+
+  private final ConditionVariable conditionVariable;
+  private final DefaultDrmSessionManager<T> drmSessionManager;
+  private final HandlerThread handlerThread;
+
+  /**
+   * Helper method to download a DASH manifest.
+   *
+   * @param dataSource The {@link HttpDataSource} from which the manifest should be read.
+   * @param manifestUriString The URI of the manifest to be read.
+   * @return An instance of {@link DashManifest}.
+   * @throws IOException If an error occurs reading data from the stream.
+   * @see DashManifestParser
+   */
+  public static DashManifest downloadManifest(HttpDataSource dataSource, String manifestUriString)
+      throws IOException {
+    DataSourceInputStream inputStream = new DataSourceInputStream(
+        dataSource, new DataSpec(Uri.parse(manifestUriString)));
+    try {
+      inputStream.open();
+      DashManifestParser parser = new DashManifestParser();
+      return parser.parse(dataSource.getUri(), inputStream);
+    } finally {
+      inputStream.close();
+    }
+  }
+
+  /**
+   * Instantiates a new instance which uses Widevine CDM. Call {@link #releaseResources()} when
+   * you're done with the helper instance.
+   *
+   * @param licenseUrl The default license URL.
+   * @param httpDataSourceFactory A factory from which to obtain {@link HttpDataSource} instances.
+   * @return A new instance which uses Widevine CDM.
+   * @throws UnsupportedDrmException If the Widevine DRM scheme is unsupported or cannot be
+   *     instantiated.
+   */
+  public static OfflineLicenseHelper<FrameworkMediaCrypto> newWidevineInstance(
+      String licenseUrl, Factory httpDataSourceFactory) throws UnsupportedDrmException {
+    return newWidevineInstance(
+        new HttpMediaDrmCallback(licenseUrl, httpDataSourceFactory, null), null);
+  }
+
+  /**
+   * Instantiates a new instance which uses Widevine CDM. Call {@link #releaseResources()} when
+   * you're done with the helper instance.
+   *
+   * @param callback Performs key and provisioning requests.
+   * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
+   *     to {@link MediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
+   * @return A new instance which uses Widevine CDM.
+   * @throws UnsupportedDrmException If the Widevine DRM scheme is unsupported or cannot be
+   *     instantiated.
+   * @see DefaultDrmSessionManager#DefaultDrmSessionManager(java.util.UUID, ExoMediaDrm,
+   *     MediaDrmCallback, HashMap, Handler, EventListener)
+   */
+  public static OfflineLicenseHelper<FrameworkMediaCrypto> newWidevineInstance(
+      MediaDrmCallback callback, HashMap<String, String> optionalKeyRequestParameters)
+      throws UnsupportedDrmException {
+    return new OfflineLicenseHelper<>(FrameworkMediaDrm.newInstance(C.WIDEVINE_UUID), callback,
+        optionalKeyRequestParameters);
+  }
+
+  /**
+   * Constructs an instance. Call {@link #releaseResources()} when you're done with it.
+   *
+   * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
+   * @param callback Performs key and provisioning requests.
+   * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
+   *     to {@link MediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
+   * @see DefaultDrmSessionManager#DefaultDrmSessionManager(java.util.UUID, ExoMediaDrm,
+   *     MediaDrmCallback, HashMap, Handler, EventListener)
+   */
+  public OfflineLicenseHelper(ExoMediaDrm<T> mediaDrm, MediaDrmCallback callback,
+      HashMap<String, String> optionalKeyRequestParameters) {
+    handlerThread = new HandlerThread("OfflineLicenseHelper");
+    handlerThread.start();
+
+    conditionVariable = new ConditionVariable();
+    EventListener eventListener = new EventListener() {
+      @Override
+      public void onDrmKeysLoaded() {
+        conditionVariable.open();
+      }
+
+      @Override
+      public void onDrmSessionManagerError(Exception e) {
+        conditionVariable.open();
+      }
+
+      @Override
+      public void onDrmKeysRestored() {
+        conditionVariable.open();
+      }
+
+      @Override
+      public void onDrmKeysRemoved() {
+        conditionVariable.open();
+      }
+    };
+    drmSessionManager = new DefaultDrmSessionManager<>(C.WIDEVINE_UUID, mediaDrm, callback,
+        optionalKeyRequestParameters, new Handler(handlerThread.getLooper()), eventListener);
+  }
+
+  /** Releases the used resources. */
+  public void releaseResources() {
+    handlerThread.quit();
+  }
+
+  /**
+   * Downloads an offline license.
+   *
+   * @param dataSource The {@link HttpDataSource} to be used for download.
+   * @param manifestUriString The URI of the manifest to be read.
+   * @return The downloaded offline license key set id.
+   * @throws IOException If an error occurs reading data from the stream.
+   * @throws InterruptedException If the thread has been interrupted.
+   * @throws DrmSessionException Thrown when there is an error during DRM session.
+   */
+  public byte[] download(HttpDataSource dataSource, String manifestUriString)
+      throws IOException, InterruptedException, DrmSessionException {
+    return download(dataSource, downloadManifest(dataSource, manifestUriString));
+  }
+
+  /**
+   * Downloads an offline license.
+   *
+   * @param dataSource The {@link HttpDataSource} to be used for download.
+   * @param dashManifest The {@link DashManifest} of the DASH content.
+   * @return The downloaded offline license key set id.
+   * @throws IOException If an error occurs reading data from the stream.
+   * @throws InterruptedException If the thread has been interrupted.
+   * @throws DrmSessionException Thrown when there is an error during DRM session.
+   */
+  public byte[] download(HttpDataSource dataSource, DashManifest dashManifest)
+      throws IOException, InterruptedException, DrmSessionException {
+    // Get DrmInitData
+    // Prefer drmInitData obtained from the manifest over drmInitData obtained from the stream,
+    // as per DASH IF Interoperability Recommendations V3.0, 7.5.3.
+    if (dashManifest.getPeriodCount() < 1) {
+      return null;
+    }
+    Period period = dashManifest.getPeriod(0);
+    int adaptationSetIndex = period.getAdaptationSetIndex(C.TRACK_TYPE_VIDEO);
+    if (adaptationSetIndex == C.INDEX_UNSET) {
+      adaptationSetIndex = period.getAdaptationSetIndex(C.TRACK_TYPE_AUDIO);
+      if (adaptationSetIndex == C.INDEX_UNSET) {
+        return null;
+      }
+    }
+    AdaptationSet adaptationSet = period.adaptationSets.get(adaptationSetIndex);
+    if (adaptationSet.representations.isEmpty()) {
+      return null;
+    }
+    Representation representation = adaptationSet.representations.get(0);
+    DrmInitData drmInitData = representation.format.drmInitData;
+    if (drmInitData == null) {
+      InitializationChunk initializationChunk = loadInitializationChunk(dataSource, representation);
+      if (initializationChunk == null) {
+        return null;
+      }
+      Format sampleFormat = initializationChunk.getSampleFormat();
+      if (sampleFormat != null) {
+        drmInitData = sampleFormat.drmInitData;
+      }
+      if (drmInitData == null) {
+        return null;
+      }
+    }
+    blockingKeyRequest(DefaultDrmSessionManager.MODE_DOWNLOAD, null, drmInitData);
+    return drmSessionManager.getOfflineLicenseKeySetId();
+  }
+
+  /**
+   * Renews an offline license.
+   *
+   * @param offlineLicenseKeySetId The key set id of the license to be renewed.
+   * @return Renewed offline license key set id.
+   * @throws DrmSessionException Thrown when there is an error during DRM session.
+   */
+  public byte[] renew(byte[] offlineLicenseKeySetId) throws DrmSessionException {
+    Assertions.checkNotNull(offlineLicenseKeySetId);
+    blockingKeyRequest(DefaultDrmSessionManager.MODE_DOWNLOAD, offlineLicenseKeySetId, null);
+    return drmSessionManager.getOfflineLicenseKeySetId();
+  }
+
+  /**
+   * Releases an offline license.
+   *
+   * @param offlineLicenseKeySetId The key set id of the license to be released.
+   * @throws DrmSessionException Thrown when there is an error during DRM session.
+   */
+  public void release(byte[] offlineLicenseKeySetId) throws DrmSessionException {
+    Assertions.checkNotNull(offlineLicenseKeySetId);
+    blockingKeyRequest(DefaultDrmSessionManager.MODE_RELEASE, offlineLicenseKeySetId, null);
+  }
+
+  /**
+   * Returns license and playback durations remaining in seconds of the given offline license.
+   *
+   * @param offlineLicenseKeySetId The key set id of the license.
+   */
+  public Pair<Long, Long> getLicenseDurationRemainingSec(byte[] offlineLicenseKeySetId)
+      throws DrmSessionException {
+    Assertions.checkNotNull(offlineLicenseKeySetId);
+    DrmSession<T> session = openBlockingKeyRequest(DefaultDrmSessionManager.MODE_QUERY,
+        offlineLicenseKeySetId, null);
+    Pair<Long, Long> licenseDurationRemainingSec =
+        WidevineUtil.getLicenseDurationRemainingSec(drmSessionManager);
+    drmSessionManager.releaseSession(session);
+    return licenseDurationRemainingSec;
+  }
+
+  private void blockingKeyRequest(@Mode int licenseMode, byte[] offlineLicenseKeySetId,
+      DrmInitData drmInitData) throws DrmSessionException {
+    DrmSession<T> session = openBlockingKeyRequest(licenseMode, offlineLicenseKeySetId,
+        drmInitData);
+    DrmSessionException error = session.getError();
+    if (error != null) {
+      throw error;
+    }
+    drmSessionManager.releaseSession(session);
+  }
+
+  private DrmSession<T> openBlockingKeyRequest(@Mode int licenseMode, byte[] offlineLicenseKeySetId,
+      DrmInitData drmInitData) {
+    drmSessionManager.setMode(licenseMode, offlineLicenseKeySetId);
+    conditionVariable.close();
+    DrmSession<T> session = drmSessionManager.acquireSession(handlerThread.getLooper(),
+        drmInitData);
+    // Block current thread until key loading is finished
+    conditionVariable.block();
+    return session;
+  }
+
+  private static InitializationChunk loadInitializationChunk(final DataSource dataSource,
+      final Representation representation) throws IOException, InterruptedException {
+    RangedUri rangedUri = representation.getInitializationUri();
+    if (rangedUri == null) {
+      return null;
+    }
+    DataSpec dataSpec = new DataSpec(rangedUri.resolveUri(representation.baseUrl), rangedUri.start,
+        rangedUri.length, representation.getCacheKey());
+    InitializationChunk initializationChunk = new InitializationChunk(dataSource, dataSpec,
+        representation.format, C.SELECTION_REASON_UNKNOWN, null /* trackSelectionData */,
+        newWrappedExtractor(representation.format));
+    initializationChunk.load();
+    return initializationChunk;
+  }
+
+  private static ChunkExtractorWrapper newWrappedExtractor(final Format format) {
+    final String mimeType = format.containerMimeType;
+    final boolean isWebm = mimeType.startsWith(MimeTypes.VIDEO_WEBM)
+        || mimeType.startsWith(MimeTypes.AUDIO_WEBM);
+    final Extractor extractor = isWebm ? new MatroskaExtractor() : new FragmentedMp4Extractor();
+    return new ChunkExtractorWrapper(extractor, format, false /* preferManifestDrmInitData */,
+        false /* resendFormatOnInit */);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/drm/WidevineUtil.java b/library/src/main/java/com/google/android/exoplayer2/drm/WidevineUtil.java
new file mode 100644
index 0000000000..fc80cfb6fb
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/drm/WidevineUtil.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.drm;
+
+import android.util.Pair;
+import com.google.android.exoplayer2.C;
+import java.util.Map;
+
+/**
+ * Utility methods for Widevine.
+ */
+public final class WidevineUtil {
+
+  /** Widevine specific key status field name for the remaining license duration, in seconds. */
+  public static final String PROPERTY_LICENSE_DURATION_REMAINING = "LicenseDurationRemaining";
+  /** Widevine specific key status field name for the remaining playback duration, in seconds. */
+  public static final String PROPERTY_PLAYBACK_DURATION_REMAINING = "PlaybackDurationRemaining";
+
+  private WidevineUtil() {}
+
+  /**
+   * Returns license and playback durations remaining in seconds.
+   *
+   * @return A {@link Pair} consisting of the remaining license and playback durations in seconds.
+   * @throws IllegalStateException If called when a session isn't opened.
+   * @param drmSession
+   */
+  public static Pair<Long, Long> getLicenseDurationRemainingSec(DrmSession drmSession) {
+    Map<String, String> keyStatus = drmSession.queryKeyStatus();
+    return new Pair<>(
+        getDurationRemainingSec(keyStatus, PROPERTY_LICENSE_DURATION_REMAINING),
+        getDurationRemainingSec(keyStatus, PROPERTY_PLAYBACK_DURATION_REMAINING));
+  }
+
+  private static long getDurationRemainingSec(Map<String, String> keyStatus, String property) {
+    if (keyStatus != null) {
+      try {
+        String value = keyStatus.get(property);
+        if (value != null) {
+          return Long.parseLong(value);
+        }
+      } catch (NumberFormatException e) {
+        // do nothing.
+      }
+    }
+    return C.TIME_UNSET;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java b/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
index cb9e41aa62..b3bcd97048 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
@@ -226,13 +226,32 @@ public long getLargestQueuedTimestampUs() {
   }
 
   /**
-   * Attempts to skip to the keyframe before the specified time, if it's present in the buffer.
+   * Attempts to skip to the keyframe before or at the specified time. Succeeds only if the buffer
+   * contains a keyframe with a timestamp of {@code timeUs} or earlier, and if {@code timeUs} falls
+   * within the currently buffered media.
+   * <p>
+   * This method is equivalent to {@code skipToKeyframeBefore(timeUs, false)}.
    *
    * @param timeUs The seek time.
    * @return Whether the skip was successful.
    */
   public boolean skipToKeyframeBefore(long timeUs) {
-    long nextOffset = infoQueue.skipToKeyframeBefore(timeUs);
+    return skipToKeyframeBefore(timeUs, false);
+  }
+
+  /**
+   * Attempts to skip to the keyframe before or at the specified time. Succeeds only if the buffer
+   * contains a keyframe with a timestamp of {@code timeUs} or earlier. If
+   * {@code allowTimeBeyondBuffer} is {@code false} then it is also required that {@code timeUs}
+   * falls within the buffer.
+   *
+   * @param timeUs The seek time.
+   * @param allowTimeBeyondBuffer Whether the skip can succeed if {@code timeUs} is beyond the end
+   *     of the buffer.
+   * @return Whether the skip was successful.
+   */
+  public boolean skipToKeyframeBefore(long timeUs, boolean allowTimeBeyondBuffer) {
+    long nextOffset = infoQueue.skipToKeyframeBefore(timeUs, allowTimeBeyondBuffer);
     if (nextOffset == C.POSITION_UNSET) {
       return false;
     }
@@ -246,7 +265,8 @@ public boolean skipToKeyframeBefore(long timeUs) {
    * @param formatHolder A {@link FormatHolder} to populate in the case of reading a format.
    * @param buffer A {@link DecoderInputBuffer} to populate in the case of reading a sample or the
    *     end of the stream. If the end of the stream has been reached, the
-   *     {@link C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer.
+   *     {@link C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer.  May be null if the
+   *     caller requires that the format of the stream be read even if it's not changing.
    * @param loadingFinished True if an empty queue should be considered the end of the stream.
    * @param decodeOnlyUntilUs If a buffer is read, the {@link C#BUFFER_FLAG_DECODE_ONLY} flag will
    *     be set if the buffer's timestamp is less than this value.
@@ -732,7 +752,8 @@ public synchronized long getLargestQueuedTimestampUs() {
      *     about the sample, but not its data. The size and absolute position of the data in the
      *     rolling buffer is stored in {@code extrasHolder}, along with an encryption id if present
      *     and the absolute position of the first byte that may still be required after the current
-     *     sample has been read.
+     *     sample has been read. May be null if the caller requires that the format of the stream be
+     *     read even if it's not changing.
      * @param downstreamFormat The current downstream {@link Format}. If the format of the next
      *     sample is different to the current downstream format then a format will be read.
      * @param extrasHolder The holder into which extra sample information should be written.
@@ -742,14 +763,14 @@ public synchronized long getLargestQueuedTimestampUs() {
     public synchronized int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
         Format downstreamFormat, BufferExtrasHolder extrasHolder) {
       if (queueSize == 0) {
-        if (upstreamFormat != null && upstreamFormat != downstreamFormat) {
+        if (upstreamFormat != null && (buffer == null || upstreamFormat != downstreamFormat)) {
           formatHolder.format = upstreamFormat;
           return C.RESULT_FORMAT_READ;
         }
         return C.RESULT_NOTHING_READ;
       }
 
-      if (formats[relativeReadIndex] != downstreamFormat) {
+      if (buffer == null || formats[relativeReadIndex] != downstreamFormat) {
         formatHolder.format = formats[relativeReadIndex];
         return C.RESULT_FORMAT_READ;
       }
@@ -775,20 +796,22 @@ public synchronized int readData(FormatHolder formatHolder, DecoderInputBuffer b
     }
 
     /**
-     * Attempts to locate the keyframe before the specified time, if it's present in the buffer.
+     * Attempts to locate the keyframe before or at the specified time. If
+     * {@code allowTimeBeyondBuffer} is {@code false} then it is also required that {@code timeUs}
+     * falls within the buffer.
      *
      * @param timeUs The seek time.
+     * @param allowTimeBeyondBuffer Whether the skip can succeed if {@code timeUs} is beyond the end
+     *     of the buffer.
      * @return The offset of the keyframe's data if the keyframe was present.
      *     {@link C#POSITION_UNSET} otherwise.
      */
-    public synchronized long skipToKeyframeBefore(long timeUs) {
+    public synchronized long skipToKeyframeBefore(long timeUs, boolean allowTimeBeyondBuffer) {
       if (queueSize == 0 || timeUs < timesUs[relativeReadIndex]) {
         return C.POSITION_UNSET;
       }
 
-      int lastWriteIndex = (relativeWriteIndex == 0 ? capacity : relativeWriteIndex) - 1;
-      long lastTimeUs = timesUs[lastWriteIndex];
-      if (timeUs > lastTimeUs) {
+      if (timeUs > largestQueuedTimestampUs && !allowTimeBeyondBuffer) {
         return C.POSITION_UNSET;
       }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
index ccf78e6bc6..970335e9d2 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
@@ -529,11 +529,9 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
         }
         break;
       case ID_TRACK_ENTRY:
-        if (tracks.get(currentTrack.number) == null && isCodecSupported(currentTrack.codecId)) {
+        if (isCodecSupported(currentTrack.codecId)) {
           currentTrack.initializeOutput(extractorOutput, currentTrack.number);
           tracks.put(currentTrack.number, currentTrack);
-        } else {
-          // We've seen this track entry before, or the codec is unsupported. Do nothing.
         }
         currentTrack = null;
         break;
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java
index 2eac7926e7..cc7e662336 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java
@@ -127,6 +127,7 @@
   public static final int TYPE_mean = Util.getIntegerCodeForString("mean");
   public static final int TYPE_name = Util.getIntegerCodeForString("name");
   public static final int TYPE_data = Util.getIntegerCodeForString("data");
+  public static final int TYPE_emsg = Util.getIntegerCodeForString("emsg");
   public static final int TYPE_st3d = Util.getIntegerCodeForString("st3d");
   public static final int TYPE_sv3d = Util.getIntegerCodeForString("sv3d");
   public static final int TYPE_proj = Util.getIntegerCodeForString("proj");
@@ -134,6 +135,7 @@
   public static final int TYPE_vp09 = Util.getIntegerCodeForString("vp09");
   public static final int TYPE_vpcC = Util.getIntegerCodeForString("vpcC");
   public static final int TYPE_camm = Util.getIntegerCodeForString("camm");
+  public static final int TYPE_alac = Util.getIntegerCodeForString("alac");
 
   public final int type;
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
index 9dc0578263..5288a3e6ba 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
@@ -604,7 +604,7 @@ private static StsdData parseStsd(ParsableByteArray stsd, int trackId, int rotat
           || childAtomType == Atom.TYPE_dtsh || childAtomType == Atom.TYPE_dtsl
           || childAtomType == Atom.TYPE_samr || childAtomType == Atom.TYPE_sawb
           || childAtomType == Atom.TYPE_lpcm || childAtomType == Atom.TYPE_sowt
-          || childAtomType == Atom.TYPE__mp3) {
+          || childAtomType == Atom.TYPE__mp3 || childAtomType == Atom.TYPE_alac) {
         parseAudioSampleEntry(stsd, childAtomType, childStartPosition, childAtomSize, trackId,
             language, isQuickTime, drmInitData, out, i);
       } else if (childAtomType == Atom.TYPE_TTML) {
@@ -839,6 +839,8 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
       mimeType = MimeTypes.AUDIO_RAW;
     } else if (atomType == Atom.TYPE__mp3) {
       mimeType = MimeTypes.AUDIO_MPEG;
+    } else if (atomType == Atom.TYPE_alac) {
+      mimeType = MimeTypes.AUDIO_ALAC;
     }
 
     byte[] initializationData = null;
@@ -876,6 +878,10 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
         out.format = Format.createAudioSampleFormat(Integer.toString(trackId), mimeType, null,
             Format.NO_VALUE, Format.NO_VALUE, channelCount, sampleRate, null, drmInitData, 0,
             language);
+      } else if (childAtomType == Atom.TYPE_alac) {
+        initializationData = new byte[childAtomSize];
+        parent.setPosition(childPosition);
+        parent.readBytes(initializationData, 0, childAtomSize);
       }
       childPosition += childAtomSize;
     }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
index c718cd7111..f7cc42c48f 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
@@ -20,6 +20,7 @@
 import android.util.Pair;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
@@ -30,20 +31,22 @@
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.extractor.mp4.Atom.ContainerAtom;
 import com.google.android.exoplayer2.extractor.mp4.Atom.LeafAtom;
+import com.google.android.exoplayer2.text.cea.CeaUtil;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.NalUnitUtil;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Stack;
 import java.util.UUID;
@@ -65,15 +68,13 @@
 
   };
 
-  private static final String TAG = "FragmentedMp4Extractor";
-  private static final int SAMPLE_GROUP_TYPE_seig = Util.getIntegerCodeForString("seig");
-
   /**
    * Flags controlling the behavior of the extractor.
    */
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(flag = true, value = {FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME,
-      FLAG_WORKAROUND_IGNORE_TFDT_BOX, FLAG_SIDELOADED})
+      FLAG_WORKAROUND_IGNORE_TFDT_BOX, FLAG_ENABLE_EMSG_TRACK, FLAG_ENABLE_CEA608_TRACK,
+      FLAG_SIDELOADED})
   public @interface Flags {}
   /**
    * Flag to work around an issue in some video streams where every frame is marked as a sync frame.
@@ -87,12 +88,25 @@
    * Flag to ignore any tfdt boxes in the stream.
    */
   public static final int FLAG_WORKAROUND_IGNORE_TFDT_BOX = 2;
+  /**
+   * Flag to indicate that the extractor should output an event message metadata track. Any event
+   * messages in the stream will be delivered as samples to this track.
+   */
+  public static final int FLAG_ENABLE_EMSG_TRACK = 4;
+  /**
+   * Flag to indicate that the extractor should output a CEA-608 text track. Any CEA-608 messages
+   * contained within SEI NAL units in the stream will be delivered as samples to this track.
+   */
+  public static final int FLAG_ENABLE_CEA608_TRACK = 8;
   /**
    * Flag to indicate that the {@link Track} was sideloaded, instead of being declared by the MP4
    * container.
    */
-  private static final int FLAG_SIDELOADED = 4;
+  private static final int FLAG_SIDELOADED = 16;
 
+  private static final String TAG = "FragmentedMp4Extractor";
+  private static final int SAMPLE_GROUP_TYPE_seig = Util.getIntegerCodeForString("seig");
+  private static final int NAL_UNIT_TYPE_SEI = 6; // Supplemental enhancement information
   private static final byte[] PIFF_SAMPLE_ENCRYPTION_BOX_EXTENDED_TYPE =
       new byte[] {-94, 57, 79, 82, 90, -101, 79, 20, -94, 68, 108, 66, 124, 100, -115, -12};
 
@@ -114,6 +128,7 @@
   // Temporary arrays.
   private final ParsableByteArray nalStartCode;
   private final ParsableByteArray nalLength;
+  private final ParsableByteArray nalPayload;
   private final ParsableByteArray encryptionSignalByte;
 
   // Adjusts sample timestamps.
@@ -123,6 +138,7 @@
   private final ParsableByteArray atomHeader;
   private final byte[] extendedTypeScratch;
   private final Stack<ContainerAtom> containerAtoms;
+  private final LinkedList<MetadataSampleInfo> pendingMetadataSampleInfos;
 
   private int parserState;
   private int atomType;
@@ -130,8 +146,10 @@
   private int atomHeaderBytesRead;
   private ParsableByteArray atomData;
   private long endOfMdatPosition;
+  private int pendingMetadataSampleBytes;
 
   private long durationUs;
+  private long segmentIndexEarliestPresentationTimeUs;
   private TrackBundle currentTrackBundle;
   private int sampleSize;
   private int sampleBytesWritten;
@@ -139,6 +157,8 @@
 
   // Extractor output.
   private ExtractorOutput extractorOutput;
+  private TrackOutput eventMessageTrackOutput;
+  private TrackOutput cea608TrackOutput;
 
   // Whether extractorOutput.seekMap has been called.
   private boolean haveOutputSeekMap;
@@ -169,11 +189,14 @@ public FragmentedMp4Extractor(@Flags int flags, Track sideloadedTrack,
     atomHeader = new ParsableByteArray(Atom.LONG_HEADER_SIZE);
     nalStartCode = new ParsableByteArray(NalUnitUtil.NAL_START_CODE);
     nalLength = new ParsableByteArray(4);
+    nalPayload = new ParsableByteArray(1);
     encryptionSignalByte = new ParsableByteArray(1);
     extendedTypeScratch = new byte[16];
     containerAtoms = new Stack<>();
+    pendingMetadataSampleInfos = new LinkedList<>();
     trackBundles = new SparseArray<>();
     durationUs = C.TIME_UNSET;
+    segmentIndexEarliestPresentationTimeUs = C.TIME_UNSET;
     enterReadingAtomHeaderState();
   }
 
@@ -189,6 +212,7 @@ public void init(ExtractorOutput output) {
       TrackBundle bundle = new TrackBundle(output.track(0));
       bundle.init(sideloadedTrack, new DefaultSampleValues(0, 0, 0, 0));
       trackBundles.put(0, bundle);
+      maybeInitExtraTracks();
       extractorOutput.endTracks();
     }
   }
@@ -199,6 +223,8 @@ public void seek(long position, long timeUs) {
     for (int i = 0; i < trackCount; i++) {
       trackBundles.valueAt(i).reset();
     }
+    pendingMetadataSampleInfos.clear();
+    pendingMetadataSampleBytes = 0;
     containerAtoms.clear();
     enterReadingAtomHeaderState();
   }
@@ -257,6 +283,10 @@ private boolean readAtomHeader(ExtractorInput input) throws IOException, Interru
       atomSize = atomHeader.readUnsignedLongToLong();
     }
 
+    if (atomSize < atomHeaderBytesRead) {
+      throw new ParserException("Atom size less than header length (unsupported).");
+    }
+
     long atomPosition = input.getPosition() - atomHeaderBytesRead;
     if (atomType == Atom.TYPE_moof) {
       // The data positions may be updated when parsing the tfhd/trun.
@@ -332,9 +362,12 @@ private void onLeafAtomRead(LeafAtom leaf, long inputPosition) throws ParserExce
     if (!containerAtoms.isEmpty()) {
       containerAtoms.peek().add(leaf);
     } else if (leaf.type == Atom.TYPE_sidx) {
-      ChunkIndex segmentIndex = parseSidx(leaf.data, inputPosition);
-      extractorOutput.seekMap(segmentIndex);
+      Pair<Long, ChunkIndex> result = parseSidx(leaf.data, inputPosition);
+      segmentIndexEarliestPresentationTimeUs = result.first;
+      extractorOutput.seekMap(result.second);
       haveOutputSeekMap = true;
+    } else if (leaf.type == Atom.TYPE_emsg) {
+      onEmsgLeafAtomRead(leaf.data);
     }
   }
 
@@ -387,18 +420,19 @@ private void onMoovContainerAtomRead(ContainerAtom moov) throws ParserException
       // We need to create the track bundles.
       for (int i = 0; i < trackCount; i++) {
         Track track = tracks.valueAt(i);
-        trackBundles.put(track.id, new TrackBundle(extractorOutput.track(i)));
+        TrackBundle trackBundle = new TrackBundle(extractorOutput.track(i));
+        trackBundle.init(track, defaultSampleValuesArray.get(track.id));
+        trackBundles.put(track.id, trackBundle);
         durationUs = Math.max(durationUs, track.durationUs);
       }
+      maybeInitExtraTracks();
       extractorOutput.endTracks();
     } else {
       Assertions.checkState(trackBundles.size() == trackCount);
-    }
-
-    // Initialization of tracks and default sample values.
-    for (int i = 0; i < trackCount; i++) {
-      Track track = tracks.valueAt(i);
-      trackBundles.get(track.id).init(track, defaultSampleValuesArray.get(track.id));
+      for (int i = 0; i < trackCount; i++) {
+        Track track = tracks.valueAt(i);
+        trackBundles.get(track.id).init(track, defaultSampleValuesArray.get(track.id));
+      }
     }
   }
 
@@ -413,6 +447,51 @@ private void onMoofContainerAtomRead(ContainerAtom moof) throws ParserException
     }
   }
 
+  private void maybeInitExtraTracks() {
+    if ((flags & FLAG_ENABLE_EMSG_TRACK) != 0 && eventMessageTrackOutput == null) {
+      eventMessageTrackOutput = extractorOutput.track(trackBundles.size());
+      eventMessageTrackOutput.format(Format.createSampleFormat(null, MimeTypes.APPLICATION_EMSG,
+          Format.OFFSET_SAMPLE_RELATIVE));
+    }
+    if ((flags & FLAG_ENABLE_CEA608_TRACK) != 0 && cea608TrackOutput == null) {
+      cea608TrackOutput = extractorOutput.track(trackBundles.size() + 1);
+      cea608TrackOutput.format(Format.createTextSampleFormat(null, MimeTypes.APPLICATION_CEA608,
+          null, Format.NO_VALUE, 0, null, null));
+    }
+  }
+
+  /**
+   * Handles an emsg atom (defined in 23009-1).
+   */
+  private void onEmsgLeafAtomRead(ParsableByteArray atom) {
+    if (eventMessageTrackOutput == null) {
+      return;
+    }
+    // Parse the event's presentation time delta.
+    atom.setPosition(Atom.FULL_HEADER_SIZE);
+    atom.readNullTerminatedString(); // schemeIdUri
+    atom.readNullTerminatedString(); // value
+    long timescale = atom.readUnsignedInt();
+    long presentationTimeDeltaUs =
+        Util.scaleLargeTimestamp(atom.readUnsignedInt(), C.MICROS_PER_SECOND, timescale);
+    // Output the sample data.
+    atom.setPosition(Atom.FULL_HEADER_SIZE);
+    int sampleSize = atom.bytesLeft();
+    eventMessageTrackOutput.sampleData(atom, sampleSize);
+    // Output the sample metadata.
+    if (segmentIndexEarliestPresentationTimeUs != C.TIME_UNSET) {
+      // We can output the sample metadata immediately.
+      eventMessageTrackOutput.sampleMetadata(
+          segmentIndexEarliestPresentationTimeUs + presentationTimeDeltaUs,
+          C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0 /* offset */, null);
+    } else {
+      // We need the first sample timestamp in the segment before we can output the metadata.
+      pendingMetadataSampleInfos.addLast(
+          new MetadataSampleInfo(presentationTimeDeltaUs, sampleSize));
+      pendingMetadataSampleBytes += sampleSize;
+    }
+  }
+
   /**
    * Parses a trex atom (defined in 14496-12).
    */
@@ -624,7 +703,7 @@ private static TrackBundle parseTfhd(ParsableByteArray tfhd,
     DefaultSampleValues defaultSampleValues = trackBundle.defaultSampleValues;
     int defaultSampleDescriptionIndex =
         ((atomFlags & 0x02 /* default_sample_description_index_present */) != 0)
-        ? tfhd.readUnsignedIntToInt() - 1 : defaultSampleValues.sampleDescriptionIndex;
+            ? tfhd.readUnsignedIntToInt() - 1 : defaultSampleValues.sampleDescriptionIndex;
     int defaultSampleDuration = ((atomFlags & 0x08 /* default_sample_duration_present */) != 0)
         ? tfhd.readUnsignedIntToInt() : defaultSampleValues.duration;
     int defaultSampleSize = ((atomFlags & 0x10 /* default_sample_size_present */) != 0)
@@ -828,8 +907,13 @@ private static void parseSgpd(ParsableByteArray sbgp, ParsableByteArray sgpd, Tr
 
   /**
    * Parses a sidx atom (defined in 14496-12).
+   *
+   * @param atom The atom data.
+   * @param inputPosition The input position of the first byte after the atom.
+   * @return A pair consisting of the earliest presentation time in microseconds, and the parsed
+   *     {@link ChunkIndex}.
    */
-  private static ChunkIndex parseSidx(ParsableByteArray atom, long inputPosition)
+  private static Pair<Long, ChunkIndex> parseSidx(ParsableByteArray atom, long inputPosition)
       throws ParserException {
     atom.setPosition(Atom.HEADER_SIZE);
     int fullAtom = atom.readInt();
@@ -846,6 +930,8 @@ private static ChunkIndex parseSidx(ParsableByteArray atom, long inputPosition)
       earliestPresentationTime = atom.readUnsignedLongToLong();
       offset += atom.readUnsignedLongToLong();
     }
+    long earliestPresentationTimeUs = Util.scaleLargeTimestamp(earliestPresentationTime,
+        C.MICROS_PER_SECOND, timescale);
 
     atom.skipBytes(2);
 
@@ -856,7 +942,7 @@ private static ChunkIndex parseSidx(ParsableByteArray atom, long inputPosition)
     long[] timesUs = new long[referenceCount];
 
     long time = earliestPresentationTime;
-    long timeUs = Util.scaleLargeTimestamp(time, C.MICROS_PER_SECOND, timescale);
+    long timeUs = earliestPresentationTimeUs;
     for (int i = 0; i < referenceCount; i++) {
       int firstInt = atom.readInt();
 
@@ -880,7 +966,8 @@ private static ChunkIndex parseSidx(ParsableByteArray atom, long inputPosition)
       offset += sizes[i];
     }
 
-    return new ChunkIndex(sizes, offsets, durationsUs, timesUs);
+    return Pair.create(earliestPresentationTimeUs,
+        new ChunkIndex(sizes, offsets, durationsUs, timesUs));
   }
 
   private void readEncryptionData(ExtractorInput input) throws IOException, InterruptedException {
@@ -942,13 +1029,9 @@ private boolean readSample(ExtractorInput input) throws IOException, Interrupted
         // We skip bytes preceding the next sample to read.
         int bytesToSkip = (int) (nextDataPosition - input.getPosition());
         if (bytesToSkip < 0) {
-          if (nextDataPosition == currentTrackBundle.fragment.atomPosition) {
-            // Assume the sample data must be contiguous in the mdat with no preceeding data.
-            Log.w(TAG, "Offset to sample data was missing.");
-            bytesToSkip = 0;
-          } else {
-            throw new ParserException("Offset to sample data was negative.");
-          }
+          // Assume the sample data must be contiguous in the mdat with no preceding data.
+          Log.w(TAG, "Ignoring negative offset to sample data.");
+          bytesToSkip = 0;
         }
         input.skipFully(bytesToSkip);
         this.currentTrackBundle = currentTrackBundle;
@@ -996,6 +1079,26 @@ private boolean readSample(ExtractorInput input) throws IOException, Interrupted
           output.sampleData(nalStartCode, 4);
           sampleBytesWritten += 4;
           sampleSize += nalUnitLengthFieldLengthDiff;
+          if (cea608TrackOutput != null) {
+            byte[] nalPayloadData = nalPayload.data;
+            // Peek the NAL unit type byte.
+            input.peekFully(nalPayloadData, 0, 1);
+            if ((nalPayloadData[0] & 0x1F) == NAL_UNIT_TYPE_SEI) {
+              // Read the whole SEI NAL unit into nalWrapper, including the NAL unit type byte.
+              nalPayload.reset(sampleCurrentNalBytesRemaining);
+              input.readFully(nalPayloadData, 0, sampleCurrentNalBytesRemaining);
+              // Write the SEI unit straight to the output.
+              output.sampleData(nalPayload, sampleCurrentNalBytesRemaining);
+              sampleBytesWritten += sampleCurrentNalBytesRemaining;
+              sampleCurrentNalBytesRemaining = 0;
+              // Unescape and process the SEI unit.
+              int unescapedLength = NalUnitUtil.unescapeStream(nalPayloadData, nalPayload.limit());
+              nalPayload.setPosition(1); // Skip the NAL unit type byte.
+              nalPayload.setLimit(unescapedLength);
+              CeaUtil.consume(fragment.getSamplePresentationTime(sampleIndex) * 1000L, nalPayload,
+                  cea608TrackOutput);
+            }
+          }
         } else {
           // Write the payload of the NAL unit.
           int writtenBytes = output.sampleData(input, sampleCurrentNalBytesRemaining, false);
@@ -1025,6 +1128,14 @@ private boolean readSample(ExtractorInput input) throws IOException, Interrupted
     }
     output.sampleMetadata(sampleTimeUs, sampleFlags, sampleSize, 0, encryptionKey);
 
+    while (!pendingMetadataSampleInfos.isEmpty()) {
+      MetadataSampleInfo sampleInfo = pendingMetadataSampleInfos.removeFirst();
+      pendingMetadataSampleBytes -= sampleInfo.size;
+      eventMessageTrackOutput.sampleMetadata(
+          sampleTimeUs + sampleInfo.presentationTimeDeltaUs,
+          C.BUFFER_FLAG_KEY_FRAME, sampleInfo.size, pendingMetadataSampleBytes, null);
+    }
+
     currentTrackBundle.currentSampleIndex++;
     currentTrackBundle.currentSampleInTrackRun++;
     if (currentTrackBundle.currentSampleInTrackRun
@@ -1130,7 +1241,7 @@ private static boolean shouldParseLeafAtom(int atom) {
         || atom == Atom.TYPE_trun || atom == Atom.TYPE_pssh || atom == Atom.TYPE_saiz
         || atom == Atom.TYPE_saio || atom == Atom.TYPE_senc || atom == Atom.TYPE_uuid
         || atom == Atom.TYPE_sbgp || atom == Atom.TYPE_sgpd || atom == Atom.TYPE_elst
-        || atom == Atom.TYPE_mehd;
+        || atom == Atom.TYPE_mehd || atom == Atom.TYPE_emsg;
   }
 
   /** Returns whether the extractor should decode a container atom with type {@code atom}. */
@@ -1140,6 +1251,21 @@ private static boolean shouldParseContainerAtom(int atom) {
         || atom == Atom.TYPE_traf || atom == Atom.TYPE_mvex || atom == Atom.TYPE_edts;
   }
 
+  /**
+   * Holds data corresponding to a metadata sample.
+   */
+  private static final class MetadataSampleInfo {
+
+    public final long presentationTimeDeltaUs;
+    public final int size;
+
+    public MetadataSampleInfo(long presentationTimeDeltaUs, int size) {
+      this.presentationTimeDeltaUs = presentationTimeDeltaUs;
+      this.size = size;
+    }
+
+  }
+
   /**
    * Holds data corresponding to a single track.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/MetadataUtil.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/MetadataUtil.java
index e99dab053b..fed1694925 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/MetadataUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/MetadataUtil.java
@@ -188,7 +188,7 @@ private static TextInformationFrame parseTextAttribute(int type, String id,
     if (atomType == Atom.TYPE_data) {
       data.skipBytes(8); // version (1), flags (3), empty (4)
       String value = data.readNullTerminatedString(atomSize - 16);
-      return new TextInformationFrame(id, value);
+      return new TextInformationFrame(id, null, value);
     }
     Log.w(TAG, "Failed to parse text attribute: " + Atom.getAtomTypeString(type));
     return null;
@@ -213,7 +213,7 @@ private static Id3Frame parseUint8Attribute(int type, String id, ParsableByteArr
       value = Math.min(1, value);
     }
     if (value >= 0) {
-      return isTextInformationFrame ? new TextInformationFrame(id, Integer.toString(value))
+      return isTextInformationFrame ? new TextInformationFrame(id, null, Integer.toString(value))
           : new CommentFrame(LANGUAGE_UNDEFINED, id, Integer.toString(value));
     }
     Log.w(TAG, "Failed to parse uint8 attribute: " + Atom.getAtomTypeString(type));
@@ -228,12 +228,12 @@ private static TextInformationFrame parseIndexAndCountAttribute(int type, String
       data.skipBytes(10); // version (1), flags (3), empty (4), empty (2)
       int index = data.readUnsignedShort();
       if (index > 0) {
-        String description = "" + index;
+        String value = "" + index;
         int count = data.readUnsignedShort();
         if (count > 0) {
-          description += "/" + count;
+          value += "/" + count;
         }
-        return new TextInformationFrame(attributeName, description);
+        return new TextInformationFrame(attributeName, null, value);
       }
     }
     Log.w(TAG, "Failed to parse index/count attribute: " + Atom.getAtomTypeString(type));
@@ -245,7 +245,7 @@ private static TextInformationFrame parseStandardGenreAttribute(ParsableByteArra
     String genreString = (0 < genreCode && genreCode <= STANDARD_GENRES.length)
         ? STANDARD_GENRES[genreCode - 1] : null;
     if (genreString != null) {
-      return new TextInformationFrame("TCON", genreString);
+      return new TextInformationFrame("TCON", null, genreString);
     }
     Log.w(TAG, "Failed to parse standard genre code");
     return null;
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractor.java
index f6cd29aff2..f9957aebe5 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractor.java
@@ -83,8 +83,11 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     while (true) {
       switch (parserState) {
         case STATE_READING_HEADER:
-          parseHeader(input);
-          parserState = STATE_READING_TIMESTAMP_AND_COUNT;
+          if (parseHeader(input)) {
+            parserState = STATE_READING_TIMESTAMP_AND_COUNT;
+          } else {
+            return RESULT_END_OF_INPUT;
+          }
           break;
         case STATE_READING_TIMESTAMP_AND_COUNT:
           if (parseTimestampAndSampleCount(input)) {
@@ -114,14 +117,18 @@ public void release() {
     // Do nothing
   }
 
-  private void parseHeader(ExtractorInput input) throws IOException, InterruptedException {
+  private boolean parseHeader(ExtractorInput input) throws IOException, InterruptedException {
     dataScratch.reset();
-    input.readFully(dataScratch.data, 0, HEADER_SIZE);
-    if (dataScratch.readInt() != HEADER_ID) {
-      throw new IOException("Input not RawCC");
+    if (input.readFully(dataScratch.data, 0, HEADER_SIZE, true)) {
+      if (dataScratch.readInt() != HEADER_ID) {
+        throw new IOException("Input not RawCC");
+      }
+      version = dataScratch.readUnsignedByte();
+      // no versions use the flag fields yet
+      return true;
+    } else {
+      return false;
     }
-    version = dataScratch.readUnsignedByte();
-    // no versions use the flag fields yet
   }
 
   private boolean parseTimestampAndSampleCount(ExtractorInput input) throws IOException,
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java
index 598394a870..59696b9dea 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java
@@ -16,12 +16,11 @@
 package com.google.android.exoplayer2.extractor.ts;
 
 import android.util.Log;
-
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 
 /**
  * Parses PES packet data and extracts samples.
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
index 5c50ca7bf3..883fb8f880 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
@@ -23,10 +23,10 @@
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import java.io.IOException;
 
 /**
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionPayloadReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionPayloadReader.java
index 347c401337..d6e6eadf3f 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionPayloadReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionPayloadReader.java
@@ -16,10 +16,10 @@
 package com.google.android.exoplayer2.extractor.ts;
 
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 
 /**
  * Reads section data.
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionReader.java
index 822f5653c4..d217cfcb7a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionReader.java
@@ -17,8 +17,8 @@
 
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.Util;
 
 /**
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java
index a2791bcaae..6e2e42d8e2 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java
@@ -15,10 +15,9 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
-import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.TrackOutput;
-import com.google.android.exoplayer2.text.cea.Cea608Decoder;
+import com.google.android.exoplayer2.text.cea.CeaUtil;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 
@@ -36,40 +35,7 @@ public SeiReader(TrackOutput output) {
   }
 
   public void consume(long pesTimeUs, ParsableByteArray seiBuffer) {
-    int b;
-    while (seiBuffer.bytesLeft() > 1 /* last byte will be rbsp_trailing_bits */) {
-      // Parse payload type.
-      int payloadType = 0;
-      do {
-        b = seiBuffer.readUnsignedByte();
-        payloadType += b;
-      } while (b == 0xFF);
-      // Parse payload size.
-      int payloadSize = 0;
-      do {
-        b = seiBuffer.readUnsignedByte();
-        payloadSize += b;
-      } while (b == 0xFF);
-      // Process the payload.
-      if (Cea608Decoder.isSeiMessageCea608(payloadType, payloadSize, seiBuffer)) {
-        // Ignore country_code (1) + provider_code (2) + user_identifier (4)
-        // + user_data_type_code (1).
-        seiBuffer.skipBytes(8);
-        // Ignore first three bits: reserved (1) + process_cc_data_flag (1) + zero_bit (1).
-        int ccCount = seiBuffer.readUnsignedByte() & 0x1F;
-        // Ignore em_data (1)
-        seiBuffer.skipBytes(1);
-        // Each data packet consists of 24 bits: marker bits (5) + cc_valid (1) + cc_type (2)
-        // + cc_data_1 (8) + cc_data_2 (8).
-        int sampleLength = ccCount * 3;
-        output.sampleData(seiBuffer, sampleLength);
-        output.sampleMetadata(pesTimeUs, C.BUFFER_FLAG_KEY_FRAME, sampleLength, 0, null);
-        // Ignore trailing information in SEI, if any.
-        seiBuffer.skipBytes(payloadSize - (10 + ccCount * 3));
-      } else {
-        seiBuffer.skipBytes(payloadSize);
-      }
-    }
+    CeaUtil.consume(pesTimeUs, seiBuffer, output);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SpliceInfoSectionReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SpliceInfoSectionReader.java
index b1e71d6651..057fa636ce 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SpliceInfoSectionReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SpliceInfoSectionReader.java
@@ -18,21 +18,24 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 
 /**
  * Parses splice info sections as defined by SCTE35.
  */
 public final class SpliceInfoSectionReader implements SectionPayloadReader {
 
+  private TimestampAdjuster timestampAdjuster;
   private TrackOutput output;
+  private boolean formatDeclared;
 
   @Override
   public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
       TsPayloadReader.TrackIdGenerator idGenerator) {
+    this.timestampAdjuster = timestampAdjuster;
     output = extractorOutput.track(idGenerator.getNextId());
     output.format(Format.createSampleFormat(null, MimeTypes.APPLICATION_SCTE35, null,
         Format.NO_VALUE, null));
@@ -40,9 +43,19 @@ public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorO
 
   @Override
   public void consume(ParsableByteArray sectionData) {
+    if (!formatDeclared) {
+      if (timestampAdjuster.getTimestampOffsetUs() == C.TIME_UNSET) {
+        // There is not enough information to initialize the timestamp adjuster.
+        return;
+      }
+      output.format(Format.createSampleFormat(null, MimeTypes.APPLICATION_SCTE35,
+          timestampAdjuster.getTimestampOffsetUs()));
+      formatDeclared = true;
+    }
     int sampleSize = sectionData.bytesLeft();
     output.sampleData(sectionData, sampleSize);
-    output.sampleMetadata(0, C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0, null);
+    output.sampleMetadata(timestampAdjuster.getLastAdjustedTimestampUs(), C.BUFFER_FLAG_KEY_FRAME,
+        sampleSize, 0, null);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
index bf5adac500..61d66afbc2 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
@@ -25,13 +25,13 @@
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.EsInfo;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.Arrays;
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
index 304c8c1282..5785c50a7b 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
@@ -17,9 +17,9 @@
 
 import android.util.SparseArray;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 
 /**
  * Parses TS packet payload data.
diff --git a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
index 166de37c50..6914b2f52c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.mediacodec;
 
 import android.annotation.TargetApi;
+import android.graphics.Point;
 import android.media.MediaCodec;
 import android.media.MediaCodecInfo.AudioCapabilities;
 import android.media.MediaCodecInfo.CodecCapabilities;
@@ -23,6 +24,7 @@
 import android.media.MediaCodecInfo.VideoCapabilities;
 import android.util.Log;
 import android.util.Pair;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
@@ -142,70 +144,68 @@ public boolean isCodecSupported(String codec) {
   }
 
   /**
-   * Whether the decoder supports video with a specified width and height.
+   * Whether the decoder supports video with a given width, height and frame rate.
    * <p>
    * Must not be called if the device SDK version is less than 21.
    *
    * @param width Width in pixels.
    * @param height Height in pixels.
-   * @return Whether the decoder supports video with the given width and height.
+   * @param frameRate Optional frame rate in frames per second. Ignored if set to
+   *     {@link Format#NO_VALUE} or any value less than or equal to 0.
+   * @return Whether the decoder supports video with the given width, height and frame rate.
    */
   @TargetApi(21)
-  public boolean isVideoSizeSupportedV21(int width, int height) {
+  public boolean isVideoSizeAndRateSupportedV21(int width, int height, double frameRate) {
     if (capabilities == null) {
-      logNoSupport("size.caps");
+      logNoSupport("sizeAndRate.caps");
       return false;
     }
     VideoCapabilities videoCapabilities = capabilities.getVideoCapabilities();
     if (videoCapabilities == null) {
-      logNoSupport("size.vCaps");
+      logNoSupport("sizeAndRate.vCaps");
       return false;
     }
-    if (!videoCapabilities.isSizeSupported(width, height)) {
+    if (!areSizeAndRateSupported(videoCapabilities, width, height, frameRate)) {
       // Capabilities are known to be inaccurately reported for vertical resolutions on some devices
       // (b/31387661). If the video is vertical and the capabilities indicate support if the width
       // and height are swapped, we assume that the vertical resolution is also supported.
-      if (width >= height || !videoCapabilities.isSizeSupported(height, width)) {
-        logNoSupport("size.support, " + width + "x" + height);
+      if (width >= height
+          || !areSizeAndRateSupported(videoCapabilities, height, width, frameRate)) {
+        logNoSupport("sizeAndRate.support, " + width + "x" + height + "x" + frameRate);
         return false;
       }
-      logAssumedSupport("size.rotated, " + width + "x" + height);
+      logAssumedSupport("sizeAndRate.rotated, " + width + "x" + height + "x" + frameRate);
     }
     return true;
   }
 
   /**
-   * Whether the decoder supports video with a given width, height and frame rate.
+   * Returns the smallest video size greater than or equal to a specified size that also satisfies
+   * the {@link MediaCodec}'s width and height alignment requirements.
    * <p>
    * Must not be called if the device SDK version is less than 21.
    *
    * @param width Width in pixels.
    * @param height Height in pixels.
-   * @param frameRate Frame rate in frames per second.
-   * @return Whether the decoder supports video with the given width, height and frame rate.
+   * @return The smallest video size greater than or equal to the specified size that also satisfies
+   *     the {@link MediaCodec}'s width and height alignment requirements, or null if not a video
+   *     codec.
    */
   @TargetApi(21)
-  public boolean isVideoSizeAndRateSupportedV21(int width, int height, double frameRate) {
+  public Point alignVideoSizeV21(int width, int height) {
     if (capabilities == null) {
-      logNoSupport("sizeAndRate.caps");
-      return false;
+      logNoSupport("align.caps");
+      return null;
     }
     VideoCapabilities videoCapabilities = capabilities.getVideoCapabilities();
     if (videoCapabilities == null) {
-      logNoSupport("sizeAndRate.vCaps");
-      return false;
+      logNoSupport("align.vCaps");
+      return null;
     }
-    if (!videoCapabilities.areSizeAndRateSupported(width, height, frameRate)) {
-      // Capabilities are known to be inaccurately reported for vertical resolutions on some devices
-      // (b/31387661). If the video is vertical and the capabilities indicate support if the width
-      // and height are swapped, we assume that the vertical resolution is also supported.
-      if (width >= height || !videoCapabilities.areSizeAndRateSupported(height, width, frameRate)) {
-        logNoSupport("sizeAndRate.support, " + width + "x" + height + "x" + frameRate);
-        return false;
-      }
-      logAssumedSupport("sizeAndRate.rotated, " + width + "x" + height + "x" + frameRate);
-    }
-    return true;
+    int widthAlignment = videoCapabilities.getWidthAlignment();
+    int heightAlignment = videoCapabilities.getHeightAlignment();
+    return new Point(Util.ceilDivide(width, widthAlignment) * widthAlignment,
+        Util.ceilDivide(height, heightAlignment) * heightAlignment);
   }
 
   /**
@@ -279,6 +279,14 @@ private static boolean isAdaptiveV19(CodecCapabilities capabilities) {
     return capabilities.isFeatureSupported(CodecCapabilities.FEATURE_AdaptivePlayback);
   }
 
+  @TargetApi(21)
+  private static boolean areSizeAndRateSupported(VideoCapabilities capabilities, int width,
+      int height, double frameRate) {
+    return frameRate == Format.NO_VALUE || frameRate <= 0
+        ? capabilities.isSizeSupported(width, height)
+        : capabilities.areSizeAndRateSupported(width, height, frameRate);
+  }
+
   private static boolean isTunneling(CodecCapabilities capabilities) {
     return Util.SDK_INT >= 21 && isTunnelingV21(capabilities);
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
index 6dce2abc2a..9be1c59baf 100644
--- a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
@@ -201,6 +201,7 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   private boolean inputStreamEnded;
   private boolean outputStreamEnded;
   private boolean waitingForKeys;
+  private boolean waitingForFirstSyncFrame;
 
   protected DecoderCounters decoderCounters;
 
@@ -270,17 +271,20 @@ protected abstract int supportsFormat(MediaCodecSelector mediaCodecSelector, For
    */
   protected MediaCodecInfo getDecoderInfo(MediaCodecSelector mediaCodecSelector,
       Format format, boolean requiresSecureDecoder) throws DecoderQueryException {
-    return mediaCodecSelector.getDecoderInfo(format.sampleMimeType, requiresSecureDecoder, false);
+    return mediaCodecSelector.getDecoderInfo(format.sampleMimeType, requiresSecureDecoder);
   }
 
   /**
    * Configures a newly created {@link MediaCodec}.
    *
+   * @param codecInfo Information about the {@link MediaCodec} being configured.
    * @param codec The {@link MediaCodec} to configure.
    * @param format The format for which the codec is being configured.
    * @param crypto For drm protected playbacks, a {@link MediaCrypto} to use for decryption.
+   * @throws DecoderQueryException If an error occurs querying {@code codecInfo}.
    */
-  protected abstract void configureCodec(MediaCodec codec, Format format, MediaCrypto crypto);
+  protected abstract void configureCodec(MediaCodecInfo codecInfo, MediaCodec codec, Format format,
+      MediaCrypto crypto) throws DecoderQueryException;
 
   @SuppressWarnings("deprecation")
   protected final void maybeInitCodec() throws ExoPlaybackException {
@@ -345,7 +349,7 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
       codec = MediaCodec.createByCodecName(codecName);
       TraceUtil.endSection();
       TraceUtil.beginSection("configureCodec");
-      configureCodec(codec, format, mediaCrypto);
+      configureCodec(decoderInfo, codec, format, mediaCrypto);
       TraceUtil.endSection();
       TraceUtil.beginSection("startCodec");
       codec.start();
@@ -363,6 +367,7 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
         ? (SystemClock.elapsedRealtime() + MAX_CODEC_HOTSWAP_TIME_MS) : C.TIME_UNSET;
     inputIndex = C.INDEX_UNSET;
     outputIndex = C.INDEX_UNSET;
+    waitingForFirstSyncFrame = true;
     decoderCounters.decoderInitCount++;
   }
 
@@ -501,6 +506,7 @@ protected void flushCodec() throws ExoPlaybackException {
     codecHotswapDeadlineMs = C.TIME_UNSET;
     inputIndex = C.INDEX_UNSET;
     outputIndex = C.INDEX_UNSET;
+    waitingForFirstSyncFrame = true;
     waitingForKeys = false;
     shouldSkipOutputBuffer = false;
     decodeOnlyPresentationTimestamps.clear();
@@ -630,6 +636,16 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
       }
       return false;
     }
+    if (waitingForFirstSyncFrame && !buffer.isKeyFrame()) {
+      buffer.clear();
+      if (codecReconfigurationState == RECONFIGURATION_STATE_QUEUE_PENDING) {
+        // The buffer we just cleared contained reconfiguration data. We need to re-write this
+        // data into a subsequent buffer (if there is one).
+        codecReconfigurationState = RECONFIGURATION_STATE_WRITE_PENDING;
+      }
+      return true;
+    }
+    waitingForFirstSyncFrame = false;
     boolean bufferEncrypted = buffer.isEncrypted();
     waitingForKeys = shouldWaitForKeys(bufferEncrypted);
     if (waitingForKeys) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecSelector.java b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecSelector.java
index ea8832c39c..bb946d76f9 100644
--- a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecSelector.java
+++ b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecSelector.java
@@ -29,9 +29,9 @@
   MediaCodecSelector DEFAULT = new MediaCodecSelector() {
 
     @Override
-    public MediaCodecInfo getDecoderInfo(String mimeType, boolean requiresSecureDecoder,
-        boolean requiresTunneling) throws DecoderQueryException {
-      return MediaCodecUtil.getDecoderInfo(mimeType, requiresSecureDecoder, requiresTunneling);
+    public MediaCodecInfo getDecoderInfo(String mimeType, boolean requiresSecureDecoder)
+        throws DecoderQueryException {
+      return MediaCodecUtil.getDecoderInfo(mimeType, requiresSecureDecoder);
     }
 
     @Override
@@ -46,13 +46,11 @@ public MediaCodecInfo getPassthroughDecoderInfo() throws DecoderQueryException {
    *
    * @param mimeType The mime type for which a decoder is required.
    * @param requiresSecureDecoder Whether a secure decoder is required.
-   * @param requiresTunneling Whether a decoder that supports tunneling is required.
-   * @return A {@link MediaCodecInfo} describing the decoder, or null if no suitable decoder
-   *     exists.
+   * @return A {@link MediaCodecInfo} describing the decoder, or null if no suitable decoder exists.
    * @throws DecoderQueryException Thrown if there was an error querying decoders.
    */
-  MediaCodecInfo getDecoderInfo(String mimeType, boolean requiresSecureDecoder,
-      boolean requiresTunneling) throws DecoderQueryException;
+  MediaCodecInfo getDecoderInfo(String mimeType, boolean requiresSecureDecoder)
+      throws DecoderQueryException;
 
   /**
    * Selects a decoder to instantiate for audio passthrough.
diff --git a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
index 14ba309790..a3a2543461 100644
--- a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
@@ -81,9 +81,8 @@ private MediaCodecUtil() {}
   /**
    * Optional call to warm the codec cache for a given mime type.
    * <p>
-   * Calling this method may speed up subsequent calls to
-   * {@link #getDecoderInfo(String, boolean, boolean)} and
-   * {@link #getDecoderInfos(String, boolean)}.
+   * Calling this method may speed up subsequent calls to {@link #getDecoderInfo(String, boolean)}
+   * and {@link #getDecoderInfos(String, boolean)}.
    *
    * @param mimeType The mime type.
    * @param secure Whether the decoder is required to support secure decryption. Always pass false
@@ -115,26 +114,14 @@ public static MediaCodecInfo getPassthroughDecoderInfo() {
    * @param mimeType The mime type.
    * @param secure Whether the decoder is required to support secure decryption. Always pass false
    *     unless secure decryption really is required.
-   * @param tunneling Whether the decoder is required to support tunneling. Always pass false unless
-   *     tunneling really is required.
    * @return A {@link MediaCodecInfo} describing the decoder, or null if no suitable decoder
    *     exists.
    * @throws DecoderQueryException If there was an error querying the available decoders.
    */
-  public static MediaCodecInfo getDecoderInfo(String mimeType, boolean secure, boolean tunneling)
+  public static MediaCodecInfo getDecoderInfo(String mimeType, boolean secure)
       throws DecoderQueryException {
     List<MediaCodecInfo> decoderInfos = getDecoderInfos(mimeType, secure);
-    if (tunneling) {
-      for (int i = 0; i < decoderInfos.size(); i++) {
-        MediaCodecInfo decoderInfo = decoderInfos.get(i);
-        if (decoderInfo.tunneling) {
-          return decoderInfo;
-        }
-      }
-      return null;
-    } else {
-      return decoderInfos.isEmpty() ? null : decoderInfos.get(0);
-    }
+    return decoderInfos.isEmpty() ? null : decoderInfos.get(0);
   }
 
   /**
@@ -305,7 +292,7 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
   public static int maxH264DecodableFrameSize() throws DecoderQueryException {
     if (maxH264DecodableFrameSize == -1) {
       int result = 0;
-      MediaCodecInfo decoderInfo = getDecoderInfo(MimeTypes.VIDEO_H264, false, false);
+      MediaCodecInfo decoderInfo = getDecoderInfo(MimeTypes.VIDEO_H264, false);
       if (decoderInfo != null) {
         for (CodecProfileLevel profileLevel : decoderInfo.getProfileLevels()) {
           result = Math.max(avcLevelToMaxFrameSize(profileLevel.level), result);
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoder.java b/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoder.java
index a73311f16b..9137bad4fd 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoder.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoder.java
@@ -21,21 +21,12 @@
 public interface MetadataDecoder {
 
   /**
-   * Checks whether the decoder supports a given mime type.
+   * Decodes a {@link Metadata} element from the provided input buffer.
    *
-   * @param mimeType A metadata mime type.
-   * @return Whether the mime type is supported.
-   */
-  boolean canDecode(String mimeType);
-
-  /**
-   * Decodes a metadata object from the provided binary data.
-   *
-   * @param data The raw binary data from which to decode the metadata.
-   * @param size The size of the input data.
+   * @param inputBuffer The input buffer to decode.
    * @return The decoded metadata object.
    * @throws MetadataDecoderException If a problem occurred decoding the data.
    */
-  Metadata decode(byte[] data, int size) throws MetadataDecoderException;
+  Metadata decode(MetadataInputBuffer inputBuffer) throws MetadataDecoderException;
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoderFactory.java b/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoderFactory.java
new file mode 100644
index 0000000000..414a8269d7
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoderFactory.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata;
+
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.metadata.emsg.EventMessageDecoder;
+import com.google.android.exoplayer2.metadata.id3.Id3Decoder;
+import com.google.android.exoplayer2.metadata.scte35.SpliceInfoDecoder;
+import com.google.android.exoplayer2.util.MimeTypes;
+
+/**
+ * A factory for {@link MetadataDecoder} instances.
+ */
+public interface MetadataDecoderFactory {
+
+  /**
+   * Returns whether the factory is able to instantiate a {@link MetadataDecoder} for the given
+   * {@link Format}.
+   *
+   * @param format The {@link Format}.
+   * @return Whether the factory can instantiate a suitable {@link MetadataDecoder}.
+   */
+  boolean supportsFormat(Format format);
+
+  /**
+   * Creates a {@link MetadataDecoder} for the given {@link Format}.
+   *
+   * @param format The {@link Format}.
+   * @return A new {@link MetadataDecoder}.
+   * @throws IllegalArgumentException If the {@link Format} is not supported.
+   */
+  MetadataDecoder createDecoder(Format format);
+
+  /**
+   * Default {@link MetadataDecoder} implementation.
+   * <p>
+   * The formats supported by this factory are:
+   * <ul>
+   * <li>ID3 ({@link Id3Decoder})</li>
+   * <li>EMSG ({@link EventMessageDecoder})</li>
+   * <li>SCTE-35 ({@link SpliceInfoDecoder})</li>
+   * </ul>
+   */
+  MetadataDecoderFactory DEFAULT = new MetadataDecoderFactory() {
+
+    @Override
+    public boolean supportsFormat(Format format) {
+      return getDecoderClass(format.sampleMimeType) != null;
+    }
+
+    @Override
+    public MetadataDecoder createDecoder(Format format) {
+      try {
+        Class<?> clazz = getDecoderClass(format.sampleMimeType);
+        if (clazz == null) {
+          throw new IllegalArgumentException("Attempted to create decoder for unsupported format");
+        }
+        return clazz.asSubclass(MetadataDecoder.class).getConstructor().newInstance();
+      } catch (Exception e) {
+        throw new IllegalStateException("Unexpected error instantiating decoder", e);
+      }
+    }
+
+    private Class<?> getDecoderClass(String mimeType) {
+      if (mimeType == null) {
+        return null;
+      }
+      try {
+        switch (mimeType) {
+          case MimeTypes.APPLICATION_ID3:
+            return Class.forName("com.google.android.exoplayer2.metadata.id3.Id3Decoder");
+          case MimeTypes.APPLICATION_EMSG:
+            return Class.forName("com.google.android.exoplayer2.metadata.emsg.EventMessageDecoder");
+          case MimeTypes.APPLICATION_SCTE35:
+            return Class.forName("com.google.android.exoplayer2.metadata.scte35.SpliceInfoDecoder");
+          default:
+            return null;
+        }
+      } catch (ClassNotFoundException e) {
+        return null;
+      }
+    }
+
+  };
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataInputBuffer.java b/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataInputBuffer.java
new file mode 100644
index 0000000000..a09b565653
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataInputBuffer.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata;
+
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+
+/**
+ * A {@link DecoderInputBuffer} for a {@link MetadataDecoder}.
+ */
+public final class MetadataInputBuffer extends DecoderInputBuffer {
+
+  /**
+   * An offset that must be added to the metadata's timestamps after it's been decoded, or
+   * {@link Format#OFFSET_SAMPLE_RELATIVE} if {@link #timeUs} should be added.
+   */
+  public long subsampleOffsetUs;
+
+  public MetadataInputBuffer() {
+    super(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_NORMAL);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java b/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
index ff1364610b..550a13771f 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
@@ -24,9 +24,7 @@
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
-import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.util.Assertions;
-import java.nio.ByteBuffer;
 
 /**
  * A renderer for metadata.
@@ -49,12 +47,13 @@
 
   private static final int MSG_INVOKE_RENDERER = 0;
 
-  private final MetadataDecoder metadataDecoder;
+  private final MetadataDecoderFactory decoderFactory;
   private final Output output;
   private final Handler outputHandler;
   private final FormatHolder formatHolder;
-  private final DecoderInputBuffer buffer;
+  private final MetadataInputBuffer buffer;
 
+  private MetadataDecoder decoder;
   private boolean inputStreamEnded;
   private long pendingMetadataTimestamp;
   private Metadata pendingMetadata;
@@ -66,21 +65,38 @@
    *     looper associated with the application's main thread, which can be obtained using
    *     {@link android.app.Activity#getMainLooper()}. Null may be passed if the output should be
    *     called directly on the player's internal rendering thread.
-   * @param metadataDecoder A decoder for the metadata.
    */
-  public MetadataRenderer(Output output, Looper outputLooper, MetadataDecoder metadataDecoder) {
+  public MetadataRenderer(Output output, Looper outputLooper) {
+    this(output, outputLooper, MetadataDecoderFactory.DEFAULT);
+  }
+
+  /**
+   * @param output The output.
+   * @param outputLooper The looper associated with the thread on which the output should be called.
+   *     If the output makes use of standard Android UI components, then this should normally be the
+   *     looper associated with the application's main thread, which can be obtained using
+   *     {@link android.app.Activity#getMainLooper()}. Null may be passed if the output should be
+   *     called directly on the player's internal rendering thread.
+   * @param decoderFactory A factory from which to obtain {@link MetadataDecoder} instances.
+   */
+  public MetadataRenderer(Output output, Looper outputLooper,
+      MetadataDecoderFactory decoderFactory) {
     super(C.TRACK_TYPE_METADATA);
     this.output = Assertions.checkNotNull(output);
     this.outputHandler = outputLooper == null ? null : new Handler(outputLooper, this);
-    this.metadataDecoder = Assertions.checkNotNull(metadataDecoder);
+    this.decoderFactory = Assertions.checkNotNull(decoderFactory);
     formatHolder = new FormatHolder();
-    buffer = new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_NORMAL);
+    buffer = new MetadataInputBuffer();
   }
 
   @Override
   public int supportsFormat(Format format) {
-    return metadataDecoder.canDecode(format.sampleMimeType) ? FORMAT_HANDLED
-        : FORMAT_UNSUPPORTED_TYPE;
+    return decoderFactory.supportsFormat(format) ? FORMAT_HANDLED : FORMAT_UNSUPPORTED_TYPE;
+  }
+
+  @Override
+  protected void onStreamChanged(Format[] formats) throws ExoPlaybackException {
+    decoder = decoderFactory.createDecoder(formats[0]);
   }
 
   @Override
@@ -97,12 +113,16 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
       if (result == C.RESULT_BUFFER_READ) {
         if (buffer.isEndOfStream()) {
           inputStreamEnded = true;
+        } else if (buffer.isDecodeOnly()) {
+          // Do nothing. Note this assumes that all metadata buffers can be decoded independently.
+          // If we ever need to support a metadata format where this is not the case, we'll need to
+          // pass the buffer to the decoder and discard the output.
         } else {
           pendingMetadataTimestamp = buffer.timeUs;
+          buffer.subsampleOffsetUs = formatHolder.format.subsampleOffsetUs;
+          buffer.flip();
           try {
-            buffer.flip();
-            ByteBuffer bufferData = buffer.data;
-            pendingMetadata = metadataDecoder.decode(bufferData.array(), bufferData.limit());
+            pendingMetadata = decoder.decode(buffer);
           } catch (MetadataDecoderException e) {
             throw ExoPlaybackException.createForRenderer(e, getIndex());
           }
@@ -119,6 +139,7 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
   @Override
   protected void onDisabled() {
     pendingMetadata = null;
+    decoder = null;
     super.onDisabled();
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java b/library/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java
new file mode 100644
index 0000000000..9d6d0af60c
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.emsg;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.util.Util;
+import java.util.Arrays;
+
+/**
+ * An Event Message (emsg) as defined in ISO 23009-1.
+ */
+public final class EventMessage implements Metadata.Entry {
+
+  /**
+   * The message scheme.
+   */
+  public final String schemeIdUri;
+
+  /**
+   * The value for the event.
+   */
+  public final String value;
+
+  /**
+   * The duration of the event in milliseconds.
+   */
+  public final long durationMs;
+
+  /**
+   * The instance identifier.
+   */
+  public final long id;
+
+  /**
+   * The body of the message.
+   */
+  public final byte[] messageData;
+
+  // Lazily initialized hashcode.
+  private int hashCode;
+
+  /**
+   *
+   * @param schemeIdUri The message scheme.
+   * @param value The value for the event.
+   * @param durationMs The duration of the event in milliseconds.
+   * @param id The instance identifier.
+   * @param messageData The body of the message.
+   */
+  public EventMessage(String schemeIdUri, String value, long durationMs, long id,
+      byte[] messageData) {
+    this.schemeIdUri = schemeIdUri;
+    this.value = value;
+    this.durationMs = durationMs;
+    this.id = id;
+    this.messageData = messageData;
+  }
+
+  /* package */ EventMessage(Parcel in) {
+    schemeIdUri = in.readString();
+    value = in.readString();
+    durationMs = in.readLong();
+    id = in.readLong();
+    messageData = in.createByteArray();
+  }
+
+  @Override
+  public int hashCode() {
+    if (hashCode == 0) {
+      int result = 17;
+      result = 31 * result + (schemeIdUri != null ? schemeIdUri.hashCode() : 0);
+      result = 31 * result + (value != null ? value.hashCode() : 0);
+      result = 31 * result + (int) (durationMs ^ (durationMs >>> 32));
+      result = 31 * result + (int) (id ^ (id >>> 32));
+      result = 31 * result + Arrays.hashCode(messageData);
+      hashCode = result;
+    }
+    return hashCode;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    EventMessage other = (EventMessage) obj;
+    return durationMs == other.durationMs && id == other.id
+        && Util.areEqual(schemeIdUri, other.schemeIdUri) && Util.areEqual(value, other.value)
+        && Arrays.equals(messageData, other.messageData);
+  }
+
+  // Parcelable implementation.
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(schemeIdUri);
+    dest.writeString(value);
+    dest.writeLong(durationMs);
+    dest.writeLong(id);
+    dest.writeByteArray(messageData);
+  }
+
+  public static final Parcelable.Creator<EventMessage> CREATOR =
+      new Parcelable.Creator<EventMessage>() {
+
+    @Override
+    public EventMessage createFromParcel(Parcel in) {
+      return new EventMessage(in);
+    }
+
+    @Override
+    public EventMessage[] newArray(int size) {
+      return new EventMessage[size];
+    }
+
+  };
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java b/library/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
new file mode 100644
index 0000000000..fd6996aa80
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.emsg;
+
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.MetadataDecoder;
+import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+/**
+ * Decodes Event Message (emsg) atoms, as defined in ISO 23009-1.
+ * <p>
+ * Atom data should be provided to the decoder without the full atom header (i.e. starting from the
+ * first byte of the scheme_id_uri field).
+ */
+public final class EventMessageDecoder implements MetadataDecoder {
+
+  @Override
+  public Metadata decode(MetadataInputBuffer inputBuffer) {
+    ByteBuffer buffer = inputBuffer.data;
+    byte[] data = buffer.array();
+    int size = buffer.limit();
+    ParsableByteArray emsgData = new ParsableByteArray(data, size);
+    String schemeIdUri = emsgData.readNullTerminatedString();
+    String value = emsgData.readNullTerminatedString();
+    long timescale = emsgData.readUnsignedInt();
+    emsgData.skipBytes(4); // presentation_time_delta
+    long durationMs = (emsgData.readUnsignedInt() * 1000) / timescale;
+    long id = emsgData.readUnsignedInt();
+    byte[] messageData = Arrays.copyOfRange(data, emsgData.getPosition(), size);
+    return new Metadata(new EventMessage(schemeIdUri, value, durationMs, id, messageData));
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterFrame.java b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterFrame.java
new file mode 100644
index 0000000000..c82f982aa7
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterFrame.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.id3;
+
+import android.os.Parcel;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.Util;
+import java.util.Arrays;
+
+/**
+ * Chapter information ID3 frame.
+ */
+public final class ChapterFrame extends Id3Frame {
+
+  public static final String ID = "CHAP";
+
+  public final String chapterId;
+  public final int startTimeMs;
+  public final int endTimeMs;
+  /**
+   * The byte offset of the start of the chapter, or {@link C#POSITION_UNSET} if not set.
+   */
+  public final long startOffset;
+  /**
+   * The byte offset of the end of the chapter, or {@link C#POSITION_UNSET} if not set.
+   */
+  public final long endOffset;
+  private final Id3Frame[] subFrames;
+
+  public ChapterFrame(String chapterId, int startTimeMs, int endTimeMs, long startOffset,
+      long endOffset, Id3Frame[] subFrames) {
+    super(ID);
+    this.chapterId = chapterId;
+    this.startTimeMs = startTimeMs;
+    this.endTimeMs = endTimeMs;
+    this.startOffset = startOffset;
+    this.endOffset = endOffset;
+    this.subFrames = subFrames;
+  }
+
+  /* package */ ChapterFrame(Parcel in) {
+    super(ID);
+    this.chapterId = in.readString();
+    this.startTimeMs = in.readInt();
+    this.endTimeMs = in.readInt();
+    this.startOffset = in.readLong();
+    this.endOffset = in.readLong();
+    int subFrameCount = in.readInt();
+    subFrames = new Id3Frame[subFrameCount];
+    for (int i = 0; i < subFrameCount; i++) {
+      subFrames[i] = in.readParcelable(Id3Frame.class.getClassLoader());
+    }
+  }
+
+  /**
+   * Returns the number of sub-frames.
+   */
+  public int getSubFrameCount() {
+    return subFrames.length;
+  }
+
+  /**
+   * Returns the sub-frame at {@code index}.
+   */
+  public Id3Frame getSubFrame(int index) {
+    return subFrames[index];
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    ChapterFrame other = (ChapterFrame) obj;
+    return startTimeMs == other.startTimeMs
+        && endTimeMs == other.endTimeMs
+        && startOffset == other.startOffset
+        && endOffset == other.endOffset
+        && Util.areEqual(chapterId, other.chapterId)
+        && Arrays.equals(subFrames, other.subFrames);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + startTimeMs;
+    result = 31 * result + endTimeMs;
+    result = 31 * result + (int) startOffset;
+    result = 31 * result + (int) endOffset;
+    result = 31 * result + (chapterId != null ? chapterId.hashCode() : 0);
+    return result;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(chapterId);
+    dest.writeInt(startTimeMs);
+    dest.writeInt(endTimeMs);
+    dest.writeLong(startOffset);
+    dest.writeLong(endOffset);
+    dest.writeInt(subFrames.length);
+    for (Id3Frame subFrame : subFrames) {
+      dest.writeParcelable(subFrame, 0);
+    }
+  }
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  public static final Creator<ChapterFrame> CREATOR = new Creator<ChapterFrame>() {
+
+    @Override
+    public ChapterFrame createFromParcel(Parcel in) {
+      return new ChapterFrame(in);
+    }
+
+    @Override
+    public ChapterFrame[] newArray(int size) {
+      return new ChapterFrame[size];
+    }
+
+  };
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrame.java b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrame.java
new file mode 100644
index 0000000000..d71d0863c7
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrame.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.id3;
+
+import android.os.Parcel;
+import com.google.android.exoplayer2.util.Util;
+import java.util.Arrays;
+
+/**
+ * Chapter table of contents ID3 frame.
+ */
+public final class ChapterTocFrame extends Id3Frame {
+
+  public static final String ID = "CTOC";
+
+  public final String elementId;
+  public final boolean isRoot;
+  public final boolean isOrdered;
+  public final String[] children;
+  private final Id3Frame[] subFrames;
+
+  public ChapterTocFrame(String elementId, boolean isRoot, boolean isOrdered, String[] children,
+      Id3Frame[] subFrames) {
+    super(ID);
+    this.elementId = elementId;
+    this.isRoot = isRoot;
+    this.isOrdered = isOrdered;
+    this.children = children;
+    this.subFrames = subFrames;
+  }
+
+  /* package */ ChapterTocFrame(Parcel in) {
+    super(ID);
+    this.elementId = in.readString();
+    this.isRoot = in.readByte() != 0;
+    this.isOrdered = in.readByte() != 0;
+    this.children = in.createStringArray();
+    int subFrameCount = in.readInt();
+    subFrames = new Id3Frame[subFrameCount];
+    for (int i = 0; i < subFrameCount; i++) {
+      subFrames[i] = in.readParcelable(Id3Frame.class.getClassLoader());
+    }
+  }
+
+  /**
+   * Returns the number of sub-frames.
+   */
+  public int getSubFrameCount() {
+    return subFrames.length;
+  }
+
+  /**
+   * Returns the sub-frame at {@code index}.
+   */
+  public Id3Frame getSubFrame(int index) {
+    return subFrames[index];
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    ChapterTocFrame other = (ChapterTocFrame) obj;
+    return isRoot == other.isRoot
+        && isOrdered == other.isOrdered
+        && Util.areEqual(elementId, other.elementId)
+        && Arrays.equals(children, other.children)
+        && Arrays.equals(subFrames, other.subFrames);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + (isRoot ? 1 : 0);
+    result = 31 * result + (isOrdered ? 1 : 0);
+    result = 31 * result + (elementId != null ? elementId.hashCode() : 0);
+    return result;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(elementId);
+    dest.writeByte((byte) (isRoot ? 1 : 0));
+    dest.writeByte((byte) (isOrdered ? 1 : 0));
+    dest.writeStringArray(children);
+    dest.writeInt(subFrames.length);
+    for (int i = 0; i < subFrames.length; i++) {
+      dest.writeParcelable(subFrames[i], 0);
+    }
+  }
+
+  public static final Creator<ChapterTocFrame> CREATOR = new Creator<ChapterTocFrame>() {
+
+    @Override
+    public ChapterTocFrame createFromParcel(Parcel in) {
+      return new ChapterTocFrame(in);
+    }
+
+    @Override
+    public ChapterTocFrame[] newArray(int size) {
+      return new ChapterTocFrame[size];
+    }
+
+  };
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
index d27c4f06e9..16059ccfbf 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
@@ -16,12 +16,14 @@
 package com.google.android.exoplayer2.metadata.id3;
 
 import android.util.Log;
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataDecoder;
-import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.io.UnsupportedEncodingException;
+import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -49,11 +51,18 @@
   private static final int ID3_TEXT_ENCODING_UTF_8 = 3;
 
   @Override
-  public boolean canDecode(String mimeType) {
-    return mimeType.equals(MimeTypes.APPLICATION_ID3);
+  public Metadata decode(MetadataInputBuffer inputBuffer) {
+    ByteBuffer buffer = inputBuffer.data;
+    return decode(buffer.array(), buffer.limit());
   }
 
-  @Override
+  /**
+   * Decodes ID3 tags.
+   *
+   * @param data The bytes to decode ID3 tags from.
+   * @param size Amount of bytes in {@code data} to read.
+   * @return A {@link Metadata} object containing the decoded ID3 tags.
+   */
   public Metadata decode(byte[] data, int size) {
     List<Id3Frame> id3Frames = new ArrayList<>();
     ParsableByteArray id3Data = new ParsableByteArray(data, size);
@@ -84,7 +93,8 @@ public Metadata decode(byte[] data, int size) {
 
     int frameHeaderSize = id3Header.majorVersion == 2 ? 6 : 10;
     while (id3Data.bytesLeft() >= frameHeaderSize) {
-      Id3Frame frame = decodeFrame(id3Header.majorVersion, id3Data, unsignedIntFrameSizeHack);
+      Id3Frame frame = decodeFrame(id3Header.majorVersion, id3Data, unsignedIntFrameSizeHack,
+          frameHeaderSize);
       if (frame != null) {
         id3Frames.add(frame);
       }
@@ -190,7 +200,7 @@ private static boolean validateV4Frames(ParsableByteArray id3Data,
   }
 
   private static Id3Frame decodeFrame(int majorVersion, ParsableByteArray id3Data,
-      boolean unsignedIntFrameSizeHack)  {
+      boolean unsignedIntFrameSizeHack, int frameHeaderSize) {
     int frameId0 = id3Data.readUnsignedByte();
     int frameId1 = id3Data.readUnsignedByte();
     int frameId2 = id3Data.readUnsignedByte();
@@ -266,6 +276,19 @@ private static Id3Frame decodeFrame(int majorVersion, ParsableByteArray id3Data,
       if (frameId0 == 'T' && frameId1 == 'X' && frameId2 == 'X'
           && (majorVersion == 2 || frameId3 == 'X')) {
         frame = decodeTxxxFrame(id3Data, frameSize);
+      } else if (frameId0 == 'T') {
+        String id = majorVersion == 2
+            ? String.format(Locale.US, "%c%c%c", frameId0, frameId1, frameId2)
+            : String.format(Locale.US, "%c%c%c%c", frameId0, frameId1, frameId2, frameId3);
+        frame = decodeTextInformationFrame(id3Data, frameSize, id);
+      } else if (frameId0 == 'W' && frameId1 == 'X' && frameId2 == 'X'
+          && (majorVersion == 2 || frameId3 == 'X')) {
+        frame = decodeWxxxFrame(id3Data, frameSize);
+      } else if (frameId0 == 'W') {
+        String id = majorVersion == 2
+            ? String.format(Locale.US, "%c%c%c", frameId0, frameId1, frameId2)
+            : String.format(Locale.US, "%c%c%c%c", frameId0, frameId1, frameId2, frameId3);
+        frame = decodeUrlLinkFrame(id3Data, frameSize, id);
       } else if (frameId0 == 'P' && frameId1 == 'R' && frameId2 == 'I' && frameId3 == 'V') {
         frame = decodePrivFrame(id3Data, frameSize);
       } else if (frameId0 == 'G' && frameId1 == 'E' && frameId2 == 'O'
@@ -274,14 +297,15 @@ private static Id3Frame decodeFrame(int majorVersion, ParsableByteArray id3Data,
       } else if (majorVersion == 2 ? (frameId0 == 'P' && frameId1 == 'I' && frameId2 == 'C')
           : (frameId0 == 'A' && frameId1 == 'P' && frameId2 == 'I' && frameId3 == 'C')) {
         frame = decodeApicFrame(id3Data, frameSize, majorVersion);
-      } else if (frameId0 == 'T') {
-        String id = majorVersion == 2
-            ? String.format(Locale.US, "%c%c%c", frameId0, frameId1, frameId2)
-            : String.format(Locale.US, "%c%c%c%c", frameId0, frameId1, frameId2, frameId3);
-        frame = decodeTextInformationFrame(id3Data, frameSize, id);
       } else if (frameId0 == 'C' && frameId1 == 'O' && frameId2 == 'M'
           && (frameId3 == 'M' || majorVersion == 2)) {
         frame = decodeCommentFrame(id3Data, frameSize);
+      } else if (frameId0 == 'C' && frameId1 == 'H' && frameId2 == 'A' && frameId3 == 'P') {
+        frame = decodeChapterFrame(id3Data, frameSize, majorVersion, unsignedIntFrameSizeHack,
+            frameHeaderSize);
+      } else if (frameId0 == 'C' && frameId1 == 'T' && frameId2 == 'O' && frameId3 == 'C') {
+        frame = decodeChapterTOCFrame(id3Data, frameSize, majorVersion, unsignedIntFrameSizeHack,
+            frameHeaderSize);
       } else {
         String id = majorVersion == 2
             ? String.format(Locale.US, "%c%c%c", frameId0, frameId1, frameId2)
@@ -297,7 +321,7 @@ private static Id3Frame decodeFrame(int majorVersion, ParsableByteArray id3Data,
     }
   }
 
-  private static TxxxFrame decodeTxxxFrame(ParsableByteArray id3Data, int frameSize)
+  private static TextInformationFrame decodeTxxxFrame(ParsableByteArray id3Data, int frameSize)
       throws UnsupportedEncodingException {
     int encoding = id3Data.readUnsignedByte();
     String charset = getCharsetName(encoding);
@@ -308,11 +332,74 @@ private static TxxxFrame decodeTxxxFrame(ParsableByteArray id3Data, int frameSiz
     int descriptionEndIndex = indexOfEos(data, 0, encoding);
     String description = new String(data, 0, descriptionEndIndex, charset);
 
+    String value;
     int valueStartIndex = descriptionEndIndex + delimiterLength(encoding);
-    int valueEndIndex = indexOfEos(data, valueStartIndex, encoding);
-    String value = new String(data, valueStartIndex, valueEndIndex - valueStartIndex, charset);
+    if (valueStartIndex < data.length) {
+      int valueEndIndex = indexOfEos(data, valueStartIndex, encoding);
+      value = new String(data, valueStartIndex, valueEndIndex - valueStartIndex, charset);
+    } else {
+      value = "";
+    }
 
-    return new TxxxFrame(description, value);
+    return new TextInformationFrame("TXXX", description, value);
+  }
+
+  private static TextInformationFrame decodeTextInformationFrame(ParsableByteArray id3Data,
+      int frameSize, String id) throws UnsupportedEncodingException {
+    if (frameSize <= 1) {
+      // Frame is empty or contains only the text encoding byte.
+      return new TextInformationFrame(id, null, "");
+    }
+
+    int encoding = id3Data.readUnsignedByte();
+    String charset = getCharsetName(encoding);
+
+    byte[] data = new byte[frameSize - 1];
+    id3Data.readBytes(data, 0, frameSize - 1);
+
+    int valueEndIndex = indexOfEos(data, 0, encoding);
+    String value = new String(data, 0, valueEndIndex, charset);
+
+    return new TextInformationFrame(id, null, value);
+  }
+
+  private static UrlLinkFrame decodeWxxxFrame(ParsableByteArray id3Data, int frameSize)
+      throws UnsupportedEncodingException {
+    int encoding = id3Data.readUnsignedByte();
+    String charset = getCharsetName(encoding);
+
+    byte[] data = new byte[frameSize - 1];
+    id3Data.readBytes(data, 0, frameSize - 1);
+
+    int descriptionEndIndex = indexOfEos(data, 0, encoding);
+    String description = new String(data, 0, descriptionEndIndex, charset);
+
+    String url;
+    int urlStartIndex = descriptionEndIndex + delimiterLength(encoding);
+    if (urlStartIndex < data.length) {
+      int urlEndIndex = indexOfZeroByte(data, urlStartIndex);
+      url = new String(data, urlStartIndex, urlEndIndex - urlStartIndex, "ISO-8859-1");
+    } else {
+      url = "";
+    }
+
+    return new UrlLinkFrame("WXXX", description, url);
+  }
+
+  private static UrlLinkFrame decodeUrlLinkFrame(ParsableByteArray id3Data, int frameSize,
+      String id) throws UnsupportedEncodingException {
+    if (frameSize == 0) {
+      // Frame is empty.
+      return new UrlLinkFrame(id, null, "");
+    }
+
+    byte[] data = new byte[frameSize];
+    id3Data.readBytes(data, 0, frameSize);
+
+    int urlEndIndex = indexOfZeroByte(data, 0);
+    String url = new String(data, 0, urlEndIndex, "ISO-8859-1");
+
+    return new UrlLinkFrame(id, null, url);
   }
 
   private static PrivFrame decodePrivFrame(ParsableByteArray id3Data, int frameSize)
@@ -408,25 +495,88 @@ private static CommentFrame decodeCommentFrame(ParsableByteArray id3Data, int fr
     int descriptionEndIndex = indexOfEos(data, 0, encoding);
     String description = new String(data, 0, descriptionEndIndex, charset);
 
+    String text;
     int textStartIndex = descriptionEndIndex + delimiterLength(encoding);
-    int textEndIndex = indexOfEos(data, textStartIndex, encoding);
-    String text = new String(data, textStartIndex, textEndIndex - textStartIndex, charset);
+    if (textStartIndex < data.length) {
+      int textEndIndex = indexOfEos(data, textStartIndex, encoding);
+      text = new String(data, textStartIndex, textEndIndex - textStartIndex, charset);
+    } else {
+      text = "";
+    }
 
     return new CommentFrame(language, description, text);
   }
 
-  private static TextInformationFrame decodeTextInformationFrame(ParsableByteArray id3Data,
-      int frameSize, String id) throws UnsupportedEncodingException {
-    int encoding = id3Data.readUnsignedByte();
-    String charset = getCharsetName(encoding);
+  private static ChapterFrame decodeChapterFrame(ParsableByteArray id3Data, int frameSize,
+      int majorVersion, boolean unsignedIntFrameSizeHack, int frameHeaderSize)
+      throws UnsupportedEncodingException {
+    int framePosition = id3Data.getPosition();
+    int chapterIdEndIndex = indexOfZeroByte(id3Data.data, framePosition);
+    String chapterId = new String(id3Data.data, framePosition, chapterIdEndIndex - framePosition,
+        "ISO-8859-1");
+    id3Data.setPosition(chapterIdEndIndex + 1);
+
+    int startTime = id3Data.readInt();
+    int endTime = id3Data.readInt();
+    long startOffset = id3Data.readUnsignedInt();
+    if (startOffset == 0xFFFFFFFFL) {
+      startOffset = C.POSITION_UNSET;
+    }
+    long endOffset = id3Data.readUnsignedInt();
+    if (endOffset == 0xFFFFFFFFL) {
+      endOffset = C.POSITION_UNSET;
+    }
 
-    byte[] data = new byte[frameSize - 1];
-    id3Data.readBytes(data, 0, frameSize - 1);
+    ArrayList<Id3Frame> subFrames = new ArrayList<>();
+    int limit = framePosition + frameSize;
+    while (id3Data.getPosition() < limit) {
+      Id3Frame frame = decodeFrame(majorVersion, id3Data, unsignedIntFrameSizeHack,
+          frameHeaderSize);
+      if (frame != null) {
+        subFrames.add(frame);
+      }
+    }
 
-    int descriptionEndIndex = indexOfEos(data, 0, encoding);
-    String description = new String(data, 0, descriptionEndIndex, charset);
+    Id3Frame[] subFrameArray = new Id3Frame[subFrames.size()];
+    subFrames.toArray(subFrameArray);
+    return new ChapterFrame(chapterId, startTime, endTime, startOffset, endOffset, subFrameArray);
+  }
+
+  private static ChapterTocFrame decodeChapterTOCFrame(ParsableByteArray id3Data, int frameSize,
+      int majorVersion, boolean unsignedIntFrameSizeHack, int frameHeaderSize)
+      throws UnsupportedEncodingException {
+    int framePosition = id3Data.getPosition();
+    int elementIdEndIndex = indexOfZeroByte(id3Data.data, framePosition);
+    String elementId = new String(id3Data.data, framePosition, elementIdEndIndex - framePosition,
+        "ISO-8859-1");
+    id3Data.setPosition(elementIdEndIndex + 1);
+
+    int ctocFlags = id3Data.readUnsignedByte();
+    boolean isRoot = (ctocFlags & 0x0002) != 0;
+    boolean isOrdered = (ctocFlags & 0x0001) != 0;
+
+    int childCount = id3Data.readUnsignedByte();
+    String[] children = new String[childCount];
+    for (int i = 0; i < childCount; i++) {
+      int startIndex = id3Data.getPosition();
+      int endIndex = indexOfZeroByte(id3Data.data, startIndex);
+      children[i] = new String(id3Data.data, startIndex, endIndex - startIndex, "ISO-8859-1");
+      id3Data.setPosition(endIndex + 1);
+    }
 
-    return new TextInformationFrame(id, description);
+    ArrayList<Id3Frame> subFrames = new ArrayList<>();
+    int limit = framePosition + frameSize;
+    while (id3Data.getPosition() < limit) {
+      Id3Frame frame = decodeFrame(majorVersion, id3Data, unsignedIntFrameSizeHack,
+          frameHeaderSize);
+      if (frame != null) {
+        subFrames.add(frame);
+      }
+    }
+
+    Id3Frame[] subFrameArray = new Id3Frame[subFrames.size()];
+    subFrames.toArray(subFrameArray);
+    return new ChapterTocFrame(elementId, isRoot, isOrdered, children, subFrameArray);
   }
 
   private static BinaryFrame decodeBinaryFrame(ParsableByteArray id3Data, int frameSize,
@@ -458,6 +608,7 @@ private static int removeUnsynchronization(ParsableByteArray data, int length) {
 
   /**
    * Maps encoding byte from ID3v2 frame to a Charset.
+   *
    * @param encodingByte The value of encoding byte from ID3v2 frame.
    * @return Charset name.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/TextInformationFrame.java b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/TextInformationFrame.java
index b8c061fd0a..6221062e33 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/TextInformationFrame.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/TextInformationFrame.java
@@ -20,20 +20,23 @@
 import com.google.android.exoplayer2.util.Util;
 
 /**
- * Text information ("T000" - "TZZZ", excluding "TXXX") ID3 frame.
+ * Text information ID3 frame.
  */
 public final class TextInformationFrame extends Id3Frame {
 
   public final String description;
+  public final String value;
 
-  public TextInformationFrame(String id, String description) {
+  public TextInformationFrame(String id, String description, String value) {
     super(id);
     this.description = description;
+    this.value = value;
   }
 
   /* package */ TextInformationFrame(Parcel in) {
     super(in.readString());
     description = in.readString();
+    value = in.readString();
   }
 
   @Override
@@ -45,7 +48,8 @@ public boolean equals(Object obj) {
       return false;
     }
     TextInformationFrame other = (TextInformationFrame) obj;
-    return id.equals(other.id) && Util.areEqual(description, other.description);
+    return id.equals(other.id) && Util.areEqual(description, other.description)
+        && Util.areEqual(value, other.value);
   }
 
   @Override
@@ -53,6 +57,7 @@ public int hashCode() {
     int result = 17;
     result = 31 * result + id.hashCode();
     result = 31 * result + (description != null ? description.hashCode() : 0);
+    result = 31 * result + (value != null ? value.hashCode() : 0);
     return result;
   }
 
@@ -60,6 +65,7 @@ public int hashCode() {
   public void writeToParcel(Parcel dest, int flags) {
     dest.writeString(id);
     dest.writeString(description);
+    dest.writeString(value);
   }
 
   public static final Parcelable.Creator<TextInformationFrame> CREATOR =
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/TxxxFrame.java b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/UrlLinkFrame.java
similarity index 55%
rename from library/src/main/java/com/google/android/exoplayer2/metadata/id3/TxxxFrame.java
rename to library/src/main/java/com/google/android/exoplayer2/metadata/id3/UrlLinkFrame.java
index 5c24e70ef4..2148b921e1 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/TxxxFrame.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/UrlLinkFrame.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 The Android Open Source Project
+ * Copyright (C) 2017 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,25 +20,23 @@
 import com.google.android.exoplayer2.util.Util;
 
 /**
- * TXXX (User defined text information) ID3 frame.
+ * Url link ID3 frame.
  */
-public final class TxxxFrame extends Id3Frame {
-
-  public static final String ID = "TXXX";
+public final class UrlLinkFrame extends Id3Frame {
 
   public final String description;
-  public final String value;
+  public final String url;
 
-  public TxxxFrame(String description, String value) {
-    super(ID);
+  public UrlLinkFrame(String id, String description, String url) {
+    super(id);
     this.description = description;
-    this.value = value;
+    this.url = url;
   }
 
-  /* package */ TxxxFrame(Parcel in) {
-    super(ID);
+  /* package */ UrlLinkFrame(Parcel in) {
+    super(in.readString());
     description = in.readString();
-    value = in.readString();
+    url = in.readString();
   }
 
   @Override
@@ -49,36 +47,40 @@ public boolean equals(Object obj) {
     if (obj == null || getClass() != obj.getClass()) {
       return false;
     }
-    TxxxFrame other = (TxxxFrame) obj;
-    return Util.areEqual(description, other.description) && Util.areEqual(value, other.value);
+    UrlLinkFrame other = (UrlLinkFrame) obj;
+    return id.equals(other.id) && Util.areEqual(description, other.description)
+        && Util.areEqual(url, other.url);
   }
 
   @Override
   public int hashCode() {
     int result = 17;
+    result = 31 * result + id.hashCode();
     result = 31 * result + (description != null ? description.hashCode() : 0);
-    result = 31 * result + (value != null ? value.hashCode() : 0);
+    result = 31 * result + (url != null ? url.hashCode() : 0);
     return result;
   }
 
   @Override
   public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(id);
     dest.writeString(description);
-    dest.writeString(value);
+    dest.writeString(url);
   }
 
-  public static final Parcelable.Creator<TxxxFrame> CREATOR = new Parcelable.Creator<TxxxFrame>() {
+  public static final Parcelable.Creator<UrlLinkFrame> CREATOR =
+      new Parcelable.Creator<UrlLinkFrame>() {
 
-    @Override
-    public TxxxFrame createFromParcel(Parcel in) {
-      return new TxxxFrame(in);
-    }
+        @Override
+        public UrlLinkFrame createFromParcel(Parcel in) {
+          return new UrlLinkFrame(in);
+        }
 
-    @Override
-    public TxxxFrame[] newArray(int size) {
-      return new TxxxFrame[size];
-    }
+        @Override
+        public UrlLinkFrame[] newArray(int size) {
+          return new UrlLinkFrame[size];
+        }
 
-  };
+      };
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/PrivateCommand.java b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/PrivateCommand.java
index f75a1b46a4..beb4cb9b88 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/PrivateCommand.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/PrivateCommand.java
@@ -26,7 +26,6 @@
 
   public final long ptsAdjustment;
   public final long identifier;
-
   public final byte[] commandBytes;
 
   private PrivateCommand(long identifier, byte[] commandBytes, long ptsAdjustment) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoder.java b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoder.java
index 5af0f25481..58c23d253a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoder.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoder.java
@@ -15,13 +15,14 @@
  */
 package com.google.android.exoplayer2.metadata.scte35;
 
-import android.text.TextUtils;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataDecoder;
 import com.google.android.exoplayer2.metadata.MetadataDecoderException;
-import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
+import java.nio.ByteBuffer;
 
 /**
  * Decodes splice info sections and produces splice commands.
@@ -37,18 +38,25 @@
   private final ParsableByteArray sectionData;
   private final ParsableBitArray sectionHeader;
 
+  private TimestampAdjuster timestampAdjuster;
+
   public SpliceInfoDecoder() {
     sectionData = new ParsableByteArray();
     sectionHeader = new ParsableBitArray();
   }
 
   @Override
-  public boolean canDecode(String mimeType) {
-    return TextUtils.equals(mimeType, MimeTypes.APPLICATION_SCTE35);
-  }
+  public Metadata decode(MetadataInputBuffer inputBuffer) throws MetadataDecoderException {
+    // Internal timestamps adjustment.
+    if (timestampAdjuster == null
+        || inputBuffer.subsampleOffsetUs != timestampAdjuster.getTimestampOffsetUs()) {
+      timestampAdjuster = new TimestampAdjuster(inputBuffer.timeUs);
+      timestampAdjuster.adjustSampleTimestamp(inputBuffer.timeUs - inputBuffer.subsampleOffsetUs);
+    }
 
-  @Override
-  public Metadata decode(byte[] data, int size) throws MetadataDecoderException {
+    ByteBuffer buffer = inputBuffer.data;
+    byte[] data = buffer.array();
+    int size = buffer.limit();
     sectionData.reset(data, size);
     sectionHeader.reset(data, size);
     // table_id(8), section_syntax_indicator(1), private_indicator(1), reserved(2),
@@ -71,10 +79,11 @@ public Metadata decode(byte[] data, int size) throws MetadataDecoderException {
         command = SpliceScheduleCommand.parseFromSection(sectionData);
         break;
       case TYPE_SPLICE_INSERT:
-        command = SpliceInsertCommand.parseFromSection(sectionData, ptsAdjustment);
+        command = SpliceInsertCommand.parseFromSection(sectionData, ptsAdjustment,
+            timestampAdjuster);
         break;
       case TYPE_TIME_SIGNAL:
-        command = TimeSignalCommand.parseFromSection(sectionData, ptsAdjustment);
+        command = TimeSignalCommand.parseFromSection(sectionData, ptsAdjustment, timestampAdjuster);
         break;
       case TYPE_PRIVATE_COMMAND:
         command = PrivateCommand.parseFromSection(sectionData, spliceCommandLength, ptsAdjustment);
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInsertCommand.java b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInsertCommand.java
index 1e025aeb35..7ce8b47e2a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInsertCommand.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInsertCommand.java
@@ -19,6 +19,7 @@
 import android.os.Parcelable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -34,6 +35,7 @@
   public final boolean programSpliceFlag;
   public final boolean spliceImmediateFlag;
   public final long programSplicePts;
+  public final long programSplicePlaybackPositionUs;
   public final List<ComponentSplice> componentSpliceList;
   public final boolean autoReturn;
   public final long breakDuration;
@@ -43,14 +45,16 @@
 
   private SpliceInsertCommand(long spliceEventId, boolean spliceEventCancelIndicator,
       boolean outOfNetworkIndicator, boolean programSpliceFlag, boolean spliceImmediateFlag,
-      long programSplicePts, List<ComponentSplice> componentSpliceList, boolean autoReturn,
-      long breakDuration, int uniqueProgramId, int availNum, int availsExpected) {
+      long programSplicePts, long programSplicePlaybackPositionUs,
+      List<ComponentSplice> componentSpliceList, boolean autoReturn, long breakDuration,
+      int uniqueProgramId, int availNum, int availsExpected) {
     this.spliceEventId = spliceEventId;
     this.spliceEventCancelIndicator = spliceEventCancelIndicator;
     this.outOfNetworkIndicator = outOfNetworkIndicator;
     this.programSpliceFlag = programSpliceFlag;
     this.spliceImmediateFlag = spliceImmediateFlag;
     this.programSplicePts = programSplicePts;
+    this.programSplicePlaybackPositionUs = programSplicePlaybackPositionUs;
     this.componentSpliceList = Collections.unmodifiableList(componentSpliceList);
     this.autoReturn = autoReturn;
     this.breakDuration = breakDuration;
@@ -66,6 +70,7 @@ private SpliceInsertCommand(Parcel in) {
     programSpliceFlag = in.readByte() == 1;
     spliceImmediateFlag = in.readByte() == 1;
     programSplicePts = in.readLong();
+    programSplicePlaybackPositionUs = in.readLong();
     int componentSpliceListSize = in.readInt();
     List<ComponentSplice> componentSpliceList = new ArrayList<>(componentSpliceListSize);
     for (int i = 0; i < componentSpliceListSize; i++) {
@@ -80,7 +85,7 @@ private SpliceInsertCommand(Parcel in) {
   }
 
   /* package */ static SpliceInsertCommand parseFromSection(ParsableByteArray sectionData,
-      long ptsAdjustment) {
+      long ptsAdjustment, TimestampAdjuster timestampAdjuster) {
     long spliceEventId = sectionData.readUnsignedInt();
     // splice_event_cancel_indicator(1), reserved(7).
     boolean spliceEventCancelIndicator = (sectionData.readUnsignedByte() & 0x80) != 0;
@@ -88,7 +93,7 @@ private SpliceInsertCommand(Parcel in) {
     boolean programSpliceFlag = false;
     boolean spliceImmediateFlag = false;
     long programSplicePts = C.TIME_UNSET;
-    ArrayList<ComponentSplice> componentSplices = new ArrayList<>();
+    List<ComponentSplice> componentSplices = Collections.emptyList();
     int uniqueProgramId = 0;
     int availNum = 0;
     int availsExpected = 0;
@@ -112,7 +117,8 @@ private SpliceInsertCommand(Parcel in) {
           if (!spliceImmediateFlag) {
             componentSplicePts = TimeSignalCommand.parseSpliceTime(sectionData, ptsAdjustment);
           }
-          componentSplices.add(new ComponentSplice(componentTag, componentSplicePts));
+          componentSplices.add(new ComponentSplice(componentTag, componentSplicePts,
+              timestampAdjuster.adjustTsTimestamp(componentSplicePts)));
         }
       }
       if (durationFlag) {
@@ -125,7 +131,8 @@ private SpliceInsertCommand(Parcel in) {
       availsExpected = sectionData.readUnsignedByte();
     }
     return new SpliceInsertCommand(spliceEventId, spliceEventCancelIndicator, outOfNetworkIndicator,
-        programSpliceFlag, spliceImmediateFlag, programSplicePts, componentSplices, autoReturn,
+        programSpliceFlag, spliceImmediateFlag, programSplicePts,
+        timestampAdjuster.adjustTsTimestamp(programSplicePts), componentSplices, autoReturn,
         duration, uniqueProgramId, availNum, availsExpected);
   }
 
@@ -136,19 +143,23 @@ private SpliceInsertCommand(Parcel in) {
 
     public final int componentTag;
     public final long componentSplicePts;
+    public final long componentSplicePlaybackPositionUs;
 
-    private ComponentSplice(int componentTag, long componentSplicePts) {
+    private ComponentSplice(int componentTag, long componentSplicePts,
+        long componentSplicePlaybackPositionUs) {
       this.componentTag = componentTag;
       this.componentSplicePts = componentSplicePts;
+      this.componentSplicePlaybackPositionUs = componentSplicePlaybackPositionUs;
     }
 
     public void writeToParcel(Parcel dest) {
       dest.writeInt(componentTag);
       dest.writeLong(componentSplicePts);
+      dest.writeLong(componentSplicePlaybackPositionUs);
     }
 
     public static ComponentSplice createFromParcel(Parcel in) {
-      return new ComponentSplice(in.readInt(), in.readLong());
+      return new ComponentSplice(in.readInt(), in.readLong(), in.readLong());
     }
 
   }
@@ -163,6 +174,7 @@ public void writeToParcel(Parcel dest, int flags) {
     dest.writeByte((byte) (programSpliceFlag ? 1 : 0));
     dest.writeByte((byte) (spliceImmediateFlag ? 1 : 0));
     dest.writeLong(programSplicePts);
+    dest.writeLong(programSplicePlaybackPositionUs);
     int componentSpliceListSize = componentSpliceList.size();
     dest.writeInt(componentSpliceListSize);
     for (int i = 0; i < componentSpliceListSize; i++) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/TimeSignalCommand.java b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/TimeSignalCommand.java
index c31f4dedc8..f756b72d6d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/TimeSignalCommand.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/TimeSignalCommand.java
@@ -18,6 +18,7 @@
 import android.os.Parcel;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 
 /**
  * Represents a time signal command as defined in SCTE35, Section 9.3.4.
@@ -25,14 +26,18 @@
 public final class TimeSignalCommand extends SpliceCommand {
 
   public final long ptsTime;
+  public final long playbackPositionUs;
 
-  private TimeSignalCommand(long ptsTime) {
+  private TimeSignalCommand(long ptsTime, long playbackPositionUs) {
     this.ptsTime = ptsTime;
+    this.playbackPositionUs = playbackPositionUs;
   }
 
   /* package */ static TimeSignalCommand parseFromSection(ParsableByteArray sectionData,
-      long ptsAdjustment) {
-    return new TimeSignalCommand(parseSpliceTime(sectionData, ptsAdjustment));
+      long ptsAdjustment, TimestampAdjuster timestampAdjuster) {
+    long ptsTime = parseSpliceTime(sectionData, ptsAdjustment);
+    long playbackPositionUs = timestampAdjuster.adjustTsTimestamp(ptsTime);
+    return new TimeSignalCommand(ptsTime, playbackPositionUs);
   }
 
   /**
@@ -61,6 +66,7 @@ private TimeSignalCommand(long ptsTime) {
   @Override
   public void writeToParcel(Parcel dest, int flags) {
     dest.writeLong(ptsTime);
+    dest.writeLong(playbackPositionUs);
   }
 
   public static final Creator<TimeSignalCommand> CREATOR =
@@ -68,7 +74,7 @@ public void writeToParcel(Parcel dest, int flags) {
 
     @Override
     public TimeSignalCommand createFromParcel(Parcel in) {
-      return new TimeSignalCommand(in.readLong());
+      return new TimeSignalCommand(in.readLong(), in.readLong());
     }
 
     @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java
new file mode 100644
index 0000000000..b18eabf493
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java
@@ -0,0 +1,268 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.FormatHolder;
+import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.util.Assertions;
+import java.io.IOException;
+
+/**
+ * Wraps a {@link MediaPeriod} and clips its {@link SampleStream}s to provide a subsequence of their
+ * samples.
+ */
+public final class ClippingMediaPeriod implements MediaPeriod, MediaPeriod.Callback {
+
+  /**
+   * The {@link MediaPeriod} wrapped by this clipping media period.
+   */
+  public final MediaPeriod mediaPeriod;
+
+  private MediaPeriod.Callback callback;
+  private long startUs;
+  private long endUs;
+  private ClippingSampleStream[] sampleStreams;
+  private boolean pendingInitialDiscontinuity;
+
+  /**
+   * Creates a new clipping media period that provides a clipped view of the specified
+   * {@link MediaPeriod}'s sample streams.
+   * <p>
+   * The clipping start/end positions must be specified by calling {@link #setClipping(long, long)}
+   * on the playback thread before preparation completes.
+   *
+   * @param mediaPeriod The media period to clip.
+   */
+  public ClippingMediaPeriod(MediaPeriod mediaPeriod) {
+    this.mediaPeriod = mediaPeriod;
+    startUs = C.TIME_UNSET;
+    endUs = C.TIME_UNSET;
+    sampleStreams = new ClippingSampleStream[0];
+  }
+
+  /**
+   * Sets the clipping start/end times for this period, in microseconds.
+   *
+   * @param startUs The clipping start time, in microseconds.
+   * @param endUs The clipping end time, in microseconds, or {@link C#TIME_END_OF_SOURCE} to
+   *     indicate the end of the period.
+   */
+  public void setClipping(long startUs, long endUs) {
+    this.startUs = startUs;
+    this.endUs = endUs;
+  }
+
+  @Override
+  public void prepare(MediaPeriod.Callback callback) {
+    this.callback = callback;
+    mediaPeriod.prepare(this);
+  }
+
+  @Override
+  public void maybeThrowPrepareError() throws IOException {
+    mediaPeriod.maybeThrowPrepareError();
+  }
+
+  @Override
+  public TrackGroupArray getTrackGroups() {
+    return mediaPeriod.getTrackGroups();
+  }
+
+  @Override
+  public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
+      SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
+    sampleStreams = new ClippingSampleStream[streams.length];
+    SampleStream[] internalStreams = new SampleStream[streams.length];
+    for (int i = 0; i < streams.length; i++) {
+      sampleStreams[i] = (ClippingSampleStream) streams[i];
+      internalStreams[i] = sampleStreams[i] != null ? sampleStreams[i].stream : null;
+    }
+    long enablePositionUs = mediaPeriod.selectTracks(selections, mayRetainStreamFlags,
+        internalStreams, streamResetFlags, positionUs + startUs);
+    Assertions.checkState(enablePositionUs == positionUs + startUs
+        || (enablePositionUs >= startUs
+        && (endUs == C.TIME_END_OF_SOURCE || enablePositionUs <= endUs)));
+    for (int i = 0; i < streams.length; i++) {
+      if (internalStreams[i] == null) {
+        sampleStreams[i] = null;
+      } else if (streams[i] == null || sampleStreams[i].stream != internalStreams[i]) {
+        sampleStreams[i] = new ClippingSampleStream(this, internalStreams[i], startUs, endUs,
+            pendingInitialDiscontinuity);
+      }
+      streams[i] = sampleStreams[i];
+    }
+    return enablePositionUs - startUs;
+  }
+
+  @Override
+  public long readDiscontinuity() {
+    if (pendingInitialDiscontinuity) {
+      for (ClippingSampleStream sampleStream : sampleStreams) {
+        if (sampleStream != null) {
+          sampleStream.clearPendingDiscontinuity();
+        }
+      }
+      pendingInitialDiscontinuity = false;
+      // Always read an initial discontinuity, using mediaPeriod's discontinuity if set.
+      long discontinuityUs = readDiscontinuity();
+      return discontinuityUs != C.TIME_UNSET ? discontinuityUs : 0;
+    }
+    long discontinuityUs = mediaPeriod.readDiscontinuity();
+    if (discontinuityUs == C.TIME_UNSET) {
+      return C.TIME_UNSET;
+    }
+    Assertions.checkState(discontinuityUs >= startUs);
+    Assertions.checkState(endUs == C.TIME_END_OF_SOURCE || discontinuityUs <= endUs);
+    return discontinuityUs - startUs;
+  }
+
+  @Override
+  public long getBufferedPositionUs() {
+    long bufferedPositionUs = mediaPeriod.getBufferedPositionUs();
+    if (bufferedPositionUs == C.TIME_END_OF_SOURCE
+        || (endUs != C.TIME_END_OF_SOURCE && bufferedPositionUs >= endUs)) {
+      return C.TIME_END_OF_SOURCE;
+    }
+    return Math.max(0, bufferedPositionUs - startUs);
+  }
+
+  @Override
+  public long seekToUs(long positionUs) {
+    for (ClippingSampleStream sampleStream : sampleStreams) {
+      if (sampleStream != null) {
+        sampleStream.clearSentEos();
+      }
+    }
+    long seekUs = mediaPeriod.seekToUs(positionUs + startUs);
+    Assertions.checkState(seekUs == positionUs + startUs
+        || (seekUs >= startUs && (endUs == C.TIME_END_OF_SOURCE || seekUs <= endUs)));
+    return seekUs - startUs;
+  }
+
+  @Override
+  public long getNextLoadPositionUs() {
+    long nextLoadPositionUs = mediaPeriod.getNextLoadPositionUs();
+    if (nextLoadPositionUs == C.TIME_END_OF_SOURCE
+        || (endUs != C.TIME_END_OF_SOURCE && nextLoadPositionUs >= endUs)) {
+      return C.TIME_END_OF_SOURCE;
+    }
+    return nextLoadPositionUs - startUs;
+  }
+
+  @Override
+  public boolean continueLoading(long positionUs) {
+    return mediaPeriod.continueLoading(positionUs + startUs);
+  }
+
+  // MediaPeriod.Callback implementation.
+
+  @Override
+  public void onPrepared(MediaPeriod mediaPeriod) {
+    Assertions.checkState(startUs != C.TIME_UNSET && endUs != C.TIME_UNSET);
+    // If the clipping start position is non-zero, the clipping sample streams will adjust
+    // timestamps on buffers they read from the unclipped sample streams. These adjusted buffer
+    // timestamps can be negative, because sample streams provide buffers starting at a key-frame,
+    // which may be before the clipping start point. When the renderer reads a buffer with a
+    // negative timestamp, its offset timestamp can jump backwards compared to the last timestamp
+    // read in the previous period. Renderer implementations may not allow this, so we signal a
+    // discontinuity which resets the renderers before they read the clipping sample stream.
+    pendingInitialDiscontinuity = startUs != 0;
+    callback.onPrepared(this);
+  }
+
+  @Override
+  public void onContinueLoadingRequested(MediaPeriod source) {
+    callback.onContinueLoadingRequested(this);
+  }
+
+  /**
+   * Wraps a {@link SampleStream} and clips its samples.
+   */
+  private static final class ClippingSampleStream implements SampleStream {
+
+    private final MediaPeriod mediaPeriod;
+    private final SampleStream stream;
+    private final long startUs;
+    private final long endUs;
+
+    private boolean pendingDiscontinuity;
+    private boolean sentEos;
+
+    public ClippingSampleStream(MediaPeriod mediaPeriod, SampleStream stream, long startUs,
+        long endUs, boolean pendingDiscontinuity) {
+      this.mediaPeriod = mediaPeriod;
+      this.stream = stream;
+      this.startUs = startUs;
+      this.endUs = endUs;
+      this.pendingDiscontinuity = pendingDiscontinuity;
+    }
+
+    public void clearPendingDiscontinuity() {
+      pendingDiscontinuity = false;
+    }
+
+    public void clearSentEos() {
+      sentEos = false;
+    }
+
+    @Override
+    public boolean isReady() {
+      return stream.isReady();
+    }
+
+    @Override
+    public void maybeThrowError() throws IOException {
+      stream.maybeThrowError();
+    }
+
+    @Override
+    public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer) {
+      if (pendingDiscontinuity) {
+        return C.RESULT_NOTHING_READ;
+      }
+      if (buffer == null) {
+        return stream.readData(formatHolder, null);
+      }
+      if (sentEos) {
+        buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
+        return C.RESULT_BUFFER_READ;
+      }
+      int result = stream.readData(formatHolder, buffer);
+      // TODO: Clear gapless playback metadata if a format was read (if applicable).
+      if (endUs != C.TIME_END_OF_SOURCE && ((result == C.RESULT_BUFFER_READ
+          && buffer.timeUs >= endUs) || (result == C.RESULT_NOTHING_READ
+          && mediaPeriod.getBufferedPositionUs() == C.TIME_END_OF_SOURCE))) {
+        buffer.clear();
+        buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
+        sentEos = true;
+        return C.RESULT_BUFFER_READ;
+      }
+      if (result == C.RESULT_BUFFER_READ && !buffer.isEndOfStream()) {
+        buffer.timeUs -= startUs;
+      }
+      return result;
+    }
+
+    @Override
+    public void skipToKeyframeBefore(long timeUs) {
+      stream.skipToKeyframeBefore(startUs + timeUs);
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
new file mode 100644
index 0000000000..be15a07726
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.util.Assertions;
+import java.io.IOException;
+import java.util.ArrayList;
+
+/**
+ * {@link MediaSource} that wraps a source and clips its timeline based on specified start/end
+ * positions. The wrapped source may only have a single period/window and it must not be dynamic
+ * (live).
+ */
+public final class ClippingMediaSource implements MediaSource, MediaSource.Listener {
+
+  private final MediaSource mediaSource;
+  private final long startUs;
+  private final long endUs;
+  private final ArrayList<ClippingMediaPeriod> mediaPeriods;
+
+  private MediaSource.Listener sourceListener;
+  private ClippingTimeline clippingTimeline;
+
+  /**
+   * Creates a new clipping source that wraps the specified source.
+   *
+   * @param mediaSource The single-period, non-dynamic source to wrap.
+   * @param startPositionUs The start position within {@code mediaSource}'s timeline at which to
+   *     start providing samples, in microseconds.
+   * @param endPositionUs The end position within {@code mediaSource}'s timeline at which to stop
+   *     providing samples, in microseconds. Specify {@link C#TIME_END_OF_SOURCE} to provide samples
+   *     from the specified start point up to the end of the source.
+   */
+  public ClippingMediaSource(MediaSource mediaSource, long startPositionUs, long endPositionUs) {
+    Assertions.checkArgument(startPositionUs >= 0);
+    this.mediaSource = Assertions.checkNotNull(mediaSource);
+    startUs = startPositionUs;
+    endUs = endPositionUs;
+    mediaPeriods = new ArrayList<>();
+  }
+
+  @Override
+  public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
+    this.sourceListener = listener;
+    mediaSource.prepareSource(player, false, this);
+  }
+
+  @Override
+  public void maybeThrowSourceInfoRefreshError() throws IOException {
+    mediaSource.maybeThrowSourceInfoRefreshError();
+  }
+
+  @Override
+  public MediaPeriod createPeriod(int index, Allocator allocator, long positionUs) {
+    ClippingMediaPeriod mediaPeriod = new ClippingMediaPeriod(
+        mediaSource.createPeriod(index, allocator, startUs + positionUs));
+    mediaPeriods.add(mediaPeriod);
+    mediaPeriod.setClipping(clippingTimeline.startUs, clippingTimeline.endUs);
+    return mediaPeriod;
+  }
+
+  @Override
+  public void releasePeriod(MediaPeriod mediaPeriod) {
+    Assertions.checkState(mediaPeriods.remove(mediaPeriod));
+    mediaSource.releasePeriod(((ClippingMediaPeriod) mediaPeriod).mediaPeriod);
+  }
+
+  @Override
+  public void releaseSource() {
+    mediaSource.releaseSource();
+  }
+
+  // MediaSource.Listener implementation.
+
+  @Override
+  public void onSourceInfoRefreshed(Timeline timeline, Object manifest) {
+    clippingTimeline = new ClippingTimeline(timeline, startUs, endUs);
+    sourceListener.onSourceInfoRefreshed(clippingTimeline, manifest);
+    long startUs = clippingTimeline.startUs;
+    long endUs = clippingTimeline.endUs == C.TIME_UNSET ? C.TIME_END_OF_SOURCE
+        : clippingTimeline.endUs;
+    int count = mediaPeriods.size();
+    for (int i = 0; i < count; i++) {
+      mediaPeriods.get(i).setClipping(startUs, endUs);
+    }
+  }
+
+  /**
+   * Provides a clipped view of a specified timeline.
+   */
+  private static final class ClippingTimeline extends Timeline {
+
+    private final Timeline timeline;
+    private final long startUs;
+    private final long endUs;
+
+    /**
+     * Creates a new clipping timeline that wraps the specified timeline.
+     *
+     * @param timeline The timeline to clip.
+     * @param startUs The number of microseconds to clip from the start of {@code timeline}.
+     * @param endUs The end position in microseconds for the clipped timeline relative to the start
+     *     of {@code timeline}, or {@link C#TIME_END_OF_SOURCE} to clip no samples from the end.
+     */
+    public ClippingTimeline(Timeline timeline, long startUs, long endUs) {
+      Assertions.checkArgument(timeline.getWindowCount() == 1);
+      Assertions.checkArgument(timeline.getPeriodCount() == 1);
+      Window window = timeline.getWindow(0, new Window(), false);
+      Assertions.checkArgument(!window.isDynamic);
+      long resolvedEndUs = endUs == C.TIME_END_OF_SOURCE ? window.durationUs : endUs;
+      if (window.durationUs != C.TIME_UNSET) {
+        Assertions.checkArgument(startUs == 0 || window.isSeekable);
+        Assertions.checkArgument(resolvedEndUs <= window.durationUs);
+        Assertions.checkArgument(startUs <= resolvedEndUs);
+      }
+      Period period = timeline.getPeriod(0, new Period());
+      Assertions.checkArgument(period.getPositionInWindowUs() == 0);
+      this.timeline = timeline;
+      this.startUs = startUs;
+      this.endUs = resolvedEndUs;
+    }
+
+    @Override
+    public int getWindowCount() {
+      return 1;
+    }
+
+    @Override
+    public Window getWindow(int windowIndex, Window window, boolean setIds,
+        long defaultPositionProjectionUs) {
+      window = timeline.getWindow(0, window, setIds, defaultPositionProjectionUs);
+      window.durationUs = endUs != C.TIME_UNSET ? endUs - startUs : C.TIME_UNSET;
+      if (window.defaultPositionUs != C.TIME_UNSET) {
+        window.defaultPositionUs = Math.max(window.defaultPositionUs, startUs);
+        window.defaultPositionUs = endUs == C.TIME_UNSET ? window.defaultPositionUs
+            : Math.min(window.defaultPositionUs, endUs);
+        window.defaultPositionUs -= startUs;
+      }
+      long startMs = C.usToMs(startUs);
+      if (window.presentationStartTimeMs != C.TIME_UNSET) {
+        window.presentationStartTimeMs += startMs;
+      }
+      if (window.windowStartTimeMs != C.TIME_UNSET) {
+        window.windowStartTimeMs += startMs;
+      }
+      return window;
+    }
+
+    @Override
+    public int getPeriodCount() {
+      return 1;
+    }
+
+    @Override
+    public Period getPeriod(int periodIndex, Period period, boolean setIds) {
+      period = timeline.getPeriod(0, period, setIds);
+      period.durationUs = endUs != C.TIME_UNSET ? endUs - startUs : C.TIME_UNSET;
+      return period;
+    }
+
+    @Override
+    public int getIndexOfPeriod(Object uid) {
+      return timeline.getIndexOfPeriod(uid);
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
index 8ab4d45c47..5226043593 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
@@ -40,6 +40,7 @@
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ConditionVariable;
 import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.Util;
 import java.io.EOFException;
 import java.io.IOException;
 
@@ -62,6 +63,7 @@
   private final ExtractorMediaSource.EventListener eventListener;
   private final MediaSource.Listener sourceListener;
   private final Allocator allocator;
+  private final String customCacheKey;
   private final Loader loader;
   private final ExtractorHolder extractorHolder;
   private final ConditionVariable loadCondition;
@@ -101,11 +103,13 @@
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @param sourceListener A listener to notify when the timeline has been loaded.
    * @param allocator An {@link Allocator} from which to obtain media buffer allocations.
+   * @param customCacheKey A custom key that uniquely identifies the original stream. Used for cache
+   *     indexing. May be null.
    */
   public ExtractorMediaPeriod(Uri uri, DataSource dataSource, Extractor[] extractors,
       int minLoadableRetryCount, Handler eventHandler,
       ExtractorMediaSource.EventListener eventListener, MediaSource.Listener sourceListener,
-      Allocator allocator) {
+      Allocator allocator, String customCacheKey) {
     this.uri = uri;
     this.dataSource = dataSource;
     this.minLoadableRetryCount = minLoadableRetryCount;
@@ -113,6 +117,7 @@ public ExtractorMediaPeriod(Uri uri, DataSource dataSource, Extractor[] extracto
     this.eventListener = eventListener;
     this.sourceListener = sourceListener;
     this.allocator = allocator;
+    this.customCacheKey = customCacheKey;
     loader = new Loader("Loader:ExtractorMediaPeriod");
     extractorHolder = new ExtractorHolder(extractors, this);
     loadCondition = new ConditionVariable();
@@ -514,7 +519,7 @@ private boolean isPendingReset() {
   }
 
   private boolean isLoadableExceptionFatal(IOException e) {
-    return e instanceof ExtractorMediaSource.UnrecognizedInputFormatException;
+    return e instanceof UnrecognizedInputFormatException;
   }
 
   private void notifyLoadError(final IOException error) {
@@ -615,12 +620,12 @@ public void load() throws IOException, InterruptedException {
         ExtractorInput input = null;
         try {
           long position = positionHolder.position;
-          length = dataSource.open(new DataSpec(uri, position, C.LENGTH_UNSET, null));
+          length = dataSource.open(new DataSpec(uri, position, C.LENGTH_UNSET, customCacheKey));
           if (length != C.LENGTH_UNSET) {
             length += position;
           }
           input = new DefaultExtractorInput(dataSource, position, length);
-          Extractor extractor = extractorHolder.selectExtractor(input);
+          Extractor extractor = extractorHolder.selectExtractor(input, dataSource.getUri());
           if (pendingExtractorSeek) {
             extractor.seek(position, seekTimeUs);
             pendingExtractorSeek = false;
@@ -640,7 +645,7 @@ public void load() throws IOException, InterruptedException {
           } else if (input != null) {
             positionHolder.position = input.getPosition();
           }
-          dataSource.close();
+          Util.closeQuietly(dataSource);
         }
       }
     }
@@ -672,13 +677,13 @@ public ExtractorHolder(Extractor[] extractors, ExtractorOutput extractorOutput)
      * later calls.
      *
      * @param input The {@link ExtractorInput} from which data should be read.
+     * @param uri The {@link Uri} of the data.
      * @return An initialized extractor for reading {@code input}.
-     * @throws ExtractorMediaSource.UnrecognizedInputFormatException Thrown if the input format
-     *     could not be detected.
+     * @throws UnrecognizedInputFormatException Thrown if the input format could not be detected.
      * @throws IOException Thrown if the input could not be read.
      * @throws InterruptedException Thrown if the thread was interrupted.
      */
-    public Extractor selectExtractor(ExtractorInput input)
+    public Extractor selectExtractor(ExtractorInput input, Uri uri)
         throws IOException, InterruptedException {
       if (extractor != null) {
         return extractor;
@@ -696,7 +701,8 @@ public Extractor selectExtractor(ExtractorInput input)
         }
       }
       if (extractor == null) {
-        throw new ExtractorMediaSource.UnrecognizedInputFormatException(extractors);
+        throw new UnrecognizedInputFormatException("None of the available extractors ("
+            + Util.getCommaDelimitedSimpleClassNames(extractors) + ") could read the stream.", uri);
       }
       extractor.init(extractorOutput);
       return extractor;
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
index 559d241598..c560616aae 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
@@ -19,7 +19,6 @@
 import android.os.Handler;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayer;
-import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.extractor.DefaultExtractorsFactory;
 import com.google.android.exoplayer2.extractor.Extractor;
@@ -27,7 +26,6 @@
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 
 /**
@@ -57,18 +55,6 @@
 
   }
 
-  /**
-   * Thrown if the input format could not recognized.
-   */
-  public static final class UnrecognizedInputFormatException extends ParserException {
-
-    public UnrecognizedInputFormatException(Extractor[] extractors) {
-      super("None of the available extractors ("
-          + Util.getCommaDelimitedSimpleClassNames(extractors) + ") could read the stream.");
-    }
-
-  }
-
   /**
    * The default minimum number of times to retry loading prior to failing for on-demand streams.
    */
@@ -93,6 +79,7 @@ public UnrecognizedInputFormatException(Extractor[] extractors) {
   private final Handler eventHandler;
   private final EventListener eventListener;
   private final Timeline.Period period;
+  private final String customCacheKey;
 
   private MediaSource.Listener sourceListener;
   private Timeline timeline;
@@ -110,7 +97,25 @@ public UnrecognizedInputFormatException(Extractor[] extractors) {
   public ExtractorMediaSource(Uri uri, DataSource.Factory dataSourceFactory,
       ExtractorsFactory extractorsFactory, Handler eventHandler, EventListener eventListener) {
     this(uri, dataSourceFactory, extractorsFactory, MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA, eventHandler,
-        eventListener);
+        eventListener, null);
+  }
+
+  /**
+   * @param uri The {@link Uri} of the media stream.
+   * @param dataSourceFactory A factory for {@link DataSource}s to read the media.
+   * @param extractorsFactory A factory for {@link Extractor}s to process the media stream. If the
+   *     possible formats are known, pass a factory that instantiates extractors for those formats.
+   *     Otherwise, pass a {@link DefaultExtractorsFactory} to use default extractors.
+   * @param eventHandler A handler for events. May be null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param customCacheKey A custom key that uniquely identifies the original stream. Used for cache
+   *     indexing. May be null.
+   */
+  public ExtractorMediaSource(Uri uri, DataSource.Factory dataSourceFactory,
+      ExtractorsFactory extractorsFactory, Handler eventHandler, EventListener eventListener,
+      String customCacheKey) {
+    this(uri, dataSourceFactory, extractorsFactory, MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA, eventHandler,
+        eventListener, customCacheKey);
   }
 
   /**
@@ -122,16 +127,19 @@ public ExtractorMediaSource(Uri uri, DataSource.Factory dataSourceFactory,
    * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
    * @param eventHandler A handler for events. May be null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param customCacheKey A custom key that uniquely identifies the original stream. Used for cache
+   *     indexing. May be null.
    */
   public ExtractorMediaSource(Uri uri, DataSource.Factory dataSourceFactory,
       ExtractorsFactory extractorsFactory, int minLoadableRetryCount, Handler eventHandler,
-      EventListener eventListener) {
+      EventListener eventListener, String customCacheKey) {
     this.uri = uri;
     this.dataSourceFactory = dataSourceFactory;
     this.extractorsFactory = extractorsFactory;
     this.minLoadableRetryCount = minLoadableRetryCount;
     this.eventHandler = eventHandler;
     this.eventListener = eventListener;
+    this.customCacheKey = customCacheKey;
     period = new Timeline.Period();
   }
 
@@ -152,7 +160,7 @@ public MediaPeriod createPeriod(int index, Allocator allocator, long positionUs)
     Assertions.checkArgument(index == 0);
     return new ExtractorMediaPeriod(uri, dataSourceFactory.createDataSource(),
         extractorsFactory.createExtractors(), minLoadableRetryCount, eventHandler, eventListener,
-        this, allocator);
+        this, allocator, customCacheKey);
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
index f4a9665b10..31ee8df1e4 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.source;
 
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import java.io.IOException;
 
@@ -47,6 +48,10 @@
    * <p>
    * {@code callback.onPrepared} is called when preparation completes. If preparation fails,
    * {@link #maybeThrowPrepareError()} will throw an {@link IOException}.
+   * <p>
+   * If preparation succeeds and results in a source timeline change (e.g. the period duration
+   * becoming known), {@link MediaSource.Listener#onSourceInfoRefreshed(Timeline, Object)} will be
+   * called before {@code callback.onPrepared}.
    *
    * @param callback Callback to receive updates from this period, including being notified when
    *     preparation completes.
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/SampleStream.java b/library/src/main/java/com/google/android/exoplayer2/source/SampleStream.java
index 39374acb33..5ee70cd2ed 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/SampleStream.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/SampleStream.java
@@ -44,11 +44,17 @@
 
   /**
    * Attempts to read from the stream.
+   * <p>
+   * If no data is available then {@link C#RESULT_NOTHING_READ} is returned. If the format of the
+   * media is changing or if {@code buffer == null} then {@code formatHolder} is populated and
+   * {@link C#RESULT_FORMAT_READ} is returned. Else {@code buffer} is populated and
+   * {@link C#RESULT_BUFFER_READ} is returned.
    *
    * @param formatHolder A {@link FormatHolder} to populate in the case of reading a format.
    * @param buffer A {@link DecoderInputBuffer} to populate in the case of reading a sample or the
    *     end of the stream. If the end of the stream has been reached, the
-   *     {@link C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer.
+   *     {@link C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer. May be null if the
+   *     caller requires that the format of the stream be read even if it's not changing.
    * @return The result, which can be {@link C#RESULT_NOTHING_READ}, {@link C#RESULT_FORMAT_READ} or
    *     {@link C#RESULT_BUFFER_READ}.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
index 1ad448bd12..c78bb5371b 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
@@ -28,6 +28,7 @@
 import com.google.android.exoplayer2.upstream.Loader;
 import com.google.android.exoplayer2.upstream.Loader.Loadable;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -205,13 +206,13 @@ public void maybeThrowError() throws IOException {
 
     @Override
     public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer) {
-      if (streamState == STREAM_STATE_END_OF_STREAM) {
-        buffer.addFlag(C.BUFFER_FLAG_END_OF_STREAM);
-        return C.RESULT_BUFFER_READ;
-      } else if (streamState == STREAM_STATE_SEND_FORMAT) {
+      if (buffer == null || streamState == STREAM_STATE_SEND_FORMAT) {
         formatHolder.format = format;
         streamState = STREAM_STATE_SEND_SAMPLE;
         return C.RESULT_FORMAT_READ;
+      } else if (streamState == STREAM_STATE_END_OF_STREAM) {
+        buffer.addFlag(C.BUFFER_FLAG_END_OF_STREAM);
+        return C.RESULT_BUFFER_READ;
       }
 
       Assertions.checkState(streamState == STREAM_STATE_SEND_SAMPLE);
@@ -276,7 +277,7 @@ public void load() throws IOException, InterruptedException {
           result = dataSource.read(sampleData, sampleSize, sampleData.length - sampleSize);
         }
       } finally {
-        dataSource.close();
+        Util.closeQuietly(dataSource);
       }
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/UnrecognizedInputFormatException.java b/library/src/main/java/com/google/android/exoplayer2/source/UnrecognizedInputFormatException.java
new file mode 100644
index 0000000000..508bf0e365
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/source/UnrecognizedInputFormatException.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.ParserException;
+
+/**
+ * Thrown if the input format was not recognized.
+ */
+public class UnrecognizedInputFormatException extends ParserException {
+
+  /**
+   * The {@link Uri} from which the unrecognized data was read.
+   */
+  public final Uri uri;
+
+  /**
+   * @param message The detail message for the exception.
+   * @param uri The {@link Uri} from which the unrecognized data was read.
+   */
+  public UnrecognizedInputFormatException(String message, Uri uri) {
+    super(message);
+    this.uri = uri;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java b/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java
index ed76a505ea..2623d31cef 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java
@@ -30,15 +30,15 @@
 /**
  * An {@link Extractor} wrapper for loading chunks containing a single track.
  * <p>
- * The wrapper allows switching of the {@link SingleTrackMetadataOutput} and {@link TrackOutput}
- * which receive parsed data.
+ * The wrapper allows switching of the {@link SeekMapOutput} and {@link TrackOutput} that receive
+ * parsed data.
  */
 public final class ChunkExtractorWrapper implements ExtractorOutput, TrackOutput {
 
   /**
-   * Receives metadata associated with the track as extracted by the wrapped {@link Extractor}.
+   * Receives {@link SeekMap}s extracted by the wrapped {@link Extractor}.
    */
-  public interface SingleTrackMetadataOutput {
+  public interface SeekMapOutput {
 
     /**
      * @see ExtractorOutput#seekMap(SeekMap)
@@ -47,13 +47,14 @@
 
   }
 
-  private final Extractor extractor;
+  public final Extractor extractor;
+
   private final Format manifestFormat;
   private final boolean preferManifestDrmInitData;
   private final boolean resendFormatOnInit;
 
   private boolean extractorInitialized;
-  private SingleTrackMetadataOutput metadataOutput;
+  private SeekMapOutput seekMapOutput;
   private TrackOutput trackOutput;
   private Format sentFormat;
 
@@ -68,7 +69,7 @@
    * @param preferManifestDrmInitData Whether {@link DrmInitData} defined in {@code manifestFormat}
    *     should be preferred when the sample and manifest {@link Format}s are merged.
    * @param resendFormatOnInit Whether the extractor should resend the previous {@link Format} when
-   *     it is initialized via {@link #init(SingleTrackMetadataOutput, TrackOutput)}.
+   *     it is initialized via {@link #init(SeekMapOutput, TrackOutput)}.
    */
   public ChunkExtractorWrapper(Extractor extractor, Format manifestFormat,
       boolean preferManifestDrmInitData, boolean resendFormatOnInit) {
@@ -79,14 +80,14 @@ public ChunkExtractorWrapper(Extractor extractor, Format manifestFormat,
   }
 
   /**
-   * Initializes the extractor to output to the provided {@link SingleTrackMetadataOutput} and
+   * Initializes the extractor to output to the provided {@link SeekMapOutput} and
    * {@link TrackOutput} instances, and configures it to receive data from a new chunk.
    *
-   * @param metadataOutput The {@link SingleTrackMetadataOutput} that will receive metadata.
+   * @param seekMapOutput The {@link SeekMapOutput} that will receive extracted {@link SeekMap}s.
    * @param trackOutput The {@link TrackOutput} that will receive sample data.
    */
-  public void init(SingleTrackMetadataOutput metadataOutput, TrackOutput trackOutput) {
-    this.metadataOutput = metadataOutput;
+  public void init(SeekMapOutput seekMapOutput, TrackOutput trackOutput) {
+    this.seekMapOutput = seekMapOutput;
     this.trackOutput = trackOutput;
     if (!extractorInitialized) {
       extractor.init(this);
@@ -99,20 +100,6 @@ public void init(SingleTrackMetadataOutput metadataOutput, TrackOutput trackOutp
     }
   }
 
-  /**
-   * Reads from the provided {@link ExtractorInput}.
-   *
-   * @param input The {@link ExtractorInput} from which to read.
-   * @return One of {@link Extractor#RESULT_CONTINUE} and {@link Extractor#RESULT_END_OF_INPUT}.
-   * @throws IOException If an error occurred reading from the source.
-   * @throws InterruptedException If the thread was interrupted.
-   */
-  public int read(ExtractorInput input) throws IOException, InterruptedException {
-    int result = extractor.read(input, null);
-    Assertions.checkState(result != Extractor.RESULT_SEEK);
-    return result;
-  }
-
   // ExtractorOutput implementation.
 
   @Override
@@ -130,7 +117,7 @@ public void endTracks() {
 
   @Override
   public void seekMap(SeekMap seekMap) {
-    metadataOutput.seekMap(seekMap);
+    seekMapOutput.seekMap(seekMap);
   }
 
   // TrackOutput implementation.
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java b/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
index 6de7c6ec01..3955d64034 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
@@ -122,7 +122,8 @@ public long getBufferedPositionUs() {
   public void seekToUs(long positionUs) {
     lastSeekPositionUs = positionUs;
     // If we're not pending a reset, see if we can seek within the sample queue.
-    boolean seekInsideBuffer = !isPendingReset() && sampleQueue.skipToKeyframeBefore(positionUs);
+    boolean seekInsideBuffer = !isPendingReset()
+        && sampleQueue.skipToKeyframeBefore(positionUs, positionUs < getNextLoadPositionUs());
     if (seekInsideBuffer) {
       // We succeeded. All we need to do is discard any chunks that we've moved past.
       while (mediaChunks.size() > 1
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/chunk/ContainerMediaChunk.java b/library/src/main/java/com/google/android/exoplayer2/source/chunk/ContainerMediaChunk.java
index a5af3cc42f..060e6130cf 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/chunk/ContainerMediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/chunk/ContainerMediaChunk.java
@@ -21,16 +21,17 @@
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.SeekMap;
-import com.google.android.exoplayer2.source.chunk.ChunkExtractorWrapper.SingleTrackMetadataOutput;
+import com.google.android.exoplayer2.source.chunk.ChunkExtractorWrapper.SeekMapOutput;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 
 /**
  * A {@link BaseMediaChunk} that uses an {@link Extractor} to decode sample data.
  */
-public class ContainerMediaChunk extends BaseMediaChunk implements SingleTrackMetadataOutput {
+public class ContainerMediaChunk extends BaseMediaChunk implements SeekMapOutput {
 
   private final int chunkCount;
   private final long sampleOffsetUs;
@@ -85,7 +86,7 @@ public final long bytesLoaded() {
     return bytesLoaded;
   }
 
-  // SingleTrackMetadataOutput implementation.
+  // SeekMapOutput implementation.
 
   @Override
   public final void seekMap(SeekMap seekMap) {
@@ -120,15 +121,17 @@ public final void load() throws IOException, InterruptedException {
       }
       // Load and decode the sample data.
       try {
+        Extractor extractor = extractorWrapper.extractor;
         int result = Extractor.RESULT_CONTINUE;
         while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
-          result = extractorWrapper.read(input);
+          result = extractor.read(input, null);
         }
+        Assertions.checkState(result != Extractor.RESULT_SEEK);
       } finally {
         bytesLoaded = (int) (input.getPosition() - dataSpec.absoluteStreamPosition);
       }
     } finally {
-      dataSource.close();
+      Util.closeQuietly(dataSource);
     }
     loadCompleted = true;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/chunk/DataChunk.java b/library/src/main/java/com/google/android/exoplayer2/source/chunk/DataChunk.java
index 99653d323f..0846e7679d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/chunk/DataChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/chunk/DataChunk.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.Arrays;
 
@@ -96,7 +97,7 @@ public final void load() throws IOException, InterruptedException {
         consume(data, limit);
       }
     } finally {
-      dataSource.close();
+      Util.closeQuietly(dataSource);
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/chunk/InitializationChunk.java b/library/src/main/java/com/google/android/exoplayer2/source/chunk/InitializationChunk.java
index 388dc63899..c8c3389830 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/chunk/InitializationChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/chunk/InitializationChunk.java
@@ -22,9 +22,10 @@
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.extractor.TrackOutput;
-import com.google.android.exoplayer2.source.chunk.ChunkExtractorWrapper.SingleTrackMetadataOutput;
+import com.google.android.exoplayer2.source.chunk.ChunkExtractorWrapper.SeekMapOutput;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
@@ -32,7 +33,7 @@
 /**
  * A {@link Chunk} that uses an {@link Extractor} to decode initialization data for single track.
  */
-public final class InitializationChunk extends Chunk implements SingleTrackMetadataOutput,
+public final class InitializationChunk extends Chunk implements SeekMapOutput,
     TrackOutput {
 
   private final ChunkExtractorWrapper extractorWrapper;
@@ -85,7 +86,7 @@ public SeekMap getSeekMap() {
     return seekMap;
   }
 
-  // SingleTrackMetadataOutput implementation.
+  // SeekMapOutput implementation.
 
   @Override
   public void seekMap(SeekMap seekMap) {
@@ -142,15 +143,17 @@ public void load() throws IOException, InterruptedException {
       }
       // Load and decode the initialization data.
       try {
+        Extractor extractor = extractorWrapper.extractor;
         int result = Extractor.RESULT_CONTINUE;
         while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
-          result = extractorWrapper.read(input);
+          result = extractor.read(input, null);
         }
+        Assertions.checkState(result != Extractor.RESULT_SEEK);
       } finally {
         bytesLoaded = (int) (input.getPosition() - dataSpec.absoluteStreamPosition);
       }
     } finally {
-      dataSource.close();
+      Util.closeQuietly(dataSource);
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/chunk/SingleSampleMediaChunk.java b/library/src/main/java/com/google/android/exoplayer2/source/chunk/SingleSampleMediaChunk.java
index 3033566950..d7be74535e 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/chunk/SingleSampleMediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/chunk/SingleSampleMediaChunk.java
@@ -98,7 +98,7 @@ public void load() throws IOException, InterruptedException {
       int sampleSize = bytesLoaded;
       trackOutput.sampleMetadata(startTimeUs, C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0, null);
     } finally {
-      dataSource.close();
+      Util.closeQuietly(dataSource);
     }
     loadCompleted = true;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/DashWrappingSegmentIndex.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/DashWrappingSegmentIndex.java
index 9e48bc2c79..56ea626120 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/DashWrappingSegmentIndex.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/DashWrappingSegmentIndex.java
@@ -28,9 +28,8 @@
 
   /**
    * @param chunkIndex The {@link ChunkIndex} to wrap.
-   * @param uri The URI where the data is located.
    */
-  public DashWrappingSegmentIndex(ChunkIndex chunkIndex, String uri) {
+  public DashWrappingSegmentIndex(ChunkIndex chunkIndex) {
     this.chunkIndex = chunkIndex;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
index 0e3d127796..74d53d3e32 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
@@ -185,10 +185,9 @@ public final void getNextChunk(MediaChunk previous, long playbackPositionUs, Chu
     }
     if (pendingInitializationUri != null || pendingIndexUri != null) {
       // We have initialization and/or index requests to make.
-      Chunk initializationChunk = newInitializationChunk(representationHolder, dataSource,
+      out.chunk = newInitializationChunk(representationHolder, dataSource,
           trackSelection.getSelectedFormat(), trackSelection.getSelectionReason(),
           trackSelection.getSelectionData(), pendingInitializationUri, pendingIndexUri);
-      out.chunk = initializationChunk;
       return;
     }
 
@@ -233,10 +232,9 @@ public final void getNextChunk(MediaChunk previous, long playbackPositionUs, Chu
     }
 
     int maxSegmentCount = Math.min(maxSegmentsPerLoad, lastAvailableSegmentNum - segmentNum + 1);
-    Chunk nextMediaChunk = newMediaChunk(representationHolder, dataSource,
-        trackSelection.getSelectedFormat(), trackSelection.getSelectionReason(),
-        trackSelection.getSelectionData(), sampleFormat, segmentNum, maxSegmentCount);
-    out.chunk = nextMediaChunk;
+    out.chunk = newMediaChunk(representationHolder, dataSource, trackSelection.getSelectedFormat(),
+        trackSelection.getSelectionReason(), trackSelection.getSelectionData(), sampleFormat,
+        segmentNum, maxSegmentCount);
   }
 
   @Override
@@ -255,8 +253,7 @@ public void onChunkLoadCompleted(Chunk chunk) {
       if (representationHolder.segmentIndex == null) {
         SeekMap seekMap = initializationChunk.getSeekMap();
         if (seekMap != null) {
-          representationHolder.segmentIndex = new DashWrappingSegmentIndex((ChunkIndex) seekMap,
-              initializationChunk.dataSpec.uri.toString());
+          representationHolder.segmentIndex = new DashWrappingSegmentIndex((ChunkIndex) seekMap);
         }
       }
     }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/AdaptationSet.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/AdaptationSet.java
index 44da52f52c..097676b89f 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/AdaptationSet.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/AdaptationSet.java
@@ -23,18 +23,49 @@
  */
 public class AdaptationSet {
 
-  public static final int UNSET_ID = -1;
+  /**
+   * Value of {@link #id} indicating no value is set.=
+   */
+  public static final int ID_UNSET = -1;
 
+  /**
+   * A non-negative identifier for the adaptation set that's unique in the scope of its containing
+   * period, or {@link #ID_UNSET} if not specified.
+   */
   public final int id;
 
+  /**
+   * The type of the adaptation set. One of the {@link com.google.android.exoplayer2.C}
+   * {@code TRACK_TYPE_*} constants.
+   */
   public final int type;
 
+  /**
+   * The {@link Representation}s in the adaptation set.
+   */
   public final List<Representation> representations;
 
-  public AdaptationSet(int id, int type, List<Representation> representations) {
+  /**
+   * The accessibility descriptors in the adaptation set.
+   */
+  public final List<SchemeValuePair> accessibilityDescriptors;
+
+  /**
+   * @param id A non-negative identifier for the adaptation set that's unique in the scope of its
+   *     containing period, or {@link #ID_UNSET} if not specified.
+   * @param type The type of the adaptation set. One of the {@link com.google.android.exoplayer2.C}
+   *     {@code TRACK_TYPE_*} constants.
+   * @param representations The {@link Representation}s in the adaptation set.
+   * @param accessibilityDescriptors The accessibility descriptors in the adaptation set.
+   */
+  public AdaptationSet(int id, int type, List<Representation> representations,
+      List<SchemeValuePair> accessibilityDescriptors) {
     this.id = id;
     this.type = type;
     this.representations = Collections.unmodifiableList(representations);
+    this.accessibilityDescriptors = accessibilityDescriptors == null
+        ? Collections.<SchemeValuePair>emptyList()
+        : Collections.unmodifiableList(accessibilityDescriptors);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
index 7e2ce0de1d..1917399282 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
@@ -227,7 +227,7 @@ protected Period buildPeriod(String id, long startMs, List<AdaptationSet> adapta
 
   protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
       SegmentBase segmentBase) throws XmlPullParserException, IOException {
-    int id = parseInt(xpp, "id", AdaptationSet.UNSET_ID);
+    int id = parseInt(xpp, "id", AdaptationSet.ID_UNSET);
     int contentType = parseContentType(xpp);
 
     String mimeType = xpp.getAttributeValue(null, "mimeType");
@@ -238,9 +238,11 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
     int audioChannels = Format.NO_VALUE;
     int audioSamplingRate = parseInt(xpp, "audioSamplingRate", Format.NO_VALUE);
     String language = xpp.getAttributeValue(null, "lang");
-    int accessibilityChannel = Format.NO_VALUE;
     ArrayList<SchemeData> drmSchemeDatas = new ArrayList<>();
+    ArrayList<SchemeValuePair> inbandEventStreams = new ArrayList<>();
+    ArrayList<SchemeValuePair> accessibilityDescriptors = new ArrayList<>();
     List<RepresentationInfo> representationInfos = new ArrayList<>();
+    @C.SelectionFlags int selectionFlags = 0;
 
     boolean seenFirstBaseUrl = false;
     do {
@@ -258,40 +260,45 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
       } else if (XmlPullParserUtil.isStartTag(xpp, "ContentComponent")) {
         language = checkLanguageConsistency(language, xpp.getAttributeValue(null, "lang"));
         contentType = checkContentTypeConsistency(contentType, parseContentType(xpp));
+      } else if (XmlPullParserUtil.isStartTag(xpp, "Role")) {
+        selectionFlags |= parseRole(xpp);
+      } else if (XmlPullParserUtil.isStartTag(xpp, "AudioChannelConfiguration")) {
+        audioChannels = parseAudioChannelConfiguration(xpp);
+      } else if (XmlPullParserUtil.isStartTag(xpp, "Accessibility")) {
+        accessibilityDescriptors.add(parseAccessibility(xpp));
       } else if (XmlPullParserUtil.isStartTag(xpp, "Representation")) {
         RepresentationInfo representationInfo = parseRepresentation(xpp, baseUrl, mimeType, codecs,
             width, height, frameRate, audioChannels, audioSamplingRate, language,
-            accessibilityChannel, segmentBase);
+            selectionFlags, accessibilityDescriptors, segmentBase);
         contentType = checkContentTypeConsistency(contentType,
             getContentType(representationInfo.format));
         representationInfos.add(representationInfo);
-      } else if (XmlPullParserUtil.isStartTag(xpp, "AudioChannelConfiguration")) {
-        audioChannels = parseAudioChannelConfiguration(xpp);
-      } else if (XmlPullParserUtil.isStartTag(xpp, "Accessibility")) {
-        accessibilityChannel = parseAccessibilityValue(xpp);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentBase")) {
         segmentBase = parseSegmentBase(xpp, (SingleSegmentBase) segmentBase);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentList")) {
         segmentBase = parseSegmentList(xpp, (SegmentList) segmentBase);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentTemplate")) {
         segmentBase = parseSegmentTemplate(xpp, (SegmentTemplate) segmentBase);
+      } else if (XmlPullParserUtil.isStartTag(xpp, "InbandEventStream")) {
+        inbandEventStreams.add(parseInbandEventStream(xpp));
       } else if (XmlPullParserUtil.isStartTag(xpp)) {
         parseAdaptationSetChild(xpp);
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "AdaptationSet"));
 
+    // Build the representations.
     List<Representation> representations = new ArrayList<>(representationInfos.size());
     for (int i = 0; i < representationInfos.size(); i++) {
       representations.add(buildRepresentation(representationInfos.get(i), contentId,
-          drmSchemeDatas));
+          drmSchemeDatas, inbandEventStreams));
     }
 
-    return buildAdaptationSet(id, contentType, representations);
+    return buildAdaptationSet(id, contentType, representations, accessibilityDescriptors);
   }
 
   protected AdaptationSet buildAdaptationSet(int id, int contentType,
-      List<Representation> representations) {
-    return new AdaptationSet(id, contentType, representations);
+      List<Representation> representations, List<SchemeValuePair> accessibilityDescriptors) {
+    return new AdaptationSet(id, contentType, representations, accessibilityDescriptors);
   }
 
   protected int parseContentType(XmlPullParser xpp) {
@@ -311,8 +318,7 @@ protected int getContentType(Format format) {
       return C.TRACK_TYPE_VIDEO;
     } else if (MimeTypes.isAudio(sampleMimeType)) {
       return C.TRACK_TYPE_AUDIO;
-    } else if (mimeTypeIsRawText(sampleMimeType)
-        || MimeTypes.APPLICATION_RAWCC.equals(format.containerMimeType)) {
+    } else if (mimeTypeIsRawText(sampleMimeType)) {
       return C.TRACK_TYPE_TEXT;
     }
     return C.TRACK_TYPE_UNKNOWN;
@@ -355,6 +361,50 @@ protected SchemeData parseContentProtection(XmlPullParser xpp) throws XmlPullPar
     }
   }
 
+  /**
+   * Parses an InbandEventStream element.
+   *
+   * @param xpp The parser from which to read.
+   * @throws XmlPullParserException If an error occurs parsing the element.
+   * @throws IOException If an error occurs reading the element.
+   * @return A {@link SchemeValuePair} parsed from the element.
+   */
+  protected SchemeValuePair parseInbandEventStream(XmlPullParser xpp)
+      throws XmlPullParserException, IOException {
+    return parseSchemeValuePair(xpp, "InbandEventStream");
+  }
+
+  /**
+   * Parses an Accessibility element.
+   *
+   * @param xpp The parser from which to read.
+   * @throws XmlPullParserException If an error occurs parsing the element.
+   * @throws IOException If an error occurs reading the element.
+   * @return A {@link SchemeValuePair} parsed from the element.
+   */
+  protected SchemeValuePair parseAccessibility(XmlPullParser xpp)
+      throws XmlPullParserException, IOException {
+    return parseSchemeValuePair(xpp, "Accessibility");
+  }
+
+  /**
+   * Parses a Role element.
+   *
+   * @param xpp The parser from which to read.
+   * @throws XmlPullParserException If an error occurs parsing the element.
+   * @throws IOException If an error occurs reading the element.
+   * @return {@link C.SelectionFlags} parsed from the element.
+   */
+  protected int parseRole(XmlPullParser xpp) throws XmlPullParserException, IOException {
+    String schemeIdUri = parseString(xpp, "schemeIdUri", null);
+    String value = parseString(xpp, "value", null);
+    do {
+      xpp.next();
+    } while (!XmlPullParserUtil.isEndTag(xpp, "Role"));
+    return "urn:mpeg:dash:role:2011".equals(schemeIdUri) && "main".equals(value)
+        ? C.SELECTION_FLAG_DEFAULT : 0;
+  }
+
   /**
    * Parses children of AdaptationSet elements not specifically parsed elsewhere.
    *
@@ -373,7 +423,8 @@ protected RepresentationInfo parseRepresentation(XmlPullParser xpp, String baseU
       String adaptationSetMimeType, String adaptationSetCodecs, int adaptationSetWidth,
       int adaptationSetHeight, float adaptationSetFrameRate, int adaptationSetAudioChannels,
       int adaptationSetAudioSamplingRate, String adaptationSetLanguage,
-      int adaptationSetAccessibilityChannel, SegmentBase segmentBase)
+      @C.SelectionFlags int adaptationSetSelectionFlags,
+      List<SchemeValuePair> adaptationSetAccessibilityDescriptors, SegmentBase segmentBase)
       throws XmlPullParserException, IOException {
     String id = xpp.getAttributeValue(null, "id");
     int bandwidth = parseInt(xpp, "bandwidth", Format.NO_VALUE);
@@ -386,6 +437,7 @@ protected RepresentationInfo parseRepresentation(XmlPullParser xpp, String baseU
     int audioChannels = adaptationSetAudioChannels;
     int audioSamplingRate = parseInt(xpp, "audioSamplingRate", adaptationSetAudioSamplingRate);
     ArrayList<SchemeData> drmSchemeDatas = new ArrayList<>();
+    ArrayList<SchemeValuePair> inbandEventStreams = new ArrayList<>();
 
     boolean seenFirstBaseUrl = false;
     do {
@@ -408,52 +460,61 @@ protected RepresentationInfo parseRepresentation(XmlPullParser xpp, String baseU
         if (contentProtection != null) {
           drmSchemeDatas.add(contentProtection);
         }
+      } else if (XmlPullParserUtil.isStartTag(xpp, "InbandEventStream")) {
+        inbandEventStreams.add(parseInbandEventStream(xpp));
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "Representation"));
 
     Format format = buildFormat(id, mimeType, width, height, frameRate, audioChannels,
-        audioSamplingRate, bandwidth, adaptationSetLanguage, adaptationSetAccessibilityChannel,
-        codecs);
+        audioSamplingRate, bandwidth, adaptationSetLanguage, adaptationSetSelectionFlags,
+        adaptationSetAccessibilityDescriptors, codecs);
     segmentBase = segmentBase != null ? segmentBase : new SingleSegmentBase();
 
-    return new RepresentationInfo(format, baseUrl, segmentBase, drmSchemeDatas);
+    return new RepresentationInfo(format, baseUrl, segmentBase, drmSchemeDatas, inbandEventStreams);
   }
 
   protected Format buildFormat(String id, String containerMimeType, int width, int height,
       float frameRate, int audioChannels, int audioSamplingRate, int bitrate, String language,
-      int accessiblityChannel, String codecs) {
+      @C.SelectionFlags int selectionFlags, List<SchemeValuePair> accessibilityDescriptors,
+      String codecs) {
     String sampleMimeType = getSampleMimeType(containerMimeType, codecs);
     if (sampleMimeType != null) {
       if (MimeTypes.isVideo(sampleMimeType)) {
         return Format.createVideoContainerFormat(id, containerMimeType, sampleMimeType, codecs,
-            bitrate, width, height, frameRate, null);
+            bitrate, width, height, frameRate, null, selectionFlags);
       } else if (MimeTypes.isAudio(sampleMimeType)) {
         return Format.createAudioContainerFormat(id, containerMimeType, sampleMimeType, codecs,
-            bitrate, audioChannels, audioSamplingRate, null, 0, language);
+            bitrate, audioChannels, audioSamplingRate, null, selectionFlags, language);
       } else if (mimeTypeIsRawText(sampleMimeType)) {
+        int accessibilityChannel;
+        if (MimeTypes.APPLICATION_CEA608.equals(sampleMimeType)) {
+          accessibilityChannel = parseCea608AccessibilityChannel(accessibilityDescriptors);
+        } else if (MimeTypes.APPLICATION_CEA708.equals(sampleMimeType)) {
+          accessibilityChannel = parseCea708AccessibilityChannel(accessibilityDescriptors);
+        } else {
+          accessibilityChannel = Format.NO_VALUE;
+        }
         return Format.createTextContainerFormat(id, containerMimeType, sampleMimeType, codecs,
-            bitrate, 0, language, accessiblityChannel);
-      } else if (containerMimeType.equals(MimeTypes.APPLICATION_RAWCC)) {
-        return Format.createTextContainerFormat(id, containerMimeType, sampleMimeType, codecs,
-            bitrate, 0, language, accessiblityChannel);
-      } else {
-        return Format.createContainerFormat(id, containerMimeType, codecs, sampleMimeType, bitrate);
+            bitrate, selectionFlags, language, accessibilityChannel);
       }
-    } else {
-      return Format.createContainerFormat(id, containerMimeType, codecs, sampleMimeType, bitrate);
     }
+    return Format.createContainerFormat(id, containerMimeType, sampleMimeType, codecs, bitrate,
+        selectionFlags, language);
   }
 
   protected Representation buildRepresentation(RepresentationInfo representationInfo,
-      String contentId, ArrayList<SchemeData> extraDrmSchemeDatas) {
+      String contentId, ArrayList<SchemeData> extraDrmSchemeDatas,
+      ArrayList<SchemeValuePair> extraInbandEventStreams) {
     Format format = representationInfo.format;
     ArrayList<SchemeData> drmSchemeDatas = representationInfo.drmSchemeDatas;
     drmSchemeDatas.addAll(extraDrmSchemeDatas);
     if (!drmSchemeDatas.isEmpty()) {
       format = format.copyWithDrmInitData(new DrmInitData(drmSchemeDatas));
     }
+    ArrayList<SchemeValuePair> inbandEventStremas = representationInfo.inbandEventStreams;
+    inbandEventStremas.addAll(extraInbandEventStreams);
     return Representation.newInstance(contentId, Representation.REVISION_ID_DEFAULT, format,
-        representationInfo.baseUrl, representationInfo.segmentBase);
+        representationInfo.baseUrl, representationInfo.segmentBase, inbandEventStremas);
   }
 
   // SegmentBase, SegmentList and SegmentTemplate parsing.
@@ -664,6 +725,14 @@ private static String getSampleMimeType(String containerMimeType, String codecs)
       return MimeTypes.getAudioMediaMimeType(codecs);
     } else if (MimeTypes.isVideo(containerMimeType)) {
       return MimeTypes.getVideoMediaMimeType(codecs);
+    } else if (mimeTypeIsRawText(containerMimeType)) {
+      return containerMimeType;
+    } else if (MimeTypes.APPLICATION_MP4.equals(containerMimeType)) {
+      if ("stpp".equals(codecs)) {
+        return MimeTypes.APPLICATION_TTML;
+      } else if ("wvtt".equals(codecs)) {
+        return MimeTypes.APPLICATION_MP4VTT;
+      }
     } else if (MimeTypes.APPLICATION_RAWCC.equals(containerMimeType)) {
       if (codecs != null) {
         if (codecs.contains("cea708")) {
@@ -673,14 +742,6 @@ private static String getSampleMimeType(String containerMimeType, String codecs)
         }
       }
       return null;
-    } else if (mimeTypeIsRawText(containerMimeType)) {
-      return containerMimeType;
-    } else if (MimeTypes.APPLICATION_MP4.equals(containerMimeType)) {
-      if ("stpp".equals(codecs)) {
-        return MimeTypes.APPLICATION_TTML;
-      } else if ("wvtt".equals(codecs)) {
-        return MimeTypes.APPLICATION_MP4VTT;
-      }
     }
     return null;
   }
@@ -692,7 +753,11 @@ private static String getSampleMimeType(String containerMimeType, String codecs)
    * @return Whether the mimeType is a text sample mimeType.
    */
   private static boolean mimeTypeIsRawText(String mimeType) {
-    return MimeTypes.isText(mimeType) || MimeTypes.APPLICATION_TTML.equals(mimeType);
+    return MimeTypes.isText(mimeType)
+        || MimeTypes.APPLICATION_TTML.equals(mimeType)
+        || MimeTypes.APPLICATION_MP4VTT.equals(mimeType)
+        || MimeTypes.APPLICATION_CEA708.equals(mimeType)
+        || MimeTypes.APPLICATION_CEA608.equals(mimeType);
   }
 
   /**
@@ -738,52 +803,57 @@ private static int checkContentTypeConsistency(int firstType, int secondType) {
     }
   }
 
-  private static int parseAccessibilityValue(XmlPullParser xpp)
-      throws IOException, XmlPullParserException {
+  /**
+   * Parses a {@link SchemeValuePair} from an element.
+   *
+   * @param xpp The parser from which to read.
+   * @param tag The tag of the element being parsed.
+   * @throws XmlPullParserException If an error occurs parsing the element.
+   * @throws IOException If an error occurs reading the element.
+   * @return The parsed {@link SchemeValuePair}.
+   */
+  protected static SchemeValuePair parseSchemeValuePair(XmlPullParser xpp, String tag)
+      throws XmlPullParserException, IOException {
     String schemeIdUri = parseString(xpp, "schemeIdUri", null);
-    String valueString = parseString(xpp, "value", null);
-    int accessibilityValue;
-    if (schemeIdUri == null || valueString == null) {
-      accessibilityValue = Format.NO_VALUE;
-    } else if ("urn:scte:dash:cc:cea-608:2015".equals(schemeIdUri)) {
-      accessibilityValue = parseCea608AccessibilityChannel(valueString);
-    } else if ("urn:scte:dash:cc:cea-708:2015".equals(schemeIdUri)) {
-      accessibilityValue = parseCea708AccessibilityChannel(valueString);
-    } else {
-      accessibilityValue = Format.NO_VALUE;
-    }
+    String value = parseString(xpp, "value", null);
     do {
       xpp.next();
-    } while (!XmlPullParserUtil.isEndTag(xpp, "Accessibility"));
-    return accessibilityValue;
-  }
-
-  static int parseCea608AccessibilityChannel(String accessibilityValueString) {
-    if (accessibilityValueString == null) {
-      return Format.NO_VALUE;
-    }
-    Matcher accessibilityValueMatcher =
-        CEA_608_ACCESSIBILITY_PATTERN.matcher(accessibilityValueString);
-    if (accessibilityValueMatcher.matches()) {
-      return Integer.parseInt(accessibilityValueMatcher.group(1));
-    } else {
-      Log.w(TAG, "Unable to parse channel number from " + accessibilityValueString);
-      return Format.NO_VALUE;
-    }
-  }
-
-  static int parseCea708AccessibilityChannel(String accessibilityValueString) {
-    if (accessibilityValueString == null) {
-      return Format.NO_VALUE;
+    } while (!XmlPullParserUtil.isEndTag(xpp, tag));
+    return new SchemeValuePair(schemeIdUri, value);
+  }
+
+  protected static int parseCea608AccessibilityChannel(
+      List<SchemeValuePair> accessibilityDescriptors) {
+    for (int i = 0; i < accessibilityDescriptors.size(); i++) {
+      SchemeValuePair descriptor = accessibilityDescriptors.get(i);
+      if ("urn:scte:dash:cc:cea-608:2015".equals(descriptor.schemeIdUri)
+          && descriptor.value != null) {
+        Matcher accessibilityValueMatcher = CEA_608_ACCESSIBILITY_PATTERN.matcher(descriptor.value);
+        if (accessibilityValueMatcher.matches()) {
+          return Integer.parseInt(accessibilityValueMatcher.group(1));
+        } else {
+          Log.w(TAG, "Unable to parse CEA-608 channel number from: " + descriptor.value);
+        }
+      }
     }
-    Matcher accessibilityValueMatcher =
-        CEA_708_ACCESSIBILITY_PATTERN.matcher(accessibilityValueString);
-    if (accessibilityValueMatcher.matches()) {
-      return Integer.parseInt(accessibilityValueMatcher.group(1));
-    } else {
-      Log.w(TAG, "Unable to parse service block number from " + accessibilityValueString);
-      return Format.NO_VALUE;
+    return Format.NO_VALUE;
+  }
+
+  protected static int parseCea708AccessibilityChannel(
+      List<SchemeValuePair> accessibilityDescriptors) {
+    for (int i = 0; i < accessibilityDescriptors.size(); i++) {
+      SchemeValuePair descriptor = accessibilityDescriptors.get(i);
+      if ("urn:scte:dash:cc:cea-708:2015".equals(descriptor.schemeIdUri)
+          && descriptor.value != null) {
+        Matcher accessibilityValueMatcher = CEA_708_ACCESSIBILITY_PATTERN.matcher(descriptor.value);
+        if (accessibilityValueMatcher.matches()) {
+          return Integer.parseInt(accessibilityValueMatcher.group(1));
+        } else {
+          Log.w(TAG, "Unable to parse CEA-708 service block number from: " + descriptor.value);
+        }
+      }
     }
+    return Format.NO_VALUE;
   }
 
   protected static float parseFrameRate(XmlPullParser xpp, float defaultValue) {
@@ -850,13 +920,15 @@ protected static String parseString(XmlPullParser xpp, String name, String defau
     public final String baseUrl;
     public final SegmentBase segmentBase;
     public final ArrayList<SchemeData> drmSchemeDatas;
+    public final ArrayList<SchemeValuePair> inbandEventStreams;
 
     public RepresentationInfo(Format format, String baseUrl, SegmentBase segmentBase,
-        ArrayList<SchemeData> drmSchemeDatas) {
+        ArrayList<SchemeData> drmSchemeDatas, ArrayList<SchemeValuePair> inbandEventStreams) {
       this.format = format;
       this.baseUrl = baseUrl;
       this.segmentBase = segmentBase;
       this.drmSchemeDatas = drmSchemeDatas;
+      this.inbandEventStreams = inbandEventStreams;
     }
 
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Representation.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Representation.java
index f52727c1a8..4146037e1c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Representation.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Representation.java
@@ -21,6 +21,8 @@
 import com.google.android.exoplayer2.source.dash.DashSegmentIndex;
 import com.google.android.exoplayer2.source.dash.manifest.SegmentBase.MultiSegmentBase;
 import com.google.android.exoplayer2.source.dash.manifest.SegmentBase.SingleSegmentBase;
+import java.util.Collections;
+import java.util.List;
 
 /**
  * A DASH representation.
@@ -60,6 +62,10 @@
    * The offset of the presentation timestamps in the media stream relative to media time.
    */
   public final long presentationTimeOffsetUs;
+  /**
+   * The in-band event streams in the representation. Never null, but may be empty.
+   */
+  public final List<SchemeValuePair> inbandEventStreams;
 
   private final RangedUri initializationUri;
 
@@ -78,6 +84,23 @@ public static Representation newInstance(String contentId, long revisionId, Form
     return newInstance(contentId, revisionId, format, baseUrl, segmentBase, null);
   }
 
+  /**
+   * Constructs a new instance.
+   *
+   * @param contentId Identifies the piece of content to which this representation belongs.
+   * @param revisionId Identifies the revision of the content.
+   * @param format The format of the representation.
+   * @param baseUrl The base URL.
+   * @param segmentBase A segment base element for the representation.
+   * @param inbandEventStreams The in-band event streams in the representation. May be null.
+   * @return The constructed instance.
+   */
+  public static Representation newInstance(String contentId, long revisionId, Format format,
+      String baseUrl, SegmentBase segmentBase, List<SchemeValuePair> inbandEventStreams) {
+    return newInstance(contentId, revisionId, format, baseUrl, segmentBase, inbandEventStreams,
+        null);
+  }
+
   /**
    * Constructs a new instance.
    *
@@ -86,18 +109,20 @@ public static Representation newInstance(String contentId, long revisionId, Form
    * @param format The format of the representation.
    * @param baseUrl The base URL of the representation.
    * @param segmentBase A segment base element for the representation.
+   * @param inbandEventStreams The in-band event streams in the representation. May be null.
    * @param customCacheKey A custom value to be returned from {@link #getCacheKey()}, or null. This
    *     parameter is ignored if {@code segmentBase} consists of multiple segments.
    * @return The constructed instance.
    */
   public static Representation newInstance(String contentId, long revisionId, Format format,
-      String baseUrl, SegmentBase segmentBase, String customCacheKey) {
+      String baseUrl, SegmentBase segmentBase, List<SchemeValuePair> inbandEventStreams,
+      String customCacheKey) {
     if (segmentBase instanceof SingleSegmentBase) {
       return new SingleSegmentRepresentation(contentId, revisionId, format, baseUrl,
-          (SingleSegmentBase) segmentBase, customCacheKey, C.LENGTH_UNSET);
+          (SingleSegmentBase) segmentBase, inbandEventStreams, customCacheKey, C.LENGTH_UNSET);
     } else if (segmentBase instanceof MultiSegmentBase) {
       return new MultiSegmentRepresentation(contentId, revisionId, format, baseUrl,
-          (MultiSegmentBase) segmentBase);
+          (MultiSegmentBase) segmentBase, inbandEventStreams);
     } else {
       throw new IllegalArgumentException("segmentBase must be of type SingleSegmentBase or "
           + "MultiSegmentBase");
@@ -105,11 +130,14 @@ public static Representation newInstance(String contentId, long revisionId, Form
   }
 
   private Representation(String contentId, long revisionId, Format format, String baseUrl,
-      SegmentBase segmentBase) {
+      SegmentBase segmentBase, List<SchemeValuePair> inbandEventStreams) {
     this.contentId = contentId;
     this.revisionId = revisionId;
     this.format = format;
     this.baseUrl = baseUrl;
+    this.inbandEventStreams = inbandEventStreams == null
+        ? Collections.<SchemeValuePair>emptyList()
+        : Collections.unmodifiableList(inbandEventStreams);
     initializationUri = segmentBase.getInitialization(this);
     presentationTimeOffsetUs = segmentBase.getPresentationTimeOffsetUs();
   }
@@ -167,18 +195,20 @@ public RangedUri getInitializationUri() {
      * @param initializationEnd The offset of the last byte of initialization data.
      * @param indexStart The offset of the first byte of index data.
      * @param indexEnd The offset of the last byte of index data.
+     * @param inbandEventStreams The in-band event streams in the representation. May be null.
      * @param customCacheKey A custom value to be returned from {@link #getCacheKey()}, or null.
      * @param contentLength The content length, or {@link C#LENGTH_UNSET} if unknown.
      */
     public static SingleSegmentRepresentation newInstance(String contentId, long revisionId,
         Format format, String uri, long initializationStart, long initializationEnd,
-        long indexStart, long indexEnd, String customCacheKey, long contentLength) {
+        long indexStart, long indexEnd, List<SchemeValuePair> inbandEventStreams,
+        String customCacheKey, long contentLength) {
       RangedUri rangedUri = new RangedUri(null, initializationStart,
           initializationEnd - initializationStart + 1);
       SingleSegmentBase segmentBase = new SingleSegmentBase(rangedUri, 1, 0, indexStart,
           indexEnd - indexStart + 1);
       return new SingleSegmentRepresentation(contentId, revisionId,
-          format, uri, segmentBase, customCacheKey, contentLength);
+          format, uri, segmentBase, inbandEventStreams, customCacheKey, contentLength);
     }
 
     /**
@@ -187,12 +217,14 @@ public static SingleSegmentRepresentation newInstance(String contentId, long rev
      * @param format The format of the representation.
      * @param baseUrl The base URL of the representation.
      * @param segmentBase The segment base underlying the representation.
+     * @param inbandEventStreams The in-band event streams in the representation. May be null.
      * @param customCacheKey A custom value to be returned from {@link #getCacheKey()}, or null.
      * @param contentLength The content length, or {@link C#LENGTH_UNSET} if unknown.
      */
     public SingleSegmentRepresentation(String contentId, long revisionId, Format format,
-        String baseUrl, SingleSegmentBase segmentBase, String customCacheKey, long contentLength) {
-      super(contentId, revisionId, format, baseUrl, segmentBase);
+        String baseUrl, SingleSegmentBase segmentBase, List<SchemeValuePair> inbandEventStreams,
+        String customCacheKey, long contentLength) {
+      super(contentId, revisionId, format, baseUrl, segmentBase, inbandEventStreams);
       this.uri = Uri.parse(baseUrl);
       this.indexUri = segmentBase.getIndex();
       this.cacheKey = customCacheKey != null ? customCacheKey
@@ -235,10 +267,11 @@ public String getCacheKey() {
      * @param format The format of the representation.
      * @param baseUrl The base URL of the representation.
      * @param segmentBase The segment base underlying the representation.
+     * @param inbandEventStreams The in-band event streams in the representation. May be null.
      */
     public MultiSegmentRepresentation(String contentId, long revisionId, Format format,
-        String baseUrl, MultiSegmentBase segmentBase) {
-      super(contentId, revisionId, format, baseUrl, segmentBase);
+        String baseUrl, MultiSegmentBase segmentBase, List<SchemeValuePair> inbandEventStreams) {
+      super(contentId, revisionId, format, baseUrl, segmentBase, inbandEventStreams);
       this.segmentBase = segmentBase;
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SchemeValuePair.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SchemeValuePair.java
new file mode 100644
index 0000000000..470bf0f989
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SchemeValuePair.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash.manifest;
+
+import com.google.android.exoplayer2.util.Util;
+
+/**
+ * A pair consisting of a scheme ID and value.
+ */
+public class SchemeValuePair {
+
+  public final String schemeIdUri;
+  public final String value;
+
+  public SchemeValuePair(String schemeIdUri, String value) {
+    this.schemeIdUri = schemeIdUri;
+    this.value = value;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    SchemeValuePair other = (SchemeValuePair) obj;
+    return Util.areEqual(schemeIdUri, other.schemeIdUri) && Util.areEqual(value, other.value);
+  }
+
+  @Override
+  public int hashCode() {
+    return 31 * (schemeIdUri != null ? schemeIdUri.hashCode() : 0)
+        + (value != null ? value.hashCode() : 0);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SegmentBase.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SegmentBase.java
index ef319d508d..70a65e932a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SegmentBase.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SegmentBase.java
@@ -143,7 +143,7 @@ public int getSegmentNum(long timeUs, long periodDurationUs) {
       } else {
         // The high index cannot be unbounded. Identify the segment using binary search.
         while (lowIndex <= highIndex) {
-          int midIndex = (lowIndex + highIndex) / 2;
+          int midIndex = lowIndex + (highIndex - lowIndex) / 2;
           long midTimeUs = getSegmentTimeUs(midIndex);
           if (midTimeUs < timeUs) {
             lowIndex = midIndex + 1;
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
index a20e061591..130c76ec2c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
@@ -19,7 +19,6 @@
 import android.os.SystemClock;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.source.BehindLiveWindowException;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.chunk.Chunk;
@@ -33,6 +32,7 @@
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.UriUtil;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
@@ -194,15 +194,16 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
 
     // Select the variant.
     trackSelection.updateSelectedTrack(bufferedDurationUs);
-    int newVariantIndex = trackSelection.getSelectedIndexInTrackGroup();
+    int selectedVariantIndex = trackSelection.getSelectedIndexInTrackGroup();
 
-    boolean switchingVariant = oldVariantIndex != newVariantIndex;
-    HlsMediaPlaylist mediaPlaylist = playlistTracker.getPlaylistSnapshot(variants[newVariantIndex]);
-    if (mediaPlaylist == null) {
-      out.playlist = variants[newVariantIndex];
+    boolean switchingVariant = oldVariantIndex != selectedVariantIndex;
+    HlsUrl selectedUrl = variants[selectedVariantIndex];
+    if (!playlistTracker.isSnapshotValid(selectedUrl)) {
+      out.playlist = selectedUrl;
       // Retry when playlist is refreshed.
       return;
     }
+    HlsMediaPlaylist mediaPlaylist = playlistTracker.getPlaylistSnapshot(selectedUrl);
 
     // Select the chunk.
     int chunkMediaSequence;
@@ -218,8 +219,9 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
         if (chunkMediaSequence < mediaPlaylist.mediaSequence && previous != null) {
           // We try getting the next chunk without adapting in case that's the reason for falling
           // behind the live window.
-          newVariantIndex = oldVariantIndex;
-          mediaPlaylist = playlistTracker.getPlaylistSnapshot(variants[newVariantIndex]);
+          selectedVariantIndex = oldVariantIndex;
+          selectedUrl = variants[selectedVariantIndex];
+          mediaPlaylist = playlistTracker.getPlaylistSnapshot(selectedUrl);
           chunkMediaSequence = previous.getNextChunkIndex();
         }
       }
@@ -236,7 +238,7 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
       if (mediaPlaylist.hasEndTag) {
         out.endOfStream = true;
       } else /* Live */ {
-        out.playlist = variants[newVariantIndex];
+        out.playlist = selectedUrl;
       }
       return;
     }
@@ -249,7 +251,7 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
       Uri keyUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.encryptionKeyUri);
       if (!keyUri.equals(encryptionKeyUri)) {
         // Encryption is specified and the key has changed.
-        out.chunk = newEncryptionKeyChunk(keyUri, segment.encryptionIV, newVariantIndex,
+        out.chunk = newEncryptionKeyChunk(keyUri, segment.encryptionIV, selectedVariantIndex,
             trackSelection.getSelectionReason(), trackSelection.getSelectionData());
         return;
       }
@@ -270,18 +272,19 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
 
     // Compute start time of the next chunk.
     long startTimeUs = mediaPlaylist.startTimeUs + segment.relativeStartTimeUs;
+    int discontinuitySequence = mediaPlaylist.discontinuitySequence
+        + segment.relativeDiscontinuitySequence;
     TimestampAdjuster timestampAdjuster = timestampAdjusterProvider.getAdjuster(
-        segment.discontinuitySequenceNumber, startTimeUs);
+        discontinuitySequence, startTimeUs);
 
     // Configure the data source and spec for the chunk.
     Uri chunkUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.url);
     DataSpec dataSpec = new DataSpec(chunkUri, segment.byterangeOffset, segment.byterangeLength,
         null);
-    out.chunk = new HlsMediaChunk(dataSource, dataSpec, initDataSpec, variants[newVariantIndex],
+    out.chunk = new HlsMediaChunk(dataSource, dataSpec, initDataSpec, selectedUrl,
         trackSelection.getSelectionReason(), trackSelection.getSelectionData(),
-        startTimeUs, startTimeUs + segment.durationUs, chunkMediaSequence,
-        segment.discontinuitySequenceNumber, isTimestampMaster, timestampAdjuster, previous,
-        encryptionKey, encryptionIv);
+        startTimeUs, startTimeUs + segment.durationUs, chunkMediaSequence, discontinuitySequence,
+        isTimestampMaster, timestampAdjuster, previous, encryptionKey, encryptionIv);
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
index 0071a74a77..b45e7612a1 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
@@ -21,7 +21,6 @@
 import com.google.android.exoplayer2.extractor.DefaultExtractorInput;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.mp3.Mp3Extractor;
 import com.google.android.exoplayer2.extractor.mp4.FragmentedMp4Extractor;
 import com.google.android.exoplayer2.extractor.ts.Ac3Extractor;
@@ -37,6 +36,7 @@
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -79,8 +79,10 @@
   private final boolean isEncrypted;
   private final boolean isMasterTimestampSource;
   private final TimestampAdjuster timestampAdjuster;
-  private final HlsMediaChunk previousChunk;
   private final String lastPathSegment;
+  private final Extractor previousExtractor;
+  private final boolean shouldSpliceIn;
+  private final boolean needNewExtractor;
 
   private final boolean isPackedAudio;
   private final Id3Decoder id3Decoder;
@@ -123,7 +125,6 @@ public HlsMediaChunk(DataSource dataSource, DataSpec dataSpec, DataSpec initData
     this.isMasterTimestampSource = isMasterTimestampSource;
     this.timestampAdjuster = timestampAdjuster;
     this.discontinuitySequenceNumber = discontinuitySequenceNumber;
-    this.previousChunk = previousChunk;
     // Note: this.dataSource and dataSource may be different.
     this.isEncrypted = this.dataSource instanceof Aes128DataSource;
     lastPathSegment = dataSpec.uri.getLastPathSegment();
@@ -131,13 +132,19 @@ public HlsMediaChunk(DataSource dataSource, DataSpec dataSpec, DataSpec initData
         || lastPathSegment.endsWith(AC3_FILE_EXTENSION)
         || lastPathSegment.endsWith(EC3_FILE_EXTENSION)
         || lastPathSegment.endsWith(MP3_FILE_EXTENSION);
-    if (isPackedAudio) {
-      id3Decoder = previousChunk != null ? previousChunk.id3Decoder : new Id3Decoder();
-      id3Data = previousChunk != null ? previousChunk.id3Data
-          : new ParsableByteArray(Id3Decoder.ID3_HEADER_LENGTH);
+    if (previousChunk != null) {
+      id3Decoder = previousChunk.id3Decoder;
+      id3Data = previousChunk.id3Data;
+      previousExtractor = previousChunk.extractor;
+      shouldSpliceIn = previousChunk.hlsUrl != hlsUrl;
+      needNewExtractor = previousChunk.discontinuitySequenceNumber != discontinuitySequenceNumber
+          || shouldSpliceIn;
     } else {
-      id3Decoder = null;
-      id3Data = null;
+      id3Decoder = isPackedAudio ? new Id3Decoder() : null;
+      id3Data = isPackedAudio ? new ParsableByteArray(Id3Decoder.ID3_HEADER_LENGTH) : null;
+      previousExtractor = null;
+      shouldSpliceIn = false;
+      needNewExtractor = true;
     }
     initDataSource = dataSource;
     uid = UID_SOURCE.getAndIncrement();
@@ -151,7 +158,7 @@ public HlsMediaChunk(DataSource dataSource, DataSpec dataSpec, DataSpec initData
    */
   public void init(HlsSampleStreamWrapper output) {
     extractorOutput = output;
-    output.init(uid, previousChunk != null && previousChunk.hlsUrl != hlsUrl);
+    output.init(uid, shouldSpliceIn);
   }
 
   @Override
@@ -180,7 +187,7 @@ public boolean isLoadCanceled() {
   public void load() throws IOException, InterruptedException {
     if (extractor == null && !isPackedAudio) {
       // See HLS spec, version 20, Section 3.4 for more information on packed audio extraction.
-      extractor = buildExtractorByExtension();
+      extractor = createExtractor();
     }
     maybeLoadInitData();
     if (!loadCanceled) {
@@ -191,8 +198,8 @@ public void load() throws IOException, InterruptedException {
   // Internal loading methods.
 
   private void maybeLoadInitData() throws IOException, InterruptedException {
-    if ((previousChunk != null && previousChunk.extractor == extractor) || initLoadCompleted
-        || initDataSpec == null) {
+    if (previousExtractor == extractor || initLoadCompleted || initDataSpec == null) {
+      // According to spec, for packed audio, initDataSpec is expected to be null.
       return;
     }
     DataSpec initSegmentDataSpec = Util.getRemainderDataSpec(initDataSpec, initSegmentBytesLoaded);
@@ -322,20 +329,18 @@ private static DataSource buildDataSource(DataSource dataSource, byte[] encrypti
     return new Aes128DataSource(dataSource, encryptionKey, encryptionIv);
   }
 
-  private Extractor buildExtractorByExtension() {
-    // Set the extractor that will read the chunk.
+  private Extractor createExtractor() {
+    // Select the extractor that will read the chunk.
     Extractor extractor;
-    boolean needNewExtractor = previousChunk == null
-        || previousChunk.discontinuitySequenceNumber != discontinuitySequenceNumber
-        || trackFormat != previousChunk.trackFormat;
     boolean usingNewExtractor = true;
-    if (lastPathSegment.endsWith(WEBVTT_FILE_EXTENSION)
+    if (MimeTypes.TEXT_VTT.equals(hlsUrl.format.sampleMimeType)
+        || lastPathSegment.endsWith(WEBVTT_FILE_EXTENSION)
         || lastPathSegment.endsWith(VTT_FILE_EXTENSION)) {
       extractor = new WebvttExtractor(trackFormat.language, timestampAdjuster);
     } else if (!needNewExtractor) {
       // Only reuse TS and fMP4 extractors.
       usingNewExtractor = false;
-      extractor = previousChunk.extractor;
+      extractor = previousExtractor;
     } else if (lastPathSegment.endsWith(MP4_FILE_EXTENSION)) {
       extractor = new FragmentedMp4Extractor(0, timestampAdjuster);
     } else {
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
index 869efa6cdc..10e12f0ec6 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
@@ -94,24 +94,33 @@ public void releasePeriod(MediaPeriod mediaPeriod) {
 
   @Override
   public void releaseSource() {
-    playlistTracker.release();
-    playlistTracker = null;
+    if (playlistTracker != null) {
+      playlistTracker.release();
+      playlistTracker = null;
+    }
     sourceListener = null;
   }
 
   @Override
   public void onPrimaryPlaylistRefreshed(HlsMediaPlaylist playlist) {
     SinglePeriodTimeline timeline;
+    long windowDefaultStartPositionUs = playlist.startOffsetUs;
     if (playlistTracker.isLive()) {
-      // TODO: fix windowPositionInPeriodUs when playlist is empty.
+      long periodDurationUs = playlist.hasEndTag ? (playlist.startTimeUs + playlist.durationUs)
+          : C.TIME_UNSET;
       List<HlsMediaPlaylist.Segment> segments = playlist.segments;
-      long windowDefaultStartPositionUs = segments.isEmpty() ? 0
-          : segments.get(Math.max(0, segments.size() - 3)).relativeStartTimeUs;
-      timeline = new SinglePeriodTimeline(C.TIME_UNSET, playlist.durationUs,
+      if (windowDefaultStartPositionUs == C.TIME_UNSET) {
+        windowDefaultStartPositionUs = segments.isEmpty() ? 0
+            : segments.get(Math.max(0, segments.size() - 3)).relativeStartTimeUs;
+      }
+      timeline = new SinglePeriodTimeline(periodDurationUs, playlist.durationUs,
           playlist.startTimeUs, windowDefaultStartPositionUs, true, !playlist.hasEndTag);
     } else /* not live */ {
+      if (windowDefaultStartPositionUs == C.TIME_UNSET) {
+        windowDefaultStartPositionUs = 0;
+      }
       timeline = new SinglePeriodTimeline(playlist.startTimeUs + playlist.durationUs,
-          playlist.durationUs, playlist.startTimeUs, 0, true, false);
+          playlist.durationUs, playlist.startTimeUs, windowDefaultStartPositionUs, true, false);
     }
     sourceListener.onSourceInfoRefreshed(timeline, playlist);
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java
index c63cf3e5a4..04fe8a093c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java
@@ -26,7 +26,7 @@
 /* package */ final class HlsSampleStream implements SampleStream {
 
   public final int group;
-  
+
   private final HlsSampleStreamWrapper sampleStreamWrapper;
 
   public HlsSampleStream(HlsSampleStreamWrapper sampleStreamWrapper, int group) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/TimestampAdjusterProvider.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/TimestampAdjusterProvider.java
index 624e5fa4f8..41fb2c1512 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/TimestampAdjusterProvider.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/TimestampAdjusterProvider.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.source.hls;
 
 import android.util.SparseArray;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 
 /**
  * Provides {@link TimestampAdjuster} instances for use during HLS playbacks.
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/WebvttExtractor.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/WebvttExtractor.java
index 498dd55004..c8928ce65d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/WebvttExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/WebvttExtractor.java
@@ -24,12 +24,12 @@
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.text.SubtitleDecoderException;
 import com.google.android.exoplayer2.text.webvtt.WebvttParserUtil;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.regex.Matcher;
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
index 4aaec59f7d..b7426fd03d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
@@ -40,7 +40,7 @@
 
     public static HlsUrl createMediaPlaylistHlsUrl(String baseUri) {
       Format format = Format.createContainerFormat("0", MimeTypes.APPLICATION_M3U8, null, null,
-          Format.NO_VALUE);
+          Format.NO_VALUE, 0, null);
       return new HlsUrl(null, baseUri, format, null, null, null);
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
index fc70ec6de1..b8d8d69af4 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
@@ -15,7 +15,10 @@
  */
 package com.google.android.exoplayer2.source.hls.playlist;
 
+import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.C;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.util.Collections;
 import java.util.List;
 
@@ -31,7 +34,7 @@
 
     public final String url;
     public final long durationUs;
-    public final int discontinuitySequenceNumber;
+    public final int relativeDiscontinuitySequence;
     public final long relativeStartTimeUs;
     public final boolean isEncrypted;
     public final String encryptionKeyUri;
@@ -43,12 +46,12 @@ public Segment(String uri, long byterangeOffset, long byterangeLength) {
       this(uri, 0, -1, C.TIME_UNSET, false, null, null, byterangeOffset, byterangeLength);
     }
 
-    public Segment(String uri, long durationUs, int discontinuitySequenceNumber,
+    public Segment(String uri, long durationUs, int relativeDiscontinuitySequence,
         long relativeStartTimeUs, boolean isEncrypted, String encryptionKeyUri, String encryptionIV,
         long byterangeOffset, long byterangeLength) {
       this.url = uri;
       this.durationUs = durationUs;
-      this.discontinuitySequenceNumber = discontinuitySequenceNumber;
+      this.relativeDiscontinuitySequence = relativeDiscontinuitySequence;
       this.relativeStartTimeUs = relativeStartTimeUs;
       this.isEncrypted = isEncrypted;
       this.encryptionKeyUri = encryptionKeyUri;
@@ -65,7 +68,22 @@ public int compareTo(Long relativeStartTimeUs) {
 
   }
 
+  /**
+   * Type of the playlist as specified by #EXT-X-PLAYLIST-TYPE.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({PLAYLIST_TYPE_UNKNOWN, PLAYLIST_TYPE_VOD, PLAYLIST_TYPE_EVENT})
+  public @interface PlaylistType {}
+  public static final int PLAYLIST_TYPE_UNKNOWN = 0;
+  public static final int PLAYLIST_TYPE_VOD = 1;
+  public static final int PLAYLIST_TYPE_EVENT = 2;
+
+  @PlaylistType
+  public final int playlistType;
+  public final long startOffsetUs;
   public final long startTimeUs;
+  public final boolean hasDiscontinuitySequence;
+  public final int discontinuitySequence;
   public final int mediaSequence;
   public final int version;
   public final long targetDurationUs;
@@ -75,11 +93,15 @@ public int compareTo(Long relativeStartTimeUs) {
   public final List<Segment> segments;
   public final long durationUs;
 
-  public HlsMediaPlaylist(String baseUri, long startTimeUs, int mediaSequence,
-      int version, long targetDurationUs, boolean hasEndTag, boolean hasProgramDateTime,
-      Segment initializationSegment, List<Segment> segments) {
+  public HlsMediaPlaylist(@PlaylistType int playlistType, String baseUri, long startOffsetUs,
+      long startTimeUs, boolean hasDiscontinuitySequence, int discontinuitySequence,
+      int mediaSequence, int version, long targetDurationUs, boolean hasEndTag,
+      boolean hasProgramDateTime, Segment initializationSegment, List<Segment> segments) {
     super(baseUri, HlsPlaylist.TYPE_MEDIA);
+    this.playlistType = playlistType;
     this.startTimeUs = startTimeUs;
+    this.hasDiscontinuitySequence = hasDiscontinuitySequence;
+    this.discontinuitySequence = discontinuitySequence;
     this.mediaSequence = mediaSequence;
     this.version = version;
     this.targetDurationUs = targetDurationUs;
@@ -87,28 +109,68 @@ public HlsMediaPlaylist(String baseUri, long startTimeUs, int mediaSequence,
     this.hasProgramDateTime = hasProgramDateTime;
     this.initializationSegment = initializationSegment;
     this.segments = Collections.unmodifiableList(segments);
-
     if (!segments.isEmpty()) {
       Segment last = segments.get(segments.size() - 1);
       durationUs = last.relativeStartTimeUs + last.durationUs;
     } else {
       durationUs = 0;
     }
+    this.startOffsetUs = startOffsetUs == C.TIME_UNSET ? C.TIME_UNSET
+        : startOffsetUs >= 0 ? startOffsetUs : durationUs + startOffsetUs;
   }
 
+  /**
+   * Returns whether this playlist is newer than {@code other}.
+   *
+   * @param other The playlist to compare.
+   * @return Whether this playlist is newer than {@code other}.
+   */
   public boolean isNewerThan(HlsMediaPlaylist other) {
-    return other == null || mediaSequence > other.mediaSequence
-        || (mediaSequence == other.mediaSequence && segments.size() > other.segments.size())
-        || (hasEndTag && !other.hasEndTag);
+    if (other == null || mediaSequence > other.mediaSequence) {
+      return true;
+    }
+    if (mediaSequence < other.mediaSequence) {
+      return false;
+    }
+    // The media sequences are equal.
+    int segmentCount = segments.size();
+    int otherSegmentCount = other.segments.size();
+    return segmentCount > otherSegmentCount
+        || (segmentCount == otherSegmentCount && hasEndTag && !other.hasEndTag);
   }
 
   public long getEndTimeUs() {
     return startTimeUs + durationUs;
   }
 
-  public HlsMediaPlaylist copyWithStartTimeUs(long startTimeUs) {
-    return new HlsMediaPlaylist(baseUri, startTimeUs, mediaSequence, version, targetDurationUs,
-        hasEndTag, hasProgramDateTime, initializationSegment, segments);
+  /**
+   * Returns a playlist identical to this one except for the start time, the discontinuity sequence
+   * and {@code hasDiscontinuitySequence} values. The first two are set to the specified values,
+   * {@code hasDiscontinuitySequence} is set to true.
+   *
+   * @param startTimeUs The start time for the returned playlist.
+   * @param discontinuitySequence The discontinuity sequence for the returned playlist.
+   * @return The playlist.
+   */
+  public HlsMediaPlaylist copyWith(long startTimeUs, int discontinuitySequence) {
+    return new HlsMediaPlaylist(playlistType, baseUri, startOffsetUs, startTimeUs, true,
+        discontinuitySequence, mediaSequence, version, targetDurationUs, hasEndTag,
+        hasProgramDateTime, initializationSegment, segments);
+  }
+
+  /**
+   * Returns a playlist identical to this one except that an end tag is added. If an end tag is
+   * already present then the playlist will return itself.
+   *
+   * @return The playlist.
+   */
+  public HlsMediaPlaylist copyWithEndTag() {
+    if (this.hasEndTag) {
+      return this;
+    }
+    return new HlsMediaPlaylist(playlistType, baseUri, startOffsetUs, startTimeUs,
+        hasDiscontinuitySequence, discontinuitySequence, mediaSequence, version, targetDurationUs,
+        true, hasProgramDateTime, initializationSegment, segments);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
index 1932caccf7..a211417501 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.source.UnrecognizedInputFormatException;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist.Segment;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
 import com.google.android.exoplayer2.util.MimeTypes;
@@ -39,16 +40,20 @@
  */
 public final class HlsPlaylistParser implements ParsingLoadable.Parser<HlsPlaylist> {
 
+  private static final String PLAYLIST_HEADER = "#EXTM3U";
+
   private static final String TAG_VERSION = "#EXT-X-VERSION";
+  private static final String TAG_PLAYLIST_TYPE = "#EXT-X-PLAYLIST-TYPE";
   private static final String TAG_STREAM_INF = "#EXT-X-STREAM-INF";
   private static final String TAG_MEDIA = "#EXT-X-MEDIA";
+  private static final String TAG_TARGET_DURATION = "#EXT-X-TARGETDURATION";
   private static final String TAG_DISCONTINUITY = "#EXT-X-DISCONTINUITY";
   private static final String TAG_DISCONTINUITY_SEQUENCE = "#EXT-X-DISCONTINUITY-SEQUENCE";
   private static final String TAG_PROGRAM_DATE_TIME = "#EXT-X-PROGRAM-DATE-TIME";
   private static final String TAG_INIT_SEGMENT = "#EXT-X-MAP";
   private static final String TAG_MEDIA_DURATION = "#EXTINF";
   private static final String TAG_MEDIA_SEQUENCE = "#EXT-X-MEDIA-SEQUENCE";
-  private static final String TAG_TARGET_DURATION = "#EXT-X-TARGETDURATION";
+  private static final String TAG_START = "#EXT-X-START";
   private static final String TAG_ENDLIST = "#EXT-X-ENDLIST";
   private static final String TAG_KEY = "#EXT-X-KEY";
   private static final String TAG_BYTERANGE = "#EXT-X-BYTERANGE";
@@ -70,10 +75,13 @@
   private static final Pattern REGEX_TARGET_DURATION = Pattern.compile(TAG_TARGET_DURATION
       + ":(\\d+)\\b");
   private static final Pattern REGEX_VERSION = Pattern.compile(TAG_VERSION + ":(\\d+)\\b");
+  private static final Pattern REGEX_PLAYLIST_TYPE = Pattern.compile(TAG_PLAYLIST_TYPE
+      + ":(.+)\\b");
   private static final Pattern REGEX_MEDIA_SEQUENCE = Pattern.compile(TAG_MEDIA_SEQUENCE
       + ":(\\d+)\\b");
   private static final Pattern REGEX_MEDIA_DURATION = Pattern.compile(TAG_MEDIA_DURATION
       + ":([\\d\\.]+)\\b");
+  private static final Pattern REGEX_TIME_OFFSET = Pattern.compile("TIME-OFFSET=([\\d\\.]+)\\b");
   private static final Pattern REGEX_BYTERANGE = Pattern.compile(TAG_BYTERANGE
       + ":(\\d+(?:@\\d+)?)\\b");
   private static final Pattern REGEX_ATTR_BYTERANGE =
@@ -97,6 +105,10 @@ public HlsPlaylist parse(Uri uri, InputStream inputStream) throws IOException {
     Queue<String> extraLines = new LinkedList<>();
     String line;
     try {
+      if (!checkPlaylistHeader(reader)) {
+        throw new UnrecognizedInputFormatException("Input does not start with the #EXTM3U header.",
+            uri);
+      }
       while ((line = reader.readLine()) != null) {
         line = line.trim();
         if (line.isEmpty()) {
@@ -119,11 +131,40 @@ public HlsPlaylist parse(Uri uri, InputStream inputStream) throws IOException {
         }
       }
     } finally {
-      reader.close();
+      Util.closeQuietly(reader);
     }
     throw new ParserException("Failed to parse the playlist, could not identify any tags.");
   }
 
+  private static boolean checkPlaylistHeader(BufferedReader reader) throws IOException {
+    int last = reader.read();
+    if (last == 0xEF) {
+      if (reader.read() != 0xBB || reader.read() != 0xBF) {
+        return false;
+      }
+      // The playlist contains a Byte Order Mark, which gets discarded.
+      last = reader.read();
+    }
+    last = skipIgnorableWhitespace(reader, true, last);
+    int playlistHeaderLength = PLAYLIST_HEADER.length();
+    for (int i = 0; i < playlistHeaderLength; i++) {
+      if (last != PLAYLIST_HEADER.charAt(i)) {
+        return false;
+      }
+      last = reader.read();
+    }
+    last = skipIgnorableWhitespace(reader, false, last);
+    return Util.isLinebreak(last);
+  }
+
+  private static int skipIgnorableWhitespace(BufferedReader reader, boolean skipLinebreaks, int c)
+      throws IOException {
+    while (c != -1 && Character.isWhitespace(c) && (skipLinebreaks || !Util.isLinebreak(c))) {
+      c = reader.read();
+    }
+    return c;
+  }
+
   private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, String baseUri)
       throws IOException {
     ArrayList<HlsMasterPlaylist.HlsUrl> variants = new ArrayList<>();
@@ -190,7 +231,7 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
         line = iterator.next();
         String name = Integer.toString(variants.size());
         Format format = Format.createVideoContainerFormat(name, MimeTypes.APPLICATION_M3U8, null,
-            codecs, bitrate, width, height, Format.NO_VALUE, null);
+            codecs, bitrate, width, height, Format.NO_VALUE, null, 0);
         variants.add(new HlsMasterPlaylist.HlsUrl(name, line, format, null, null, null));
       }
     }
@@ -207,6 +248,8 @@ private static int parseSelectionFlags(String line) {
 
   private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String baseUri)
       throws IOException {
+    @HlsMediaPlaylist.PlaylistType int playlistType = HlsMediaPlaylist.PLAYLIST_TYPE_UNKNOWN;
+    long startOffsetUs = C.TIME_UNSET;
     int mediaSequence = 0;
     int version = 1; // Default version == 1.
     long targetDurationUs = C.TIME_UNSET;
@@ -215,7 +258,9 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
     List<Segment> segments = new ArrayList<>();
 
     long segmentDurationUs = 0;
-    int discontinuitySequenceNumber = 0;
+    boolean hasDiscontinuitySequence = false;
+    int playlistDiscontinuitySequence = 0;
+    int relativeDiscontinuitySequence = 0;
     long playlistStartTimeUs = 0;
     long segmentStartTimeUs = 0;
     long segmentByteRangeOffset = 0;
@@ -229,7 +274,18 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
     String line;
     while (iterator.hasNext()) {
       line = iterator.next();
-      if (line.startsWith(TAG_INIT_SEGMENT)) {
+      if (line.startsWith(TAG_PLAYLIST_TYPE)) {
+        String playlistTypeString = parseStringAttr(line, REGEX_PLAYLIST_TYPE);
+        if ("VOD".equals(playlistTypeString)) {
+          playlistType = HlsMediaPlaylist.PLAYLIST_TYPE_VOD;
+        } else if ("EVENT".equals(playlistTypeString)) {
+          playlistType = HlsMediaPlaylist.PLAYLIST_TYPE_EVENT;
+        } else {
+          throw new ParserException("Illegal playlist type: " + playlistTypeString);
+        }
+      } else if (line.startsWith(TAG_START)) {
+        startOffsetUs = (long) (parseDoubleAttr(line, REGEX_TIME_OFFSET) * C.MICROS_PER_SECOND);
+      } else if (line.startsWith(TAG_INIT_SEGMENT)) {
         String uri = parseStringAttr(line, REGEX_URI);
         String byteRange = parseOptionalStringAttr(line, REGEX_ATTR_BYTERANGE);
         if (byteRange != null) {
@@ -270,9 +326,10 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
           segmentByteRangeOffset = Long.parseLong(splitByteRange[1]);
         }
       } else if (line.startsWith(TAG_DISCONTINUITY_SEQUENCE)) {
-        discontinuitySequenceNumber = Integer.parseInt(line.substring(line.indexOf(':') + 1));
+        hasDiscontinuitySequence = true;
+        playlistDiscontinuitySequence = Integer.parseInt(line.substring(line.indexOf(':') + 1));
       } else if (line.equals(TAG_DISCONTINUITY)) {
-        discontinuitySequenceNumber++;
+        relativeDiscontinuitySequence++;
       } else if (line.startsWith(TAG_PROGRAM_DATE_TIME)) {
         if (playlistStartTimeUs == 0) {
           long programDatetimeUs =
@@ -292,7 +349,7 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
         if (segmentByteRangeLength == C.LENGTH_UNSET) {
           segmentByteRangeOffset = 0;
         }
-        segments.add(new Segment(line, segmentDurationUs, discontinuitySequenceNumber,
+        segments.add(new Segment(line, segmentDurationUs, relativeDiscontinuitySequence,
             segmentStartTimeUs, isEncrypted, encryptionKeyUri, segmentEncryptionIV,
             segmentByteRangeOffset, segmentByteRangeLength));
         segmentStartTimeUs += segmentDurationUs;
@@ -305,7 +362,8 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
         hasEndTag = true;
       }
     }
-    return new HlsMediaPlaylist(baseUri, playlistStartTimeUs, mediaSequence, version,
+    return new HlsMediaPlaylist(playlistType, baseUri, startOffsetUs, playlistStartTimeUs,
+        hasDiscontinuitySequence, playlistDiscontinuitySequence, mediaSequence, version,
         targetDurationUs, hasEndTag, playlistStartTimeUs != 0, initializationSegment, segments);
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
index d25e5b1d9c..356aa0b466 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
@@ -166,8 +166,24 @@ public HlsMasterPlaylist getMasterPlaylist() {
    *     be null if no snapshot has been loaded yet.
    */
   public HlsMediaPlaylist getPlaylistSnapshot(HlsUrl url) {
-    maybeSetPrimaryUrl(url);
-    return playlistBundles.get(url).getPlaylistSnapshot();
+    HlsMediaPlaylist snapshot = playlistBundles.get(url).getPlaylistSnapshot();
+    if (snapshot != null) {
+      maybeSetPrimaryUrl(url);
+    }
+    return snapshot;
+  }
+
+  /**
+   * Returns whether the snapshot of the playlist referenced by the provided {@link HlsUrl} is
+   * valid, meaning all the segments referenced by the playlist are expected to be available. If the
+   * playlist is not valid then some of the segments may no longer be available.
+
+   * @param url The {@link HlsUrl}.
+   * @return Whether the snapshot of the playlist referenced by the provided {@link HlsUrl} is
+   *     valid.
+   */
+  public boolean isSnapshotValid(HlsUrl url) {
+    return playlistBundles.get(url).isSnapshotValid();
   }
 
   /**
@@ -334,45 +350,71 @@ private void notifyPlaylistBlacklisting(HlsUrl url, long blacklistMs) {
     }
   }
 
-  /**
-   * TODO: Track discontinuities for media playlists that don't include the discontinuity number.
-   */
-  private HlsMediaPlaylist adjustPlaylistTimestamps(HlsMediaPlaylist oldPlaylist,
-      HlsMediaPlaylist newPlaylist) {
-    if (newPlaylist.hasProgramDateTime) {
-      if (newPlaylist.isNewerThan(oldPlaylist)) {
-        return newPlaylist;
+  private HlsMediaPlaylist getLatestPlaylistSnapshot(HlsMediaPlaylist oldPlaylist,
+      HlsMediaPlaylist loadedPlaylist) {
+    if (!loadedPlaylist.isNewerThan(oldPlaylist)) {
+      if (loadedPlaylist.hasEndTag) {
+        // If the loaded playlist has an end tag but is not newer than the old playlist then we have
+        // an inconsistent state. This is typically caused by the server incorrectly resetting the
+        // media sequence when appending the end tag. We resolve this case as best we can by
+        // returning the old playlist with the end tag appended.
+        return oldPlaylist.copyWithEndTag();
       } else {
         return oldPlaylist;
       }
     }
-    // TODO: Once playlist type support is added, the snapshot's age can be added by using the
-    // target duration.
+    long startTimeUs = getLoadedPlaylistStartTimeUs(oldPlaylist, loadedPlaylist);
+    int discontinuitySequence = getLoadedPlaylistDiscontinuitySequence(oldPlaylist, loadedPlaylist);
+    return loadedPlaylist.copyWith(startTimeUs, discontinuitySequence);
+  }
+
+  private long getLoadedPlaylistStartTimeUs(HlsMediaPlaylist oldPlaylist,
+      HlsMediaPlaylist loadedPlaylist) {
+    if (loadedPlaylist.hasProgramDateTime) {
+      return loadedPlaylist.startTimeUs;
+    }
     long primarySnapshotStartTimeUs = primaryUrlSnapshot != null
         ? primaryUrlSnapshot.startTimeUs : 0;
     if (oldPlaylist == null) {
-      if (newPlaylist.startTimeUs == primarySnapshotStartTimeUs) {
-        // Playback has just started or is VOD so no adjustment is needed.
-        return newPlaylist;
-      } else {
-        return newPlaylist.copyWithStartTimeUs(primarySnapshotStartTimeUs);
-      }
+      return primarySnapshotStartTimeUs;
     }
-    List<Segment> oldSegments = oldPlaylist.segments;
-    int oldPlaylistSize = oldSegments.size();
-    if (!newPlaylist.isNewerThan(oldPlaylist)) {
-      // Playlist has not changed.
-      return oldPlaylist;
+    int oldPlaylistSize = oldPlaylist.segments.size();
+    Segment firstOldOverlappingSegment = getFirstOldOverlappingSegment(oldPlaylist, loadedPlaylist);
+    if (firstOldOverlappingSegment != null) {
+      return oldPlaylist.startTimeUs + firstOldOverlappingSegment.relativeStartTimeUs;
+    } else if (oldPlaylistSize == loadedPlaylist.mediaSequence - oldPlaylist.mediaSequence) {
+      return oldPlaylist.getEndTimeUs();
+    } else {
+      // No segments overlap, we assume the new playlist start coincides with the primary playlist.
+      return primarySnapshotStartTimeUs;
+    }
+  }
+
+  private int getLoadedPlaylistDiscontinuitySequence(HlsMediaPlaylist oldPlaylist,
+      HlsMediaPlaylist loadedPlaylist) {
+    if (loadedPlaylist.hasDiscontinuitySequence) {
+      return loadedPlaylist.discontinuitySequence;
+    }
+    // TODO: Improve cross-playlist discontinuity adjustment.
+    int primaryUrlDiscontinuitySequence = primaryUrlSnapshot != null
+        ? primaryUrlSnapshot.discontinuitySequence : 0;
+    if (oldPlaylist == null) {
+      return primaryUrlDiscontinuitySequence;
     }
-    int mediaSequenceOffset = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;
-    if (mediaSequenceOffset <= oldPlaylistSize) {
-      long adjustedNewPlaylistStartTimeUs = mediaSequenceOffset == oldPlaylistSize
-          ? oldPlaylist.getEndTimeUs()
-          : oldPlaylist.startTimeUs + oldSegments.get(mediaSequenceOffset).relativeStartTimeUs;
-      return newPlaylist.copyWithStartTimeUs(adjustedNewPlaylistStartTimeUs);
+    Segment firstOldOverlappingSegment = getFirstOldOverlappingSegment(oldPlaylist, loadedPlaylist);
+    if (firstOldOverlappingSegment != null) {
+      return oldPlaylist.discontinuitySequence
+          + firstOldOverlappingSegment.relativeDiscontinuitySequence
+          - loadedPlaylist.segments.get(0).relativeDiscontinuitySequence;
     }
-    // No segments overlap, we assume the new playlist start coincides with the primary playlist.
-    return newPlaylist.copyWithStartTimeUs(primarySnapshotStartTimeUs);
+    return primaryUrlDiscontinuitySequence;
+  }
+
+  private static Segment getFirstOldOverlappingSegment(HlsMediaPlaylist oldPlaylist,
+      HlsMediaPlaylist loadedPlaylist) {
+    int mediaSequenceOffset = loadedPlaylist.mediaSequence - oldPlaylist.mediaSequence;
+    List<Segment> oldSegments = oldPlaylist.segments;
+    return mediaSequenceOffset < oldSegments.size() ? oldSegments.get(mediaSequenceOffset) : null;
   }
 
   /**
@@ -386,6 +428,7 @@ private HlsMediaPlaylist adjustPlaylistTimestamps(HlsMediaPlaylist oldPlaylist,
     private final ParsingLoadable<HlsPlaylist> mediaPlaylistLoadable;
 
     private HlsMediaPlaylist playlistSnapshot;
+    private long lastSnapshotLoadMs;
     private long lastSnapshotAccessTimeMs;
     private long blacklistUntilMs;
 
@@ -403,6 +446,18 @@ public HlsMediaPlaylist getPlaylistSnapshot() {
       return playlistSnapshot;
     }
 
+    public boolean isSnapshotValid() {
+      if (playlistSnapshot == null) {
+        return false;
+      }
+      long currentTimeMs = SystemClock.elapsedRealtime();
+      long snapshotValidityDurationMs = Math.max(30000, C.usToMs(playlistSnapshot.durationUs));
+      return playlistSnapshot.hasEndTag
+          || playlistSnapshot.playlistType == HlsMediaPlaylist.PLAYLIST_TYPE_EVENT
+          || playlistSnapshot.playlistType == HlsMediaPlaylist.PLAYLIST_TYPE_VOD
+          || lastSnapshotLoadMs + snapshotValidityDurationMs > currentTimeMs;
+    }
+
     public void release() {
       mediaPlaylistLoader.release();
     }
@@ -460,15 +515,16 @@ public void run() {
 
     // Internal methods.
 
-    private void processLoadedPlaylist(HlsMediaPlaylist loadedMediaPlaylist) {
+    private void processLoadedPlaylist(HlsMediaPlaylist loadedPlaylist) {
       HlsMediaPlaylist oldPlaylist = playlistSnapshot;
-      playlistSnapshot = adjustPlaylistTimestamps(oldPlaylist, loadedMediaPlaylist);
+      lastSnapshotLoadMs = SystemClock.elapsedRealtime();
+      playlistSnapshot = getLatestPlaylistSnapshot(oldPlaylist, loadedPlaylist);
       long refreshDelayUs = C.TIME_UNSET;
-      if (oldPlaylist != playlistSnapshot) {
+      if (playlistSnapshot != oldPlaylist) {
         if (onPlaylistUpdated(playlistUrl, playlistSnapshot)) {
           refreshDelayUs = playlistSnapshot.targetDurationUs;
         }
-      } else if (!loadedMediaPlaylist.hasEndTag) {
+      } else if (!playlistSnapshot.hasEndTag) {
         refreshDelayUs = playlistSnapshot.targetDurationUs / 2;
       }
       if (refreshDelayUs != C.TIME_UNSET) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java b/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
index b17a424ee6..3ca5f8d997 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
@@ -625,7 +625,7 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
         List<byte[]> codecSpecificData = buildCodecSpecificData(
             parser.getAttributeValue(null, KEY_CODEC_PRIVATE_DATA));
         format = Format.createVideoContainerFormat(id, MimeTypes.VIDEO_MP4, sampleMimeType, null,
-            bitrate, width, height, Format.NO_VALUE, codecSpecificData);
+            bitrate, width, height, Format.NO_VALUE, codecSpecificData, 0);
       } else if (type == C.TRACK_TYPE_AUDIO) {
         sampleMimeType = sampleMimeType == null ? MimeTypes.AUDIO_AAC : sampleMimeType;
         int channels = parseRequiredInt(parser, KEY_CHANNELS);
@@ -644,8 +644,8 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
         format = Format.createTextContainerFormat(id, MimeTypes.APPLICATION_MP4, sampleMimeType,
             null, bitrate, 0, language);
       } else {
-        format = Format.createContainerFormat(id, MimeTypes.APPLICATION_MP4, null, sampleMimeType,
-            bitrate);
+        format = Format.createContainerFormat(id, MimeTypes.APPLICATION_MP4, sampleMimeType, null,
+            bitrate, 0, null);
       }
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/Cue.java b/library/src/main/java/com/google/android/exoplayer2/text/Cue.java
index 1c29f10c84..c4c5a7e4ca 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/Cue.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/Cue.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.text;
 
+import android.graphics.Color;
 import android.support.annotation.IntDef;
 import android.text.Layout.Alignment;
 import java.lang.annotation.Retention;
@@ -36,19 +37,23 @@
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({TYPE_UNSET, ANCHOR_TYPE_START, ANCHOR_TYPE_MIDDLE, ANCHOR_TYPE_END})
   public @interface AnchorType {}
+
   /**
    * An unset anchor or line type value.
    */
   public static final int TYPE_UNSET = Integer.MIN_VALUE;
+
   /**
    * Anchors the left (for horizontal positions) or top (for vertical positions) edge of the cue
    * box.
    */
   public static final int ANCHOR_TYPE_START = 0;
+
   /**
    * Anchors the middle of the cue box.
    */
   public static final int ANCHOR_TYPE_MIDDLE = 1;
+
   /**
    * Anchors the right (for horizontal positions) or bottom (for vertical positions) edge of the cue
    * box.
@@ -61,10 +66,12 @@
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({TYPE_UNSET, LINE_TYPE_FRACTION, LINE_TYPE_NUMBER})
   public @interface LineType {}
+
   /**
    * Value for {@link #lineType} when {@link #line} is a fractional position.
    */
   public static final int LINE_TYPE_FRACTION = 0;
+
   /**
    * Value for {@link #lineType} when {@link #line} is a line number.
    */
@@ -74,10 +81,12 @@
    * The cue text. Note the {@link CharSequence} may be decorated with styling spans.
    */
   public final CharSequence text;
+
   /**
    * The alignment of the cue text within the cue box, or null if the alignment is undefined.
    */
   public final Alignment textAlignment;
+
   /**
    * The position of the {@link #lineAnchor} of the cue box within the viewport in the direction
    * orthogonal to the writing direction, or {@link #DIMEN_UNSET}. When set, the interpretation of
@@ -86,6 +95,7 @@
    * For horizontal text and {@link #lineType} equal to {@link #LINE_TYPE_FRACTION}, this is the
    * fractional vertical position relative to the top of the viewport.
    */
+
   public final float line;
   /**
    * The type of the {@link #line} value.
@@ -112,6 +122,7 @@
    * {@code (line == -2 && lineAnchor == ANCHOR_TYPE_START)} position a cue so that only its first
    * line is visible at the bottom of the viewport.
    */
+
   @LineType
   public final int lineType;
   /**
@@ -122,6 +133,7 @@
    * and {@link #ANCHOR_TYPE_END} correspond to the top, middle and bottom of the cue box
    * respectively.
    */
+
   @AnchorType
   public final int lineAnchor;
   /**
@@ -133,6 +145,7 @@
    * text.
    */
   public final float position;
+
   /**
    * The cue box anchor positioned by {@link #position}. One of {@link #ANCHOR_TYPE_START},
    * {@link #ANCHOR_TYPE_MIDDLE}, {@link #ANCHOR_TYPE_END} and {@link #TYPE_UNSET}.
@@ -143,12 +156,23 @@
    */
   @AnchorType
   public final int positionAnchor;
+
   /**
    * The size of the cue box in the writing direction specified as a fraction of the viewport size
    * in that direction, or {@link #DIMEN_UNSET}.
    */
   public final float size;
 
+  /**
+   * Specifies whether or not the {@link #windowColor} property is set.
+   */
+  public final boolean windowColorSet;
+
+  /**
+   * The fill color of the window.
+   */
+  public final int windowColor;
+
   /**
    * Constructs a cue whose {@link #textAlignment} is null, whose type parameters are set to
    * {@link #TYPE_UNSET} and whose dimension parameters are set to {@link #DIMEN_UNSET}.
@@ -171,6 +195,25 @@ public Cue(CharSequence text) {
    */
   public Cue(CharSequence text, Alignment textAlignment, float line, @LineType int lineType,
       @AnchorType int lineAnchor, float position, @AnchorType int positionAnchor, float size) {
+    this(text, textAlignment, line, lineType, lineAnchor, position, positionAnchor, size, false,
+        Color.BLACK);
+  }
+
+  /**
+   * @param text See {@link #text}.
+   * @param textAlignment See {@link #textAlignment}.
+   * @param line See {@link #line}.
+   * @param lineType See {@link #lineType}.
+   * @param lineAnchor See {@link #lineAnchor}.
+   * @param position See {@link #position}.
+   * @param positionAnchor See {@link #positionAnchor}.
+   * @param size See {@link #size}.
+   * @param windowColorSet See {@link #windowColorSet}.
+   * @param windowColor See {@link #windowColor}.
+   */
+  public Cue(CharSequence text, Alignment textAlignment, float line, @LineType int lineType,
+      @AnchorType int lineAnchor, float position, @AnchorType int positionAnchor, float size,
+      boolean windowColorSet, int windowColor) {
     this.text = text;
     this.textAlignment = textAlignment;
     this.line = line;
@@ -179,6 +222,8 @@ public Cue(CharSequence text, Alignment textAlignment, float line, @LineType int
     this.position = position;
     this.positionAnchor = positionAnchor;
     this.size = size;
+    this.windowColorSet = windowColorSet;
+    this.windowColor = windowColor;
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java b/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java
index a5d1c0a9c0..077fc8848b 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.text.cea.Cea608Decoder;
+import com.google.android.exoplayer2.text.cea.Cea708Decoder;
 import com.google.android.exoplayer2.text.subrip.SubripDecoder;
 import com.google.android.exoplayer2.text.ttml.TtmlDecoder;
 import com.google.android.exoplayer2.text.tx3g.Tx3gDecoder;
@@ -58,6 +59,7 @@
    * <li>SubRip ({@link SubripDecoder})</li>
    * <li>TX3G ({@link Tx3gDecoder})</li>
    * <li>Cea608 ({@link Cea608Decoder})</li>
+   * <li>Cea708 ({@link Cea708Decoder})</li>
    * </ul>
    */
   SubtitleDecoderFactory DEFAULT = new SubtitleDecoderFactory() {
@@ -74,9 +76,13 @@ public SubtitleDecoder createDecoder(Format format) {
         if (clazz == null) {
           throw new IllegalArgumentException("Attempted to create decoder for unsupported format");
         }
-        if (clazz == Cea608Decoder.class) {
+        if (format.sampleMimeType.equals(MimeTypes.APPLICATION_CEA608)
+            || format.sampleMimeType.equals(MimeTypes.APPLICATION_MP4CEA608)) {
           return clazz.asSubclass(SubtitleDecoder.class).getConstructor(String.class, Integer.TYPE)
               .newInstance(format.sampleMimeType, format.accessibilityChannel);
+        } else if (format.sampleMimeType.equals(MimeTypes.APPLICATION_CEA708)) {
+          return clazz.asSubclass(SubtitleDecoder.class).getConstructor(Integer.TYPE)
+              .newInstance(format.accessibilityChannel);
         } else {
           return clazz.asSubclass(SubtitleDecoder.class).getConstructor().newInstance();
         }
@@ -104,6 +110,8 @@ public SubtitleDecoder createDecoder(Format format) {
           case MimeTypes.APPLICATION_CEA608:
           case MimeTypes.APPLICATION_MP4CEA608:
             return Class.forName("com.google.android.exoplayer2.text.cea.Cea608Decoder");
+          case MimeTypes.APPLICATION_CEA708:
+            return Class.forName("com.google.android.exoplayer2.text.cea.Cea708Decoder");
           default:
             return null;
         }
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java b/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
index 3ae8ded9ba..7324c94288 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
@@ -49,12 +49,6 @@
   private static final int NTSC_CC_FIELD_2 = 0x01;
   private static final int CC_VALID_608_ID = 0x04;
 
-  private static final int PAYLOAD_TYPE_CC = 4;
-  private static final int COUNTRY_CODE = 0xB5;
-  private static final int PROVIDER_CODE = 0x31;
-  private static final int USER_ID = 0x47413934; // "GA94"
-  private static final int USER_DATA_TYPE_CODE = 0x3;
-
   private static final int CC_MODE_UNKNOWN = 0;
   private static final int CC_MODE_ROLL_UP = 1;
   private static final int CC_MODE_POP_ON = 2;
@@ -573,31 +567,6 @@ private static boolean isRepeatable(byte cc1) {
     return (cc1 & 0xF0) == 0x10;
   }
 
-  /**
-   * Inspects an sei message to determine whether it contains CEA-608.
-   * <p>
-   * The position of {@code payload} is left unchanged.
-   *
-   * @param payloadType The payload type of the message.
-   * @param payloadLength The length of the payload.
-   * @param payload A {@link ParsableByteArray} containing the payload.
-   * @return Whether the sei message contains CEA-608.
-   */
-  public static boolean isSeiMessageCea608(int payloadType, int payloadLength,
-      ParsableByteArray payload) {
-    if (payloadType != PAYLOAD_TYPE_CC || payloadLength < 8) {
-      return false;
-    }
-    int startPosition = payload.getPosition();
-    int countryCode = payload.readUnsignedByte();
-    int providerCode = payload.readUnsignedShort();
-    int userIdentifier = payload.readInt();
-    int userDataTypeCode = payload.readUnsignedByte();
-    payload.setPosition(startPosition);
-    return countryCode == COUNTRY_CODE && providerCode == PROVIDER_CODE
-        && userIdentifier == USER_ID && userDataTypeCode == USER_DATA_TYPE_CODE;
-  }
-
   private static class CueBuilder {
 
     private static final int POSITION_UNSET = -1;
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Cue.java b/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Cue.java
new file mode 100644
index 0000000000..e63d1d4118
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Cue.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.text.cea;
+
+import android.text.Layout.Alignment;
+import com.google.android.exoplayer2.text.Cue;
+
+/**
+ * A {@link Cue} for CEA-708.
+ */
+/* package */ final class Cea708Cue extends Cue implements Comparable<Cea708Cue> {
+
+  /**
+   * An unset priority.
+   */
+  public static final int PRIORITY_UNSET = -1;
+
+  /**
+   * The priority of the cue box.
+   */
+  public final int priority;
+
+  /**
+   * @param text See {@link #text}.
+   * @param textAlignment See {@link #textAlignment}.
+   * @param line See {@link #line}.
+   * @param lineType See {@link #lineType}.
+   * @param lineAnchor See {@link #lineAnchor}.
+   * @param position See {@link #position}.
+   * @param positionAnchor See {@link #positionAnchor}.
+   * @param size See {@link #size}.
+   * @param windowColorSet See {@link #windowColorSet}.
+   * @param windowColor See {@link #windowColor}.
+   * @param priority See (@link #priority}.
+   */
+  public Cea708Cue(CharSequence text, Alignment textAlignment, float line, @LineType int lineType,
+      @AnchorType int lineAnchor, float position, @AnchorType int positionAnchor, float size,
+      boolean windowColorSet, int windowColor, int priority) {
+    super(text, textAlignment, line, lineType, lineAnchor, position, positionAnchor, size,
+        windowColorSet, windowColor);
+    this.priority = priority;
+  }
+
+  @Override
+  public int compareTo(Cea708Cue other) {
+    if (other.priority < priority) {
+      return -1;
+    } else if (other.priority > priority) {
+      return 1;
+    }
+    return 0;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java b/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java
new file mode 100644
index 0000000000..5ca5ce1270
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java
@@ -0,0 +1,1225 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.text.cea;
+
+import android.graphics.Color;
+import android.graphics.Typeface;
+import android.text.Layout.Alignment;
+import android.text.SpannableString;
+import android.text.SpannableStringBuilder;
+import android.text.Spanned;
+import android.text.style.BackgroundColorSpan;
+import android.text.style.ForegroundColorSpan;
+import android.text.style.StyleSpan;
+import android.text.style.UnderlineSpan;
+import android.util.Log;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.text.Cue;
+import com.google.android.exoplayer2.text.Cue.AnchorType;
+import com.google.android.exoplayer2.text.Subtitle;
+import com.google.android.exoplayer2.text.SubtitleDecoder;
+import com.google.android.exoplayer2.text.SubtitleInputBuffer;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.ParsableBitArray;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * A {@link SubtitleDecoder} for CEA-708 (also known as "EIA-708").
+ *
+ * <p>This implementation does not provide full compatibility with the CEA-708 specification. Note
+ * that only the default pen/text and window/cue colors (i.e. text with
+ * {@link CueBuilder#COLOR_SOLID_WHITE} foreground and {@link CueBuilder#COLOR_SOLID_BLACK}
+ * background, and cues with {@link CueBuilder#COLOR_SOLID_BLACK} fill) will be overridden with
+ * device accessibility settings; all others will use the colors and opacity specified by the
+ * caption data.
+ */
+public final class Cea708Decoder extends CeaDecoder {
+
+  private static final String TAG = "Cea708Decoder";
+
+  private static final int NUM_WINDOWS = 8;
+
+  private static final int DTVCC_PACKET_DATA = 0x02;
+  private static final int DTVCC_PACKET_START = 0x03;
+  private static final int CC_VALID_FLAG = 0x04;
+
+  // Base Commands
+  private static final int GROUP_C0_END = 0x1F;  // Miscellaneous Control Codes
+  private static final int GROUP_G0_END = 0x7F;  // ASCII Printable Characters
+  private static final int GROUP_C1_END = 0x9F;  // Captioning Command Control Codes
+  private static final int GROUP_G1_END = 0xFF;  // ISO 8859-1 LATIN-1 Character Set
+
+  // Extended Commands
+  private static final int GROUP_C2_END = 0x1F;  // Extended Control Code Set 1
+  private static final int GROUP_G2_END = 0x7F;  // Extended Miscellaneous Characters
+  private static final int GROUP_C3_END = 0x9F;  // Extended Control Code Set 2
+  private static final int GROUP_G3_END = 0xFF;  // Future Expansion
+
+  // Group C0 Commands
+  private static final int COMMAND_NUL = 0x00;        // Nul
+  private static final int COMMAND_ETX = 0x03;        // EndOfText
+  private static final int COMMAND_BS = 0x08;         // Backspace
+  private static final int COMMAND_FF = 0x0C;         // FormFeed (Flush)
+  private static final int COMMAND_CR = 0x0D;         // CarriageReturn
+  private static final int COMMAND_HCR = 0x0E;        // ClearLine
+  private static final int COMMAND_EXT1 = 0x10;       // Extended Control Code Flag
+  private static final int COMMAND_EXT1_START = 0x11;
+  private static final int COMMAND_EXT1_END = 0x17;
+  private static final int COMMAND_P16_START = 0x18;
+  private static final int COMMAND_P16_END = 0x1F;
+
+  // Group C1 Commands
+  private static final int COMMAND_CW0 = 0x80;  // SetCurrentWindow to 0
+  private static final int COMMAND_CW1 = 0x81;  // SetCurrentWindow to 1
+  private static final int COMMAND_CW2 = 0x82;  // SetCurrentWindow to 2
+  private static final int COMMAND_CW3 = 0x83;  // SetCurrentWindow to 3
+  private static final int COMMAND_CW4 = 0x84;  // SetCurrentWindow to 4
+  private static final int COMMAND_CW5 = 0x85;  // SetCurrentWindow to 5
+  private static final int COMMAND_CW6 = 0x86;  // SetCurrentWindow to 6
+  private static final int COMMAND_CW7 = 0x87;  // SetCurrentWindow to 7
+  private static final int COMMAND_CLW = 0x88;  // ClearWindows (+1 byte)
+  private static final int COMMAND_DSW = 0x89;  // DisplayWindows (+1 byte)
+  private static final int COMMAND_HDW = 0x8A;  // HideWindows (+1 byte)
+  private static final int COMMAND_TGW = 0x8B;  // ToggleWindows (+1 byte)
+  private static final int COMMAND_DLW = 0x8C;  // DeleteWindows (+1 byte)
+  private static final int COMMAND_DLY = 0x8D;  // Delay (+1 byte)
+  private static final int COMMAND_DLC = 0x8E;  // DelayCancel
+  private static final int COMMAND_RST = 0x8F;  // Reset
+  private static final int COMMAND_SPA = 0x90;  // SetPenAttributes (+2 bytes)
+  private static final int COMMAND_SPC = 0x91;  // SetPenColor (+3 bytes)
+  private static final int COMMAND_SPL = 0x92;  // SetPenLocation (+2 bytes)
+  private static final int COMMAND_SWA = 0x97;  // SetWindowAttributes (+4 bytes)
+  private static final int COMMAND_DF0 = 0x98;  // DefineWindow 0 (+6 bytes)
+  private static final int COMMAND_DF1 = 0x99;  // DefineWindow 1 (+6 bytes)
+  private static final int COMMAND_DF2 = 0x9A;  // DefineWindow 2 (+6 bytes)
+  private static final int COMMAND_DF3 = 0x9B;  // DefineWindow 3 (+6 bytes)
+  private static final int COMMAND_DS4 = 0x9C;  // DefineWindow 4 (+6 bytes)
+  private static final int COMMAND_DF5 = 0x9D;  // DefineWindow 5 (+6 bytes)
+  private static final int COMMAND_DF6 = 0x9E;  // DefineWindow 6 (+6 bytes)
+  private static final int COMMAND_DF7 = 0x9F;  // DefineWindow 7 (+6 bytes)
+
+  // G0 Table Special Chars
+  private static final int CHARACTER_MN = 0x7F;  // MusicNote
+
+  // G2 Table Special Chars
+  private static final int CHARACTER_TSP = 0x20;
+  private static final int CHARACTER_NBTSP = 0x21;
+  private static final int CHARACTER_ELLIPSIS = 0x25;
+  private static final int CHARACTER_BIG_CARONS = 0x2A;
+  private static final int CHARACTER_BIG_OE = 0x2C;
+  private static final int CHARACTER_SOLID_BLOCK = 0x30;
+  private static final int CHARACTER_OPEN_SINGLE_QUOTE = 0x31;
+  private static final int CHARACTER_CLOSE_SINGLE_QUOTE = 0x32;
+  private static final int CHARACTER_OPEN_DOUBLE_QUOTE = 0x33;
+  private static final int CHARACTER_CLOSE_DOUBLE_QUOTE = 0x34;
+  private static final int CHARACTER_BOLD_BULLET = 0x35;
+  private static final int CHARACTER_TM = 0x39;
+  private static final int CHARACTER_SMALL_CARONS = 0x3A;
+  private static final int CHARACTER_SMALL_OE = 0x3C;
+  private static final int CHARACTER_SM = 0x3D;
+  private static final int CHARACTER_DIAERESIS_Y = 0x3F;
+  private static final int CHARACTER_ONE_EIGHTH = 0x76;
+  private static final int CHARACTER_THREE_EIGHTHS = 0x77;
+  private static final int CHARACTER_FIVE_EIGHTHS = 0x78;
+  private static final int CHARACTER_SEVEN_EIGHTHS = 0x79;
+  private static final int CHARACTER_VERTICAL_BORDER = 0x7A;
+  private static final int CHARACTER_UPPER_RIGHT_BORDER = 0x7B;
+  private static final int CHARACTER_LOWER_LEFT_BORDER = 0x7C;
+  private static final int CHARACTER_HORIZONTAL_BORDER = 0x7D;
+  private static final int CHARACTER_LOWER_RIGHT_BORDER = 0x7E;
+  private static final int CHARACTER_UPPER_LEFT_BORDER = 0x7F;
+
+  private final ParsableByteArray ccData;
+  private final ParsableBitArray serviceBlockPacket;
+
+  private final int selectedServiceNumber;
+  private final CueBuilder[] cueBuilders;
+
+  private CueBuilder currentCueBuilder;
+  private List<Cue> cues;
+  private List<Cue> lastCues;
+
+  private DtvCcPacket currentDtvCcPacket;
+  private int currentWindow;
+
+  public Cea708Decoder(int accessibilityChannel) {
+    ccData = new ParsableByteArray();
+    serviceBlockPacket = new ParsableBitArray();
+    selectedServiceNumber = (accessibilityChannel == Format.NO_VALUE) ? 1 : accessibilityChannel;
+
+    cueBuilders = new CueBuilder[NUM_WINDOWS];
+    for (int i = 0; i < NUM_WINDOWS; i++) {
+      cueBuilders[i] = new CueBuilder();
+    }
+
+    currentCueBuilder = cueBuilders[0];
+    resetCueBuilders();
+  }
+
+  @Override
+  public String getName() {
+    return "Cea708Decoder";
+  }
+
+  @Override
+  public void flush() {
+    super.flush();
+    cues = null;
+    lastCues = null;
+    currentWindow = 0;
+    currentCueBuilder = cueBuilders[currentWindow];
+    resetCueBuilders();
+    currentDtvCcPacket = null;
+  }
+
+  @Override
+  protected boolean isNewSubtitleDataAvailable() {
+    return cues != lastCues;
+  }
+
+  @Override
+  protected Subtitle createSubtitle() {
+    lastCues = cues;
+    return new CeaSubtitle(cues);
+  }
+
+  @Override
+  protected void decode(SubtitleInputBuffer inputBuffer) {
+    ccData.reset(inputBuffer.data.array(), inputBuffer.data.limit());
+    while (ccData.bytesLeft() >= 3) {
+      int ccTypeAndValid = (ccData.readUnsignedByte() & 0x07);
+
+      int ccType = ccTypeAndValid & (DTVCC_PACKET_DATA | DTVCC_PACKET_START);
+      boolean ccValid = (ccTypeAndValid & CC_VALID_FLAG) == CC_VALID_FLAG;
+      byte ccData1 = (byte) ccData.readUnsignedByte();
+      byte ccData2 = (byte) ccData.readUnsignedByte();
+
+      // Ignore any non-CEA-708 data
+      if (ccType != DTVCC_PACKET_DATA && ccType != DTVCC_PACKET_START) {
+        continue;
+      }
+
+      if (!ccValid) {
+        finalizeCurrentPacket();
+        continue;
+      }
+
+      if (ccType == DTVCC_PACKET_START) {
+        finalizeCurrentPacket();
+
+        int sequenceNumber = (ccData1 & 0xC0) >> 6; // first 2 bits
+        int packetSize = ccData1 & 0x3F; // last 6 bits
+        if (packetSize == 0) {
+          packetSize = 64;
+        }
+
+        currentDtvCcPacket = new DtvCcPacket(sequenceNumber, packetSize);
+        currentDtvCcPacket.packetData[currentDtvCcPacket.currentIndex++] = ccData2;
+      } else {
+        // The only remaining valid packet type is DTVCC_PACKET_DATA
+        Assertions.checkArgument(ccType == DTVCC_PACKET_DATA);
+
+        if (currentDtvCcPacket == null) {
+          Log.e(TAG, "Encountered DTVCC_PACKET_DATA before DTVCC_PACKET_START");
+          continue;
+        }
+
+        currentDtvCcPacket.packetData[currentDtvCcPacket.currentIndex++] = ccData1;
+        currentDtvCcPacket.packetData[currentDtvCcPacket.currentIndex++] = ccData2;
+      }
+
+      if (currentDtvCcPacket.currentIndex == (currentDtvCcPacket.packetSize * 2 - 1)) {
+        finalizeCurrentPacket();
+      }
+    }
+  }
+
+  private void finalizeCurrentPacket() {
+    if (currentDtvCcPacket == null) {
+      // No packet to finalize;
+      return;
+    }
+
+    processCurrentPacket();
+    currentDtvCcPacket = null;
+  }
+
+  private void processCurrentPacket() {
+    if (currentDtvCcPacket.currentIndex != (currentDtvCcPacket.packetSize * 2 - 1)) {
+      Log.w(TAG, "DtvCcPacket ended prematurely; size is " + (currentDtvCcPacket.packetSize * 2 - 1)
+          + ", but current index is " + currentDtvCcPacket.currentIndex + " (sequence number "
+          + currentDtvCcPacket.sequenceNumber + ")");
+    }
+
+    serviceBlockPacket.reset(currentDtvCcPacket.packetData, currentDtvCcPacket.currentIndex);
+
+    int serviceNumber = serviceBlockPacket.readBits(3);
+    int blockSize = serviceBlockPacket.readBits(5);
+    if (serviceNumber == 7) {
+      // extended service numbers
+      serviceBlockPacket.skipBits(2);
+      serviceNumber += serviceBlockPacket.readBits(6);
+    }
+
+    // Ignore packets in which blockSize is 0
+    if (blockSize == 0) {
+      if (serviceNumber != 0) {
+        Log.w(TAG, "serviceNumber is non-zero (" + serviceNumber + ") when blockSize is 0");
+      }
+      return;
+    }
+
+    if (serviceNumber != selectedServiceNumber) {
+      return;
+    }
+
+    while (serviceBlockPacket.bitsLeft() > 0) {
+      int command = serviceBlockPacket.readBits(8);
+      if (command != COMMAND_EXT1) {
+        if (command <= GROUP_C0_END) {
+          handleC0Command(command);
+        } else if (command <= GROUP_G0_END) {
+          handleG0Character(command);
+        } else if (command <= GROUP_C1_END) {
+          handleC1Command(command);
+          // Cues are always updated after a C1 command
+          cues = getDisplayCues();
+        } else if (command <= GROUP_G1_END) {
+          handleG1Character(command);
+        } else {
+          Log.w(TAG, "Invalid base command: " + command);
+        }
+      } else {
+        // Read the extended command
+        command = serviceBlockPacket.readBits(8);
+        if (command <= GROUP_C2_END) {
+          handleC2Command(command);
+        } else if (command <= GROUP_G2_END) {
+          handleG2Character(command);
+        } else if (command <= GROUP_C3_END) {
+          handleC3Command(command);
+        } else if (command <= GROUP_G3_END) {
+          handleG3Character(command);
+        } else {
+          Log.w(TAG, "Invalid extended command: " + command);
+        }
+      }
+    }
+  }
+
+  private void handleC0Command(int command) {
+    switch (command) {
+      case COMMAND_NUL:
+        // Do nothing.
+        break;
+      case COMMAND_ETX:
+        cues = getDisplayCues();
+        break;
+      case COMMAND_BS:
+        currentCueBuilder.backspace();
+        break;
+      case COMMAND_FF:
+        resetCueBuilders();
+        break;
+      case COMMAND_CR:
+        currentCueBuilder.append('\n');
+        break;
+      case COMMAND_HCR:
+        // TODO: Add support for this command.
+        break;
+      default:
+        if (command >= COMMAND_EXT1_START && command <= COMMAND_EXT1_END) {
+          Log.w(TAG, "Currently unsupported COMMAND_EXT1 Command: " + command);
+          serviceBlockPacket.skipBits(8);
+        } else if (command >= COMMAND_P16_START && command <= COMMAND_P16_END) {
+          Log.w(TAG, "Currently unsupported COMMAND_P16 Command: " + command);
+          serviceBlockPacket.skipBits(16);
+        } else {
+          Log.w(TAG, "Invalid C0 command: " + command);
+        }
+    }
+  }
+
+  private void handleC1Command(int command) {
+    int window;
+    switch (command) {
+      case COMMAND_CW0:
+      case COMMAND_CW1:
+      case COMMAND_CW2:
+      case COMMAND_CW3:
+      case COMMAND_CW4:
+      case COMMAND_CW5:
+      case COMMAND_CW6:
+      case COMMAND_CW7:
+        window = (command - COMMAND_CW0);
+        if (currentWindow != window) {
+          currentWindow = window;
+          currentCueBuilder = cueBuilders[window];
+        }
+        break;
+      case COMMAND_CLW:
+        for (int i = 1; i <= NUM_WINDOWS; i++) {
+          if (serviceBlockPacket.readBit()) {
+            cueBuilders[NUM_WINDOWS - i].clear();
+          }
+        }
+        break;
+      case COMMAND_DSW:
+        for (int i = 1; i <= NUM_WINDOWS; i++) {
+          if (serviceBlockPacket.readBit()) {
+            cueBuilders[NUM_WINDOWS - i].setVisibility(true);
+          }
+        }
+        break;
+      case COMMAND_HDW:
+        for (int i = 1; i <= NUM_WINDOWS; i++) {
+          if (serviceBlockPacket.readBit()) {
+            cueBuilders[NUM_WINDOWS - i].setVisibility(false);
+          }
+        }
+        break;
+      case COMMAND_TGW:
+        for (int i = 1; i <= NUM_WINDOWS; i++) {
+          if (serviceBlockPacket.readBit()) {
+            CueBuilder cueBuilder = cueBuilders[NUM_WINDOWS - i];
+            cueBuilder.setVisibility(!cueBuilder.isVisible());
+          }
+        }
+        break;
+      case COMMAND_DLW:
+        for (int i = 1; i <= NUM_WINDOWS; i++) {
+          if (serviceBlockPacket.readBit()) {
+            cueBuilders[NUM_WINDOWS - i].reset();
+          }
+        }
+        break;
+      case COMMAND_DLY:
+        // TODO: Add support for delay commands.
+        serviceBlockPacket.skipBits(8);
+        break;
+      case COMMAND_DLC:
+        // TODO: Add support for delay commands.
+        break;
+      case COMMAND_RST:
+        resetCueBuilders();
+        break;
+      case COMMAND_SPA:
+        if (!currentCueBuilder.isDefined()) {
+          // ignore this command if the current window/cue isn't defined
+          serviceBlockPacket.skipBits(16);
+        } else {
+          handleSetPenAttributes();
+        }
+        break;
+      case COMMAND_SPC:
+        if (!currentCueBuilder.isDefined()) {
+          // ignore this command if the current window/cue isn't defined
+          serviceBlockPacket.skipBits(24);
+        } else {
+          handleSetPenColor();
+        }
+        break;
+      case COMMAND_SPL:
+        if (!currentCueBuilder.isDefined()) {
+          // ignore this command if the current window/cue isn't defined
+          serviceBlockPacket.skipBits(16);
+        } else {
+          handleSetPenLocation();
+        }
+        break;
+      case COMMAND_SWA:
+        if (!currentCueBuilder.isDefined()) {
+          // ignore this command if the current window/cue isn't defined
+          serviceBlockPacket.skipBits(32);
+        } else {
+          handleSetWindowAttributes();
+        }
+        break;
+      case COMMAND_DF0:
+      case COMMAND_DF1:
+      case COMMAND_DF2:
+      case COMMAND_DF3:
+      case COMMAND_DS4:
+      case COMMAND_DF5:
+      case COMMAND_DF6:
+      case COMMAND_DF7:
+        window = (command - COMMAND_DF0);
+        handleDefineWindow(window);
+        break;
+      default:
+        Log.w(TAG, "Invalid C1 command: " + command);
+    }
+  }
+
+  private void handleC2Command(int command) {
+    // C2 Table doesn't contain any commands in CEA-708-B, but we do need to skip bytes
+    if (command <= 0x0F) {
+      // Do nothing.
+    } else if (command <= 0x0F) {
+      serviceBlockPacket.skipBits(8);
+    } else if (command <= 0x17) {
+      serviceBlockPacket.skipBits(16);
+    } else if (command <= 0x1F) {
+      serviceBlockPacket.skipBits(24);
+    }
+  }
+
+  private void handleC3Command(int command) {
+    // C3 Table doesn't contain any commands in CEA-708-B, but we do need to skip bytes
+    if (command <= 0x87) {
+      serviceBlockPacket.skipBits(32);
+    } else if (command <= 0x8F) {
+      serviceBlockPacket.skipBits(40);
+    } else if (command <= 0x9F) {
+      // 90-9F are variable length codes; the first byte defines the header with the first
+      // 2 bits specifying the type and the last 6 bits specifying the remaining length of the
+      // command in bytes
+      serviceBlockPacket.skipBits(2);
+      int length = serviceBlockPacket.readBits(6);
+      serviceBlockPacket.skipBits(8 * length);
+    }
+  }
+
+  private void handleG0Character(int characterCode) {
+    if (characterCode == CHARACTER_MN) {
+      currentCueBuilder.append('\u266B');
+    } else {
+      currentCueBuilder.append((char) (characterCode & 0xFF));
+    }
+  }
+
+  private void handleG1Character(int characterCode) {
+    currentCueBuilder.append((char) (characterCode & 0xFF));
+  }
+
+  private void handleG2Character(int characterCode) {
+    switch (characterCode) {
+      case CHARACTER_TSP:
+        currentCueBuilder.append('\u0020');
+        break;
+      case CHARACTER_NBTSP:
+        currentCueBuilder.append('\u00A0');
+        break;
+      case CHARACTER_ELLIPSIS:
+        currentCueBuilder.append('\u2026');
+        break;
+      case CHARACTER_BIG_CARONS:
+        currentCueBuilder.append('\u0160');
+        break;
+      case CHARACTER_BIG_OE:
+        currentCueBuilder.append('\u0152');
+        break;
+      case CHARACTER_SOLID_BLOCK:
+        currentCueBuilder.append('\u2588');
+        break;
+      case CHARACTER_OPEN_SINGLE_QUOTE:
+        currentCueBuilder.append('\u2018');
+        break;
+      case CHARACTER_CLOSE_SINGLE_QUOTE:
+        currentCueBuilder.append('\u2019');
+        break;
+      case CHARACTER_OPEN_DOUBLE_QUOTE:
+        currentCueBuilder.append('\u201C');
+        break;
+      case CHARACTER_CLOSE_DOUBLE_QUOTE:
+        currentCueBuilder.append('\u201D');
+        break;
+      case CHARACTER_BOLD_BULLET:
+        currentCueBuilder.append('\u2022');
+        break;
+      case CHARACTER_TM:
+        currentCueBuilder.append('\u2122');
+        break;
+      case CHARACTER_SMALL_CARONS:
+        currentCueBuilder.append('\u0161');
+        break;
+      case CHARACTER_SMALL_OE:
+        currentCueBuilder.append('\u0153');
+        break;
+      case CHARACTER_SM:
+        currentCueBuilder.append('\u2120');
+        break;
+      case CHARACTER_DIAERESIS_Y:
+        currentCueBuilder.append('\u0178');
+        break;
+      case CHARACTER_ONE_EIGHTH:
+        currentCueBuilder.append('\u215B');
+        break;
+      case CHARACTER_THREE_EIGHTHS:
+        currentCueBuilder.append('\u215C');
+        break;
+      case CHARACTER_FIVE_EIGHTHS:
+        currentCueBuilder.append('\u215D');
+        break;
+      case CHARACTER_SEVEN_EIGHTHS:
+        currentCueBuilder.append('\u215E');
+        break;
+      case CHARACTER_VERTICAL_BORDER:
+        currentCueBuilder.append('\u2502');
+        break;
+      case CHARACTER_UPPER_RIGHT_BORDER:
+        currentCueBuilder.append('\u2510');
+        break;
+      case CHARACTER_LOWER_LEFT_BORDER:
+        currentCueBuilder.append('\u2514');
+        break;
+      case CHARACTER_HORIZONTAL_BORDER:
+        currentCueBuilder.append('\u2500');
+        break;
+      case CHARACTER_LOWER_RIGHT_BORDER:
+        currentCueBuilder.append('\u2518');
+        break;
+      case CHARACTER_UPPER_LEFT_BORDER:
+        currentCueBuilder.append('\u250C');
+        break;
+      default:
+        Log.w(TAG, "Invalid G2 character: " + characterCode);
+        // The CEA-708 specification doesn't specify what to do in the case of an unexpected
+        // value in the G2 character range, so we ignore it.
+    }
+  }
+
+  private void handleG3Character(int characterCode) {
+    if (characterCode == 0xA0) {
+      currentCueBuilder.append('\u33C4');
+    } else {
+      Log.w(TAG, "Invalid G3 character: " + characterCode);
+      // Substitute any unsupported G3 character with an underscore as per CEA-708 specification.
+      currentCueBuilder.append('_');
+    }
+  }
+
+  private void handleSetPenAttributes() {
+    // the SetPenAttributes command contains 2 bytes of data
+    // first byte
+    int textTag = serviceBlockPacket.readBits(4);
+    int offset = serviceBlockPacket.readBits(2);
+    int penSize = serviceBlockPacket.readBits(2);
+    // second byte
+    boolean italicsToggle = serviceBlockPacket.readBit();
+    boolean underlineToggle = serviceBlockPacket.readBit();
+    int edgeType = serviceBlockPacket.readBits(3);
+    int fontStyle = serviceBlockPacket.readBits(3);
+
+    currentCueBuilder.setPenAttributes(textTag, offset, penSize, italicsToggle, underlineToggle,
+        edgeType, fontStyle);
+  }
+
+  private void handleSetPenColor() {
+    // the SetPenColor command contains 3 bytes of data
+    // first byte
+    int foregroundO = serviceBlockPacket.readBits(2);
+    int foregroundR = serviceBlockPacket.readBits(2);
+    int foregroundG = serviceBlockPacket.readBits(2);
+    int foregroundB = serviceBlockPacket.readBits(2);
+    int foregroundColor = CueBuilder.getArgbColorFromCeaColor(foregroundR, foregroundG, foregroundB,
+        foregroundO);
+    // second byte
+    int backgroundO = serviceBlockPacket.readBits(2);
+    int backgroundR = serviceBlockPacket.readBits(2);
+    int backgroundG = serviceBlockPacket.readBits(2);
+    int backgroundB = serviceBlockPacket.readBits(2);
+    int backgroundColor = CueBuilder.getArgbColorFromCeaColor(backgroundR, backgroundG, backgroundB,
+        backgroundO);
+    // third byte
+    serviceBlockPacket.skipBits(2); // null padding
+    int edgeR = serviceBlockPacket.readBits(2);
+    int edgeG = serviceBlockPacket.readBits(2);
+    int edgeB = serviceBlockPacket.readBits(2);
+    int edgeColor = CueBuilder.getArgbColorFromCeaColor(edgeR, edgeG, edgeB);
+
+    currentCueBuilder.setPenColor(foregroundColor, backgroundColor, edgeColor);
+  }
+
+  private void handleSetPenLocation() {
+    // the SetPenLocation command contains 2 bytes of data
+    // first byte
+    serviceBlockPacket.skipBits(4);
+    int row = serviceBlockPacket.readBits(4);
+    // second byte
+    serviceBlockPacket.skipBits(2);
+    int column = serviceBlockPacket.readBits(6);
+
+    currentCueBuilder.setPenLocation(row, column);
+  }
+
+  private void handleSetWindowAttributes() {
+    // the SetWindowAttributes command contains 4 bytes of data
+    // first byte
+    int fillO = serviceBlockPacket.readBits(2);
+    int fillR = serviceBlockPacket.readBits(2);
+    int fillG = serviceBlockPacket.readBits(2);
+    int fillB = serviceBlockPacket.readBits(2);
+    int fillColor = CueBuilder.getArgbColorFromCeaColor(fillR, fillG, fillB, fillO);
+    // second byte
+    int borderType = serviceBlockPacket.readBits(2); // only the lower 2 bits of borderType
+    int borderR = serviceBlockPacket.readBits(2);
+    int borderG = serviceBlockPacket.readBits(2);
+    int borderB = serviceBlockPacket.readBits(2);
+    int borderColor = CueBuilder.getArgbColorFromCeaColor(borderR, borderG, borderB);
+    // third byte
+    if (serviceBlockPacket.readBit()) {
+      borderType |= 0x04; // set the top bit of the 3-bit borderType
+    }
+    boolean wordWrapToggle = serviceBlockPacket.readBit();
+    int printDirection = serviceBlockPacket.readBits(2);
+    int scrollDirection = serviceBlockPacket.readBits(2);
+    int justification = serviceBlockPacket.readBits(2);
+    // fourth byte
+    // Note that we don't intend to support display effects
+    serviceBlockPacket.skipBits(8); // effectSpeed(4), effectDirection(2), displayEffect(2)
+
+    currentCueBuilder.setWindowAttributes(fillColor, borderColor, wordWrapToggle, borderType,
+        printDirection, scrollDirection, justification);
+  }
+
+  private void handleDefineWindow(int window) {
+    CueBuilder cueBuilder = cueBuilders[window];
+
+    // the DefineWindow command contains 6 bytes of data
+    // first byte
+    serviceBlockPacket.skipBits(2); // null padding
+    boolean visible = serviceBlockPacket.readBit();
+    boolean rowLock = serviceBlockPacket.readBit();
+    boolean columnLock = serviceBlockPacket.readBit();
+    int priority = serviceBlockPacket.readBits(3);
+    // second byte
+    boolean relativePositioning = serviceBlockPacket.readBit();
+    int verticalAnchor = serviceBlockPacket.readBits(7);
+    // third byte
+    int horizontalAnchor = serviceBlockPacket.readBits(8);
+    // fourth byte
+    int anchorId = serviceBlockPacket.readBits(4);
+    int rowCount = serviceBlockPacket.readBits(4);
+    // fifth byte
+    serviceBlockPacket.skipBits(2); // null padding
+    int columnCount = serviceBlockPacket.readBits(6);
+    // sixth byte
+    serviceBlockPacket.skipBits(2); // null padding
+    int windowStyle = serviceBlockPacket.readBits(3);
+    int penStyle = serviceBlockPacket.readBits(3);
+
+    cueBuilder.defineWindow(visible, rowLock, columnLock, priority, relativePositioning,
+        verticalAnchor, horizontalAnchor, rowCount, columnCount, anchorId, windowStyle, penStyle);
+  }
+
+  private List<Cue> getDisplayCues() {
+    List<Cea708Cue> displayCues = new ArrayList<>();
+    for (int i = 0; i < NUM_WINDOWS; i++) {
+      if (!cueBuilders[i].isEmpty() && cueBuilders[i].isVisible()) {
+        displayCues.add(cueBuilders[i].build());
+      }
+    }
+    Collections.sort(displayCues);
+    return Collections.<Cue>unmodifiableList(displayCues);
+  }
+
+  private void resetCueBuilders() {
+    for (int i = 0; i < NUM_WINDOWS; i++) {
+      cueBuilders[i].reset();
+    }
+  }
+
+  private static final class DtvCcPacket {
+
+    public final int sequenceNumber;
+    public final int packetSize;
+    public final byte[] packetData;
+
+    int currentIndex;
+
+    public DtvCcPacket(int sequenceNumber, int packetSize) {
+      this.sequenceNumber = sequenceNumber;
+      this.packetSize = packetSize;
+      packetData = new byte[2 * packetSize - 1];
+      currentIndex = 0;
+    }
+
+  }
+
+  // TODO: There is a lot of overlap between Cea708Decoder.CueBuilder and Cea608Decoder.CueBuilder
+  // which could be refactored into a separate class.
+  private static final class CueBuilder {
+
+    private static final int RELATIVE_CUE_SIZE = 99;
+    private static final int VERTICAL_SIZE = 74;
+    private static final int HORIZONTAL_SIZE = 209;
+
+    private static final int DEFAULT_PRIORITY = 4;
+
+    private static final int MAXIMUM_ROW_COUNT = 15;
+
+    private static final int JUSTIFICATION_LEFT = 0;
+    private static final int JUSTIFICATION_RIGHT = 1;
+    private static final int JUSTIFICATION_CENTER = 2;
+    private static final int JUSTIFICATION_FULL = 3;
+
+    private static final int DIRECTION_LEFT_TO_RIGHT = 0;
+    private static final int DIRECTION_RIGHT_TO_LEFT = 1;
+    private static final int DIRECTION_TOP_TO_BOTTOM = 2;
+    private static final int DIRECTION_BOTTOM_TO_TOP = 3;
+
+    // TODO: Add other border/edge types when utilized.
+    private static final int BORDER_AND_EDGE_TYPE_NONE = 0;
+    private static final int BORDER_AND_EDGE_TYPE_UNIFORM = 3;
+
+    public static final int COLOR_SOLID_WHITE = getArgbColorFromCeaColor(2, 2, 2, 0);
+    public static final int COLOR_SOLID_BLACK = getArgbColorFromCeaColor(0, 0, 0, 0);
+    public static final int COLOR_TRANSPARENT = getArgbColorFromCeaColor(0, 0, 0, 3);
+
+    // TODO: Add other sizes when utilized.
+    private static final int PEN_SIZE_STANDARD = 1;
+
+    // TODO: Add other pen font styles when utilized.
+    private static final int PEN_FONT_STYLE_DEFAULT = 0;
+    private static final int PEN_FONT_STYLE_MONOSPACED_WITH_SERIFS = 1;
+    private static final int PEN_FONT_STYLE_PROPORTIONALLY_SPACED_WITH_SERIFS = 2;
+    private static final int PEN_FONT_STYLE_MONOSPACED_WITHOUT_SERIFS = 3;
+    private static final int PEN_FONT_STYLE_PROPORTIONALLY_SPACED_WITHOUT_SERIFS = 4;
+
+    // TODO: Add other pen offsets when utilized.
+    private static final int PEN_OFFSET_NORMAL = 1;
+
+    // The window style properties are specified in the CEA-708 specification.
+    private static final int[] WINDOW_STYLE_JUSTIFICATION = new int[]{
+        JUSTIFICATION_LEFT, JUSTIFICATION_LEFT, JUSTIFICATION_LEFT,
+        JUSTIFICATION_LEFT, JUSTIFICATION_LEFT, JUSTIFICATION_CENTER,
+        JUSTIFICATION_LEFT
+    };
+    private static final int[] WINDOW_STYLE_PRINT_DIRECTION = new int[]{
+        DIRECTION_LEFT_TO_RIGHT, DIRECTION_LEFT_TO_RIGHT, DIRECTION_LEFT_TO_RIGHT,
+        DIRECTION_LEFT_TO_RIGHT, DIRECTION_LEFT_TO_RIGHT, DIRECTION_LEFT_TO_RIGHT,
+        DIRECTION_TOP_TO_BOTTOM
+    };
+    private static final int[] WINDOW_STYLE_SCROLL_DIRECTION = new int[]{
+        DIRECTION_BOTTOM_TO_TOP, DIRECTION_BOTTOM_TO_TOP, DIRECTION_BOTTOM_TO_TOP,
+        DIRECTION_BOTTOM_TO_TOP, DIRECTION_BOTTOM_TO_TOP, DIRECTION_BOTTOM_TO_TOP,
+        DIRECTION_RIGHT_TO_LEFT
+    };
+    private static final boolean[] WINDOW_STYLE_WORD_WRAP = new boolean[]{
+        false, false, false, true, true, true, false
+    };
+    private static final int[] WINDOW_STYLE_FILL = new int[]{
+        COLOR_SOLID_BLACK, COLOR_TRANSPARENT, COLOR_SOLID_BLACK, COLOR_SOLID_BLACK,
+        COLOR_TRANSPARENT, COLOR_SOLID_BLACK, COLOR_SOLID_BLACK
+    };
+
+    // The pen style properties are specified in the CEA-708 specification.
+    private static final int[] PEN_STYLE_FONT_STYLE = new int[]{
+        PEN_FONT_STYLE_DEFAULT, PEN_FONT_STYLE_MONOSPACED_WITH_SERIFS,
+        PEN_FONT_STYLE_PROPORTIONALLY_SPACED_WITH_SERIFS, PEN_FONT_STYLE_MONOSPACED_WITHOUT_SERIFS,
+        PEN_FONT_STYLE_PROPORTIONALLY_SPACED_WITHOUT_SERIFS,
+        PEN_FONT_STYLE_MONOSPACED_WITHOUT_SERIFS,
+        PEN_FONT_STYLE_PROPORTIONALLY_SPACED_WITHOUT_SERIFS
+    };
+    private static final int[] PEN_STYLE_EDGE_TYPE = new int[]{
+        BORDER_AND_EDGE_TYPE_NONE, BORDER_AND_EDGE_TYPE_NONE, BORDER_AND_EDGE_TYPE_NONE,
+        BORDER_AND_EDGE_TYPE_NONE, BORDER_AND_EDGE_TYPE_NONE, BORDER_AND_EDGE_TYPE_UNIFORM,
+        BORDER_AND_EDGE_TYPE_UNIFORM
+    };
+    private static final int[] PEN_STYLE_BACKGROUND = new int[]{
+        COLOR_SOLID_BLACK, COLOR_SOLID_BLACK, COLOR_SOLID_BLACK, COLOR_SOLID_BLACK,
+        COLOR_SOLID_BLACK, COLOR_TRANSPARENT, COLOR_TRANSPARENT};
+
+    private final List<SpannableString> rolledUpCaptions;
+    private final SpannableStringBuilder captionStringBuilder;
+
+    // Window/Cue properties
+    private boolean defined;
+    private boolean visible;
+    private int priority;
+    private boolean relativePositioning;
+    private int verticalAnchor;
+    private int horizontalAnchor;
+    private int anchorId;
+    private int rowCount;
+    private boolean rowLock;
+    private int justification;
+    private int windowStyleId;
+    private int penStyleId;
+    private int windowFillColor;
+
+    // Pen/Text properties
+    private int italicsStartPosition;
+    private int underlineStartPosition;
+    private int foregroundColorStartPosition;
+    private int foregroundColor;
+    private int backgroundColorStartPosition;
+    private int backgroundColor;
+
+    public CueBuilder() {
+      rolledUpCaptions = new LinkedList<>();
+      captionStringBuilder = new SpannableStringBuilder();
+      reset();
+    }
+
+    public boolean isEmpty() {
+      return !isDefined() || (rolledUpCaptions.isEmpty() && captionStringBuilder.length() == 0);
+    }
+
+    public void reset() {
+      clear();
+
+      defined = false;
+      visible = false;
+      priority = DEFAULT_PRIORITY;
+      relativePositioning = false;
+      verticalAnchor = 0;
+      horizontalAnchor = 0;
+      anchorId = 0;
+      rowCount = MAXIMUM_ROW_COUNT;
+      rowLock = true;
+      justification = JUSTIFICATION_LEFT;
+      windowStyleId = 0;
+      penStyleId = 0;
+      windowFillColor = COLOR_SOLID_BLACK;
+
+      foregroundColor = COLOR_SOLID_WHITE;
+      backgroundColor = COLOR_SOLID_BLACK;
+    }
+
+    public void clear() {
+      rolledUpCaptions.clear();
+      captionStringBuilder.clear();
+      italicsStartPosition = C.POSITION_UNSET;
+      underlineStartPosition = C.POSITION_UNSET;
+      foregroundColorStartPosition = C.POSITION_UNSET;
+      backgroundColorStartPosition = C.POSITION_UNSET;
+    }
+
+    public boolean isDefined() {
+      return defined;
+    }
+
+    public void setVisibility(boolean visible) {
+      this.visible = visible;
+    }
+
+    public boolean isVisible() {
+      return visible;
+    }
+
+    public void defineWindow(boolean visible, boolean rowLock, boolean columnLock, int priority,
+        boolean relativePositioning, int verticalAnchor, int horizontalAnchor, int rowCount,
+        int columnCount, int anchorId, int windowStyleId, int penStyleId) {
+      this.defined = true;
+      this.visible = visible;
+      this.rowLock = rowLock;
+      this.priority = priority;
+      this.relativePositioning = relativePositioning;
+      this.verticalAnchor = verticalAnchor;
+      this.horizontalAnchor = horizontalAnchor;
+      this.anchorId = anchorId;
+
+      // Decoders must add one to rowCount to get the desired number of rows.
+      if (this.rowCount != rowCount + 1) {
+        this.rowCount = rowCount + 1;
+
+        // Trim any rolled up captions that are no longer valid, if applicable.
+        while ((rowLock && (rolledUpCaptions.size() >= this.rowCount))
+            || (rolledUpCaptions.size() >= MAXIMUM_ROW_COUNT)) {
+          rolledUpCaptions.remove(0);
+        }
+      }
+
+      // TODO: Add support for column lock and count.
+
+      if (windowStyleId != 0 && this.windowStyleId != windowStyleId) {
+        this.windowStyleId = windowStyleId;
+        // windowStyleId is 1-based.
+        int windowStyleIdIndex = windowStyleId - 1;
+        // Note that Border type and border color are the same for all window styles.
+        setWindowAttributes(WINDOW_STYLE_FILL[windowStyleIdIndex], COLOR_TRANSPARENT,
+            WINDOW_STYLE_WORD_WRAP[windowStyleIdIndex], BORDER_AND_EDGE_TYPE_NONE,
+            WINDOW_STYLE_PRINT_DIRECTION[windowStyleIdIndex],
+            WINDOW_STYLE_SCROLL_DIRECTION[windowStyleIdIndex],
+            WINDOW_STYLE_JUSTIFICATION[windowStyleIdIndex]);
+      }
+
+      if (penStyleId != 0 && this.penStyleId != penStyleId) {
+        this.penStyleId = penStyleId;
+        // penStyleId is 1-based.
+        int penStyleIdIndex = penStyleId - 1;
+        // Note that pen size, offset, italics, underline, foreground color, and foreground
+        // opacity are the same for all pen styles.
+        setPenAttributes(0, PEN_OFFSET_NORMAL, PEN_SIZE_STANDARD, false, false,
+            PEN_STYLE_EDGE_TYPE[penStyleIdIndex], PEN_STYLE_FONT_STYLE[penStyleIdIndex]);
+        setPenColor(COLOR_SOLID_WHITE, PEN_STYLE_BACKGROUND[penStyleIdIndex], COLOR_SOLID_BLACK);
+      }
+    }
+
+
+    public void setWindowAttributes(int fillColor, int borderColor, boolean wordWrapToggle,
+        int borderType, int printDirection, int scrollDirection, int justification) {
+      this.windowFillColor = fillColor;
+      // TODO: Add support for border color and types.
+      // TODO: Add support for word wrap.
+      // TODO: Add support for other scroll directions.
+      // TODO: Add support for other print directions.
+      this.justification = justification;
+
+    }
+
+    public void setPenAttributes(int textTag, int offset, int penSize, boolean italicsToggle,
+        boolean underlineToggle, int edgeType, int fontStyle) {
+      // TODO: Add support for text tags.
+      // TODO: Add support for other offsets.
+      // TODO: Add support for other pen sizes.
+
+      if (italicsStartPosition != C.POSITION_UNSET) {
+        if (!italicsToggle) {
+          captionStringBuilder.setSpan(new StyleSpan(Typeface.ITALIC), italicsStartPosition,
+              captionStringBuilder.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+          italicsStartPosition = C.POSITION_UNSET;
+        }
+      } else if (italicsToggle) {
+        italicsStartPosition = captionStringBuilder.length();
+      }
+
+      if (underlineStartPosition != C.POSITION_UNSET) {
+        if (!underlineToggle) {
+          captionStringBuilder.setSpan(new UnderlineSpan(), underlineStartPosition,
+              captionStringBuilder.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+          underlineStartPosition = C.POSITION_UNSET;
+        }
+      } else if (underlineToggle) {
+        underlineStartPosition = captionStringBuilder.length();
+      }
+
+      // TODO: Add support for edge types.
+      // TODO: Add support for other font styles.
+    }
+
+    public void setPenColor(int foregroundColor, int backgroundColor, int edgeColor) {
+      if (foregroundColorStartPosition != C.POSITION_UNSET) {
+        if (this.foregroundColor != foregroundColor) {
+          captionStringBuilder.setSpan(new ForegroundColorSpan(this.foregroundColor),
+              foregroundColorStartPosition, captionStringBuilder.length(),
+              Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        }
+      }
+      if (foregroundColor != COLOR_SOLID_WHITE) {
+        foregroundColorStartPosition = captionStringBuilder.length();
+        this.foregroundColor = foregroundColor;
+      }
+
+      if (backgroundColorStartPosition != C.POSITION_UNSET) {
+        if (this.backgroundColor != backgroundColor) {
+          captionStringBuilder.setSpan(new BackgroundColorSpan(this.backgroundColor),
+              backgroundColorStartPosition, captionStringBuilder.length(),
+              Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        }
+      }
+      if (backgroundColor != COLOR_SOLID_BLACK) {
+        backgroundColorStartPosition = captionStringBuilder.length();
+        this.backgroundColor = backgroundColor;
+      }
+
+      // TODO: Add support for edge color.
+    }
+
+    public void setPenLocation(int row, int column) {
+      // TODO: Support moving the pen location with a window.
+    }
+
+    public void backspace() {
+      int length = captionStringBuilder.length();
+      if (length > 0) {
+        captionStringBuilder.delete(length - 1, length);
+      }
+    }
+
+    public void append(char text) {
+      if (text == '\n') {
+        rolledUpCaptions.add(buildSpannableString());
+        captionStringBuilder.clear();
+
+        if (italicsStartPosition != C.POSITION_UNSET) {
+          italicsStartPosition = 0;
+        }
+        if (underlineStartPosition != C.POSITION_UNSET) {
+          underlineStartPosition = 0;
+        }
+        if (foregroundColorStartPosition != C.POSITION_UNSET) {
+          foregroundColorStartPosition = 0;
+        }
+        if (backgroundColorStartPosition != C.POSITION_UNSET) {
+          backgroundColorStartPosition = 0;
+        }
+
+        while ((rowLock && (rolledUpCaptions.size() >= rowCount))
+            || (rolledUpCaptions.size() >= MAXIMUM_ROW_COUNT)) {
+          rolledUpCaptions.remove(0);
+        }
+      } else {
+        captionStringBuilder.append(text);
+      }
+    }
+
+    public SpannableString buildSpannableString() {
+      SpannableStringBuilder spannableStringBuilder =
+          new SpannableStringBuilder(captionStringBuilder);
+      int length = spannableStringBuilder.length();
+
+      if (length > 0) {
+        if (italicsStartPosition != C.POSITION_UNSET) {
+          spannableStringBuilder.setSpan(new StyleSpan(Typeface.ITALIC), italicsStartPosition,
+              length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        }
+
+        if (underlineStartPosition != C.POSITION_UNSET) {
+          spannableStringBuilder.setSpan(new UnderlineSpan(), underlineStartPosition,
+              length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        }
+
+        if (foregroundColorStartPosition != C.POSITION_UNSET) {
+          spannableStringBuilder.setSpan(new ForegroundColorSpan(foregroundColor),
+              foregroundColorStartPosition, length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        }
+
+        if (backgroundColorStartPosition != C.POSITION_UNSET) {
+          spannableStringBuilder.setSpan(new BackgroundColorSpan(backgroundColor),
+              backgroundColorStartPosition, length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        }
+      }
+
+      return new SpannableString(spannableStringBuilder);
+    }
+
+    public Cea708Cue build() {
+      if (isEmpty()) {
+        // The cue is empty.
+        return null;
+      }
+
+      SpannableStringBuilder cueString = new SpannableStringBuilder();
+
+      // Add any rolled up captions, separated by new lines.
+      for (int i = 0; i < rolledUpCaptions.size(); i++) {
+        cueString.append(rolledUpCaptions.get(i));
+        cueString.append('\n');
+      }
+      // Add the current line.
+      cueString.append(buildSpannableString());
+
+      // TODO: Add support for right-to-left languages (i.e. where right would correspond to normal
+      // alignment).
+      Alignment alignment;
+      switch (justification) {
+        case JUSTIFICATION_FULL:
+          // TODO: Add support for full justification.
+        case JUSTIFICATION_LEFT:
+          alignment = Alignment.ALIGN_NORMAL;
+          break;
+        case JUSTIFICATION_RIGHT:
+          alignment = Alignment.ALIGN_OPPOSITE;
+          break;
+        case JUSTIFICATION_CENTER:
+          alignment = Alignment.ALIGN_CENTER;
+          break;
+        default:
+          throw new IllegalArgumentException("Unexpected justification value: " + justification);
+      }
+
+      float position;
+      float line;
+      if (relativePositioning) {
+        position = (float) horizontalAnchor / RELATIVE_CUE_SIZE;
+        line = (float) verticalAnchor / RELATIVE_CUE_SIZE;
+      } else {
+        position = (float) horizontalAnchor / HORIZONTAL_SIZE;
+        line = (float) verticalAnchor / VERTICAL_SIZE;
+      }
+      // Apply screen-edge padding to the line and position.
+      position = (position * 0.9f) + 0.05f;
+      line = (line * 0.9f) + 0.05f;
+
+      // anchorId specifies where the anchor should be placed on the caption cue/window. The 9
+      // possible configurations are as follows:
+      //   0-----1-----2
+      //   |           |
+      //   3     4     5
+      //   |           |
+      //   6-----7-----8
+      @AnchorType int verticalAnchorType;
+      if (anchorId % 3 == 0) {
+        verticalAnchorType = Cue.ANCHOR_TYPE_START;
+      } else if (anchorId % 3 == 1) {
+        verticalAnchorType = Cue.ANCHOR_TYPE_MIDDLE;
+      } else {
+        verticalAnchorType = Cue.ANCHOR_TYPE_END;
+      }
+      // TODO: Add support for right-to-left languages (i.e. where start is on the right).
+      @AnchorType int horizontalAnchorType;
+      if (anchorId / 3 == 0) {
+        horizontalAnchorType = Cue.ANCHOR_TYPE_START;
+      } else if (anchorId / 3 == 1) {
+        horizontalAnchorType = Cue.ANCHOR_TYPE_MIDDLE;
+      } else {
+        horizontalAnchorType = Cue.ANCHOR_TYPE_END;
+      }
+
+      boolean windowColorSet = (windowFillColor != COLOR_SOLID_BLACK);
+
+      return new Cea708Cue(cueString, alignment, line, Cue.LINE_TYPE_FRACTION, verticalAnchorType,
+          position, horizontalAnchorType, Cue.DIMEN_UNSET, windowColorSet, windowFillColor,
+          priority);
+    }
+
+    public static int getArgbColorFromCeaColor(int red, int green, int blue) {
+      return getArgbColorFromCeaColor(red, green, blue, 0);
+    }
+
+    public static int getArgbColorFromCeaColor(int red, int green, int blue, int opacity) {
+      Assertions.checkIndex(red, 0, 4);
+      Assertions.checkIndex(green, 0, 4);
+      Assertions.checkIndex(blue, 0, 4);
+      Assertions.checkIndex(opacity, 0, 4);
+
+      int alpha;
+      switch (opacity) {
+        case 0:
+        case 1:
+          // Note the value of '1' is actually FLASH, but we don't support that.
+          alpha = 255;
+          break;
+        case 2:
+          alpha = 127;
+          break;
+        case 3:
+          alpha = 0;
+          break;
+        default:
+          alpha = 255;
+      }
+
+      // TODO: Add support for the Alternative Minimum Color List or the full 64 RGB combinations.
+
+      // Return values based on the Minimum Color List
+      return Color.argb(alpha,
+          (red > 1 ? 255 : 0),
+          (green > 1 ? 255 : 0),
+          (blue > 1 ? 255 : 0));
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaDecoder.java b/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaDecoder.java
index ae92d7fab8..f479050d57 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaDecoder.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaDecoder.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.text.cea;
 
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.text.Subtitle;
 import com.google.android.exoplayer2.text.SubtitleDecoder;
 import com.google.android.exoplayer2.text.SubtitleDecoderException;
@@ -109,7 +110,7 @@ public SubtitleOutputBuffer dequeueOutputBuffer() throws SubtitleDecoderExceptio
         Subtitle subtitle = createSubtitle();
         if (!inputBuffer.isDecodeOnly()) {
           SubtitleOutputBuffer outputBuffer = availableOutputBuffers.pollFirst();
-          outputBuffer.setContent(inputBuffer.timeUs, subtitle, 0);
+          outputBuffer.setContent(inputBuffer.timeUs, subtitle, Format.OFFSET_SAMPLE_RELATIVE);
           releaseInputBuffer(inputBuffer);
           return outputBuffer;
         }
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaSubtitle.java b/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaSubtitle.java
index 620b2c7d80..7da2054a08 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaSubtitle.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaSubtitle.java
@@ -15,8 +15,11 @@
  */
 package com.google.android.exoplayer2.text.cea;
 
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.Subtitle;
+import com.google.android.exoplayer2.util.Assertions;
+import java.util.Collections;
 import java.util.List;
 
 /**
@@ -35,7 +38,7 @@ public CeaSubtitle(List<Cue> cues) {
 
   @Override
   public int getNextEventTimeIndex(long timeUs) {
-    return 0;
+    return timeUs < 0 ? 0 : C.INDEX_UNSET;
   }
 
   @Override
@@ -45,12 +48,13 @@ public int getEventTimeCount() {
 
   @Override
   public long getEventTime(int index) {
+    Assertions.checkArgument(index == 0);
     return 0;
   }
 
   @Override
   public List<Cue> getCues(long timeUs) {
-    return cues;
+    return timeUs >= 0 ? cues : Collections.<Cue>emptyList();
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaUtil.java b/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaUtil.java
new file mode 100644
index 0000000000..3053debfcf
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaUtil.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.text.cea;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+
+/**
+ * Utility methods for handling CEA-608/708 messages.
+ */
+public final class CeaUtil {
+
+  private static final int PAYLOAD_TYPE_CC = 4;
+  private static final int COUNTRY_CODE = 0xB5;
+  private static final int PROVIDER_CODE = 0x31;
+  private static final int USER_ID = 0x47413934; // "GA94"
+  private static final int USER_DATA_TYPE_CODE = 0x3;
+
+  /**
+   * Consumes the unescaped content of an SEI NAL unit, writing the content of any CEA-608 messages
+   * as samples to the provided output.
+   *
+   * @param presentationTimeUs The presentation time in microseconds for any samples.
+   * @param seiBuffer The unescaped SEI NAL unit data, excluding the NAL unit start code and type.
+   * @param output The output to which any samples should be written.
+   */
+  public static void consume(long presentationTimeUs, ParsableByteArray seiBuffer,
+      TrackOutput output) {
+    int b;
+    while (seiBuffer.bytesLeft() > 1 /* last byte will be rbsp_trailing_bits */) {
+      // Parse payload type.
+      int payloadType = 0;
+      do {
+        b = seiBuffer.readUnsignedByte();
+        payloadType += b;
+      } while (b == 0xFF);
+      // Parse payload size.
+      int payloadSize = 0;
+      do {
+        b = seiBuffer.readUnsignedByte();
+        payloadSize += b;
+      } while (b == 0xFF);
+      // Process the payload.
+      if (isSeiMessageCea608(payloadType, payloadSize, seiBuffer)) {
+        // Ignore country_code (1) + provider_code (2) + user_identifier (4)
+        // + user_data_type_code (1).
+        seiBuffer.skipBytes(8);
+        // Ignore first three bits: reserved (1) + process_cc_data_flag (1) + zero_bit (1).
+        int ccCount = seiBuffer.readUnsignedByte() & 0x1F;
+        // Ignore em_data (1)
+        seiBuffer.skipBytes(1);
+        // Each data packet consists of 24 bits: marker bits (5) + cc_valid (1) + cc_type (2)
+        // + cc_data_1 (8) + cc_data_2 (8).
+        int sampleLength = ccCount * 3;
+        output.sampleData(seiBuffer, sampleLength);
+        output.sampleMetadata(presentationTimeUs, C.BUFFER_FLAG_KEY_FRAME, sampleLength, 0, null);
+        // Ignore trailing information in SEI, if any.
+        seiBuffer.skipBytes(payloadSize - (10 + ccCount * 3));
+      } else {
+        seiBuffer.skipBytes(payloadSize);
+      }
+    }
+  }
+
+  /**
+   * Inspects an sei message to determine whether it contains CEA-608.
+   * <p>
+   * The position of {@code payload} is left unchanged.
+   *
+   * @param payloadType The payload type of the message.
+   * @param payloadLength The length of the payload.
+   * @param payload A {@link ParsableByteArray} containing the payload.
+   * @return Whether the sei message contains CEA-608.
+   */
+  private static boolean isSeiMessageCea608(int payloadType, int payloadLength,
+      ParsableByteArray payload) {
+    if (payloadType != PAYLOAD_TYPE_CC || payloadLength < 8) {
+      return false;
+    }
+    int startPosition = payload.getPosition();
+    int countryCode = payload.readUnsignedByte();
+    int providerCode = payload.readUnsignedShort();
+    int userIdentifier = payload.readInt();
+    int userDataTypeCode = payload.readUnsignedByte();
+    payload.setPosition(startPosition);
+    return countryCode == COUNTRY_CODE && providerCode == PROVIDER_CODE
+        && userIdentifier == USER_ID && userDataTypeCode == USER_DATA_TYPE_CODE;
+  }
+
+  private CeaUtil() {}
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
index 79979401f7..f62d5d9075 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
@@ -560,6 +560,7 @@ private static TrackSelection selectFixedVideoTrack(TrackGroupArray groups,
     TrackGroup selectedGroup = null;
     int selectedTrackIndex = 0;
     int selectedTrackScore = 0;
+    int selectedBitrate = Format.NO_VALUE;
     int selectedPixelCount = Format.NO_VALUE;
     for (int groupIndex = 0; groupIndex < groups.length; groupIndex++) {
       TrackGroup trackGroup = groups.get(groupIndex);
@@ -582,16 +583,24 @@ private static TrackSelection selectFixedVideoTrack(TrackGroupArray groups,
           }
           boolean selectTrack = trackScore > selectedTrackScore;
           if (trackScore == selectedTrackScore) {
-            // Use the pixel count as a tie breaker. If we're within constraints prefer a higher
-            // pixel count, else prefer a lower count. If still tied then prefer the first track
-            // (i.e. the one that's already selected).
-            int pixelComparison = comparePixelCounts(format.getPixelCount(), selectedPixelCount);
-            selectTrack = isWithinConstraints ? pixelComparison > 0 : pixelComparison < 0;
+            // Use the pixel count as a tie breaker (or bitrate if pixel counts are tied). If we're
+            // within constraints prefer a higher pixel count (or bitrate), else prefer a lower
+            // count (or bitrate). If still tied then prefer the first track (i.e. the one that's
+            // already selected).
+            int comparisonResult;
+            int formatPixelCount = format.getPixelCount();
+            if (formatPixelCount != selectedPixelCount) {
+              comparisonResult = compareFormatValues(format.getPixelCount(), selectedPixelCount);
+            } else {
+              comparisonResult = compareFormatValues(format.bitrate, selectedBitrate);
+            }
+            selectTrack = isWithinConstraints ? comparisonResult > 0 : comparisonResult < 0;
           }
           if (selectTrack) {
             selectedGroup = trackGroup;
             selectedTrackIndex = trackIndex;
             selectedTrackScore = trackScore;
+            selectedBitrate = format.bitrate;
             selectedPixelCount = format.getPixelCount();
           }
         }
@@ -602,20 +611,19 @@ private static TrackSelection selectFixedVideoTrack(TrackGroupArray groups,
   }
 
   /**
-   * Compares two pixel counts for order. A known pixel count is considered greater than
+   * Compares two format values for order. A known value is considered greater than
    * {@link Format#NO_VALUE}.
    *
-   * @param first The first pixel count.
-   * @param second The second pixel count.
-   * @return A negative integer if the first pixel count is less than the second. Zero if they are
-   *     equal. A positive integer if the first pixel count is greater than the second.
+   * @param first The first value.
+   * @param second The second value.
+   * @return A negative integer if the first value is less than the second. Zero if they are equal.
+   *     A positive integer if the first value is greater than the second.
    */
-  private static int comparePixelCounts(int first, int second) {
+  private static int compareFormatValues(int first, int second) {
     return first == Format.NO_VALUE ? (second == Format.NO_VALUE ? 0 : -1)
         : (second == Format.NO_VALUE ? 1 : (first - second));
   }
 
-
   // Audio track selection implementation.
 
   protected TrackSelection selectAudioTrack(TrackGroupArray groups, int[][] formatSupport,
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
index 77df9a2173..690723cf15 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
@@ -15,12 +15,13 @@
  */
 package com.google.android.exoplayer2.trackselection;
 
-import android.util.Pair;
+import android.content.Context;
 import android.util.SparseArray;
 import android.util.SparseBooleanArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.RendererCapabilities;
+import com.google.android.exoplayer2.RendererConfiguration;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.util.Util;
@@ -82,12 +83,14 @@ public boolean containsTrack(int track) {
 
   private final SparseArray<Map<TrackGroupArray, SelectionOverride>> selectionOverrides;
   private final SparseBooleanArray rendererDisabledFlags;
+  private int tunnelingAudioSessionId;
 
   private MappedTrackInfo currentMappedTrackInfo;
 
   public MappingTrackSelector() {
     selectionOverrides = new SparseArray<>();
     rendererDisabledFlags = new SparseBooleanArray();
+    tunnelingAudioSessionId = C.AUDIO_SESSION_ID_UNSET;
   }
 
   /**
@@ -224,12 +227,28 @@ public final void clearSelectionOverrides() {
     invalidate();
   }
 
+  /**
+   * Enables or disables tunneling. To enable tunneling, pass an audio session id to use when in
+   * tunneling mode. Session ids can be generated using
+   * {@link C#generateAudioSessionIdV21(Context)}. To disable tunneling pass
+   * {@link C#AUDIO_SESSION_ID_UNSET}. Tunneling will only be activated if it's both enabled and
+   * supported by the audio and video renderers for the selected tracks.
+   *
+   * @param tunnelingAudioSessionId The audio session id to use when tunneling, or
+   *     {@link C#AUDIO_SESSION_ID_UNSET} to disable tunneling.
+   */
+  public void setTunnelingAudioSessionId(int tunnelingAudioSessionId) {
+    if (this.tunnelingAudioSessionId != tunnelingAudioSessionId) {
+      this.tunnelingAudioSessionId = tunnelingAudioSessionId;
+      invalidate();
+    }
+  }
+
   // TrackSelector implementation.
 
   @Override
-  public final Pair<TrackSelectionArray, Object> selectTracks(
-      RendererCapabilities[] rendererCapabilities, TrackGroupArray trackGroups)
-      throws ExoPlaybackException {
+  public final TrackSelectorResult selectTracks(RendererCapabilities[] rendererCapabilities,
+      TrackGroupArray trackGroups) throws ExoPlaybackException {
     // Structures into which data will be written during the selection. The extra item at the end
     // of each array is to store data associated with track groups that cannot be associated with
     // any renderer.
@@ -297,8 +316,20 @@ public final void clearSelectionOverrides() {
     MappedTrackInfo mappedTrackInfo = new MappedTrackInfo(rendererTrackTypes,
         rendererTrackGroupArrays, mixedMimeTypeAdaptationSupport, rendererFormatSupports,
         unassociatedTrackGroupArray);
-    return Pair.<TrackSelectionArray, Object>create(new TrackSelectionArray(trackSelections),
-        mappedTrackInfo);
+
+    // Initialize the renderer configurations to the default configuration for all renderers with
+    // selections, and null otherwise.
+    RendererConfiguration[] rendererConfigurations =
+        new RendererConfiguration[rendererCapabilities.length];
+    for (int i = 0; i < rendererCapabilities.length; i++) {
+      rendererConfigurations[i] = trackSelections[i] != null ? RendererConfiguration.DEFAULT : null;
+    }
+    // Configure audio and video renderers to use tunneling if appropriate.
+    maybeConfigureRenderersForTunneling(rendererCapabilities, rendererTrackGroupArrays,
+        rendererFormatSupports, rendererConfigurations, trackSelections, tunnelingAudioSessionId);
+
+    return new TrackSelectorResult(trackGroups, new TrackSelectionArray(trackSelections),
+        mappedTrackInfo, rendererConfigurations);
   }
 
   @Override
@@ -345,15 +376,16 @@ public final void onSelectionActivated(Object info) {
   private static int findRenderer(RendererCapabilities[] rendererCapabilities, TrackGroup group)
       throws ExoPlaybackException {
     int bestRendererIndex = rendererCapabilities.length;
-    int bestSupportLevel = RendererCapabilities.FORMAT_UNSUPPORTED_TYPE;
+    int bestFormatSupportLevel = RendererCapabilities.FORMAT_UNSUPPORTED_TYPE;
     for (int rendererIndex = 0; rendererIndex < rendererCapabilities.length; rendererIndex++) {
       RendererCapabilities rendererCapability = rendererCapabilities[rendererIndex];
       for (int trackIndex = 0; trackIndex < group.length; trackIndex++) {
-        int trackSupportLevel = rendererCapability.supportsFormat(group.getFormat(trackIndex));
-        if (trackSupportLevel > bestSupportLevel) {
+        int formatSupportLevel = rendererCapability.supportsFormat(group.getFormat(trackIndex))
+            & RendererCapabilities.FORMAT_SUPPORT_MASK;
+        if (formatSupportLevel > bestFormatSupportLevel) {
           bestRendererIndex = rendererIndex;
-          bestSupportLevel = trackSupportLevel;
-          if (bestSupportLevel == RendererCapabilities.FORMAT_HANDLED) {
+          bestFormatSupportLevel = formatSupportLevel;
+          if (bestFormatSupportLevel == RendererCapabilities.FORMAT_HANDLED) {
             // We can't do better.
             return bestRendererIndex;
           }
@@ -400,6 +432,94 @@ private static int findRenderer(RendererCapabilities[] rendererCapabilities, Tra
     return mixedMimeTypeAdaptationSupport;
   }
 
+  /**
+   * Determines whether tunneling should be enabled, replacing {@link RendererConfiguration}s in
+   * {@code rendererConfigurations} with configurations that enable tunneling on the appropriate
+   * renderers if so.
+   *
+   * @param rendererCapabilities The {@link RendererCapabilities} of the renderers for which
+   *     {@link TrackSelection}s are to be generated.
+   * @param rendererTrackGroupArrays An array of {@link TrackGroupArray}s where each entry
+   *     corresponds to the renderer of equal index in {@code renderers}.
+   * @param rendererFormatSupports Maps every available track to a specific level of support as
+   *     defined by the renderer {@code FORMAT_*} constants.
+   * @param rendererConfigurations The renderer configurations. Configurations may be replaced with
+   *     ones that enable tunneling as a result of this call.
+   * @param trackSelections The renderer track selections.
+   * @param tunnelingAudioSessionId The audio session id to use when tunneling, or
+   *     {@link C#AUDIO_SESSION_ID_UNSET} if tunneling should not be enabled.
+   */
+  private static void maybeConfigureRenderersForTunneling(
+      RendererCapabilities[] rendererCapabilities, TrackGroupArray[] rendererTrackGroupArrays,
+      int[][][] rendererFormatSupports, RendererConfiguration[] rendererConfigurations,
+      TrackSelection[] trackSelections, int tunnelingAudioSessionId) {
+    if (tunnelingAudioSessionId == C.AUDIO_SESSION_ID_UNSET) {
+      return;
+    }
+    // Check whether we can enable tunneling. To enable tunneling we require exactly one audio and
+    // one video renderer to support tunneling and have a selection.
+    int tunnelingAudioRendererIndex = -1;
+    int tunnelingVideoRendererIndex = -1;
+    boolean enableTunneling = true;
+    for (int i = 0; i < rendererCapabilities.length; i++) {
+      int rendererType = rendererCapabilities[i].getTrackType();
+      TrackSelection trackSelection = trackSelections[i];
+      if ((rendererType == C.TRACK_TYPE_AUDIO || rendererType == C.TRACK_TYPE_VIDEO)
+          && trackSelection != null) {
+        if (rendererSupportsTunneling(rendererFormatSupports[i], rendererTrackGroupArrays[i],
+            trackSelection)) {
+          if (rendererType == C.TRACK_TYPE_AUDIO) {
+            if (tunnelingAudioRendererIndex != -1) {
+              enableTunneling = false;
+              break;
+            } else {
+              tunnelingAudioRendererIndex = i;
+            }
+          } else {
+            if (tunnelingVideoRendererIndex != -1) {
+              enableTunneling = false;
+              break;
+            } else {
+              tunnelingVideoRendererIndex = i;
+            }
+          }
+        }
+      }
+    }
+    enableTunneling &= tunnelingAudioRendererIndex != -1 && tunnelingVideoRendererIndex != -1;
+    if (enableTunneling) {
+      RendererConfiguration tunnelingRendererConfiguration =
+          new RendererConfiguration(tunnelingAudioSessionId);
+      rendererConfigurations[tunnelingAudioRendererIndex] = tunnelingRendererConfiguration;
+      rendererConfigurations[tunnelingVideoRendererIndex] = tunnelingRendererConfiguration;
+    }
+  }
+
+  /**
+   * Returns whether a renderer supports tunneling for a {@link TrackSelection}.
+   *
+   * @param formatSupport The result of {@link RendererCapabilities#supportsFormat} for each
+   *     track, indexed by group index and track index (in that order).
+   * @param trackGroups The {@link TrackGroupArray}s for the renderer.
+   * @param selection The track selection.
+   * @return Whether the renderer supports tunneling for the {@link TrackSelection}.
+   */
+  private static boolean rendererSupportsTunneling(int[][] formatSupport,
+      TrackGroupArray trackGroups, TrackSelection selection) {
+    if (selection == null) {
+      return false;
+    }
+    int trackGroupIndex = trackGroups.indexOf(selection.getTrackGroup());
+    for (int i = 0; i < selection.length(); i++) {
+      int trackFormatSupport = formatSupport[trackGroupIndex][selection.getIndexInTrackGroup(i)];
+      if ((trackFormatSupport & RendererCapabilities.TUNNELING_SUPPORT_MASK)
+          != RendererCapabilities.TUNNELING_SUPPORTED) {
+        return false;
+      }
+    }
+    return true;
+  }
+
   /**
    * Provides track information for each renderer.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java
index 5a9d3923bf..6c9fbfcb00 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer2.trackselection;
 
-import android.util.Pair;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.RendererCapabilities;
 import com.google.android.exoplayer2.source.TrackGroupArray;
@@ -47,25 +46,22 @@ public final void init(InvalidationListener listener) {
   }
 
   /**
-   * Generates {@link TrackSelectionArray} for the renderers.
+   * Performs a track selection for renderers.
    *
-   * @param rendererCapabilities The {@link RendererCapabilities} of the renderers for which
-   *     {@link TrackSelection}s are to be generated.
+   * @param rendererCapabilities The {@link RendererCapabilities} of the renderers for which tracks
+   *     are to be selected.
    * @param trackGroups The available track groups.
-   * @return The track selections, and an implementation specific object that will be returned to
-   *     the selector via {@link #onSelectionActivated(Object)} should the selections be activated.
+   * @return A {@link TrackSelectorResult} describing the track selections.
    * @throws ExoPlaybackException If an error occurs selecting tracks.
    */
-  public abstract Pair<TrackSelectionArray, Object> selectTracks(
-      RendererCapabilities[] rendererCapabilities, TrackGroupArray trackGroups)
-      throws ExoPlaybackException;
+  public abstract TrackSelectorResult selectTracks(RendererCapabilities[] rendererCapabilities,
+      TrackGroupArray trackGroups) throws ExoPlaybackException;
 
   /**
-   * Called when {@link TrackSelectionArray} previously generated by
-   * {@link #selectTracks(RendererCapabilities[], TrackGroupArray)} are activated.
+   * Called when a {@link TrackSelectorResult} previously generated by
+   * {@link #selectTracks(RendererCapabilities[], TrackGroupArray)} is activated.
    *
-   * @param info The information associated with the selections, or null if the selected tracks are
-   *     being cleared.
+   * @param info The value of {@link TrackSelectorResult#info} in the activated result.
    */
   public abstract void onSelectionActivated(Object info);
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java
new file mode 100644
index 0000000000..5cdb157570
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.trackselection;
+
+import com.google.android.exoplayer2.RendererConfiguration;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.util.Util;
+
+/**
+ * The result of a {@link TrackSelector} operation.
+ */
+public final class TrackSelectorResult {
+
+  /**
+   * The groups provided to the {@link TrackSelector}.
+   */
+  public final TrackGroupArray groups;
+  /**
+   * A {@link TrackSelectionArray} containing the selection for each renderer.
+   */
+  public final TrackSelectionArray selections;
+  /**
+   * An opaque object that will be returned to {@link TrackSelector#onSelectionActivated(Object)}
+   * should the selections be activated.
+   */
+  public final Object info;
+  /**
+   * A {@link RendererConfiguration} for each renderer, to be used with the selections.
+   */
+  public final RendererConfiguration[] rendererConfigurations;
+
+  /**
+   * @param groups The groups provided to the {@link TrackSelector}.
+   * @param selections A {@link TrackSelectionArray} containing the selection for each renderer.
+   * @param info An opaque object that will be returned to
+   *     {@link TrackSelector#onSelectionActivated(Object)} should the selections be activated.
+   * @param rendererConfigurations A {@link RendererConfiguration} for each renderer, to be used
+   *     with the selections.
+   */
+  public TrackSelectorResult(TrackGroupArray groups, TrackSelectionArray selections, Object info,
+      RendererConfiguration[] rendererConfigurations) {
+    this.groups = groups;
+    this.selections = selections;
+    this.info = info;
+    this.rendererConfigurations = rendererConfigurations;
+  }
+
+  /**
+   * Returns whether this result is equivalent to {@code other} for all renderers.
+   *
+   * @param other The other {@link TrackSelectorResult}. May be null, in which case {@code false}
+   *     will be returned in all cases.
+   * @return Whether this result is equivalent to {@code other} for all renderers.
+   */
+  public boolean isEquivalent(TrackSelectorResult other) {
+    if (other == null) {
+      return false;
+    }
+    for (int i = 0; i < selections.length; i++) {
+      if (!isEquivalent(other, i)) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  /**
+   * Returns whether this result is equivalent to {@code other} for the renderer at the given index.
+   * The results are equivalent if they have equal track selections and configurations for the
+   * renderer.
+   *
+   * @param other The other {@link TrackSelectorResult}. May be null, in which case {@code false}
+   *     will be returned in all cases.
+   * @param index The renderer index to check for equivalence.
+   * @return Whether this result is equivalent to {@code other} for all renderers.
+   */
+  public boolean isEquivalent(TrackSelectorResult other, int index) {
+    if (other == null) {
+      return false;
+    }
+    return Util.areEqual(selections.get(index), other.selections.get(index))
+        && Util.areEqual(rendererConfigurations[index], other.rendererConfigurations[index]);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java b/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
index 40e814dab3..dc3c398357 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
@@ -735,8 +735,14 @@ public void onStartTrackingTouch(SeekBar seekBar) {
 
     @Override
     public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
-      if (fromUser && positionView != null) {
-        positionView.setText(stringForTime(positionValue(progress)));
+      if (fromUser) {
+        long position = positionValue(progress);
+        if (positionView != null) {
+          positionView.setText(stringForTime(position));
+        }
+        if (player != null && !dragging) {
+          seekTo(position);
+        }
       }
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java b/library/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java
index d094266fcc..3349e05eda 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java
@@ -65,6 +65,13 @@
  *         <li>Default: {@code true}</li>
  *       </ul>
  *   </li>
+ *   <li><b>{@code default_artwork}</b> - Default artwork to use if no artwork available in audio
+ *       streams.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setDefaultArtwork(Bitmap)}</li>
+ *         <li>Default: {@code null}</li>
+ *       </ul>
+ *   </li>
  *   <li><b>{@code use_controller}</b> - Whether playback controls are displayed.
  *       <ul>
  *         <li>Corresponding method: {@link #setUseController(boolean)}</li>
@@ -179,6 +186,7 @@
   private SimpleExoPlayer player;
   private boolean useController;
   private boolean useArtwork;
+  private Bitmap defaultArtwork;
   private int controllerShowTimeoutMs;
 
   public SimpleExoPlayerView(Context context) {
@@ -194,6 +202,7 @@ public SimpleExoPlayerView(Context context, AttributeSet attrs, int defStyleAttr
 
     int playerLayoutId = R.layout.exo_simple_player_view;
     boolean useArtwork = true;
+    int defaultArtworkId = 0;
     boolean useController = true;
     int surfaceType = SURFACE_TYPE_SURFACE_VIEW;
     int resizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;
@@ -205,6 +214,8 @@ public SimpleExoPlayerView(Context context, AttributeSet attrs, int defStyleAttr
         playerLayoutId = a.getResourceId(R.styleable.SimpleExoPlayerView_player_layout_id,
             playerLayoutId);
         useArtwork = a.getBoolean(R.styleable.SimpleExoPlayerView_use_artwork, useArtwork);
+        defaultArtworkId = a.getResourceId(R.styleable.SimpleExoPlayerView_default_artwork,
+            defaultArtworkId);
         useController = a.getBoolean(R.styleable.SimpleExoPlayerView_use_controller, useController);
         surfaceType = a.getInt(R.styleable.SimpleExoPlayerView_surface_type, surfaceType);
         resizeMode = a.getInt(R.styleable.SimpleExoPlayerView_resize_mode, resizeMode);
@@ -246,6 +257,9 @@ public SimpleExoPlayerView(Context context, AttributeSet attrs, int defStyleAttr
     // Artwork view.
     artworkView = (ImageView) findViewById(R.id.exo_artwork);
     this.useArtwork = useArtwork && artworkView != null;
+    if (defaultArtworkId != 0) {
+      defaultArtwork = BitmapFactory.decodeResource(context.getResources(), defaultArtworkId);
+    }
 
     // Subtitle view.
     subtitleView = (SubtitleView) findViewById(R.id.exo_subtitles);
@@ -351,6 +365,26 @@ public void setUseArtwork(boolean useArtwork) {
     }
   }
 
+  /**
+   * Returns the default artwork to display.
+   */
+  public Bitmap getDefaultArtwork() {
+    return defaultArtwork;
+  }
+
+  /**
+   * Sets the default artwork to display if {@code useArtwork} is {@code true} and no artwork is
+   * present in the media.
+   *
+   * @param defaultArtwork the default artwork to display.
+   */
+  public void setDefaultArtwork(Bitmap defaultArtwork) {
+    if (this.defaultArtwork != defaultArtwork) {
+      this.defaultArtwork = defaultArtwork;
+      updateForCurrentTrackSelections();
+    }
+  }
+
   /**
    * Returns whether the playback controls are enabled.
    */
@@ -569,6 +603,9 @@ private void updateForCurrentTrackSelections() {
           }
         }
       }
+      if (setArtworkFromBitmap(defaultArtwork)) {
+        return;
+      }
     }
     // Artwork disabled or unavailable.
     hideArtwork();
@@ -580,18 +617,23 @@ private boolean setArtworkFromMetadata(Metadata metadata) {
       if (metadataEntry instanceof ApicFrame) {
         byte[] bitmapData = ((ApicFrame) metadataEntry).pictureData;
         Bitmap bitmap = BitmapFactory.decodeByteArray(bitmapData, 0, bitmapData.length);
-        if (bitmap != null) {
-          int bitmapWidth = bitmap.getWidth();
-          int bitmapHeight = bitmap.getHeight();
-          if (bitmapWidth > 0 && bitmapHeight > 0) {
-            if (contentFrame != null) {
-              contentFrame.setAspectRatio((float) bitmapWidth / bitmapHeight);
-            }
-            artworkView.setImageBitmap(bitmap);
-            artworkView.setVisibility(VISIBLE);
-            return true;
-          }
+        return setArtworkFromBitmap(bitmap);
+      }
+    }
+    return false;
+  }
+
+  private boolean setArtworkFromBitmap(Bitmap bitmap) {
+    if (bitmap != null) {
+      int bitmapWidth = bitmap.getWidth();
+      int bitmapHeight = bitmap.getHeight();
+      if (bitmapWidth > 0 && bitmapHeight > 0) {
+        if (contentFrame != null) {
+          contentFrame.setAspectRatio((float) bitmapWidth / bitmapHeight);
         }
+        artworkView.setImageBitmap(bitmap);
+        artworkView.setVisibility(VISIBLE);
+        return true;
       }
     }
     return false;
diff --git a/library/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java b/library/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java
index de461ecf0d..04f3b986bd 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java
@@ -146,9 +146,13 @@ public void draw(Cue cue, boolean applyEmbeddedStyles, CaptionStyleCompat style,
       // Nothing to draw.
       return;
     }
+
+    int windowColor = cue.windowColorSet ? cue.windowColor : style.windowColor;
+
     if (!applyEmbeddedStyles) {
       // Strip out any embedded styling.
       cueText = cueText.toString();
+      windowColor = style.windowColor;
     }
     if (areCharSequencesEqual(this.cueText, cueText)
         && Util.areEqual(this.cueTextAlignment, cue.textAlignment)
@@ -161,7 +165,7 @@ public void draw(Cue cue, boolean applyEmbeddedStyles, CaptionStyleCompat style,
         && this.applyEmbeddedStyles == applyEmbeddedStyles
         && this.foregroundColor == style.foregroundColor
         && this.backgroundColor == style.backgroundColor
-        && this.windowColor == style.windowColor
+        && this.windowColor == windowColor
         && this.edgeType == style.edgeType
         && this.edgeColor == style.edgeColor
         && Util.areEqual(this.textPaint.getTypeface(), style.typeface)
@@ -187,7 +191,7 @@ public void draw(Cue cue, boolean applyEmbeddedStyles, CaptionStyleCompat style,
     this.applyEmbeddedStyles = applyEmbeddedStyles;
     this.foregroundColor = style.foregroundColor;
     this.backgroundColor = style.backgroundColor;
-    this.windowColor = style.windowColor;
+    this.windowColor = windowColor;
     this.edgeType = style.edgeType;
     this.edgeColor = style.edgeColor;
     this.textPaint.setTypeface(style.typeface);
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java
index 0ddf17cbe9..4a2354e180 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java
@@ -65,7 +65,7 @@
    * @param buffer The buffer into which the read data should be stored.
    * @param offset The start offset into {@code buffer} at which data should be written.
    * @param readLength The maximum number of bytes to read.
-   * @return The number of bytes read, or {@link C#RESULT_END_OF_INPUT} if no data is avaliable
+   * @return The number of bytes read, or {@link C#RESULT_END_OF_INPUT} if no data is available
    *     because the end of the opened range has been reached.
    * @throws IOException If an error occurs reading from the source.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
index d251446976..133e71f6e2 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
@@ -32,7 +32,7 @@
    * The flags that apply to any request for data.
    */
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef(flag = true, value = {FLAG_ALLOW_GZIP})
+  @IntDef(flag = true, value = {FLAG_ALLOW_GZIP, FLAG_ALLOW_CACHING_UNKNOWN_LENGTH})
   public @interface Flags {}
   /**
    * Permits an underlying network stack to request that the server use gzip compression.
@@ -45,7 +45,10 @@
    * {@link DataSource#open(DataSpec)} will typically be {@link C#LENGTH_UNSET}. The data read from
    * {@link DataSource#read(byte[], int, int)} will be the decompressed data.
    */
-  public static final int FLAG_ALLOW_GZIP = 1;
+  public static final int FLAG_ALLOW_GZIP = 1 << 0;
+
+  /** Permits content to be cached even if its length can not be resolved. */
+  public static final int FLAG_ALLOW_CACHING_UNKNOWN_LENGTH = 1 << 1;
 
   /**
    * The source from which data should be read.
@@ -76,7 +79,8 @@
    */
   public final String key;
   /**
-   * Request flags. Currently {@link #FLAG_ALLOW_GZIP} is the only supported flag.
+   * Request flags. Currently {@link #FLAG_ALLOW_GZIP} and
+   * {@link #FLAG_ALLOW_CACHING_UNKNOWN_LENGTH} are the only supported flags.
    */
   @Flags
   public final int flags;
@@ -167,6 +171,15 @@ public DataSpec(Uri uri, byte[] postBody, long absoluteStreamPosition, long posi
     this.flags = flags;
   }
 
+  /**
+   * Returns whether the given flag is set.
+   *
+   * @param flag Flag to be checked if it is set.
+   */
+  public boolean isFlagSet(@Flags int flag) {
+    return (this.flags & flag) == flag;
+  }
+
   @Override
   public String toString() {
     return "DataSpec[" + uri + ", " + Arrays.toString(postBody) + ", " + absoluteStreamPosition
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
index b326c41b18..ca0fda9399 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
@@ -230,7 +230,7 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     bytesToSkip = responseCode == 200 && dataSpec.position != 0 ? dataSpec.position : 0;
 
     // Determine the length of the data to be read, after skipping.
-    if ((dataSpec.flags & DataSpec.FLAG_ALLOW_GZIP) == 0) {
+    if (!dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_GZIP)) {
       if (dataSpec.length != C.LENGTH_UNSET) {
         bytesToRead = dataSpec.length;
       } else {
@@ -343,7 +343,7 @@ private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
     byte[] postBody = dataSpec.postBody;
     long position = dataSpec.position;
     long length = dataSpec.length;
-    boolean allowGzip = (dataSpec.flags & DataSpec.FLAG_ALLOW_GZIP) != 0;
+    boolean allowGzip = dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_GZIP);
 
     if (!allowCrossProtocolRedirects) {
       // HttpURLConnection disallows cross-protocol redirects, but otherwise performs redirection
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.java
index dcfed59145..615eb4df97 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.java
@@ -15,10 +15,11 @@
  */
 package com.google.android.exoplayer2.upstream;
 
+import com.google.android.exoplayer2.upstream.HttpDataSource.BaseFactory;
 import com.google.android.exoplayer2.upstream.HttpDataSource.Factory;
 
 /** A {@link Factory} that produces {@link DefaultHttpDataSource} instances. */
-public final class DefaultHttpDataSourceFactory implements Factory {
+public final class DefaultHttpDataSourceFactory extends BaseFactory {
 
   private final String userAgent;
   private final TransferListener<? super DataSource> listener;
@@ -75,8 +76,9 @@ public DefaultHttpDataSourceFactory(String userAgent,
   }
 
   @Override
-  public DefaultHttpDataSource createDataSource() {
+  protected DefaultHttpDataSource createDataSourceInternal() {
     return new DefaultHttpDataSource(userAgent, null, listener, connectTimeoutMillis,
         readTimeoutMillis, allowCrossProtocolRedirects);
   }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
index f915ee4e24..8df8624102 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
@@ -17,11 +17,13 @@
 
 import android.support.annotation.IntDef;
 import android.text.TextUtils;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Predicate;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
@@ -38,6 +40,86 @@
     @Override
     HttpDataSource createDataSource();
 
+    /**
+     * Sets a default request header field for {@link HttpDataSource} instances subsequently
+     * created by the factory. Previously created instances are not affected.
+     *
+     * @param name The name of the header field.
+     * @param value The value of the field.
+     */
+    void setDefaultRequestProperty(String name, String value);
+
+    /**
+     * Clears a default request header field for {@link HttpDataSource} instances subsequently
+     * created by the factory. Previously created instances are not affected.
+     *
+     * @param name The name of the header field.
+     */
+    void clearDefaultRequestProperty(String name);
+
+    /**
+     * Clears all default request header fields for all {@link HttpDataSource} instances
+     * subsequently created by the factory.  Previously created instances are not affected.
+     */
+    void clearAllDefaultRequestProperties();
+
+  }
+
+  /**
+   * Base implementation of {@link Factory} that sets default request properties.
+   */
+  abstract class BaseFactory implements Factory {
+
+    private final HashMap<String, String> requestProperties;
+
+    public BaseFactory() {
+      requestProperties = new HashMap<>();
+    }
+
+    @Override
+    public final HttpDataSource createDataSource() {
+      HttpDataSource dataSource = createDataSourceInternal();
+      synchronized (requestProperties) {
+        for (Map.Entry<String, String> property : requestProperties.entrySet()) {
+          dataSource.setRequestProperty(property.getKey(), property.getValue());
+        }
+      }
+      return dataSource;
+    }
+
+    @Override
+    public final void setDefaultRequestProperty(String name, String value) {
+      Assertions.checkNotNull(name);
+      Assertions.checkNotNull(value);
+      synchronized (requestProperties) {
+        requestProperties.put(name, value);
+      }
+    }
+
+    @Override
+    public final void clearDefaultRequestProperty(String name) {
+      Assertions.checkNotNull(name);
+      synchronized (requestProperties) {
+        requestProperties.remove(name);
+      }
+    }
+
+    @Override
+    public final void clearAllDefaultRequestProperties() {
+      synchronized (requestProperties) {
+        requestProperties.clear();
+      }
+    }
+
+    /**
+     * Called by {@link #createDataSource()} to create a {@link HttpDataSource} instance without
+     * default request properties set. Default request properties will be set by
+     * {@link #createDataSource()} before the instance is returned.
+     *
+     * @return A {@link HttpDataSource} instance without default request properties set.
+     */
+    protected abstract HttpDataSource createDataSourceInternal();
+
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java b/library/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
index c23b609704..c25638ac86 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.upstream.Loader.Loadable;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.io.InputStream;
 
@@ -114,7 +115,7 @@ public final void load() throws IOException, InterruptedException {
       result = parser.parse(dataSource.getUri(), inputStream);
     } finally {
       bytesLoaded = inputStream.bytesRead();
-      inputStream.close();
+      Util.closeQuietly(inputStream);
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
index d57f3ee140..71397bd403 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
@@ -81,10 +81,12 @@ public CacheDataSink(Cache cache, long maxCacheFileSize, int bufferSize) {
 
   @Override
   public void open(DataSpec dataSpec) throws CacheDataSinkException {
-    this.dataSpec = dataSpec;
-    if (dataSpec.length == C.LENGTH_UNSET) {
+    if (dataSpec.length == C.LENGTH_UNSET
+        && !dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH)) {
+      this.dataSpec = null;
       return;
     }
+    this.dataSpec = dataSpec;
     dataSpecBytesWritten = 0;
     try {
       openNextOutputStream();
@@ -95,7 +97,7 @@ public void open(DataSpec dataSpec) throws CacheDataSinkException {
 
   @Override
   public void write(byte[] buffer, int offset, int length) throws CacheDataSinkException {
-    if (dataSpec.length == C.LENGTH_UNSET) {
+    if (dataSpec == null) {
       return;
     }
     try {
@@ -119,7 +121,7 @@ public void write(byte[] buffer, int offset, int length) throws CacheDataSinkExc
 
   @Override
   public void close() throws CacheDataSinkException {
-    if (dataSpec == null || dataSpec.length == C.LENGTH_UNSET) {
+    if (dataSpec == null) {
       return;
     }
     try {
@@ -130,8 +132,10 @@ public void close() throws CacheDataSinkException {
   }
 
   private void openNextOutputStream() throws IOException {
+    long maxLength = dataSpec.length == C.LENGTH_UNSET ? maxCacheFileSize
+        : Math.min(dataSpec.length - dataSpecBytesWritten, maxCacheFileSize);
     file = cache.startFile(dataSpec.key, dataSpec.absoluteStreamPosition + dataSpecBytesWritten,
-        Math.min(dataSpec.length - dataSpecBytesWritten, maxCacheFileSize));
+        maxLength);
     underlyingFileOutputStream = new FileOutputStream(file);
     if (bufferSize > 0) {
       if (bufferedOutputStream == null) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
index 4dc5431b47..9b29984d06 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
@@ -330,16 +330,16 @@ private boolean openNextSource(boolean initial) throws IOException {
     // bytesRemaining == C.LENGTH_UNSET) and got a resolved length from open() request
     if (currentRequestUnbounded && currentBytesRemaining != C.LENGTH_UNSET) {
       bytesRemaining = currentBytesRemaining;
-      // If writing into cache
-      if (lockedSpan != null) {
-        setContentLength(dataSpec.position + bytesRemaining);
-      }
+      setContentLength(dataSpec.position + bytesRemaining);
     }
     return successful;
   }
 
   private void setContentLength(long length) throws IOException {
-    cache.setContentLength(key, length);
+    // If writing into cache
+    if (currentDataSource == cacheWriteDataSource) {
+      cache.setContentLength(key, length);
+    }
   }
 
   private void closeCurrentSource() throws IOException {
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
index 9e38dabc31..58cc70d68d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
@@ -67,14 +67,25 @@
   private boolean changed;
   private ReusableBufferedOutputStream bufferedOutputStream;
 
-  /** Creates a CachedContentIndex which works on the index file in the given cacheDir. */
+  /**
+   * Creates a CachedContentIndex which works on the index file in the given cacheDir.
+   *
+   * @param cacheDir Directory where the index file is kept.
+   */
   public CachedContentIndex(File cacheDir) {
     this(cacheDir, null);
   }
 
-  /** Creates a CachedContentIndex which works on the index file in the given cacheDir. */
+  /**
+   * Creates a CachedContentIndex which works on the index file in the given cacheDir.
+   *
+   * @param cacheDir Directory where the index file is kept.
+   * @param secretKey If not null, cache keys will be stored encrypted on filesystem using AES/CBC.
+   *     The key must be 16 bytes long.
+   */
   public CachedContentIndex(File cacheDir, byte[] secretKey) {
     if (secretKey != null) {
+      Assertions.checkArgument(secretKey.length == 16);
       try {
         cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
         secretKeySpec = new SecretKeySpec(secretKey, "AES");
@@ -302,6 +313,9 @@ private void writeFile() throws CacheException {
       }
       output.writeInt(hashCode);
       atomicFile.endWrite(output);
+      // Avoid calling close twice. Duplicate CipherOutputStream.close calls did
+      // not used to be no-ops: https://android-review.googlesource.com/#/c/272799/
+      output = null;
     } catch (IOException e) {
       throw new CacheException(e);
     } finally {
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTracker.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTracker.java
new file mode 100644
index 0000000000..0f08ca40f2
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTracker.java
@@ -0,0 +1,205 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.cache;
+
+import android.util.Log;
+import com.google.android.exoplayer2.extractor.ChunkIndex;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.NavigableSet;
+import java.util.TreeSet;
+
+/**
+ * Utility class for efficiently tracking regions of data that are stored in a {@link Cache}
+ * for a given cache key.
+ */
+public final class CachedRegionTracker implements Cache.Listener {
+
+  private static final String TAG = "CachedRegionTracker";
+
+  public static final int NOT_CACHED = -1;
+  public static final int CACHED_TO_END = -2;
+
+  private final Cache cache;
+  private final String cacheKey;
+  private final ChunkIndex chunkIndex;
+
+  private final TreeSet<Region> regions;
+  private final Region lookupRegion;
+
+  public CachedRegionTracker(Cache cache, String cacheKey, ChunkIndex chunkIndex) {
+    this.cache = cache;
+    this.cacheKey = cacheKey;
+    this.chunkIndex = chunkIndex;
+    this.regions = new TreeSet<>();
+    this.lookupRegion = new Region(0, 0);
+
+    synchronized (this) {
+      NavigableSet<CacheSpan> cacheSpans = cache.addListener(cacheKey, this);
+      if (cacheSpans != null) {
+        // Merge the spans into regions. mergeSpan is more efficient when merging from high to low,
+        // which is why a descending iterator is used here.
+        Iterator<CacheSpan> spanIterator = cacheSpans.descendingIterator();
+        while (spanIterator.hasNext()) {
+          CacheSpan span = spanIterator.next();
+          mergeSpan(span);
+        }
+      }
+    }
+  }
+
+  public void release() {
+    cache.removeListener(cacheKey, this);
+  }
+
+  /**
+   * When provided with a byte offset, this method locates the cached region within which the
+   * offset falls, and returns the approximate end position in milliseconds of that region. If the
+   * byte offset does not fall within a cached region then {@link #NOT_CACHED} is returned.
+   * If the cached region extends to the end of the stream, {@link #CACHED_TO_END} is returned.
+   *
+   * @param byteOffset The byte offset in the underlying stream.
+   * @return The end position of the corresponding cache region, {@link #NOT_CACHED}, or
+   *     {@link #CACHED_TO_END}.
+   */
+  public synchronized int getRegionEndTimeMs(long byteOffset) {
+    lookupRegion.startOffset = byteOffset;
+    Region floorRegion = regions.floor(lookupRegion);
+    if (floorRegion == null || byteOffset > floorRegion.endOffset
+        || floorRegion.endOffsetIndex == -1) {
+      return NOT_CACHED;
+    }
+    int index = floorRegion.endOffsetIndex;
+    if (index == chunkIndex.length - 1
+        && floorRegion.endOffset == (chunkIndex.offsets[index] + chunkIndex.sizes[index])) {
+      return CACHED_TO_END;
+    }
+    long segmentFractionUs = (chunkIndex.durationsUs[index]
+        * (floorRegion.endOffset - chunkIndex.offsets[index])) / chunkIndex.sizes[index];
+    return (int) ((chunkIndex.timesUs[index] + segmentFractionUs) / 1000);
+  }
+
+  @Override
+  public synchronized void onSpanAdded(Cache cache, CacheSpan span) {
+    mergeSpan(span);
+  }
+
+  @Override
+  public synchronized void onSpanRemoved(Cache cache, CacheSpan span) {
+    Region removedRegion = new Region(span.position, span.position + span.length);
+
+    // Look up a region this span falls into.
+    Region floorRegion = regions.floor(removedRegion);
+    if (floorRegion == null) {
+      Log.e(TAG, "Removed a span we were not aware of");
+      return;
+    }
+
+    // Remove it.
+    regions.remove(floorRegion);
+
+    // Add new floor and ceiling regions, if necessary.
+    if (floorRegion.startOffset < removedRegion.startOffset) {
+      Region newFloorRegion = new Region(floorRegion.startOffset, removedRegion.startOffset);
+
+      int index = Arrays.binarySearch(chunkIndex.offsets, newFloorRegion.endOffset);
+      newFloorRegion.endOffsetIndex = index < 0 ? -index - 2 : index;
+      regions.add(newFloorRegion);
+    }
+
+    if (floorRegion.endOffset > removedRegion.endOffset) {
+      Region newCeilingRegion = new Region(removedRegion.endOffset + 1, floorRegion.endOffset);
+      newCeilingRegion.endOffsetIndex = floorRegion.endOffsetIndex;
+      regions.add(newCeilingRegion);
+    }
+  }
+
+  @Override
+  public void onSpanTouched(Cache cache, CacheSpan oldSpan, CacheSpan newSpan) {
+    // Do nothing.
+  }
+
+  private void mergeSpan(CacheSpan span) {
+    Region newRegion = new Region(span.position, span.position + span.length);
+    Region floorRegion = regions.floor(newRegion);
+    Region ceilingRegion = regions.ceiling(newRegion);
+    boolean floorConnects = regionsConnect(floorRegion, newRegion);
+    boolean ceilingConnects = regionsConnect(newRegion, ceilingRegion);
+
+    if (ceilingConnects) {
+      if (floorConnects) {
+        // Extend floorRegion to cover both newRegion and ceilingRegion.
+        floorRegion.endOffset = ceilingRegion.endOffset;
+        floorRegion.endOffsetIndex = ceilingRegion.endOffsetIndex;
+      } else {
+        // Extend newRegion to cover ceilingRegion. Add it.
+        newRegion.endOffset = ceilingRegion.endOffset;
+        newRegion.endOffsetIndex = ceilingRegion.endOffsetIndex;
+        regions.add(newRegion);
+      }
+      regions.remove(ceilingRegion);
+    } else if (floorConnects) {
+      // Extend floorRegion to the right to cover newRegion.
+      floorRegion.endOffset = newRegion.endOffset;
+      int index = floorRegion.endOffsetIndex;
+      while (index < chunkIndex.length - 1
+          && (chunkIndex.offsets[index + 1] <= floorRegion.endOffset)) {
+        index++;
+      }
+      floorRegion.endOffsetIndex = index;
+    } else {
+      // This is a new region.
+      int index = Arrays.binarySearch(chunkIndex.offsets, newRegion.endOffset);
+      newRegion.endOffsetIndex = index < 0 ? -index - 2 : index;
+      regions.add(newRegion);
+    }
+  }
+
+  private boolean regionsConnect(Region lower, Region upper) {
+    return lower != null && upper != null && lower.endOffset == upper.startOffset;
+  }
+
+  private static class Region implements Comparable<Region> {
+
+    /**
+     * The first byte of the region (inclusive).
+     */
+    public long startOffset;
+    /**
+     * End offset of the region (exclusive).
+     */
+    public long endOffset;
+    /**
+     * The index in chunkIndex that contains the end offset. May be -1 if the end offset comes
+     * before the start of the first media chunk (i.e. if the end offset is within the stream
+     * header).
+     */
+    public int endOffsetIndex;
+
+    public Region(long position, long endOffset) {
+      this.startOffset = position;
+      this.endOffset = endOffset;
+    }
+
+    @Override
+    public int compareTo(Region another) {
+      return startOffset < another.startOffset ? -1
+          : startOffset == another.startOffset ? 0 : 1;
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSink.java b/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSink.java
new file mode 100644
index 0000000000..ccf9a5b3f5
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSink.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.crypto;
+
+import com.google.android.exoplayer2.upstream.DataSink;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import java.io.IOException;
+import javax.crypto.Cipher;
+
+/**
+ * A wrapping {@link DataSink} that encrypts the data being consumed.
+ */
+public final class AesCipherDataSink implements DataSink {
+
+  private final DataSink wrappedDataSink;
+  private final byte[] secretKey;
+  private final byte[] scratch;
+
+  private AesFlushingCipher cipher;
+
+  /**
+   * Create an instance whose {@code write} methods have the side effect of overwriting the input
+   * {@code data}. Use this constructor for maximum efficiency in the case that there is no
+   * requirement for the input data arrays to remain unchanged.
+   *
+   * @param secretKey The key data.
+   * @param wrappedDataSink The wrapped {@link DataSink}.
+   */
+  public AesCipherDataSink(byte[] secretKey, DataSink wrappedDataSink) {
+    this(secretKey, wrappedDataSink, null);
+  }
+
+  /**
+   * Create an instance whose {@code write} methods are free of side effects. Use this constructor
+   * when the input data arrays are required to remain unchanged.
+   *
+   * @param secretKey The key data.
+   * @param wrappedDataSink The wrapped {@link DataSink}.
+   * @param scratch Scratch space. Data is decrypted into this array before being written to the
+   *     wrapped {@link DataSink}. It should be of appropriate size for the expected writes. If a
+   *     write is larger than the size of this array the write will still succeed, but multiple
+   *     cipher calls will be required to complete the operation.
+   */
+  public AesCipherDataSink(byte[] secretKey, DataSink wrappedDataSink, byte[] scratch) {
+    this.wrappedDataSink = wrappedDataSink;
+    this.secretKey = secretKey;
+    this.scratch = scratch;
+  }
+
+  @Override
+  public void open(DataSpec dataSpec) throws IOException {
+    wrappedDataSink.open(dataSpec);
+    long nonce = CryptoUtil.getFNV64Hash(dataSpec.key);
+    cipher = new AesFlushingCipher(Cipher.ENCRYPT_MODE, secretKey, nonce,
+        dataSpec.absoluteStreamPosition);
+  }
+
+  @Override
+  public void write(byte[] data, int offset, int length) throws IOException {
+    if (scratch == null) {
+      // In-place mode. Writes over the input data.
+      cipher.updateInPlace(data, offset, length);
+      wrappedDataSink.write(data, offset, length);
+    } else {
+      // Use scratch space. The original data remains intact.
+      int bytesProcessed = 0;
+      while (bytesProcessed < length) {
+        int bytesToProcess = Math.min(length - bytesProcessed, scratch.length);
+        cipher.update(data, offset + bytesProcessed, bytesToProcess, scratch, 0);
+        wrappedDataSink.write(scratch, 0, bytesToProcess);
+        bytesProcessed += bytesToProcess;
+      }
+    }
+  }
+
+  @Override
+  public void close() throws IOException {
+    cipher = null;
+    wrappedDataSink.close();
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSource.java
new file mode 100644
index 0000000000..26ac3b38fa
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSource.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.crypto;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import java.io.IOException;
+import javax.crypto.Cipher;
+
+/**
+ * A {@link DataSource} that decrypts the data read from an upstream source.
+ */
+public final class AesCipherDataSource implements DataSource {
+
+  private final DataSource upstream;
+  private final byte[] secretKey;
+
+  private AesFlushingCipher cipher;
+
+  public AesCipherDataSource(byte[] secretKey, DataSource upstream) {
+    this.upstream = upstream;
+    this.secretKey = secretKey;
+  }
+
+  @Override
+  public long open(DataSpec dataSpec) throws IOException {
+    long dataLength = upstream.open(dataSpec);
+    long nonce = CryptoUtil.getFNV64Hash(dataSpec.key);
+    cipher = new AesFlushingCipher(Cipher.DECRYPT_MODE, secretKey, nonce,
+        dataSpec.absoluteStreamPosition);
+    return dataLength;
+  }
+
+  @Override
+  public int read(byte[] data, int offset, int readLength) throws IOException {
+    if (readLength == 0) {
+      return 0;
+    }
+    int read = upstream.read(data, offset, readLength);
+    if (read == C.RESULT_END_OF_INPUT) {
+      return C.RESULT_END_OF_INPUT;
+    }
+    cipher.updateInPlace(data, offset, read);
+    return read;
+  }
+
+  @Override
+  public void close() throws IOException {
+    cipher = null;
+    upstream.close();
+  }
+
+  @Override
+  public Uri getUri() {
+    return upstream.getUri();
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipher.java b/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipher.java
new file mode 100644
index 0000000000..e093eb3064
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipher.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.crypto;
+
+import com.google.android.exoplayer2.util.Assertions;
+import java.nio.ByteBuffer;
+import java.security.InvalidAlgorithmParameterException;
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+import javax.crypto.Cipher;
+import javax.crypto.NoSuchPaddingException;
+import javax.crypto.ShortBufferException;
+import javax.crypto.spec.IvParameterSpec;
+import javax.crypto.spec.SecretKeySpec;
+
+/**
+ * A flushing variant of a AES/CTR/NoPadding {@link Cipher}.
+ *
+ * Unlike a regular {@link Cipher}, the update methods of this class are guaranteed to process all
+ * of the bytes input (and hence output the same number of bytes).
+ */
+public final class AesFlushingCipher {
+
+  private final Cipher cipher;
+  private final int blockSize;
+  private final byte[] zerosBlock;
+  private final byte[] flushedBlock;
+
+  private int pendingXorBytes;
+
+  public AesFlushingCipher(int mode, byte[] secretKey, long nonce, long offset) {
+    try {
+      cipher = Cipher.getInstance("AES/CTR/NoPadding");
+      blockSize = cipher.getBlockSize();
+      zerosBlock = new byte[blockSize];
+      flushedBlock = new byte[blockSize];
+      long counter = offset / blockSize;
+      int startPadding = (int) (offset % blockSize);
+      cipher.init(mode, new SecretKeySpec(secretKey, cipher.getAlgorithm().split("/")[0]),
+          new IvParameterSpec(getInitializationVector(nonce, counter)));
+      if (startPadding != 0) {
+        updateInPlace(new byte[startPadding], 0, startPadding);
+      }
+    } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException
+        | InvalidAlgorithmParameterException e) {
+      // Should never happen.
+      throw new RuntimeException(e);
+    }
+  }
+
+  public void updateInPlace(byte[] data, int offset, int length) {
+    update(data, offset, length, data, offset);
+  }
+
+  public void update(byte[] in, int inOffset, int length, byte[] out, int outOffset) {
+    // If we previously flushed the cipher by inputting zeros up to a block boundary, then we need
+    // to manually transform the data that actually ended the block. See the comment below for more
+    // details.
+    while (pendingXorBytes > 0) {
+      out[outOffset] = (byte) (in[inOffset] ^ flushedBlock[blockSize - pendingXorBytes]);
+      outOffset++;
+      inOffset++;
+      pendingXorBytes--;
+      length--;
+      if (length == 0) {
+        return;
+      }
+    }
+
+    // Do the bulk of the update.
+    int written = nonFlushingUpdate(in, inOffset, length, out, outOffset);
+    if (length == written) {
+      return;
+    }
+
+    // We need to finish the block to flush out the remaining bytes. We do so by inputting zeros,
+    // so that the corresponding bytes output by the cipher are those that would have been XORed
+    // against the real end-of-block data to transform it. We store these bytes so that we can
+    // perform the transformation manually in the case of a subsequent call to this method with
+    // the real data.
+    int bytesToFlush = length - written;
+    Assertions.checkState(bytesToFlush < blockSize);
+    outOffset += written;
+    pendingXorBytes = blockSize - bytesToFlush;
+    written = nonFlushingUpdate(zerosBlock, 0, pendingXorBytes, flushedBlock, 0);
+    Assertions.checkState(written == blockSize);
+    // The first part of xorBytes contains the flushed data, which we copy out. The remainder
+    // contains the bytes that will be needed for manual transformation in a subsequent call.
+    for (int i = 0; i < bytesToFlush; i++) {
+      out[outOffset++] = flushedBlock[i];
+    }
+  }
+
+  private int nonFlushingUpdate(byte[] in, int inOffset, int length, byte[] out, int outOffset) {
+    try {
+      return cipher.update(in, inOffset, length, out, outOffset);
+    } catch (ShortBufferException e) {
+      // Should never happen.
+      throw new RuntimeException(e);
+    }
+  }
+
+  private byte[] getInitializationVector(long nonce, long counter) {
+    return ByteBuffer.allocate(16).putLong(nonce).putLong(counter).array();
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/CryptoUtil.java b/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/CryptoUtil.java
new file mode 100644
index 0000000000..ff8841fa9c
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/CryptoUtil.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.crypto;
+
+/**
+ * Utility functions for the crypto package.
+ */
+/* package */ final class CryptoUtil {
+
+  private CryptoUtil() {}
+
+  /**
+   * Returns the hash value of the input as a long using the 64 bit FNV-1a hash function. The hash
+   * values produced by this function are less likely to collide than those produced by
+   * {@link #hashCode()}.
+   */
+  public static long getFNV64Hash(String input) {
+    if (input == null) {
+      return 0;
+    }
+
+    long hash = 0;
+    for (int i = 0; i < input.length(); i++) {
+      hash ^= input.charAt(i);
+      // This is equivalent to hash *= 0x100000001b3 (the FNV magic prime number).
+      hash += (hash << 1) + (hash << 4) + (hash << 5) + (hash << 7) + (hash << 8) + (hash << 40);
+    }
+    return hash;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java b/library/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
index 84e1f42707..69d4229186 100644
--- a/library/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
@@ -60,17 +60,18 @@
   public static final String AUDIO_AMR_NB = BASE_TYPE_AUDIO + "/3gpp";
   public static final String AUDIO_AMR_WB = BASE_TYPE_AUDIO + "/amr-wb";
   public static final String AUDIO_FLAC = BASE_TYPE_AUDIO + "/x-flac";
+  public static final String AUDIO_ALAC = BASE_TYPE_AUDIO + "/alac";
 
   public static final String TEXT_VTT = BASE_TYPE_TEXT + "/vtt";
 
   public static final String APPLICATION_MP4 = BASE_TYPE_APPLICATION + "/mp4";
   public static final String APPLICATION_WEBM = BASE_TYPE_APPLICATION + "/webm";
+  public static final String APPLICATION_M3U8 = BASE_TYPE_APPLICATION + "/x-mpegURL";
   public static final String APPLICATION_ID3 = BASE_TYPE_APPLICATION + "/id3";
   public static final String APPLICATION_CEA608 = BASE_TYPE_APPLICATION + "/cea-608";
   public static final String APPLICATION_CEA708 = BASE_TYPE_APPLICATION + "/cea-708";
   public static final String APPLICATION_SUBRIP = BASE_TYPE_APPLICATION + "/x-subrip";
   public static final String APPLICATION_TTML = BASE_TYPE_APPLICATION + "/ttml+xml";
-  public static final String APPLICATION_M3U8 = BASE_TYPE_APPLICATION + "/x-mpegURL";
   public static final String APPLICATION_TX3G = BASE_TYPE_APPLICATION + "/x-quicktime-tx3g";
   public static final String APPLICATION_MP4VTT = BASE_TYPE_APPLICATION + "/x-mp4-vtt";
   public static final String APPLICATION_MP4CEA608 = BASE_TYPE_APPLICATION + "/x-mp4-cea-608";
@@ -79,6 +80,7 @@
   public static final String APPLICATION_PGS = BASE_TYPE_APPLICATION + "/pgs";
   public static final String APPLICATION_SCTE35 = BASE_TYPE_APPLICATION + "/x-scte35";
   public static final String APPLICATION_CAMERA_MOTION = BASE_TYPE_APPLICATION + "/x-camera-motion";
+  public static final String APPLICATION_EMSG = BASE_TYPE_APPLICATION + "/x-emsg";
 
   private MimeTypes() {}
 
@@ -216,12 +218,16 @@ public static int getTrackType(String mimeType) {
     } else if (isVideo(mimeType)) {
       return C.TRACK_TYPE_VIDEO;
     } else if (isText(mimeType) || APPLICATION_CEA608.equals(mimeType)
-        || APPLICATION_CEA708.equals(mimeType) || APPLICATION_SUBRIP.equals(mimeType)
-        || APPLICATION_TTML.equals(mimeType) || APPLICATION_TX3G.equals(mimeType)
-        || APPLICATION_MP4VTT.equals(mimeType) || APPLICATION_RAWCC.equals(mimeType)
-        || APPLICATION_VOBSUB.equals(mimeType) || APPLICATION_PGS.equals(mimeType)) {
+        || APPLICATION_CEA708.equals(mimeType) || APPLICATION_MP4CEA608.equals(mimeType)
+        || APPLICATION_SUBRIP.equals(mimeType) || APPLICATION_TTML.equals(mimeType)
+        || APPLICATION_TX3G.equals(mimeType) || APPLICATION_MP4VTT.equals(mimeType)
+        || APPLICATION_RAWCC.equals(mimeType) || APPLICATION_VOBSUB.equals(mimeType)
+        || APPLICATION_PGS.equals(mimeType)) {
       return C.TRACK_TYPE_TEXT;
-    } else if (APPLICATION_ID3.equals(mimeType)) {
+    } else if (APPLICATION_ID3.equals(mimeType)
+        || APPLICATION_EMSG.equals(mimeType)
+        || APPLICATION_SCTE35.equals(mimeType)
+        || APPLICATION_CAMERA_MOTION.equals(mimeType)) {
       return C.TRACK_TYPE_METADATA;
     } else {
       return C.TRACK_TYPE_UNKNOWN;
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java b/library/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java
index b8d635a053..ef4aa05cfe 100644
--- a/library/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java
@@ -424,11 +424,24 @@ public String readString(int length) {
   }
 
   /**
-   * Reads the next {@code length} bytes as UTF-8 characters. A terminating NUL byte is ignored,
+   * Reads the next {@code length} bytes as characters in the specified {@link Charset}.
+   *
+   * @param length The number of bytes to read.
+   * @param charset The character set of the encoded characters.
+   * @return The string encoded by the bytes in the specified character set.
+   */
+  public String readString(int length, Charset charset) {
+    String result = new String(data, position, length, charset);
+    position += length;
+    return result;
+  }
+
+  /**
+   * Reads the next {@code length} bytes as UTF-8 characters. A terminating NUL byte is discarded,
    * if present.
    *
    * @param length The number of bytes to read.
-   * @return The string encoded by the bytes.
+   * @return The string, not including any terminating NUL byte.
    */
   public String readNullTerminatedString(int length) {
     if (length == 0) {
@@ -439,22 +452,31 @@ public String readNullTerminatedString(int length) {
     if (lastIndex < limit && data[lastIndex] == 0) {
       stringLength--;
     }
-    String result = new String(data, position, stringLength, Charset.defaultCharset());
+    String result = new String(data, position, stringLength);
     position += length;
     return result;
   }
 
   /**
-   * Reads the next {@code length} bytes as characters in the specified {@link Charset}.
+   * Reads up to the next NUL byte (or the limit) as UTF-8 characters.
    *
-   * @param length The number of bytes to read.
-   * @param charset The character set of the encoded characters.
-   * @return The string encoded by the bytes in the specified character set.
+   * @return The string not including any terminating NUL byte, or null if the end of the data has
+   *     already been reached.
    */
-  public String readString(int length, Charset charset) {
-    String result = new String(data, position, length, charset);
-    position += length;
-    return result;
+  public String readNullTerminatedString() {
+    if (bytesLeft() == 0) {
+      return null;
+    }
+    int stringLimit = position;
+    while (stringLimit < limit && data[stringLimit] != 0) {
+      stringLimit++;
+    }
+    String string = new String(data, position, stringLimit - position);
+    position = stringLimit;
+    if (position < limit) {
+      position++;
+    }
+    return string;
   }
 
   /**
@@ -464,15 +486,15 @@ public String readString(int length, Charset charset) {
    * ('\n'), or a carriage return followed immediately by a line feed ('\r\n'). The system's default
    * charset (UTF-8) is used.
    *
-   * @return A String containing the contents of the line, not including any line-termination
-   *     characters, or null if the end of the stream has been reached.
+   * @return The line not including any line-termination characters, or null if the end of the data
+   *     has already been reached.
    */
   public String readLine() {
     if (bytesLeft() == 0) {
       return null;
     }
     int lineLimit = position;
-    while (lineLimit < limit && data[lineLimit] != '\n' && data[lineLimit] != '\r') {
+    while (lineLimit < limit && !Util.isLinebreak(data[lineLimit])) {
       lineLimit++;
     }
     if (lineLimit - position >= 3 && data[position] == (byte) 0xEF
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStream.java b/library/src/main/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStream.java
index a3d1d4d02e..1db3d2c1f4 100644
--- a/library/src/main/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStream.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStream.java
@@ -67,6 +67,7 @@ public void close() throws IOException {
   public void reset(OutputStream out) {
     Assertions.checkState(closed);
     this.out = out;
+    count = 0;
     closed = false;
   }
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/SlidingPercentile.java b/library/src/main/java/com/google/android/exoplayer2/util/SlidingPercentile.java
index 8b1af1f0c8..c43b1929cb 100644
--- a/library/src/main/java/com/google/android/exoplayer2/util/SlidingPercentile.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/SlidingPercentile.java
@@ -32,7 +32,7 @@
  * @see <a href="http://en.wikipedia.org/wiki/Moving_average">Wiki: Moving average</a>
  * @see <a href="http://en.wikipedia.org/wiki/Selection_algorithm">Wiki: Selection algorithm</a>
  */
-public final class SlidingPercentile {
+public class SlidingPercentile {
 
   // Orderings.
   private static final Comparator<Sample> INDEX_COMPARATOR = new Comparator<Sample>() {
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/TimestampAdjuster.java b/library/src/main/java/com/google/android/exoplayer2/util/TimestampAdjuster.java
similarity index 75%
rename from library/src/main/java/com/google/android/exoplayer2/extractor/TimestampAdjuster.java
rename to library/src/main/java/com/google/android/exoplayer2/util/TimestampAdjuster.java
index 4de4b38897..19c500202b 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/TimestampAdjuster.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/TimestampAdjuster.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer2.extractor;
+package com.google.android.exoplayer2.util;
 
 import com.google.android.exoplayer2.C;
 
@@ -51,6 +51,34 @@ public TimestampAdjuster(long firstSampleTimestampUs) {
     lastSampleTimestamp = C.TIME_UNSET;
   }
 
+  /**
+   * Returns the last adjusted timestamp. If no timestamp has been adjusted, returns
+   * {@code firstSampleTimestampUs} as provided to the constructor. If this value is
+   * {@link #DO_NOT_OFFSET}, returns {@link C#TIME_UNSET}.
+   *
+   * @return The last adjusted timestamp. If not present, {@code firstSampleTimestampUs} is
+   *     returned unless equal to {@link #DO_NOT_OFFSET}, in which case {@link C#TIME_UNSET} is
+   *     returned.
+   */
+  public long getLastAdjustedTimestampUs() {
+    return lastSampleTimestamp != C.TIME_UNSET ? lastSampleTimestamp
+        : firstSampleTimestampUs != DO_NOT_OFFSET ? firstSampleTimestampUs : C.TIME_UNSET;
+  }
+
+  /**
+   * Returns the offset between the input of {@link #adjustSampleTimestamp(long)} and its output.
+   * If {@link #DO_NOT_OFFSET} was provided to the constructor, 0 is returned. If the timestamp
+   * adjuster is yet not initialized, {@link C#TIME_UNSET} is returned.
+   *
+   * @return The offset between {@link #adjustSampleTimestamp(long)}'s input and output.
+   *     {@link C#TIME_UNSET} if the adjuster is not yet initialized and 0 if timestamps should not
+   *     be offset.
+   */
+  public long getTimestampOffsetUs() {
+    return firstSampleTimestampUs == DO_NOT_OFFSET ? 0
+        : lastSampleTimestamp == C.TIME_UNSET ? C.TIME_UNSET : timestampOffsetUs;
+  }
+
   /**
    * Resets the instance to its initial state.
    */
@@ -65,6 +93,9 @@ public void reset() {
    * @return The adjusted timestamp in microseconds.
    */
   public long adjustTsTimestamp(long pts) {
+    if (pts == C.TIME_UNSET) {
+      return C.TIME_UNSET;
+    }
     if (lastSampleTimestamp != C.TIME_UNSET) {
       // The wrap count for the current PTS may be closestWrapCount or (closestWrapCount - 1),
       // and we need to snap to the one closest to lastSampleTimestamp.
@@ -85,6 +116,9 @@ public long adjustTsTimestamp(long pts) {
    * @return The adjusted timestamp in microseconds.
    */
   public long adjustSampleTimestamp(long timeUs) {
+    if (timeUs == C.TIME_UNSET) {
+      return C.TIME_UNSET;
+    }
     // Record the adjusted PTS to adjust for wraparound next time.
     if (lastSampleTimestamp != C.TIME_UNSET) {
       lastSampleTimestamp = timeUs;
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/Util.java b/library/src/main/java/com/google/android/exoplayer2/util/Util.java
index 4477de7abb..e854c05165 100644
--- a/library/src/main/java/com/google/android/exoplayer2/util/Util.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/Util.java
@@ -254,6 +254,16 @@ public static String normalizeLanguageCode(String language) {
     return value.getBytes(Charset.defaultCharset()); // UTF-8 is the default on Android.
   }
 
+  /**
+   * Returns whether the given character is a carriage return ('\r') or a line feed ('\n').
+   *
+   * @param c The character.
+   * @return Whether the given character is a linebreak.
+   */
+  public static boolean isLinebreak(int c) {
+    return c == '\n' || c == '\r';
+  }
+
   /**
    * Converts text to lower case using {@link Locale#US}.
    *
diff --git a/library/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/library/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index 2a13953106..280f004211 100644
--- a/library/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -18,7 +18,9 @@
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.content.Context;
+import android.graphics.Point;
 import android.media.MediaCodec;
+import android.media.MediaCodecInfo.CodecCapabilities;
 import android.media.MediaCrypto;
 import android.media.MediaFormat;
 import android.os.Handler;
@@ -28,6 +30,7 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
@@ -54,6 +57,10 @@
   private static final String KEY_CROP_BOTTOM = "crop-bottom";
   private static final String KEY_CROP_TOP = "crop-top";
 
+  // Long edge length in pixels for standard video formats, in decreasing in order.
+  private static final int[] STANDARD_LONG_EDGE_VIDEO_PX = new int[] {
+      1920, 1600, 1440, 1280, 960, 854, 640, 540, 480};
+
   private final VideoFrameReleaseTimeHelper frameReleaseTimeHelper;
   private final EventDispatcher eventDispatcher;
   private final long allowedJoiningTimeMs;
@@ -83,6 +90,10 @@
   private int lastReportedUnappliedRotationDegrees;
   private float lastReportedPixelWidthHeightRatio;
 
+  private boolean tunneling;
+  private int tunnelingAudioSessionId;
+  /* package */ OnFrameRenderedListenerV23 tunnelingOnFrameRenderedListener;
+
   /**
    * @param context A context.
    * @param mediaCodecSelector A decoder selector.
@@ -172,7 +183,7 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector, Format forma
       }
     }
     MediaCodecInfo decoderInfo = mediaCodecSelector.getDecoderInfo(mimeType,
-        requiresSecureDecryption, false);
+        requiresSecureDecryption);
     if (decoderInfo == null) {
       return FORMAT_UNSUPPORTED_SUBTYPE;
     }
@@ -180,12 +191,8 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector, Format forma
     boolean decoderCapable = decoderInfo.isCodecSupported(format.codecs);
     if (decoderCapable && format.width > 0 && format.height > 0) {
       if (Util.SDK_INT >= 21) {
-        if (format.frameRate > 0) {
-          decoderCapable = decoderInfo.isVideoSizeAndRateSupportedV21(format.width, format.height,
-              format.frameRate);
-        } else {
-          decoderCapable = decoderInfo.isVideoSizeSupportedV21(format.width, format.height);
-        }
+        decoderCapable = decoderInfo.isVideoSizeAndRateSupportedV21(format.width, format.height,
+            format.frameRate);
       } else {
         decoderCapable = format.width * format.height <= MediaCodecUtil.maxH264DecodableFrameSize();
         if (!decoderCapable) {
@@ -196,13 +203,16 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector, Format forma
     }
 
     int adaptiveSupport = decoderInfo.adaptive ? ADAPTIVE_SEAMLESS : ADAPTIVE_NOT_SEAMLESS;
+    int tunnelingSupport = decoderInfo.tunneling ? TUNNELING_SUPPORTED : TUNNELING_NOT_SUPPORTED;
     int formatSupport = decoderCapable ? FORMAT_HANDLED : FORMAT_EXCEEDS_CAPABILITIES;
-    return adaptiveSupport | formatSupport;
+    return adaptiveSupport | tunnelingSupport | formatSupport;
   }
 
   @Override
   protected void onEnabled(boolean joining) throws ExoPlaybackException {
     super.onEnabled(joining);
+    tunnelingAudioSessionId = getConfiguration().tunnelingAudioSessionId;
+    tunneling = tunnelingAudioSessionId != C.AUDIO_SESSION_ID_UNSET;
     eventDispatcher.enabled(decoderCounters);
     frameReleaseTimeHelper.enable();
   }
@@ -216,7 +226,7 @@ protected void onStreamChanged(Format[] formats) throws ExoPlaybackException {
   @Override
   protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {
     super.onPositionReset(positionUs, joining);
-    renderedFirstFrame = false;
+    clearRenderedFirstFrame();
     consecutiveDroppedFrameCount = 0;
     joiningDeadlineMs = joining && allowedJoiningTimeMs > 0
         ? (SystemClock.elapsedRealtime() + allowedJoiningTimeMs) : C.TIME_UNSET;
@@ -263,6 +273,7 @@ protected void onDisabled() {
     pendingPixelWidthHeightRatio = Format.NO_VALUE;
     clearLastReportedVideoSize();
     frameReleaseTimeHelper.disable();
+    tunnelingOnFrameRenderedListener = null;
     try {
       super.onDisabled();
     } finally {
@@ -287,11 +298,7 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
   }
 
   private void setSurface(Surface surface) throws ExoPlaybackException {
-    // Clear state so that we always call the event listener with the video size and when a frame
-    // is rendered, even if the surface hasn't changed.
-    renderedFirstFrame = false;
-    clearLastReportedVideoSize();
-    // We only need to actually release and reinitialize the codec if the surface has changed.
+    // We only need to release and reinitialize the codec if the surface has changed.
     if (this.surface != surface) {
       this.surface = surface;
       int state = getState();
@@ -300,6 +307,10 @@ private void setSurface(Surface surface) throws ExoPlaybackException {
         maybeInitCodec();
       }
     }
+    // Clear state so that we always call the event listener with the video size and when a frame
+    // is rendered, even if the surface hasn't changed.
+    clearRenderedFirstFrame();
+    clearLastReportedVideoSize();
   }
 
   @Override
@@ -308,10 +319,15 @@ protected boolean shouldInitCodec() {
   }
 
   @Override
-  protected void configureCodec(MediaCodec codec, Format format, MediaCrypto crypto) {
-    codecMaxValues = getCodecMaxValues(format, streamFormats);
-    MediaFormat mediaFormat = getMediaFormat(format, codecMaxValues, deviceNeedsAutoFrcWorkaround);
+  protected void configureCodec(MediaCodecInfo codecInfo, MediaCodec codec, Format format,
+      MediaCrypto crypto) throws DecoderQueryException {
+    codecMaxValues = getCodecMaxValues(codecInfo, format, streamFormats);
+    MediaFormat mediaFormat = getMediaFormat(format, codecMaxValues, deviceNeedsAutoFrcWorkaround,
+        tunnelingAudioSessionId);
     codec.configure(mediaFormat, surface, crypto, 0);
+    if (Util.SDK_INT >= 23 && tunneling) {
+      tunnelingOnFrameRenderedListener = new OnFrameRenderedListenerV23(codec);
+    }
   }
 
   @Override
@@ -328,6 +344,13 @@ protected void onInputFormatChanged(Format newFormat) throws ExoPlaybackExceptio
     pendingRotationDegrees = getRotationDegrees(newFormat);
   }
 
+  @Override
+  protected void onQueueInputBuffer(DecoderInputBuffer buffer) {
+    if (Util.SDK_INT < 23 && tunneling) {
+      maybeNotifyRenderedFirstFrame();
+    }
+  }
+
   @Override
   protected void onOutputFormatChanged(MediaCodec codec, android.media.MediaFormat outputFormat) {
     boolean hasCrop = outputFormat.containsKey(KEY_CROP_RIGHT)
@@ -403,7 +426,7 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
         bufferPresentationTimeUs, unadjustedFrameReleaseTimeNs);
     earlyUs = (adjustedReleaseTimeNs - systemTimeNs) / 1000;
 
-    if (earlyUs < -30000) {
+    if (shouldDropOutputBuffer(earlyUs, elapsedRealtimeUs)) {
       // We're more than 30ms late rendering the frame.
       dropOutputBuffer(codec, bufferIndex);
       return true;
@@ -437,6 +460,19 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
     return false;
   }
 
+  /**
+   * Returns whether the buffer being processed should be dropped.
+   *
+   * @param earlyUs The time until the buffer should be presented in microseconds. A negative value
+   *     indicates that the buffer is late.
+   * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
+   *     measured at the start of the current iteration of the rendering loop.
+   */
+  protected boolean shouldDropOutputBuffer(long earlyUs, long elapsedRealtimeUs) {
+    // Drop the frame if we're more than 30ms late rendering the frame.
+    return earlyUs < -30000;
+  }
+
   private void skipOutputBuffer(MediaCodec codec, int bufferIndex) {
     TraceUtil.beginSection("skipVideoBuffer");
     codec.releaseOutputBuffer(bufferIndex, false);
@@ -465,10 +501,7 @@ private void renderOutputBuffer(MediaCodec codec, int bufferIndex) {
     TraceUtil.endSection();
     decoderCounters.renderedOutputBufferCount++;
     consecutiveDroppedFrameCount = 0;
-    if (!renderedFirstFrame) {
-      renderedFirstFrame = true;
-      eventDispatcher.renderedFirstFrame(surface);
-    }
+    maybeNotifyRenderedFirstFrame();
   }
 
   @TargetApi(21)
@@ -479,6 +512,25 @@ private void renderOutputBufferV21(MediaCodec codec, int bufferIndex, long relea
     TraceUtil.endSection();
     decoderCounters.renderedOutputBufferCount++;
     consecutiveDroppedFrameCount = 0;
+    maybeNotifyRenderedFirstFrame();
+  }
+
+  private void clearRenderedFirstFrame() {
+    renderedFirstFrame = false;
+    // The first frame notification is triggered by renderOutputBuffer or renderOutputBufferV21 for
+    // non-tunneled playback, onQueueInputBuffer for tunneled playback prior to API level 23, and
+    // OnFrameRenderedListenerV23.onFrameRenderedListener for tunneled playback on API level 23 and
+    // above.
+    if (Util.SDK_INT >= 23 && tunneling) {
+      MediaCodec codec = getCodec();
+      // If codec is null then the listener will be instantiated in configureCodec.
+      if (codec != null) {
+        tunnelingOnFrameRenderedListener = new OnFrameRenderedListenerV23(codec);
+      }
+    }
+  }
+
+  /* package */ void maybeNotifyRenderedFirstFrame() {
     if (!renderedFirstFrame) {
       renderedFirstFrame = true;
       eventDispatcher.renderedFirstFrame(surface);
@@ -517,7 +569,7 @@ private void maybeNotifyDroppedFrames() {
 
   @SuppressLint("InlinedApi")
   private static MediaFormat getMediaFormat(Format format, CodecMaxValues codecMaxValues,
-      boolean deviceNeedsAutoFrcWorkaround) {
+      boolean deviceNeedsAutoFrcWorkaround, int tunnelingAudioSessionId) {
     MediaFormat frameworkMediaFormat = format.getFrameworkMediaFormatV16();
     // Set the maximum adaptive video dimensions.
     frameworkMediaFormat.setInteger(MediaFormat.KEY_MAX_WIDTH, codecMaxValues.width);
@@ -530,36 +582,109 @@ private static MediaFormat getMediaFormat(Format format, CodecMaxValues codecMax
     if (deviceNeedsAutoFrcWorkaround) {
       frameworkMediaFormat.setInteger("auto-frc", 0);
     }
+    // Configure tunneling if enabled.
+    if (tunnelingAudioSessionId != C.AUDIO_SESSION_ID_UNSET) {
+      configureTunnelingV21(frameworkMediaFormat, tunnelingAudioSessionId);
+    }
     return frameworkMediaFormat;
   }
 
+  @TargetApi(21)
+  private static void configureTunnelingV21(MediaFormat mediaFormat, int tunnelingAudioSessionId) {
+    mediaFormat.setFeatureEnabled(CodecCapabilities.FEATURE_TunneledPlayback, true);
+    mediaFormat.setInteger(MediaFormat.KEY_AUDIO_SESSION_ID, tunnelingAudioSessionId);
+  }
+
   /**
    * Returns {@link CodecMaxValues} suitable for configuring a codec for {@code format} in a way
    * that will allow possible adaptation to other compatible formats in {@code streamFormats}.
    *
+   * @param codecInfo Information about the {@link MediaCodec} being configured.
    * @param format The format for which the codec is being configured.
    * @param streamFormats The possible stream formats.
    * @return Suitable {@link CodecMaxValues}.
+   * @throws DecoderQueryException If an error occurs querying {@code codecInfo}.
    */
-  private static CodecMaxValues getCodecMaxValues(Format format, Format[] streamFormats) {
+  private static CodecMaxValues getCodecMaxValues(MediaCodecInfo codecInfo, Format format,
+      Format[] streamFormats) throws DecoderQueryException {
     int maxWidth = format.width;
     int maxHeight = format.height;
     int maxInputSize = getMaxInputSize(format);
+    if (streamFormats.length == 1) {
+      // The single entry in streamFormats must correspond to the format for which the codec is
+      // being configured.
+      return new CodecMaxValues(maxWidth, maxHeight, maxInputSize);
+    }
+    boolean haveUnknownDimensions = false;
     for (Format streamFormat : streamFormats) {
       if (areAdaptationCompatible(format, streamFormat)) {
+        haveUnknownDimensions |= (streamFormat.width == Format.NO_VALUE
+            || streamFormat.height == Format.NO_VALUE);
         maxWidth = Math.max(maxWidth, streamFormat.width);
         maxHeight = Math.max(maxHeight, streamFormat.height);
         maxInputSize = Math.max(maxInputSize, getMaxInputSize(streamFormat));
       }
     }
+    if (haveUnknownDimensions) {
+      Log.w(TAG, "Resolutions unknown. Codec max resolution: " + maxWidth + "x" + maxHeight);
+      Point codecMaxSize = getCodecMaxSize(codecInfo, format);
+      if (codecMaxSize != null) {
+        maxWidth = Math.max(maxWidth, codecMaxSize.x);
+        maxHeight = Math.max(maxHeight, codecMaxSize.y);
+        maxInputSize = Math.max(maxInputSize,
+            getMaxInputSize(format.sampleMimeType, maxWidth, maxHeight));
+        Log.w(TAG, "Codec max resolution adjusted to: " + maxWidth + "x" + maxHeight);
+      }
+    }
     return new CodecMaxValues(maxWidth, maxHeight, maxInputSize);
   }
 
+  /**
+   * Returns a maximum video size to use when configuring a codec for {@code format} in a way
+   * that will allow possible adaptation to other compatible formats that are expected to have the
+   * same aspect ratio, but whose sizes are unknown.
+   *
+   * @param codecInfo Information about the {@link MediaCodec} being configured.
+   * @param format The format for which the codec is being configured.
+   * @return The maximum video size to use, or null if the size of {@code format} should be used.
+   * @throws DecoderQueryException If an error occurs querying {@code codecInfo}.
+   */
+  private static Point getCodecMaxSize(MediaCodecInfo codecInfo, Format format)
+      throws DecoderQueryException {
+    boolean isVerticalVideo = format.height > format.width;
+    int formatLongEdgePx = isVerticalVideo ? format.height : format.width;
+    int formatShortEdgePx = isVerticalVideo ? format.width : format.height;
+    float aspectRatio = (float) formatShortEdgePx / formatLongEdgePx;
+    for (int longEdgePx : STANDARD_LONG_EDGE_VIDEO_PX) {
+      int shortEdgePx = (int) (longEdgePx * aspectRatio);
+      if (longEdgePx <= formatLongEdgePx || shortEdgePx <= formatShortEdgePx) {
+        // Don't return a size not larger than the format for which the codec is being configured.
+        return null;
+      } else if (Util.SDK_INT >= 21) {
+        Point alignedSize = codecInfo.alignVideoSizeV21(isVerticalVideo ? shortEdgePx : longEdgePx,
+            isVerticalVideo ? longEdgePx : shortEdgePx);
+        float frameRate = format.frameRate;
+        if (codecInfo.isVideoSizeAndRateSupportedV21(alignedSize.x, alignedSize.y, frameRate)) {
+          return alignedSize;
+        }
+      } else {
+        // Conservatively assume the codec requires 16px width and height alignment.
+        longEdgePx = Util.ceilDivide(longEdgePx, 16) * 16;
+        shortEdgePx = Util.ceilDivide(shortEdgePx, 16) * 16;
+        if (longEdgePx * shortEdgePx <= MediaCodecUtil.maxH264DecodableFrameSize()) {
+          return new Point(isVerticalVideo ? shortEdgePx : longEdgePx,
+              isVerticalVideo ? longEdgePx : shortEdgePx);
+        }
+      }
+    }
+    return null;
+  }
+
   /**
    * Returns a maximum input size for a given format.
    *
    * @param format The format.
-   * @return An maximum input size in bytes, or {@link Format#NO_VALUE} if a maximum could not be
+   * @return A maximum input size in bytes, or {@link Format#NO_VALUE} if a maximum could not be
    *     determined.
    */
   private static int getMaxInputSize(Format format) {
@@ -567,8 +692,20 @@ private static int getMaxInputSize(Format format) {
       // The format defines an explicit maximum input size.
       return format.maxInputSize;
     }
+    return getMaxInputSize(format.sampleMimeType, format.width, format.height);
+  }
 
-    if (format.width == Format.NO_VALUE || format.height == Format.NO_VALUE) {
+  /**
+   * Returns a maximum input size for a given mime type, width and height.
+   *
+   * @param sampleMimeType The format mime type.
+   * @param width The width in pixels.
+   * @param height The height in pixels.
+   * @return A maximum input size in bytes, or {@link Format#NO_VALUE} if a maximum could not be
+   *     determined.
+   */
+  private static int getMaxInputSize(String sampleMimeType, int width, int height) {
+    if (width == Format.NO_VALUE || height == Format.NO_VALUE) {
       // We can't infer a maximum input size without video dimensions.
       return Format.NO_VALUE;
     }
@@ -576,10 +713,10 @@ private static int getMaxInputSize(Format format) {
     // Attempt to infer a maximum input size from the format.
     int maxPixels;
     int minCompressionRatio;
-    switch (format.sampleMimeType) {
+    switch (sampleMimeType) {
       case MimeTypes.VIDEO_H263:
       case MimeTypes.VIDEO_MP4V:
-        maxPixels = format.width * format.height;
+        maxPixels = width * height;
         minCompressionRatio = 2;
         break;
       case MimeTypes.VIDEO_H264:
@@ -589,17 +726,17 @@ private static int getMaxInputSize(Format format) {
           return Format.NO_VALUE;
         }
         // Round up width/height to an integer number of macroblocks.
-        maxPixels = ((format.width + 15) / 16) * ((format.height + 15) / 16) * 16 * 16;
+        maxPixels = Util.ceilDivide(width, 16) * Util.ceilDivide(height, 16) * 16 * 16;
         minCompressionRatio = 2;
         break;
       case MimeTypes.VIDEO_VP8:
         // VPX does not specify a ratio so use the values from the platform's SoftVPX.cpp.
-        maxPixels = format.width * format.height;
+        maxPixels = width * height;
         minCompressionRatio = 2;
         break;
       case MimeTypes.VIDEO_H265:
       case MimeTypes.VIDEO_VP9:
-        maxPixels = format.width * format.height;
+        maxPixels = width * height;
         minCompressionRatio = 4;
         break;
       default:
@@ -668,4 +805,22 @@ public CodecMaxValues(int width, int height, int inputSize) {
 
   }
 
+  @TargetApi(23)
+  private final class OnFrameRenderedListenerV23 implements MediaCodec.OnFrameRenderedListener {
+
+    private OnFrameRenderedListenerV23(MediaCodec codec) {
+      codec.setOnFrameRenderedListener(this, new Handler());
+    }
+
+    @Override
+    public void onFrameRendered(MediaCodec codec, long presentationTimeUs, long nanoTime) {
+      if (this != tunnelingOnFrameRenderedListener) {
+        // Stale event.
+        return;
+      }
+      maybeNotifyRenderedFirstFrame();
+    }
+
+  }
+
 }
diff --git a/library/src/main/res/drawable-anydpi-v21/exo_controls_fastforward.xml b/library/src/main/res/drawable-anydpi-v21/exo_controls_fastforward.xml
new file mode 100644
index 0000000000..4b86e109e9
--- /dev/null
+++ b/library/src/main/res/drawable-anydpi-v21/exo_controls_fastforward.xml
@@ -0,0 +1,25 @@
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="32dp"
+    android:height="32dp"
+    android:viewportHeight="24.0"
+    android:viewportWidth="24.0">
+
+  <path
+      android:fillColor="#FFFFFFFF"
+      android:pathData="M4,18l8.5,-6L4,6v12zM13,6v12l8.5,-6L13,6z"/>
+
+</vector>
diff --git a/library/src/main/res/drawable-anydpi-v21/exo_controls_next.xml b/library/src/main/res/drawable-anydpi-v21/exo_controls_next.xml
new file mode 100644
index 0000000000..6305bcbc90
--- /dev/null
+++ b/library/src/main/res/drawable-anydpi-v21/exo_controls_next.xml
@@ -0,0 +1,25 @@
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="32dp"
+    android:height="32dp"
+    android:viewportHeight="24.0"
+    android:viewportWidth="24.0">
+
+  <path
+      android:fillColor="#FFFFFFFF"
+      android:pathData="M6,18l8.5,-6L6,6v12zM16,6v12h2V6h-2z"/>
+
+</vector>
diff --git a/library/src/main/res/drawable-anydpi-v21/exo_controls_pause.xml b/library/src/main/res/drawable-anydpi-v21/exo_controls_pause.xml
new file mode 100644
index 0000000000..45cd68bed6
--- /dev/null
+++ b/library/src/main/res/drawable-anydpi-v21/exo_controls_pause.xml
@@ -0,0 +1,25 @@
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="32dp"
+    android:height="32dp"
+    android:viewportHeight="24.0"
+    android:viewportWidth="24.0">
+
+  <path
+      android:fillColor="#FFFFFFFF"
+      android:pathData="M6,19h4L10,5L6,5v14zM14,5v14h4L18,5h-4z"/>
+
+</vector>
diff --git a/library/src/main/res/drawable-anydpi-v21/exo_controls_play.xml b/library/src/main/res/drawable-anydpi-v21/exo_controls_play.xml
new file mode 100644
index 0000000000..c8c4cdb127
--- /dev/null
+++ b/library/src/main/res/drawable-anydpi-v21/exo_controls_play.xml
@@ -0,0 +1,25 @@
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="32dp"
+    android:height="32dp"
+    android:viewportHeight="24.0"
+    android:viewportWidth="24.0">
+
+  <path
+      android:fillColor="#FFFFFFFF"
+      android:pathData="M8,5v14l11,-7z"/>
+
+</vector>
diff --git a/library/src/main/res/drawable-anydpi-v21/exo_controls_previous.xml b/library/src/main/res/drawable-anydpi-v21/exo_controls_previous.xml
new file mode 100644
index 0000000000..9564a2a350
--- /dev/null
+++ b/library/src/main/res/drawable-anydpi-v21/exo_controls_previous.xml
@@ -0,0 +1,25 @@
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="32dp"
+    android:height="32dp"
+    android:viewportHeight="24.0"
+    android:viewportWidth="24.0">
+
+  <path
+      android:fillColor="#FFFFFFFF"
+      android:pathData="M6,6h2v12L6,18zM9.5,12l8.5,6L18,6z"/>
+
+</vector>
diff --git a/library/src/main/res/drawable-anydpi-v21/exo_controls_rewind.xml b/library/src/main/res/drawable-anydpi-v21/exo_controls_rewind.xml
new file mode 100644
index 0000000000..976b706170
--- /dev/null
+++ b/library/src/main/res/drawable-anydpi-v21/exo_controls_rewind.xml
@@ -0,0 +1,25 @@
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="32dp"
+    android:height="32dp"
+    android:viewportHeight="24.0"
+    android:viewportWidth="24.0">
+
+  <path
+      android:fillColor="#FFFFFFFF"
+      android:pathData="M11,18L11,6l-8.5,6 8.5,6zM11.5,12l8.5,6L20,6l-8.5,6z"/>
+
+</vector>
diff --git a/library/src/main/res/drawable-hdpi/exo_controls_fastforward.png b/library/src/main/res/drawable-hdpi/exo_controls_fastforward.png
index c65956ab7f..843df84091 100644
Binary files a/library/src/main/res/drawable-hdpi/exo_controls_fastforward.png and b/library/src/main/res/drawable-hdpi/exo_controls_fastforward.png differ
diff --git a/library/src/main/res/drawable-hdpi/exo_controls_next.png b/library/src/main/res/drawable-hdpi/exo_controls_next.png
index 6e27b8161e..c37541472e 100644
Binary files a/library/src/main/res/drawable-hdpi/exo_controls_next.png and b/library/src/main/res/drawable-hdpi/exo_controls_next.png differ
diff --git a/library/src/main/res/drawable-hdpi/exo_controls_pause.png b/library/src/main/res/drawable-hdpi/exo_controls_pause.png
index 1d465a41e4..0a23452746 100644
Binary files a/library/src/main/res/drawable-hdpi/exo_controls_pause.png and b/library/src/main/res/drawable-hdpi/exo_controls_pause.png differ
diff --git a/library/src/main/res/drawable-hdpi/exo_controls_play.png b/library/src/main/res/drawable-hdpi/exo_controls_play.png
index 2746d17fb1..e98e2b9cbe 100644
Binary files a/library/src/main/res/drawable-hdpi/exo_controls_play.png and b/library/src/main/res/drawable-hdpi/exo_controls_play.png differ
diff --git a/library/src/main/res/drawable-hdpi/exo_controls_previous.png b/library/src/main/res/drawable-hdpi/exo_controls_previous.png
index 85b3766904..3eae5c883b 100644
Binary files a/library/src/main/res/drawable-hdpi/exo_controls_previous.png and b/library/src/main/res/drawable-hdpi/exo_controls_previous.png differ
diff --git a/library/src/main/res/drawable-hdpi/exo_controls_rewind.png b/library/src/main/res/drawable-hdpi/exo_controls_rewind.png
index a4ac181777..36537d3b73 100644
Binary files a/library/src/main/res/drawable-hdpi/exo_controls_rewind.png and b/library/src/main/res/drawable-hdpi/exo_controls_rewind.png differ
diff --git a/library/src/main/res/drawable-ldpi/exo_controls_fastforward.png b/library/src/main/res/drawable-ldpi/exo_controls_fastforward.png
index 1b4d9dbef9..19b9e6015c 100644
Binary files a/library/src/main/res/drawable-ldpi/exo_controls_fastforward.png and b/library/src/main/res/drawable-ldpi/exo_controls_fastforward.png differ
diff --git a/library/src/main/res/drawable-ldpi/exo_controls_next.png b/library/src/main/res/drawable-ldpi/exo_controls_next.png
index 99927fd27b..d4872037aa 100644
Binary files a/library/src/main/res/drawable-ldpi/exo_controls_next.png and b/library/src/main/res/drawable-ldpi/exo_controls_next.png differ
diff --git a/library/src/main/res/drawable-ldpi/exo_controls_pause.png b/library/src/main/res/drawable-ldpi/exo_controls_pause.png
index 3b98d66688..616ec42f39 100644
Binary files a/library/src/main/res/drawable-ldpi/exo_controls_pause.png and b/library/src/main/res/drawable-ldpi/exo_controls_pause.png differ
diff --git a/library/src/main/res/drawable-ldpi/exo_controls_play.png b/library/src/main/res/drawable-ldpi/exo_controls_play.png
index e7c19724bb..5d1c702892 100644
Binary files a/library/src/main/res/drawable-ldpi/exo_controls_play.png and b/library/src/main/res/drawable-ldpi/exo_controls_play.png differ
diff --git a/library/src/main/res/drawable-ldpi/exo_controls_previous.png b/library/src/main/res/drawable-ldpi/exo_controls_previous.png
index df043228d0..930534d312 100644
Binary files a/library/src/main/res/drawable-ldpi/exo_controls_previous.png and b/library/src/main/res/drawable-ldpi/exo_controls_previous.png differ
diff --git a/library/src/main/res/drawable-ldpi/exo_controls_rewind.png b/library/src/main/res/drawable-ldpi/exo_controls_rewind.png
index 28843f9fb0..83d71782f6 100644
Binary files a/library/src/main/res/drawable-ldpi/exo_controls_rewind.png and b/library/src/main/res/drawable-ldpi/exo_controls_rewind.png differ
diff --git a/library/src/main/res/drawable-mdpi/exo_controls_fastforward.png b/library/src/main/res/drawable-mdpi/exo_controls_fastforward.png
index 170dd2daaa..ee3efe1d69 100644
Binary files a/library/src/main/res/drawable-mdpi/exo_controls_fastforward.png and b/library/src/main/res/drawable-mdpi/exo_controls_fastforward.png differ
diff --git a/library/src/main/res/drawable-mdpi/exo_controls_next.png b/library/src/main/res/drawable-mdpi/exo_controls_next.png
index fcd73d90e7..9d4d7469ed 100644
Binary files a/library/src/main/res/drawable-mdpi/exo_controls_next.png and b/library/src/main/res/drawable-mdpi/exo_controls_next.png differ
diff --git a/library/src/main/res/drawable-mdpi/exo_controls_pause.png b/library/src/main/res/drawable-mdpi/exo_controls_pause.png
index 3e6b2a17b5..f54c942201 100644
Binary files a/library/src/main/res/drawable-mdpi/exo_controls_pause.png and b/library/src/main/res/drawable-mdpi/exo_controls_pause.png differ
diff --git a/library/src/main/res/drawable-mdpi/exo_controls_play.png b/library/src/main/res/drawable-mdpi/exo_controls_play.png
index 7966bbc516..dd0c142859 100644
Binary files a/library/src/main/res/drawable-mdpi/exo_controls_play.png and b/library/src/main/res/drawable-mdpi/exo_controls_play.png differ
diff --git a/library/src/main/res/drawable-mdpi/exo_controls_previous.png b/library/src/main/res/drawable-mdpi/exo_controls_previous.png
index b653d05b9f..950e213d2f 100644
Binary files a/library/src/main/res/drawable-mdpi/exo_controls_previous.png and b/library/src/main/res/drawable-mdpi/exo_controls_previous.png differ
diff --git a/library/src/main/res/drawable-mdpi/exo_controls_rewind.png b/library/src/main/res/drawable-mdpi/exo_controls_rewind.png
index 5489180eb1..e75efae189 100644
Binary files a/library/src/main/res/drawable-mdpi/exo_controls_rewind.png and b/library/src/main/res/drawable-mdpi/exo_controls_rewind.png differ
diff --git a/library/src/main/res/drawable-xhdpi/exo_controls_fastforward.png b/library/src/main/res/drawable-xhdpi/exo_controls_fastforward.png
index 60f7e92181..ead712cfe9 100644
Binary files a/library/src/main/res/drawable-xhdpi/exo_controls_fastforward.png and b/library/src/main/res/drawable-xhdpi/exo_controls_fastforward.png differ
diff --git a/library/src/main/res/drawable-xhdpi/exo_controls_next.png b/library/src/main/res/drawable-xhdpi/exo_controls_next.png
index 4def965cec..bc1ebf83c5 100644
Binary files a/library/src/main/res/drawable-xhdpi/exo_controls_next.png and b/library/src/main/res/drawable-xhdpi/exo_controls_next.png differ
diff --git a/library/src/main/res/drawable-xhdpi/exo_controls_pause.png b/library/src/main/res/drawable-xhdpi/exo_controls_pause.png
index 6bd3d482e1..1c868f1831 100644
Binary files a/library/src/main/res/drawable-xhdpi/exo_controls_pause.png and b/library/src/main/res/drawable-xhdpi/exo_controls_pause.png differ
diff --git a/library/src/main/res/drawable-xhdpi/exo_controls_play.png b/library/src/main/res/drawable-xhdpi/exo_controls_play.png
index ccfef18056..f2f934413e 100644
Binary files a/library/src/main/res/drawable-xhdpi/exo_controls_play.png and b/library/src/main/res/drawable-xhdpi/exo_controls_play.png differ
diff --git a/library/src/main/res/drawable-xhdpi/exo_controls_previous.png b/library/src/main/res/drawable-xhdpi/exo_controls_previous.png
index c4472ae2d9..d197eff873 100644
Binary files a/library/src/main/res/drawable-xhdpi/exo_controls_previous.png and b/library/src/main/res/drawable-xhdpi/exo_controls_previous.png differ
diff --git a/library/src/main/res/drawable-xhdpi/exo_controls_rewind.png b/library/src/main/res/drawable-xhdpi/exo_controls_rewind.png
index 167d10e58b..3340ef9bd2 100644
Binary files a/library/src/main/res/drawable-xhdpi/exo_controls_rewind.png and b/library/src/main/res/drawable-xhdpi/exo_controls_rewind.png differ
diff --git a/library/src/main/res/drawable-xxhdpi/exo_controls_fastforward.png b/library/src/main/res/drawable-xxhdpi/exo_controls_fastforward.png
index ab9e022fbf..e1c6cae292 100644
Binary files a/library/src/main/res/drawable-xxhdpi/exo_controls_fastforward.png and b/library/src/main/res/drawable-xxhdpi/exo_controls_fastforward.png differ
diff --git a/library/src/main/res/drawable-xxhdpi/exo_controls_next.png b/library/src/main/res/drawable-xxhdpi/exo_controls_next.png
index ce0a14325a..232f09e910 100644
Binary files a/library/src/main/res/drawable-xxhdpi/exo_controls_next.png and b/library/src/main/res/drawable-xxhdpi/exo_controls_next.png differ
diff --git a/library/src/main/res/drawable-xxhdpi/exo_controls_pause.png b/library/src/main/res/drawable-xxhdpi/exo_controls_pause.png
index 9a36b17cb8..50a545db4d 100644
Binary files a/library/src/main/res/drawable-xxhdpi/exo_controls_pause.png and b/library/src/main/res/drawable-xxhdpi/exo_controls_pause.png differ
diff --git a/library/src/main/res/drawable-xxhdpi/exo_controls_play.png b/library/src/main/res/drawable-xxhdpi/exo_controls_play.png
index 41f76bbf99..08508c5015 100644
Binary files a/library/src/main/res/drawable-xxhdpi/exo_controls_play.png and b/library/src/main/res/drawable-xxhdpi/exo_controls_play.png differ
diff --git a/library/src/main/res/drawable-xxhdpi/exo_controls_previous.png b/library/src/main/res/drawable-xxhdpi/exo_controls_previous.png
index d4688741b9..f71acc4875 100644
Binary files a/library/src/main/res/drawable-xxhdpi/exo_controls_previous.png and b/library/src/main/res/drawable-xxhdpi/exo_controls_previous.png differ
diff --git a/library/src/main/res/drawable-xxhdpi/exo_controls_rewind.png b/library/src/main/res/drawable-xxhdpi/exo_controls_rewind.png
index 8ebb2ccf30..db0555f9e5 100644
Binary files a/library/src/main/res/drawable-xxhdpi/exo_controls_rewind.png and b/library/src/main/res/drawable-xxhdpi/exo_controls_rewind.png differ
diff --git a/library/src/main/res/values/attrs.xml b/library/src/main/res/values/attrs.xml
index b5c01b4575..c73bfb0a3c 100644
--- a/library/src/main/res/values/attrs.xml
+++ b/library/src/main/res/values/attrs.xml
@@ -37,6 +37,7 @@
 
   <declare-styleable name="SimpleExoPlayerView">
     <attr name="use_artwork" format="boolean"/>
+    <attr name="default_artwork" format="reference"/>
     <attr name="use_controller" format="boolean"/>
     <attr name="surface_type"/>
     <attr name="show_timeout"/>
diff --git a/playbacktests/build.gradle b/playbacktests/build.gradle
index c099e2c86e..c53793b534 100644
--- a/playbacktests/build.gradle
+++ b/playbacktests/build.gradle
@@ -21,17 +21,6 @@ android {
         minSdkVersion 9
         targetSdkVersion project.ext.targetSdkVersion
     }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
-        }
-    }
-
-    lintOptions {
-        abortOnError false
-    }
 }
 
 dependencies {
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTest.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTest.java
index 8c1ee45e0e..5752058c4e 100644
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTest.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTest.java
@@ -17,22 +17,28 @@
 
 import android.annotation.TargetApi;
 import android.media.MediaDrm;
+import android.media.MediaDrm.MediaDrmStateException;
 import android.media.UnsupportedSchemeException;
 import android.net.Uri;
 import android.test.ActivityInstrumentationTestCase2;
 import android.util.Log;
+import android.util.Pair;
 import android.view.Surface;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.DefaultLoadControl;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.RendererCapabilities;
 import com.google.android.exoplayer2.SimpleExoPlayer;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
+import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
+import com.google.android.exoplayer2.drm.DrmSession.DrmSessionException;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
 import com.google.android.exoplayer2.drm.HttpMediaDrmCallback;
-import com.google.android.exoplayer2.drm.StreamingDrmSessionManager;
+import com.google.android.exoplayer2.drm.MediaDrmCallback;
+import com.google.android.exoplayer2.drm.OfflineLicenseHelper;
 import com.google.android.exoplayer2.drm.UnsupportedDrmException;
 import com.google.android.exoplayer2.mediacodec.MediaCodecInfo;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil;
@@ -60,6 +66,7 @@
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -275,7 +282,7 @@ public void testH264Adaptive() throws DecoderQueryException {
     }
     String streamName = "test_h264_adaptive";
     testDashPlayback(getActivity(), streamName, H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false,
-            MimeTypes.VIDEO_H264, ALLOW_ADDITIONAL_VIDEO_FORMATS, H264_CDD_ADAPTIVE);
+        MimeTypes.VIDEO_H264, ALLOW_ADDITIONAL_VIDEO_FORMATS, H264_CDD_ADAPTIVE);
   }
 
   public void testH264AdaptiveWithSeeking() throws DecoderQueryException {
@@ -600,6 +607,121 @@ public void testWidevine29FpsH264Fixed() throws DecoderQueryException {
         WIDEVINE_H264_BASELINE_480P_29FPS_VIDEO_REPRESENTATION_ID);
   }
 
+  // Offline license tests
+
+  public void testWidevineOfflineLicense() throws Exception {
+    if (Util.SDK_INT < 22) {
+      // Pass.
+      return;
+    }
+    String streamName = "test_widevine_h264_fixed_offline";
+    DashHostedTestEncParameters parameters = newDashHostedTestEncParameters(
+        WIDEVINE_H264_MANIFEST_PREFIX, true, MimeTypes.VIDEO_H264);
+    TestOfflineLicenseHelper helper = new TestOfflineLicenseHelper(parameters);
+    try {
+      byte[] keySetId = helper.downloadLicense();
+      testDashPlayback(getActivity(), streamName, null, true, parameters,
+          WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, false, keySetId, WIDEVINE_H264_CDD_FIXED);
+      helper.renewLicense();
+    } finally {
+      helper.releaseResources();
+    }
+  }
+
+  public void testWidevineOfflineReleasedLicense() throws Throwable {
+    if (Util.SDK_INT < 22) {
+      // Pass.
+      return;
+    }
+    String streamName = "test_widevine_h264_fixed_offline";
+    DashHostedTestEncParameters parameters = newDashHostedTestEncParameters(
+        WIDEVINE_H264_MANIFEST_PREFIX, true, MimeTypes.VIDEO_H264);
+    TestOfflineLicenseHelper helper = new TestOfflineLicenseHelper(parameters);
+    try {
+      byte[] keySetId = helper.downloadLicense();
+      helper.releaseLicense(); // keySetId no longer valid.
+      try {
+        testDashPlayback(getActivity(), streamName, null, true, parameters,
+            WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, false, keySetId, WIDEVINE_H264_CDD_FIXED);
+        fail("Playback should fail because the license has been released.");
+      } catch (Throwable e) {
+        // Get the root cause
+        while (true) {
+          Throwable cause = e.getCause();
+          if (cause == null || cause == e) {
+            break;
+          }
+          e = cause;
+        }
+        // It should be a MediaDrmStateException instance
+        if (!(e instanceof MediaDrmStateException)) {
+          throw e;
+        }
+      }
+    } finally {
+      helper.releaseResources();
+    }
+  }
+
+  public void testWidevineOfflineExpiredLicense() throws Exception {
+    if (Util.SDK_INT < 22) {
+      // Pass.
+      return;
+    }
+    String streamName = "test_widevine_h264_fixed_offline";
+    DashHostedTestEncParameters parameters = newDashHostedTestEncParameters(
+        WIDEVINE_H264_MANIFEST_PREFIX, true, MimeTypes.VIDEO_H264);
+    TestOfflineLicenseHelper helper = new TestOfflineLicenseHelper(parameters);
+    try {
+      byte[] keySetId = helper.downloadLicense();
+
+      // Wait until the license expires
+      long licenseDuration = helper.getLicenseDurationRemainingSec().first;
+      assertTrue("License duration should be less than 30 sec. "
+          + "Server settings might have changed.", licenseDuration < 30);
+      while (licenseDuration > 0) {
+        synchronized (this) {
+          wait(licenseDuration * 1000 + 2000);
+        }
+        long previousDuration = licenseDuration;
+        licenseDuration = helper.getLicenseDurationRemainingSec().first;
+        assertTrue("License duration should be decreasing.", previousDuration > licenseDuration);
+      }
+
+      // DefaultDrmSessionManager should renew the license and stream play fine
+      testDashPlayback(getActivity(), streamName, null, true, parameters,
+          WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, false, keySetId, WIDEVINE_H264_CDD_FIXED);
+    } finally {
+      helper.releaseResources();
+    }
+  }
+
+  public void testWidevineOfflineLicenseExpiresOnPause() throws Exception {
+    if (Util.SDK_INT < 22) {
+      // Pass.
+      return;
+    }
+    String streamName = "test_widevine_h264_fixed_offline";
+    DashHostedTestEncParameters parameters = newDashHostedTestEncParameters(
+        WIDEVINE_H264_MANIFEST_PREFIX, true, MimeTypes.VIDEO_H264);
+    TestOfflineLicenseHelper helper = new TestOfflineLicenseHelper(parameters);
+    try {
+      byte[] keySetId = helper.downloadLicense();
+      // During playback pause until the license expires then continue playback
+      Pair<Long, Long> licenseDurationRemainingSec = helper.getLicenseDurationRemainingSec();
+      long licenseDuration = licenseDurationRemainingSec.first;
+      assertTrue("License duration should be less than 30 sec. "
+          + "Server settings might have changed.", licenseDuration < 30);
+      ActionSchedule schedule = new ActionSchedule.Builder(TAG)
+          .delay(3000).pause().delay(licenseDuration * 1000 + 2000).play().build();
+      // DefaultDrmSessionManager should renew the license and stream play fine
+      testDashPlayback(getActivity(), streamName, schedule, true, parameters,
+          WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, false, keySetId, WIDEVINE_H264_CDD_FIXED);
+    } finally {
+      helper.releaseResources();
+    }
+  }
+
   // Internal.
 
   private void testDashPlayback(HostActivity activity, String streamName, String manifestFileName,
@@ -613,27 +735,41 @@ private void testDashPlayback(HostActivity activity, String streamName,
       ActionSchedule actionSchedule, boolean fullPlaybackNoSeeking, String manifestFileName,
       String audioFormat, boolean isWidevineEncrypted, String videoMimeType,
       boolean canIncludeAdditionalVideoFormats, String... videoFormats) {
+    testDashPlayback(activity, streamName, actionSchedule, fullPlaybackNoSeeking,
+        newDashHostedTestEncParameters(manifestFileName, isWidevineEncrypted, videoMimeType),
+        audioFormat, canIncludeAdditionalVideoFormats, null, videoFormats);
+  }
+
+  private void testDashPlayback(HostActivity activity, String streamName,
+      ActionSchedule actionSchedule, boolean fullPlaybackNoSeeking,
+      DashHostedTestEncParameters parameters, String audioFormat,
+      boolean canIncludeAdditionalVideoFormats, byte[] offlineLicenseKeySetId,
+      String... videoFormats) {
     MetricsLogger metricsLogger = MetricsLogger.Factory.createDefault(getInstrumentation(), TAG,
         REPORT_NAME, REPORT_OBJECT_NAME);
-    String manifestPath = MANIFEST_URL_PREFIX + manifestFileName;
-    DashHostedTest test = new DashHostedTest(streamName, manifestPath, metricsLogger,
-        fullPlaybackNoSeeking, audioFormat, isWidevineEncrypted, videoMimeType,
-        canIncludeAdditionalVideoFormats, false, actionSchedule, videoFormats);
+    DashHostedTest test = new DashHostedTest(streamName, metricsLogger, fullPlaybackNoSeeking,
+        audioFormat, canIncludeAdditionalVideoFormats, false, actionSchedule, parameters,
+        offlineLicenseKeySetId, videoFormats);
     activity.runTest(test, TEST_TIMEOUT_MS);
     // Retry test exactly once if adaptive test fails due to excessive dropped buffers when playing
     // non-CDD required formats (b/28220076).
     if (test.needsCddLimitedRetry) {
       metricsLogger = MetricsLogger.Factory.createDefault(getInstrumentation(), TAG, REPORT_NAME,
           REPORT_OBJECT_NAME);
-      test = new DashHostedTest(streamName, manifestPath, metricsLogger, fullPlaybackNoSeeking,
-          audioFormat, isWidevineEncrypted, videoMimeType, false, true, actionSchedule,
-          videoFormats);
+      test = new DashHostedTest(streamName, metricsLogger, fullPlaybackNoSeeking, audioFormat,
+          false, true, actionSchedule, parameters, offlineLicenseKeySetId, videoFormats);
       activity.runTest(test, TEST_TIMEOUT_MS);
     }
   }
 
+  private static DashHostedTestEncParameters newDashHostedTestEncParameters(String manifestFileName,
+      boolean isWidevineEncrypted, String videoMimeType) {
+    String manifestPath = MANIFEST_URL_PREFIX + manifestFileName;
+    return new DashHostedTestEncParameters(manifestPath, isWidevineEncrypted, videoMimeType);
+  }
+
   private static boolean shouldSkipAdaptiveTest(String mimeType) throws DecoderQueryException {
-    MediaCodecInfo decoderInfo = MediaCodecUtil.getDecoderInfo(mimeType, false, false);
+    MediaCodecInfo decoderInfo = MediaCodecUtil.getDecoderInfo(mimeType, false);
     assertNotNull(decoderInfo);
     if (decoderInfo.adaptive) {
       return false;
@@ -642,48 +778,139 @@ private static boolean shouldSkipAdaptiveTest(String mimeType) throws DecoderQue
     return true;
   }
 
+  private static class DashHostedTestEncParameters {
+
+    public final String manifestUrl;
+    public final boolean useL1Widevine;
+    public final String widevineLicenseUrl;
+    public final boolean isWidevineEncrypted;
+
+    public DashHostedTestEncParameters(String manifestUrl, boolean isWidevineEncrypted,
+        String videoMimeType) {
+      this.isWidevineEncrypted = isWidevineEncrypted;
+      if (!isWidevineEncrypted) {
+        this.manifestUrl = manifestUrl;
+        this.useL1Widevine = true;
+        this.widevineLicenseUrl = null;
+      } else {
+        this.useL1Widevine = isL1WidevineAvailable(videoMimeType);
+        this.widevineLicenseUrl = WIDEVINE_LICENSE_URL + (useL1Widevine
+            ? WIDEVINE_HW_SECURE_DECODE_CONTENT_ID : WIDEVINE_SW_CRYPTO_CONTENT_ID);
+        this.manifestUrl =
+            manifestUrl + (useL1Widevine ? WIDEVINE_L1_SUFFIX : WIDEVINE_L3_SUFFIX);
+      }
+    }
+
+    @TargetApi(18)
+    @SuppressWarnings("ResourceType")
+    private static boolean isL1WidevineAvailable(String videoMimeType) {
+      try {
+        // Force L3 if secure decoder is not available.
+        if (MediaCodecUtil.getDecoderInfo(videoMimeType, true) == null) {
+          return false;
+        }
+
+        MediaDrm mediaDrm = new MediaDrm(WIDEVINE_UUID);
+        String securityProperty = mediaDrm.getPropertyString(SECURITY_LEVEL_PROPERTY);
+        mediaDrm.release();
+        return WIDEVINE_SECURITY_LEVEL_1.equals(securityProperty);
+      } catch (DecoderQueryException | UnsupportedSchemeException e) {
+        throw new IllegalStateException(e);
+      }
+    }
+
+  }
+
+  private static class TestOfflineLicenseHelper {
+
+    private final DashHostedTestEncParameters parameters;
+    private final OfflineLicenseHelper<FrameworkMediaCrypto> offlineLicenseHelper;
+    private final DefaultHttpDataSourceFactory httpDataSourceFactory;
+    private byte[] offlineLicenseKeySetId;
+
+    public TestOfflineLicenseHelper(DashHostedTestEncParameters parameters)
+        throws UnsupportedDrmException {
+      this.parameters = parameters;
+      httpDataSourceFactory = new DefaultHttpDataSourceFactory("ExoPlayerPlaybackTests");
+      offlineLicenseHelper = OfflineLicenseHelper.newWidevineInstance(
+          parameters.widevineLicenseUrl, httpDataSourceFactory);
+    }
+
+    public byte[] downloadLicense() throws InterruptedException, DrmSessionException, IOException {
+      assertNull(offlineLicenseKeySetId);
+      offlineLicenseKeySetId = offlineLicenseHelper
+          .download(httpDataSourceFactory.createDataSource(), parameters.manifestUrl);
+      assertNotNull(offlineLicenseKeySetId);
+      assertTrue(offlineLicenseKeySetId.length > 0);
+      return offlineLicenseKeySetId;
+    }
+
+    public void renewLicense() throws DrmSessionException {
+      assertNotNull(offlineLicenseKeySetId);
+      offlineLicenseKeySetId = offlineLicenseHelper.renew(offlineLicenseKeySetId);
+      assertNotNull(offlineLicenseKeySetId);
+    }
+
+    public void releaseLicense() throws DrmSessionException {
+      assertNotNull(offlineLicenseKeySetId);
+      offlineLicenseHelper.release(offlineLicenseKeySetId);
+      offlineLicenseKeySetId = null;
+    }
+
+    public Pair<Long, Long> getLicenseDurationRemainingSec() throws DrmSessionException {
+      return offlineLicenseHelper.getLicenseDurationRemainingSec(offlineLicenseKeySetId);
+    }
+
+    public void releaseResources() throws DrmSessionException {
+      if (offlineLicenseKeySetId != null) {
+        releaseLicense();
+      }
+      if (offlineLicenseHelper != null) {
+        offlineLicenseHelper.releaseResources();
+      }
+    }
+
+  }
+
   @TargetApi(16)
   private static class DashHostedTest extends ExoHostedTest {
 
     private final String streamName;
-    private final String videoMimeType;
-    private final String manifestPath;
     private final MetricsLogger metricsLogger;
     private final boolean fullPlaybackNoSeeking;
     private final boolean isCddLimitedRetry;
-    private final boolean isWidevineEncrypted;
     private final DashTestTrackSelector trackSelector;
+    private final DashHostedTestEncParameters parameters;
+    private final byte[] offlineLicenseKeySetId;
 
     private boolean needsCddLimitedRetry;
-    private boolean needsSecureVideoDecoder;
 
     /**
      * @param streamName The name of the test stream for metric logging.
-     * @param manifestPath The manifest path.
      * @param metricsLogger Logger to log metrics from the test.
      * @param fullPlaybackNoSeeking Whether the test will play the entire source with no seeking.
      * @param audioFormat The audio format.
-     * @param isWidevineEncrypted Whether the video is Widevine encrypted.
-     * @param videoMimeType The video mime type.
      * @param canIncludeAdditionalVideoFormats Whether to use video formats in addition to those
      *     listed in the videoFormats argument, if the device is capable of playing them.
      * @param isCddLimitedRetry Whether this is a CDD limited retry following a previous failure.
      * @param actionSchedule The action schedule for the test.
+     * @param parameters Encryption parameters.
+     * @param offlineLicenseKeySetId The key set id of the license to be used.
      * @param videoFormats The video formats.
      */
-    public DashHostedTest(String streamName, String manifestPath, MetricsLogger metricsLogger,
-        boolean fullPlaybackNoSeeking, String audioFormat, boolean isWidevineEncrypted,
-        String videoMimeType, boolean canIncludeAdditionalVideoFormats, boolean isCddLimitedRetry,
-        ActionSchedule actionSchedule, String... videoFormats) {
+    public DashHostedTest(String streamName, MetricsLogger metricsLogger,
+        boolean fullPlaybackNoSeeking, String audioFormat,
+        boolean canIncludeAdditionalVideoFormats, boolean isCddLimitedRetry,
+        ActionSchedule actionSchedule, DashHostedTestEncParameters parameters,
+        byte[] offlineLicenseKeySetId, String... videoFormats) {
       super(TAG, fullPlaybackNoSeeking);
       Assertions.checkArgument(!(isCddLimitedRetry && canIncludeAdditionalVideoFormats));
       this.streamName = streamName;
-      this.manifestPath = manifestPath;
       this.metricsLogger = metricsLogger;
       this.fullPlaybackNoSeeking = fullPlaybackNoSeeking;
-      this.isWidevineEncrypted = isWidevineEncrypted;
-      this.videoMimeType = videoMimeType;
       this.isCddLimitedRetry = isCddLimitedRetry;
+      this.parameters = parameters;
+      this.offlineLicenseKeySetId = offlineLicenseKeySetId;
       trackSelector = new DashTestTrackSelector(audioFormat, videoFormats,
           canIncludeAdditionalVideoFormats);
       if (actionSchedule != null) {
@@ -698,34 +925,23 @@ protected MappingTrackSelector buildTrackSelector(HostActivity host,
     }
 
     @Override
-    @TargetApi(18)
-    @SuppressWarnings("ResourceType")
-    protected final StreamingDrmSessionManager<FrameworkMediaCrypto> buildDrmSessionManager(
+    protected final DefaultDrmSessionManager<FrameworkMediaCrypto> buildDrmSessionManager(
         final String userAgent) {
-      StreamingDrmSessionManager<FrameworkMediaCrypto> drmSessionManager = null;
-      if (isWidevineEncrypted) {
+      DefaultDrmSessionManager<FrameworkMediaCrypto> drmSessionManager = null;
+      if (parameters.isWidevineEncrypted) {
         try {
-          // Force L3 if secure decoder is not available.
-          boolean forceL3Widevine =
-              MediaCodecUtil.getDecoderInfo(videoMimeType, true, false) == null;
-          MediaDrm mediaDrm = new MediaDrm(WIDEVINE_UUID);
-          String securityProperty = mediaDrm.getPropertyString(SECURITY_LEVEL_PROPERTY);
-          String widevineContentId = forceL3Widevine ? WIDEVINE_SW_CRYPTO_CONTENT_ID
-              : WIDEVINE_SECURITY_LEVEL_1.equals(securityProperty)
-              ? WIDEVINE_HW_SECURE_DECODE_CONTENT_ID : WIDEVINE_SW_CRYPTO_CONTENT_ID;
-          HttpMediaDrmCallback drmCallback = new HttpMediaDrmCallback(
-              WIDEVINE_LICENSE_URL + widevineContentId,
+          MediaDrmCallback drmCallback = new HttpMediaDrmCallback(parameters.widevineLicenseUrl,
               new DefaultHttpDataSourceFactory(userAgent));
-          drmSessionManager = StreamingDrmSessionManager.newWidevineInstance(drmCallback, null,
+          drmSessionManager = DefaultDrmSessionManager.newWidevineInstance(drmCallback, null,
               null, null);
-          if (forceL3Widevine && !WIDEVINE_SECURITY_LEVEL_3.equals(securityProperty)) {
+          if (!parameters.useL1Widevine) {
             drmSessionManager.setPropertyString(SECURITY_LEVEL_PROPERTY, WIDEVINE_SECURITY_LEVEL_3);
           }
-          // Check if secure video decoder is required.
-          securityProperty = drmSessionManager.getPropertyString(SECURITY_LEVEL_PROPERTY);
-          needsSecureVideoDecoder = WIDEVINE_SECURITY_LEVEL_1.equals(securityProperty);
-        } catch (MediaCodecUtil.DecoderQueryException | UnsupportedSchemeException
-            | UnsupportedDrmException e) {
+          if (offlineLicenseKeySetId != null) {
+            drmSessionManager.setMode(DefaultDrmSessionManager.MODE_PLAYBACK,
+                offlineLicenseKeySetId);
+          }
+        } catch (UnsupportedDrmException e) {
           throw new IllegalStateException(e);
         }
       }
@@ -748,10 +964,7 @@ protected MediaSource buildSource(HostActivity host, String userAgent,
       DataSource.Factory manifestDataSourceFactory = new DefaultDataSourceFactory(host, userAgent);
       DataSource.Factory mediaDataSourceFactory = new DefaultDataSourceFactory(host, userAgent,
           mediaTransferListener);
-      String manifestUrl = manifestPath;
-      manifestUrl += isWidevineEncrypted ? (needsSecureVideoDecoder ? WIDEVINE_L1_SUFFIX
-          : WIDEVINE_L3_SUFFIX) : "";
-      Uri manifestUri = Uri.parse(manifestUrl);
+      Uri manifestUri = Uri.parse(parameters.manifestUrl);
       DefaultDashChunkSource.Factory chunkSourceFactory = new DefaultDashChunkSource.Factory(
           mediaDataSourceFactory);
       return new DashMediaSource(manifestUri, manifestDataSourceFactory, chunkSourceFactory,
@@ -837,7 +1050,7 @@ private DashTestTrackSelector(String audioFormatId, String[] videoFormatIds,
       TrackSelection[] selections = new TrackSelection[rendererCapabilities.length];
       selections[VIDEO_RENDERER_INDEX] = new RandomTrackSelection(
           rendererTrackGroupArrays[VIDEO_RENDERER_INDEX].get(0),
-          getTrackIndices(rendererTrackGroupArrays[VIDEO_RENDERER_INDEX].get(0),
+          getVideoTrackIndices(rendererTrackGroupArrays[VIDEO_RENDERER_INDEX].get(0),
               rendererFormatSupports[VIDEO_RENDERER_INDEX][0], videoFormatIds,
               canIncludeAdditionalVideoFormats),
           0 /* seed */);
@@ -849,20 +1062,24 @@ private DashTestTrackSelector(String audioFormatId, String[] videoFormatIds,
       return selections;
     }
 
-    private static int[] getTrackIndices(TrackGroup trackGroup, int[] formatSupport,
+    private static int[] getVideoTrackIndices(TrackGroup trackGroup, int[] formatSupport,
         String[] formatIds, boolean canIncludeAdditionalFormats) {
       List<Integer> trackIndices = new ArrayList<>();
 
       // Always select explicitly listed representations.
       for (String formatId : formatIds) {
-        trackIndices.add(getTrackIndex(trackGroup, formatId));
+        int trackIndex = getTrackIndex(trackGroup, formatId);
+        Log.d(TAG, "Adding base video format: "
+            + Format.toLogString(trackGroup.getFormat(trackIndex)));
+        trackIndices.add(trackIndex);
       }
 
       // Select additional video representations, if supported by the device.
       if (canIncludeAdditionalFormats) {
         for (int i = 0; i < trackGroup.length; i++) {
           if (!trackIndices.contains(i) && isFormatHandled(formatSupport[i])) {
-            Log.d(TAG, "Adding video format: " + trackGroup.getFormat(i).id);
+            Log.d(TAG, "Adding extra video format: "
+                + Format.toLogString(trackGroup.getFormat(i)));
             trackIndices.add(i);
           }
         }
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/hls/HlsTest.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/hls/HlsTest.java
deleted file mode 100644
index 99f8944c48..0000000000
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/hls/HlsTest.java
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.playbacktests.hls;
-
-import android.annotation.TargetApi;
-import android.net.Uri;
-import android.test.ActivityInstrumentationTestCase2;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayer;
-import com.google.android.exoplayer2.playbacktests.util.ExoHostedTest;
-import com.google.android.exoplayer2.playbacktests.util.HostActivity;
-import com.google.android.exoplayer2.source.MediaSource;
-import com.google.android.exoplayer2.source.hls.HlsMediaSource;
-import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
-import com.google.android.exoplayer2.upstream.TransferListener;
-import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.ClosedSource;
-import com.google.android.exoplayer2.util.Util;
-import java.io.IOException;
-
-/**
- * Tests HLS playbacks using {@link ExoPlayer}.
- */
-@ClosedSource(reason = "Streams are internal")
-public final class HlsTest extends ActivityInstrumentationTestCase2<HostActivity> {
-
-  private static final String TAG = "HlsTest";
-  private static final String BASE_URL = "https://storage.googleapis.com/"
-      + "exoplayer-test-media-internal-63834241aced7884c2544af1a3452e01/hls/bipbop/";
-  private static final long TIMEOUT_MS = 3 * 60 * 1000;
-
-  public HlsTest() {
-    super(HostActivity.class);
-  }
-
-  /**
-   * Tests playback for two variants with all segments available.
-   */
-  public void testAllSegmentsAvailable() throws IOException {
-    testPlaybackForPath("bipbop-all-200.m3u8");
-  }
-
-  /**
-   * Tests playback for a single variant with all segments available.
-   */
-  public void testSingleGearAllSegmentsAvailable() throws IOException {
-    testPlaybackForPath("gear1/prog_index.m3u8");
-  }
-
-  /**
-   * Tests playback for two variants where the first has an unavailable playlist. Playback should
-   * succeed using the second variant.
-   */
-  public void testGear1PlaylistMissing() throws IOException {
-    testPlaybackForPath("bipbop-gear1-playlist-404.m3u8");
-  }
-
-  /**
-   * Tests playback for two variants where the second has an unavailable playlist. Playback should
-   * succeed using the first variant.
-   */
-  public void testGear2PlaylistMissing() throws IOException {
-    testPlaybackForPath("bipbop-gear2-playlist-404.m3u8");
-  }
-
-  /**
-   * Tests playback for two variants where the first has a missing first segment. Playback should
-   * succeed using the first segment from the second variant.
-   */
-  public void testGear1Seg1Missing() throws IOException {
-    testPlaybackForPath("bipbop-gear1-seg1-404.m3u8");
-  }
-
-  /**
-   * Tests playback for two variants where the second has a missing first segment. Playback should
-   * succeed using the first segment from the first variant.
-   */
-  public void testGear2Seg1Missing() throws IOException {
-    testPlaybackForPath("bipbop-gear2-seg1-404.m3u8");
-  }
-
-  /**
-   * Tests playback for two variants where the first has a missing second segment. Playback should
-   * succeed using the second segment from the second variant.
-   */
-  public void testGear1Seg2Missing() throws IOException {
-    testPlaybackForPath("bipbop-gear1-seg2-404.m3u8");
-  }
-
-  /**
-   * Tests playback for two variants where the second has a missing second segment. Playback should
-   * succeed using the second segment from the first variant.
-   */
-  public void testGear2Seg2Missing() throws IOException {
-    testPlaybackForPath("bipbop-gear2-seg2-404.m3u8");
-  }
-
-  /**
-   * Tests playback for two variants where the first has a missing sixth segment. Playback should
-   * succeed using the sixth segment from the second variant.
-   */
-  public void testGear1Seg6Missing() throws IOException {
-    testPlaybackForPath("bipbop-gear1-seg6-404.m3u8");
-  }
-
-  /**
-   * Tests playback for two variants where the second has a missing sixth segment. Playback should
-   * succeed using the sixth segment from the first variant.
-   */
-  public void testGear2Seg6Missing() throws IOException {
-    testPlaybackForPath("bipbop-gear2-seg6-404.m3u8");
-  }
-
-  /**
-   * Tests playback of a single variant with a missing sixth segment. Playback should fail, however
-   * should not do so until playback reaches the missing segment at 60 seconds.
-   */
-  public void testSingleGearSeg6Missing() throws IOException {
-    testPlaybackForPath("gear1/prog_index-seg6-404.m3u8", 60000);
-  }
-
-  private void testPlaybackForPath(String path) throws IOException {
-    testPlaybackForPath(path, C.TIME_UNSET);
-  }
-
-  private void testPlaybackForPath(String path, long expectedFailureTimeMs) throws IOException {
-    if (Util.SDK_INT < 16) {
-      // Pass.
-      return;
-    }
-    HlsHostedTest test = new HlsHostedTest(Uri.parse(BASE_URL + path), expectedFailureTimeMs);
-    getActivity().runTest(test, TIMEOUT_MS);
-  }
-
-  @TargetApi(16)
-  private static class HlsHostedTest extends ExoHostedTest {
-
-    private final Uri playlistUri;
-
-    public HlsHostedTest(Uri playlistUri, long expectedFailureTimeMs) {
-      super(TAG, expectedFailureTimeMs == C.TIME_UNSET
-          ? ExoHostedTest.EXPECTED_PLAYING_TIME_MEDIA_DURATION_MS : expectedFailureTimeMs,
-          expectedFailureTimeMs == C.TIME_UNSET);
-      this.playlistUri = Assertions.checkNotNull(playlistUri);
-    }
-
-    @Override
-    public MediaSource buildSource(HostActivity host, String userAgent,
-        TransferListener<? super DataSource> mediaTransferListener) {
-      DataSource.Factory dataSourceFactory = new DefaultDataSourceFactory(host, userAgent,
-          mediaTransferListener);
-      return new HlsMediaSource(playlistUri, dataSourceFactory, null, null);
-    }
-
-  }
-
-}
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/DebugSimpleExoPlayer.java b/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/DebugSimpleExoPlayer.java
index e279bc8ae8..ede172ad29 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/DebugSimpleExoPlayer.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/DebugSimpleExoPlayer.java
@@ -19,6 +19,7 @@
 import android.content.Context;
 import android.os.Handler;
 import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.LoadControl;
 import com.google.android.exoplayer2.Renderer;
 import com.google.android.exoplayer2.SimpleExoPlayer;
@@ -66,16 +67,14 @@ protected void buildVideoRenderers(Context context, Handler mainHandler,
     private int startIndex;
     private int queueSize;
     private int bufferCount;
+    private int minimumInsertIndex;
 
     public DebugMediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSelector,
         long allowedJoiningTimeMs, Handler eventHandler,
         DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
-        VideoRendererEventListener eventListener,
-        int maxDroppedFrameCountToNotify) {
+        VideoRendererEventListener eventListener, int maxDroppedFrameCountToNotify) {
       super(context, mediaCodecSelector, allowedJoiningTimeMs, drmSessionManager, false,
           eventHandler, eventListener, maxDroppedFrameCountToNotify);
-      startIndex = 0;
-      queueSize = 0;
     }
 
     @Override
@@ -90,6 +89,14 @@ protected void flushCodec() throws ExoPlaybackException {
       clearTimestamps();
     }
 
+    @Override
+    protected void onInputFormatChanged(Format newFormat) throws ExoPlaybackException {
+      super.onInputFormatChanged(newFormat);
+      // Ensure timestamps of buffers queued after this format change are never inserted into the
+      // queue of expected output timestamps before those of buffers that have already been queued.
+      minimumInsertIndex = startIndex + queueSize;
+    }
+
     @Override
     protected void onQueueInputBuffer(DecoderInputBuffer buffer) {
       insertTimestamp(buffer.timeUs);
@@ -111,10 +118,11 @@ private void clearTimestamps() {
       startIndex = 0;
       queueSize = 0;
       bufferCount = 0;
+      minimumInsertIndex = 0;
     }
 
     private void insertTimestamp(long presentationTimeUs) {
-      for (int i = startIndex + queueSize - 1; i >= startIndex; i--) {
+      for (int i = startIndex + queueSize - 1; i >= minimumInsertIndex; i--) {
         if (presentationTimeUs >= timestampsList[i]) {
           timestampsList[i + 1] = presentationTimeUs;
           queueSize++;
@@ -122,20 +130,22 @@ private void insertTimestamp(long presentationTimeUs) {
         }
         timestampsList[i + 1] = timestampsList[i];
       }
-      timestampsList[startIndex] = presentationTimeUs;
+      timestampsList[minimumInsertIndex] = presentationTimeUs;
       queueSize++;
     }
 
     private void maybeShiftTimestampsList() {
       if (startIndex + queueSize == ARRAY_SIZE) {
         System.arraycopy(timestampsList, startIndex, timestampsList, 0, queueSize);
+        minimumInsertIndex -= startIndex;
         startIndex = 0;
       }
     }
 
     private long dequeueTimestamp() {
-      startIndex++;
       queueSize--;
+      startIndex++;
+      minimumInsertIndex = Math.max(minimumInsertIndex, startIndex);
       return timestampsList[startIndex - 1];
     }
 
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/ExoHostedTest.java b/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/ExoHostedTest.java
index dfecdd236a..7bf8985b64 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/ExoHostedTest.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/ExoHostedTest.java
@@ -247,7 +247,7 @@ public void onAudioDecoderInitialized(String decoderName, long elapsedRealtimeMs
 
   @Override
   public void onAudioInputFormatChanged(Format format) {
-    Log.d(tag, "audioFormatChanged [" + format.id + "]");
+    Log.d(tag, "audioFormatChanged [" + Format.toLogString(format) + "]");
   }
 
   @Override
@@ -277,7 +277,7 @@ public void onVideoDecoderInitialized(String decoderName, long elapsedRealtimeMs
 
   @Override
   public void onVideoInputFormatChanged(Format format) {
-    Log.d(tag, "videoFormatChanged [" + format.id + "]");
+    Log.d(tag, "videoFormatChanged [" + Format.toLogString(format) + "]");
   }
 
   @Override
diff --git a/testutils/build.gradle b/testutils/build.gradle
index 61bb50f74d..83ff065f9a 100644
--- a/testutils/build.gradle
+++ b/testutils/build.gradle
@@ -1,3 +1,16 @@
+// Copyright (C) 2017 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
 apply plugin: 'com.android.library'
 
 android {
@@ -8,13 +21,6 @@ android {
         minSdkVersion 9
         targetSdkVersion project.ext.targetSdkVersion
     }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
-        }
-    }
 }
 
 dependencies {
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
index 7f6187f16b..fd971892b4 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
@@ -300,6 +300,81 @@ public static FakeExtractorOutput assertOutput(Extractor extractor, String sampl
     return extractorOutput;
   }
 
+  /**
+   * Calls {@link #assertThrows(Extractor, byte[], Class, boolean, boolean, boolean)} with all
+   * possible combinations of "simulate" parameters.
+   *
+   * @param factory An {@link ExtractorFactory} which creates instances of the {@link Extractor}
+   *     class which is to be tested.
+   * @param sampleFile The path to the input sample.
+   * @param instrumentation To be used to load the sample file.
+   * @param expectedThrowable Expected {@link Throwable} class.
+   * @throws IOException If reading from the input fails.
+   * @throws InterruptedException If interrupted while reading from the input.
+   * @see #assertThrows(Extractor, byte[], Class, boolean, boolean, boolean)
+   */
+  public static void assertThrows(ExtractorFactory factory, String sampleFile,
+      Instrumentation instrumentation, Class<? extends Throwable> expectedThrowable)
+      throws IOException, InterruptedException {
+    byte[] fileData = getByteArray(instrumentation, sampleFile);
+    assertThrows(factory, fileData, expectedThrowable);
+  }
+
+  /**
+   * Calls {@link #assertThrows(Extractor, byte[], Class, boolean, boolean, boolean)} with all
+   * possible combinations of "simulate" parameters.
+   *
+   * @param factory An {@link ExtractorFactory} which creates instances of the {@link Extractor}
+   *     class which is to be tested.
+   * @param fileData Content of the input file.
+   * @param expectedThrowable Expected {@link Throwable} class.
+   * @throws IOException If reading from the input fails.
+   * @throws InterruptedException If interrupted while reading from the input.
+   * @see #assertThrows(Extractor, byte[], Class, boolean, boolean, boolean)
+   */
+  public static void assertThrows(ExtractorFactory factory, byte[] fileData,
+      Class<? extends Throwable> expectedThrowable) throws IOException, InterruptedException {
+    assertThrows(factory.create(), fileData, expectedThrowable, false, false, false);
+    assertThrows(factory.create(), fileData, expectedThrowable,  true, false, false);
+    assertThrows(factory.create(), fileData, expectedThrowable, false,  true, false);
+    assertThrows(factory.create(), fileData, expectedThrowable,  true,  true, false);
+    assertThrows(factory.create(), fileData, expectedThrowable, false, false,  true);
+    assertThrows(factory.create(), fileData, expectedThrowable,  true, false,  true);
+    assertThrows(factory.create(), fileData, expectedThrowable, false,  true,  true);
+    assertThrows(factory.create(), fileData, expectedThrowable,  true,  true,  true);
+  }
+
+  /**
+   * Asserts {@code extractor} throws {@code expectedThrowable} while consuming {@code sampleFile}.
+   *
+   * @param extractor The {@link Extractor} to be tested.
+   * @param fileData Content of the input file.
+   * @param expectedThrowable Expected {@link Throwable} class.
+   * @param simulateIOErrors If true simulates IOErrors.
+   * @param simulateUnknownLength If true simulates unknown input length.
+   * @param simulatePartialReads If true simulates partial reads.
+   * @throws IOException If reading from the input fails.
+   * @throws InterruptedException If interrupted while reading from the input.
+   */
+  public static void assertThrows(Extractor extractor, byte[] fileData,
+      Class<? extends Throwable> expectedThrowable, boolean simulateIOErrors,
+      boolean simulateUnknownLength, boolean simulatePartialReads) throws IOException,
+      InterruptedException {
+    FakeExtractorInput input = new FakeExtractorInput.Builder().setData(fileData)
+        .setSimulateIOErrors(simulateIOErrors)
+        .setSimulateUnknownLength(simulateUnknownLength)
+        .setSimulatePartialReads(simulatePartialReads).build();
+    try {
+      consumeTestData(extractor, input, 0, true);
+      throw new AssertionError(expectedThrowable.getSimpleName() + " expected but not thrown");
+    } catch (Throwable throwable) {
+      if (expectedThrowable.equals(throwable.getClass())) {
+        return; // Pass!
+      }
+      throw throwable;
+    }
+  }
+
   public static void recursiveDelete(File fileOrDirectory) {
     if (fileOrDirectory.isDirectory()) {
       for (File child : fileOrDirectory.listFiles()) {
