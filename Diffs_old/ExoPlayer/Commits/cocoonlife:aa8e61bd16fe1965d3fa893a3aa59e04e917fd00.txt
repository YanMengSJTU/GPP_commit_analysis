diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
index b9d8fde7f3..f9ca67b60a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
@@ -253,42 +253,16 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
     }
 
     int chunkMediaSequence;
-    if (live) {
-      if (previous == null) {
-        // When playing a live stream, the starting chunk will be the third counting from the live
-        // edge.
-        chunkMediaSequence = Math.max(0, mediaPlaylist.segments.size() - 3)
-            + mediaPlaylist.mediaSequence;
-        // TODO: Bring this back for live window seeking.
-        // chunkMediaSequence = Util.binarySearchFloor(mediaPlaylist.segments, playbackPositionUs,
-        //     true, true) + mediaPlaylist.mediaSequence;
-      } else {
-        chunkMediaSequence = getLiveNextChunkSequenceNumber(previous.chunkIndex, oldVariantIndex,
-            newVariantIndex);
-        if (chunkMediaSequence < mediaPlaylist.mediaSequence) {
-          // We try getting the next chunk without adapting in case that's the reason for falling
-          // behind the live window.
-          newVariantIndex = oldVariantIndex;
-          mediaPlaylist = variantPlaylists[newVariantIndex];
-          chunkMediaSequence = getLiveNextChunkSequenceNumber(previous.chunkIndex, oldVariantIndex,
-              newVariantIndex);
-          if (chunkMediaSequence < mediaPlaylist.mediaSequence) {
-            fatalError = new BehindLiveWindowException();
-            return;
-          }
-        }
-      }
+    // Changed behaviour from exoplayer standard - this now allows standard seeking behaviour within
+    // live streams rather than relative seek positions
+    if (previous == null) {
+      chunkMediaSequence = Util.binarySearchFloor(mediaPlaylist.segments, playbackPositionUs,
+          true, true) + mediaPlaylist.mediaSequence;
+    } else if (switchingVariant) {
+      chunkMediaSequence = Util.binarySearchFloor(mediaPlaylist.segments,
+          previous.startTimeUs, true, true) + mediaPlaylist.mediaSequence;
     } else {
-      // Not live.
-      if (previous == null) {
-        chunkMediaSequence = Util.binarySearchFloor(mediaPlaylist.segments, playbackPositionUs,
-            true, true) + mediaPlaylist.mediaSequence;
-      } else if (switchingVariant) {
-        chunkMediaSequence = Util.binarySearchFloor(mediaPlaylist.segments,
-            previous.startTimeUs, true, true) + mediaPlaylist.mediaSequence;
-      } else {
-        chunkMediaSequence = previous.getNextChunkIndex();
-      }
+      chunkMediaSequence = previous.getNextChunkIndex();
     }
 
     int chunkIndex = chunkMediaSequence - mediaPlaylist.mediaSequence;
@@ -328,18 +302,7 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
     }
 
     // Compute start and end times, and the sequence number of the next chunk.
-    long startTimeUs;
-    if (live) {
-      if (previous == null) {
-        startTimeUs = 0;
-      } else if (switchingVariant) {
-        startTimeUs = previous.getAdjustedStartTimeUs();
-      } else {
-        startTimeUs = previous.getAdjustedEndTimeUs();
-      }
-    } else /* Not live */ {
-      startTimeUs = segment.startTimeUs;
-    }
+    long startTimeUs = segment.startTimeUs;
     long endTimeUs = startTimeUs + (long) (segment.durationSecs * C.MICROS_PER_SECOND);
     Format format = variants[newVariantIndex].format;
 
