diff --git a/library/src/main/java/com/google/android/exoplayer/C.java b/library/src/main/java/com/google/android/exoplayer/C.java
index b2c32bec9d..8a8a9c3dd1 100644
--- a/library/src/main/java/com/google/android/exoplayer/C.java
+++ b/library/src/main/java/com/google/android/exoplayer/C.java
@@ -78,6 +78,11 @@
    */
   public static final int ENCODING_PCM_24BIT = 0x80000000;
 
+  /**
+   * PCM encoding with 32 bits per sample.
+   */
+  public static final int ENCODING_PCM_32BIT = 0x40000000;
+
   /**
    * @see AudioFormat#ENCODING_AC3
    */
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
index 986a0a9cfa..846a778718 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
@@ -124,8 +124,8 @@
   public final int sampleRate;
   /**
    * The encoding for PCM audio streams. If {@link #mimeType} is {@link MimeTypes#AUDIO_RAW} then
-   * one of {@link C#ENCODING_PCM_8BIT}, {@link C#ENCODING_PCM_16BIT} and
-   * {@link C#ENCODING_PCM_24BIT}. Set to {@link #NO_VALUE} for other media types.
+   * one of {@link C#ENCODING_PCM_8BIT}, {@link C#ENCODING_PCM_16BIT}, {@link C#ENCODING_PCM_24BIT}
+   * and {@link C#ENCODING_PCM_32BIT}. Set to {@link #NO_VALUE} for other media types.
    */
   public final int pcmEncoding;
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java b/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
index f236afac81..a38846fdaa 100644
--- a/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
+++ b/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
@@ -341,7 +341,8 @@ public long getCurrentPositionUs(boolean sourceEnded) {
    * @param channelCount The number of channels.
    * @param sampleRate The sample rate in Hz.
    * @param pcmEncoding For PCM formats, the encoding used. One of {@link C#ENCODING_PCM_16BIT},
-   *     {@link C#ENCODING_PCM_16BIT} and {@link C#ENCODING_PCM_24BIT}.
+   *     {@link C#ENCODING_PCM_16BIT}, {@link C#ENCODING_PCM_24BIT} and
+   *     {@link C#ENCODING_PCM_32BIT}.
    */
   public void configure(String mimeType, int channelCount, int sampleRate, int pcmEncoding) {
     configure(mimeType, channelCount, sampleRate, pcmEncoding, 0);
@@ -354,7 +355,8 @@ public void configure(String mimeType, int channelCount, int sampleRate, int pcm
    * @param channelCount The number of channels.
    * @param sampleRate The sample rate in Hz.
    * @param pcmEncoding For PCM formats, the encoding used. One of {@link C#ENCODING_PCM_16BIT},
-   *     {@link C#ENCODING_PCM_16BIT} and {@link C#ENCODING_PCM_24BIT}.
+   *     {@link C#ENCODING_PCM_16BIT}, {@link C#ENCODING_PCM_24BIT} and
+   *     {@link C#ENCODING_PCM_32BIT}.
    * @param specifiedBufferSize A specific size for the playback buffer in bytes, or 0 to infer a
    *     suitable buffer size automatically.
    */
@@ -395,7 +397,7 @@ public void configure(String mimeType, int channelCount, int sampleRate, int pcm
     if (passthrough) {
       sourceEncoding = getEncodingForMimeType(mimeType);
     } else if (pcmEncoding == C.ENCODING_PCM_8BIT || pcmEncoding == C.ENCODING_PCM_16BIT
-        || pcmEncoding == C.ENCODING_PCM_24BIT) {
+        || pcmEncoding == C.ENCODING_PCM_24BIT || pcmEncoding == C.ENCODING_PCM_32BIT) {
       sourceEncoding = pcmEncoding;
     } else {
       throw new IllegalArgumentException("Unsupported PCM encoding: " + pcmEncoding);
@@ -980,6 +982,9 @@ private static ByteBuffer resampleTo16BitPcm(ByteBuffer buffer, int offset, int
       case C.ENCODING_PCM_24BIT:
         resampledSize = (size / 3) * 2;
         break;
+      case C.ENCODING_PCM_32BIT:
+        resampledSize = size / 2;
+        break;
       default:
         // Never happens.
         throw new IllegalStateException();
@@ -1009,6 +1014,13 @@ private static ByteBuffer resampleTo16BitPcm(ByteBuffer buffer, int offset, int
           resampledBuffer.put(buffer.get(i + 2));
         }
         break;
+      case C.ENCODING_PCM_32BIT:
+        // 32->16 bit resampling. Drop the two least significant bytes.
+        for (int i = offset; i < limit; i += 4) {
+          resampledBuffer.put(buffer.get(i + 2));
+          resampledBuffer.put(buffer.get(i + 3));
+        }
+        break;
       default:
         // Never happens.
         throw new IllegalStateException();
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeaderReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeaderReader.java
index ca220d523c..2407a68129 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeaderReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeaderReader.java
@@ -126,6 +126,9 @@ public static void skipToData(ExtractorInput input, WavHeader wavHeader)
     Assertions.checkNotNull(input);
     Assertions.checkNotNull(wavHeader);
 
+    // Make sure the peek position is set to the read position before we peek the first header.
+    input.resetPeekPosition();
+
     ParsableByteArray scratch = new ParsableByteArray(ChunkHeader.SIZE_IN_BYTES);
     // Skip all chunks until we hit the data header.
     ChunkHeader chunkHeader = ChunkHeader.peek(input, scratch);
diff --git a/library/src/main/java/com/google/android/exoplayer/util/Util.java b/library/src/main/java/com/google/android/exoplayer/util/Util.java
index efad3ecc1f..08c1118aa3 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/Util.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/Util.java
@@ -772,10 +772,11 @@ public static String getUserAgent(Context context, String applicationName) {
   /**
    * Converts a sample bit depth to a corresponding PCM encoding constant.
    *
-   * @param bitDepth The bit depth. Supported values are 8, 16 and 24.
+   * @param bitDepth The bit depth. Supported values are 8, 16, 24 and 32.
    * @return The corresponding encoding. One of {@link C#ENCODING_PCM_8BIT},
-   *     {@link C#ENCODING_PCM_16BIT} and {@link C#ENCODING_PCM_24BIT}. If the bit depth is
-   *     unsupported then {@link C#ENCODING_INVALID} is returned.
+   *     {@link C#ENCODING_PCM_16BIT}, {@link C#ENCODING_PCM_24BIT} and
+   *     {@link C#ENCODING_PCM_32BIT}. If the bit depth is unsupported then
+   *     {@link C#ENCODING_INVALID} is returned.
    */
   public static int getPcmEncoding(int bitDepth) {
     switch (bitDepth) {
@@ -785,6 +786,8 @@ public static int getPcmEncoding(int bitDepth) {
         return C.ENCODING_PCM_16BIT;
       case 24:
         return C.ENCODING_PCM_24BIT;
+      case 32:
+        return C.ENCODING_PCM_32BIT;
       default:
         return C.ENCODING_INVALID;
     }
