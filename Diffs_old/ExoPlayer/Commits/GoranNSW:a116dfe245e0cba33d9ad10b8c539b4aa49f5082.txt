diff --git a/library/src/main/java/com/google/android/exoplayer2/Format.java b/library/src/main/java/com/google/android/exoplayer2/Format.java
index 9cfe019ef4..1e9dc80d84 100644
--- a/library/src/main/java/com/google/android/exoplayer2/Format.java
+++ b/library/src/main/java/com/google/android/exoplayer2/Format.java
@@ -306,9 +306,14 @@ public static Format createContainerFormat(String id, String containerMimeType,
 
   public static Format createSampleFormat(String id, String sampleMimeType, String codecs,
       int bitrate, DrmInitData drmInitData) {
+    return createSampleFormat(id, sampleMimeType, codecs, bitrate, drmInitData, null);
+  }
+
+  public static Format createSampleFormat(String id, String sampleMimeType, String codecs,
+                                          int bitrate, DrmInitData drmInitData, String language) {
     return new Format(id, null, sampleMimeType, codecs, bitrate, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, 0, null, OFFSET_SAMPLE_RELATIVE, null, drmInitData);
+            NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
+            NO_VALUE, 0, language, OFFSET_SAMPLE_RELATIVE, null, drmInitData);
   }
 
   /* package */ Format(String id, String containerMimeType, String sampleMimeType, String codecs,
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DvbSubtitlesReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DvbSubtitlesReader.java
new file mode 100644
index 0000000000..c6d6790773
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DvbSubtitlesReader.java
@@ -0,0 +1,59 @@
+package com.google.android.exoplayer2.extractor.ts;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import android.util.Log;
+
+
+public class DvbSubtitlesReader extends ElementaryStreamReader {
+
+    private static final String TAG= "DVBSubsReader";
+
+    private long sampleTimeUs;
+    private int totalBytesWritten;
+    private boolean writingSample;
+
+
+    public DvbSubtitlesReader(TrackOutput output) {
+        this(output, null);
+    }
+
+    public DvbSubtitlesReader(TrackOutput output, String language) {
+        super(output);
+        output.format(Format.createSampleFormat(null, MimeTypes.APPLICATION_DVBSUBS, null, Format.NO_VALUE,
+                null, language));
+    }
+
+    @Override
+    public void seek() {
+        writingSample = false;
+    }
+
+    @Override
+    public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+        if (!dataAlignmentIndicator) {
+            return;
+        }
+        writingSample = true;
+        sampleTimeUs = pesTimeUs;
+        totalBytesWritten = 0;
+    }
+
+    @Override
+    public void packetFinished() {
+        output.sampleMetadata(sampleTimeUs, C.BUFFER_FLAG_KEY_FRAME, totalBytesWritten, 0, null);
+        writingSample = false;
+    }
+
+    @Override
+    public void consume(ParsableByteArray data) {
+        if (writingSample) {
+            totalBytesWritten += data.bytesLeft();
+            output.sampleData(data, data.bytesLeft());
+            //Log.d(TAG, "bytesWritten=" + totalBytesWritten);
+        }
+    }
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
index 5c9e8cf673..5e1a7b5075 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
@@ -64,6 +64,7 @@
 
   private static final int TS_STREAM_TYPE_MPA = 0x03;
   private static final int TS_STREAM_TYPE_MPA_LSF = 0x04;
+  private static final int TS_STREAM_TYPE_PRIVATE = 0x06;
   private static final int TS_STREAM_TYPE_AAC = 0x0F;
   private static final int TS_STREAM_TYPE_AC3 = 0x81;
   private static final int TS_STREAM_TYPE_DTS = 0x8A;
@@ -73,6 +74,7 @@
   private static final int TS_STREAM_TYPE_H264 = 0x1B;
   private static final int TS_STREAM_TYPE_H265 = 0x24;
   private static final int TS_STREAM_TYPE_ID3 = 0x15;
+  private static final int TS_STREAM_TYPE_DVBSUBS   = 0x59;
   private static final int BASE_EMBEDDED_TRACK_ID = 0x2000; // 0xFF + 1
 
   private static final long AC3_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("AC-3");
@@ -353,6 +355,7 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
     private static final int TS_PMT_DESC_AC3 = 0x6A;
     private static final int TS_PMT_DESC_EAC3 = 0x7A;
     private static final int TS_PMT_DESC_DTS = 0x7B;
+    private static final int TS_PMT_DESC_DVBSUBS = 0x59;
 
     private final ParsableBitArray pmtScratch;
     private final ParsableByteArray sectionData;
@@ -432,7 +435,7 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
         pmtScratch.skipBits(4); // reserved
         int esInfoLength = pmtScratch.readBits(12); // ES_info_length.
         EsInfo esInfo = readEsInfo(sectionData, esInfoLength);
-        if (streamType == 0x06) {
+        if (streamType == TS_STREAM_TYPE_PRIVATE) {
           streamType = esInfo.streamType;
         }
         remainingEntriesLength -= esInfoLength + 5;
@@ -481,6 +484,9 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
               pesPayloadReader = new Id3Reader(output.track(nextEmbeddedTrackId++));
             }
             break;
+          case TS_STREAM_TYPE_DVBSUBS:
+            pesPayloadReader = new DvbSubtitlesReader(output.track(trackId), esInfo.language);
+            break;
           default:
             pesPayloadReader = null;
             break;
@@ -508,7 +514,7 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
     private EsInfo readEsInfo(ParsableByteArray data, int length) {
       int descriptorsEndPosition = data.getPosition() + length;
       int streamType = -1;
-      int audioType = -1;
+      int streamSubType = -1;
       String language = null;
       while (data.getPosition() < descriptorsEndPosition) {
         int descriptorTag = data.readUnsignedByte();
@@ -531,24 +537,29 @@ private EsInfo readEsInfo(ParsableByteArray data, int length) {
           streamType = TS_STREAM_TYPE_DTS;
         } else if (descriptorTag == TS_PMT_DESC_ISO639_LANG) {
           language = new String(data.data, data.getPosition(), 3).trim();
-          audioType = data.data[data.getPosition() + 3];
+          streamSubType = data.data[data.getPosition() + 3];
+        } else if (descriptorTag == TS_PMT_DESC_DVBSUBS && descriptorLength == 8) { // we only support one subtitle service per PID
+          streamType = TS_STREAM_TYPE_DVBSUBS;
+          language = new String(data.data, data.getPosition(), 3).trim();
+          streamSubType = data.data[data.getPosition() + 3];
+          // We discard all the additional info as is no relevant to the library
         }
         // Skip unused bytes of current descriptor.
         data.skipBytes(positionOfNextDescriptor - data.getPosition());
       }
       data.setPosition(descriptorsEndPosition);
-      return new EsInfo(streamType, audioType, language);
+      return new EsInfo(streamType, streamSubType, language);
     }
 
     private final class EsInfo {
 
       final int streamType;
-      final int audioType;
+      final int streamSubType;
       final String language;
 
-      public EsInfo(int streamType, int audioType, String language) {
+      public EsInfo(int streamType, int streamSubType, String language) {
         this.streamType = streamType;
-        this.audioType = audioType;
+        this.streamSubType = streamSubType;
         this.language = language;
       }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/Cue.java b/library/src/main/java/com/google/android/exoplayer2/text/Cue.java
index 01d5b53c86..bfdc9eefc3 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/Cue.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/Cue.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.text;
 
+import android.graphics.Bitmap;
 import android.text.Layout.Alignment;
 
 /**
@@ -117,6 +118,13 @@
    */
   public final float size;
 
+  /**
+   * Graphical content
+   */
+  public final Bitmap bitmap;
+
+  public final boolean isGraphic;
+
   /**
    * Constructs a cue whose {@link #textAlignment} is null, whose type parameters are set to
    * {@link #TYPE_UNSET} and whose dimension parameters are set to {@link #DIMEN_UNSET}.
@@ -147,6 +155,24 @@ public Cue(CharSequence text, Alignment textAlignment, float line, int lineType,
     this.position = position;
     this.positionAnchor = positionAnchor;
     this.size = size;
+
+    this.bitmap = null;
+    this.isGraphic = false;
+  }
+
+  public Cue(Bitmap data) {
+
+    this.text = null;
+    this.textAlignment = null;
+    this.line = DIMEN_UNSET;
+    this.lineType = TYPE_UNSET;
+    this.lineAnchor = TYPE_UNSET;
+    this.position = DIMEN_UNSET;
+    this.positionAnchor = TYPE_UNSET;
+    this.size = DIMEN_UNSET;
+
+    this.bitmap = data;
+    this.isGraphic = true;
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java b/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java
index 918d0b37b7..bfe894f7b4 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java
@@ -22,6 +22,7 @@
 import com.google.android.exoplayer2.text.tx3g.Tx3gDecoder;
 import com.google.android.exoplayer2.text.webvtt.Mp4WebvttDecoder;
 import com.google.android.exoplayer2.text.webvtt.WebvttDecoder;
+import com.google.android.exoplayer2.text.dvbsubs.DvbSubsDecoder;
 import com.google.android.exoplayer2.util.MimeTypes;
 
 /**
@@ -58,6 +59,7 @@
    * <li>SubRip ({@link SubripDecoder})</li>
    * <li>TX3G ({@link Tx3gDecoder})</li>
    * <li>Eia608 ({@link Eia608Decoder})</li>
+   * <li>DVB ({@link DvbSubsDecoder})</li>
    * </ul>
    */
   SubtitleDecoderFactory DEFAULT = new SubtitleDecoderFactory() {
@@ -95,6 +97,8 @@ public SubtitleDecoder createDecoder(Format format) {
             return Class.forName("com.google.android.exoplayer2.text.tx3g.Tx3gDecoder");
           case MimeTypes.APPLICATION_EIA608:
             return Class.forName("com.google.android.exoplayer2.text.eia608.Eia608Decoder");
+          case MimeTypes.APPLICATION_DVBSUBS:
+            return Class.forName("com.google.android.exoplayer2.text.dvbsubs.DvbSubsDecoder");
           default:
             return null;
         }
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/dvbsubs/DvbSubsDecoder.java b/library/src/main/java/com/google/android/exoplayer2/text/dvbsubs/DvbSubsDecoder.java
new file mode 100644
index 0000000000..9b79d8dfc4
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/text/dvbsubs/DvbSubsDecoder.java
@@ -0,0 +1,24 @@
+package com.google.android.exoplayer2.text.dvbsubs;
+
+import android.graphics.Bitmap;
+
+import com.google.android.exoplayer2.text.SimpleSubtitleDecoder;
+
+/**
+ * Created by opatino on 8/17/16.
+ */
+public final class DvbSubsDecoder extends SimpleSubtitleDecoder {
+    private final String TAG = "DVBSubs Decoder";
+
+    DvbSubtitlesParser parser;
+
+    public DvbSubsDecoder() {
+        super("dvbsubs");
+        parser = new DvbSubtitlesParser(null);
+    }
+
+    @Override
+    protected DvbSubsSubtitle decode(byte[] data, int length) {
+        return new DvbSubsSubtitle(parser.dvbSubsDecode(data, length));
+    }
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/dvbsubs/DvbSubsSubtitle.java b/library/src/main/java/com/google/android/exoplayer2/text/dvbsubs/DvbSubsSubtitle.java
new file mode 100644
index 0000000000..dfa000279a
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/text/dvbsubs/DvbSubsSubtitle.java
@@ -0,0 +1,45 @@
+package com.google.android.exoplayer2.text.dvbsubs;
+
+import android.graphics.Bitmap;
+
+import com.google.android.exoplayer2.text.Cue;
+import com.google.android.exoplayer2.text.Subtitle;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Created by opatino on 8/24/16.
+ */
+final class DvbSubsSubtitle implements Subtitle {
+    private final List<Cue> cues;
+
+    public DvbSubsSubtitle(Bitmap data) {
+        if (data == null) {
+            this.cues = Collections.emptyList();
+        } else {
+            Cue cue = new Cue(data);
+            this.cues = Collections.singletonList(cue);
+        }
+    }
+
+    @Override
+    public int getNextEventTimeIndex(long timeUs) {
+        return 0;
+    }
+
+    @Override
+    public int getEventTimeCount() {
+        return 1;
+    }
+
+    @Override
+    public long getEventTime(int index) {
+        return 0;
+    }
+
+    @Override
+    public List<Cue> getCues(long timeUs) {
+        return cues;
+    }
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/dvbsubs/DvbSubtitlesParser.java b/library/src/main/java/com/google/android/exoplayer2/text/dvbsubs/DvbSubtitlesParser.java
new file mode 100644
index 0000000000..cc33b12b43
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/text/dvbsubs/DvbSubtitlesParser.java
@@ -0,0 +1,913 @@
+package com.google.android.exoplayer2.text.dvbsubs;
+
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.PorterDuff;
+import android.util.Log;
+
+import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.ParsableBitArray;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+
+/* Original C code taken from VLC project */
+public class DvbSubtitlesParser {
+
+    private static final String TAG = "DVBSubs";
+    private final int NUM_BITMAPS = 2;
+    /* List of different SEGMENT TYPES */
+    /* According to EN 300-743, table 2 */
+    final static int DVBSUB_ST_PAGE_COMPOSITION = 0x10;
+    final static int DVBSUB_ST_REGION_COMPOSITION = 0x11;
+    final static int DVBSUB_ST_CLUT_DEFINITION = 0x12;
+    final static int DVBSUB_ST_OBJECT_DATA = 0x13;
+    final static int DVBSUB_ST_DISPLAY_DEFINITION = 0x14;
+    final static int DVBSUB_ST_ENDOFDISPLAY = 0x80;
+    final static int DVBSUB_ST_STUFFING = 0xff;
+    /* List of different OBJECT TYPES */
+    /* According to EN 300-743, table 6 */
+    final static int DVBSUB_OT_BASIC_BITMAP = 0x00;
+    final static int DVBSUB_OT_BASIC_CHAR = 0x01;
+    final static int DVBSUB_OT_COMPOSITE_STRING = 0x02;
+    /* Pixel DATA TYPES */
+    /* According to EN 300-743, table 9 */
+    final static int DVBSUB_DT_2BP_CODE_STRING = 0x10;
+    final static int DVBSUB_DT_4BP_CODE_STRING = 0x11;
+    final static int DVBSUB_DT_8BP_CODE_STRING = 0x12;
+    final static int DVBSUB_DT_24_TABLE_DATA = 0x20;
+    final static int DVBSUB_DT_28_TABLE_DATA = 0x21;
+    final static int DVBSUB_DT_48_TABLE_DATA = 0x22;
+    final static int DVBSUB_DT_END_LINE = 0xf0;
+    /* List of different Page Composition Segment state */
+    /* According to EN 300-743, 7.2.1 table 3 */
+    final static int DVBSUB_PCS_STATE_ACQUISITION = 0x01;
+    final static int DVBSUB_PCS_STATE_CHANGE = 0x02;
+
+    final static int DVBSUB_MAX_OBJECTS_STORED = 16;
+
+    int offset, dataCount;
+    int numTSPackets;
+    private Paint graphicsPaintObject;
+    private Canvas graphicsCanvasObject;
+    private Bitmap[] subsBitmap;
+    static ParsableBitArray tsStream;
+    private DvbSubRegion[] regions;
+    private DvbSubDisplay[] displays;
+    private DvbSubObjectDef[] objects;
+    private DvbSubClut[] cluts;
+    private DvbSubPage[] pages;
+    private int regionCounter;
+    private int displayCounter;
+    private int clutCounter;
+    private int objectCounter;
+    private int pageCounter;
+    private int previousCoordX, previousCoordY;
+    private boolean newGraphicData;
+    int currentBitmap;
+    private Map<Integer, Integer> pageMapping; // array index and pageid mapping
+    private Map<Integer, Integer> regionMapping; // array index and regionid mapping
+    private Map<Integer, Integer> objectMapping;
+    private int displayWidth, displayHeight;
+    private int displayHorizontal, displayVertical;
+
+    class DvbSubObjectDef {
+        public int id;
+        public int version;
+        public int codingMethod;
+        public int nonModifyingColor;
+        public int topFieldDataLength;
+        public int bottomFieldDataLength;
+        public int type;
+        public int x;
+        public int y;
+        public int providerFlag;
+        public int foregroundPC;
+        public int backgroundPC;
+        //public byte[] psz_text; /* for string of characters objects */
+    }
+
+    /* The entry in the palette CLUT */
+    class DvbSubColor {
+        public byte Y;
+        public byte Cr;
+        public byte Cb;
+        public byte T;
+    }
+
+    /* The displays dimensions [7.2.1] */
+    class DvbSubDisplay {
+        public int id;
+        public int version;
+
+        public int width;
+        public int height;
+
+        public int windowed;
+        /* these values are only relevant if windowed */
+        public int x;
+        public int y;
+        public int maxX;
+        public int maxY;
+    }
+
+    /* The Region is an aera on the image [7.2.3]
+     * with a list of the object definitions associated and a CLUT */
+    class DvbSubRegion {
+        public int pageId;
+        public int id;
+        public int version;
+        public int b_fill_region;
+        public int x;
+        public int y;
+        public int width;
+        public int height;
+        public int levelComp;
+        public int depth;
+        public int clut;
+        public int numberOfObjectDefs;
+        public DvbSubObjectDef[] objectDefs;
+
+        public int findObject(int objectId) {
+            if (objectDefs != null) {
+                for (int i = 0; i < numberOfObjectDefs; i++) {
+                    if (objectDefs[i].id == objectId) {
+                        return i;
+                    }
+                }
+            }
+            return -1;
+        }
+    }
+
+    /* The object definition gives the position of the object in a region */
+    class DvbSubRegionDef {
+        public int id;
+        public int x;
+        public int y;
+    }
+
+    /* The page final static ints the list of regions [7.2.2] */
+    class DvbSubPage {
+        public int id;
+        public int timeout; /* in seconds */
+        public int state;
+        public int version;
+        public int regionDefs;
+        public DvbSubRegionDef[] pRegionDefs;
+    }
+
+    /* [7.2.4] */
+    class DvbSubClut {
+        int id;
+        int version;
+        DvbSubColor[] c2b;
+        DvbSubColor[] c4b;
+        DvbSubColor[] c8b;
+        DvbSubClut next;
+
+        public DvbSubClut() {
+            c2b = new DvbSubColor[4];
+            for (int i = 0; i < 4; i++) {
+                c2b[i] = new DvbSubColor();
+            }
+            c4b = new DvbSubColor[16];
+            for (int i = 0; i < 16; i++) {
+                c4b[i] = new DvbSubColor();
+            }
+            c8b = new DvbSubColor[256];
+            for (int i = 0; i < 256; i++) {
+                c8b[i] = new DvbSubColor();
+            }
+            next = null;
+        }
+    }
+
+    private int addPage() {
+        if (pageCounter == 0) {
+            pages = new DvbSubPage[1];
+            pages[0] = new DvbSubPage();
+        } else {
+            pages = Arrays.copyOf(pages, pageCounter + 1);
+            pages[pageCounter] = new DvbSubPage();
+        }
+        pageCounter++;
+        return pageCounter - 1;
+    }
+
+    private int checkAlreadyStoredPages(DvbSubPage received, int pageid) {
+        if (pages != null) {
+            for (int i = 0; i < pages.length; i++) {
+                if (pages[i].id == received.id) {
+                    pages[i] = received;
+                    return pageMapping.get(received.id);
+                }
+            }
+        }
+        int index = addPage();
+        pages[index] = received;
+        pageMapping.put(pageid, index);
+        return index;
+    }
+
+    private void checkAlreadyStoredCLUT(DvbSubClut received, int clutId) {
+        if (cluts != null) {
+            for (int i = 0; i < cluts.length; i++) {
+                if (cluts[i].id == received.id) {
+                    cluts[i] = received;
+                    Log.d(TAG, "overwriting already stored region");
+                    return;
+                }
+            }
+        }
+        int index = addCLUT();
+        cluts[index] = received;
+    }
+
+    private int addCLUT() {
+        if (clutCounter == 0) {
+            cluts = new DvbSubClut[1];
+            cluts[0] = new DvbSubClut();
+        } else {
+            cluts = Arrays.copyOf(cluts, clutCounter + 1);
+            cluts[clutCounter] = new DvbSubClut();
+        }
+        clutCounter++;
+        return clutCounter - 1;
+    }
+
+    private int updateDisplay(DvbSubDisplay disp) {
+        if (displays != null) {
+            displays[0] = disp;
+            return 0;
+        }
+        int index = addDisplay();
+        displays[index] = disp;
+        return 0;
+    }
+
+    private int addDisplay() {
+        if (displayCounter == 0) {
+            displays = new DvbSubDisplay[1];
+            displays[0] = new DvbSubDisplay();
+            displayCounter = 1;
+        } else {
+            displays = Arrays.copyOf(displays, displayCounter + 1);
+            displayCounter++;
+        }
+        return displayCounter - 1; /* index of the created display */
+    }
+
+    private int addRegion() {
+        if (regionCounter == 0) {
+            regions = new DvbSubRegion[1];
+            regions[0] = new DvbSubRegion();
+        } else {
+            regions = Arrays.copyOf(regions, regionCounter + 1);
+            regions[regionCounter] = new DvbSubRegion();
+        }
+        regionCounter++;
+        return regionCounter - 1; /* index of the created region */
+    }
+
+    private int checkAlreadyStoredRegion(DvbSubRegion received, int regionid) {
+        if (regions != null) {
+            for (int i = 0; i < regions.length; i++) {
+                if (regions[i].id == received.id) {
+                    regions[i] = received;
+                    Log.d(TAG, "overwriting already stored region");
+                    return regionMapping.get(received.id);
+                }
+            }
+        }
+        int index = addRegion();
+        regions[index] = received;
+        regionMapping.put(regionid, index);
+        return index;
+    }
+
+    private int checkAlreadyStoredObject(DvbSubObjectDef received, int objectid) {
+        if (objects != null) {
+            for (int i = 0; i < objects.length; i++) {
+                if (objects[i].id == received.id) {
+                    objects[i] = received;
+                    Log.d(TAG, "overwriting already created object");
+                    return objectMapping.get(received.id);
+                }
+            }
+        }
+        int index = addObject();
+        objects[index] = received;
+        objectMapping.put(objectid, index);
+        return index;
+    }
+
+    private int addObject() {
+        if (objectCounter == 0) {
+            objects = new DvbSubObjectDef[1];
+            objects[0] = new DvbSubObjectDef();
+        } else {
+            objects = Arrays.copyOf(objects, objectCounter + 1);
+            objects[objectCounter] = new DvbSubObjectDef();
+        }
+        objectCounter++;
+        ;
+        return objectCounter - 1; /* index of the created object */
+    }
+
+    public void parseSegments() {
+        int segmentId, pageId, size;
+        segmentId = tsStream.readBits(8);
+        switch (segmentId) {
+            case DVBSUB_ST_PAGE_COMPOSITION:
+                DvbSubPage tempPage = new DvbSubPage();
+                int pageid = parsePageSegment(tempPage);
+                if (pageid != -1) {
+                    checkAlreadyStoredPages(tempPage, pageid);
+                }
+                break;
+            case DVBSUB_ST_CLUT_DEFINITION:
+                DvbSubClut tempCLUT = new DvbSubClut();
+                int clutId = parseCLUTSegment(tempCLUT);
+                if (clutId != -1) {
+                    checkAlreadyStoredCLUT(tempCLUT, clutId);
+                }
+                break;
+            case DVBSUB_ST_DISPLAY_DEFINITION:
+                DvbSubDisplay tempDisplay = new DvbSubDisplay();
+                parseDDSegment(tempDisplay);
+                updateDisplay(tempDisplay);
+                break;
+            case DVBSUB_ST_REGION_COMPOSITION:
+                DvbSubRegion tempRegion = new DvbSubRegion();
+                int regionid = parseRegionSegment(tempRegion);
+                if (regionid != -1) {
+                    checkAlreadyStoredRegion(tempRegion, regionid);
+                }
+                break;
+            case DVBSUB_ST_OBJECT_DATA:
+                DvbSubObjectDef tempObject = new DvbSubObjectDef();
+                int objectId = parseObjectSegment(tempObject);
+                if (objectId != -1) {
+                    checkAlreadyStoredObject(tempObject, objectId);
+                }
+                break;
+            case DVBSUB_ST_ENDOFDISPLAY:
+                pageId = tsStream.readBits(16);
+                size = tsStream.readBits(16);
+                Log.d(TAG, "pageId " + pageId + "end of display size = " + size);
+                tsStream.skipBits(size * 8);
+                break;
+            case DVBSUB_ST_STUFFING:
+                pageId = tsStream.readBits(16);
+                size = tsStream.readBits(16);
+                Log.d(TAG, "pageId " + pageId + "stuffing size = " + size);
+                tsStream.skipBits(size * 8);
+                break;
+            default:
+                break;
+        }
+    }
+
+    private int parsePageSegment(DvbSubPage page) {
+        int processedBytes = 0;
+        int pageid = tsStream.readBits(16);
+        int segmentLength = tsStream.readBits(16);
+        page.id = pageid;
+        page.timeout = tsStream.readBits(8);
+        processedBytes++;
+        page.version = tsStream.readBits(4);
+        page.state = tsStream.readBits(2);
+        tsStream.skipBits(2);
+        processedBytes++;
+        int numOfBlocks = (segmentLength - processedBytes) / 6;
+        if (numOfBlocks == 0)
+            return -1;
+        page.pRegionDefs = new DvbSubRegionDef[numOfBlocks];
+        int count = 0;
+        while (processedBytes < segmentLength) {
+            page.pRegionDefs[count] = new DvbSubRegionDef();
+            page.pRegionDefs[count].id = tsStream.readBits(8);
+            tsStream.skipBits(8);
+            page.pRegionDefs[count].x = tsStream.readBits(16);
+            page.pRegionDefs[count].y = tsStream.readBits(16);
+            count++;
+            processedBytes += 6;
+        }
+        page.regionDefs = count;
+        return page.id;
+    }
+
+    private int parseCLUTSegment(DvbSubClut clut) {
+        int processedBytes = 0;
+        int pageid = tsStream.readBits(16);
+        int segmentLength = tsStream.readBits(16);
+        int id = tsStream.readBits(8);
+        int version = tsStream.readBits(4);
+
+        clut.version = version;
+        clut.id = id;
+        tsStream.skipBits(4);
+
+        processedBytes = 2;
+        while (processedBytes < segmentLength) {
+            byte y, cb, cr, t;
+            int id2, type;
+
+            id2 = tsStream.readBits(8);
+            type = tsStream.readBits(3);
+            tsStream.skipBits(4);
+            if (tsStream.readBit()) {
+                y = (byte) (tsStream.readBits(8));
+                cr = (byte) (tsStream.readBits(8));
+                cb = (byte) (tsStream.readBits(8));
+                t = (byte) (tsStream.readBits(8));
+                processedBytes += 6;
+            } else {
+                y = (byte) (tsStream.readBits(6) << 2);
+                cr = (byte) (tsStream.readBits(4) << 4);
+                cb = (byte) (tsStream.readBits(4) << 4);
+                t = (byte) (tsStream.readBits(2) << 6);
+                processedBytes += 4;
+            }
+            if (y == 0) {
+                cr = 0;
+                cb = 0;
+                t = (byte) 0xff;
+            }
+            if (((type & 0x04) == 4) && id2 < 4) {
+                clut.c2b[id2].Y = y;
+                clut.c2b[id2].Cr = cr;
+                clut.c2b[id2].Cb = cb;
+                clut.c2b[id2].T = t;
+            }
+            if (((type & 0x02) == 2) && id2 < 16) {
+                clut.c4b[id2].Y = y;
+                clut.c4b[id2].Cr = cr;
+                clut.c4b[id2].Cb = cb;
+                clut.c4b[id2].T = t;
+            }
+            if ((type & 0x01) == 1) {
+                clut.c8b[id2].Y = y;
+                clut.c8b[id2].Cr = cr;
+                clut.c8b[id2].Cb = cb;
+                clut.c8b[id2].T = t;
+            }
+        }
+        return clut.id;
+    }
+
+    private void parseDDSegment(DvbSubDisplay display) {
+        int pageid = tsStream.readBits(16);
+        int segmentLength = tsStream.readBits(16);
+        display.version = tsStream.readBits(4);
+        display.windowed = tsStream.readBits(1);
+        tsStream.skipBits(3);
+        display.width = tsStream.readBits(16);
+        displayWidth = display.width;
+        display.height = tsStream.readBits(16);
+        displayHeight = display.height;
+        if (display.windowed == 1) {
+            display.x = tsStream.readBits(16);
+            displayHorizontal = display.x;
+            display.maxX = tsStream.readBits(16);
+            display.y = tsStream.readBits(16);
+            displayVertical = display.y;
+            display.maxY = tsStream.readBits(16);
+        }
+        updateBitmapResolution();
+    }
+
+    private int parseRegionSegment(DvbSubRegion region) {
+        region.pageId = tsStream.readBits(16);
+        int segmentLength = tsStream.readBits(16);
+        region.id = tsStream.readBits(8);
+        region.version = tsStream.readBits(4);
+        region.b_fill_region = tsStream.readBits(1);
+        tsStream.skipBits(3);
+        region.width = tsStream.readBits(16);
+        region.height = tsStream.readBits(16);
+        region.levelComp = tsStream.readBits(3);
+        region.depth = tsStream.readBits(3);
+        tsStream.skipBits(2);
+        region.clut = tsStream.readBits(8);
+        tsStream.skipBits(16);
+        int count = 0;
+        int processedBytes = 10;
+        region.objectDefs = new DvbSubObjectDef[1];
+        region.objectDefs[0] = new DvbSubObjectDef();
+        count = 0;
+        while (processedBytes < segmentLength) {
+            if (count != 0) {
+                region.objectDefs = Arrays.copyOf(region.objectDefs, count + 1);
+            }
+            region.objectDefs[count] = new DvbSubObjectDef();
+            region.objectDefs[count].id = tsStream.readBits(16);
+            region.objectDefs[count].type = tsStream.readBits(2);
+            region.objectDefs[count].providerFlag = tsStream.readBits(2);
+            region.objectDefs[count].x = tsStream.readBits(12);
+            tsStream.skipBits(4);
+            region.objectDefs[count].y = tsStream.readBits(12);
+            processedBytes += 6;
+            if (region.objectDefs[count].type == 0x01 || region.objectDefs[count].type == 0x02) {
+                region.objectDefs[count].backgroundPC = tsStream.readBits(8);
+                region.objectDefs[count].foregroundPC = tsStream.readBits(8);
+                processedBytes += 2;
+            }
+            //Log.d(TAG, "Count regions = " + count + " x  = " + region.objectDefs[count].x
+            //+ " y = " + region.objectDefs[count].y);
+            count++;
+        }
+        region.numberOfObjectDefs = count;
+        return region.id;
+    }
+
+    private DvbSubRegion findRegion(int objectId, int pageid) {
+        int i;
+        for (i = 0; i < pages.length; i++) {
+            if (pages[i].id == pageid) {
+                int j;
+                for (j = 0; j < pages[i].regionDefs; j++) {
+                    if (regions[j].findObject(objectId) != -1) {
+                        break;
+                    }
+                }
+                if (j < pages[i].regionDefs) {
+                    return regions[j];
+                } else {
+                    return null;
+                }
+            }
+        }
+        return null;
+    }
+
+    private int parseObjectSegment(DvbSubObjectDef object) {
+        TestVal testVal;
+
+        int pageid = tsStream.readBits(16);
+        int segmentLength = tsStream.readBits(16);
+        object.id = tsStream.readBits(16);
+        object.version = tsStream.readBits(4);
+        object.codingMethod = tsStream.readBits(2);
+        object.nonModifyingColor = tsStream.readBits(1);
+        DvbSubRegion reg = findRegion(object.id, pageid);
+        int x = previousCoordX, y = previousCoordY;
+        if (reg != null) {
+            int objectIdx = reg.findObject(object.id);
+            int index = pageMapping.get(pageid);
+            if (index != -1) {
+                x = pages[index].pRegionDefs[reg.id].x + reg.objectDefs[objectIdx].x;
+                y = pages[index].pRegionDefs[reg.id].y + reg.objectDefs[objectIdx].y;
+            }
+        }
+        Point position = new Point(x, y);
+        previousCoordX = x;
+        previousCoordY = y;
+        tsStream.skipBits(1);
+        if (object.codingMethod == DVBSUB_OT_BASIC_CHAR || object.codingMethod == DVBSUB_OT_COMPOSITE_STRING) {
+       /* not implemented yet */
+        } else if (object.codingMethod == DVBSUB_OT_BASIC_BITMAP) {
+            object.topFieldDataLength = tsStream.readBits(16);
+            object.bottomFieldDataLength = tsStream.readBits(16);
+            int processedBytes = 7;
+            int totalCount = 0;
+            int topLimitBytes = processedBytes + object.topFieldDataLength;
+            int test = 0;
+            int totalBytes = 0;
+            while (processedBytes < topLimitBytes) {
+                testVal = pixelDataSubBlock(object.id, position);
+                processedBytes += testVal.bits / 8;
+                totalBytes += testVal.bits / 8;
+                if (testVal.count == 0) {
+                    position.x = x;
+                    position.y += 2;
+                }
+            }
+            topLimitBytes = processedBytes + object.bottomFieldDataLength;
+            totalBytes = 0;
+            position.x = x;
+            position.y = y;
+            position.y++;
+            while (processedBytes < topLimitBytes) {
+                testVal = pixelDataSubBlock(object.id, position);
+                processedBytes += testVal.bits / 8;
+                totalBytes += testVal.bits / 8;
+                if (testVal.count == 0) {
+                    position.x = x;
+                    position.y += 2;
+                }
+            }
+//            if (!wordAligned()){
+//                tsStream.skipBits(8); /* 8 '0' bits stuffing */
+//            }
+        }
+        return object.id;
+    }
+
+    class TestVal {
+        int count;
+        int bits;
+    }
+
+    private TestVal pixelDataSubBlock(int objectId, Point objectOrigin) {
+        TestVal testVal = new TestVal();
+        int bitsRead = tsStream.getPosition();
+        int dataType = tsStream.readBits(8);
+        switch (dataType) {
+            case DVBSUB_DT_2BP_CODE_STRING:
+                testVal.count = dvbSub2BitPixelCodeString(objectOrigin);
+                testVal.bits = tsStream.getPosition() - bitsRead;
+                break;
+            case DVBSUB_DT_4BP_CODE_STRING:
+                testVal.count = dvbSub4BitPixelCodeString(objectOrigin);
+                testVal.bits = tsStream.getPosition() - bitsRead;
+                break;
+            case DVBSUB_DT_8BP_CODE_STRING:
+                testVal.count = dvbSub8BitPixelCodeString(objectOrigin);
+                testVal.bits = tsStream.getPosition() - bitsRead;
+                break;
+            case DVBSUB_DT_24_TABLE_DATA:
+            case DVBSUB_DT_28_TABLE_DATA:
+            case DVBSUB_DT_48_TABLE_DATA:
+                break;
+            case DVBSUB_DT_END_LINE:
+                testVal.count = 0;
+                testVal.bits = tsStream.getPosition() - bitsRead;
+                break;
+        }
+        return testVal;
+    }
+
+    private int dvbSub2BitPixelCodeString(Point objectOrigin) {
+        int switchVal;
+        boolean stop = false;
+        int initialX = objectOrigin.x;
+        while (!stop) {
+            int count = 0;
+            int color = tsStream.readBits(2);
+            if (color != 0x00) {
+                count = 1;
+            } else {
+                switchVal = tsStream.readBits(1);
+                if (switchVal == 1) {
+                    count = 3 + tsStream.readBits(3);
+                    color = tsStream.readBits(2);
+                } else {
+                    switchVal = tsStream.readBits(1);
+                    if (switchVal == 0) {
+                        switchVal = tsStream.readBits(2);
+                        switch (switchVal) {
+                            case 0x00:
+                                stop = true;
+                                break;
+                            case 0x01:
+                                count = 2;
+                                break;
+                            case 0x02:
+                                count = 12 + tsStream.readBits(4);
+                                color = tsStream.readBits(2);
+                                break;
+                            case 0x03:
+                                count = 29 + tsStream.readBits(8);
+                                color = tsStream.readBits(2);
+                                break;
+                            default:
+                                break;
+                        }
+                    } else {
+                        count = 1;
+                    }
+                }
+            }
+            if (count == 0)
+                continue;
+            paintInCanvas(objectOrigin, count, color, 2);
+            objectOrigin.x += count;
+        }
+        return objectOrigin.x - initialX;
+    }
+
+    private int dvbSub4BitPixelCodeString(Point objectOrigin) {
+        int switchVal;
+        boolean stop = false;
+        int initialX = objectOrigin.x;
+        while (!stop) {
+            int count = 0;
+            int color = tsStream.readBits(4);
+            if (color != 0) {
+                count = 1;
+            } else {
+                if (tsStream.readBits(1) == 0x00) {
+                    switchVal = tsStream.readBits(3);
+                    if (switchVal != 0x00) {
+                        count = 2 + switchVal;
+                    } else {
+                        stop = true;
+                    }
+                } else {
+                    if (tsStream.readBits(1) == 0x00) {
+                        count = 4 + tsStream.readBits(2);
+                        color = tsStream.readBits(4);
+                    } else {
+                        switch (tsStream.readBits(2)) {
+                            case 0x00:
+                                count = 1;
+                                break;
+                            case 0x01:
+                                count = 2;
+                                break;
+                            case 0x02:
+                                count = 9 + tsStream.readBits(4);
+                                color = tsStream.readBits(4);
+                                break;
+                            case 0x03:
+                                count = 25 + tsStream.readBits(8);
+                                color = tsStream.readBits(4);
+                                break;
+                        }
+                    }
+                }
+            }
+            if (count == 0)
+                continue;
+            paintInCanvas(objectOrigin, count, color, 4);
+            objectOrigin.x += count;
+        }
+        alignTSStream();
+        return objectOrigin.x - initialX;
+    }
+
+    private int dvbSub8BitPixelCodeString(Point objectOrigin) {
+        boolean stop = false;
+        int initialX = objectOrigin.x;
+        int switchVal;
+        while (!stop) {
+            int count = 0;
+            int color = tsStream.readBits(8);
+            if (color != 0) {
+                count = 1;
+            } else {
+                if (tsStream.readBits(1) == 0x00) {
+                    switchVal = tsStream.readBits(7);
+                    if (switchVal != 0x00) {
+                        count = switchVal;
+                    } else {
+                        stop = true;
+                    }
+                } else {
+                    count = tsStream.readBits(7);
+                    color = tsStream.readBits(8);
+                }
+            }
+            if (count == 0)
+                continue;
+            paintInCanvas(objectOrigin, count, color, 8);
+            objectOrigin.x += count;
+        }
+        return objectOrigin.x - initialX;
+    }
+
+
+    public class Point {
+        int x;
+        int y;
+
+        public Point(int m, int n) {
+            x = m;
+            y = n;
+        }
+    }
+
+    public class RGBColor {
+        int r, g, b, a;
+    }
+
+    public RGBColor yuvToRGB(byte y, byte cb, byte cr, byte t) {
+        RGBColor color = new RGBColor();
+        color.r = clip(((298 * (y) + 409 * (cr + 128) + 128) >> 8) & 0xff);
+        color.g = clip(((298 * (y) - 100 * (cb + 128) - 208 * (cr + 128) + 128) >> 8) & 0xff);
+        color.b = clip(((298 * (y) + 516 * (cb + 128) + 128) >> 8) & 0xff);
+        color.a = 0xff - (t & 0xff);
+        return color;
+    }
+
+    public int clip(int val) {
+        if (val < 0) {
+            return 0;
+        } else if (val > 255) {
+            return 255;
+        } else {
+            return (val);
+        }
+    }
+
+    private void paintInCanvas(Point point, int count, int color, int bitDepth) {
+        RGBColor rgb = null;
+        switch (bitDepth) {
+            case 2:
+                rgb = yuvToRGB(cluts[0].c2b[color].Y, cluts[0].c2b[color].Cb, cluts[0].c2b[color].Cr, cluts[0].c2b[color].T);
+                break;
+            case 4:
+                rgb = yuvToRGB(cluts[0].c4b[color].Y, cluts[0].c4b[color].Cb, cluts[0].c4b[color].Cr, cluts[0].c4b[color].T);
+                break;
+            case 8:
+                rgb = yuvToRGB(cluts[0].c8b[color].Y, cluts[0].c8b[color].Cb, cluts[0].c8b[color].Cr, cluts[0].c8b[color].T);
+                break;
+        }
+        if (rgb == null)
+            return;
+        graphicsPaintObject.setARGB(rgb.a, rgb.r, rgb.g, rgb.b);
+        graphicsCanvasObject.drawLine(point.x, point.y, point.x + count, point.y, graphicsPaintObject);
+        newGraphicData = true;
+    }
+
+    private int alignTSStream() {
+        int skipBits = 8 - (tsStream.getPosition() % 8);
+        if (skipBits != 8) {
+            tsStream.skipBits(skipBits);
+            return skipBits;
+        }
+        return 0;
+    }
+
+    private boolean wordAligned() {
+        int bytePos = (tsStream.getPosition() - 1) / 8;
+        if (bytePos % 2 != 0) {
+            return false;
+        } else {
+            return true;
+        }
+    }
+
+    public DvbSubtitlesParser(Bitmap bitmap) {
+        dataCount = 0;
+        offset = 0;
+        displayCounter = 0;
+        clutCounter = 0;
+        objectCounter = 0;
+        regionCounter = 0;
+        pageCounter = 0;
+        numTSPackets = 0;
+        currentBitmap = 0;
+        pageMapping = new HashMap<Integer, Integer>(DVBSUB_MAX_OBJECTS_STORED);
+        regionMapping = new HashMap<Integer, Integer>(DVBSUB_MAX_OBJECTS_STORED);
+        objectMapping = new HashMap<Integer, Integer>(DVBSUB_MAX_OBJECTS_STORED);
+        graphicsPaintObject = new Paint();
+//   rendererState = new DvbSubsRendererState();
+        subsBitmap = new Bitmap[2];
+        displayWidth = 720;
+        displayHeight = 576;
+        updateBitmapResolution();
+        graphicsCanvasObject = new Canvas(subsBitmap[currentBitmap]);
+        newGraphicData = false;
+    }
+
+    public boolean canParse(String mimeType) {
+        return mimeType.equals(MimeTypes.APPLICATION_DVBSUBS);
+    }
+
+    public Bitmap dvbSubsDecode(byte[] input, int inputSize) {
+        if (input != null) {
+            tsStream = new ParsableBitArray(input);
+        } else {
+            return null;
+        }
+        if (tsStream.readBits(8) != 0x20) {
+            return null;
+        }
+        if (tsStream.readBits(8) != 0x00) {
+            return null;
+        }
+        int sync = tsStream.readBits(8);
+        while (sync == 0x0f || (sync == 0x00 && tsStream.readBits(8) == 0x0f)) {
+            parseSegments();
+            sync = tsStream.readBits(8);
+        }
+        if (sync == 0xff) {
+            //end of subtitle
+            if (newGraphicData) {
+                Log.d(TAG, "Reached end of subtitle");
+                newGraphicData = false;
+                Bitmap bitmap = subsBitmap[currentBitmap];
+                currentBitmap = (currentBitmap + 1) % 2;
+                graphicsCanvasObject = new Canvas(subsBitmap[currentBitmap]);
+                graphicsCanvasObject.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);
+                return bitmap;
+            } else {
+                Log.d(TAG, "Reached end of subtitle but no newGraphicData");
+                return null;
+            }
+        }
+        return null;
+    }
+
+    private void updateBitmapResolution() {
+        for (int i = 0; i < NUM_BITMAPS; i++) {
+            subsBitmap[i] = Bitmap.createBitmap(displayWidth, displayHeight, Bitmap.Config.ARGB_8888);
+        }
+    }
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java b/library/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java
index 0c8d9ef92e..2d345d2ff4 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java
@@ -18,7 +18,11 @@
 import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.res.Resources;
+import android.graphics.Bitmap;
 import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Rect;
+import android.graphics.RectF;
 import android.util.AttributeSet;
 import android.util.TypedValue;
 import android.view.View;
@@ -221,29 +225,44 @@ public void setBottomPaddingFraction(float bottomPaddingFraction) {
   @Override
   public void dispatchDraw(Canvas canvas) {
     int cueCount = (cues == null) ? 0 : cues.size();
-    int rawTop = getTop();
-    int rawBottom = getBottom();
 
-    // Calculate the bounds after padding is taken into account.
-    int left = getLeft() + getPaddingLeft();
-    int top = rawTop + getPaddingTop();
-    int right = getRight() + getPaddingRight();
-    int bottom = rawBottom - getPaddingBottom();
-    if (bottom <= top || right <= left) {
-      // No space to draw subtitles.
-      return;
-    }
+    if (cueCount > 0) {
+      Cue cue;
+      cue = cues.get(0);
+      if (cue.isGraphic) {
+        Bitmap subsBitmap = cue.bitmap;
+        if (subsBitmap == null) {
+          return;
+        }
+        Paint paint = new Paint(); // fixme default paint
+        Rect src = new Rect(0, 0, subsBitmap.getWidth(), subsBitmap.getHeight());
+        RectF dst = new RectF(0, 0, getWidth(), getHeight());
+        canvas.drawBitmap(subsBitmap, src, dst, paint);
+      } else {
+        int rawTop = getTop();
+        int rawBottom = getBottom();
 
-    float textSizePx = textSizeType == ABSOLUTE ? textSize
-        : textSize * (textSizeType == FRACTIONAL ? (bottom - top) : (rawBottom - rawTop));
-    if (textSizePx <= 0) {
-      // Text has no height.
-      return;
-    }
+        // Calculate the bounds after padding is taken into account.
+        int left = getLeft() + getPaddingLeft();
+        int top = rawTop + getPaddingTop();
+        int right = getRight() + getPaddingRight();
+        int bottom = rawBottom - getPaddingBottom();
+        if (bottom <= top || right <= left) {
+          // No space to draw subtitles.
+          return;
+        }
+        float textSizePx = textSizeType == ABSOLUTE ? textSize
+                : textSize * (textSizeType == FRACTIONAL ? (bottom - top) : (rawBottom - rawTop));
+        if (textSizePx <= 0) {
+          // Text has no height.
+          return;
+        }
 
-    for (int i = 0; i < cueCount; i++) {
-      painters.get(i).draw(cues.get(i), applyEmbeddedStyles, style, textSizePx,
-          bottomPaddingFraction, canvas, left, top, right, bottom);
+        for (int i = 0; i < cueCount; i++) {
+          painters.get(i).draw(cues.get(i), applyEmbeddedStyles, style, textSizePx,
+                  bottomPaddingFraction, canvas, left, top, right, bottom);
+        }
+      }
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java b/library/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
index a678d9487b..596857242b 100644
--- a/library/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
@@ -70,6 +70,7 @@
   public static final String APPLICATION_RAWCC = BASE_TYPE_APPLICATION + "/x-rawcc";
   public static final String APPLICATION_VOBSUB = BASE_TYPE_APPLICATION + "/vobsub";
   public static final String APPLICATION_PGS = BASE_TYPE_APPLICATION + "/pgs";
+  public static final String APPLICATION_DVBSUBS = BASE_TYPE_APPLICATION + "/dvbsubs";
 
   private MimeTypes() {}
 
