diff --git a/.github/ISSUE_TEMPLATE/bug.md b/.github/ISSUE_TEMPLATE/bug.md
index c0980df440..8824c9e8d8 100644
--- a/.github/ISSUE_TEMPLATE/bug.md
+++ b/.github/ISSUE_TEMPLATE/bug.md
@@ -55,8 +55,3 @@ Specify the absolute version number. Avoid using terms such as "latest".
 Specify the devices and versions of Android on which the issue can be
 reproduced, and how easily it reproduces. If possible, please test on multiple
 devices and Android versions.
-
-<!-- DO NOT DELETE
-validate_template=true
-template_path=.github/ISSUE_TEMPLATE/bug.md
--->
diff --git a/.github/ISSUE_TEMPLATE/content_not_playing.md b/.github/ISSUE_TEMPLATE/content_not_playing.md
index c8d4668a6a..91ddf725ce 100644
--- a/.github/ISSUE_TEMPLATE/content_not_playing.md
+++ b/.github/ISSUE_TEMPLATE/content_not_playing.md
@@ -51,8 +51,3 @@ log snippet is NOT sufficient. Please attach the captured bug report as a file.
 If you don't wish to post it publicly, please submit the issue, then email the
 bug report to dev.exoplayer@gmail.com using a subject in the format
 "Issue #1234", where "#1234" should be replaced with your issue number.
-
-<!-- DO NOT DELETE
-validate_template=true
-template_path=.github/ISSUE_TEMPLATE/content_not_playing.md
--->
diff --git a/.github/ISSUE_TEMPLATE/feature_request.md b/.github/ISSUE_TEMPLATE/feature_request.md
index d481de33ce..d660d0342a 100644
--- a/.github/ISSUE_TEMPLATE/feature_request.md
+++ b/.github/ISSUE_TEMPLATE/feature_request.md
@@ -28,8 +28,3 @@ A clear and concise description of your proposed solution, if you have one.
 ### Alternatives considered
 A clear and concise description of any alternative solutions you considered,
 if applicable.
-
-<!-- DO NOT DELETE
-validate_template=true
-template_path=.github/ISSUE_TEMPLATE/feature_request.md
--->
diff --git a/.github/ISSUE_TEMPLATE/question.md b/.github/ISSUE_TEMPLATE/question.md
index b5f40884d8..f3ad83b67d 100644
--- a/.github/ISSUE_TEMPLATE/question.md
+++ b/.github/ISSUE_TEMPLATE/question.md
@@ -48,8 +48,3 @@ dev.exoplayer@gmail.com using a subject in the format "Issue #1234", where
 "#1234" should be replaced with your issue number. Provide all the metadata we'd
 need to play the content like drm license urls or similar. If the content is
 accessible only in certain countries or regions, please say so.
-
-<!-- DO NOT DELETE
-validate_template=true
-template_path=.github/ISSUE_TEMPLATE/question.md
--->
diff --git a/.gitignore b/.gitignore
index 4731d5ba99..2ec73a6fd8 100644
--- a/.gitignore
+++ b/.gitignore
@@ -71,7 +71,3 @@ extensions/cronet/jniLibs/*
 !extensions/cronet/jniLibs/README.md
 extensions/cronet/libs/*
 !extensions/cronet/libs/README.md
-
-# Cast receiver
-cast_receiver_app/external-js
-cast_receiver_app/bazel-cast_receiver_app
diff --git a/.hgignore b/.hgignore
index 36d3268005..5889f43b8d 100644
--- a/.hgignore
+++ b/.hgignore
@@ -12,13 +12,14 @@ libs
 obj
 lint.xml
 
-# IntelliJ IDEA
+# IntelliJ IDEA & Android Studio
 .idea
 *.iml
 *.ipr
 *.iws
 classes
 gen-external-apklibs
+*.li
 
 # Eclipse
 .project
@@ -75,7 +76,3 @@ extensions/cronet/jniLibs/*
 !extensions/cronet/jniLibs/README.md
 extensions/cronet/libs/*
 !extensions/cronet/libs/README.md
-
-# Cast receiver
-cast_receiver_app/external-js
-cast_receiver_app/bazel-cast_receiver_app
diff --git a/README.md b/README.md
index a369b077f4..d488f4113e 100644
--- a/README.md
+++ b/README.md
@@ -107,6 +107,7 @@ branch:
 
 ```sh
 git clone https://github.com/google/ExoPlayer.git
+cd ExoPlayer
 git checkout release-v2
 ```
 
diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 470a665030..77edbd468f 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -2,10 +2,33 @@
 
 ### dev-v2 (not yet released) ###
 
-* Fix transitions between packed audio and non-packed audio segments in HLS
-  ([#6444](https://github.com/google/ExoPlayer/issues/6444)).
-* DASH: Support negative @r values in segment timelines
-  ([#1787](https://github.com/google/ExoPlayer/issues/1787)).
+* UI
+  * Setting `app:played_color` on `PlayerView` and `PlayerControlView` no longer
+    adjusts the colors of the scrubber handle , buffered and unplayed parts of
+    the time bar. These can be set separately using `app:scrubber_color`,
+    `app:buffered_color` and `app_unplayed_color` respectively.
+  * Setting `app:ad_marker_color` on `PlayerView` and `PlayerControlView` no
+    longer adjusts the color of played ad markers. The color of played ad
+    markers can be set separately using `app:played_ad_marker_color`
+* DRM:
+  * Inject `DrmSessionManager` into the `MediaSources` instead of `Renderers`
+    ([#5619](https://github.com/google/ExoPlayer/issues/5619)).
+  * Add a `DefaultDrmSessionManager.Builder`.
+  * Add support for the use of secure decoders in clear sections of content
+    ([#4867](https://github.com/google/ExoPlayer/issues/4867)).
+  * Add basic DRM support to the Cast demo app.
+  * Add support for custom `LoadErrorHandlingPolicies` in key and provisioning
+    requests ([#6334](https://github.com/google/ExoPlayer/issues/6334)).
+  * Remove `DefaultDrmSessionManager` factory methods that leak `ExoMediaDrm`
+    instances ([#4721](https://github.com/google/ExoPlayer/issues/4721)).
+* Remove the `DataSpec.FLAG_ALLOW_ICY_METADATA` flag. Instead, set the header
+  `IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_NAME` in the `DataSpec`
+  `httpRequestHeaders`.
+* DASH:
+  * Support negative @r values in segment timelines
+    ([#1787](https://github.com/google/ExoPlayer/issues/1787)).
+  * Support `Label` elements
+    ([#6297](https://github.com/google/ExoPlayer/issues/6297)).
 * Add `allowedCapturePolicy` field to `AudioAttributes` wrapper to allow to
   opt-out of audio recording.
 * Add `DataSpec.httpRequestHeaders` to set HTTP request headers when connecting
@@ -15,13 +38,12 @@
 * Bypass sniffing in `ProgressiveMediaPeriod` in case a single extractor is
   provided ([#6325](https://github.com/google/ExoPlayer/issues/6325)).
 * Surface information provided by methods `isHardwareAccelerated`,
-  `isSoftwareOnly` and `isVendor` added in Android Q in `MediaCodecInfo` class
+  `isSoftwareOnly` and `isVendor` added in Android 10 in `MediaCodecInfo` class
   ([#5839](https://github.com/google/ExoPlayer/issues/5839)).
 * Update `DefaultTrackSelector` to apply a viewport constraint for the default
   display by default.
 * Add `PlaybackStatsListener` to collect `PlaybackStats` for playbacks analysis
   and analytics reporting (TODO: link to developer guide page/blog post).
-* Add basic DRM support to the Cast demo app.
 * Assume that encrypted content requires secure decoders in renderer support
   checks ([#5568](https://github.com/google/ExoPlayer/issues/5568)).
 * Decoders: Prefer decoders that advertise format support over ones that do not,
@@ -35,7 +57,7 @@
   `SourceInfoRefreshListener` anymore. Instead make it accessible through
   `Player.getCurrentManifest()` and `Timeline.Window.manifest`. Also rename
   `SourceInfoRefreshListener` to `MediaSourceCaller`.
-* Set `compileSdkVersion` to 29 to use Android Q APIs.
+* Set `compileSdkVersion` to 29 to use Android 10 APIs.
 * Add `enable` and `disable` methods to `MediaSource` to improve resource
   management in playlists.
 * Text selection logic:
@@ -47,8 +69,6 @@
   the `Player` set later using `AnalyticsCollector.setPlayer`.
 * Replace `ExoPlayerFactory` by `SimpleExoPlayer.Builder` and
   `ExoPlayer.Builder`.
-* Inject `DrmSessionManager` into the `MediaSources` instead of `Renderers`
-  ([#5619](https://github.com/google/ExoPlayer/issues/5619)).
 * Fix issue where player errors are thrown too early at playlist transitions
   ([#5407](https://github.com/google/ExoPlayer/issues/5407)).
 * Deprecate `setTag` parameter of `Timeline.getWindow`. Tags will always be set.
@@ -61,6 +81,28 @@
 * Fix Dolby Vision fallback to AVC and HEVC.
 * Add top-level playlist API
   ([#6161](https://github.com/google/ExoPlayer/issues/6161)).
+* Add demo app to show how to use the Android 10 `SurfaceControl` API with
+  ExoPlayer ([#677](https://github.com/google/ExoPlayer/issues/677)).
+* Add automatic `WakeLock` handling to `SimpleExoPlayer` through calling
+  `setEnableWakeLock`, which requires the
+  `android.Manifest.permission#WAKE_LOCK` permission
+  ([#5846](https://github.com/google/ExoPlayer/issues/5846)).
+* Add `Player.onPlaybackSuppressionReasonChanged` to allow listeners to
+  detect playbacks suppressions (e.g. audio focus loss) directly
+  ([#6203](https://github.com/google/ExoPlayer/issues/6203)).
+* VP9 extension:
+  * Rename `VpxVideoSurfaceView` to `VideoDecoderSurfaceView`
+    and move it to the core library.
+  * Move `LibvpxVideoRenderer.MSG_SET_OUTPUT_BUFFER_RENDERER` to
+    `C.MSG_SET_OUTPUT_BUFFER_RENDERER`.
+* Add `Timeline.Window.isLive` to indicate that a window is a live stream
+  ([#2668](https://github.com/google/ExoPlayer/issues/2668) and
+  [#5973](https://github.com/google/ExoPlayer/issues/5973)).
+* Expose the raw ICY metadata through `IcyInfo`
+  ([#6476](https://github.com/google/ExoPlayer/issues/6476)).
+* Fail more explicitly when local-file Uris contain invalid parts (e.g.
+  fragment) ([#6470](https://github.com/google/ExoPlayer/issues/6470)).
+* Add `MediaPeriod.isLoading` to improve `Player.isLoading` state.
 
 ### 2.10.5 (2019-09-20) ###
 
@@ -88,6 +130,8 @@
   * Support unwrapping of nested metadata (e.g. ID3 and SCTE-35 in EMSG).
 * Add `HttpDataSource.getResponseCode` to provide the status code associated
   with the most recent HTTP response.
+* Fix transitions between packed audio and non-packed audio segments in HLS
+  ([#6444](https://github.com/google/ExoPlayer/issues/6444)).
 * Fix issue where a request would be retried after encountering an error, even
   though the `LoadErrorHandlingPolicy` classified the error as fatal.
 * Fix initialization data handling for FLAC in MP4
diff --git a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/PlayerManager.java b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/PlayerManager.java
index b1a12f6bc9..894012664c 100644
--- a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/PlayerManager.java
+++ b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/PlayerManager.java
@@ -29,10 +29,9 @@
 import com.google.android.exoplayer2.Timeline.Period;
 import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
-import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
+import com.google.android.exoplayer2.drm.ExoMediaCrypto;
 import com.google.android.exoplayer2.drm.FrameworkMediaDrm;
 import com.google.android.exoplayer2.drm.HttpMediaDrmCallback;
-import com.google.android.exoplayer2.drm.UnsupportedDrmException;
 import com.google.android.exoplayer2.ext.cast.CastPlayer;
 import com.google.android.exoplayer2.ext.cast.DefaultMediaItemConverter;
 import com.google.android.exoplayer2.ext.cast.MediaItem;
@@ -54,7 +53,6 @@
 import com.google.android.gms.cast.MediaQueueItem;
 import com.google.android.gms.cast.framework.CastContext;
 import java.util.ArrayList;
-import java.util.IdentityHashMap;
 import java.util.Map;
 
 /** Manages players and an internal media queue for the demo app. */
@@ -87,7 +85,6 @@
   private final Listener listener;
   private final ConcatenatingMediaSource concatenatingMediaSource;
   private final MediaItemConverter mediaItemConverter;
-  private final IdentityHashMap<MediaSource, FrameworkMediaDrm> mediaDrms;
 
   private TrackGroupArray lastSeenTrackGroupArray;
   private int currentItemIndex;
@@ -115,7 +112,6 @@ public PlayerManager(
     currentItemIndex = C.INDEX_UNSET;
     concatenatingMediaSource = new ConcatenatingMediaSource();
     mediaItemConverter = new DefaultMediaItemConverter();
-    mediaDrms = new IdentityHashMap<>();
 
     trackSelector = new DefaultTrackSelector(context);
     exoPlayer = new SimpleExoPlayer.Builder(context).setTrackSelector(trackSelector).build();
@@ -185,8 +181,7 @@ public boolean removeItem(MediaItem item) {
     if (itemIndex == -1) {
       return false;
     }
-    MediaSource removedMediaSource = concatenatingMediaSource.removeMediaSource(itemIndex);
-    releaseMediaDrmOfMediaSource(removedMediaSource);
+    concatenatingMediaSource.removeMediaSource(itemIndex);
     if (currentPlayer == castPlayer) {
       if (castPlayer.getPlaybackState() != Player.STATE_IDLE) {
         Timeline castTimeline = castPlayer.getCurrentTimeline();
@@ -262,9 +257,6 @@ public void release() {
     currentItemIndex = C.INDEX_UNSET;
     mediaQueue.clear();
     concatenatingMediaSource.clear();
-    for (FrameworkMediaDrm mediaDrm : mediaDrms.values()) {
-      mediaDrm.release();
-    }
     castPlayer.setSessionAvailabilityListener(null);
     castPlayer.release();
     localPlayerView.setPlayer(null);
@@ -413,8 +405,7 @@ private MediaSource buildMediaSource(MediaItem item) {
       throw new IllegalArgumentException("mimeType is required");
     }
 
-    FrameworkMediaDrm mediaDrm = null;
-    DrmSessionManager<FrameworkMediaCrypto> drmSessionManager =
+    DrmSessionManager<ExoMediaCrypto> drmSessionManager =
         DrmSessionManager.getDummyDrmSessionManager();
     MediaItem.DrmConfiguration drmConfiguration = item.drmConfiguration;
     if (drmConfiguration != null) {
@@ -425,18 +416,12 @@ private MediaSource buildMediaSource(MediaItem item) {
       for (Map.Entry<String, String> requestHeader : drmConfiguration.requestHeaders.entrySet()) {
         drmCallback.setKeyRequestProperty(requestHeader.getKey(), requestHeader.getValue());
       }
-      try {
-        mediaDrm = FrameworkMediaDrm.newInstance(drmConfiguration.uuid);
-        drmSessionManager =
-            new DefaultDrmSessionManager<>(
-                drmConfiguration.uuid,
-                mediaDrm,
-                drmCallback,
-                /* optionalKeyRequestParameters= */ null,
-                /* multiSession= */ true);
-      } catch (UnsupportedDrmException e) {
-        // Do nothing. The track selector will avoid selecting the DRM protected tracks.
-      }
+      drmSessionManager =
+          new DefaultDrmSessionManager.Builder()
+              .setMultiSession(/* multiSession= */ true)
+              .setUuidAndExoMediaDrmProvider(
+                  drmConfiguration.uuid, FrameworkMediaDrm.DEFAULT_PROVIDER)
+              .build(drmCallback);
     }
 
     MediaSource createdMediaSource;
@@ -468,16 +453,6 @@ private MediaSource buildMediaSource(MediaItem item) {
       default:
         throw new IllegalArgumentException("mimeType is unsupported: " + mimeType);
     }
-    if (mediaDrm != null) {
-      mediaDrms.put(createdMediaSource, mediaDrm);
-    }
     return createdMediaSource;
   }
-
-  private void releaseMediaDrmOfMediaSource(MediaSource mediaSource) {
-    FrameworkMediaDrm mediaDrmToRelease = mediaDrms.remove(mediaSource);
-    if (mediaDrmToRelease != null) {
-      mediaDrmToRelease.release();
-    }
-  }
 }
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
index a9d1db64ad..1dc56bfbc9 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
@@ -17,6 +17,7 @@
 
 import android.content.Intent;
 import android.content.pm.PackageManager;
+import android.media.MediaDrm;
 import android.net.Uri;
 import android.os.Bundle;
 import android.util.Pair;
@@ -40,15 +41,16 @@
 import com.google.android.exoplayer2.demo.Sample.UriSample;
 import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
-import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
+import com.google.android.exoplayer2.drm.ExoMediaCrypto;
 import com.google.android.exoplayer2.drm.FrameworkMediaDrm;
 import com.google.android.exoplayer2.drm.HttpMediaDrmCallback;
-import com.google.android.exoplayer2.drm.UnsupportedDrmException;
+import com.google.android.exoplayer2.drm.MediaDrmCallback;
 import com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.DecoderInitializationException;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer2.offline.DownloadHelper;
 import com.google.android.exoplayer2.offline.DownloadRequest;
 import com.google.android.exoplayer2.source.BehindLiveWindowException;
+import com.google.android.exoplayer2.source.ConcatenatingMediaSource;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.MediaSourceFactory;
 import com.google.android.exoplayer2.source.ProgressiveMediaSource;
@@ -77,9 +79,6 @@
 import java.net.CookieHandler;
 import java.net.CookieManager;
 import java.net.CookiePolicy;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.UUID;
 
 /** An activity that plays media using {@link SimpleExoPlayer}. */
 public class PlayerActivity extends AppCompatActivity
@@ -131,8 +130,6 @@
     DEFAULT_COOKIE_MANAGER.setCookiePolicy(CookiePolicy.ACCEPT_ORIGINAL_SERVER);
   }
 
-  private final ArrayList<FrameworkMediaDrm> mediaDrms;
-
   private PlayerView playerView;
   private LinearLayout debugRootView;
   private Button selectTracksButton;
@@ -141,7 +138,7 @@
 
   private DataSource.Factory dataSourceFactory;
   private SimpleExoPlayer player;
-  private List<MediaSource> mediaSources;
+  private MediaSource mediaSource;
   private DefaultTrackSelector trackSelector;
   private DefaultTrackSelector.Parameters trackSelectorParameters;
   private DebugTextViewHelper debugViewHelper;
@@ -156,10 +153,6 @@
   private AdsLoader adsLoader;
   private Uri loadedAdTagUri;
 
-  public PlayerActivity() {
-    mediaDrms = new ArrayList<>();
-  }
-
   // Activity lifecycle
 
   @Override
@@ -342,9 +335,8 @@ private void initializePlayer() {
     if (player == null) {
       Intent intent = getIntent();
 
-      releaseMediaDrms();
-      mediaSources = createTopLevelMediaSources(intent);
-      if (mediaSources.isEmpty()) {
+      mediaSource = createTopLevelMediaSource(intent);
+      if (mediaSource == null) {
         return;
       }
 
@@ -388,12 +380,12 @@ private void initializePlayer() {
     if (haveStartPosition) {
       player.seekTo(startWindow, startPosition);
     }
-    player.setMediaItems(mediaSources, /* resetPosition= */ !haveStartPosition);
-    player.prepare();
+    player.prepare(mediaSource, !haveStartPosition, false);
     updateButtonVisibility();
   }
 
-  private List<MediaSource> createTopLevelMediaSources(Intent intent) {
+  @Nullable
+  private MediaSource createTopLevelMediaSource(Intent intent) {
     String action = intent.getAction();
     boolean actionIsListView = ACTION_VIEW_LIST.equals(action);
     if (!actionIsListView && !ACTION_VIEW.equals(action)) {
@@ -421,65 +413,60 @@ private void initializePlayer() {
       }
     }
 
-    List<MediaSource> mediaSources = new ArrayList<>();
-    for (UriSample sample : samples) {
-      mediaSources.add(createLeafMediaSource(sample));
+    MediaSource[] mediaSources = new MediaSource[samples.length];
+    for (int i = 0; i < samples.length; i++) {
+      mediaSources[i] = createLeafMediaSource(samples[i]);
     }
-    if (seenAdsTagUri && mediaSources.size() == 1) {
+    MediaSource mediaSource =
+        mediaSources.length == 1 ? mediaSources[0] : new ConcatenatingMediaSource(mediaSources);
+
+    if (seenAdsTagUri) {
       Uri adTagUri = samples[0].adTagUri;
-      if (!adTagUri.equals(loadedAdTagUri)) {
-        releaseAdsLoader();
-        loadedAdTagUri = adTagUri;
-      }
-      MediaSource adsMediaSource = createAdsMediaSource(mediaSources.get(0), adTagUri);
-      if (adsMediaSource != null) {
-        mediaSources.set(0, adsMediaSource);
+      if (actionIsListView) {
+        showToast(R.string.unsupported_ads_in_concatenation);
       } else {
-        showToast(R.string.ima_not_loaded);
+        if (!adTagUri.equals(loadedAdTagUri)) {
+          releaseAdsLoader();
+          loadedAdTagUri = adTagUri;
+        }
+        MediaSource adsMediaSource = createAdsMediaSource(mediaSource, adTagUri);
+        if (adsMediaSource != null) {
+          mediaSource = adsMediaSource;
+        } else {
+          showToast(R.string.ima_not_loaded);
+        }
       }
-    } else if (seenAdsTagUri && mediaSources.size() > 1) {
-      showToast(R.string.unsupported_ads_in_concatenation);
-      releaseAdsLoader();
     } else {
       releaseAdsLoader();
     }
 
-    return mediaSources;
+    return mediaSource;
   }
 
   private MediaSource createLeafMediaSource(UriSample parameters) {
-    DrmSessionManager<FrameworkMediaCrypto> drmSessionManager = null;
     Sample.DrmInfo drmInfo = parameters.drmInfo;
-    if (drmInfo != null) {
-      int errorStringId = R.string.error_drm_unknown;
-      if (Util.SDK_INT < 18) {
-        errorStringId = R.string.error_drm_not_supported;
-      } else {
-        try {
-          if (drmInfo.drmScheme == null) {
-            errorStringId = R.string.error_drm_unsupported_scheme;
-          } else {
-            drmSessionManager =
-                buildDrmSessionManagerV18(
-                    drmInfo.drmScheme,
-                    drmInfo.drmLicenseUrl,
-                    drmInfo.drmKeyRequestProperties,
-                    drmInfo.drmMultiSession);
-          }
-        } catch (UnsupportedDrmException e) {
-          errorStringId =
-              e.reason == UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME
-                  ? R.string.error_drm_unsupported_scheme
-                  : R.string.error_drm_unknown;
-        }
-      }
-      if (drmSessionManager == null) {
-        showToast(errorStringId);
-        finish();
-        return null;
-      }
-    } else {
+    int errorStringId = R.string.error_drm_unknown;
+    DrmSessionManager<ExoMediaCrypto> drmSessionManager = null;
+    if (drmInfo == null) {
       drmSessionManager = DrmSessionManager.getDummyDrmSessionManager();
+    } else if (Util.SDK_INT < 18) {
+      errorStringId = R.string.error_drm_unsupported_before_api_18;
+    } else if (!MediaDrm.isCryptoSchemeSupported(drmInfo.drmScheme)) {
+      errorStringId = R.string.error_drm_unsupported_scheme;
+    } else {
+      MediaDrmCallback mediaDrmCallback =
+          createMediaDrmCallback(drmInfo.drmLicenseUrl, drmInfo.drmKeyRequestProperties);
+      drmSessionManager =
+          new DefaultDrmSessionManager.Builder()
+              .setUuidAndExoMediaDrmProvider(drmInfo.drmScheme, FrameworkMediaDrm.DEFAULT_PROVIDER)
+              .setMultiSession(drmInfo.drmMultiSession)
+              .build(mediaDrmCallback);
+    }
+
+    if (drmSessionManager == null) {
+      showToast(errorStringId);
+      finish();
+      return null;
     }
 
     DownloadRequest downloadRequest =
@@ -493,7 +480,7 @@ private MediaSource createLeafMediaSource(UriSample parameters) {
   }
 
   private MediaSource createLeafMediaSource(
-      Uri uri, String extension, DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
+      Uri uri, String extension, DrmSessionManager<ExoMediaCrypto> drmSessionManager) {
     @ContentType int type = Util.inferContentType(uri, extension);
     switch (type) {
       case C.TYPE_DASH:
@@ -517,9 +504,8 @@ private MediaSource createLeafMediaSource(
     }
   }
 
-  private DefaultDrmSessionManager<FrameworkMediaCrypto> buildDrmSessionManagerV18(
-      UUID uuid, String licenseUrl, String[] keyRequestPropertiesArray, boolean multiSession)
-      throws UnsupportedDrmException {
+  private HttpMediaDrmCallback createMediaDrmCallback(
+      String licenseUrl, String[] keyRequestPropertiesArray) {
     HttpDataSource.Factory licenseDataSourceFactory =
         ((DemoApplication) getApplication()).buildHttpDataSourceFactory();
     HttpMediaDrmCallback drmCallback =
@@ -530,10 +516,7 @@ private MediaSource createLeafMediaSource(
             keyRequestPropertiesArray[i + 1]);
       }
     }
-
-    FrameworkMediaDrm mediaDrm = FrameworkMediaDrm.newInstance(uuid);
-    mediaDrms.add(mediaDrm);
-    return new DefaultDrmSessionManager<>(uuid, mediaDrm, drmCallback, null, multiSession);
+    return drmCallback;
   }
 
   private void releasePlayer() {
@@ -544,20 +527,12 @@ private void releasePlayer() {
       debugViewHelper = null;
       player.release();
       player = null;
-      mediaSources = null;
+      mediaSource = null;
       trackSelector = null;
     }
     if (adsLoader != null) {
       adsLoader.setPlayer(null);
     }
-    releaseMediaDrms();
-  }
-
-  private void releaseMediaDrms() {
-    for (FrameworkMediaDrm mediaDrm : mediaDrms) {
-      mediaDrm.release();
-    }
-    mediaDrms.clear();
   }
 
   private void releaseAdsLoader() {
diff --git a/demos/main/src/main/res/values/strings.xml b/demos/main/src/main/res/values/strings.xml
index f74ce8c076..c39fffa65d 100644
--- a/demos/main/src/main/res/values/strings.xml
+++ b/demos/main/src/main/res/values/strings.xml
@@ -29,7 +29,7 @@
 
   <string name="error_unrecognized_stereo_mode">Unrecognized stereo mode</string>
 
-  <string name="error_drm_not_supported">Protected content not supported on API levels below 18</string>
+  <string name="error_drm_unsupported_before_api_18">Protected content not supported on API levels below 18</string>
 
   <string name="error_drm_unsupported_scheme">This device does not support the required DRM scheme</string>
 
diff --git a/demos/surface/README.md b/demos/surface/README.md
new file mode 100644
index 0000000000..312259dbf6
--- /dev/null
+++ b/demos/surface/README.md
@@ -0,0 +1,21 @@
+# ExoPlayer SurfaceControl demo
+
+This app demonstrates how to use the [SurfaceControl][] API to redirect video
+output from ExoPlayer between different views or off-screen. `SurfaceControl`
+is new in Android 10, so the app requires `minSdkVersion` 29.
+
+The app layout has a grid of `SurfaceViews`. Initially video is output to one
+of the views. Tap a `SurfaceView` to move video output to it. You can also tap
+the buttons at the top of the activity to move video output off-screen, to a
+full-screen `SurfaceView` or to a new activity.
+
+When using `SurfaceControl`, the `MediaCodec` always has the same surface
+attached to it, which can be freely 'reparented' to any `SurfaceView` (or
+off-screen) without any interruptions to playback. This works better than
+calling `MediaCodec.setOutputSurface` to change the output surface of the codec
+because `MediaCodec` does not re-render its last frame when that method is
+called, and because you can move output off-screen easily (`setOutputSurface`
+can't take a `null` surface, so the player has to use a `DummySurface`, which
+doesn't handle protected output on all devices).
+
+[SurfaceControl]: https://developer.android.com/reference/android/view/SurfaceControl
diff --git a/demos/surface/build.gradle b/demos/surface/build.gradle
new file mode 100644
index 0000000000..1f653f160e
--- /dev/null
+++ b/demos/surface/build.gradle
@@ -0,0 +1,51 @@
+// Copyright (C) 2019 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+apply from: '../../constants.gradle'
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion project.ext.compileSdkVersion
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
+    defaultConfig {
+        versionName project.ext.releaseVersion
+        versionCode project.ext.releaseVersionCode
+        minSdkVersion 29
+        targetSdkVersion 29
+    }
+
+    buildTypes {
+        release {
+            shrinkResources true
+            minifyEnabled true
+            proguardFiles getDefaultProguardFile('proguard-android.txt')
+        }
+    }
+
+    lintOptions {
+        // This demo app does not have translations.
+        disable 'MissingTranslation'
+    }
+}
+
+dependencies {
+    implementation project(modulePrefix + 'library-core')
+    implementation project(modulePrefix + 'library-ui')
+    implementation project(modulePrefix + 'library-dash')
+    implementation 'androidx.annotation:annotation:' + androidxAnnotationVersion
+}
diff --git a/demos/surface/src/main/AndroidManifest.xml b/demos/surface/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..c33a9e646b
--- /dev/null
+++ b/demos/surface/src/main/AndroidManifest.xml
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.google.android.exoplayer2.surfacedemo">
+  <uses-sdk/>
+  <uses-permission android:name="android.permission.INTERNET"/>
+  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
+  <application
+    android:allowBackup="false"
+    android:icon="@mipmap/ic_launcher"
+    android:label="@string/application_name">
+    <activity android:name=".MainActivity">
+      <intent-filter>
+        <action android:name="android.intent.action.MAIN"/>
+        <category android:name="android.intent.category.LAUNCHER"/>
+      </intent-filter>
+      <intent-filter>
+        <action android:name="com.google.android.exoplayer.surfacedemo.action.VIEW"/>
+        <category android:name="android.intent.category.DEFAULT"/>
+        <data android:scheme="http"/>
+        <data android:scheme="https"/>
+        <data android:scheme="content"/>
+        <data android:scheme="asset"/>
+        <data android:scheme="file"/>
+      </intent-filter>
+    </activity>
+  </application>
+</manifest>
diff --git a/demos/surface/src/main/java/com/google/android/exoplayer2/surfacedemo/MainActivity.java b/demos/surface/src/main/java/com/google/android/exoplayer2/surfacedemo/MainActivity.java
new file mode 100644
index 0000000000..ca011434ac
--- /dev/null
+++ b/demos/surface/src/main/java/com/google/android/exoplayer2/surfacedemo/MainActivity.java
@@ -0,0 +1,282 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.surfacedemo;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Bundle;
+import android.view.Surface;
+import android.view.SurfaceControl;
+import android.view.SurfaceHolder;
+import android.view.SurfaceView;
+import android.view.View;
+import android.widget.Button;
+import android.widget.GridLayout;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.SimpleExoPlayer;
+import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
+import com.google.android.exoplayer2.drm.DrmSessionManager;
+import com.google.android.exoplayer2.drm.ExoMediaCrypto;
+import com.google.android.exoplayer2.drm.FrameworkMediaDrm;
+import com.google.android.exoplayer2.drm.HttpMediaDrmCallback;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.ProgressiveMediaSource;
+import com.google.android.exoplayer2.source.dash.DashMediaSource;
+import com.google.android.exoplayer2.ui.PlayerControlView;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
+import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
+import com.google.android.exoplayer2.upstream.HttpDataSource;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
+import java.util.UUID;
+
+/** Activity that demonstrates use of {@link SurfaceControl} with ExoPlayer. */
+public final class MainActivity extends Activity {
+
+  private static final String DEFAULT_MEDIA_URI =
+      "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv";
+  private static final String SURFACE_CONTROL_NAME = "surfacedemo";
+
+  private static final String ACTION_VIEW = "com.google.android.exoplayer.surfacedemo.action.VIEW";
+  private static final String EXTENSION_EXTRA = "extension";
+  private static final String DRM_SCHEME_EXTRA = "drm_scheme";
+  private static final String DRM_LICENSE_URL_EXTRA = "drm_license_url";
+  private static final String OWNER_EXTRA = "owner";
+
+  private boolean isOwner;
+  @Nullable private PlayerControlView playerControlView;
+  @Nullable private SurfaceView fullScreenView;
+  @Nullable private SurfaceView nonFullScreenView;
+  @Nullable private SurfaceView currentOutputView;
+
+  @Nullable private static SimpleExoPlayer player;
+  @Nullable private static SurfaceControl surfaceControl;
+  @Nullable private static Surface videoSurface;
+
+  @Override
+  protected void onCreate(@Nullable Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    setContentView(R.layout.main_activity);
+    playerControlView = findViewById(R.id.player_control_view);
+    fullScreenView = findViewById(R.id.full_screen_view);
+    fullScreenView.setOnClickListener(
+        v -> {
+          setCurrentOutputView(nonFullScreenView);
+          Assertions.checkNotNull(fullScreenView).setVisibility(View.GONE);
+        });
+    attachSurfaceListener(fullScreenView);
+    isOwner = getIntent().getBooleanExtra(OWNER_EXTRA, /* defaultValue= */ true);
+    GridLayout gridLayout = findViewById(R.id.grid_layout);
+    for (int i = 0; i < 9; i++) {
+      View view;
+      if (i == 0) {
+        Button button = new Button(/* context= */ this);
+        view = button;
+        button.setText(getString(R.string.no_output_label));
+        button.setOnClickListener(v -> reparent(/* surfaceView= */ null));
+      } else if (i == 1) {
+        Button button = new Button(/* context= */ this);
+        view = button;
+        button.setText(getString(R.string.full_screen_label));
+        button.setOnClickListener(
+            v -> {
+              setCurrentOutputView(fullScreenView);
+              Assertions.checkNotNull(fullScreenView).setVisibility(View.VISIBLE);
+            });
+      } else if (i == 2) {
+        Button button = new Button(/* context= */ this);
+        view = button;
+        button.setText(getString(R.string.new_activity_label));
+        button.setOnClickListener(
+            v ->
+                startActivity(
+                    new Intent(MainActivity.this, MainActivity.class)
+                        .putExtra(OWNER_EXTRA, /* value= */ false)));
+      } else {
+        SurfaceView surfaceView = new SurfaceView(this);
+        view = surfaceView;
+        attachSurfaceListener(surfaceView);
+        surfaceView.setOnClickListener(
+            v -> {
+              setCurrentOutputView(surfaceView);
+              nonFullScreenView = surfaceView;
+            });
+        if (nonFullScreenView == null) {
+          nonFullScreenView = surfaceView;
+        }
+      }
+      gridLayout.addView(view);
+      GridLayout.LayoutParams layoutParams = new GridLayout.LayoutParams();
+      layoutParams.width = 400;
+      layoutParams.height = 400;
+      layoutParams.columnSpec = GridLayout.spec(i % 3);
+      layoutParams.rowSpec = GridLayout.spec(i / 3);
+      layoutParams.bottomMargin = 10;
+      layoutParams.leftMargin = 10;
+      layoutParams.topMargin = 10;
+      layoutParams.rightMargin = 10;
+      view.setLayoutParams(layoutParams);
+    }
+  }
+
+  @Override
+  public void onResume() {
+    super.onResume();
+
+    if (isOwner && player == null) {
+      initializePlayer();
+    }
+
+    setCurrentOutputView(nonFullScreenView);
+
+    PlayerControlView playerControlView = Assertions.checkNotNull(this.playerControlView);
+    playerControlView.setPlayer(player);
+    playerControlView.show();
+  }
+
+  @Override
+  public void onPause() {
+    super.onPause();
+
+    Assertions.checkNotNull(playerControlView).setPlayer(null);
+  }
+
+  @Override
+  public void onDestroy() {
+    super.onDestroy();
+    if (isOwner && isFinishing()) {
+      if (surfaceControl != null) {
+        surfaceControl.release();
+        surfaceControl = null;
+      }
+      if (videoSurface != null) {
+        videoSurface.release();
+        videoSurface = null;
+      }
+      if (player != null) {
+        player.release();
+        player = null;
+      }
+    }
+  }
+
+  private void initializePlayer() {
+    Intent intent = getIntent();
+    String action = intent.getAction();
+    Uri uri =
+        ACTION_VIEW.equals(action)
+            ? Assertions.checkNotNull(intent.getData())
+            : Uri.parse(DEFAULT_MEDIA_URI);
+    String userAgent = Util.getUserAgent(this, getString(R.string.application_name));
+    DrmSessionManager<ExoMediaCrypto> drmSessionManager;
+    if (intent.hasExtra(DRM_SCHEME_EXTRA)) {
+      String drmScheme = Assertions.checkNotNull(intent.getStringExtra(DRM_SCHEME_EXTRA));
+      String drmLicenseUrl = Assertions.checkNotNull(intent.getStringExtra(DRM_LICENSE_URL_EXTRA));
+      UUID drmSchemeUuid = Assertions.checkNotNull(Util.getDrmUuid(drmScheme));
+      HttpDataSource.Factory licenseDataSourceFactory = new DefaultHttpDataSourceFactory(userAgent);
+      HttpMediaDrmCallback drmCallback =
+          new HttpMediaDrmCallback(drmLicenseUrl, licenseDataSourceFactory);
+      drmSessionManager =
+          new DefaultDrmSessionManager.Builder()
+              .setUuidAndExoMediaDrmProvider(drmSchemeUuid, FrameworkMediaDrm.DEFAULT_PROVIDER)
+              .build(drmCallback);
+    } else {
+      drmSessionManager = DrmSessionManager.getDummyDrmSessionManager();
+    }
+
+    DataSource.Factory dataSourceFactory =
+        new DefaultDataSourceFactory(
+            this, Util.getUserAgent(this, getString(R.string.application_name)));
+    MediaSource mediaSource;
+    @C.ContentType int type = Util.inferContentType(uri, intent.getStringExtra(EXTENSION_EXTRA));
+    if (type == C.TYPE_DASH) {
+      mediaSource =
+          new DashMediaSource.Factory(dataSourceFactory)
+              .setDrmSessionManager(drmSessionManager)
+              .createMediaSource(uri);
+    } else if (type == C.TYPE_OTHER) {
+      mediaSource =
+          new ProgressiveMediaSource.Factory(dataSourceFactory)
+              .setDrmSessionManager(drmSessionManager)
+              .createMediaSource(uri);
+    } else {
+      throw new IllegalStateException();
+    }
+    SimpleExoPlayer player = new SimpleExoPlayer.Builder(getApplicationContext()).build();
+    player.prepare(mediaSource);
+    player.setPlayWhenReady(true);
+    player.setRepeatMode(Player.REPEAT_MODE_ALL);
+
+    surfaceControl =
+        new SurfaceControl.Builder()
+            .setName(SURFACE_CONTROL_NAME)
+            .setBufferSize(/* width= */ 0, /* height= */ 0)
+            .build();
+    videoSurface = new Surface(surfaceControl);
+    player.setVideoSurface(videoSurface);
+    MainActivity.player = player;
+  }
+
+  private void setCurrentOutputView(@Nullable SurfaceView surfaceView) {
+    currentOutputView = surfaceView;
+    if (surfaceView != null && surfaceView.getHolder().getSurface() != null) {
+      reparent(surfaceView);
+    }
+  }
+
+  private void attachSurfaceListener(SurfaceView surfaceView) {
+    surfaceView
+        .getHolder()
+        .addCallback(
+            new SurfaceHolder.Callback() {
+              @Override
+              public void surfaceCreated(SurfaceHolder surfaceHolder) {
+                if (surfaceView == currentOutputView) {
+                  reparent(surfaceView);
+                }
+              }
+
+              @Override
+              public void surfaceChanged(
+                  SurfaceHolder surfaceHolder, int format, int width, int height) {}
+
+              @Override
+              public void surfaceDestroyed(SurfaceHolder surfaceHolder) {}
+            });
+  }
+
+  private static void reparent(@Nullable SurfaceView surfaceView) {
+    SurfaceControl surfaceControl = Assertions.checkNotNull(MainActivity.surfaceControl);
+    if (surfaceView == null) {
+      new SurfaceControl.Transaction()
+          .reparent(surfaceControl, /* newParent= */ null)
+          .setBufferSize(surfaceControl, /* w= */ 0, /* h= */ 0)
+          .setVisibility(surfaceControl, /* visible= */ false)
+          .apply();
+    } else {
+      SurfaceControl newParentSurfaceControl = surfaceView.getSurfaceControl();
+      new SurfaceControl.Transaction()
+          .reparent(surfaceControl, newParentSurfaceControl)
+          .setBufferSize(surfaceControl, surfaceView.getWidth(), surfaceView.getHeight())
+          .setVisibility(surfaceControl, /* visible= */ true)
+          .apply();
+    }
+  }
+}
diff --git a/demos/surface/src/main/res/layout/main_activity.xml b/demos/surface/src/main/res/layout/main_activity.xml
new file mode 100644
index 0000000000..d4b7fc77cd
--- /dev/null
+++ b/demos/surface/src/main/res/layout/main_activity.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<FrameLayout
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  xmlns:app="http://schemas.android.com/apk/res-auto"
+  android:layout_width="match_parent"
+  android:layout_height="match_parent"
+  android:keepScreenOn="true">
+
+  <GridLayout
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:id="@+id/grid_layout"
+    android:columnCount="3" />
+
+  <SurfaceView
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:id="@+id/full_screen_view"
+    android:visibility="gone" />
+
+  <com.google.android.exoplayer2.ui.PlayerControlView
+    android:id="@+id/player_control_view"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:layout_gravity="bottom"
+    app:show_timeout="0" />
+
+</FrameLayout>
+
diff --git a/demos/surface/src/main/res/mipmap-hdpi/ic_launcher.png b/demos/surface/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100644
index 0000000000..adaa93220e
Binary files /dev/null and b/demos/surface/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/demos/surface/src/main/res/mipmap-mdpi/ic_launcher.png b/demos/surface/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100644
index 0000000000..9b6f7d5e80
Binary files /dev/null and b/demos/surface/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/demos/surface/src/main/res/mipmap-xhdpi/ic_launcher.png b/demos/surface/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100644
index 0000000000..2101026c9f
Binary files /dev/null and b/demos/surface/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/demos/surface/src/main/res/mipmap-xxhdpi/ic_launcher.png b/demos/surface/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..223ec8bd11
Binary files /dev/null and b/demos/surface/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/demos/surface/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/demos/surface/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..698ed68c42
Binary files /dev/null and b/demos/surface/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/demos/surface/src/main/res/values/strings.xml b/demos/surface/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..9ba24bd368
--- /dev/null
+++ b/demos/surface/src/main/res/values/strings.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources>
+
+  <string name="application_name">ExoPlayer SurfaceControl demo</string>
+  <string name="no_output_label">No output</string>
+  <string name="full_screen_label">Full screen</string>
+  <string name="new_activity_label">New activity</string>
+
+</resources>
diff --git a/demos/surface/src/main/res/values/styles.xml b/demos/surface/src/main/res/values/styles.xml
new file mode 100644
index 0000000000..aaa1e2ef83
--- /dev/null
+++ b/demos/surface/src/main/res/values/styles.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources xmlns:android="http://schemas.android.com/apk/res/android">
+
+  <style name="PlayerTheme" parent="android:Theme.Holo">
+    <item name="android:windowNoTitle">true</item>
+    <item name="android:windowBackground">@android:color/black</item>
+  </style>
+
+</resources>
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
index 91a4c86cf2..147f769a98 100644
--- a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
@@ -50,12 +50,13 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.CopyOnWriteArrayList;
+import org.checkerframework.checker.nullness.qual.RequiresNonNull;
 
 /**
  * {@link Player} implementation that communicates with a Cast receiver app.
  *
  * <p>The behavior of this class depends on the underlying Cast session, which is obtained from the
- * Cast context passed to {@link #CastPlayer}. To keep track of the session, {@link
+ * Cast context passed to {@link #@}. To keep track of the session, {@link
  * #isCastSessionAvailable()} can be queried and {@link SessionAvailabilityListener} can be
  * implemented and attached to the player.
  *
@@ -106,6 +107,7 @@
   private int pendingSeekCount;
   private int pendingSeekWindowIndex;
   private long pendingSeekPositionMs;
+  private boolean waitingForInitialTimeline;
 
   /**
    * @param castContext The context from which the cast session is obtained.
@@ -132,7 +134,7 @@ public CastPlayer(CastContext castContext) {
     currentTrackSelection = EMPTY_TRACK_SELECTION_ARRAY;
     pendingSeekWindowIndex = C.INDEX_UNSET;
     pendingSeekPositionMs = C.TIME_UNSET;
-    updateInternalState();
+    maybeUpdateInternalState();
   }
 
   // Media Queue manipulation methods.
@@ -167,6 +169,7 @@ public CastPlayer(CastContext castContext) {
       MediaQueueItem[] items, int startIndex, long positionMs, @RepeatMode int repeatMode) {
     if (remoteMediaClient != null) {
       positionMs = positionMs != C.TIME_UNSET ? positionMs : 0;
+      waitingForInitialTimeline = true;
       return remoteMediaClient.queueLoad(items, startIndex, getCastRepeatMode(repeatMode),
           positionMs, null);
     }
@@ -321,7 +324,7 @@ public void removeListener(EventListener listener) {
   }
 
   @Override
-  @State
+  @Player.State
   public int getPlaybackState() {
     return playbackState;
   }
@@ -343,11 +346,19 @@ public void setPlayWhenReady(boolean playWhenReady) {
     if (remoteMediaClient == null) {
       return;
     }
-    if (playWhenReady) {
-      remoteMediaClient.play();
-    } else {
-      remoteMediaClient.pause();
-    }
+    // We send the message to the receiver app and update the local state, which will cause the
+    // operation to be perceived as synchronous by the user.
+    PendingResult<MediaChannelResult> pendingResult =
+        playWhenReady ? remoteMediaClient.play() : remoteMediaClient.pause();
+    pendingResult.setResultCallback(
+        mediaChannelResult -> {
+          if (remoteMediaClient != null) {
+            maybeUpdatePlayerStateAndNotify();
+            flushNotifications();
+          }
+        });
+    maybeSetPlayerStateAndNotify(playWhenReady, playbackState);
+    flushNotifications();
   }
 
   @Override
@@ -536,23 +547,14 @@ public long getContentBufferedPosition() {
 
   // Internal methods.
 
-  private void updateInternalState() {
+  private void maybeUpdateInternalState() {
     if (remoteMediaClient == null) {
       // There is no session. We leave the state of the player as it is now.
       return;
     }
 
     boolean wasPlaying = playbackState == Player.STATE_READY && playWhenReady;
-    int playbackState = fetchPlaybackState(remoteMediaClient);
-    boolean playWhenReady = !remoteMediaClient.isPaused();
-    if (this.playbackState != playbackState
-        || this.playWhenReady != playWhenReady) {
-      this.playbackState = playbackState;
-      this.playWhenReady = playWhenReady;
-      notificationsBatch.add(
-          new ListenerNotificationTask(
-              listener -> listener.onPlayerStateChanged(this.playWhenReady, this.playbackState)));
-    }
+    maybeUpdatePlayerStateAndNotify();
     boolean isPlaying = playbackState == Player.STATE_READY && playWhenReady;
     if (wasPlaying != isPlaying) {
       notificationsBatch.add(
@@ -590,15 +592,23 @@ private void updateInternalState() {
     flushNotifications();
   }
 
+  @RequiresNonNull("remoteMediaClient")
+  private void maybeUpdatePlayerStateAndNotify() {
+    maybeSetPlayerStateAndNotify(
+        !remoteMediaClient.isPaused(), fetchPlaybackState(remoteMediaClient));
+  }
+
   private void maybeUpdateTimelineAndNotify() {
     if (updateTimeline()) {
-      // TODO: Differentiate TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED and
-      //     TIMELINE_CHANGE_REASON_SOURCE_UPDATE [see internal: b/65152553].
+      @Player.TimelineChangeReason
+      int reason =
+          waitingForInitialTimeline
+              ? Player.TIMELINE_CHANGE_REASON_PREPARED
+              : Player.TIMELINE_CHANGE_REASON_DYNAMIC;
+      waitingForInitialTimeline = false;
       notificationsBatch.add(
           new ListenerNotificationTask(
-              listener ->
-                  listener.onTimelineChanged(
-                      currentTimeline, Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE)));
+              listener -> listener.onTimelineChanged(currentTimeline, reason)));
     }
   }
 
@@ -664,6 +674,17 @@ private boolean updateTracksAndSelections() {
     return false;
   }
 
+  private void maybeSetPlayerStateAndNotify(
+      boolean playWhenReady, @Player.State int playbackState) {
+    if (this.playWhenReady != playWhenReady || this.playbackState != playbackState) {
+      this.playWhenReady = playWhenReady;
+      this.playbackState = playbackState;
+      notificationsBatch.add(
+          new ListenerNotificationTask(
+              listener -> listener.onPlayerStateChanged(playWhenReady, playbackState)));
+    }
+  }
+
   private void setRemoteMediaClient(@Nullable RemoteMediaClient remoteMediaClient) {
     if (this.remoteMediaClient == remoteMediaClient) {
       // Do nothing.
@@ -680,7 +701,7 @@ private void setRemoteMediaClient(@Nullable RemoteMediaClient remoteMediaClient)
       }
       remoteMediaClient.addListener(statusListener);
       remoteMediaClient.addProgressListener(statusListener, PROGRESS_REPORT_PERIOD_MS);
-      updateInternalState();
+      maybeUpdateInternalState();
     } else {
       if (sessionAvailabilityListener != null) {
         sessionAvailabilityListener.onCastSessionUnavailable();
@@ -767,8 +788,26 @@ private static int getCastRepeatMode(@RepeatMode int repeatMode) {
     }
   }
 
-  private final class StatusListener implements RemoteMediaClient.Listener,
-      SessionManagerListener<CastSession>, RemoteMediaClient.ProgressListener {
+  private void flushNotifications() {
+    boolean recursiveNotification = !ongoingNotificationsTasks.isEmpty();
+    ongoingNotificationsTasks.addAll(notificationsBatch);
+    notificationsBatch.clear();
+    if (recursiveNotification) {
+      // This will be handled once the current notification task is finished.
+      return;
+    }
+    while (!ongoingNotificationsTasks.isEmpty()) {
+      ongoingNotificationsTasks.peekFirst().execute();
+      ongoingNotificationsTasks.removeFirst();
+    }
+  }
+
+  // Internal classes.
+
+  private final class StatusListener
+      implements RemoteMediaClient.Listener,
+          SessionManagerListener<CastSession>,
+          RemoteMediaClient.ProgressListener {
 
     // RemoteMediaClient.ProgressListener implementation.
 
@@ -781,7 +820,7 @@ public void onProgressUpdated(long progressMs, long unusedDurationMs) {
 
     @Override
     public void onStatusUpdated() {
-      updateInternalState();
+      maybeUpdateInternalState();
     }
 
     @Override
@@ -852,24 +891,6 @@ public void onSessionResuming(CastSession castSession, String s) {
 
   }
 
-  // Internal methods.
-
-  private void flushNotifications() {
-    boolean recursiveNotification = !ongoingNotificationsTasks.isEmpty();
-    ongoingNotificationsTasks.addAll(notificationsBatch);
-    notificationsBatch.clear();
-    if (recursiveNotification) {
-      // This will be handled once the current notification task is finished.
-      return;
-    }
-    while (!ongoingNotificationsTasks.isEmpty()) {
-      ongoingNotificationsTasks.peekFirst().execute();
-      ongoingNotificationsTasks.removeFirst();
-    }
-  }
-
-  // Internal classes.
-
   private final class SeekResultCallback implements ResultCallback<MediaChannelResult> {
 
     @Override
@@ -904,5 +925,4 @@ public void execute() {
       }
     }
   }
-
 }
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimeline.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimeline.java
index 2857141f8f..54ff7e6777 100644
--- a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimeline.java
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimeline.java
@@ -121,6 +121,7 @@ public Window getWindow(int windowIndex, Window window, long defaultPositionProj
         /* windowStartTimeMs= */ C.TIME_UNSET,
         /* isSeekable= */ !isDynamic,
         isDynamic,
+        /* isLive= */ isDynamic,
         defaultPositionsUs[windowIndex],
         durationUs,
         /* firstPeriodIndex= */ windowIndex,
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
index 91bceb9aee..1903e33995 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
@@ -22,7 +22,6 @@
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
-import com.google.android.exoplayer2.metadata.icy.IcyHeaders;
 import com.google.android.exoplayer2.upstream.BaseDataSource;
 import com.google.android.exoplayer2.upstream.DataSourceException;
 import com.google.android.exoplayer2.upstream.DataSpec;
@@ -706,11 +705,7 @@ protected UrlResponseInfo getCurrentUrlResponseInfo() {
     if (dataSpec.httpBody != null && !requestHeaders.containsKey(CONTENT_TYPE)) {
       throw new IOException("HTTP request with non-empty body must set Content-Type");
     }
-    if (dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_ICY_METADATA)) {
-      requestBuilder.addHeader(
-          IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_NAME,
-          IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_VALUE);
-    }
+    
     // Set the Range header.
     if (dataSpec.position != 0 || dataSpec.length != C.LENGTH_UNSET) {
       StringBuilder rangeValue = new StringBuilder();
@@ -937,7 +932,8 @@ public synchronized void onRedirectReceived(
                 dataSpec.position,
                 dataSpec.length,
                 dataSpec.key,
-                dataSpec.flags);
+                dataSpec.flags,
+                dataSpec.httpRequestHeaders);
       } else {
         redirectUrlDataSpec = dataSpec.withUri(Uri.parse(newLocationUrl));
       }
diff --git a/extensions/ffmpeg/README.md b/extensions/ffmpeg/README.md
index dd9ce38d35..3348f7cffb 100644
--- a/extensions/ffmpeg/README.md
+++ b/extensions/ffmpeg/README.md
@@ -25,8 +25,7 @@ follows:
 
 ```
 cd "<path to exoplayer checkout>"
-EXOPLAYER_ROOT="$(pwd)"
-FFMPEG_EXT_PATH="${EXOPLAYER_ROOT}/extensions/ffmpeg/src/main"
+FFMPEG_EXT_PATH="$(pwd)/extensions/ffmpeg/src/main/jni"
 ```
 
 * Download the [Android NDK][] and set its location in an environment variable.
@@ -69,7 +68,7 @@ COMMON_OPTIONS="\
     --enable-decoder=opus \
     --enable-decoder=flac \
     " && \
-cd "${FFMPEG_EXT_PATH}/jni" && \
+cd "${FFMPEG_EXT_PATH}" && \
 (git -C ffmpeg pull || git clone git://source.ffmpeg.org/ffmpeg ffmpeg) && \
 cd ffmpeg && git checkout release/4.0 && \
 ./configure \
@@ -112,7 +111,7 @@ make clean
   built in the previous step. For example:
 
 ```
-cd "${FFMPEG_EXT_PATH}"/jni && \
+cd "${FFMPEG_EXT_PATH}" && \
 ${NDK_PATH}/ndk-build APP_ABI="armeabi-v7a arm64-v8a x86" -j4
 ```
 
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoderJni.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoderJni.java
index f454e28c68..5e020175e7 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoderJni.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoderJni.java
@@ -19,6 +19,8 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
+import com.google.android.exoplayer2.extractor.SeekMap;
+import com.google.android.exoplayer2.extractor.SeekPoint;
 import com.google.android.exoplayer2.util.FlacStreamMetadata;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
@@ -216,15 +218,25 @@ public long getNextFrameFirstSampleIndex() {
   }
 
   /**
-   * Maps a seek position in microseconds to a corresponding position (byte offset) in the flac
+   * Maps a seek position in microseconds to the corresponding {@link SeekMap.SeekPoints} in the
    * stream.
    *
    * @param timeUs A seek position in microseconds.
-   * @return The corresponding position (byte offset) in the flac stream or -1 if the stream doesn't
-   * have a seek table.
+   * @return The corresponding {@link SeekMap.SeekPoints} obtained from the seek table, or {@code
+   *     null} if the stream doesn't have a seek table.
    */
-  public long getSeekPosition(long timeUs) {
-    return flacGetSeekPosition(nativeDecoderContext, timeUs);
+  @Nullable
+  public SeekMap.SeekPoints getSeekPoints(long timeUs) {
+    long[] seekPoints = new long[4];
+    if (!flacGetSeekPoints(nativeDecoderContext, timeUs, seekPoints)) {
+      return null;
+    }
+    SeekPoint firstSeekPoint = new SeekPoint(seekPoints[0], seekPoints[1]);
+    SeekPoint secondSeekPoint =
+        seekPoints[2] == seekPoints[0]
+            ? firstSeekPoint
+            : new SeekPoint(seekPoints[2], seekPoints[3]);
+    return new SeekMap.SeekPoints(firstSeekPoint, secondSeekPoint);
   }
 
   public String getStateString() {
@@ -283,7 +295,7 @@ private native int flacDecodeToArray(long context, byte[] outputArray)
 
   private native long flacGetNextFrameFirstSampleIndex(long context);
 
-  private native long flacGetSeekPosition(long context, long timeUs);
+  private native boolean flacGetSeekPoints(long context, long timeUs, long[] outSeekPoints);
 
   private native String flacGetStateString(long context);
 
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
index cd91b06288..59fb7b4835 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
@@ -276,10 +276,10 @@ private static FlacBinarySearchSeeker outputSeekMap(
       FlacStreamMetadata streamMetadata,
       long streamLength,
       ExtractorOutput output) {
-    boolean hasSeekTable = decoderJni.getSeekPosition(/* timeUs= */ 0) != -1;
+    boolean haveSeekTable = decoderJni.getSeekPoints(/* timeUs= */ 0) != null;
     FlacBinarySearchSeeker binarySearchSeeker = null;
     SeekMap seekMap;
-    if (hasSeekTable) {
+    if (haveSeekTable) {
       seekMap = new FlacSeekMap(streamMetadata.durationUs(), decoderJni);
     } else if (streamLength != C.LENGTH_UNSET) {
       long firstFramePosition = decoderJni.getDecodePosition();
@@ -341,8 +341,8 @@ public boolean isSeekable() {
 
     @Override
     public SeekPoints getSeekPoints(long timeUs) {
-      // TODO: Access the seek table via JNI to return two seek points when appropriate.
-      return new SeekPoints(new SeekPoint(timeUs, decoderJni.getSeekPosition(timeUs)));
+      @Nullable SeekPoints seekPoints = decoderJni.getSeekPoints(timeUs);
+      return seekPoints == null ? new SeekPoints(SeekPoint.START) : seekPoints;
     }
 
     @Override
diff --git a/extensions/flac/src/main/jni/flac_jni.cc b/extensions/flac/src/main/jni/flac_jni.cc
index d60a7cead2..f0a33f323c 100644
--- a/extensions/flac/src/main/jni/flac_jni.cc
+++ b/extensions/flac/src/main/jni/flac_jni.cc
@@ -17,6 +17,7 @@
 #include <android/log.h>
 #include <jni.h>
 
+#include <array>
 #include <cstdlib>
 #include <cstring>
 
@@ -46,7 +47,6 @@ class JavaDataSource : public DataSource {
     if (mid == NULL) {
       jclass cls = env->GetObjectClass(flacDecoderJni);
       mid = env->GetMethodID(cls, "read", "(Ljava/nio/ByteBuffer;)I");
-      env->DeleteLocalRef(cls);
     }
   }
 
@@ -57,7 +57,6 @@ class JavaDataSource : public DataSource {
       // Exception is thrown in Java when returning from the native call.
       result = -1;
     }
-    env->DeleteLocalRef(byteBuffer);
     return result;
   }
 
@@ -200,9 +199,15 @@ DECODER_FUNC(jlong, flacGetNextFrameFirstSampleIndex, jlong jContext) {
   return context->parser->getNextFrameFirstSampleIndex();
 }
 
-DECODER_FUNC(jlong, flacGetSeekPosition, jlong jContext, jlong timeUs) {
+DECODER_FUNC(jboolean, flacGetSeekPoints, jlong jContext, jlong timeUs,
+             jlongArray outSeekPoints) {
   Context *context = reinterpret_cast<Context *>(jContext);
-  return context->parser->getSeekPosition(timeUs);
+  std::array<int64_t, 4> result;
+  bool success = context->parser->getSeekPositions(timeUs, result);
+  if (success) {
+    env->SetLongArrayRegion(outSeekPoints, 0, result.size(), result.data());
+  }
+  return success;
 }
 
 DECODER_FUNC(jstring, flacGetStateString, jlong jContext) {
diff --git a/extensions/flac/src/main/jni/flac_parser.cc b/extensions/flac/src/main/jni/flac_parser.cc
index 830f3e2178..7c69119fe4 100644
--- a/extensions/flac/src/main/jni/flac_parser.cc
+++ b/extensions/flac/src/main/jni/flac_parser.cc
@@ -438,22 +438,41 @@ size_t FLACParser::readBuffer(void *output, size_t output_size) {
   return bufferSize;
 }
 
-int64_t FLACParser::getSeekPosition(int64_t timeUs) {
+bool FLACParser::getSeekPositions(int64_t timeUs,
+                                  std::array<int64_t, 4> &result) {
   if (!mSeekTable) {
-    return -1;
+    return false;
   }
 
-  int64_t sample = (timeUs * getSampleRate()) / 1000000LL;
-  if (sample >= getTotalSamples()) {
-      sample = getTotalSamples();
+  unsigned sampleRate = getSampleRate();
+  int64_t totalSamples = getTotalSamples();
+  int64_t targetSampleNumber = (timeUs * sampleRate) / 1000000LL;
+  if (targetSampleNumber >= totalSamples) {
+    targetSampleNumber = totalSamples - 1;
   }
 
   FLAC__StreamMetadata_SeekPoint* points = mSeekTable->points;
-  for (unsigned i = mSeekTable->num_points; i > 0; ) {
-    i--;
-    if (points[i].sample_number <= sample) {
-      return firstFrameOffset + points[i].stream_offset;
+  unsigned length = mSeekTable->num_points;
+
+  for (unsigned i = length; i != 0; i--) {
+    int64_t sampleNumber = points[i - 1].sample_number;
+    if (sampleNumber <= targetSampleNumber) {
+      result[0] = (sampleNumber * 1000000LL) / sampleRate;
+      result[1] = firstFrameOffset + points[i - 1].stream_offset;
+      if (sampleNumber == targetSampleNumber || i >= length) {
+        // exact seek, or no following seek point.
+        result[2] = result[0];
+        result[3] = result[1];
+      } else {
+        result[2] = (points[i].sample_number * 1000000LL) / sampleRate;
+        result[3] = firstFrameOffset + points[i].stream_offset;
+      }
+      return true;
     }
   }
-  return firstFrameOffset;
+  result[0] = 0;
+  result[1] = firstFrameOffset;
+  result[2] = 0;
+  result[3] = firstFrameOffset;
+  return true;
 }
diff --git a/extensions/flac/src/main/jni/include/flac_parser.h b/extensions/flac/src/main/jni/include/flac_parser.h
index fd3e36a806..44a0d08718 100644
--- a/extensions/flac/src/main/jni/include/flac_parser.h
+++ b/extensions/flac/src/main/jni/include/flac_parser.h
@@ -19,6 +19,7 @@
 
 #include <stdint.h>
 
+#include <array>
 #include <cstdlib>
 #include <string>
 #include <vector>
@@ -84,7 +85,7 @@ class FLACParser {
   bool decodeMetadata();
   size_t readBuffer(void *output, size_t output_size);
 
-  int64_t getSeekPosition(int64_t timeUs);
+  bool getSeekPositions(int64_t timeUs, std::array<int64_t, 4> &result);
 
   void flush() {
     reset(mCurrentPos);
diff --git a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakePlayer.java b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakePlayer.java
index a6a725ee9e..a9572b7a8d 100644
--- a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakePlayer.java
+++ b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/FakePlayer.java
@@ -30,6 +30,7 @@
   private final Timeline.Period period;
   private final Timeline timeline;
 
+  private boolean prepared;
   @Player.State private int state;
   private boolean playWhenReady;
   private long position;
@@ -46,17 +47,13 @@ public FakePlayer() {
     timeline = Timeline.EMPTY;
   }
 
-  /**
-   * Sets the timeline on this fake player, which notifies listeners with the changed timeline and
-   * the given timeline change reason.
-   *
-   * @param timeline The new timeline.
-   * @param timelineChangeReason The reason for the timeline change.
-   */
-  public void updateTimeline(Timeline timeline, @TimelineChangeReason int timelineChangeReason) {
+  /** Sets the timeline on this fake player, which notifies listeners with the changed timeline. */
+  public void updateTimeline(Timeline timeline) {
     for (Player.EventListener listener : listeners) {
-      listener.onTimelineChanged(timeline, timelineChangeReason);
+      listener.onTimelineChanged(
+          timeline, prepared ? TIMELINE_CHANGE_REASON_DYNAMIC : TIMELINE_CHANGE_REASON_PREPARED);
     }
+    prepared = true;
   }
 
   /**
diff --git a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoaderTest.java b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoaderTest.java
index a5c6b00619..edaa4cde29 100644
--- a/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoaderTest.java
+++ b/extensions/ima/src/test/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoaderTest.java
@@ -63,7 +63,8 @@
 
   private static final long CONTENT_DURATION_US = 10 * C.MICROS_PER_SECOND;
   private static final Timeline CONTENT_TIMELINE =
-      new SinglePeriodTimeline(CONTENT_DURATION_US, /* isSeekable= */ true, /* isDynamic= */ false);
+      new SinglePeriodTimeline(
+          CONTENT_DURATION_US, /* isSeekable= */ true, /* isDynamic= */ false, /* isLive= */ false);
   private static final Uri TEST_URI = Uri.EMPTY;
   private static final long TEST_AD_DURATION_US = 5 * C.MICROS_PER_SECOND;
   private static final long[][] PREROLL_ADS_DURATIONS_US = new long[][] {{TEST_AD_DURATION_US}};
@@ -285,9 +286,7 @@ public TestAdsLoaderListener(
     public void onAdPlaybackState(AdPlaybackState adPlaybackState) {
       adPlaybackState = adPlaybackState.withAdDurationsUs(adDurationsUs);
       this.adPlaybackState = adPlaybackState;
-      fakeExoPlayer.updateTimeline(
-          new SinglePeriodAdTimeline(contentTimeline, adPlaybackState),
-          Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE);
+      fakeExoPlayer.updateTimeline(new SinglePeriodAdTimeline(contentTimeline, adPlaybackState));
     }
 
     @Override
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
index a69449378a..3b92e7e4ff 100644
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
@@ -889,26 +889,27 @@ private boolean canDispatchMediaButtonEvent() {
 
   private void rewind(Player player) {
     if (player.isCurrentWindowSeekable() && rewindMs > 0) {
-      seekTo(player, player.getCurrentPosition() - rewindMs);
+      seekToOffset(player, /* offsetMs= */ -rewindMs);
     }
   }
 
   private void fastForward(Player player) {
     if (player.isCurrentWindowSeekable() && fastForwardMs > 0) {
-      seekTo(player, player.getCurrentPosition() + fastForwardMs);
+      seekToOffset(player, /* offsetMs= */ fastForwardMs);
     }
   }
 
-  private void seekTo(Player player, long positionMs) {
-    seekTo(player, player.getCurrentWindowIndex(), positionMs);
-  }
-
-  private void seekTo(Player player, int windowIndex, long positionMs) {
+  private void seekToOffset(Player player, long offsetMs) {
+    long positionMs = player.getCurrentPosition() + offsetMs;
     long durationMs = player.getDuration();
     if (durationMs != C.TIME_UNSET) {
       positionMs = Math.min(positionMs, durationMs);
     }
     positionMs = Math.max(positionMs, 0);
+    seekTo(player, player.getCurrentWindowIndex(), positionMs);
+  }
+
+  private void seekTo(Player player, int windowIndex, long positionMs) {
     controlDispatcher.dispatchSeekTo(player, windowIndex, positionMs);
   }
 
@@ -1119,7 +1120,7 @@ public void onPlay() {
             playbackPreparer.onPrepare(/* playWhenReady= */ true);
           }
         } else if (player.getPlaybackState() == Player.STATE_ENDED) {
-          controlDispatcher.dispatchSeekTo(player, player.getCurrentWindowIndex(), C.TIME_UNSET);
+          seekTo(player, player.getCurrentWindowIndex(), C.TIME_UNSET);
         }
         controlDispatcher.dispatchSetPlayWhenReady(
             Assertions.checkNotNull(player), /* playWhenReady= */ true);
@@ -1136,7 +1137,7 @@ public void onPause() {
     @Override
     public void onSeekTo(long positionMs) {
       if (canDispatchPlaybackAction(PlaybackStateCompat.ACTION_SEEK_TO)) {
-        seekTo(player, positionMs);
+        seekTo(player, player.getCurrentWindowIndex(), positionMs);
       }
     }
 
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
index c75b162df5..d9630fe3bd 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
@@ -21,7 +21,6 @@
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
-import com.google.android.exoplayer2.metadata.icy.IcyHeaders;
 import com.google.android.exoplayer2.upstream.BaseDataSource;
 import com.google.android.exoplayer2.upstream.DataSourceException;
 import com.google.android.exoplayer2.upstream.DataSpec;
@@ -361,11 +360,7 @@ private Request makeRequest(DataSpec dataSpec) throws HttpDataSourceException {
     if (!dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_GZIP)) {
       builder.addHeader("Accept-Encoding", "identity");
     }
-    if (dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_ICY_METADATA)) {
-      builder.addHeader(
-          IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_NAME,
-          IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_VALUE);
-    }
+
     RequestBody requestBody = null;
     if (dataSpec.httpBody != null) {
       requestBody = RequestBody.create(dataSpec.httpBody, null);
diff --git a/extensions/rtmp/src/main/java/com/google/android/exoplayer2/ext/rtmp/RtmpDataSourceFactory.java b/extensions/rtmp/src/main/java/com/google/android/exoplayer2/ext/rtmp/RtmpDataSourceFactory.java
index 505724e846..db60eea269 100644
--- a/extensions/rtmp/src/main/java/com/google/android/exoplayer2/ext/rtmp/RtmpDataSourceFactory.java
+++ b/extensions/rtmp/src/main/java/com/google/android/exoplayer2/ext/rtmp/RtmpDataSourceFactory.java
@@ -37,7 +37,7 @@ public RtmpDataSourceFactory(@Nullable TransferListener listener) {
   }
 
   @Override
-  public DataSource createDataSource() {
+  public RtmpDataSource createDataSource() {
     RtmpDataSource dataSource = new RtmpDataSource();
     if (listener != null) {
       dataSource.addTransferListener(listener);
diff --git a/extensions/vp9/README.md b/extensions/vp9/README.md
index 34230db2ec..b7ea254a6c 100644
--- a/extensions/vp9/README.md
+++ b/extensions/vp9/README.md
@@ -107,12 +107,11 @@ a custom track selector the choice of `Renderer` is up to your implementation,
 so you need to make sure you are passing an `LibvpxVideoRenderer` to the
 player, then implement your own logic to use the renderer for a given track.
 
-`LibvpxVideoRenderer` can optionally output to a `VpxVideoSurfaceView` when not
-being used via `SimpleExoPlayer`, in which case color space conversion will be
-performed using a GL shader. To enable this mode, send the renderer a message of
-type `LibvpxVideoRenderer.MSG_SET_OUTPUT_BUFFER_RENDERER` with the
-`VpxVideoSurfaceView` as its object, instead of sending `MSG_SET_SURFACE` with a
-`Surface`.
+`LibvpxVideoRenderer` can optionally output to a `VideoDecoderSurfaceView` when
+not being used via `SimpleExoPlayer`, in which case color space conversion will
+be performed using a GL shader. To enable this mode, send the renderer a message
+of type `C.MSG_SET_OUTPUT_BUFFER_RENDERER` with the `VideoDecoderSurfaceView` as
+its object, instead of sending `MSG_SET_SURFACE` with a `Surface`.
 
 ## Links ##
 
diff --git a/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java b/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
index d4e0795293..3dd039118c 100644
--- a/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
+++ b/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
@@ -23,6 +23,7 @@
 import android.os.Looper;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Player;
@@ -31,6 +32,7 @@
 import com.google.android.exoplayer2.source.ProgressiveMediaSource;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
 import com.google.android.exoplayer2.util.Log;
+import com.google.android.exoplayer2.video.VideoDecoderSurfaceView;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -121,8 +123,8 @@ public void run() {
               .createMediaSource(uri);
       player
           .createMessage(videoRenderer)
-          .setType(LibvpxVideoRenderer.MSG_SET_OUTPUT_BUFFER_RENDERER)
-          .setPayload(new VpxVideoSurfaceView(context))
+          .setType(C.MSG_SET_OUTPUT_BUFFER_RENDERER)
+          .setPayload(new VideoDecoderSurfaceView(context))
           .send();
       player.prepare(mediaSource);
       player.setPlayWhenReady(true);
diff --git a/extensions/vp9/src/main/METADATA b/extensions/vp9/src/main/METADATA
new file mode 100644
index 0000000000..7510fdadc0
--- /dev/null
+++ b/extensions/vp9/src/main/METADATA
@@ -0,0 +1,9 @@
+# Format: google3/devtools/metadata/metadata.proto (go/google3metadata)
+
+tricorder: {
+  options: {
+    builder: {
+      config: "android"
+    }
+  }
+}
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
index 13f020031c..ec4f3f7903 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
@@ -28,13 +28,13 @@
 import com.google.android.exoplayer2.decoder.SimpleDecoder;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.ExoMediaCrypto;
-import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.TraceUtil;
 import com.google.android.exoplayer2.video.SimpleDecoderVideoRenderer;
 import com.google.android.exoplayer2.video.VideoDecoderException;
 import com.google.android.exoplayer2.video.VideoDecoderInputBuffer;
 import com.google.android.exoplayer2.video.VideoDecoderOutputBuffer;
+import com.google.android.exoplayer2.video.VideoDecoderOutputBufferRenderer;
 import com.google.android.exoplayer2.video.VideoFrameMetadataListener;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
 
@@ -47,20 +47,13 @@
  * <ul>
  *   <li>Message with type {@link C#MSG_SET_SURFACE} to set the output surface. The message payload
  *       should be the target {@link Surface}, or null.
- *   <li>Message with type {@link #MSG_SET_OUTPUT_BUFFER_RENDERER} to set the output buffer
- *       renderer. The message payload should be the target {@link VpxOutputBufferRenderer}, or
- *       null.
+ *   <li>Message with type {@link C#MSG_SET_OUTPUT_BUFFER_RENDERER} to set the output buffer
+ *       renderer. The message payload should be the target {@link
+ *       VideoDecoderOutputBufferRenderer}, or null.
  * </ul>
  */
 public class LibvpxVideoRenderer extends SimpleDecoderVideoRenderer {
 
-  /**
-   * The type of a message that can be passed to an instance of this class via {@link
-   * ExoPlayer#createMessage(Target)}. The message payload should be the target {@link
-   * VpxOutputBufferRenderer}, or null.
-   */
-  public static final int MSG_SET_OUTPUT_BUFFER_RENDERER = C.MSG_CUSTOM_BASE;
-
   /** The number of input buffers. */
   private final int numInputBuffers;
   /**
@@ -78,13 +71,7 @@
   private final boolean disableLoopFilter;
   private final int threads;
 
-  private Surface surface;
-  private VpxOutputBufferRenderer outputBufferRenderer;
-  @C.VideoOutputMode private int outputMode;
-
   private VpxDecoder decoder;
-  private VpxOutputBuffer outputBuffer;
-
   private VideoFrameMetadataListener frameMetadataListener;
 
   /**
@@ -203,7 +190,6 @@ public LibvpxVideoRenderer(
     this.threads = threads;
     this.numInputBuffers = numInputBuffers;
     this.numOutputBuffers = numOutputBuffers;
-    outputMode = C.VIDEO_OUTPUT_MODE_NONE;
   }
 
   @Override
@@ -242,53 +228,37 @@ protected int supportsFormatInternal(
             disableLoopFilter,
             enableRowMultiThreadMode,
             threads);
-    decoder.setOutputMode(outputMode);
     TraceUtil.endSection();
     return decoder;
   }
 
   @Override
-  @Nullable
-  protected VideoDecoderOutputBuffer dequeueOutputBuffer() throws VpxDecoderException {
-    outputBuffer = decoder.dequeueOutputBuffer();
-    return outputBuffer;
-  }
-
-  @Override
-  protected void renderOutputBuffer(long presentationTimeUs, Format outputFormat)
-      throws VpxDecoderException {
+  protected void renderOutputBuffer(
+      VideoDecoderOutputBuffer outputBuffer, long presentationTimeUs, Format outputFormat)
+      throws VideoDecoderException {
     if (frameMetadataListener != null) {
       frameMetadataListener.onVideoFrameAboutToBeRendered(
           presentationTimeUs, System.nanoTime(), outputFormat);
     }
-
-    int bufferMode = outputBuffer.mode;
-    boolean renderSurface = bufferMode == C.VIDEO_OUTPUT_MODE_SURFACE_YUV && surface != null;
-    boolean renderYuv = bufferMode == C.VIDEO_OUTPUT_MODE_YUV && outputBufferRenderer != null;
-    if (!renderYuv && !renderSurface) {
-      dropOutputBuffer(outputBuffer);
-    } else {
-      maybeNotifyVideoSizeChanged(outputBuffer.width, outputBuffer.height);
-      if (renderYuv) {
-        outputBufferRenderer.setOutputBuffer(outputBuffer);
-        // The renderer will release the buffer.
-      } else { // renderSurface
-        decoder.renderToSurface(outputBuffer, surface);
-        outputBuffer.release();
-      }
-      onFrameRendered(surface);
-    }
+    super.renderOutputBuffer(outputBuffer, presentationTimeUs, outputFormat);
   }
 
   @Override
-  protected void clearOutputBuffer() {
-    super.clearOutputBuffer();
-    outputBuffer = null;
+  protected void renderOutputBufferToSurface(VideoDecoderOutputBuffer outputBuffer, Surface surface)
+      throws VpxDecoderException {
+    if (decoder == null) {
+      throw new VpxDecoderException(
+          "Failed to render output buffer to surface: decoder is not initialized.");
+    }
+    decoder.renderToSurface(outputBuffer, surface);
+    outputBuffer.release();
   }
 
   @Override
-  protected boolean hasOutputSurface() {
-    return outputMode != C.VIDEO_OUTPUT_MODE_NONE;
+  protected void setDecoderOutputMode(@C.VideoOutputMode int outputMode) {
+    if (decoder != null) {
+      decoder.setOutputMode(outputMode);
+    }
   }
 
   // PlayerMessage.Target implementation.
@@ -296,44 +266,13 @@ protected boolean hasOutputSurface() {
   @Override
   public void handleMessage(int messageType, @Nullable Object message) throws ExoPlaybackException {
     if (messageType == C.MSG_SET_SURFACE) {
-      setOutput((Surface) message, null);
-    } else if (messageType == MSG_SET_OUTPUT_BUFFER_RENDERER) {
-      setOutput(null, (VpxOutputBufferRenderer) message);
+      setOutputSurface((Surface) message);
+    } else if (messageType == C.MSG_SET_OUTPUT_BUFFER_RENDERER) {
+      setOutputBufferRenderer((VideoDecoderOutputBufferRenderer) message);
     } else if (messageType == C.MSG_SET_VIDEO_FRAME_METADATA_LISTENER) {
       frameMetadataListener = (VideoFrameMetadataListener) message;
     } else {
       super.handleMessage(messageType, message);
     }
   }
-
-  // Internal methods.
-
-  private void setOutput(
-      @Nullable Surface surface, @Nullable VpxOutputBufferRenderer outputBufferRenderer) {
-    // At most one output may be non-null. Both may be null if the output is being cleared.
-    Assertions.checkState(surface == null || outputBufferRenderer == null);
-    if (this.surface != surface || this.outputBufferRenderer != outputBufferRenderer) {
-      // The output has changed.
-      this.surface = surface;
-      this.outputBufferRenderer = outputBufferRenderer;
-      if (surface != null) {
-        outputMode = C.VIDEO_OUTPUT_MODE_SURFACE_YUV;
-      } else {
-        outputMode =
-            outputBufferRenderer != null ? C.VIDEO_OUTPUT_MODE_YUV : C.VIDEO_OUTPUT_MODE_NONE;
-      }
-      if (hasOutputSurface()) {
-        if (decoder != null) {
-          decoder.setOutputMode(outputMode);
-        }
-        onOutputSurfaceChanged();
-      } else {
-        // The output has been removed. We leave the outputMode of the underlying decoder unchanged
-        // in anticipation that a subsequent output will likely be of the same type.
-        onOutputSurfaceRemoved();
-      }
-    } else if (hasOutputSurface()) {
-      onOutputSurfaceReset(surface);
-    }
-  }
 }
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
index f6b1ddccea..d6ab6efc8d 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
@@ -24,11 +24,12 @@
 import com.google.android.exoplayer2.drm.ExoMediaCrypto;
 import com.google.android.exoplayer2.util.Util;
 import com.google.android.exoplayer2.video.VideoDecoderInputBuffer;
+import com.google.android.exoplayer2.video.VideoDecoderOutputBuffer;
 import java.nio.ByteBuffer;
 
 /** Vpx decoder. */
 /* package */ final class VpxDecoder
-    extends SimpleDecoder<VideoDecoderInputBuffer, VpxOutputBuffer, VpxDecoderException> {
+    extends SimpleDecoder<VideoDecoderInputBuffer, VideoDecoderOutputBuffer, VpxDecoderException> {
 
   // These constants should match the codes returned from vpxDecode and vpxSecureDecode functions in
   // https://github.com/google/ExoPlayer/blob/release-v2/extensions/vp9/src/main/jni/vpx_jni.cc.
@@ -63,7 +64,9 @@ public VpxDecoder(
       boolean enableRowMultiThreadMode,
       int threads)
       throws VpxDecoderException {
-    super(new VideoDecoderInputBuffer[numInputBuffers], new VpxOutputBuffer[numOutputBuffers]);
+    super(
+        new VideoDecoderInputBuffer[numInputBuffers],
+        new VideoDecoderOutputBuffer[numOutputBuffers]);
     if (!VpxLibrary.isAvailable()) {
       throw new VpxDecoderException("Failed to load decoder native libraries.");
     }
@@ -98,12 +101,12 @@ protected VideoDecoderInputBuffer createInputBuffer() {
   }
 
   @Override
-  protected VpxOutputBuffer createOutputBuffer() {
-    return new VpxOutputBuffer(this);
+  protected VideoDecoderOutputBuffer createOutputBuffer() {
+    return new VideoDecoderOutputBuffer(this::releaseOutputBuffer);
   }
 
   @Override
-  protected void releaseOutputBuffer(VpxOutputBuffer buffer) {
+  protected void releaseOutputBuffer(VideoDecoderOutputBuffer buffer) {
     // Decode only frames do not acquire a reference on the internal decoder buffer and thus do not
     // require a call to vpxReleaseFrame.
     if (outputMode == C.VIDEO_OUTPUT_MODE_SURFACE_YUV && !buffer.isDecodeOnly()) {
@@ -120,7 +123,7 @@ protected VpxDecoderException createUnexpectedDecodeException(Throwable error) {
   @Override
   @Nullable
   protected VpxDecoderException decode(
-      VideoDecoderInputBuffer inputBuffer, VpxOutputBuffer outputBuffer, boolean reset) {
+      VideoDecoderInputBuffer inputBuffer, VideoDecoderOutputBuffer outputBuffer, boolean reset) {
     ByteBuffer inputData = Util.castNonNull(inputBuffer.data);
     int inputSize = inputData.limit();
     CryptoInfo cryptoInfo = inputBuffer.cryptoInfo;
@@ -163,7 +166,7 @@ public void release() {
   }
 
   /** Renders the outputBuffer to the surface. Used with OUTPUT_MODE_SURFACE_YUV only. */
-  public void renderToSurface(VpxOutputBuffer outputBuffer, Surface surface)
+  public void renderToSurface(VideoDecoderOutputBuffer outputBuffer, Surface surface)
       throws VpxDecoderException {
     int getFrameResult = vpxRenderFrame(vpxDecContext, surface, outputBuffer);
     if (getFrameResult == -1) {
@@ -189,19 +192,20 @@ private native long vpxSecureDecode(
       int[] numBytesOfClearData,
       int[] numBytesOfEncryptedData);
 
-  private native int vpxGetFrame(long context, VpxOutputBuffer outputBuffer);
+  private native int vpxGetFrame(long context, VideoDecoderOutputBuffer outputBuffer);
 
   /**
    * Renders the frame to the surface. Used with OUTPUT_MODE_SURFACE_YUV only. Must only be called
    * if {@link #vpxInit} was called with {@code enableBufferManager = true}.
    */
-  private native int vpxRenderFrame(long context, Surface surface, VpxOutputBuffer outputBuffer);
+  private native int vpxRenderFrame(
+      long context, Surface surface, VideoDecoderOutputBuffer outputBuffer);
 
   /**
    * Releases the frame. Used with OUTPUT_MODE_SURFACE_YUV only. Must only be called if {@link
    * #vpxInit} was called with {@code enableBufferManager = true}.
    */
-  private native int vpxReleaseFrame(long context, VpxOutputBuffer outputBuffer);
+  private native int vpxReleaseFrame(long context, VideoDecoderOutputBuffer outputBuffer);
 
   private native int vpxGetErrorCode(long context);
   private native String vpxGetErrorMessage(long context);
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java
index 7177cde12e..1c434032d0 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java
@@ -17,18 +17,22 @@
 
 import com.google.android.exoplayer2.video.VideoDecoderOutputBuffer;
 
-/** Video output buffer, populated by {@link VpxDecoder}. */
+// TODO(b/139174707): Delete this class once binaries in WVVp9OpusPlaybackTest are updated to depend
+// on VideoDecoderOutputBuffer. Also mark VideoDecoderOutputBuffer as final.
+/**
+ * Video output buffer, populated by {@link VpxDecoder}.
+ *
+ * @deprecated Use {@link VideoDecoderOutputBuffer} instead.
+ */
+@Deprecated
 public final class VpxOutputBuffer extends VideoDecoderOutputBuffer {
 
-  private final VpxDecoder owner;
-
-  public VpxOutputBuffer(VpxDecoder owner) {
-    this.owner = owner;
+  /**
+   * Creates VpxOutputBuffer.
+   *
+   * @param owner Buffer owner.
+   */
+  public VpxOutputBuffer(VideoDecoderOutputBuffer.Owner owner) {
+    super(owner);
   }
-
-  @Override
-  public void release() {
-    owner.releaseOutputBuffer(this);
-  }
-
 }
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxRenderer.java
deleted file mode 100644
index d82f5a6071..0000000000
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxRenderer.java
+++ /dev/null
@@ -1,205 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.ext.vp9;
-
-import android.opengl.GLES20;
-import android.opengl.GLSurfaceView;
-import com.google.android.exoplayer2.util.GlUtil;
-import java.nio.FloatBuffer;
-import java.util.concurrent.atomic.AtomicReference;
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.opengles.GL10;
-
-/**
- * GLSurfaceView.Renderer implementation that can render YUV Frames returned by libvpx after
- * decoding. It does the YUV to RGB color conversion in the Fragment Shader.
- */
-/* package */ class VpxRenderer implements GLSurfaceView.Renderer {
-
-  private static final float[] kColorConversion601 = {
-    1.164f, 1.164f, 1.164f,
-    0.0f, -0.392f, 2.017f,
-    1.596f, -0.813f, 0.0f,
-  };
-
-  private static final float[] kColorConversion709 = {
-    1.164f, 1.164f, 1.164f,
-    0.0f, -0.213f, 2.112f,
-    1.793f, -0.533f, 0.0f,
-  };
-
-  private static final float[] kColorConversion2020 = {
-    1.168f, 1.168f, 1.168f,
-    0.0f, -0.188f, 2.148f,
-    1.683f, -0.652f, 0.0f,
-  };
-
-  private static final String VERTEX_SHADER =
-      "varying vec2 interp_tc;\n"
-      + "attribute vec4 in_pos;\n"
-      + "attribute vec2 in_tc;\n"
-      + "void main() {\n"
-      + "  gl_Position = in_pos;\n"
-      + "  interp_tc = in_tc;\n"
-      + "}\n";
-  private static final String[] TEXTURE_UNIFORMS = {"y_tex", "u_tex", "v_tex"};
-  private static final String FRAGMENT_SHADER =
-      "precision mediump float;\n"
-      + "varying vec2 interp_tc;\n"
-      + "uniform sampler2D y_tex;\n"
-      + "uniform sampler2D u_tex;\n"
-      + "uniform sampler2D v_tex;\n"
-      + "uniform mat3 mColorConversion;\n"
-      + "void main() {\n"
-      + "  vec3 yuv;\n"
-      + "  yuv.x = texture2D(y_tex, interp_tc).r - 0.0625;\n"
-      + "  yuv.y = texture2D(u_tex, interp_tc).r - 0.5;\n"
-      + "  yuv.z = texture2D(v_tex, interp_tc).r - 0.5;\n"
-      + "  gl_FragColor = vec4(mColorConversion * yuv, 1.0);\n"
-      + "}\n";
-
-  private static final FloatBuffer TEXTURE_VERTICES =
-      GlUtil.createBuffer(new float[] {-1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f});
-  private final int[] yuvTextures = new int[3];
-  private final AtomicReference<VpxOutputBuffer> pendingOutputBufferReference;
-
-  // Kept in a field rather than a local variable so that it doesn't get garbage collected before
-  // glDrawArrays uses it.
-  @SuppressWarnings("FieldCanBeLocal")
-  private FloatBuffer textureCoords;
-  private int program;
-  private int texLocation;
-  private int colorMatrixLocation;
-  private int previousWidth;
-  private int previousStride;
-
-  private VpxOutputBuffer renderedOutputBuffer; // Accessed only from the GL thread.
-
-  public VpxRenderer() {
-    previousWidth = -1;
-    previousStride = -1;
-    pendingOutputBufferReference = new AtomicReference<>();
-  }
-
-  /**
-   * Set a frame to be rendered. This should be followed by a call to
-   * VpxVideoSurfaceView.requestRender() to actually render the frame.
-   *
-   * @param outputBuffer OutputBuffer containing the YUV Frame to be rendered
-   */
-  public void setFrame(VpxOutputBuffer outputBuffer) {
-    VpxOutputBuffer oldPendingOutputBuffer = pendingOutputBufferReference.getAndSet(outputBuffer);
-    if (oldPendingOutputBuffer != null) {
-      // The old pending output buffer will never be used for rendering, so release it now.
-      oldPendingOutputBuffer.release();
-    }
-  }
-
-  @Override
-  public void onSurfaceCreated(GL10 unused, EGLConfig config) {
-    program = GlUtil.compileProgram(VERTEX_SHADER, FRAGMENT_SHADER);
-    GLES20.glUseProgram(program);
-    int posLocation = GLES20.glGetAttribLocation(program, "in_pos");
-    GLES20.glEnableVertexAttribArray(posLocation);
-    GLES20.glVertexAttribPointer(
-        posLocation, 2, GLES20.GL_FLOAT, false, 0, TEXTURE_VERTICES);
-    texLocation = GLES20.glGetAttribLocation(program, "in_tc");
-    GLES20.glEnableVertexAttribArray(texLocation);
-    GlUtil.checkGlError();
-    colorMatrixLocation = GLES20.glGetUniformLocation(program, "mColorConversion");
-    GlUtil.checkGlError();
-    setupTextures();
-    GlUtil.checkGlError();
-  }
-
-  @Override
-  public void onSurfaceChanged(GL10 unused, int width, int height) {
-    GLES20.glViewport(0, 0, width, height);
-  }
-
-  @Override
-  public void onDrawFrame(GL10 unused) {
-    VpxOutputBuffer pendingOutputBuffer = pendingOutputBufferReference.getAndSet(null);
-    if (pendingOutputBuffer == null && renderedOutputBuffer == null) {
-      // There is no output buffer to render at the moment.
-      return;
-    }
-    if (pendingOutputBuffer != null) {
-      if (renderedOutputBuffer != null) {
-        renderedOutputBuffer.release();
-      }
-      renderedOutputBuffer = pendingOutputBuffer;
-    }
-    VpxOutputBuffer outputBuffer = renderedOutputBuffer;
-    // Set color matrix. Assume BT709 if the color space is unknown.
-    float[] colorConversion = kColorConversion709;
-    switch (outputBuffer.colorspace) {
-      case VpxOutputBuffer.COLORSPACE_BT601:
-        colorConversion = kColorConversion601;
-        break;
-      case VpxOutputBuffer.COLORSPACE_BT2020:
-        colorConversion = kColorConversion2020;
-        break;
-      case VpxOutputBuffer.COLORSPACE_BT709:
-      default:
-        break; // Do nothing
-    }
-    GLES20.glUniformMatrix3fv(colorMatrixLocation, 1, false, colorConversion, 0);
-
-    for (int i = 0; i < 3; i++) {
-      int h = (i == 0) ? outputBuffer.height : (outputBuffer.height + 1) / 2;
-      GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + i);
-      GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, yuvTextures[i]);
-      GLES20.glPixelStorei(GLES20.GL_UNPACK_ALIGNMENT, 1);
-      GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_LUMINANCE,
-          outputBuffer.yuvStrides[i], h, 0, GLES20.GL_LUMINANCE, GLES20.GL_UNSIGNED_BYTE,
-          outputBuffer.yuvPlanes[i]);
-    }
-    // Set cropping of stride if either width or stride has changed.
-    if (previousWidth != outputBuffer.width || previousStride != outputBuffer.yuvStrides[0]) {
-      float crop = (float) outputBuffer.width / outputBuffer.yuvStrides[0];
-      // This buffer is consumed during each call to glDrawArrays. It needs to be a member variable
-      // rather than a local variable to ensure that it doesn't get garbage collected.
-      textureCoords =
-          GlUtil.createBuffer(new float[] {0.0f, 0.0f, 0.0f, 1.0f, crop, 0.0f, crop, 1.0f});
-      GLES20.glVertexAttribPointer(
-          texLocation, 2, GLES20.GL_FLOAT, false, 0, textureCoords);
-      previousWidth = outputBuffer.width;
-      previousStride = outputBuffer.yuvStrides[0];
-    }
-    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
-    GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4);
-    GlUtil.checkGlError();
-  }
-
-  private void setupTextures() {
-    GLES20.glGenTextures(3, yuvTextures, 0);
-    for (int i = 0; i < 3; i++)  {
-      GLES20.glUniform1i(GLES20.glGetUniformLocation(program, TEXTURE_UNIFORMS[i]), i);
-      GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + i);
-      GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, yuvTextures[i]);
-      GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
-          GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
-      GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
-          GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
-      GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
-          GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
-      GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
-          GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
-    }
-    GlUtil.checkGlError();
-  }
-}
diff --git a/extensions/vp9/src/main/jni/vpx_jni.cc b/extensions/vp9/src/main/jni/vpx_jni.cc
index 303672334d..823f9b8cab 100644
--- a/extensions/vp9/src/main/jni/vpx_jni.cc
+++ b/extensions/vp9/src/main/jni/vpx_jni.cc
@@ -38,27 +38,27 @@
 #define LOGE(...) ((void)__android_log_print(ANDROID_LOG_ERROR, LOG_TAG, \
                                              __VA_ARGS__))
 
-#define DECODER_FUNC(RETURN_TYPE, NAME, ...) \
-  extern "C" { \
-  JNIEXPORT RETURN_TYPE \
-    Java_com_google_android_exoplayer2_ext_vp9_VpxDecoder_ ## NAME \
-      (JNIEnv* env, jobject thiz, ##__VA_ARGS__);\
-  } \
-  JNIEXPORT RETURN_TYPE \
-    Java_com_google_android_exoplayer2_ext_vp9_VpxDecoder_ ## NAME \
-      (JNIEnv* env, jobject thiz, ##__VA_ARGS__)\
-
-#define LIBRARY_FUNC(RETURN_TYPE, NAME, ...) \
-  extern "C" { \
-  JNIEXPORT RETURN_TYPE \
-    Java_com_google_android_exoplayer2_ext_vp9_VpxLibrary_ ## NAME \
-      (JNIEnv* env, jobject thiz, ##__VA_ARGS__);\
-  } \
-  JNIEXPORT RETURN_TYPE \
-    Java_com_google_android_exoplayer2_ext_vp9_VpxLibrary_ ## NAME \
-      (JNIEnv* env, jobject thiz, ##__VA_ARGS__)\
-
-// JNI references for VpxOutputBuffer class.
+#define DECODER_FUNC(RETURN_TYPE, NAME, ...)                        \
+  extern "C" {                                                      \
+  JNIEXPORT RETURN_TYPE                                             \
+      Java_com_google_android_exoplayer2_ext_vp9_VpxDecoder_##NAME( \
+          JNIEnv* env, jobject thiz, ##__VA_ARGS__);                \
+  }                                                                 \
+  JNIEXPORT RETURN_TYPE                                             \
+      Java_com_google_android_exoplayer2_ext_vp9_VpxDecoder_##NAME( \
+          JNIEnv* env, jobject thiz, ##__VA_ARGS__)
+
+#define LIBRARY_FUNC(RETURN_TYPE, NAME, ...)                        \
+  extern "C" {                                                      \
+  JNIEXPORT RETURN_TYPE                                             \
+      Java_com_google_android_exoplayer2_ext_vp9_VpxLibrary_##NAME( \
+          JNIEnv* env, jobject thiz, ##__VA_ARGS__);                \
+  }                                                                 \
+  JNIEXPORT RETURN_TYPE                                             \
+      Java_com_google_android_exoplayer2_ext_vp9_VpxLibrary_##NAME( \
+          JNIEnv* env, jobject thiz, ##__VA_ARGS__)
+
+// JNI references for VideoDecoderOutputBuffer class.
 static jmethodID initForYuvFrame;
 static jmethodID initForPrivateFrame;
 static jfieldID dataField;
@@ -477,7 +477,7 @@ DECODER_FUNC(jlong, vpxInit, jboolean disableLoopFilter,
 
   // Populate JNI References.
   const jclass outputBufferClass = env->FindClass(
-      "com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer");
+      "com/google/android/exoplayer2/video/VideoDecoderOutputBuffer");
   initForYuvFrame = env->GetMethodID(outputBufferClass, "initForYuvFrame",
                                      "(IIIII)Z");
   initForPrivateFrame =
@@ -532,15 +532,19 @@ DECODER_FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer) {
     return 1;
   }
 
+  // LINT.IfChange
   const int kOutputModeYuv = 0;
   const int kOutputModeSurfaceYuv = 1;
+  // LINT.ThenChange(../../../../../library/core/src/main/java/com/google/android/exoplayer2/C.java)
 
   int outputMode = env->GetIntField(jOutputBuffer, outputModeField);
   if (outputMode == kOutputModeYuv) {
+    // LINT.IfChange
     const int kColorspaceUnknown = 0;
     const int kColorspaceBT601 = 1;
     const int kColorspaceBT709 = 2;
     const int kColorspaceBT2020 = 3;
+    // LINT.ThenChange(../../../../../library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java)
 
     int colorspace = kColorspaceUnknown;
     switch (img->cs) {
diff --git a/library/core/proguard-rules.txt b/library/core/proguard-rules.txt
index ab3cc5fccd..67646be956 100644
--- a/library/core/proguard-rules.txt
+++ b/library/core/proguard-rules.txt
@@ -61,3 +61,8 @@
 # Don't warn about checkerframework and Kotlin annotations
 -dontwarn org.checkerframework.**
 -dontwarn kotlin.annotations.jvm.**
+
+# Some members of this class are being accessed from native methods. Keep them unobfuscated.
+-keep class com.google.android.exoplayer2.ext.video.VideoDecoderOutputBuffer {
+    *;
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioFocusManager.java b/library/core/src/main/java/com/google/android/exoplayer2/AudioFocusManager.java
similarity index 98%
rename from library/core/src/main/java/com/google/android/exoplayer2/audio/AudioFocusManager.java
rename to library/core/src/main/java/com/google/android/exoplayer2/AudioFocusManager.java
index 44bcdfd495..87d5c05bbe 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioFocusManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/AudioFocusManager.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer2.audio;
+package com.google.android.exoplayer2;
 
 import android.content.Context;
 import android.media.AudioFocusRequest;
@@ -22,9 +22,7 @@
 import androidx.annotation.Nullable;
 import androidx.annotation.RequiresApi;
 import androidx.annotation.VisibleForTesting;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayer;
-import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.audio.AudioAttributes;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
@@ -35,7 +33,7 @@
 import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
 
 /** Manages requesting and responding to changes in audio focus. */
-public final class AudioFocusManager {
+/* package */ final class AudioFocusManager {
 
   /** Interface to allow AudioFocusManager to give commands to a player. */
   public interface PlayerControl {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/BasePlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/BasePlayer.java
index baa2a767b5..2646cbc035 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/BasePlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/BasePlayer.java
@@ -127,6 +127,12 @@ public final boolean isCurrentWindowDynamic() {
     return !timeline.isEmpty() && timeline.getWindow(getCurrentWindowIndex(), window).isDynamic;
   }
 
+  @Override
+  public final boolean isCurrentWindowLive() {
+    Timeline timeline = getCurrentTimeline();
+    return !timeline.isEmpty() && timeline.getWindow(getCurrentWindowIndex(), window).isLive;
+  }
+
   @Override
   public final boolean isCurrentWindowSeekable() {
     Timeline timeline = getCurrentTimeline();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/C.java b/library/core/src/main/java/com/google/android/exoplayer2/C.java
index c8a73fbe9a..b235715f46 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/C.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/C.java
@@ -27,6 +27,8 @@
 import com.google.android.exoplayer2.PlayerMessage.Target;
 import com.google.android.exoplayer2.audio.AuxEffectInfo;
 import com.google.android.exoplayer2.util.Util;
+import com.google.android.exoplayer2.video.SimpleDecoderVideoRenderer;
+import com.google.android.exoplayer2.video.VideoDecoderOutputBufferRenderer;
 import com.google.android.exoplayer2.video.VideoFrameMetadataListener;
 import com.google.android.exoplayer2.video.spherical.CameraMotionListener;
 import java.lang.annotation.Documented;
@@ -823,6 +825,13 @@ private C() {}
    */
   public static final int MSG_SET_CAMERA_MOTION_LISTENER = 7;
 
+  /**
+   * The type of a message that can be passed to a {@link SimpleDecoderVideoRenderer} via {@link
+   * ExoPlayer#createMessage(Target)}. The message payload should be the target {@link
+   * VideoDecoderOutputBufferRenderer}, or null.
+   */
+  public static final int MSG_SET_OUTPUT_BUFFER_RENDERER = 8;
+
   /**
    * Applications or extensions may define custom {@code MSG_*} constants that can be passed to
    * {@link Renderer}s. These custom constants must be greater than or equal to this value.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
index 4418549c8b..7c8a454191 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
@@ -28,7 +28,6 @@
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.MergingMediaSource;
 import com.google.android.exoplayer2.source.ProgressiveMediaSource;
-import com.google.android.exoplayer2.source.ShuffleOrder;
 import com.google.android.exoplayer2.source.SingleSampleMediaSource;
 import com.google.android.exoplayer2.text.TextRenderer;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
@@ -40,7 +39,6 @@
 import com.google.android.exoplayer2.util.Clock;
 import com.google.android.exoplayer2.util.Util;
 import com.google.android.exoplayer2.video.MediaCodecVideoRenderer;
-import java.util.List;
 
 /**
  * An extensible media player that plays {@link MediaSource}s. Instances can be obtained from {@link
@@ -141,7 +139,7 @@
     private LoadControl loadControl;
     private BandwidthMeter bandwidthMeter;
     private Looper looper;
-    @Nullable private AnalyticsCollector analyticsCollector;
+    private AnalyticsCollector analyticsCollector;
     private boolean useLazyPreparation;
     private boolean buildCalled;
 
@@ -172,7 +170,7 @@ public Builder(Context context, Renderer... renderers) {
           new DefaultLoadControl(),
           DefaultBandwidthMeter.getSingletonInstance(context),
           Util.getLooper(),
-          /* analyticsCollector= */ null,
+          new AnalyticsCollector(Clock.DEFAULT),
           /* useLazyPreparation= */ true,
           Clock.DEFAULT);
     }
@@ -199,7 +197,7 @@ public Builder(
         LoadControl loadControl,
         BandwidthMeter bandwidthMeter,
         Looper looper,
-        @Nullable AnalyticsCollector analyticsCollector,
+        AnalyticsCollector analyticsCollector,
         boolean useLazyPreparation,
         Clock clock) {
       Assertions.checkArgument(renderers.length > 0);
@@ -320,156 +318,38 @@ public ExoPlayer build() {
       Assertions.checkState(!buildCalled);
       buildCalled = true;
       return new ExoPlayerImpl(
-          renderers,
-          trackSelector,
-          loadControl,
-          bandwidthMeter,
-          analyticsCollector,
-          useLazyPreparation,
-          clock,
-          looper);
+          renderers, trackSelector, loadControl, bandwidthMeter, clock, looper);
     }
   }
 
   /** Returns the {@link Looper} associated with the playback thread. */
   Looper getPlaybackLooper();
 
-  /** @deprecated Use {@link #prepare()} instead. */
-  @Deprecated
+  /**
+   * Retries a failed or stopped playback. Does nothing if the player has been reset, or if playback
+   * has not failed or been stopped.
+   */
   void retry();
 
-  /** @deprecated Use {@link #setMediaItem(MediaSource)} and {@link #prepare()} instead. */
-  @Deprecated
-  void prepare(MediaSource mediaSource);
-
-  /** @deprecated Use {@link #setMediaItems(List, int, long)} and {@link #prepare()} instead. */
-  @Deprecated
-  void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState);
-
-  /** Prepares the player. */
-  void prepare();
-
   /**
-   * Clears the playlist and adds the specified {@link MediaSource MediaSources}.
-   *
-   * @param mediaItems The new {@link MediaSource MediaSources}.
+   * Prepares the player to play the provided {@link MediaSource}. Equivalent to {@code
+   * prepare(mediaSource, true, true)}.
    */
-  void setMediaItems(List<MediaSource> mediaItems);
+  void prepare(MediaSource mediaSource);
 
   /**
-   * Clears the playlist and adds the specified {@link MediaSource MediaSources}.
+   * Prepares the player to play the provided {@link MediaSource}, optionally resetting the playback
+   * position the default position in the first {@link Timeline.Window}.
    *
-   * @param mediaItems The new {@link MediaSource MediaSources}.
+   * @param mediaSource The {@link MediaSource} to play.
    * @param resetPosition Whether the playback position should be reset to the default position in
    *     the first {@link Timeline.Window}. If false, playback will start from the position defined
    *     by {@link #getCurrentWindowIndex()} and {@link #getCurrentPosition()}.
+   * @param resetState Whether the timeline, manifest, tracks and track selections should be reset.
+   *     Should be true unless the player is being prepared to play the same media as it was playing
+   *     previously (e.g. if playback failed and is being retried).
    */
-  void setMediaItems(List<MediaSource> mediaItems, boolean resetPosition);
-
-  /**
-   * Clears the playlist and adds the specified {@link MediaSource MediaSources}.
-   *
-   * @param mediaItems The new {@link MediaSource MediaSources}.
-   * @param startWindowIndex The window index to start playback from. If {@link C#INDEX_UNSET} is
-   *     passed, the current position is not reset.
-   * @param startPositionMs The position in milliseconds to start playback from. If {@link
-   *     C#TIME_UNSET} is passed, the default position of the given window is used. In any case, if
-   *     {@code startWindowIndex} is set to {@link C#INDEX_UNSET}, this parameter is ignored and the
-   *     position is not reset at all.
-   */
-  void setMediaItems(List<MediaSource> mediaItems, int startWindowIndex, long startPositionMs);
-
-  /**
-   * Clears the playlist and adds the specified {@link MediaSource}.
-   *
-   * @param mediaItem The new {@link MediaSource}.
-   */
-  void setMediaItem(MediaSource mediaItem);
-
-  /**
-   * Clears the playlist and adds the specified {@link MediaSource}.
-   *
-   * @param mediaItem The new {@link MediaSource}.
-   * @param startPositionMs The position in milliseconds to start playback from.
-   */
-  void setMediaItem(MediaSource mediaItem, long startPositionMs);
-
-  /**
-   * Adds a media item to the end of the playlist.
-   *
-   * @param mediaSource The {@link MediaSource} to add.
-   */
-  void addMediaItem(MediaSource mediaSource);
-
-  /**
-   * Adds a media item at the given index of the playlist.
-   *
-   * @param index The index at which to add the item.
-   * @param mediaSource The {@link MediaSource} to add.
-   */
-  void addMediaItem(int index, MediaSource mediaSource);
-
-  /**
-   * Adds a list of media items to the end of the playlist.
-   *
-   * @param mediaSources The {@link MediaSource MediaSources} to add.
-   */
-  void addMediaItems(List<MediaSource> mediaSources);
-
-  /**
-   * Adds a list of media items at the given index of the playlist.
-   *
-   * @param index The index at which to add the media items.
-   * @param mediaSources The {@link MediaSource MediaSources} to add.
-   */
-  void addMediaItems(int index, List<MediaSource> mediaSources);
-
-  /**
-   * Moves the media item at the current index to the new index.
-   *
-   * @param currentIndex The current index of the media item to move.
-   * @param newIndex The new index of the media item. If the new index is larger than the size of
-   *     the playlist the item is moved to the end of the playlist.
-   */
-  void moveMediaItem(int currentIndex, int newIndex);
-
-  /**
-   * Moves the media item range to the new index.
-   *
-   * @param fromIndex The start of the range to move.
-   * @param toIndex The first item not to be included in the range (exclusive).
-   * @param newIndex The new index of the first media item of the range. If the new index is larger
-   *     than the size of the remaining playlist after removing the range, the range is moved to the
-   *     end of the playlist.
-   */
-  void moveMediaItems(int fromIndex, int toIndex, int newIndex);
-
-  /**
-   * Removes the media item at the given index of the playlist.
-   *
-   * @param index The index at which to remove the media item.
-   * @return The removed {@link MediaSource} or null if no item exists at the given index.
-   */
-  @Nullable
-  MediaSource removeMediaItem(int index);
-
-  /**
-   * Removes a range of media items from the playlist.
-   *
-   * @param fromIndex The index at which to start removing media items.
-   * @param toIndex The index of the first item to be kept (exclusive).
-   */
-  void removeMediaItems(int fromIndex, int toIndex);
-
-  /** Clears the playlist. */
-  void clearMediaItems();
-
-  /**
-   * Sets the shuffle order.
-   *
-   * @param shuffleOrder The shuffle order.
-   */
-  void setShuffleOrder(ShuffleOrder shuffleOrder);
+  void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState);
 
   /**
    * Creates a message that can be sent to a {@link PlayerMessage.Target}. By default, the message
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
index b900491b1d..efe351c70a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
@@ -296,7 +296,6 @@ public static SimpleExoPlayer newSimpleInstance(
         drmSessionManager,
         bandwidthMeter,
         analyticsCollector,
-        /* useLazyPreparation= */ true,
         Clock.DEFAULT,
         looper);
   }
@@ -345,13 +344,6 @@ public static ExoPlayer newInstance(
       BandwidthMeter bandwidthMeter,
       Looper looper) {
     return new ExoPlayerImpl(
-        renderers,
-        trackSelector,
-        loadControl,
-        bandwidthMeter,
-        /* analyticsCollector= */ null,
-        /* useLazyPreparation= */ true,
-        Clock.DEFAULT,
-        looper);
+        renderers, trackSelector, loadControl, bandwidthMeter, Clock.DEFAULT, looper);
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
index b9f29e2cb3..dd8fbee53c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
@@ -22,10 +22,8 @@
 import android.util.Pair;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.PlayerMessage.Target;
-import com.google.android.exoplayer2.analytics.AnalyticsCollector;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
-import com.google.android.exoplayer2.source.ShuffleOrder;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
@@ -37,9 +35,6 @@
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
 import java.util.concurrent.CopyOnWriteArrayList;
 
 /**
@@ -66,20 +61,19 @@
   private final CopyOnWriteArrayList<ListenerHolder> listeners;
   private final Timeline.Period period;
   private final ArrayDeque<Runnable> pendingListenerNotifications;
-  private final List<Playlist.MediaSourceHolder> mediaSourceHolders;
-  private final boolean useLazyPreparation;
 
+  private MediaSource mediaSource;
   private boolean playWhenReady;
   @PlaybackSuppressionReason private int playbackSuppressionReason;
   @RepeatMode private int repeatMode;
   private boolean shuffleModeEnabled;
   private int pendingOperationAcks;
+  private boolean hasPendingPrepare;
   private boolean hasPendingSeek;
   private boolean foregroundMode;
   private int pendingSetPlaybackParametersAcks;
   private PlaybackParameters playbackParameters;
   private SeekParameters seekParameters;
-  private ShuffleOrder shuffleOrder;
 
   // Playback information when there is no pending seek/set source operation.
   private PlaybackInfo playbackInfo;
@@ -96,10 +90,6 @@
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    * @param loadControl The {@link LoadControl} that will be used by the instance.
    * @param bandwidthMeter The {@link BandwidthMeter} that will be used by the instance.
-   * @param analyticsCollector The {@link AnalyticsCollector} that will be used by the instance.
-   * @param useLazyPreparation Whether playlist items are prepared lazily. If false, all manifest
-   *     loads and other initial preparation steps happen immediately. If true, these initial
-   *     preparations are triggered only when the player starts buffering the media.
    * @param clock The {@link Clock} that will be used by the instance.
    * @param looper The {@link Looper} which must be used for all calls to the player and which is
    *     used to call listeners on.
@@ -110,8 +100,6 @@ public ExoPlayerImpl(
       TrackSelector trackSelector,
       LoadControl loadControl,
       BandwidthMeter bandwidthMeter,
-      @Nullable AnalyticsCollector analyticsCollector,
-      boolean useLazyPreparation,
       Clock clock,
       Looper looper) {
     Log.i(TAG, "Init " + Integer.toHexString(System.identityHashCode(this)) + " ["
@@ -119,13 +107,10 @@ public ExoPlayerImpl(
     Assertions.checkState(renderers.length > 0);
     this.renderers = Assertions.checkNotNull(renderers);
     this.trackSelector = Assertions.checkNotNull(trackSelector);
-    this.useLazyPreparation = useLazyPreparation;
-    playWhenReady = false;
-    repeatMode = Player.REPEAT_MODE_OFF;
-    shuffleModeEnabled = false;
-    listeners = new CopyOnWriteArrayList<>();
-    mediaSourceHolders = new ArrayList<>();
-    shuffleOrder = new ShuffleOrder.DefaultShuffleOrder(/* length= */ 0);
+    this.playWhenReady = false;
+    this.repeatMode = Player.REPEAT_MODE_OFF;
+    this.shuffleModeEnabled = false;
+    this.listeners = new CopyOnWriteArrayList<>();
     emptyTrackSelectorResult =
         new TrackSelectorResult(
             new RendererConfiguration[renderers.length],
@@ -144,9 +129,6 @@ public void handleMessage(Message msg) {
         };
     playbackInfo = PlaybackInfo.createDummy(/* startPositionUs= */ 0, emptyTrackSelectorResult);
     pendingListenerNotifications = new ArrayDeque<>();
-    if (analyticsCollector != null) {
-      analyticsCollector.setPlayer(this);
-    }
     internalPlayer =
         new ExoPlayerImplInternal(
             renderers,
@@ -157,7 +139,6 @@ public void handleMessage(Message msg) {
             playWhenReady,
             repeatMode,
             shuffleModeEnabled,
-            analyticsCollector,
             eventHandler,
             clock);
     internalPlayerHandler = new Handler(internalPlayer.getPlaybackLooper());
@@ -231,168 +212,41 @@ public ExoPlaybackException getPlaybackError() {
   }
 
   @Override
-  @Deprecated
   public void retry() {
-    prepare();
+    if (mediaSource != null && playbackInfo.playbackState == Player.STATE_IDLE) {
+      prepare(mediaSource, /* resetPosition= */ false, /* resetState= */ false);
+    }
   }
 
   @Override
-  public void prepare() {
-    if (playbackInfo.playbackState != Player.STATE_IDLE) {
-      return;
-    }
+  public void prepare(MediaSource mediaSource) {
+    prepare(mediaSource, /* resetPosition= */ true, /* resetState= */ true);
+  }
+
+  @Override
+  public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
+    this.mediaSource = mediaSource;
     PlaybackInfo playbackInfo =
         getResetPlaybackInfo(
-            /* clearPlaylist= */ false,
+            resetPosition,
+            resetState,
             /* resetError= */ true,
             /* playbackState= */ Player.STATE_BUFFERING);
     // Trigger internal prepare first before updating the playback info and notifying external
     // listeners to ensure that new operations issued in the listener notifications reach the
     // player after this prepare. The internal player can't change the playback info immediately
     // because it uses a callback.
+    hasPendingPrepare = true;
     pendingOperationAcks++;
-    internalPlayer.prepare();
+    internalPlayer.prepare(mediaSource, resetPosition, resetState);
     updatePlaybackInfo(
         playbackInfo,
         /* positionDiscontinuity= */ false,
         /* ignored */ DISCONTINUITY_REASON_INTERNAL,
-        /* ignored */ TIMELINE_CHANGE_REASON_SOURCE_UPDATE,
+        TIMELINE_CHANGE_REASON_RESET,
         /* seekProcessed= */ false);
   }
 
-  @Override
-  @Deprecated
-  public void prepare(MediaSource mediaSource) {
-    setMediaItem(mediaSource);
-    prepare();
-  }
-
-  @Override
-  @Deprecated
-  public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
-    setMediaItem(
-        mediaSource, /* startPositionMs= */ resetPosition ? C.TIME_UNSET : getCurrentPosition());
-    prepare();
-  }
-
-  @Override
-  public void setMediaItem(MediaSource mediaItem) {
-    setMediaItems(Collections.singletonList(mediaItem));
-  }
-
-  @Override
-  public void setMediaItem(MediaSource mediaItem, long startPositionMs) {
-    setMediaItems(Collections.singletonList(mediaItem), /* startWindowIndex= */ 0, startPositionMs);
-  }
-
-  @Override
-  public void setMediaItems(List<MediaSource> mediaItems) {
-    setMediaItems(
-        mediaItems, /* startWindowIndex= */ C.INDEX_UNSET, /* startPositionMs */ C.TIME_UNSET);
-  }
-
-  @Override
-  public void setMediaItems(List<MediaSource> mediaItems, boolean resetPosition) {
-    setMediaItems(
-        mediaItems,
-        /* startWindowIndex= */ resetPosition ? C.INDEX_UNSET : getCurrentWindowIndex(),
-        /* startPositionMs= */ resetPosition ? C.TIME_UNSET : getCurrentPosition());
-  }
-
-  @Override
-  public void setMediaItems(
-      List<MediaSource> mediaItems, int startWindowIndex, long startPositionMs) {
-    pendingOperationAcks++;
-    if (!mediaSourceHolders.isEmpty()) {
-      removeMediaSourceHolders(
-          /* fromIndex= */ 0, /* toIndexExclusive= */ mediaSourceHolders.size());
-    }
-    List<Playlist.MediaSourceHolder> holders = addMediaSourceHolders(/* index= */ 0, mediaItems);
-    Timeline timeline = maskTimeline();
-    internalPlayer.setMediaItems(
-        holders, startWindowIndex, C.msToUs(startPositionMs), shuffleOrder);
-    notifyListeners(
-        listener -> listener.onTimelineChanged(timeline, TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED));
-  }
-
-  @Override
-  public void addMediaItem(MediaSource mediaSource) {
-    addMediaItems(Collections.singletonList(mediaSource));
-  }
-
-  @Override
-  public void addMediaItem(int index, MediaSource mediaSource) {
-    addMediaItems(index, Collections.singletonList(mediaSource));
-  }
-
-  @Override
-  public void addMediaItems(List<MediaSource> mediaSources) {
-    addMediaItems(/* index= */ mediaSourceHolders.size(), mediaSources);
-  }
-
-  @Override
-  public void addMediaItems(int index, List<MediaSource> mediaSources) {
-    Assertions.checkArgument(index >= 0);
-    pendingOperationAcks++;
-    List<Playlist.MediaSourceHolder> holders = addMediaSourceHolders(index, mediaSources);
-    Timeline timeline = maskTimeline();
-    internalPlayer.addMediaItems(index, holders, shuffleOrder);
-    notifyListeners(
-        listener -> listener.onTimelineChanged(timeline, TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED));
-  }
-
-  @Override
-  public MediaSource removeMediaItem(int index) {
-    List<Playlist.MediaSourceHolder> mediaSourceHolders =
-        removeMediaItemsInternal(/* fromIndex= */ index, /* toIndex= */ index + 1);
-    return mediaSourceHolders.isEmpty() ? null : mediaSourceHolders.get(0).mediaSource;
-  }
-
-  @Override
-  public void removeMediaItems(int fromIndex, int toIndex) {
-    Assertions.checkArgument(toIndex > fromIndex);
-    removeMediaItemsInternal(fromIndex, toIndex);
-  }
-
-  @Override
-  public void moveMediaItem(int currentIndex, int newIndex) {
-    Assertions.checkArgument(currentIndex != newIndex);
-    moveMediaItems(/* fromIndex= */ currentIndex, /* toIndex= */ currentIndex + 1, newIndex);
-  }
-
-  @Override
-  public void moveMediaItems(int fromIndex, int toIndex, int newFromIndex) {
-    Assertions.checkArgument(
-        fromIndex >= 0
-            && fromIndex <= toIndex
-            && toIndex <= mediaSourceHolders.size()
-            && newFromIndex >= 0);
-    pendingOperationAcks++;
-    newFromIndex = Math.min(newFromIndex, mediaSourceHolders.size() - (toIndex - fromIndex));
-    Playlist.moveMediaSourceHolders(mediaSourceHolders, fromIndex, toIndex, newFromIndex);
-    Timeline timeline = maskTimeline();
-    internalPlayer.moveMediaItems(fromIndex, toIndex, newFromIndex, shuffleOrder);
-    notifyListeners(
-        listener -> listener.onTimelineChanged(timeline, TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED));
-  }
-
-  @Override
-  public void clearMediaItems() {
-    if (mediaSourceHolders.isEmpty()) {
-      return;
-    }
-    removeMediaItemsInternal(/* fromIndex= */ 0, /* toIndex= */ mediaSourceHolders.size());
-  }
-
-  @Override
-  public void setShuffleOrder(ShuffleOrder shuffleOrder) {
-    pendingOperationAcks++;
-    this.shuffleOrder = shuffleOrder;
-    Timeline timeline = maskTimeline();
-    internalPlayer.setShuffleOrder(shuffleOrder);
-    notifyListeners(
-        listener -> listener.onTimelineChanged(timeline, TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED));
-  }
 
   @Override
   public void setPlayWhenReady(boolean playWhenReady) {
@@ -410,17 +264,21 @@ public void setPlayWhenReady(
       internalPlayer.setPlayWhenReady(internalPlayWhenReady);
     }
     boolean playWhenReadyChanged = this.playWhenReady != playWhenReady;
+    boolean suppressionReasonChanged = this.playbackSuppressionReason != playbackSuppressionReason;
     this.playWhenReady = playWhenReady;
     this.playbackSuppressionReason = playbackSuppressionReason;
     boolean isPlaying = isPlaying();
     boolean isPlayingChanged = oldIsPlaying != isPlaying;
-    if (playWhenReadyChanged || isPlayingChanged) {
+    if (playWhenReadyChanged || suppressionReasonChanged || isPlayingChanged) {
       int playbackState = playbackInfo.playbackState;
       notifyListeners(
           listener -> {
             if (playWhenReadyChanged) {
               listener.onPlayerStateChanged(playWhenReady, playbackState);
             }
+            if (suppressionReasonChanged) {
+              listener.onPlaybackSuppressionReasonChanged(playbackSuppressionReason);
+            }
             if (isPlayingChanged) {
               listener.onIsPlayingChanged(isPlaying);
             }
@@ -550,9 +408,13 @@ public void setForegroundMode(boolean foregroundMode) {
 
   @Override
   public void stop(boolean reset) {
+    if (reset) {
+      mediaSource = null;
+    }
     PlaybackInfo playbackInfo =
         getResetPlaybackInfo(
-            /* clearPlaylist= */ reset,
+            /* resetPosition= */ reset,
+            /* resetState= */ reset,
             /* resetError= */ reset,
             /* playbackState= */ Player.STATE_IDLE);
     // Trigger internal stop first before updating the playback info and notifying external
@@ -565,7 +427,7 @@ public void stop(boolean reset) {
         playbackInfo,
         /* positionDiscontinuity= */ false,
         /* ignored */ DISCONTINUITY_REASON_INTERNAL,
-        TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
+        TIMELINE_CHANGE_REASON_RESET,
         /* seekProcessed= */ false);
   }
 
@@ -574,11 +436,13 @@ public void release() {
     Log.i(TAG, "Release " + Integer.toHexString(System.identityHashCode(this)) + " ["
         + ExoPlayerLibraryInfo.VERSION_SLASHY + "] [" + Util.DEVICE_DEBUG_INFO + "] ["
         + ExoPlayerLibraryInfo.registeredModules() + "]");
+    mediaSource = null;
     internalPlayer.release();
     eventHandler.removeCallbacksAndMessages(null);
     playbackInfo =
         getResetPlaybackInfo(
-            /* clearPlaylist= */ false,
+            /* resetPosition= */ false,
+            /* resetState= */ false,
             /* resetError= */ false,
             /* playbackState= */ Player.STATE_IDLE);
   }
@@ -726,11 +590,10 @@ public Timeline getCurrentTimeline() {
 
   // Not private so it can be called from an inner class without going through a thunk method.
   /* package */ void handleEvent(Message msg) {
-
     switch (msg.what) {
       case ExoPlayerImplInternal.MSG_PLAYBACK_INFO_CHANGED:
         handlePlaybackInfo(
-            /* playbackInfo= */ (PlaybackInfo) msg.obj,
+            (PlaybackInfo) msg.obj,
             /* operationAcks= */ msg.arg1,
             /* positionDiscontinuity= */ msg.arg2 != C.INDEX_UNSET,
             /* positionDiscontinuityReason= */ msg.arg2);
@@ -778,23 +641,29 @@ private void handlePlaybackInfo(
         maskingWindowIndex = 0;
         maskingWindowPositionMs = 0;
       }
+      @Player.TimelineChangeReason
+      int timelineChangeReason =
+          hasPendingPrepare
+              ? Player.TIMELINE_CHANGE_REASON_PREPARED
+              : Player.TIMELINE_CHANGE_REASON_DYNAMIC;
       boolean seekProcessed = hasPendingSeek;
+      hasPendingPrepare = false;
       hasPendingSeek = false;
       updatePlaybackInfo(
           playbackInfo,
           positionDiscontinuity,
           positionDiscontinuityReason,
-          TIMELINE_CHANGE_REASON_SOURCE_UPDATE,
+          timelineChangeReason,
           seekProcessed);
     }
   }
 
   private PlaybackInfo getResetPlaybackInfo(
-      boolean clearPlaylist, boolean resetError, @Player.State int playbackState) {
-    if (clearPlaylist) {
-      // Reset list of media source holders which are used for creating the masking timeline.
-      removeMediaSourceHolders(
-          /* fromIndex= */ 0, /* toIndexExclusive= */ mediaSourceHolders.size());
+      boolean resetPosition,
+      boolean resetState,
+      boolean resetError,
+      @Player.State int playbackState) {
+    if (resetPosition) {
       maskingWindowIndex = 0;
       maskingPeriodIndex = 0;
       maskingWindowPositionMs = 0;
@@ -803,22 +672,24 @@ private PlaybackInfo getResetPlaybackInfo(
       maskingPeriodIndex = getCurrentPeriodIndex();
       maskingWindowPositionMs = getCurrentPosition();
     }
+    // Also reset period-based PlaybackInfo positions if resetting the state.
+    resetPosition = resetPosition || resetState;
     MediaPeriodId mediaPeriodId =
-        clearPlaylist
+        resetPosition
             ? playbackInfo.getDummyFirstMediaPeriodId(shuffleModeEnabled, window, period)
             : playbackInfo.periodId;
-    long startPositionUs = clearPlaylist ? 0 : playbackInfo.positionUs;
-    long contentPositionUs = clearPlaylist ? C.TIME_UNSET : playbackInfo.contentPositionUs;
+    long startPositionUs = resetPosition ? 0 : playbackInfo.positionUs;
+    long contentPositionUs = resetPosition ? C.TIME_UNSET : playbackInfo.contentPositionUs;
     return new PlaybackInfo(
-        clearPlaylist ? Timeline.EMPTY : playbackInfo.timeline,
+        resetState ? Timeline.EMPTY : playbackInfo.timeline,
         mediaPeriodId,
         startPositionUs,
         contentPositionUs,
         playbackState,
         resetError ? null : playbackInfo.playbackError,
         /* isLoading= */ false,
-        clearPlaylist ? TrackGroupArray.EMPTY : playbackInfo.trackGroups,
-        clearPlaylist ? emptyTrackSelectorResult : playbackInfo.trackSelectorResult,
+        resetState ? TrackGroupArray.EMPTY : playbackInfo.trackGroups,
+        resetState ? emptyTrackSelectorResult : playbackInfo.trackSelectorResult,
         mediaPeriodId,
         startPositionUs,
         /* totalBufferedDurationUs= */ 0,
@@ -828,8 +699,8 @@ private PlaybackInfo getResetPlaybackInfo(
   private void updatePlaybackInfo(
       PlaybackInfo playbackInfo,
       boolean positionDiscontinuity,
-      @DiscontinuityReason int positionDiscontinuityReason,
-      @TimelineChangeReason int timelineChangeReason,
+      @Player.DiscontinuityReason int positionDiscontinuityReason,
+      @Player.TimelineChangeReason int timelineChangeReason,
       boolean seekProcessed) {
     boolean previousIsPlaying = isPlaying();
     // Assign playback info immediately such that all getters return the right values.
@@ -850,53 +721,6 @@ private void updatePlaybackInfo(
             /* isPlayingChanged= */ previousIsPlaying != isPlaying));
   }
 
-  private List<Playlist.MediaSourceHolder> addMediaSourceHolders(
-      int index, List<MediaSource> mediaSources) {
-    List<Playlist.MediaSourceHolder> holders = new ArrayList<>();
-    for (int i = 0; i < mediaSources.size(); i++) {
-      Playlist.MediaSourceHolder holder =
-          new Playlist.MediaSourceHolder(mediaSources.get(i), useLazyPreparation);
-      holders.add(holder);
-      mediaSourceHolders.add(i + index, holder);
-    }
-    shuffleOrder =
-        shuffleOrder.cloneAndInsert(
-            /* insertionIndex= */ index, /* insertionCount= */ holders.size());
-    return holders;
-  }
-
-  private List<Playlist.MediaSourceHolder> removeMediaItemsInternal(int fromIndex, int toIndex) {
-    Assertions.checkArgument(
-        fromIndex >= 0 && toIndex >= fromIndex && toIndex <= mediaSourceHolders.size());
-    pendingOperationAcks++;
-    List<Playlist.MediaSourceHolder> mediaSourceHolders =
-        removeMediaSourceHolders(fromIndex, /* toIndexExclusive= */ toIndex);
-    Timeline timeline = maskTimeline();
-    internalPlayer.removeMediaItems(fromIndex, toIndex, shuffleOrder);
-    notifyListeners(
-        listener -> listener.onTimelineChanged(timeline, TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED));
-    return mediaSourceHolders;
-  }
-
-  private List<Playlist.MediaSourceHolder> removeMediaSourceHolders(
-      int fromIndex, int toIndexExclusive) {
-    List<Playlist.MediaSourceHolder> removed = new ArrayList<>();
-    for (int i = toIndexExclusive - 1; i >= fromIndex; i--) {
-      removed.add(mediaSourceHolders.remove(i));
-    }
-    shuffleOrder = shuffleOrder.cloneAndRemove(fromIndex, toIndexExclusive);
-    return removed;
-  }
-
-  private Timeline maskTimeline() {
-    playbackInfo =
-        playbackInfo.copyWithTimeline(
-            mediaSourceHolders.isEmpty()
-                ? Timeline.EMPTY
-                : new Playlist.PlaylistTimeline(mediaSourceHolders, shuffleOrder));
-    return playbackInfo.timeline;
-  }
-
   private void notifyListeners(ListenerInvocation listenerInvocation) {
     CopyOnWriteArrayList<ListenerHolder> listenerSnapshot = new CopyOnWriteArrayList<>(listeners);
     notifyListeners(() -> invokeAll(listenerSnapshot, listenerInvocation));
@@ -932,7 +756,7 @@ private boolean shouldMaskPosition() {
     private final TrackSelector trackSelector;
     private final boolean positionDiscontinuity;
     private final @Player.DiscontinuityReason int positionDiscontinuityReason;
-    private final int timelineChangeReason;
+    private final @Player.TimelineChangeReason int timelineChangeReason;
     private final boolean seekProcessed;
     private final boolean playbackStateChanged;
     private final boolean playbackErrorChanged;
@@ -966,16 +790,15 @@ public PlaybackInfoUpdate(
       playbackErrorChanged =
           previousPlaybackInfo.playbackError != playbackInfo.playbackError
               && playbackInfo.playbackError != null;
+      timelineChanged = previousPlaybackInfo.timeline != playbackInfo.timeline;
       isLoadingChanged = previousPlaybackInfo.isLoading != playbackInfo.isLoading;
-      timelineChanged =
-          !Util.areTimelinesSame(previousPlaybackInfo.timeline, playbackInfo.timeline);
       trackSelectorResultChanged =
           previousPlaybackInfo.trackSelectorResult != playbackInfo.trackSelectorResult;
     }
 
     @Override
     public void run() {
-      if (timelineChanged) {
+      if (timelineChanged || timelineChangeReason == TIMELINE_CHANGE_REASON_PREPARED) {
         invokeAll(
             listenerSnapshot,
             listener -> listener.onTimelineChanged(playbackInfo.timeline, timelineChangeReason));
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
index 49de45c771..f5c4b40d55 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
@@ -26,11 +26,11 @@
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.DefaultMediaClock.PlaybackParameterListener;
 import com.google.android.exoplayer2.Player.DiscontinuityReason;
-import com.google.android.exoplayer2.analytics.AnalyticsCollector;
 import com.google.android.exoplayer2.source.MediaPeriod;
+import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+import com.google.android.exoplayer2.source.MediaSource.MediaSourceCaller;
 import com.google.android.exoplayer2.source.SampleStream;
-import com.google.android.exoplayer2.source.ShuffleOrder;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
@@ -45,7 +45,6 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 /** Implements the internal behavior of {@link ExoPlayerImpl}. */
@@ -53,7 +52,7 @@
     implements Handler.Callback,
         MediaPeriod.Callback,
         TrackSelector.InvalidationListener,
-        Playlist.PlaylistInfoRefreshListener,
+        MediaSourceCaller,
         PlaybackParameterListener,
         PlayerMessage.Sender {
 
@@ -72,21 +71,16 @@
   private static final int MSG_SET_SEEK_PARAMETERS = 5;
   private static final int MSG_STOP = 6;
   private static final int MSG_RELEASE = 7;
-  private static final int MSG_PERIOD_PREPARED = 8;
-  private static final int MSG_SOURCE_CONTINUE_LOADING_REQUESTED = 9;
-  private static final int MSG_TRACK_SELECTION_INVALIDATED = 10;
-  private static final int MSG_SET_REPEAT_MODE = 11;
-  private static final int MSG_SET_SHUFFLE_ENABLED = 12;
-  private static final int MSG_SET_FOREGROUND_MODE = 13;
-  private static final int MSG_SEND_MESSAGE = 14;
-  private static final int MSG_SEND_MESSAGE_TO_TARGET_THREAD = 15;
-  private static final int MSG_PLAYBACK_PARAMETERS_CHANGED_INTERNAL = 16;
-  private static final int MSG_SET_MEDIA_ITEMS = 17;
-  private static final int MSG_ADD_MEDIA_ITEMS = 18;
-  private static final int MSG_MOVE_MEDIA_ITEMS = 19;
-  private static final int MSG_REMOVE_MEDIA_ITEMS = 20;
-  private static final int MSG_SET_SHUFFLE_ORDER = 21;
-  private static final int MSG_PLAYLIST_UPDATE_REQUESTED = 22;
+  private static final int MSG_REFRESH_SOURCE_INFO = 8;
+  private static final int MSG_PERIOD_PREPARED = 9;
+  private static final int MSG_SOURCE_CONTINUE_LOADING_REQUESTED = 10;
+  private static final int MSG_TRACK_SELECTION_INVALIDATED = 11;
+  private static final int MSG_SET_REPEAT_MODE = 12;
+  private static final int MSG_SET_SHUFFLE_ENABLED = 13;
+  private static final int MSG_SET_FOREGROUND_MODE = 14;
+  private static final int MSG_SEND_MESSAGE = 15;
+  private static final int MSG_SEND_MESSAGE_TO_TARGET_THREAD = 16;
+  private static final int MSG_PLAYBACK_PARAMETERS_CHANGED_INTERNAL = 17;
 
   private static final int ACTIVE_INTERVAL_MS = 10;
   private static final int IDLE_INTERVAL_MS = 1000;
@@ -109,21 +103,23 @@
   private final ArrayList<PendingMessageInfo> pendingMessages;
   private final Clock clock;
   private final MediaPeriodQueue queue;
-  private final Playlist playlist;
 
   @SuppressWarnings("unused")
   private SeekParameters seekParameters;
 
   private PlaybackInfo playbackInfo;
+  private MediaSource mediaSource;
   private Renderer[] enabledRenderers;
   private boolean released;
   private boolean playWhenReady;
   private boolean rebuffering;
+  private boolean shouldContinueLoading;
   @Player.RepeatMode private int repeatMode;
   private boolean shuffleModeEnabled;
   private boolean foregroundMode;
 
-  @Nullable private SeekPosition pendingInitialSeekPosition;
+  private int pendingPrepareCount;
+  private SeekPosition pendingInitialSeekPosition;
   private long rendererPositionUs;
   private int nextPendingMessageIndex;
 
@@ -136,7 +132,6 @@ public ExoPlayerImplInternal(
       boolean playWhenReady,
       @Player.RepeatMode int repeatMode,
       boolean shuffleModeEnabled,
-      @Nullable AnalyticsCollector analyticsCollector,
       Handler eventHandler,
       Clock clock) {
     this.renderers = renderers;
@@ -176,14 +171,12 @@ public ExoPlayerImplInternal(
         new HandlerThread("ExoPlayerImplInternal:Handler", Process.THREAD_PRIORITY_AUDIO);
     internalPlaybackThread.start();
     handler = clock.createHandler(internalPlaybackThread.getLooper(), this);
-    playlist = new Playlist(this);
-    if (analyticsCollector != null) {
-      playlist.setAnalyticsCollector(eventHandler, analyticsCollector);
-    }
   }
 
-  public void prepare() {
-    handler.obtainMessage(MSG_PREPARE).sendToTarget();
+  public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
+    handler
+        .obtainMessage(MSG_PREPARE, resetPosition ? 1 : 0, resetState ? 1 : 0, mediaSource)
+        .sendToTarget();
   }
 
   public void setPlayWhenReady(boolean playWhenReady) {
@@ -216,65 +209,9 @@ public void stop(boolean reset) {
     handler.obtainMessage(MSG_STOP, reset ? 1 : 0, 0).sendToTarget();
   }
 
-  public void setMediaItems(
-      List<Playlist.MediaSourceHolder> mediaSources, ShuffleOrder shuffleOrder) {
-    setMediaItems(
-        mediaSources,
-        /* windowIndex= */ C.INDEX_UNSET,
-        /* positionUs= */ C.TIME_UNSET,
-        shuffleOrder);
-  }
-
-  public void setMediaItems(
-      List<Playlist.MediaSourceHolder> mediaSources,
-      int windowIndex,
-      long positionUs,
-      ShuffleOrder shuffleOrder) {
-    handler
-        .obtainMessage(
-            MSG_SET_MEDIA_ITEMS,
-            new PlaylistUpdateMessage(mediaSources, shuffleOrder, windowIndex, positionUs))
-        .sendToTarget();
-  }
-
-  public void addMediaItems(
-      List<Playlist.MediaSourceHolder> mediaSources, ShuffleOrder shuffleOrder) {
-    addMediaItems(C.INDEX_UNSET, mediaSources, shuffleOrder);
-  }
-
-  public void addMediaItems(
-      int index, List<Playlist.MediaSourceHolder> mediaSources, ShuffleOrder shuffleOrder) {
-    handler
-        .obtainMessage(
-            MSG_ADD_MEDIA_ITEMS,
-            index,
-            /* ignored */ 0,
-            new PlaylistUpdateMessage(
-                mediaSources,
-                shuffleOrder,
-                /* windowIndex= */ C.INDEX_UNSET,
-                /* positionUs= */ C.TIME_UNSET))
-        .sendToTarget();
-  }
-
-  public void removeMediaItems(int fromIndex, int toIndex, ShuffleOrder shuffleOrder) {
-    handler.obtainMessage(MSG_REMOVE_MEDIA_ITEMS, fromIndex, toIndex, shuffleOrder).sendToTarget();
-  }
-
-  public void moveMediaItems(
-      int fromIndex, int toIndex, int newFromIndex, ShuffleOrder shuffleOrder) {
-    MoveMediaItemsMessage moveMediaItemsMessage =
-        new MoveMediaItemsMessage(fromIndex, toIndex, newFromIndex, shuffleOrder);
-    handler.obtainMessage(MSG_MOVE_MEDIA_ITEMS, moveMediaItemsMessage).sendToTarget();
-  }
-
-  public void setShuffleOrder(ShuffleOrder shuffleOrder) {
-    handler.obtainMessage(MSG_SET_SHUFFLE_ORDER, shuffleOrder).sendToTarget();
-  }
-
   @Override
   public synchronized void sendMessage(PlayerMessage message) {
-    if (released) {
+    if (released || !internalPlaybackThread.isAlive()) {
       Log.w(TAG, "Ignoring messages sent after release.");
       message.markAsProcessed(/* isDelivered= */ false);
       return;
@@ -283,6 +220,9 @@ public synchronized void sendMessage(PlayerMessage message) {
   }
 
   public synchronized void setForegroundMode(boolean foregroundMode) {
+    if (released || !internalPlaybackThread.isAlive()) {
+      return;
+    }
     if (foregroundMode) {
       handler.obtainMessage(MSG_SET_FOREGROUND_MODE, /* foregroundMode */ 1, 0).sendToTarget();
     } else {
@@ -291,7 +231,7 @@ public synchronized void setForegroundMode(boolean foregroundMode) {
           .obtainMessage(MSG_SET_FOREGROUND_MODE, /* foregroundMode */ 0, 0, processedFlag)
           .sendToTarget();
       boolean wasInterrupted = false;
-      while (!processedFlag.get() && !released) {
+      while (!processedFlag.get()) {
         try {
           wait();
         } catch (InterruptedException e) {
@@ -306,7 +246,7 @@ public synchronized void setForegroundMode(boolean foregroundMode) {
   }
 
   public synchronized void release() {
-    if (released) {
+    if (released || !internalPlaybackThread.isAlive()) {
       return;
     }
     handler.sendEmptyMessage(MSG_RELEASE);
@@ -328,11 +268,13 @@ public Looper getPlaybackLooper() {
     return internalPlaybackThread.getLooper();
   }
 
-  // Playlist.PlaylistInfoRefreshListener implementation.
+  // MediaSource.MediaSourceCaller implementation.
 
   @Override
-  public void onPlaylistUpdateRequested() {
-    handler.sendEmptyMessage(MSG_PLAYLIST_UPDATE_REQUESTED);
+  public void onSourceInfoRefreshed(MediaSource source, Timeline timeline) {
+    handler
+        .obtainMessage(MSG_REFRESH_SOURCE_INFO, new MediaSourceRefreshInfo(source, timeline))
+        .sendToTarget();
   }
 
   // MediaPeriod.Callback implementation.
@@ -364,12 +306,14 @@ public void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {
   // Handler.Callback implementation.
 
   @Override
-  @SuppressWarnings("unchecked")
   public boolean handleMessage(Message msg) {
     try {
       switch (msg.what) {
         case MSG_PREPARE:
-          prepareInternal();
+          prepareInternal(
+              (MediaSource) msg.obj,
+              /* resetPosition= */ msg.arg1 != 0,
+              /* resetState= */ msg.arg2 != 0);
           break;
         case MSG_SET_PLAY_WHEN_READY:
           setPlayWhenReadyInternal(msg.arg1 != 0);
@@ -405,6 +349,9 @@ public boolean handleMessage(Message msg) {
         case MSG_PERIOD_PREPARED:
           handlePeriodPrepared((MediaPeriod) msg.obj);
           break;
+        case MSG_REFRESH_SOURCE_INFO:
+          handleSourceInfoRefreshed((MediaSourceRefreshInfo) msg.obj);
+          break;
         case MSG_SOURCE_CONTINUE_LOADING_REQUESTED:
           handleContinueLoadingRequested((MediaPeriod) msg.obj);
           break;
@@ -421,24 +368,6 @@ public boolean handleMessage(Message msg) {
         case MSG_SEND_MESSAGE_TO_TARGET_THREAD:
           sendMessageToTargetThread((PlayerMessage) msg.obj);
           break;
-        case MSG_SET_MEDIA_ITEMS:
-          setMediaItemsInternal((PlaylistUpdateMessage) msg.obj);
-          break;
-        case MSG_ADD_MEDIA_ITEMS:
-          addMediaItemsInternal((PlaylistUpdateMessage) msg.obj, msg.arg1);
-          break;
-        case MSG_MOVE_MEDIA_ITEMS:
-          moveMediaItemsInternal((MoveMediaItemsMessage) msg.obj);
-          break;
-        case MSG_REMOVE_MEDIA_ITEMS:
-          removeMediaItemsInternal(msg.arg1, msg.arg2, (ShuffleOrder) msg.obj);
-          break;
-        case MSG_SET_SHUFFLE_ORDER:
-          setShuffleOrderInternal((ShuffleOrder) msg.obj);
-          break;
-        case MSG_PLAYLIST_UPDATE_REQUESTED:
-          playlistUpdateRequestedInternal();
-          break;
         case MSG_RELEASE:
           releaseInternal();
           // Return immediately to not send playback info updates after release.
@@ -487,12 +416,6 @@ private void setState(int state) {
     }
   }
 
-  private void setIsLoading(boolean isLoading) {
-    if (playbackInfo.isLoading != isLoading) {
-      playbackInfo = playbackInfo.copyWithIsLoading(isLoading);
-    }
-  }
-
   private void maybeNotifyPlaybackInfoChanged() {
     if (playbackInfoUpdate.hasPendingUpdate(playbackInfo)) {
       eventHandler
@@ -508,77 +431,21 @@ private void maybeNotifyPlaybackInfoChanged() {
     }
   }
 
-  private void prepareInternal() {
-    playbackInfoUpdate.incrementPendingOperationAcks(/* operationAcks= */ 1);
+  private void prepareInternal(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
+    pendingPrepareCount++;
     resetInternal(
         /* resetRenderers= */ false,
-        /* resetPosition= */ false,
-        /* releasePlaylist= */ false,
-        /* clearPlaylist= */ false,
+        /* releaseMediaSource= */ true,
+        resetPosition,
+        resetState,
         /* resetError= */ true);
     loadControl.onPrepared();
-    setState(playbackInfo.timeline.isEmpty() ? Player.STATE_ENDED : Player.STATE_BUFFERING);
-    playlist.prepare(bandwidthMeter.getTransferListener());
+    this.mediaSource = mediaSource;
+    setState(Player.STATE_BUFFERING);
+    mediaSource.prepareSource(/* caller= */ this, bandwidthMeter.getTransferListener());
     handler.sendEmptyMessage(MSG_DO_SOME_WORK);
   }
 
-  private void setMediaItemsInternal(PlaylistUpdateMessage playlistUpdateMessage)
-      throws ExoPlaybackException {
-    playbackInfoUpdate.incrementPendingOperationAcks(/* operationAcks= */ 1);
-    if (playlistUpdateMessage.windowIndex != C.INDEX_UNSET) {
-      pendingInitialSeekPosition =
-          new SeekPosition(
-              new Playlist.PlaylistTimeline(
-                  playlistUpdateMessage.mediaSourceHolders, playlistUpdateMessage.shuffleOrder),
-              playlistUpdateMessage.windowIndex,
-              playlistUpdateMessage.positionUs);
-    }
-    Timeline timeline =
-        playlist.setMediaSources(
-            playlistUpdateMessage.mediaSourceHolders, playlistUpdateMessage.shuffleOrder);
-    handlePlaylistInfoRefreshed(timeline);
-  }
-
-  private void addMediaItemsInternal(PlaylistUpdateMessage addMessage, int insertionIndex)
-      throws ExoPlaybackException {
-    playbackInfoUpdate.incrementPendingOperationAcks(/* operationAcks= */ 1);
-    Timeline timeline =
-        playlist.addMediaSources(
-            insertionIndex == C.INDEX_UNSET ? playlist.getSize() : insertionIndex,
-            addMessage.mediaSourceHolders,
-            addMessage.shuffleOrder);
-    handlePlaylistInfoRefreshed(timeline);
-  }
-
-  private void moveMediaItemsInternal(MoveMediaItemsMessage moveMediaItemsMessage)
-      throws ExoPlaybackException {
-    playbackInfoUpdate.incrementPendingOperationAcks(/* operationAcks= */ 1);
-    Timeline timeline =
-        playlist.moveMediaSourceRange(
-            moveMediaItemsMessage.fromIndex,
-            moveMediaItemsMessage.toIndex,
-            moveMediaItemsMessage.newFromIndex,
-            moveMediaItemsMessage.shuffleOrder);
-    handlePlaylistInfoRefreshed(timeline);
-  }
-
-  private void removeMediaItemsInternal(int fromIndex, int toIndex, ShuffleOrder shuffleOrder)
-      throws ExoPlaybackException {
-    playbackInfoUpdate.incrementPendingOperationAcks(/* operationAcks= */ 1);
-    Timeline timeline = playlist.removeMediaSourceRange(fromIndex, toIndex, shuffleOrder);
-    handlePlaylistInfoRefreshed(timeline);
-  }
-
-  private void playlistUpdateRequestedInternal() throws ExoPlaybackException {
-    handlePlaylistInfoRefreshed(playlist.createTimeline());
-  }
-
-  private void setShuffleOrderInternal(ShuffleOrder shuffleOrder) throws ExoPlaybackException {
-    playbackInfoUpdate.incrementPendingOperationAcks(/* operationAcks= */ 1);
-    Timeline timeline = playlist.setShuffleOrder(shuffleOrder);
-    handlePlaylistInfoRefreshed(timeline);
-  }
-
   private void setPlayWhenReadyInternal(boolean playWhenReady) throws ExoPlaybackException {
     rebuffering = false;
     this.playWhenReady = playWhenReady;
@@ -690,7 +557,14 @@ private void doSomeWork() throws ExoPlaybackException, IOException {
     long operationStartTimeMs = clock.uptimeMillis();
     updatePeriods();
 
-    MediaPeriodHolder playingPeriodHolder = queue.getPlayingPeriod();
+    if (playbackInfo.playbackState == Player.STATE_IDLE
+        || playbackInfo.playbackState == Player.STATE_ENDED) {
+      // Remove all messages. Prepare (in case of IDLE) or seek (in case of ENDED) will resume.
+      handler.removeMessages(MSG_DO_SOME_WORK);
+      return;
+    }
+
+    @Nullable MediaPeriodHolder playingPeriodHolder = queue.getPlayingPeriod();
     if (playingPeriodHolder == null) {
       // We're still waiting until the playing period is available.
       scheduleNextWork(operationStartTimeMs, ACTIVE_INTERVAL_MS);
@@ -789,7 +663,6 @@ private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackExcepti
     long periodPositionUs;
     long contentPositionUs;
     boolean seekPositionAdjusted;
-    @Nullable
     Pair<Object, Long> resolvedSeekPosition =
         resolveSeekPosition(seekPosition, /* trySubsequentPeriods= */ true);
     if (resolvedSeekPosition == null) {
@@ -814,7 +687,7 @@ private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackExcepti
     }
 
     try {
-      if (playbackInfo.timeline.isEmpty() || !playlist.isPrepared()) {
+      if (mediaSource == null || pendingPrepareCount > 0) {
         // Save seek position for later, as we are still waiting for a prepared source.
         pendingInitialSeekPosition = seekPosition;
       } else if (periodPositionUs == C.TIME_UNSET) {
@@ -822,9 +695,9 @@ private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackExcepti
         setState(Player.STATE_ENDED);
         resetInternal(
             /* resetRenderers= */ false,
+            /* releaseMediaSource= */ false,
             /* resetPosition= */ true,
-            /* releasePlaylist= */ false,
-            /* clearPlaylist= */ false,
+            /* resetState= */ false,
             /* resetError= */ true);
       } else {
         // Execute the seek in the current media periods.
@@ -870,7 +743,9 @@ private long seekToPeriodPosition(
       throws ExoPlaybackException {
     stopRenderers();
     rebuffering = false;
-    setState(Player.STATE_BUFFERING);
+    if (playbackInfo.playbackState != Player.STATE_IDLE && !playbackInfo.timeline.isEmpty()) {
+      setState(Player.STATE_BUFFERING);
+    }
 
     // Clear the timeline, but keep the requested period if it is already prepared.
     MediaPeriodHolder oldPlayingPeriodHolder = queue.getPlayingPeriod();
@@ -969,11 +844,13 @@ private void stopInternal(
       boolean forceResetRenderers, boolean resetPositionAndState, boolean acknowledgeStop) {
     resetInternal(
         /* resetRenderers= */ forceResetRenderers || !foregroundMode,
+        /* releaseMediaSource= */ true,
         /* resetPosition= */ resetPositionAndState,
-        /* releasePlaylist= */ true,
-        /* clearPlaylist= */ resetPositionAndState,
+        /* resetState= */ resetPositionAndState,
         /* resetError= */ resetPositionAndState);
-    playbackInfoUpdate.incrementPendingOperationAcks(acknowledgeStop ? 1 : 0);
+    playbackInfoUpdate.incrementPendingOperationAcks(
+        pendingPrepareCount + (acknowledgeStop ? 1 : 0));
+    pendingPrepareCount = 0;
     loadControl.onStopped();
     setState(Player.STATE_IDLE);
   }
@@ -981,9 +858,9 @@ private void stopInternal(
   private void releaseInternal() {
     resetInternal(
         /* resetRenderers= */ true,
+        /* releaseMediaSource= */ true,
         /* resetPosition= */ true,
-        /* releasePlaylist= */ true,
-        /* clearPlaylist= */ true,
+        /* resetState= */ true,
         /* resetError= */ false);
     loadControl.onReleased();
     setState(Player.STATE_IDLE);
@@ -996,9 +873,9 @@ private void releaseInternal() {
 
   private void resetInternal(
       boolean resetRenderers,
+      boolean releaseMediaSource,
       boolean resetPosition,
-      boolean releasePlaylist,
-      boolean clearPlaylist,
+      boolean resetState,
       boolean resetError) {
     handler.removeMessages(MSG_DO_SOME_WORK);
     rebuffering = false;
@@ -1026,8 +903,8 @@ private void resetInternal(
 
     if (resetPosition) {
       pendingInitialSeekPosition = null;
-    } else if (clearPlaylist) {
-      // When clearing the playlist, also reset the period-based PlaybackInfo position and convert
+    } else if (resetState) {
+      // When resetting the state, also reset the period-based PlaybackInfo position and convert
       // existing position to initial seek instead.
       resetPosition = true;
       if (pendingInitialSeekPosition == null && !playbackInfo.timeline.isEmpty()) {
@@ -1038,10 +915,10 @@ private void resetInternal(
       }
     }
 
-    queue.clear(/* keepFrontPeriodUid= */ !clearPlaylist);
-    setIsLoading(false);
-    if (clearPlaylist) {
-      queue.setTimeline(playlist.clear(/* shuffleOrder= */ null));
+    queue.clear(/* keepFrontPeriodUid= */ !resetState);
+    shouldContinueLoading = false;
+    if (resetState) {
+      queue.setTimeline(Timeline.EMPTY);
       for (PendingMessageInfo pendingMessageInfo : pendingMessages) {
         pendingMessageInfo.message.markAsProcessed(/* isDelivered= */ false);
       }
@@ -1057,21 +934,24 @@ private void resetInternal(
     long contentPositionUs = resetPosition ? C.TIME_UNSET : playbackInfo.contentPositionUs;
     playbackInfo =
         new PlaybackInfo(
-            clearPlaylist ? Timeline.EMPTY : playbackInfo.timeline,
+            resetState ? Timeline.EMPTY : playbackInfo.timeline,
             mediaPeriodId,
             startPositionUs,
             contentPositionUs,
             playbackInfo.playbackState,
             resetError ? null : playbackInfo.playbackError,
             /* isLoading= */ false,
-            clearPlaylist ? TrackGroupArray.EMPTY : playbackInfo.trackGroups,
-            clearPlaylist ? emptyTrackSelectorResult : playbackInfo.trackSelectorResult,
+            resetState ? TrackGroupArray.EMPTY : playbackInfo.trackGroups,
+            resetState ? emptyTrackSelectorResult : playbackInfo.trackSelectorResult,
             mediaPeriodId,
             startPositionUs,
             /* totalBufferedDurationUs= */ 0,
             startPositionUs);
-    if (releasePlaylist) {
-      playlist.release();
+    if (releaseMediaSource) {
+      if (mediaSource != null) {
+        mediaSource.releaseSource(/* caller= */ this);
+        mediaSource = null;
+      }
     }
   }
 
@@ -1079,7 +959,7 @@ private void sendMessageInternal(PlayerMessage message) throws ExoPlaybackExcept
     if (message.getPositionMs() == C.TIME_UNSET) {
       // If no delivery time is specified, trigger immediate message delivery.
       sendMessageToTarget(message);
-    } else if (playbackInfo.timeline.isEmpty()) {
+    } else if (mediaSource == null || pendingPrepareCount > 0) {
       // Still waiting for initial timeline to resolve position.
       pendingMessages.add(new PendingMessageInfo(message));
     } else {
@@ -1109,6 +989,11 @@ private void sendMessageToTarget(PlayerMessage message) throws ExoPlaybackExcept
 
   private void sendMessageToTargetThread(final PlayerMessage message) {
     Handler handler = message.getHandler();
+    if (!handler.getLooper().getThread().isAlive()) {
+      Log.w("TAG", "Trying to send message on a dead thread.");
+      message.markAsProcessed(/* isDelivered= */ false);
+      return;
+    }
     handler.post(
         () -> {
           try {
@@ -1394,11 +1279,20 @@ private void maybeThrowSourceInfoRefreshError() throws IOException {
         }
       }
     }
-    playlist.maybeThrowSourceInfoRefreshError();
+    mediaSource.maybeThrowSourceInfoRefreshError();
   }
 
-  private void handlePlaylistInfoRefreshed(Timeline timeline) throws ExoPlaybackException {
+  private void handleSourceInfoRefreshed(MediaSourceRefreshInfo sourceRefreshInfo)
+      throws ExoPlaybackException {
+    if (sourceRefreshInfo.source != mediaSource) {
+      // Stale event.
+      return;
+    }
+    playbackInfoUpdate.incrementPendingOperationAcks(pendingPrepareCount);
+    pendingPrepareCount = 0;
+
     Timeline oldTimeline = playbackInfo.timeline;
+    Timeline timeline = sourceRefreshInfo.timeline;
     queue.setTimeline(timeline);
     playbackInfo = playbackInfo.copyWithTimeline(timeline);
     resolvePendingMessagePositions();
@@ -1409,7 +1303,6 @@ private void handlePlaylistInfoRefreshed(Timeline timeline) throws ExoPlaybackEx
     long newContentPositionUs = oldContentPositionUs;
     if (pendingInitialSeekPosition != null) {
       // Resolve initial seek position.
-      @Nullable
       Pair<Object, Long> periodPosition =
           resolveSeekPosition(pendingInitialSeekPosition, /* trySubsequentPeriods= */ true);
       pendingInitialSeekPosition = null;
@@ -1511,13 +1404,15 @@ private long getMaxRendererReadPositionUs() {
   }
 
   private void handleSourceInfoRefreshEndedPlayback() {
-    setState(Player.STATE_ENDED);
-    // Reset, but retain the playlist so that it can still be used should a seek occur.
+    if (playbackInfo.playbackState != Player.STATE_IDLE) {
+      setState(Player.STATE_ENDED);
+    }
+    // Reset, but retain the source so that it can still be used should a seek occur.
     resetInternal(
         /* resetRenderers= */ false,
+        /* releaseMediaSource= */ false,
         /* resetPosition= */ true,
-        /* releasePlaylist= */ false,
-        /* clearPlaylist= */ false,
+        /* resetState= */ false,
         /* resetError= */ true);
   }
 
@@ -1560,7 +1455,6 @@ private void handleSourceInfoRefreshEndedPlayback() {
    * @throws IllegalSeekPositionException If the window index of the seek position is outside the
    *     bounds of the timeline.
    */
-  @Nullable
   private Pair<Object, Long> resolveSeekPosition(
       SeekPosition seekPosition, boolean trySubsequentPeriods) {
     Timeline timeline = playbackInfo.timeline;
@@ -1617,9 +1511,13 @@ private void handleSourceInfoRefreshEndedPlayback() {
   }
 
   private void updatePeriods() throws ExoPlaybackException, IOException {
-    if (playbackInfo.timeline.isEmpty() || !playlist.isPrepared()) {
+    if (mediaSource == null) {
+      // The player has no media source yet.
+      return;
+    }
+    if (pendingPrepareCount > 0) {
       // We're waiting to get information about periods.
-      playlist.maybeThrowSourceInfoRefreshError();
+      mediaSource.maybeThrowSourceInfoRefreshError();
       return;
     }
     maybeUpdateLoadingPeriod();
@@ -1639,27 +1537,26 @@ private void maybeUpdateLoadingPeriod() throws ExoPlaybackException, IOException
                 rendererCapabilities,
                 trackSelector,
                 loadControl.getAllocator(),
-                playlist,
+                mediaSource,
                 info,
                 emptyTrackSelectorResult);
         mediaPeriodHolder.mediaPeriod.prepare(this, info.startPositionUs);
-        setIsLoading(true);
         if (queue.getPlayingPeriod() == mediaPeriodHolder) {
           resetRendererPosition(mediaPeriodHolder.getStartPositionRendererTime());
         }
         handleLoadingMediaPeriodChanged(/* loadingTrackSelectionChanged= */ false);
       }
     }
-    @Nullable MediaPeriodHolder loadingPeriodHolder = queue.getLoadingPeriod();
-    if (loadingPeriodHolder == null || loadingPeriodHolder.isFullyBuffered()) {
-      setIsLoading(false);
-    } else if (!playbackInfo.isLoading) {
+    if (shouldContinueLoading) {
+      shouldContinueLoading = isLoadingPossible();
+      updateIsLoading();
+    } else {
       maybeContinueLoading();
     }
   }
 
   private void maybeUpdateReadingPeriod() throws ExoPlaybackException {
-    @Nullable MediaPeriodHolder readingPeriodHolder = queue.getReadingPeriod();
+    MediaPeriodHolder readingPeriodHolder = queue.getReadingPeriod();
     if (readingPeriodHolder == null) {
       return;
     }
@@ -1854,20 +1751,41 @@ private void handlePlaybackParameters(
   }
 
   private void maybeContinueLoading() {
+    shouldContinueLoading = shouldContinueLoading();
+    if (shouldContinueLoading) {
+      queue.getLoadingPeriod().continueLoading(rendererPositionUs);
+    }
+    updateIsLoading();
+  }
+
+  private boolean shouldContinueLoading() {
+    if (!isLoadingPossible()) {
+      return false;
+    }
+    long bufferedDurationUs =
+        getTotalBufferedDurationUs(queue.getLoadingPeriod().getNextLoadPositionUs());
+    float playbackSpeed = mediaClock.getPlaybackParameters().speed;
+    return loadControl.shouldContinueLoading(bufferedDurationUs, playbackSpeed);
+  }
+
+  private boolean isLoadingPossible() {
     MediaPeriodHolder loadingPeriodHolder = queue.getLoadingPeriod();
+    if (loadingPeriodHolder == null) {
+      return false;
+    }
     long nextLoadPositionUs = loadingPeriodHolder.getNextLoadPositionUs();
     if (nextLoadPositionUs == C.TIME_END_OF_SOURCE) {
-      setIsLoading(false);
-      return;
+      return false;
     }
-    long bufferedDurationUs =
-        getTotalBufferedDurationUs(/* bufferedPositionInLoadingPeriodUs= */ nextLoadPositionUs);
-    boolean continueLoading =
-        loadControl.shouldContinueLoading(
-            bufferedDurationUs, mediaClock.getPlaybackParameters().speed);
-    setIsLoading(continueLoading);
-    if (continueLoading) {
-      loadingPeriodHolder.continueLoading(rendererPositionUs);
+    return true;
+  }
+
+  private void updateIsLoading() {
+    MediaPeriodHolder loadingPeriod = queue.getLoadingPeriod();
+    boolean isLoading =
+        shouldContinueLoading || (loadingPeriod != null && loadingPeriod.mediaPeriod.isLoading());
+    if (isLoading != playbackInfo.isLoading) {
+      playbackInfo = playbackInfo.copyWithIsLoading(isLoading);
     }
   }
 
@@ -2068,38 +1986,14 @@ public int compareTo(@NonNull PendingMessageInfo other) {
     }
   }
 
-  private static final class PlaylistUpdateMessage {
-
-    private final List<Playlist.MediaSourceHolder> mediaSourceHolders;
-    private final ShuffleOrder shuffleOrder;
-    private final int windowIndex;
-    private final long positionUs;
-
-    private PlaylistUpdateMessage(
-        List<Playlist.MediaSourceHolder> mediaSourceHolders,
-        ShuffleOrder shuffleOrder,
-        int windowIndex,
-        long positionUs) {
-      this.mediaSourceHolders = mediaSourceHolders;
-      this.shuffleOrder = shuffleOrder;
-      this.windowIndex = windowIndex;
-      this.positionUs = positionUs;
-    }
-  }
-
-  private static class MoveMediaItemsMessage {
+  private static final class MediaSourceRefreshInfo {
 
-    public final int fromIndex;
-    public final int toIndex;
-    public final int newFromIndex;
-    public final ShuffleOrder shuffleOrder;
+    public final MediaSource source;
+    public final Timeline timeline;
 
-    public MoveMediaItemsMessage(
-        int fromIndex, int toIndex, int newFromIndex, ShuffleOrder shuffleOrder) {
-      this.fromIndex = fromIndex;
-      this.toIndex = toIndex;
-      this.newFromIndex = newFromIndex;
-      this.shuffleOrder = shuffleOrder;
+    public MediaSourceRefreshInfo(MediaSource source, Timeline timeline) {
+      this.source = source;
+      this.timeline = timeline;
     }
   }
 
@@ -2108,7 +2002,7 @@ public MoveMediaItemsMessage(
     private PlaybackInfo lastPlaybackInfo;
     private int operationAcks;
     private boolean positionDiscontinuity;
-    @DiscontinuityReason private int discontinuityReason;
+    private @DiscontinuityReason int discontinuityReason;
 
     public boolean hasPendingUpdate(PlaybackInfo playbackInfo) {
       return playbackInfo != lastPlaybackInfo || operationAcks > 0 || positionDiscontinuity;
@@ -2136,4 +2030,5 @@ public void setPositionDiscontinuity(@DiscontinuityReason int discontinuityReaso
       this.discontinuityReason = discontinuityReason;
     }
   }
+
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Format.java b/library/core/src/main/java/com/google/android/exoplayer2/Format.java
index 37539845dc..f58893f4eb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Format.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Format.java
@@ -1099,6 +1099,39 @@ public Format copyWithSubsampleOffsetUs(long subsampleOffsetUs) {
         exoMediaCryptoType);
   }
 
+  public Format copyWithLabel(@Nullable String label) {
+    return new Format(
+        id,
+        label,
+        selectionFlags,
+        roleFlags,
+        bitrate,
+        codecs,
+        metadata,
+        containerMimeType,
+        sampleMimeType,
+        maxInputSize,
+        initializationData,
+        drmInitData,
+        subsampleOffsetUs,
+        width,
+        height,
+        frameRate,
+        rotationDegrees,
+        pixelWidthHeightRatio,
+        projectionData,
+        stereoMode,
+        colorInfo,
+        channelCount,
+        sampleRate,
+        pcmEncoding,
+        encoderDelay,
+        encoderPadding,
+        language,
+        accessibilityChannel,
+        exoMediaCryptoType);
+  }
+
   public Format copyWithContainerInfo(
       @Nullable String id,
       @Nullable String label,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
index 5bbbcbea2a..850d2b7d10 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.source.ClippingMediaPeriod;
 import com.google.android.exoplayer2.source.EmptySampleStream;
 import com.google.android.exoplayer2.source.MediaPeriod;
+import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
 import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.source.TrackGroupArray;
@@ -55,7 +56,7 @@
   private final boolean[] mayRetainStreamFlags;
   private final RendererCapabilities[] rendererCapabilities;
   private final TrackSelector trackSelector;
-  private final Playlist playlist;
+  private final MediaSource mediaSource;
 
   @Nullable private MediaPeriodHolder next;
   private TrackGroupArray trackGroups;
@@ -69,7 +70,7 @@
    * @param rendererPositionOffsetUs The renderer time of the start of the period, in microseconds.
    * @param trackSelector The track selector.
    * @param allocator The allocator.
-   * @param playlist The playlist.
+   * @param mediaSource The media source that produced the media period.
    * @param info Information used to identify this media period in its timeline period.
    * @param emptyTrackSelectorResult A {@link TrackSelectorResult} with empty selections for each
    *     renderer.
@@ -79,13 +80,13 @@ public MediaPeriodHolder(
       long rendererPositionOffsetUs,
       TrackSelector trackSelector,
       Allocator allocator,
-      Playlist playlist,
+      MediaSource mediaSource,
       MediaPeriodInfo info,
       TrackSelectorResult emptyTrackSelectorResult) {
     this.rendererCapabilities = rendererCapabilities;
     this.rendererPositionOffsetUs = rendererPositionOffsetUs;
     this.trackSelector = trackSelector;
-    this.playlist = playlist;
+    this.mediaSource = mediaSource;
     this.uid = info.id.periodUid;
     this.info = info;
     this.trackGroups = TrackGroupArray.EMPTY;
@@ -93,7 +94,8 @@ public MediaPeriodHolder(
     sampleStreams = new SampleStream[rendererCapabilities.length];
     mayRetainStreamFlags = new boolean[rendererCapabilities.length];
     mediaPeriod =
-        createMediaPeriod(info.id, playlist, allocator, info.startPositionUs, info.endPositionUs);
+        createMediaPeriod(
+            info.id, mediaSource, allocator, info.startPositionUs, info.endPositionUs);
   }
 
   /**
@@ -303,7 +305,7 @@ public long applyTrackSelection(
   /** Releases the media period. No other method should be called after the release. */
   public void release() {
     disableTrackSelectionsInResult();
-    releaseMediaPeriod(info.endPositionUs, playlist, mediaPeriod);
+    releaseMediaPeriod(info.endPositionUs, mediaSource, mediaPeriod);
   }
 
   /**
@@ -400,11 +402,11 @@ private boolean isLoadingMediaPeriod() {
   /** Returns a media period corresponding to the given {@code id}. */
   private static MediaPeriod createMediaPeriod(
       MediaPeriodId id,
-      Playlist playlist,
+      MediaSource mediaSource,
       Allocator allocator,
       long startPositionUs,
       long endPositionUs) {
-    MediaPeriod mediaPeriod = playlist.createPeriod(id, allocator, startPositionUs);
+    MediaPeriod mediaPeriod = mediaSource.createPeriod(id, allocator, startPositionUs);
     if (endPositionUs != C.TIME_UNSET && endPositionUs != C.TIME_END_OF_SOURCE) {
       mediaPeriod =
           new ClippingMediaPeriod(
@@ -415,12 +417,12 @@ private static MediaPeriod createMediaPeriod(
 
   /** Releases the given {@code mediaPeriod}, logging and suppressing any errors. */
   private static void releaseMediaPeriod(
-      long endPositionUs, Playlist playlist, MediaPeriod mediaPeriod) {
+      long endPositionUs, MediaSource mediaSource, MediaPeriod mediaPeriod) {
     try {
       if (endPositionUs != C.TIME_UNSET && endPositionUs != C.TIME_END_OF_SOURCE) {
-        playlist.releasePeriod(((ClippingMediaPeriod) mediaPeriod).mediaPeriod);
+        mediaSource.releasePeriod(((ClippingMediaPeriod) mediaPeriod).mediaPeriod);
       } else {
-        playlist.releasePeriod(mediaPeriod);
+        mediaSource.releasePeriod(mediaPeriod);
       }
     } catch (RuntimeException e) {
       // There's nothing we can do.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
index 5b39db54aa..901b7b4d94 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
@@ -19,6 +19,7 @@
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.Player.RepeatMode;
 import com.google.android.exoplayer2.source.MediaPeriod;
+import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
 import com.google.android.exoplayer2.trackselection.TrackSelectorResult;
@@ -133,7 +134,7 @@ public boolean shouldLoadNextMediaPeriod() {
    * @param rendererCapabilities The renderer capabilities.
    * @param trackSelector The track selector.
    * @param allocator The allocator.
-   * @param playlist The playlist.
+   * @param mediaSource The media source that produced the media period.
    * @param info Information used to identify this media period in its timeline period.
    * @param emptyTrackSelectorResult A {@link TrackSelectorResult} with empty selections for each
    *     renderer.
@@ -142,7 +143,7 @@ public MediaPeriodHolder enqueueNextMediaPeriodHolder(
       RendererCapabilities[] rendererCapabilities,
       TrackSelector trackSelector,
       Allocator allocator,
-      Playlist playlist,
+      MediaSource mediaSource,
       MediaPeriodInfo info,
       TrackSelectorResult emptyTrackSelectorResult) {
     long rendererPositionOffsetUs =
@@ -157,7 +158,7 @@ public MediaPeriodHolder enqueueNextMediaPeriodHolder(
             rendererPositionOffsetUs,
             trackSelector,
             allocator,
-            playlist,
+            mediaSource,
             info,
             emptyTrackSelectorResult);
     if (loading != null) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Player.java b/library/core/src/main/java/com/google/android/exoplayer2/Player.java
index b9ab69c45f..5f00916892 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Player.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Player.java
@@ -356,8 +356,7 @@ default void onTimelineChanged(Timeline timeline, @TimelineChangeReason int reas
      * {@link #onPositionDiscontinuity(int)}.
      *
      * @param timeline The latest timeline. Never null, but may be empty.
-     * @param manifest The latest manifest in case the timeline has a single window only. Always
-     *     null if the timeline has more than a single window.
+     * @param manifest The latest manifest. May be null.
      * @param reason The {@link TimelineChangeReason} responsible for this timeline change.
      * @deprecated Use {@link #onTimelineChanged(Timeline, int)} instead. The manifest can be
      *     accessed by using {@link #getCurrentManifest()} or {@code timeline.getWindow(windowIndex,
@@ -393,6 +392,14 @@ default void onLoadingChanged(boolean isLoading) {}
      */
     default void onPlayerStateChanged(boolean playWhenReady, @State int playbackState) {}
 
+    /**
+     * Called when the value returned from {@link #getPlaybackSuppressionReason()} changes.
+     *
+     * @param playbackSuppressionReason The current {@link PlaybackSuppressionReason}.
+     */
+    default void onPlaybackSuppressionReasonChanged(
+        @PlaybackSuppressionReason int playbackSuppressionReason) {}
+
     /**
      * Called when the value of {@link #isPlaying()} changes.
      *
@@ -585,17 +592,25 @@ public void onTimelineChanged(Timeline timeline, @Nullable Object manifest) {
   int DISCONTINUITY_REASON_INTERNAL = 4;
 
   /**
-   * Reasons for timeline changes. One of {@link #TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED} or {@link
-   * #TIMELINE_CHANGE_REASON_SOURCE_UPDATE}.
+   * Reasons for timeline changes. One of {@link #TIMELINE_CHANGE_REASON_PREPARED}, {@link
+   * #TIMELINE_CHANGE_REASON_RESET} or {@link #TIMELINE_CHANGE_REASON_DYNAMIC}.
    */
   @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED, TIMELINE_CHANGE_REASON_SOURCE_UPDATE})
+  @IntDef({
+    TIMELINE_CHANGE_REASON_PREPARED,
+    TIMELINE_CHANGE_REASON_RESET,
+    TIMELINE_CHANGE_REASON_DYNAMIC
+  })
   @interface TimelineChangeReason {}
-  /** Timeline changed as a result of a change of the playlist items or the order of the items. */
-  int TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED = 0;
-  /** Timeline changed as a result of a dynamic update introduced by the played media. */
-  int TIMELINE_CHANGE_REASON_SOURCE_UPDATE = 1;
+  /** Timeline and manifest changed as a result of a player initialization with new media. */
+  int TIMELINE_CHANGE_REASON_PREPARED = 0;
+  /** Timeline and manifest changed as a result of a player reset. */
+  int TIMELINE_CHANGE_REASON_RESET = 1;
+  /**
+   * Timeline or manifest changed as a result of an dynamic update introduced by the played media.
+   */
+  int TIMELINE_CHANGE_REASON_DYNAMIC = 2;
 
   /** Returns the component of this player for audio output, or null if audio is not supported. */
   @Nullable
@@ -946,6 +961,13 @@ public void onTimelineChanged(Timeline timeline, @Nullable Object manifest) {
    */
   boolean isCurrentWindowDynamic();
 
+  /**
+   * Returns whether the current window is live, or {@code false} if the {@link Timeline} is empty.
+   *
+   * @see Timeline.Window#isLive
+   */
+  boolean isCurrentWindowLive();
+
   /**
    * Returns whether the current window is seekable, or {@code false} if the {@link Timeline} is
    * empty.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Playlist.java b/library/core/src/main/java/com/google/android/exoplayer2/Playlist.java
deleted file mode 100644
index c5476a151b..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/Playlist.java
+++ /dev/null
@@ -1,708 +0,0 @@
-/*
- * Copyright (C) 2019 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2;
-
-import android.os.Handler;
-import androidx.annotation.Nullable;
-import com.google.android.exoplayer2.analytics.AnalyticsCollector;
-import com.google.android.exoplayer2.source.MaskingMediaPeriod;
-import com.google.android.exoplayer2.source.MaskingMediaSource;
-import com.google.android.exoplayer2.source.MediaPeriod;
-import com.google.android.exoplayer2.source.MediaSource;
-import com.google.android.exoplayer2.source.MediaSourceEventListener;
-import com.google.android.exoplayer2.source.ShuffleOrder;
-import com.google.android.exoplayer2.source.ShuffleOrder.DefaultShuffleOrder;
-import com.google.android.exoplayer2.upstream.Allocator;
-import com.google.android.exoplayer2.upstream.TransferListener;
-import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.Util;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.IdentityHashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * Concatenates multiple {@link MediaSource}s. The list of {@link MediaSource}s can be modified
- * during playback. It is valid for the same {@link MediaSource} instance to be present more than
- * once in the playlist.
- *
- * <p>With the exception of the constructor, all methods are called on the playback thread.
- */
-/* package */ class Playlist {
-
-  /** Listener for source events. */
-  public interface PlaylistInfoRefreshListener {
-
-    /**
-     * Called when the timeline of a media item has changed and a new timeline that reflects the
-     * current playlist state needs to be created by calling {@link #createTimeline()}.
-     *
-     * <p>Called on the playback thread.
-     */
-    void onPlaylistUpdateRequested();
-  }
-
-  private final List<MediaSourceHolder> mediaSourceHolders;
-  private final Map<MediaPeriod, MediaSourceHolder> mediaSourceByMediaPeriod;
-  private final Map<Object, MediaSourceHolder> mediaSourceByUid;
-  private final PlaylistInfoRefreshListener playlistInfoListener;
-  private final MediaSourceEventListener.EventDispatcher eventDispatcher;
-  private final HashMap<Playlist.MediaSourceHolder, MediaSourceAndListener> childSources;
-  private final Set<MediaSourceHolder> enabledMediaSourceHolders;
-
-  private ShuffleOrder shuffleOrder;
-  private boolean isPrepared;
-
-  @Nullable private TransferListener mediaTransferListener;
-
-  @SuppressWarnings("initialization")
-  public Playlist(PlaylistInfoRefreshListener listener) {
-    playlistInfoListener = listener;
-    shuffleOrder = new DefaultShuffleOrder(0);
-    mediaSourceByMediaPeriod = new IdentityHashMap<>();
-    mediaSourceByUid = new HashMap<>();
-    mediaSourceHolders = new ArrayList<>();
-    eventDispatcher = new MediaSourceEventListener.EventDispatcher();
-    childSources = new HashMap<>();
-    enabledMediaSourceHolders = new HashSet<>();
-  }
-
-  /**
-   * Sets the media sources replacing any sources previously contained in the playlist.
-   *
-   * @param holders The list of {@link MediaSourceHolder}s to set.
-   * @param shuffleOrder The new shuffle order.
-   * @return The new {@link Timeline}.
-   */
-  public final Timeline setMediaSources(
-      List<MediaSourceHolder> holders, ShuffleOrder shuffleOrder) {
-    removeMediaSourcesInternal(/* fromIndex= */ 0, /* toIndex= */ mediaSourceHolders.size());
-    return addMediaSources(/* index= */ this.mediaSourceHolders.size(), holders, shuffleOrder);
-  }
-
-  /**
-   * Adds multiple {@link MediaSourceHolder}s to the playlist.
-   *
-   * @param index The index at which the new {@link MediaSourceHolder}s will be inserted. This index
-   *     must be in the range of 0 &lt;= index &lt;= {@link #getSize()}.
-   * @param holders A list of {@link MediaSourceHolder}s to be added.
-   * @param shuffleOrder The new shuffle order.
-   * @return The new {@link Timeline}.
-   */
-  public final Timeline addMediaSources(
-      int index, List<MediaSourceHolder> holders, ShuffleOrder shuffleOrder) {
-    if (!holders.isEmpty()) {
-      this.shuffleOrder = shuffleOrder;
-      for (int insertionIndex = index; insertionIndex < index + holders.size(); insertionIndex++) {
-        MediaSourceHolder holder = holders.get(insertionIndex - index);
-        if (insertionIndex > 0) {
-          MediaSourceHolder previousHolder = mediaSourceHolders.get(insertionIndex - 1);
-          Timeline previousTimeline = previousHolder.mediaSource.getTimeline();
-          holder.reset(
-              /* firstWindowInChildIndex= */ previousHolder.firstWindowIndexInChild
-                  + previousTimeline.getWindowCount());
-        } else {
-          holder.reset(/* firstWindowIndexInChild= */ 0);
-        }
-        Timeline newTimeline = holder.mediaSource.getTimeline();
-        correctOffsets(
-            /* startIndex= */ insertionIndex,
-            /* windowOffsetUpdate= */ newTimeline.getWindowCount());
-        mediaSourceHolders.add(insertionIndex, holder);
-        mediaSourceByUid.put(holder.uid, holder);
-        if (isPrepared) {
-          prepareChildSource(holder);
-          if (mediaSourceByMediaPeriod.isEmpty()) {
-            enabledMediaSourceHolders.add(holder);
-          } else {
-            disableChildSource(holder);
-          }
-        }
-      }
-    }
-    return createTimeline();
-  }
-
-  /**
-   * Removes a range of {@link MediaSourceHolder}s from the playlist, by specifying an initial index
-   * (included) and a final index (excluded).
-   *
-   * <p>Note: when specified range is empty, no actual media source is removed and no exception is
-   * thrown.
-   *
-   * @param fromIndex The initial range index, pointing to the first media source that will be
-   *     removed. This index must be in the range of 0 &lt;= index &lt;= {@link #getSize()}.
-   * @param toIndex The final range index, pointing to the first media source that will be left
-   *     untouched. This index must be in the range of 0 &lt;= index &lt;= {@link #getSize()}.
-   * @param shuffleOrder The new shuffle order.
-   * @return The new {@link Timeline}.
-   * @throws IllegalArgumentException When the range is malformed, i.e. {@code fromIndex} &lt; 0,
-   *     {@code toIndex} &gt; {@link #getSize()}, {@code fromIndex} &gt; {@code toIndex}
-   */
-  public final Timeline removeMediaSourceRange(
-      int fromIndex, int toIndex, ShuffleOrder shuffleOrder) {
-    Assertions.checkArgument(fromIndex >= 0 && fromIndex <= toIndex && toIndex <= getSize());
-    this.shuffleOrder = shuffleOrder;
-    removeMediaSourcesInternal(fromIndex, toIndex);
-    return createTimeline();
-  }
-
-  /**
-   * Moves an existing media source within the playlist.
-   *
-   * @param currentIndex The current index of the media source in the playlist. This index must be
-   *     in the range of 0 &lt;= index &lt; {@link #getSize()}.
-   * @param newIndex The target index of the media source in the playlist. This index must be in the
-   *     range of 0 &lt;= index &lt; {@link #getSize()}.
-   * @param shuffleOrder The new shuffle order.
-   * @return The new {@link Timeline}.
-   * @throws IllegalArgumentException When an index is invalid, i.e. {@code currentIndex} &lt; 0,
-   *     {@code currentIndex} &gt;= {@link #getSize()}, {@code newIndex} &lt; 0
-   */
-  public final Timeline moveMediaSource(int currentIndex, int newIndex, ShuffleOrder shuffleOrder) {
-    return moveMediaSourceRange(currentIndex, currentIndex + 1, newIndex, shuffleOrder);
-  }
-
-  /**
-   * Moves a range of media sources within the playlist.
-   *
-   * <p>Note: when specified range is empty or the from index equals the new from index, no actual
-   * media source is moved and no exception is thrown.
-   *
-   * @param fromIndex The initial range index, pointing to the first media source of the range that
-   *     will be moved. This index must be in the range of 0 &lt;= index &lt;= {@link #getSize()}.
-   * @param toIndex The final range index, pointing to the first media source that will be left
-   *     untouched. This index must be larger or equals than {@code fromIndex}.
-   * @param newFromIndex The target index of the first media source of the range that will be moved.
-   * @param shuffleOrder The new shuffle order.
-   * @return The new {@link Timeline}.
-   * @throws IllegalArgumentException When the range is malformed, i.e. {@code fromIndex} &lt; 0,
-   *     {@code toIndex} &lt; {@code fromIndex}, {@code fromIndex} &gt; {@code toIndex}, {@code
-   *     newFromIndex} &lt; 0
-   */
-  public Timeline moveMediaSourceRange(
-      int fromIndex, int toIndex, int newFromIndex, ShuffleOrder shuffleOrder) {
-    Assertions.checkArgument(
-        fromIndex >= 0 && fromIndex <= toIndex && toIndex <= getSize() && newFromIndex >= 0);
-    this.shuffleOrder = shuffleOrder;
-    if (fromIndex == toIndex || fromIndex == newFromIndex) {
-      return createTimeline();
-    }
-    int startIndex = Math.min(fromIndex, newFromIndex);
-    int newEndIndex = newFromIndex + (toIndex - fromIndex) - 1;
-    int endIndex = Math.max(newEndIndex, toIndex - 1);
-    int windowOffset = mediaSourceHolders.get(startIndex).firstWindowIndexInChild;
-    moveMediaSourceHolders(mediaSourceHolders, fromIndex, toIndex, newFromIndex);
-    for (int i = startIndex; i <= endIndex; i++) {
-      MediaSourceHolder holder = mediaSourceHolders.get(i);
-      holder.firstWindowIndexInChild = windowOffset;
-      windowOffset += holder.mediaSource.getTimeline().getWindowCount();
-    }
-    return createTimeline();
-  }
-
-  /** Clears the playlist. */
-  public final Timeline clear(@Nullable ShuffleOrder shuffleOrder) {
-    this.shuffleOrder = shuffleOrder != null ? shuffleOrder : this.shuffleOrder.cloneAndClear();
-    removeMediaSourcesInternal(/* fromIndex= */ 0, /* toIndex= */ getSize());
-    return createTimeline();
-  }
-
-  /** Whether the playlist is prepared. */
-  public final boolean isPrepared() {
-    return isPrepared;
-  }
-
-  /** Returns the number of media sources in the playlist. */
-  public final int getSize() {
-    return mediaSourceHolders.size();
-  }
-
-  /**
-   * Sets the {@link AnalyticsCollector}.
-   *
-   * @param handler The handler on which to call the collector.
-   * @param analyticsCollector The analytics collector.
-   */
-  public final void setAnalyticsCollector(Handler handler, AnalyticsCollector analyticsCollector) {
-    eventDispatcher.addEventListener(handler, analyticsCollector);
-  }
-
-  /**
-   * Sets a new shuffle order to use when shuffling the child media sources.
-   *
-   * @param shuffleOrder A {@link ShuffleOrder}.
-   */
-  public final Timeline setShuffleOrder(ShuffleOrder shuffleOrder) {
-    int size = getSize();
-    if (shuffleOrder.getLength() != size) {
-      shuffleOrder =
-          shuffleOrder
-              .cloneAndClear()
-              .cloneAndInsert(/* insertionIndex= */ 0, /* insertionCount= */ size);
-    }
-    this.shuffleOrder = shuffleOrder;
-    return createTimeline();
-  }
-
-  /** Prepares the playlist. */
-  public final void prepare(@Nullable TransferListener mediaTransferListener) {
-    Assertions.checkState(!isPrepared);
-    this.mediaTransferListener = mediaTransferListener;
-    for (int i = 0; i < mediaSourceHolders.size(); i++) {
-      MediaSourceHolder mediaSourceHolder = mediaSourceHolders.get(i);
-      prepareChildSource(mediaSourceHolder);
-      enabledMediaSourceHolders.add(mediaSourceHolder);
-    }
-    isPrepared = true;
-  }
-
-  /**
-   * Returns a new {@link MediaPeriod} identified by {@code periodId}.
-   *
-   * @param id The identifier of the period.
-   * @param allocator An {@link Allocator} from which to obtain media buffer allocations.
-   * @param startPositionUs The expected start position, in microseconds.
-   * @return A new {@link MediaPeriod}.
-   */
-  public MediaPeriod createPeriod(
-      MediaSource.MediaPeriodId id, Allocator allocator, long startPositionUs) {
-    Object mediaSourceHolderUid = getMediaSourceHolderUid(id.periodUid);
-    MediaSource.MediaPeriodId childMediaPeriodId =
-        id.copyWithPeriodUid(getChildPeriodUid(id.periodUid));
-    MediaSourceHolder holder = Assertions.checkNotNull(mediaSourceByUid.get(mediaSourceHolderUid));
-    enableMediaSource(holder);
-    holder.activeMediaPeriodIds.add(childMediaPeriodId);
-    MediaPeriod mediaPeriod =
-        holder.mediaSource.createPeriod(childMediaPeriodId, allocator, startPositionUs);
-    mediaSourceByMediaPeriod.put(mediaPeriod, holder);
-    disableUnusedMediaSources();
-    return mediaPeriod;
-  }
-
-  /**
-   * Releases the period.
-   *
-   * @param mediaPeriod The period to release.
-   */
-  public final void releasePeriod(MediaPeriod mediaPeriod) {
-    MediaSourceHolder holder =
-        Assertions.checkNotNull(mediaSourceByMediaPeriod.remove(mediaPeriod));
-    holder.mediaSource.releasePeriod(mediaPeriod);
-    holder.activeMediaPeriodIds.remove(((MaskingMediaPeriod) mediaPeriod).id);
-    if (!mediaSourceByMediaPeriod.isEmpty()) {
-      disableUnusedMediaSources();
-    }
-    maybeReleaseChildSource(holder);
-  }
-
-  /** Releases the playlist. */
-  public final void release() {
-    for (MediaSourceAndListener childSource : childSources.values()) {
-      childSource.mediaSource.releaseSource(childSource.caller);
-      childSource.mediaSource.removeEventListener(childSource.eventListener);
-    }
-    childSources.clear();
-    enabledMediaSourceHolders.clear();
-    isPrepared = false;
-  }
-
-  /** Throws any pending error encountered while loading or refreshing. */
-  public final void maybeThrowSourceInfoRefreshError() throws IOException {
-    for (MediaSourceAndListener childSource : childSources.values()) {
-      childSource.mediaSource.maybeThrowSourceInfoRefreshError();
-    }
-  }
-
-  /** Creates a timeline reflecting the current state of the playlist. */
-  public final Timeline createTimeline() {
-    if (mediaSourceHolders.isEmpty()) {
-      return Timeline.EMPTY;
-    }
-    int windowOffset = 0;
-    for (int i = 0; i < mediaSourceHolders.size(); i++) {
-      MediaSourceHolder mediaSourceHolder = mediaSourceHolders.get(i);
-      mediaSourceHolder.firstWindowIndexInChild = windowOffset;
-      windowOffset += mediaSourceHolder.mediaSource.getTimeline().getWindowCount();
-    }
-    return new PlaylistTimeline(mediaSourceHolders, shuffleOrder);
-  }
-
-  // Internal methods.
-
-  private void enableMediaSource(MediaSourceHolder mediaSourceHolder) {
-    enabledMediaSourceHolders.add(mediaSourceHolder);
-    @Nullable MediaSourceAndListener enabledChild = childSources.get(mediaSourceHolder);
-    if (enabledChild != null) {
-      enabledChild.mediaSource.enable(enabledChild.caller);
-    }
-  }
-
-  private void disableUnusedMediaSources() {
-    Iterator<MediaSourceHolder> iterator = enabledMediaSourceHolders.iterator();
-    while (iterator.hasNext()) {
-      MediaSourceHolder holder = iterator.next();
-      if (holder.activeMediaPeriodIds.isEmpty()) {
-        disableChildSource(holder);
-        iterator.remove();
-      }
-    }
-  }
-
-  private void disableChildSource(MediaSourceHolder holder) {
-    @Nullable MediaSourceAndListener disabledChild = childSources.get(holder);
-    if (disabledChild != null) {
-      disabledChild.mediaSource.disable(disabledChild.caller);
-    }
-  }
-
-  private void removeMediaSourcesInternal(int fromIndex, int toIndex) {
-    for (int index = toIndex - 1; index >= fromIndex; index--) {
-      MediaSourceHolder holder = mediaSourceHolders.remove(index);
-      mediaSourceByUid.remove(holder.uid);
-      Timeline oldTimeline = holder.mediaSource.getTimeline();
-      correctOffsets(
-          /* startIndex= */ index, /* windowOffsetUpdate= */ -oldTimeline.getWindowCount());
-      holder.isRemoved = true;
-      if (isPrepared) {
-        maybeReleaseChildSource(holder);
-      }
-    }
-  }
-
-  private void correctOffsets(int startIndex, int windowOffsetUpdate) {
-    for (int i = startIndex; i < mediaSourceHolders.size(); i++) {
-      MediaSourceHolder mediaSourceHolder = mediaSourceHolders.get(i);
-      mediaSourceHolder.firstWindowIndexInChild += windowOffsetUpdate;
-    }
-  }
-
-  // Internal methods to manage child sources.
-
-  @Nullable
-  private static MediaSource.MediaPeriodId getMediaPeriodIdForChildMediaPeriodId(
-      MediaSourceHolder mediaSourceHolder, MediaSource.MediaPeriodId mediaPeriodId) {
-    for (int i = 0; i < mediaSourceHolder.activeMediaPeriodIds.size(); i++) {
-      // Ensure the reported media period id has the same window sequence number as the one created
-      // by this media source. Otherwise it does not belong to this child source.
-      if (mediaSourceHolder.activeMediaPeriodIds.get(i).windowSequenceNumber
-          == mediaPeriodId.windowSequenceNumber) {
-        Object periodUid = getPeriodUid(mediaSourceHolder, mediaPeriodId.periodUid);
-        return mediaPeriodId.copyWithPeriodUid(periodUid);
-      }
-    }
-    return null;
-  }
-
-  private static int getWindowIndexForChildWindowIndex(
-      MediaSourceHolder mediaSourceHolder, int windowIndex) {
-    return windowIndex + mediaSourceHolder.firstWindowIndexInChild;
-  }
-
-  private void prepareChildSource(MediaSourceHolder holder) {
-    MediaSource mediaSource = holder.mediaSource;
-    MediaSource.MediaSourceCaller caller =
-        (source, timeline) -> playlistInfoListener.onPlaylistUpdateRequested();
-    MediaSourceEventListener eventListener = new ForwardingEventListener(holder);
-    childSources.put(holder, new MediaSourceAndListener(mediaSource, caller, eventListener));
-    mediaSource.addEventListener(new Handler(), eventListener);
-    mediaSource.prepareSource(caller, mediaTransferListener);
-  }
-
-  private void maybeReleaseChildSource(MediaSourceHolder mediaSourceHolder) {
-    // Release if the source has been removed from the playlist and no periods are still active.
-    if (mediaSourceHolder.isRemoved && mediaSourceHolder.activeMediaPeriodIds.isEmpty()) {
-      MediaSourceAndListener removedChild =
-          Assertions.checkNotNull(childSources.remove(mediaSourceHolder));
-      removedChild.mediaSource.releaseSource(removedChild.caller);
-      removedChild.mediaSource.removeEventListener(removedChild.eventListener);
-      enabledMediaSourceHolders.remove(mediaSourceHolder);
-    }
-  }
-
-  /** Return uid of media source holder from period uid of concatenated source. */
-  private static Object getMediaSourceHolderUid(Object periodUid) {
-    return PlaylistTimeline.getChildTimelineUidFromConcatenatedUid(periodUid);
-  }
-
-  /** Return uid of child period from period uid of concatenated source. */
-  private static Object getChildPeriodUid(Object periodUid) {
-    return PlaylistTimeline.getChildPeriodUidFromConcatenatedUid(periodUid);
-  }
-
-  private static Object getPeriodUid(MediaSourceHolder holder, Object childPeriodUid) {
-    return PlaylistTimeline.getConcatenatedUid(holder.uid, childPeriodUid);
-  }
-
-  /* package */ static void moveMediaSourceHolders(
-      List<MediaSourceHolder> mediaSourceHolders, int fromIndex, int toIndex, int newFromIndex) {
-    MediaSourceHolder[] removedItems = new MediaSourceHolder[toIndex - fromIndex];
-    for (int i = removedItems.length - 1; i >= 0; i--) {
-      removedItems[i] = mediaSourceHolders.remove(fromIndex + i);
-    }
-    mediaSourceHolders.addAll(
-        Math.min(newFromIndex, mediaSourceHolders.size()), Arrays.asList(removedItems));
-  }
-
-  /** Data class to hold playlist media sources together with meta data needed to process them. */
-  /* package */ static final class MediaSourceHolder {
-
-    public final MaskingMediaSource mediaSource;
-    public final Object uid;
-    public final List<MediaSource.MediaPeriodId> activeMediaPeriodIds;
-
-    public int firstWindowIndexInChild;
-    public boolean isRemoved;
-
-    public MediaSourceHolder(MediaSource mediaSource, boolean useLazyPreparation) {
-      this.mediaSource = new MaskingMediaSource(mediaSource, useLazyPreparation);
-      this.activeMediaPeriodIds = new ArrayList<>();
-      this.uid = new Object();
-    }
-
-    public void reset(int firstWindowIndexInChild) {
-      this.firstWindowIndexInChild = firstWindowIndexInChild;
-      this.isRemoved = false;
-      this.activeMediaPeriodIds.clear();
-    }
-  }
-
-  /** Timeline exposing concatenated timelines of playlist media sources. */
-  /* package */ static final class PlaylistTimeline extends AbstractConcatenatedTimeline {
-
-    private final int windowCount;
-    private final int periodCount;
-    private final int[] firstPeriodInChildIndices;
-    private final int[] firstWindowInChildIndices;
-    private final Timeline[] timelines;
-    private final Object[] uids;
-    private final HashMap<Object, Integer> childIndexByUid;
-
-    public PlaylistTimeline(
-        Collection<MediaSourceHolder> mediaSourceHolders, ShuffleOrder shuffleOrder) {
-      super(/* isAtomic= */ false, shuffleOrder);
-      int childCount = mediaSourceHolders.size();
-      firstPeriodInChildIndices = new int[childCount];
-      firstWindowInChildIndices = new int[childCount];
-      timelines = new Timeline[childCount];
-      uids = new Object[childCount];
-      childIndexByUid = new HashMap<>();
-      int index = 0;
-      int windowCount = 0;
-      int periodCount = 0;
-      for (MediaSourceHolder mediaSourceHolder : mediaSourceHolders) {
-        timelines[index] = mediaSourceHolder.mediaSource.getTimeline();
-        firstWindowInChildIndices[index] = windowCount;
-        firstPeriodInChildIndices[index] = periodCount;
-        windowCount += timelines[index].getWindowCount();
-        periodCount += timelines[index].getPeriodCount();
-        uids[index] = mediaSourceHolder.uid;
-        childIndexByUid.put(uids[index], index++);
-      }
-      this.windowCount = windowCount;
-      this.periodCount = periodCount;
-    }
-
-    @Override
-    protected int getChildIndexByPeriodIndex(int periodIndex) {
-      return Util.binarySearchFloor(firstPeriodInChildIndices, periodIndex + 1, false, false);
-    }
-
-    @Override
-    protected int getChildIndexByWindowIndex(int windowIndex) {
-      return Util.binarySearchFloor(firstWindowInChildIndices, windowIndex + 1, false, false);
-    }
-
-    @Override
-    protected int getChildIndexByChildUid(Object childUid) {
-      Integer index = childIndexByUid.get(childUid);
-      return index == null ? C.INDEX_UNSET : index;
-    }
-
-    @Override
-    protected Timeline getTimelineByChildIndex(int childIndex) {
-      return timelines[childIndex];
-    }
-
-    @Override
-    protected int getFirstPeriodIndexByChildIndex(int childIndex) {
-      return firstPeriodInChildIndices[childIndex];
-    }
-
-    @Override
-    protected int getFirstWindowIndexByChildIndex(int childIndex) {
-      return firstWindowInChildIndices[childIndex];
-    }
-
-    @Override
-    protected Object getChildUidByChildIndex(int childIndex) {
-      return uids[childIndex];
-    }
-
-    @Override
-    public int getWindowCount() {
-      return windowCount;
-    }
-
-    @Override
-    public int getPeriodCount() {
-      return periodCount;
-    }
-  }
-
-  private static final class MediaSourceAndListener {
-
-    public final MediaSource mediaSource;
-    public final MediaSource.MediaSourceCaller caller;
-    public final MediaSourceEventListener eventListener;
-
-    public MediaSourceAndListener(
-        MediaSource mediaSource,
-        MediaSource.MediaSourceCaller caller,
-        MediaSourceEventListener eventListener) {
-      this.mediaSource = mediaSource;
-      this.caller = caller;
-      this.eventListener = eventListener;
-    }
-  }
-
-  private final class ForwardingEventListener implements MediaSourceEventListener {
-
-    private final Playlist.MediaSourceHolder id;
-    private EventDispatcher eventDispatcher;
-
-    public ForwardingEventListener(Playlist.MediaSourceHolder id) {
-      eventDispatcher = Playlist.this.eventDispatcher;
-      this.id = id;
-    }
-
-    @Override
-    public void onMediaPeriodCreated(int windowIndex, MediaSource.MediaPeriodId mediaPeriodId) {
-      if (maybeUpdateEventDispatcher(windowIndex, mediaPeriodId)) {
-        eventDispatcher.mediaPeriodCreated();
-      }
-    }
-
-    @Override
-    public void onMediaPeriodReleased(int windowIndex, MediaSource.MediaPeriodId mediaPeriodId) {
-      if (maybeUpdateEventDispatcher(windowIndex, mediaPeriodId)) {
-        eventDispatcher.mediaPeriodReleased();
-      }
-    }
-
-    @Override
-    public void onLoadStarted(
-        int windowIndex,
-        @Nullable MediaSource.MediaPeriodId mediaPeriodId,
-        LoadEventInfo loadEventData,
-        MediaLoadData mediaLoadData) {
-      if (maybeUpdateEventDispatcher(windowIndex, mediaPeriodId)) {
-        eventDispatcher.loadStarted(loadEventData, mediaLoadData);
-      }
-    }
-
-    @Override
-    public void onLoadCompleted(
-        int windowIndex,
-        @Nullable MediaSource.MediaPeriodId mediaPeriodId,
-        LoadEventInfo loadEventData,
-        MediaLoadData mediaLoadData) {
-      if (maybeUpdateEventDispatcher(windowIndex, mediaPeriodId)) {
-        eventDispatcher.loadCompleted(loadEventData, mediaLoadData);
-      }
-    }
-
-    @Override
-    public void onLoadCanceled(
-        int windowIndex,
-        @Nullable MediaSource.MediaPeriodId mediaPeriodId,
-        LoadEventInfo loadEventData,
-        MediaLoadData mediaLoadData) {
-      if (maybeUpdateEventDispatcher(windowIndex, mediaPeriodId)) {
-        eventDispatcher.loadCanceled(loadEventData, mediaLoadData);
-      }
-    }
-
-    @Override
-    public void onLoadError(
-        int windowIndex,
-        @Nullable MediaSource.MediaPeriodId mediaPeriodId,
-        LoadEventInfo loadEventData,
-        MediaLoadData mediaLoadData,
-        IOException error,
-        boolean wasCanceled) {
-      if (maybeUpdateEventDispatcher(windowIndex, mediaPeriodId)) {
-        eventDispatcher.loadError(loadEventData, mediaLoadData, error, wasCanceled);
-      }
-    }
-
-    @Override
-    public void onReadingStarted(int windowIndex, MediaSource.MediaPeriodId mediaPeriodId) {
-      if (maybeUpdateEventDispatcher(windowIndex, mediaPeriodId)) {
-        eventDispatcher.readingStarted();
-      }
-    }
-
-    @Override
-    public void onUpstreamDiscarded(
-        int windowIndex,
-        @Nullable MediaSource.MediaPeriodId mediaPeriodId,
-        MediaLoadData mediaLoadData) {
-      if (maybeUpdateEventDispatcher(windowIndex, mediaPeriodId)) {
-        eventDispatcher.upstreamDiscarded(mediaLoadData);
-      }
-    }
-
-    @Override
-    public void onDownstreamFormatChanged(
-        int windowIndex,
-        @Nullable MediaSource.MediaPeriodId mediaPeriodId,
-        MediaLoadData mediaLoadData) {
-      if (maybeUpdateEventDispatcher(windowIndex, mediaPeriodId)) {
-        eventDispatcher.downstreamFormatChanged(mediaLoadData);
-      }
-    }
-
-    /** Updates the event dispatcher and returns whether the event should be dispatched. */
-    private boolean maybeUpdateEventDispatcher(
-        int childWindowIndex, @Nullable MediaSource.MediaPeriodId childMediaPeriodId) {
-      @Nullable MediaSource.MediaPeriodId mediaPeriodId = null;
-      if (childMediaPeriodId != null) {
-        mediaPeriodId = getMediaPeriodIdForChildMediaPeriodId(id, childMediaPeriodId);
-        if (mediaPeriodId == null) {
-          // Media period not found. Ignore event.
-          return false;
-        }
-      }
-      int windowIndex = getWindowIndexForChildWindowIndex(id, childWindowIndex);
-      if (eventDispatcher.windowIndex != windowIndex
-          || !Util.areEqual(eventDispatcher.mediaPeriodId, mediaPeriodId)) {
-        eventDispatcher =
-            Playlist.this.eventDispatcher.withParameters(
-                windowIndex, mediaPeriodId, /* mediaTimeOffsetMs= */ 0L);
-      }
-      return true;
-    }
-  }
-}
-
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
index de9802357c..d7861da797 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
@@ -32,7 +32,6 @@
 import com.google.android.exoplayer2.analytics.AnalyticsCollector;
 import com.google.android.exoplayer2.analytics.AnalyticsListener;
 import com.google.android.exoplayer2.audio.AudioAttributes;
-import com.google.android.exoplayer2.audio.AudioFocusManager;
 import com.google.android.exoplayer2.audio.AudioListener;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
 import com.google.android.exoplayer2.audio.AuxEffectInfo;
@@ -43,7 +42,6 @@
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataOutput;
 import com.google.android.exoplayer2.source.MediaSource;
-import com.google.android.exoplayer2.source.ShuffleOrder;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.TextOutput;
@@ -164,9 +162,7 @@ public Builder(Context context, RenderersFactory renderersFactory) {
      * @param bandwidthMeter A {@link BandwidthMeter}.
      * @param looper A {@link Looper} that must be used for all calls to the player.
      * @param analyticsCollector An {@link AnalyticsCollector}.
-     * @param useLazyPreparation Whether playlist items should be prepared lazily. If false, all
-     *     initial preparation steps (e.g., manifest loads) happen immediately. If true, these
-     *     initial preparations are triggered only when the player starts buffering the media.
+     * @param useLazyPreparation Whether media sources should be initialized lazily.
      * @param clock A {@link Clock}. Should always be {@link Clock#DEFAULT}.
      */
     public Builder(
@@ -303,7 +299,6 @@ public SimpleExoPlayer build() {
           loadControl,
           bandwidthMeter,
           analyticsCollector,
-          useLazyPreparation,
           clock,
           looper);
     }
@@ -327,6 +322,7 @@ public SimpleExoPlayer build() {
   private final AnalyticsCollector analyticsCollector;
 
   private final AudioFocusManager audioFocusManager;
+  private final WakeLockManager wakeLockManager;
 
   @Nullable private Format videoFormat;
   @Nullable private Format audioFormat;
@@ -343,6 +339,7 @@ public SimpleExoPlayer build() {
   private int audioSessionId;
   private AudioAttributes audioAttributes;
   private float audioVolume;
+  @Nullable private MediaSource mediaSource;
   private List<Cue> currentCues;
   @Nullable private VideoFrameMetadataListener videoFrameMetadataListener;
   @Nullable private CameraMotionListener cameraMotionListener;
@@ -358,9 +355,6 @@ public SimpleExoPlayer build() {
    * @param bandwidthMeter The {@link BandwidthMeter} that will be used by the instance.
    * @param analyticsCollector A factory for creating the {@link AnalyticsCollector} that will
    *     collect and forward all player events.
-   * @param useLazyPreparation Whether playlist items are prepared lazily. If false, all manifest
-   *     loads and other initial preparation steps happen immediately. If true, these initial
-   *     preparations are triggered only when the player starts buffering the media.
    * @param clock The {@link Clock} that will be used by the instance. Should always be {@link
    *     Clock#DEFAULT}, unless the player is being used from a test.
    * @param looper The {@link Looper} which must be used for all calls to the player and which is
@@ -374,7 +368,6 @@ protected SimpleExoPlayer(
       LoadControl loadControl,
       BandwidthMeter bandwidthMeter,
       AnalyticsCollector analyticsCollector,
-      boolean useLazyPreparation,
       Clock clock,
       Looper looper) {
     this(
@@ -385,14 +378,26 @@ protected SimpleExoPlayer(
         DrmSessionManager.getDummyDrmSessionManager(),
         bandwidthMeter,
         analyticsCollector,
-        useLazyPreparation,
         clock,
         looper);
   }
 
   /**
+   * @param context A {@link Context}.
+   * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
+   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
+   * @param loadControl The {@link LoadControl} that will be used by the instance.
+   * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the instance
+   *     will not be used for DRM protected playbacks.
+   * @param bandwidthMeter The {@link BandwidthMeter} that will be used by the instance.
+   * @param analyticsCollector The {@link AnalyticsCollector} that will collect and forward all
+   *     player events.
+   * @param clock The {@link Clock} that will be used by the instance. Should always be {@link
+   *     Clock#DEFAULT}, unless the player is being used from a test.
+   * @param looper The {@link Looper} which must be used for all calls to the player and which is
+   *     used to call listeners on.
    * @deprecated Use {@link #SimpleExoPlayer(Context, RenderersFactory, TrackSelector, LoadControl,
-   *     BandwidthMeter, AnalyticsCollector, boolean, Clock, Looper)} instead, and pass the {@link
+   *     BandwidthMeter, AnalyticsCollector, Clock, Looper)} instead, and pass the {@link
    *     DrmSessionManager} to the {@link MediaSource} factories.
    */
   @Deprecated
@@ -404,7 +409,6 @@ protected SimpleExoPlayer(
       @Nullable DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       BandwidthMeter bandwidthMeter,
       AnalyticsCollector analyticsCollector,
-      boolean useLazyPreparation,
       Clock clock,
       Looper looper) {
     this.bandwidthMeter = bandwidthMeter;
@@ -435,15 +439,7 @@ protected SimpleExoPlayer(
 
     // Build the player and associated objects.
     player =
-        new ExoPlayerImpl(
-            renderers,
-            trackSelector,
-            loadControl,
-            bandwidthMeter,
-            analyticsCollector,
-            useLazyPreparation,
-            clock,
-            looper);
+        new ExoPlayerImpl(renderers, trackSelector, loadControl, bandwidthMeter, clock, looper);
     analyticsCollector.setPlayer(player);
     addListener(analyticsCollector);
     addListener(componentListener);
@@ -457,6 +453,7 @@ protected SimpleExoPlayer(
       ((DefaultDrmSessionManager) drmSessionManager).addListener(eventHandler, analyticsCollector);
     }
     audioFocusManager = new AudioFocusManager(context, componentListener);
+    wakeLockManager = new WakeLockManager(context);
   }
 
   @Override
@@ -1103,133 +1100,32 @@ public ExoPlaybackException getPlaybackError() {
   }
 
   @Override
-  @Deprecated
   public void retry() {
     verifyApplicationThread();
-    prepare();
-  }
-
-  @Override
-  public void prepare() {
-    verifyApplicationThread();
-    @AudioFocusManager.PlayerCommand
-    int playerCommand = audioFocusManager.handlePrepare(getPlayWhenReady());
-    updatePlayWhenReady(getPlayWhenReady(), playerCommand);
-    player.prepare();
+    if (mediaSource != null
+        && (getPlaybackError() != null || getPlaybackState() == Player.STATE_IDLE)) {
+      prepare(mediaSource, /* resetPosition= */ false, /* resetState= */ false);
+    }
   }
 
   @Override
-  @Deprecated
-  @SuppressWarnings("deprecation")
   public void prepare(MediaSource mediaSource) {
     prepare(mediaSource, /* resetPosition= */ true, /* resetState= */ true);
   }
 
   @Override
-  @Deprecated
   public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
     verifyApplicationThread();
-    setMediaItems(
-        Collections.singletonList(mediaSource),
-        /* startWindowIndex= */ resetPosition ? 0 : C.INDEX_UNSET,
-        /* startPositionMs= */ C.TIME_UNSET);
-    prepare();
-  }
-
-  @Override
-  public void setMediaItems(List<MediaSource> mediaItems) {
-    verifyApplicationThread();
-    analyticsCollector.resetForNewPlaylist();
-    player.setMediaItems(mediaItems);
-  }
-
-  @Override
-  public void setMediaItems(List<MediaSource> mediaItems, boolean resetPosition) {
-    verifyApplicationThread();
-    analyticsCollector.resetForNewPlaylist();
-    player.setMediaItems(mediaItems, resetPosition);
-  }
-
-  @Override
-  public void setMediaItems(
-      List<MediaSource> mediaItems, int startWindowIndex, long startPositionMs) {
-    verifyApplicationThread();
-    analyticsCollector.resetForNewPlaylist();
-    player.setMediaItems(mediaItems, startWindowIndex, startPositionMs);
-  }
-
-  @Override
-  public void setMediaItem(MediaSource mediaItem) {
-    verifyApplicationThread();
-    analyticsCollector.resetForNewPlaylist();
-    player.setMediaItem(mediaItem);
-  }
-
-  @Override
-  public void setMediaItem(MediaSource mediaItem, long startPositionMs) {
-    verifyApplicationThread();
-    analyticsCollector.resetForNewPlaylist();
-    player.setMediaItem(mediaItem, startPositionMs);
-  }
-
-  @Override
-  public void addMediaItem(MediaSource mediaSource) {
-    verifyApplicationThread();
-    player.addMediaItem(mediaSource);
-  }
-
-  @Override
-  public void addMediaItem(int index, MediaSource mediaSource) {
-    verifyApplicationThread();
-    player.addMediaItem(index, mediaSource);
-  }
-
-  @Override
-  public void addMediaItems(List<MediaSource> mediaSources) {
-    verifyApplicationThread();
-    player.addMediaItems(mediaSources);
-  }
-
-  @Override
-  public void addMediaItems(int index, List<MediaSource> mediaSources) {
-    verifyApplicationThread();
-    player.addMediaItems(index, mediaSources);
-  }
-
-  @Override
-  public void moveMediaItem(int currentIndex, int newIndex) {
-    verifyApplicationThread();
-    player.moveMediaItem(currentIndex, newIndex);
-  }
-
-  @Override
-  public void moveMediaItems(int fromIndex, int toIndex, int newIndex) {
-    verifyApplicationThread();
-    player.moveMediaItems(fromIndex, toIndex, newIndex);
-  }
-
-  @Override
-  public MediaSource removeMediaItem(int index) {
-    verifyApplicationThread();
-    return player.removeMediaItem(index);
-  }
-
-  @Override
-  public void removeMediaItems(int fromIndex, int toIndex) {
-    verifyApplicationThread();
-    player.removeMediaItems(fromIndex, toIndex);
-  }
-
-  @Override
-  public void clearMediaItems() {
-    verifyApplicationThread();
-    player.clearMediaItems();
-  }
-
-  @Override
-  public void setShuffleOrder(ShuffleOrder shuffleOrder) {
-    verifyApplicationThread();
-    player.setShuffleOrder(shuffleOrder);
+    if (this.mediaSource != null) {
+      this.mediaSource.removeEventListener(analyticsCollector);
+      analyticsCollector.resetForNewMediaSource();
+    }
+    this.mediaSource = mediaSource;
+    mediaSource.addEventListener(eventHandler, analyticsCollector);
+    @AudioFocusManager.PlayerCommand
+    int playerCommand = audioFocusManager.handlePrepare(getPlayWhenReady());
+    updatePlayWhenReady(getPlayWhenReady(), playerCommand);
+    player.prepare(mediaSource, resetPosition, resetState);
   }
 
   @Override
@@ -1309,7 +1205,6 @@ public SeekParameters getSeekParameters() {
 
   @Override
   public void setForegroundMode(boolean foregroundMode) {
-    verifyApplicationThread();
     player.setForegroundMode(foregroundMode);
   }
 
@@ -1317,6 +1212,13 @@ public void setForegroundMode(boolean foregroundMode) {
   public void stop(boolean reset) {
     verifyApplicationThread();
     player.stop(reset);
+    if (mediaSource != null) {
+      mediaSource.removeEventListener(analyticsCollector);
+      analyticsCollector.resetForNewMediaSource();
+      if (reset) {
+        mediaSource = null;
+      }
+    }
     audioFocusManager.handleStop();
     currentCues = Collections.emptyList();
   }
@@ -1325,6 +1227,7 @@ public void stop(boolean reset) {
   public void release() {
     verifyApplicationThread();
     audioFocusManager.handleStop();
+    wakeLockManager.setStayAwake(false);
     player.release();
     removeSurfaceCallbacks();
     if (surface != null) {
@@ -1333,6 +1236,10 @@ public void release() {
       }
       surface = null;
     }
+    if (mediaSource != null) {
+      mediaSource.removeEventListener(analyticsCollector);
+      mediaSource = null;
+    }
     if (isPriorityTaskManagerRegistered) {
       Assertions.checkNotNull(priorityTaskManager).remove(C.PRIORITY_PLAYBACK);
       isPriorityTaskManagerRegistered = false;
@@ -1443,6 +1350,22 @@ public long getContentBufferedPosition() {
     return player.getContentBufferedPosition();
   }
 
+  /**
+   * Sets whether to enable the acquiring and releasing of a {@link
+   * android.os.PowerManager.WakeLock}.
+   *
+   * <p>By default, automatic wake lock handling is not enabled. Enabling this on will acquire the
+   * WakeLock if necessary. Disabling this will release the WakeLock if it is held.
+   *
+   * @param handleWakeLock True if the player should handle a {@link
+   *     android.os.PowerManager.WakeLock}, false otherwise. This is for use with a foreground
+   *     {@link android.app.Service}, for allowing audio playback with the screen off. Please note
+   *     that enabling this requires the {@link android.Manifest.permission#WAKE_LOCK} permission.
+   */
+  public void setHandleWakeLock(boolean handleWakeLock) {
+    wakeLockManager.setEnabled(handleWakeLock);
+  }
+
   // Internal methods.
 
   private void removeSurfaceCallbacks() {
@@ -1762,5 +1685,19 @@ public void onLoadingChanged(boolean isLoading) {
         }
       }
     }
+
+    @Override
+    public void onPlayerStateChanged(boolean playWhenReady, @State int playbackState) {
+      switch (playbackState) {
+        case Player.STATE_READY:
+        case Player.STATE_BUFFERING:
+          wakeLockManager.setStayAwake(playWhenReady);
+          break;
+        case Player.STATE_ENDED:
+        case Player.STATE_IDLE:
+          wakeLockManager.setStayAwake(false);
+          break;
+      }
+    }
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java b/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java
index 458532c86d..ce1a58822c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java
@@ -19,7 +19,6 @@
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.source.ads.AdPlaybackState;
 import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.Util;
 
 /**
  * A flexible representation of the structure of media. A timeline is able to represent the
@@ -67,8 +66,9 @@
  * duration is unknown, since it's continually extending as more content is broadcast. If content
  * only remains available for a limited period of time then the window may start at a non-zero
  * position, defining the region of content that can still be played. The window will have {@link
- * Window#isDynamic} set to true if the stream is still live. Its default position is typically near
- * to the live edge (indicated by the black dot in the figure above).
+ * Window#isLive} set to true to indicate it's a live stream and {@link Window#isDynamic} set to
+ * true as long as we expect changes to the live window. Its default position is typically near to
+ * the live edge (indicated by the black dot in the figure above).
  *
  * <h3>Live stream with indefinite availability</h3>
  *
@@ -159,8 +159,13 @@
     public boolean isDynamic;
 
     /**
-     * The index of the first period that belongs to this window.
+     * Whether the media in this window is live. For informational purposes only.
+     *
+     * <p>Check {@link #isDynamic} to know whether this window may still change.
      */
+    public boolean isLive;
+
+    /** The index of the first period that belongs to this window. */
     public int firstPeriodIndex;
 
     /**
@@ -201,6 +206,7 @@ public Window set(
         long windowStartTimeMs,
         boolean isSeekable,
         boolean isDynamic,
+        boolean isLive,
         long defaultPositionUs,
         long durationUs,
         int firstPeriodIndex,
@@ -213,6 +219,7 @@ public Window set(
       this.windowStartTimeMs = windowStartTimeMs;
       this.isSeekable = isSeekable;
       this.isDynamic = isDynamic;
+      this.isLive = isLive;
       this.defaultPositionUs = defaultPositionUs;
       this.durationUs = durationUs;
       this.firstPeriodIndex = firstPeriodIndex;
@@ -271,46 +278,6 @@ public long getPositionInFirstPeriodUs() {
       return positionInFirstPeriodUs;
     }
 
-    @Override
-    public boolean equals(@Nullable Object obj) {
-      if (this == obj) {
-        return true;
-      }
-      if (obj == null || !getClass().equals(obj.getClass())) {
-        return false;
-      }
-      Window that = (Window) obj;
-      return Util.areEqual(uid, that.uid)
-          && Util.areEqual(tag, that.tag)
-          && Util.areEqual(manifest, that.manifest)
-          && presentationStartTimeMs == that.presentationStartTimeMs
-          && windowStartTimeMs == that.windowStartTimeMs
-          && isSeekable == that.isSeekable
-          && isDynamic == that.isDynamic
-          && defaultPositionUs == that.defaultPositionUs
-          && durationUs == that.durationUs
-          && firstPeriodIndex == that.firstPeriodIndex
-          && lastPeriodIndex == that.lastPeriodIndex
-          && positionInFirstPeriodUs == that.positionInFirstPeriodUs;
-    }
-
-    @Override
-    public int hashCode() {
-      int result = 7;
-      result = 31 * result + uid.hashCode();
-      result = 31 * result + (tag == null ? 0 : tag.hashCode());
-      result = 31 * result + (manifest == null ? 0 : manifest.hashCode());
-      result = 31 * result + (int) (presentationStartTimeMs ^ (presentationStartTimeMs >>> 32));
-      result = 31 * result + (int) (windowStartTimeMs ^ (windowStartTimeMs >>> 32));
-      result = 31 * result + (isSeekable ? 1 : 0);
-      result = 31 * result + (isDynamic ? 1 : 0);
-      result = 31 * result + (int) (defaultPositionUs ^ (defaultPositionUs >>> 32));
-      result = 31 * result + (int) (durationUs ^ (durationUs >>> 32));
-      result = 31 * result + firstPeriodIndex;
-      result = 31 * result + lastPeriodIndex;
-      result = 31 * result + (int) (positionInFirstPeriodUs ^ (positionInFirstPeriodUs >>> 32));
-      return result;
-    }
   }
 
   /**
@@ -567,34 +534,6 @@ public long getAdResumePositionUs() {
       return adPlaybackState.adResumePositionUs;
     }
 
-    @Override
-    public boolean equals(@Nullable Object obj) {
-      if (this == obj) {
-        return true;
-      }
-      if (obj == null || !getClass().equals(obj.getClass())) {
-        return false;
-      }
-      Period that = (Period) obj;
-      return Util.areEqual(id, that.id)
-          && Util.areEqual(uid, that.uid)
-          && windowIndex == that.windowIndex
-          && durationUs == that.durationUs
-          && positionInWindowUs == that.positionInWindowUs
-          && Util.areEqual(adPlaybackState, that.adPlaybackState);
-    }
-
-    @Override
-    public int hashCode() {
-      int result = 7;
-      result = 31 * result + (id == null ? 0 : id.hashCode());
-      result = 31 * result + (uid == null ? 0 : uid.hashCode());
-      result = 31 * result + windowIndex;
-      result = 31 * result + (int) (durationUs ^ (durationUs >>> 32));
-      result = 31 * result + (int) (positionInWindowUs ^ (positionInWindowUs >>> 32));
-      result = 31 * result + (adPlaybackState == null ? 0 : adPlaybackState.hashCode());
-      return result;
-    }
   }
 
   /** An empty timeline. */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/WakeLockManager.java b/library/core/src/main/java/com/google/android/exoplayer2/WakeLockManager.java
new file mode 100644
index 0000000000..f498eea6f4
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/WakeLockManager.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.os.PowerManager;
+import android.os.PowerManager.WakeLock;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.util.Log;
+
+/**
+ * Handles a {@link WakeLock}.
+ *
+ * <p>The handling of wake locks requires the {@link android.Manifest.permission#WAKE_LOCK}
+ * permission.
+ */
+/* package */ final class WakeLockManager {
+
+  private static final String TAG = "WakeLockManager";
+  private static final String WAKE_LOCK_TAG = "ExoPlayer:WakeLockManager";
+
+  @Nullable private final PowerManager powerManager;
+  @Nullable private WakeLock wakeLock;
+  private boolean enabled;
+  private boolean stayAwake;
+
+  public WakeLockManager(Context context) {
+    powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
+  }
+
+  /**
+   * Sets whether to enable the acquiring and releasing of the {@link WakeLock}.
+   *
+   * <p>By default, wake lock handling is not enabled. Enabling this will acquire the wake lock if
+   * necessary. Disabling this will release the wake lock if it is held.
+   *
+   * @param enabled True if the player should handle a {@link WakeLock}, false otherwise. Please
+   *     note that enabling this requires the {@link android.Manifest.permission#WAKE_LOCK}
+   *     permission.
+   */
+  public void setEnabled(boolean enabled) {
+    if (enabled) {
+      if (wakeLock == null) {
+        if (powerManager == null) {
+          Log.w(TAG, "PowerManager was null, therefore the WakeLock was not created.");
+          return;
+        }
+        wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, WAKE_LOCK_TAG);
+      }
+    }
+
+    this.enabled = enabled;
+    updateWakeLock();
+  }
+
+  /**
+   * Sets whether to acquire or release the {@link WakeLock}.
+   *
+   * <p>Please note this method requires wake lock handling to be enabled through setEnabled(boolean
+   * enable) to actually have an impact on the {@link WakeLock}.
+   *
+   * @param stayAwake True if the player should acquire the {@link WakeLock}. False if the player
+   *     should release.
+   */
+  public void setStayAwake(boolean stayAwake) {
+    this.stayAwake = stayAwake;
+    updateWakeLock();
+  }
+
+  // WakelockTimeout suppressed because the time the wake lock is needed for is unknown (could be
+  // listening to radio with screen off for multiple hours), therefore we can not determine a
+  // reasonable timeout that would not affect the user.
+  @SuppressLint("WakelockTimeout")
+  private void updateWakeLock() {
+    // Needed for the library nullness check. If enabled is true, the wakelock will not be null.
+    if (wakeLock != null) {
+      if (enabled) {
+        if (stayAwake && !wakeLock.isHeld()) {
+          wakeLock.acquire();
+        } else if (!stayAwake && wakeLock.isHeld()) {
+          wakeLock.release();
+        }
+      } else if (wakeLock.isHeld()) {
+        wakeLock.release();
+      }
+    }
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsCollector.java b/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsCollector.java
index 2cb160d092..5a57844c83 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsCollector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsCollector.java
@@ -22,6 +22,7 @@
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.Player.PlaybackSuppressionReason;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.Timeline.Period;
 import com.google.android.exoplayer2.Timeline.Window;
@@ -132,8 +133,11 @@ public final void notifySeekStarted() {
     }
   }
 
-  /** Resets the analytics collector for a new playlist. */
-  public final void resetForNewPlaylist() {
+  /**
+   * Resets the analytics collector for a new media source. Should be called before the player is
+   * prepared with a new media source.
+   */
+  public final void resetForNewMediaSource() {
     // Copying the list is needed because onMediaPeriodReleased will modify the list.
     List<MediaPeriodInfo> mediaPeriodInfos =
         new ArrayList<>(mediaPeriodQueueTracker.mediaPeriodInfoQueue);
@@ -444,6 +448,23 @@ public final void onPlayerStateChanged(boolean playWhenReady, @Player.State int
     }
   }
 
+  @Override
+  public void onPlaybackSuppressionReasonChanged(
+      @PlaybackSuppressionReason int playbackSuppressionReason) {
+    EventTime eventTime = generatePlayingMediaPeriodEventTime();
+    for (AnalyticsListener listener : listeners) {
+      listener.onPlaybackSuppressionReasonChanged(eventTime, playbackSuppressionReason);
+    }
+  }
+
+  @Override
+  public void onIsPlayingChanged(boolean isPlaying) {
+    EventTime eventTime = generatePlayingMediaPeriodEventTime();
+    for (AnalyticsListener listener : listeners) {
+      listener.onIsPlayingChanged(eventTime, isPlaying);
+    }
+  }
+
   @Override
   public final void onRepeatModeChanged(@Player.RepeatMode int repeatMode) {
     EventTime eventTime = generatePlayingMediaPeriodEventTime();
@@ -783,13 +804,9 @@ public void onSeekProcessed() {
 
     /** Updates the queue with a newly created media period. */
     public void onMediaPeriodCreated(int windowIndex, MediaPeriodId mediaPeriodId) {
-      int periodIndex = timeline.getIndexOfPeriod(mediaPeriodId.periodUid);
-      boolean isInTimeline = periodIndex != C.INDEX_UNSET;
+      boolean isInTimeline = timeline.getIndexOfPeriod(mediaPeriodId.periodUid) != C.INDEX_UNSET;
       MediaPeriodInfo mediaPeriodInfo =
-          new MediaPeriodInfo(
-              mediaPeriodId,
-              isInTimeline ? timeline : Timeline.EMPTY,
-              isInTimeline ? timeline.getPeriod(periodIndex, period).windowIndex : windowIndex);
+          new MediaPeriodInfo(mediaPeriodId, isInTimeline ? timeline : Timeline.EMPTY, windowIndex);
       mediaPeriodInfoQueue.add(mediaPeriodInfo);
       mediaPeriodIdToInfo.put(mediaPeriodId, mediaPeriodInfo);
       lastPlayingMediaPeriod = mediaPeriodInfoQueue.get(0);
@@ -805,7 +822,7 @@ public void onMediaPeriodCreated(int windowIndex, MediaPeriodId mediaPeriodId) {
     public boolean onMediaPeriodReleased(MediaPeriodId mediaPeriodId) {
       MediaPeriodInfo mediaPeriodInfo = mediaPeriodIdToInfo.remove(mediaPeriodId);
       if (mediaPeriodInfo == null) {
-        // The media period has already been removed from the queue in resetForNewPlaylist().
+        // The media period has already been removed from the queue in resetForNewMediaSource().
         return false;
       }
       mediaPeriodInfoQueue.remove(mediaPeriodInfo);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsListener.java b/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsListener.java
index 656548df47..e16d92df9e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsListener.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/analytics/AnalyticsListener.java
@@ -23,6 +23,7 @@
 import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Player.DiscontinuityReason;
+import com.google.android.exoplayer2.Player.PlaybackSuppressionReason;
 import com.google.android.exoplayer2.Player.TimelineChangeReason;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.audio.AudioAttributes;
@@ -132,6 +133,23 @@ public EventTime(
   default void onPlayerStateChanged(
       EventTime eventTime, boolean playWhenReady, @Player.State int playbackState) {}
 
+  /**
+   * Called when playback suppression reason changed.
+   *
+   * @param eventTime The event time.
+   * @param playbackSuppressionReason The new {@link PlaybackSuppressionReason}.
+   */
+  default void onPlaybackSuppressionReasonChanged(
+      EventTime eventTime, @PlaybackSuppressionReason int playbackSuppressionReason) {}
+
+  /**
+   * Called when the player starts or stops playing.
+   *
+   * @param eventTime The event time.
+   * @param isPlaying Whether the player is playing.
+   */
+  default void onIsPlayingChanged(EventTime eventTime, boolean isPlaying) {}
+
   /**
    * Called when the timeline changed.
    *
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/analytics/PlaybackStats.java b/library/core/src/main/java/com/google/android/exoplayer2/analytics/PlaybackStats.java
index bd8fb213ed..b370c893de 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/analytics/PlaybackStats.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/analytics/PlaybackStats.java
@@ -38,8 +38,10 @@
    * #PLAYBACK_STATE_JOINING_FOREGROUND}, {@link #PLAYBACK_STATE_JOINING_BACKGROUND}, {@link
    * #PLAYBACK_STATE_PLAYING}, {@link #PLAYBACK_STATE_PAUSED}, {@link #PLAYBACK_STATE_SEEKING},
    * {@link #PLAYBACK_STATE_BUFFERING}, {@link #PLAYBACK_STATE_PAUSED_BUFFERING}, {@link
-   * #PLAYBACK_STATE_SEEK_BUFFERING}, {@link #PLAYBACK_STATE_ENDED}, {@link
-   * #PLAYBACK_STATE_STOPPED}, {@link #PLAYBACK_STATE_FAILED} or {@link #PLAYBACK_STATE_SUSPENDED}.
+   * #PLAYBACK_STATE_SEEK_BUFFERING}, {@link #PLAYBACK_STATE_SUPPRESSED}, {@link
+   * #PLAYBACK_STATE_SUPPRESSED_BUFFERING}, {@link #PLAYBACK_STATE_ENDED}, {@link
+   * #PLAYBACK_STATE_STOPPED}, {@link #PLAYBACK_STATE_FAILED}, {@link
+   * #PLAYBACK_STATE_INTERRUPTED_BY_AD} or {@link #PLAYBACK_STATE_ABANDONED}.
    */
   @Documented
   @Retention(RetentionPolicy.SOURCE)
@@ -54,10 +56,13 @@
     PLAYBACK_STATE_BUFFERING,
     PLAYBACK_STATE_PAUSED_BUFFERING,
     PLAYBACK_STATE_SEEK_BUFFERING,
+    PLAYBACK_STATE_SUPPRESSED,
+    PLAYBACK_STATE_SUPPRESSED_BUFFERING,
     PLAYBACK_STATE_ENDED,
     PLAYBACK_STATE_STOPPED,
     PLAYBACK_STATE_FAILED,
-    PLAYBACK_STATE_SUSPENDED
+    PLAYBACK_STATE_INTERRUPTED_BY_AD,
+    PLAYBACK_STATE_ABANDONED
   })
   @interface PlaybackState {}
   /** Playback has not started (initial state). */
@@ -72,22 +77,28 @@
   public static final int PLAYBACK_STATE_PAUSED = 4;
   /** Playback is handling a seek. */
   public static final int PLAYBACK_STATE_SEEKING = 5;
-  /** Playback is buffering to restart playback. */
+  /** Playback is buffering to resume active playback. */
   public static final int PLAYBACK_STATE_BUFFERING = 6;
   /** Playback is buffering while paused. */
   public static final int PLAYBACK_STATE_PAUSED_BUFFERING = 7;
   /** Playback is buffering after a seek. */
   public static final int PLAYBACK_STATE_SEEK_BUFFERING = 8;
+  /** Playback is suppressed (e.g. due to audio focus loss). */
+  public static final int PLAYBACK_STATE_SUPPRESSED = 9;
+  /** Playback is suppressed (e.g. due to audio focus loss) while buffering to resume a playback. */
+  public static final int PLAYBACK_STATE_SUPPRESSED_BUFFERING = 10;
   /** Playback has reached the end of the media. */
-  public static final int PLAYBACK_STATE_ENDED = 9;
-  /** Playback is stopped and can be resumed. */
-  public static final int PLAYBACK_STATE_STOPPED = 10;
+  public static final int PLAYBACK_STATE_ENDED = 11;
+  /** Playback is stopped and can be restarted. */
+  public static final int PLAYBACK_STATE_STOPPED = 12;
   /** Playback is stopped due a fatal error and can be retried. */
-  public static final int PLAYBACK_STATE_FAILED = 11;
-  /** Playback is suspended, e.g. because the user left or it is interrupted by another playback. */
-  public static final int PLAYBACK_STATE_SUSPENDED = 12;
+  public static final int PLAYBACK_STATE_FAILED = 13;
+  /** Playback is interrupted by an ad. */
+  public static final int PLAYBACK_STATE_INTERRUPTED_BY_AD = 14;
+  /** Playback is abandoned before reaching the end of the media. */
+  public static final int PLAYBACK_STATE_ABANDONED = 15;
   /** Total number of playback states. */
-  /* package */ static final int PLAYBACK_STATE_COUNT = 13;
+  /* package */ static final int PLAYBACK_STATE_COUNT = 16;
 
   /** Empty playback stats. */
   public static final PlaybackStats EMPTY = merge(/* nothing */ );
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/analytics/PlaybackStatsListener.java b/library/core/src/main/java/com/google/android/exoplayer2/analytics/PlaybackStatsListener.java
index 8b9f1d1ced..6768677fa4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/analytics/PlaybackStatsListener.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/analytics/PlaybackStatsListener.java
@@ -81,6 +81,7 @@
   @Nullable private String activeAdPlayback;
   private boolean playWhenReady;
   @Player.State private int playbackState;
+  private boolean isSuppressed;
   private float playbackSpeed;
 
   /**
@@ -205,7 +206,7 @@ public void onAdPlaybackStarted(EventTime eventTime, String contentSession, Stri
             eventTime.currentPlaybackPositionMs,
             eventTime.totalBufferedDurationMs);
     Assertions.checkNotNull(playbackStatsTrackers.get(contentSession))
-        .onSuspended(contentEventTime, /* belongsToPlayback= */ true);
+        .onInterruptedByAd(contentEventTime);
   }
 
   @Override
@@ -222,7 +223,7 @@ public void onSessionFinished(EventTime eventTime, String session, boolean autom
       tracker.onPlayerStateChanged(
           eventTime, /* playWhenReady= */ true, Player.STATE_ENDED, /* belongsToPlayback= */ false);
     }
-    tracker.onSuspended(eventTime, /* belongsToPlayback= */ false);
+    tracker.onFinished(eventTime);
     PlaybackStats playbackStats = tracker.build(/* isFinal= */ true);
     finishedPlaybackStats = PlaybackStats.merge(finishedPlaybackStats, playbackStats);
     if (callback != null) {
@@ -246,6 +247,19 @@ public void onPlayerStateChanged(
     }
   }
 
+  @Override
+  public void onPlaybackSuppressionReasonChanged(
+      EventTime eventTime, int playbackSuppressionReason) {
+    isSuppressed = playbackSuppressionReason != Player.PLAYBACK_SUPPRESSION_REASON_NONE;
+    sessionManager.updateSessions(eventTime);
+    for (String session : playbackStatsTrackers.keySet()) {
+      boolean belongsToPlayback = sessionManager.belongsToSession(eventTime, session);
+      playbackStatsTrackers
+          .get(session)
+          .onIsSuppressedChanged(eventTime, isSuppressed, belongsToPlayback);
+    }
+  }
+
   @Override
   public void onTimelineChanged(EventTime eventTime, int reason) {
     sessionManager.handleTimelineUpdate(eventTime);
@@ -456,9 +470,11 @@ public void onDrmSessionManagerError(EventTime eventTime, Exception error) {
     private long currentPlaybackStateStartTimeMs;
     private boolean isSeeking;
     private boolean isForeground;
-    private boolean isSuspended;
+    private boolean isInterruptedByAd;
+    private boolean isFinished;
     private boolean playWhenReady;
     @Player.State private int playerPlaybackState;
+    private boolean isSuppressed;
     private boolean hasFatalError;
     private boolean startedLoading;
     private long lastRebufferStartTimeMs;
@@ -515,18 +531,32 @@ public void onPlayerStateChanged(
         hasFatalError = false;
       }
       if (playbackState == Player.STATE_IDLE || playbackState == Player.STATE_ENDED) {
-        isSuspended = false;
+        isInterruptedByAd = false;
       }
       maybeUpdatePlaybackState(eventTime, belongsToPlayback);
     }
 
+    /**
+     * Notifies the tracker of a change to the playback suppression (e.g. due to audio focus loss),
+     * including all updates while the playback is not in the foreground.
+     *
+     * @param eventTime The {@link EventTime}.
+     * @param isSuppressed Whether playback is suppressed.
+     * @param belongsToPlayback Whether the {@code eventTime} belongs to the current playback.
+     */
+    public void onIsSuppressedChanged(
+        EventTime eventTime, boolean isSuppressed, boolean belongsToPlayback) {
+      this.isSuppressed = isSuppressed;
+      maybeUpdatePlaybackState(eventTime, belongsToPlayback);
+    }
+
     /**
      * Notifies the tracker of a position discontinuity or timeline update for the current playback.
      *
      * @param eventTime The {@link EventTime}.
      */
     public void onPositionDiscontinuity(EventTime eventTime) {
-      isSuspended = false;
+      isInterruptedByAd = false;
       maybeUpdatePlaybackState(eventTime, /* belongsToPlayback= */ true);
     }
 
@@ -561,7 +591,7 @@ public void onFatalError(EventTime eventTime, Exception error) {
         fatalErrorHistory.add(Pair.create(eventTime, error));
       }
       hasFatalError = true;
-      isSuspended = false;
+      isInterruptedByAd = false;
       isSeeking = false;
       maybeUpdatePlaybackState(eventTime, /* belongsToPlayback= */ true);
     }
@@ -587,16 +617,24 @@ public void onForeground(EventTime eventTime) {
     }
 
     /**
-     * Notifies the tracker that the current playback has been suspended, e.g. for ad playback or
-     * permanently.
+     * Notifies the tracker that the current playback has been interrupted for ad playback.
      *
      * @param eventTime The {@link EventTime}.
-     * @param belongsToPlayback Whether the {@code eventTime} belongs to the current playback.
      */
-    public void onSuspended(EventTime eventTime, boolean belongsToPlayback) {
-      isSuspended = true;
+    public void onInterruptedByAd(EventTime eventTime) {
+      isInterruptedByAd = true;
       isSeeking = false;
-      maybeUpdatePlaybackState(eventTime, belongsToPlayback);
+      maybeUpdatePlaybackState(eventTime, /* belongsToPlayback= */ true);
+    }
+
+    /**
+     * Notifies the tracker that the current playback has finished.
+     *
+     * @param eventTime The {@link EventTime}. Not guaranteed to belong to the current playback.
+     */
+    public void onFinished(EventTime eventTime) {
+      isFinished = true;
+      maybeUpdatePlaybackState(eventTime, /* belongsToPlayback= */ false);
     }
 
     /**
@@ -809,8 +847,9 @@ private void maybeUpdatePlaybackState(EventTime eventTime, boolean belongsToPlay
         rebufferCount++;
         lastRebufferStartTimeMs = eventTime.realtimeMs;
       }
-      if (newPlaybackState == PlaybackStats.PLAYBACK_STATE_PAUSED_BUFFERING
-          && currentPlaybackState == PlaybackStats.PLAYBACK_STATE_BUFFERING) {
+      if (isRebufferingState(currentPlaybackState)
+          && currentPlaybackState != PlaybackStats.PLAYBACK_STATE_PAUSED_BUFFERING
+          && newPlaybackState == PlaybackStats.PLAYBACK_STATE_PAUSED_BUFFERING) {
         pauseBufferCount++;
       }
 
@@ -829,11 +868,11 @@ private void maybeUpdatePlaybackState(EventTime eventTime, boolean belongsToPlay
     }
 
     private @PlaybackState int resolveNewPlaybackState() {
-      if (isSuspended) {
+      if (isFinished) {
         // Keep VIDEO_STATE_ENDED if playback naturally ended (or progressed to next item).
         return currentPlaybackState == PlaybackStats.PLAYBACK_STATE_ENDED
             ? PlaybackStats.PLAYBACK_STATE_ENDED
-            : PlaybackStats.PLAYBACK_STATE_SUSPENDED;
+            : PlaybackStats.PLAYBACK_STATE_ABANDONED;
       } else if (isSeeking) {
         // Seeking takes precedence over errors such that we report a seek while in error state.
         return PlaybackStats.PLAYBACK_STATE_SEEKING;
@@ -844,26 +883,34 @@ private void maybeUpdatePlaybackState(EventTime eventTime, boolean belongsToPlay
         return startedLoading
             ? PlaybackStats.PLAYBACK_STATE_JOINING_BACKGROUND
             : PlaybackStats.PLAYBACK_STATE_NOT_STARTED;
+      } else if (isInterruptedByAd) {
+        return PlaybackStats.PLAYBACK_STATE_INTERRUPTED_BY_AD;
       } else if (playerPlaybackState == Player.STATE_ENDED) {
         return PlaybackStats.PLAYBACK_STATE_ENDED;
       } else if (playerPlaybackState == Player.STATE_BUFFERING) {
         if (currentPlaybackState == PlaybackStats.PLAYBACK_STATE_NOT_STARTED
             || currentPlaybackState == PlaybackStats.PLAYBACK_STATE_JOINING_BACKGROUND
             || currentPlaybackState == PlaybackStats.PLAYBACK_STATE_JOINING_FOREGROUND
-            || currentPlaybackState == PlaybackStats.PLAYBACK_STATE_SUSPENDED) {
+            || currentPlaybackState == PlaybackStats.PLAYBACK_STATE_INTERRUPTED_BY_AD) {
           return PlaybackStats.PLAYBACK_STATE_JOINING_FOREGROUND;
         }
         if (currentPlaybackState == PlaybackStats.PLAYBACK_STATE_SEEKING
             || currentPlaybackState == PlaybackStats.PLAYBACK_STATE_SEEK_BUFFERING) {
           return PlaybackStats.PLAYBACK_STATE_SEEK_BUFFERING;
         }
-        return playWhenReady
-            ? PlaybackStats.PLAYBACK_STATE_BUFFERING
-            : PlaybackStats.PLAYBACK_STATE_PAUSED_BUFFERING;
+        if (!playWhenReady) {
+          return PlaybackStats.PLAYBACK_STATE_PAUSED_BUFFERING;
+        }
+        return isSuppressed
+            ? PlaybackStats.PLAYBACK_STATE_SUPPRESSED_BUFFERING
+            : PlaybackStats.PLAYBACK_STATE_BUFFERING;
       } else if (playerPlaybackState == Player.STATE_READY) {
-        return playWhenReady
-            ? PlaybackStats.PLAYBACK_STATE_PLAYING
-            : PlaybackStats.PLAYBACK_STATE_PAUSED;
+        if (!playWhenReady) {
+          return PlaybackStats.PLAYBACK_STATE_PAUSED;
+        }
+        return isSuppressed
+            ? PlaybackStats.PLAYBACK_STATE_SUPPRESSED
+            : PlaybackStats.PLAYBACK_STATE_PLAYING;
       } else if (playerPlaybackState == Player.STATE_IDLE
           && currentPlaybackState != PlaybackStats.PLAYBACK_STATE_NOT_STARTED) {
         // This case only applies for calls to player.stop(). All other IDLE cases are handled by
@@ -974,7 +1021,8 @@ private void maybeRecordAudioFormatTime(long nowMs) {
 
     private static boolean isReadyState(@PlaybackState int state) {
       return state == PlaybackStats.PLAYBACK_STATE_PLAYING
-          || state == PlaybackStats.PLAYBACK_STATE_PAUSED;
+          || state == PlaybackStats.PLAYBACK_STATE_PAUSED
+          || state == PlaybackStats.PLAYBACK_STATE_SUPPRESSED;
     }
 
     private static boolean isPausedState(@PlaybackState int state) {
@@ -984,21 +1032,23 @@ private static boolean isPausedState(@PlaybackState int state) {
 
     private static boolean isRebufferingState(@PlaybackState int state) {
       return state == PlaybackStats.PLAYBACK_STATE_BUFFERING
-          || state == PlaybackStats.PLAYBACK_STATE_PAUSED_BUFFERING;
+          || state == PlaybackStats.PLAYBACK_STATE_PAUSED_BUFFERING
+          || state == PlaybackStats.PLAYBACK_STATE_SUPPRESSED_BUFFERING;
     }
 
     private static boolean isInvalidJoinTransition(
         @PlaybackState int oldState, @PlaybackState int newState) {
       if (oldState != PlaybackStats.PLAYBACK_STATE_JOINING_BACKGROUND
           && oldState != PlaybackStats.PLAYBACK_STATE_JOINING_FOREGROUND
-          && oldState != PlaybackStats.PLAYBACK_STATE_SUSPENDED) {
+          && oldState != PlaybackStats.PLAYBACK_STATE_INTERRUPTED_BY_AD) {
         return false;
       }
       return newState != PlaybackStats.PLAYBACK_STATE_JOINING_BACKGROUND
           && newState != PlaybackStats.PLAYBACK_STATE_JOINING_FOREGROUND
-          && newState != PlaybackStats.PLAYBACK_STATE_SUSPENDED
+          && newState != PlaybackStats.PLAYBACK_STATE_INTERRUPTED_BY_AD
           && newState != PlaybackStats.PLAYBACK_STATE_PLAYING
           && newState != PlaybackStats.PLAYBACK_STATE_PAUSED
+          && newState != PlaybackStats.PLAYBACK_STATE_SUPPRESSED
           && newState != PlaybackStats.PLAYBACK_STATE_ENDED;
     }
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
index 759f88cdab..e3fad51f69 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
@@ -20,7 +20,6 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
-import android.text.TextUtils;
 import androidx.annotation.IntDef;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
@@ -38,8 +37,10 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.UUID;
 
 /** A {@link DrmSessionManager} that supports playbacks using {@link ExoMediaDrm}. */
@@ -47,6 +48,148 @@
 public class DefaultDrmSessionManager<T extends ExoMediaCrypto>
     implements DrmSessionManager<T>, ProvisioningManager<T> {
 
+  /**
+   * Builder for {@link DefaultDrmSessionManager} instances.
+   *
+   * <p>See {@link #Builder} for the list of default values.
+   */
+  public static final class Builder {
+
+    private final HashMap<String, String> keyRequestParameters;
+    private UUID uuid;
+    private ExoMediaDrm.Provider<ExoMediaCrypto> exoMediaDrmProvider;
+    private boolean multiSession;
+    private boolean allowPlaceholderSessions;
+    @Flags private int flags;
+    private LoadErrorHandlingPolicy loadErrorHandlingPolicy;
+
+    /**
+     * Creates a builder with default values. The default values are:
+     *
+     * <ul>
+     *   <li>{@link #setKeyRequestParameters keyRequestParameters}: An empty map.
+     *   <li>{@link #setUuidAndExoMediaDrmProvider UUID}: {@link C#WIDEVINE_UUID}.
+     *   <li>{@link #setUuidAndExoMediaDrmProvider ExoMediaDrm.Provider}: {@link
+     *       FrameworkMediaDrm#DEFAULT_PROVIDER}.
+     *   <li>{@link #setMultiSession multiSession}: Not allowed by default.
+     *   <li>{@link #setAllowPlaceholderSessions allowPlaceholderSession}: Not allowed by default.
+     *   <li>{@link #setPlayClearSamplesWithoutKeys playClearSamplesWithoutKeys}: Not allowed by
+     *       default.
+     *   <li>{@link #setLoadErrorHandlingPolicy LoadErrorHandlingPolicy}: {@link
+     *       DefaultLoadErrorHandlingPolicy}.
+     * </ul>
+     */
+    @SuppressWarnings("unchecked")
+    public Builder() {
+      keyRequestParameters = new HashMap<>();
+      uuid = C.WIDEVINE_UUID;
+      exoMediaDrmProvider = (ExoMediaDrm.Provider) FrameworkMediaDrm.DEFAULT_PROVIDER;
+      multiSession = false;
+      allowPlaceholderSessions = false;
+      flags = 0;
+      loadErrorHandlingPolicy = new DefaultLoadErrorHandlingPolicy();
+    }
+
+    /**
+     * Sets the parameters to pass to {@link ExoMediaDrm#getKeyRequest(byte[], List, int, HashMap)}.
+     *
+     * @param keyRequestParameters A map with parameters.
+     * @return This builder.
+     */
+    public Builder setKeyRequestParameters(Map<String, String> keyRequestParameters) {
+      this.keyRequestParameters.clear();
+      this.keyRequestParameters.putAll(Assertions.checkNotNull(keyRequestParameters));
+      return this;
+    }
+
+    /**
+     * Sets the UUID of the DRM scheme and the {@link ExoMediaDrm.Provider} to use.
+     *
+     * @param uuid The UUID of the DRM scheme.
+     * @param exoMediaDrmProvider The {@link ExoMediaDrm.Provider}.
+     * @return This builder.
+     */
+    @SuppressWarnings({"rawtypes", "unchecked"})
+    public Builder setUuidAndExoMediaDrmProvider(
+        UUID uuid, ExoMediaDrm.Provider exoMediaDrmProvider) {
+      this.uuid = Assertions.checkNotNull(uuid);
+      this.exoMediaDrmProvider = Assertions.checkNotNull(exoMediaDrmProvider);
+      return this;
+    }
+
+    /**
+     * Sets whether this session manager is allowed to acquire multiple simultaneous sessions.
+     *
+     * <p>Users should pass false when a single key request will obtain all keys required to decrypt
+     * the associated content. {@code multiSession} is required when content uses key rotation.
+     *
+     * @param multiSession Whether this session manager is allowed to acquire multiple simultaneous
+     *     sessions.
+     * @return This builder.
+     */
+    public Builder setMultiSession(boolean multiSession) {
+      this.multiSession = multiSession;
+      return this;
+    }
+
+    /**
+     * Sets whether this session manager is allowed to acquire placeholder sessions.
+     *
+     * <p>Placeholder sessions allow the use of secure renderers to play clear content.
+     *
+     * @param allowPlaceholderSessions Whether this session manager is allowed to acquire
+     *     placeholder sessions.
+     * @return This builder.
+     */
+    public Builder setAllowPlaceholderSessions(boolean allowPlaceholderSessions) {
+      this.allowPlaceholderSessions = allowPlaceholderSessions;
+      return this;
+    }
+
+    /**
+     * Sets whether clear samples should be played when keys are not available. Keys are considered
+     * unavailable when the load request is taking place, or when the key request has failed.
+     *
+     * <p>This option does not affect placeholder sessions.
+     *
+     * @param playClearSamplesWithoutKeys Whether clear samples should be played when keys are not
+     *     available.
+     * @return This builder.
+     */
+    public Builder setPlayClearSamplesWithoutKeys(boolean playClearSamplesWithoutKeys) {
+      if (playClearSamplesWithoutKeys) {
+        this.flags |= FLAG_PLAY_CLEAR_SAMPLES_WITHOUT_KEYS;
+      } else {
+        this.flags &= ~FLAG_PLAY_CLEAR_SAMPLES_WITHOUT_KEYS;
+      }
+      return this;
+    }
+
+    /**
+     * Sets the {@link LoadErrorHandlingPolicy} for key and provisioning requests.
+     *
+     * @param loadErrorHandlingPolicy A {@link LoadErrorHandlingPolicy}.
+     * @return This builder.
+     */
+    public Builder setLoadErrorHandlingPolicy(LoadErrorHandlingPolicy loadErrorHandlingPolicy) {
+      this.loadErrorHandlingPolicy = Assertions.checkNotNull(loadErrorHandlingPolicy);
+      return this;
+    }
+
+    /** Builds a {@link DefaultDrmSessionManager} instance. */
+    public DefaultDrmSessionManager<ExoMediaCrypto> build(MediaDrmCallback mediaDrmCallback) {
+      return new DefaultDrmSessionManager<>(
+          uuid,
+          exoMediaDrmProvider,
+          mediaDrmCallback,
+          keyRequestParameters,
+          multiSession,
+          allowPlaceholderSessions,
+          flags,
+          loadErrorHandlingPolicy);
+    }
+  }
+
   /**
    * Signals that the {@link DrmInitData} passed to {@link #acquireSession} does not contain does
    * not contain scheme data for the required UUID.
@@ -88,18 +231,22 @@ private MissingSchemeDataException(UUID uuid) {
   private static final String TAG = "DefaultDrmSessionMgr";
 
   private final UUID uuid;
-  private final ExoMediaDrm<T> mediaDrm;
+  private final ExoMediaDrm.Provider<T> exoMediaDrmProvider;
   private final MediaDrmCallback callback;
   @Nullable private final HashMap<String, String> optionalKeyRequestParameters;
   private final EventDispatcher<DefaultDrmSessionEventListener> eventDispatcher;
   private final boolean multiSession;
   private final boolean allowPlaceholderSessions;
+  @Flags private final int flags;
   private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
 
   private final List<DefaultDrmSession<T>> sessions;
   private final List<DefaultDrmSession<T>> provisioningSessions;
 
+  private int prepareCallsCount;
+  @Nullable private ExoMediaDrm<T> exoMediaDrm;
   @Nullable private DefaultDrmSession<T> placeholderDrmSession;
+  @Nullable private DefaultDrmSession<T> noMultiSessionDrmSession;
   @Nullable private Looper playbackLooper;
   private int mode;
   @Nullable private byte[] offlineLicenseKeySetId;
@@ -107,79 +254,22 @@ private MissingSchemeDataException(UUID uuid) {
   /* package */ volatile @Nullable MediaDrmHandler mediaDrmHandler;
 
   /**
-   * Instantiates a new instance using the Widevine scheme.
-   *
-   * @param callback Performs key and provisioning requests.
-   * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
-   *     to {@link ExoMediaDrm#getKeyRequest(byte[], List, int, HashMap)}. May be null.
-   * @throws UnsupportedDrmException If the specified DRM scheme is not supported.
-   */
-  public static DefaultDrmSessionManager<FrameworkMediaCrypto> newWidevineInstance(
-      MediaDrmCallback callback, @Nullable HashMap<String, String> optionalKeyRequestParameters)
-      throws UnsupportedDrmException {
-    return newFrameworkInstance(C.WIDEVINE_UUID, callback, optionalKeyRequestParameters);
-  }
-
-  /**
-   * Instantiates a new instance using the PlayReady scheme.
-   *
-   * <p>Note that PlayReady is unsupported by most Android devices, with the exception of Android TV
-   * devices, which do provide support.
-   *
-   * @param callback Performs key and provisioning requests.
-   * @param customData Optional custom data to include in requests generated by the instance.
-   * @throws UnsupportedDrmException If the specified DRM scheme is not supported.
-   */
-  public static DefaultDrmSessionManager<FrameworkMediaCrypto> newPlayReadyInstance(
-      MediaDrmCallback callback, @Nullable String customData) throws UnsupportedDrmException {
-    HashMap<String, String> optionalKeyRequestParameters;
-    if (!TextUtils.isEmpty(customData)) {
-      optionalKeyRequestParameters = new HashMap<>();
-      optionalKeyRequestParameters.put(PLAYREADY_CUSTOM_DATA_KEY, customData);
-    } else {
-      optionalKeyRequestParameters = null;
-    }
-    return newFrameworkInstance(C.PLAYREADY_UUID, callback, optionalKeyRequestParameters);
-  }
-
-  /**
-   * Instantiates a new instance.
-   *
    * @param uuid The UUID of the drm scheme.
+   * @param exoMediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
    * @param callback Performs key and provisioning requests.
    * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
    *     to {@link ExoMediaDrm#getKeyRequest(byte[], List, int, HashMap)}. May be null.
-   * @throws UnsupportedDrmException If the specified DRM scheme is not supported.
-   */
-  public static DefaultDrmSessionManager<FrameworkMediaCrypto> newFrameworkInstance(
-      UUID uuid,
-      MediaDrmCallback callback,
-      @Nullable HashMap<String, String> optionalKeyRequestParameters)
-      throws UnsupportedDrmException {
-    return new DefaultDrmSessionManager<>(
-        uuid,
-        FrameworkMediaDrm.newInstance(uuid),
-        callback,
-        optionalKeyRequestParameters,
-        /* multiSession= */ false,
-        INITIAL_DRM_REQUEST_RETRY_COUNT);
-  }
-
-  /**
-   * @param uuid The UUID of the drm scheme.
-   * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
-   * @param callback Performs key and provisioning requests.
-   * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
-   *     to {@link ExoMediaDrm#getKeyRequest(byte[], List, int, HashMap)}. May be null.
+   * @deprecated Use {@link Builder} instead.
    */
+  @Deprecated
   public DefaultDrmSessionManager(
       UUID uuid,
-      ExoMediaDrm<T> mediaDrm,
+      ExoMediaDrm<T> exoMediaDrm,
       MediaDrmCallback callback,
       @Nullable HashMap<String, String> optionalKeyRequestParameters) {
     this(
         uuid,
-        mediaDrm,
+        exoMediaDrm,
         callback,
         optionalKeyRequestParameters,
         /* multiSession= */ false,
@@ -188,22 +278,24 @@ public DefaultDrmSessionManager(
 
   /**
    * @param uuid The UUID of the drm scheme.
-   * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
+   * @param exoMediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
    * @param callback Performs key and provisioning requests.
    * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
    *     to {@link ExoMediaDrm#getKeyRequest(byte[], List, int, HashMap)}. May be null.
    * @param multiSession A boolean that specify whether multiple key session support is enabled.
    *     Default is false.
+   * @deprecated Use {@link Builder} instead.
    */
+  @Deprecated
   public DefaultDrmSessionManager(
       UUID uuid,
-      ExoMediaDrm<T> mediaDrm,
+      ExoMediaDrm<T> exoMediaDrm,
       MediaDrmCallback callback,
       @Nullable HashMap<String, String> optionalKeyRequestParameters,
       boolean multiSession) {
     this(
         uuid,
-        mediaDrm,
+        exoMediaDrm,
         callback,
         optionalKeyRequestParameters,
         multiSession,
@@ -212,7 +304,7 @@ public DefaultDrmSessionManager(
 
   /**
    * @param uuid The UUID of the drm scheme.
-   * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
+   * @param exoMediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
    * @param callback Performs key and provisioning requests.
    * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
    *     to {@link ExoMediaDrm#getKeyRequest(byte[], List, int, HashMap)}. May be null.
@@ -220,58 +312,50 @@ public DefaultDrmSessionManager(
    *     Default is false.
    * @param initialDrmRequestRetryCount The number of times to retry for initial provisioning and
    *     key request before reporting error.
+   * @deprecated Use {@link Builder} instead.
    */
+  @Deprecated
   public DefaultDrmSessionManager(
       UUID uuid,
-      ExoMediaDrm<T> mediaDrm,
+      ExoMediaDrm<T> exoMediaDrm,
       MediaDrmCallback callback,
       @Nullable HashMap<String, String> optionalKeyRequestParameters,
       boolean multiSession,
       int initialDrmRequestRetryCount) {
     this(
         uuid,
-        mediaDrm,
+        new ExoMediaDrm.AppManagedProvider<>(exoMediaDrm),
         callback,
         optionalKeyRequestParameters,
         multiSession,
         /* allowPlaceholderSessions= */ false,
+        /* flags= */ 0,
         new DefaultLoadErrorHandlingPolicy(initialDrmRequestRetryCount));
   }
 
   private DefaultDrmSessionManager(
       UUID uuid,
-      ExoMediaDrm<T> mediaDrm,
+      ExoMediaDrm.Provider<T> exoMediaDrmProvider,
       MediaDrmCallback callback,
       @Nullable HashMap<String, String> optionalKeyRequestParameters,
       boolean multiSession,
       boolean allowPlaceholderSessions,
+      @Flags int flags,
       LoadErrorHandlingPolicy loadErrorHandlingPolicy) {
     Assertions.checkNotNull(uuid);
-    Assertions.checkNotNull(mediaDrm);
     Assertions.checkArgument(!C.COMMON_PSSH_UUID.equals(uuid), "Use C.CLEARKEY_UUID instead");
     this.uuid = uuid;
-    this.mediaDrm = mediaDrm;
+    this.exoMediaDrmProvider = exoMediaDrmProvider;
     this.callback = callback;
     this.optionalKeyRequestParameters = optionalKeyRequestParameters;
     this.eventDispatcher = new EventDispatcher<>();
     this.multiSession = multiSession;
-    boolean canAcquirePlaceholderSessions =
-        !FrameworkMediaCrypto.class.equals(mediaDrm.getExoMediaCryptoType())
-            || !FrameworkMediaCrypto.WORKAROUND_DEVICE_NEEDS_KEYS_TO_CONFIGURE_CODEC;
-    // TODO: Allow customization once this class has a Builder.
-    this.allowPlaceholderSessions = canAcquirePlaceholderSessions && allowPlaceholderSessions;
+    this.allowPlaceholderSessions = allowPlaceholderSessions;
+    this.flags = flags;
     this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
     mode = MODE_PLAYBACK;
     sessions = new ArrayList<>();
     provisioningSessions = new ArrayList<>();
-    if (multiSession && C.WIDEVINE_UUID.equals(uuid) && Util.SDK_INT >= 19) {
-      // TODO: Enabling session sharing probably doesn't do anything useful here. It would only be
-      // useful if DefaultDrmSession instances were aware of one another's state, which is not
-      // implemented. Or if custom renderers are being used that allow playback to proceed before
-      // keys, which seems unlikely to be true in practice.
-      mediaDrm.setPropertyString("sessionSharing", "enable");
-    }
-    mediaDrm.setOnEventListener(new MediaDrmEventListener());
   }
 
   /**
@@ -293,54 +377,6 @@ public final void removeListener(DefaultDrmSessionEventListener eventListener) {
     eventDispatcher.removeListener(eventListener);
   }
 
-  /**
-   * Provides access to {@link ExoMediaDrm#getPropertyString(String)}.
-   *
-   * <p>This method may be called when the manager is in any state.
-   *
-   * @param key The key to request.
-   * @return The retrieved property.
-   */
-  public final String getPropertyString(String key) {
-    return mediaDrm.getPropertyString(key);
-  }
-
-  /**
-   * Provides access to {@link ExoMediaDrm#setPropertyString(String, String)}.
-   *
-   * <p>This method may be called when the manager is in any state.
-   *
-   * @param key The property to write.
-   * @param value The value to write.
-   */
-  public final void setPropertyString(String key, String value) {
-    mediaDrm.setPropertyString(key, value);
-  }
-
-  /**
-   * Provides access to {@link ExoMediaDrm#getPropertyByteArray(String)}.
-   *
-   * <p>This method may be called when the manager is in any state.
-   *
-   * @param key The key to request.
-   * @return The retrieved property.
-   */
-  public final byte[] getPropertyByteArray(String key) {
-    return mediaDrm.getPropertyByteArray(key);
-  }
-
-  /**
-   * Provides access to {@link ExoMediaDrm#setPropertyByteArray(String, byte[])}.
-   *
-   * <p>This method may be called when the manager is in any state.
-   *
-   * @param key The property to write.
-   * @param value The value to write.
-   */
-  public final void setPropertyByteArray(String key, byte[] value) {
-    mediaDrm.setPropertyByteArray(key, value);
-  }
-
   /**
    * Sets the mode, which determines the role of sessions acquired from the instance. This must be
    * called before {@link #acquireSession(Looper, DrmInitData)} or {@link
@@ -376,6 +412,30 @@ public void setMode(@Mode int mode, @Nullable byte[] offlineLicenseKeySetId) {
 
   // DrmSessionManager implementation.
 
+  @Override
+  public final void prepare() {
+    if (prepareCallsCount++ == 0) {
+      Assertions.checkState(exoMediaDrm == null);
+      exoMediaDrm = exoMediaDrmProvider.acquireExoMediaDrm(uuid);
+      if (multiSession && C.WIDEVINE_UUID.equals(uuid) && Util.SDK_INT >= 19) {
+        // TODO: Enabling session sharing probably doesn't do anything useful here. It would only be
+        // useful if DefaultDrmSession instances were aware of one another's state, which is not
+        // implemented. Or if custom renderers are being used that allow playback to proceed before
+        // keys, which seems unlikely to be true in practice.
+        exoMediaDrm.setPropertyString("sessionSharing", "enable");
+      }
+      exoMediaDrm.setOnEventListener(new MediaDrmEventListener());
+    }
+  }
+
+  @Override
+  public final void release() {
+    if (--prepareCallsCount == 0) {
+      Assertions.checkNotNull(exoMediaDrm).release();
+      exoMediaDrm = null;
+    }
+  }
+
   @Override
   public boolean canAcquireSession(DrmInitData drmInitData) {
     if (offlineLicenseKeySetId != null) {
@@ -412,13 +472,20 @@ public boolean canAcquireSession(DrmInitData drmInitData) {
   @Nullable
   public DrmSession<T> acquirePlaceholderSession(Looper playbackLooper) {
     assertExpectedPlaybackLooper(playbackLooper);
-    if (!allowPlaceholderSessions || mediaDrm.getExoMediaCryptoType() == null) {
+    Assertions.checkNotNull(exoMediaDrm);
+    boolean avoidPlaceholderDrmSessions =
+        FrameworkMediaCrypto.class.equals(exoMediaDrm.getExoMediaCryptoType())
+            && FrameworkMediaCrypto.WORKAROUND_DEVICE_NEEDS_KEYS_TO_CONFIGURE_CODEC;
+    if (avoidPlaceholderDrmSessions
+        || !allowPlaceholderSessions
+        || exoMediaDrm.getExoMediaCryptoType() == null) {
       return null;
     }
     maybeCreateMediaDrmHandler(playbackLooper);
     if (placeholderDrmSession == null) {
       DefaultDrmSession<T> placeholderDrmSession =
-          createNewDefaultSession(/* schemeDatas= */ null, /* isPlaceholderSession= */ true);
+          createNewDefaultSession(
+              /* schemeDatas= */ Collections.emptyList(), /* isPlaceholderSession= */ true);
       sessions.add(placeholderDrmSession);
       this.placeholderDrmSession = placeholderDrmSession;
     }
@@ -441,9 +508,9 @@ public boolean canAcquireSession(DrmInitData drmInitData) {
       }
     }
 
-    DefaultDrmSession<T> session;
+    @Nullable DefaultDrmSession<T> session;
     if (!multiSession) {
-      session = sessions.isEmpty() ? null : sessions.get(0);
+      session = noMultiSessionDrmSession;
     } else {
       // Only use an existing session if it has matching init data.
       session = null;
@@ -458,16 +525,27 @@ public boolean canAcquireSession(DrmInitData drmInitData) {
     if (session == null) {
       // Create a new session.
       session = createNewDefaultSession(schemeDatas, /* isPlaceholderSession= */ false);
+      if (!multiSession) {
+        noMultiSessionDrmSession = session;
+      }
       sessions.add(session);
     }
     session.acquireReference();
     return session;
   }
 
+  @Override
+  @Flags
+  public final int getFlags() {
+    return flags;
+  }
+
   @Override
   @Nullable
   public Class<T> getExoMediaCryptoType(DrmInitData drmInitData) {
-    return canAcquireSession(drmInitData) ? mediaDrm.getExoMediaCryptoType() : null;
+    return canAcquireSession(drmInitData)
+        ? Assertions.checkNotNull(exoMediaDrm).getExoMediaCryptoType()
+        : null;
   }
 
   // ProvisioningManager implementation.
@@ -516,9 +594,10 @@ private void maybeCreateMediaDrmHandler(Looper playbackLooper) {
 
   private DefaultDrmSession<T> createNewDefaultSession(
       @Nullable List<SchemeData> schemeDatas, boolean isPlaceholderSession) {
+    Assertions.checkNotNull(exoMediaDrm);
     return new DefaultDrmSession<>(
         uuid,
-        mediaDrm,
+        exoMediaDrm,
         /* provisioningManager= */ this,
         /* releaseCallback= */ this::onSessionReleased,
         schemeDatas,
@@ -537,6 +616,9 @@ private void onSessionReleased(DefaultDrmSession<T> drmSession) {
     if (placeholderDrmSession == drmSession) {
       placeholderDrmSession = null;
     }
+    if (noMultiSessionDrmSession == drmSession) {
+      noMultiSessionDrmSession = null;
+    }
     if (provisioningSessions.size() > 1 && provisioningSessions.get(0) == drmSession) {
       // Other sessions were waiting for the released session to complete a provision operation.
       // We need to have one of those sessions perform the provision operation instead.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSessionManager.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSessionManager.java
index 457b1630c8..46f9458408 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSessionManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSessionManager.java
@@ -78,6 +78,21 @@ public boolean canAcquireSession(DrmInitData drmInitData) {
    */
   int FLAG_PLAY_CLEAR_SAMPLES_WITHOUT_KEYS = 1;
 
+  /**
+   * Acquires any required resources.
+   *
+   * <p>{@link #release()} must be called to ensure the acquired resources are released. After
+   * releasing, an instance may be re-prepared.
+   */
+  default void prepare() {
+    // Do nothing.
+  }
+
+  /** Releases any acquired resources. */
+  default void release() {
+    // Do nothing.
+  }
+
   /**
    * Returns whether the manager is capable of acquiring a session for the given
    * {@link DrmInitData}.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
index 42050d7eb9..bff66760cc 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaDrm.java
@@ -25,6 +25,7 @@
 import android.media.UnsupportedSchemeException;
 import android.text.TextUtils;
 import androidx.annotation.Nullable;
+import androidx.annotation.RequiresApi;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import com.google.android.exoplayer2.extractor.mp4.PsshAtomUtil;
@@ -42,12 +43,13 @@
 import java.util.Map;
 import java.util.UUID;
 
-/**
- * An {@link ExoMediaDrm} implementation that wraps the framework {@link MediaDrm}.
- */
+/** An {@link ExoMediaDrm} implementation that wraps the framework {@link MediaDrm}. */
 @TargetApi(23)
+@RequiresApi(18)
 public final class FrameworkMediaDrm implements ExoMediaDrm<FrameworkMediaCrypto> {
 
+  private static final String TAG = "FrameworkMediaDrm";
+
   /**
    * {@link ExoMediaDrm.Provider} that returns a new {@link FrameworkMediaDrm} for the requested
    * UUID. Returns a {@link DummyExoMediaDrm} if the protection scheme identified by the given UUID
@@ -60,6 +62,7 @@
         try {
           return newInstance(uuid);
         } catch (UnsupportedDrmException e) {
+          Log.e(TAG, "Failed to instantiate a FrameworkMediaDrm for uuid: " + uuid + ".");
           return new DummyExoMediaDrm<>();
         }
       };
@@ -68,7 +71,6 @@
   private static final String MOCK_LA_URL_VALUE = "https://x";
   private static final String MOCK_LA_URL = "<LA_URL>" + MOCK_LA_URL_VALUE + "</LA_URL>";
   private static final int UTF_16_BYTES_PER_CHARACTER = 2;
-  private static final String TAG = "FrameworkMediaDrm";
 
   private final UUID uuid;
   private final MediaDrm mediaDrm;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java
index 03c199bda0..79dc743bc9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java
@@ -152,34 +152,6 @@ public void onDrmKeysRemoved() {
     drmSessionManager.addListener(new Handler(handlerThread.getLooper()), eventListener);
   }
 
-  /**
-   * @see DefaultDrmSessionManager#getPropertyByteArray
-   */
-  public synchronized byte[] getPropertyByteArray(String key) {
-    return drmSessionManager.getPropertyByteArray(key);
-  }
-
-  /**
-   * @see DefaultDrmSessionManager#setPropertyByteArray
-   */
-  public synchronized void setPropertyByteArray(String key, byte[] value) {
-    drmSessionManager.setPropertyByteArray(key, value);
-  }
-
-  /**
-   * @see DefaultDrmSessionManager#getPropertyString
-   */
-  public synchronized String getPropertyString(String key) {
-    return drmSessionManager.getPropertyString(key);
-  }
-
-  /**
-   * @see DefaultDrmSessionManager#setPropertyString
-   */
-  public synchronized void setPropertyString(String key, String value) {
-    drmSessionManager.setPropertyString(key, value);
-  }
-
   /**
    * Downloads an offline license.
    *
@@ -229,6 +201,7 @@ public synchronized void releaseLicense(byte[] offlineLicenseKeySetId)
   public synchronized Pair<Long, Long> getLicenseDurationRemainingSec(byte[] offlineLicenseKeySetId)
       throws DrmSessionException {
     Assertions.checkNotNull(offlineLicenseKeySetId);
+    drmSessionManager.prepare();
     DrmSession<T> drmSession =
         openBlockingKeyRequest(
             DefaultDrmSessionManager.MODE_QUERY, offlineLicenseKeySetId, DUMMY_DRM_INIT_DATA);
@@ -236,6 +209,7 @@ public synchronized void releaseLicense(byte[] offlineLicenseKeySetId)
     Pair<Long, Long> licenseDurationRemainingSec =
         WidevineUtil.getLicenseDurationRemainingSec(drmSession);
     drmSession.releaseReference();
+    drmSessionManager.release();
     if (error != null) {
       if (error.getCause() instanceof KeysExpiredException) {
         return Pair.create(0L, 0L);
@@ -255,11 +229,13 @@ public void release() {
   private byte[] blockingKeyRequest(
       @Mode int licenseMode, @Nullable byte[] offlineLicenseKeySetId, DrmInitData drmInitData)
       throws DrmSessionException {
+    drmSessionManager.prepare();
     DrmSession<T> drmSession = openBlockingKeyRequest(licenseMode, offlineLicenseKeySetId,
         drmInitData);
     DrmSessionException error = drmSession.getError();
     byte[] keySetId = drmSession.getOfflineLicenseKeySetId();
     drmSession.releaseReference();
+    drmSessionManager.release();
     if (error != null) {
       throw error;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
index 14219b8dfd..211fc13ea5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
@@ -303,13 +303,17 @@ private static String getDiagnosticInfoV21(Throwable cause) {
   private static final int ADAPTATION_WORKAROUND_MODE_ALWAYS = 2;
 
   /**
-   * H.264/AVC buffer to queue when using the adaptation workaround (see
-   * {@link #codecAdaptationWorkaroundMode(String)}. Consists of three NAL units with start codes:
-   * Baseline sequence/picture parameter sets and a 32 * 32 pixel IDR slice. This stream can be
-   * queued to force a resolution change when adapting to a new format.
+   * H.264/AVC buffer to queue when using the adaptation workaround (see {@link
+   * #codecAdaptationWorkaroundMode(String)}. Consists of three NAL units with start codes: Baseline
+   * sequence/picture parameter sets and a 32 * 32 pixel IDR slice. This stream can be queued to
+   * force a resolution change when adapting to a new format.
    */
-  private static final byte[] ADAPTATION_WORKAROUND_BUFFER = Util.getBytesFromHexString(
-      "0000016742C00BDA259000000168CE0F13200000016588840DCE7118A0002FBF1C31C3275D78");
+  private static final byte[] ADAPTATION_WORKAROUND_BUFFER =
+      new byte[] {
+        0, 0, 1, 103, 66, -64, 11, -38, 37, -112, 0, 0, 1, 104, -50, 15, 19, 32, 0, 0, 1, 101, -120,
+        -124, 13, -50, 113, 24, -96, 0, 47, -65, 28, 49, -61, 39, 93, 120
+      };
+
   private static final int ADAPTATION_WORKAROUND_SLICE_WIDTH_HEIGHT = 32;
 
   private final MediaCodecSelector mediaCodecSelector;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
index bbf7476d25..d87376feb0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer2.metadata.emsg;
 
-import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataDecoder;
 import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
@@ -29,31 +28,20 @@
 
   @SuppressWarnings("ByteBufferBackingArray")
   @Override
-  @Nullable
   public Metadata decode(MetadataInputBuffer inputBuffer) {
     ByteBuffer buffer = Assertions.checkNotNull(inputBuffer.data);
     byte[] data = buffer.array();
     int size = buffer.limit();
-    EventMessage decodedEventMessage = decode(new ParsableByteArray(data, size));
-    if (decodedEventMessage == null) {
-      return null;
-    } else {
-      return new Metadata(decodedEventMessage);
-    }
+    return new Metadata(decode(new ParsableByteArray(data, size)));
   }
 
-  @Nullable
   public EventMessage decode(ParsableByteArray emsgData) {
-    try {
-      String schemeIdUri = Assertions.checkNotNull(emsgData.readNullTerminatedString());
-      String value = Assertions.checkNotNull(emsgData.readNullTerminatedString());
-      long durationMs = emsgData.readUnsignedInt();
-      long id = emsgData.readUnsignedInt();
-      byte[] messageData =
-          Arrays.copyOfRange(emsgData.data, emsgData.getPosition(), emsgData.limit());
-      return new EventMessage(schemeIdUri, value, durationMs, id, messageData);
-    } catch (RuntimeException e) {
-      return null;
-    }
+    String schemeIdUri = Assertions.checkNotNull(emsgData.readNullTerminatedString());
+    String value = Assertions.checkNotNull(emsgData.readNullTerminatedString());
+    long durationMs = emsgData.readUnsignedInt();
+    long id = emsgData.readUnsignedInt();
+    byte[] messageData =
+        Arrays.copyOfRange(emsgData.data, emsgData.getPosition(), emsgData.limit());
+    return new EventMessage(schemeIdUri, value, durationMs, id, messageData);
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyDecoder.java
index 12f65f1cda..13d6b485b3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyDecoder.java
@@ -15,13 +15,11 @@
  */
 package com.google.android.exoplayer2.metadata.icy;
 
-import androidx.annotation.Nullable;
 import androidx.annotation.VisibleForTesting;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataDecoder;
 import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
 import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.Util;
 import java.nio.ByteBuffer;
 import java.util.regex.Matcher;
@@ -37,7 +35,6 @@
   private static final String STREAM_KEY_URL = "streamurl";
 
   @Override
-  @Nullable
   @SuppressWarnings("ByteBufferBackingArray")
   public Metadata decode(MetadataInputBuffer inputBuffer) {
     ByteBuffer buffer = Assertions.checkNotNull(inputBuffer.data);
@@ -46,7 +43,6 @@ public Metadata decode(MetadataInputBuffer inputBuffer) {
     return decode(Util.fromUtf8Bytes(data, 0, length));
   }
 
-  @Nullable
   @VisibleForTesting
   /* package */ Metadata decode(String metadata) {
     String name = null;
@@ -63,12 +59,9 @@ public Metadata decode(MetadataInputBuffer inputBuffer) {
         case STREAM_KEY_URL:
           url = value;
           break;
-        default:
-          Log.w(TAG, "Unrecognized ICY tag: " + name);
-          break;
       }
       index = matcher.end();
     }
-    return (name != null || url != null) ? new Metadata(new IcyInfo(name, url)) : null;
+    return new Metadata(new IcyInfo(metadata, name, url));
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyInfo.java
index e6b915a6c8..717bb2b2e2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyInfo.java
@@ -19,26 +19,35 @@
 import android.os.Parcelable;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 
 /** ICY in-stream information. */
 public final class IcyInfo implements Metadata.Entry {
 
+  /** The complete metadata string used to construct this IcyInfo. */
+  public final String rawMetadata;
   /** The stream title if present, or {@code null}. */
   @Nullable public final String title;
-  /** The stream title if present, or {@code null}. */
+  /** The stream URL if present, or {@code null}. */
   @Nullable public final String url;
 
   /**
+   * Construct a new IcyInfo from the source metadata string, and optionally a StreamTitle &
+   * StreamUrl that have been extracted.
+   *
+   * @param rawMetadata See {@link #rawMetadata}.
    * @param title See {@link #title}.
    * @param url See {@link #url}.
    */
-  public IcyInfo(@Nullable String title, @Nullable String url) {
+  public IcyInfo(String rawMetadata, @Nullable String title, @Nullable String url) {
+    this.rawMetadata = rawMetadata;
     this.title = title;
     this.url = url;
   }
 
   /* package */ IcyInfo(Parcel in) {
+    rawMetadata = Assertions.checkNotNull(in.readString());
     title = in.readString();
     url = in.readString();
   }
@@ -52,26 +61,27 @@ public boolean equals(@Nullable Object obj) {
       return false;
     }
     IcyInfo other = (IcyInfo) obj;
-    return Util.areEqual(title, other.title) && Util.areEqual(url, other.url);
+    // title & url are derived from rawMetadata, so no need to include them in the comparison.
+    return Util.areEqual(rawMetadata, other.rawMetadata);
   }
 
   @Override
   public int hashCode() {
-    int result = 17;
-    result = 31 * result + (title != null ? title.hashCode() : 0);
-    result = 31 * result + (url != null ? url.hashCode() : 0);
-    return result;
+    // title & url are derived from rawMetadata, so no need to include them in the hash.
+    return rawMetadata.hashCode();
   }
 
   @Override
   public String toString() {
-    return "ICY: title=\"" + title + "\", url=\"" + url + "\"";
+    return String.format(
+        "ICY: title=\"%s\", url=\"%s\", rawMetadata=\"%s\"", title, url, rawMetadata);
   }
 
   // Parcelable implementation.
 
   @Override
   public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(rawMetadata);
     dest.writeString(title);
     dest.writeString(url);
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
index c8755f9aee..ba0968cbd4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
@@ -163,7 +163,7 @@ public Metadata decode(byte[] data, int size) {
 
     int id = data.readUnsignedInt24();
     if (id != ID3_TAG) {
-      Log.w(TAG, "Unexpected first three bytes of ID3 tag header: " + id);
+      Log.w(TAG, "Unexpected first three bytes of ID3 tag header: 0x" + String.format("%06X", id));
       return null;
     }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/AbstractConcatenatedTimeline.java b/library/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java
similarity index 89%
rename from library/core/src/main/java/com/google/android/exoplayer2/AbstractConcatenatedTimeline.java
rename to library/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java
index a307e4b35d..29ef1faa80 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/AbstractConcatenatedTimeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java
@@ -13,14 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer2;
+package com.google.android.exoplayer2.source;
 
 import android.util.Pair;
-import com.google.android.exoplayer2.source.ShuffleOrder;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.util.Assertions;
 
 /** Abstract base class for the concatenation of one or more {@link Timeline}s. */
-public abstract class AbstractConcatenatedTimeline extends Timeline {
+/* package */ abstract class AbstractConcatenatedTimeline extends Timeline {
 
   private final int childCount;
   private final ShuffleOrder shuffleOrder;
@@ -74,8 +76,8 @@ public AbstractConcatenatedTimeline(boolean isAtomic, ShuffleOrder shuffleOrder)
   }
 
   @Override
-  public int getNextWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode,
-      boolean shuffleModeEnabled) {
+  public int getNextWindowIndex(
+      int windowIndex, @Player.RepeatMode int repeatMode, boolean shuffleModeEnabled) {
     if (isAtomic) {
       // Adapt repeat and shuffle mode to atomic concatenation.
       repeatMode = repeatMode == Player.REPEAT_MODE_ONE ? Player.REPEAT_MODE_ALL : repeatMode;
@@ -84,10 +86,12 @@ public int getNextWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode
     // Find next window within current child.
     int childIndex = getChildIndexByWindowIndex(windowIndex);
     int firstWindowIndexInChild = getFirstWindowIndexByChildIndex(childIndex);
-    int nextWindowIndexInChild = getTimelineByChildIndex(childIndex).getNextWindowIndex(
-        windowIndex - firstWindowIndexInChild,
-        repeatMode == Player.REPEAT_MODE_ALL ? Player.REPEAT_MODE_OFF : repeatMode,
-        shuffleModeEnabled);
+    int nextWindowIndexInChild =
+        getTimelineByChildIndex(childIndex)
+            .getNextWindowIndex(
+                windowIndex - firstWindowIndexInChild,
+                repeatMode == Player.REPEAT_MODE_ALL ? Player.REPEAT_MODE_OFF : repeatMode,
+                shuffleModeEnabled);
     if (nextWindowIndexInChild != C.INDEX_UNSET) {
       return firstWindowIndexInChild + nextWindowIndexInChild;
     }
@@ -108,8 +112,8 @@ public int getNextWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode
   }
 
   @Override
-  public int getPreviousWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode,
-      boolean shuffleModeEnabled) {
+  public int getPreviousWindowIndex(
+      int windowIndex, @Player.RepeatMode int repeatMode, boolean shuffleModeEnabled) {
     if (isAtomic) {
       // Adapt repeat and shuffle mode to atomic concatenation.
       repeatMode = repeatMode == Player.REPEAT_MODE_ONE ? Player.REPEAT_MODE_ALL : repeatMode;
@@ -118,10 +122,12 @@ public int getPreviousWindowIndex(int windowIndex, @Player.RepeatMode int repeat
     // Find previous window within current child.
     int childIndex = getChildIndexByWindowIndex(windowIndex);
     int firstWindowIndexInChild = getFirstWindowIndexByChildIndex(childIndex);
-    int previousWindowIndexInChild = getTimelineByChildIndex(childIndex).getPreviousWindowIndex(
-        windowIndex - firstWindowIndexInChild,
-        repeatMode == Player.REPEAT_MODE_ALL ? Player.REPEAT_MODE_OFF : repeatMode,
-        shuffleModeEnabled);
+    int previousWindowIndexInChild =
+        getTimelineByChildIndex(childIndex)
+            .getPreviousWindowIndex(
+                windowIndex - firstWindowIndexInChild,
+                repeatMode == Player.REPEAT_MODE_ALL ? Player.REPEAT_MODE_OFF : repeatMode,
+                shuffleModeEnabled);
     if (previousWindowIndexInChild != C.INDEX_UNSET) {
       return firstWindowIndexInChild + previousWindowIndexInChild;
     }
@@ -219,8 +225,8 @@ public final Period getPeriod(int periodIndex, Period period, boolean setIds) {
     int childIndex = getChildIndexByPeriodIndex(periodIndex);
     int firstWindowIndexInChild = getFirstWindowIndexByChildIndex(childIndex);
     int firstPeriodIndexInChild = getFirstPeriodIndexByChildIndex(childIndex);
-    getTimelineByChildIndex(childIndex).getPeriod(periodIndex - firstPeriodIndexInChild, period,
-        setIds);
+    getTimelineByChildIndex(childIndex)
+        .getPeriod(periodIndex - firstPeriodIndexInChild, period, setIds);
     period.windowIndex += firstWindowIndexInChild;
     if (setIds) {
       period.uid =
@@ -242,7 +248,8 @@ public final int getIndexOfPeriod(Object uid) {
       return C.INDEX_UNSET;
     }
     int periodIndexInChild = getTimelineByChildIndex(childIndex).getIndexOfPeriod(periodUid);
-    return periodIndexInChild == C.INDEX_UNSET ? C.INDEX_UNSET
+    return periodIndexInChild == C.INDEX_UNSET
+        ? C.INDEX_UNSET
         : getFirstPeriodIndexByChildIndex(childIndex) + periodIndexInChild;
   }
 
@@ -307,13 +314,14 @@ public final Object getUidOfPeriod(int periodIndex) {
   protected abstract Object getChildUidByChildIndex(int childIndex);
 
   private int getNextChildIndex(int childIndex, boolean shuffleModeEnabled) {
-    return shuffleModeEnabled ? shuffleOrder.getNextIndex(childIndex)
+    return shuffleModeEnabled
+        ? shuffleOrder.getNextIndex(childIndex)
         : childIndex < childCount - 1 ? childIndex + 1 : C.INDEX_UNSET;
   }
 
   private int getPreviousChildIndex(int childIndex, boolean shuffleModeEnabled) {
-    return shuffleModeEnabled ? shuffleOrder.getPreviousIndex(childIndex)
+    return shuffleModeEnabled
+        ? shuffleOrder.getPreviousIndex(childIndex)
         : childIndex > 0 ? childIndex - 1 : C.INDEX_UNSET;
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java
index d57dccd8fe..8aafb9a0e5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java
@@ -211,6 +211,11 @@ public boolean continueLoading(long positionUs) {
     return mediaPeriod.continueLoading(positionUs);
   }
 
+  @Override
+  public boolean isLoading() {
+    return mediaPeriod.isLoading();
+  }
+
   // MediaPeriod.Callback implementation.
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeSequenceableLoader.java b/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeSequenceableLoader.java
index c41933b48b..b583705170 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeSequenceableLoader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeSequenceableLoader.java
@@ -83,4 +83,13 @@ public boolean continueLoading(long positionUs) {
     return madeProgress;
   }
 
+  @Override
+  public boolean isLoading() {
+    for (SequenceableLoader loader : loaders) {
+      if (loader.isLoading()) {
+        return true;
+      }
+    }
+    return false;
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
index cfd0ad9377..8dfea1e511 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
@@ -19,7 +19,6 @@
 import android.os.Message;
 import androidx.annotation.GuardedBy;
 import androidx.annotation.Nullable;
-import com.google.android.exoplayer2.AbstractConcatenatedTimeline;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.ConcatenatingMediaSource.MediaSourceHolder;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
index 68bed250e8..ac23e2a831 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
@@ -16,7 +16,6 @@
 package com.google.android.exoplayer2.source;
 
 import androidx.annotation.Nullable;
-import com.google.android.exoplayer2.AbstractConcatenatedTimeline;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Player;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MaskingMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MaskingMediaPeriod.java
index 344c4989eb..17ac6c0667 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MaskingMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MaskingMediaPeriod.java
@@ -211,6 +211,11 @@ public boolean continueLoading(long positionUs) {
     return mediaPeriod != null && mediaPeriod.continueLoading(positionUs);
   }
 
+  @Override
+  public boolean isLoading() {
+    return mediaPeriod != null && mediaPeriod.isLoading();
+  }
+
   @Override
   public void onContinueLoadingRequested(MediaPeriod source) {
     castNonNull(callback).onContinueLoadingRequested(this);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MaskingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MaskingMediaSource.java
index 33bbf795be..891cb351c1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MaskingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MaskingMediaSource.java
@@ -17,7 +17,6 @@
 
 import android.util.Pair;
 import androidx.annotation.Nullable;
-import androidx.annotation.VisibleForTesting;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.Timeline.Window;
@@ -62,7 +61,7 @@ public MaskingMediaSource(MediaSource mediaSource, boolean useLazyPreparation) {
   }
 
   /** Returns the {@link Timeline}. */
-  public synchronized Timeline getTimeline() {
+  public Timeline getTimeline() {
     return timeline;
   }
 
@@ -130,7 +129,7 @@ public void releaseSourceInternal() {
   }
 
   @Override
-  protected synchronized void onChildSourceInfoRefreshed(
+  protected void onChildSourceInfoRefreshed(
       Void id, MediaSource mediaSource, Timeline newTimeline) {
     if (isPrepared) {
       timeline = timeline.cloneWithUpdatedTimeline(newTimeline);
@@ -294,8 +293,7 @@ public Object getUidOfPeriod(int periodIndex) {
   }
 
   /** Dummy placeholder timeline with one dynamic window with a period of indeterminate duration. */
-  @VisibleForTesting
-  public static final class DummyTimeline extends Timeline {
+  private static final class DummyTimeline extends Timeline {
 
     @Nullable private final Object tag;
 
@@ -319,6 +317,7 @@ public Window getWindow(int windowIndex, Window window, long defaultPositionProj
           /* isSeekable= */ false,
           // Dynamic window to indicate pending timeline updates.
           /* isDynamic= */ true,
+          /* isLive= */ false,
           /* defaultPositionUs= */ 0,
           /* durationUs= */ C.TIME_UNSET,
           /* firstPeriodIndex= */ 0,
@@ -334,8 +333,8 @@ public int getPeriodCount() {
     @Override
     public Period getPeriod(int periodIndex, Period period, boolean setIds) {
       return period.set(
-          /* id= */ setIds ? 0 : null,
-          /* uid= */ setIds ? MaskingTimeline.DUMMY_EXTERNAL_PERIOD_UID : null,
+          /* id= */ 0,
+          /* uid= */ MaskingTimeline.DUMMY_EXTERNAL_PERIOD_UID,
           /* windowIndex= */ 0,
           /* durationUs = */ C.TIME_UNSET,
           /* positionInWindowUs= */ 0);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
index 3f306c0c8a..2e2cf9caba 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
@@ -231,6 +231,9 @@ long selectTracks(
   @Override
   boolean continueLoading(long positionUs);
 
+  /** Returns whether the media period is currently loading. */
+  boolean isLoading();
+
   /**
    * Re-evaluates the buffer given the playback position.
    *
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaPeriod.java
index cafc052f34..afa25d6fce 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaPeriod.java
@@ -169,6 +169,11 @@ public boolean continueLoading(long positionUs) {
     }
   }
 
+  @Override
+  public boolean isLoading() {
+    return compositeSequenceableLoader.isLoading();
+  }
+
   @Override
   public long getNextLoadPositionUs() {
     return compositeSequenceableLoader.getNextLoadPositionUs();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaPeriod.java
index 7cb767854f..7ffc0faee6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaPeriod.java
@@ -55,6 +55,9 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
 import org.checkerframework.checker.nullness.compatqual.NullableType;
 
 /** A {@link MediaPeriod} that extracts data using an {@link Extractor}. */
@@ -71,13 +74,14 @@
   interface Listener {
 
     /**
-     * Called when the duration or ability to seek within the period changes.
+     * Called when the duration, the ability to seek within the period, or the categorization as
+     * live stream changes.
      *
      * @param durationUs The duration of the period, or {@link C#TIME_UNSET}.
      * @param isSeekable Whether the period is seekable.
+     * @param isLive Whether the period is live.
      */
-    void onSourceInfoRefreshed(long durationUs, boolean isSeekable);
-
+    void onSourceInfoRefreshed(long durationUs, boolean isSeekable, boolean isLive);
   }
 
   /**
@@ -86,6 +90,8 @@
    */
   private static final long DEFAULT_LAST_SAMPLE_DURATION_US = 10000;
 
+  private static final Map<String, String> ICY_METADATA_HEADERS = createIcyMetadataHeaders();
+
   private static final Format ICY_FORMAT =
       Format.createSampleFormat("icy", MimeTypes.APPLICATION_ICY, Format.OFFSET_SAMPLE_RELATIVE);
 
@@ -124,6 +130,7 @@
   private int enabledTrackCount;
   private long durationUs;
   private long length;
+  private boolean isLive;
 
   private long lastSeekPositionUs;
   private long pendingResetPositionUs;
@@ -351,6 +358,11 @@ public boolean continueLoading(long playbackPositionUs) {
     return continuedLoading;
   }
 
+  @Override
+  public boolean isLoading() {
+    return loader.isLoading() && loadCondition.isOpen();
+  }
+
   @Override
   public long getNextLoadPositionUs() {
     return enabledTrackCount == 0 ? C.TIME_END_OF_SOURCE : getBufferedPositionUs();
@@ -546,7 +558,7 @@ public void onLoadCompleted(ExtractingLoadable loadable, long elapsedRealtimeMs,
       long largestQueuedTimestampUs = getLargestQueuedTimestampUs();
       durationUs = largestQueuedTimestampUs == Long.MIN_VALUE ? 0
           : largestQueuedTimestampUs + DEFAULT_LAST_SAMPLE_DURATION_US;
-      listener.onSourceInfoRefreshed(durationUs, isSeekable);
+      listener.onSourceInfoRefreshed(durationUs, isSeekable, isLive);
     }
     eventDispatcher.loadCompleted(
         loadable.dataSpec,
@@ -735,14 +747,12 @@ private void maybeFinishPrepare() {
       }
       trackArray[i] = new TrackGroup(trackFormat);
     }
-    dataType =
-        length == C.LENGTH_UNSET && seekMap.getDurationUs() == C.TIME_UNSET
-            ? C.DATA_TYPE_MEDIA_PROGRESSIVE_LIVE
-            : C.DATA_TYPE_MEDIA;
+    isLive = length == C.LENGTH_UNSET && seekMap.getDurationUs() == C.TIME_UNSET;
+    dataType = isLive ? C.DATA_TYPE_MEDIA_PROGRESSIVE_LIVE : C.DATA_TYPE_MEDIA;
     preparedState =
         new PreparedState(seekMap, new TrackGroupArray(trackArray), trackIsAudioVideoFlags);
     prepared = true;
-    listener.onSourceInfoRefreshed(durationUs, seekMap.isSeekable());
+    listener.onSourceInfoRefreshed(durationUs, seekMap.isSeekable(), isLive);
     Assertions.checkNotNull(callback).onPrepared(this);
   }
 
@@ -1025,9 +1035,8 @@ private DataSpec buildDataSpec(long position) {
           position,
           C.LENGTH_UNSET,
           customCacheKey,
-          DataSpec.FLAG_ALLOW_ICY_METADATA
-              | DataSpec.FLAG_DONT_CACHE_IF_LENGTH_UNKNOWN
-              | DataSpec.FLAG_ALLOW_CACHE_FRAGMENTATION);
+          DataSpec.FLAG_DONT_CACHE_IF_LENGTH_UNKNOWN | DataSpec.FLAG_ALLOW_CACHE_FRAGMENTATION,
+          ICY_METADATA_HEADERS);
     }
 
     private void setLoadPosition(long position, long timeUs) {
@@ -1154,4 +1163,12 @@ public int hashCode() {
       return 31 * id + (isIcyTrack ? 1 : 0);
     }
   }
+
+  private static Map<String, String> createIcyMetadataHeaders() {
+    Map<String, String> headers = new HashMap<>();
+    headers.put(
+        IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_NAME,
+        IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_VALUE);
+    return Collections.unmodifiableMap(headers);
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaSource.java
index bd32587bdd..c88972da62 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ProgressiveMediaSource.java
@@ -220,6 +220,7 @@ public ProgressiveMediaSource createMediaSource(Uri uri) {
 
   private long timelineDurationUs;
   private boolean timelineIsSeekable;
+  private boolean timelineIsLive;
   @Nullable private TransferListener transferListener;
 
   // TODO: Make private when ExtractorMediaSource is deleted.
@@ -252,7 +253,8 @@ public Object getTag() {
   @Override
   protected void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
     transferListener = mediaTransferListener;
-    notifySourceInfoRefreshed(timelineDurationUs, timelineIsSeekable);
+    drmSessionManager.prepare();
+    notifySourceInfoRefreshed(timelineDurationUs, timelineIsSeekable, timelineIsLive);
   }
 
   @Override
@@ -286,33 +288,38 @@ public void releasePeriod(MediaPeriod mediaPeriod) {
 
   @Override
   protected void releaseSourceInternal() {
-    // Do nothing.
+    drmSessionManager.release();
   }
 
   // ProgressiveMediaPeriod.Listener implementation.
 
   @Override
-  public void onSourceInfoRefreshed(long durationUs, boolean isSeekable) {
+  public void onSourceInfoRefreshed(long durationUs, boolean isSeekable, boolean isLive) {
     // If we already have the duration from a previous source info refresh, use it.
     durationUs = durationUs == C.TIME_UNSET ? timelineDurationUs : durationUs;
-    if (timelineDurationUs == durationUs && timelineIsSeekable == isSeekable) {
+    if (timelineDurationUs == durationUs
+        && timelineIsSeekable == isSeekable
+        && timelineIsLive == isLive) {
       // Suppress no-op source info changes.
       return;
     }
-    notifySourceInfoRefreshed(durationUs, isSeekable);
+    notifySourceInfoRefreshed(durationUs, isSeekable, isLive);
   }
 
   // Internal methods.
 
-  private void notifySourceInfoRefreshed(long durationUs, boolean isSeekable) {
+  private void notifySourceInfoRefreshed(long durationUs, boolean isSeekable, boolean isLive) {
     timelineDurationUs = durationUs;
     timelineIsSeekable = isSeekable;
-    // TODO: Make timeline dynamic until its duration is known. This is non-trivial. See b/69703223.
+    timelineIsLive = isLive;
+    // TODO: Split up isDynamic into multiple fields to indicate which values may change. Then
+    // indicate that the duration may change until it's known. See [internal: b/69703223].
     refreshSourceInfo(
         new SinglePeriodTimeline(
             timelineDurationUs,
             timelineIsSeekable,
             /* isDynamic= */ false,
+            /* isLive= */ timelineIsLive,
             /* manifest= */ null,
             tag));
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java
index 182f0f17cc..189c13ef0f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java
@@ -60,6 +60,9 @@
    */
   boolean continueLoading(long positionUs);
 
+  /** Returns whether the loader is currently loading. */
+  boolean isLoading();
+
   /**
    * Re-evaluates the buffer given the playback position.
    *
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SilenceMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SilenceMediaSource.java
index 3bb7ada7e0..abaf33633e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SilenceMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SilenceMediaSource.java
@@ -68,7 +68,8 @@ public SilenceMediaSource(long durationUs) {
   @Override
   protected void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
     refreshSourceInfo(
-        new SinglePeriodTimeline(durationUs, /* isSeekable= */ true, /* isDynamic= */ false));
+        new SinglePeriodTimeline(
+            durationUs, /* isSeekable= */ true, /* isDynamic= */ false, /* isLive= */ false));
   }
 
   @Override
@@ -171,6 +172,11 @@ public boolean continueLoading(long positionUs) {
       return false;
     }
 
+    @Override
+    public boolean isLoading() {
+      return false;
+    }
+
     @Override
     public void reevaluateBuffer(long positionUs) {}
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
index 49d67935a5..45f64cacf2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
@@ -35,6 +35,7 @@
   private final long windowDefaultStartPositionUs;
   private final boolean isSeekable;
   private final boolean isDynamic;
+  private final boolean isLive;
   @Nullable private final Object tag;
   @Nullable private final Object manifest;
 
@@ -44,9 +45,11 @@
    * @param durationUs The duration of the period, in microseconds.
    * @param isSeekable Whether seeking is supported within the period.
    * @param isDynamic Whether the window may change when the timeline is updated.
+   * @param isLive Whether the window is live.
    */
-  public SinglePeriodTimeline(long durationUs, boolean isSeekable, boolean isDynamic) {
-    this(durationUs, isSeekable, isDynamic, /* manifest= */ null, /* tag= */ null);
+  public SinglePeriodTimeline(
+      long durationUs, boolean isSeekable, boolean isDynamic, boolean isLive) {
+    this(durationUs, isSeekable, isDynamic, isLive, /* manifest= */ null, /* tag= */ null);
   }
 
   /**
@@ -55,6 +58,7 @@ public SinglePeriodTimeline(long durationUs, boolean isSeekable, boolean isDynam
    * @param durationUs The duration of the period, in microseconds.
    * @param isSeekable Whether seeking is supported within the period.
    * @param isDynamic Whether the window may change when the timeline is updated.
+   * @param isLive Whether the window is live.
    * @param manifest The manifest. May be {@code null}.
    * @param tag A tag used for {@link Window#tag}.
    */
@@ -62,6 +66,7 @@ public SinglePeriodTimeline(
       long durationUs,
       boolean isSeekable,
       boolean isDynamic,
+      boolean isLive,
       @Nullable Object manifest,
       @Nullable Object tag) {
     this(
@@ -71,6 +76,7 @@ public SinglePeriodTimeline(
         /* windowDefaultStartPositionUs= */ 0,
         isSeekable,
         isDynamic,
+        isLive,
         manifest,
         tag);
   }
@@ -87,6 +93,7 @@ public SinglePeriodTimeline(
    *     which to begin playback, in microseconds.
    * @param isSeekable Whether seeking is supported within the window.
    * @param isDynamic Whether the window may change when the timeline is updated.
+   * @param isLive Whether the window is live.
    * @param manifest The manifest. May be (@code null}.
    * @param tag A tag used for {@link Timeline.Window#tag}.
    */
@@ -97,6 +104,7 @@ public SinglePeriodTimeline(
       long windowDefaultStartPositionUs,
       boolean isSeekable,
       boolean isDynamic,
+      boolean isLive,
       @Nullable Object manifest,
       @Nullable Object tag) {
     this(
@@ -108,6 +116,7 @@ public SinglePeriodTimeline(
         windowDefaultStartPositionUs,
         isSeekable,
         isDynamic,
+        isLive,
         manifest,
         tag);
   }
@@ -127,6 +136,7 @@ public SinglePeriodTimeline(
    *     which to begin playback, in microseconds.
    * @param isSeekable Whether seeking is supported within the window.
    * @param isDynamic Whether the window may change when the timeline is updated.
+   * @param isLive Whether the window is live.
    * @param manifest The manifest. May be {@code null}.
    * @param tag A tag used for {@link Timeline.Window#tag}.
    */
@@ -139,6 +149,7 @@ public SinglePeriodTimeline(
       long windowDefaultStartPositionUs,
       boolean isSeekable,
       boolean isDynamic,
+      boolean isLive,
       @Nullable Object manifest,
       @Nullable Object tag) {
     this.presentationStartTimeMs = presentationStartTimeMs;
@@ -149,6 +160,7 @@ public SinglePeriodTimeline(
     this.windowDefaultStartPositionUs = windowDefaultStartPositionUs;
     this.isSeekable = isSeekable;
     this.isDynamic = isDynamic;
+    this.isLive = isLive;
     this.manifest = manifest;
     this.tag = tag;
   }
@@ -182,6 +194,7 @@ public Window getWindow(int windowIndex, Window window, long defaultPositionProj
         windowStartTimeMs,
         isSeekable,
         isDynamic,
+        isLive,
         windowDefaultStartPositionUs,
         windowDurationUs,
         0,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
index 8d41fbc73f..a5d8266ef6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
@@ -172,6 +172,11 @@ public boolean continueLoading(long positionUs) {
     return true;
   }
 
+  @Override
+  public boolean isLoading() {
+    return loader.isLoading();
+  }
+
   @Override
   public long readDiscontinuity() {
     if (!notifiedReadingStarted) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
index 04ee3a153c..be939fd018 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
@@ -291,7 +291,12 @@ private SingleSampleMediaSource(
     dataSpec = new DataSpec(uri, DataSpec.FLAG_ALLOW_GZIP);
     timeline =
         new SinglePeriodTimeline(
-            durationUs, /* isSeekable= */ true, /* isDynamic= */ false, /* manifest= */ null, tag);
+            durationUs,
+            /* isSeekable= */ true,
+            /* isDynamic= */ false,
+            /* isLive= */ false,
+            /* manifest= */ null,
+            tag);
   }
 
   // MediaSource implementation.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
index 6817f294b2..61e2868725 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
@@ -577,6 +577,11 @@ public boolean continueLoading(long positionUs) {
     return true;
   }
 
+  @Override
+  public boolean isLoading() {
+    return loader.isLoading();
+  }
+
   @Override
   public long getNextLoadPositionUs() {
     if (isPendingReset()) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
index fc3783d56b..eae21b5b30 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
@@ -285,7 +285,7 @@ protected AdaptiveTrackSelection createAdaptiveTrackSelection(
   public static final int DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS = 10000;
   public static final int DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS = 25000;
   public static final int DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS = 25000;
-  public static final float DEFAULT_BANDWIDTH_FRACTION = 0.75f;
+  public static final float DEFAULT_BANDWIDTH_FRACTION = 0.7f;
   public static final float DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE = 0.75f;
   public static final long DEFAULT_MIN_TIME_BETWEEN_BUFFER_REEVALUTATION_MS = 2000;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
index f5802bed4e..acf5550427 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
@@ -35,19 +35,14 @@
 
   /**
    * The flags that apply to any request for data. Possible flag values are {@link
-   * #FLAG_ALLOW_GZIP}, {@link #FLAG_ALLOW_ICY_METADATA}, {@link #FLAG_DONT_CACHE_IF_LENGTH_UNKNOWN}
-   * and {@link #FLAG_ALLOW_CACHE_FRAGMENTATION}.
+   * #FLAG_ALLOW_GZIP}, {@link #FLAG_DONT_CACHE_IF_LENGTH_UNKNOWN} and {@link
+   * #FLAG_ALLOW_CACHE_FRAGMENTATION}.
    */
   @Documented
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(
       flag = true,
-      value = {
-        FLAG_ALLOW_GZIP,
-        FLAG_ALLOW_ICY_METADATA,
-        FLAG_DONT_CACHE_IF_LENGTH_UNKNOWN,
-        FLAG_ALLOW_CACHE_FRAGMENTATION
-      })
+      value = {FLAG_ALLOW_GZIP, FLAG_DONT_CACHE_IF_LENGTH_UNKNOWN, FLAG_ALLOW_CACHE_FRAGMENTATION})
   public @interface Flags {}
   /**
    * Allows an underlying network stack to request that the server use gzip compression.
@@ -61,17 +56,15 @@
    * DataSource#read(byte[], int, int)} will be the decompressed data.
    */
   public static final int FLAG_ALLOW_GZIP = 1;
-  /** Allows an underlying network stack to request that the stream contain ICY metadata. */
-  public static final int FLAG_ALLOW_ICY_METADATA = 1 << 1; // 2
   /** Prevents caching if the length cannot be resolved when the {@link DataSource} is opened. */
-  public static final int FLAG_DONT_CACHE_IF_LENGTH_UNKNOWN = 1 << 2; // 4
+  public static final int FLAG_DONT_CACHE_IF_LENGTH_UNKNOWN = 1 << 1; // 2
   /**
    * Allows fragmentation of this request into multiple cache files, meaning a cache eviction policy
    * will be able to evict individual fragments of the data. Depending on the cache implementation,
    * setting this flag may also enable more concurrent access to the data (e.g. reading one fragment
    * whilst writing another).
    */
-  public static final int FLAG_ALLOW_CACHE_FRAGMENTATION = 1 << 3; // 8
+  public static final int FLAG_ALLOW_CACHE_FRAGMENTATION = 1 << 2; // 4
 
   /**
    * The set of HTTP methods that are supported by ExoPlayer {@link HttpDataSource}s. One of {@link
@@ -172,6 +165,36 @@ public DataSpec(
     this(uri, absoluteStreamPosition, absoluteStreamPosition, length, key, flags);
   }
 
+  /**
+   * Construct a data spec where {@link #position} equals {@link #absoluteStreamPosition} and has
+   * request headers.
+   *
+   * @param uri {@link #uri}.
+   * @param absoluteStreamPosition {@link #absoluteStreamPosition}, equal to {@link #position}.
+   * @param length {@link #length}.
+   * @param key {@link #key}.
+   * @param flags {@link #flags}.
+   * @param httpRequestHeaders {@link #httpRequestHeaders}
+   */
+  public DataSpec(
+      Uri uri,
+      long absoluteStreamPosition,
+      long length,
+      @Nullable String key,
+      @Flags int flags,
+      Map<String, String> httpRequestHeaders) {
+    this(
+        uri,
+        inferHttpMethod(null),
+        null,
+        absoluteStreamPosition,
+        absoluteStreamPosition,
+        length,
+        key,
+        flags,
+        httpRequestHeaders);
+  }
+
   /**
    * Construct a data spec where {@link #position} may differ from {@link #absoluteStreamPosition}.
    *
@@ -216,7 +239,7 @@ public DataSpec(
       @Flags int flags) {
     this(
         uri,
-        /* httpMethod= */ postBody != null ? HTTP_METHOD_POST : HTTP_METHOD_GET,
+        /* httpMethod= */ inferHttpMethod(postBody),
         /* httpBody= */ postBody,
         absoluteStreamPosition,
         position,
@@ -403,4 +426,53 @@ public DataSpec withUri(Uri uri) {
         flags,
         httpRequestHeaders);
   }
+
+  /**
+   * Returns a copy of this data spec with the specified request headers.
+   *
+   * @param requestHeaders The HTTP request headers.
+   * @return The copied data spec with the specified request headers.
+   */
+  public DataSpec withRequestHeaders(Map<String, String> requestHeaders) {
+    return new DataSpec(
+        uri,
+        httpMethod,
+        httpBody,
+        absoluteStreamPosition,
+        position,
+        length,
+        key,
+        flags,
+        requestHeaders);
+  }
+
+  /**
+   * Returns a copy this data spec with additional request headers.
+   *
+   * <p>Note: Values in {@code requestHeaders} will overwrite values with the same header key that
+   * were previously set in this instance's {@code #httpRequestHeaders}.
+   *
+   * @param requestHeaders The additional HTTP request headers.
+   * @return The copied data with the additional HTTP request headers.
+   */
+  public DataSpec withAdditionalHeaders(Map<String, String> requestHeaders) {
+    Map<String, String> totalHeaders = new HashMap<>(this.httpRequestHeaders);
+    totalHeaders.putAll(requestHeaders);
+
+    return new DataSpec(
+        uri,
+        httpMethod,
+        httpBody,
+        absoluteStreamPosition,
+        position,
+        length,
+        key,
+        flags,
+        totalHeaders);
+  }
+
+  @HttpMethod
+  private static int inferHttpMethod(@Nullable byte[] postBody) {
+    return postBody != null ? HTTP_METHOD_POST : HTTP_METHOD_GET;
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
index 37329a4868..436cad0d64 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
@@ -20,7 +20,6 @@
 import androidx.annotation.Nullable;
 import androidx.annotation.VisibleForTesting;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.metadata.icy.IcyHeaders;
 import com.google.android.exoplayer2.upstream.DataSpec.HttpMethod;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
@@ -432,7 +431,6 @@ private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
     long position = dataSpec.position;
     long length = dataSpec.length;
     boolean allowGzip = dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_GZIP);
-    boolean allowIcyMetadata = dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_ICY_METADATA);
 
     if (!allowCrossProtocolRedirects) {
       // HttpURLConnection disallows cross-protocol redirects, but otherwise performs redirection
@@ -444,7 +442,6 @@ private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
           position,
           length,
           allowGzip,
-          allowIcyMetadata,
           /* followRedirects= */ true,
           dataSpec.httpRequestHeaders);
     }
@@ -460,7 +457,6 @@ private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
               position,
               length,
               allowGzip,
-              allowIcyMetadata,
               /* followRedirects= */ false,
               dataSpec.httpRequestHeaders);
       int responseCode = connection.getResponseCode();
@@ -502,7 +498,6 @@ private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
    * @param position The byte offset of the requested data.
    * @param length The length of the requested data, or {@link C#LENGTH_UNSET}.
    * @param allowGzip Whether to allow the use of gzip.
-   * @param allowIcyMetadata Whether to allow ICY metadata.
    * @param followRedirects Whether to follow redirects.
    * @param requestParameters parameters (HTTP headers) to include in request.
    */
@@ -513,7 +508,6 @@ private HttpURLConnection makeConnection(
       long position,
       long length,
       boolean allowGzip,
-      boolean allowIcyMetadata,
       boolean followRedirects,
       Map<String, String> requestParameters)
       throws IOException {
@@ -541,14 +535,10 @@ private HttpURLConnection makeConnection(
     }
     connection.setRequestProperty("User-Agent", userAgent);
     connection.setRequestProperty("Accept-Encoding", allowGzip ? "gzip" : "identity");
-    if (allowIcyMetadata) {
-      connection.setRequestProperty(
-          IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_NAME,
-          IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_VALUE);
-    }
     connection.setInstanceFollowRedirects(followRedirects);
     connection.setDoOutput(httpBody != null);
     connection.setRequestMethod(DataSpec.getStringForHttpMethod(httpMethod));
+    
     if (httpBody != null) {
       connection.setFixedLengthStreamingMode(httpBody.length);
       connection.connect();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java
index e329dc722e..38b4a1da03 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java
@@ -18,10 +18,12 @@
 import static com.google.android.exoplayer2.util.Util.castNonNull;
 
 import android.net.Uri;
+import android.text.TextUtils;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.EOFException;
+import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.RandomAccessFile;
 
@@ -37,6 +39,9 @@ public FileDataSourceException(IOException cause) {
       super(cause);
     }
 
+    public FileDataSourceException(String message, IOException cause) {
+      super(message, cause);
+    }
   }
 
   @Nullable private RandomAccessFile file;
@@ -55,8 +60,8 @@ public long open(DataSpec dataSpec) throws FileDataSourceException {
       this.uri = uri;
 
       transferInitializing(dataSpec);
-      RandomAccessFile file = new RandomAccessFile(Assertions.checkNotNull(uri.getPath()), "r");
-      this.file = file;
+
+      this.file = openLocalFile(uri);
 
       file.seek(dataSpec.position);
       bytesRemaining = dataSpec.length == C.LENGTH_UNSET ? file.length() - dataSpec.position
@@ -74,6 +79,23 @@ public long open(DataSpec dataSpec) throws FileDataSourceException {
     return bytesRemaining;
   }
 
+  private static RandomAccessFile openLocalFile(Uri uri) throws FileDataSourceException {
+    try {
+      return new RandomAccessFile(Assertions.checkNotNull(uri.getPath()), "r");
+    } catch (FileNotFoundException e) {
+      if (!TextUtils.isEmpty(uri.getQuery()) || !TextUtils.isEmpty(uri.getFragment())) {
+        throw new FileDataSourceException(
+            String.format(
+                "uri has query and/or fragment, which are not supported. Did you call Uri.parse()"
+                    + " on a string containing '?' or '#'? Use Uri.fromFile(new File(path)) to"
+                    + " avoid this. path=%s,query=%s,fragment=%s",
+                uri.getPath(), uri.getQuery(), uri.getFragment()),
+            e);
+      }
+      throw new FileDataSourceException(e);
+    }
+  }
+
   @Override
   public int read(byte[] buffer, int offset, int readLength) throws FileDataSourceException {
     if (readLength == 0) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSourceFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSourceFactory.java
index 0b4de1b43e..e0630c7989 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSourceFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSourceFactory.java
@@ -33,7 +33,7 @@ public FileDataSourceFactory(@Nullable TransferListener listener) {
   }
 
   @Override
-  public DataSource createDataSource() {
+  public FileDataSource createDataSource() {
     FileDataSource dataSource = new FileDataSource();
     if (listener != null) {
       dataSource.addTransferListener(listener);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ResolvingDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ResolvingDataSource.java
index 99f0dee207..412f866e99 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ResolvingDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ResolvingDataSource.java
@@ -64,9 +64,7 @@ default Uri resolveReportedUri(Uri uri) {
     private final Resolver resolver;
 
     /**
-     * Creates factory for {@link ResolvingDataSource} instances.
-     *
-     * @param upstreamFactory The wrapped {@link DataSource.Factory} handling the resolved {@link
+     * @param upstreamFactory The wrapped {@link DataSource.Factory} for handling resolved {@link
      *     DataSpec DataSpecs}.
      * @param resolver The {@link Resolver} to resolve the {@link DataSpec DataSpecs}.
      */
@@ -76,7 +74,7 @@ public Factory(DataSource.Factory upstreamFactory, Resolver resolver) {
     }
 
     @Override
-    public DataSource createDataSource() {
+    public ResolvingDataSource createDataSource() {
       return new ResolvingDataSource(upstreamFactory.createDataSource(), resolver);
     }
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
index 80fecf19cc..22ed3892ec 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
@@ -53,7 +53,6 @@
   private long dataSpecFragmentSize;
   private File file;
   private OutputStream outputStream;
-  private FileOutputStream underlyingFileOutputStream;
   private long outputStreamBytesWritten;
   private long dataSpecBytesWritten;
   private ReusableBufferedOutputStream bufferedOutputStream;
@@ -171,7 +170,7 @@ private void openNextOutputStream() throws IOException {
     file =
         cache.startFile(
             dataSpec.key, dataSpec.absoluteStreamPosition + dataSpecBytesWritten, length);
-    underlyingFileOutputStream = new FileOutputStream(file);
+    FileOutputStream underlyingFileOutputStream = new FileOutputStream(file);
     if (bufferSize > 0) {
       if (bufferedOutputStream == null) {
         bufferedOutputStream = new ReusableBufferedOutputStream(underlyingFileOutputStream,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSink.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSink.java
index 522fdc9a3f..d9b3ff0069 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSink.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSink.java
@@ -52,10 +52,10 @@ public AesCipherDataSink(byte[] secretKey, DataSink wrappedDataSink) {
    *
    * @param secretKey The key data.
    * @param wrappedDataSink The wrapped {@link DataSink}.
-   * @param scratch Scratch space. Data is decrypted into this array before being written to the
+   * @param scratch Scratch space. Data is encrypted into this array before being written to the
    *     wrapped {@link DataSink}. It should be of appropriate size for the expected writes. If a
    *     write is larger than the size of this array the write will still succeed, but multiple
-   *     cipher calls will be required to complete the operation. If {@code null} then decryption
+   *     cipher calls will be required to complete the operation. If {@code null} then encryption
    *     will overwrite the input {@code data}.
    */
   public AesCipherDataSink(byte[] secretKey, DataSink wrappedDataSink, @Nullable byte[] scratch) {
@@ -96,5 +96,4 @@ public void close() throws IOException {
     cipher = null;
     wrappedDataSink.close();
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/ConditionVariable.java b/library/core/src/main/java/com/google/android/exoplayer2/util/ConditionVariable.java
index 058a5d6dd2..c035c62a7e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/ConditionVariable.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/ConditionVariable.java
@@ -76,4 +76,8 @@ public synchronized boolean block(long timeout) throws InterruptedException {
     return isOpen;
   }
 
+  /** Returns whether the condition is opened. */
+  public synchronized boolean isOpen() {
+    return isOpen;
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/EventLogger.java b/library/core/src/main/java/com/google/android/exoplayer2/util/EventLogger.java
index 66e78eb3a5..ec9ddba122 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/EventLogger.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/EventLogger.java
@@ -23,9 +23,11 @@
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.Player.PlaybackSuppressionReason;
 import com.google.android.exoplayer2.RendererCapabilities;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.analytics.AnalyticsListener;
+import com.google.android.exoplayer2.audio.AudioAttributes;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.source.MediaSourceEventListener.LoadEventInfo;
@@ -98,6 +100,20 @@ public void onPlayerStateChanged(
     logd(eventTime, "state", playWhenReady + ", " + getStateString(state));
   }
 
+  @Override
+  public void onPlaybackSuppressionReasonChanged(
+      EventTime eventTime, @PlaybackSuppressionReason int playbackSuppressionReason) {
+    logd(
+        eventTime,
+        "playbackSuppressionReason",
+        getPlaybackSuppressionReasonString(playbackSuppressionReason));
+  }
+
+  @Override
+  public void onIsPlayingChanged(EventTime eventTime, boolean isPlaying) {
+    logd(eventTime, "isPlaying", Boolean.toString(isPlaying));
+  }
+
   @Override
   public void onRepeatModeChanged(EventTime eventTime, @Player.RepeatMode int repeatMode) {
     logd(eventTime, "repeatMode", getRepeatModeString(repeatMode));
@@ -134,7 +150,7 @@ public void onTimelineChanged(EventTime eventTime, @Player.TimelineChangeReason
     int periodCount = eventTime.timeline.getPeriodCount();
     int windowCount = eventTime.timeline.getWindowCount();
     logd(
-        "timelineChanged ["
+        "timeline ["
             + getEventTimeString(eventTime)
             + ", periodCount="
             + periodCount
@@ -178,10 +194,10 @@ public void onTracksChanged(
     MappedTrackInfo mappedTrackInfo =
         trackSelector != null ? trackSelector.getCurrentMappedTrackInfo() : null;
     if (mappedTrackInfo == null) {
-      logd(eventTime, "tracksChanged", "[]");
+      logd(eventTime, "tracks", "[]");
       return;
     }
-    logd("tracksChanged [" + getEventTimeString(eventTime) + ", ");
+    logd("tracks [" + getEventTimeString(eventTime) + ", ");
     // Log tracks associated to renderers.
     int rendererCount = mappedTrackInfo.getRendererCount();
     for (int rendererIndex = 0; rendererIndex < rendererCount; rendererIndex++) {
@@ -278,6 +294,25 @@ public void onAudioSessionId(EventTime eventTime, int audioSessionId) {
     logd(eventTime, "audioSessionId", Integer.toString(audioSessionId));
   }
 
+  @Override
+  public void onAudioAttributesChanged(EventTime eventTime, AudioAttributes audioAttributes) {
+    logd(
+        eventTime,
+        "audioAttributes",
+        audioAttributes.contentType
+            + ","
+            + audioAttributes.flags
+            + ","
+            + audioAttributes.usage
+            + ","
+            + audioAttributes.allowedCapturePolicy);
+  }
+
+  @Override
+  public void onVolumeChanged(EventTime eventTime, float volume) {
+    logd(eventTime, "volume", Float.toString(volume));
+  }
+
   @Override
   public void onDecoderInitialized(
       EventTime eventTime, int trackType, String decoderName, long initializationDurationMs) {
@@ -288,7 +323,7 @@ public void onDecoderInitialized(
   public void onDecoderInputFormatChanged(EventTime eventTime, int trackType, Format format) {
     logd(
         eventTime,
-        "decoderInputFormatChanged",
+        "decoderInputFormat",
         getTrackTypeString(trackType) + ", " + Format.toLogString(format));
   }
 
@@ -319,7 +354,7 @@ public void onVideoSizeChanged(
       int height,
       int unappliedRotationDegrees,
       float pixelWidthHeightRatio) {
-    logd(eventTime, "videoSizeChanged", width + ", " + height);
+    logd(eventTime, "videoSize", width + ", " + height);
   }
 
   @Override
@@ -378,7 +413,7 @@ public void onBandwidthEstimate(
 
   @Override
   public void onSurfaceSizeChanged(EventTime eventTime, int width, int height) {
-    logd(eventTime, "surfaceSizeChanged", width + ", " + height);
+    logd(eventTime, "surfaceSize", width + ", " + height);
   }
 
   @Override
@@ -388,7 +423,7 @@ public void onUpstreamDiscarded(EventTime eventTime, MediaLoadData mediaLoadData
 
   @Override
   public void onDownstreamFormatChanged(EventTime eventTime, MediaLoadData mediaLoadData) {
-    logd(eventTime, "downstreamFormatChanged", Format.toLogString(mediaLoadData.trackFormat));
+    logd(eventTime, "downstreamFormat", Format.toLogString(mediaLoadData.trackFormat));
   }
 
   @Override
@@ -594,10 +629,12 @@ private static String getDiscontinuityReasonString(@Player.DiscontinuityReason i
 
   private static String getTimelineChangeReasonString(@Player.TimelineChangeReason int reason) {
     switch (reason) {
-      case Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE:
-        return "SOURCE_UPDATE";
-      case Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED:
-        return "PLAYLIST_CHANGED";
+      case Player.TIMELINE_CHANGE_REASON_PREPARED:
+        return "PREPARED";
+      case Player.TIMELINE_CHANGE_REASON_RESET:
+        return "RESET";
+      case Player.TIMELINE_CHANGE_REASON_DYNAMIC:
+        return "DYNAMIC";
       default:
         return "?";
     }
@@ -623,4 +660,16 @@ private static String getTrackTypeString(int trackType) {
         return trackType >= C.TRACK_TYPE_CUSTOM_BASE ? "custom (" + trackType + ")" : "?";
     }
   }
+
+  private static String getPlaybackSuppressionReasonString(
+      @PlaybackSuppressionReason int playbackSuppressionReason) {
+    switch (playbackSuppressionReason) {
+      case Player.PLAYBACK_SUPPRESSION_REASON_NONE:
+        return "NONE";
+      case Player.PLAYBACK_SUPPRESSION_REASON_AUDIO_FOCUS_LOSS:
+        return "AUDIO_FOCUS_LOSS";
+      default:
+        return "?";
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/GlUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/util/GlUtil.java
index 7fc46dc363..c7feff516a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/GlUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/GlUtil.java
@@ -42,7 +42,7 @@ public static void checkGlError() {
     int lastError = GLES20.GL_NO_ERROR;
     int error;
     while ((error = GLES20.glGetError()) != GLES20.GL_NO_ERROR) {
-      Log.e(TAG, "glError " + gluErrorString(lastError));
+      Log.e(TAG, "glError " + gluErrorString(error));
       lastError = error;
     }
     if (ExoPlayerLibraryInfo.GL_ASSERTIONS_ENABLED && lastError != GLES20.GL_NO_ERROR) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java b/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
index cbd246cf22..e11aa53b0f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
@@ -53,7 +53,6 @@
 import com.google.android.exoplayer2.RendererCapabilities;
 import com.google.android.exoplayer2.RenderersFactory;
 import com.google.android.exoplayer2.SeekParameters;
-import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
@@ -2025,42 +2024,6 @@ private static String normalizeLanguageCodeSyntaxV21(String languageTag) {
     }
   }
 
-  /**
-   * Checks whether the timelines are the same.
-   *
-   * @param firstTimeline The first {@link Timeline}.
-   * @param secondTimeline The second {@link Timeline} to compare with.
-   * @return {@code true} if the both timelines are the same.
-   */
-  public static boolean areTimelinesSame(Timeline firstTimeline, Timeline secondTimeline) {
-    if (firstTimeline == secondTimeline) {
-      return true;
-    }
-    if (secondTimeline.getWindowCount() != firstTimeline.getWindowCount()
-        || secondTimeline.getPeriodCount() != firstTimeline.getPeriodCount()) {
-      return false;
-    }
-    Timeline.Window firstWindow = new Timeline.Window();
-    Timeline.Period firstPeriod = new Timeline.Period();
-    Timeline.Window secondWindow = new Timeline.Window();
-    Timeline.Period secondPeriod = new Timeline.Period();
-    for (int i = 0; i < firstTimeline.getWindowCount(); i++) {
-      if (!firstTimeline
-          .getWindow(i, firstWindow)
-          .equals(secondTimeline.getWindow(i, secondWindow))) {
-        return false;
-      }
-    }
-    for (int i = 0; i < firstTimeline.getPeriodCount(); i++) {
-      if (!firstTimeline
-          .getPeriod(i, firstPeriod, /* setIds= */ true)
-          .equals(secondTimeline.getPeriod(i, secondPeriod, /* setIds= */ true))) {
-        return false;
-      }
-    }
-    return true;
-  }
-
   private static HashMap<String, String> createIso3ToIso2Map() {
     String[] iso2Languages = Locale.getISOLanguages();
     HashMap<String, String> iso3ToIso2 =
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index 035e3bfad8..c66ce82614 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -802,9 +802,10 @@ protected boolean processOutputBuffer(
     long elapsedRealtimeNowUs = SystemClock.elapsedRealtime() * 1000;
     long elapsedSinceLastRenderUs = elapsedRealtimeNowUs - lastRenderTimeUs;
     boolean isStarted = getState() == STATE_STARTED;
-    // Don't force output until we joined and always render first frame if not joining.
+    // Don't force output until we joined and the position reached the current stream.
     boolean forceRenderOutputBuffer =
         joiningDeadlineMs == C.TIME_UNSET
+            && positionUs >= outputStreamOffsetUs
             && (!renderedFirstFrame
                 || (isStarted && shouldForceRenderOutputBuffer(earlyUs, elapsedSinceLastRenderUs)));
     if (forceRenderOutputBuffer) {
@@ -956,6 +957,7 @@ protected void onProcessedOutputBuffer(long presentationTimeUs) {
           pendingOutputStreamSwitchTimesUs,
           /* destPos= */ 0,
           pendingOutputStreamOffsetCount);
+      clearRenderedFirstFrame();
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/SimpleDecoderVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/SimpleDecoderVideoRenderer.java
index e8d63dd617..c7dc056823 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/SimpleDecoderVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/SimpleDecoderVideoRenderer.java
@@ -86,6 +86,10 @@
       decoder;
   private VideoDecoderInputBuffer inputBuffer;
   private VideoDecoderOutputBuffer outputBuffer;
+  @Nullable private Surface surface;
+  @Nullable private VideoDecoderOutputBufferRenderer outputBufferRenderer;
+  @C.VideoOutputMode private int outputMode;
+
   @Nullable private DrmSession<ExoMediaCrypto> decoderDrmSession;
   @Nullable private DrmSession<ExoMediaCrypto> sourceDrmSession;
 
@@ -147,6 +151,7 @@ protected SimpleDecoderVideoRenderer(
     flagsOnlyBuffer = DecoderInputBuffer.newFlagsOnlyInstance();
     eventDispatcher = new EventDispatcher(eventHandler, eventListener);
     decoderReinitializationState = REINITIALIZATION_STATE_NONE;
+    outputMode = C.VIDEO_OUTPUT_MODE_NONE;
   }
 
   // BaseRenderer implementation.
@@ -210,7 +215,7 @@ public boolean isReady() {
     }
     if (inputFormat != null
         && (isSourceReady() || outputBuffer != null)
-        && (renderedFirstFrame || !hasOutputSurface())) {
+        && (renderedFirstFrame || !hasOutput())) {
       // Ready. If we were joining then we've now joined, so clear the joining deadline.
       joiningDeadlineMs = C.TIME_UNSET;
       return true;
@@ -227,6 +232,8 @@ public boolean isReady() {
     }
   }
 
+  // Protected methods.
+
   @Override
   protected void onEnabled(boolean joining) throws ExoPlaybackException {
     decoderCounters = new DecoderCounters();
@@ -316,7 +323,7 @@ protected void flushDecoder() throws ExoPlaybackException {
       inputBuffer = null;
       if (outputBuffer != null) {
         outputBuffer.release();
-        clearOutputBuffer();
+        outputBuffer = null;
       }
       decoder.flush();
       decoderReceivedBuffers = false;
@@ -327,7 +334,7 @@ protected void flushDecoder() throws ExoPlaybackException {
   @CallSuper
   protected void releaseDecoder() {
     inputBuffer = null;
-    clearOutputBuffer();
+    outputBuffer = null;
     decoderReinitializationState = REINITIALIZATION_STATE_NONE;
     decoderReceivedBuffers = false;
     buffersInCodecCount = 0;
@@ -339,16 +346,6 @@ protected void releaseDecoder() {
     setDecoderDrmSession(null);
   }
 
-  private void setSourceDrmSession(@Nullable DrmSession<ExoMediaCrypto> session) {
-    DrmSession.replaceSessionReferences(sourceDrmSession, session);
-    sourceDrmSession = session;
-  }
-
-  private void setDecoderDrmSession(@Nullable DrmSession<ExoMediaCrypto> session) {
-    DrmSession.replaceSessionReferences(decoderDrmSession, session);
-    decoderDrmSession = session;
-  }
-
   /**
    * Called when a new format is read from the upstream source.
    *
@@ -528,94 +525,124 @@ protected abstract int supportsFormatInternal(
           throws VideoDecoderException;
 
   /**
-   * Dequeues output buffer.
+   * Renders the specified output buffer.
+   *
+   * <p>The implementation of this method takes ownership of the output buffer and is responsible
+   * for calling {@link VideoDecoderOutputBuffer#release()} either immediately or in the future.
    *
-   * @return Dequeued video decoder output buffer, or null if an output buffer isn't available.
-   * @throws VideoDecoderException If an error occurs while dequeuing the output buffer.
+   * @param outputBuffer {@link VideoDecoderOutputBuffer} to render.
+   * @param presentationTimeUs Presentation time in microseconds.
+   * @param outputFormat Output {@link Format}.
+   * @throws VideoDecoderException If an error occurs when rendering the output buffer.
    */
-  @Nullable
-  protected abstract VideoDecoderOutputBuffer dequeueOutputBuffer() throws VideoDecoderException;
-
-  /** Clears output buffer. */
-  protected void clearOutputBuffer() {
-    outputBuffer = null;
+  protected void renderOutputBuffer(
+      VideoDecoderOutputBuffer outputBuffer, long presentationTimeUs, Format outputFormat)
+      throws VideoDecoderException {
+    lastRenderTimeUs = C.msToUs(SystemClock.elapsedRealtime() * 1000);
+    int bufferMode = outputBuffer.mode;
+    boolean renderSurface = bufferMode == C.VIDEO_OUTPUT_MODE_SURFACE_YUV && surface != null;
+    boolean renderYuv = bufferMode == C.VIDEO_OUTPUT_MODE_YUV && outputBufferRenderer != null;
+    if (!renderYuv && !renderSurface) {
+      dropOutputBuffer(outputBuffer);
+    } else {
+      maybeNotifyVideoSizeChanged(outputBuffer.width, outputBuffer.height);
+      if (renderYuv) {
+        outputBufferRenderer.setOutputBuffer(outputBuffer);
+      } else {
+        renderOutputBufferToSurface(outputBuffer, surface);
+      }
+      consecutiveDroppedFrameCount = 0;
+      decoderCounters.renderedOutputBufferCount++;
+      maybeNotifyRenderedFirstFrame();
+    }
   }
 
   /**
-   * Renders the specified output buffer.
+   * Renders the specified output buffer to the passed surface.
    *
    * <p>The implementation of this method takes ownership of the output buffer and is responsible
    * for calling {@link VideoDecoderOutputBuffer#release()} either immediately or in the future.
    *
-   * @param presentationTimeUs Presentation time in microseconds.
-   * @param outputFormat Output format.
+   * @param outputBuffer {@link VideoDecoderOutputBuffer} to render.
+   * @param surface Output {@link Surface}.
+   * @throws VideoDecoderException If an error occurs when rendering the output buffer.
    */
-  // TODO: The output buffer is not being passed to this method currently. Due to the need of
-  // decoder-specific output buffer type, the reference to the output buffer is being kept in the
-  // subclass. Once the common output buffer is established, this method can be updated to receive
-  // the output buffer as an argument. See [Internal: b/139174707].
-  protected abstract void renderOutputBuffer(long presentationTimeUs, Format outputFormat)
-      throws VideoDecoderException;
+  protected abstract void renderOutputBufferToSurface(
+      VideoDecoderOutputBuffer outputBuffer, Surface surface) throws VideoDecoderException;
 
   /**
-   * Returns whether the renderer has output surface.
+   * Sets output surface.
    *
-   * @return Whether the renderer has output surface.
+   * @param surface Surface.
    */
-  protected abstract boolean hasOutputSurface();
-
-  /** Called when the output surface is changed. */
-  protected final void onOutputSurfaceChanged() {
-    // If we know the video size, report it again immediately.
-    maybeRenotifyVideoSizeChanged();
-    // We haven't rendered to the new output yet.
-    clearRenderedFirstFrame();
-    if (getState() == STATE_STARTED) {
-      setJoiningDeadlineMs();
+  protected final void setOutputSurface(@Nullable Surface surface) {
+    if (this.surface != surface) {
+      // The output has changed.
+      this.surface = surface;
+      if (surface != null) {
+        outputMode = C.VIDEO_OUTPUT_MODE_SURFACE_YUV;
+        if (decoder != null) {
+          setDecoderOutputMode(outputMode);
+        }
+        onOutputChanged();
+      } else {
+        // The output has been removed. We leave the outputMode of the underlying decoder unchanged
+        // in anticipation that a subsequent output will likely be of the same type.
+        outputMode = C.VIDEO_OUTPUT_MODE_NONE;
+        onOutputRemoved();
+      }
+    } else if (surface != null) {
+      // The output is unchanged and non-null.
+      onOutputReset();
     }
   }
 
-  /** Called when the output surface is removed. */
-  protected final void onOutputSurfaceRemoved() {
-    clearReportedVideoSize();
-    clearRenderedFirstFrame();
-  }
-
   /**
-   * Called when the output surface is set again to the same non-null value.
+   * Sets output buffer renderer.
    *
-   * @param surface Output surface.
+   * @param outputBufferRenderer Output buffer renderer.
    */
-  protected final void onOutputSurfaceReset(Surface surface) {
-    // The output is unchanged and non-null. If we know the video size and/or have already
-    // rendered to the output, report these again immediately.
-    maybeRenotifyVideoSizeChanged();
-    maybeRenotifyRenderedFirstFrame(surface);
+  protected final void setOutputBufferRenderer(
+      @Nullable VideoDecoderOutputBufferRenderer outputBufferRenderer) {
+    if (this.outputBufferRenderer != outputBufferRenderer) {
+      // The output has changed.
+      this.outputBufferRenderer = outputBufferRenderer;
+      if (outputBufferRenderer != null) {
+        outputMode = C.VIDEO_OUTPUT_MODE_YUV;
+        if (decoder != null) {
+          setDecoderOutputMode(outputMode);
+        }
+        onOutputChanged();
+      } else {
+        // The output has been removed. We leave the outputMode of the underlying decoder unchanged
+        // in anticipation that a subsequent output will likely be of the same type.
+        outputMode = C.VIDEO_OUTPUT_MODE_NONE;
+        onOutputRemoved();
+      }
+    } else if (outputBufferRenderer != null) {
+      // The output is unchanged and non-null.
+      onOutputReset();
+    }
   }
 
   /**
-   * Notifies event dispatcher if video size changed.
+   * Sets output mode of the decoder.
    *
-   * @param width New video width.
-   * @param height New video height.
+   * @param outputMode Output mode.
    */
-  protected final void maybeNotifyVideoSizeChanged(int width, int height) {
-    if (reportedWidth != width || reportedHeight != height) {
-      reportedWidth = width;
-      reportedHeight = height;
-      eventDispatcher.videoSizeChanged(
-          width, height, /* unappliedRotationDegrees= */ 0, /* pixelWidthHeightRatio= */ 1);
-    }
-  }
+  protected abstract void setDecoderOutputMode(@C.VideoOutputMode int outputMode);
 
-  /** Called after rendering a frame. */
-  protected final void onFrameRendered(Surface surface) {
-    consecutiveDroppedFrameCount = 0;
-    decoderCounters.renderedOutputBufferCount++;
-    maybeNotifyRenderedFirstFrame(surface);
+  // Internal methods.
+
+  private void setSourceDrmSession(@Nullable DrmSession<ExoMediaCrypto> session) {
+    DrmSession.replaceSessionReferences(sourceDrmSession, session);
+    sourceDrmSession = session;
   }
 
-  // Internal methods.
+  private void setDecoderDrmSession(@Nullable DrmSession<ExoMediaCrypto> session) {
+    DrmSession.replaceSessionReferences(decoderDrmSession, session);
+    decoderDrmSession = session;
+  }
 
   private void maybeInitDecoder() throws ExoPlaybackException {
     if (decoder != null) {
@@ -642,6 +669,7 @@ private void maybeInitDecoder() throws ExoPlaybackException {
     try {
       long decoderInitializingTimestamp = SystemClock.elapsedRealtime();
       decoder = createDecoder(inputFormat, mediaCrypto);
+      setDecoderOutputMode(outputMode);
       long decoderInitializedTimestamp = SystemClock.elapsedRealtime();
       onDecoderInitialized(
           decoder.getName(),
@@ -731,7 +759,7 @@ private boolean feedInputBuffer() throws VideoDecoderException, ExoPlaybackExcep
   private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
       throws ExoPlaybackException, VideoDecoderException {
     if (outputBuffer == null) {
-      outputBuffer = dequeueOutputBuffer();
+      outputBuffer = decoder.dequeueOutputBuffer();
       if (outputBuffer == null) {
         return false;
       }
@@ -746,7 +774,7 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
         maybeInitDecoder();
       } else {
         outputBuffer.release();
-        clearOutputBuffer();
+        outputBuffer = null;
         outputStreamEnded = true;
       }
       return false;
@@ -755,7 +783,7 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
     boolean processedOutputBuffer = processOutputBuffer(positionUs, elapsedRealtimeUs);
     if (processedOutputBuffer) {
       onProcessedOutputBuffer(outputBuffer.timeUs);
-      clearOutputBuffer();
+      outputBuffer = null;
     }
     return processedOutputBuffer;
   }
@@ -777,7 +805,7 @@ private boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs)
     }
 
     long earlyUs = outputBuffer.timeUs - positionUs;
-    if (!hasOutputSurface()) {
+    if (!hasOutput()) {
       // Skip frames in sync with playback, so we'll be at the right frame if the mode changes.
       if (isBufferLate(earlyUs)) {
         skipOutputBuffer(outputBuffer);
@@ -797,8 +825,7 @@ private boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs)
     if (!renderedFirstFrame
         || (isStarted
             && shouldForceRenderOutputBuffer(earlyUs, elapsedRealtimeNowUs - lastRenderTimeUs))) {
-      lastRenderTimeUs = SystemClock.elapsedRealtime() * 1000;
-      renderOutputBuffer(presentationTimeUs, outputFormat);
+      renderOutputBuffer(outputBuffer, presentationTimeUs, outputFormat);
       return true;
     }
 
@@ -815,14 +842,39 @@ private boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs)
     }
 
     if (earlyUs < 30000) {
-      lastRenderTimeUs = SystemClock.elapsedRealtime() * 1000;
-      renderOutputBuffer(presentationTimeUs, outputFormat);
+      renderOutputBuffer(outputBuffer, presentationTimeUs, outputFormat);
       return true;
     }
 
     return false;
   }
 
+  private boolean hasOutput() {
+    return outputMode != C.VIDEO_OUTPUT_MODE_NONE;
+  }
+
+  private void onOutputChanged() {
+    // If we know the video size, report it again immediately.
+    maybeRenotifyVideoSizeChanged();
+    // We haven't rendered to the new output yet.
+    clearRenderedFirstFrame();
+    if (getState() == STATE_STARTED) {
+      setJoiningDeadlineMs();
+    }
+  }
+
+  private void onOutputRemoved() {
+    clearReportedVideoSize();
+    clearRenderedFirstFrame();
+  }
+
+  private void onOutputReset() {
+    // The output is unchanged and non-null. If we know the video size and/or have already
+    // rendered to the output, report these again immediately.
+    maybeRenotifyVideoSizeChanged();
+    maybeRenotifyRenderedFirstFrame();
+  }
+
   private boolean shouldWaitForKeys(boolean bufferEncrypted) throws ExoPlaybackException {
     if (decoderDrmSession == null || (!bufferEncrypted && playClearSamplesWithoutKeys)) {
       return false;
@@ -845,14 +897,14 @@ private void clearRenderedFirstFrame() {
     renderedFirstFrame = false;
   }
 
-  private void maybeNotifyRenderedFirstFrame(Surface surface) {
+  private void maybeNotifyRenderedFirstFrame() {
     if (!renderedFirstFrame) {
       renderedFirstFrame = true;
       eventDispatcher.renderedFirstFrame(surface);
     }
   }
 
-  private void maybeRenotifyRenderedFirstFrame(Surface surface) {
+  private void maybeRenotifyRenderedFirstFrame() {
     if (renderedFirstFrame) {
       eventDispatcher.renderedFirstFrame(surface);
     }
@@ -863,6 +915,15 @@ private void clearReportedVideoSize() {
     reportedHeight = Format.NO_VALUE;
   }
 
+  private void maybeNotifyVideoSizeChanged(int width, int height) {
+    if (reportedWidth != width || reportedHeight != height) {
+      reportedWidth = width;
+      reportedHeight = height;
+      eventDispatcher.videoSizeChanged(
+          width, height, /* unappliedRotationDegrees= */ 0, /* pixelWidthHeightRatio= */ 1);
+    }
+  }
+
   private void maybeRenotifyVideoSizeChanged() {
     if (reportedWidth != Format.NO_VALUE || reportedHeight != Format.NO_VALUE) {
       eventDispatcher.videoSizeChanged(
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java
index 3704a09da0..44ab168505 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java
@@ -21,7 +21,18 @@
 import java.nio.ByteBuffer;
 
 /** Video decoder output buffer containing video frame data. */
-public abstract class VideoDecoderOutputBuffer extends OutputBuffer {
+public class VideoDecoderOutputBuffer extends OutputBuffer {
+
+  /** Buffer owner. */
+  public interface Owner {
+
+    /**
+     * Releases the buffer.
+     *
+     * @param outputBuffer Output buffer.
+     */
+    void releaseOutputBuffer(VideoDecoderOutputBuffer outputBuffer);
+  }
 
   public static final int COLORSPACE_UNKNOWN = 0;
   public static final int COLORSPACE_BT601 = 1;
@@ -52,6 +63,22 @@
    */
   @Nullable public ByteBuffer supplementalData;
 
+  private final Owner owner;
+
+  /**
+   * Creates VideoDecoderOutputBuffer.
+   *
+   * @param owner Buffer owner.
+   */
+  public VideoDecoderOutputBuffer(Owner owner) {
+    this.owner = owner;
+  }
+
+  @Override
+  public void release() {
+    owner.releaseOutputBuffer(this);
+  }
+
   /**
    * Initializes the buffer.
    *
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBufferRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBufferRenderer.java
similarity index 78%
rename from extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBufferRenderer.java
rename to library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBufferRenderer.java
index d07e24d920..c57794f454 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBufferRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBufferRenderer.java
@@ -13,18 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer2.ext.vp9;
+package com.google.android.exoplayer2.video;
 
-/**
- * Renders the {@link VpxOutputBuffer}.
- */
-public interface VpxOutputBufferRenderer {
+/** Renders the {@link VideoDecoderOutputBuffer}. */
+public interface VideoDecoderOutputBufferRenderer {
 
   /**
    * Sets the output buffer to be rendered. The renderer is responsible for releasing the buffer.
    *
    * @param outputBuffer The output buffer to be rendered.
    */
-  void setOutputBuffer(VpxOutputBuffer outputBuffer);
-
+  void setOutputBuffer(VideoDecoderOutputBuffer outputBuffer);
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderRenderer.java
new file mode 100644
index 0000000000..c85dff0c26
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderRenderer.java
@@ -0,0 +1,241 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.video;
+
+import android.opengl.GLES20;
+import android.opengl.GLSurfaceView;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.GlUtil;
+import java.nio.FloatBuffer;
+import java.util.concurrent.atomic.AtomicReference;
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.opengles.GL10;
+
+/**
+ * GLSurfaceView.Renderer implementation that can render YUV Frames returned by a video decoder
+ * after decoding. It does the YUV to RGB color conversion in the Fragment Shader.
+ */
+/* package */ class VideoDecoderRenderer implements GLSurfaceView.Renderer {
+
+  private static final float[] kColorConversion601 = {
+    1.164f, 1.164f, 1.164f,
+    0.0f, -0.392f, 2.017f,
+    1.596f, -0.813f, 0.0f,
+  };
+
+  private static final float[] kColorConversion709 = {
+    1.164f, 1.164f, 1.164f,
+    0.0f, -0.213f, 2.112f,
+    1.793f, -0.533f, 0.0f,
+  };
+
+  private static final float[] kColorConversion2020 = {
+    1.168f, 1.168f, 1.168f,
+    0.0f, -0.188f, 2.148f,
+    1.683f, -0.652f, 0.0f,
+  };
+
+  private static final String VERTEX_SHADER =
+      "varying vec2 interp_tc_y;\n"
+          + "varying vec2 interp_tc_u;\n"
+          + "varying vec2 interp_tc_v;\n"
+          + "attribute vec4 in_pos;\n"
+          + "attribute vec2 in_tc_y;\n"
+          + "attribute vec2 in_tc_u;\n"
+          + "attribute vec2 in_tc_v;\n"
+          + "void main() {\n"
+          + "  gl_Position = in_pos;\n"
+          + "  interp_tc_y = in_tc_y;\n"
+          + "  interp_tc_u = in_tc_u;\n"
+          + "  interp_tc_v = in_tc_v;\n"
+          + "}\n";
+  private static final String[] TEXTURE_UNIFORMS = {"y_tex", "u_tex", "v_tex"};
+  private static final String FRAGMENT_SHADER =
+      "precision mediump float;\n"
+          + "varying vec2 interp_tc_y;\n"
+          + "varying vec2 interp_tc_u;\n"
+          + "varying vec2 interp_tc_v;\n"
+          + "uniform sampler2D y_tex;\n"
+          + "uniform sampler2D u_tex;\n"
+          + "uniform sampler2D v_tex;\n"
+          + "uniform mat3 mColorConversion;\n"
+          + "void main() {\n"
+          + "  vec3 yuv;\n"
+          + "  yuv.x = texture2D(y_tex, interp_tc_y).r - 0.0625;\n"
+          + "  yuv.y = texture2D(u_tex, interp_tc_u).r - 0.5;\n"
+          + "  yuv.z = texture2D(v_tex, interp_tc_v).r - 0.5;\n"
+          + "  gl_FragColor = vec4(mColorConversion * yuv, 1.0);\n"
+          + "}\n";
+
+  private static final FloatBuffer TEXTURE_VERTICES =
+      GlUtil.createBuffer(new float[] {-1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f});
+  private final int[] yuvTextures = new int[3];
+  private final AtomicReference<VideoDecoderOutputBuffer> pendingOutputBufferReference;
+
+  // Kept in field rather than a local variable in order not to get garbage collected before
+  // glDrawArrays uses it.
+  @SuppressWarnings("FieldCanBeLocal")
+  private FloatBuffer[] textureCoords;
+
+  private int program;
+  private int[] texLocations;
+  private int colorMatrixLocation;
+  private int[] previousWidths;
+  private int[] previousStrides;
+
+  private VideoDecoderOutputBuffer renderedOutputBuffer; // Accessed only from the GL thread.
+
+  public VideoDecoderRenderer() {
+    pendingOutputBufferReference = new AtomicReference<>();
+    textureCoords = new FloatBuffer[3];
+    texLocations = new int[3];
+    previousWidths = new int[3];
+    previousStrides = new int[3];
+    for (int i = 0; i < 3; i++) {
+      previousWidths[i] = previousStrides[i] = -1;
+    }
+  }
+
+  /**
+   * Set a frame to be rendered. This should be followed by a call to
+   * VideoDecoderSurfaceView.requestRender() to actually render the frame.
+   *
+   * @param outputBuffer OutputBuffer containing the YUV Frame to be rendered
+   */
+  public void setFrame(VideoDecoderOutputBuffer outputBuffer) {
+    VideoDecoderOutputBuffer oldPendingOutputBuffer =
+        pendingOutputBufferReference.getAndSet(outputBuffer);
+    if (oldPendingOutputBuffer != null) {
+      // The old pending output buffer will never be used for rendering, so release it now.
+      oldPendingOutputBuffer.release();
+    }
+  }
+
+  @Override
+  public void onSurfaceCreated(GL10 unused, EGLConfig config) {
+    program = GlUtil.compileProgram(VERTEX_SHADER, FRAGMENT_SHADER);
+    GLES20.glUseProgram(program);
+    int posLocation = GLES20.glGetAttribLocation(program, "in_pos");
+    GLES20.glEnableVertexAttribArray(posLocation);
+    GLES20.glVertexAttribPointer(posLocation, 2, GLES20.GL_FLOAT, false, 0, TEXTURE_VERTICES);
+    texLocations[0] = GLES20.glGetAttribLocation(program, "in_tc_y");
+    GLES20.glEnableVertexAttribArray(texLocations[0]);
+    texLocations[1] = GLES20.glGetAttribLocation(program, "in_tc_u");
+    GLES20.glEnableVertexAttribArray(texLocations[1]);
+    texLocations[2] = GLES20.glGetAttribLocation(program, "in_tc_v");
+    GLES20.glEnableVertexAttribArray(texLocations[2]);
+    GlUtil.checkGlError();
+    colorMatrixLocation = GLES20.glGetUniformLocation(program, "mColorConversion");
+    GlUtil.checkGlError();
+    setupTextures();
+    GlUtil.checkGlError();
+  }
+
+  @Override
+  public void onSurfaceChanged(GL10 unused, int width, int height) {
+    GLES20.glViewport(0, 0, width, height);
+  }
+
+  @Override
+  public void onDrawFrame(GL10 unused) {
+    VideoDecoderOutputBuffer pendingOutputBuffer = pendingOutputBufferReference.getAndSet(null);
+    if (pendingOutputBuffer == null && renderedOutputBuffer == null) {
+      // There is no output buffer to render at the moment.
+      return;
+    }
+    if (pendingOutputBuffer != null) {
+      if (renderedOutputBuffer != null) {
+        renderedOutputBuffer.release();
+      }
+      renderedOutputBuffer = pendingOutputBuffer;
+    }
+    VideoDecoderOutputBuffer outputBuffer = renderedOutputBuffer;
+    // Set color matrix. Assume BT709 if the color space is unknown.
+    float[] colorConversion = kColorConversion709;
+    switch (outputBuffer.colorspace) {
+      case VideoDecoderOutputBuffer.COLORSPACE_BT601:
+        colorConversion = kColorConversion601;
+        break;
+      case VideoDecoderOutputBuffer.COLORSPACE_BT2020:
+        colorConversion = kColorConversion2020;
+        break;
+      case VideoDecoderOutputBuffer.COLORSPACE_BT709:
+      default:
+        break; // Do nothing
+    }
+    GLES20.glUniformMatrix3fv(colorMatrixLocation, 1, false, colorConversion, 0);
+
+    for (int i = 0; i < 3; i++) {
+      int h = (i == 0) ? outputBuffer.height : (outputBuffer.height + 1) / 2;
+      GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + i);
+      GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, yuvTextures[i]);
+      GLES20.glPixelStorei(GLES20.GL_UNPACK_ALIGNMENT, 1);
+      GLES20.glTexImage2D(
+          GLES20.GL_TEXTURE_2D,
+          0,
+          GLES20.GL_LUMINANCE,
+          outputBuffer.yuvStrides[i],
+          h,
+          0,
+          GLES20.GL_LUMINANCE,
+          GLES20.GL_UNSIGNED_BYTE,
+          outputBuffer.yuvPlanes[i]);
+    }
+
+    int[] widths = new int[3];
+    widths[0] = outputBuffer.width;
+    // TODO: Handle streams where chroma channels are not stored at half width and height
+    // compared to luma channel. See [Internal: b/142097774].
+    // U and V planes are being stored at half width compared to Y.
+    widths[1] = widths[2] = (widths[0] + 1) / 2;
+    for (int i = 0; i < 3; i++) {
+      // Set cropping of stride if either width or stride has changed.
+      if (previousWidths[i] != widths[i] || previousStrides[i] != outputBuffer.yuvStrides[i]) {
+        Assertions.checkState(outputBuffer.yuvStrides[i] != 0);
+        float widthRatio = (float) widths[i] / outputBuffer.yuvStrides[i];
+        // These buffers are consumed during each call to glDrawArrays. They need to be member
+        // variables rather than local variables in order not to get garbage collected.
+        textureCoords[i] =
+            GlUtil.createBuffer(
+                new float[] {0.0f, 0.0f, 0.0f, 1.0f, widthRatio, 0.0f, widthRatio, 1.0f});
+        GLES20.glVertexAttribPointer(
+            texLocations[i], 2, GLES20.GL_FLOAT, false, 0, textureCoords[i]);
+        previousWidths[i] = widths[i];
+        previousStrides[i] = outputBuffer.yuvStrides[i];
+      }
+    }
+
+    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
+    GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4);
+    GlUtil.checkGlError();
+  }
+
+  private void setupTextures() {
+    GLES20.glGenTextures(3, yuvTextures, 0);
+    for (int i = 0; i < 3; i++) {
+      GLES20.glUniform1i(GLES20.glGetUniformLocation(program, TEXTURE_UNIFORMS[i]), i);
+      GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + i);
+      GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, yuvTextures[i]);
+      GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
+      GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
+      GLES20.glTexParameterf(
+          GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
+      GLES20.glTexParameterf(
+          GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
+    }
+    GlUtil.checkGlError();
+  }
+}
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxVideoSurfaceView.java b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderSurfaceView.java
similarity index 67%
rename from extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxVideoSurfaceView.java
rename to library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderSurfaceView.java
index 9dd2432622..f2a4c2d002 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxVideoSurfaceView.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderSurfaceView.java
@@ -13,27 +13,26 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer2.ext.vp9;
+package com.google.android.exoplayer2.video;
 
 import android.content.Context;
 import android.opengl.GLSurfaceView;
 import android.util.AttributeSet;
 import androidx.annotation.Nullable;
 
-/**
- * A GLSurfaceView extension that scales itself to the given aspect ratio.
- */
-public class VpxVideoSurfaceView extends GLSurfaceView implements VpxOutputBufferRenderer {
+/** A GLSurfaceView extension that scales itself to the given aspect ratio. */
+public class VideoDecoderSurfaceView extends GLSurfaceView
+    implements VideoDecoderOutputBufferRenderer {
 
-  private final VpxRenderer renderer;
+  private final VideoDecoderRenderer renderer;
 
-  public VpxVideoSurfaceView(Context context) {
+  public VideoDecoderSurfaceView(Context context) {
     this(context, /* attrs= */ null);
   }
 
-  public VpxVideoSurfaceView(Context context, @Nullable AttributeSet attrs) {
+  public VideoDecoderSurfaceView(Context context, @Nullable AttributeSet attrs) {
     super(context, attrs);
-    renderer = new VpxRenderer();
+    renderer = new VideoDecoderRenderer();
     setPreserveEGLContextOnPause(true);
     setEGLContextClientVersion(2);
     setRenderer(renderer);
@@ -41,7 +40,7 @@ public VpxVideoSurfaceView(Context context, @Nullable AttributeSet attrs) {
   }
 
   @Override
-  public void setOutputBuffer(VpxOutputBuffer outputBuffer) {
+  public void setOutputBuffer(VideoDecoderOutputBuffer outputBuffer) {
     renderer.setFrame(outputBuffer);
     requestRender();
   }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/audio/AudioFocusManagerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/AudioFocusManagerTest.java
similarity index 97%
rename from library/core/src/test/java/com/google/android/exoplayer2/audio/AudioFocusManagerTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/AudioFocusManagerTest.java
index 544975ea03..7205a74853 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/audio/AudioFocusManagerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/AudioFocusManagerTest.java
@@ -13,11 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer2.audio;
+package com.google.android.exoplayer2;
 
-import static com.google.android.exoplayer2.audio.AudioFocusManager.PLAYER_COMMAND_DO_NOT_PLAY;
-import static com.google.android.exoplayer2.audio.AudioFocusManager.PLAYER_COMMAND_PLAY_WHEN_READY;
-import static com.google.android.exoplayer2.audio.AudioFocusManager.PLAYER_COMMAND_WAIT_FOR_CALLBACK;
+import static com.google.android.exoplayer2.AudioFocusManager.PLAYER_COMMAND_DO_NOT_PLAY;
+import static com.google.android.exoplayer2.AudioFocusManager.PLAYER_COMMAND_PLAY_WHEN_READY;
+import static com.google.android.exoplayer2.AudioFocusManager.PLAYER_COMMAND_WAIT_FOR_CALLBACK;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 import static org.robolectric.annotation.Config.TARGET_SDK;
@@ -27,8 +27,7 @@
 import android.media.AudioManager;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.audio.AudioAttributes;
 import com.google.android.exoplayer2.util.Util;
 import org.junit.Before;
 import org.junit.Test;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
index 21a6ac2818..37c026db74 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
@@ -31,7 +31,6 @@
 import com.google.android.exoplayer2.analytics.AnalyticsListener;
 import com.google.android.exoplayer2.source.ClippingMediaSource;
 import com.google.android.exoplayer2.source.ConcatenatingMediaSource;
-import com.google.android.exoplayer2.source.MaskingMediaSource;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
 import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
@@ -56,6 +55,7 @@
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.TransferListener;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Clock;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -85,12 +85,10 @@
   private static final int TIMEOUT_MS = 10000;
 
   private Context context;
-  private Timeline dummyTimeline;
 
   @Before
   public void setUp() {
     context = ApplicationProvider.getApplicationContext();
-    dummyTimeline = new MaskingMediaSource.DummyTimeline(/* tag= */ 0);
   }
 
   /**
@@ -100,7 +98,6 @@ public void setUp() {
   @Test
   public void testPlayEmptyTimeline() throws Exception {
     Timeline timeline = Timeline.EMPTY;
-    Timeline expectedMaskingTimeline = new MaskingMediaSource.DummyTimeline(/* tag= */ null);
     FakeRenderer renderer = new FakeRenderer();
     ExoPlayerTestRunner testRunner =
         new Builder()
@@ -110,10 +107,7 @@ public void testPlayEmptyTimeline() throws Exception {
             .start()
             .blockUntilEnded(TIMEOUT_MS);
     testRunner.assertNoPositionDiscontinuities();
-    testRunner.assertTimelinesSame(expectedMaskingTimeline, Timeline.EMPTY);
-    testRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE);
+    testRunner.assertTimelinesEqual(timeline);
     assertThat(renderer.formatReadCount).isEqualTo(0);
     assertThat(renderer.sampleBufferReadCount).isEqualTo(0);
     assertThat(renderer.isEnded).isFalse();
@@ -134,10 +128,8 @@ public void testPlaySinglePeriodTimeline() throws Exception {
             .start()
             .blockUntilEnded(TIMEOUT_MS);
     testRunner.assertNoPositionDiscontinuities();
-    testRunner.assertTimelinesSame(dummyTimeline, timeline);
-    testRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE);
+    testRunner.assertTimelinesEqual(timeline);
+    testRunner.assertTimelineChangeReasonsEqual(Player.TIMELINE_CHANGE_REASON_PREPARED);
     testRunner.assertTrackGroupsEqual(new TrackGroupArray(new TrackGroup(Builder.VIDEO_FORMAT)));
     assertThat(renderer.formatReadCount).isEqualTo(1);
     assertThat(renderer.sampleBufferReadCount).isEqualTo(1);
@@ -159,10 +151,8 @@ public void testPlayMultiPeriodTimeline() throws Exception {
     testRunner.assertPositionDiscontinuityReasonsEqual(
         Player.DISCONTINUITY_REASON_PERIOD_TRANSITION,
         Player.DISCONTINUITY_REASON_PERIOD_TRANSITION);
-    testRunner.assertTimelinesSame(dummyTimeline, timeline);
-    testRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE);
+    testRunner.assertTimelinesEqual(timeline);
+    testRunner.assertTimelineChangeReasonsEqual(Player.TIMELINE_CHANGE_REASON_PREPARED);
     assertThat(renderer.formatReadCount).isEqualTo(3);
     assertThat(renderer.sampleBufferReadCount).isEqualTo(3);
     assertThat(renderer.isEnded).isTrue();
@@ -185,10 +175,8 @@ public void testPlayShortDurationPeriods() throws Exception {
     Integer[] expectedReasons = new Integer[99];
     Arrays.fill(expectedReasons, Player.DISCONTINUITY_REASON_PERIOD_TRANSITION);
     testRunner.assertPositionDiscontinuityReasonsEqual(expectedReasons);
-    testRunner.assertTimelinesSame(dummyTimeline, timeline);
-    testRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE);
+    testRunner.assertTimelinesEqual(timeline);
+    testRunner.assertTimelineChangeReasonsEqual(Player.TIMELINE_CHANGE_REASON_PREPARED);
     assertThat(renderer.formatReadCount).isEqualTo(100);
     assertThat(renderer.sampleBufferReadCount).isEqualTo(100);
     assertThat(renderer.isEnded).isTrue();
@@ -260,17 +248,14 @@ public boolean isEnded() {
     testRunner.assertPositionDiscontinuityReasonsEqual(
         Player.DISCONTINUITY_REASON_PERIOD_TRANSITION,
         Player.DISCONTINUITY_REASON_PERIOD_TRANSITION);
-    testRunner.assertTimelinesSame(dummyTimeline, timeline);
-    testRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE);
+    testRunner.assertTimelinesEqual(timeline);
     assertThat(audioRenderer.positionResetCount).isEqualTo(1);
     assertThat(videoRenderer.isEnded).isTrue();
     assertThat(audioRenderer.isEnded).isTrue();
   }
 
   @Test
-  public void testResettingMediaItemsGivesFreshSourceInfo() throws Exception {
+  public void testRepreparationGivesFreshSourceInfo() throws Exception {
     FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
     Object firstSourceManifest = new Object();
     Timeline firstTimeline = new FakeTimeline(/* windowCount= */ 1, firstSourceManifest);
@@ -286,8 +271,8 @@ public synchronized void prepareSourceInternal(
               @Nullable TransferListener mediaTransferListener) {
             super.prepareSourceInternal(mediaTransferListener);
             // We've queued a source info refresh on the playback thread's event queue. Allow the
-            // test thread to set the third source to the playlist, and block this thread (the
-            // playback thread) until the test thread's call to setMediaItems() has returned.
+            // test thread to prepare the player with the third source, and block this thread (the
+            // playback thread) until the test thread's call to prepare() has returned.
             queuedSourceInfoCountDownLatch.countDown();
             try {
               completePreparationCountDownLatch.await();
@@ -302,13 +287,12 @@ public synchronized void prepareSourceInternal(
 
     // Prepare the player with a source with the first manifest and a non-empty timeline. Prepare
     // the player again with a source and a new manifest, which will never be exposed. Allow the
-    // test thread to set a third source, and block the playback thread until the test thread's call
-    // to setMediaItems() has returned.
+    // test thread to prepare the player with a third source, and block the playback thread until
+    // the test thread's call to prepare() has returned.
     ActionSchedule actionSchedule =
-        new ActionSchedule.Builder("testResettingMediaItemsGivesFreshSourceInfo")
-            .waitForTimelineChanged(
-                firstTimeline, /* expectedReason */ Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE)
-            .setMediaItems(secondSource)
+        new ActionSchedule.Builder("testRepreparation")
+            .waitForTimelineChanged(firstTimeline)
+            .prepareSource(secondSource)
             .executeRunnable(
                 () -> {
                   try {
@@ -317,32 +301,26 @@ public synchronized void prepareSourceInternal(
                     // Ignore.
                   }
                 })
-            .setMediaItems(thirdSource)
+            .prepareSource(thirdSource)
             .executeRunnable(completePreparationCountDownLatch::countDown)
-            .waitForPlaybackState(Player.STATE_READY)
             .build();
     ExoPlayerTestRunner testRunner =
         new Builder()
-            .setMediaSources(firstSource)
+            .setMediaSource(firstSource)
             .setRenderers(renderer)
             .setActionSchedule(actionSchedule)
             .build(context)
             .start()
-            .blockUntilActionScheduleFinished(TIMEOUT_MS)
             .blockUntilEnded(TIMEOUT_MS);
     testRunner.assertNoPositionDiscontinuities();
-    // The first source's preparation completed with a real timeline. When the second source was
-    // prepared, it immediately exposed a dummy timeline, but the source info refresh from the
-    // second source was suppressed as we replace it with the third source before the update
-    // arrives.
-    testRunner.assertTimelinesSame(
-        dummyTimeline, firstTimeline, dummyTimeline, dummyTimeline, thirdTimeline);
+    // The first source's preparation completed with a non-empty timeline. When the player was
+    // re-prepared with the second source, it immediately exposed an empty timeline, but the source
+    // info refresh from the second source was suppressed as we re-prepared with the third source.
+    testRunner.assertTimelinesEqual(firstTimeline, Timeline.EMPTY, thirdTimeline);
     testRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE,
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE);
+        Player.TIMELINE_CHANGE_REASON_PREPARED,
+        Player.TIMELINE_CHANGE_REASON_RESET,
+        Player.TIMELINE_CHANGE_REASON_PREPARED);
     testRunner.assertTrackGroupsEqual(new TrackGroupArray(new TrackGroup(Builder.VIDEO_FORMAT)));
     assertThat(renderer.isEnded).isTrue();
   }
@@ -354,8 +332,7 @@ public void testRepeatModeChanges() throws Exception {
     ActionSchedule actionSchedule =
         new ActionSchedule.Builder("testRepeatMode")
             .pause()
-            .waitForTimelineChanged(
-                timeline, /* expectedReason */ Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE)
+            .waitForTimelineChanged(timeline)
             .playUntilStartOfWindow(/* windowIndex= */ 1)
             .setRepeatMode(Player.REPEAT_MODE_ONE)
             .playUntilStartOfWindow(/* windowIndex= */ 1)
@@ -390,10 +367,8 @@ public void testRepeatModeChanges() throws Exception {
         Player.DISCONTINUITY_REASON_PERIOD_TRANSITION,
         Player.DISCONTINUITY_REASON_PERIOD_TRANSITION,
         Player.DISCONTINUITY_REASON_PERIOD_TRANSITION);
-    testRunner.assertTimelinesSame(dummyTimeline, timeline);
-    testRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE);
+    testRunner.assertTimelinesEqual(timeline);
+    testRunner.assertTimelineChangeReasonsEqual(Player.TIMELINE_CHANGE_REASON_PREPARED);
     assertThat(renderer.isEnded).isTrue();
   }
 
@@ -422,7 +397,7 @@ public void testShuffleModeEnabledChanges() throws Exception {
             .build();
     ExoPlayerTestRunner testRunner =
         new ExoPlayerTestRunner.Builder()
-            .setMediaSources(mediaSource)
+            .setMediaSource(mediaSource)
             .setRenderers(renderer)
             .setActionSchedule(actionSchedule)
             .build(context)
@@ -468,13 +443,12 @@ public void testAdGroupWithLoadErrorIsSkipped() throws Exception {
             .pause()
             .waitForPlaybackState(Player.STATE_READY)
             .executeRunnable(() -> fakeMediaSource.setNewSourceInfo(adErrorTimeline, null))
-            .waitForTimelineChanged(
-                adErrorTimeline, /* expectedReason */ Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE)
+            .waitForTimelineChanged(adErrorTimeline)
             .play()
             .build();
     ExoPlayerTestRunner testRunner =
         new ExoPlayerTestRunner.Builder()
-            .setMediaSources(fakeMediaSource)
+            .setMediaSource(fakeMediaSource)
             .setActionSchedule(actionSchedule)
             .build(context)
             .start()
@@ -569,31 +543,26 @@ public void onSeekProcessed() {
   }
 
   @Test
-  public void testIllegalSeekPositionDoesThrow() throws Exception {
-    final IllegalSeekPositionException[] exception = new IllegalSeekPositionException[1];
+  public void testSeekProcessedCalledWithIllegalSeekPosition() throws Exception {
     ActionSchedule actionSchedule =
-        new ActionSchedule.Builder("testIllegalSeekPositionDoesThrow")
+        new ActionSchedule.Builder("testSeekProcessedCalledWithIllegalSeekPosition")
             .waitForPlaybackState(Player.STATE_BUFFERING)
-            .executeRunnable(
-                new PlayerRunnable() {
-                  @Override
-                  public void run(SimpleExoPlayer player) {
-                    try {
-                      player.seekTo(/* windowIndex= */ 100, /* positionMs= */ 0);
-                    } catch (IllegalSeekPositionException e) {
-                      exception[0] = e;
-                    }
-                  }
-                })
+            // The illegal seek position will end playback.
+            .seek(/* windowIndex= */ 100, /* positionMs= */ 0)
             .waitForPlaybackState(Player.STATE_ENDED)
             .build();
-    new Builder()
-        .setActionSchedule(actionSchedule)
-        .build(context)
-        .start()
-        .blockUntilActionScheduleFinished(TIMEOUT_MS)
-        .blockUntilEnded(TIMEOUT_MS);
-    assertThat(exception[0]).isNotNull();
+    final boolean[] onSeekProcessedCalled = new boolean[1];
+    EventListener listener =
+        new EventListener() {
+          @Override
+          public void onSeekProcessed() {
+            onSeekProcessedCalled[0] = true;
+          }
+        };
+    ExoPlayerTestRunner testRunner =
+        new Builder().setActionSchedule(actionSchedule).setEventListener(listener).build(context);
+    testRunner.start().blockUntilActionScheduleFinished(TIMEOUT_MS).blockUntilEnded(TIMEOUT_MS);
+    assertThat(onSeekProcessedCalled[0]).isTrue();
   }
 
   @Test
@@ -637,7 +606,7 @@ protected FakeMediaPeriod createFakeMediaPeriod(
             .build();
     ExoPlayerTestRunner testRunner =
         new ExoPlayerTestRunner.Builder()
-            .setMediaSources(mediaSource)
+            .setMediaSource(mediaSource)
             .setActionSchedule(actionSchedule)
             .build(context)
             .start()
@@ -665,7 +634,7 @@ protected FakeMediaPeriod createFakeMediaPeriod(
         };
     ExoPlayerTestRunner testRunner =
         new ExoPlayerTestRunner.Builder()
-            .setMediaSources(mediaSource)
+            .setMediaSource(mediaSource)
             .build(context)
             .start()
             .blockUntilEnded(TIMEOUT_MS);
@@ -691,7 +660,7 @@ protected FakeMediaPeriod createFakeMediaPeriod(
         };
     ExoPlayerTestRunner testRunner =
         new ExoPlayerTestRunner.Builder()
-            .setMediaSources(mediaSource)
+            .setMediaSource(mediaSource)
             .build(context)
             .start()
             .blockUntilEnded(TIMEOUT_MS);
@@ -709,7 +678,7 @@ public void testAllActivatedTrackSelectionAreReleasedForSinglePeriod() throws Ex
     FakeTrackSelector trackSelector = new FakeTrackSelector();
 
     new Builder()
-        .setMediaSources(mediaSource)
+        .setMediaSource(mediaSource)
         .setRenderers(videoRenderer, audioRenderer)
         .setTrackSelector(trackSelector)
         .build(context)
@@ -738,7 +707,7 @@ public void testAllActivatedTrackSelectionAreReleasedForMultiPeriods() throws Ex
     FakeTrackSelector trackSelector = new FakeTrackSelector();
 
     new Builder()
-        .setMediaSources(mediaSource)
+        .setMediaSource(mediaSource)
         .setRenderers(videoRenderer, audioRenderer)
         .setTrackSelector(trackSelector)
         .build(context)
@@ -775,7 +744,7 @@ public void testAllActivatedTrackSelectionAreReleasedWhenTrackSelectionsAreRemad
             .build();
 
     new Builder()
-        .setMediaSources(mediaSource)
+        .setMediaSource(mediaSource)
         .setRenderers(videoRenderer, audioRenderer)
         .setTrackSelector(trackSelector)
         .setActionSchedule(disableTrackAction)
@@ -814,7 +783,7 @@ public void testAllActivatedTrackSelectionAreReleasedWhenTrackSelectionsAreReuse
             .build();
 
     new Builder()
-        .setMediaSources(mediaSource)
+        .setMediaSource(mediaSource)
         .setRenderers(videoRenderer, audioRenderer)
         .setTrackSelector(trackSelector)
         .setActionSchedule(disableTrackAction)
@@ -838,35 +807,31 @@ public void testAllActivatedTrackSelectionAreReleasedWhenTrackSelectionsAreReuse
 
   @Test
   public void testDynamicTimelineChangeReason() throws Exception {
-    Timeline timeline = new FakeTimeline(new TimelineWindowDefinition(false, false, 100000));
+    Timeline timeline1 = new FakeTimeline(new TimelineWindowDefinition(false, false, 100000));
     final Timeline timeline2 = new FakeTimeline(new TimelineWindowDefinition(false, false, 20000));
-    final FakeMediaSource mediaSource = new FakeMediaSource(timeline, Builder.VIDEO_FORMAT);
+    final FakeMediaSource mediaSource = new FakeMediaSource(timeline1, Builder.VIDEO_FORMAT);
     ActionSchedule actionSchedule =
         new ActionSchedule.Builder("testDynamicTimelineChangeReason")
             .pause()
-            .waitForTimelineChanged(
-                timeline, /* expectedReason */ Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE)
+            .waitForTimelineChanged(timeline1)
             .executeRunnable(() -> mediaSource.setNewSourceInfo(timeline2, null))
-            .waitForTimelineChanged(
-                timeline2, /* expectedReason */ Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE)
+            .waitForTimelineChanged(timeline2)
             .play()
             .build();
     ExoPlayerTestRunner testRunner =
         new ExoPlayerTestRunner.Builder()
-            .setMediaSources(mediaSource)
+            .setMediaSource(mediaSource)
             .setActionSchedule(actionSchedule)
             .build(context)
             .start()
             .blockUntilEnded(TIMEOUT_MS);
-    testRunner.assertTimelinesSame(dummyTimeline, timeline, timeline2);
+    testRunner.assertTimelinesEqual(timeline1, timeline2);
     testRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE);
+        Player.TIMELINE_CHANGE_REASON_PREPARED, Player.TIMELINE_CHANGE_REASON_DYNAMIC);
   }
 
   @Test
-  public void testResetMediaItemsWithPositionResetAndShufflingUsesFirstPeriod() throws Exception {
+  public void testRepreparationWithPositionResetAndShufflingUsesFirstPeriod() throws Exception {
     Timeline fakeTimeline =
         new FakeTimeline(
             new TimelineWindowDefinition(
@@ -889,19 +854,17 @@ public void testResetMediaItemsWithPositionResetAndShufflingUsesFirstPeriod() th
             .pause()
             .waitForPlaybackState(Player.STATE_READY)
             .setShuffleModeEnabled(true)
-            // Set the second media source (with position reset).
+            // Reprepare with second media source (keeping state, but with position reset).
             // Plays period 1 and 0 because of the reversed fake shuffle order.
-            .setMediaItems(/* resetPosition= */ true, secondMediaSource)
+            .prepareSource(secondMediaSource, /* resetPosition= */ true, /* resetState= */ false)
             .play()
-            .waitForPositionDiscontinuity()
             .build();
     ExoPlayerTestRunner testRunner =
         new ExoPlayerTestRunner.Builder()
-            .setMediaSources(firstMediaSource)
+            .setMediaSource(firstMediaSource)
             .setActionSchedule(actionSchedule)
             .build(context)
             .start()
-            .blockUntilActionScheduleFinished(TIMEOUT_MS)
             .blockUntilEnded(TIMEOUT_MS);
     testRunner.assertPlayedPeriodIndices(0, 1, 0);
   }
@@ -946,7 +909,7 @@ protected FakeMediaPeriod createFakeMediaPeriod(
             .executeRunnable(() -> fakeMediaPeriodHolder[0].setPreparationComplete())
             .build();
     new ExoPlayerTestRunner.Builder()
-        .setMediaSources(mediaSource)
+        .setMediaSource(mediaSource)
         .setActionSchedule(actionSchedule)
         .build(context)
         .start()
@@ -979,10 +942,8 @@ public void run(SimpleExoPlayer player) {
             .start()
             .blockUntilActionScheduleFinished(TIMEOUT_MS)
             .blockUntilEnded(TIMEOUT_MS);
-    testRunner.assertTimelinesSame(dummyTimeline, timeline);
-    testRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE);
+    testRunner.assertTimelinesEqual(timeline);
+    testRunner.assertTimelineChangeReasonsEqual(Player.TIMELINE_CHANGE_REASON_PREPARED);
     testRunner.assertNoPositionDiscontinuities();
     assertThat(positionHolder[0]).isAtLeast(50L);
   }
@@ -1013,10 +974,8 @@ public void run(SimpleExoPlayer player) {
             .start()
             .blockUntilActionScheduleFinished(TIMEOUT_MS)
             .blockUntilEnded(TIMEOUT_MS);
-    testRunner.assertTimelinesSame(dummyTimeline, timeline);
-    testRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE);
+    testRunner.assertTimelinesEqual(timeline);
+    testRunner.assertTimelineChangeReasonsEqual(Player.TIMELINE_CHANGE_REASON_PREPARED);
     testRunner.assertNoPositionDiscontinuities();
     assertThat(positionHolder[0]).isAtLeast(50L);
   }
@@ -1047,11 +1006,9 @@ public void run(SimpleExoPlayer player) {
             .start()
             .blockUntilActionScheduleFinished(TIMEOUT_MS)
             .blockUntilEnded(TIMEOUT_MS);
-    testRunner.assertTimelinesSame(dummyTimeline, timeline, Timeline.EMPTY);
+    testRunner.assertTimelinesEqual(timeline, Timeline.EMPTY);
     testRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE,
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED);
+        Player.TIMELINE_CHANGE_REASON_PREPARED, Player.TIMELINE_CHANGE_REASON_RESET);
     testRunner.assertNoPositionDiscontinuities();
     assertThat(positionHolder[0]).isEqualTo(0);
   }
@@ -1097,29 +1054,15 @@ public void testStopWithResetReleasesMediaSource() throws Exception {
   }
 
   @Test
-  public void testSettingNewStartPositionPossibleAfterStopWithReset() throws Exception {
+  public void testRepreparationDoesNotResetAfterStopWithReset() throws Exception {
     Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
-    Timeline secondTimeline = new FakeTimeline(/* windowCount= */ 2);
-    MediaSource secondSource = new FakeMediaSource(secondTimeline, Builder.VIDEO_FORMAT);
-    AtomicInteger windowIndexAfterStop = new AtomicInteger();
-    AtomicLong positionAfterStop = new AtomicLong();
+    MediaSource secondSource = new FakeMediaSource(timeline, Builder.VIDEO_FORMAT);
     ActionSchedule actionSchedule =
-        new ActionSchedule.Builder("testSettingNewStartPositionPossibleAfterStopWithReset")
+        new ActionSchedule.Builder("testRepreparationAfterStop")
             .waitForPlaybackState(Player.STATE_READY)
             .stop(/* reset= */ true)
             .waitForPlaybackState(Player.STATE_IDLE)
-            .seek(/* windowIndex= */ 1, /* positionMs= */ 1000)
-            .setMediaItems(secondSource)
-            .prepare()
-            .executeRunnable(
-                new PlayerRunnable() {
-                  @Override
-                  public void run(SimpleExoPlayer player) {
-                    windowIndexAfterStop.set(player.getCurrentWindowIndex());
-                    positionAfterStop.set(player.getCurrentPosition());
-                  }
-                })
-            .waitForPlaybackState(Player.STATE_READY)
+            .prepareSource(secondSource)
             .build();
     ExoPlayerTestRunner testRunner =
         new ExoPlayerTestRunner.Builder()
@@ -1129,95 +1072,62 @@ public void run(SimpleExoPlayer player) {
             .build(context)
             .start()
             .blockUntilEnded(TIMEOUT_MS);
-    testRunner.assertTimelinesSame(
-        dummyTimeline, timeline, Timeline.EMPTY, dummyTimeline, secondTimeline);
+    testRunner.assertTimelinesEqual(timeline, Timeline.EMPTY, timeline);
     testRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE,
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED, // stop(true)
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE);
-    assertThat(windowIndexAfterStop.get()).isEqualTo(1);
-    assertThat(positionAfterStop.get()).isAtLeast(1000L);
-    testRunner.assertPlayedPeriodIndices(0, 1);
+        Player.TIMELINE_CHANGE_REASON_PREPARED,
+        Player.TIMELINE_CHANGE_REASON_RESET,
+        Player.TIMELINE_CHANGE_REASON_PREPARED);
+    testRunner.assertNoPositionDiscontinuities();
   }
 
   @Test
-  public void testResetPlaylistWithPreviousPosition() throws Exception {
-    Object firstWindowId = new Object();
-    Timeline timeline =
-        new FakeTimeline(
-            new TimelineWindowDefinition(/* periodCount= */ 1, /* id= */ firstWindowId));
-    Timeline firstExpectedMaskingTimeline =
-        new MaskingMediaSource.DummyTimeline(/* tag= */ firstWindowId);
-    Object secondWindowId = new Object();
-    Timeline secondTimeline =
-        new FakeTimeline(
-            new TimelineWindowDefinition(/* periodCount= */ 1, /* id= */ secondWindowId));
-    Timeline secondExpectedMaskingTimeline =
-        new MaskingMediaSource.DummyTimeline(/* tag= */ secondWindowId);
-    MediaSource secondSource = new FakeMediaSource(secondTimeline);
-    AtomicLong positionAfterReprepare = new AtomicLong();
+  public void testSeekBeforeRepreparationPossibleAfterStopWithReset() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    Timeline secondTimeline = new FakeTimeline(/* windowCount= */ 2);
+    MediaSource secondSource = new FakeMediaSource(secondTimeline, Builder.VIDEO_FORMAT);
     ActionSchedule actionSchedule =
-        new ActionSchedule.Builder("testResetPlaylistWithPreviousPosition")
-            .pause()
+        new ActionSchedule.Builder("testSeekAfterStopWithReset")
             .waitForPlaybackState(Player.STATE_READY)
-            .playUntilPosition(/* windowIndex= */ 0, /* positionMs= */ 2000)
-            .setMediaItems(/* windowIndex= */ 0, /* positionMs= */ 2000, secondSource)
-            .waitForTimelineChanged(
-                secondTimeline, /* expectedReason */ Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE)
-            .executeRunnable(
-                new PlayerRunnable() {
-                  @Override
-                  public void run(SimpleExoPlayer player) {
-                    positionAfterReprepare.set(player.getCurrentPosition());
-                  }
-                })
-            .play()
+            .stop(/* reset= */ true)
+            .waitForPlaybackState(Player.STATE_IDLE)
+            // If we were still using the first timeline, this would throw.
+            .seek(/* windowIndex= */ 1, /* positionMs= */ 0)
+            .prepareSource(secondSource, /* resetPosition= */ false, /* resetState= */ true)
             .build();
     ExoPlayerTestRunner testRunner =
         new ExoPlayerTestRunner.Builder()
             .setTimeline(timeline)
             .setActionSchedule(actionSchedule)
+            .setExpectedPlayerEndedCount(2)
             .build(context)
             .start()
-            .blockUntilActionScheduleFinished(TIMEOUT_MS)
             .blockUntilEnded(TIMEOUT_MS);
-
-    testRunner.assertTimelinesSame(
-        firstExpectedMaskingTimeline, timeline, secondExpectedMaskingTimeline, secondTimeline);
+    testRunner.assertTimelinesEqual(timeline, Timeline.EMPTY, secondTimeline);
     testRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE,
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE);
-    assertThat(positionAfterReprepare.get()).isAtLeast(2000L);
+        Player.TIMELINE_CHANGE_REASON_PREPARED,
+        Player.TIMELINE_CHANGE_REASON_RESET,
+        Player.TIMELINE_CHANGE_REASON_PREPARED);
+    testRunner.assertPositionDiscontinuityReasonsEqual(Player.DISCONTINUITY_REASON_SEEK);
+    testRunner.assertPlayedPeriodIndices(0, 1);
   }
 
   @Test
-  public void testResetPlaylistStartsFromDefaultPosition() throws Exception {
-    Object firstWindowId = new Object();
+  public void testReprepareAndKeepPositionWithNewMediaSource() throws Exception {
     Timeline timeline =
         new FakeTimeline(
-            new TimelineWindowDefinition(/* periodCount= */ 1, /* id= */ firstWindowId));
-    Timeline firstExpectedDummyTimeline =
-        new MaskingMediaSource.DummyTimeline(/* tag= */ firstWindowId);
-    Object secondWindowId = new Object();
+            new TimelineWindowDefinition(/* periodCount= */ 1, /* id= */ new Object()));
     Timeline secondTimeline =
         new FakeTimeline(
-            new TimelineWindowDefinition(/* periodCount= */ 1, /* id= */ secondWindowId));
-    Timeline secondExpectedDummyTimeline =
-        new MaskingMediaSource.DummyTimeline(/* tag= */ secondWindowId);
+            new TimelineWindowDefinition(/* periodCount= */ 1, /* id= */ new Object()));
     MediaSource secondSource = new FakeMediaSource(secondTimeline);
     AtomicLong positionAfterReprepare = new AtomicLong();
     ActionSchedule actionSchedule =
-        new ActionSchedule.Builder("testResetPlaylistStartsFromDefaultPosition")
+        new ActionSchedule.Builder("testReprepareAndKeepPositionWithNewMediaSource")
             .pause()
             .waitForPlaybackState(Player.STATE_READY)
             .playUntilPosition(/* windowIndex= */ 0, /* positionMs= */ 2000)
-            .setMediaItems(secondSource)
-            .waitForTimelineChanged(
-                secondTimeline, /* expectedReason */ Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE)
+            .prepareSource(secondSource, /* resetPosition= */ false, /* resetState= */ true)
+            .waitForTimelineChanged(secondTimeline)
             .executeRunnable(
                 new PlayerRunnable() {
                   @Override
@@ -1236,14 +1146,8 @@ public void run(SimpleExoPlayer player) {
             .blockUntilActionScheduleFinished(TIMEOUT_MS)
             .blockUntilEnded(TIMEOUT_MS);
 
-    testRunner.assertTimelinesSame(
-        firstExpectedDummyTimeline, timeline, secondExpectedDummyTimeline, secondTimeline);
-    testRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE,
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE);
-    assertThat(positionAfterReprepare.get()).isEqualTo(0L);
+    testRunner.assertTimelinesEqual(timeline, Timeline.EMPTY, secondTimeline);
+    assertThat(positionAfterReprepare.get()).isAtLeast(2000L);
   }
 
   @Test
@@ -1264,10 +1168,8 @@ public void testStopDuringPreparationOverwritesPreparation() throws Exception {
             .start()
             .blockUntilActionScheduleFinished(TIMEOUT_MS)
             .blockUntilEnded(TIMEOUT_MS);
-    testRunner.assertTimelinesSame(dummyTimeline, Timeline.EMPTY);
-    testRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED);
+    testRunner.assertTimelinesEqual(Timeline.EMPTY);
+    testRunner.assertTimelineChangeReasonsEqual(Player.TIMELINE_CHANGE_REASON_PREPARED);
     testRunner.assertPositionDiscontinuityReasonsEqual(Player.DISCONTINUITY_REASON_SEEK);
   }
 
@@ -1292,10 +1194,8 @@ public void testStopAndSeekAfterStopDoesNotResetTimeline() throws Exception {
             .start()
             .blockUntilActionScheduleFinished(TIMEOUT_MS)
             .blockUntilEnded(TIMEOUT_MS);
-    testRunner.assertTimelinesSame(dummyTimeline, timeline);
-    testRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE);
+    testRunner.assertTimelinesEqual(timeline);
+    testRunner.assertTimelineChangeReasonsEqual(Player.TIMELINE_CHANGE_REASON_PREPARED);
     testRunner.assertPositionDiscontinuityReasonsEqual(Player.DISCONTINUITY_REASON_SEEK);
   }
 
@@ -1307,7 +1207,8 @@ public void testReprepareAfterPlaybackError() throws Exception {
             .waitForPlaybackState(Player.STATE_READY)
             .throwPlaybackException(ExoPlaybackException.createForSource(new IOException()))
             .waitForPlaybackState(Player.STATE_IDLE)
-            .prepare()
+            .prepareSource(
+                new FakeMediaSource(timeline), /* resetPosition= */ true, /* resetState= */ false)
             .waitForPlaybackState(Player.STATE_READY)
             .build();
     ExoPlayerTestRunner testRunner =
@@ -1321,10 +1222,9 @@ public void testReprepareAfterPlaybackError() throws Exception {
     } catch (ExoPlaybackException e) {
       // Expected exception.
     }
-    testRunner.assertTimelinesSame(dummyTimeline, timeline);
+    testRunner.assertTimelinesEqual(timeline, timeline);
     testRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE);
+        Player.TIMELINE_CHANGE_REASON_PREPARED, Player.TIMELINE_CHANGE_REASON_PREPARED);
   }
 
   @Test
@@ -1346,7 +1246,8 @@ public void run(SimpleExoPlayer player) {
                     positionHolder[0] = player.getCurrentPosition();
                   }
                 })
-            .prepare()
+            .prepareSource(
+                new FakeMediaSource(timeline), /* resetPosition= */ false, /* resetState= */ false)
             .waitForPlaybackState(Player.STATE_READY)
             .executeRunnable(
                 new PlayerRunnable() {
@@ -1368,29 +1269,52 @@ public void run(SimpleExoPlayer player) {
     } catch (ExoPlaybackException e) {
       // Expected exception.
     }
-    testRunner.assertTimelinesSame(dummyTimeline, timeline);
+    testRunner.assertTimelinesEqual(timeline, timeline);
     testRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE);
+        Player.TIMELINE_CHANGE_REASON_PREPARED, Player.TIMELINE_CHANGE_REASON_PREPARED);
     testRunner.assertPositionDiscontinuityReasonsEqual(Player.DISCONTINUITY_REASON_SEEK);
     assertThat(positionHolder[0]).isEqualTo(50);
     assertThat(positionHolder[1]).isEqualTo(50);
   }
 
+  @Test
+  public void testInvalidSeekPositionAfterSourceInfoRefreshStillUpdatesTimeline() throws Exception {
+    final Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    final FakeMediaSource mediaSource = new FakeMediaSource(/* timeline= */ null);
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testInvalidSeekPositionSourceInfoRefreshStillUpdatesTimeline")
+            .waitForPlaybackState(Player.STATE_BUFFERING)
+            // Seeking to an invalid position will end playback.
+            .seek(/* windowIndex= */ 100, /* positionMs= */ 0)
+            .executeRunnable(() -> mediaSource.setNewSourceInfo(timeline, /* newManifest= */ null))
+            .waitForPlaybackState(Player.STATE_ENDED)
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setMediaSource(mediaSource)
+            .setActionSchedule(actionSchedule)
+            .build(context);
+    testRunner.start().blockUntilActionScheduleFinished(TIMEOUT_MS).blockUntilEnded(TIMEOUT_MS);
+
+    testRunner.assertTimelinesEqual(timeline);
+    testRunner.assertTimelineChangeReasonsEqual(Player.TIMELINE_CHANGE_REASON_PREPARED);
+  }
+
   @Test
   public void
       testInvalidSeekPositionAfterSourceInfoRefreshWithShuffleModeEnabledUsesCorrectFirstPeriod()
           throws Exception {
-    FakeMediaSource mediaSource = new FakeMediaSource(new FakeTimeline(/* windowCount= */ 2));
+    FakeMediaSource mediaSource = new FakeMediaSource(new FakeTimeline(/* windowCount= */ 1));
+    ConcatenatingMediaSource concatenatingMediaSource =
+        new ConcatenatingMediaSource(
+            /* isAtomic= */ false, new FakeShuffleOrder(0), mediaSource, mediaSource);
     AtomicInteger windowIndexAfterUpdate = new AtomicInteger();
     ActionSchedule actionSchedule =
         new ActionSchedule.Builder("testInvalidSeekPositionSourceInfoRefreshUsesCorrectFirstPeriod")
-            .setShuffleOrder(new FakeShuffleOrder(/* length= */ 0))
             .setShuffleModeEnabled(true)
             .waitForPlaybackState(Player.STATE_BUFFERING)
             // Seeking to an invalid position will end playback.
-            .seek(
-                /* windowIndex= */ 100, /* positionMs= */ 0, /* catchIllegalSeekException= */ true)
+            .seek(/* windowIndex= */ 100, /* positionMs= */ 0)
             .waitForPlaybackState(Player.STATE_ENDED)
             .executeRunnable(
                 new PlayerRunnable() {
@@ -1400,13 +1324,12 @@ public void run(SimpleExoPlayer player) {
                   }
                 })
             .build();
-    new ExoPlayerTestRunner.Builder()
-        .setMediaSources(mediaSource)
-        .setActionSchedule(actionSchedule)
-        .build(context)
-        .start()
-        .blockUntilActionScheduleFinished(TIMEOUT_MS)
-        .blockUntilEnded(TIMEOUT_MS);
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setMediaSource(concatenatingMediaSource)
+            .setActionSchedule(actionSchedule)
+            .build(context);
+    testRunner.start().blockUntilActionScheduleFinished(TIMEOUT_MS).blockUntilEnded(TIMEOUT_MS);
 
     assertThat(windowIndexAfterUpdate.get()).isEqualTo(1);
   }
@@ -1440,7 +1363,7 @@ public void run(SimpleExoPlayer player) {
                 })
             .build();
     new ExoPlayerTestRunner.Builder()
-        .setMediaSources(concatenatingMediaSource)
+        .setMediaSource(concatenatingMediaSource)
         .setActionSchedule(actionSchedule)
         .build(context)
         .start()
@@ -1454,7 +1377,7 @@ public void testPlaybackErrorAndReprepareDoesNotResetPosition() throws Exception
     final Timeline timeline = new FakeTimeline(/* windowCount= */ 2);
     final long[] positionHolder = new long[3];
     final int[] windowIndexHolder = new int[3];
-    final FakeMediaSource firstMediaSource = new FakeMediaSource(timeline);
+    final FakeMediaSource secondMediaSource = new FakeMediaSource(/* timeline= */ null);
     ActionSchedule actionSchedule =
         new ActionSchedule.Builder("testPlaybackErrorDoesNotResetPosition")
             .pause()
@@ -1471,7 +1394,8 @@ public void run(SimpleExoPlayer player) {
                     windowIndexHolder[0] = player.getCurrentWindowIndex();
                   }
                 })
-            .prepare()
+            .prepareSource(secondMediaSource, /* resetPosition= */ false, /* resetState= */ false)
+            .waitForPlaybackState(Player.STATE_BUFFERING)
             .executeRunnable(
                 new PlayerRunnable() {
                   @Override
@@ -1479,6 +1403,7 @@ public void run(SimpleExoPlayer player) {
                     // Position while repreparing.
                     positionHolder[1] = player.getCurrentPosition();
                     windowIndexHolder[1] = player.getCurrentWindowIndex();
+                    secondMediaSource.setNewSourceInfo(timeline, /* newManifest= */ null);
                   }
                 })
             .waitForPlaybackState(Player.STATE_READY)
@@ -1495,7 +1420,7 @@ public void run(SimpleExoPlayer player) {
             .build();
     ExoPlayerTestRunner testRunner =
         new ExoPlayerTestRunner.Builder()
-            .setMediaSources(firstMediaSource)
+            .setTimeline(timeline)
             .setActionSchedule(actionSchedule)
             .build(context);
     try {
@@ -1522,8 +1447,7 @@ public void playbackErrorAndReprepareWithPositionResetKeepsWindowSequenceNumber(
             .waitForPlaybackState(Player.STATE_READY)
             .throwPlaybackException(ExoPlaybackException.createForSource(new IOException()))
             .waitForPlaybackState(Player.STATE_IDLE)
-            .seek(0, C.TIME_UNSET)
-            .prepare()
+            .prepareSource(mediaSource, /* resetPosition= */ true, /* resetState= */ false)
             .waitForPlaybackState(Player.STATE_READY)
             .play()
             .build();
@@ -1540,7 +1464,7 @@ public void onPlayerStateChanged(
         };
     ExoPlayerTestRunner testRunner =
         new ExoPlayerTestRunner.Builder()
-            .setMediaSources(mediaSource)
+            .setMediaSource(mediaSource)
             .setActionSchedule(actionSchedule)
             .setAnalyticsListener(listener)
             .build(context);
@@ -1556,15 +1480,14 @@ public void onPlayerStateChanged(
   @Test
   public void testPlaybackErrorTwiceStillKeepsTimeline() throws Exception {
     final Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
-    final FakeMediaSource mediaSource2 = new FakeMediaSource(timeline);
+    final FakeMediaSource mediaSource2 = new FakeMediaSource(/* timeline= */ null);
     ActionSchedule actionSchedule =
         new ActionSchedule.Builder("testPlaybackErrorDoesNotResetPosition")
             .pause()
             .waitForPlaybackState(Player.STATE_READY)
             .throwPlaybackException(ExoPlaybackException.createForSource(new IOException()))
             .waitForPlaybackState(Player.STATE_IDLE)
-            .setMediaItems(/* resetPosition= */ false, mediaSource2)
-            .prepare()
+            .prepareSource(mediaSource2, /* resetPosition= */ false, /* resetState= */ false)
             .waitForPlaybackState(Player.STATE_BUFFERING)
             .throwPlaybackException(ExoPlaybackException.createForSource(new IOException()))
             .waitForPlaybackState(Player.STATE_IDLE)
@@ -1580,12 +1503,9 @@ public void testPlaybackErrorTwiceStillKeepsTimeline() throws Exception {
     } catch (ExoPlaybackException e) {
       // Expected exception.
     }
-    testRunner.assertTimelinesSame(dummyTimeline, timeline, dummyTimeline, timeline);
+    testRunner.assertTimelinesEqual(timeline, timeline);
     testRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE,
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE);
+        Player.TIMELINE_CHANGE_REASON_PREPARED, Player.TIMELINE_CHANGE_REASON_PREPARED);
   }
 
   @Test
@@ -1615,8 +1535,7 @@ public void testSendMessagesAfterPreparation() throws Exception {
     ActionSchedule actionSchedule =
         new ActionSchedule.Builder("testSendMessages")
             .pause()
-            .waitForTimelineChanged(
-                timeline, /* expectedReason */ Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE)
+            .waitForTimelineChanged(timeline)
             .sendMessage(target, /* positionMs= */ 50)
             .play()
             .build();
@@ -1710,12 +1629,17 @@ public void testSendMessagesAtStartAndEndOfPeriod() throws Exception {
         new ActionSchedule.Builder("testSendMessages")
             .pause()
             .waitForPlaybackState(Player.STATE_BUFFERING)
-            .waitForTimelineChanged(timeline, Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE)
             .sendMessage(targetStartFirstPeriod, /* windowIndex= */ 0, /* positionMs= */ 0)
             .sendMessage(targetEndMiddlePeriod, /* windowIndex= */ 0, /* positionMs= */ duration1Ms)
             .sendMessage(targetStartMiddlePeriod, /* windowIndex= */ 1, /* positionMs= */ 0)
             .sendMessage(targetEndLastPeriod, /* windowIndex= */ 1, /* positionMs= */ duration2Ms)
             .play()
+            // Add additional prepare at end and wait until it's processed to ensure that
+            // messages sent at end of playback are received before test ends.
+            .waitForPlaybackState(Player.STATE_ENDED)
+            .prepareSource(
+                new FakeMediaSource(timeline), /* resetPosition= */ false, /* resetState= */ true)
+            .waitForPlaybackState(Player.STATE_BUFFERING)
             .waitForPlaybackState(Player.STATE_ENDED)
             .build();
     new Builder()
@@ -1762,8 +1686,7 @@ public void testSendMessagesSeekOnDeliveryTimeAfterPreparation() throws Exceptio
         new ActionSchedule.Builder("testSendMessages")
             .waitForPlaybackState(Player.STATE_BUFFERING)
             .sendMessage(target, /* positionMs= */ 50)
-            .waitForTimelineChanged(
-                timeline, /* expectedReason */ Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE)
+            .waitForTimelineChanged(timeline)
             .seek(/* positionMs= */ 50)
             .build();
     new Builder()
@@ -1804,8 +1727,7 @@ public void testSendMessagesSeekAfterDeliveryTimeAfterPreparation() throws Excep
         new ActionSchedule.Builder("testSendMessages")
             .pause()
             .sendMessage(target, /* positionMs= */ 50)
-            .waitForTimelineChanged(
-                timeline, /* expectedReason */ Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE)
+            .waitForTimelineChanged(timeline)
             .seek(/* positionMs= */ 51)
             .play()
             .build();
@@ -1884,16 +1806,14 @@ public void testSendMessagesMoveCurrentWindowIndex() throws Exception {
     ActionSchedule actionSchedule =
         new ActionSchedule.Builder("testSendMessages")
             .pause()
-            .waitForTimelineChanged(
-                timeline, /* expectedReason */ Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE)
+            .waitForTimelineChanged(timeline)
             .sendMessage(target, /* positionMs= */ 50)
             .executeRunnable(() -> mediaSource.setNewSourceInfo(secondTimeline, null))
-            .waitForTimelineChanged(
-                secondTimeline, /* expectedReason */ Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE)
+            .waitForTimelineChanged(secondTimeline)
             .play()
             .build();
     new Builder()
-        .setMediaSources(mediaSource)
+        .setMediaSource(mediaSource)
         .setActionSchedule(actionSchedule)
         .build(context)
         .start()
@@ -1909,7 +1829,7 @@ public void testSendMessagesMultiWindowDuringPreparation() throws Exception {
     ActionSchedule actionSchedule =
         new ActionSchedule.Builder("testSendMessages")
             .pause()
-            .waitForTimelineChanged(timeline, Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE)
+            .waitForPlaybackState(Player.STATE_BUFFERING)
             .sendMessage(target, /* windowIndex = */ 2, /* positionMs= */ 50)
             .play()
             .build();
@@ -1930,8 +1850,7 @@ public void testSendMessagesMultiWindowAfterPreparation() throws Exception {
     ActionSchedule actionSchedule =
         new ActionSchedule.Builder("testSendMessages")
             .pause()
-            .waitForTimelineChanged(
-                timeline, /* expectedReason */ Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE)
+            .waitForTimelineChanged(timeline)
             .sendMessage(target, /* windowIndex = */ 2, /* positionMs= */ 50)
             .play()
             .build();
@@ -1960,17 +1879,15 @@ public void testSendMessagesMoveWindowIndex() throws Exception {
     ActionSchedule actionSchedule =
         new ActionSchedule.Builder("testSendMessages")
             .pause()
-            .waitForTimelineChanged(
-                timeline, /* expectedReason */ Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE)
+            .waitForTimelineChanged(timeline)
             .sendMessage(target, /* windowIndex = */ 1, /* positionMs= */ 50)
             .executeRunnable(() -> mediaSource.setNewSourceInfo(secondTimeline, null))
-            .waitForTimelineChanged(
-                secondTimeline, /* expectedReason */ Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE)
+            .waitForTimelineChanged(secondTimeline)
             .seek(/* windowIndex= */ 0, /* positionMs= */ 0)
             .play()
             .build();
     new Builder()
-        .setMediaSources(mediaSource)
+        .setMediaSource(mediaSource)
         .setActionSchedule(actionSchedule)
         .build(context)
         .start()
@@ -2004,7 +1921,7 @@ public void testSendMessagesNonLinearPeriodOrder() throws Exception {
             .play()
             .build();
     new ExoPlayerTestRunner.Builder()
-        .setMediaSources(mediaSource)
+        .setMediaSource(mediaSource)
         .setActionSchedule(actionSchedule)
         .build(context)
         .start()
@@ -2142,21 +2059,16 @@ public void testTimelineUpdateDropsPrebufferedPeriods() throws Exception {
                 /* windowIndex= */ 0,
                 /* positionMs= */ C.usToMs(TimelineWindowDefinition.DEFAULT_WINDOW_DURATION_US))
             .executeRunnable(() -> mediaSource.setNewSourceInfo(timeline2, /* newManifest= */ null))
-            .waitForTimelineChanged(
-                timeline2, /* expectedReason */ Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE)
+            .waitForTimelineChanged(timeline2)
             .play()
             .build();
     ExoPlayerTestRunner testRunner =
         new ExoPlayerTestRunner.Builder()
-            .setMediaSources(mediaSource)
+            .setMediaSource(mediaSource)
             .setActionSchedule(actionSchedule)
             .build(context)
             .start()
             .blockUntilEnded(TIMEOUT_MS);
-    testRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE);
     testRunner.assertPlayedPeriodIndices(0, 1);
     // Assert that the second period was re-created from the new timeline.
     assertThat(mediaSource.getCreatedMediaPeriods()).hasSize(3);
@@ -2198,7 +2110,7 @@ public void testRepeatedSeeksToUnpreparedPeriodInSameWindowKeepsWindowSequenceNu
             .build();
     ExoPlayerTestRunner testRunner =
         new ExoPlayerTestRunner.Builder()
-            .setMediaSources(mediaSource)
+            .setMediaSource(mediaSource)
             .setActionSchedule(actionSchedule)
             .build(context)
             .start()
@@ -2316,56 +2228,6 @@ public void run(SimpleExoPlayer player) {
     assertThat(eventListenerPlayWhenReady).containsExactly(true, true, true, false).inOrder();
   }
 
-  @Test
-  public void testRecursiveTimelineChangeInStopAreReportedInCorrectOrder() throws Exception {
-    Timeline firstTimeline = new FakeTimeline(/* windowCount= */ 2);
-    Timeline secondTimeline = new FakeTimeline(/* windowCount= */ 3);
-    final AtomicReference<ExoPlayer> playerReference = new AtomicReference<>();
-    FakeMediaSource secondMediaSource = new FakeMediaSource(secondTimeline);
-    final EventListener eventListener =
-        new EventListener() {
-          @Override
-          public void onPlayerStateChanged(boolean playWhenReady, int state) {
-            if (state == Player.STATE_IDLE) {
-              playerReference.get().setMediaItem(secondMediaSource);
-            }
-          }
-        };
-    ActionSchedule actionSchedule =
-        new ActionSchedule.Builder("testRecursiveTimelineChangeInStopAreReportedInCorrectOrder")
-            .executeRunnable(
-                new PlayerRunnable() {
-                  @Override
-                  public void run(SimpleExoPlayer player) {
-                    playerReference.set(player);
-                    player.addListener(eventListener);
-                  }
-                })
-            .waitForTimelineChanged(firstTimeline, Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE)
-            // Ensure there are no further pending callbacks.
-            .delay(1)
-            .stop(/* reset= */ true)
-            .prepare()
-            .waitForTimelineChanged(secondTimeline, Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE)
-            .build();
-    ExoPlayerTestRunner exoPlayerTestRunner =
-        new Builder()
-            .setActionSchedule(actionSchedule)
-            .setTimeline(firstTimeline)
-            .build(context)
-            .start()
-            .blockUntilActionScheduleFinished(TIMEOUT_MS)
-            .blockUntilEnded(TIMEOUT_MS);
-    exoPlayerTestRunner.assertTimelinesSame(
-        dummyTimeline, firstTimeline, Timeline.EMPTY, dummyTimeline, secondTimeline);
-    exoPlayerTestRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE,
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE);
-  }
-
   @Test
   public void testClippedLoopedPeriodsArePlayedFully() throws Exception {
     long startPositionUs = 300_000;
@@ -2418,7 +2280,7 @@ public void run(SimpleExoPlayer player) {
             .build();
     new ExoPlayerTestRunner.Builder()
         .setClock(clock)
-        .setMediaSources(mediaSource)
+        .setMediaSource(mediaSource)
         .setActionSchedule(actionSchedule)
         .build(context)
         .start()
@@ -2452,7 +2314,7 @@ public void testUpdateTrackSelectorThenSeekToUnpreparedPeriod_returnsEmptyTrackG
     List<TrackGroupArray> trackGroupsList = new ArrayList<>();
     List<TrackSelectionArray> trackSelectionsList = new ArrayList<>();
     new Builder()
-        .setMediaSources(mediaSource)
+        .setMediaSource(mediaSource)
         .setSupportedFormats(Builder.VIDEO_FORMAT, Builder.AUDIO_FORMAT)
         .setActionSchedule(actionSchedule)
         .setEventListener(
@@ -2500,7 +2362,7 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
     FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
     ExoPlayerTestRunner testRunner =
         new Builder()
-            .setMediaSources(concatenatingMediaSource)
+            .setMediaSource(concatenatingMediaSource)
             .setRenderers(renderer)
             .build(context);
     try {
@@ -2543,7 +2405,49 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
     FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
     ExoPlayerTestRunner testRunner =
         new Builder()
-            .setMediaSources(concatenatingMediaSource)
+            .setMediaSource(concatenatingMediaSource)
+            .setActionSchedule(actionSchedule)
+            .setRenderers(renderer)
+            .build(context);
+    try {
+      testRunner.start().blockUntilEnded(TIMEOUT_MS);
+      fail();
+    } catch (ExoPlaybackException e) {
+      // Expected exception.
+    }
+    assertThat(renderer.sampleBufferReadCount).isAtLeast(1);
+    assertThat(renderer.hasReadStreamToEnd()).isTrue();
+  }
+
+  @Test
+  public void failingDynamicUpdateOnlyThrowsWhenAvailablePeriodHasBeenFullyRead() throws Exception {
+    Timeline fakeTimeline =
+        new FakeTimeline(
+            new TimelineWindowDefinition(
+                /* isSeekable= */ true,
+                /* isDynamic= */ true,
+                /* durationUs= */ 10 * C.MICROS_PER_SECOND));
+    AtomicReference<Boolean> wasReadyOnce = new AtomicReference<>(false);
+    MediaSource mediaSource =
+        new FakeMediaSource(fakeTimeline, Builder.VIDEO_FORMAT) {
+          @Override
+          public void maybeThrowSourceInfoRefreshError() throws IOException {
+            if (wasReadyOnce.get()) {
+              throw new IOException();
+            }
+          }
+        };
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testFailingDynamicMediaSourceInTimelineOnlyThrowsLater")
+            .pause()
+            .waitForPlaybackState(Player.STATE_READY)
+            .executeRunnable(() -> wasReadyOnce.set(true))
+            .play()
+            .build();
+    FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
+    ExoPlayerTestRunner testRunner =
+        new Builder()
+            .setMediaSource(mediaSource)
             .setActionSchedule(actionSchedule)
             .setRenderers(renderer)
             .build(context);
@@ -2577,7 +2481,7 @@ public void removingLoopingLastPeriodFromPlaylistDoesNotThrow() throws Exception
             .executeRunnable(concatenatingMediaSource::clear)
             .build();
     new Builder()
-        .setMediaSources(concatenatingMediaSource)
+        .setMediaSource(concatenatingMediaSource)
         .setActionSchedule(actionSchedule)
         .build(context)
         .start()
@@ -2601,7 +2505,7 @@ public void seekToUnpreparedWindowWithNonZeroOffsetInConcatenationStartsAtCorrec
             .pause()
             .waitForPlaybackState(Player.STATE_BUFFERING)
             .seek(/* positionMs= */ 10)
-            .waitForSeekProcessed()
+            .waitForTimelineChanged()
             .executeRunnable(() -> mediaSource.setNewSourceInfo(timeline, /* newManifest= */ null))
             .waitForTimelineChanged()
             .waitForPlaybackState(Player.STATE_READY)
@@ -2615,7 +2519,7 @@ public void run(SimpleExoPlayer player) {
             .play()
             .build();
     new Builder()
-        .setMediaSources(concatenatedMediaSource)
+        .setMediaSource(concatenatedMediaSource)
         .setActionSchedule(actionSchedule)
         .build(context)
         .start()
@@ -2646,7 +2550,7 @@ public void seekToUnpreparedWindowWithMultiplePeriodsInConcatenationStartsAtCorr
             .waitForPlaybackState(Player.STATE_BUFFERING)
             // Seek 10ms into the second period.
             .seek(/* positionMs= */ periodDurationMs + 10)
-            .waitForSeekProcessed()
+            .waitForTimelineChanged()
             .executeRunnable(() -> mediaSource.setNewSourceInfo(timeline, /* newManifest= */ null))
             .waitForTimelineChanged()
             .waitForPlaybackState(Player.STATE_READY)
@@ -2661,7 +2565,7 @@ public void run(SimpleExoPlayer player) {
             .play()
             .build();
     new Builder()
-        .setMediaSources(concatenatedMediaSource)
+        .setMediaSource(concatenatedMediaSource)
         .setActionSchedule(actionSchedule)
         .build(context)
         .start()
@@ -2762,10 +2666,10 @@ public void run(SimpleExoPlayer player) {
                     player.addListener(eventListener);
                   }
                 })
-            .seek(/* positionMs= */ 5_000)
+            .seek(5_000)
             .build();
     new ExoPlayerTestRunner.Builder()
-        .setMediaSources(fakeMediaSource)
+        .setMediaSource(fakeMediaSource)
         .setActionSchedule(actionSchedule)
         .build(context)
         .start()
@@ -2863,295 +2767,6 @@ public void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {
         .inOrder();
   }
 
-  @Test
-  public void testMoveMediaItem() throws Exception {
-    TimelineWindowDefinition firstWindowDefinition =
-        new TimelineWindowDefinition(
-            /* periodCount= */ 1,
-            /* id= */ 1,
-            /* isSeekable= */ true,
-            /* isDynamic= */ false,
-            /* durationUs= */ C.msToUs(10000));
-    TimelineWindowDefinition secondWindowDefinition =
-        new TimelineWindowDefinition(
-            /* periodCount= */ 1,
-            /* id= */ 2,
-            /* isSeekable= */ true,
-            /* isDynamic= */ false,
-            /* durationUs= */ C.msToUs(10000));
-    Timeline timeline1 = new FakeTimeline(firstWindowDefinition);
-    Timeline timeline2 = new FakeTimeline(secondWindowDefinition);
-    MediaSource mediaSource1 = new FakeMediaSource(timeline1);
-    MediaSource mediaSource2 = new FakeMediaSource(timeline2);
-    Timeline expectedDummyTimeline =
-        new FakeTimeline(
-            new TimelineWindowDefinition(
-                /* periodCount= */ 1,
-                /* id= */ 1,
-                /* isSeekable= */ false,
-                /* isDynamic= */ true,
-                /* durationUs= */ C.TIME_UNSET),
-            new TimelineWindowDefinition(
-                /* periodCount= */ 1,
-                /* id= */ 2,
-                /* isSeekable= */ false,
-                /* isDynamic= */ true,
-                /* durationUs= */ C.TIME_UNSET));
-    ActionSchedule actionSchedule =
-        new ActionSchedule.Builder("testMoveMediaItem")
-            .waitForTimelineChanged(
-                /* expectedTimeline= */ null, Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE)
-            .moveMediaItem(/* currentIndex= */ 0, /* newIndex= */ 1)
-            .build();
-    ExoPlayerTestRunner exoPlayerTestRunner =
-        new Builder()
-            .setMediaSources(mediaSource1, mediaSource2)
-            .setActionSchedule(actionSchedule)
-            .build(context)
-            .start()
-            .blockUntilActionScheduleFinished(TIMEOUT_MS)
-            .blockUntilEnded(TIMEOUT_MS);
-
-    Timeline expectedRealTimeline = new FakeTimeline(firstWindowDefinition, secondWindowDefinition);
-    Timeline expectedRealTimelineAfterMove =
-        new FakeTimeline(secondWindowDefinition, firstWindowDefinition);
-    exoPlayerTestRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE,
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED);
-    exoPlayerTestRunner.assertTimelinesSame(
-        expectedDummyTimeline, expectedRealTimeline, expectedRealTimelineAfterMove);
-  }
-
-  @Test
-  public void testRemoveMediaItem() throws Exception {
-    TimelineWindowDefinition firstWindowDefinition =
-        new TimelineWindowDefinition(
-            /* periodCount= */ 1,
-            /* id= */ 1,
-            /* isSeekable= */ true,
-            /* isDynamic= */ false,
-            /* durationUs= */ C.msToUs(10000));
-    TimelineWindowDefinition secondWindowDefinition =
-        new TimelineWindowDefinition(
-            /* periodCount= */ 1,
-            /* id= */ 2,
-            /* isSeekable= */ true,
-            /* isDynamic= */ false,
-            /* durationUs= */ C.msToUs(10000));
-    TimelineWindowDefinition thirdWindowDefinition =
-        new TimelineWindowDefinition(
-            /* periodCount= */ 1,
-            /* id= */ 3,
-            /* isSeekable= */ true,
-            /* isDynamic= */ false,
-            /* durationUs= */ C.msToUs(10000));
-    Timeline timeline1 = new FakeTimeline(firstWindowDefinition);
-    Timeline timeline2 = new FakeTimeline(secondWindowDefinition);
-    Timeline timeline3 = new FakeTimeline(thirdWindowDefinition);
-    MediaSource mediaSource1 = new FakeMediaSource(timeline1);
-    MediaSource mediaSource2 = new FakeMediaSource(timeline2);
-    MediaSource mediaSource3 = new FakeMediaSource(timeline3);
-    ActionSchedule actionSchedule =
-        new ActionSchedule.Builder("testRemoveMediaItems")
-            .waitForPlaybackState(Player.STATE_READY)
-            .removeMediaItem(/* index= */ 0)
-            .build();
-    ExoPlayerTestRunner exoPlayerTestRunner =
-        new Builder()
-            .setMediaSources(mediaSource1, mediaSource2, mediaSource3)
-            .setActionSchedule(actionSchedule)
-            .build(context)
-            .start()
-            .blockUntilActionScheduleFinished(TIMEOUT_MS)
-            .blockUntilEnded(TIMEOUT_MS);
-
-    Timeline expectedDummyTimeline =
-        new FakeTimeline(
-            new TimelineWindowDefinition(
-                /* periodCount= */ 1,
-                /* id= */ 1,
-                /* isSeekable= */ false,
-                /* isDynamic= */ true,
-                /* durationUs= */ C.TIME_UNSET),
-            new TimelineWindowDefinition(
-                /* periodCount= */ 1,
-                /* id= */ 2,
-                /* isSeekable= */ false,
-                /* isDynamic= */ true,
-                /* durationUs= */ C.TIME_UNSET),
-            new TimelineWindowDefinition(
-                /* periodCount= */ 1,
-                /* id= */ 3,
-                /* isSeekable= */ false,
-                /* isDynamic= */ true,
-                /* durationUs= */ C.TIME_UNSET));
-    Timeline expectedRealTimeline =
-        new FakeTimeline(firstWindowDefinition, secondWindowDefinition, thirdWindowDefinition);
-    Timeline expectedRealTimelineAfterRemove =
-        new FakeTimeline(secondWindowDefinition, thirdWindowDefinition);
-    exoPlayerTestRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE,
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED);
-    exoPlayerTestRunner.assertTimelinesSame(
-        expectedDummyTimeline, expectedRealTimeline, expectedRealTimelineAfterRemove);
-  }
-
-  @Test
-  public void testRemoveMediaItems() throws Exception {
-    TimelineWindowDefinition firstWindowDefinition =
-        new TimelineWindowDefinition(
-            /* periodCount= */ 1,
-            /* id= */ 1,
-            /* isSeekable= */ true,
-            /* isDynamic= */ false,
-            /* durationUs= */ C.msToUs(10000));
-    TimelineWindowDefinition secondWindowDefinition =
-        new TimelineWindowDefinition(
-            /* periodCount= */ 1,
-            /* id= */ 2,
-            /* isSeekable= */ true,
-            /* isDynamic= */ false,
-            /* durationUs= */ C.msToUs(10000));
-    TimelineWindowDefinition thirdWindowDefinition =
-        new TimelineWindowDefinition(
-            /* periodCount= */ 1,
-            /* id= */ 3,
-            /* isSeekable= */ true,
-            /* isDynamic= */ false,
-            /* durationUs= */ C.msToUs(10000));
-    Timeline timeline1 = new FakeTimeline(firstWindowDefinition);
-    Timeline timeline2 = new FakeTimeline(secondWindowDefinition);
-    Timeline timeline3 = new FakeTimeline(thirdWindowDefinition);
-    MediaSource mediaSource1 = new FakeMediaSource(timeline1);
-    MediaSource mediaSource2 = new FakeMediaSource(timeline2);
-    MediaSource mediaSource3 = new FakeMediaSource(timeline3);
-    ActionSchedule actionSchedule =
-        new ActionSchedule.Builder("testRemoveMediaItems")
-            .waitForPlaybackState(Player.STATE_READY)
-            .removeMediaItems(/* fromIndex= */ 1, /* toIndex= */ 3)
-            .build();
-    ExoPlayerTestRunner exoPlayerTestRunner =
-        new Builder()
-            .setMediaSources(mediaSource1, mediaSource2, mediaSource3)
-            .setActionSchedule(actionSchedule)
-            .build(context)
-            .start()
-            .blockUntilActionScheduleFinished(TIMEOUT_MS)
-            .blockUntilEnded(TIMEOUT_MS);
-
-    Timeline expectedDummyTimeline =
-        new FakeTimeline(
-            new TimelineWindowDefinition(
-                /* periodCount= */ 1,
-                /* id= */ 1,
-                /* isSeekable= */ false,
-                /* isDynamic= */ true,
-                /* durationUs= */ C.TIME_UNSET),
-            new TimelineWindowDefinition(
-                /* periodCount= */ 1,
-                /* id= */ 2,
-                /* isSeekable= */ false,
-                /* isDynamic= */ true,
-                /* durationUs= */ C.TIME_UNSET),
-            new TimelineWindowDefinition(
-                /* periodCount= */ 1,
-                /* id= */ 3,
-                /* isSeekable= */ false,
-                /* isDynamic= */ true,
-                /* durationUs= */ C.TIME_UNSET));
-    Timeline expectedRealTimeline =
-        new FakeTimeline(firstWindowDefinition, secondWindowDefinition, thirdWindowDefinition);
-    Timeline expectedRealTimelineAfterRemove = new FakeTimeline(firstWindowDefinition);
-    exoPlayerTestRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE,
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED);
-    exoPlayerTestRunner.assertTimelinesSame(
-        expectedDummyTimeline, expectedRealTimeline, expectedRealTimelineAfterRemove);
-  }
-
-  @Test
-  public void testClearMediaItems() throws Exception {
-    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
-    ActionSchedule actionSchedule =
-        new ActionSchedule.Builder("testClearMediaItems")
-            .waitForTimelineChanged(timeline, Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE)
-            .clearMediaItems()
-            .build();
-    ExoPlayerTestRunner exoPlayerTestRunner =
-        new Builder()
-            .setTimeline(timeline)
-            .setActionSchedule(actionSchedule)
-            .build(context)
-            .start()
-            .blockUntilActionScheduleFinished(TIMEOUT_MS)
-            .blockUntilEnded(TIMEOUT_MS);
-
-    exoPlayerTestRunner.assertTimelinesSame(dummyTimeline, timeline, Timeline.EMPTY);
-    exoPlayerTestRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED /* media item set (masked timeline) */,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE /* source prepared */,
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED /* playlist cleared */);
-  }
-
-  @Test
-  public void testMultipleModificationWithRecursiveListenerInvocations() throws Exception {
-    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
-    MediaSource mediaSource = new FakeMediaSource(timeline);
-    Timeline secondTimeline = new FakeTimeline(/* windowCount= */ 2);
-    MediaSource secondMediaSource = new FakeMediaSource(secondTimeline);
-    ActionSchedule actionSchedule =
-        new ActionSchedule.Builder("testMultipleModificationWithRecursiveListenerInvocations")
-            .waitForTimelineChanged(timeline, Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE)
-            .clearMediaItems()
-            .setMediaItems(secondMediaSource)
-            .build();
-    ExoPlayerTestRunner exoPlayerTestRunner =
-        new Builder()
-            .setMediaSources(mediaSource)
-            .setActionSchedule(actionSchedule)
-            .build(context)
-            .start()
-            .blockUntilActionScheduleFinished(TIMEOUT_MS)
-            .blockUntilEnded(TIMEOUT_MS);
-
-    exoPlayerTestRunner.assertTimelinesSame(
-        dummyTimeline, timeline, Timeline.EMPTY, dummyTimeline, secondTimeline);
-    exoPlayerTestRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE,
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE);
-  }
-
-  @Test
-  public void testPrepareWhenAlreadyPreparedIsANoop() throws Exception {
-    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
-    ActionSchedule actionSchedule =
-        new ActionSchedule.Builder("testPrepareWhenAlreadyPreparedIsANoop")
-            .waitForPlaybackState(Player.STATE_READY)
-            .prepare()
-            .build();
-    ExoPlayerTestRunner exoPlayerTestRunner =
-        new Builder()
-            .setTimeline(timeline)
-            .setActionSchedule(actionSchedule)
-            .build(context)
-            .start()
-            .blockUntilActionScheduleFinished(TIMEOUT_MS)
-            .blockUntilEnded(TIMEOUT_MS);
-
-    exoPlayerTestRunner.assertPlaybackStatesEqual(
-        Player.STATE_IDLE, Player.STATE_BUFFERING, Player.STATE_READY, Player.STATE_ENDED);
-    exoPlayerTestRunner.assertTimelinesSame(dummyTimeline, timeline);
-    exoPlayerTestRunner.assertTimelineChangeReasonsEqual(
-        Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED /* media item set (masked timeline) */,
-        Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE /* source prepared */);
-  }
-
   // Internal methods.
 
   private static ActionSchedule.Builder addSurfaceSwitch(ActionSchedule.Builder builder) {
@@ -3196,4 +2811,39 @@ public void handleMessage(SimpleExoPlayer player, int messageType, @Nullable Obj
       messageCount++;
     }
   }
+
+  /**
+   * Provides a wrapper for a {@link Runnable} which does collect playback states and window counts.
+   * Can be used with {@link ActionSchedule.Builder#executeRunnable(Runnable)} to verify that a
+   * playback state did not change and hence no observable callback is called.
+   *
+   * <p>This is specifically useful in cases when the test may end before a given state arrives or
+   * when an action of the action schedule might execute before a callback is called.
+   */
+  public static class PlaybackStateCollector extends PlayerRunnable {
+
+    private final int[] playbackStates;
+    private final int[] timelineWindowCount;
+    private final int index;
+
+    /**
+     * Creates the collector.
+     *
+     * @param index The index to populate.
+     * @param playbackStates An array of playback states to populate.
+     * @param timelineWindowCount An array of window counts to populate.
+     */
+    public PlaybackStateCollector(int index, int[] playbackStates, int[] timelineWindowCount) {
+      Assertions.checkArgument(playbackStates.length > index && timelineWindowCount.length > index);
+      this.playbackStates = playbackStates;
+      this.timelineWindowCount = timelineWindowCount;
+      this.index = index;
+    }
+
+    @Override
+    public void run(SimpleExoPlayer player) {
+      playbackStates[index] = player.getPlaybackState();
+      timelineWindowCount[index] = player.getCurrentTimeline().getWindowCount();
+    }
+  }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/MediaPeriodQueueTest.java b/library/core/src/test/java/com/google/android/exoplayer2/MediaPeriodQueueTest.java
index b137cd3cff..1a0e13b6c1 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/MediaPeriodQueueTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/MediaPeriodQueueTest.java
@@ -21,17 +21,15 @@
 
 import android.net.Uri;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
+import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
-import com.google.android.exoplayer2.source.ShuffleOrder;
 import com.google.android.exoplayer2.source.SinglePeriodTimeline;
 import com.google.android.exoplayer2.source.ads.AdPlaybackState;
 import com.google.android.exoplayer2.source.ads.SinglePeriodAdTimeline;
-import com.google.android.exoplayer2.testutil.FakeMediaSource;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
 import com.google.android.exoplayer2.trackselection.TrackSelectorResult;
 import com.google.android.exoplayer2.upstream.Allocator;
-import java.util.Collections;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -46,25 +44,25 @@
   private static final long SECOND_AD_START_TIME_US = 20 * C.MICROS_PER_SECOND;
 
   private static final Timeline CONTENT_TIMELINE =
-      new SinglePeriodTimeline(CONTENT_DURATION_US, /* isSeekable= */ true, /* isDynamic= */ false);
+      new SinglePeriodTimeline(
+          CONTENT_DURATION_US, /* isSeekable= */ true, /* isDynamic= */ false, /* isLive= */ false);
   private static final Uri AD_URI = Uri.EMPTY;
 
   private MediaPeriodQueue mediaPeriodQueue;
   private AdPlaybackState adPlaybackState;
+  private Timeline timeline;
   private Object periodUid;
 
   private PlaybackInfo playbackInfo;
   private RendererCapabilities[] rendererCapabilities;
   private TrackSelector trackSelector;
   private Allocator allocator;
-  private Playlist playlist;
-  private FakeMediaSource fakeMediaSource;
-  private Playlist.MediaSourceHolder mediaSourceHolder;
+  private MediaSource mediaSource;
 
   @Before
   public void setUp() {
     mediaPeriodQueue = new MediaPeriodQueue();
-    playlist = mock(Playlist.class);
+    mediaSource = mock(MediaSource.class);
     rendererCapabilities = new RendererCapabilities[0];
     trackSelector = mock(TrackSelector.class);
     allocator = mock(Allocator.class);
@@ -72,7 +70,7 @@ public void setUp() {
 
   @Test
   public void getNextMediaPeriodInfo_withoutAds_returnsLastMediaPeriodInfo() {
-    setupTimeline();
+    setupTimeline(/* initialPositionUs= */ 0);
     assertGetNextMediaPeriodInfoReturnsContentMediaPeriod(
         /* startPositionUs= */ 0,
         /* endPositionUs= */ C.TIME_UNSET,
@@ -83,7 +81,7 @@ public void getNextMediaPeriodInfo_withoutAds_returnsLastMediaPeriodInfo() {
 
   @Test
   public void getNextMediaPeriodInfo_withPrerollAd_returnsCorrectMediaPeriodInfos() {
-    setupTimeline(/* adGroupTimesUs= */ 0);
+    setupTimeline(/* initialPositionUs= */ 0, /* adGroupTimesUs= */ 0);
     setAdGroupLoaded(/* adGroupIndex= */ 0);
     assertNextMediaPeriodInfoIsAd(/* adGroupIndex= */ 0, /* contentPositionUs= */ 0);
     advance();
@@ -97,7 +95,10 @@ public void getNextMediaPeriodInfo_withPrerollAd_returnsCorrectMediaPeriodInfos(
 
   @Test
   public void getNextMediaPeriodInfo_withMidrollAds_returnsCorrectMediaPeriodInfos() {
-    setupTimeline(/* adGroupTimesUs= */ FIRST_AD_START_TIME_US, SECOND_AD_START_TIME_US);
+    setupTimeline(
+        /* initialPositionUs= */ 0,
+        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US,
+        SECOND_AD_START_TIME_US);
     assertGetNextMediaPeriodInfoReturnsContentMediaPeriod(
         /* startPositionUs= */ 0,
         /* endPositionUs= */ FIRST_AD_START_TIME_US,
@@ -132,7 +133,10 @@ public void getNextMediaPeriodInfo_withMidrollAds_returnsCorrectMediaPeriodInfos
 
   @Test
   public void getNextMediaPeriodInfo_withMidrollAndPostroll_returnsCorrectMediaPeriodInfos() {
-    setupTimeline(/* adGroupTimesUs= */ FIRST_AD_START_TIME_US, C.TIME_END_OF_SOURCE);
+    setupTimeline(
+        /* initialPositionUs= */ 0,
+        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US,
+        C.TIME_END_OF_SOURCE);
     assertGetNextMediaPeriodInfoReturnsContentMediaPeriod(
         /* startPositionUs= */ 0,
         /* endPositionUs= */ FIRST_AD_START_TIME_US,
@@ -165,7 +169,7 @@ public void getNextMediaPeriodInfo_withMidrollAndPostroll_returnsCorrectMediaPer
 
   @Test
   public void getNextMediaPeriodInfo_withPostrollLoadError_returnsEmptyFinalMediaPeriodInfo() {
-    setupTimeline(/* adGroupTimesUs= */ C.TIME_END_OF_SOURCE);
+    setupTimeline(/* initialPositionUs= */ 0, /* adGroupTimesUs= */ C.TIME_END_OF_SOURCE);
     assertGetNextMediaPeriodInfoReturnsContentMediaPeriod(
         /* startPositionUs= */ 0,
         /* endPositionUs= */ C.TIME_END_OF_SOURCE,
@@ -185,7 +189,10 @@ public void getNextMediaPeriodInfo_withPostrollLoadError_returnsEmptyFinalMediaP
   @Test
   public void
       updateQueuedPeriods_withDurationChangeAfterReadingPeriod_handlesChangeAndRemovesPeriodsAfterChangedPeriod() {
-    setupTimeline(/* adGroupTimesUs= */ FIRST_AD_START_TIME_US, SECOND_AD_START_TIME_US);
+    setupTimeline(
+        /* initialPositionUs= */ 0,
+        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US,
+        SECOND_AD_START_TIME_US);
     setAdGroupLoaded(/* adGroupIndex= */ 0);
     setAdGroupLoaded(/* adGroupIndex= */ 1);
     enqueueNext(); // Content before first ad.
@@ -195,8 +202,10 @@ public void getNextMediaPeriodInfo_withPostrollLoadError_returnsEmptyFinalMediaP
     enqueueNext(); // Second ad.
 
     // Change position of second ad (= change duration of content between ads).
-    updateAdPlaybackStateAndTimeline(
-        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US, SECOND_AD_START_TIME_US + 1);
+    setupTimeline(
+        /* initialPositionUs= */ 0,
+        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US,
+        SECOND_AD_START_TIME_US + 1);
     setAdGroupLoaded(/* adGroupIndex= */ 0);
     setAdGroupLoaded(/* adGroupIndex= */ 1);
     boolean changeHandled =
@@ -210,7 +219,10 @@ public void getNextMediaPeriodInfo_withPostrollLoadError_returnsEmptyFinalMediaP
   @Test
   public void
       updateQueuedPeriods_withDurationChangeBeforeReadingPeriod_doesntHandleChangeAndRemovesPeriodsAfterChangedPeriod() {
-    setupTimeline(/* adGroupTimesUs= */ FIRST_AD_START_TIME_US, SECOND_AD_START_TIME_US);
+    setupTimeline(
+        /* initialPositionUs= */ 0,
+        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US,
+        SECOND_AD_START_TIME_US);
     setAdGroupLoaded(/* adGroupIndex= */ 0);
     setAdGroupLoaded(/* adGroupIndex= */ 1);
     enqueueNext(); // Content before first ad.
@@ -221,8 +233,10 @@ public void getNextMediaPeriodInfo_withPostrollLoadError_returnsEmptyFinalMediaP
     advanceReading(); // Reading first ad.
 
     // Change position of first ad (= change duration of content before first ad).
-    updateAdPlaybackStateAndTimeline(
-        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US + 1, SECOND_AD_START_TIME_US);
+    setupTimeline(
+        /* initialPositionUs= */ 0,
+        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US + 1,
+        SECOND_AD_START_TIME_US);
     setAdGroupLoaded(/* adGroupIndex= */ 0);
     setAdGroupLoaded(/* adGroupIndex= */ 1);
     boolean changeHandled =
@@ -237,6 +251,7 @@ public void getNextMediaPeriodInfo_withPostrollLoadError_returnsEmptyFinalMediaP
   public void
       updateQueuedPeriods_withDurationChangeInReadingPeriodAfterReadingPosition_handlesChangeAndRemovesPeriodsAfterChangedPeriod() {
     setupTimeline(
+        /* initialPositionUs= */ 0,
         /* adGroupTimesUs= */ FIRST_AD_START_TIME_US,
         SECOND_AD_START_TIME_US);
     setAdGroupLoaded(/* adGroupIndex= */ 0);
@@ -250,8 +265,10 @@ public void getNextMediaPeriodInfo_withPostrollLoadError_returnsEmptyFinalMediaP
     advanceReading(); // Reading content between ads.
 
     // Change position of second ad (= change duration of content between ads).
-    updateAdPlaybackStateAndTimeline(
-        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US, SECOND_AD_START_TIME_US - 1000);
+    setupTimeline(
+        /* initialPositionUs= */ 0,
+        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US,
+        SECOND_AD_START_TIME_US - 1000);
     setAdGroupLoaded(/* adGroupIndex= */ 0);
     setAdGroupLoaded(/* adGroupIndex= */ 1);
     long readingPositionAtStartOfContentBetweenAds = FIRST_AD_START_TIME_US + AD_DURATION_US;
@@ -268,6 +285,7 @@ public void getNextMediaPeriodInfo_withPostrollLoadError_returnsEmptyFinalMediaP
   public void
       updateQueuedPeriods_withDurationChangeInReadingPeriodBeforeReadingPosition_doesntHandleChangeAndRemovesPeriodsAfterChangedPeriod() {
     setupTimeline(
+        /* initialPositionUs= */ 0,
         /* adGroupTimesUs= */ FIRST_AD_START_TIME_US,
         SECOND_AD_START_TIME_US);
     setAdGroupLoaded(/* adGroupIndex= */ 0);
@@ -281,8 +299,10 @@ public void getNextMediaPeriodInfo_withPostrollLoadError_returnsEmptyFinalMediaP
     advanceReading(); // Reading content between ads.
 
     // Change position of second ad (= change duration of content between ads).
-    updateAdPlaybackStateAndTimeline(
-        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US, SECOND_AD_START_TIME_US - 1000);
+    setupTimeline(
+        /* initialPositionUs= */ 0,
+        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US,
+        SECOND_AD_START_TIME_US - 1000);
     setAdGroupLoaded(/* adGroupIndex= */ 0);
     setAdGroupLoaded(/* adGroupIndex= */ 1);
     long readingPositionAtEndOfContentBetweenAds = SECOND_AD_START_TIME_US + AD_DURATION_US;
@@ -299,6 +319,7 @@ public void getNextMediaPeriodInfo_withPostrollLoadError_returnsEmptyFinalMediaP
   public void
       updateQueuedPeriods_withDurationChangeInReadingPeriodReadToEnd_doesntHandleChangeAndRemovesPeriodsAfterChangedPeriod() {
     setupTimeline(
+        /* initialPositionUs= */ 0,
         /* adGroupTimesUs= */ FIRST_AD_START_TIME_US,
         SECOND_AD_START_TIME_US);
     setAdGroupLoaded(/* adGroupIndex= */ 0);
@@ -312,8 +333,10 @@ public void getNextMediaPeriodInfo_withPostrollLoadError_returnsEmptyFinalMediaP
     advanceReading(); // Reading content between ads.
 
     // Change position of second ad (= change duration of content between ads).
-    updateAdPlaybackStateAndTimeline(
-        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US, SECOND_AD_START_TIME_US - 1000);
+    setupTimeline(
+        /* initialPositionUs= */ 0,
+        /* adGroupTimesUs= */ FIRST_AD_START_TIME_US,
+        SECOND_AD_START_TIME_US - 1000);
     setAdGroupLoaded(/* adGroupIndex= */ 0);
     setAdGroupLoaded(/* adGroupIndex= */ 1);
     boolean changeHandled =
@@ -324,25 +347,16 @@ public void getNextMediaPeriodInfo_withPostrollLoadError_returnsEmptyFinalMediaP
     assertThat(getQueueLength()).isEqualTo(3);
   }
 
-  private void setupTimeline(long... adGroupTimesUs) {
+  private void setupTimeline(long initialPositionUs, long... adGroupTimesUs) {
     adPlaybackState =
         new AdPlaybackState(adGroupTimesUs).withContentDurationUs(CONTENT_DURATION_US);
-
-    // Create a media source holder.
-    SinglePeriodAdTimeline adTimeline =
-        new SinglePeriodAdTimeline(CONTENT_TIMELINE, adPlaybackState);
-    fakeMediaSource = new FakeMediaSource(adTimeline);
-    mediaSourceHolder = new Playlist.MediaSourceHolder(fakeMediaSource, false);
-    mediaSourceHolder.mediaSource.prepareSourceInternal(/* mediaTransferListener */ null);
-
-    Timeline timeline = createPlaylistTimeline();
+    timeline = new SinglePeriodAdTimeline(CONTENT_TIMELINE, adPlaybackState);
     periodUid = timeline.getUidOfPeriod(/* periodIndex= */ 0);
     mediaPeriodQueue.setTimeline(timeline);
-
     playbackInfo =
         new PlaybackInfo(
             timeline,
-            mediaPeriodQueue.resolveMediaPeriodIdForAds(periodUid, /* positionUs= */ 0),
+            mediaPeriodQueue.resolveMediaPeriodIdForAds(periodUid, initialPositionUs),
             /* startPositionUs= */ 0,
             /* contentPositionUs= */ 0,
             Player.STATE_READY,
@@ -356,25 +370,6 @@ private void setupTimeline(long... adGroupTimesUs) {
             /* positionUs= */ 0);
   }
 
-  private void updateAdPlaybackStateAndTimeline(long... adGroupTimesUs) {
-    adPlaybackState =
-        new AdPlaybackState(adGroupTimesUs).withContentDurationUs(CONTENT_DURATION_US);
-    updateTimeline();
-  }
-
-  private void updateTimeline() {
-    SinglePeriodAdTimeline adTimeline =
-        new SinglePeriodAdTimeline(CONTENT_TIMELINE, adPlaybackState);
-    fakeMediaSource.setNewSourceInfo(adTimeline, /* manifest */ null);
-    mediaPeriodQueue.setTimeline(createPlaylistTimeline());
-  }
-
-  private Playlist.PlaylistTimeline createPlaylistTimeline() {
-    return new Playlist.PlaylistTimeline(
-        Collections.singleton(mediaSourceHolder),
-        new ShuffleOrder.DefaultShuffleOrder(/* length= */ 1));
-  }
-
   private void advance() {
     enqueueNext();
     if (mediaPeriodQueue.getLoadingPeriod() != mediaPeriodQueue.getPlayingPeriod()) {
@@ -395,7 +390,7 @@ private void enqueueNext() {
         rendererCapabilities,
         trackSelector,
         allocator,
-        playlist,
+        mediaSource,
         getNextMediaPeriodInfo(),
         new TrackSelectorResult(
             new RendererConfiguration[0], new TrackSelection[0], /* info= */ null));
@@ -427,6 +422,11 @@ private void setAdGroupFailedToLoad(int adGroupIndex) {
     updateTimeline();
   }
 
+  private void updateTimeline() {
+    timeline = new SinglePeriodAdTimeline(CONTENT_TIMELINE, adPlaybackState);
+    mediaPeriodQueue.setTimeline(timeline);
+  }
+
   private void assertGetNextMediaPeriodInfoReturnsContentMediaPeriod(
       long startPositionUs,
       long endPositionUs,
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/PlaylistTest.java b/library/core/src/test/java/com/google/android/exoplayer2/PlaylistTest.java
deleted file mode 100644
index cc551db8ac..0000000000
--- a/library/core/src/test/java/com/google/android/exoplayer2/PlaylistTest.java
+++ /dev/null
@@ -1,510 +0,0 @@
-/*
- * Copyright (C) 2019 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertSame;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.isNull;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-import com.google.android.exoplayer2.source.MediaSource;
-import com.google.android.exoplayer2.source.ShuffleOrder;
-import com.google.android.exoplayer2.testutil.FakeMediaSource;
-import com.google.android.exoplayer2.testutil.FakeShuffleOrder;
-import com.google.android.exoplayer2.testutil.FakeTimeline;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-/** Unit test for {@link Playlist}. */
-@RunWith(AndroidJUnit4.class)
-public class PlaylistTest {
-
-  private static final int PLAYLIST_SIZE = 4;
-
-  private Playlist playlist;
-
-  @Before
-  public void setUp() {
-    playlist = new Playlist(mock(Playlist.PlaylistInfoRefreshListener.class));
-  }
-
-  @Test
-  public void testEmptyPlaylist_expectConstantTimelineInstanceEMPTY() {
-    ShuffleOrder.DefaultShuffleOrder shuffleOrder =
-        new ShuffleOrder.DefaultShuffleOrder(/* length= */ 0);
-    List<Playlist.MediaSourceHolder> fakeHolders = createFakeHolders();
-
-    Timeline timeline = playlist.setMediaSources(fakeHolders, shuffleOrder);
-    assertNotSame(timeline, Timeline.EMPTY);
-
-    // Remove all media sources.
-    timeline =
-        playlist.removeMediaSourceRange(
-            /* fromIndex= */ 0, /* toIndex= */ timeline.getWindowCount(), shuffleOrder);
-    assertSame(timeline, Timeline.EMPTY);
-
-    timeline = playlist.setMediaSources(fakeHolders, shuffleOrder);
-    assertNotSame(timeline, Timeline.EMPTY);
-    // Clear.
-    timeline = playlist.clear(shuffleOrder);
-    assertSame(timeline, Timeline.EMPTY);
-  }
-
-  @Test
-  public void testPrepareAndReprepareAfterRelease_expectSourcePreparationAfterPlaylistPrepare() {
-    MediaSource mockMediaSource1 = mock(MediaSource.class);
-    MediaSource mockMediaSource2 = mock(MediaSource.class);
-    playlist.setMediaSources(
-        createFakeHoldersWithSources(
-            /* useLazyPreparation= */ false, mockMediaSource1, mockMediaSource2),
-        new ShuffleOrder.DefaultShuffleOrder(/* length= */ 2));
-    // Verify prepare is called once on prepare.
-    verify(mockMediaSource1, times(0))
-        .prepareSource(
-            any(MediaSource.MediaSourceCaller.class), /* mediaTransferListener= */ isNull());
-    verify(mockMediaSource2, times(0))
-        .prepareSource(
-            any(MediaSource.MediaSourceCaller.class), /* mediaTransferListener= */ isNull());
-
-    playlist.prepare(/* mediaTransferListener= */ null);
-    assertThat(playlist.isPrepared()).isTrue();
-    // Verify prepare is called once on prepare.
-    verify(mockMediaSource1, times(1))
-        .prepareSource(
-            any(MediaSource.MediaSourceCaller.class), /* mediaTransferListener= */ isNull());
-    verify(mockMediaSource2, times(1))
-        .prepareSource(
-            any(MediaSource.MediaSourceCaller.class), /* mediaTransferListener= */ isNull());
-
-    playlist.release();
-    playlist.prepare(/* mediaTransferListener= */ null);
-    // Verify prepare is called a second time on re-prepare.
-    verify(mockMediaSource1, times(2))
-        .prepareSource(
-            any(MediaSource.MediaSourceCaller.class), /* mediaTransferListener= */ isNull());
-    verify(mockMediaSource2, times(2))
-        .prepareSource(
-            any(MediaSource.MediaSourceCaller.class), /* mediaTransferListener= */ isNull());
-  }
-
-  @Test
-  public void testSetMediaSources_playlistUnprepared_notUsingLazyPreparation() {
-    ShuffleOrder.DefaultShuffleOrder shuffleOrder =
-        new ShuffleOrder.DefaultShuffleOrder(/* length= */ 2);
-    MediaSource mockMediaSource1 = mock(MediaSource.class);
-    MediaSource mockMediaSource2 = mock(MediaSource.class);
-    List<Playlist.MediaSourceHolder> mediaSources =
-        createFakeHoldersWithSources(
-            /* useLazyPreparation= */ false, mockMediaSource1, mockMediaSource2);
-    Timeline timeline = playlist.setMediaSources(mediaSources, shuffleOrder);
-
-    assertThat(timeline.getWindowCount()).isEqualTo(2);
-    assertThat(playlist.getSize()).isEqualTo(2);
-
-    // Assert holder offsets have been set properly
-    for (int i = 0; i < mediaSources.size(); i++) {
-      Playlist.MediaSourceHolder mediaSourceHolder = mediaSources.get(i);
-      assertThat(mediaSourceHolder.isRemoved).isFalse();
-      assertThat(mediaSourceHolder.firstWindowIndexInChild).isEqualTo(i);
-    }
-
-    // Set media items again. The second holder is re-used.
-    List<Playlist.MediaSourceHolder> moreMediaSources =
-        createFakeHoldersWithSources(/* useLazyPreparation= */ false, mock(MediaSource.class));
-    moreMediaSources.add(mediaSources.get(1));
-    timeline = playlist.setMediaSources(moreMediaSources, shuffleOrder);
-
-    assertThat(playlist.getSize()).isEqualTo(2);
-    assertThat(timeline.getWindowCount()).isEqualTo(2);
-    for (int i = 0; i < moreMediaSources.size(); i++) {
-      Playlist.MediaSourceHolder mediaSourceHolder = moreMediaSources.get(i);
-      assertThat(mediaSourceHolder.isRemoved).isFalse();
-      assertThat(mediaSourceHolder.firstWindowIndexInChild).isEqualTo(i);
-    }
-    // Expect removed holders and sources to be removed without releasing.
-    verify(mockMediaSource1, times(0)).releaseSource(any(MediaSource.MediaSourceCaller.class));
-    assertThat(mediaSources.get(0).isRemoved).isTrue();
-    // Expect re-used holder and source not to be removed.
-    verify(mockMediaSource2, times(0)).releaseSource(any(MediaSource.MediaSourceCaller.class));
-    assertThat(mediaSources.get(1).isRemoved).isFalse();
-  }
-
-  @Test
-  public void testSetMediaSources_playlistPrepared_notUsingLazyPreparation() {
-    ShuffleOrder.DefaultShuffleOrder shuffleOrder =
-        new ShuffleOrder.DefaultShuffleOrder(/* length= */ 2);
-    MediaSource mockMediaSource1 = mock(MediaSource.class);
-    MediaSource mockMediaSource2 = mock(MediaSource.class);
-    List<Playlist.MediaSourceHolder> mediaSources =
-        createFakeHoldersWithSources(
-            /* useLazyPreparation= */ false, mockMediaSource1, mockMediaSource2);
-
-    playlist.prepare(/* mediaTransferListener= */ null);
-    playlist.setMediaSources(mediaSources, shuffleOrder);
-
-    // Verify sources are prepared.
-    verify(mockMediaSource1, times(1))
-        .prepareSource(
-            any(MediaSource.MediaSourceCaller.class), /* mediaTransferListener= */ isNull());
-    verify(mockMediaSource2, times(1))
-        .prepareSource(
-            any(MediaSource.MediaSourceCaller.class), /* mediaTransferListener= */ isNull());
-
-    // Set media items again. The second holder is re-used.
-    List<Playlist.MediaSourceHolder> moreMediaSources =
-        createFakeHoldersWithSources(/* useLazyPreparation= */ false, mock(MediaSource.class));
-    moreMediaSources.add(mediaSources.get(1));
-    playlist.setMediaSources(moreMediaSources, shuffleOrder);
-
-    // Expect removed holders and sources to be removed and released.
-    verify(mockMediaSource1, times(1)).releaseSource(any(MediaSource.MediaSourceCaller.class));
-    assertThat(mediaSources.get(0).isRemoved).isTrue();
-    // Expect re-used holder and source not to be removed but released.
-    verify(mockMediaSource2, times(1)).releaseSource(any(MediaSource.MediaSourceCaller.class));
-    assertThat(mediaSources.get(1).isRemoved).isFalse();
-    verify(mockMediaSource2, times(2))
-        .prepareSource(
-            any(MediaSource.MediaSourceCaller.class), /* mediaTransferListener= */ isNull());
-  }
-
-  @Test
-  public void testAddMediaSources_playlistUnprepared_notUsingLazyPreparation_expectUnprepared() {
-    MediaSource mockMediaSource1 = mock(MediaSource.class);
-    MediaSource mockMediaSource2 = mock(MediaSource.class);
-    List<Playlist.MediaSourceHolder> mediaSources =
-        createFakeHoldersWithSources(
-            /* useLazyPreparation= */ false, mockMediaSource1, mockMediaSource2);
-    playlist.addMediaSources(/* index= */ 0, mediaSources, new ShuffleOrder.DefaultShuffleOrder(2));
-
-    assertThat(playlist.getSize()).isEqualTo(2);
-    // Verify lazy initialization does not call prepare on sources.
-    verify(mockMediaSource1, times(0))
-        .prepareSource(
-            any(MediaSource.MediaSourceCaller.class), /* mediaTransferListener= */ isNull());
-    verify(mockMediaSource2, times(0))
-        .prepareSource(
-            any(MediaSource.MediaSourceCaller.class), /* mediaTransferListener= */ isNull());
-
-    for (int i = 0; i < mediaSources.size(); i++) {
-      assertThat(mediaSources.get(i).firstWindowIndexInChild).isEqualTo(i);
-      assertThat(mediaSources.get(i).isRemoved).isFalse();
-    }
-
-    // Add for more sources in between.
-    List<Playlist.MediaSourceHolder> moreMediaSources = createFakeHolders();
-    playlist.addMediaSources(
-        /* index= */ 1, moreMediaSources, new ShuffleOrder.DefaultShuffleOrder(/* length= */ 3));
-
-    assertThat(mediaSources.get(0).firstWindowIndexInChild).isEqualTo(0);
-    assertThat(moreMediaSources.get(0).firstWindowIndexInChild).isEqualTo(1);
-    assertThat(moreMediaSources.get(3).firstWindowIndexInChild).isEqualTo(4);
-    assertThat(mediaSources.get(1).firstWindowIndexInChild).isEqualTo(5);
-  }
-
-  @Test
-  public void testAddMediaSources_playlistPrepared_notUsingLazyPreparation_expectPrepared() {
-    MediaSource mockMediaSource1 = mock(MediaSource.class);
-    MediaSource mockMediaSource2 = mock(MediaSource.class);
-    playlist.prepare(/* mediaTransferListener= */ null);
-    playlist.addMediaSources(
-        /* index= */ 0,
-        createFakeHoldersWithSources(
-            /* useLazyPreparation= */ false, mockMediaSource1, mockMediaSource2),
-        new ShuffleOrder.DefaultShuffleOrder(/* length= */ 2));
-
-    // Verify prepare is called on sources when added.
-    verify(mockMediaSource1, times(1))
-        .prepareSource(
-            any(MediaSource.MediaSourceCaller.class), /* mediaTransferListener= */ isNull());
-    verify(mockMediaSource2, times(1))
-        .prepareSource(
-            any(MediaSource.MediaSourceCaller.class), /* mediaTransferListener= */ isNull());
-  }
-
-  @Test
-  public void testMoveMediaSources() {
-    ShuffleOrder.DefaultShuffleOrder shuffleOrder =
-        new ShuffleOrder.DefaultShuffleOrder(/* length= */ 4);
-    List<Playlist.MediaSourceHolder> holders = createFakeHolders();
-    playlist.addMediaSources(/* index= */ 0, holders, shuffleOrder);
-
-    assertDefaultFirstWindowInChildIndexOrder(holders);
-    playlist.moveMediaSource(/* currentIndex= */ 0, /* newIndex= */ 3, shuffleOrder);
-    assertFirstWindowInChildIndices(holders, 3, 0, 1, 2);
-    playlist.moveMediaSource(/* currentIndex= */ 3, /* newIndex= */ 0, shuffleOrder);
-    assertDefaultFirstWindowInChildIndexOrder(holders);
-
-    playlist.moveMediaSourceRange(
-        /* fromIndex= */ 0, /* toIndex= */ 2, /* newFromIndex= */ 2, shuffleOrder);
-    assertFirstWindowInChildIndices(holders, 2, 3, 0, 1);
-    playlist.moveMediaSourceRange(
-        /* fromIndex= */ 2, /* toIndex= */ 4, /* newFromIndex= */ 0, shuffleOrder);
-    assertDefaultFirstWindowInChildIndexOrder(holders);
-
-    playlist.moveMediaSourceRange(
-        /* fromIndex= */ 0, /* toIndex= */ 2, /* newFromIndex= */ 2, shuffleOrder);
-    assertFirstWindowInChildIndices(holders, 2, 3, 0, 1);
-    playlist.moveMediaSourceRange(
-        /* fromIndex= */ 2, /* toIndex= */ 3, /* newFromIndex= */ 0, shuffleOrder);
-    assertFirstWindowInChildIndices(holders, 0, 3, 1, 2);
-    playlist.moveMediaSourceRange(
-        /* fromIndex= */ 3, /* toIndex= */ 4, /* newFromIndex= */ 1, shuffleOrder);
-    assertDefaultFirstWindowInChildIndexOrder(holders);
-
-    // No-ops.
-    playlist.moveMediaSourceRange(
-        /* fromIndex= */ 0, /* toIndex= */ 4, /* newFromIndex= */ 0, shuffleOrder);
-    assertDefaultFirstWindowInChildIndexOrder(holders);
-    playlist.moveMediaSourceRange(
-        /* fromIndex= */ 0, /* toIndex= */ 0, /* newFromIndex= */ 3, shuffleOrder);
-    assertDefaultFirstWindowInChildIndexOrder(holders);
-  }
-
-  @Test
-  public void testRemoveMediaSources_whenUnprepared_expectNoRelease() {
-    MediaSource mockMediaSource1 = mock(MediaSource.class);
-    MediaSource mockMediaSource2 = mock(MediaSource.class);
-    MediaSource mockMediaSource3 = mock(MediaSource.class);
-    MediaSource mockMediaSource4 = mock(MediaSource.class);
-    ShuffleOrder.DefaultShuffleOrder shuffleOrder =
-        new ShuffleOrder.DefaultShuffleOrder(/* length= */ 4);
-
-    List<Playlist.MediaSourceHolder> holders =
-        createFakeHoldersWithSources(
-            /* useLazyPreparation= */ false,
-            mockMediaSource1,
-            mockMediaSource2,
-            mockMediaSource3,
-            mockMediaSource4);
-    playlist.addMediaSources(/* index= */ 0, holders, shuffleOrder);
-    playlist.removeMediaSourceRange(/* fromIndex= */ 1, /* toIndex= */ 3, shuffleOrder);
-
-    assertThat(playlist.getSize()).isEqualTo(2);
-    Playlist.MediaSourceHolder removedHolder1 = holders.remove(1);
-    Playlist.MediaSourceHolder removedHolder2 = holders.remove(1);
-
-    assertDefaultFirstWindowInChildIndexOrder(holders);
-    assertThat(removedHolder1.isRemoved).isTrue();
-    assertThat(removedHolder2.isRemoved).isTrue();
-    verify(mockMediaSource1, times(0)).releaseSource(any(MediaSource.MediaSourceCaller.class));
-    verify(mockMediaSource2, times(0)).releaseSource(any(MediaSource.MediaSourceCaller.class));
-    verify(mockMediaSource3, times(0)).releaseSource(any(MediaSource.MediaSourceCaller.class));
-    verify(mockMediaSource4, times(0)).releaseSource(any(MediaSource.MediaSourceCaller.class));
-  }
-
-  @Test
-  public void testRemoveMediaSources_whenPrepared_expectRelease() {
-    MediaSource mockMediaSource1 = mock(MediaSource.class);
-    MediaSource mockMediaSource2 = mock(MediaSource.class);
-    MediaSource mockMediaSource3 = mock(MediaSource.class);
-    MediaSource mockMediaSource4 = mock(MediaSource.class);
-    ShuffleOrder.DefaultShuffleOrder shuffleOrder =
-        new ShuffleOrder.DefaultShuffleOrder(/* length= */ 4);
-
-    List<Playlist.MediaSourceHolder> holders =
-        createFakeHoldersWithSources(
-            /* useLazyPreparation= */ false,
-            mockMediaSource1,
-            mockMediaSource2,
-            mockMediaSource3,
-            mockMediaSource4);
-    playlist.prepare(/* mediaTransferListener */ null);
-    playlist.addMediaSources(/* index= */ 0, holders, shuffleOrder);
-    playlist.removeMediaSourceRange(/* fromIndex= */ 1, /* toIndex= */ 3, shuffleOrder);
-
-    assertThat(playlist.getSize()).isEqualTo(2);
-    holders.remove(2);
-    holders.remove(1);
-
-    assertDefaultFirstWindowInChildIndexOrder(holders);
-    verify(mockMediaSource1, times(0)).releaseSource(any(MediaSource.MediaSourceCaller.class));
-    verify(mockMediaSource2, times(1)).releaseSource(any(MediaSource.MediaSourceCaller.class));
-    verify(mockMediaSource3, times(1)).releaseSource(any(MediaSource.MediaSourceCaller.class));
-    verify(mockMediaSource4, times(0)).releaseSource(any(MediaSource.MediaSourceCaller.class));
-  }
-
-  @Test
-  public void testRelease_playlistUnprepared_expectSourcesNotReleased() {
-    MediaSource mockMediaSource = mock(MediaSource.class);
-    Playlist.MediaSourceHolder mediaSourceHolder =
-        new Playlist.MediaSourceHolder(mockMediaSource, /* useLazyPreparation= */ false);
-
-    playlist.setMediaSources(
-        Collections.singletonList(mediaSourceHolder),
-        new ShuffleOrder.DefaultShuffleOrder(/* length= */ 1));
-    verify(mockMediaSource, times(0))
-        .prepareSource(
-            any(MediaSource.MediaSourceCaller.class), /* mediaTransferListener= */ isNull());
-    playlist.release();
-    verify(mockMediaSource, times(0)).releaseSource(any(MediaSource.MediaSourceCaller.class));
-    assertThat(mediaSourceHolder.isRemoved).isFalse();
-  }
-
-  @Test
-  public void testRelease_playlistPrepared_expectSourcesReleasedNotRemoved() {
-    MediaSource mockMediaSource = mock(MediaSource.class);
-    Playlist.MediaSourceHolder mediaSourceHolder =
-        new Playlist.MediaSourceHolder(mockMediaSource, /* useLazyPreparation= */ false);
-
-    playlist.prepare(/* mediaTransferListener= */ null);
-    playlist.setMediaSources(
-        Collections.singletonList(mediaSourceHolder),
-        new ShuffleOrder.DefaultShuffleOrder(/* length= */ 1));
-    verify(mockMediaSource, times(1))
-        .prepareSource(
-            any(MediaSource.MediaSourceCaller.class), /* mediaTransferListener= */ isNull());
-    playlist.release();
-    verify(mockMediaSource, times(1)).releaseSource(any(MediaSource.MediaSourceCaller.class));
-    assertThat(mediaSourceHolder.isRemoved).isFalse();
-  }
-
-  @Test
-  public void testClearPlaylist_expectSourcesReleasedAndRemoved() {
-    ShuffleOrder.DefaultShuffleOrder shuffleOrder =
-        new ShuffleOrder.DefaultShuffleOrder(/* length= */ 4);
-    MediaSource mockMediaSource1 = mock(MediaSource.class);
-    MediaSource mockMediaSource2 = mock(MediaSource.class);
-    List<Playlist.MediaSourceHolder> holders =
-        createFakeHoldersWithSources(
-            /* useLazyPreparation= */ false, mockMediaSource1, mockMediaSource2);
-    playlist.setMediaSources(holders, shuffleOrder);
-    playlist.prepare(/* mediaTransferListener= */ null);
-
-    Timeline timeline = playlist.clear(shuffleOrder);
-    assertThat(timeline.isEmpty()).isTrue();
-    assertThat(holders.get(0).isRemoved).isTrue();
-    assertThat(holders.get(1).isRemoved).isTrue();
-    verify(mockMediaSource1, times(1)).releaseSource(any());
-    verify(mockMediaSource2, times(1)).releaseSource(any());
-  }
-
-  @Test
-  public void testSetMediaSources_expectTimelineUsesCustomShuffleOrder() {
-    Timeline timeline =
-        playlist.setMediaSources(createFakeHolders(), new FakeShuffleOrder(/* length=*/ 4));
-    assertTimelineUsesFakeShuffleOrder(timeline);
-  }
-
-  @Test
-  public void testAddMediaSources_expectTimelineUsesCustomShuffleOrder() {
-    Timeline timeline =
-        playlist.addMediaSources(
-            /* index= */ 0, createFakeHolders(), new FakeShuffleOrder(PLAYLIST_SIZE));
-    assertTimelineUsesFakeShuffleOrder(timeline);
-  }
-
-  @Test
-  public void testMoveMediaSources_expectTimelineUsesCustomShuffleOrder() {
-    ShuffleOrder shuffleOrder = new ShuffleOrder.DefaultShuffleOrder(/* length= */ PLAYLIST_SIZE);
-    playlist.addMediaSources(/* index= */ 0, createFakeHolders(), shuffleOrder);
-    Timeline timeline =
-        playlist.moveMediaSource(
-            /* currentIndex= */ 0, /* newIndex= */ 1, new FakeShuffleOrder(PLAYLIST_SIZE));
-    assertTimelineUsesFakeShuffleOrder(timeline);
-  }
-
-  @Test
-  public void testMoveMediaSourceRange_expectTimelineUsesCustomShuffleOrder() {
-    ShuffleOrder shuffleOrder = new ShuffleOrder.DefaultShuffleOrder(/* length= */ PLAYLIST_SIZE);
-    playlist.addMediaSources(/* index= */ 0, createFakeHolders(), shuffleOrder);
-    Timeline timeline =
-        playlist.moveMediaSourceRange(
-            /* fromIndex= */ 0,
-            /* toIndex= */ 2,
-            /* newFromIndex= */ 2,
-            new FakeShuffleOrder(PLAYLIST_SIZE));
-    assertTimelineUsesFakeShuffleOrder(timeline);
-  }
-
-  @Test
-  public void testRemoveMediaSourceRange_expectTimelineUsesCustomShuffleOrder() {
-    ShuffleOrder shuffleOrder = new ShuffleOrder.DefaultShuffleOrder(/* length= */ PLAYLIST_SIZE);
-    playlist.addMediaSources(/* index= */ 0, createFakeHolders(), shuffleOrder);
-    Timeline timeline =
-        playlist.removeMediaSourceRange(
-            /* fromIndex= */ 0, /* toIndex= */ 2, new FakeShuffleOrder(/* length= */ 2));
-    assertTimelineUsesFakeShuffleOrder(timeline);
-  }
-
-  @Test
-  public void testSetShuffleOrder_expectTimelineUsesCustomShuffleOrder() {
-    playlist.setMediaSources(
-        createFakeHolders(), new ShuffleOrder.DefaultShuffleOrder(/* length= */ PLAYLIST_SIZE));
-    assertTimelineUsesFakeShuffleOrder(
-        playlist.setShuffleOrder(new FakeShuffleOrder(PLAYLIST_SIZE)));
-  }
-
-  // Internal methods.
-
-  private static void assertTimelineUsesFakeShuffleOrder(Timeline timeline) {
-    assertThat(
-            timeline.getNextWindowIndex(
-                /* windowIndex= */ 0, Player.REPEAT_MODE_OFF, /* shuffleModeEnabled= */ true))
-        .isEqualTo(-1);
-    assertThat(
-            timeline.getPreviousWindowIndex(
-                /* windowIndex= */ timeline.getWindowCount() - 1,
-                Player.REPEAT_MODE_OFF,
-                /* shuffleModeEnabled= */ true))
-        .isEqualTo(-1);
-  }
-
-  private static void assertDefaultFirstWindowInChildIndexOrder(
-      List<Playlist.MediaSourceHolder> holders) {
-    int[] indices = new int[holders.size()];
-    for (int i = 0; i < indices.length; i++) {
-      indices[i] = i;
-    }
-    assertFirstWindowInChildIndices(holders, indices);
-  }
-
-  private static void assertFirstWindowInChildIndices(
-      List<Playlist.MediaSourceHolder> holders, int... firstWindowInChildIndices) {
-    assertThat(holders).hasSize(firstWindowInChildIndices.length);
-    for (int i = 0; i < holders.size(); i++) {
-      assertThat(holders.get(i).firstWindowIndexInChild).isEqualTo(firstWindowInChildIndices[i]);
-    }
-  }
-
-  private static List<Playlist.MediaSourceHolder> createFakeHolders() {
-    MediaSource fakeMediaSource = new FakeMediaSource(new FakeTimeline(1));
-    List<Playlist.MediaSourceHolder> holders = new ArrayList<>();
-    for (int i = 0; i < PLAYLIST_SIZE; i++) {
-      holders.add(new Playlist.MediaSourceHolder(fakeMediaSource, /* useLazyPreparation= */ true));
-    }
-    return holders;
-  }
-
-  private static List<Playlist.MediaSourceHolder> createFakeHoldersWithSources(
-      boolean useLazyPreparation, MediaSource... sources) {
-    List<Playlist.MediaSourceHolder> holders = new ArrayList<>();
-    for (MediaSource mediaSource : sources) {
-      holders.add(
-          new Playlist.MediaSourceHolder(
-              mediaSource, /* useLazyPreparation= */ useLazyPreparation));
-    }
-    return holders;
-  }
-}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/TimelineTest.java b/library/core/src/test/java/com/google/android/exoplayer2/TimelineTest.java
index ba05af385a..d6e65cb34d 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/TimelineTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/TimelineTest.java
@@ -15,8 +15,6 @@
  */
 package com.google.android.exoplayer2;
 
-import static com.google.common.truth.Truth.assertThat;
-
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.testutil.FakeTimeline;
 import com.google.android.exoplayer2.testutil.FakeTimeline.TimelineWindowDefinition;
@@ -60,142 +58,4 @@ public void testMultiPeriodTimeline() {
     TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0);
     TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 0);
   }
-
-  @Test
-  public void testWindowEquals() {
-    Timeline.Window window = new Timeline.Window();
-    assertThat(window).isEqualTo(new Timeline.Window());
-
-    Timeline.Window otherWindow = new Timeline.Window();
-    otherWindow.tag = new Object();
-    assertThat(window).isNotEqualTo(otherWindow);
-
-    otherWindow = new Timeline.Window();
-    otherWindow.manifest = new Object();
-    assertThat(window).isNotEqualTo(otherWindow);
-
-    otherWindow = new Timeline.Window();
-    otherWindow.presentationStartTimeMs = C.TIME_UNSET;
-    assertThat(window).isNotEqualTo(otherWindow);
-
-    otherWindow = new Timeline.Window();
-    otherWindow.windowStartTimeMs = C.TIME_UNSET;
-    assertThat(window).isNotEqualTo(otherWindow);
-
-    otherWindow = new Timeline.Window();
-    otherWindow.isSeekable = true;
-    assertThat(window).isNotEqualTo(otherWindow);
-
-    otherWindow = new Timeline.Window();
-    otherWindow.isDynamic = true;
-    assertThat(window).isNotEqualTo(otherWindow);
-
-    otherWindow = new Timeline.Window();
-    otherWindow.defaultPositionUs = C.TIME_UNSET;
-    assertThat(window).isNotEqualTo(otherWindow);
-
-    otherWindow = new Timeline.Window();
-    otherWindow.durationUs = C.TIME_UNSET;
-    assertThat(window).isNotEqualTo(otherWindow);
-
-    otherWindow = new Timeline.Window();
-    otherWindow.firstPeriodIndex = 1;
-    assertThat(window).isNotEqualTo(otherWindow);
-
-    otherWindow = new Timeline.Window();
-    otherWindow.lastPeriodIndex = 1;
-    assertThat(window).isNotEqualTo(otherWindow);
-
-    otherWindow = new Timeline.Window();
-    otherWindow.positionInFirstPeriodUs = C.TIME_UNSET;
-    assertThat(window).isNotEqualTo(otherWindow);
-
-    window.uid = new Object();
-    window.tag = new Object();
-    window.manifest = new Object();
-    window.presentationStartTimeMs = C.TIME_UNSET;
-    window.windowStartTimeMs = C.TIME_UNSET;
-    window.isSeekable = true;
-    window.isDynamic = true;
-    window.defaultPositionUs = C.TIME_UNSET;
-    window.durationUs = C.TIME_UNSET;
-    window.firstPeriodIndex = 1;
-    window.lastPeriodIndex = 1;
-    window.positionInFirstPeriodUs = C.TIME_UNSET;
-    otherWindow =
-        otherWindow.set(
-            window.uid,
-            window.tag,
-            window.manifest,
-            window.presentationStartTimeMs,
-            window.windowStartTimeMs,
-            window.isSeekable,
-            window.isDynamic,
-            window.defaultPositionUs,
-            window.durationUs,
-            window.firstPeriodIndex,
-            window.lastPeriodIndex,
-            window.positionInFirstPeriodUs);
-    assertThat(window).isEqualTo(otherWindow);
-  }
-
-  @Test
-  public void testWindowHashCode() {
-    Timeline.Window window = new Timeline.Window();
-    Timeline.Window otherWindow = new Timeline.Window();
-    assertThat(window.hashCode()).isEqualTo(otherWindow.hashCode());
-
-    window.tag = new Object();
-    assertThat(window.hashCode()).isNotEqualTo(otherWindow.hashCode());
-    otherWindow.tag = window.tag;
-    assertThat(window.hashCode()).isEqualTo(otherWindow.hashCode());
-  }
-
-  @Test
-  public void testPeriodEquals() {
-    Timeline.Period period = new Timeline.Period();
-    assertThat(period).isEqualTo(new Timeline.Period());
-
-    Timeline.Period otherPeriod = new Timeline.Period();
-    otherPeriod.id = new Object();
-    assertThat(period).isNotEqualTo(otherPeriod);
-
-    otherPeriod = new Timeline.Period();
-    otherPeriod.uid = new Object();
-    assertThat(period).isNotEqualTo(otherPeriod);
-
-    otherPeriod = new Timeline.Period();
-    otherPeriod.windowIndex = 12;
-    assertThat(period).isNotEqualTo(otherPeriod);
-
-    otherPeriod = new Timeline.Period();
-    otherPeriod.durationUs = 11L;
-    assertThat(period).isNotEqualTo(otherPeriod);
-
-    otherPeriod = new Timeline.Period();
-    period.id = new Object();
-    period.uid = new Object();
-    period.windowIndex = 1;
-    period.durationUs = 123L;
-    otherPeriod =
-        otherPeriod.set(
-            period.id,
-            period.uid,
-            period.windowIndex,
-            period.durationUs,
-            /* positionInWindowUs= */ 0);
-    assertThat(period).isEqualTo(otherPeriod);
-  }
-
-  @Test
-  public void testPeriodHashCode() {
-    Timeline.Period period = new Timeline.Period();
-    Timeline.Period otherPeriod = new Timeline.Period();
-    assertThat(period.hashCode()).isEqualTo(otherPeriod.hashCode());
-
-    period.windowIndex = 12;
-    assertThat(period.hashCode()).isNotEqualTo(otherPeriod.hashCode());
-    otherPeriod.windowIndex = period.windowIndex;
-    assertThat(period.hashCode()).isEqualTo(otherPeriod.hashCode());
-  }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/analytics/AnalyticsCollectorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/analytics/AnalyticsCollectorTest.java
index 7117f426f3..fb3e0936ae 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/analytics/AnalyticsCollectorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/analytics/AnalyticsCollectorTest.java
@@ -44,6 +44,7 @@
 import com.google.android.exoplayer2.testutil.ActionSchedule;
 import com.google.android.exoplayer2.testutil.ActionSchedule.PlayerRunnable;
 import com.google.android.exoplayer2.testutil.ExoPlayerTestRunner;
+import com.google.android.exoplayer2.testutil.ExoPlayerTestRunner.Builder;
 import com.google.android.exoplayer2.testutil.FakeMediaSource;
 import com.google.android.exoplayer2.testutil.FakeRenderer;
 import com.google.android.exoplayer2.testutil.FakeTimeline;
@@ -132,29 +133,24 @@ public void testEmptyTimeline() throws Exception {
     assertThat(listener.getEvents(EVENT_PLAYER_STATE_CHANGED))
         .containsExactly(
             WINDOW_0 /* setPlayWhenReady */, WINDOW_0 /* BUFFERING */, WINDOW_0 /* ENDED */);
-    assertThat(listener.getEvents(EVENT_TIMELINE_CHANGED))
-        .containsExactly(WINDOW_0 /* PLAYLIST_CHANGED */, WINDOW_0 /* DYNAMIC */);
+    assertThat(listener.getEvents(EVENT_TIMELINE_CHANGED)).containsExactly(WINDOW_0);
     listener.assertNoMoreEvents();
   }
 
   @Test
   public void testSinglePeriod() throws Exception {
     FakeMediaSource mediaSource =
-        new FakeMediaSource(
-            SINGLE_PERIOD_TIMELINE,
-            ExoPlayerTestRunner.Builder.VIDEO_FORMAT,
-            ExoPlayerTestRunner.Builder.AUDIO_FORMAT);
+        new FakeMediaSource(SINGLE_PERIOD_TIMELINE, Builder.VIDEO_FORMAT, Builder.AUDIO_FORMAT);
     TestAnalyticsListener listener = runAnalyticsTest(mediaSource);
 
-    populateEventIds(listener.lastReportedTimeline);
+    populateEventIds(SINGLE_PERIOD_TIMELINE);
     assertThat(listener.getEvents(EVENT_PLAYER_STATE_CHANGED))
         .containsExactly(
             WINDOW_0 /* setPlayWhenReady */,
             WINDOW_0 /* BUFFERING */,
             period0 /* READY */,
             period0 /* ENDED */);
-    assertThat(listener.getEvents(EVENT_TIMELINE_CHANGED))
-        .containsExactly(WINDOW_0 /* PLAYLIST_CHANGED */, WINDOW_0 /* DYNAMIC */);
+    assertThat(listener.getEvents(EVENT_TIMELINE_CHANGED)).containsExactly(WINDOW_0);
     assertThat(listener.getEvents(EVENT_LOADING_CHANGED))
         .containsExactly(period0 /* started */, period0 /* stopped */);
     assertThat(listener.getEvents(EVENT_TRACKS_CHANGED)).containsExactly(period0);
@@ -183,14 +179,9 @@ public void testSinglePeriod() throws Exception {
   public void testAutomaticPeriodTransition() throws Exception {
     MediaSource mediaSource =
         new ConcatenatingMediaSource(
+            new FakeMediaSource(SINGLE_PERIOD_TIMELINE, Builder.VIDEO_FORMAT, Builder.AUDIO_FORMAT),
             new FakeMediaSource(
-                SINGLE_PERIOD_TIMELINE,
-                ExoPlayerTestRunner.Builder.VIDEO_FORMAT,
-                ExoPlayerTestRunner.Builder.AUDIO_FORMAT),
-            new FakeMediaSource(
-                SINGLE_PERIOD_TIMELINE,
-                ExoPlayerTestRunner.Builder.VIDEO_FORMAT,
-                ExoPlayerTestRunner.Builder.AUDIO_FORMAT));
+                SINGLE_PERIOD_TIMELINE, Builder.VIDEO_FORMAT, Builder.AUDIO_FORMAT));
     TestAnalyticsListener listener = runAnalyticsTest(mediaSource);
 
     populateEventIds(listener.lastReportedTimeline);
@@ -200,8 +191,7 @@ public void testAutomaticPeriodTransition() throws Exception {
             WINDOW_0 /* BUFFERING */,
             period0 /* READY */,
             period1 /* ENDED */);
-    assertThat(listener.getEvents(EVENT_TIMELINE_CHANGED))
-        .containsExactly(WINDOW_0 /* PLAYLIST_CHANGED */, period0 /* DYNAMIC */);
+    assertThat(listener.getEvents(EVENT_TIMELINE_CHANGED)).containsExactly(WINDOW_0);
     assertThat(listener.getEvents(EVENT_POSITION_DISCONTINUITY)).containsExactly(period1);
     assertThat(listener.getEvents(EVENT_LOADING_CHANGED))
         .containsExactly(period0, period0, period0, period0);
@@ -243,8 +233,8 @@ public void testAutomaticPeriodTransition() throws Exception {
   public void testPeriodTransitionWithRendererChange() throws Exception {
     MediaSource mediaSource =
         new ConcatenatingMediaSource(
-            new FakeMediaSource(SINGLE_PERIOD_TIMELINE, ExoPlayerTestRunner.Builder.VIDEO_FORMAT),
-            new FakeMediaSource(SINGLE_PERIOD_TIMELINE, ExoPlayerTestRunner.Builder.AUDIO_FORMAT));
+            new FakeMediaSource(SINGLE_PERIOD_TIMELINE, Builder.VIDEO_FORMAT),
+            new FakeMediaSource(SINGLE_PERIOD_TIMELINE, Builder.AUDIO_FORMAT));
     TestAnalyticsListener listener = runAnalyticsTest(mediaSource);
 
     populateEventIds(listener.lastReportedTimeline);
@@ -256,8 +246,7 @@ public void testPeriodTransitionWithRendererChange() throws Exception {
             period1 /* BUFFERING */,
             period1 /* READY */,
             period1 /* ENDED */);
-    assertThat(listener.getEvents(EVENT_TIMELINE_CHANGED))
-        .containsExactly(WINDOW_0 /* PLAYLIST_CHANGED */, period0 /* DYNAMIC */);
+    assertThat(listener.getEvents(EVENT_TIMELINE_CHANGED)).containsExactly(WINDOW_0);
     assertThat(listener.getEvents(EVENT_POSITION_DISCONTINUITY)).containsExactly(period1);
     assertThat(listener.getEvents(EVENT_LOADING_CHANGED))
         .containsExactly(period0, period0, period0, period0);
@@ -297,8 +286,8 @@ public void testPeriodTransitionWithRendererChange() throws Exception {
   public void testSeekToOtherPeriod() throws Exception {
     MediaSource mediaSource =
         new ConcatenatingMediaSource(
-            new FakeMediaSource(SINGLE_PERIOD_TIMELINE, ExoPlayerTestRunner.Builder.VIDEO_FORMAT),
-            new FakeMediaSource(SINGLE_PERIOD_TIMELINE, ExoPlayerTestRunner.Builder.AUDIO_FORMAT));
+            new FakeMediaSource(SINGLE_PERIOD_TIMELINE, Builder.VIDEO_FORMAT),
+            new FakeMediaSource(SINGLE_PERIOD_TIMELINE, Builder.AUDIO_FORMAT));
     ActionSchedule actionSchedule =
         new ActionSchedule.Builder("AnalyticsCollectorTest")
             .pause()
@@ -319,8 +308,7 @@ public void testSeekToOtherPeriod() throws Exception {
             period1 /* READY */,
             period1 /* setPlayWhenReady=true */,
             period1 /* ENDED */);
-    assertThat(listener.getEvents(EVENT_TIMELINE_CHANGED))
-        .containsExactly(WINDOW_0 /* PLAYLIST_CHANGED */, period0 /* DYNAMIC */);
+    assertThat(listener.getEvents(EVENT_TIMELINE_CHANGED)).containsExactly(WINDOW_0);
     assertThat(listener.getEvents(EVENT_POSITION_DISCONTINUITY)).containsExactly(period1);
     assertThat(listener.getEvents(EVENT_SEEK_STARTED)).containsExactly(period0);
     assertThat(listener.getEvents(EVENT_SEEK_PROCESSED)).containsExactly(period1);
@@ -362,11 +350,9 @@ public void testSeekToOtherPeriod() throws Exception {
   public void testSeekBackAfterReadingAhead() throws Exception {
     MediaSource mediaSource =
         new ConcatenatingMediaSource(
-            new FakeMediaSource(SINGLE_PERIOD_TIMELINE, ExoPlayerTestRunner.Builder.VIDEO_FORMAT),
+            new FakeMediaSource(SINGLE_PERIOD_TIMELINE, Builder.VIDEO_FORMAT),
             new FakeMediaSource(
-                SINGLE_PERIOD_TIMELINE,
-                ExoPlayerTestRunner.Builder.VIDEO_FORMAT,
-                ExoPlayerTestRunner.Builder.AUDIO_FORMAT));
+                SINGLE_PERIOD_TIMELINE, Builder.VIDEO_FORMAT, Builder.AUDIO_FORMAT));
     long periodDurationMs =
         SINGLE_PERIOD_TIMELINE.getWindow(/* windowIndex= */ 0, new Window()).getDurationMs();
     ActionSchedule actionSchedule =
@@ -394,8 +380,7 @@ public void testSeekBackAfterReadingAhead() throws Exception {
             period1Seq2 /* BUFFERING */,
             period1Seq2 /* READY */,
             period1Seq2 /* ENDED */);
-    assertThat(listener.getEvents(EVENT_TIMELINE_CHANGED))
-        .containsExactly(WINDOW_0 /* PLAYLIST_CHANGED */, period0 /* DYNAMIC */);
+    assertThat(listener.getEvents(EVENT_TIMELINE_CHANGED)).containsExactly(WINDOW_0);
     assertThat(listener.getEvents(EVENT_POSITION_DISCONTINUITY))
         .containsExactly(period0, period1Seq2);
     assertThat(listener.getEvents(EVENT_SEEK_STARTED)).containsExactly(period0);
@@ -443,28 +428,18 @@ public void testSeekBackAfterReadingAhead() throws Exception {
 
   @Test
   public void testPrepareNewSource() throws Exception {
-    MediaSource mediaSource1 =
-        new FakeMediaSource(SINGLE_PERIOD_TIMELINE, ExoPlayerTestRunner.Builder.VIDEO_FORMAT);
-    MediaSource mediaSource2 =
-        new FakeMediaSource(SINGLE_PERIOD_TIMELINE, ExoPlayerTestRunner.Builder.VIDEO_FORMAT);
+    MediaSource mediaSource1 = new FakeMediaSource(SINGLE_PERIOD_TIMELINE, Builder.VIDEO_FORMAT);
+    MediaSource mediaSource2 = new FakeMediaSource(SINGLE_PERIOD_TIMELINE, Builder.VIDEO_FORMAT);
     ActionSchedule actionSchedule =
         new ActionSchedule.Builder("AnalyticsCollectorTest")
             .pause()
             .waitForPlaybackState(Player.STATE_READY)
-            .setMediaItems(/* resetPosition= */ false, mediaSource2)
+            .prepareSource(mediaSource2)
             .play()
             .build();
     TestAnalyticsListener listener = runAnalyticsTest(mediaSource1, actionSchedule);
 
-    // Populate all event ids with last timeline (after second prepare).
-    populateEventIds(listener.lastReportedTimeline);
-    // Populate event id of period 0, sequence 0 with timeline of initial preparation.
-    period0Seq0 =
-        new EventWindowAndPeriodId(
-            /* windowIndex= */ 0,
-            new MediaPeriodId(
-                listener.reportedTimelines.get(1).getUidOfPeriod(/* periodIndex= */ 0),
-                /* windowSequenceNumber= */ 0));
+    populateEventIds(SINGLE_PERIOD_TIMELINE);
     assertThat(listener.getEvents(EVENT_PLAYER_STATE_CHANGED))
         .containsExactly(
             WINDOW_0 /* setPlayWhenReady=true */,
@@ -476,16 +451,12 @@ public void testPrepareNewSource() throws Exception {
             period0Seq1 /* READY */,
             period0Seq1 /* ENDED */);
     assertThat(listener.getEvents(EVENT_TIMELINE_CHANGED))
-        .containsExactly(
-            WINDOW_0 /* PLAYLIST_CHANGE */,
-            WINDOW_0 /* DYNAMIC */,
-            WINDOW_0 /* PLAYLIST_CHANGE */,
-            WINDOW_0 /* DYNAMIC */);
+        .containsExactly(WINDOW_0 /* prepared */, WINDOW_0 /* reset */, WINDOW_0 /* prepared */);
     assertThat(listener.getEvents(EVENT_LOADING_CHANGED))
         .containsExactly(period0Seq0, period0Seq0, period0Seq1, period0Seq1);
     assertThat(listener.getEvents(EVENT_TRACKS_CHANGED))
         .containsExactly(
-            period0Seq0 /* prepared */, WINDOW_0 /* setMediaItems */, period0Seq1 /* prepared */);
+            period0Seq0 /* prepared */, WINDOW_0 /* reset */, period0Seq1 /* prepared */);
     assertThat(listener.getEvents(EVENT_LOAD_STARTED))
         .containsExactly(
             WINDOW_0 /* manifest */,
@@ -519,20 +490,19 @@ public void testPrepareNewSource() throws Exception {
 
   @Test
   public void testReprepareAfterError() throws Exception {
-    MediaSource mediaSource =
-        new FakeMediaSource(SINGLE_PERIOD_TIMELINE, ExoPlayerTestRunner.Builder.VIDEO_FORMAT);
+    MediaSource mediaSource = new FakeMediaSource(SINGLE_PERIOD_TIMELINE, Builder.VIDEO_FORMAT);
     ActionSchedule actionSchedule =
         new ActionSchedule.Builder("AnalyticsCollectorTest")
             .waitForPlaybackState(Player.STATE_READY)
             .throwPlaybackException(ExoPlaybackException.createForSource(new IOException()))
             .waitForPlaybackState(Player.STATE_IDLE)
             .seek(/* positionMs= */ 0)
-            .prepare()
+            .prepareSource(mediaSource, /* resetPosition= */ false, /* resetState= */ false)
             .waitForPlaybackState(Player.STATE_ENDED)
             .build();
     TestAnalyticsListener listener = runAnalyticsTest(mediaSource, actionSchedule);
 
-    populateEventIds(listener.lastReportedTimeline);
+    populateEventIds(SINGLE_PERIOD_TIMELINE);
     assertThat(listener.getEvents(EVENT_PLAYER_STATE_CHANGED))
         .containsExactly(
             WINDOW_0 /* setPlayWhenReady=true */,
@@ -586,7 +556,7 @@ public void testReprepareAfterError() throws Exception {
   @Test
   public void testDynamicTimelineChange() throws Exception {
     MediaSource childMediaSource =
-        new FakeMediaSource(SINGLE_PERIOD_TIMELINE, ExoPlayerTestRunner.Builder.VIDEO_FORMAT);
+        new FakeMediaSource(SINGLE_PERIOD_TIMELINE, Builder.VIDEO_FORMAT);
     final ConcatenatingMediaSource concatenatedMediaSource =
         new ConcatenatingMediaSource(childMediaSource, childMediaSource);
     long periodDurationMs =
@@ -618,11 +588,7 @@ public void testDynamicTimelineChange() throws Exception {
             period1Seq0 /* setPlayWhenReady=true */,
             period1Seq0 /* BUFFERING */,
             period1Seq0 /* ENDED */);
-    assertThat(listener.getEvents(EVENT_TIMELINE_CHANGED))
-        .containsExactly(
-            WINDOW_0 /* PLAYLIST_CHANGED */,
-            window0Period1Seq0 /* DYNAMIC (concatenated timeline replaces dummy) */,
-            period1Seq0 /* DYNAMIC (child sources in concatenating source moved) */);
+    assertThat(listener.getEvents(EVENT_TIMELINE_CHANGED)).containsExactly(WINDOW_0, period1Seq0);
     assertThat(listener.getEvents(EVENT_LOADING_CHANGED))
         .containsExactly(
             window0Period1Seq0, window0Period1Seq0, window0Period1Seq0, window0Period1Seq0);
@@ -676,7 +642,7 @@ public void run(SimpleExoPlayer player) {
             .build();
     TestAnalyticsListener listener = runAnalyticsTest(mediaSource, actionSchedule);
 
-    populateEventIds(listener.lastReportedTimeline);
+    populateEventIds(SINGLE_PERIOD_TIMELINE);
     assertThat(listener.getEvents(EVENT_SEEK_STARTED)).containsExactly(period0);
     assertThat(listener.getEvents(EVENT_SEEK_PROCESSED)).containsExactly(period0);
   }
@@ -743,7 +709,7 @@ private static TestAnalyticsListener runAnalyticsTest(
     TestAnalyticsListener listener = new TestAnalyticsListener();
     try {
       new ExoPlayerTestRunner.Builder()
-          .setMediaSources(mediaSource)
+          .setMediaSource(mediaSource)
           .setRenderersFactory(renderersFactory)
           .setAnalyticsListener(listener)
           .setActionSchedule(actionSchedule)
@@ -765,7 +731,7 @@ private static TestAnalyticsListener runAnalyticsTest(
     private boolean renderedFirstFrame;
 
     public FakeVideoRenderer(Handler handler, VideoRendererEventListener eventListener) {
-      super(ExoPlayerTestRunner.Builder.VIDEO_FORMAT);
+      super(Builder.VIDEO_FORMAT);
       eventDispatcher = new VideoRendererEventListener.EventDispatcher(handler, eventListener);
       decoderCounters = new DecoderCounters();
     }
@@ -823,7 +789,7 @@ protected void onBufferRead() {
     private boolean notifiedAudioSessionId;
 
     public FakeAudioRenderer(Handler handler, AudioRendererEventListener eventListener) {
-      super(ExoPlayerTestRunner.Builder.AUDIO_FORMAT);
+      super(Builder.AUDIO_FORMAT);
       eventDispatcher = new AudioRendererEventListener.EventDispatcher(handler, eventListener);
       decoderCounters = new DecoderCounters();
     }
@@ -907,12 +873,10 @@ public int hashCode() {
 
     public Timeline lastReportedTimeline;
 
-    private final List<Timeline> reportedTimelines;
     private final ArrayList<ReportedEvent> reportedEvents;
 
     public TestAnalyticsListener() {
       reportedEvents = new ArrayList<>();
-      reportedTimelines = new ArrayList<>();
       lastReportedTimeline = Timeline.EMPTY;
     }
 
@@ -942,7 +906,6 @@ public void onPlayerStateChanged(
     @Override
     public void onTimelineChanged(EventTime eventTime, int reason) {
       lastReportedTimeline = eventTime.timeline;
-      reportedTimelines.add(eventTime.timeline);
       reportedEvents.add(new ReportedEvent(EVENT_TIMELINE_CHANGED, eventTime));
     }
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/MetadataRendererTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/MetadataRendererTest.java
index de18d370ec..1ad0ce6b79 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/MetadataRendererTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/MetadataRendererTest.java
@@ -78,20 +78,13 @@ public void decodeMetadata() throws Exception {
             /* id= */ 0,
             "Test data".getBytes(UTF_8));
 
-    List<Metadata> metadata = runRenderer(EMSG_FORMAT, eventMessageEncoder.encode(emsg));
+    List<Metadata> metadata = runRenderer(eventMessageEncoder.encode(emsg));
 
     assertThat(metadata).hasSize(1);
     assertThat(metadata.get(0).length()).isEqualTo(1);
     assertThat(metadata.get(0).get(0)).isEqualTo(emsg);
   }
 
-  @Test
-  public void decodeMetadata_skipsMalformed() throws Exception {
-    List<Metadata> metadata = runRenderer(EMSG_FORMAT, "not valid emsg bytes".getBytes(UTF_8));
-
-    assertThat(metadata).isEmpty();
-  }
-
   @Test
   public void decodeMetadata_handlesId3WrappedInEmsg() throws Exception {
     EventMessage emsg =
@@ -102,7 +95,7 @@ public void decodeMetadata_handlesId3WrappedInEmsg() throws Exception {
             /* id= */ 0,
             encodeTxxxId3Frame("Test description", "Test value"));
 
-    List<Metadata> metadata = runRenderer(EMSG_FORMAT, eventMessageEncoder.encode(emsg));
+    List<Metadata> metadata = runRenderer(eventMessageEncoder.encode(emsg));
 
     assertThat(metadata).hasSize(1);
     assertThat(metadata.get(0).length()).isEqualTo(1);
@@ -122,7 +115,7 @@ public void decodeMetadata_handlesScte35WrappedInEmsg() throws Exception {
             /* id= */ 0,
             SCTE35_TIME_SIGNAL_BYTES);
 
-    List<Metadata> metadata = runRenderer(EMSG_FORMAT, eventMessageEncoder.encode(emsg));
+    List<Metadata> metadata = runRenderer(eventMessageEncoder.encode(emsg));
 
     assertThat(metadata).hasSize(1);
     assertThat(metadata.get(0).length()).isEqualTo(1);
@@ -139,18 +132,17 @@ public void decodeMetadata_skipsMalformedWrappedMetadata() throws Exception {
             /* id= */ 0,
             "Not a real ID3 tag".getBytes(ISO_8859_1));
 
-    List<Metadata> metadata = runRenderer(EMSG_FORMAT, eventMessageEncoder.encode(emsg));
+    List<Metadata> metadata = runRenderer(eventMessageEncoder.encode(emsg));
 
     assertThat(metadata).isEmpty();
   }
 
-  private static List<Metadata> runRenderer(Format format, byte[] input)
-      throws ExoPlaybackException {
+  private static List<Metadata> runRenderer(byte[] input) throws ExoPlaybackException {
     List<Metadata> metadata = new ArrayList<>();
     MetadataRenderer renderer = new MetadataRenderer(metadata::add, /* outputLooper= */ null);
     renderer.replaceStream(
-        new Format[] {format},
-        new FakeSampleStream(format, /* eventDispatcher= */ null, input),
+        new Format[] {EMSG_FORMAT},
+        new FakeSampleStream(EMSG_FORMAT, /* eventDispatcher= */ null, input),
         /* offsetUs= */ 0L);
     renderer.render(/* positionUs= */ 0, /* elapsedRealtimeUs= */ 0); // Read the format
     renderer.render(/* positionUs= */ 0, /* elapsedRealtimeUs= */ 0); // Read the data
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyDecoderTest.java
index 4602d172a6..72237d665c 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyDecoderTest.java
@@ -29,10 +29,12 @@
   @Test
   public void decode() {
     IcyDecoder decoder = new IcyDecoder();
-    Metadata metadata = decoder.decode("StreamTitle='test title';StreamURL='test_url';");
+    String icyContent = "StreamTitle='test title';StreamURL='test_url';";
+    Metadata metadata = decoder.decode(icyContent);
 
     assertThat(metadata.length()).isEqualTo(1);
     IcyInfo streamInfo = (IcyInfo) metadata.get(0);
+    assertThat(streamInfo.rawMetadata).isEqualTo(icyContent);
     assertThat(streamInfo.title).isEqualTo("test title");
     assertThat(streamInfo.url).isEqualTo("test_url");
   }
@@ -40,21 +42,39 @@ public void decode() {
   @Test
   public void decode_titleOnly() {
     IcyDecoder decoder = new IcyDecoder();
-    Metadata metadata = decoder.decode("StreamTitle='test title';");
+    String icyContent = "StreamTitle='test title';";
+    Metadata metadata = decoder.decode(icyContent);
 
     assertThat(metadata.length()).isEqualTo(1);
     IcyInfo streamInfo = (IcyInfo) metadata.get(0);
+    assertThat(streamInfo.rawMetadata).isEqualTo(icyContent);
     assertThat(streamInfo.title).isEqualTo("test title");
     assertThat(streamInfo.url).isNull();
   }
 
+  @Test
+  public void decode_extraTags() {
+    String icyContent =
+        "StreamTitle='test title';StreamURL='test_url';CustomTag|withWeirdSeparator";
+    IcyDecoder decoder = new IcyDecoder();
+    Metadata metadata = decoder.decode(icyContent);
+
+    assertThat(metadata.length()).isEqualTo(1);
+    IcyInfo streamInfo = (IcyInfo) metadata.get(0);
+    assertThat(streamInfo.rawMetadata).isEqualTo(icyContent);
+    assertThat(streamInfo.title).isEqualTo("test title");
+    assertThat(streamInfo.url).isEqualTo("test_url");
+  }
+
   @Test
   public void decode_emptyTitle() {
     IcyDecoder decoder = new IcyDecoder();
-    Metadata metadata = decoder.decode("StreamTitle='';StreamURL='test_url';");
+    String icyContent = "StreamTitle='';StreamURL='test_url';";
+    Metadata metadata = decoder.decode(icyContent);
 
     assertThat(metadata.length()).isEqualTo(1);
     IcyInfo streamInfo = (IcyInfo) metadata.get(0);
+    assertThat(streamInfo.rawMetadata).isEqualTo(icyContent);
     assertThat(streamInfo.title).isEmpty();
     assertThat(streamInfo.url).isEqualTo("test_url");
   }
@@ -62,10 +82,12 @@ public void decode_emptyTitle() {
   @Test
   public void decode_semiColonInTitle() {
     IcyDecoder decoder = new IcyDecoder();
-    Metadata metadata = decoder.decode("StreamTitle='test; title';StreamURL='test_url';");
+    String icyContent = "StreamTitle='test; title';StreamURL='test_url';";
+    Metadata metadata = decoder.decode(icyContent);
 
     assertThat(metadata.length()).isEqualTo(1);
     IcyInfo streamInfo = (IcyInfo) metadata.get(0);
+    assertThat(streamInfo.rawMetadata).isEqualTo(icyContent);
     assertThat(streamInfo.title).isEqualTo("test; title");
     assertThat(streamInfo.url).isEqualTo("test_url");
   }
@@ -73,10 +95,12 @@ public void decode_semiColonInTitle() {
   @Test
   public void decode_quoteInTitle() {
     IcyDecoder decoder = new IcyDecoder();
-    Metadata metadata = decoder.decode("StreamTitle='test' title';StreamURL='test_url';");
+    String icyContent = "StreamTitle='test' title';StreamURL='test_url';";
+    Metadata metadata = decoder.decode(icyContent);
 
     assertThat(metadata.length()).isEqualTo(1);
     IcyInfo streamInfo = (IcyInfo) metadata.get(0);
+    assertThat(streamInfo.rawMetadata).isEqualTo(icyContent);
     assertThat(streamInfo.title).isEqualTo("test' title");
     assertThat(streamInfo.url).isEqualTo("test_url");
   }
@@ -84,19 +108,25 @@ public void decode_quoteInTitle() {
   @Test
   public void decode_lineTerminatorInTitle() {
     IcyDecoder decoder = new IcyDecoder();
-    Metadata metadata = decoder.decode("StreamTitle='test\r\ntitle';StreamURL='test_url';");
+    String icyContent = "StreamTitle='test\r\ntitle';StreamURL='test_url';";
+    Metadata metadata = decoder.decode(icyContent);
 
     assertThat(metadata.length()).isEqualTo(1);
     IcyInfo streamInfo = (IcyInfo) metadata.get(0);
+    assertThat(streamInfo.rawMetadata).isEqualTo(icyContent);
     assertThat(streamInfo.title).isEqualTo("test\r\ntitle");
     assertThat(streamInfo.url).isEqualTo("test_url");
   }
 
   @Test
-  public void decode_notIcy() {
+  public void decode_noReconisedHeaders() {
     IcyDecoder decoder = new IcyDecoder();
     Metadata metadata = decoder.decode("NotIcyData");
 
-    assertThat(metadata).isNull();
+    assertThat(metadata.length()).isEqualTo(1);
+    IcyInfo streamInfo = (IcyInfo) metadata.get(0);
+    assertThat(streamInfo.rawMetadata).isEqualTo("NotIcyData");
+    assertThat(streamInfo.title).isNull();
+    assertThat(streamInfo.url).isNull();
   }
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyStreamInfoTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyInfoTest.java
similarity index 91%
rename from library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyStreamInfoTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyInfoTest.java
index 2bffe171d3..2c8e6616c9 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyStreamInfoTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/icy/IcyInfoTest.java
@@ -24,11 +24,11 @@
 
 /** Test for {@link IcyInfo}. */
 @RunWith(AndroidJUnit4.class)
-public final class IcyStreamInfoTest {
+public final class IcyInfoTest {
 
   @Test
   public void parcelEquals() {
-    IcyInfo streamInfo = new IcyInfo("name", "url");
+    IcyInfo streamInfo = new IcyInfo("StreamName='name';StreamUrl='url'", "name", "url");
     // Write to parcel.
     Parcel parcel = Parcel.obtain();
     streamInfo.writeToParcel(parcel, 0);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java
index 89acb3ec3e..532ad61b85 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java
@@ -64,7 +64,12 @@ public void setUp() throws Exception {
 
   @Test
   public void testNoClipping() throws IOException {
-    Timeline timeline = new SinglePeriodTimeline(TEST_PERIOD_DURATION_US, true, false);
+    Timeline timeline =
+        new SinglePeriodTimeline(
+            TEST_PERIOD_DURATION_US,
+            /* isSeekable= */ true,
+            /* isDynamic= */ false,
+            /* isLive= */ false);
 
     Timeline clippedTimeline = getClippedTimeline(timeline, 0, TEST_PERIOD_DURATION_US);
 
@@ -78,7 +83,12 @@ public void testNoClipping() throws IOException {
 
   @Test
   public void testClippingUnseekableWindowThrows() throws IOException {
-    Timeline timeline = new SinglePeriodTimeline(TEST_PERIOD_DURATION_US, false, false);
+    Timeline timeline =
+        new SinglePeriodTimeline(
+            TEST_PERIOD_DURATION_US,
+            /* isSeekable= */ false,
+            /* isDynamic= */ false,
+            /* isLive= */ false);
 
     // If the unseekable window isn't clipped, clipping succeeds.
     getClippedTimeline(timeline, 0, TEST_PERIOD_DURATION_US);
@@ -93,7 +103,12 @@ public void testClippingUnseekableWindowThrows() throws IOException {
 
   @Test
   public void testClippingStart() throws IOException {
-    Timeline timeline = new SinglePeriodTimeline(TEST_PERIOD_DURATION_US, true, false);
+    Timeline timeline =
+        new SinglePeriodTimeline(
+            TEST_PERIOD_DURATION_US,
+            /* isSeekable= */ true,
+            /* isDynamic= */ false,
+            /* isLive= */ false);
 
     Timeline clippedTimeline =
         getClippedTimeline(timeline, TEST_CLIP_AMOUNT_US, TEST_PERIOD_DURATION_US);
@@ -105,7 +120,12 @@ public void testClippingStart() throws IOException {
 
   @Test
   public void testClippingEnd() throws IOException {
-    Timeline timeline = new SinglePeriodTimeline(TEST_PERIOD_DURATION_US, true, false);
+    Timeline timeline =
+        new SinglePeriodTimeline(
+            TEST_PERIOD_DURATION_US,
+            /* isSeekable= */ true,
+            /* isDynamic= */ false,
+            /* isLive= */ false);
 
     Timeline clippedTimeline =
         getClippedTimeline(timeline, 0, TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US);
@@ -121,7 +141,8 @@ public void testClippingStartAndEndInitial() throws IOException {
     // to it having loaded sufficient data to establish its duration and seekability. Such timelines
     // should not result in clipping failure.
     Timeline timeline =
-        new SinglePeriodTimeline(C.TIME_UNSET, /* isSeekable= */ false, /* isDynamic= */ true);
+        new SinglePeriodTimeline(
+            C.TIME_UNSET, /* isSeekable= */ false, /* isDynamic= */ true, /* isLive= */ true);
 
     Timeline clippedTimeline =
         getClippedTimeline(
@@ -139,7 +160,8 @@ public void testClippingToEndOfSourceWithDurationSetsDuration() throws IOExcepti
         new SinglePeriodTimeline(
             /* durationUs= */ TEST_PERIOD_DURATION_US,
             /* isSeekable= */ true,
-            /* isDynamic= */ false);
+            /* isDynamic= */ false,
+            /* isLive= */ false);
 
     // When clipping to the end, the clipped timeline should also have a duration.
     Timeline clippedTimeline =
@@ -153,7 +175,10 @@ public void testClippingToEndOfSourceWithUnsetDurationDoesNotSetDuration() throw
     // Create a child timeline that has an unknown duration.
     Timeline timeline =
         new SinglePeriodTimeline(
-            /* durationUs= */ C.TIME_UNSET, /* isSeekable= */ true, /* isDynamic= */ false);
+            /* durationUs= */ C.TIME_UNSET,
+            /* isSeekable= */ true,
+            /* isDynamic= */ false,
+            /* isLive= */ false);
 
     // When clipping to the end, the clipped timeline should also have an unset duration.
     Timeline clippedTimeline =
@@ -164,7 +189,12 @@ public void testClippingToEndOfSourceWithUnsetDurationDoesNotSetDuration() throw
 
   @Test
   public void testClippingStartAndEnd() throws IOException {
-    Timeline timeline = new SinglePeriodTimeline(TEST_PERIOD_DURATION_US, true, false);
+    Timeline timeline =
+        new SinglePeriodTimeline(
+            TEST_PERIOD_DURATION_US,
+            /* isSeekable= */ true,
+            /* isDynamic= */ false,
+            /* isLive= */ false);
 
     Timeline clippedTimeline =
         getClippedTimeline(
@@ -185,6 +215,7 @@ public void testClippingFromDefaultPosition() throws IOException {
             /* windowDefaultStartPositionUs= */ TEST_CLIP_AMOUNT_US,
             /* isSeekable= */ true,
             /* isDynamic= */ true,
+            /* isLive= */ true,
             /* manifest= */ null,
             /* tag= */ null);
 
@@ -207,6 +238,7 @@ public void testAllowDynamicUpdatesWithOverlappingLiveWindow() throws IOExceptio
             /* windowDefaultStartPositionUs= */ TEST_CLIP_AMOUNT_US,
             /* isSeekable= */ true,
             /* isDynamic= */ true,
+            /* isLive= */ true,
             /* manifest= */ null,
             /* tag= */ null);
     Timeline timeline2 =
@@ -217,6 +249,7 @@ public void testAllowDynamicUpdatesWithOverlappingLiveWindow() throws IOExceptio
             /* windowDefaultStartPositionUs= */ TEST_CLIP_AMOUNT_US,
             /* isSeekable= */ true,
             /* isDynamic= */ true,
+            /* isLive= */ true,
             /* manifest= */ null,
             /* tag= */ null);
 
@@ -256,6 +289,7 @@ public void testAllowDynamicUpdatesWithNonOverlappingLiveWindow() throws IOExcep
             /* windowDefaultStartPositionUs= */ TEST_CLIP_AMOUNT_US,
             /* isSeekable= */ true,
             /* isDynamic= */ true,
+            /* isLive= */ true,
             /* manifest= */ null,
             /* tag= */ null);
     Timeline timeline2 =
@@ -266,6 +300,7 @@ public void testAllowDynamicUpdatesWithNonOverlappingLiveWindow() throws IOExcep
             /* windowDefaultStartPositionUs= */ TEST_CLIP_AMOUNT_US,
             /* isSeekable= */ true,
             /* isDynamic= */ true,
+            /* isLive= */ true,
             /* manifest= */ null,
             /* tag= */ null);
 
@@ -305,6 +340,7 @@ public void testDisallowDynamicUpdatesWithOverlappingLiveWindow() throws IOExcep
             /* windowDefaultStartPositionUs= */ TEST_CLIP_AMOUNT_US,
             /* isSeekable= */ true,
             /* isDynamic= */ true,
+            /* isLive= */ true,
             /* manifest= */ null,
             /* tag= */ null);
     Timeline timeline2 =
@@ -315,6 +351,7 @@ public void testDisallowDynamicUpdatesWithOverlappingLiveWindow() throws IOExcep
             /* windowDefaultStartPositionUs= */ TEST_CLIP_AMOUNT_US,
             /* isSeekable= */ true,
             /* isDynamic= */ true,
+            /* isLive= */ true,
             /* manifest= */ null,
             /* tag= */ null);
 
@@ -355,6 +392,7 @@ public void testDisallowDynamicUpdatesWithNonOverlappingLiveWindow() throws IOEx
             /* windowDefaultStartPositionUs= */ TEST_CLIP_AMOUNT_US,
             /* isSeekable= */ true,
             /* isDynamic= */ true,
+            /* isLive= */ true,
             /* manifest= */ null,
             /* tag= */ null);
     Timeline timeline2 =
@@ -365,6 +403,7 @@ public void testDisallowDynamicUpdatesWithNonOverlappingLiveWindow() throws IOEx
             /* windowDefaultStartPositionUs= */ TEST_CLIP_AMOUNT_US,
             /* isSeekable= */ true,
             /* isDynamic= */ true,
+            /* isLive= */ true,
             /* manifest= */ null,
             /* tag= */ null);
 
@@ -480,7 +519,10 @@ private static MediaLoadData getClippingMediaSourceMediaLoadData(
       throws IOException {
     Timeline timeline =
         new SinglePeriodTimeline(
-            TEST_PERIOD_DURATION_US, /* isSeekable= */ true, /* isDynamic= */ false);
+            TEST_PERIOD_DURATION_US,
+            /* isSeekable= */ true,
+            /* isDynamic= */ false,
+            /* isLive= */ false);
     FakeMediaSource fakeMediaSource =
         new FakeMediaSource(timeline) {
           @Override
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/CompositeSequenceableLoaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/CompositeSequenceableLoaderTest.java
index 4a881d53b4..c996aadddb 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/CompositeSequenceableLoaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/CompositeSequenceableLoaderTest.java
@@ -261,6 +261,11 @@ public boolean continueLoading(long positionUs) {
       return loaded;
     }
 
+    @Override
+    public boolean isLoading() {
+      return nextChunkDurationUs != 0;
+    }
+
     @Override
     public void reevaluateBuffer(long positionUs) {
       // Do nothing.
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/SinglePeriodTimelineTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/SinglePeriodTimelineTest.java
index cb21db8212..6ff4f78fa2 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/SinglePeriodTimelineTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/SinglePeriodTimelineTest.java
@@ -41,7 +41,9 @@ public void setUp() throws Exception {
 
   @Test
   public void testGetPeriodPositionDynamicWindowUnknownDuration() {
-    SinglePeriodTimeline timeline = new SinglePeriodTimeline(C.TIME_UNSET, false, true);
+    SinglePeriodTimeline timeline =
+        new SinglePeriodTimeline(
+            C.TIME_UNSET, /* isSeekable= */ false, /* isDynamic= */ true, /* isLive= */ true);
     // Should return null with any positive position projection.
     Pair<Object, Long> position = timeline.getPeriodPosition(window, period, 0, C.TIME_UNSET, 1);
     assertThat(position).isNull();
@@ -62,6 +64,7 @@ public void testGetPeriodPositionDynamicWindowKnownDuration() {
             /* windowDefaultStartPositionUs= */ 0,
             /* isSeekable= */ false,
             /* isDynamic= */ true,
+            /* isLive= */ true,
             /* manifest= */ null,
             /* tag= */ null);
     // Should return null with a positive position projection beyond window duration.
@@ -85,6 +88,7 @@ public void setNullTag_returnsNullTag_butUsesDefaultUid() {
             /* durationUs= */ C.TIME_UNSET,
             /* isSeekable= */ false,
             /* isDynamic= */ false,
+            /* isLive= */ false,
             /* manifest= */ null,
             /* tag= */ null);
 
@@ -104,6 +108,7 @@ public void getWindow_setsTag() {
             /* durationUs= */ C.TIME_UNSET,
             /* isSeekable= */ false,
             /* isDynamic= */ false,
+            /* isLive= */ false,
             /* manifest= */ null,
             tag);
 
@@ -117,6 +122,7 @@ public void getIndexOfPeriod_returnsPeriod() {
             /* durationUs= */ C.TIME_UNSET,
             /* isSeekable= */ false,
             /* isDynamic= */ false,
+            /* isLive= */ false,
             /* manifest= */ null,
             /* tag= */ null);
     Object uid = timeline.getPeriod(/* periodIndex= */ 0, period, /* setIds= */ true).uid;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSpecTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSpecTest.java
index f6e30f814a..2323dfe965 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSpecTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSpecTest.java
@@ -98,31 +98,87 @@ public void httpRequestParameters_areReadOnly() {
   }
 
   @Test
-  public void copyMethods_copiesHttpRequestHeaders() {
-    Map<String, String> httpRequestParameters = new HashMap<>();
-    httpRequestParameters.put("key1", "value1");
-    httpRequestParameters.put("key2", "value2");
-    httpRequestParameters.put("key3", "value3");
-
-    DataSpec dataSpec =
-        new DataSpec(
-            Uri.parse("www.google.com"),
-            /* httpMethod= */ 0,
-            /* httpBody= */ new byte[] {0, 0, 0, 0},
-            /* absoluteStreamPosition= */ 0,
-            /* position= */ 0,
-            /* length= */ 1,
-            /* key= */ "key",
-            /* flags= */ 0,
-            httpRequestParameters);
+  public void withUri_copiesHttpRequestHeaders() {
+    Map<String, String> httpRequestProperties = createRequestProperties(5);
+    DataSpec dataSpec = createDataSpecWithHeaders(httpRequestProperties);
 
     DataSpec dataSpecCopy = dataSpec.withUri(Uri.parse("www.new-uri.com"));
-    assertThat(dataSpecCopy.httpRequestHeaders).isEqualTo(httpRequestParameters);
 
-    dataSpecCopy = dataSpec.subrange(2);
-    assertThat(dataSpecCopy.httpRequestHeaders).isEqualTo(httpRequestParameters);
+    assertThat(dataSpecCopy.httpRequestHeaders).isEqualTo(httpRequestProperties);
+  }
+
+  @Test
+  public void subrange_copiesHttpRequestHeaders() {
+    Map<String, String> httpRequestProperties = createRequestProperties(5);
+    DataSpec dataSpec = createDataSpecWithHeaders(httpRequestProperties);
+
+    DataSpec dataSpecCopy = dataSpec.subrange(2);
+
+    assertThat(dataSpecCopy.httpRequestHeaders).isEqualTo(httpRequestProperties);
+  }
+
+  @Test
+  public void subrange_withOffsetAndLength_copiesHttpRequestHeaders() {
+    Map<String, String> httpRequestProperties = createRequestProperties(5);
+    DataSpec dataSpec = createDataSpecWithHeaders(httpRequestProperties);
+
+    DataSpec dataSpecCopy = dataSpec.subrange(2, 2);
+
+    assertThat(dataSpecCopy.httpRequestHeaders).isEqualTo(httpRequestProperties);
+  }
+
+  @Test
+  public void withRequestHeaders_setsCorrectHeaders() {
+    Map<String, String> httpRequestProperties = createRequestProperties(5);
+    DataSpec dataSpec = createDataSpecWithHeaders(httpRequestProperties);
+
+    Map<String, String> newRequestHeaders = createRequestProperties(5, 10);
+    DataSpec dataSpecCopy = dataSpec.withRequestHeaders(newRequestHeaders);
+
+    assertThat(dataSpecCopy.httpRequestHeaders).isEqualTo(newRequestHeaders);
+  }
+
+  @Test
+  public void withAdditionalHeaders_setsCorrectHeaders() {
+    Map<String, String> httpRequestProperties = createRequestProperties(5);
+    DataSpec dataSpec = createDataSpecWithHeaders(httpRequestProperties);
+    Map<String, String> additionalHeaders = createRequestProperties(5, 10);
+    // additionalHeaders may overwrite a header key
+    String existingKey = httpRequestProperties.keySet().iterator().next();
+    additionalHeaders.put(existingKey, "overwritten");
+    Map<String, String> expectedHeaders = new HashMap<>(httpRequestProperties);
+    expectedHeaders.putAll(additionalHeaders);
+
+    DataSpec dataSpecCopy = dataSpec.withAdditionalHeaders(additionalHeaders);
+
+    assertThat(dataSpecCopy.httpRequestHeaders).isEqualTo(expectedHeaders);
+  }
+
+  private static Map<String, String> createRequestProperties(int howMany) {
+    return createRequestProperties(0, howMany);
+  }
+
+  private static Map<String, String> createRequestProperties(int from, int to) {
+    assertThat(from).isLessThan(to);
+
+    Map<String, String> httpRequestParameters = new HashMap<>();
+    for (int i = from; i < to; i++) {
+      httpRequestParameters.put("key-" + i, "value-" + i);
+    }
+
+    return httpRequestParameters;
+  }
 
-    dataSpecCopy = dataSpec.subrange(2, 2);
-    assertThat(dataSpecCopy.httpRequestHeaders).isEqualTo(httpRequestParameters);
+  private static DataSpec createDataSpecWithHeaders(Map<String, String> httpRequestProperties) {
+    return new DataSpec(
+        Uri.parse("www.google.com"),
+        /* httpMethod= */ 0,
+        /* httpBody= */ new byte[] {0, 0, 0, 0},
+        /* absoluteStreamPosition= */ 0,
+        /* position= */ 0,
+        /* length= */ 1,
+        /* key= */ "key",
+        /* flags= */ 0,
+        httpRequestProperties);
   }
 }
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
index d62474cb1b..bb8226e172 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
@@ -297,6 +297,11 @@ public boolean continueLoading(long positionUs) {
     return compositeSequenceableLoader.continueLoading(positionUs);
   }
 
+  @Override
+  public boolean isLoading() {
+    return compositeSequenceableLoader.isLoading();
+  }
+
   @Override
   public long getNextLoadPositionUs() {
     return compositeSequenceableLoader.getNextLoadPositionUs();
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
index ac7dcc3737..352131d70a 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
@@ -657,6 +657,7 @@ public Object getTag() {
   @Override
   protected void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
     this.mediaTransferListener = mediaTransferListener;
+    drmSessionManager.prepare();
     if (sideloadedManifest) {
       processManifest(false);
     } else {
@@ -726,6 +727,7 @@ protected void releaseSourceInternal() {
     expiredManifestPublishTimeUs = C.TIME_UNSET;
     firstPeriodId = 0;
     periodsById.clear();
+    drmSessionManager.release();
   }
 
   // PlayerEmsgCallback callbacks.
@@ -1214,10 +1216,6 @@ public Window getWindow(int windowIndex, Window window, long defaultPositionProj
       Assertions.checkIndex(windowIndex, 0, 1);
       long windowDefaultStartPositionUs = getAdjustedWindowDefaultStartPositionUs(
           defaultPositionProjectionUs);
-      boolean isDynamic =
-          manifest.dynamic
-              && manifest.minUpdatePeriodMs != C.TIME_UNSET
-              && manifest.durationMs == C.TIME_UNSET;
       return window.set(
           Window.SINGLE_WINDOW_UID,
           windowTag,
@@ -1225,7 +1223,8 @@ public Window getWindow(int windowIndex, Window window, long defaultPositionProj
           presentationStartTimeMs,
           windowStartTimeMs,
           /* isSeekable= */ true,
-          isDynamic,
+          /* isDynamic= */ isMovingLiveWindow(manifest),
+          /* isLive= */ manifest.dynamic,
           windowDefaultStartPositionUs,
           windowDurationUs,
           /* firstPeriodIndex= */ 0,
@@ -1245,7 +1244,7 @@ public int getIndexOfPeriod(Object uid) {
 
     private long getAdjustedWindowDefaultStartPositionUs(long defaultPositionProjectionUs) {
       long windowDefaultStartPositionUs = this.windowDefaultStartPositionUs;
-      if (!manifest.dynamic) {
+      if (!isMovingLiveWindow(manifest)) {
         return windowDefaultStartPositionUs;
       }
       if (defaultPositionProjectionUs > 0) {
@@ -1290,6 +1289,12 @@ public Object getUidOfPeriod(int periodIndex) {
       Assertions.checkIndex(periodIndex, 0, getPeriodCount());
       return firstPeriodId + periodIndex;
     }
+
+    private static boolean isMovingLiveWindow(DashManifest manifest) {
+      return manifest.dynamic
+          && manifest.minUpdatePeriodMs != C.TIME_UNSET
+          && manifest.durationMs == C.TIME_UNSET;
+    }
   }
 
   private final class DefaultPlayerEmsgCallback implements PlayerEmsgCallback {
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/PlayerEmsgHandler.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/PlayerEmsgHandler.java
index 883ca7420e..af4bf3ad70 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/PlayerEmsgHandler.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/PlayerEmsgHandler.java
@@ -360,9 +360,6 @@ private void parseAndDiscardSamples() {
         }
         long eventTimeUs = inputBuffer.timeUs;
         Metadata metadata = decoder.decode(inputBuffer);
-        if (metadata == null) {
-          continue;
-        }
         EventMessage eventMessage = (EventMessage) metadata.get(0);
         if (isPlayerEmsgEvent(eventMessage.schemeIdUri, eventMessage.value)) {
           parsePlayerEmsgEvent(eventTimeUs, eventMessage);
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
index 6feb529958..d225f65cea 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
@@ -316,7 +316,6 @@ protected AdaptationSet parseAdaptationSet(
             parseRepresentation(
                 xpp,
                 baseUrl,
-                label,
                 mimeType,
                 codecs,
                 width,
@@ -343,6 +342,8 @@ protected AdaptationSet parseAdaptationSet(
                 xpp, (SegmentTemplate) segmentBase, supplementalProperties, periodDurationMs);
       } else if (XmlPullParserUtil.isStartTag(xpp, "InbandEventStream")) {
         inbandEventStreams.add(parseDescriptor(xpp, "InbandEventStream"));
+      } else if (XmlPullParserUtil.isStartTag(xpp, "Label")) {
+        label = parseLabel(xpp);
       } else if (XmlPullParserUtil.isStartTag(xpp)) {
         parseAdaptationSetChild(xpp);
       }
@@ -353,7 +354,11 @@ protected AdaptationSet parseAdaptationSet(
     for (int i = 0; i < representationInfos.size(); i++) {
       representations.add(
           buildRepresentation(
-              representationInfos.get(i), drmSchemeType, drmSchemeDatas, inbandEventStreams));
+              representationInfos.get(i),
+              label,
+              drmSchemeType,
+              drmSchemeDatas,
+              inbandEventStreams));
     }
 
     return buildAdaptationSet(id, contentType, representations, accessibilityDescriptors,
@@ -482,7 +487,6 @@ protected void parseAdaptationSetChild(XmlPullParser xpp)
   protected RepresentationInfo parseRepresentation(
       XmlPullParser xpp,
       String baseUrl,
-      @Nullable String label,
       @Nullable String adaptationSetMimeType,
       @Nullable String adaptationSetCodecs,
       int adaptationSetWidth,
@@ -553,7 +557,6 @@ protected RepresentationInfo parseRepresentation(
     Format format =
         buildFormat(
             id,
-            label,
             mimeType,
             width,
             height,
@@ -574,7 +577,6 @@ protected RepresentationInfo parseRepresentation(
 
   protected Format buildFormat(
       @Nullable String id,
-      @Nullable String label,
       @Nullable String containerMimeType,
       int width,
       int height,
@@ -598,7 +600,7 @@ protected Format buildFormat(
       if (MimeTypes.isVideo(sampleMimeType)) {
         return Format.createVideoContainerFormat(
             id,
-            label,
+            /* label= */ null,
             containerMimeType,
             sampleMimeType,
             codecs,
@@ -613,7 +615,7 @@ protected Format buildFormat(
       } else if (MimeTypes.isAudio(sampleMimeType)) {
         return Format.createAudioContainerFormat(
             id,
-            label,
+            /* label= */ null,
             containerMimeType,
             sampleMimeType,
             codecs,
@@ -636,7 +638,7 @@ protected Format buildFormat(
         }
         return Format.createTextContainerFormat(
             id,
-            label,
+            /* label= */ null,
             containerMimeType,
             sampleMimeType,
             codecs,
@@ -649,7 +651,7 @@ protected Format buildFormat(
     }
     return Format.createContainerFormat(
         id,
-        label,
+        /* label= */ null,
         containerMimeType,
         sampleMimeType,
         codecs,
@@ -661,10 +663,14 @@ protected Format buildFormat(
 
   protected Representation buildRepresentation(
       RepresentationInfo representationInfo,
+      @Nullable String label,
       @Nullable String extraDrmSchemeType,
       ArrayList<SchemeData> extraDrmSchemeDatas,
       ArrayList<Descriptor> extraInbandEventStreams) {
     Format format = representationInfo.format;
+    if (label != null) {
+      format = format.copyWithLabel(label);
+    }
     String drmSchemeType = representationInfo.drmSchemeType != null
         ? representationInfo.drmSchemeType : extraDrmSchemeType;
     ArrayList<SchemeData> drmSchemeDatas = representationInfo.drmSchemeDatas;
@@ -1132,6 +1138,32 @@ protected ProgramInformation parseProgramInformation(XmlPullParser xpp)
     return new ProgramInformation(title, source, copyright, moreInformationURL, lang);
   }
 
+  /**
+   * Parses a Label element.
+   *
+   * @param xpp The parser from which to read.
+   * @throws XmlPullParserException If an error occurs parsing the element.
+   * @throws IOException If an error occurs reading the element.
+   * @return The parsed label.
+   */
+  protected String parseLabel(XmlPullParser xpp) throws XmlPullParserException, IOException {
+    return parseText(xpp, "Label");
+  }
+
+  /**
+   * Parses a BaseURL element.
+   *
+   * @param xpp The parser from which to read.
+   * @param parentBaseUrl A base URL for resolving the parsed URL.
+   * @throws XmlPullParserException If an error occurs parsing the element.
+   * @throws IOException If an error occurs reading the element.
+   * @return The parsed and resolved URL.
+   */
+  protected String parseBaseUrl(XmlPullParser xpp, String parentBaseUrl)
+      throws XmlPullParserException, IOException {
+    return UriUtil.resolve(parentBaseUrl, parseText(xpp, "BaseURL"));
+  }
+
   // AudioChannelConfiguration parsing.
 
   protected int parseAudioChannelConfiguration(XmlPullParser xpp)
@@ -1487,10 +1519,18 @@ protected static long parseDateTime(XmlPullParser xpp, String name, long default
     }
   }
 
-  protected static String parseBaseUrl(XmlPullParser xpp, String parentBaseUrl)
+  protected static String parseText(XmlPullParser xpp, String label)
       throws XmlPullParserException, IOException {
-    xpp.next();
-    return UriUtil.resolve(parentBaseUrl, xpp.getText());
+    String text = "";
+    do {
+      xpp.next();
+      if (xpp.getEventType() == XmlPullParser.TEXT) {
+        text = xpp.getText();
+      } else {
+        maybeSkipTag(xpp);
+      }
+    } while (!XmlPullParserUtil.isEndTag(xpp, label));
+    return text;
   }
 
   protected static int parseInt(XmlPullParser xpp, String name, int defaultValue) {
diff --git a/library/dash/src/test/assets/sample_mpd_1 b/library/dash/src/test/assets/sample_mpd
similarity index 99%
rename from library/dash/src/test/assets/sample_mpd_1
rename to library/dash/src/test/assets/sample_mpd
index ccd3ab4dd6..8417d2f7c4 100644
--- a/library/dash/src/test/assets/sample_mpd_1
+++ b/library/dash/src/test/assets/sample_mpd
@@ -102,4 +102,3 @@ http://www.test.com/vtt
         </AdaptationSet>
     </Period>
 </MPD>
-
diff --git a/library/dash/src/test/assets/sample_mpd_4_event_stream b/library/dash/src/test/assets/sample_mpd_event_stream
similarity index 99%
rename from library/dash/src/test/assets/sample_mpd_4_event_stream
rename to library/dash/src/test/assets/sample_mpd_event_stream
index e4c927260d..4148b420f1 100644
--- a/library/dash/src/test/assets/sample_mpd_4_event_stream
+++ b/library/dash/src/test/assets/sample_mpd_event_stream
@@ -44,4 +44,3 @@
   </AdaptationSet>
  </Period>
 </MPD>
-
diff --git a/library/dash/src/test/assets/sample_mpd_labels b/library/dash/src/test/assets/sample_mpd_labels
new file mode 100644
index 0000000000..58eceb8c42
--- /dev/null
+++ b/library/dash/src/test/assets/sample_mpd_labels
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<MPD type="static" duration="1s" mediaPresentationDuration="PT1S">
+ <Period>
+  <SegmentTemplate startNumber="0" timescale="1000" media="sq/$Number$">
+   <SegmentTimeline>
+    <S d="1000"/>
+   </SegmentTimeline>
+  </SegmentTemplate>
+  <AdaptationSet id="0" mimeType="audio/mp4" subsegmentAlignment="true" label="audio label">
+   <Representation id="0" codecs="mp4a.40.2" audioSamplingRate="48000" bandwidth="144000">
+    <BaseURL>https://test.com/0</BaseURL>
+   </Representation>
+  </AdaptationSet>
+  <AdaptationSet id="1" mimeType="video/mp4" subsegmentAlignment="true" label="ignored label">
+   <Representation id="1" codecs="avc1.4d4015" width="426" height="240" bandwidth="258000">
+    <BaseURL>https://test.com/1</BaseURL>
+   </Representation>
+   <Label>video label</Label>
+  </AdaptationSet>
+ </Period>
+</MPD>
diff --git a/library/dash/src/test/assets/sample_mpd_3_segment_template b/library/dash/src/test/assets/sample_mpd_segment_template
similarity index 99%
rename from library/dash/src/test/assets/sample_mpd_3_segment_template
rename to library/dash/src/test/assets/sample_mpd_segment_template
index a9147b54df..d45ab14f52 100644
--- a/library/dash/src/test/assets/sample_mpd_3_segment_template
+++ b/library/dash/src/test/assets/sample_mpd_segment_template
@@ -35,4 +35,3 @@
   </AdaptationSet>
  </Period>
 </MPD>
-
diff --git a/library/dash/src/test/assets/sample_mpd_2_unknown_mime_type b/library/dash/src/test/assets/sample_mpd_unknown_mime_type
similarity index 99%
rename from library/dash/src/test/assets/sample_mpd_2_unknown_mime_type
rename to library/dash/src/test/assets/sample_mpd_unknown_mime_type
index c6f00965e3..4645e3c859 100644
--- a/library/dash/src/test/assets/sample_mpd_2_unknown_mime_type
+++ b/library/dash/src/test/assets/sample_mpd_unknown_mime_type
@@ -115,4 +115,3 @@ http://www.test.com/vtt
                 </AdaptationSet>
     </Period>
 </MPD>
-
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
index 6f5bc5c83d..390a18d2cc 100644
--- a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
@@ -40,32 +40,36 @@
 @RunWith(AndroidJUnit4.class)
 public class DashManifestParserTest {
 
-  private static final String SAMPLE_MPD_1 = "sample_mpd_1";
-  private static final String SAMPLE_MPD_2_UNKNOWN_MIME_TYPE = "sample_mpd_2_unknown_mime_type";
-  private static final String SAMPLE_MPD_3_SEGMENT_TEMPLATE = "sample_mpd_3_segment_template";
-  private static final String SAMPLE_MPD_4_EVENT_STREAM = "sample_mpd_4_event_stream";
+  private static final String SAMPLE_MPD = "sample_mpd";
+  private static final String SAMPLE_MPD_UNKNOWN_MIME_TYPE = "sample_mpd_unknown_mime_type";
+  private static final String SAMPLE_MPD_SEGMENT_TEMPLATE = "sample_mpd_segment_template";
+  private static final String SAMPLE_MPD_EVENT_STREAM = "sample_mpd_event_stream";
+  private static final String SAMPLE_MPD_LABELS = "sample_mpd_labels";
+
+  private static final String NEXT_TAG_NAME = "Next";
+  private static final String NEXT_TAG = "<" + NEXT_TAG_NAME + "/>";
 
   /** Simple test to ensure the sample manifests parse without any exceptions being thrown. */
   @Test
-  public void testParseMediaPresentationDescription() throws IOException {
+  public void parseMediaPresentationDescription() throws IOException {
     DashManifestParser parser = new DashManifestParser();
     parser.parse(
         Uri.parse("https://example.com/test.mpd"),
-        TestUtil.getInputStream(ApplicationProvider.getApplicationContext(), SAMPLE_MPD_1));
+        TestUtil.getInputStream(ApplicationProvider.getApplicationContext(), SAMPLE_MPD));
     parser.parse(
         Uri.parse("https://example.com/test.mpd"),
         TestUtil.getInputStream(
-            ApplicationProvider.getApplicationContext(), SAMPLE_MPD_2_UNKNOWN_MIME_TYPE));
+            ApplicationProvider.getApplicationContext(), SAMPLE_MPD_UNKNOWN_MIME_TYPE));
   }
 
   @Test
-  public void testParseMediaPresentationDescriptionWithSegmentTemplate() throws IOException {
+  public void parseMediaPresentationDescription_segmentTemplate() throws IOException {
     DashManifestParser parser = new DashManifestParser();
     DashManifest mpd =
         parser.parse(
             Uri.parse("https://example.com/test.mpd"),
             TestUtil.getInputStream(
-                ApplicationProvider.getApplicationContext(), SAMPLE_MPD_3_SEGMENT_TEMPLATE));
+                ApplicationProvider.getApplicationContext(), SAMPLE_MPD_SEGMENT_TEMPLATE));
 
     assertThat(mpd.getPeriodCount()).isEqualTo(1);
 
@@ -91,13 +95,13 @@ public void testParseMediaPresentationDescriptionWithSegmentTemplate() throws IO
   }
 
   @Test
-  public void testParseMediaPresentationDescriptionCanParseEventStream() throws IOException {
+  public void parseMediaPresentationDescription_eventStream() throws IOException {
     DashManifestParser parser = new DashManifestParser();
     DashManifest mpd =
         parser.parse(
             Uri.parse("https://example.com/test.mpd"),
             TestUtil.getInputStream(
-                ApplicationProvider.getApplicationContext(), SAMPLE_MPD_4_EVENT_STREAM));
+                ApplicationProvider.getApplicationContext(), SAMPLE_MPD_EVENT_STREAM));
 
     Period period = mpd.getPeriod(0);
     assertThat(period.eventStreams).hasSize(3);
@@ -161,12 +165,12 @@ public void testParseMediaPresentationDescriptionCanParseEventStream() throws IO
   }
 
   @Test
-  public void testParseMediaPresentationDescriptionCanParseProgramInformation() throws IOException {
+  public void parseMediaPresentationDescription_programInformation() throws IOException {
     DashManifestParser parser = new DashManifestParser();
     DashManifest mpd =
         parser.parse(
             Uri.parse("Https://example.com/test.mpd"),
-            TestUtil.getInputStream(ApplicationProvider.getApplicationContext(), SAMPLE_MPD_1));
+            TestUtil.getInputStream(ApplicationProvider.getApplicationContext(), SAMPLE_MPD));
     ProgramInformation expectedProgramInformation =
         new ProgramInformation(
             "MediaTitle", "MediaSource", "MediaCopyright", "www.example.com", "enUs");
@@ -174,7 +178,121 @@ public void testParseMediaPresentationDescriptionCanParseProgramInformation() th
   }
 
   @Test
-  public void testParseCea608AccessibilityChannel() {
+  public void parseMediaPresentationDescription_labels() throws IOException {
+    DashManifestParser parser = new DashManifestParser();
+    DashManifest manifest =
+        parser.parse(
+            Uri.parse("https://example.com/test.mpd"),
+            TestUtil.getInputStream(
+                ApplicationProvider.getApplicationContext(), SAMPLE_MPD_LABELS));
+
+    List<AdaptationSet> adaptationSets = manifest.getPeriod(0).adaptationSets;
+
+    assertThat(adaptationSets.get(0).representations.get(0).format.label).isEqualTo("audio label");
+    assertThat(adaptationSets.get(1).representations.get(0).format.label).isEqualTo("video label");
+  }
+
+  @Test
+  public void parseSegmentTimeline_repeatCount() throws Exception {
+    DashManifestParser parser = new DashManifestParser();
+    XmlPullParser xpp = XmlPullParserFactory.newInstance().newPullParser();
+    xpp.setInput(
+        new StringReader(
+            "<SegmentTimeline><S d=\"96000\" r=\"2\"/><S d=\"48000\" r=\"0\"/></SegmentTimeline>"
+                + NEXT_TAG));
+    xpp.next();
+
+    List<SegmentTimelineElement> elements =
+        parser.parseSegmentTimeline(xpp, /* timescale= */ 48000, /* periodDurationMs= */ 10000);
+
+    assertThat(elements)
+        .containsExactly(
+            new SegmentTimelineElement(/* startTime= */ 0, /* duration= */ 96000),
+            new SegmentTimelineElement(/* startTime= */ 96000, /* duration= */ 96000),
+            new SegmentTimelineElement(/* startTime= */ 192000, /* duration= */ 96000),
+            new SegmentTimelineElement(/* startTime= */ 288000, /* duration= */ 48000))
+        .inOrder();
+    assertNextTag(xpp);
+  }
+
+  @Test
+  public void parseSegmentTimeline_singleUndefinedRepeatCount() throws Exception {
+    DashManifestParser parser = new DashManifestParser();
+    XmlPullParser xpp = XmlPullParserFactory.newInstance().newPullParser();
+    xpp.setInput(
+        new StringReader(
+            "<SegmentTimeline><S d=\"96000\" r=\"-1\"/></SegmentTimeline>" + NEXT_TAG));
+    xpp.next();
+
+    List<SegmentTimelineElement> elements =
+        parser.parseSegmentTimeline(xpp, /* timescale= */ 48000, /* periodDurationMs= */ 10000);
+
+    assertThat(elements)
+        .containsExactly(
+            new SegmentTimelineElement(/* startTime= */ 0, /* duration= */ 96000),
+            new SegmentTimelineElement(/* startTime= */ 96000, /* duration= */ 96000),
+            new SegmentTimelineElement(/* startTime= */ 192000, /* duration= */ 96000),
+            new SegmentTimelineElement(/* startTime= */ 288000, /* duration= */ 96000),
+            new SegmentTimelineElement(/* startTime= */ 384000, /* duration= */ 96000))
+        .inOrder();
+    assertNextTag(xpp);
+  }
+
+  @Test
+  public void parseSegmentTimeline_timeOffsetsAndUndefinedRepeatCount() throws Exception {
+    DashManifestParser parser = new DashManifestParser();
+    XmlPullParser xpp = XmlPullParserFactory.newInstance().newPullParser();
+    xpp.setInput(
+        new StringReader(
+            "<SegmentTimeline><S t=\"0\" "
+                + "d=\"96000\" r=\"-1\"/><S t=\"192000\" d=\"48000\" r=\"-1\"/>"
+                + "</SegmentTimeline>"
+                + NEXT_TAG));
+    xpp.next();
+
+    List<SegmentTimelineElement> elements =
+        parser.parseSegmentTimeline(xpp, /* timescale= */ 48000, /* periodDurationMs= */ 10000);
+
+    assertThat(elements)
+        .containsExactly(
+            new SegmentTimelineElement(/* startTime= */ 0, /* duration= */ 96000),
+            new SegmentTimelineElement(/* startTime= */ 96000, /* duration= */ 96000),
+            new SegmentTimelineElement(/* startTime= */ 192000, /* duration= */ 48000),
+            new SegmentTimelineElement(/* startTime= */ 240000, /* duration= */ 48000),
+            new SegmentTimelineElement(/* startTime= */ 288000, /* duration= */ 48000),
+            new SegmentTimelineElement(/* startTime= */ 336000, /* duration= */ 48000),
+            new SegmentTimelineElement(/* startTime= */ 384000, /* duration= */ 48000),
+            new SegmentTimelineElement(/* startTime= */ 432000, /* duration= */ 48000))
+        .inOrder();
+    assertNextTag(xpp);
+  }
+
+  @Test
+  public void parseLabel() throws Exception {
+    DashManifestParser parser = new DashManifestParser();
+    XmlPullParser xpp = XmlPullParserFactory.newInstance().newPullParser();
+    xpp.setInput(new StringReader("<Label>test label</Label>" + NEXT_TAG));
+    xpp.next();
+
+    String label = parser.parseLabel(xpp);
+    assertThat(label).isEqualTo("test label");
+    assertNextTag(xpp);
+  }
+
+  @Test
+  public void parseLabel_noText() throws Exception {
+    DashManifestParser parser = new DashManifestParser();
+    XmlPullParser xpp = XmlPullParserFactory.newInstance().newPullParser();
+    xpp.setInput(new StringReader("<Label/>" + NEXT_TAG));
+    xpp.next();
+
+    String label = parser.parseLabel(xpp);
+    assertThat(label).isEqualTo("");
+    assertNextTag(xpp);
+  }
+
+  @Test
+  public void parseCea608AccessibilityChannel() {
     assertThat(
             DashManifestParser.parseCea608AccessibilityChannel(
                 buildCea608AccessibilityDescriptors("CC1=eng")))
@@ -215,7 +333,7 @@ public void testParseCea608AccessibilityChannel() {
   }
 
   @Test
-  public void testParseCea708AccessibilityChannel() {
+  public void parseCea708AccessibilityChannel() {
     assertThat(
             DashManifestParser.parseCea708AccessibilityChannel(
                 buildCea708AccessibilityDescriptors("1=lang:eng")))
@@ -259,74 +377,6 @@ public void testParseCea708AccessibilityChannel() {
         .isEqualTo(Format.NO_VALUE);
   }
 
-  @Test
-  public void parseSegmentTimeline_withRepeatCount() throws Exception {
-    DashManifestParser parser = new DashManifestParser();
-    XmlPullParser xpp = XmlPullParserFactory.newInstance().newPullParser();
-    xpp.setInput(
-        new StringReader(
-            "<SegmentTimeline><S d=\"96000\" r=\"2\"/><S d=\"48000\" r=\"0\"/></SegmentTimeline>"));
-    xpp.next();
-
-    List<SegmentTimelineElement> elements =
-        parser.parseSegmentTimeline(xpp, /* timescale= */ 48000, /* periodDurationMs= */ 10000);
-
-    assertThat(elements)
-        .containsExactly(
-            new SegmentTimelineElement(/* startTime= */ 0, /* duration= */ 96000),
-            new SegmentTimelineElement(/* startTime= */ 96000, /* duration= */ 96000),
-            new SegmentTimelineElement(/* startTime= */ 192000, /* duration= */ 96000),
-            new SegmentTimelineElement(/* startTime= */ 288000, /* duration= */ 48000))
-        .inOrder();
-  }
-
-  @Test
-  public void parseSegmentTimeline_withSingleUndefinedRepeatCount() throws Exception {
-    DashManifestParser parser = new DashManifestParser();
-    XmlPullParser xpp = XmlPullParserFactory.newInstance().newPullParser();
-    xpp.setInput(new StringReader("<SegmentTimeline><S d=\"96000\" r=\"-1\"/></SegmentTimeline>"));
-    xpp.next();
-
-    List<SegmentTimelineElement> elements =
-        parser.parseSegmentTimeline(xpp, /* timescale= */ 48000, /* periodDurationMs= */ 10000);
-
-    assertThat(elements)
-        .containsExactly(
-            new SegmentTimelineElement(/* startTime= */ 0, /* duration= */ 96000),
-            new SegmentTimelineElement(/* startTime= */ 96000, /* duration= */ 96000),
-            new SegmentTimelineElement(/* startTime= */ 192000, /* duration= */ 96000),
-            new SegmentTimelineElement(/* startTime= */ 288000, /* duration= */ 96000),
-            new SegmentTimelineElement(/* startTime= */ 384000, /* duration= */ 96000))
-        .inOrder();
-  }
-
-  @Test
-  public void parseSegmentTimeline_withTimeOffsetsAndUndefinedRepeatCount() throws Exception {
-    DashManifestParser parser = new DashManifestParser();
-    XmlPullParser xpp = XmlPullParserFactory.newInstance().newPullParser();
-    xpp.setInput(
-        new StringReader(
-            "<SegmentTimeline><S t=\"0\" "
-                + "d=\"96000\" r=\"-1\"/><S t=\"192000\" d=\"48000\" r=\"-1\"/>"
-                + "</SegmentTimeline>"));
-    xpp.next();
-
-    List<SegmentTimelineElement> elements =
-        parser.parseSegmentTimeline(xpp, /* timescale= */ 48000, /* periodDurationMs= */ 10000);
-
-    assertThat(elements)
-        .containsExactly(
-            new SegmentTimelineElement(/* startTime= */ 0, /* duration= */ 96000),
-            new SegmentTimelineElement(/* startTime= */ 96000, /* duration= */ 96000),
-            new SegmentTimelineElement(/* startTime= */ 192000, /* duration= */ 48000),
-            new SegmentTimelineElement(/* startTime= */ 240000, /* duration= */ 48000),
-            new SegmentTimelineElement(/* startTime= */ 288000, /* duration= */ 48000),
-            new SegmentTimelineElement(/* startTime= */ 336000, /* duration= */ 48000),
-            new SegmentTimelineElement(/* startTime= */ 384000, /* duration= */ 48000),
-            new SegmentTimelineElement(/* startTime= */ 432000, /* duration= */ 48000))
-        .inOrder();
-  }
-
   private static List<Descriptor> buildCea608AccessibilityDescriptors(String value) {
     return Collections.singletonList(new Descriptor("urn:scte:dash:cc:cea-608:2015", value, null));
   }
@@ -334,4 +384,10 @@ public void parseSegmentTimeline_withTimeOffsetsAndUndefinedRepeatCount() throws
   private static List<Descriptor> buildCea708AccessibilityDescriptors(String value) {
     return Collections.singletonList(new Descriptor("urn:scte:dash:cc:cea-708:2015", value, null));
   }
+
+  private static void assertNextTag(XmlPullParser xpp) throws Exception {
+    xpp.next();
+    assertThat(xpp.getEventType()).isEqualTo(XmlPullParser.START_TAG);
+    assertThat(xpp.getName()).isEqualTo(NEXT_TAG_NAME);
+  }
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
index 7d47cc43c6..b0b4c04b48 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
@@ -359,6 +359,11 @@ public boolean continueLoading(long positionUs) {
     }
   }
 
+  @Override
+  public boolean isLoading() {
+    return compositeSequenceableLoader.isLoading();
+  }
+
   @Override
   public long getNextLoadPositionUs() {
     return compositeSequenceableLoader.getNextLoadPositionUs();
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
index 7a463d6b98..aa30e9ba37 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
@@ -368,6 +368,7 @@ public Object getTag() {
   @Override
   protected void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
     this.mediaTransferListener = mediaTransferListener;
+    drmSessionManager.prepare();
     EventDispatcher eventDispatcher = createEventDispatcher(/* mediaPeriodId= */ null);
     playlistTracker.start(manifestUri, eventDispatcher, /* listener= */ this);
   }
@@ -402,6 +403,7 @@ public void releasePeriod(MediaPeriod mediaPeriod) {
   @Override
   protected void releaseSourceInternal() {
     playlistTracker.stop();
+    drmSessionManager.release();
   }
 
   @Override
@@ -458,6 +460,7 @@ public void onPrimaryPlaylistRefreshed(HlsMediaPlaylist playlist) {
               windowDefaultStartPositionUs,
               /* isSeekable= */ true,
               /* isDynamic= */ !playlist.hasEndTag,
+              /* isLive= */ true,
               manifest,
               tag);
     } else /* not live */ {
@@ -474,6 +477,7 @@ public void onPrimaryPlaylistRefreshed(HlsMediaPlaylist playlist) {
               windowDefaultStartPositionUs,
               /* isSeekable= */ true,
               /* isDynamic= */ false,
+              /* isLive= */ false,
               manifest,
               tag);
     }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
index e618d7f134..58c275664b 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
@@ -17,6 +17,7 @@
 
 import android.net.Uri;
 import android.os.Handler;
+import android.util.SparseIntArray;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
@@ -93,6 +94,10 @@
   public static final int SAMPLE_QUEUE_INDEX_NO_MAPPING_FATAL = -2;
   public static final int SAMPLE_QUEUE_INDEX_NO_MAPPING_NON_FATAL = -3;
 
+  private static final Set<Integer> MAPPABLE_TYPES =
+      Collections.unmodifiableSet(
+          new HashSet<>(Arrays.asList(C.TRACK_TYPE_AUDIO, C.TRACK_TYPE_VIDEO)));
+
   private final int trackType;
   private final Callback callback;
   private final HlsChunkSource chunkSource;
@@ -114,10 +119,8 @@
   private SampleQueue[] sampleQueues;
   private DecryptableSampleQueueReader[] sampleQueueReaders;
   private int[] sampleQueueTrackIds;
-  private boolean audioSampleQueueMappingDone;
-  private int audioSampleQueueIndex;
-  private boolean videoSampleQueueMappingDone;
-  private int videoSampleQueueIndex;
+  private Set<Integer> sampleQueueMappingDoneByType;
+  private SparseIntArray sampleQueueIndicesByType;
   private int primarySampleQueueType;
   private int primarySampleQueueIndex;
   private boolean sampleQueuesBuilt;
@@ -188,8 +191,8 @@ public HlsSampleStreamWrapper(
     loader = new Loader("Loader:HlsSampleStreamWrapper");
     nextChunkHolder = new HlsChunkSource.HlsChunkHolder();
     sampleQueueTrackIds = new int[0];
-    audioSampleQueueIndex = C.INDEX_UNSET;
-    videoSampleQueueIndex = C.INDEX_UNSET;
+    sampleQueueMappingDoneByType = new HashSet<>(MAPPABLE_TYPES.size());
+    sampleQueueIndicesByType = new SparseIntArray(MAPPABLE_TYPES.size());
     sampleQueues = new SampleQueue[0];
     sampleQueueReaders = new DecryptableSampleQueueReader[0];
     sampleQueueIsAudioVideoFlags = new boolean[0];
@@ -660,6 +663,11 @@ public boolean continueLoading(long positionUs) {
     return true;
   }
 
+  @Override
+  public boolean isLoading() {
+    return loader.isLoading();
+  }
+
   @Override
   public void reevaluateBuffer(long positionUs) {
     // Do nothing.
@@ -794,8 +802,7 @@ public LoadErrorAction onLoadError(
    */
   public void init(int chunkUid, boolean shouldSpliceIn, boolean reusingExtractor) {
     if (!reusingExtractor) {
-      audioSampleQueueMappingDone = false;
-      videoSampleQueueMappingDone = false;
+      sampleQueueMappingDoneByType.clear();
     }
     this.chunkUid = chunkUid;
     for (SampleQueue sampleQueue : sampleQueues) {
@@ -812,45 +819,24 @@ public void init(int chunkUid, boolean shouldSpliceIn, boolean reusingExtractor)
 
   @Override
   public TrackOutput track(int id, int type) {
-    int trackCount = sampleQueues.length;
-
-    // Audio and video tracks are handled manually to ignore ids.
-    if (type == C.TRACK_TYPE_AUDIO) {
-      if (audioSampleQueueIndex != C.INDEX_UNSET) {
-        if (audioSampleQueueMappingDone) {
-          return sampleQueueTrackIds[audioSampleQueueIndex] == id
-              ? sampleQueues[audioSampleQueueIndex]
-              : createDummyTrackOutput(id, type);
-        }
-        audioSampleQueueMappingDone = true;
-        sampleQueueTrackIds[audioSampleQueueIndex] = id;
-        return sampleQueues[audioSampleQueueIndex];
-      } else if (tracksEnded) {
-        return createDummyTrackOutput(id, type);
-      }
-    } else if (type == C.TRACK_TYPE_VIDEO) {
-      if (videoSampleQueueIndex != C.INDEX_UNSET) {
-        if (videoSampleQueueMappingDone) {
-          return sampleQueueTrackIds[videoSampleQueueIndex] == id
-              ? sampleQueues[videoSampleQueueIndex]
-              : createDummyTrackOutput(id, type);
-        }
-        videoSampleQueueMappingDone = true;
-        sampleQueueTrackIds[videoSampleQueueIndex] = id;
-        return sampleQueues[videoSampleQueueIndex];
-      } else if (tracksEnded) {
-        return createDummyTrackOutput(id, type);
+    if (MAPPABLE_TYPES.contains(type)) {
+      // Track types in MAPPABLE_TYPES are handled manually to ignore IDs.
+      @Nullable TrackOutput mappedTrackOutput = getMappedTrackOutput(id, type);
+      if (mappedTrackOutput != null) {
+        return mappedTrackOutput;
       }
     } else /* sparse track */ {
-      for (int i = 0; i < trackCount; i++) {
+      for (int i = 0; i < sampleQueues.length; i++) {
         if (sampleQueueTrackIds[i] == id) {
           return sampleQueues[i];
         }
       }
-      if (tracksEnded) {
-        return createDummyTrackOutput(id, type);
-      }
     }
+    if (tracksEnded) {
+      return createDummyTrackOutput(id, type);
+    }
+
+    int trackCount = sampleQueues.length;
     SampleQueue trackOutput = new FormatAdjustingSampleQueue(allocator, overridingDrmInitData);
     trackOutput.setSampleOffsetUs(sampleOffsetUs);
     trackOutput.sourceId(chunkUid);
@@ -866,13 +852,8 @@ public TrackOutput track(int id, int type) {
     sampleQueueIsAudioVideoFlags[trackCount] = type == C.TRACK_TYPE_AUDIO
         || type == C.TRACK_TYPE_VIDEO;
     haveAudioVideoSampleQueues |= sampleQueueIsAudioVideoFlags[trackCount];
-    if (type == C.TRACK_TYPE_AUDIO) {
-      audioSampleQueueMappingDone = true;
-      audioSampleQueueIndex = trackCount;
-    } else if (type == C.TRACK_TYPE_VIDEO) {
-      videoSampleQueueMappingDone = true;
-      videoSampleQueueIndex = trackCount;
-    }
+    sampleQueueMappingDoneByType.add(type);
+    sampleQueueIndicesByType.append(type, trackCount);
     if (getTrackTypeScore(type) > getTrackTypeScore(primarySampleQueueType)) {
       primarySampleQueueIndex = trackCount;
       primarySampleQueueType = type;
@@ -881,6 +862,37 @@ public TrackOutput track(int id, int type) {
     return trackOutput;
   }
 
+  /**
+   * Returns the {@link TrackOutput} for the provided {@code type} and {@code id}, or null if none
+   * has been created yet.
+   *
+   * <p>If a {@link SampleQueue} for {@code type} has been created and is mapped, but it has a
+   * different ID, then return a {@link DummyTrackOutput} that does nothing.
+   *
+   * <p>If a {@link SampleQueue} for {@code type} has been created but is not mapped, then map it to
+   * this {@code id} and return it. This situation can happen after a call to {@link #init} with
+   * {@code reusingExtractor=false}.
+   *
+   * @param id The ID of the track.
+   * @param type The type of the track, must be one of {@link #MAPPABLE_TYPES}.
+   * @return The the mapped {@link TrackOutput}, or null if it's not been created yet.
+   */
+  @Nullable
+  private TrackOutput getMappedTrackOutput(int id, int type) {
+    Assertions.checkArgument(MAPPABLE_TYPES.contains(type));
+    int sampleQueueIndex = sampleQueueIndicesByType.get(type, C.INDEX_UNSET);
+    if (sampleQueueIndex == C.INDEX_UNSET) {
+      return null;
+    }
+
+    if (sampleQueueMappingDoneByType.add(type)) {
+      sampleQueueTrackIds[sampleQueueIndex] = id;
+    }
+    return sampleQueueTrackIds[sampleQueueIndex] == id
+        ? sampleQueues[sampleQueueIndex]
+        : createDummyTrackOutput(id, type);
+  }
+
   @Override
   public void endTracks() {
     tracksEnded = true;
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
index b3d950959a..42ac82e553 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
@@ -184,6 +184,11 @@ public boolean continueLoading(long positionUs) {
     return compositeSequenceableLoader.continueLoading(positionUs);
   }
 
+  @Override
+  public boolean isLoading() {
+    return compositeSequenceableLoader.isLoading();
+  }
+
   @Override
   public long getNextLoadPositionUs() {
     return compositeSequenceableLoader.getNextLoadPositionUs();
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
index 410f41caee..4c05353186 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
@@ -552,6 +552,7 @@ public Object getTag() {
   @Override
   protected void prepareSourceInternal(@Nullable TransferListener mediaTransferListener) {
     this.mediaTransferListener = mediaTransferListener;
+    drmSessionManager.prepare();
     if (sideloadedManifest) {
       manifestLoaderErrorThrower = new LoaderErrorThrower.Dummy();
       processManifest();
@@ -606,6 +607,7 @@ protected void releaseSourceInternal() {
       manifestRefreshHandler.removeCallbacksAndMessages(null);
       manifestRefreshHandler = null;
     }
+    drmSessionManager.release();
   }
 
   // Loader.Callback implementation
@@ -694,7 +696,8 @@ private void processManifest() {
               /* windowPositionInPeriodUs= */ 0,
               /* windowDefaultStartPositionUs= */ 0,
               /* isSeekable= */ true,
-              manifest.isLive,
+              /* isDynamic= */ manifest.isLive,
+              /* isLive= */ manifest.isLive,
               manifest,
               tag);
     } else if (manifest.isLive) {
@@ -717,6 +720,7 @@ private void processManifest() {
               defaultStartPositionUs,
               /* isSeekable= */ true,
               /* isDynamic= */ true,
+              /* isLive= */ true,
               manifest,
               tag);
     } else {
@@ -730,6 +734,7 @@ private void processManifest() {
               /* windowDefaultStartPositionUs= */ 0,
               /* isSeekable= */ true,
               /* isDynamic= */ false,
+              /* isLive= */ false,
               manifest,
               tag);
     }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java
index d0e621547e..4e7422b291 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java
@@ -98,19 +98,19 @@
  *   <li><b>{@code scrubber_color}</b> - Color for the scrubber handle.
  *       <ul>
  *         <li>Corresponding method: {@link #setScrubberColor(int)}
- *         <li>Default: see {@link #getDefaultScrubberColor(int)}
+ *         <li>Default: {@link #DEFAULT_SCRUBBER_COLOR}
  *       </ul>
  *   <li><b>{@code buffered_color}</b> - Color for the portion of the time bar after the current
  *       played position up to the current buffered position.
  *       <ul>
  *         <li>Corresponding method: {@link #setBufferedColor(int)}
- *         <li>Default: see {@link #getDefaultBufferedColor(int)}
+ *         <li>Default: {@link #DEFAULT_BUFFERED_COLOR}
  *       </ul>
  *   <li><b>{@code unplayed_color}</b> - Color for the portion of the time bar after the current
  *       buffered position.
  *       <ul>
  *         <li>Corresponding method: {@link #setUnplayedColor(int)}
- *         <li>Default: see {@link #getDefaultUnplayedColor(int)}
+ *         <li>Default: {@link #DEFAULT_UNPLAYED_COLOR}
  *       </ul>
  *   <li><b>{@code ad_marker_color}</b> - Color for unplayed ad markers.
  *       <ul>
@@ -120,7 +120,7 @@
  *   <li><b>{@code played_ad_marker_color}</b> - Color for played ad markers.
  *       <ul>
  *         <li>Corresponding method: {@link #setPlayedAdMarkerColor(int)}
- *         <li>Default: see {@link #getDefaultPlayedAdMarkerColor(int)}
+ *         <li>Default: {@link #DEFAULT_PLAYED_AD_MARKER_COLOR}
  *       </ul>
  * </ul>
  */
@@ -154,10 +154,16 @@
    * Default color for the played portion of the time bar.
    */
   public static final int DEFAULT_PLAYED_COLOR = 0xFFFFFFFF;
-  /**
-   * Default color for ad markers.
-   */
+  /** Default color for the played portion of the time bar. */
+  public static final int DEFAULT_UNPLAYED_COLOR = 0x33FFFFFF;
+  /** Default color for the buffered portion of the time bar. */
+  public static final int DEFAULT_BUFFERED_COLOR = 0xCCFFFFFF;
+  /** Default color for the scrubber handle. */
+  public static final int DEFAULT_SCRUBBER_COLOR = 0xFFFFFFFF;
+  /** Default color for ad markers. */
   public static final int DEFAULT_AD_MARKER_COLOR = 0xB2FFFF00;
+  /** Default color for played ad markers. */
+  public static final int DEFAULT_PLAYED_AD_MARKER_COLOR = 0x33FFFF00;
 
   /**
    * The threshold in dps above the bar at which touch events trigger fine scrub mode.
@@ -289,16 +295,17 @@ public DefaultTimeBar(
         scrubberDraggedSize = a.getDimensionPixelSize(
             R.styleable.DefaultTimeBar_scrubber_dragged_size, defaultScrubberDraggedSize);
         int playedColor = a.getInt(R.styleable.DefaultTimeBar_played_color, DEFAULT_PLAYED_COLOR);
-        int scrubberColor = a.getInt(R.styleable.DefaultTimeBar_scrubber_color,
-            getDefaultScrubberColor(playedColor));
-        int bufferedColor = a.getInt(R.styleable.DefaultTimeBar_buffered_color,
-            getDefaultBufferedColor(playedColor));
-        int unplayedColor = a.getInt(R.styleable.DefaultTimeBar_unplayed_color,
-            getDefaultUnplayedColor(playedColor));
+        int scrubberColor =
+            a.getInt(R.styleable.DefaultTimeBar_scrubber_color, DEFAULT_SCRUBBER_COLOR);
+        int bufferedColor =
+            a.getInt(R.styleable.DefaultTimeBar_buffered_color, DEFAULT_BUFFERED_COLOR);
+        int unplayedColor =
+            a.getInt(R.styleable.DefaultTimeBar_unplayed_color, DEFAULT_UNPLAYED_COLOR);
         int adMarkerColor = a.getInt(R.styleable.DefaultTimeBar_ad_marker_color,
             DEFAULT_AD_MARKER_COLOR);
-        int playedAdMarkerColor = a.getInt(R.styleable.DefaultTimeBar_played_ad_marker_color,
-            getDefaultPlayedAdMarkerColor(adMarkerColor));
+        int playedAdMarkerColor =
+            a.getInt(
+                R.styleable.DefaultTimeBar_played_ad_marker_color, DEFAULT_PLAYED_AD_MARKER_COLOR);
         playedPaint.setColor(playedColor);
         scrubberPaint.setColor(scrubberColor);
         bufferedPaint.setColor(bufferedColor);
@@ -316,10 +323,11 @@ public DefaultTimeBar(
       scrubberDisabledSize = defaultScrubberDisabledSize;
       scrubberDraggedSize = defaultScrubberDraggedSize;
       playedPaint.setColor(DEFAULT_PLAYED_COLOR);
-      scrubberPaint.setColor(getDefaultScrubberColor(DEFAULT_PLAYED_COLOR));
-      bufferedPaint.setColor(getDefaultBufferedColor(DEFAULT_PLAYED_COLOR));
-      unplayedPaint.setColor(getDefaultUnplayedColor(DEFAULT_PLAYED_COLOR));
+      scrubberPaint.setColor(DEFAULT_SCRUBBER_COLOR);
+      bufferedPaint.setColor(DEFAULT_BUFFERED_COLOR);
+      unplayedPaint.setColor(DEFAULT_UNPLAYED_COLOR);
       adMarkerPaint.setColor(DEFAULT_AD_MARKER_COLOR);
+      playedAdMarkerPaint.setColor(DEFAULT_PLAYED_AD_MARKER_COLOR);
       scrubberDrawable = null;
     }
     formatBuilder = new StringBuilder();
@@ -856,22 +864,6 @@ private static boolean setDrawableLayoutDirection(Drawable drawable, int layoutD
     return Util.SDK_INT >= 23 && drawable.setLayoutDirection(layoutDirection);
   }
 
-  public static int getDefaultScrubberColor(int playedColor) {
-    return 0xFF000000 | playedColor;
-  }
-
-  public static int getDefaultUnplayedColor(int playedColor) {
-    return 0x33000000 | (playedColor & 0x00FFFFFF);
-  }
-
-  public static int getDefaultBufferedColor(int playedColor) {
-    return 0xCC000000 | (playedColor & 0x00FFFFFF);
-  }
-
-  public static int getDefaultPlayedAdMarkerColor(int adMarkerColor) {
-    return 0x33000000 | (adMarkerColor & 0x00FFFFFF);
-  }
-
   private static int dpToPx(float density, int dps) {
     return (int) (dps * density + 0.5f);
   }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
index fd949db6a2..3b6711766e 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
@@ -750,14 +750,14 @@ private void updatePlayPauseButton() {
       return;
     }
     boolean requestPlayPauseFocus = false;
-    boolean playing = isPlaying();
+    boolean shouldShowPauseButton = shouldShowPauseButton();
     if (playButton != null) {
-      requestPlayPauseFocus |= playing && playButton.isFocused();
-      playButton.setVisibility(playing ? GONE : VISIBLE);
+      requestPlayPauseFocus |= shouldShowPauseButton && playButton.isFocused();
+      playButton.setVisibility(shouldShowPauseButton ? GONE : VISIBLE);
     }
     if (pauseButton != null) {
-      requestPlayPauseFocus |= !playing && pauseButton.isFocused();
-      pauseButton.setVisibility(!playing ? GONE : VISIBLE);
+      requestPlayPauseFocus |= !shouldShowPauseButton && pauseButton.isFocused();
+      pauseButton.setVisibility(shouldShowPauseButton ? VISIBLE : GONE);
     }
     if (requestPlayPauseFocus) {
       requestPlayPauseFocus();
@@ -945,7 +945,7 @@ private void updateProgress() {
     // Cancel any pending updates and schedule a new one if necessary.
     removeCallbacks(updateProgressAction);
     int playbackState = player == null ? Player.STATE_IDLE : player.getPlaybackState();
-    if (playbackState == Player.STATE_READY && player.getPlayWhenReady()) {
+    if (player != null && player.isPlaying()) {
       long mediaTimeDelayMs =
           timeBar != null ? timeBar.getPreferredUpdateDelay() : MAX_UPDATE_INTERVAL_MS;
 
@@ -967,10 +967,10 @@ private void updateProgress() {
   }
 
   private void requestPlayPauseFocus() {
-    boolean playing = isPlaying();
-    if (!playing && playButton != null) {
+    boolean shouldShowPauseButton = shouldShowPauseButton();
+    if (!shouldShowPauseButton && playButton != null) {
       playButton.requestFocus();
-    } else if (playing && pauseButton != null) {
+    } else if (shouldShowPauseButton && pauseButton != null) {
       pauseButton.requestFocus();
     }
   }
@@ -997,7 +997,7 @@ private void previous(Player player) {
             || (window.isDynamic && !window.isSeekable))) {
       seekTo(player, previousWindowIndex, C.TIME_UNSET);
     } else {
-      seekTo(player, 0);
+      seekTo(player, windowIndex, /* positionMs= */ 0);
     }
   }
 
@@ -1017,27 +1017,24 @@ private void next(Player player) {
 
   private void rewind(Player player) {
     if (player.isCurrentWindowSeekable() && rewindMs > 0) {
-      seekTo(player, player.getCurrentPosition() - rewindMs);
+      seekToOffset(player, -rewindMs);
     }
   }
 
   private void fastForward(Player player) {
     if (player.isCurrentWindowSeekable() && fastForwardMs > 0) {
-      seekTo(player, player.getCurrentPosition() + fastForwardMs);
+      seekToOffset(player, fastForwardMs);
     }
   }
 
-  private void seekTo(Player player, long positionMs) {
-    seekTo(player, player.getCurrentWindowIndex(), positionMs);
-  }
-
-  private boolean seekTo(Player player, int windowIndex, long positionMs) {
+  private void seekToOffset(Player player, long offsetMs) {
+    long positionMs = player.getCurrentPosition() + offsetMs;
     long durationMs = player.getDuration();
     if (durationMs != C.TIME_UNSET) {
       positionMs = Math.min(positionMs, durationMs);
     }
     positionMs = Math.max(positionMs, 0);
-    return controlDispatcher.dispatchSeekTo(player, windowIndex, positionMs);
+    seekTo(player, player.getCurrentWindowIndex(), positionMs);
   }
 
   private void seekToTimeBarPosition(Player player, long positionMs) {
@@ -1069,6 +1066,10 @@ private void seekToTimeBarPosition(Player player, long positionMs) {
     }
   }
 
+  private boolean seekTo(Player player, int windowIndex, long positionMs) {
+    return controlDispatcher.dispatchSeekTo(player, windowIndex, positionMs);
+  }
+
   @Override
   public void onAttachedToWindow() {
     super.onAttachedToWindow();
@@ -1151,7 +1152,7 @@ public boolean dispatchMediaKeyEvent(KeyEvent event) {
     return true;
   }
 
-  private boolean isPlaying() {
+  private boolean shouldShowPauseButton() {
     return player != null
         && player.getPlaybackState() != Player.STATE_ENDED
         && player.getPlaybackState() != Player.STATE_IDLE
@@ -1221,6 +1222,11 @@ public void onPlayerStateChanged(boolean playWhenReady, @Player.State int playba
       updateProgress();
     }
 
+    @Override
+    public void onIsPlayingChanged(boolean isPlaying) {
+      updateProgress();
+    }
+
     @Override
     public void onRepeatModeChanged(int repeatMode) {
       updateRepeatModeButton();
@@ -1265,7 +1271,7 @@ public void onClick(View view) {
             playbackPreparer.preparePlayback();
           }
         } else if (player.getPlaybackState() == Player.STATE_ENDED) {
-          controlDispatcher.dispatchSeekTo(player, player.getCurrentWindowIndex(), C.TIME_UNSET);
+          seekTo(player, player.getCurrentWindowIndex(), C.TIME_UNSET);
         }
         controlDispatcher.dispatchSetPlayWhenReady(player, true);
       } else if (pauseButton == view) {
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java
index e4fcb37af3..fb11dfae71 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerNotificationManager.java
@@ -382,8 +382,6 @@ public void onBitmap(final Bitmap bitmap) {
   private int visibility;
   @Priority private int priority;
   private boolean useChronometer;
-  private boolean wasPlayWhenReady;
-  private int lastPlaybackState;
 
   /**
    * @deprecated Use {@link #createWithNotificationChannel(Context, String, int, int, int,
@@ -663,8 +661,6 @@ public final void setPlayer(@Nullable Player player) {
     }
     this.player = player;
     if (player != null) {
-      wasPlayWhenReady = player.getPlayWhenReady();
-      lastPlaybackState = player.getPlaybackState();
       player.addListener(playerListener);
       startOrUpdateNotification();
     }
@@ -1070,10 +1066,9 @@ private void stopNotification(boolean dismissedByUser) {
     // Changing "showWhen" causes notification flicker if SDK_INT < 21.
     if (Util.SDK_INT >= 21
         && useChronometer
+        && player.isPlaying()
         && !player.isPlayingAd()
-        && !player.isCurrentWindowDynamic()
-        && player.getPlayWhenReady()
-        && player.getPlaybackState() == Player.STATE_READY) {
+        && !player.isCurrentWindowDynamic()) {
       builder
           .setWhen(System.currentTimeMillis() - player.getContentPosition())
           .setShowWhen(true)
@@ -1138,7 +1133,7 @@ private void stopNotification(boolean dismissedByUser) {
       stringActions.add(ACTION_REWIND);
     }
     if (usePlayPauseActions) {
-      if (isPlaying(player)) {
+      if (shouldShowPauseButton(player)) {
         stringActions.add(ACTION_PAUSE);
       } else {
         stringActions.add(ACTION_PLAY);
@@ -1182,10 +1177,10 @@ private void stopNotification(boolean dismissedByUser) {
     if (skipPreviousActionIndex != -1) {
       actionIndices[actionCounter++] = skipPreviousActionIndex;
     }
-    boolean isPlaying = isPlaying(player);
-    if (pauseActionIndex != -1 && isPlaying) {
+    boolean shouldShowPauseButton = shouldShowPauseButton(player);
+    if (pauseActionIndex != -1 && shouldShowPauseButton) {
       actionIndices[actionCounter++] = pauseActionIndex;
-    } else if (playActionIndex != -1 && !isPlaying) {
+    } else if (playActionIndex != -1 && !shouldShowPauseButton) {
       actionIndices[actionCounter++] = playActionIndex;
     }
     if (skipNextActionIndex != -1) {
@@ -1214,7 +1209,7 @@ private void previous(Player player) {
             || (window.isDynamic && !window.isSeekable))) {
       seekTo(player, previousWindowIndex, C.TIME_UNSET);
     } else {
-      seekTo(player, 0);
+      seekTo(player, windowIndex, /* positionMs= */ 0);
     }
   }
 
@@ -1234,30 +1229,31 @@ private void next(Player player) {
 
   private void rewind(Player player) {
     if (player.isCurrentWindowSeekable() && rewindMs > 0) {
-      seekTo(player, Math.max(player.getCurrentPosition() - rewindMs, 0));
+      seekToOffset(player, /* offsetMs= */ -rewindMs);
     }
   }
 
   private void fastForward(Player player) {
     if (player.isCurrentWindowSeekable() && fastForwardMs > 0) {
-      seekTo(player, player.getCurrentPosition() + fastForwardMs);
+      seekToOffset(player, /* offsetMs= */ fastForwardMs);
     }
   }
 
-  private void seekTo(Player player, long positionMs) {
+  private void seekToOffset(Player player, long offsetMs) {
+    long positionMs = player.getCurrentPosition() + offsetMs;
+    long durationMs = player.getDuration();
+    if (durationMs != C.TIME_UNSET) {
+      positionMs = Math.min(positionMs, durationMs);
+    }
+    positionMs = Math.max(positionMs, 0);
     seekTo(player, player.getCurrentWindowIndex(), positionMs);
   }
 
   private void seekTo(Player player, int windowIndex, long positionMs) {
-    long duration = player.getDuration();
-    if (duration != C.TIME_UNSET) {
-      positionMs = Math.min(positionMs, duration);
-    }
-    positionMs = Math.max(positionMs, 0);
     controlDispatcher.dispatchSeekTo(player, windowIndex, positionMs);
   }
 
-  private boolean isPlaying(Player player) {
+  private boolean shouldShowPauseButton(Player player) {
     return player.getPlaybackState() != Player.STATE_ENDED
         && player.getPlaybackState() != Player.STATE_IDLE
         && player.getPlayWhenReady();
@@ -1328,11 +1324,12 @@ private static void setLargeIcon(NotificationCompat.Builder builder, @Nullable B
 
     @Override
     public void onPlayerStateChanged(boolean playWhenReady, @Player.State int playbackState) {
-      if (wasPlayWhenReady != playWhenReady || lastPlaybackState != playbackState) {
-        startOrUpdateNotification();
-        wasPlayWhenReady = playWhenReady;
-        lastPlaybackState = playbackState;
-      }
+      startOrUpdateNotification();
+    }
+
+    @Override
+    public void onIsPlayingChanged(boolean isPlaying) {
+      startOrUpdateNotification();
     }
 
     @Override
@@ -1373,7 +1370,7 @@ public void onReceive(Context context, Intent intent) {
             playbackPreparer.preparePlayback();
           }
         } else if (player.getPlaybackState() == Player.STATE_ENDED) {
-          controlDispatcher.dispatchSeekTo(player, player.getCurrentWindowIndex(), C.TIME_UNSET);
+          seekTo(player, player.getCurrentWindowIndex(), C.TIME_UNSET);
         }
         controlDispatcher.dispatchSetPlayWhenReady(player, /* playWhenReady= */ true);
       } else if (ACTION_PAUSE.equals(action)) {
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java
index 0d966c9080..052cd7d0a2 100644
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java
@@ -30,6 +30,7 @@
 import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
+import com.google.android.exoplayer2.drm.FrameworkMediaDrm;
 import com.google.android.exoplayer2.drm.HttpMediaDrmCallback;
 import com.google.android.exoplayer2.drm.MediaDrmCallback;
 import com.google.android.exoplayer2.drm.UnsupportedDrmException;
@@ -265,11 +266,17 @@ protected DefaultTrackSelector buildTrackSelector(HostActivity host) {
       try {
         MediaDrmCallback drmCallback = new HttpMediaDrmCallback(widevineLicenseUrl,
             new DefaultHttpDataSourceFactory(userAgent));
+        FrameworkMediaDrm frameworkMediaDrm = FrameworkMediaDrm.newInstance(WIDEVINE_UUID);
         DefaultDrmSessionManager<FrameworkMediaCrypto> drmSessionManager =
-            DefaultDrmSessionManager.newWidevineInstance(drmCallback, null);
+            new DefaultDrmSessionManager<>(
+                C.WIDEVINE_UUID,
+                frameworkMediaDrm,
+                drmCallback,
+                /* optionalKeyRequestParameters= */ null,
+                /* multiSession= */ false,
+                DefaultDrmSessionManager.INITIAL_DRM_REQUEST_RETRY_COUNT);
         if (!useL1Widevine) {
-          drmSessionManager.setPropertyString(
-              SECURITY_LEVEL_PROPERTY, WIDEVINE_SECURITY_LEVEL_3);
+          frameworkMediaDrm.setPropertyString(SECURITY_LEVEL_PROPERTY, WIDEVINE_SECURITY_LEVEL_3);
         }
         if (offlineLicenseKeySetId != null) {
           drmSessionManager.setMode(DefaultDrmSessionManager.MODE_PLAYBACK,
diff --git a/settings.gradle b/settings.gradle
index 50fdb68f30..2708596a9e 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -22,11 +22,13 @@ include modulePrefix + 'demo'
 include modulePrefix + 'demo-cast'
 include modulePrefix + 'demo-ima'
 include modulePrefix + 'demo-gvr'
+include modulePrefix + 'demo-surface'
 include modulePrefix + 'playbacktests'
 project(modulePrefix + 'demo').projectDir = new File(rootDir, 'demos/main')
 project(modulePrefix + 'demo-cast').projectDir = new File(rootDir, 'demos/cast')
 project(modulePrefix + 'demo-ima').projectDir = new File(rootDir, 'demos/ima')
 project(modulePrefix + 'demo-gvr').projectDir = new File(rootDir, 'demos/gvr')
+project(modulePrefix + 'demo-surface').projectDir = new File(rootDir, 'demos/surface')
 project(modulePrefix + 'playbacktests').projectDir = new File(rootDir, 'playbacktests')
 
 apply from: 'core_settings.gradle'
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java
index dada94df0a..52f6121bae 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java
@@ -15,13 +15,14 @@
  */
 package com.google.android.exoplayer2.testutil;
 
+import android.content.Intent;
 import android.os.Handler;
 import android.view.Surface;
 import androidx.annotation.Nullable;
+import androidx.test.core.app.ApplicationProvider;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
-import com.google.android.exoplayer2.IllegalSeekPositionException;
 import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.PlayerMessage;
@@ -29,7 +30,6 @@
 import com.google.android.exoplayer2.SimpleExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.MediaSource;
-import com.google.android.exoplayer2.source.ShuffleOrder;
 import com.google.android.exoplayer2.testutil.ActionSchedule.ActionNode;
 import com.google.android.exoplayer2.testutil.ActionSchedule.PlayerRunnable;
 import com.google.android.exoplayer2.testutil.ActionSchedule.PlayerTarget;
@@ -38,8 +38,6 @@
 import com.google.android.exoplayer2.util.ConditionVariable;
 import com.google.android.exoplayer2.util.HandlerWrapper;
 import com.google.android.exoplayer2.util.Log;
-import java.util.Arrays;
-import java.util.List;
 
 /** Base class for actions to perform during playback tests. */
 public abstract class Action {
@@ -116,7 +114,6 @@ protected abstract void doActionImpl(
 
     private final Integer windowIndex;
     private final long positionMs;
-    private final boolean catchIllegalSeekException;
 
     /**
      * Action calls {@link Player#seekTo(long)}.
@@ -128,7 +125,6 @@ public Seek(String tag, long positionMs) {
       super(tag, "Seek:" + positionMs);
       this.windowIndex = null;
       this.positionMs = positionMs;
-      catchIllegalSeekException = false;
     }
 
     /**
@@ -137,170 +133,24 @@ public Seek(String tag, long positionMs) {
      * @param tag A tag to use for logging.
      * @param windowIndex The window to seek to.
      * @param positionMs The seek position.
-     * @param catchIllegalSeekException Whether {@link IllegalSeekPositionException} should be
-     *     silently caught or not.
      */
-    public Seek(String tag, int windowIndex, long positionMs, boolean catchIllegalSeekException) {
+    public Seek(String tag, int windowIndex, long positionMs) {
       super(tag, "Seek:" + positionMs);
       this.windowIndex = windowIndex;
       this.positionMs = positionMs;
-      this.catchIllegalSeekException = catchIllegalSeekException;
     }
 
     @Override
     protected void doActionImpl(
         SimpleExoPlayer player, DefaultTrackSelector trackSelector, Surface surface) {
-      try {
-        if (windowIndex == null) {
-          player.seekTo(positionMs);
-        } else {
-          player.seekTo(windowIndex, positionMs);
-        }
-      } catch (IllegalSeekPositionException e) {
-        if (!catchIllegalSeekException) {
-          throw e;
-        }
+      if (windowIndex == null) {
+        player.seekTo(positionMs);
+      } else {
+        player.seekTo(windowIndex, positionMs);
       }
     }
   }
 
-  /** Calls {@link SimpleExoPlayer#setMediaItems(List, int, long)}. */
-  public static final class SetMediaItems extends Action {
-
-    private final int windowIndex;
-    private final long positionMs;
-    private final MediaSource[] mediaSources;
-
-    /**
-     * @param tag A tag to use for logging.
-     * @param windowIndex The window index to start playback from.
-     * @param positionMs The position in milliseconds to start playback from.
-     * @param mediaSources The media sources to populate the playlist with.
-     */
-    public SetMediaItems(
-        String tag, int windowIndex, long positionMs, MediaSource... mediaSources) {
-      super(tag, "SetMediaItems");
-      this.windowIndex = windowIndex;
-      this.positionMs = positionMs;
-      this.mediaSources = mediaSources;
-    }
-
-    @Override
-    protected void doActionImpl(
-        SimpleExoPlayer player, DefaultTrackSelector trackSelector, Surface surface) {
-      player.setMediaItems(Arrays.asList(mediaSources), windowIndex, positionMs);
-    }
-  }
-
-  /** Calls {@link SimpleExoPlayer#setMediaItems(List, boolean)}. */
-  public static final class SetMediaItemsResetPosition extends Action {
-
-    private final boolean resetPosition;
-    private final MediaSource[] mediaSources;
-
-    /**
-     * @param tag A tag to use for logging.
-     * @param resetPosition Whether the position should be reset.
-     * @param mediaSources The media sources to populate the playlist with.
-     */
-    public SetMediaItemsResetPosition(
-        String tag, boolean resetPosition, MediaSource... mediaSources) {
-      super(tag, "SetMediaItems");
-      this.resetPosition = resetPosition;
-      this.mediaSources = mediaSources;
-    }
-
-    @Override
-    protected void doActionImpl(
-        SimpleExoPlayer player, DefaultTrackSelector trackSelector, Surface surface) {
-      player.setMediaItems(Arrays.asList(mediaSources), resetPosition);
-    }
-  }
-
-  /** Calls {@link SimpleExoPlayer#moveMediaItem(int, int)}. */
-  public static class MoveMediaItem extends Action {
-
-    private final int currentIndex;
-    private final int newIndex;
-
-    /**
-     * @param tag A tag to use for logging.
-     * @param currentIndex The current index of the media item.
-     * @param newIndex The new index of the media item.
-     */
-    public MoveMediaItem(String tag, int currentIndex, int newIndex) {
-      super(tag, "MoveMediaItem");
-      this.currentIndex = currentIndex;
-      this.newIndex = newIndex;
-    }
-
-    @Override
-    protected void doActionImpl(
-        SimpleExoPlayer player, DefaultTrackSelector trackSelector, Surface surface) {
-      player.moveMediaItem(currentIndex, newIndex);
-    }
-  }
-
-  /** Calls {@link SimpleExoPlayer#removeMediaItem(int)}. */
-  public static class RemoveMediaItem extends Action {
-
-    private final int index;
-
-    /**
-     * @param tag A tag to use for logging.
-     * @param index The index of the item to remove.
-     */
-    public RemoveMediaItem(String tag, int index) {
-      super(tag, "RemoveMediaItem");
-      this.index = index;
-    }
-
-    @Override
-    protected void doActionImpl(
-        SimpleExoPlayer player, DefaultTrackSelector trackSelector, Surface surface) {
-      player.removeMediaItem(index);
-    }
-  }
-
-  /** Calls {@link SimpleExoPlayer#removeMediaItems(int, int)}. */
-  public static class RemoveMediaItems extends Action {
-
-    private final int fromIndex;
-    private final int toIndex;
-
-    /**
-     * @param tag A tag to use for logging.
-     * @param fromIndex The start if the range of media items to remove.
-     * @param toIndex The end of the range of media items to remove (exclusive).
-     */
-    public RemoveMediaItems(String tag, int fromIndex, int toIndex) {
-      super(tag, "RemoveMediaItem");
-      this.fromIndex = fromIndex;
-      this.toIndex = toIndex;
-    }
-
-    @Override
-    protected void doActionImpl(
-        SimpleExoPlayer player, DefaultTrackSelector trackSelector, Surface surface) {
-      player.removeMediaItems(fromIndex, toIndex);
-    }
-  }
-
-  /** Calls {@link SimpleExoPlayer#clearMediaItems()}}. */
-  public static class ClearMediaItems extends Action {
-
-    /** @param tag A tag to use for logging. */
-    public ClearMediaItems(String tag) {
-      super(tag, "ClearMediaItems");
-    }
-
-    @Override
-    protected void doActionImpl(
-        SimpleExoPlayer player, DefaultTrackSelector trackSelector, Surface surface) {
-      player.clearMediaItems();
-    }
-  }
-
   /** Calls {@link Player#stop()} or {@link Player#stop(boolean)}. */
   public static final class Stop extends Action {
 
@@ -359,6 +209,27 @@ protected void doActionImpl(
         SimpleExoPlayer player, DefaultTrackSelector trackSelector, Surface surface) {
       player.setPlayWhenReady(playWhenReady);
     }
+
+  }
+
+  /** Broadcasts an {@link Intent}. */
+  public static final class SendBroadcast extends Action {
+    private final Intent intent;
+
+    /**
+     * @param tag A tag to use for logging.
+     * @param intent The {@link Intent} to broadcast.
+     */
+    public SendBroadcast(String tag, Intent intent) {
+      super(tag, "SendBroadcast: " + intent.getAction());
+      this.intent = intent;
+    }
+
+    @Override
+    protected void doActionImpl(
+        SimpleExoPlayer player, DefaultTrackSelector trackSelector, Surface surface) {
+      ApplicationProvider.getApplicationContext().sendBroadcast(intent);
+    }
   }
 
   /**
@@ -419,28 +290,42 @@ protected void doActionImpl(
     }
   }
 
-  /** Calls {@link ExoPlayer#prepare()}. */
-  public static final class Prepare extends Action {
+  /** Calls {@link ExoPlayer#prepare(MediaSource)}. */
+  public static final class PrepareSource extends Action {
+
+    private final MediaSource mediaSource;
+    private final boolean resetPosition;
+    private final boolean resetState;
+
     /** @param tag A tag to use for logging. */
-    public Prepare(String tag) {
-      super(tag, "Prepare");
+    public PrepareSource(String tag, MediaSource mediaSource) {
+      this(tag, mediaSource, true, true);
+    }
+
+    /** @param tag A tag to use for logging. */
+    public PrepareSource(
+        String tag, MediaSource mediaSource, boolean resetPosition, boolean resetState) {
+      super(tag, "PrepareSource");
+      this.mediaSource = mediaSource;
+      this.resetPosition = resetPosition;
+      this.resetState = resetState;
     }
 
     @Override
     protected void doActionImpl(
         SimpleExoPlayer player, DefaultTrackSelector trackSelector, Surface surface) {
-      player.prepare();
+      player.prepare(mediaSource, resetPosition, resetState);
     }
   }
 
   /** Calls {@link Player#setRepeatMode(int)}. */
   public static final class SetRepeatMode extends Action {
 
-    @Player.RepeatMode private final int repeatMode;
+    private final @Player.RepeatMode int repeatMode;
 
     /** @param tag A tag to use for logging. */
     public SetRepeatMode(String tag, @Player.RepeatMode int repeatMode) {
-      super(tag, "SetRepeatMode: " + repeatMode);
+      super(tag, "SetRepeatMode:" + repeatMode);
       this.repeatMode = repeatMode;
     }
 
@@ -451,27 +336,6 @@ protected void doActionImpl(
     }
   }
 
-  /** Calls {@link ExoPlayer#setShuffleOrder(ShuffleOrder)} . */
-  public static final class SetShuffleOrder extends Action {
-
-    private final ShuffleOrder shuffleOrder;
-
-    /**
-     * @param tag A tag to use for logging.
-     * @param shuffleOrder The shuffle order.
-     */
-    public SetShuffleOrder(String tag, ShuffleOrder shuffleOrder) {
-      super(tag, "SetShufflerOrder");
-      this.shuffleOrder = shuffleOrder;
-    }
-
-    @Override
-    protected void doActionImpl(
-        SimpleExoPlayer player, DefaultTrackSelector trackSelector, Surface surface) {
-      player.setShuffleOrder(shuffleOrder);
-    }
-  }
-
   /** Calls {@link Player#setShuffleModeEnabled(boolean)}. */
   public static final class SetShuffleModeEnabled extends Action {
 
@@ -479,7 +343,7 @@ protected void doActionImpl(
 
     /** @param tag A tag to use for logging. */
     public SetShuffleModeEnabled(String tag, boolean shuffleModeEnabled) {
-      super(tag, "SetShuffleModeEnabled: " + shuffleModeEnabled);
+      super(tag, "SetShuffleModeEnabled:" + shuffleModeEnabled);
       this.shuffleModeEnabled = shuffleModeEnabled;
     }
 
@@ -566,6 +430,7 @@ protected void doActionImpl(
         SimpleExoPlayer player, DefaultTrackSelector trackSelector, Surface surface) {
       player.setPlaybackParameters(playbackParameters);
     }
+
   }
 
   /** Throws a playback exception on the playback thread. */
@@ -662,35 +527,18 @@ protected void doActionImpl(
   /** Waits for {@link Player.EventListener#onTimelineChanged(Timeline, int)}. */
   public static final class WaitForTimelineChanged extends Action {
 
-    private final Timeline expectedTimeline;
-    private final boolean ignoreExpectedReason;
-    @Player.TimelineChangeReason private final int expectedReason;
+    @Nullable private final Timeline expectedTimeline;
 
     /**
-     * Creates action waiting for a timeline change for a given reason.
+     * Creates action waiting for a timeline change.
      *
      * @param tag A tag to use for logging.
-     * @param expectedTimeline The expected timeline or null if any timeline change is relevant.
-     * @param expectedReason The expected timeline change reason.
+     * @param expectedTimeline The expected timeline to wait for. If null, wait for any timeline
+     *     change.
      */
-    public WaitForTimelineChanged(
-        String tag, Timeline expectedTimeline, @Player.TimelineChangeReason int expectedReason) {
+    public WaitForTimelineChanged(String tag, @Nullable Timeline expectedTimeline) {
       super(tag, "WaitForTimelineChanged");
       this.expectedTimeline = expectedTimeline;
-      this.ignoreExpectedReason = false;
-      this.expectedReason = expectedReason;
-    }
-
-    /**
-     * Creates action waiting for any timeline change for any reason.
-     *
-     * @param tag A tag to use for logging.
-     */
-    public WaitForTimelineChanged(String tag) {
-      super(tag, "WaitForTimelineChanged");
-      this.expectedTimeline = null;
-      this.ignoreExpectedReason = true;
-      this.expectedReason = Player.TIMELINE_CHANGE_REASON_PLAYLIST_CHANGED;
     }
 
     @Override
@@ -708,9 +556,7 @@ protected void doActionAndScheduleNextImpl(
             @Override
             public void onTimelineChanged(
                 Timeline timeline, @Player.TimelineChangeReason int reason) {
-              if ((expectedTimeline == null
-                      || TestUtil.areTimelinesSame(expectedTimeline, timeline))
-                  && (ignoreExpectedReason || expectedReason == reason)) {
+              if (expectedTimeline == null || timeline.equals(expectedTimeline)) {
                 player.removeListener(this);
                 nextAction.schedule(player, trackSelector, surface, handler);
               }
@@ -898,7 +744,7 @@ protected void doActionImpl(
     }
   }
 
-  /** Calls {@code Runnable.run()}. */
+  /** Calls {@link Runnable#run()}. */
   public static final class ExecuteRunnable extends Action {
 
     private final Runnable runnable;
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java
index 3a1ca37c55..9cc8790757 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.testutil;
 
+import android.content.Intent;
 import android.os.Looper;
 import android.view.Surface;
 import androidx.annotation.Nullable;
@@ -27,18 +28,18 @@
 import com.google.android.exoplayer2.SimpleExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.MediaSource;
-import com.google.android.exoplayer2.source.ShuffleOrder;
 import com.google.android.exoplayer2.testutil.Action.ClearVideoSurface;
 import com.google.android.exoplayer2.testutil.Action.ExecuteRunnable;
 import com.google.android.exoplayer2.testutil.Action.PlayUntilPosition;
+import com.google.android.exoplayer2.testutil.Action.PrepareSource;
 import com.google.android.exoplayer2.testutil.Action.Seek;
+import com.google.android.exoplayer2.testutil.Action.SendBroadcast;
 import com.google.android.exoplayer2.testutil.Action.SendMessages;
 import com.google.android.exoplayer2.testutil.Action.SetPlayWhenReady;
 import com.google.android.exoplayer2.testutil.Action.SetPlaybackParameters;
 import com.google.android.exoplayer2.testutil.Action.SetRendererDisabled;
 import com.google.android.exoplayer2.testutil.Action.SetRepeatMode;
 import com.google.android.exoplayer2.testutil.Action.SetShuffleModeEnabled;
-import com.google.android.exoplayer2.testutil.Action.SetShuffleOrder;
 import com.google.android.exoplayer2.testutil.Action.SetVideoSurface;
 import com.google.android.exoplayer2.testutil.Action.Stop;
 import com.google.android.exoplayer2.testutil.Action.ThrowPlaybackException;
@@ -170,19 +171,7 @@ public Builder seek(long positionMs) {
      * @return The builder, for convenience.
      */
     public Builder seek(int windowIndex, long positionMs) {
-      return apply(new Seek(tag, windowIndex, positionMs, /* catchIllegalSeekException= */ false));
-    }
-
-    /**
-     * Schedules a seek action to be executed.
-     *
-     * @param windowIndex The window to seek to.
-     * @param positionMs The seek position.
-     * @param catchIllegalSeekException Whether an illegal seek position should be caught or not.
-     * @return The builder, for convenience.
-     */
-    public Builder seek(int windowIndex, long positionMs, boolean catchIllegalSeekException) {
-      return apply(new Seek(tag, windowIndex, positionMs, catchIllegalSeekException));
+      return apply(new Seek(tag, windowIndex, positionMs));
     }
 
     /**
@@ -314,90 +303,23 @@ public Builder setVideoSurface() {
     }
 
     /**
-     * Schedules a set media items action to be executed.
-     *
-     * @param windowIndex The window index to start playback from or {@link C#INDEX_UNSET} if the
-     *     playback position should not be reset.
-     * @param positionMs The position in milliseconds from where playback should start. If {@link
-     *     C#TIME_UNSET} is passed the default position is used. In any case, if {@code windowIndex}
-     *     is set to {@link C#INDEX_UNSET} the position is not reset at all and this parameter is
-     *     ignored.
-     * @return The builder, for convenience.
-     */
-    public Builder setMediaItems(int windowIndex, long positionMs, MediaSource... sources) {
-      return apply(new Action.SetMediaItems(tag, windowIndex, positionMs, sources));
-    }
-
-    /**
-     * Schedules a set media items action to be executed.
+     * Schedules a new source preparation action to be executed.
      *
-     * @param resetPosition Whether the playback position should be reset.
      * @return The builder, for convenience.
      */
-    public Builder setMediaItems(boolean resetPosition, MediaSource... sources) {
-      return apply(new Action.SetMediaItemsResetPosition(tag, resetPosition, sources));
+    public Builder prepareSource(MediaSource mediaSource) {
+      return apply(new PrepareSource(tag, mediaSource));
     }
 
     /**
-     * Schedules a set media items action to be executed.
+     * Schedules a new source preparation action to be executed.
      *
-     * @return The builder, for convenience.
-     */
-    public Builder setMediaItems(MediaSource... sources) {
-      return apply(
-          new Action.SetMediaItems(
-              tag, /* windowIndex */ C.INDEX_UNSET, /* positionUs */ C.TIME_UNSET, sources));
-    }
-
-    /**
-     * Schedules a move media item action to be executed.
-     *
-     * @param currentIndex The current index of the item to move.
-     * @param newIndex The index after the item has been moved.
-     * @return The builder, for convenience.
-     */
-    public Builder moveMediaItem(int currentIndex, int newIndex) {
-      return apply(new Action.MoveMediaItem(tag, currentIndex, newIndex));
-    }
-
-    /**
-     * Schedules a remove media item action to be executed.
-     *
-     * @param index The index of the media item to be removed.
      * @see com.google.android.exoplayer2.ExoPlayer#prepare(MediaSource, boolean, boolean)
      * @return The builder, for convenience.
      */
-    public Builder removeMediaItem(int index) {
-      return apply(new Action.RemoveMediaItem(tag, index));
-    }
-
-    /**
-     * Schedules a remove media items action to be executed.
-     *
-     * @param fromIndex The start of the range of media items to be removed.
-     * @param toIndex The end of the range of media items to be removed (exclusive).
-     * @return The builder, for convenience.
-     */
-    public Builder removeMediaItems(int fromIndex, int toIndex) {
-      return apply(new Action.RemoveMediaItems(tag, fromIndex, toIndex));
-    }
-
-    /**
-     * Schedules a prepare action to be executed.
-     *
-     * @return The builder, for convenience.
-     */
-    public Builder prepare() {
-      return apply(new Action.Prepare(tag));
-    }
-
-    /**
-     * Schedules a clear media items action to be created.
-     *
-     * @return The builder. for convenience,
-     */
-    public Builder clearMediaItems() {
-      return apply(new Action.ClearMediaItems(tag));
+    public Builder prepareSource(
+        MediaSource mediaSource, boolean resetPosition, boolean resetState) {
+      return apply(new PrepareSource(tag, mediaSource, resetPosition, resetState));
     }
 
     /**
@@ -409,16 +331,6 @@ public Builder setRepeatMode(@Player.RepeatMode int repeatMode) {
       return apply(new SetRepeatMode(tag, repeatMode));
     }
 
-    /**
-     * Schedules a set shuffle order action to be executed.
-     *
-     * @param shuffleOrder The shuffle order.
-     * @return The builder, for convenience.
-     */
-    public Builder setShuffleOrder(ShuffleOrder shuffleOrder) {
-      return apply(new SetShuffleOrder(tag, shuffleOrder));
-    }
-
     /**
      * Schedules a shuffle setting action to be executed.
      *
@@ -466,25 +378,34 @@ public Builder sendMessage(
       return apply(new SendMessages(tag, target, windowIndex, positionMs, deleteAfterDelivery));
     }
 
+    /**
+     * Schedules broadcasting an {@link Intent}.
+     *
+     * @param intent An intent to broadcast.
+     * @return The builder, for convenience.
+     */
+    public Builder sendBroadcast(Intent intent) {
+      return apply(new SendBroadcast(tag, intent));
+    }
+
     /**
      * Schedules a delay until any timeline change.
      *
      * @return The builder, for convenience.
      */
     public Builder waitForTimelineChanged() {
-      return apply(new WaitForTimelineChanged(tag));
+      return apply(new WaitForTimelineChanged(tag, /* expectedTimeline= */ null));
     }
 
     /**
      * Schedules a delay until the timeline changed to a specified expected timeline.
      *
-     * @param expectedTimeline The expected timeline.
-     * @param expectedReason The expected reason of the timeline change.
+     * @param expectedTimeline The expected timeline to wait for. If null, wait for any timeline
+     *     change.
      * @return The builder, for convenience.
      */
-    public Builder waitForTimelineChanged(
-        Timeline expectedTimeline, @Player.TimelineChangeReason int expectedReason) {
-      return apply(new WaitForTimelineChanged(tag, expectedTimeline, expectedReason));
+    public Builder waitForTimelineChanged(Timeline expectedTimeline) {
+      return apply(new WaitForTimelineChanged(tag, expectedTimeline));
     }
 
     /**
@@ -595,9 +516,7 @@ public final void run() {
     }
   }
 
-  /**
-   * Wraps an {@link Action}, allowing a delay and a next {@link Action} to be specified.
-   */
+  /** Wraps an {@link Action}, allowing a delay and a next {@link Action} to be specified. */
   /* package */ static final class ActionNode implements Runnable {
 
     private final Action action;
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoHostedTest.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoHostedTest.java
index b00ad287bb..5f01d7724b 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoHostedTest.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoHostedTest.java
@@ -141,8 +141,7 @@ public final void onStart(HostActivity host, Surface surface) {
       pendingSchedule = null;
     }
     DrmSessionManager<FrameworkMediaCrypto> drmSessionManager = buildDrmSessionManager(userAgent);
-    player.setMediaItem(buildSource(host, Util.getUserAgent(host, userAgent), drmSessionManager));
-    player.prepare();
+    player.prepare(buildSource(host, Util.getUserAgent(host, userAgent), drmSessionManager));
   }
 
   @Override
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerTestRunner.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerTestRunner.java
index 7b53c8d964..d64a44ac04 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerTestRunner.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerTestRunner.java
@@ -16,7 +16,6 @@
 package com.google.android.exoplayer2.testutil;
 
 import static com.google.common.truth.Truth.assertThat;
-import static junit.framework.TestCase.assertTrue;
 
 import android.content.Context;
 import android.os.HandlerThread;
@@ -37,7 +36,6 @@
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
-import com.google.android.exoplayer2.trackselection.TrackSelector;
 import com.google.android.exoplayer2.upstream.BandwidthMeter;
 import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
 import com.google.android.exoplayer2.util.Clock;
@@ -45,7 +43,6 @@
 import com.google.android.exoplayer2.util.MimeTypes;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
@@ -74,8 +71,8 @@
 
     private Clock clock;
     private Timeline timeline;
-    private List<MediaSource> mediaSources;
     private Object manifest;
+    private MediaSource mediaSource;
     private DefaultTrackSelector trackSelector;
     private LoadControl loadControl;
     private BandwidthMeter bandwidthMeter;
@@ -87,22 +84,18 @@
     private AnalyticsListener analyticsListener;
     private Integer expectedPlayerEndedCount;
 
-    public Builder() {
-      mediaSources = new ArrayList<>();
-    }
-
     /**
      * Sets a {@link Timeline} to be used by a {@link FakeMediaSource} in the test runner. The
      * default value is a seekable, non-dynamic {@link FakeTimeline} with a duration of {@link
      * FakeTimeline.TimelineWindowDefinition#DEFAULT_WINDOW_DURATION_US}. Setting the timeline is
-     * not allowed after a call to {@link #setMediaSources(MediaSource...)}.
+     * not allowed after a call to {@link #setMediaSource(MediaSource)}.
      *
      * @param timeline A {@link Timeline} to be used by a {@link FakeMediaSource} in the test
      *     runner.
      * @return This builder.
      */
     public Builder setTimeline(Timeline timeline) {
-      assertThat(mediaSources).isEmpty();
+      assertThat(mediaSource).isNull();
       this.timeline = timeline;
       return this;
     }
@@ -110,30 +103,30 @@ public Builder setTimeline(Timeline timeline) {
     /**
      * Sets a manifest to be used by a {@link FakeMediaSource} in the test runner. The default value
      * is null. Setting the manifest is not allowed after a call to {@link
-     * #setMediaSources(MediaSource...)}.
+     * #setMediaSource(MediaSource)}.
      *
      * @param manifest A manifest to be used by a {@link FakeMediaSource} in the test runner.
      * @return This builder.
      */
     public Builder setManifest(Object manifest) {
-      assertThat(mediaSources).isEmpty();
+      assertThat(mediaSource).isNull();
       this.manifest = manifest;
       return this;
     }
 
     /**
-     * Sets the {@link MediaSource}s to be used by the test runner. The default value is a {@link
+     * Sets a {@link MediaSource} to be used by the test runner. The default value is a {@link
      * FakeMediaSource} with the timeline and manifest provided by {@link #setTimeline(Timeline)}
-     * and {@link #setManifest(Object)}. Setting media sources is not allowed after calls to {@link
-     * #setTimeline(Timeline)} and/or {@link #setManifest(Object)}.
+     * and {@link #setManifest(Object)}. Setting the media source is not allowed after calls to
+     * {@link #setTimeline(Timeline)} and/or {@link #setManifest(Object)}.
      *
-     * @param mediaSources The {@link MediaSource}s to be used by the test runner.
+     * @param mediaSource A {@link MediaSource} to be used by the test runner.
      * @return This builder.
      */
-    public Builder setMediaSources(MediaSource... mediaSources) {
+    public Builder setMediaSource(MediaSource mediaSource) {
       assertThat(timeline).isNull();
       assertThat(manifest).isNull();
-      this.mediaSources = Arrays.asList(mediaSources);
+      this.mediaSource = mediaSource;
       return this;
     }
 
@@ -177,7 +170,7 @@ public Builder setBandwidthMeter(BandwidthMeter bandwidthMeter) {
      * Sets a list of {@link Format}s to be used by a {@link FakeMediaSource} to create media
      * periods and for setting up a {@link FakeRenderer}. The default value is a single {@link
      * #VIDEO_FORMAT}. Note that this parameter doesn't have any influence if both a media source
-     * with {@link #setMediaSources(MediaSource...)} and renderers with {@link
+     * with {@link #setMediaSource(MediaSource)} and renderers with {@link
      * #setRenderers(Renderer...)} or {@link #setRenderersFactory(RenderersFactory)} are set.
      *
      * @param supportedFormats A list of supported {@link Format}s.
@@ -231,7 +224,7 @@ public Builder setClock(Clock clock) {
 
     /**
      * Sets an {@link ActionSchedule} to be run by the test runner. The first action will be
-     * executed immediately before {@link SimpleExoPlayer#prepare()}.
+     * executed immediately before {@link SimpleExoPlayer#prepare(MediaSource)}.
      *
      * @param actionSchedule An {@link ActionSchedule} to be used by the test runner.
      * @return This builder.
@@ -312,11 +305,11 @@ public ExoPlayerTestRunner build(Context context) {
       if (clock == null) {
         clock = new AutoAdvancingFakeClock();
       }
-      if (mediaSources.isEmpty()) {
+      if (mediaSource == null) {
         if (timeline == null) {
           timeline = new FakeTimeline(/* windowCount= */ 1, manifest);
         }
-        mediaSources.add(new FakeMediaSource(timeline, supportedFormats));
+        mediaSource = new FakeMediaSource(timeline, supportedFormats);
       }
       if (expectedPlayerEndedCount == null) {
         expectedPlayerEndedCount = 1;
@@ -324,7 +317,7 @@ public ExoPlayerTestRunner build(Context context) {
       return new ExoPlayerTestRunner(
           context,
           clock,
-          mediaSources,
+          mediaSource,
           renderersFactory,
           trackSelector,
           loadControl,
@@ -338,7 +331,7 @@ public ExoPlayerTestRunner build(Context context) {
 
   private final Context context;
   private final Clock clock;
-  private final List<MediaSource> mediaSources;
+  private final MediaSource mediaSource;
   private final RenderersFactory renderersFactory;
   private final DefaultTrackSelector trackSelector;
   private final LoadControl loadControl;
@@ -355,7 +348,6 @@ public ExoPlayerTestRunner build(Context context) {
   private final ArrayList<Integer> timelineChangeReasons;
   private final ArrayList<Integer> periodIndices;
   private final ArrayList<Integer> discontinuityReasons;
-  private final ArrayList<Integer> playbackStates;
 
   private SimpleExoPlayer player;
   private Exception exception;
@@ -365,7 +357,7 @@ public ExoPlayerTestRunner build(Context context) {
   private ExoPlayerTestRunner(
       Context context,
       Clock clock,
-      List<MediaSource> mediaSources,
+      MediaSource mediaSource,
       RenderersFactory renderersFactory,
       DefaultTrackSelector trackSelector,
       LoadControl loadControl,
@@ -376,7 +368,7 @@ private ExoPlayerTestRunner(
       int expectedPlayerEndedCount) {
     this.context = context;
     this.clock = clock;
-    this.mediaSources = mediaSources;
+    this.mediaSource = mediaSource;
     this.renderersFactory = renderersFactory;
     this.trackSelector = trackSelector;
     this.loadControl = loadControl;
@@ -388,7 +380,6 @@ private ExoPlayerTestRunner(
     this.timelineChangeReasons = new ArrayList<>();
     this.periodIndices = new ArrayList<>();
     this.discontinuityReasons = new ArrayList<>();
-    this.playbackStates = new ArrayList<>();
     this.endedCountDownLatch = new CountDownLatch(expectedPlayerEndedCount);
     this.actionScheduleFinishedCountDownLatch = new CountDownLatch(actionSchedule != null ? 1 : 0);
     this.playerThread = new HandlerThread("ExoPlayerTest thread");
@@ -400,18 +391,35 @@ private ExoPlayerTestRunner(
 
   /**
    * Starts the test runner on its own thread. This will trigger the creation of the player, the
-   * listener registration, the start of the action schedule, and the preparation of the player
-   * with the provided media source.
+   * listener registration, the start of the action schedule, the initial set of media items and the
+   * preparation of the player.
    *
    * @return This test runner.
    */
   public ExoPlayerTestRunner start() {
+    return start(/* doPrepare= */ true);
+  }
+
+  /**
+   * Starts the test runner on its own thread. This will trigger the creation of the player, the
+   * listener registration, the start of the action schedule and the initial set of media items.
+   *
+   * @param doPrepare Whether the player should be prepared.
+   * @return This test runner.
+   */
+  public ExoPlayerTestRunner start(boolean doPrepare) {
     handler.post(
         () -> {
           try {
             player =
-                new TestSimpleExoPlayer(
-                    context, renderersFactory, trackSelector, loadControl, bandwidthMeter, clock);
+                new SimpleExoPlayer.Builder(context, renderersFactory)
+                    .setTrackSelector(trackSelector)
+                    .setLoadControl(loadControl)
+                    .setBandwidthMeter(bandwidthMeter)
+                    .setAnalyticsCollector(new AnalyticsCollector(clock))
+                    .setClock(clock)
+                    .setLooper(Looper.myLooper())
+                    .build();
             player.addListener(ExoPlayerTestRunner.this);
             if (eventListener != null) {
               player.addListener(eventListener);
@@ -423,8 +431,7 @@ public ExoPlayerTestRunner start() {
             if (actionSchedule != null) {
               actionSchedule.start(player, trackSelector, null, handler, ExoPlayerTestRunner.this);
             }
-            player.setMediaItems(mediaSources, /* resetPosition= */ false);
-            player.prepare();
+            player.prepare(mediaSource, /* resetPosition= */ false, /* resetState= */ false);
           } catch (Exception e) {
             handleException(e);
           }
@@ -476,16 +483,12 @@ public ExoPlayerTestRunner blockUntilActionScheduleFinished(long timeoutMs)
 
   /**
    * Asserts that the timelines reported by {@link Player.EventListener#onTimelineChanged(Timeline,
-   * int)} are the same to the provided timelines. This assert differs from testing equality by not
-   * comparing period ids which may be different due to id mapping of child source period ids.
+   * int)} are equal to the provided timelines.
    *
    * @param timelines A list of expected {@link Timeline}s.
    */
-  public void assertTimelinesSame(Timeline... timelines) {
-    assertThat(this.timelines).hasSize(timelines.length);
-    for (int i = 0; i < timelines.length; i++) {
-      assertTrue(TestUtil.areTimelinesSame(timelines[i], this.timelines.get(i)));
-    }
+  public void assertTimelinesEqual(Timeline... timelines) {
+    assertThat(this.timelines).containsExactlyElementsIn(Arrays.asList(timelines)).inOrder();
   }
 
   /**
@@ -497,15 +500,6 @@ public void assertTimelineChangeReasonsEqual(Integer... reasons) {
     assertThat(timelineChangeReasons).containsExactlyElementsIn(Arrays.asList(reasons)).inOrder();
   }
 
-  /**
-   * Asserts that the playback states reported by {@link
-   * Player.EventListener#onPlayerStateChanged(boolean, int)} are equal to the provided playback
-   * states.
-   */
-  public void assertPlaybackStatesEqual(Integer... states) {
-    assertThat(playbackStates).containsExactlyElementsIn(Arrays.asList(states)).inOrder();
-  }
-
   /**
    * Asserts that the last track group array reported by {@link
    * Player.EventListener#onTracksChanged(TrackGroupArray, TrackSelectionArray)} is equal to the
@@ -581,12 +575,10 @@ private void handleException(Exception exception) {
 
   @Override
   public void onTimelineChanged(Timeline timeline, @Player.TimelineChangeReason int reason) {
-    timelineChangeReasons.add(reason);
     timelines.add(timeline);
-    int currentIndex = player.getCurrentPeriodIndex();
-    if (periodIndices.isEmpty() || periodIndices.get(periodIndices.size() - 1) != currentIndex) {
-      // Ignore timeline changes that do not change the period index.
-      periodIndices.add(currentIndex);
+    timelineChangeReasons.add(reason);
+    if (reason == Player.TIMELINE_CHANGE_REASON_PREPARED) {
+      periodIndices.add(player.getCurrentPeriodIndex());
     }
   }
 
@@ -597,7 +589,6 @@ public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray tra
 
   @Override
   public void onPlayerStateChanged(boolean playWhenReady, @Player.State int playbackState) {
-    playbackStates.add(playbackState);
     playerWasPrepared |= playbackState != Player.STATE_IDLE;
     if (playbackState == Player.STATE_ENDED
         || (playbackState == Player.STATE_IDLE && playerWasPrepared)) {
@@ -628,27 +619,4 @@ public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
   public void onActionScheduleFinished() {
     actionScheduleFinishedCountDownLatch.countDown();
   }
-
-  /** SimpleExoPlayer implementation using a custom Clock. */
-  private static final class TestSimpleExoPlayer extends SimpleExoPlayer {
-
-    public TestSimpleExoPlayer(
-        Context context,
-        RenderersFactory renderersFactory,
-        TrackSelector trackSelector,
-        LoadControl loadControl,
-        BandwidthMeter bandwidthMeter,
-        Clock clock) {
-      super(
-          context,
-          renderersFactory,
-          trackSelector,
-          loadControl,
-          bandwidthMeter,
-          new AnalyticsCollector(clock),
-          /* useLazyPreparation= */ false,
-          clock,
-          Looper.myLooper());
-    }
-  }
 }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaPeriod.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaPeriod.java
index 6d141fe04a..9c6fdc85cd 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaPeriod.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaPeriod.java
@@ -138,6 +138,11 @@ public boolean continueLoading(long positionUs) {
     return sequenceableLoader.continueLoading(positionUs);
   }
 
+  @Override
+  public boolean isLoading() {
+    return sequenceableLoader.isLoading();
+  }
+
   @Override
   protected SampleStream createSampleStream(TrackSelection trackSelection) {
     FakeChunkSource chunkSource =
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeDataSource.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeDataSource.java
index 9f6fdc9d49..ab7c5be5b2 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeDataSource.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeDataSource.java
@@ -52,7 +52,7 @@ public final Factory setIsNetwork(boolean isNetwork) {
     }
 
     @Override
-    public DataSource createDataSource() {
+    public FakeDataSource createDataSource() {
       return new FakeDataSource(fakeDataSet, isNetwork);
     }
   }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaPeriod.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaPeriod.java
index d524d381fa..bcc96ef47e 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaPeriod.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaPeriod.java
@@ -217,6 +217,11 @@ public boolean continueLoading(long positionUs) {
     return false;
   }
 
+  @Override
+  public boolean isLoading() {
+    return false;
+  }
+
   protected SampleStream createSampleStream(TrackSelection selection) {
     return new FakeSampleStream(
         selection.getSelectedFormat(), eventDispatcher, /* shouldOutputSample= */ true);
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTimeline.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTimeline.java
index af672f0da3..401fcf8034 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTimeline.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTimeline.java
@@ -189,6 +189,7 @@ public Window getWindow(int windowIndex, Window window, long defaultPositionProj
         /* windowStartTimeMs= */ C.TIME_UNSET,
         windowDefinition.isSeekable,
         windowDefinition.isDynamic,
+        /* isLive= */ windowDefinition.isDynamic,
         /* defaultPositionUs= */ 0,
         windowDefinition.durationUs,
         periodOffsets[windowIndex],
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/StubExoPlayer.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/StubExoPlayer.java
index a826e73e16..18eaec2cd7 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/StubExoPlayer.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/StubExoPlayer.java
@@ -25,10 +25,8 @@
 import com.google.android.exoplayer2.SeekParameters;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.MediaSource;
-import com.google.android.exoplayer2.source.ShuffleOrder;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
-import java.util.List;
 
 /**
  * An abstract {@link ExoPlayer} implementation that throws {@link UnsupportedOperationException}
@@ -98,11 +96,6 @@ public void retry() {
     throw new UnsupportedOperationException();
   }
 
-  @Override
-  public void prepare() {
-    throw new UnsupportedOperationException();
-  }
-
   @Override
   public void prepare(MediaSource mediaSource) {
     throw new UnsupportedOperationException();
@@ -113,77 +106,6 @@ public void prepare(MediaSource mediaSource, boolean resetPosition, boolean rese
     throw new UnsupportedOperationException();
   }
 
-  @Override
-  public void setMediaItems(List<MediaSource> mediaItems, boolean resetPosition) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void setMediaItems(List<MediaSource> mediaItems) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void setMediaItems(
-      List<MediaSource> mediaItems, int startWindowIndex, long startPositionMs) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void setMediaItem(MediaSource mediaItem, long startPositionMs) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void setMediaItem(MediaSource mediaItem) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void addMediaItem(MediaSource mediaSource) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void addMediaItem(int index, MediaSource mediaSource) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void addMediaItems(List<MediaSource> mediaSources) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void addMediaItems(int index, List<MediaSource> mediaSources) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void moveMediaItem(int currentIndex, int newIndex) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void moveMediaItems(int fromIndex, int toIndex, int newIndex) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public MediaSource removeMediaItem(int index) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void removeMediaItems(int fromIndex, int toIndex) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void clearMediaItems() {
-    throw new UnsupportedOperationException();
-  }
-
   @Override
   public void setPlayWhenReady(boolean playWhenReady) {
     throw new UnsupportedOperationException();
@@ -204,11 +126,6 @@ public int getRepeatMode() {
     throw new UnsupportedOperationException();
   }
 
-  @Override
-  public void setShuffleOrder(ShuffleOrder shuffleOrder) {
-    throw new UnsupportedOperationException();
-  }
-
   @Override
   public void setShuffleModeEnabled(boolean shuffleModeEnabled) {
     throw new UnsupportedOperationException();
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
index 52c12f78b2..facfa0d7e4 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
@@ -26,7 +26,6 @@
 import android.graphics.Color;
 import android.net.Uri;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.database.DatabaseProvider;
 import com.google.android.exoplayer2.database.DefaultDatabaseProvider;
 import com.google.android.exoplayer2.extractor.DefaultExtractorInput;
@@ -399,61 +398,4 @@ public static ExtractorInput getExtractorInputFromPosition(
     }
     return new DefaultExtractorInput(dataSource, position, length);
   }
-
-  /**
-   * Checks whether the timelines are the same (does not compare {@link Timeline.Window#uid} and
-   * {@link Timeline.Period#uid}).
-   *
-   * @param firstTimeline The first {@link Timeline}.
-   * @param secondTimeline The second {@link Timeline} to compare with.
-   * @return {@code true} if both timelines are the same.
-   */
-  public static boolean areTimelinesSame(Timeline firstTimeline, Timeline secondTimeline) {
-    if (firstTimeline == secondTimeline) {
-      return true;
-    }
-    if (secondTimeline.getWindowCount() != firstTimeline.getWindowCount()
-        || secondTimeline.getPeriodCount() != firstTimeline.getPeriodCount()) {
-      return false;
-    }
-    Timeline.Window firstWindow = new Timeline.Window();
-    Timeline.Period firstPeriod = new Timeline.Period();
-    Timeline.Window secondWindow = new Timeline.Window();
-    Timeline.Period secondPeriod = new Timeline.Period();
-    for (int i = 0; i < firstTimeline.getWindowCount(); i++) {
-      if (!areWindowsSame(
-          firstTimeline.getWindow(i, firstWindow), secondTimeline.getWindow(i, secondWindow))) {
-        return false;
-      }
-    }
-    for (int i = 0; i < firstTimeline.getPeriodCount(); i++) {
-      if (!firstTimeline
-          .getPeriod(i, firstPeriod, /* setIds= */ false)
-          .equals(secondTimeline.getPeriod(i, secondPeriod, /* setIds= */ false))) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  /**
-   * Checks whether the windows are the same. This comparison does not compare the uid.
-   *
-   * @param first The first {@link Timeline.Window}.
-   * @param second The second {@link Timeline.Window}.
-   * @return true if both windows are the same.
-   */
-  private static boolean areWindowsSame(Timeline.Window first, Timeline.Window second) {
-    return Util.areEqual(first.tag, second.tag)
-        && Util.areEqual(first.manifest, second.manifest)
-        && first.presentationStartTimeMs == second.presentationStartTimeMs
-        && first.windowStartTimeMs == second.windowStartTimeMs
-        && first.isSeekable == second.isSeekable
-        && first.isDynamic == second.isDynamic
-        && first.defaultPositionUs == second.defaultPositionUs
-        && first.durationUs == second.durationUs
-        && first.firstPeriodIndex == second.firstPeriodIndex
-        && first.lastPeriodIndex == second.lastPeriodIndex
-        && first.positionInFirstPeriodUs == second.positionInFirstPeriodUs;
-  }
 }
