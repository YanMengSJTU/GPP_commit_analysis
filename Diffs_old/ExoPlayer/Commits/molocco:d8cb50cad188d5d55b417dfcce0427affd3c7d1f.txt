diff --git a/build.gradle b/build.gradle
index fd9560cbb2..24810b28d5 100644
--- a/build.gradle
+++ b/build.gradle
@@ -17,7 +17,7 @@ buildscript {
         google()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.1.1'
+        classpath 'com.android.tools.build:gradle:3.1.2'
         classpath 'com.novoda:bintray-release:0.8.1'
     }
     // Workaround for the following test coverage issue. Remove when fixed:
diff --git a/demos/main/build.gradle b/demos/main/build.gradle
index ce0992eb7a..d365e476c4 100644
--- a/demos/main/build.gradle
+++ b/demos/main/build.gradle
@@ -58,6 +58,8 @@ android {
 
 dependencies {
     implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    implementation 'com.android.support:support-compat:' + supportLibraryVersion
+    implementation 'com.android.support:support-core-utils:' + supportLibraryVersion
     implementation project(modulePrefix + 'library-core')
     implementation project(modulePrefix + 'library-dash')
     implementation project(modulePrefix + 'library-hls')
diff --git a/demos/main/src/main/AndroidManifest.xml b/demos/main/src/main/AndroidManifest.xml
index cde95300ab..dc07b95aa3 100644
--- a/demos/main/src/main/AndroidManifest.xml
+++ b/demos/main/src/main/AndroidManifest.xml
@@ -1,5 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="utf-8"?><!-- Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -17,62 +16,80 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer2.demo">
 
-  <uses-permission android:name="android.permission.INTERNET"/>
-  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
-  <uses-feature android:name="android.software.leanback" android:required="false"/>
-  <uses-feature android:name="android.hardware.touchscreen" android:required="false"/>
-  <uses-sdk/>
-
-  <application
-      android:label="@string/application_name"
-      android:icon="@mipmap/ic_launcher"
-      android:banner="@drawable/ic_banner"
-      android:largeHeap="true"
-      android:allowBackup="false"
-      android:name="com.google.android.exoplayer2.demo.DemoApplication">
-
-    <activity android:name="com.google.android.exoplayer2.demo.SampleChooserActivity"
-        android:configChanges="keyboardHidden"
-        android:label="@string/application_name">
-      <intent-filter>
-        <action android:name="android.intent.action.MAIN"/>
-        <category android:name="android.intent.category.LAUNCHER"/>
-        <category android:name="android.intent.category.LEANBACK_LAUNCHER"/>
-      </intent-filter>
-      <intent-filter>
-        <action android:name="android.intent.action.VIEW"/>
-        <category android:name="android.intent.category.DEFAULT"/>
-        <category android:name="android.intent.category.BROWSABLE"/>
-        <data android:scheme="http"/>
-        <data android:scheme="https"/>
-        <data android:scheme="content"/>
-        <data android:scheme="asset"/>
-        <data android:scheme="file"/>
-        <data android:host="*"/>
-        <data android:pathPattern=".*\\.exolist\\.json"/>
-      </intent-filter>
-    </activity>
-
-    <activity android:name="com.google.android.exoplayer2.demo.PlayerActivity"
-        android:configChanges="keyboard|keyboardHidden|orientation|screenSize|screenLayout|smallestScreenSize|uiMode"
-        android:launchMode="singleTop"
+    <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
+
+    <uses-feature
+        android:name="android.software.leanback"
+        android:required="false" />
+    <uses-feature
+        android:name="android.hardware.touchscreen"
+        android:required="false" />
+
+    <uses-sdk />
+
+    <application
+        android:name="com.google.android.exoplayer2.demo.DemoApplication"
+        android:allowBackup="false"
+        android:banner="@drawable/ic_banner"
+        android:icon="@mipmap/ic_launcher"
         android:label="@string/application_name"
-        android:theme="@style/PlayerTheme">
-      <intent-filter>
-        <action android:name="com.google.android.exoplayer.demo.action.VIEW"/>
-        <category android:name="android.intent.category.DEFAULT"/>
-        <data android:scheme="http"/>
-        <data android:scheme="https"/>
-        <data android:scheme="content"/>
-        <data android:scheme="asset"/>
-        <data android:scheme="file"/>
-      </intent-filter>
-      <intent-filter>
-        <action android:name="com.google.android.exoplayer.demo.action.VIEW_LIST"/>
-        <category android:name="android.intent.category.DEFAULT"/>
-      </intent-filter>
-    </activity>
-
-  </application>
+        android:largeHeap="true">
+
+        <activity android:name="com.google.android.exoplayer2.demo.DownloadActivity" />
+
+        <service android:name="com.google.android.exoplayer2.demo.ExoDownloadService" />
+
+
+        <activity
+            android:name="com.google.android.exoplayer2.demo.SampleChooserActivity"
+            android:configChanges="keyboardHidden"
+            android:label="@string/application_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+                <category android:name="android.intent.category.LEANBACK_LAUNCHER" />
+            </intent-filter>
+            <intent-filter>
+                <action android:name="android.intent.action.VIEW" />
+
+                <category android:name="android.intent.category.DEFAULT" />
+                <category android:name="android.intent.category.BROWSABLE" />
+
+                <data android:scheme="http" />
+                <data android:scheme="https" />
+                <data android:scheme="content" />
+                <data android:scheme="asset" />
+                <data android:scheme="file" />
+                <data android:host="*" />
+                <data android:pathPattern=".*\\.exolist\\.json" />
+            </intent-filter>
+        </activity>
+
+        <activity
+            android:name="com.google.android.exoplayer2.demo.PlayerActivity"
+            android:configChanges="keyboard|keyboardHidden|orientation|screenSize|screenLayout|smallestScreenSize|uiMode"
+            android:label="@string/application_name"
+            android:launchMode="singleTop"
+            android:theme="@style/PlayerTheme">
+            <intent-filter>
+                <action android:name="com.google.android.exoplayer.demo.action.VIEW" />
+                <category android:name="android.intent.category.DEFAULT" />
+
+                <data android:scheme="http" />
+                <data android:scheme="https" />
+                <data android:scheme="content" />
+                <data android:scheme="asset" />
+                <data android:scheme="file" />
+            </intent-filter>
+            <intent-filter>
+                <action android:name="com.google.android.exoplayer.demo.action.VIEW_LIST" />
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+        </activity>
+
+    </application>
 
 </manifest>
diff --git a/demos/main/src/main/assets/media.exolist.json b/demos/main/src/main/assets/media.exolist.json
index 9df74a6f19..9823026862 100644
--- a/demos/main/src/main/assets/media.exolist.json
+++ b/demos/main/src/main/assets/media.exolist.json
@@ -5,6 +5,10 @@
       {
         "name": "WV: Clear SD & HD (MP4,H265)",
         "uri": "https://storage.googleapis.com/wvmedia/clear/hevc/tears/tears.mpd"
+      },
+      {
+        "name": "Gymondo",
+        "uri": "https://gymondo-adaptive-videos.akamaized.net/resources/237/music/608764_0f63fc4a7b2f55322085a8a481942a3f/608764.mpd?hdnts=exp=1524567082~acl=/*~hmac=817a3608318e559d199885c5a36dcabe6892397344a612ba5bab67176fb58922"
       }
     ]
   }
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/DownloadActivity.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DownloadActivity.java
new file mode 100644
index 0000000000..1a8a11472f
--- /dev/null
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DownloadActivity.java
@@ -0,0 +1,112 @@
+package com.google.android.exoplayer2.demo;
+
+import android.app.Activity;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Bundle;
+import android.support.annotation.Nullable;
+import android.view.View;
+import android.widget.Button;
+import android.widget.TextView;
+
+import com.google.android.exoplayer2.demo.offline.DashDownloadAction;
+import com.google.android.exoplayer2.demo.offline.DownloadService;
+import com.google.android.exoplayer2.source.dash.manifest.RepresentationKey;
+
+import static com.google.android.exoplayer2.demo.LocalBroadcastHelper.DOWNLOADING;
+import static com.google.android.exoplayer2.demo.offline.DownloadService.ACTION_STOP;
+
+/**
+ * @author Kryspin.Arnold (Kryspin.Arnold@gymondo.de)
+ * @since 2018-04-24
+ */
+public class DownloadActivity extends Activity {
+
+    private final String url = "https://gymondo-adaptive-videos.akamaized.net/resources/237/music/608764_0f63fc4a7b2f55322085a8a481942a3f/608764.mpd?hdnts=exp=1524567082~acl=/*~hmac=817a3608318e559d199885c5a36dcabe6892397344a612ba5bab67176fb58922";
+    private Uri uri;
+
+    private TextView txtStatus;
+
+    @Override
+    protected void onCreate(@Nullable Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.download_activity);
+
+        LocalBroadcastHelper.register(this, downloadBroadcastReceiver, DOWNLOADING);
+
+        // Create Uri
+        uri = Uri.parse(url);
+
+        Button btnStartDownload = findViewById(R.id.btn_start_download);
+        btnStartDownload.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                startDownload();
+            }
+        });
+
+        Button btnCancelDownload = findViewById(R.id.btn_cancel_download);
+        btnCancelDownload.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                cancelDownload();
+            }
+        });
+
+        Button btnPauseDownload = findViewById(R.id.btn_pause_download);
+        btnPauseDownload.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                pauseDownload();
+            }
+        });
+
+        txtStatus = findViewById(R.id.txt_status);
+
+    }
+
+    final private BroadcastReceiver downloadBroadcastReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String downloadString = intent.getStringExtra(ExoDownloadService.ARG_DOWNLOAD_DATA);
+            txtStatus.setText(downloadString);
+        }
+    };
+
+    private void startDownload() {
+        // 480p
+        RepresentationKey[] downloadKeys = new RepresentationKey[2];
+        downloadKeys[0] = new RepresentationKey(0, 0, 1);
+        downloadKeys[1] = new RepresentationKey(0, 1, 0);
+
+        // Remove action == remove all downloaded media
+        DashDownloadAction downloadAction = new DashDownloadAction(uri, false, null, downloadKeys);
+        DownloadService.addDownloadAction(this, ExoDownloadService.class, downloadAction);
+    }
+
+    private void cancelDownload() {
+        DashDownloadAction downloadAction = new DashDownloadAction(uri, true, null);
+        DownloadService.addDownloadAction(this, ExoDownloadService.class, downloadAction);
+    }
+
+    private void pauseDownload() {
+
+        Intent intent = new Intent(this, ExoDownloadService.class)
+                .setAction(ACTION_STOP);
+        startService(intent);
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        LocalBroadcastHelper.register(this, downloadBroadcastReceiver, DOWNLOADING);
+    }
+
+    @Override
+    protected void onPause() {
+        LocalBroadcastHelper.unregister(this, downloadBroadcastReceiver);
+        super.onPause();
+    }
+}
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/ExoDownloadService.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/ExoDownloadService.java
new file mode 100644
index 0000000000..112966bbae
--- /dev/null
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/ExoDownloadService.java
@@ -0,0 +1,98 @@
+package com.google.android.exoplayer2.demo;
+
+import android.app.Notification;
+import android.app.PendingIntent;
+import android.content.Intent;
+import android.os.Bundle;
+import android.os.Environment;
+import android.support.annotation.Nullable;
+import android.support.v4.app.NotificationCompat;
+import android.util.Log;
+
+import com.google.android.exoplayer2.demo.offline.DashDownloadAction;
+import com.google.android.exoplayer2.demo.offline.DownloadManager;
+import com.google.android.exoplayer2.demo.offline.DownloadService;
+import com.google.android.exoplayer2.demo.scheduler.Requirements;
+import com.google.android.exoplayer2.demo.scheduler.Scheduler;
+import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
+import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
+import com.google.android.exoplayer2.upstream.cache.NoOpCacheEvictor;
+import com.google.android.exoplayer2.upstream.cache.SimpleCache;
+
+import java.io.File;
+
+/**
+ * @author Kryspin.Arnold (Kryspin.Arnold@gymondo.de)
+ * @since 2018-04-24
+ */
+public class ExoDownloadService extends DownloadService {
+
+    public static final String ARG_DOWNLOAD_DATA = "arg_download_data";
+    private static final int NOTIFICATION_ID = 1337;
+
+    public ExoDownloadService() {
+        super(NOTIFICATION_ID);
+    }
+
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+
+        Intent notificationIntent = new Intent(this, DownloadActivity.class);
+
+        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0,
+                notificationIntent, 0);
+
+        Notification notification = new NotificationCompat.Builder(this, "channelId")
+                .setSmallIcon(R.mipmap.ic_launcher)
+                .setContentTitle("Gymondo")
+                .setContentText("Downloading Workouts...")
+                .setContentIntent(pendingIntent).build();
+
+        startForeground(notification);
+
+        return super.onStartCommand(intent, flags, startId);
+    }
+
+    @Override
+    protected DownloadManager getDownloadManager() {
+
+        Log.e("GYMONDO", "getDownloadManager");
+        File dir = getApplicationContext().getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS);
+        SimpleCache cache = new SimpleCache(dir, new NoOpCacheEvictor());
+        DefaultHttpDataSourceFactory factory = new DefaultHttpDataSourceFactory("ExoPlayer", null);
+        DownloaderConstructorHelper constructorHelper = new DownloaderConstructorHelper(cache, factory);
+
+        String actionFile = dir.getAbsolutePath() + "/action/action_file.txt";
+        DownloadManager downloadManager = new DownloadManager(constructorHelper, actionFile, DashDownloadAction.DESERIALIZER);
+
+        return downloadManager;
+    }
+
+    @Override
+    protected void onProgressUpdate(DownloadManager.DownloadState[] activeDownloadTasks) {
+        if (activeDownloadTasks.length > 0) {
+            String downloadString = "Downloading: " + activeDownloadTasks[0].downloadPercentage + "%";
+            Log.e("GYMONDO", downloadString);
+            Bundle args = new Bundle(1);
+            args.putString(ARG_DOWNLOAD_DATA, downloadString);
+            LocalBroadcastHelper.sendMessage(this, LocalBroadcastHelper.DOWNLOADING, args);
+        }
+    }
+
+    @Nullable
+    @Override
+    protected Requirements getRequirements() {
+        return new Requirements(Requirements.NETWORK_TYPE_ANY);
+    }
+
+    @Nullable
+    @Override
+    protected Scheduler getScheduler() {
+        return null;
+    }
+
+    @Override
+    protected String getNotificationChannelId() {
+        return null;
+    }
+}
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/LocalBroadcastHelper.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/LocalBroadcastHelper.java
new file mode 100644
index 0000000000..18540a9832
--- /dev/null
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/LocalBroadcastHelper.java
@@ -0,0 +1,73 @@
+package com.google.android.exoplayer2.demo;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Bundle;
+import android.support.v4.content.LocalBroadcastManager;
+
+public class LocalBroadcastHelper {
+    /*
+     * Shared events
+     */
+    public static final String MENU_SHOULD_REFRESH = "MENU_SHOULD_REFRESH";
+    public static final String SHOW_INACTIVE_ACTIVITY = "SHOW_INACTIVE_ACTIVITY";
+    public static final String SHOPPING_LIST_SYNC_DONE = "SHOPPING_LIST_SYNC_DONE";
+
+    /*
+     * Mobile-Only events
+     */
+    public static final String REFRESH_RESOURCE_FRAGMENT = "REFRESH_RESOURCE_FRAGMENT";
+    public static final String REFRESH_LOCAL_PLAN = "REFRESH_LOCAL_PLAN";
+    public static final String LOCAL_PLAN_REFRESHED = "LOCAL_PLAN_REFRESHED";
+    public static final String DOWNLOADING = "DOWNLOADING";
+
+    /*
+     * TV-Only events
+     */
+    public static final String PLAN_HAS_SWAPPED = "PLAN_HAS_SWAPPED";
+    public static final String REFRESH_TV_MENU = "REFRESH_TV_MENU";
+
+    private LocalBroadcastHelper() {
+    }
+
+    public static void sendMessage(Context context, String action) {
+        if (context == null)
+            return;
+
+        Intent intent = new Intent(action);
+        LocalBroadcastManager.getInstance(context).sendBroadcast(intent);
+    }
+
+    public static void sendMessage(Context context, String action, Bundle args) {
+        if (context == null)
+            return;
+
+        Intent intent = new Intent(action);
+        intent.putExtras(args);
+        LocalBroadcastManager.getInstance(context).sendBroadcast(intent);
+    }
+
+    public static void register(Context context, BroadcastReceiver receiver, String intentFilterName) {
+        if (context != null)
+            LocalBroadcastManager
+                    .getInstance(context)
+                    .registerReceiver(
+                            receiver,
+                            getIntentFilter(intentFilterName)
+                    );
+    }
+
+    public static void unregister(Context context, BroadcastReceiver receiver) {
+        if (context != null && receiver != null)
+            LocalBroadcastManager
+                    .getInstance(context)
+                    .unregisterReceiver(receiver);
+    }
+
+    private static IntentFilter getIntentFilter(String action) {
+        return new IntentFilter(action);
+    }
+
+}
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
index 265688ffcc..03fa061399 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
@@ -54,7 +54,7 @@
 import com.google.android.exoplayer2.source.dash.DashMediaSource;
 import com.google.android.exoplayer2.source.dash.DefaultDashChunkSource;
 import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
-import com.google.android.exoplayer2.source.dash.manifest.DashManifestParser;
+import com.google.android.exoplayer2.source.dash.manifest.Representation;
 import com.google.android.exoplayer2.source.dash.manifest.RepresentationKey;
 import com.google.android.exoplayer2.source.dash.offline.DashDownloader;
 import com.google.android.exoplayer2.trackselection.AdaptiveTrackSelection;
@@ -79,8 +79,8 @@
 import java.net.CookieHandler;
 import java.net.CookieManager;
 import java.net.CookiePolicy;
-import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.List;
 
 /**
  * An activity that plays media using {@link SimpleExoPlayer}.
@@ -281,7 +281,6 @@ private void initializePlayer() {
         MediaSource mediaSource = mediaSources.length == 1 ? mediaSources[0]
                 : new ConcatenatingMediaSource(mediaSources);
 
-
         boolean haveResumePosition = resumeWindow != C.INDEX_UNSET;
         if (haveResumePosition) {
             player.seekTo(resumeWindow, resumePosition);
@@ -394,7 +393,7 @@ private void updateButtonVisibilities() {
         downloadClickedListener = new OnClickListener() {
             @Override
             public void onClick(View v) {
-                new DashDownload().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, uris[0]);
+                new DashDownload().execute(uris[0]);
             }
         };
         Button button = new Button(this);
@@ -513,8 +512,8 @@ public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray tra
 
     private void changeTrack() {
         if (trackChanged) {
-            trackSelectionHelper.selectTrack(0, 0);
-            trackSelectionHelper.selectTrack(1, 0);
+            /*trackSelectionHelper.selectTrack(0, 0);
+            trackSelectionHelper.selectTrack(1, 0);*/
             trackChanged = true;
         }
     }
@@ -536,12 +535,27 @@ protected Void doInBackground(Uri... videos) {
                 RepresentationKey[] keys = dashDownloader.getAllRepresentationKeys();
                 RepresentationKey[] downloadKeys = new RepresentationKey[2];
                 for (RepresentationKey key : keys) {
-                    if (key.adaptationSetIndex == 1 && key.representationIndex == 0) {
-                        downloadKeys[1] = key;
-                    } else if (key.adaptationSetIndex == 0 && key.representationIndex == 0) {
-                        downloadKeys[0] = key;
+                    if (key.adaptationSetIndex == 1 && key.representationIndex == 0 && null == downloadKeys[1]) {
+                        downloadKeys[1] = new RepresentationKey(0, 1, 0);
+                    } else if (key.adaptationSetIndex == 0 && downloadKeys[0] == null) {
+                        List<Representation> representations = dashDownloader.getManifest().getPeriod(0).adaptationSets.get(key.adaptationSetIndex).representations;
+                        for (int i = 0; i < representations.size(); i++) {
+                            if (representations.get(i).format.height == 480) {
+                                downloadKeys[0] = new RepresentationKey(0, 0, i);
+                                break;
+                            }
+                        }
                     }
                 }
+
+//
+//                for (RepresentationKey key : keys) {
+//                    if (key.adaptationSetIndex == 1 && key.representationIndex == 0) {
+//                        downloadKeys[1] = key;
+//                    } else if (key.adaptationSetIndex == 0 && key.representationIndex == 0) {
+//                        downloadKeys[0] = key;
+//                    }
+//                }
                 DashManifest newManifest = dashDownloader.getManifest().copy(Arrays.asList(downloadKeys));
 
                 dashDownloader.selectRepresentations(downloadKeys);
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
index eef20e16a0..08bba71837 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
@@ -25,6 +25,9 @@
 import android.util.JsonReader;
 import android.util.Log;
 import android.view.LayoutInflater;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.BaseExpandableListAdapter;
@@ -38,7 +41,6 @@
 import com.google.android.exoplayer2.upstream.DataSourceInputStream;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.DefaultDataSource;
-import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 
 import java.io.IOException;
@@ -47,7 +49,6 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-import java.util.UUID;
 
 /**
  * An activity for selecting from a list of samples.
@@ -60,6 +61,11 @@
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.sample_chooser_activity);
+
+//        // Start Download Service
+//        Intent serviceIntent = new Intent(this, ExoDownloadService.class);
+//        startService(serviceIntent);
+
         Intent intent = getIntent();
         String dataUri = intent.getDataString();
         String[] uris;
@@ -87,6 +93,25 @@ public void onCreate(Bundle savedInstanceState) {
         loaderTask.execute(uris);
     }
 
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        MenuInflater inflater = getMenuInflater();
+        inflater.inflate(R.menu.download_menu, menu);
+        return true;
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        switch (item.getItemId()) {
+            case R.id.menu_download:
+                Intent intent = new Intent(this, DownloadActivity.class);
+                startActivity(intent);
+                return true;
+            default:
+                return super.onOptionsItemSelected(item);
+        }
+    }
+
     private class SampleListLoaderCallback {
 
         private void postExecuteCallback(final List<SampleGroup> groups, boolean sawError) {
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/offline/ActionFile.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/offline/ActionFile.java
new file mode 100644
index 0000000000..41a375d176
--- /dev/null
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/offline/ActionFile.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.demo.offline;
+
+import com.google.android.exoplayer2.demo.offline.DownloadAction.Deserializer;
+import com.google.android.exoplayer2.util.AtomicFile;
+import com.google.android.exoplayer2.util.Util;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Stores and loads {@link DownloadAction}s to/from a file.
+ */
+public final class ActionFile {
+
+    private final AtomicFile atomicFile;
+    private final File actionFile;
+
+    /**
+     * @param actionFile File to be used to store and load {@link DownloadAction}s.
+     */
+    public ActionFile(File actionFile) {
+        this.actionFile = actionFile;
+        atomicFile = new AtomicFile(actionFile);
+    }
+
+    /**
+     * Loads {@link DownloadAction}s from file.
+     *
+     * @param deserializers {@link Deserializer}s to deserialize DownloadActions.
+     * @return Loaded DownloadActions. If the action file doesn't exists returns an empty array.
+     * @throws IOException If there is an error during loading.
+     */
+    public DownloadAction[] load(Deserializer... deserializers) throws IOException {
+        if (!actionFile.exists()) {
+            return new DownloadAction[0];
+        }
+        InputStream inputStream = null;
+        try {
+            inputStream = atomicFile.openRead();
+            DataInputStream dataInputStream = new DataInputStream(inputStream);
+            int version = dataInputStream.readInt();
+            if (version > DownloadAction.MASTER_VERSION) {
+                throw new IOException("Not supported action file version: " + version);
+            }
+            int actionCount = dataInputStream.readInt();
+            DownloadAction[] actions = new DownloadAction[actionCount];
+            for (int i = 0; i < actionCount; i++) {
+                actions[i] = DownloadAction.deserializeFromStream(deserializers, dataInputStream, version);
+            }
+            return actions;
+        } finally {
+            Util.closeQuietly(inputStream);
+        }
+    }
+
+    /**
+     * Stores {@link DownloadAction}s to file.
+     *
+     * @param downloadActions DownloadActions to store to file.
+     * @throws IOException If there is an error during storing.
+     */
+    public void store(DownloadAction... downloadActions) throws IOException {
+        DataOutputStream output = null;
+        try {
+            output = new DataOutputStream(atomicFile.startWrite());
+            output.writeInt(DownloadAction.MASTER_VERSION);
+            output.writeInt(downloadActions.length);
+            for (DownloadAction action : downloadActions) {
+                DownloadAction.serializeToStream(action, output);
+            }
+            atomicFile.endWrite(output);
+            // Avoid calling close twice.
+            output = null;
+        } finally {
+            Util.closeQuietly(output);
+        }
+    }
+
+}
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/offline/DashDownloadAction.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/offline/DashDownloadAction.java
new file mode 100644
index 0000000000..a9761b6b59
--- /dev/null
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/offline/DashDownloadAction.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.demo.offline;
+
+import android.net.Uri;
+import android.support.annotation.Nullable;
+
+import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
+import com.google.android.exoplayer2.source.dash.manifest.RepresentationKey;
+import com.google.android.exoplayer2.source.dash.offline.DashDownloader;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+/**
+ * An action to download or remove downloaded DASH streams.
+ */
+public final class DashDownloadAction extends SegmentDownloadAction<RepresentationKey> {
+
+    public static final Deserializer DESERIALIZER =
+            new SegmentDownloadActionDeserializer<RepresentationKey>() {
+
+                @Override
+                public String getType() {
+                    return TYPE;
+                }
+
+                @Override
+                protected RepresentationKey readKey(DataInputStream input) throws IOException {
+                    return new RepresentationKey(input.readInt(), input.readInt(), input.readInt());
+                }
+
+                @Override
+                protected RepresentationKey[] createKeyArray(int keyCount) {
+                    return new RepresentationKey[keyCount];
+                }
+
+                @Override
+                protected DownloadAction createDownloadAction(Uri manifestUri, boolean removeAction,
+                                                              String data, RepresentationKey[] keys) {
+                    return new DashDownloadAction(manifestUri, removeAction, data, keys);
+                }
+
+            };
+
+    private static final String TYPE = "DashDownloadAction";
+
+    /**
+     * @see SegmentDownloadAction#SegmentDownloadAction(Uri, boolean, String, Object[])
+     */
+    public DashDownloadAction(
+            Uri manifestUri, boolean removeAction, @Nullable String data, RepresentationKey... keys) {
+        super(manifestUri, removeAction, data, keys);
+    }
+
+    @Override
+    protected String getType() {
+        return TYPE;
+    }
+
+    @Override
+    protected DashDownloader createDownloader(DownloaderConstructorHelper constructorHelper) {
+        DashDownloader downloader = new DashDownloader(manifestUri, constructorHelper);
+        if (!isRemoveAction()) {
+            downloader.selectRepresentations(keys);
+        }
+        return downloader;
+    }
+
+    @Override
+    protected void writeKey(DataOutputStream output, RepresentationKey key) throws IOException {
+        output.writeInt(key.periodIndex);
+        output.writeInt(key.adaptationSetIndex);
+        output.writeInt(key.representationIndex);
+    }
+
+}
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/offline/DownloadAction.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/offline/DownloadAction.java
new file mode 100644
index 0000000000..6cd190a196
--- /dev/null
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/offline/DownloadAction.java
@@ -0,0 +1,194 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.demo.offline;
+
+import android.support.annotation.Nullable;
+
+import com.google.android.exoplayer2.offline.DownloadException;
+import com.google.android.exoplayer2.offline.Downloader;
+import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
+
+import java.io.ByteArrayOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/**
+ * Contains the necessary parameters for a download or remove action.
+ */
+public abstract class DownloadAction {
+
+    /**
+     * Master version for all {@link DownloadAction} serialization/deserialization implementations. On
+     * each change on any {@link DownloadAction} serialization format this version needs to be
+     * increased.
+     */
+    public static final int MASTER_VERSION = 0;
+
+    /**
+     * Used to deserialize {@link DownloadAction}s.
+     */
+    public interface Deserializer {
+
+        /**
+         * Returns the type string of the {@link DownloadAction}. This string should be unique.
+         */
+        String getType();
+
+        /**
+         * Deserializes a {@link DownloadAction} from the {@code input}.
+         *
+         * @param version Version of the data.
+         * @param input   DataInputStream to read data from.
+         * @see DownloadAction#writeToStream(DataOutputStream)
+         * @see DownloadAction#MASTER_VERSION
+         */
+        DownloadAction readFromStream(int version, DataInputStream input) throws IOException;
+    }
+
+    /**
+     * Deserializes one {@code action} which was serialized by {@link
+     * #serializeToStream(DownloadAction, OutputStream)} from the {@code input} using one of the
+     * {@link Deserializer}s which supports the type of the action.
+     * <p>
+     * <p>The caller is responsible for closing the given {@link InputStream}.
+     *
+     * @param deserializers Array of {@link Deserializer}s to deserialize a {@link DownloadAction}.
+     * @param input         Input stream to read serialized data.
+     * @return The deserialized {@link DownloadAction}.
+     * @throws IOException If there is an IO error from {@code input} or the action type isn't
+     *                     supported by any of the {@code deserializers}.
+     */
+    public static DownloadAction deserializeFromStream(
+            Deserializer[] deserializers, InputStream input) throws IOException {
+        return deserializeFromStream(deserializers, input, MASTER_VERSION);
+    }
+
+    /**
+     * Deserializes one {@code action} which was serialized by {@link
+     * #serializeToStream(DownloadAction, OutputStream)} from the {@code input} using one of the
+     * {@link Deserializer}s which supports the type of the action.
+     * <p>
+     * <p>The caller is responsible for closing the given {@link InputStream}.
+     *
+     * @param deserializers Array of {@link Deserializer}s to deserialize a {@link DownloadAction}.
+     * @param input         Input stream to read serialized data.
+     * @param version       Master version of the serialization. See {@link DownloadAction#MASTER_VERSION}.
+     * @return The deserialized {@link DownloadAction}.
+     * @throws IOException       If there is an IO error from {@code input}.
+     * @throws DownloadException If the action type isn't supported by any of the {@code
+     *                           deserializers}.
+     */
+    public static DownloadAction deserializeFromStream(
+            Deserializer[] deserializers, InputStream input, int version) throws IOException {
+        // Don't close the stream as it closes the underlying stream too.
+        DataInputStream dataInputStream = new DataInputStream(input);
+        String type = dataInputStream.readUTF();
+        for (Deserializer deserializer : deserializers) {
+            if (type.equals(deserializer.getType())) {
+                return deserializer.readFromStream(version, dataInputStream);
+            }
+        }
+        throw new DownloadException("No Deserializer can be found to parse the data.");
+    }
+
+    /**
+     * Serializes {@code action} type and data into the {@code output}.
+     */
+    public static void serializeToStream(DownloadAction action, OutputStream output)
+            throws IOException {
+        // Don't close the stream as it closes the underlying stream too.
+        DataOutputStream dataOutputStream = new DataOutputStream(output);
+        dataOutputStream.writeUTF(action.getType());
+        action.writeToStream(dataOutputStream);
+        dataOutputStream.flush();
+    }
+
+    private final String data;
+
+    /**
+     * @param data Optional custom data for this action. If null, an empty string is used.
+     */
+    protected DownloadAction(@Nullable String data) {
+        this.data = data != null ? data : "";
+    }
+
+    /**
+     * Serializes itself into a byte array.
+     */
+    public final byte[] toByteArray() {
+        ByteArrayOutputStream output = new ByteArrayOutputStream();
+        try {
+            serializeToStream(this, output);
+        } catch (IOException e) {
+            // ByteArrayOutputStream shouldn't throw IOException.
+            throw new IllegalStateException();
+        }
+        return output.toByteArray();
+    }
+
+    /**
+     * Returns custom data for this action.
+     */
+    public final String getData() {
+        return data;
+    }
+
+    /**
+     * Returns whether this is a remove action or a download action.
+     */
+    public abstract boolean isRemoveAction();
+
+    /**
+     * Returns the type string of the {@link DownloadAction}. This string should be unique.
+     */
+    protected abstract String getType();
+
+    /**
+     * Serializes itself into the {@code output}.
+     */
+    protected abstract void writeToStream(DataOutputStream output) throws IOException;
+
+    /**
+     * Returns whether this is an action for the same media as the {@code other}.
+     */
+    protected abstract boolean isSameMedia(DownloadAction other);
+
+    /**
+     * Creates a {@link Downloader} with the given parameters.
+     */
+    protected abstract Downloader createDownloader(
+            DownloaderConstructorHelper downloaderConstructorHelper);
+
+    @Override
+    public boolean equals(Object o) {
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
+        DownloadAction that = (DownloadAction) o;
+        return data.equals(that.data) && isRemoveAction() == that.isRemoveAction();
+    }
+
+    @Override
+    public int hashCode() {
+        int result = data.hashCode();
+        result = 31 * result + (isRemoveAction() ? 1 : 0);
+        return result;
+    }
+
+}
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/offline/DownloadManager.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/offline/DownloadManager.java
new file mode 100644
index 0000000000..0af19e3130
--- /dev/null
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/offline/DownloadManager.java
@@ -0,0 +1,849 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.demo.offline;
+
+import android.os.ConditionVariable;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.support.annotation.IntDef;
+import android.util.Log;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.demo.offline.DownloadAction.Deserializer;
+import com.google.android.exoplayer2.offline.Downloader;
+import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
+import com.google.android.exoplayer2.util.Assertions;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.ArrayList;
+import java.util.concurrent.CopyOnWriteArraySet;
+
+import static com.google.android.exoplayer2.demo.offline.DownloadManager.DownloadState.STATE_CANCELED;
+import static com.google.android.exoplayer2.demo.offline.DownloadManager.DownloadState.STATE_ENDED;
+import static com.google.android.exoplayer2.demo.offline.DownloadManager.DownloadState.STATE_ERROR;
+import static com.google.android.exoplayer2.demo.offline.DownloadManager.DownloadState.STATE_QUEUED;
+import static com.google.android.exoplayer2.demo.offline.DownloadManager.DownloadState.STATE_STARTED;
+
+/**
+ * Manages multiple stream download and remove requests.
+ * <p>
+ * <p>By default downloads are stopped. Call {@link #startDownloads()} to start downloads.
+ * <p>
+ * <p>WARNING: Methods of this class must be called only on the main thread of the application.
+ */
+public final class DownloadManager {
+
+    /**
+     * Listener for download events. Listener methods are called on the main thread of the
+     * application.
+     */
+    public interface DownloadListener {
+        /**
+         * Called on download state change.
+         *
+         * @param downloadManager The reporting instance.
+         * @param downloadState   The download task.
+         */
+        void onStateChange(DownloadManager downloadManager, DownloadState downloadState);
+
+        /**
+         * Called when there is no active task left.
+         *
+         * @param downloadManager The reporting instance.
+         */
+        void onIdle(DownloadManager downloadManager);
+    }
+
+    /**
+     * The default maximum number of simultaneous downloads.
+     */
+    public static final int DEFAULT_MAX_SIMULTANEOUS_DOWNLOADS = 1;
+    /**
+     * The default minimum number of times the downloads must be retried before failing.
+     */
+    public static final int DEFAULT_MIN_RETRY_COUNT = 5;
+
+    private static final String TAG = "DownloadManager";
+    private static final boolean DEBUG = true;
+
+    private final DownloaderConstructorHelper downloaderConstructorHelper;
+    private final int maxActiveDownloadTasks;
+    private final int minRetryCount;
+    private final ActionFile actionFile;
+    private final DownloadAction.Deserializer[] deserializers;
+    private final ArrayList<DownloadTask> tasks;
+    private final ArrayList<DownloadTask> activeDownloadTasks;
+    private final Handler handler;
+    private final HandlerThread fileIOThread;
+    private final Handler fileIOHandler;
+    private final CopyOnWriteArraySet<DownloadListener> listeners;
+
+    private int nextTaskId;
+    private boolean actionFileLoadCompleted;
+    private boolean released;
+    private boolean downloadsStopped;
+
+    /**
+     * Constructs a {@link DownloadManager}.
+     *
+     * @param constructorHelper A {@link DownloaderConstructorHelper} to create {@link Downloader}s
+     *                          for downloading data.
+     * @param actionSaveFile    File to save active actions.
+     * @param deserializers     Used to deserialize {@link DownloadAction}s.
+     */
+    public DownloadManager(
+            DownloaderConstructorHelper constructorHelper,
+            String actionSaveFile,
+            Deserializer... deserializers) {
+        this(
+                constructorHelper,
+                DEFAULT_MAX_SIMULTANEOUS_DOWNLOADS,
+                DEFAULT_MIN_RETRY_COUNT,
+                actionSaveFile,
+                deserializers);
+    }
+
+    /**
+     * Constructs a {@link DownloadManager}.
+     *
+     * @param constructorHelper        A {@link DownloaderConstructorHelper} to create {@link Downloader}s
+     *                                 for downloading data.
+     * @param maxSimultaneousDownloads The maximum number of simultaneous downloads.
+     * @param minRetryCount            The minimum number of times the downloads must be retried before failing.
+     * @param actionSaveFile           File to save active actions.
+     * @param deserializers            Used to deserialize {@link DownloadAction}s.
+     */
+    public DownloadManager(
+            DownloaderConstructorHelper constructorHelper,
+            int maxSimultaneousDownloads,
+            int minRetryCount,
+            String actionSaveFile,
+            Deserializer... deserializers) {
+        Assertions.checkArgument(
+                deserializers.length > 0, "At least one Deserializer should be given.");
+
+        this.downloaderConstructorHelper = constructorHelper;
+        this.maxActiveDownloadTasks = maxSimultaneousDownloads;
+        this.minRetryCount = minRetryCount;
+        this.actionFile = new ActionFile(new File(actionSaveFile));
+        this.deserializers = deserializers;
+        this.downloadsStopped = true;
+
+        tasks = new ArrayList<>();
+        activeDownloadTasks = new ArrayList<>();
+
+        Looper looper = Looper.myLooper();
+        if (looper == null) {
+            looper = Looper.getMainLooper();
+        }
+        handler = new Handler(looper);
+
+        fileIOThread = new HandlerThread("DownloadManager file i/o");
+        fileIOThread.start();
+        fileIOHandler = new Handler(fileIOThread.getLooper());
+
+        listeners = new CopyOnWriteArraySet<>();
+
+        loadActions();
+        logd("DownloadManager is created");
+    }
+
+    /**
+     * Stops all of the tasks and releases resources. If the action file isn't up to date,
+     * waits for the changes to be written.
+     */
+    public void release() {
+        released = true;
+        for (int i = 0; i < tasks.size(); i++) {
+            tasks.get(i).stop();
+        }
+        final ConditionVariable fileIOFinishedCondition = new ConditionVariable();
+        fileIOHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                fileIOFinishedCondition.open();
+            }
+        });
+        fileIOFinishedCondition.block();
+        fileIOThread.quit();
+        logd("DownloadManager is released");
+    }
+
+    /**
+     * Stops all of the download tasks. Call {@link #startDownloads()} to restart tasks.
+     */
+    public void stopDownloads() {
+        if (!downloadsStopped) {
+            downloadsStopped = true;
+            for (int i = 0; i < activeDownloadTasks.size(); i++) {
+                activeDownloadTasks.get(i).stop();
+            }
+            logd("Downloads are stopping");
+        }
+    }
+
+    /**
+     * Starts the download tasks.
+     */
+    public void startDownloads() {
+        if (downloadsStopped) {
+            downloadsStopped = false;
+            maybeStartTasks();
+            logd("Downloads are started");
+        }
+    }
+
+    /**
+     * Adds a {@link DownloadListener}.
+     *
+     * @param listener The listener to be added.
+     */
+    public void addListener(DownloadListener listener) {
+        listeners.add(listener);
+    }
+
+    /**
+     * Removes a {@link DownloadListener}.
+     *
+     * @param listener The listener to be removed.
+     */
+    public void removeListener(DownloadListener listener) {
+        listeners.remove(listener);
+    }
+
+    /**
+     * Deserializes one {@link DownloadAction} from {@code actionData} and calls {@link
+     * #handleAction(DownloadAction)}.
+     *
+     * @param actionData Serialized {@link DownloadAction} data.
+     * @return The task id.
+     * @throws IOException If an error occurs during handling action.
+     */
+    public int handleAction(byte[] actionData) throws IOException {
+        ByteArrayInputStream input = new ByteArrayInputStream(actionData);
+        DownloadAction action = DownloadAction.deserializeFromStream(deserializers, input);
+        return handleAction(action);
+    }
+
+    /**
+     * Handles the given {@link DownloadAction}. A task is created and added to the task queue. If
+     * it's a remove action then this method cancels any download tasks which works on the same media
+     * immediately.
+     *
+     * @param downloadAction Action to be executed.
+     * @return The task id.
+     */
+    public int handleAction(DownloadAction downloadAction) {
+        DownloadTask downloadTask = createDownloadTask(downloadAction);
+        saveActions();
+        if (downloadsStopped && !downloadAction.isRemoveAction()) {
+            logd("Can't start the task as downloads are stopped", downloadTask);
+        } else {
+            maybeStartTasks();
+        }
+        return downloadTask.id;
+    }
+
+    private DownloadTask createDownloadTask(DownloadAction downloadAction) {
+        DownloadTask downloadTask = new DownloadTask(nextTaskId++, this, downloadAction, minRetryCount);
+        tasks.add(downloadTask);
+        logd("Task is added", downloadTask);
+        notifyListenersTaskStateChange(downloadTask);
+        return downloadTask;
+    }
+
+    /**
+     * Returns number of tasks.
+     */
+    public int getTaskCount() {
+        return tasks.size();
+    }
+
+    /**
+     * Returns a {@link DownloadTask} for a task.
+     */
+    public DownloadState getDownloadState(int taskId) {
+        for (int i = 0; i < tasks.size(); i++) {
+            DownloadTask task = tasks.get(i);
+            if (task.id == taskId) {
+                return task.getDownloadState();
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Returns {@link DownloadState}s for all tasks.
+     */
+    public DownloadState[] getDownloadStates() {
+        return getDownloadStates(tasks);
+    }
+
+    /**
+     * Returns an array of {@link DownloadState}s for active download tasks.
+     */
+    public DownloadState[] getActiveDownloadStates() {
+        return getDownloadStates(activeDownloadTasks);
+    }
+
+    /**
+     * Returns whether there are no active tasks.
+     */
+    public boolean isIdle() {
+        if (!actionFileLoadCompleted) {
+            return false;
+        }
+        for (int i = 0; i < tasks.size(); i++) {
+            if (tasks.get(i).isActive()) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Iterates through the task queue and starts any task if all of the following are true:
+     * <p>
+     * <ul>
+     * <li>It hasn't started yet.
+     * <li>There are no preceding conflicting tasks.
+     * <li>If it's a download task then there are no preceding download tasks on hold and the
+     * maximum number of active downloads hasn't been reached.
+     * </ul>
+     * <p>
+     * If the task is a remove action then preceding conflicting tasks are canceled.
+     */
+    private void maybeStartTasks() {
+        if (released) {
+            return;
+        }
+
+        boolean skipDownloadActions = downloadsStopped
+                || activeDownloadTasks.size() == maxActiveDownloadTasks;
+        for (int i = 0; i < tasks.size(); i++) {
+            DownloadTask downloadTask = tasks.get(i);
+            if (!downloadTask.canStart()) {
+                continue;
+            }
+
+            DownloadAction downloadAction = downloadTask.downloadAction;
+            boolean removeAction = downloadAction.isRemoveAction();
+            if (!removeAction && skipDownloadActions) {
+                continue;
+            }
+
+            boolean canStartTask = true;
+            for (int j = 0; j < i; j++) {
+                DownloadTask task = tasks.get(j);
+                if (task.downloadAction.isSameMedia(downloadAction)) {
+                    if (removeAction) {
+                        canStartTask = false;
+                        logd(downloadTask + " clashes with " + task);
+                        task.cancel();
+                        // Continue loop to cancel any other preceding clashing tasks.
+                    } else if (task.downloadAction.isRemoveAction()) {
+                        canStartTask = false;
+                        skipDownloadActions = true;
+                        break;
+                    }
+                }
+            }
+
+            if (canStartTask) {
+                downloadTask.start();
+                if (!removeAction) {
+                    activeDownloadTasks.add(downloadTask);
+                    skipDownloadActions = activeDownloadTasks.size() == maxActiveDownloadTasks;
+                }
+            }
+        }
+    }
+
+    private void maybeNotifyListenersIdle() {
+        if (!isIdle()) {
+            return;
+        }
+        logd("Notify idle state");
+        for (DownloadListener listener : listeners) {
+            listener.onIdle(this);
+        }
+    }
+
+    private void onTaskStateChange(DownloadTask downloadTask) {
+        if (released) {
+            return;
+        }
+        logd("Task state is changed", downloadTask);
+        boolean stopped = !downloadTask.isActive();
+        if (stopped) {
+            activeDownloadTasks.remove(downloadTask);
+        }
+        notifyListenersTaskStateChange(downloadTask);
+        if (downloadTask.isFinished()) {
+            tasks.remove(downloadTask);
+            saveActions();
+        }
+        if (stopped) {
+            maybeStartTasks();
+            maybeNotifyListenersIdle();
+        }
+    }
+
+    private void notifyListenersTaskStateChange(DownloadTask downloadTask) {
+        DownloadState downloadState = downloadTask.getDownloadState();
+        for (DownloadListener listener : listeners) {
+            listener.onStateChange(this, downloadState);
+        }
+    }
+
+    private void loadActions() {
+        fileIOHandler.post(
+                new Runnable() {
+                    @Override
+                    public void run() {
+                        DownloadAction[] loadedActions;
+                        try {
+                            loadedActions = actionFile.load(DownloadManager.this.deserializers);
+                            logd("Action file is loaded.");
+                        } catch (Throwable e) {
+                            Log.e(TAG, "Action file loading failed.", e);
+                            loadedActions = new DownloadAction[0];
+                        }
+                        final DownloadAction[] actions = loadedActions;
+                        handler.post(
+                                new Runnable() {
+                                    @Override
+                                    public void run() {
+                                        try {
+                                            for (DownloadAction action : actions) {
+                                                createDownloadTask(action);
+                                            }
+                                            logd("Tasks are created.");
+                                            maybeStartTasks();
+                                        } finally {
+                                            actionFileLoadCompleted = true;
+                                            maybeNotifyListenersIdle();
+                                        }
+                                    }
+                                });
+                    }
+                });
+    }
+
+    private void saveActions() {
+        if (!actionFileLoadCompleted || released) {
+            return;
+        }
+        final DownloadAction[] actions = new DownloadAction[tasks.size()];
+        for (int i = 0; i < tasks.size(); i++) {
+            actions[i] = tasks.get(i).downloadAction;
+        }
+        fileIOHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    actionFile.store(actions);
+                    logd("Actions persisted.");
+                } catch (IOException e) {
+                    Log.e(TAG, "Persisting actions failed.", e);
+                }
+            }
+        });
+    }
+
+    private void logd(String message) {
+        if (DEBUG) {
+            Log.d(TAG, message);
+        }
+    }
+
+    private void logd(String message, DownloadTask task) {
+        logd(message + ": " + task);
+    }
+
+    private static DownloadState[] getDownloadStates(ArrayList<DownloadTask> tasks) {
+        DownloadState[] states = new DownloadState[tasks.size()];
+        for (int i = 0; i < tasks.size(); i++) {
+            DownloadTask task = tasks.get(i);
+            states[i] = task.getDownloadState();
+        }
+        return states;
+    }
+
+    /**
+     * Represents state of a download task.
+     */
+    public static final class DownloadState {
+
+        /**
+         * Task states.
+         * <p>
+         * <p>Transition diagram:
+         * <p>
+         * <pre>
+         *                    -&gt; canceled
+         * queued &lt;-&gt; started -&gt; ended
+         *                    -&gt; error
+         * </pre>
+         */
+        @Retention(RetentionPolicy.SOURCE)
+        @IntDef({STATE_QUEUED, STATE_STARTED, STATE_ENDED, STATE_CANCELED, STATE_ERROR})
+        public @interface State {
+        }
+
+        /**
+         * The task is waiting to be started.
+         */
+        public static final int STATE_QUEUED = 0;
+        /**
+         * The task is currently started.
+         */
+        public static final int STATE_STARTED = 1;
+        /**
+         * The task completed.
+         */
+        public static final int STATE_ENDED = 2;
+        /**
+         * The task was canceled.
+         */
+        public static final int STATE_CANCELED = 3;
+        /**
+         * The task failed.
+         */
+        public static final int STATE_ERROR = 4;
+
+        /**
+         * Returns the state string for the given state value.
+         */
+        public static String getStateString(@State int state) {
+            switch (state) {
+                case STATE_QUEUED:
+                    return "QUEUED";
+                case STATE_STARTED:
+                    return "STARTED";
+                case STATE_ENDED:
+                    return "ENDED";
+                case STATE_CANCELED:
+                    return "CANCELED";
+                case STATE_ERROR:
+                    return "ERROR";
+                default:
+                    throw new IllegalStateException();
+            }
+        }
+
+        /**
+         * Unique id of the task.
+         */
+        public final int taskId;
+        /**
+         * The {@link DownloadAction} which is being executed.
+         */
+        public final DownloadAction downloadAction;
+        /**
+         * The state of the task. See {@link State}.
+         */
+        public final @State
+        int state;
+        /**
+         * The download percentage, or {@link Float#NaN} if it can't be calculated or the task is for
+         * removing.
+         */
+        public final float downloadPercentage;
+        /**
+         * The downloaded bytes, or {@link C#LENGTH_UNSET} if it hasn't been calculated yet or the task
+         * is for removing.
+         */
+        public final long downloadedBytes;
+        /**
+         * If {@link #state} is {@link #STATE_ERROR} then this is the cause, otherwise null.
+         */
+        public final Throwable error;
+
+        private DownloadState(
+                int taskId,
+                DownloadAction downloadAction,
+                @State int state,
+                float downloadPercentage,
+                long downloadedBytes,
+                Throwable error) {
+            this.taskId = taskId;
+            this.downloadAction = downloadAction;
+            this.state = state;
+            this.downloadPercentage = downloadPercentage;
+            this.downloadedBytes = downloadedBytes;
+            this.error = error;
+        }
+
+    }
+
+    private static final class DownloadTask implements Runnable {
+
+        /**
+         * Task states.
+         * <p>
+         * <p>Transition map (vertical states are source states):
+         * <p>
+         * <pre>
+         *             +------+-------+-----+-----------+-----------+--------+--------+-----+
+         *             |queued|started|ended|q_canceling|s_canceling|canceled|stopping|error|
+         * +-----------+------+-------+-----+-----------+-----------+--------+--------+-----+
+         * |queued     |      |   X   |     |     X     |           |        |        |     |
+         * |started    |      |       |  X  |           |     X     |        |   X    |  X  |
+         * |q_canceling|      |       |     |           |           |   X    |        |     |
+         * |s_canceling|      |       |     |           |           |   X    |        |     |
+         * |stopping   |   X  |       |     |           |           |        |        |     |
+         * +-----------+------+-------+-----+-----------+-----------+--------+--------+-----+
+         * </pre>
+         */
+        @Retention(RetentionPolicy.SOURCE)
+        @IntDef({
+                STATE_QUEUED,
+                STATE_STARTED,
+                STATE_ENDED,
+                STATE_CANCELED,
+                STATE_ERROR,
+                STATE_QUEUED_CANCELING,
+                STATE_STARTED_CANCELING,
+                STATE_STARTED_STOPPING
+        })
+        public @interface InternalState {
+        }
+
+        /**
+         * The task is about to be canceled.
+         */
+        public static final int STATE_QUEUED_CANCELING = 5;
+        /**
+         * The task is about to be canceled.
+         */
+        public static final int STATE_STARTED_CANCELING = 6;
+        /**
+         * The task is about to be stopped.
+         */
+        public static final int STATE_STARTED_STOPPING = 7;
+
+        private final int id;
+        private final DownloadManager downloadManager;
+        private final DownloadAction downloadAction;
+        private final int minRetryCount;
+        private volatile @InternalState
+        int currentState;
+        private volatile Downloader downloader;
+        private Thread thread;
+        private Throwable error;
+
+        private DownloadTask(
+                int id, DownloadManager downloadManager, DownloadAction downloadAction, int minRetryCount) {
+            this.id = id;
+            this.downloadManager = downloadManager;
+            this.downloadAction = downloadAction;
+            this.currentState = STATE_QUEUED;
+            this.minRetryCount = minRetryCount;
+        }
+
+        public DownloadState getDownloadState() {
+            int externalState = getExternalState();
+            return new DownloadState(
+                    id, downloadAction, externalState, getDownloadPercentage(), getDownloadedBytes(), error);
+        }
+
+        /**
+         * Returns whether the task is finished.
+         */
+        public boolean isFinished() {
+            return currentState == STATE_ERROR
+                    || currentState == STATE_ENDED
+                    || currentState == STATE_CANCELED;
+        }
+
+        /**
+         * Returns whether the task is started.
+         */
+        public boolean isActive() {
+            return currentState == STATE_QUEUED_CANCELING
+                    || currentState == STATE_STARTED
+                    || currentState == STATE_STARTED_STOPPING
+                    || currentState == STATE_STARTED_CANCELING;
+        }
+
+        /**
+         * Returns the download percentage, or {@link Float#NaN} if it can't be calculated yet. This
+         * value can be an estimation.
+         */
+        public float getDownloadPercentage() {
+            return downloader != null ? downloader.getDownloadPercentage() : Float.NaN;
+        }
+
+        /**
+         * Returns the total number of downloaded bytes, or {@link C#LENGTH_UNSET} if it hasn't been
+         * calculated yet.
+         */
+        public long getDownloadedBytes() {
+            return downloader != null ? downloader.getDownloadedBytes() : C.LENGTH_UNSET;
+        }
+
+        @Override
+        public String toString() {
+            if (!DEBUG) {
+                return super.toString();
+            }
+            return downloadAction.getType()
+                    + ' '
+                    + (downloadAction.isRemoveAction() ? "remove" : "download")
+                    + ' '
+                    + downloadAction.getData()
+                    + ' '
+                    + getStateString();
+        }
+
+        private String getStateString() {
+            switch (currentState) {
+                case STATE_QUEUED_CANCELING:
+                case STATE_STARTED_CANCELING:
+                    return "CANCELING";
+                case STATE_STARTED_STOPPING:
+                    return "STOPPING";
+                default:
+                    return DownloadState.getStateString(currentState);
+            }
+        }
+
+        private int getExternalState() {
+            switch (currentState) {
+                case STATE_QUEUED_CANCELING:
+                    return STATE_QUEUED;
+                case STATE_STARTED_CANCELING:
+                case STATE_STARTED_STOPPING:
+                    return STATE_STARTED;
+                default:
+                    return currentState;
+            }
+        }
+
+        private void start() {
+            if (changeStateAndNotify(STATE_QUEUED, STATE_STARTED)) {
+                thread = new Thread(this);
+                thread.start();
+            }
+        }
+
+        private boolean canStart() {
+            return currentState == STATE_QUEUED;
+        }
+
+        private void cancel() {
+            if (changeStateAndNotify(STATE_QUEUED, STATE_QUEUED_CANCELING)) {
+                downloadManager.handler.post(
+                        new Runnable() {
+                            @Override
+                            public void run() {
+                                changeStateAndNotify(STATE_QUEUED_CANCELING, STATE_CANCELED);
+                            }
+                        });
+            } else if (changeStateAndNotify(STATE_STARTED, STATE_STARTED_CANCELING)) {
+                thread.interrupt();
+            }
+        }
+
+        private void stop() {
+            if (changeStateAndNotify(STATE_STARTED, STATE_STARTED_STOPPING)) {
+                downloadManager.logd("Stopping", this);
+                thread.interrupt();
+            }
+        }
+
+        private boolean changeStateAndNotify(@InternalState int oldState, @InternalState int newState) {
+            return changeStateAndNotify(oldState, newState, null);
+        }
+
+        private boolean changeStateAndNotify(
+                @InternalState int oldState, @InternalState int newState, Throwable error) {
+            if (currentState != oldState) {
+                return false;
+            }
+            currentState = newState;
+            this.error = error;
+            boolean isInternalState = currentState != getExternalState();
+            if (!isInternalState) {
+                downloadManager.onTaskStateChange(DownloadTask.this);
+            }
+            return true;
+        }
+
+        /* Methods running on download thread. */
+
+        @Override
+        public void run() {
+            downloadManager.logd("Task is started", DownloadTask.this);
+            Throwable error = null;
+            try {
+                downloader = downloadAction.createDownloader(downloadManager.downloaderConstructorHelper);
+                if (downloadAction.isRemoveAction()) {
+                    downloader.remove();
+                } else {
+                    int errorCount = 0;
+                    long errorPosition = C.LENGTH_UNSET;
+                    while (true) {
+                        try {
+                            downloader.download(null);
+                            break;
+                        } catch (IOException e) {
+                            long downloadedBytes = downloader.getDownloadedBytes();
+                            if (downloadedBytes != errorPosition) {
+                                downloadManager.logd(
+                                        "Reset error count. downloadedBytes = " + downloadedBytes, this);
+                                errorPosition = downloadedBytes;
+                                errorCount = 0;
+                            }
+                            if (currentState != STATE_STARTED || ++errorCount > minRetryCount) {
+                                throw e;
+                            }
+                            downloadManager.logd("Download error. Retry " + errorCount, this);
+                            Thread.sleep(getRetryDelayMillis(errorCount));
+                        }
+                    }
+                }
+            } catch (Throwable e) {
+                error = e;
+            }
+            final Throwable finalError = error;
+            downloadManager.handler.post(
+                    new Runnable() {
+                        @Override
+                        public void run() {
+                            if (changeStateAndNotify(
+                                    STATE_STARTED, finalError != null ? STATE_ERROR : STATE_ENDED, finalError)
+                                    || changeStateAndNotify(STATE_STARTED_CANCELING, STATE_CANCELED)
+                                    || changeStateAndNotify(STATE_STARTED_STOPPING, STATE_QUEUED)) {
+                                return;
+                            }
+                            throw new IllegalStateException();
+                        }
+                    });
+        }
+
+        private int getRetryDelayMillis(int errorCount) {
+            return Math.min((errorCount - 1) * 1000, 5000);
+        }
+    }
+
+}
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/offline/DownloadService.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/offline/DownloadService.java
new file mode 100644
index 0000000000..8c3655c629
--- /dev/null
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/offline/DownloadService.java
@@ -0,0 +1,427 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.demo.offline;
+
+import android.app.Notification;
+import android.app.Notification.Builder;
+import android.app.NotificationChannel;
+import android.app.NotificationManager;
+import android.app.Service;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Looper;
+import android.support.annotation.CallSuper;
+import android.support.annotation.Nullable;
+import android.util.Log;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.demo.offline.DownloadManager.DownloadState;
+import com.google.android.exoplayer2.demo.scheduler.Requirements;
+import com.google.android.exoplayer2.demo.scheduler.RequirementsWatcher;
+import com.google.android.exoplayer2.demo.scheduler.Scheduler;
+import com.google.android.exoplayer2.util.Util;
+
+import java.io.IOException;
+
+/**
+ * A {@link Service} that downloads streams in the background.
+ * <p>
+ * <p>To start the service, create an instance of one of the subclasses of {@link DownloadAction}
+ * and call {@link #addDownloadAction(Context, Class, DownloadAction)} with it.
+ */
+public abstract class DownloadService extends Service implements DownloadManager.DownloadListener {
+
+    /**
+     * Use this action to initialize {@link DownloadManager}.
+     */
+    public static final String ACTION_INIT =
+            "com.google.android.exoplayer.downloadService.action.INIT";
+
+    /**
+     * Use this action to add a {@link DownloadAction} to {@link DownloadManager} action queue.
+     */
+    public static final String ACTION_ADD = "com.google.android.exoplayer.downloadService.action.ADD";
+
+    /**
+     * Use this action to make {@link DownloadManager} stop download tasks.
+     */
+    public static final String ACTION_STOP =
+            "com.google.android.exoplayer.downloadService.action.STOP";
+
+    /**
+     * Use this action to make {@link DownloadManager} start download tasks.
+     */
+    private static final String ACTION_START =
+            "com.google.android.exoplayer.downloadService.action.START";
+
+    /**
+     * A {@link DownloadAction} to be executed.
+     */
+    public static final String DOWNLOAD_ACTION = "DownloadAction";
+
+    /**
+     * Default progress update interval in milliseconds.
+     */
+    public static final long DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS = 1000;
+
+    private static final String TAG = "DownloadService";
+    private static final boolean DEBUG = true;
+
+    // Keep requirementsWatcher and scheduler alive beyond DownloadService life span (until the app is
+    // killed) because it may take long time for Scheduler to start the service.
+    private static RequirementsWatcher requirementsWatcher;
+    private static Scheduler scheduler;
+
+    private final int notificationIdOffset;
+    private final long progressUpdateIntervalMillis;
+
+    private DownloadManager downloadManager;
+    private ProgressUpdater progressUpdater;
+    private int lastStartId;
+
+    /**
+     * @param notificationIdOffset Value to offset notification ids. Must be greater than 0.
+     */
+    protected DownloadService(int notificationIdOffset) {
+        this(notificationIdOffset, DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS);
+    }
+
+    /**
+     * @param notificationIdOffset         Value to offset notification ids. Must be greater than 0.
+     * @param progressUpdateIntervalMillis {@link #onProgressUpdate(DownloadState[])} is called using
+     *                                     this interval. If it's {@link C#TIME_UNSET}, then {@link
+     *                                     #onProgressUpdate(DownloadState[])} isn't called.
+     */
+    protected DownloadService(int notificationIdOffset, long progressUpdateIntervalMillis) {
+        this.notificationIdOffset = notificationIdOffset;
+        this.progressUpdateIntervalMillis = progressUpdateIntervalMillis;
+    }
+
+    /**
+     * Creates an {@link Intent} to be used to start this service and adds the {@link DownloadAction}
+     * to the {@link DownloadManager}.
+     *
+     * @param context        A {@link Context} of the application calling this service.
+     * @param clazz          Class object of DownloadService or subclass.
+     * @param downloadAction A {@link DownloadAction} to be executed.
+     * @return Created Intent.
+     */
+    public static Intent createAddDownloadActionIntent(
+            Context context, Class<? extends DownloadService> clazz, DownloadAction downloadAction) {
+        return new Intent(context, clazz)
+                .setAction(ACTION_ADD)
+                .putExtra(DOWNLOAD_ACTION, downloadAction.toByteArray());
+    }
+
+    /**
+     * Adds a {@link DownloadAction} to the {@link DownloadManager}. This will start the download
+     * service if it was not running.
+     *
+     * @param context        A {@link Context} of the application calling this service.
+     * @param clazz          Class object of DownloadService or subclass.
+     * @param downloadAction A {@link DownloadAction} to be executed.
+     * @see #createAddDownloadActionIntent(Context, Class, DownloadAction)
+     */
+    public static void addDownloadAction(
+            Context context, Class<? extends DownloadService> clazz, DownloadAction downloadAction) {
+        context.startService(createAddDownloadActionIntent(context, clazz, downloadAction));
+    }
+
+    @Override
+    public void onCreate() {
+        logd("onCreate");
+        downloadManager = getDownloadManager();
+        downloadManager.addListener(this);
+
+        if (requirementsWatcher == null) {
+            Requirements requirements = getRequirements();
+            if (requirements != null) {
+                scheduler = getScheduler();
+                RequirementsListener listener =
+                        new RequirementsListener(getApplicationContext(), getClass(), scheduler);
+                requirementsWatcher =
+                        new RequirementsWatcher(getApplicationContext(), listener, requirements);
+                requirementsWatcher.start();
+            }
+        }
+
+        progressUpdater = new ProgressUpdater(this, progressUpdateIntervalMillis);
+    }
+
+    @Override
+    public void onDestroy() {
+        logd("onDestroy");
+        progressUpdater.stop();
+        downloadManager.removeListener(this);
+        if (downloadManager.getTaskCount() == 0) {
+            if (requirementsWatcher != null) {
+                requirementsWatcher.stop();
+                requirementsWatcher = null;
+            }
+            if (scheduler != null) {
+                scheduler.cancel();
+                scheduler = null;
+            }
+        }
+    }
+
+    @Nullable
+    @Override
+    public IBinder onBind(Intent intent) {
+        return null;
+    }
+
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+        this.lastStartId = startId;
+        String intentAction = intent != null ? intent.getAction() : null;
+        if (intentAction == null) {
+            intentAction = ACTION_INIT;
+        }
+        logd("onStartCommand action: " + intentAction + " startId: " + startId);
+        switch (intentAction) {
+            case ACTION_INIT:
+                // Do nothing. DownloadManager and RequirementsWatcher is initialized. If there are download
+                // or remove tasks loaded from file, they will start if the requirements are met.
+                break;
+            case ACTION_ADD:
+                byte[] actionData = intent.getByteArrayExtra(DOWNLOAD_ACTION);
+                if (actionData == null) {
+                    onCommandError(intent, new IllegalArgumentException("DownloadAction is missing."));
+                } else {
+                    try {
+                        onNewTask(intent, downloadManager.handleAction(actionData));
+                    } catch (IOException e) {
+                        onCommandError(intent, e);
+                    }
+                }
+                break;
+            case ACTION_STOP:
+                downloadManager.stopDownloads();
+                break;
+            case ACTION_START:
+                downloadManager.startDownloads();
+                break;
+            default:
+                onCommandError(intent, new IllegalArgumentException("Unknown action: " + intentAction));
+                break;
+        }
+        if (downloadManager.isIdle()) {
+            onIdle(null);
+        }
+        return START_STICKY;
+    }
+
+    /**
+     * Returns a {@link DownloadManager} to be used to downloaded content. Called only once in the
+     * life cycle of the service.
+     */
+    protected abstract DownloadManager getDownloadManager();
+
+    /**
+     * Returns a {@link Scheduler} which contains a job to initialize {@link DownloadService} when the
+     * requirements are met, or null. If not null, scheduler is used to start downloads even when the
+     * app isn't running.
+     */
+    protected abstract @Nullable
+    Scheduler getScheduler();
+
+    /**
+     * Returns requirements for downloads to take place, or null.
+     */
+    protected abstract @Nullable
+    Requirements getRequirements();
+
+    /**
+     * Called on error in start command.
+     */
+    protected void onCommandError(Intent intent, Exception error) {
+        // Do nothing.
+    }
+
+    /**
+     * Called when a new task is added to the {@link DownloadManager}.
+     */
+    protected void onNewTask(Intent intent, int taskId) {
+        // Do nothing.
+    }
+
+    /**
+     * Returns a notification channelId. See {@link NotificationChannel}.
+     */
+    protected abstract String getNotificationChannelId();
+
+    /**
+     * Helper method which calls {@link #startForeground(int, Notification)} with {@code
+     * notificationIdOffset} and {@code foregroundNotification}.
+     */
+    public void startForeground(Notification foregroundNotification) {
+        // logd("start foreground");
+        startForeground(notificationIdOffset, foregroundNotification);
+    }
+
+    /**
+     * Sets/replaces or cancels the notification for the given id.
+     *
+     * @param id           A unique id for the notification. This value is offset by {@code
+     *                     notificationIdOffset}.
+     * @param notification If not null, it's showed, replacing any previous notification. Otherwise
+     *                     any previous notification is canceled.
+     */
+    public void setNotification(int id, @Nullable Notification notification) {
+        NotificationManager notificationManager =
+                (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
+        if (notification != null) {
+            notificationManager.notify(notificationIdOffset + 1 + id, notification);
+        } else {
+            notificationManager.cancel(notificationIdOffset + 1 + id);
+        }
+    }
+
+    /**
+     * Override this method to get notified.
+     * <p>
+     * <p>{@inheritDoc}
+     */
+    @CallSuper
+    @Override
+    public void onStateChange(DownloadManager downloadManager, DownloadState downloadState) {
+        if (downloadState.state == DownloadState.STATE_STARTED) {
+            progressUpdater.start();
+        }
+    }
+
+    /**
+     * Override this method to get notified.
+     * <p>
+     * <p>{@inheritDoc}
+     */
+    @CallSuper
+    @Override
+    public void onIdle(DownloadManager downloadManager) {
+        // Make sure startForeground is called before stopping.
+        if (Util.SDK_INT >= 26) {
+            Builder notificationBuilder = new Builder(this, getNotificationChannelId());
+            Notification foregroundNotification = notificationBuilder.build();
+            startForeground(foregroundNotification);
+        }
+        boolean stopSelfResult = stopSelfResult(lastStartId);
+        logd("stopSelf(" + lastStartId + ") result: " + stopSelfResult);
+    }
+
+    /**
+     * Override this method to get notified on every second while there are active downloads.
+     */
+    protected void onProgressUpdate(DownloadState[] activeDownloadTasks) {
+        // Do nothing.
+    }
+
+    private void logd(String message) {
+        if (DEBUG) {
+            Log.d(TAG, message);
+        }
+    }
+
+    private static final class ProgressUpdater implements Runnable {
+
+        private final DownloadService downloadService;
+        private final long progressUpdateIntervalMillis;
+        private final Handler handler;
+        private boolean stopped;
+
+        public ProgressUpdater(DownloadService downloadService, long progressUpdateIntervalMillis) {
+            this.downloadService = downloadService;
+            this.progressUpdateIntervalMillis = progressUpdateIntervalMillis;
+            this.handler = new Handler(Looper.getMainLooper());
+            stopped = true;
+        }
+
+        @Override
+        public void run() {
+            DownloadState[] activeDownloadTasks =
+                    downloadService.downloadManager.getActiveDownloadStates();
+            if (activeDownloadTasks.length > 0) {
+                downloadService.onProgressUpdate(activeDownloadTasks);
+                if (progressUpdateIntervalMillis != C.TIME_UNSET) {
+                    handler.postDelayed(this, progressUpdateIntervalMillis);
+                }
+            } else {
+                stop();
+            }
+        }
+
+        public void stop() {
+            stopped = true;
+            handler.removeCallbacks(this);
+        }
+
+        public void start() {
+            if (stopped) {
+                stopped = false;
+                if (progressUpdateIntervalMillis != C.TIME_UNSET) {
+                    handler.post(this);
+                }
+            }
+        }
+
+    }
+
+    private static final class RequirementsListener implements RequirementsWatcher.Listener {
+
+        private final Context context;
+        private final Class<? extends DownloadService> serviceClass;
+        private final Scheduler scheduler;
+
+        private RequirementsListener(
+                Context context, Class<? extends DownloadService> serviceClass, Scheduler scheduler) {
+            this.context = context;
+            this.serviceClass = serviceClass;
+            this.scheduler = scheduler;
+        }
+
+        @Override
+        public void requirementsMet(RequirementsWatcher requirementsWatcher) {
+            startServiceWithAction(DownloadService.ACTION_START);
+            if (scheduler != null) {
+                scheduler.cancel();
+            }
+        }
+
+        @Override
+        public void requirementsNotMet(RequirementsWatcher requirementsWatcher) {
+
+            Log.e("GYMONDO", "Requirements not met. Stopping service.");
+
+            startServiceWithAction(DownloadService.ACTION_STOP);
+            if (scheduler != null) {
+                if (!scheduler.schedule()) {
+                    Log.e(TAG, "Scheduling downloads failed.");
+                }
+            }
+        }
+
+        private void startServiceWithAction(String action) {
+            Intent intent = new Intent(context, serviceClass).setAction(action);
+            if (Util.SDK_INT >= 26) {
+                context.startForegroundService(intent);
+            } else {
+                context.startService(intent);
+            }
+        }
+    }
+}
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/offline/ProgressiveDownloadAction.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/offline/ProgressiveDownloadAction.java
new file mode 100644
index 0000000000..dd1bae54ca
--- /dev/null
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/offline/ProgressiveDownloadAction.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.demo.offline;
+
+import android.net.Uri;
+import android.support.annotation.Nullable;
+
+import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
+import com.google.android.exoplayer2.offline.ProgressiveDownloader;
+import com.google.android.exoplayer2.upstream.cache.CacheUtil;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+/**
+ * An action to download or remove downloaded progressive streams.
+ */
+public final class ProgressiveDownloadAction extends DownloadAction {
+
+    public static final Deserializer DESERIALIZER = new Deserializer() {
+
+        @Override
+        public String getType() {
+            return TYPE;
+        }
+
+        @Override
+        public ProgressiveDownloadAction readFromStream(int version, DataInputStream input)
+                throws IOException {
+            return new ProgressiveDownloadAction(input.readUTF(),
+                    input.readBoolean() ? input.readUTF() : null, input.readBoolean(), input.readUTF());
+        }
+
+    };
+
+    private static final String TYPE = "ProgressiveDownloadAction";
+
+    private final String uri;
+    private final @Nullable
+    String customCacheKey;
+    private final boolean removeAction;
+
+    /**
+     * @param uri            Uri of the data to be downloaded.
+     * @param customCacheKey A custom key that uniquely identifies the original stream. If not null it
+     *                       is used for cache indexing.
+     * @param removeAction   Whether the data should be downloaded or removed.
+     * @param data           Optional custom data for this action. If null, an empty string is used.
+     */
+    public ProgressiveDownloadAction(
+            String uri, @Nullable String customCacheKey, boolean removeAction, @Nullable String data) {
+        super(data);
+        this.uri = Assertions.checkNotNull(uri);
+        this.customCacheKey = customCacheKey;
+        this.removeAction = removeAction;
+    }
+
+    @Override
+    public boolean isRemoveAction() {
+        return removeAction;
+    }
+
+    @Override
+    protected ProgressiveDownloader createDownloader(DownloaderConstructorHelper constructorHelper) {
+        return new ProgressiveDownloader(uri, customCacheKey, constructorHelper);
+    }
+
+    @Override
+    protected String getType() {
+        return TYPE;
+    }
+
+    @Override
+    protected void writeToStream(DataOutputStream output) throws IOException {
+        output.writeUTF(uri);
+        boolean customCacheKeyAvailable = customCacheKey != null;
+        output.writeBoolean(customCacheKeyAvailable);
+        if (customCacheKeyAvailable) {
+            output.writeUTF(customCacheKey);
+        }
+        output.writeBoolean(isRemoveAction());
+        output.writeUTF(getData());
+    }
+
+    @Override
+    protected boolean isSameMedia(DownloadAction other) {
+        if (!(other instanceof ProgressiveDownloadAction)) {
+            return false;
+        }
+        return getCacheKey().equals(((ProgressiveDownloadAction) other).getCacheKey());
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (!super.equals(o)) {
+            return false;
+        }
+        ProgressiveDownloadAction that = (ProgressiveDownloadAction) o;
+        return uri.equals(that.uri) && Util.areEqual(customCacheKey, that.customCacheKey);
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode();
+        result = 31 * result + uri.hashCode();
+        result = 31 * result + (customCacheKey != null ? customCacheKey.hashCode() : 0);
+        return result;
+    }
+
+    private String getCacheKey() {
+        return customCacheKey != null ? customCacheKey : CacheUtil.generateKey(Uri.parse(uri));
+    }
+}
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/offline/SegmentDownloadAction.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/offline/SegmentDownloadAction.java
new file mode 100644
index 0000000000..df5c483210
--- /dev/null
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/offline/SegmentDownloadAction.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.demo.offline;
+
+import android.net.Uri;
+import android.support.annotation.Nullable;
+
+import com.google.android.exoplayer2.util.Assertions;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.Arrays;
+
+/**
+ * {@link DownloadAction} for {@link SegmentDownloader}s.
+ *
+ * @param <K> The type of the representation key object.
+ */
+public abstract class SegmentDownloadAction<K> extends DownloadAction {
+
+    /**
+     * Base class for {@link SegmentDownloadAction} {@link Deserializer}s.
+     *
+     * @param <K> The type of the representation key object.
+     */
+    protected abstract static class SegmentDownloadActionDeserializer<K> implements Deserializer {
+
+        @Override
+        public DownloadAction readFromStream(int version, DataInputStream input) throws IOException {
+            Uri manifestUri = Uri.parse(input.readUTF());
+            String data = input.readUTF();
+            boolean removeAction = input.readBoolean();
+            int keyCount = input.readInt();
+            K[] keys = createKeyArray(keyCount);
+            for (int i = 0; i < keyCount; i++) {
+                keys[i] = readKey(input);
+            }
+            return createDownloadAction(manifestUri, removeAction, data, keys);
+        }
+
+        /**
+         * Deserializes a key from the {@code input}.
+         */
+        protected abstract K readKey(DataInputStream input) throws IOException;
+
+        /**
+         * Returns a key array.
+         */
+        protected abstract K[] createKeyArray(int keyCount);
+
+        /**
+         * Returns a {@link DownloadAction}.
+         */
+        protected abstract DownloadAction createDownloadAction(Uri manifestUri, boolean removeAction,
+                                                               String data, K[] keys);
+
+    }
+
+    protected final Uri manifestUri;
+    protected final K[] keys;
+    private final boolean removeAction;
+
+    /**
+     * @param manifestUri  The {@link Uri} of the manifest to be downloaded.
+     * @param removeAction Whether the data will be removed. If {@code false} it will be downloaded.
+     * @param data         Optional custom data for this action. If null, an empty string is used.
+     * @param keys         Keys of representations to be downloaded. If empty, all representations are
+     *                     downloaded. If {@code removeAction} is true, {@code keys} should be an empty array.
+     */
+    protected SegmentDownloadAction(
+            Uri manifestUri, boolean removeAction, @Nullable String data, K[] keys) {
+        super(data);
+        this.manifestUri = manifestUri;
+        this.keys = Assertions.checkNotNull(keys);
+        this.removeAction = removeAction;
+        if (removeAction) {
+            Assertions.checkArgument(keys.length == 0);
+        }
+    }
+
+    @Override
+    public final boolean isRemoveAction() {
+        return removeAction;
+    }
+
+    @Override
+    public final void writeToStream(DataOutputStream output) throws IOException {
+        output.writeUTF(manifestUri.toString());
+        output.writeUTF(getData());
+        output.writeBoolean(removeAction);
+        output.writeInt(keys.length);
+        for (K key : keys) {
+            writeKey(output, key);
+        }
+    }
+
+    /**
+     * Serializes the {@code key} into the {@code output}.
+     */
+    protected abstract void writeKey(DataOutputStream output, K key) throws IOException;
+
+
+    @Override
+    public boolean isSameMedia(DownloadAction other) {
+        return other instanceof SegmentDownloadAction
+                && manifestUri.equals(((SegmentDownloadAction<?>) other).manifestUri);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (!super.equals(o)) {
+            return false;
+        }
+        SegmentDownloadAction<?> that = (SegmentDownloadAction<?>) o;
+        return manifestUri.equals(that.manifestUri)
+                && removeAction == that.removeAction
+                && keys.length == that.keys.length
+                && Arrays.asList(keys).containsAll(Arrays.asList(that.keys));
+    }
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode();
+        result = 31 * result + manifestUri.hashCode();
+        result = 31 * result + Arrays.hashCode(keys);
+        return result;
+    }
+
+}
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/offline/SegmentDownloader.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/offline/SegmentDownloader.java
new file mode 100644
index 0000000000..2926d83908
--- /dev/null
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/offline/SegmentDownloader.java
@@ -0,0 +1,342 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.demo.offline;
+
+import android.net.Uri;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.offline.DownloadException;
+import com.google.android.exoplayer2.offline.Downloader;
+import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.cache.Cache;
+import com.google.android.exoplayer2.upstream.cache.CacheDataSource;
+import com.google.android.exoplayer2.upstream.cache.CacheUtil;
+import com.google.android.exoplayer2.upstream.cache.CacheUtil.CachingCounters;
+import com.google.android.exoplayer2.util.PriorityTaskManager;
+
+import java.io.IOException;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Base class for multi segment stream downloaders.
+ * <p>
+ * <p>All of the methods are blocking. Also they are not thread safe, except {@link
+ * #getTotalSegments()}, {@link #getDownloadedSegments()} and {@link #getDownloadedBytes()}.
+ *
+ * @param <M> The type of the manifest object.
+ * @param <K> The type of the representation key object.
+ */
+public abstract class SegmentDownloader<M, K> implements Downloader {
+
+    /**
+     * Smallest unit of content to be downloaded.
+     */
+    protected static class Segment implements Comparable<Segment> {
+        /**
+         * The start time of the segment in microseconds.
+         */
+        public final long startTimeUs;
+
+        /**
+         * The {@link DataSpec} of the segment.
+         */
+        public final DataSpec dataSpec;
+
+        /**
+         * Constructs a Segment.
+         */
+        public Segment(long startTimeUs, DataSpec dataSpec) {
+            this.startTimeUs = startTimeUs;
+            this.dataSpec = dataSpec;
+        }
+
+        @Override
+        public int compareTo(@NonNull Segment other) {
+            long startOffsetDiff = startTimeUs - other.startTimeUs;
+            return startOffsetDiff == 0 ? 0 : ((startOffsetDiff < 0) ? -1 : 1);
+        }
+    }
+
+    private static final int BUFFER_SIZE_BYTES = 128 * 1024;
+
+    private final Uri manifestUri;
+    private final PriorityTaskManager priorityTaskManager;
+    private final Cache cache;
+    private final CacheDataSource dataSource;
+    private final CacheDataSource offlineDataSource;
+
+    private M manifest;
+    private K[] keys;
+    private volatile int totalSegments;
+    private volatile int downloadedSegments;
+    private volatile long downloadedBytes;
+
+    /**
+     * @param manifestUri       The {@link Uri} of the manifest to be downloaded.
+     * @param constructorHelper a {@link DownloaderConstructorHelper} instance.
+     */
+    public SegmentDownloader(Uri manifestUri, DownloaderConstructorHelper constructorHelper) {
+        this.manifestUri = manifestUri;
+        this.cache = constructorHelper.getCache();
+        this.dataSource = constructorHelper.buildCacheDataSource(false);
+        this.offlineDataSource = constructorHelper.buildCacheDataSource(true);
+        this.priorityTaskManager = constructorHelper.getPriorityTaskManager();
+        resetCounters();
+    }
+
+    /**
+     * Returns the manifest. Downloads and parses it if necessary.
+     *
+     * @return The manifest.
+     * @throws IOException If an error occurs reading data.
+     */
+    public final M getManifest() throws IOException {
+        return getManifestIfNeeded(false);
+    }
+
+    /**
+     * Selects multiple representations pointed to by the keys for downloading, checking status. Any
+     * previous selection is cleared. If keys array is empty, all representations are downloaded.
+     */
+    public final void selectRepresentations(K[] keys) {
+        this.keys = keys.length > 0 ? keys.clone() : null;
+        resetCounters();
+    }
+
+    /**
+     * Returns keys for all representations.
+     *
+     * @see #selectRepresentations(Object[])
+     */
+    public abstract K[] getAllRepresentationKeys() throws IOException;
+
+    /**
+     * Initializes the total segments, downloaded segments and downloaded bytes counters for the
+     * selected representations.
+     *
+     * @throws IOException          Thrown when there is an io error while reading from cache.
+     * @throws DownloadException    Thrown if the media cannot be downloaded.
+     * @throws InterruptedException If the thread has been interrupted.
+     * @see #getTotalSegments()
+     * @see #getDownloadedSegments()
+     * @see #getDownloadedBytes()
+     */
+    @Override
+    public final void init() throws InterruptedException, IOException {
+        try {
+            getManifestIfNeeded(true);
+        } catch (IOException e) {
+            // Either the manifest file isn't available offline or not parsable.
+            return;
+        }
+        try {
+            initStatus(true);
+        } catch (IOException | InterruptedException e) {
+            resetCounters();
+            throw e;
+        }
+    }
+
+    /**
+     * Downloads the content for the selected representations in sync or resumes a previously stopped
+     * download.
+     *
+     * @param listener If not null, called during download.
+     * @throws IOException          Thrown when there is an io error while downloading.
+     * @throws DownloadException    Thrown if the media cannot be downloaded.
+     * @throws InterruptedException If the thread has been interrupted.
+     */
+    @Override
+    public final synchronized void download(@Nullable ProgressListener listener)
+            throws IOException, InterruptedException {
+        priorityTaskManager.add(C.PRIORITY_DOWNLOAD);
+        try {
+            getManifestIfNeeded(false);
+            List<Segment> segments = initStatus(false);
+            notifyListener(listener); // Initial notification.
+            Collections.sort(segments);
+            byte[] buffer = new byte[BUFFER_SIZE_BYTES];
+            CachingCounters cachingCounters = new CachingCounters();
+            for (int i = 0; i < segments.size(); i++) {
+                CacheUtil.cache(segments.get(i).dataSpec, cache, dataSource, buffer,
+                        priorityTaskManager, C.PRIORITY_DOWNLOAD, cachingCounters, true);
+                downloadedBytes += cachingCounters.newlyCachedBytes;
+                downloadedSegments++;
+                notifyListener(listener);
+            }
+        } finally {
+            priorityTaskManager.remove(C.PRIORITY_DOWNLOAD);
+        }
+    }
+
+    /**
+     * Returns the total number of segments in the representations which are selected, or {@link
+     * C#LENGTH_UNSET} if it hasn't been calculated yet.
+     *
+     * @see #init()
+     */
+    public final int getTotalSegments() {
+        return totalSegments;
+    }
+
+    /**
+     * Returns the total number of downloaded segments in the representations which are selected, or
+     * {@link C#LENGTH_UNSET} if it hasn't been calculated yet.
+     *
+     * @see #init()
+     */
+    public final int getDownloadedSegments() {
+        return downloadedSegments;
+    }
+
+    /**
+     * Returns the total number of downloaded bytes in the representations which are selected, or
+     * {@link C#LENGTH_UNSET} if it hasn't been calculated yet.
+     *
+     * @see #init()
+     */
+    @Override
+    public final long getDownloadedBytes() {
+        return downloadedBytes;
+    }
+
+    @Override
+    public float getDownloadPercentage() {
+        // Take local snapshot of the volatile fields
+        int totalSegments = this.totalSegments;
+        int downloadedSegments = this.downloadedSegments;
+        if (totalSegments == C.LENGTH_UNSET || downloadedSegments == C.LENGTH_UNSET) {
+            return Float.NaN;
+        }
+        return totalSegments == 0 ? 100f : (downloadedSegments * 100f) / totalSegments;
+    }
+
+    @Override
+    public final void remove() throws InterruptedException {
+        try {
+            getManifestIfNeeded(true);
+        } catch (IOException e) {
+            // Either the manifest file isn't available offline, or it's not parsable. Continue anyway to
+            // reset the counters and attempt to remove the manifest file.
+        }
+        resetCounters();
+        if (manifest != null) {
+            List<Segment> segments = null;
+            try {
+                segments = getSegments(offlineDataSource, manifest, getAllRepresentationKeys(), true);
+            } catch (IOException e) {
+                // Ignore exceptions. We do our best with what's available offline.
+            }
+            if (segments != null) {
+                for (int i = 0; i < segments.size(); i++) {
+                    remove(segments.get(i).dataSpec.uri);
+                }
+            }
+            manifest = null;
+        }
+        remove(manifestUri);
+    }
+
+    /**
+     * Loads and parses the manifest.
+     *
+     * @param dataSource The {@link DataSource} through which to load.
+     * @param uri        The manifest uri.
+     * @return The manifest.
+     * @throws IOException If an error occurs reading data.
+     */
+    protected abstract M getManifest(DataSource dataSource, Uri uri) throws IOException;
+
+    /**
+     * Returns a list of {@link Segment}s for given keys.
+     *
+     * @param dataSource           The {@link DataSource} through which to load any required data.
+     * @param manifest             The manifest containing the segments.
+     * @param keys                 The selected representation keys.
+     * @param allowIncompleteIndex Whether to continue in the case that a load error prevents all
+     *                             segments from being listed. If true then a partial segment list will be returned. If false
+     *                             an {@link IOException} will be thrown.
+     * @return A list of {@link Segment}s for given keys.
+     * @throws InterruptedException Thrown if the thread was interrupted.
+     * @throws IOException          Thrown if {@code allowPartialIndex} is false and a load error occurs, or if
+     *                              the media is not in a form that allows for its segments to be listed.
+     */
+    protected abstract List<Segment> getSegments(DataSource dataSource, M manifest, K[] keys,
+                                                 boolean allowIncompleteIndex) throws InterruptedException, IOException;
+
+    private void resetCounters() {
+        totalSegments = C.LENGTH_UNSET;
+        downloadedSegments = C.LENGTH_UNSET;
+        downloadedBytes = C.LENGTH_UNSET;
+    }
+
+    private void remove(Uri uri) {
+        CacheUtil.remove(cache, CacheUtil.generateKey(uri));
+    }
+
+    private void notifyListener(ProgressListener listener) {
+        if (listener != null) {
+            listener.onDownloadProgress(this, getDownloadPercentage(), downloadedBytes);
+        }
+    }
+
+    /**
+     * Initializes totalSegments, downloadedSegments and downloadedBytes for selected representations.
+     * If not offline then downloads missing metadata.
+     *
+     * @return A list of not fully downloaded segments.
+     */
+    private synchronized List<Segment> initStatus(boolean offline)
+            throws IOException, InterruptedException {
+        DataSource dataSource = getDataSource(offline);
+        if (keys == null) {
+            keys = getAllRepresentationKeys();
+        }
+        List<Segment> segments = getSegments(dataSource, manifest, keys, offline);
+        CachingCounters cachingCounters = new CachingCounters();
+        totalSegments = segments.size();
+        downloadedSegments = 0;
+        downloadedBytes = 0;
+        for (int i = segments.size() - 1; i >= 0; i--) {
+            Segment segment = segments.get(i);
+            CacheUtil.getCached(segment.dataSpec, cache, cachingCounters);
+            downloadedBytes += cachingCounters.alreadyCachedBytes;
+            if (cachingCounters.alreadyCachedBytes == cachingCounters.contentLength) {
+                // The segment is fully downloaded.
+                downloadedSegments++;
+                segments.remove(i);
+            }
+        }
+        return segments;
+    }
+
+    private M getManifestIfNeeded(boolean offline) throws IOException {
+        if (manifest == null) {
+            manifest = getManifest(getDataSource(offline), manifestUri);
+        }
+        return manifest;
+    }
+
+    private DataSource getDataSource(boolean offline) {
+        return offline ? offlineDataSource : dataSource;
+    }
+
+}
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/scheduler/Requirements.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/scheduler/Requirements.java
new file mode 100644
index 0000000000..648180a77d
--- /dev/null
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/scheduler/Requirements.java
@@ -0,0 +1,239 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.demo.scheduler;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.ConnectivityManager;
+import android.net.Network;
+import android.net.NetworkCapabilities;
+import android.net.NetworkInfo;
+import android.os.BatteryManager;
+import android.os.PowerManager;
+import android.support.annotation.IntDef;
+import android.util.Log;
+import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * Defines a set of device state requirements.
+ *
+ * <p>To use network type requirement, application needs to have ACCESS_NETWORK_STATE permission.
+ */
+public final class Requirements {
+
+    /** Network types. */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({
+            NETWORK_TYPE_NONE,
+            NETWORK_TYPE_ANY,
+            NETWORK_TYPE_UNMETERED,
+            NETWORK_TYPE_NOT_ROAMING,
+            NETWORK_TYPE_METERED,
+    })
+    public @interface NetworkType {}
+    /** This job doesn't require network connectivity. */
+    public static final int NETWORK_TYPE_NONE = 0;
+    /** This job requires network connectivity. */
+    public static final int NETWORK_TYPE_ANY = 1;
+    /** This job requires network connectivity that is unmetered. */
+    public static final int NETWORK_TYPE_UNMETERED = 2;
+    /** This job requires network connectivity that is not roaming. */
+    public static final int NETWORK_TYPE_NOT_ROAMING = 3;
+    /** This job requires metered connectivity such as most cellular data networks. */
+    public static final int NETWORK_TYPE_METERED = 4;
+    /** This job requires the device to be idle. */
+    private static final int DEVICE_IDLE = 8;
+    /** This job requires the device to be charging. */
+    private static final int DEVICE_CHARGING = 16;
+
+    private static final int NETWORK_TYPE_MASK = 7;
+
+    private static final String TAG = "Requirements";
+
+    private static final String[] NETWORK_TYPE_STRINGS;
+
+    static {
+        if (Scheduler.DEBUG) {
+            NETWORK_TYPE_STRINGS =
+                    new String[] {
+                            "NETWORK_TYPE_NONE",
+                            "NETWORK_TYPE_ANY",
+                            "NETWORK_TYPE_UNMETERED",
+                            "NETWORK_TYPE_NOT_ROAMING",
+                            "NETWORK_TYPE_METERED"
+                    };
+        } else {
+            NETWORK_TYPE_STRINGS = null;
+        }
+    }
+
+    private final int requirements;
+
+    /**
+     * @param networkType Required network type.
+     * @param charging Whether the device should be charging.
+     * @param idle Whether the device should be idle.
+     */
+    public Requirements(@NetworkType int networkType, boolean charging, boolean idle) {
+        this(networkType | (charging ? DEVICE_CHARGING : 0) | (idle ? DEVICE_IDLE : 0));
+    }
+
+    /** @param requirementsData The value returned by {@link #getRequirementsData()}. */
+    public Requirements(int requirementsData) {
+        this.requirements = requirementsData;
+    }
+
+    /** Returns required network type. */
+    public int getRequiredNetworkType() {
+        return requirements & NETWORK_TYPE_MASK;
+    }
+
+    /** Returns whether the device should be charging. */
+    public boolean isChargingRequired() {
+        return (requirements & DEVICE_CHARGING) != 0;
+    }
+
+    /** Returns whether the device should be idle. */
+    public boolean isIdleRequired() {
+        return (requirements & DEVICE_IDLE) != 0;
+    }
+
+    /**
+     * Returns whether the requirements are met.
+     *
+     * @param context Any context.
+     */
+    public boolean checkRequirements(Context context) {
+        return checkNetworkRequirements(context)
+                && checkChargingRequirement(context)
+                && checkIdleRequirement(context);
+    }
+
+    /** Returns the encoded requirements data which can be used with {@link #Requirements(int)}. */
+    public int getRequirementsData() {
+        return requirements;
+    }
+
+    private boolean checkNetworkRequirements(Context context) {
+        int networkRequirement = getRequiredNetworkType();
+        if (networkRequirement == NETWORK_TYPE_NONE) {
+            return true;
+        }
+        ConnectivityManager connectivityManager =
+                (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+        NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
+        if (networkInfo == null || !networkInfo.isConnected()) {
+            logd("No network info or no connection.");
+            return false;
+        }
+        if (!checkInternetConnectivity(connectivityManager)) {
+            return false;
+        }
+        if (networkRequirement == NETWORK_TYPE_ANY) {
+            return true;
+        }
+        if (networkRequirement == NETWORK_TYPE_NOT_ROAMING) {
+            boolean roaming = networkInfo.isRoaming();
+            logd("Roaming: " + roaming);
+            return !roaming;
+        }
+        boolean activeNetworkMetered = isActiveNetworkMetered(connectivityManager, networkInfo);
+        logd("Metered network: " + activeNetworkMetered);
+        if (networkRequirement == NETWORK_TYPE_UNMETERED) {
+            return !activeNetworkMetered;
+        }
+        if (networkRequirement == NETWORK_TYPE_METERED) {
+            return activeNetworkMetered;
+        }
+        throw new IllegalStateException();
+    }
+
+    private boolean checkChargingRequirement(Context context) {
+        if (!isChargingRequired()) {
+            return true;
+        }
+        Intent batteryStatus =
+                context.registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
+        if (batteryStatus == null) {
+            return false;
+        }
+        int status = batteryStatus.getIntExtra(BatteryManager.EXTRA_STATUS, -1);
+        return status == BatteryManager.BATTERY_STATUS_CHARGING
+                || status == BatteryManager.BATTERY_STATUS_FULL;
+    }
+
+    private boolean checkIdleRequirement(Context context) {
+        if (!isIdleRequired()) {
+            return true;
+        }
+        PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
+        return Util.SDK_INT >= 23
+                ? !powerManager.isDeviceIdleMode()
+                : Util.SDK_INT >= 20 ? !powerManager.isInteractive() : !powerManager.isScreenOn();
+    }
+
+    private static boolean checkInternetConnectivity(ConnectivityManager connectivityManager) {
+        if (Util.SDK_INT < 23) {
+            // TODO Check internet connectivity using http://clients3.google.com/generate_204 on API
+            // levels prior to 23.
+            return true;
+        }
+        Network activeNetwork = connectivityManager.getActiveNetwork();
+        if (activeNetwork == null) {
+            logd("No active network.");
+            return false;
+        }
+        NetworkCapabilities networkCapabilities =
+                connectivityManager.getNetworkCapabilities(activeNetwork);
+        boolean validated =
+                networkCapabilities == null
+                        || !networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED);
+        logd("Network capability validated: " + validated);
+        return !validated;
+    }
+
+    private static boolean isActiveNetworkMetered(
+            ConnectivityManager connectivityManager, NetworkInfo networkInfo) {
+        if (Util.SDK_INT >= 16) {
+            return connectivityManager.isActiveNetworkMetered();
+        }
+        int type = networkInfo.getType();
+        return type != ConnectivityManager.TYPE_WIFI
+                && type != ConnectivityManager.TYPE_BLUETOOTH
+                && type != ConnectivityManager.TYPE_ETHERNET;
+    }
+
+    private static void logd(String message) {
+        if (Scheduler.DEBUG) {
+            Log.d(TAG, message);
+        }
+    }
+
+    @Override
+    public String toString() {
+        if (!Scheduler.DEBUG) {
+            return super.toString();
+        }
+        return "requirements{"
+                + NETWORK_TYPE_STRINGS[getRequiredNetworkType()]
+                + (isChargingRequired() ? ",charging" : "")
+                + (isIdleRequired() ? ",idle" : "")
+                + '}';
+    }
+}
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/scheduler/RequirementsWatcher.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/scheduler/RequirementsWatcher.java
new file mode 100644
index 0000000000..1ebecb71a9
--- /dev/null
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/scheduler/RequirementsWatcher.java
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.demo.scheduler;
+
+import android.annotation.TargetApi;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.ConnectivityManager;
+import android.net.Network;
+import android.net.NetworkCapabilities;
+import android.net.NetworkRequest;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.PowerManager;
+import android.support.annotation.RequiresApi;
+import android.util.Log;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
+
+/**
+ * Watches whether the {@link Requirements} are met and notifies the {@link Listener} on changes.
+ */
+public final class RequirementsWatcher {
+
+    /**
+     * Notified when RequirementsWatcher instance first created and on changes whether the {@link
+     * Requirements} are met.
+     */
+    public interface Listener {
+
+        /**
+         * Called when the requirements are met.
+         *
+         * @param requirementsWatcher Calling instance.
+         */
+        void requirementsMet(RequirementsWatcher requirementsWatcher);
+
+        /**
+         * Called when the requirements are not met.
+         *
+         * @param requirementsWatcher Calling instance.
+         */
+        void requirementsNotMet(RequirementsWatcher requirementsWatcher);
+    }
+
+    private static final String TAG = "RequirementsWatcher";
+
+    private final Context context;
+    private final Listener listener;
+    private final Requirements requirements;
+    private DeviceStatusChangeReceiver receiver;
+
+    private boolean requirementsWereMet;
+    private CapabilityValidatedCallback networkCallback;
+
+    /**
+     * @param context Used to register for broadcasts.
+     * @param listener Notified whether the {@link Requirements} are met.
+     * @param requirements The requirements to watch.
+     */
+    public RequirementsWatcher(Context context, Listener listener, Requirements requirements) {
+        this.requirements = requirements;
+        this.listener = listener;
+        this.context = context;
+        logd(this + " created");
+    }
+
+    /**
+     * Starts watching for changes. Must be called from a thread that has an associated {@link
+     * Looper}. Listener methods are called on the caller thread.
+     */
+    public void start() {
+        Assertions.checkNotNull(Looper.myLooper());
+
+        checkRequirements(true);
+
+        IntentFilter filter = new IntentFilter();
+        if (requirements.getRequiredNetworkType() != Requirements.NETWORK_TYPE_NONE) {
+            if (Util.SDK_INT >= 23) {
+                registerNetworkCallbackV23();
+            } else {
+                filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
+            }
+        }
+        if (requirements.isChargingRequired()) {
+            filter.addAction(Intent.ACTION_POWER_CONNECTED);
+            filter.addAction(Intent.ACTION_POWER_DISCONNECTED);
+        }
+        if (requirements.isIdleRequired()) {
+            if (Util.SDK_INT >= 23) {
+                filter.addAction(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
+            } else {
+                filter.addAction(Intent.ACTION_SCREEN_ON);
+                filter.addAction(Intent.ACTION_SCREEN_OFF);
+            }
+        }
+        receiver = new DeviceStatusChangeReceiver();
+        context.registerReceiver(receiver, filter, null, new Handler());
+        logd(this + " started");
+    }
+
+    /** Stops watching for changes. */
+    public void stop() {
+        context.unregisterReceiver(receiver);
+        receiver = null;
+        if (networkCallback != null) {
+            unregisterNetworkCallback();
+        }
+        logd(this + " stopped");
+    }
+
+    /** Returns watched {@link Requirements}. */
+    public Requirements getRequirements() {
+        return requirements;
+    }
+
+    @Override
+    public String toString() {
+        if (!Scheduler.DEBUG) {
+            return super.toString();
+        }
+        return "RequirementsWatcher{" + requirements + '}';
+    }
+
+    @TargetApi(23)
+    private void registerNetworkCallbackV23() {
+        ConnectivityManager connectivityManager =
+                (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+        NetworkRequest request =
+                new NetworkRequest.Builder()
+                        .addCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)
+                        .build();
+        networkCallback = new CapabilityValidatedCallback();
+        connectivityManager.registerNetworkCallback(request, networkCallback);
+    }
+
+    private void unregisterNetworkCallback() {
+        if (Util.SDK_INT >= 21) {
+            ConnectivityManager connectivityManager =
+                    (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+            connectivityManager.unregisterNetworkCallback(networkCallback);
+            networkCallback = null;
+        }
+    }
+
+    private void checkRequirements(boolean force) {
+        boolean requirementsAreMet = requirements.checkRequirements(context);
+        if (!force) {
+            if (requirementsAreMet == requirementsWereMet) {
+                logd("requirementsAreMet is still " + requirementsAreMet);
+                return;
+            }
+        }
+        requirementsWereMet = requirementsAreMet;
+        if (requirementsAreMet) {
+            logd("start job");
+            listener.requirementsMet(this);
+        } else {
+            logd("stop job");
+            listener.requirementsNotMet(this);
+        }
+    }
+
+    private static void logd(String message) {
+        if (Scheduler.DEBUG) {
+            Log.d(TAG, message);
+        }
+    }
+
+    private class DeviceStatusChangeReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (!isInitialStickyBroadcast()) {
+                logd(RequirementsWatcher.this + " received " + intent.getAction());
+                checkRequirements(false);
+            }
+        }
+    }
+
+    @RequiresApi(api = 21)
+    private final class CapabilityValidatedCallback extends ConnectivityManager.NetworkCallback {
+        @Override
+        public void onAvailable(Network network) {
+            super.onAvailable(network);
+            logd(RequirementsWatcher.this + " NetworkCallback.onAvailable");
+            checkRequirements(false);
+        }
+
+        @Override
+        public void onLost(Network network) {
+            super.onLost(network);
+            logd(RequirementsWatcher.this + " NetworkCallback.onLost");
+            checkRequirements(false);
+        }
+    }
+}
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/scheduler/Scheduler.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/scheduler/Scheduler.java
new file mode 100644
index 0000000000..3aca8c1c5b
--- /dev/null
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/scheduler/Scheduler.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.demo.scheduler;
+
+/**
+ * Implementer of this interface schedules one implementation specific job to be run when some
+ * requirements are met even if the app isn't running.
+ */
+public interface Scheduler {
+
+    /*package*/ boolean DEBUG = true;
+
+    /**
+     * Schedules the job to be run when the requirements are met.
+     *
+     * @return Whether the job scheduled successfully.
+     */
+    boolean schedule();
+
+    /**
+     * Cancels any previous schedule.
+     *
+     * @return Whether the job cancelled successfully.
+     */
+    boolean cancel();
+}
+
diff --git a/demos/main/src/main/res/layout/download_activity.xml b/demos/main/src/main/res/layout/download_activity.xml
new file mode 100644
index 0000000000..1915d33729
--- /dev/null
+++ b/demos/main/src/main/res/layout/download_activity.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical">
+
+    <Button
+        android:id="@+id/btn_start_download"
+        android:layout_width="wrap_content"
+        android:layout_height="50dp"
+        android:text="Start Download" />
+
+    <Button
+        android:id="@+id/btn_cancel_download"
+        android:layout_width="wrap_content"
+        android:layout_height="50dp"
+        android:text="Cancel Download" />
+
+    <Button
+        android:id="@+id/btn_pause_download"
+        android:layout_width="wrap_content"
+        android:layout_height="50dp"
+        android:text="Pause Download" />
+
+    <TextView
+        android:id="@+id/txt_status"
+        android:layout_width="wrap_content"
+        android:layout_height="50dp"
+        android:text="Nothing happening here" />
+
+</LinearLayout>
\ No newline at end of file
diff --git a/demos/main/src/main/res/menu/download_menu.xml b/demos/main/src/main/res/menu/download_menu.xml
new file mode 100644
index 0000000000..99fc329e16
--- /dev/null
+++ b/demos/main/src/main/res/menu/download_menu.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android">
+    <item
+        android:id="@+id/menu_download"
+        android:icon="@android:drawable/ic_menu_save"
+        android:showAsAction="ifRoom"
+        android:title="Download" />
+</menu>
\ No newline at end of file
