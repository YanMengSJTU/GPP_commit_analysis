diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 60e421a860..d0c9a6400c 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,5 +1,12 @@
 # Release notes #
 
+### r1.5.12 ###
+
+* Improvements to Cronet network stack extension.
+* Fix bug in demo app introduced in r1.5.11 that caused L3 Widevine
+  provisioning requests to fail.
+* Misc bugfixes.
+
 ### r1.5.11 ###
 
 * Cronet network stack extension.
diff --git a/build.gradle b/build.gradle
index 7e24099ded..40ffda09f6 100644
--- a/build.gradle
+++ b/build.gradle
@@ -16,7 +16,6 @@
 
 buildscript {
     repositories {
-        mavenCentral()
         jcenter()
     }
     dependencies {
@@ -27,6 +26,6 @@ buildscript {
 
 allprojects {
     repositories {
-        mavenCentral()
+        jcenter()
     }
 }
diff --git a/demo/src/main/AndroidManifest.xml b/demo/src/main/AndroidManifest.xml
index eaa2e296d1..79b070e161 100644
--- a/demo/src/main/AndroidManifest.xml
+++ b/demo/src/main/AndroidManifest.xml
@@ -16,8 +16,8 @@
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer.demo"
-    android:versionCode="1511"
-    android:versionName="1.5.11"
+    android:versionCode="1512"
+    android:versionName="1.5.12"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/WidevineTestMediaDrmCallback.java b/demo/src/main/java/com/google/android/exoplayer/demo/WidevineTestMediaDrmCallback.java
index 9039d16cb2..291a5afdde 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/WidevineTestMediaDrmCallback.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/WidevineTestMediaDrmCallback.java
@@ -47,7 +47,7 @@ public WidevineTestMediaDrmCallback(String contentId, String provider) {
   @Override
   public byte[] executeProvisionRequest(UUID uuid, ProvisionRequest request) throws IOException {
     String url = request.getDefaultUrl() + "&signedRequest=" + new String(request.getData());
-    return Util.executePost(url, null, REQUEST_PROPERTIES);
+    return Util.executePost(url, null, null);
   }
 
   @Override
diff --git a/extensions/cronet/src/androidTest/java/com/google/android/exoplayer/ext/cronet/CronetDataSourceTest.java b/extensions/cronet/src/androidTest/java/com/google/android/exoplayer/ext/cronet/CronetDataSourceTest.java
index 246028649a..3c0851f5c9 100644
--- a/extensions/cronet/src/androidTest/java/com/google/android/exoplayer/ext/cronet/CronetDataSourceTest.java
+++ b/extensions/cronet/src/androidTest/java/com/google/android/exoplayer/ext/cronet/CronetDataSourceTest.java
@@ -81,7 +81,6 @@
   private static final String TEST_CONTENT_TYPE = "test/test";
   private static final byte[] TEST_POST_BODY = "test post body".getBytes();
   private static final long TEST_CONTENT_LENGTH = 16000L;
-  private static final int TEST_BUFFER_SIZE = 16;
   private static final int TEST_CONNECTION_STATUS = 5;
 
   private DataSpec testDataSpec;
@@ -99,8 +98,8 @@ public abstract UrlRequest createRequest(String url, UrlRequest.Callback callbac
         Executor executor, int priority,
         Collection<Object> connectionAnnotations,
         boolean disableCache,
-        boolean disableConnectionMigration);
-
+        boolean disableConnectionMigration,
+        boolean allowDirectExecutor);
   }
 
   @Mock
@@ -129,12 +128,12 @@ public void setUp() throws Exception {
         new CronetDataSource(
             mockCronetEngine,
             mockExecutor,
-            mockClock,
             mockContentTypePredicate,
             mockTransferListener,
             TEST_CONNECT_TIMEOUT_MS,
             TEST_READ_TIMEOUT_MS,
-            true)); // resetTimeoutOnRedirects
+            true, // resetTimeoutOnRedirects
+            mockClock));
     when(mockContentTypePredicate.evaluate(anyString())).thenReturn(true);
     when(mockCronetEngine.createRequest(
         anyString(),
@@ -143,6 +142,7 @@ public void setUp() throws Exception {
         anyInt(),
         eq(Collections.emptyList()),
         any(Boolean.class),
+        any(Boolean.class),
         any(Boolean.class))).thenReturn(mockUrlRequest);
     mockStatusResponse();
 
@@ -151,7 +151,7 @@ public void setUp() throws Exception {
         Uri.parse(TEST_URL), TEST_POST_BODY, 0, 0, C.LENGTH_UNBOUNDED, null, 0);
     testResponseHeader = new HashMap<>();
     testResponseHeader.put("Content-Type", TEST_CONTENT_TYPE);
-    // This value can be anything since the DataSpec is unbounded.
+    // This value can be anything since the DataSpec is unset.
     testResponseHeader.put("Content-Length", Long.toString(TEST_CONTENT_LENGTH));
     testUrlResponseInfo = createUrlResponseInfo(200); // statusCode
   }
@@ -170,18 +170,15 @@ private UrlResponseInfo createUrlResponseInfo(int statusCode) {
   }
 
   @Test(expected = IllegalStateException.class)
-  public void testOpeningTwiceThrows() throws HttpDataSourceException, IllegalStateException {
-    mockResponesStartSuccess();
-
-    assertConnectionState(CronetDataSource.IDLE_CONNECTION);
+  public void testOpeningTwiceThrows() throws HttpDataSourceException {
+    mockResponseStartSuccess();
     dataSourceUnderTest.open(testDataSpec);
-    assertConnectionState(CronetDataSource.OPEN_CONNECTION);
     dataSourceUnderTest.open(testDataSpec);
   }
 
   @Test
   public void testCallbackFromPreviousRequest() throws HttpDataSourceException {
-    mockResponesStartSuccess();
+    mockResponseStartSuccess();
 
     dataSourceUnderTest.open(testDataSpec);
     dataSourceUnderTest.close();
@@ -194,6 +191,7 @@ public void testCallbackFromPreviousRequest() throws HttpDataSourceException {
         anyInt(),
         eq(Collections.emptyList()),
         any(Boolean.class),
+        any(Boolean.class),
         any(Boolean.class))).thenReturn(mockUrlRequest2);
     doAnswer(new Answer<Object>() {
       @Override
@@ -202,7 +200,7 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
         dataSourceUnderTest.onFailed(
             mockUrlRequest,
             testUrlResponseInfo,
-            null);
+            mockUrlRequestException);
         dataSourceUnderTest.onResponseStarted(
             mockUrlRequest2,
             testUrlResponseInfo);
@@ -214,7 +212,7 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
 
   @Test
   public void testRequestStartCalled() throws HttpDataSourceException {
-    mockResponesStartSuccess();
+    mockResponseStartSuccess();
 
     dataSourceUnderTest.open(testDataSpec);
     verify(mockCronetEngine).createRequest(
@@ -224,16 +222,15 @@ public void testRequestStartCalled() throws HttpDataSourceException {
         anyInt(),
         eq(Collections.emptyList()),
         any(Boolean.class),
+        any(Boolean.class),
         any(Boolean.class));
     verify(mockUrlRequest).start();
   }
 
   @Test
   public void testRequestHeadersSet() throws HttpDataSourceException {
-    mockResponesStartSuccess();
-
     testDataSpec = new DataSpec(Uri.parse(TEST_URL), 1000, 5000, null);
-    testResponseHeader.put("Content-Length", Long.toString(5000L));
+    mockResponseStartSuccess();
 
     dataSourceUnderTest.setRequestProperty("firstHeader", "firstValue");
     dataSourceUnderTest.setRequestProperty("secondHeader", "secondValue");
@@ -248,10 +245,20 @@ public void testRequestHeadersSet() throws HttpDataSourceException {
 
   @Test
   public void testRequestOpen() throws HttpDataSourceException {
-    mockResponesStartSuccess();
-
+    mockResponseStartSuccess();
     assertEquals(TEST_CONTENT_LENGTH, dataSourceUnderTest.open(testDataSpec));
-    assertConnectionState(CronetDataSource.OPEN_CONNECTION);
+    verify(mockTransferListener).onTransferStart();
+  }
+
+  @Test
+  public void testRequestOpenGzippedCompressedReturnsDataSpecLength()
+      throws HttpDataSourceException {
+    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 0, 5000, null);
+    testResponseHeader.put("Content-Encoding", "gzip");
+    testResponseHeader.put("Content-Length", Long.toString(50L));
+    mockResponseStartSuccess();
+
+    assertEquals(5000 /* contentLength */, dataSourceUnderTest.open(testDataSpec));
     verify(mockTransferListener).onTransferStart();
   }
 
@@ -266,7 +273,6 @@ public void testRequestOpenFail() {
       // Check for connection not automatically closed.
       assertFalse(e.getCause() instanceof UnknownHostException);
       verify(mockUrlRequest, never()).cancel();
-      assertConnectionState(CronetDataSource.OPENING_CONNECTION);
       verify(mockTransferListener, never()).onTransferStart();
     }
   }
@@ -284,14 +290,13 @@ public void testRequestOpenFailDueToDnsFailure() {
       // Check for connection not automatically closed.
       assertTrue(e.getCause() instanceof UnknownHostException);
       verify(mockUrlRequest, never()).cancel();
-      assertConnectionState(CronetDataSource.OPENING_CONNECTION);
       verify(mockTransferListener, never()).onTransferStart();
     }
   }
 
   @Test
   public void testRequestOpenValidatesStatusCode() {
-    mockResponesStartSuccess();
+    mockResponseStartSuccess();
     testUrlResponseInfo = createUrlResponseInfo(500); // statusCode
 
     try {
@@ -301,14 +306,13 @@ public void testRequestOpenValidatesStatusCode() {
       assertTrue(e instanceof HttpDataSource.InvalidResponseCodeException);
       // Check for connection not automatically closed.
       verify(mockUrlRequest, never()).cancel();
-      assertConnectionState(CronetDataSource.OPENING_CONNECTION);
       verify(mockTransferListener, never()).onTransferStart();
     }
   }
 
   @Test
   public void testRequestOpenValidatesContentTypePredicate() {
-    mockResponesStartSuccess();
+    mockResponseStartSuccess();
     when(mockContentTypePredicate.evaluate(anyString())).thenReturn(false);
 
     try {
@@ -318,43 +322,22 @@ public void testRequestOpenValidatesContentTypePredicate() {
       assertTrue(e instanceof HttpDataSource.InvalidContentTypeException);
       // Check for connection not automatically closed.
       verify(mockUrlRequest, never()).cancel();
-      assertConnectionState(CronetDataSource.OPENING_CONNECTION);
       verify(mockContentTypePredicate).evaluate(TEST_CONTENT_TYPE);
     }
   }
 
-  @Test
-  public void testRequestOpenValidatesContentLength() {
-    mockResponesStartSuccess();
-
-    // Data spec's requested length, 5000. Test response's length, 16,000.
-    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 1000, 5000, null);
-
-    try {
-      dataSourceUnderTest.open(testDataSpec);
-      fail("HttpDataSource.HttpDataSourceException expected");
-    } catch (HttpDataSourceException e) {
-      verify(mockUrlRequest).addHeader("Range", "bytes=1000-5999");
-      // Check for connection not automatically closed.
-      verify(mockUrlRequest, never()).cancel();
-      assertConnectionState(CronetDataSource.OPENING_CONNECTION);
-      verify(mockTransferListener, never()).onTransferStart();
-    }
-  }
-
   @Test
   public void testPostRequestOpen() throws HttpDataSourceException {
-    mockResponesStartSuccess();
+    mockResponseStartSuccess();
 
     dataSourceUnderTest.setRequestProperty("Content-Type", TEST_CONTENT_TYPE);
     assertEquals(TEST_CONTENT_LENGTH, dataSourceUnderTest.open(testPostDataSpec));
-    assertConnectionState(CronetDataSource.OPEN_CONNECTION);
     verify(mockTransferListener).onTransferStart();
   }
 
   @Test
   public void testPostRequestOpenValidatesContentType() {
-    mockResponesStartSuccess();
+    mockResponseStartSuccess();
 
     try {
       dataSourceUnderTest.open(testPostDataSpec);
@@ -366,7 +349,7 @@ public void testPostRequestOpenValidatesContentType() {
 
   @Test
   public void testPostRequestOpenRejects307Redirects() {
-    mockResponesStartSuccess();
+    mockResponseStartSuccess();
     mockResponseStartRedirect();
 
     try {
@@ -380,8 +363,8 @@ public void testPostRequestOpenRejects307Redirects() {
 
   @Test
   public void testRequestReadTwice() throws HttpDataSourceException {
-    mockResponesStartSuccess();
-    mockReadSuccess();
+    mockResponseStartSuccess();
+    mockReadSuccess(0, 16);
 
     dataSourceUnderTest.open(testDataSpec);
 
@@ -402,29 +385,24 @@ public void testRequestReadTwice() throws HttpDataSourceException {
 
   @Test
   public void testSecondRequestNoContentLength() throws HttpDataSourceException {
-    mockResponesStartSuccess();
-    mockReadSuccess();
-
-    byte[] returnedBuffer = new byte[8];
+    mockResponseStartSuccess();
+    testResponseHeader.put("Content-Length", Long.toString(1L));
+    mockReadSuccess(0, 16);
 
     // First request.
-    testResponseHeader.put("Content-Length", Long.toString(1L));
-    testUrlResponseInfo = createUrlResponseInfo(200); // statusCode
     dataSourceUnderTest.open(testDataSpec);
+    byte[] returnedBuffer = new byte[8];
     dataSourceUnderTest.read(returnedBuffer, 0, 1);
     dataSourceUnderTest.close();
 
-    // Second request. There's no Content-Length response header.
     testResponseHeader.remove("Content-Length");
-    testUrlResponseInfo = createUrlResponseInfo(200); // statusCode
+    mockReadSuccess(0, 16);
+
+    // Second request.
     dataSourceUnderTest.open(testDataSpec);
     returnedBuffer = new byte[16];
     int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 10);
     assertEquals(10, bytesRead);
-
-    mockResponseFinished();
-
-    // Should read whats left in the buffer first.
     bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 10);
     assertEquals(6, bytesRead);
     bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 10);
@@ -433,8 +411,55 @@ public void testSecondRequestNoContentLength() throws HttpDataSourceException {
 
   @Test
   public void testReadWithOffset() throws HttpDataSourceException {
-    mockResponesStartSuccess();
-    mockReadSuccess();
+    mockResponseStartSuccess();
+    mockReadSuccess(0, 16);
+
+    dataSourceUnderTest.open(testDataSpec);
+
+    byte[] returnedBuffer = new byte[16];
+    int bytesRead = dataSourceUnderTest.read(returnedBuffer, 8, 8);
+    assertEquals(8, bytesRead);
+    assertArrayEquals(prefixZeros(buildTestDataArray(0, 8), 16), returnedBuffer);
+    verify(mockTransferListener).onBytesTransferred(8);
+  }
+
+  @Test
+  public void testRangeRequestWith206Response() throws HttpDataSourceException {
+    mockResponseStartSuccess();
+    mockReadSuccess(1000, 5000);
+    testUrlResponseInfo = createUrlResponseInfo(206); // Server supports range requests.
+    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 1000, 5000, null);
+
+    dataSourceUnderTest.open(testDataSpec);
+
+    byte[] returnedBuffer = new byte[16];
+    int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 16);
+    assertEquals(16, bytesRead);
+    assertArrayEquals(buildTestDataArray(1000, 16), returnedBuffer);
+    verify(mockTransferListener).onBytesTransferred(16);
+  }
+
+  @Test
+  public void testRangeRequestWith200Response() throws HttpDataSourceException {
+    mockResponseStartSuccess();
+    mockReadSuccess(0, 7000);
+    testUrlResponseInfo = createUrlResponseInfo(200); // Server does not support range requests.
+    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 1000, 5000, null);
+
+    dataSourceUnderTest.open(testDataSpec);
+
+    byte[] returnedBuffer = new byte[16];
+    int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 16);
+    assertEquals(16, bytesRead);
+    assertArrayEquals(buildTestDataArray(1000, 16), returnedBuffer);
+    verify(mockTransferListener).onBytesTransferred(16);
+  }
+
+  @Test
+  public void testReadWithUnsetLength() throws HttpDataSourceException {
+    testResponseHeader.remove("Content-Length");
+    mockResponseStartSuccess();
+    mockReadSuccess(0, 16);
 
     dataSourceUnderTest.open(testDataSpec);
 
@@ -447,8 +472,8 @@ public void testReadWithOffset() throws HttpDataSourceException {
 
   @Test
   public void testReadReturnsWhatItCan() throws HttpDataSourceException {
-    mockResponesStartSuccess();
-    mockReadSuccess();
+    mockResponseStartSuccess();
+    mockReadSuccess(0, 16);
 
     dataSourceUnderTest.open(testDataSpec);
 
@@ -461,8 +486,8 @@ public void testReadReturnsWhatItCan() throws HttpDataSourceException {
 
   @Test
   public void testClosedMeansClosed() throws HttpDataSourceException {
-    mockResponesStartSuccess();
-    mockReadSuccess();
+    mockResponseStartSuccess();
+    mockReadSuccess(0, 16);
 
     int bytesRead = 0;
     dataSourceUnderTest.open(testDataSpec);
@@ -474,7 +499,6 @@ public void testClosedMeansClosed() throws HttpDataSourceException {
 
     dataSourceUnderTest.close();
     verify(mockTransferListener).onTransferEnd();
-    assertConnectionState(CronetDataSource.IDLE_CONNECTION);
 
     try {
       bytesRead += dataSourceUnderTest.read(returnedBuffer, 0, 8);
@@ -489,32 +513,29 @@ public void testClosedMeansClosed() throws HttpDataSourceException {
 
   @Test
   public void testOverread() throws HttpDataSourceException {
-    mockResponesStartSuccess();
-    mockReadSuccess();
-
-    // Ask for 16 bytes
-    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 10000, 16, null);
-    // Let the response promise to give 16 bytes back.
+    testDataSpec = new DataSpec(Uri.parse(TEST_URL), 0, 16, null);
     testResponseHeader.put("Content-Length", Long.toString(16L));
+    mockResponseStartSuccess();
+    mockReadSuccess(0, 16);
 
     dataSourceUnderTest.open(testDataSpec);
 
     byte[] returnedBuffer = new byte[8];
     int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 8);
-    assertArrayEquals(buildTestDataArray(0, 8), returnedBuffer);
     assertEquals(8, bytesRead);
+    assertArrayEquals(buildTestDataArray(0, 8), returnedBuffer);
 
     // The current buffer is kept if not completely consumed by DataSource reader.
     returnedBuffer = new byte[8];
     bytesRead += dataSourceUnderTest.read(returnedBuffer, 0, 6);
-    assertArrayEquals(suffixZeros(buildTestDataArray(8, 6), 8), returnedBuffer);
     assertEquals(14, bytesRead);
+    assertArrayEquals(suffixZeros(buildTestDataArray(8, 6), 8), returnedBuffer);
 
     // 2 bytes left at this point.
     returnedBuffer = new byte[8];
     bytesRead += dataSourceUnderTest.read(returnedBuffer, 0, 8);
-    assertArrayEquals(suffixZeros(buildTestDataArray(14, 2), 8), returnedBuffer);
     assertEquals(16, bytesRead);
+    assertArrayEquals(suffixZeros(buildTestDataArray(14, 2), 8), returnedBuffer);
 
     // Should have only called read on cronet once.
     verify(mockUrlRequest, times(1)).read(any(ByteBuffer.class));
@@ -535,7 +556,6 @@ public void testOverread() throws HttpDataSourceException {
     verify(mockUrlRequest, times(1)).read(any(ByteBuffer.class));
     // Check for connection not automatically closed.
     verify(mockUrlRequest, never()).cancel();
-    assertConnectionState(CronetDataSource.OPEN_CONNECTION);
     assertEquals(16, bytesRead);
   }
 
@@ -566,15 +586,12 @@ public void run() {
 
     // We should still be trying to open.
     assertFalse(timedOutCondition.block(50));
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
     // We should still be trying to open as we approach the timeout.
     when(mockClock.elapsedRealtime()).thenReturn((long) TEST_CONNECT_TIMEOUT_MS - 1);
     assertFalse(timedOutCondition.block(50));
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
     // Now we timeout.
     when(mockClock.elapsedRealtime()).thenReturn((long) TEST_CONNECT_TIMEOUT_MS);
     timedOutCondition.block();
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
 
     verify(mockTransferListener, never()).onTransferStart();
   }
@@ -600,15 +617,12 @@ public void run() {
 
     // We should still be trying to open.
     assertFalse(openCondition.block(50));
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
     // We should still be trying to open as we approach the timeout.
     when(mockClock.elapsedRealtime()).thenReturn((long) TEST_CONNECT_TIMEOUT_MS - 1);
     assertFalse(openCondition.block(50));
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
     // The response arrives just in time.
     dataSourceUnderTest.onResponseStarted(mockUrlRequest, testUrlResponseInfo);
     openCondition.block();
-    assertEquals(CronetDataSource.OPEN_CONNECTION, dataSourceUnderTest.connectionState);
   }
 
   @Test
@@ -637,11 +651,9 @@ public void run() {
 
     // We should still be trying to open.
     assertFalse(timedOutCondition.block(50));
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
     // We should still be trying to open as we approach the timeout.
     when(mockClock.elapsedRealtime()).thenReturn((long) TEST_CONNECT_TIMEOUT_MS - 1);
     assertFalse(timedOutCondition.block(50));
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
     // A redirect arrives just in time.
     dataSourceUnderTest.onRedirectReceived(mockUrlRequest, testUrlResponseInfo,
         "RandomRedirectedUrl1");
@@ -652,7 +664,6 @@ public void run() {
     assertFalse(timedOutCondition.block(newTimeoutMs));
     // We should still be trying to open as we approach the new timeout.
     assertFalse(timedOutCondition.block(50));
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
     // A redirect arrives just in time.
     dataSourceUnderTest.onRedirectReceived(mockUrlRequest, testUrlResponseInfo,
         "RandomRedirectedUrl2");
@@ -663,11 +674,9 @@ public void run() {
     assertFalse(timedOutCondition.block(newTimeoutMs));
     // We should still be trying to open as we approach the new timeout.
     assertFalse(timedOutCondition.block(50));
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
     // Now we timeout.
     when(mockClock.elapsedRealtime()).thenReturn(newTimeoutMs);
     timedOutCondition.block();
-    assertEquals(CronetDataSource.OPENING_CONNECTION, dataSourceUnderTest.connectionState);
 
     verify(mockTransferListener, never()).onTransferStart();
     assertEquals(1, openExceptions.get());
@@ -675,7 +684,7 @@ public void run() {
 
   @Test
   public void testExceptionFromTransferListener() throws HttpDataSourceException {
-    mockResponesStartSuccess();
+    mockResponseStartSuccess();
 
     // Make mockTransferListener throw an exception in CronetDataSource.close(). Ensure that
     // the subsequent open() call succeeds.
@@ -693,7 +702,7 @@ public void testExceptionFromTransferListener() throws HttpDataSourceException {
 
   @Test
   public void testReadFailure() throws HttpDataSourceException {
-    mockResponesStartSuccess();
+    mockResponseStartSuccess();
     mockReadFailure();
 
     dataSourceUnderTest.open(testDataSpec);
@@ -720,7 +729,7 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
     }).when(mockUrlRequest).getStatus(any(UrlRequest.StatusListener.class));
   }
 
-  private void mockResponesStartSuccess() {
+  private void mockResponseStartSuccess() {
     doAnswer(new Answer<Object>() {
       @Override
       public Object answer(InvocationOnMock invocation) throws Throwable {
@@ -758,16 +767,24 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
     }).when(mockUrlRequest).start();
   }
 
-  private void mockReadSuccess() {
+  private void mockReadSuccess(int position, int length) {
+    final int[] positionAndRemaining = new int[] {position, length};
     doAnswer(new Answer<Void>() {
       @Override
       public Void answer(InvocationOnMock invocation) throws Throwable {
-        ByteBuffer inputBuffer = (ByteBuffer) invocation.getArguments()[0];
-        inputBuffer.put(buildTestDataBuffer());
-        dataSourceUnderTest.onReadCompleted(
-            mockUrlRequest,
-            testUrlResponseInfo,
-            inputBuffer);
+        if (positionAndRemaining[1] == 0) {
+          dataSourceUnderTest.onSucceeded(mockUrlRequest, testUrlResponseInfo);
+        } else {
+          ByteBuffer inputBuffer = (ByteBuffer) invocation.getArguments()[0];
+          int readLength = Math.min(positionAndRemaining[1], inputBuffer.remaining());
+          inputBuffer.put(buildTestDataBuffer(positionAndRemaining[0], readLength));
+          positionAndRemaining[0] += readLength;
+          positionAndRemaining[1] -= readLength;
+          dataSourceUnderTest.onReadCompleted(
+              mockUrlRequest,
+              testUrlResponseInfo,
+              inputBuffer);
+        }
         return null;
       }
     }).when(mockUrlRequest).read(any(ByteBuffer.class));
@@ -780,17 +797,7 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
         dataSourceUnderTest.onFailed(
             mockUrlRequest,
             createUrlResponseInfo(500), // statusCode
-            null);
-        return null;
-      }
-    }).when(mockUrlRequest).read(any(ByteBuffer.class));
-  }
-
-  private void mockResponseFinished() {
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocation) throws Throwable {
-        dataSourceUnderTest.onSucceeded(mockUrlRequest, testUrlResponseInfo);
+            mockUrlRequestException);
         return null;
       }
     }).when(mockUrlRequest).read(any(ByteBuffer.class));
@@ -808,8 +815,8 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
     return startedCondition;
   }
 
-  private static byte[] buildTestDataArray(int start, int length) {
-    return Arrays.copyOfRange(buildTestDataBuffer().array(), start, start + length);
+  private static byte[] buildTestDataArray(int position, int length) {
+    return buildTestDataBuffer(position, length).array();
   }
 
   public static byte[] prefixZeros(byte[] data, int requiredLength) {
@@ -822,17 +829,13 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
     return Arrays.copyOf(data, requiredLength);
   }
 
-  private static ByteBuffer buildTestDataBuffer() {
-    ByteBuffer testBuffer = ByteBuffer.allocate(TEST_BUFFER_SIZE);
-    for (byte i = 1; i <= TEST_BUFFER_SIZE; i++) {
-      testBuffer.put(i);
+  private static ByteBuffer buildTestDataBuffer(int position, int length) {
+    ByteBuffer testBuffer = ByteBuffer.allocate(length);
+    for (int i = 0; i < length; i++) {
+      testBuffer.put((byte) (position + i));
     }
     testBuffer.flip();
     return testBuffer;
   }
 
-  private void assertConnectionState(int state) {
-    assertEquals(state, dataSourceUnderTest.connectionState);
-  }
-
 }
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer/ext/cronet/CronetDataSource.java b/extensions/cronet/src/main/java/com/google/android/exoplayer/ext/cronet/CronetDataSource.java
index 7c26e93b1e..feec8686a8 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer/ext/cronet/CronetDataSource.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer/ext/cronet/CronetDataSource.java
@@ -25,7 +25,7 @@
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.Clock;
 import com.google.android.exoplayer.util.Predicate;
-import com.google.android.exoplayer.util.TraceUtil;
+import com.google.android.exoplayer.util.SystemClock;
 import java.io.IOException;
 import java.net.SocketTimeoutException;
 import java.net.UnknownHostException;
@@ -35,12 +35,11 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.concurrent.Executor;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicLong;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import org.chromium.net.CronetEngine;
 import org.chromium.net.UrlRequest;
+import org.chromium.net.UrlRequest.Status;
 import org.chromium.net.UrlRequestException;
 import org.chromium.net.UrlResponseInfo;
 
@@ -73,72 +72,105 @@ public OpenException(String errorMessage, DataSpec dataSpec, int cronetConnectio
 
   }
 
+  /**
+   * The default connection timeout, in milliseconds.
+   */
+  public static final int DEFAULT_CONNECT_TIMEOUT_MILLIS = 8 * 1000;
+  /**
+   * The default read timeout, in milliseconds.
+   */
+  public static final int DEFAULT_READ_TIMEOUT_MILLIS = 8 * 1000;
+
   private static final String TAG = "CronetDataSource";
+  private static final String CONTENT_TYPE = "Content-Type";
   private static final Pattern CONTENT_RANGE_HEADER_PATTERN =
       Pattern.compile("^bytes (\\d+)-(\\d+)/(\\d+)$");
   // The size of read buffer passed to cronet UrlRequest.read().
   private static final int READ_BUFFER_SIZE_BYTES = 32 * 1024;
 
-  /* package */ static final int IDLE_CONNECTION = 5;
-  /* package */ static final int OPENING_CONNECTION = 2;
-  /* package */ static final int CONNECTED_CONNECTION = 3;
-  /* package */ static final int OPEN_CONNECTION = 4;
-
   private final CronetEngine cronetEngine;
   private final Executor executor;
   private final Predicate<String> contentTypePredicate;
-  private final TransferListener transferListener;
+  private final TransferListener listener;
   private final int connectTimeoutMs;
   private final int readTimeoutMs;
   private final boolean resetTimeoutOnRedirects;
   private final Map<String, String> requestProperties;
   private final ConditionVariable operation;
-  private final ByteBuffer readBuffer;
   private final Clock clock;
 
+  // Accessed by the calling thread only.
+  private boolean opened;
+  private long bytesToSkip;
+  private long bytesRemaining;
+
+  // Written from the calling thread only. currentUrlRequest.start() calls ensure writes are visible
+  // to reads made by the Cronet thread.
   private UrlRequest currentUrlRequest;
   private DataSpec currentDataSpec;
+
+  // Reference written and read by calling thread only. Passed to Cronet thread as a local variable.
+  // operation.open() calls ensure writes into the buffer are visible to reads made by the calling
+  // thread.
+  private ByteBuffer readBuffer;
+
+  // Written from the Cronet thread only. operation.open() calls ensure writes are visible to reads
+  // made by the calling thread.
   private UrlResponseInfo responseInfo;
+  private IOException exception;
+  private boolean finished;
 
-  /* package */ volatile int connectionState;
-  private volatile String currentUrl;
   private volatile long currentConnectTimeoutMs;
-  private volatile HttpDataSourceException exception;
-  private volatile long contentLength;
-  private volatile AtomicLong expectedBytesRemainingToRead;
-  private volatile boolean hasData;
-  private volatile boolean responseFinished;
 
   /**
    * @param cronetEngine A CronetEngine.
-   * @param executor The {@link java.util.concurrent.Executor} that will perform the request.
-   * @param clock A {@link com.google.android.exoplayer.util.Clock} for keeping track of timeout.
-   * @param contentTypePredicate A {@link Predicate}. If a content type is rejected by the
-   *     predicate then a
-   *     {@link com.google.android.exoplayer.upstream.HttpDataSource.InvalidContentTypeException}
-   *     is thrown from {@link #validateResponse(UrlResponseInfo)}.
-   * @param transferListener A listener.
-   * @param connectTimeoutMs The timeout to execute a connection.
-   * @param readTimeoutMs The timeout to execute a connection.
-   * @param resetTimeoutOnRedirects Allow to reset the timeout when redirects occur.
+   * @param executor The {@link java.util.concurrent.Executor} that will perform the requests.
+   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
+   *     predicate then an {@link InvalidContentTypeException} is thrown from
+   *     {@link #open(DataSpec)}.
+   * @param listener An optional listener.
    */
-  public CronetDataSource(CronetEngine cronetEngine, Executor executor, Clock clock,
-      Predicate<String> contentTypePredicate, TransferListener transferListener,
-      int connectTimeoutMs, int readTimeoutMs, boolean resetTimeoutOnRedirects) {
+  public CronetDataSource(CronetEngine cronetEngine, Executor executor,
+      Predicate<String> contentTypePredicate, TransferListener listener) {
+    this(cronetEngine, executor, contentTypePredicate, listener, DEFAULT_CONNECT_TIMEOUT_MILLIS,
+        DEFAULT_READ_TIMEOUT_MILLIS, false);
+  }
+
+  /**
+   * @param cronetEngine A CronetEngine.
+   * @param executor The {@link java.util.concurrent.Executor} that will perform the requests.
+   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
+   *     predicate then an {@link InvalidContentTypeException} is thrown from
+   *     {@link #open(DataSpec)}.
+   * @param listener An optional listener.
+   * @param connectTimeoutMs The connection timeout, in milliseconds.
+   * @param readTimeoutMs The read timeout, in milliseconds.
+   * @param resetTimeoutOnRedirects Whether the connect timeout is reset when a redirect occurs.
+   */
+  public CronetDataSource(CronetEngine cronetEngine, Executor executor,
+      Predicate<String> contentTypePredicate, TransferListener listener, int connectTimeoutMs,
+      int readTimeoutMs, boolean resetTimeoutOnRedirects) {
+    this(cronetEngine, executor, contentTypePredicate, listener, connectTimeoutMs,
+        readTimeoutMs, resetTimeoutOnRedirects, new SystemClock());
+  }
+
+  /* package */ CronetDataSource(CronetEngine cronetEngine, Executor executor,
+      Predicate<String> contentTypePredicate, TransferListener listener, int connectTimeoutMs,
+      int readTimeoutMs, boolean resetTimeoutOnRedirects, Clock clock) {
     this.cronetEngine = Assertions.checkNotNull(cronetEngine);
     this.executor = Assertions.checkNotNull(executor);
-    this.clock = Assertions.checkNotNull(clock);
     this.contentTypePredicate = contentTypePredicate;
-    this.transferListener = transferListener;
+    this.listener = listener;
     this.connectTimeoutMs = connectTimeoutMs;
     this.readTimeoutMs = readTimeoutMs;
     this.resetTimeoutOnRedirects = resetTimeoutOnRedirects;
-    readBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE_BYTES);
+    this.clock = Assertions.checkNotNull(clock);
     requestProperties = new HashMap<>();
     operation = new ConditionVariable();
-    connectionState = IDLE_CONNECTION;
   }
 
+  // HttpDataSource implementation.
+
   @Override
   public void setRequestProperty(String name, String value) {
     synchronized (requestProperties) {
@@ -166,256 +198,152 @@ public void clearAllRequestProperties() {
   }
 
   @Override
-  public long open(DataSpec dataSpec) throws HttpDataSourceException {
-    TraceUtil.beginSection("CronetDataSource.open");
-    try {
-      Assertions.checkNotNull(dataSpec);
-      synchronized (this) {
-        Assertions.checkState(connectionState == IDLE_CONNECTION, "Connection already open");
-        connectionState = OPENING_CONNECTION;
-      }
-
-      operation.close();
-      resetConnectTimeout();
-      startRequest(dataSpec);
-      boolean requestStarted = blockUntilConnectTimeout();
-
-      if (exception != null) {
-        // An error occurred opening the connection.
-        throw exception;
-      } else if (!requestStarted) {
-        // The timeout was reached before the connection was opened.
-        throw new OpenException(new SocketTimeoutException(), dataSpec, getCurrentRequestStatus());
-      }
-
-      // Connection was opened.
-      if (transferListener != null) {
-        transferListener.onTransferStart();
-      }
-      connectionState = OPEN_CONNECTION;
-      return contentLength;
-    } finally {
-      TraceUtil.endSection();
-    }
-  }
-
-  private void startRequest(DataSpec dataSpec) throws HttpDataSourceException {
-    currentUrl = dataSpec.uri.toString();
-    currentDataSpec = dataSpec;
-    UrlRequest.Builder urlRequestBuilder = new UrlRequest.Builder(currentUrl, this, executor,
-        cronetEngine);
-    fillCurrentRequestHeader(urlRequestBuilder);
-    fillCurrentRequestPostBody(urlRequestBuilder, dataSpec);
-    currentUrlRequest = urlRequestBuilder.build();
-    currentUrlRequest.start();
-  }
-
-  private void fillCurrentRequestHeader(UrlRequest.Builder urlRequestBuilder) {
-    synchronized (requestProperties) {
-      for (Entry<String, String> headerEntry : requestProperties.entrySet()) {
-        urlRequestBuilder.addHeader(headerEntry.getKey(), headerEntry.getValue());
-      }
-    }
-    if (currentDataSpec.position == 0 && currentDataSpec.length == C.LENGTH_UNBOUNDED) {
-      // Not required.
-      return;
-    }
-    StringBuilder rangeValue = new StringBuilder();
-    rangeValue.append("bytes=");
-    rangeValue.append(currentDataSpec.position);
-    rangeValue.append("-");
-    if (currentDataSpec.length != C.LENGTH_UNBOUNDED) {
-      rangeValue.append(currentDataSpec.position + currentDataSpec.length - 1);
-    }
-    urlRequestBuilder.addHeader("Range", rangeValue.toString());
-  }
-
-  private void fillCurrentRequestPostBody(UrlRequest.Builder urlRequestBuilder, DataSpec dataSpec)
-      throws HttpDataSourceException {
-    if (dataSpec.postBody != null) {
-      if (!requestProperties.containsKey("Content-Type")) {
-        throw new OpenException("POST requests must set a Content-Type header", dataSpec,
-            getCurrentRequestStatus());
-      }
-      urlRequestBuilder.setUploadDataProvider(
-          new ByteArrayUploadDataProvider(dataSpec.postBody), executor);
-    }
-  }
-
-  @Override
-  public synchronized void onFailed(UrlRequest request, UrlResponseInfo info,
-      UrlRequestException error) {
-    if (request != currentUrlRequest) {
-      return;
-    }
-    if (connectionState == OPENING_CONNECTION) {
-      IOException cause = error.getErrorCode() == UrlRequestException.ERROR_HOSTNAME_NOT_RESOLVED
-          ? new UnknownHostException() : error;
-      exception = new OpenException(cause, currentDataSpec, getCurrentRequestStatus());
-    } else if (connectionState == OPEN_CONNECTION) {
-      readBuffer.limit(0);
-      exception = new HttpDataSourceException(error, currentDataSpec,
-          HttpDataSourceException.TYPE_READ);
-    }
-    operation.open();
+  public String getUri() {
+    return responseInfo == null ? null : responseInfo.getUrl();
   }
 
   @Override
-  public synchronized void onResponseStarted(UrlRequest request, UrlResponseInfo info) {
-    if (request != currentUrlRequest) {
-      return;
-    }
-    TraceUtil.beginSection("CronetDataSource.onResponseStarted");
-    try {
-      validateResponse(info);
-      responseInfo = info;
-      // Check content length.
-      contentLength = getContentLength(info.getAllHeaders());
-      // If a specific length is requested and a specific length is returned but the 2 don't match
-      // it's an error.
-      if (currentDataSpec.length != C.LENGTH_UNBOUNDED
-          && contentLength != C.LENGTH_UNBOUNDED
-          && currentDataSpec.length != contentLength) {
-        throw new OpenException("Content length did not match requested length", currentDataSpec,
-            getCurrentRequestStatus());
-      }
+  public long open(DataSpec dataSpec) throws HttpDataSourceException {
+    Assertions.checkNotNull(dataSpec);
+    Assertions.checkState(!opened);
 
-      if (contentLength > 0) {
-        expectedBytesRemainingToRead = new AtomicLong(contentLength);
-      }
+    operation.close();
+    resetConnectTimeout();
+    currentDataSpec = dataSpec;
+    currentUrlRequest = buildRequest(dataSpec);
+    currentUrlRequest.start();
+    boolean requestStarted = blockUntilConnectTimeout();
 
-      // Keep track of redirects.
-      currentUrl = responseInfo.getUrl();
-      connectionState = CONNECTED_CONNECTION;
-    } catch (HttpDataSourceException e) {
-      exception = e;
-    } finally {
-      operation.open();
-      TraceUtil.endSection();
+    if (exception != null) {
+      throw new OpenException(exception, currentDataSpec, getStatus(currentUrlRequest));
+    } else if (!requestStarted) {
+      // The timeout was reached before the connection was opened.
+      throw new OpenException(new SocketTimeoutException(), dataSpec, getStatus(currentUrlRequest));
     }
-  }
 
-  private void validateResponse(UrlResponseInfo info) throws HttpDataSourceException {
     // Check for a valid response code.
-    int responseCode = info.getHttpStatusCode();
+    int responseCode = responseInfo.getHttpStatusCode();
     if (responseCode < 200 || responseCode > 299) {
-      throw new HttpDataSource.InvalidResponseCodeException(
-          responseCode,
-          info.getAllHeaders(),
+      throw new InvalidResponseCodeException(responseCode, responseInfo.getAllHeaders(),
           currentDataSpec);
     }
+
     // Check for a valid content type.
-    try {
-      String contentType = info.getAllHeaders().get("Content-Type").get(0);
-      if (contentTypePredicate != null && !contentTypePredicate.evaluate(contentType)) {
-        throw new HttpDataSource.InvalidContentTypeException(contentType, currentDataSpec);
+    if (contentTypePredicate != null) {
+      List<String> contentTypeHeaders = responseInfo.getAllHeaders().get(CONTENT_TYPE);
+      String contentType = isEmpty(contentTypeHeaders) ? null : contentTypeHeaders.get(0);
+      if (!contentTypePredicate.evaluate(contentType)) {
+        throw new InvalidContentTypeException(contentType, currentDataSpec);
       }
-    } catch (IndexOutOfBoundsException e) {
-      throw new HttpDataSource.InvalidContentTypeException(null, currentDataSpec);
     }
-  }
 
-  private long getContentLength(Map<String, List<String>> headers) {
-    // Logic copied from {@code DefaultHttpDataSource}
-    long contentLength = C.LENGTH_UNBOUNDED;
-    List<String> contentLengthHeader = headers.get("Content-Length");
-    if (contentLengthHeader != null
-        && !contentLengthHeader.isEmpty()
-        && !TextUtils.isEmpty(contentLengthHeader.get(0))) {
-      try {
-        contentLength = Long.parseLong(contentLengthHeader.get(0));
-      } catch (NumberFormatException e) {
-        log(Log.ERROR, "Unexpected Content-Length [" + contentLengthHeader + "]");
+    // If we requested a range starting from a non-zero position and received a 200 rather than a
+    // 206, then the server does not support partial requests. We'll need to manually skip to the
+    // requested position.
+    bytesToSkip = responseCode == 200 && dataSpec.position != 0 ? dataSpec.position : 0;
+
+    // Calculate the content length.
+    if (!getIsCompressed(responseInfo)) {
+      if (dataSpec.length != C.LENGTH_UNBOUNDED) {
+        bytesRemaining = dataSpec.length;
+      } else {
+        bytesRemaining = getContentLength(responseInfo);
       }
+    } else {
+      // If the response is compressed then the content length will be that of the compressed data
+      // which isn't what we want. Always use the dataSpec length in this case.
+      bytesRemaining = currentDataSpec.length;
     }
-    List<String> contentRangeHeader = headers.get("Content-Range");
-    if (contentRangeHeader != null
-        && !contentRangeHeader.isEmpty()
-        && !TextUtils.isEmpty(contentRangeHeader.get(0))) {
-      Matcher matcher = CONTENT_RANGE_HEADER_PATTERN.matcher(contentRangeHeader.get(0));
-      if (matcher.find()) {
-        try {
-          long contentLengthFromRange =
-              Long.parseLong(matcher.group(2)) - Long.parseLong(matcher.group(1)) + 1;
-          if (contentLength < 0) {
-            // Some proxy servers strip the Content-Length header. Fall back to the length
-            // calculated here in this case.
-            contentLength = contentLengthFromRange;
-          } else if (contentLength != contentLengthFromRange) {
-            // If there is a discrepancy between the Content-Length and Content-Range headers,
-            // assume the one with the larger value is correct. We have seen cases where carrier
-            // change one of them to reduce the size of a request, but it is unlikely anybody
-            // would increase it.
-            log(Log.WARN, "Inconsistent headers [" + contentLengthHeader + "] ["
-                + contentRangeHeader + "]");
-            contentLength = Math.max(contentLength, contentLengthFromRange);
-          }
-        } catch (NumberFormatException e) {
-          log(Log.ERROR, "Unexpected Content-Range [" + contentRangeHeader + "]");
-        }
-      }
+
+    opened = true;
+    if (listener != null) {
+      listener.onTransferStart();
     }
-    return contentLength;
+
+    return bytesRemaining;
   }
 
   @Override
   public int read(byte[] buffer, int offset, int readLength) throws HttpDataSourceException {
-    TraceUtil.beginSection("CronetDataSource.read");
-    try {
-      synchronized (this) {
-        if (connectionState != OPEN_CONNECTION) {
-          throw new IllegalStateException("Connection not ready");
-        }
-      }
+    Assertions.checkState(opened);
 
-      // If being asked to read beyond the amount of bytes initially requested, return
-      // RESULT_END_OF_INPUT.
-      if (expectedBytesRemainingToRead != null && expectedBytesRemainingToRead.get() <= 0) {
-        return C.RESULT_END_OF_INPUT;
-      }
+    if (readLength == 0) {
+      return 0;
+    } else if (bytesRemaining == 0) {
+      return C.RESULT_END_OF_INPUT;
+    }
 
-      if (!hasData) {
-        // Read more data from cronet.
-        operation.close();
-        currentUrlRequest.read(readBuffer);
-        if (!operation.block(readTimeoutMs)) {
-          throw new HttpDataSourceException(
-              new SocketTimeoutException(), currentDataSpec, HttpDataSourceException.TYPE_READ);
-        }
-        if (exception != null) {
-          throw exception;
-        }
-        // The expected response length is unknown, but cronet has indicated that the request
-        // already finished successfully.
-        if (responseFinished) {
-          return C.RESULT_END_OF_INPUT;
+    if (readBuffer == null) {
+      readBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE_BYTES);
+      readBuffer.limit(0);
+    }
+    while (!readBuffer.hasRemaining()) {
+      // Fill readBuffer with more data from Cronet.
+      operation.close();
+      readBuffer.clear();
+      currentUrlRequest.read(readBuffer);
+      if (!operation.block(readTimeoutMs)) {
+        // We're timing out, but since the operation is still ongoing we'll need to replace
+        // readBuffer to avoid the possibility of it being written to by this operation during a
+        // subsequent request.
+        readBuffer = null;
+        throw new HttpDataSourceException(
+            new SocketTimeoutException(), currentDataSpec, HttpDataSourceException.TYPE_READ);
+      } else if (exception != null) {
+        throw new HttpDataSourceException(exception, currentDataSpec,
+            HttpDataSourceException.TYPE_READ);
+      } else if (finished) {
+        return C.RESULT_END_OF_INPUT;
+      } else {
+        // The operation didn't time out, fail or finish, and therefore data must have been read.
+        readBuffer.flip();
+        Assertions.checkState(readBuffer.hasRemaining());
+        if (bytesToSkip > 0) {
+          int bytesSkipped = (int) Math.min(readBuffer.remaining(), bytesToSkip);
+          readBuffer.position(readBuffer.position() + bytesSkipped);
+          bytesToSkip -= bytesSkipped;
         }
       }
+    }
 
-      int bytesRead = Math.min(readBuffer.remaining(), readLength);
-
-      readBuffer.get(buffer, offset, bytesRead);
-
-      if (!readBuffer.hasRemaining()) {
-        readBuffer.clear();
-        hasData = false;
-      }
+    int bytesRead = Math.min(readBuffer.remaining(), readLength);
+    readBuffer.get(buffer, offset, bytesRead);
 
-      if (expectedBytesRemainingToRead != null) {
-        expectedBytesRemainingToRead.addAndGet(-bytesRead);
-      }
+    if (bytesRemaining != C.LENGTH_UNBOUNDED) {
+      bytesRemaining -= bytesRead;
+    }
+    if (listener != null) {
+      listener.onBytesTransferred(bytesRead);
+    }
+    return bytesRead;
+  }
 
-      if (transferListener != null && bytesRead >= 0) {
-        transferListener.onBytesTransferred(bytesRead);
+  @Override
+  public synchronized void close() {
+    if (currentUrlRequest != null) {
+      currentUrlRequest.cancel();
+      currentUrlRequest = null;
+    }
+    if (readBuffer != null) {
+      readBuffer.limit(0);
+    }
+    currentDataSpec = null;
+    responseInfo = null;
+    exception = null;
+    finished = false;
+    if (opened) {
+      opened = false;
+      if (listener != null) {
+        listener.onTransferEnd();
       }
-      return bytesRead;
-    } finally {
-      TraceUtil.endSection();
     }
   }
 
+  // UrlRequest.Callback implementation
+
   @Override
-  public void onRedirectReceived(UrlRequest request, UrlResponseInfo info, String newLocationUrl) {
+  public synchronized void onRedirectReceived(UrlRequest request, UrlResponseInfo info,
+      String newLocationUrl) {
     if (request != currentUrlRequest) {
       return;
     }
@@ -425,8 +353,8 @@ public void onRedirectReceived(UrlRequest request, UrlResponseInfo info, String
       // For other redirect response codes the POST request is converted to a GET request and the
       // redirect is followed.
       if (responseCode == 307 || responseCode == 308) {
-        exception = new OpenException("POST request redirected with 307 or 308 response code",
-            currentDataSpec, getCurrentRequestStatus());
+        exception = new InvalidResponseCodeException(responseCode, info.getAllHeaders(),
+            currentDataSpec);
         operation.open();
         return;
       }
@@ -438,78 +366,79 @@ public void onRedirectReceived(UrlRequest request, UrlResponseInfo info, String
   }
 
   @Override
-  public synchronized void onReadCompleted(UrlRequest request, UrlResponseInfo info,
-      ByteBuffer buffer) {
+  public synchronized void onResponseStarted(UrlRequest request, UrlResponseInfo info) {
     if (request != currentUrlRequest) {
       return;
     }
-    readBuffer.flip();
-    if (readBuffer.limit() > 0) {
-      hasData = true;
-    }
+    responseInfo = info;
     operation.open();
   }
 
   @Override
-  public void onSucceeded(UrlRequest request, UrlResponseInfo info) {
+  public synchronized void onReadCompleted(UrlRequest request, UrlResponseInfo info,
+      ByteBuffer buffer) {
     if (request != currentUrlRequest) {
       return;
     }
-    responseFinished = true;
     operation.open();
   }
 
   @Override
-  public synchronized void close() {
-    TraceUtil.beginSection("CronetDataSource.close");
-    try {
-      if (currentUrlRequest != null) {
-        currentUrlRequest.cancel();
-        currentUrlRequest = null;
-      }
-      readBuffer.clear();
-      currentDataSpec = null;
-      currentUrl = null;
-      exception = null;
-      contentLength = 0;
-      hasData = false;
-      responseInfo = null;
-      expectedBytesRemainingToRead = null;
-      responseFinished = false;
-      if (transferListener != null && connectionState == OPEN_CONNECTION) {
-        transferListener.onTransferEnd();
-      }
-    } finally {
-      connectionState = IDLE_CONNECTION;
-      TraceUtil.endSection();
+  public synchronized void onSucceeded(UrlRequest request, UrlResponseInfo info) {
+    if (request != currentUrlRequest) {
+      return;
     }
+    finished = true;
+    operation.open();
   }
 
   @Override
-  public String getUri() {
-    return currentUrl;
-  }
-
-  private void log(int priority, String message) {
-    if (Log.isLoggable(TAG, priority)) {
-      Log.println(priority, TAG, message);
+  public synchronized void onFailed(UrlRequest request, UrlResponseInfo info,
+      UrlRequestException error) {
+    if (request != currentUrlRequest) {
+      return;
     }
+    exception = error.getErrorCode() == UrlRequestException.ERROR_HOSTNAME_NOT_RESOLVED
+        ? new UnknownHostException() : error;
+    operation.open();
   }
 
-  private int getCurrentRequestStatus() {
-    if (currentUrlRequest == null) {
-      return UrlRequest.Status.IDLE;
+  // Internal methods.
+
+  private UrlRequest buildRequest(DataSpec dataSpec) throws OpenException {
+    UrlRequest.Builder requestBuilder = new UrlRequest.Builder(dataSpec.uri.toString(), this,
+        executor, cronetEngine);
+    // Set the headers.
+    synchronized (requestProperties) {
+      if (dataSpec.postBody != null && dataSpec.postBody.length != 0
+          && !requestProperties.containsKey(CONTENT_TYPE)) {
+        throw new OpenException("POST request with non-empty body must set Content-Type", dataSpec,
+            Status.IDLE);
+      }
+      for (Entry<String, String> headerEntry : requestProperties.entrySet()) {
+        requestBuilder.addHeader(headerEntry.getKey(), headerEntry.getValue());
+      }
     }
-    final ConditionVariable conditionVariable = new ConditionVariable();
-    final AtomicInteger result = new AtomicInteger();
-    currentUrlRequest.getStatus(new UrlRequest.StatusListener() {
-      @Override
-      public void onStatus(int status) {
-        result.set(status);
-        conditionVariable.open();
+    // Set the Range header.
+    if (currentDataSpec.position != 0 || currentDataSpec.length != C.LENGTH_UNBOUNDED) {
+      StringBuilder rangeValue = new StringBuilder();
+      rangeValue.append("bytes=");
+      rangeValue.append(currentDataSpec.position);
+      rangeValue.append("-");
+      if (currentDataSpec.length != C.LENGTH_UNBOUNDED) {
+        rangeValue.append(currentDataSpec.position + currentDataSpec.length - 1);
       }
-    });
-    return result.get();
+      requestBuilder.addHeader("Range", rangeValue.toString());
+    }
+    // Set the method and (if non-empty) the body.
+    if (dataSpec.postBody != null) {
+      requestBuilder.setHttpMethod("POST");
+      if (dataSpec.postBody.length != 0) {
+        requestBuilder.setUploadDataProvider(new ByteArrayUploadDataProvider(dataSpec.postBody),
+            executor);
+      }
+    }
+    return requestBuilder.build();
   }
 
   private boolean blockUntilConnectTimeout() {
@@ -526,4 +455,75 @@ private void resetConnectTimeout() {
     currentConnectTimeoutMs = clock.elapsedRealtime() + connectTimeoutMs;
   }
 
+  private static boolean getIsCompressed(UrlResponseInfo info) {
+    for (Map.Entry<String, String> entry : info.getAllHeadersAsList()) {
+      if (entry.getKey().equalsIgnoreCase("Content-Encoding")) {
+        return !entry.getValue().equalsIgnoreCase("identity");
+      }
+    }
+    return false;
+  }
+
+  private static long getContentLength(UrlResponseInfo info) {
+    long contentLength = C.LENGTH_UNBOUNDED;
+    Map<String, List<String>> headers = info.getAllHeaders();
+    List<String> contentLengthHeaders = headers.get("Content-Length");
+    String contentLengthHeader = null;
+    if (!isEmpty(contentLengthHeaders)) {
+      contentLengthHeader = contentLengthHeaders.get(0);
+      if (!TextUtils.isEmpty(contentLengthHeader)) {
+        try {
+          contentLength = Long.parseLong(contentLengthHeader);
+        } catch (NumberFormatException e) {
+          Log.e(TAG, "Unexpected Content-Length [" + contentLengthHeader + "]");
+        }
+      }
+    }
+    List<String> contentRangeHeaders = headers.get("Content-Range");
+    if (!isEmpty(contentRangeHeaders)) {
+      String contentRangeHeader = contentRangeHeaders.get(0);
+      Matcher matcher = CONTENT_RANGE_HEADER_PATTERN.matcher(contentRangeHeader);
+      if (matcher.find()) {
+        try {
+          long contentLengthFromRange =
+              Long.parseLong(matcher.group(2)) - Long.parseLong(matcher.group(1)) + 1;
+          if (contentLength < 0) {
+            // Some proxy servers strip the Content-Length header. Fall back to the length
+            // calculated here in this case.
+            contentLength = contentLengthFromRange;
+          } else if (contentLength != contentLengthFromRange) {
+            // If there is a discrepancy between the Content-Length and Content-Range headers,
+            // assume the one with the larger value is correct. We have seen cases where carrier
+            // change one of them to reduce the size of a request, but it is unlikely anybody
+            // would increase it.
+            Log.w(TAG, "Inconsistent headers [" + contentLengthHeader + "] [" + contentRangeHeader
+                + "]");
+            contentLength = Math.max(contentLength, contentLengthFromRange);
+          }
+        } catch (NumberFormatException e) {
+          Log.e(TAG, "Unexpected Content-Range [" + contentRangeHeader + "]");
+        }
+      }
+    }
+    return contentLength;
+  }
+
+  private static int getStatus(UrlRequest request) {
+    final ConditionVariable conditionVariable = new ConditionVariable();
+    final int[] statusHolder = new int[1];
+    request.getStatus(new UrlRequest.StatusListener() {
+      @Override
+      public void onStatus(int status) {
+        statusHolder[0] = status;
+        conditionVariable.open();
+      }
+    });
+    conditionVariable.block();
+    return statusHolder[0];
+  }
+
+  private static boolean isEmpty(List<?> list) {
+    return list == null || list.isEmpty();
+  }
+
 }
diff --git a/library/build.gradle b/library/build.gradle
index 560b699d10..8237533173 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -83,7 +83,7 @@ publish {
     userOrg = 'google'
     groupId = 'com.google.android.exoplayer'
     artifactId = 'exoplayer'
-    version = 'r1.5.11'
+    version = 'r1.5.12'
     description = 'The ExoPlayer library.'
     website = 'https://github.com/google/ExoPlayer'
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/DefaultExtractorInputTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/DefaultExtractorInputTest.java
index 938251ed5c..6976e898a7 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/extractor/DefaultExtractorInputTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/DefaultExtractorInputTest.java
@@ -33,14 +33,14 @@
   private static final byte[] TEST_DATA = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8};
   private static final int LARGE_TEST_DATA_LENGTH = 8192;
 
-  public void testInitialPosition() throws IOException {
+  public void testInitialPosition() throws Exception {
     FakeDataSource testDataSource = buildDataSource();
     DefaultExtractorInput input =
         new DefaultExtractorInput(testDataSource, 123, C.LENGTH_UNBOUNDED);
     assertEquals(123, input.getPosition());
   }
 
-  public void testRead() throws IOException, InterruptedException {
+  public void testRead() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
     // We expect to perform three reads of three bytes, as setup in buildTestDataSource.
@@ -58,7 +58,7 @@ public void testRead() throws IOException, InterruptedException {
     assertEquals(-1, expectedEndOfInput);
   }
 
-  public void testReadPeeked() throws IOException, InterruptedException {
+  public void testReadPeeked() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
 
@@ -71,7 +71,7 @@ public void testReadPeeked() throws IOException, InterruptedException {
     assertTrue(Arrays.equals(TEST_DATA, target));
   }
 
-  public void testReadMoreDataPeeked() throws IOException, InterruptedException {
+  public void testReadMoreDataPeeked() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
 
@@ -84,7 +84,7 @@ public void testReadMoreDataPeeked() throws IOException, InterruptedException {
     assertTrue(Arrays.equals(TEST_DATA, target));
   }
 
-  public void testReadFullyOnce() throws IOException, InterruptedException {
+  public void testReadFullyOnce() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
     input.readFully(target, 0, TEST_DATA.length);
@@ -103,7 +103,7 @@ public void testReadFullyOnce() throws IOException, InterruptedException {
     }
   }
 
-  public void testReadFullyTwice() throws IOException, InterruptedException {
+  public void testReadFullyTwice() throws Exception {
     // Read TEST_DATA in two parts.
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[5];
@@ -116,7 +116,7 @@ public void testReadFullyTwice() throws IOException, InterruptedException {
     assertEquals(5 + 4, input.getPosition());
   }
 
-  public void testReadFullyTooMuch() throws IOException, InterruptedException {
+  public void testReadFullyTooMuch() throws Exception {
     // Read more than TEST_DATA. Should fail with an EOFException. Position should not update.
     DefaultExtractorInput input = createDefaultExtractorInput();
     try {
@@ -141,7 +141,7 @@ public void testReadFullyTooMuch() throws IOException, InterruptedException {
     assertEquals(0, input.getPosition());
   }
 
-  public void testReadFullyWithFailingDataSource() throws IOException, InterruptedException {
+  public void testReadFullyWithFailingDataSource() throws Exception {
     FakeDataSource testDataSource = buildFailingDataSource();
     DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
     try {
@@ -155,7 +155,7 @@ public void testReadFullyWithFailingDataSource() throws IOException, Interrupted
     assertEquals(0, input.getPosition());
   }
 
-  public void testReadFullyHalfPeeked() throws IOException, InterruptedException {
+  public void testReadFullyHalfPeeked() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
 
@@ -168,7 +168,7 @@ public void testReadFullyHalfPeeked() throws IOException, InterruptedException {
     assertEquals(TEST_DATA.length, input.getPosition());
   }
 
-  public void testSkip() throws IOException, InterruptedException {
+  public void testSkip() throws Exception {
     FakeDataSource testDataSource = buildDataSource();
     DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
     // We expect to perform three skips of three bytes, as setup in buildTestDataSource.
@@ -180,7 +180,7 @@ public void testSkip() throws IOException, InterruptedException {
     assertEquals(-1, expectedEndOfInput);
   }
 
-  public void testLargeSkip() throws IOException, InterruptedException {
+  public void testLargeSkip() throws Exception {
     FakeDataSource testDataSource = buildLargeDataSource();
     DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
     // Check that skipping the entire data source succeeds.
@@ -190,7 +190,7 @@ public void testLargeSkip() throws IOException, InterruptedException {
     }
   }
 
-  public void testSkipFullyOnce() throws IOException, InterruptedException {
+  public void testSkipFullyOnce() throws Exception {
     // Skip TEST_DATA.
     DefaultExtractorInput input = createDefaultExtractorInput();
     input.skipFully(TEST_DATA.length);
@@ -207,7 +207,7 @@ public void testSkipFullyOnce() throws IOException, InterruptedException {
     }
   }
 
-  public void testSkipFullyTwice() throws IOException, InterruptedException {
+  public void testSkipFullyTwice() throws Exception {
     // Skip TEST_DATA in two parts.
     DefaultExtractorInput input = createDefaultExtractorInput();
     input.skipFully(5);
@@ -216,7 +216,7 @@ public void testSkipFullyTwice() throws IOException, InterruptedException {
     assertEquals(5 + 4, input.getPosition());
   }
 
-  public void testSkipFullyTwicePeeked() throws IOException, InterruptedException {
+  public void testSkipFullyTwicePeeked() throws Exception {
     // Skip TEST_DATA.
     DefaultExtractorInput input = createDefaultExtractorInput();
 
@@ -230,7 +230,7 @@ public void testSkipFullyTwicePeeked() throws IOException, InterruptedException
     assertEquals(TEST_DATA.length, input.getPosition());
   }
 
-  public void testSkipFullyTooMuch() throws IOException, InterruptedException {
+  public void testSkipFullyTooMuch() throws Exception {
     // Skip more than TEST_DATA. Should fail with an EOFException. Position should not update.
     DefaultExtractorInput input = createDefaultExtractorInput();
     try {
@@ -253,7 +253,7 @@ public void testSkipFullyTooMuch() throws IOException, InterruptedException {
     assertEquals(0, input.getPosition());
   }
 
-  public void testSkipFullyWithFailingDataSource() throws IOException, InterruptedException {
+  public void testSkipFullyWithFailingDataSource() throws Exception {
     FakeDataSource testDataSource = buildFailingDataSource();
     DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
     try {
@@ -266,7 +266,7 @@ public void testSkipFullyWithFailingDataSource() throws IOException, Interrupted
     assertEquals(0, input.getPosition());
   }
 
-  public void testSkipFullyLarge() throws IOException, InterruptedException {
+  public void testSkipFullyLarge() throws Exception {
     // Tests skipping an amount of data that's larger than any internal scratch space.
     int largeSkipSize = 1024 * 1024;
     FakeDataSource.Builder builder = new FakeDataSource.Builder();
@@ -286,7 +286,7 @@ public void testSkipFullyLarge() throws IOException, InterruptedException {
     }
   }
 
-  public void testPeekFully() throws IOException, InterruptedException {
+  public void testPeekFully() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
     input.peekFully(target, 0, TEST_DATA.length);
@@ -312,7 +312,7 @@ public void testPeekFully() throws IOException, InterruptedException {
     }
   }
 
-  public void testResetPeekPosition() throws IOException, InterruptedException {
+  public void testResetPeekPosition() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
     input.peekFully(target, 0, TEST_DATA.length);
@@ -336,8 +336,7 @@ public void testResetPeekPosition() throws IOException, InterruptedException {
     }
   }
 
-  public void testPeekFullyAtEndOfStreamWithAllowEndOfInputSucceeds()
-      throws IOException, InterruptedException {
+  public void testPeekFullyAtEndOfStreamWithAllowEndOfInputSucceeds() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
 
@@ -348,8 +347,24 @@ public void testPeekFullyAtEndOfStreamWithAllowEndOfInputSucceeds()
     assertFalse(input.peekFully(target, 0, 1, true));
   }
 
-  public void testPeekFullyAcrossEndOfInputWithAllowEndOfInputFails()
-      throws IOException, InterruptedException {
+  public void testPeekFullyAtEndThenReadEndOfInput() throws Exception {
+    DefaultExtractorInput input = createDefaultExtractorInput();
+    byte[] target = new byte[TEST_DATA.length];
+
+    // Peek up to the end of the input.
+    assertTrue(input.peekFully(target, 0, TEST_DATA.length, false));
+
+    // Peek the end of the input.
+    assertFalse(input.peekFully(target, 0, 1, true));
+
+    // Read up to the end of the input.
+    assertTrue(input.readFully(target, 0, TEST_DATA.length, false));
+
+    // Read the end of the input.
+    assertFalse(input.readFully(target, 0, 1, true));
+  }
+
+  public void testPeekFullyAcrossEndOfInputWithAllowEndOfInputFails() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
 
@@ -365,8 +380,7 @@ public void testPeekFullyAcrossEndOfInputWithAllowEndOfInputFails()
     }
   }
 
-  public void testResetAndPeekFullyPastEndOfStreamWithAllowEndOfInputFails()
-      throws IOException, InterruptedException {
+  public void testResetAndPeekFullyPastEndOfStreamWithAllowEndOfInputFails() throws Exception {
     DefaultExtractorInput input = createDefaultExtractorInput();
     byte[] target = new byte[TEST_DATA.length];
 
@@ -382,7 +396,7 @@ public void testResetAndPeekFullyPastEndOfStreamWithAllowEndOfInputFails()
     }
   }
 
-  private static FakeDataSource buildDataSource() throws IOException {
+  private static FakeDataSource buildDataSource() throws Exception {
     FakeDataSource.Builder builder = new FakeDataSource.Builder();
     builder.appendReadData(Arrays.copyOfRange(TEST_DATA, 0, 3));
     builder.appendReadData(Arrays.copyOfRange(TEST_DATA, 3, 6));
@@ -392,7 +406,7 @@ private static FakeDataSource buildDataSource() throws IOException {
     return testDataSource;
   }
 
-  private static FakeDataSource buildFailingDataSource() throws IOException {
+  private static FakeDataSource buildFailingDataSource() throws Exception {
     FakeDataSource.Builder builder = new FakeDataSource.Builder();
     builder.appendReadData(Arrays.copyOfRange(TEST_DATA, 0, 6));
     builder.appendReadError(new IOException());
@@ -402,7 +416,7 @@ private static FakeDataSource buildFailingDataSource() throws IOException {
     return testDataSource;
   }
 
-  private static FakeDataSource buildLargeDataSource() throws IOException {
+  private static FakeDataSource buildLargeDataSource() throws Exception {
     FakeDataSource.Builder builder = new FakeDataSource.Builder();
     builder.appendReadData(new byte[LARGE_TEST_DATA_LENGTH]);
     FakeDataSource testDataSource = builder.build();
@@ -410,8 +424,9 @@ private static FakeDataSource buildLargeDataSource() throws IOException {
     return testDataSource;
   }
 
-  private static DefaultExtractorInput createDefaultExtractorInput() throws IOException {
+  private static DefaultExtractorInput createDefaultExtractorInput() throws Exception {
     FakeDataSource testDataSource = buildDataSource();
     return new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
   }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
index 48fd78d8eb..874900942d 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
@@ -23,7 +23,7 @@
   /**
    * The version of the library, expressed as a string.
    */
-  public static final String VERSION = "1.5.11";
+  public static final String VERSION = "1.5.12";
 
   /**
    * The version of the library, expressed as an integer.
@@ -32,7 +32,7 @@
    * corresponding integer version 1002003 (001-002-003), and "123.45.6" has the corresponding
    * integer version 123045006 (123-045-006).
    */
-  public static final int VERSION_INT = 1005011;
+  public static final int VERSION_INT = 1005012;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer.util.Assertions}
diff --git a/library/src/main/java/com/google/android/exoplayer/SampleSourceTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/SampleSourceTrackRenderer.java
index 2759edac39..5a83413947 100644
--- a/library/src/main/java/com/google/android/exoplayer/SampleSourceTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/SampleSourceTrackRenderer.java
@@ -113,7 +113,7 @@ protected void onEnabled(int track, long positionUs, boolean joining)
   }
 
   @Override
-  protected final void seekTo(long positionUs) throws ExoPlaybackException {
+  protected void seekTo(long positionUs) throws ExoPlaybackException {
     positionUs = shiftInputPosition(positionUs);
     enabledSource.seekToUs(positionUs);
     checkForDiscontinuity(positionUs);
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkExtractorWrapper.java b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkExtractorWrapper.java
index 8b48461fca..79436342ca 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkExtractorWrapper.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkExtractorWrapper.java
@@ -56,6 +56,7 @@
 
   // Accessed only on the loader thread.
   private boolean seenTrack;
+  private int seenTrackId;
 
   /**
    * @param extractor The extractor to wrap.
@@ -98,8 +99,9 @@ public int read(ExtractorInput input) throws IOException, InterruptedException {
 
   @Override
   public TrackOutput track(int id) {
-    Assertions.checkState(!seenTrack);
+    Assertions.checkState(!seenTrack || id == seenTrackId);
     seenTrack = true;
+    seenTrackId = id;
     return this;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/DefaultExtractorInput.java b/library/src/main/java/com/google/android/exoplayer/extractor/DefaultExtractorInput.java
index d8206671ca..27e90bf008 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/DefaultExtractorInput.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/DefaultExtractorInput.java
@@ -124,7 +124,6 @@ public boolean advancePeekPosition(int length, boolean allowEndOfInput)
       throws IOException, InterruptedException {
     ensureSpaceForPeek(length);
     int bytesPeeked = Math.min(peekBufferLength - peekBufferPosition, length);
-    peekBufferLength += length - bytesPeeked;
     while (bytesPeeked < length) {
       bytesPeeked = readFromDataSource(peekBuffer, peekBufferPosition, length, bytesPeeked,
           allowEndOfInput);
@@ -133,6 +132,7 @@ public boolean advancePeekPosition(int length, boolean allowEndOfInput)
       }
     }
     peekBufferPosition += length;
+    peekBufferLength = Math.max(peekBufferLength, peekBufferPosition);
     return true;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/Extractor.java
index cc3e04f35a..aa485b8096 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/Extractor.java
@@ -42,7 +42,7 @@
   public static final int RESULT_END_OF_INPUT = C.RESULT_END_OF_INPUT;
 
   /**
-   * Initializes the extractor with an {@link ExtractorOutput}.
+   * Initializes the extractor with an {@link ExtractorOutput}. Called at most once.
    *
    * @param output An {@link ExtractorOutput} to receive extracted data.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorOutput.java b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorOutput.java
index 683d8d6ea9..51002bc8e4 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorOutput.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorOutput.java
@@ -23,12 +23,13 @@
 public interface ExtractorOutput {
 
   /**
-   * Invoked when the {@link Extractor} identifies the existence of a track in the stream.
+   * Called by the {@link Extractor} to get the {@link TrackOutput} for a specific track.
    * <p>
-   * Returns a {@link TrackOutput} that will receive track level data belonging to the track.
+   * The same {@link TrackOutput} is returned if multiple calls are made with the same
+   * {@code trackId}.
    *
    * @param trackId A track identifier.
-   * @return The {@link TrackOutput} that should receive track level data belonging to the track.
+   * @return The {@link TrackOutput} for the given track identifier.
    */
   TrackOutput track(int trackId);
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
index 7e934a6d6e..5712a6218f 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
@@ -281,13 +281,16 @@ private void setupSeeker(ExtractorInput input) throws IOException, InterruptedEx
 
     long position = input.getPosition();
     long length = input.getLength();
+    int headerData = 0;
 
     // Check if there is a Xing header.
     int xingBase = (synchronizedHeader.version & 1) != 0
         ? (synchronizedHeader.channels != 1 ? 36 : 21) // MPEG 1
         : (synchronizedHeader.channels != 1 ? 21 : 13); // MPEG 2 or 2.5
-    frame.setPosition(xingBase);
-    int headerData = frame.readInt();
+    if (frame.limit() >= xingBase + 4) {
+      frame.setPosition(xingBase);
+      headerData = frame.readInt();
+    }
     if (headerData == XING_HEADER || headerData == INFO_HEADER) {
       seeker = XingSeeker.create(synchronizedHeader, frame, position, length);
       if (seeker != null && gaplessInfo == null) {
@@ -299,7 +302,7 @@ private void setupSeeker(ExtractorInput input) throws IOException, InterruptedEx
         gaplessInfo = GaplessInfo.createFromXingHeaderValue(scratch.readUnsignedInt24());
       }
       input.skipFully(synchronizedHeader.frameSize);
-    } else {
+    } else if (frame.limit() >= 40) {
       // Check if there is a VBRI header.
       frame.setPosition(36); // MPEG audio header (4 bytes) + 32 bytes.
       headerData = frame.readInt();
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
index 63564ba245..a4afbce611 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer.extractor.mp4;
 
+import android.util.Log;
 import android.util.Pair;
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
@@ -38,6 +39,10 @@
  */
 /* package */ final class AtomParsers {
 
+  private static final String TAG = "AtomParsers";
+
+  private static final int TYPE_cenc = Util.getIntegerCodeForString("cenc");
+
   /**
    * Parses a trak atom (defined in 14496-12).
    *
@@ -241,11 +246,16 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
         remainingTimestampOffsetChanges--;
       }
 
-      // Check all the expected samples have been seen.
-      Assertions.checkArgument(remainingSynchronizationSamples == 0);
-      Assertions.checkArgument(remainingSamplesAtTimestampDelta == 0);
-      Assertions.checkArgument(remainingSamplesInChunk == 0);
-      Assertions.checkArgument(remainingTimestampDeltaChanges == 0);
+      // If the stbl's child boxes are not consistent the container is malformed, but the stream may
+      // still be playable.
+      if (remainingSynchronizationSamples != 0 || remainingSamplesAtTimestampDelta != 0
+          || remainingSamplesInChunk != 0 || remainingTimestampDeltaChanges != 0) {
+        Log.w(TAG, "Inconsistent stbl box for track " + track.id
+            + ": remainingSynchronizationSamples " + remainingSynchronizationSamples
+            + ", remainingSamplesAtTimestampDelta " + remainingSamplesAtTimestampDelta
+            + ", remainingSamplesInChunk " + remainingSamplesInChunk
+            + ", remainingTimestampDeltaChanges " + remainingTimestampDeltaChanges);
+      }
     } else {
       long[] chunkOffsetsBytes = new long[chunkIterator.length];
       int[] chunkSampleCounts = new int[chunkIterator.length];
@@ -1014,7 +1024,7 @@ private static int findEsdsPosition(ParsableByteArray parent, int position, int
 
   /**
    * Parses encryption data from an audio/video sample entry, populating {@code out} and returning
-   * the unencrypted atom type, or 0 if no sinf atom was present.
+   * the unencrypted atom type, or 0 if no common encryption sinf atom was present.
    */
   private static int parseSampleEntryEncryptionData(ParsableByteArray parent, int position,
       int size, StsdData out, int entryIndex) {
@@ -1027,10 +1037,10 @@ private static int parseSampleEntryEncryptionData(ParsableByteArray parent, int
       if (childAtomType == Atom.TYPE_sinf) {
         Pair<Integer, TrackEncryptionBox> result = parseSinfFromParent(parent, childPosition,
             childAtomSize);
-        Integer dataFormat = result.first;
-        Assertions.checkArgument(dataFormat != null, "frma atom is mandatory");
-        out.trackEncryptionBoxes[entryIndex] = result.second;
-        return dataFormat;
+        if (result != null) {
+          out.trackEncryptionBoxes[entryIndex] = result.second;
+          return result.first;
+        }
       }
       childPosition += childAtomSize;
     }
@@ -1042,6 +1052,7 @@ private static int parseSampleEntryEncryptionData(ParsableByteArray parent, int
       int position, int size) {
     int childPosition = position + Atom.HEADER_SIZE;
 
+    boolean isCencScheme = false;
     TrackEncryptionBox trackEncryptionBox = null;
     Integer dataFormat = null;
     while (childPosition - position < size) {
@@ -1052,15 +1063,20 @@ private static int parseSampleEntryEncryptionData(ParsableByteArray parent, int
         dataFormat = parent.readInt();
       } else if (childAtomType == Atom.TYPE_schm) {
         parent.skipBytes(4);
-        parent.readInt(); // schemeType. Expect cenc
-        parent.readInt(); // schemeVersion. Expect 0x00010000
+        isCencScheme = parent.readInt() == TYPE_cenc;
       } else if (childAtomType == Atom.TYPE_schi) {
         trackEncryptionBox = parseSchiFromParent(parent, childPosition, childAtomSize);
       }
       childPosition += childAtomSize;
     }
 
-    return Pair.create(dataFormat, trackEncryptionBox);
+    if (isCencScheme) {
+      Assertions.checkArgument(dataFormat != null, "frma atom is mandatory");
+      Assertions.checkArgument(trackEncryptionBox != null, "schi->tenc atom is mandatory");
+      return Pair.create(dataFormat, trackEncryptionBox);
+    } else {
+      return null;
+    }
   }
 
   private static TrackEncryptionBox parseSchiFromParent(ParsableByteArray parent, int position,
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
index 6487829d3b..8a6fbc5fb5 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
@@ -79,6 +79,7 @@
 
   // Accessed only by the loading thread.
   private ExtractorOutput output;
+  private boolean tracksEnded;
   private int nextEmbeddedTrackId;
   /* package */ Id3Reader id3Reader;
 
@@ -96,10 +97,9 @@ public TsExtractor(PtsTimestampAdjuster ptsTimestampAdjuster, int workaroundFlag
     tsPacketBuffer = new ParsableByteArray(BUFFER_SIZE);
     tsScratch = new ParsableBitArray(new byte[3]);
     tsPayloadReaders = new SparseArray<>();
-    tsPayloadReaders.put(TS_PAT_PID, new PatReader());
     trackIds = new SparseBooleanArray();
-    nextEmbeddedTrackId = BASE_EMBEDDED_TRACK_ID;
     continuityCounters = new SparseIntArray();
+    resetPayloadReaders();
   }
 
   // Extractor implementation.
@@ -131,11 +131,10 @@ public void init(ExtractorOutput output) {
   @Override
   public void seek() {
     ptsTimestampAdjuster.reset();
-    for (int i = 0; i < tsPayloadReaders.size(); i++) {
-      tsPayloadReaders.valueAt(i).seek();
-    }
     tsPacketBuffer.reset();
     continuityCounters.clear();
+    // Elementary stream readers' state should be cleared to get consistent behaviours when seeking.
+    resetPayloadReaders();
   }
 
   @Override
@@ -230,6 +229,14 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
 
   // Internals.
 
+  private void resetPayloadReaders() {
+    trackIds.clear();
+    tsPayloadReaders.clear();
+    tsPayloadReaders.put(TS_PAT_PID, new PatReader());
+    id3Reader = null;
+    nextEmbeddedTrackId = BASE_EMBEDDED_TRACK_ID;
+  }
+
   /**
    * Parses TS packet payload data.
    */
@@ -323,7 +330,7 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
           patScratch.skipBits(13); // network_PID (13)
         } else {
           int pid = patScratch.readBits(13);
-          tsPayloadReaders.put(pid, new PmtReader());
+          tsPayloadReaders.put(pid, new PmtReader(pid));
         }
       }
 
@@ -339,14 +346,16 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
 
     private final ParsableBitArray pmtScratch;
     private final ParsableByteArray sectionData;
+    private final int pid;
 
     private int sectionLength;
     private int sectionBytesRead;
     private int crc;
 
-    public PmtReader() {
+    public PmtReader(int pid) {
       pmtScratch = new ParsableBitArray(new byte[5]);
       sectionData = new ParsableByteArray();
+      this.pid = pid;
     }
 
     @Override
@@ -479,8 +488,16 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
               new PesReader(pesPayloadReader, ptsTimestampAdjuster));
         }
       }
-
-      output.endTracks();
+      if ((workaroundFlags & WORKAROUND_MAP_BY_TYPE) != 0) {
+       if (!tracksEnded) {
+         output.endTracks();
+       }
+      } else {
+        tsPayloadReaders.remove(TS_PAT_PID);
+        tsPayloadReaders.remove(pid);
+        output.endTracks();
+      }
+      tracksEnded = true;
     }
 
     /**
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
index c95deab41a..aa316b2fa2 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
@@ -151,7 +151,9 @@
   private static final int ID_CUE_TRACK_POSITIONS = 0xB7;
   private static final int ID_CUE_CLUSTER_POSITION = 0xF1;
   private static final int ID_LANGUAGE = 0x22B59C;
-
+  private static final int ID_PROJECTION = 0x7670;
+  private static final int ID_PROJECTION_PRIVATE = 0x7672;
+  private static final int ID_STEREO_MODE = 0x53B8;
   private static final int LACING_NONE = 0;
   private static final int LACING_XIPH = 1;
   private static final int LACING_FIXED_SIZE = 2;
@@ -350,6 +352,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       case ID_CUE_POINT:
       case ID_CUE_TRACK_POSITIONS:
       case ID_BLOCK_GROUP:
+      case ID_PROJECTION:
         return EbmlReader.TYPE_MASTER;
       case ID_EBML_READ_VERSION:
       case ID_DOC_TYPE_READ_VERSION:
@@ -377,6 +380,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       case ID_CUE_TIME:
       case ID_CUE_CLUSTER_POSITION:
       case ID_REFERENCE_BLOCK:
+      case ID_STEREO_MODE:
         return EbmlReader.TYPE_UNSIGNED_INT;
       case ID_DOC_TYPE:
       case ID_CODEC_ID:
@@ -388,6 +392,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       case ID_SIMPLE_BLOCK:
       case ID_BLOCK:
       case ID_CODEC_PRIVATE:
+      case ID_PROJECTION_PRIVATE:
         return EbmlReader.TYPE_BINARY;
       case ID_DURATION:
       case ID_SAMPLING_FREQUENCY:
@@ -638,6 +643,22 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
       case ID_BLOCK_DURATION:
         blockDurationUs = scaleTimecodeToUs(value);
         return;
+      case ID_STEREO_MODE:
+        int layout = (int) value;
+        switch (layout) {
+          case 0:
+            currentTrack.stereoMode = C.STEREO_MODE_MONO;
+            break;
+          case 1:
+            currentTrack.stereoMode = C.STEREO_MODE_LEFT_RIGHT;
+            break;
+          case 3:
+            currentTrack.stereoMode = C.STEREO_MODE_TOP_BOTTOM;
+            break;
+          default:
+            break;
+        }
+        return;
       default:
         return;
     }
@@ -688,6 +709,10 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
         currentTrack.codecPrivate = new byte[contentSize];
         input.readFully(currentTrack.codecPrivate, 0, contentSize);
         return;
+      case ID_PROJECTION_PRIVATE:
+        currentTrack.projectionData = new byte[contentSize];
+        input.readFully(currentTrack.projectionData, 0, contentSize);
+        return;
       case ID_CONTENT_COMPRESSION_SETTINGS:
         // This extractor only supports header stripping, so the payload is the stripped bytes.
         currentTrack.sampleStrippedBytes = new byte[contentSize];
@@ -1276,6 +1301,8 @@ public void binaryElement(int id, int contentsSize, ExtractorInput input)
     public int displayWidth = MediaFormat.NO_VALUE;
     public int displayHeight = MediaFormat.NO_VALUE;
     public int displayUnit = DISPLAY_UNIT_PIXELS;
+    public byte[] projectionData = null;
+    public int stereoMode = MediaFormat.NO_VALUE;
 
     // Audio elements. Initially set to their default values.
     public int channelCount = 1;
@@ -1427,7 +1454,7 @@ public void initializeOutput(ExtractorOutput output, int trackId, long durationU
         }
         format = MediaFormat.createVideoFormat(Integer.toString(trackId), mimeType,
             MediaFormat.NO_VALUE, maxInputSize, durationUs, width, height, initializationData,
-            MediaFormat.NO_VALUE, pixelWidthHeightRatio);
+            MediaFormat.NO_VALUE, pixelWidthHeightRatio, projectionData, stereoMode);
       } else if (MimeTypes.APPLICATION_SUBRIP.equals(mimeType)) {
         format = MediaFormat.createTextFormat(Integer.toString(trackId), mimeType,
             MediaFormat.NO_VALUE, durationUs, language);
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsExtractorWrapper.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsExtractorWrapper.java
index dda93bc649..459362c58a 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsExtractorWrapper.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsExtractorWrapper.java
@@ -253,9 +253,13 @@ public long getAdjustedEndTimeUs() {
 
   @Override
   public TrackOutput track(int id) {
-    DefaultTrackOutput sampleQueue = new DefaultTrackOutput(allocator);
-    sampleQueues.put(id, sampleQueue);
-    return sampleQueue;
+    DefaultTrackOutput trackOutput = sampleQueues.get(id);
+    if (trackOutput != null) {
+      return trackOutput;
+    }
+    trackOutput = new DefaultTrackOutput(allocator);
+    sampleQueues.put(id, trackOutput);
+    return trackOutput;
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultHttpDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultHttpDataSource.java
index 5c63b0a402..04d8fb4cdd 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultHttpDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultHttpDataSource.java
@@ -403,11 +403,16 @@ private HttpURLConnection makeConnection(URL url, byte[] postBody, long position
     connection.setInstanceFollowRedirects(followRedirects);
     connection.setDoOutput(postBody != null);
     if (postBody != null) {
-      connection.setFixedLengthStreamingMode(postBody.length);
-      connection.connect();
-      OutputStream os = connection.getOutputStream();
-      os.write(postBody);
-      os.close();
+      connection.setRequestMethod("POST");
+      if (postBody.length == 0) {
+        connection.connect();
+      } else  {
+        connection.setFixedLengthStreamingMode(postBody.length);
+        connection.connect();
+        OutputStream os = connection.getOutputStream();
+        os.write(postBody);
+        os.close();
+      }
     } else {
       connection.connect();
     }
@@ -540,11 +545,8 @@ private void skipInternal() throws IOException {
    * @throws IOException If an error occurs reading from the source.
    */
   private int readInternal(byte[] buffer, int offset, int readLength) throws IOException {
-    readLength = bytesToRead == C.LENGTH_UNBOUNDED ? readLength
-        : (int) Math.min(readLength, bytesToRead - bytesRead);
     if (readLength == 0) {
-      // We've read all of the requested data.
-      return C.RESULT_END_OF_INPUT;
+      return 0;
     }
 
     int read = inputStream.read(buffer, offset, readLength);
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheSpan.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheSpan.java
index 414dd18a7a..2d872c4df9 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheSpan.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheSpan.java
@@ -29,7 +29,7 @@
   private static final Pattern CACHE_FILE_PATTERN_V1 =
       Pattern.compile("^(.+)\\.(\\d+)\\.(\\d+)\\.v1\\.exo$", Pattern.DOTALL);
   private static final Pattern CACHE_FILE_PATTERN_V2 =
-      Pattern.compile("^(.+)\\.(\\d+)(E?)\\.(\\d+)\\.v2\\.exo$", Pattern.DOTALL);
+      Pattern.compile("^(.+)\\.(\\d+)\\.(\\d+)\\.v2\\.exo$", Pattern.DOTALL);
 
   /**
    * The cache key that uniquely identifies the original stream.
@@ -87,7 +87,7 @@ public static CacheSpan createCacheEntry(File file) {
     }
     String key = Util.unescapeFileName(matcher.group(1));
     return key == null ? null : createCacheEntry(
-        key, Long.parseLong(matcher.group(2)), Long.parseLong(matcher.group(4)), file);
+        key, Long.parseLong(matcher.group(2)), Long.parseLong(matcher.group(3)), file);
   }
 
   static File upgradeIfNeeded(File file) {
diff --git a/playbacktests/src/main/AndroidManifest.xml b/playbacktests/src/main/AndroidManifest.xml
index 996a4e698b..06beaaec0b 100644
--- a/playbacktests/src/main/AndroidManifest.xml
+++ b/playbacktests/src/main/AndroidManifest.xml
@@ -17,8 +17,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer.playbacktests"
-    android:versionCode="1511"
-    android:versionName="1.5.11">
+    android:versionCode="1512"
+    android:versionName="1.5.12">
 
   <uses-permission android:name="android.permission.INTERNET"/>
   <uses-permission android:name="android.permission.WAKE_LOCK"/>
