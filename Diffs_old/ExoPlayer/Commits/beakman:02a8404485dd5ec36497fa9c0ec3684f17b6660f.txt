diff --git a/demo/src/main/AndroidManifest.xml b/demo/src/main/AndroidManifest.xml
index bbf2a65f34..8c0c2db2de 100644
--- a/demo/src/main/AndroidManifest.xml
+++ b/demo/src/main/AndroidManifest.xml
@@ -88,6 +88,7 @@
                 <action android:name="COMMAND" />
                 <action android:name="EXTRA_COMMAND" />
                 <action android:name="VIDEO_SOURCE" />
+                <action android:name="DBNAME" />
                 <action android:name="EXTRA_PARAMS" />
                 <action android:name="DRM_SCHEME_UUID_EXTRA" />
                 <action android:name="DRM_LICENSE_URL" />
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/AutomationReceiver.java b/demo/src/main/java/com/google/android/exoplayer2/demo/AutomationReceiver.java
index 948eb25a79..e79cd219b4 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/AutomationReceiver.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/AutomationReceiver.java
@@ -41,6 +41,7 @@ private void onSampleSelected(Sample sample) {
     *
     * */
     public static final String COMMAND_INTENT = "COMMAND";
+    public static final String DBNAME = "DBNAME";
     public static final String EXTRA_COMMAND = "EXTRA_COMMAND";
     public static final String VIDEO_SOURCE = "VIDEO_SOURCE";
     public static final String EXTRA_PARAMS = "EXTRA_PARAMS";
@@ -61,12 +62,20 @@ public void onReceive(Context context, Intent intent) {
             String command = intent.getStringExtra(EXTRA_COMMAND); // el comando ej: PLAY:VID:INI
             if (command != null) {
                 Log.d(TAG, "Processing command...");
-                String drm_scheme_uuid = intent.getStringExtra(DRM_SCHEME_UUID_EXTRA);
-                String drm_license_url = intent.getStringExtra(DRM_LICENSE_URL);
-                String drm_key_request_properties = intent.getStringExtra(DRM_KEY_REQUEST_PROPERTIES);
-                String prefer_extension_decoders = intent.getStringExtra(PREFER_EXTENSION_DECODERS);
+                // Procesamos los parametros opcionales
+                String drm_scheme_uuid = null;
+                String drm_license_url = null;
+                String drm_key_request_properties = null;
+                String prefer_extension_decoders = null;
+                String dbname = null;
+
+                if (intent.getStringExtra(DRM_SCHEME_UUID_EXTRA) != null) { drm_scheme_uuid = intent.getStringExtra(DRM_SCHEME_UUID_EXTRA); }
+                if (intent.getStringExtra(DRM_LICENSE_URL) != null) { drm_license_url = intent.getStringExtra(DRM_LICENSE_URL); }
+                if (intent.getStringExtra(DRM_KEY_REQUEST_PROPERTIES) != null) { drm_key_request_properties = intent.getStringExtra(DRM_KEY_REQUEST_PROPERTIES); }
+                if (intent.getStringExtra(PREFER_EXTENSION_DECODERS) != null) { prefer_extension_decoders = intent.getStringExtra(PREFER_EXTENSION_DECODERS); }
+                if (intent.getStringExtra(DBNAME) != null) { dbname = intent.getStringExtra(DBNAME); }
                 String video_source = intent.getStringExtra(VIDEO_SOURCE);
-                processCommand(command, video_source, drm_scheme_uuid, drm_license_url, drm_key_request_properties, prefer_extension_decoders);
+                processCommand(command, video_source, dbname, drm_scheme_uuid, drm_license_url, drm_key_request_properties, prefer_extension_decoders);
             }
         }
     }
@@ -75,12 +84,13 @@ public void onReceive(Context context, Intent intent) {
     // La sitaxis de los comandos es SCAPY.
     private void processCommand(String command,
                                 String video_source,
+                                String dbname,
                                 String drm_sheme_uuid,
                                 String drm_license_url,
                                 String drm_key_request_properties,
                                 String prefer_extension_decoders) {
         if (command.equalsIgnoreCase("PLAY:VID:INI")) {
-            playVideo(video_source, drm_sheme_uuid, drm_license_url, drm_key_request_properties, prefer_extension_decoders);
+            playVideo(video_source, dbname, drm_sheme_uuid, drm_license_url, drm_key_request_properties, prefer_extension_decoders);
             Log.d(TAG, "Command match: PLAY:VID:INI");
         } else if (command.equalsIgnoreCase("PLAY:VID:5:MIN")) {
             playVideoTo(video_source, 5);
@@ -93,18 +103,20 @@ private void processCommand(String command,
 
     // Estas son las funciones que se ejecutan cuando se recibe cierto comando
     public void playVideo(String video_source,
+                          String dbname,
                           String drm_sheme_uuid,
                           String drm_license_url,
                           String drm_key_request_properties,
                           String prefer_extension_decoders) {
         Log.d(TAG, "Play video!");
-        Intent mpdIntent = new Intent(mContext, PlayerActivity.class)
-                .setData(Uri.parse(video_source))
-                .putExtra(PlayerActivity.DRM_SCHEME_UUID_EXTRA, drm_sheme_uuid)
-                .putExtra(PlayerActivity.DRM_LICENSE_URL, drm_license_url)
-                .putExtra(PlayerActivity.DRM_KEY_REQUEST_PROPERTIES, drm_key_request_properties)
-                .putExtra(PlayerActivity.PREFER_EXTENSION_DECODERS, prefer_extension_decoders)
-                .setAction("com.google.android.exoplayer.demo.action.VIEW");
+        Intent mpdIntent = new Intent(mContext, PlayerActivity.class);
+        mpdIntent.setData(Uri.parse(video_source));
+        if (dbname != null) { mpdIntent.putExtra(PlayerActivity.DBNAME, dbname); }
+        if (drm_sheme_uuid != null) { mpdIntent.putExtra(PlayerActivity.DRM_SCHEME_UUID_EXTRA, drm_sheme_uuid); }
+        if (drm_license_url != null) { mpdIntent.putExtra(PlayerActivity.DRM_LICENSE_URL, drm_license_url); }
+        if (drm_key_request_properties != null) { mpdIntent.putExtra(PlayerActivity.DRM_KEY_REQUEST_PROPERTIES, drm_key_request_properties); }
+        if (prefer_extension_decoders != null) { mpdIntent.putExtra(PlayerActivity.PREFER_EXTENSION_DECODERS, prefer_extension_decoders); }
+        mpdIntent.setAction("com.google.android.exoplayer.demo.action.VIEW");
         mContext.startActivity(mpdIntent);
     }
 
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java b/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
index a7327d30cf..e6ee0028ff 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
@@ -48,8 +48,6 @@
 import java.util.List;
 import java.util.Locale;
 
-import com.google.android.exoplayer2.demo.LogService;
-
 /**
  * Logs player events using {@link Log}.
  */
@@ -155,6 +153,7 @@ private static String getFormatString(Format format) {
       builder.append(", language=").append(format.language);
     }
     return builder.toString();
+    //LogService.logVideoSizeChange(width, height);
   }
 
   // MappingTrackSelector.EventListener
@@ -172,6 +171,14 @@ private static String getTrackStatusString(boolean enabled) {
   }
 
   // AudioRendererEventListener
+  /*
+  *  Vamos a capturar en una tabla todos los eventos relacionados con el audio.
+  *  El LogService se encarga de colocarle el timestamp.
+  *
+  *  - onLoadingChanged: True/False
+  *  - onPlayerStateChanged: String state
+  *
+  * */
 
   @Override
   public void onLoadingChanged(boolean isLoading) {
@@ -299,34 +306,47 @@ public void onMetadata(List<Id3Frame> id3Frames) {
   @Override
   public void onAudioEnabled(DecoderCounters counters) {
     Log.d(TAG, "audioEnabled [" + getSessionTimeString() + "]");
+    LogService.logAudioEnabled();
   }
 
   @Override
   public void onAudioSessionId(int audioSessionId) {
     Log.d(TAG, "audioSessionId [" + audioSessionId + "]");
+    LogService.logAudioSessionId(audioSessionId);
   }
 
   @Override
   public void onAudioDecoderInitialized(String decoderName, long elapsedRealtimeMs,
                                         long initializationDurationMs) {
     Log.d(TAG, "audioDecoderInitialized [" + getSessionTimeString() + ", " + decoderName + "]");
+    LogService.logAudioDecoderInitialized(decoderName);
   }
 
   @Override
   public void onAudioInputFormatChanged(Format format) {
     Log.d(TAG, "audioFormatChanged [" + getSessionTimeString() + ", " + getFormatString(format)
             + "]");
+
+    String mimetype = String.valueOf(format.sampleMimeType);
+    String bitrate = String.valueOf(format.bitrate);
+    String channels = String.valueOf(format.channelCount);
+    String sample_rate = String.valueOf(format.sampleRate);
+    String language = String.valueOf(format.language);
+
+    LogService.logAudioInputFormatChanged(mimetype, bitrate, channels, sample_rate, language);
   }
 
   @Override
   public void onAudioDisabled(DecoderCounters counters) {
     Log.d(TAG, "audioDisabled [" + getSessionTimeString() + "]");
+    LogService.logAudioDisabled();
   }
 
   @Override
   public void onAudioTrackUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {
     printInternalError("audioTrackUnderrun [" + bufferSize + ", " + bufferSizeMs + ", "
             + elapsedSinceLastFeedMs + "]", null);
+    LogService.logAudioTrackUnderrun(bufferSize, bufferSizeMs);
   }
 
   // StreamingDrmSessionManager.EventListener
@@ -334,12 +354,14 @@ public void onAudioTrackUnderrun(int bufferSize, long bufferSizeMs, long elapsed
   @Override
   public void onVideoEnabled(DecoderCounters counters) {
     Log.d(TAG, "videoEnabled [" + getSessionTimeString() + "]");
+    LogService.logVideoEnabled();
   }
 
   @Override
   public void onVideoDecoderInitialized(String decoderName, long elapsedRealtimeMs,
                                         long initializationDurationMs) {
     Log.d(TAG, "videoDecoderInitialized [" + getSessionTimeString() + ", " + decoderName + "]");
+    LogService.logVideoDecoderInitialized(decoderName);
   }
 
   // ExtractorMediaSource.EventListener
@@ -348,6 +370,12 @@ public void onVideoDecoderInitialized(String decoderName, long elapsedRealtimeMs
   public void onVideoInputFormatChanged(Format format) {
     Log.d(TAG, "videoFormatChanged [" + getSessionTimeString() + ", " + getFormatString(format)
             + "]");
+    String mimetype = format.sampleMimeType;
+    String bitrate = String.valueOf(format.bitrate);
+    String resolution = String.valueOf(format.width) + "x" + String.valueOf(format.height);
+    String fps = String.valueOf(format.frameRate);
+
+    LogService.logVideoInputFormatChanged(mimetype, bitrate, resolution, fps);
   }
 
   // AdaptiveMediaSourceEventListener
@@ -355,19 +383,19 @@ public void onVideoInputFormatChanged(Format format) {
   @Override
   public void onVideoDisabled(DecoderCounters counters) {
     Log.d(TAG, "videoDisabled [" + getSessionTimeString() + "]");
+    LogService.logVideoDisabled();
   }
 
   @Override
   public void onDroppedFrames(int count, long elapsed) {
     Log.d(TAG, "droppedFrames [" + getSessionTimeString() + ", " + count + "]");
+    LogService.logDroppedFrames(String.valueOf(count));
   }
 
   @Override
   public void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
                                  float pixelWidthHeightRatio) {
     // Do nothing.
-    // LogService
-    LogService.logVideoSizeChange(width, height);
   }
 
   @Override
@@ -378,11 +406,13 @@ public void onRenderedFirstFrame(Surface surface) {
   @Override
   public void onDrmSessionManagerError(Exception e) {
     printInternalError("drmSessionManagerError", e);
+    LogService.logDrmSessionManagerError();
   }
 
   @Override
   public void onDrmKeysLoaded() {
     Log.d(TAG, "drmKeysLoaded [" + getSessionTimeString() + "]");
+    LogService.logDrmKeysLoaded();
   }
 
   // Internal methods
@@ -418,7 +448,6 @@ public void onLoadCanceled(DataSpec dataSpec, int dataType, int trackType, Forma
   public void onLoadCompleted(DataSpec dataSpec, int dataType, int trackType, Format trackFormat,
                               int trackSelectionReason, Object trackSelectionData, long mediaStartTimeMs,
                               long mediaEndTimeMs, long elapsedRealtimeMs, long loadDurationMs, long bytesLoaded) {
-    // Do nothing.
   }
 
   @Override
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/LogService.java b/demo/src/main/java/com/google/android/exoplayer2/demo/LogService.java
index 1555872773..111b09e5d6 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/LogService.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/LogService.java
@@ -28,6 +28,10 @@
 import android.os.Binder;
 import android.util.Log;
 
+/* Librerias auxiliares */
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
 public class LogService extends Service {
 
     public static OMLBase oml;
@@ -45,18 +49,90 @@
     IBinder mBinder = new LocalBinder();
     private String audio_format;
 
-    //
-    public static void logVideoSizeChange(int w, int h) {
-        Log.d("[LogService]", "logVideoSizeChange");
+    /*
+    * Funciones de log:
+    * =================
+    * - logAudioEnabled ------------------- [audio_events]
+    * - logAudioSessionId ----------------- [audio_events]
+    * - logAudioDecoderInitialized -------- [audio_events]
+    * - logAudioDisabled ------------------ [audio_events]
+    * - logAudioTrackUnderrun ------------- [audio_trackunderrun]
+    * - logAudioInputFormatChanged -------- [audio_format]
+    * - logVideoEnabled ------------------- [video_events]
+    * - logVideoDecoderInitialized -------- [video_events]
+    * - logVideoDisabled ------------------ [video_events]
+    * - logRenderedFirstFrame ------------- [video_events][disabled]
+    * - logDrmSessionManagerError --------- [video_events]
+    * - logDrmKeysLoaded ------------------ [video_events]
+    * - logVideoInputFormatChanged -------- [video_format]
+    * - logDroppedFrames ------------------ [video_dropped]
+    *
+    * */
+
+    /*
+    * AUDIO
+    *
+    * */
+
+    // Tabla audio_events
+    // Idea: eventos con parametros en json anidado
+    public static void logAudioEnabled() {
+        timestamp = formatter.format(System.currentTimeMillis());
+        final String[] data = {String.valueOf(timestamp), "audioEnabled"};
+        if (isOmlRunning) {
+            // hay que injectar en un thread para no bloquear
+            Thread t = new Thread(new Runnable() {
+                public void run() {
+                    measure_points.get(5).inject(data); // audio_events field
+                    Log.d("[LogService]", "audioEnabled at " + data[0]);
+                }
+            });
+            t.start();
+        } else {
+            Log.d("[LogService]", "OML Server not running yet.");
+        }
+    }
+    public static void logAudioSessionId(int audioSessionId) {
+        timestamp = formatter.format(System.currentTimeMillis());
+        final String[] data = {String.valueOf(timestamp), "AudioSessionId " + String.valueOf(audioSessionId)};
+        if (isOmlRunning) {
+            // hay que injectar en un thread para no bloquear
+            Thread t = new Thread(new Runnable() {
+                public void run() {
+                    measure_points.get(5).inject(data); // audio_events field
+                    Log.d("[LogService]", "audioSessionId at " + data[0]);
+                }
+            });
+            t.start();
+        } else {
+            Log.d("[LogService]", "OML Server not running yet.");
+        }
+    }
+    public static void logAudioDecoderInitialized(String decoderName) {
         timestamp = formatter.format(System.currentTimeMillis());
-        final String[] data = {String.valueOf(timestamp), String.valueOf(w), String.valueOf(h)};
+        final String[] data = {String.valueOf(timestamp), "AudioDecoderInitialized " + decoderName};
         if (isOmlRunning) {
-            // hay que inyectar los datos en un nuevo thread, sino
-            // se bloquea por un error NetworkOnMainThreadException
+            // hay que injectar en un thread para no bloquear
             Thread t = new Thread(new Runnable() {
                 public void run() {
-                    measure_points.get(0).inject(data);
-                    Log.d("[LogService]", "video_mp: " + data[0] + ", " + data[1] + ", " + data[2]);
+                    measure_points.get(5).inject(data); // audio_events field
+                    Log.d("[LogService]", "AudioDecoderInitialized at " + data[0]);
+                }
+            });
+            t.start();
+        } else {
+            Log.d("[LogService]", "OML Server not running yet.");
+        }
+    }
+    public static void logAudioDisabled() {
+        timestamp = formatter.format(System.currentTimeMillis());
+        final String[] data = {String.valueOf(timestamp), "AudioDisabled"};
+        if (isOmlRunning) {
+            // hay que injectar en un thread para no bloquear
+            Thread t = new Thread(new Runnable() {
+                public void run() {
+                    measure_points.get(5).inject(data); // audio_events field
+                    Log.d("[LogService]", "AudioDisabled at " + data[0]);
                 }
             });
             t.start();
@@ -65,6 +141,202 @@ public void run() {
         }
     }
 
+    // Tabla audio_trackunderrun
+    public static void logAudioTrackUnderrun(int bufferSize, long bufferSizeMs) {
+        timestamp = formatter.format(System.currentTimeMillis());
+        final String[] data = {String.valueOf(timestamp), String.valueOf(bufferSize), String.valueOf(bufferSizeMs)};
+        if (isOmlRunning) {
+            // hay que injectar en un thread para no bloquear
+            Thread t = new Thread(new Runnable() {
+                public void run() {
+                    measure_points.get(4).inject(data); // audio_track_underrun field
+                    Log.d("[LogService]", "AudioTrackUnderrun at " + data[0]);
+                }
+            });
+            t.start();
+        } else {
+            Log.d("[LogService]", "OML Server not running yet.");
+        }
+    }
+
+    // Tabla audio_format
+    public static void logAudioInputFormatChanged(String mimetype, String bitrate, String channels, String sample_rate, String language) {
+        timestamp = formatter.format(System.currentTimeMillis());
+        final String[] data = {String.valueOf(timestamp), mimetype, bitrate, channels, sample_rate, language};
+        Log.d("[LogService]", "AudioInputFormatChanged at " + data[0] + "; Format: " + data[1]);
+    }
+
+    /*
+    * VIDEO
+    *
+    * */
+
+    // Tabla video_events
+    public static void logVideoEnabled() {
+        timestamp = formatter.format(System.currentTimeMillis());
+        final String[] data = {String.valueOf(timestamp), "videoEnabled"};
+        if (isOmlRunning) {
+            // hay que injectar en un thread para no bloquear
+            Thread t = new Thread(new Runnable() {
+                public void run() {
+                    measure_points.get(2).inject(data); // video_events field
+                    Log.d("[LogService]", "videoEnabled at " + data[0]);
+                }
+            });
+            t.start();
+        } else {
+            Log.d("[LogService]", "OML Server not running yet.");
+        }
+    }
+    public static void logVideoDecoderInitialized(String decoder) {
+        timestamp = formatter.format(System.currentTimeMillis());
+        final String[] data = {String.valueOf(timestamp), "VideoDecoderInitialized: " + decoder};
+        if (isOmlRunning) {
+            // hay que injectar en un thread para no bloquear
+            Thread t = new Thread(new Runnable() {
+                public void run() {
+                    measure_points.get(2).inject(data); // video_events field
+                    Log.d("[LogService]", "VideoDecoderInitialized at " + data[0]);
+                }
+            });
+            t.start();
+        } else {
+            Log.d("[LogService]", "OML Server not running yet.");
+        }
+    }
+    public static void logVideoDisabled() {
+        timestamp = formatter.format(System.currentTimeMillis());
+        final String[] data = {String.valueOf(timestamp), "videoDisabled"};
+        if (isOmlRunning) {
+            // hay que injectar en un thread para no bloquear
+            Thread t = new Thread(new Runnable() {
+                public void run() {
+                    measure_points.get(2).inject(data); // video_events field
+                    Log.d("[LogService]", "videoDisabled at " + data[0]);
+                }
+            });
+            t.start();
+        } else {
+            Log.d("[LogService]", "OML Server not running yet.");
+        }
+    }
+    public static void logRenderedFirstFrame() {
+        // Do nothing.
+    }
+    public static void logDrmSessionManagerError() {
+        timestamp = formatter.format(System.currentTimeMillis());
+        final String[] data = {String.valueOf(timestamp), "DrmSessionManagerError"};
+        if (isOmlRunning) {
+            // hay que injectar en un thread para no bloquear
+            Thread t = new Thread(new Runnable() {
+                public void run() {
+                    measure_points.get(2).inject(data); // video_events field
+                    Log.d("[LogService]", "DrmSessionManagerError at " + data[0]);
+                }
+            });
+            t.start();
+        } else {
+            Log.d("[LogService]", "OML Server not running yet.");
+        }
+    }
+    public static void logDrmKeysLoaded() {
+        timestamp = formatter.format(System.currentTimeMillis());
+        final String[] data = {String.valueOf(timestamp), "DrmKeysLoaded"};
+        if (isOmlRunning) {
+            // hay que injectar en un thread para no bloquear
+            Thread t = new Thread(new Runnable() {
+                public void run() {
+                    measure_points.get(2).inject(data); // video_events field
+                    Log.d("[LogService]", "DrmKeysLoaded at " + data[0]);
+                }
+            });
+            t.start();
+        } else {
+            Log.d("[LogService]", "OML Server not running yet.");
+        }
+    }
+
+    // Tabla video_format
+    public static void logVideoInputFormatChanged(String mimetype, String bitrate, String resolution, String fps) {
+        timestamp = formatter.format(System.currentTimeMillis());
+        final String[] data = {String.valueOf(timestamp), mimetype, bitrate, resolution, fps};
+        if (isOmlRunning) {
+            // hay que injectar en un thread para no bloquear
+            Thread t = new Thread(new Runnable() {
+                public void run() {
+                    measure_points.get(0).inject(data); // video_format field
+                    Log.d("[LogService]", "VideoInputFormatChanged at " + data[0] + "; mimetype: " + data[1] + "; bitrate: " + data[2] + "; resolution: " + data[3] + "; fps: " + data[4]);
+                }
+            });
+            t.start();
+        } else {
+            Log.d("[LogService]", "OML Server not running yet.");
+        }
+    }
+
+    // Tabla video_dropped_frames
+    public static void logDroppedFrames(String count) {
+        timestamp = formatter.format(System.currentTimeMillis());
+
+        // data = {timestamp, count}
+        final String[] data = {String.valueOf(timestamp), count};
+
+        if (isOmlRunning) {
+            // hay que injectar en un thread para no bloquear
+            Thread t = new Thread(new Runnable() {
+                public void run() {
+                    measure_points.get(1).inject(data); // video_dropped field
+                    Log.d("[LogService]", "DroppedFrames at " + data[0] + "; count: " + data[1]);
+                }
+            });
+            t.start();
+        } else {
+            Log.d("[LogService]", "OML Server not running yet.");
+        }
+    }
+
+//    public static void logVideoSizeChanged() {
+//        // TODO 15/01/17
+//    }
+//
+//    public static void logVideoSizeChange(int w, int h) {
+//        Log.d("[LogService]", "logVideoSizeChange");
+//        timestamp = formatter.format(System.currentTimeMillis());
+//        final String[] data = {String.valueOf(timestamp), String.valueOf(w), String.valueOf(h)};
+//        if (isOmlRunning) {
+//            // hay que inyectar los datos en un nuevo thread, sino
+//            // se bloquea por un error NetworkOnMainThreadException
+//            Thread t = new Thread(new Runnable() {
+//                public void run() {
+//                    measure_points.get(0).inject(data);
+//                    Log.d("[LogService]", "video_mp: " + data[0] + ", " + data[1] + ", " + data[2]);
+//                }
+//            });
+//            t.start();
+//        } else {
+//            Log.d("[LogService]", "OML Server not running yet.");
+//        }
+//    }
+//
+//    public static void logVideoFormatChange(String videoFormat) {
+//        timestamp = formatter.format(System.currentTimeMillis());
+//        video_format = videoFormat;
+//        String[] data = {timestamp, resolution, video_format};
+//        if (video_format != null) {
+//            video_mp.inject(data);
+//        }
+//    }
+
+// ---------- esta la puedo quitar
+//    public void logAudioFormatChange(String audioFormat) {
+//        timestamp = formatter.format(System.currentTimeMillis());
+//        audio_format = audioFormat;
+//        String[] data = {timestamp, audio_format};
+//        if (video_format != null) {
+//            audio_mp.inject(data);
+//        }
+//    }
+
     @Override
     public IBinder onBind(Intent intent) {
         return mBinder;
@@ -77,9 +349,21 @@ public void onCreate() {
 
     @Override
     public int onStartCommand(Intent intent, int flags, int startId) {
+        // Hemos metido en el Intent parametros adicionales, los sacamos con esto
+        Bundle extras = intent.getExtras();
+        String dbname = "exoplayer_" + formatter.format(System.currentTimeMillis()); // default
+        if(extras.get("DBNAME") == null) {
+            Log.d("[LogService]", "null"); // no hay extras, nombre por defecto para la base de datos
+        }
+        else
+        {
+            Log.d("[LogService]","not null");
+            dbname = (String) extras.get("DBNAME");
+        }
         Log.d("[LogService]", "Iniciando servicio");
+        Log.d("[LogService]", "Escribiendo en " + dbname);
         super.onStartCommand(intent, flags, startId);
-        new OmlSetup().execute("exoplayer-experiment");
+        new OmlSetup().execute(dbname);
         logServiceIsRunning = true;
         return START_STICKY;
     }
@@ -90,24 +374,6 @@ public void onDestroy() {
         Log.d("[LogService]", "OML close");
     }
 
-    public void logVideoFormatChange(String videoFormat) {
-        timestamp = formatter.format(System.currentTimeMillis());
-        video_format = videoFormat;
-        String[] data = {timestamp, resolution, video_format};
-        if (video_format != null) {
-            video_mp.inject(data);
-        }
-    }
-
-    public void logAudioFormatChange(String audioFormat) {
-        timestamp = formatter.format(System.currentTimeMillis());
-        audio_format = audioFormat;
-        String[] data = {timestamp, audio_format};
-        if (video_format != null) {
-            audio_mp.inject(data);
-        }
-    }
-
     public class LocalBinder extends Binder {
 
         public LogService getServerInstance() {
@@ -130,90 +396,166 @@ protected void onPostExecute(ArrayList<OmlMP> result) {
 
         @Override
         protected ArrayList<OmlMP> doInBackground(String... experimentName) {
-            // Returns a value, that is catched by the onPostExecute method.
-            // String experiment_name = "ex_" + formatter.format(System.currentTimeMillis());
-            // PostgreSQL connection to get db name
-//            try {
-//                Class.forName("org.postgresql.Driver");
-//                // "jdbc:postgresql://IP:PUERTO/DB", "USER", "PASSWORD")
-//                Log.d("[dbService]", "Database connection...");
-//                String url = "jdbc:postgresql://94.177.232.57:5432/experiments_registry";
-//                Connection conn = DriverManager.getConnection(url, "oml", "tester");
-//                //En el stsql se puede agregar cualquier consulta SQL deseada.
-//                String stsql = "Select version()";
-//                Log.d("[dbService]", "Select version()");
-//                Statement st = conn.createStatement();
-//                ResultSet rs = st.executeQuery(stsql);
-//                rs.next();
-//                DatabaseMetaData meta = conn.getMetaData();
-//                ResultSet res = meta.getCatalogs();
-//                while (rs.next()) {
-//                    System.out.println("TABLE_CAT = " + rs.getString("TABLE_CAT") );
-//                    Log.d("[dbService]", "TABLE_CAT = " + rs.getString("TABLE_CAT"));
-//                }
-//                res.close();
-//                conn.close();
-//            } catch (SQLException se) {
-//                System.out.println("oops! No se puede conectar. Error: " + se.toString());
-//                Log.d("[dbService]", "oops! No se puede conectar. Error: " + se.toString());
-//                se.printStackTrace();
-//            } catch (ClassNotFoundException e) {
-//                System.out.println("oops! No se encuentra la clase. Error: " + e.getMessage());
-//                Log.d("[dbService]", "oops! No se encuentra la clase. Error: " + e.getMessage());
-//                e.printStackTrace();
-//            }
-            // otra forma
+            // El metodo doInBackground devuelve un 'result' que es capturado por el
+            // metodo 'onPostExecute'. Lo usamos para pasar los measure_points.
+            // Le pasamos la String dbname en la llamada: new OmlSetup().execute(dbname);
+            // Podiamos haber pasado un array de Strings, por eso el [0].
+            String experiment_name = experimentName[0];
+            Log.d("[LogService]", "!!! experiment_name="+experiment_name);
+
+            /*
+            * Esto creo que es una prueba. Luego lo quito y lo compruebo.
+            *
+            * */
             try {
                 Class.forName("org.postgresql.Driver");
-            } catch (ClassNotFoundException e) {
-                e.printStackTrace();
-            }
-            String url = "jdbc:postgresql://94.177.232.57:5432/experiments_registry?user=oml&password=tester";
-            Connection conn;
-            String exp_name = null;
-            try {
-                DriverManager.setLoginTimeout(5);
-                Log.d("[dbService]", "Connecting to database...");
-                conn = DriverManager.getConnection(url);
-                Log.d("[dbService]", "Connected! :-)");
+                // "jdbc:postgresql://IP:PUERTO/DB", "USER", "PASSWORD")
+                Log.d("[dbService]", "Database connection...");
+                String url = "jdbc:postgresql://94.177.232.57:5432/experiments_registry";
+                Connection conn = DriverManager.getConnection(url, "oml", "tester");
+                //En el stsql se puede agregar cualquier consulta SQL deseada.
+                String stsql = "Select version()";
+                Log.d("[dbService]", "Select version()");
                 Statement st = conn.createStatement();
-                String query = "SELECT * FROM experiments ORDER BY id DESC LIMIT 1";
-                ResultSet rs = st.executeQuery(query);
+                ResultSet rs = st.executeQuery(stsql);
+                rs.next();
+                DatabaseMetaData meta = conn.getMetaData();
+                ResultSet res = meta.getCatalogs();
                 while (rs.next()) {
-                    exp_name = rs.getString("experiment_name");
-                    Log.d("[dbService]", "Experiment name = " + exp_name);
+                    System.out.println("TABLE_CAT = " + rs.getString("TABLE_CAT") );
+                    Log.d("[dbService]", "TABLE_CAT = " + rs.getString("TABLE_CAT"));
                 }
-                rs.close();
-                st.close();
+                res.close();
                 conn.close();
-            } catch (SQLException e) {
+            } catch (SQLException se) {
+                System.out.println("oops! No se puede conectar. Error: " + se.toString());
+                Log.d("[dbService]", "oops! No se puede conectar. Error: " + se.toString());
+                se.printStackTrace();
+            } catch (ClassNotFoundException e) {
+                System.out.println("oops! No se encuentra la clase. Error: " + e.getMessage());
+                Log.d("[dbService]", "oops! No se encuentra la clase. Error: " + e.getMessage());
                 e.printStackTrace();
             }
-            String experiment_name = exp_name;
+
+// Lo haciamos asi para capturar el nombre de la base de datos directamente del servidor OML
+// Ahora le pasamos el nombre de la DB como parametro o le ponemos uno por defecto.
+//
+//            try {
+//                Class.forName("org.postgresql.Driver");
+//            } catch (ClassNotFoundException e) {
+//                e.printStackTrace();
+//            }
+//            String url = "jdbc:postgresql://94.177.232.57:5432/experiments_registry?user=oml&password=tester";
+//            Connection conn;
+//            String exp_name = null;
+//            try {
+//                DriverManager.setLoginTimeout(5);
+//                Log.d("[dbService]", "Connecting to database...");
+//                conn = DriverManager.getConnection(url);
+//                Log.d("[dbService]", "Connected! :-)");
+//                Statement st = conn.createStatement();
+//                String query = "SELECT * FROM experiments ORDER BY id DESC LIMIT 1";
+//                ResultSet rs = st.executeQuery(query);
+//                while (rs.next()) {
+//                    exp_name = rs.getString("experiment_name");
+//                    Log.d("[dbService]", "Experiment name = " + exp_name);
+//                }
+//                rs.close();
+//                st.close();
+//                conn.close();
+//            } catch (SQLException e) {
+//                e.printStackTrace();
+//            }
+
+            /* Configuramos el servidor OML:
+            * =============================
+            * - Establecemos la uri del servidor, la base de datos y alguna informacion mas
+            * - Establecemos los puntos de medida: que queremos medir (TODO)
+            * - Iniciamos el servidor oml
+            *
+            *
+            * Definición de los Measure Points:
+            * ================================
+            *
+            * video_format = {timestamp, mimetype, bitrate, resolution, fps}
+            * video_dropped_frames = {timestamp, count}
+            * video_events = {timestamp, event (enabled/disabled/loadDRMkeys...)}
+            *
+            * audio_events = {timestamp, event (enabled/disabled/loadDRMkeys...)}
+            * audio_format = {timestamp, mimetype, bitrate, channels, sample_rate, language}
+            *
+            * */
             OMLBase oml = new OMLBase("ExoPlayer", experiment_name, "exoplayer", "tcp:94.177.232.57:3003");
             ArrayList<OmlMP> measurePoints = new ArrayList<>();
-            ArrayList<OMLMPFieldDef> videoMp = new ArrayList<>();
-            videoMp.add(new OMLMPFieldDef("timestamp", OMLTypes.OML_STRING_VALUE));
-            videoMp.add(new OMLMPFieldDef("width", OMLTypes.OML_STRING_VALUE));
-            videoMp.add(new OMLMPFieldDef("height", OMLTypes.OML_STRING_VALUE));
 
-            ArrayList<OMLMPFieldDef> audioMp = new ArrayList<>();
-            audioMp.add(new OMLMPFieldDef("timestamp", OMLTypes.OML_STRING_VALUE));
-            audioMp.add(new OMLMPFieldDef("audio_format", OMLTypes.OML_STRING_VALUE));
+            // video_format
+            ArrayList<OMLMPFieldDef> videoFormat = new ArrayList<>();
+            videoFormat.add(new OMLMPFieldDef("timestamp", OMLTypes.OML_STRING_VALUE));
+            videoFormat.add(new OMLMPFieldDef("mimetype", OMLTypes.OML_STRING_VALUE));
+            videoFormat.add(new OMLMPFieldDef("bitrate", OMLTypes.OML_STRING_VALUE));
+            videoFormat.add(new OMLMPFieldDef("resolution", OMLTypes.OML_STRING_VALUE));
+            videoFormat.add(new OMLMPFieldDef("fps", OMLTypes.OML_STRING_VALUE));
+            OmlMP video_format = new OmlMP(videoFormat);
+
+            // video_dropped
+            ArrayList<OMLMPFieldDef> videoDropped = new ArrayList<>();
+            videoDropped.add(new OMLMPFieldDef("timestamp", OMLTypes.OML_STRING_VALUE));
+            videoDropped.add(new OMLMPFieldDef("count", OMLTypes.OML_STRING_VALUE));
+            OmlMP video_dropped = new OmlMP(videoDropped);
+
+            // video_events
+            ArrayList<OMLMPFieldDef> videoEvents = new ArrayList<>();
+            videoEvents.add(new OMLMPFieldDef("timestamp", OMLTypes.OML_STRING_VALUE));
+            videoEvents.add(new OMLMPFieldDef("event", OMLTypes.OML_STRING_VALUE));
+            OmlMP video_events = new OmlMP(videoEvents);
+
+            // audio_format
+            ArrayList<OMLMPFieldDef> audioFormat = new ArrayList<>();
+            audioFormat.add(new OMLMPFieldDef("timestamp", OMLTypes.OML_STRING_VALUE));
+            audioFormat.add(new OMLMPFieldDef("mimetype", OMLTypes.OML_STRING_VALUE));
+            audioFormat.add(new OMLMPFieldDef("bitrate", OMLTypes.OML_STRING_VALUE));
+            audioFormat.add(new OMLMPFieldDef("channels", OMLTypes.OML_STRING_VALUE));
+            audioFormat.add(new OMLMPFieldDef("sample_rate", OMLTypes.OML_STRING_VALUE));
+            audioFormat.add(new OMLMPFieldDef("language", OMLTypes.OML_STRING_VALUE));
+            OmlMP audio_format = new OmlMP(audioFormat);
+
+            // audio_track_underrun
+            // bufferSize - The size of the track's buffer, in bytes.
+            // bufferSizeMs - The size of the track's buffer, in milliseconds,
+            //    if it is configured for PCM output. C.TIME_UNSET if it is configured for passthrough
+            //    output, as the buffered media can have a variable bitrate so the duration may be
+            //    unknown.
+            // elapsedSinceLastFeedMs - The time since the track was last fed data, in milliseconds.
+            ArrayList<OMLMPFieldDef> audioTrackUnderrun = new ArrayList<>();
+            audioTrackUnderrun.add(new OMLMPFieldDef("timestamp", OMLTypes.OML_STRING_VALUE));
+            audioTrackUnderrun.add(new OMLMPFieldDef("buffer_size", OMLTypes.OML_STRING_VALUE));
+            audioTrackUnderrun.add(new OMLMPFieldDef("buffer_size_ms", OMLTypes.OML_STRING_VALUE));
+            OmlMP audio_track_underrun = new OmlMP(audioTrackUnderrun);
 
-            OmlMP video_mp = new OmlMP(videoMp);
-            OmlMP audio_mp = new OmlMP(audioMp);
+            // audio_events
+            ArrayList<OMLMPFieldDef> audioEvents = new ArrayList<>();
+            audioEvents.add(new OMLMPFieldDef("timestamp", OMLTypes.OML_STRING_VALUE));
+            audioEvents.add(new OMLMPFieldDef("event", OMLTypes.OML_STRING_VALUE));
+            OmlMP audio_events = new OmlMP(audioEvents);
 
             // Add schema
-            oml.addmp("ExoPlayer_video", video_mp);
-            oml.addmp("ExoPlayer_audio", audio_mp);
+            oml.addmp("video_format", video_format);
+            oml.addmp("video_dropped", video_dropped);
+            oml.addmp("video_events", video_events);
+            oml.addmp("audio_format", audio_format);
+            oml.addmp("audio_track_underrun", audio_track_underrun);
+            oml.addmp("audio_events", audio_events);
 
             oml.start();
 
             Log.d("[LogService]", "OML Server started");
 
-            measurePoints.add(video_mp); // measure_points[0]
-            measurePoints.add(audio_mp); // measure_points[1]
+            measurePoints.add(video_format); // measure_points[0] measure_points.get(0)
+            measurePoints.add(video_dropped); // measure_points[1] measure_points.get(1)
+            measurePoints.add(video_events); // measure_points[2] measure_points.get(2)
+            measurePoints.add(audio_format); // measure_points[3] measure_points.get(3)
+            measurePoints.add(audio_track_underrun); // measure_points[4] measure_points.get(4)
+            measurePoints.add(audio_events); // measure_points[4] measure_points.get(5)
 
             return measurePoints;
         }
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java b/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
index 485de5fd21..c77a860c07 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
@@ -84,6 +84,8 @@
   public static final String DRM_KEY_REQUEST_PROPERTIES = "drm_key_request_properties";
   public static final String PREFER_EXTENSION_DECODERS = "prefer_extension_decoders";
 
+  public static final String DBNAME = "dbname";
+
   public static final String ACTION_VIEW = "com.google.android.exoplayer.demo.action.VIEW";
   public static final String EXTENSION_EXTRA = "extension";
 
@@ -220,12 +222,28 @@ public void onVisibilityChange(int visibility) {
   // Internal methods
 
   private void initializePlayer() {
-    Intent intent = getIntent();
-    if (player == null) {
+    /*
+    *  Aqui se trata el Intent, con sus parametros.
+    *  Los parametros se cogen con los getStringExtras esos.
+    *
+    * */
+    Intent intent = getIntent(); // 1º capturamos el Intent
+    if (player == null) { // si no existe ningun player... lo configuramos:
+
+      String dbname = intent.getStringExtra(DBNAME);
+
+      // Esto no se para que sirve. Es false por defecto
       boolean preferExtensionDecoders = intent.getBooleanExtra(PREFER_EXTENSION_DECODERS, false);
+
+      // Esto es un codigo UUID. Tiene que tener un formato especifico para que no falle
       UUID drmSchemeUuid = intent.hasExtra(DRM_SCHEME_UUID_EXTRA)
           ? UUID.fromString(intent.getStringExtra(DRM_SCHEME_UUID_EXTRA)) : null;
+
+      // Esto tampoco se para que sirve
       DrmSessionManager drmSessionManager = null;
+
+      // Si tenemos UUID, capturamos la URL de la licencia drm
+      // Hay que estudiar mejor lo que hace esto
       if (drmSchemeUuid != null) {
         String drmLicenseUrl = intent.getStringExtra(DRM_LICENSE_URL);
         String[] keyRequestPropertiesArray = intent.getStringArrayExtra(DRM_KEY_REQUEST_PROPERTIES);
@@ -251,11 +269,19 @@ private void initializePlayer() {
         }
       }
 
-      // LogService
+      // Llamamos al LogService. Si ya hay un LogService escuchando, lo paramos y creamos otro.
+      // Tenemos que ver como le pasamos el parametro DBNAME
+      // Podemos usar esto: intent.getStringExtra(DBNAME
+      // if... intent.getStringExtra(DBNAME) tal, Sino lo generamos con la fecha
+
+      Intent LogServiceIntent = new Intent(this,LogService.class);
+
+      LogServiceIntent.putExtra("DBNAME", dbname); // dbname nunca sera null, viene de LogService
+
       if (LogService.logServiceIsRunning) {
-        stopService(new Intent(this, LogService.class));
+        stopService(LogServiceIntent);
       }
-      startService(new Intent(this, LogService.class));
+      startService(LogServiceIntent);
       logservice = new LogService();
 
       eventLogger = new EventLogger();
