diff --git a/library/core/aio.gradle b/library/core/aio.gradle
index a88e235a12..203e4ff150 100644
--- a/library/core/aio.gradle
+++ b/library/core/aio.gradle
@@ -1,6 +1,15 @@
 apply plugin: 'com.android.library'
 
 android {
+    // Workaround to prevent circular dependency on project :testutils.
+    sourceSets {
+        androidTest {
+            java.srcDirs += "../../testutils/src/main/java/"
+        }
+        test {
+            java.srcDirs += "../../testutils/src/main/java/"
+        }
+    }
 }
 
 hello { task ->
@@ -9,4 +18,11 @@ hello { task ->
 
 dependencies {
     compile 'com.android.support:support-annotations:' + supportLibraryVersion
+    androidTestCompile 'com.google.dexmaker:dexmaker:' + dexmakerVersion
+    androidTestCompile 'com.google.dexmaker:dexmaker-mockito:' + dexmakerVersion
+    androidTestCompile 'org.mockito:mockito-core:' + mockitoVersion
+    testCompile 'com.google.truth:truth:' + truthVersion
+    testCompile 'junit:junit:' + junitVersion
+    testCompile 'org.mockito:mockito-core:' + mockitoVersion
+    testCompile 'org.robolectric:robolectric:' + robolectricVersion
 }
\ No newline at end of file
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/ByteArrayDataSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/ByteArrayDataSourceTest.java
deleted file mode 100644
index a72d060287..0000000000
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/ByteArrayDataSourceTest.java
+++ /dev/null
@@ -1,165 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-
-import com.google.android.exoplayer2.C;
-import java.io.IOException;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-/**
- * Unit tests for {@link ByteArrayDataSource}.
- */
-@RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
-public final class ByteArrayDataSourceTest {
-
-  private static final byte[] TEST_DATA = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
-  private static final byte[] TEST_DATA_ODD = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
-
-  @Test
-  public void testFullReadSingleBytes() {
-    readTestData(TEST_DATA, 0, C.LENGTH_UNSET, 1, 0, 1, false);
-  }
-
-  @Test
-  public void testFullReadAllBytes() {
-    readTestData(TEST_DATA, 0, C.LENGTH_UNSET, 100, 0, 100, false);
-  }
-
-  @Test
-  public void testLimitReadSingleBytes() {
-    // Limit set to the length of the data.
-    readTestData(TEST_DATA, 0, TEST_DATA.length, 1, 0, 1, false);
-    // And less.
-    readTestData(TEST_DATA, 0, 6, 1, 0, 1, false);
-  }
-
-  @Test
-  public void testFullReadTwoBytes() {
-    // Try with the total data length an exact multiple of the size of each individual read.
-    readTestData(TEST_DATA, 0, C.LENGTH_UNSET, 2, 0, 2, false);
-    // And not.
-    readTestData(TEST_DATA_ODD, 0, C.LENGTH_UNSET, 2, 0, 2, false);
-  }
-
-  @Test
-  public void testLimitReadTwoBytes() {
-    // Try with the limit an exact multiple of the size of each individual read.
-    readTestData(TEST_DATA, 0, 6, 2, 0, 2, false);
-    // And not.
-    readTestData(TEST_DATA, 0, 7, 2, 0, 2, false);
-  }
-
-  @Test
-  public void testReadFromValidOffsets() {
-    // Read from an offset without bound.
-    readTestData(TEST_DATA, 1, C.LENGTH_UNSET, 1, 0, 1, false);
-    // And with bound.
-    readTestData(TEST_DATA, 1, 6, 1, 0, 1, false);
-    // Read from the last possible offset without bound.
-    readTestData(TEST_DATA, TEST_DATA.length - 1, C.LENGTH_UNSET, 1, 0, 1, false);
-    // And with bound.
-    readTestData(TEST_DATA, TEST_DATA.length - 1, 1, 1, 0, 1, false);
-  }
-
-  @Test
-  public void testReadFromInvalidOffsets() {
-    // Read from first invalid offset and check failure without bound.
-    readTestData(TEST_DATA, TEST_DATA.length, C.LENGTH_UNSET, 1, 0, 1, true);
-    // And with bound.
-    readTestData(TEST_DATA, TEST_DATA.length, 1, 1, 0, 1, true);
-  }
-
-  @Test
-  public void testReadWithInvalidLength() {
-    // Read more data than is available.
-    readTestData(TEST_DATA, 0, TEST_DATA.length + 1, 1, 0, 1, true);
-    // And with bound.
-    readTestData(TEST_DATA, 1, TEST_DATA.length, 1, 0, 1, true);
-  }
-
-  /**
-   * Tests reading from a {@link ByteArrayDataSource} with various parameters.
-   *
-   * @param testData The data that the {@link ByteArrayDataSource} will wrap.
-   * @param dataOffset The offset from which to read data.
-   * @param dataLength The total length of data to read.
-   * @param outputBufferLength The length of the target buffer for each read.
-   * @param writeOffset The offset into {@code outputBufferLength} for each read.
-   * @param maxReadLength The maximum length of each read.
-   * @param expectFailOnOpen Whether it is expected that opening the source will fail.
-   */
-  private void readTestData(byte[] testData, int dataOffset, int dataLength, int outputBufferLength,
-      int writeOffset, int maxReadLength, boolean expectFailOnOpen) {
-    int expectedFinalBytesRead =
-        dataLength == C.LENGTH_UNSET ? (testData.length - dataOffset) : dataLength;
-    ByteArrayDataSource dataSource = new ByteArrayDataSource(testData);
-    boolean opened = false;
-    try {
-      // Open the source.
-      long length = dataSource.open(new DataSpec(null, dataOffset, dataLength, null));
-      opened = true;
-      assertThat(expectFailOnOpen).isFalse();
-
-      // Verify the resolved length is as we expect.
-      assertThat(length).isEqualTo(expectedFinalBytesRead);
-
-      byte[] outputBuffer = new byte[outputBufferLength];
-      int accumulatedBytesRead = 0;
-      while (true) {
-        // Calculate a valid length for the next read, constraining by the specified output buffer
-        // length, write offset and maximum write length input parameters.
-        int requestedReadLength = Math.min(maxReadLength, outputBufferLength - writeOffset);
-        assertThat(requestedReadLength).isGreaterThan(0);
-
-        int bytesRead = dataSource.read(outputBuffer, writeOffset, requestedReadLength);
-        if (bytesRead != C.RESULT_END_OF_INPUT) {
-          assertThat(bytesRead).isGreaterThan(0);
-          assertThat(bytesRead).isAtMost(requestedReadLength);
-          // Check the data read was correct.
-          for (int i = 0; i < bytesRead; i++) {
-            assertThat(outputBuffer[writeOffset + i])
-                .isEqualTo(testData[dataOffset + accumulatedBytesRead + i]);
-          }
-          // Check that we haven't read more data than we were expecting.
-          accumulatedBytesRead += bytesRead;
-          assertThat(accumulatedBytesRead).isAtMost(expectedFinalBytesRead);
-          // If we haven't read all of the bytes the request should have been satisfied in full.
-          assertThat(accumulatedBytesRead == expectedFinalBytesRead
-              || bytesRead == requestedReadLength).isTrue();
-        } else {
-          // We're done. Check we read the expected number of bytes.
-          assertThat(accumulatedBytesRead).isEqualTo(expectedFinalBytesRead);
-          return;
-        }
-      }
-    } catch (IOException e) {
-      if (expectFailOnOpen && !opened) {
-        // Expected.
-        return;
-      }
-      // Unexpected failure.
-      fail();
-    }
-  }
-
-}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSchemeDataSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSchemeDataSourceTest.java
deleted file mode 100644
index 85c4341232..0000000000
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSchemeDataSourceTest.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream;
-
-import static com.google.android.exoplayer2.C.RESULT_END_OF_INPUT;
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-
-import android.net.Uri;
-import com.google.android.exoplayer2.C;
-import java.io.IOException;
-import java.nio.charset.Charset;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-/**
- * Unit tests for {@link DataSchemeDataSource}.
- */
-@RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
-public final class DataSchemeDataSourceTest {
-
-  private DataSource schemeDataDataSource;
-
-  @Before
-  public void setUp() {
-    schemeDataDataSource = new DataSchemeDataSource();
-  }
-
-  @Test
-  public void testBase64Data() throws IOException {
-    DataSpec dataSpec = buildDataSpec("data:text/plain;base64,eyJwcm92aWRlciI6IndpZGV2aW5lX3Rlc3QiL"
-        + "CJjb250ZW50X2lkIjoiTWpBeE5WOTBaV0Z5Y3c9PSIsImtleV9pZHMiOlsiMDAwMDAwMDAwMDAwMDAwMDAwMDAwM"
-        + "DAwMDAwMDAwMDAiXX0=");
-    DataSourceAsserts.assertDataSourceContent(schemeDataDataSource, dataSpec,
-        ("{\"provider\":\"widevine_test\",\"content_id\":\"MjAxNV90ZWFycw==\",\"key_ids\":"
-        + "[\"00000000000000000000000000000000\"]}").getBytes(Charset.forName(C.UTF8_NAME)));
-  }
-
-  @Test
-  public void testAsciiData() throws IOException {
-    DataSourceAsserts.assertDataSourceContent(schemeDataDataSource,
-        buildDataSpec("data:,A%20brief%20note"),
-        "A brief note".getBytes(Charset.forName(C.UTF8_NAME)));
-  }
-
-  @Test
-  public void testPartialReads() throws IOException {
-    byte[] buffer = new byte[18];
-    DataSpec dataSpec = buildDataSpec("data:,012345678901234567");
-    assertThat(schemeDataDataSource.open(dataSpec)).isEqualTo(18);
-    assertThat(schemeDataDataSource.read(buffer, 0, 9)).isEqualTo(9);
-    assertThat(schemeDataDataSource.read(buffer, 3, 0)).isEqualTo(0);
-    assertThat(schemeDataDataSource.read(buffer, 9, 15)).isEqualTo(9);
-    assertThat(schemeDataDataSource.read(buffer, 1, 0)).isEqualTo(0);
-    assertThat(schemeDataDataSource.read(buffer, 1, 1)).isEqualTo(RESULT_END_OF_INPUT);
-    assertThat(new String(buffer, 0, 18, C.UTF8_NAME)).isEqualTo("012345678901234567");
-  }
-
-  @Test
-  public void testIncorrectScheme() {
-    try {
-      schemeDataDataSource.open(buildDataSpec("http://www.google.com"));
-      fail();
-    } catch (IOException e) {
-      // Expected.
-    }
-  }
-
-  @Test
-  public void testMalformedData() {
-    try {
-      schemeDataDataSource.open(buildDataSpec("data:text/plain;base64,,This%20is%20Content"));
-      fail();
-    } catch (IOException e) {
-      // Expected.
-    }
-    try {
-      schemeDataDataSource.open(buildDataSpec("data:text/plain;base64,IncorrectPadding=="));
-      fail();
-    } catch (IOException e) {
-      // Expected.
-    }
-  }
-
-  private static DataSpec buildDataSpec(String uriString) {
-    return new DataSpec(Uri.parse(uriString));
-  }
-
-}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSourceAsserts.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSourceAsserts.java
deleted file mode 100644
index eff3245923..0000000000
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSourceAsserts.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import com.google.android.exoplayer2.testutil.TestUtil;
-import java.io.IOException;
-
-/**
- * Assertions for data source tests.
- */
-/* package */ final class DataSourceAsserts {
-
-  /**
-   * Asserts that data read from a {@link DataSource} matches {@code expected}.
-   *
-   * @param dataSource The {@link DataSource} through which to read.
-   * @param dataSpec The {@link DataSpec} to use when opening the {@link DataSource}.
-   * @param expectedData The expected data.
-   * @throws IOException If an error occurs reading fom the {@link DataSource}.
-   */
-  public static void assertDataSourceContent(DataSource dataSource, DataSpec dataSpec,
-      byte[] expectedData) throws IOException {
-    try {
-      long length = dataSource.open(dataSpec);
-      assertThat(length).isEqualTo(expectedData.length);
-      byte[] readData = TestUtil.readToEnd(dataSource);
-      assertThat(readData).isEqualTo(expectedData);
-    } finally {
-      dataSource.close();
-    }
-  }
-
-  private DataSourceAsserts() {}
-
-}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSourceInputStreamTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSourceInputStreamTest.java
deleted file mode 100644
index 8cd6c23fb1..0000000000
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSourceInputStreamTest.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import android.net.Uri;
-import com.google.android.exoplayer2.testutil.FakeDataSource;
-import com.google.android.exoplayer2.testutil.TestUtil;
-import java.io.IOException;
-import java.util.Arrays;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-/**
- * Unit tests for {@link DataSourceInputStream}.
- */
-@RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
-public final class DataSourceInputStreamTest {
-
-  private static final byte[] TEST_DATA = TestUtil.buildTestData(16);
-
-  @Test
-  public void testReadSingleBytes() throws IOException {
-    DataSourceInputStream inputStream = buildTestInputStream();
-    // No bytes read yet.
-    assertThat(inputStream.bytesRead()).isEqualTo(0);
-    // Read bytes.
-    for (int i = 0; i < TEST_DATA.length; i++) {
-      int readByte = inputStream.read();
-      assertThat(0 <= readByte && readByte < 256).isTrue();
-      assertThat(readByte).isEqualTo(TEST_DATA[i] & 0xFF);
-      assertThat(inputStream.bytesRead()).isEqualTo(i + 1);
-    }
-    // Check end of stream.
-    assertThat(inputStream.read()).isEqualTo(-1);
-    assertThat(inputStream.bytesRead()).isEqualTo(TEST_DATA.length);
-    // Check close succeeds.
-    inputStream.close();
-  }
-
-  @Test
-  public void testRead() throws IOException {
-    DataSourceInputStream inputStream = buildTestInputStream();
-    // Read bytes.
-    byte[] readBytes = new byte[TEST_DATA.length];
-    int totalBytesRead = 0;
-    while (totalBytesRead < TEST_DATA.length) {
-      int bytesRead = inputStream.read(readBytes, totalBytesRead,
-          TEST_DATA.length - totalBytesRead);
-      assertThat(bytesRead).isGreaterThan(0);
-      totalBytesRead += bytesRead;
-      assertThat(inputStream.bytesRead()).isEqualTo(totalBytesRead);
-    }
-    // Check the read data.
-    assertThat(readBytes).isEqualTo(TEST_DATA);
-    // Check end of stream.
-    assertThat(inputStream.bytesRead()).isEqualTo(TEST_DATA.length);
-    assertThat(totalBytesRead).isEqualTo(TEST_DATA.length);
-    assertThat(inputStream.read()).isEqualTo(-1);
-    // Check close succeeds.
-    inputStream.close();
-  }
-
-  @Test
-  public void testSkip() throws IOException {
-    DataSourceInputStream inputStream = buildTestInputStream();
-    // Skip bytes.
-    long totalBytesSkipped = 0;
-    while (totalBytesSkipped < TEST_DATA.length) {
-      long bytesSkipped = inputStream.skip(Long.MAX_VALUE);
-      assertThat(bytesSkipped > 0).isTrue();
-      totalBytesSkipped += bytesSkipped;
-      assertThat(inputStream.bytesRead()).isEqualTo(totalBytesSkipped);
-    }
-    // Check end of stream.
-    assertThat(inputStream.bytesRead()).isEqualTo(TEST_DATA.length);
-    assertThat(totalBytesSkipped).isEqualTo(TEST_DATA.length);
-    assertThat(inputStream.read()).isEqualTo(-1);
-    // Check close succeeds.
-    inputStream.close();
-  }
-
-  private static DataSourceInputStream buildTestInputStream() {
-    FakeDataSource fakeDataSource = new FakeDataSource();
-    fakeDataSource.getDataSet().newDefaultData()
-        .appendReadData(Arrays.copyOfRange(TEST_DATA, 0, 5))
-        .appendReadData(Arrays.copyOfRange(TEST_DATA, 5, 10))
-        .appendReadData(Arrays.copyOfRange(TEST_DATA, 10, 15))
-        .appendReadData(Arrays.copyOfRange(TEST_DATA, 15, TEST_DATA.length));
-    return new DataSourceInputStream(fakeDataSource, new DataSpec(Uri.EMPTY));
-  }
-
-}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheAsserts.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheAsserts.java
deleted file mode 100644
index aa98ad3179..0000000000
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheAsserts.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.truth.Truth.assertWithMessage;
-
-import android.net.Uri;
-import com.google.android.exoplayer2.testutil.FakeDataSet;
-import com.google.android.exoplayer2.testutil.FakeDataSet.FakeData;
-import com.google.android.exoplayer2.upstream.DataSourceInputStream;
-import com.google.android.exoplayer2.upstream.DataSpec;
-import com.google.android.exoplayer2.upstream.DummyDataSource;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.util.ArrayList;
-
-/** Assertion methods for {@link com.google.android.exoplayer2.upstream.cache.Cache}. */
-/* package */ final class CacheAsserts {
-
-  /** Asserts that the cache content is equal to the data in the {@code fakeDataSet}. */
-  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet) throws IOException {
-    ArrayList<FakeData> allData = fakeDataSet.getAllData();
-    Uri[] uris = new Uri[allData.size()];
-    for (int i = 0; i < allData.size(); i++) {
-      uris[i] = allData.get(i).uri;
-    }
-    assertCachedData(cache, fakeDataSet, uris);
-  }
-
-  /**
-   * Asserts that the cache content is equal to the given subset of data in the {@code fakeDataSet}.
-   */
-  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, String... uriStrings)
-      throws IOException {
-    Uri[] uris = new Uri[uriStrings.length];
-    for (int i = 0; i < uriStrings.length; i++) {
-      uris[i] = Uri.parse(uriStrings[i]);
-    }
-    assertCachedData(cache, fakeDataSet, uris);
-  }
-
-  /**
-   * Asserts that the cache content is equal to the given subset of data in the {@code fakeDataSet}.
-   */
-  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, Uri... uris)
-      throws IOException {
-    int totalLength = 0;
-    for (Uri uri : uris) {
-      byte[] data = fakeDataSet.getData(uri).getData();
-      assertDataCached(cache, uri, data);
-      totalLength += data.length;
-    }
-    assertThat(cache.getCacheSpace()).isEqualTo(totalLength);
-  }
-
-  /** Asserts that the cache contains the given subset of data in the {@code fakeDataSet}. */
-  public static void assertDataCached(Cache cache, FakeDataSet fakeDataSet, Uri... uris)
-      throws IOException {
-    for (Uri uri : uris) {
-      assertDataCached(cache, uri, fakeDataSet.getData(uri).getData());
-    }
-  }
-
-  /** Asserts that the cache contains the given data for {@code uriString}. */
-  public static void assertDataCached(Cache cache, Uri uri, byte[] expected) throws IOException {
-    CacheDataSource dataSource = new CacheDataSource(cache, DummyDataSource.INSTANCE, 0);
-    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
-    DataSourceInputStream inputStream = new DataSourceInputStream(dataSource,
-        new DataSpec(uri, DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH));
-    try {
-      inputStream.open();
-      byte[] buffer = new byte[1024];
-      int bytesRead;
-      while ((bytesRead = inputStream.read(buffer)) != -1) {
-        outputStream.write(buffer, 0, bytesRead);
-      }
-    } catch (IOException e) {
-      // Ignore
-    } finally {
-      inputStream.close();
-    }
-    assertWithMessage("Cached data doesn't match expected for '" + uri + "'")
-        .that(outputStream.toByteArray()).isEqualTo(expected);
-  }
-
-  /** Asserts that there is no cache content for the given {@code uriStrings}. */
-  public static void assertDataNotCached(Cache cache, String... uriStrings) {
-    for (String uriString : uriStrings) {
-      assertWithMessage("There is cached data for '" + uriString + "'")
-          .that(cache.getCachedSpans(CacheUtil.generateKey(Uri.parse(uriString)))).isNull();
-    }
-  }
-
-  /** Asserts that the cache is empty. */
-  public static void assertCacheEmpty(Cache cache) {
-    assertThat(cache.getCacheSpace()).isEqualTo(0);
-  }
-
-  private CacheAsserts() {}
-
-}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
deleted file mode 100644
index e92f072dc2..0000000000
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
+++ /dev/null
@@ -1,237 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-import static android.net.Uri.EMPTY;
-import static com.google.android.exoplayer2.C.LENGTH_UNSET;
-import static com.google.android.exoplayer2.upstream.cache.CacheAsserts.assertCacheEmpty;
-import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.truth.Truth.assertWithMessage;
-import static java.util.Arrays.copyOf;
-import static java.util.Arrays.copyOfRange;
-import static org.junit.Assert.fail;
-
-import android.net.Uri;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.testutil.FakeDataSet.FakeData;
-import com.google.android.exoplayer2.testutil.FakeDataSource;
-import com.google.android.exoplayer2.upstream.DataSpec;
-import com.google.android.exoplayer2.upstream.FileDataSource;
-import com.google.android.exoplayer2.util.Util;
-import java.io.File;
-import java.io.IOException;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
-
-/**
- * Unit tests for {@link CacheDataSource}.
- */
-@RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
-public final class CacheDataSourceTest {
-
-  private static final byte[] TEST_DATA = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
-  private static final int MAX_CACHE_FILE_SIZE = 3;
-  private static final String KEY_1 = "key 1";
-  private static final String KEY_2 = "key 2";
-
-  private File tempFolder;
-  private SimpleCache cache;
-
-  @Before
-  public void setUp() throws Exception {
-    tempFolder = Util.createTempDirectory(RuntimeEnvironment.application, "ExoPlayerTest");
-    cache = new SimpleCache(tempFolder, new NoOpCacheEvictor());
-  }
-
-  @After
-  public void tearDown() throws Exception {
-    Util.recursiveDelete(tempFolder);
-  }
-
-  @Test
-  public void testMaxCacheFileSize() throws Exception {
-    CacheDataSource cacheDataSource = createCacheDataSource(false, false);
-    assertReadDataContentLength(cacheDataSource, false, false);
-    for (String key : cache.getKeys()) {
-      for (CacheSpan cacheSpan : cache.getCachedSpans(key)) {
-        assertThat(cacheSpan.length <= MAX_CACHE_FILE_SIZE).isTrue();
-        assertThat(cacheSpan.file.length() <= MAX_CACHE_FILE_SIZE).isTrue();
-      }
-    }
-  }
-
-  @Test
-  public void testCacheAndRead() throws Exception {
-    assertCacheAndRead(false, false);
-  }
-
-  @Test
-  public void testCacheAndReadUnboundedRequest() throws Exception {
-    assertCacheAndRead(true, false);
-  }
-
-  @Test
-  public void testCacheAndReadUnknownLength() throws Exception {
-    assertCacheAndRead(false, true);
-  }
-
-  // Disabled test as we don't support caching of definitely unknown length content
-  @Ignore
-  @Test
-  public void disabledTestCacheAndReadUnboundedRequestUnknownLength() throws Exception {
-    assertCacheAndRead(true, true);
-  }
-
-  @Test
-  public void testUnsatisfiableRange() throws Exception {
-    // Bounded request but the content length is unknown. This forces all data to be cached but not
-    // the length
-    assertCacheAndRead(false, true);
-
-    // Now do an unbounded request. This will read all of the data from cache and then try to read
-    // more from upstream which will cause to a 416 so CDS will store the length.
-    CacheDataSource cacheDataSource = createCacheDataSource(true, true);
-    assertReadDataContentLength(cacheDataSource, true, true);
-
-    // If the user try to access off range then it should throw an IOException
-    try {
-      cacheDataSource = createCacheDataSource(false, false);
-      cacheDataSource.open(new DataSpec(Uri.EMPTY, TEST_DATA.length, 5, KEY_1));
-      fail();
-    } catch (IOException e) {
-      // success
-    }
-  }
-
-  @Test
-  public void testContentLengthEdgeCases() throws Exception {
-    // Read partial at EOS but don't cross it so length is unknown
-    CacheDataSource cacheDataSource = createCacheDataSource(false, true);
-    assertReadData(cacheDataSource, true, TEST_DATA.length - 2, 2);
-    assertThat(cache.getContentLength(KEY_1)).isEqualTo(LENGTH_UNSET);
-
-    // Now do an unbounded request for whole data. This will cause a bounded request from upstream.
-    // End of data from upstream shouldn't be mixed up with EOS and cause length set wrong.
-    cacheDataSource = createCacheDataSource(false, true);
-    assertReadDataContentLength(cacheDataSource, true, true);
-
-    // Now the length set correctly do an unbounded request with offset
-    assertThat(cacheDataSource.open(new DataSpec(EMPTY, TEST_DATA.length - 2,
-        LENGTH_UNSET, KEY_1))).isEqualTo(2);
-
-    // An unbounded request with offset for not cached content
-    assertThat(cacheDataSource.open(new DataSpec(EMPTY, TEST_DATA.length - 2,
-        LENGTH_UNSET, KEY_2))).isEqualTo(LENGTH_UNSET);
-  }
-
-  @Test
-  public void testIgnoreCacheForUnsetLengthRequests() throws Exception {
-    CacheDataSource cacheDataSource = createCacheDataSource(false, true,
-        CacheDataSource.FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS);
-    assertReadData(cacheDataSource, true, 0, C.LENGTH_UNSET);
-    assertThat(cache.getKeys()).isEmpty();
-  }
-
-  @Test
-  public void testReadOnlyCache() throws Exception {
-    CacheDataSource cacheDataSource = createCacheDataSource(false, false, 0, null);
-    assertReadDataContentLength(cacheDataSource, false, false);
-    assertCacheEmpty(cache);
-  }
-
-  private void assertCacheAndRead(boolean unboundedRequest, boolean simulateUnknownLength)
-      throws IOException {
-    // Read all data from upstream and write to cache
-    CacheDataSource cacheDataSource = createCacheDataSource(false, simulateUnknownLength);
-    assertReadDataContentLength(cacheDataSource, unboundedRequest, simulateUnknownLength);
-
-    // Just read from cache
-    cacheDataSource = createCacheDataSource(true, simulateUnknownLength);
-    assertReadDataContentLength(cacheDataSource, unboundedRequest,
-        false /*length is already cached*/);
-  }
-
-  /**
-   * Reads data until EOI and compares it to {@link #TEST_DATA}. Also checks content length returned
-   * from open() call and the cached content length.
-   */
-  private void assertReadDataContentLength(CacheDataSource cacheDataSource,
-      boolean unboundedRequest, boolean unknownLength) throws IOException {
-    int length = unboundedRequest ? C.LENGTH_UNSET : TEST_DATA.length;
-    assertReadData(cacheDataSource, unknownLength, 0, length);
-    assertWithMessage("When the range specified, CacheDataSource doesn't reach EOS so shouldn't "
-        + "cache content length").that(cache.getContentLength(KEY_1))
-        .isEqualTo(!unboundedRequest ? C.LENGTH_UNSET : TEST_DATA.length);
-  }
-
-  private void assertReadData(CacheDataSource cacheDataSource, boolean unknownLength, int position,
-      int length) throws IOException {
-    int testDataLength = TEST_DATA.length - position;
-    if (length != C.LENGTH_UNSET) {
-      testDataLength = Math.min(testDataLength, length);
-    }
-    assertThat(cacheDataSource.open(new DataSpec(EMPTY, position, length, KEY_1)))
-        .isEqualTo(unknownLength ? length : testDataLength);
-
-    byte[] buffer = new byte[100];
-    int totalBytesRead = 0;
-    while (true) {
-      int read = cacheDataSource.read(buffer, totalBytesRead, buffer.length - totalBytesRead);
-      if (read == C.RESULT_END_OF_INPUT) {
-        break;
-      }
-      totalBytesRead += read;
-    }
-    assertThat(totalBytesRead).isEqualTo(testDataLength);
-    assertThat(copyOf(buffer, totalBytesRead))
-        .isEqualTo(copyOfRange(TEST_DATA, position, position + testDataLength));
-
-    cacheDataSource.close();
-  }
-
-  private CacheDataSource createCacheDataSource(boolean setReadException,
-      boolean simulateUnknownLength) {
-    return createCacheDataSource(setReadException, simulateUnknownLength,
-        CacheDataSource.FLAG_BLOCK_ON_CACHE);
-  }
-
-  private CacheDataSource createCacheDataSource(boolean setReadException,
-      boolean simulateUnknownLength, @CacheDataSource.Flags int flags) {
-    return createCacheDataSource(setReadException, simulateUnknownLength, flags,
-        new CacheDataSink(cache, MAX_CACHE_FILE_SIZE));
-  }
-
-  private CacheDataSource createCacheDataSource(boolean setReadException,
-      boolean simulateUnknownLength, @CacheDataSource.Flags int flags,
-      CacheDataSink cacheWriteDataSink) {
-    FakeDataSource upstream = new FakeDataSource();
-    FakeData fakeData = upstream.getDataSet().newDefaultData()
-        .setSimulateUnknownLength(simulateUnknownLength).appendReadData(TEST_DATA);
-    if (setReadException) {
-      fakeData.appendReadError(new IOException("Shouldn't read from upstream"));
-    }
-    return new CacheDataSource(cache, upstream, new FileDataSource(), cacheWriteDataSink,
-        flags, null);
-  }
-
-}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java
deleted file mode 100644
index 3b8276c731..0000000000
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java
+++ /dev/null
@@ -1,194 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-import static com.google.common.truth.Truth.assertThat;
-import static java.util.Arrays.copyOf;
-import static java.util.Arrays.copyOfRange;
-
-import android.content.Context;
-import android.net.Uri;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.testutil.FakeDataSource;
-import com.google.android.exoplayer2.testutil.TestUtil;
-import com.google.android.exoplayer2.upstream.DataSink;
-import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.DataSpec;
-import com.google.android.exoplayer2.upstream.FileDataSource;
-import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
-import com.google.android.exoplayer2.upstream.crypto.AesCipherDataSink;
-import com.google.android.exoplayer2.upstream.crypto.AesCipherDataSource;
-import com.google.android.exoplayer2.util.Util;
-import java.io.File;
-import java.io.IOException;
-import java.util.Random;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
-
-/**
- * Additional tests for {@link CacheDataSource}.
- */
-@RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
-public final class CacheDataSourceTest2 {
-
-  private static final String EXO_CACHE_DIR = "exo";
-  private static final int EXO_CACHE_MAX_FILESIZE = 128;
-
-  private static final Uri URI = Uri.parse("http://test.com/content");
-  private static final String KEY = "key";
-  private static final byte[] DATA = TestUtil.buildTestData(8 * EXO_CACHE_MAX_FILESIZE + 1);
-
-  // A DataSpec that covers the full file.
-  private static final DataSpec FULL = new DataSpec(URI, 0, DATA.length, KEY);
-
-  private static final int OFFSET_ON_BOUNDARY = EXO_CACHE_MAX_FILESIZE;
-  // A DataSpec that starts at 0 and extends to a cache file boundary.
-  private static final DataSpec END_ON_BOUNDARY = new DataSpec(URI, 0, OFFSET_ON_BOUNDARY, KEY);
-  // A DataSpec that starts on the same boundary and extends to the end of the file.
-  private static final DataSpec START_ON_BOUNDARY = new DataSpec(URI, OFFSET_ON_BOUNDARY,
-      DATA.length - OFFSET_ON_BOUNDARY, KEY);
-
-  private static final int OFFSET_OFF_BOUNDARY = EXO_CACHE_MAX_FILESIZE * 2 + 1;
-  // A DataSpec that starts at 0 and extends to just past a cache file boundary.
-  private static final DataSpec END_OFF_BOUNDARY = new DataSpec(URI, 0, OFFSET_OFF_BOUNDARY, KEY);
-  // A DataSpec that starts on the same boundary and extends to the end of the file.
-  private static final DataSpec START_OFF_BOUNDARY = new DataSpec(URI, OFFSET_OFF_BOUNDARY,
-      DATA.length - OFFSET_OFF_BOUNDARY, KEY);
-
-  @Test
-  public void testWithoutEncryption() throws IOException {
-    testReads(false);
-  }
-
-  @Test
-  public void testWithEncryption() throws IOException {
-    testReads(true);
-  }
-
-  private void testReads(boolean useEncryption) throws IOException {
-    FakeDataSource upstreamSource = buildFakeUpstreamSource();
-    CacheDataSource source =
-        buildCacheDataSource(RuntimeEnvironment.application, upstreamSource, useEncryption);
-    // First read, should arrive from upstream.
-    testRead(END_ON_BOUNDARY, source);
-    assertSingleOpen(upstreamSource, 0, OFFSET_ON_BOUNDARY);
-    // Second read, should arrive from upstream.
-    testRead(START_OFF_BOUNDARY, source);
-    assertSingleOpen(upstreamSource, OFFSET_OFF_BOUNDARY, DATA.length);
-    // Second read, should arrive part from cache and part from upstream.
-    testRead(END_OFF_BOUNDARY, source);
-    assertSingleOpen(upstreamSource, OFFSET_ON_BOUNDARY, OFFSET_OFF_BOUNDARY);
-    // Third read, should arrive from cache.
-    testRead(FULL, source);
-    assertNoOpen(upstreamSource);
-    // Various reads, should all arrive from cache.
-    testRead(FULL, source);
-    assertNoOpen(upstreamSource);
-    testRead(START_ON_BOUNDARY, source);
-    assertNoOpen(upstreamSource);
-    testRead(END_ON_BOUNDARY, source);
-    assertNoOpen(upstreamSource);
-    testRead(START_OFF_BOUNDARY, source);
-    assertNoOpen(upstreamSource);
-    testRead(END_OFF_BOUNDARY, source);
-    assertNoOpen(upstreamSource);
-  }
-
-  private void testRead(DataSpec dataSpec, CacheDataSource source) throws IOException {
-    byte[] scratch = new byte[4096];
-    Random random = new Random(0);
-    source.open(dataSpec);
-    int position = (int) dataSpec.absoluteStreamPosition;
-    int bytesRead = 0;
-    while (bytesRead != C.RESULT_END_OF_INPUT) {
-      int maxBytesToRead = random.nextInt(scratch.length) + 1;
-      bytesRead = source.read(scratch, 0, maxBytesToRead);
-      if (bytesRead != C.RESULT_END_OF_INPUT) {
-        assertThat(copyOf(scratch, bytesRead))
-            .isEqualTo(copyOfRange(DATA, position, position + bytesRead));
-        position += bytesRead;
-      }
-    }
-    source.close();
-  }
-
-  /**
-   * Asserts that a single {@link DataSource#open(DataSpec)} call has been made to the upstream
-   * source, with the specified start (inclusive) and end (exclusive) positions.
-   */
-  private void assertSingleOpen(FakeDataSource upstreamSource, int start, int end) {
-    DataSpec[] openedDataSpecs = upstreamSource.getAndClearOpenedDataSpecs();
-    assertThat(openedDataSpecs).hasLength(1);
-    assertThat(openedDataSpecs[0].position).isEqualTo(start);
-    assertThat(openedDataSpecs[0].absoluteStreamPosition).isEqualTo(start);
-    assertThat(openedDataSpecs[0].length).isEqualTo(end - start);
-  }
-
-  /**
-   * Asserts that the upstream source was not opened.
-   */
-  private void assertNoOpen(FakeDataSource upstreamSource) {
-    DataSpec[] openedDataSpecs = upstreamSource.getAndClearOpenedDataSpecs();
-    assertThat(openedDataSpecs).hasLength(0);
-  }
-
-  private static FakeDataSource buildFakeUpstreamSource() {
-    FakeDataSource fakeDataSource = new FakeDataSource();
-    fakeDataSource.getDataSet().newDefaultData().appendReadData(DATA);
-    return fakeDataSource;
-  }
-
-  private static CacheDataSource buildCacheDataSource(Context context, DataSource upstreamSource,
-      boolean useAesEncryption) throws CacheException {
-    File cacheDir = context.getExternalCacheDir();
-    Cache cache = new SimpleCache(new File(cacheDir, EXO_CACHE_DIR), new NoOpCacheEvictor());
-    emptyCache(cache);
-
-    // Source and cipher
-    final String secretKey = "testKey:12345678";
-    DataSource file = new FileDataSource();
-    DataSource cacheReadDataSource = useAesEncryption
-        ? new AesCipherDataSource(Util.getUtf8Bytes(secretKey), file) : file;
-
-    // Sink and cipher
-    CacheDataSink cacheSink = new CacheDataSink(cache, EXO_CACHE_MAX_FILESIZE);
-    byte[] scratch = new byte[3897];
-    DataSink cacheWriteDataSink = useAesEncryption
-        ? new AesCipherDataSink(Util.getUtf8Bytes(secretKey), cacheSink, scratch) : cacheSink;
-
-    return new CacheDataSource(cache,
-        upstreamSource,
-        cacheReadDataSource,
-        cacheWriteDataSink,
-        CacheDataSource.FLAG_BLOCK_ON_CACHE,
-        null); // eventListener
-  }
-
-  private static void emptyCache(Cache cache) throws CacheException {
-    for (String key : cache.getKeys()) {
-      for (CacheSpan span : cache.getCachedSpans(key)) {
-        cache.removeSpan(span);
-      }
-    }
-    // Sanity check that the cache really is empty now.
-    assertThat(cache.getKeys().isEmpty()).isTrue();
-  }
-
-}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheUtilTest.java
deleted file mode 100644
index c8231ec4ac..0000000000
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheUtilTest.java
+++ /dev/null
@@ -1,319 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-import static android.net.Uri.EMPTY;
-import static android.net.Uri.parse;
-import static com.google.android.exoplayer2.C.LENGTH_UNSET;
-import static com.google.android.exoplayer2.upstream.cache.CacheAsserts.assertCacheEmpty;
-import static com.google.android.exoplayer2.upstream.cache.CacheAsserts.assertCachedData;
-import static com.google.android.exoplayer2.upstream.cache.CacheUtil.generateKey;
-import static com.google.android.exoplayer2.upstream.cache.CacheUtil.getKey;
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-
-import android.net.Uri;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.testutil.FakeDataSet;
-import com.google.android.exoplayer2.testutil.FakeDataSource;
-import com.google.android.exoplayer2.testutil.TestUtil;
-import com.google.android.exoplayer2.upstream.DataSpec;
-import com.google.android.exoplayer2.upstream.cache.CacheUtil.CachingCounters;
-import com.google.android.exoplayer2.util.Util;
-import java.io.EOFException;
-import java.io.File;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Answers;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
-
-/**
- * Tests {@link CacheUtil}.
- */
-@RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
-public final class CacheUtilTest {
-
-  /**
-   * Abstract fake Cache implementation used by the test. This class must be public so Mockito can
-   * create a proxy for it.
-   */
-  public abstract static class AbstractFakeCache implements Cache {
-
-    // This array is set to alternating length of cached and not cached regions in tests:
-    // spansAndGaps = {<length of 1st cached region>, <length of 1st not cached region>,
-    //    <length of 2nd cached region>, <length of 2nd not cached region>, ... }
-    // Ideally it should end with a cached region but it shouldn't matter for any code.
-    private int[] spansAndGaps;
-    private long contentLength;
-
-    private void init() {
-      spansAndGaps = new int[] {};
-      contentLength = C.LENGTH_UNSET;
-    }
-
-    @Override
-    public long getCachedBytes(String key, long position, long length) {
-      for (int i = 0; i < spansAndGaps.length; i++) {
-        int spanOrGap = spansAndGaps[i];
-        if (position < spanOrGap) {
-          long left = Math.min(spanOrGap - position, length);
-          return (i & 1) == 1 ? -left : left;
-        }
-        position -= spanOrGap;
-      }
-      return -length;
-    }
-
-    @Override
-    public long getContentLength(String key) {
-      return contentLength;
-    }
-  }
-
-  @Mock(answer = Answers.CALLS_REAL_METHODS) private AbstractFakeCache mockCache;
-  private File tempFolder;
-  private SimpleCache cache;
-
-  @Before
-  public void setUp() throws Exception {
-    MockitoAnnotations.initMocks(this);
-    mockCache.init();
-    tempFolder = Util.createTempDirectory(RuntimeEnvironment.application, "ExoPlayerTest");
-    cache = new SimpleCache(tempFolder, new NoOpCacheEvictor());
-  }
-
-  @After
-  public void tearDown() throws Exception {
-    Util.recursiveDelete(tempFolder);
-  }
-
-  @Test
-  public void testGenerateKey() throws Exception {
-    assertThat(generateKey(EMPTY)).isNotNull();
-
-    Uri testUri = Uri.parse("test");
-    String key = CacheUtil.generateKey(testUri);
-    assertThat(key).isNotNull();
-
-    // Should generate the same key for the same input
-    assertThat(generateKey(testUri)).isEqualTo(key);
-
-    // Should generate different key for different input
-    assertThat(key.equals(generateKey(parse("test2")))).isFalse();
-  }
-
-  @Test
-  public void testGetKey() throws Exception {
-    Uri testUri = Uri.parse("test");
-    String key = "key";
-    // If DataSpec.key is present, returns it
-    assertThat(getKey(new DataSpec(testUri, 0, LENGTH_UNSET, key))).isEqualTo(key);
-    // If not generates a new one using DataSpec.uri
-    assertThat(getKey(new DataSpec(testUri, 0, LENGTH_UNSET, null)))
-        .isEqualTo(generateKey(testUri));
-  }
-
-  @Test
-  public void testGetCachedNoData() throws Exception {
-    CachingCounters counters = new CachingCounters();
-    CacheUtil.getCached(new DataSpec(Uri.parse("test")), mockCache, counters);
-
-    assertCounters(counters, 0, 0, C.LENGTH_UNSET);
-  }
-
-  @Test
-  public void testGetCachedDataUnknownLength() throws Exception {
-    // Mock there is 100 bytes cached at the beginning
-    mockCache.spansAndGaps = new int[] {100};
-    CachingCounters counters = new CachingCounters();
-    CacheUtil.getCached(new DataSpec(Uri.parse("test")), mockCache, counters);
-
-    assertCounters(counters, 100, 0, C.LENGTH_UNSET);
-  }
-
-  @Test
-  public void testGetCachedNoDataKnownLength() throws Exception {
-    mockCache.contentLength = 1000;
-    CachingCounters counters = new CachingCounters();
-    CacheUtil.getCached(new DataSpec(Uri.parse("test")), mockCache, counters);
-
-    assertCounters(counters, 0, 0, 1000);
-  }
-
-  @Test
-  public void testGetCached() throws Exception {
-    mockCache.contentLength = 1000;
-    mockCache.spansAndGaps = new int[] {100, 100, 200};
-    CachingCounters counters = new CachingCounters();
-    CacheUtil.getCached(new DataSpec(Uri.parse("test")), mockCache, counters);
-
-    assertCounters(counters, 300, 0, 1000);
-  }
-
-  @Test
-  public void testCache() throws Exception {
-    FakeDataSet fakeDataSet = new FakeDataSet().setRandomData("test_data", 100);
-    FakeDataSource dataSource = new FakeDataSource(fakeDataSet);
-
-    CachingCounters counters = new CachingCounters();
-    CacheUtil.cache(new DataSpec(Uri.parse("test_data")), cache, dataSource, counters);
-
-    assertCounters(counters, 0, 100, 100);
-    assertCachedData(cache, fakeDataSet);
-  }
-
-  @Test
-  public void testCacheSetOffsetAndLength() throws Exception {
-    FakeDataSet fakeDataSet = new FakeDataSet().setRandomData("test_data", 100);
-    FakeDataSource dataSource = new FakeDataSource(fakeDataSet);
-
-    Uri testUri = Uri.parse("test_data");
-    DataSpec dataSpec = new DataSpec(testUri, 10, 20, null);
-    CachingCounters counters = new CachingCounters();
-    CacheUtil.cache(dataSpec, cache, dataSource, counters);
-
-    assertCounters(counters, 0, 20, 20);
-
-    CacheUtil.cache(new DataSpec(testUri), cache, dataSource, counters);
-
-    assertCounters(counters, 20, 80, 100);
-    assertCachedData(cache, fakeDataSet);
-  }
-
-  @Test
-  public void testCacheUnknownLength() throws Exception {
-    FakeDataSet fakeDataSet = new FakeDataSet().newData("test_data")
-        .setSimulateUnknownLength(true)
-        .appendReadData(TestUtil.buildTestData(100)).endData();
-    FakeDataSource dataSource = new FakeDataSource(fakeDataSet);
-
-    DataSpec dataSpec = new DataSpec(Uri.parse("test_data"));
-    CachingCounters counters = new CachingCounters();
-    CacheUtil.cache(dataSpec, cache, dataSource, counters);
-
-    assertCounters(counters, 0, 100, 100);
-    assertCachedData(cache, fakeDataSet);
-  }
-
-  @Test
-  public void testCacheUnknownLengthPartialCaching() throws Exception {
-    FakeDataSet fakeDataSet = new FakeDataSet().newData("test_data")
-        .setSimulateUnknownLength(true)
-        .appendReadData(TestUtil.buildTestData(100)).endData();
-    FakeDataSource dataSource = new FakeDataSource(fakeDataSet);
-
-    Uri testUri = Uri.parse("test_data");
-    DataSpec dataSpec = new DataSpec(testUri, 10, 20, null);
-    CachingCounters counters = new CachingCounters();
-    CacheUtil.cache(dataSpec, cache, dataSource, counters);
-
-    assertCounters(counters, 0, 20, 20);
-
-    CacheUtil.cache(new DataSpec(testUri), cache, dataSource, counters);
-
-    assertCounters(counters, 20, 80, 100);
-    assertCachedData(cache, fakeDataSet);
-  }
-
-  @Test
-  public void testCacheLengthExceedsActualDataLength() throws Exception {
-    FakeDataSet fakeDataSet = new FakeDataSet().setRandomData("test_data", 100);
-    FakeDataSource dataSource = new FakeDataSource(fakeDataSet);
-
-    Uri testUri = Uri.parse("test_data");
-    DataSpec dataSpec = new DataSpec(testUri, 0, 1000, null);
-    CachingCounters counters = new CachingCounters();
-    CacheUtil.cache(dataSpec, cache, dataSource, counters);
-
-    assertCounters(counters, 0, 100, 1000);
-    assertCachedData(cache, fakeDataSet);
-  }
-
-  @Test
-  public void testCacheThrowEOFException() throws Exception {
-    FakeDataSet fakeDataSet = new FakeDataSet().setRandomData("test_data", 100);
-    FakeDataSource dataSource = new FakeDataSource(fakeDataSet);
-
-    Uri testUri = Uri.parse("test_data");
-    DataSpec dataSpec = new DataSpec(testUri, 0, 1000, null);
-
-    try {
-      CacheUtil.cache(dataSpec, cache, new CacheDataSource(cache, dataSource),
-          new byte[CacheUtil.DEFAULT_BUFFER_SIZE_BYTES], null, 0, null,
-          /*enableEOFException*/ true);
-      fail();
-    } catch (EOFException e) {
-      // Do nothing.
-    }
-  }
-
-  @Test
-  public void testCachePolling() throws Exception {
-    final CachingCounters counters = new CachingCounters();
-    FakeDataSet fakeDataSet = new FakeDataSet().newData("test_data")
-        .appendReadData(TestUtil.buildTestData(100))
-        .appendReadAction(new Runnable() {
-          @Override
-          public void run() {
-            assertCounters(counters, 0, 100, 300);
-          }
-        })
-        .appendReadData(TestUtil.buildTestData(100))
-        .appendReadAction(new Runnable() {
-          @Override
-          public void run() {
-            assertCounters(counters, 0, 200, 300);
-          }
-        })
-        .appendReadData(TestUtil.buildTestData(100)).endData();
-    FakeDataSource dataSource = new FakeDataSource(fakeDataSet);
-
-    CacheUtil.cache(new DataSpec(Uri.parse("test_data")), cache, dataSource, counters);
-
-    assertCounters(counters, 0, 300, 300);
-    assertCachedData(cache, fakeDataSet);
-  }
-
-  @Test
-  public void testRemove() throws Exception {
-    FakeDataSet fakeDataSet = new FakeDataSet().setRandomData("test_data", 100);
-    FakeDataSource dataSource = new FakeDataSource(fakeDataSet);
-
-    Uri uri = Uri.parse("test_data");
-    CacheUtil.cache(new DataSpec(uri), cache,
-        // set maxCacheFileSize to 10 to make sure there are multiple spans
-        new CacheDataSource(cache, dataSource, 0, 10),
-        new byte[CacheUtil.DEFAULT_BUFFER_SIZE_BYTES], null, 0, null, true);
-    CacheUtil.remove(cache, CacheUtil.generateKey(uri));
-
-    assertCacheEmpty(cache);
-  }
-
-  private static void assertCounters(CachingCounters counters, int alreadyCachedBytes,
-      int newlyCachedBytes, int contentLength) {
-    assertThat(counters.alreadyCachedBytes).isEqualTo(alreadyCachedBytes);
-    assertThat(counters.newlyCachedBytes).isEqualTo(newlyCachedBytes);
-    assertThat(counters.contentLength).isEqualTo(contentLength);
-  }
-
-}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictorTest.java
deleted file mode 100644
index 6f7f567ae7..0000000000
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictorTest.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mockito;
-import org.mockito.MockitoAnnotations;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-/**
- * Unit tests for {@link LeastRecentlyUsedCacheEvictor}.
- */
-@RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
-public class LeastRecentlyUsedCacheEvictorTest {
-
-  @Before
-  public void setUp() throws Exception {
-    MockitoAnnotations.initMocks(this);
-  }
-
-  @Test
-  public void testContentBiggerThanMaxSizeDoesNotThrowException() throws Exception {
-    int maxBytes = 100;
-    LeastRecentlyUsedCacheEvictor evictor = new LeastRecentlyUsedCacheEvictor(maxBytes);
-    evictor.onCacheInitialized();
-    evictor.onStartFile(Mockito.mock(Cache.class), "key", 0, maxBytes + 1);
-  }
-
-}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
deleted file mode 100644
index d5894895b1..0000000000
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
+++ /dev/null
@@ -1,328 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-import static com.google.android.exoplayer2.C.LENGTH_UNSET;
-import static com.google.android.exoplayer2.util.Util.toByteArray;
-import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.Mockito.doAnswer;
-
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
-import com.google.android.exoplayer2.util.Util;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.util.NavigableSet;
-import java.util.Random;
-import java.util.Set;
-import org.junit.After;
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mockito;
-import org.mockito.MockitoAnnotations;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
-
-/**
- * Unit tests for {@link SimpleCache}.
- */
-@RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
-public class SimpleCacheTest {
-
-  private static final String KEY_1 = "key1";
-
-  private File cacheDir;
-
-  @Before
-  public void setUp() throws Exception {
-    MockitoAnnotations.initMocks(this);
-    cacheDir = Util.createTempDirectory(RuntimeEnvironment.application, "ExoPlayerTest");
-  }
-
-  @After
-  public void tearDown() throws Exception {
-    Util.recursiveDelete(cacheDir);
-  }
-
-  @Test
-  public void testCommittingOneFile() throws Exception {
-    SimpleCache simpleCache = getSimpleCache();
-
-    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
-    assertThat(cacheSpan1.isCached).isFalse();
-    assertThat(cacheSpan1.isOpenEnded()).isTrue();
-
-    assertThat(simpleCache.startReadWriteNonBlocking(KEY_1, 0)).isNull();
-
-    assertThat(simpleCache.getKeys()).isEmpty();
-    NavigableSet<CacheSpan> cachedSpans = simpleCache.getCachedSpans(KEY_1);
-    assertThat(cachedSpans == null || cachedSpans.isEmpty()).isTrue();
-    assertThat(simpleCache.getCacheSpace()).isEqualTo(0);
-    assertThat(cacheDir.listFiles()).hasLength(0);
-
-    addCache(simpleCache, KEY_1, 0, 15);
-
-    Set<String> cachedKeys = simpleCache.getKeys();
-    assertThat(cachedKeys).hasSize(1);
-    assertThat(cachedKeys.contains(KEY_1)).isTrue();
-    cachedSpans = simpleCache.getCachedSpans(KEY_1);
-    assertThat(cachedSpans).hasSize(1);
-    assertThat(cachedSpans.contains(cacheSpan1)).isTrue();
-    assertThat(simpleCache.getCacheSpace()).isEqualTo(15);
-
-    simpleCache.releaseHoleSpan(cacheSpan1);
-
-    CacheSpan cacheSpan2 = simpleCache.startReadWrite(KEY_1, 0);
-    assertThat(cacheSpan2.isCached).isTrue();
-    assertThat(cacheSpan2.isOpenEnded()).isFalse();
-    assertThat(cacheSpan2.length).isEqualTo(15);
-    assertCachedDataReadCorrect(cacheSpan2);
-  }
-
-  @Test
-  public void testReadCacheWithoutReleasingWriteCacheSpan() throws Exception {
-    SimpleCache simpleCache = getSimpleCache();
-
-    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
-    addCache(simpleCache, KEY_1, 0, 15);
-    CacheSpan cacheSpan2 = simpleCache.startReadWrite(KEY_1, 0);
-    assertCachedDataReadCorrect(cacheSpan2);
-    simpleCache.releaseHoleSpan(cacheSpan1);
-  }
-
-  @Test
-  public void testSetGetLength() throws Exception {
-    SimpleCache simpleCache = getSimpleCache();
-
-    assertThat(simpleCache.getContentLength(KEY_1)).isEqualTo(LENGTH_UNSET);
-    simpleCache.setContentLength(KEY_1, 15);
-    assertThat(simpleCache.getContentLength(KEY_1)).isEqualTo(15);
-
-    simpleCache.startReadWrite(KEY_1, 0);
-
-    addCache(simpleCache, KEY_1, 0, 15);
-
-    simpleCache.setContentLength(KEY_1, 150);
-    assertThat(simpleCache.getContentLength(KEY_1)).isEqualTo(150);
-
-    addCache(simpleCache, KEY_1, 140, 10);
-
-    // Check if values are kept after cache is reloaded.
-    SimpleCache simpleCache2 = getSimpleCache();
-    Set<String> keys = simpleCache.getKeys();
-    Set<String> keys2 = simpleCache2.getKeys();
-    assertThat(keys2).isEqualTo(keys);
-    for (String key : keys) {
-      assertThat(simpleCache2.getContentLength(key)).isEqualTo(simpleCache.getContentLength(key));
-      assertThat(simpleCache2.getCachedSpans(key)).isEqualTo(simpleCache.getCachedSpans(key));
-    }
-
-    // Removing the last span shouldn't cause the length be change next time cache loaded
-    SimpleCacheSpan lastSpan = simpleCache2.startReadWrite(KEY_1, 145);
-    simpleCache2.removeSpan(lastSpan);
-    simpleCache2 = getSimpleCache();
-    assertThat(simpleCache2.getContentLength(KEY_1)).isEqualTo(150);
-  }
-
-  @Test
-  public void testReloadCache() throws Exception {
-    SimpleCache simpleCache = getSimpleCache();
-
-    // write data
-    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
-    addCache(simpleCache, KEY_1, 0, 15);
-    simpleCache.releaseHoleSpan(cacheSpan1);
-
-    // Reload cache
-    simpleCache = getSimpleCache();
-
-    // read data back
-    CacheSpan cacheSpan2 = simpleCache.startReadWrite(KEY_1, 0);
-    assertCachedDataReadCorrect(cacheSpan2);
-  }
-
-  @Test
-  public void testEncryptedIndex() throws Exception {
-    byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
-    SimpleCache simpleCache = getEncryptedSimpleCache(key);
-
-    // write data
-    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
-    addCache(simpleCache, KEY_1, 0, 15);
-    simpleCache.releaseHoleSpan(cacheSpan1);
-
-    // Reload cache
-    simpleCache = getEncryptedSimpleCache(key);
-
-    // read data back
-    CacheSpan cacheSpan2 = simpleCache.startReadWrite(KEY_1, 0);
-    assertCachedDataReadCorrect(cacheSpan2);
-  }
-
-  @Test
-  public void testEncryptedIndexWrongKey() throws Exception {
-    byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
-    SimpleCache simpleCache = getEncryptedSimpleCache(key);
-
-    // write data
-    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
-    addCache(simpleCache, KEY_1, 0, 15);
-    simpleCache.releaseHoleSpan(cacheSpan1);
-
-    // Reload cache
-    byte[] key2 = "Foo12345Foo12345".getBytes(C.UTF8_NAME); // 128 bit key
-    simpleCache = getEncryptedSimpleCache(key2);
-
-    // Cache should be cleared
-    assertThat(simpleCache.getKeys()).isEmpty();
-    assertThat(cacheDir.listFiles()).hasLength(0);
-  }
-
-  @Test
-  public void testEncryptedIndexLostKey() throws Exception {
-    byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
-    SimpleCache simpleCache = getEncryptedSimpleCache(key);
-
-    // write data
-    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
-    addCache(simpleCache, KEY_1, 0, 15);
-    simpleCache.releaseHoleSpan(cacheSpan1);
-
-    // Reload cache
-    simpleCache = getSimpleCache();
-
-    // Cache should be cleared
-    assertThat(simpleCache.getKeys()).isEmpty();
-    assertThat(cacheDir.listFiles()).hasLength(0);
-  }
-
-  @Test
-  public void testGetCachedBytes() throws Exception {
-    SimpleCache simpleCache = getSimpleCache();
-    CacheSpan cacheSpan = simpleCache.startReadWrite(KEY_1, 0);
-
-    // No cached bytes, returns -'length'
-    assertThat(simpleCache.getCachedBytes(KEY_1, 0, 100)).isEqualTo(-100);
-
-    // Position value doesn't affect the return value
-    assertThat(simpleCache.getCachedBytes(KEY_1, 20, 100)).isEqualTo(-100);
-
-    addCache(simpleCache, KEY_1, 0, 15);
-
-    // Returns the length of a single span
-    assertThat(simpleCache.getCachedBytes(KEY_1, 0, 100)).isEqualTo(15);
-
-    // Value is capped by the 'length'
-    assertThat(simpleCache.getCachedBytes(KEY_1, 0, 10)).isEqualTo(10);
-
-    addCache(simpleCache, KEY_1, 15, 35);
-
-    // Returns the length of two adjacent spans
-    assertThat(simpleCache.getCachedBytes(KEY_1, 0, 100)).isEqualTo(50);
-
-    addCache(simpleCache, KEY_1, 60, 10);
-
-    // Not adjacent span doesn't affect return value
-    assertThat(simpleCache.getCachedBytes(KEY_1, 0, 100)).isEqualTo(50);
-
-    // Returns length of hole up to the next cached span
-    assertThat(simpleCache.getCachedBytes(KEY_1, 55, 100)).isEqualTo(-5);
-
-    simpleCache.releaseHoleSpan(cacheSpan);
-  }
-
-  /* Tests https://github.com/google/ExoPlayer/issues/3260 case. */
-  @Test
-  public void testExceptionDuringEvictionByLeastRecentlyUsedCacheEvictorNotHang() throws Exception {
-    CachedContentIndex index = Mockito.spy(new CachedContentIndex(cacheDir));
-    SimpleCache simpleCache =
-        new SimpleCache(cacheDir, new LeastRecentlyUsedCacheEvictor(20), index);
-
-    // Add some content.
-    CacheSpan cacheSpan = simpleCache.startReadWrite(KEY_1, 0);
-    addCache(simpleCache, KEY_1, 0, 15);
-
-    // Make index.store() throw exception from now on.
-    doAnswer(new Answer<Object>() {
-      @Override
-      public Object answer(InvocationOnMock invocation) throws Throwable {
-        throw new Cache.CacheException("SimpleCacheTest");
-      }
-    }).when(index).store();
-
-    // Adding more content will make LeastRecentlyUsedCacheEvictor evict previous content.
-    try {
-      addCache(simpleCache, KEY_1, 15, 15);
-      Assert.fail("Exception was expected");
-    } catch (CacheException e) {
-      // do nothing.
-    }
-
-    simpleCache.releaseHoleSpan(cacheSpan);
-
-    // Although store() has failed, it should remove the first span and add the new one.
-    NavigableSet<CacheSpan> cachedSpans = simpleCache.getCachedSpans(KEY_1);
-    assertThat(cachedSpans).isNotNull();
-    assertThat(cachedSpans).hasSize(1);
-    assertThat(cachedSpans.pollFirst().position).isEqualTo(15);
-  }
-
-  private SimpleCache getSimpleCache() {
-    return new SimpleCache(cacheDir, new NoOpCacheEvictor());
-  }
-
-  private SimpleCache getEncryptedSimpleCache(byte[] secretKey) {
-    return new SimpleCache(cacheDir, new NoOpCacheEvictor(), secretKey);
-  }
-
-  private static void addCache(SimpleCache simpleCache, String key, int position, int length)
-      throws IOException {
-    File file = simpleCache.startFile(key, position, length);
-    FileOutputStream fos = new FileOutputStream(file);
-    try {
-      fos.write(generateData(key, position, length));
-    } finally {
-      fos.close();
-    }
-    simpleCache.commitFile(file);
-  }
-
-  private static void assertCachedDataReadCorrect(CacheSpan cacheSpan) throws IOException {
-    assertThat(cacheSpan.isCached).isTrue();
-    byte[] expected = generateData(cacheSpan.key, (int) cacheSpan.position, (int) cacheSpan.length);
-    FileInputStream inputStream = new FileInputStream(cacheSpan.file);
-    try {
-      assertThat(toByteArray(inputStream)).isEqualTo(expected);
-    } finally {
-      inputStream.close();
-    }
-  }
-
-  private static byte[] generateData(String key, int position, int length) {
-    byte[] bytes = new byte[length];
-    new Random((long) (key.hashCode() ^ position)).nextBytes(bytes);
-    return bytes;
-  }
-
-}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java
deleted file mode 100644
index 833a7e10c1..0000000000
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java
+++ /dev/null
@@ -1,203 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.crypto;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import com.google.android.exoplayer2.testutil.TestUtil;
-import com.google.android.exoplayer2.util.Util;
-import java.util.Random;
-import javax.crypto.Cipher;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
-
-/**
- * Unit tests for {@link AesFlushingCipher}.
- */
-@RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
-public class AesFlushingCipherTest {
-
-  private static final int DATA_LENGTH = 65536;
-  private static final byte[] KEY = Util.getUtf8Bytes("testKey:12345678");
-  private static final long NONCE = 0;
-  private static final long START_OFFSET = 11;
-  private static final long RANDOM_SEED = 0x12345678;
-
-  private AesFlushingCipher encryptCipher;
-  private AesFlushingCipher decryptCipher;
-
-  @Before
-  public void setUp() {
-    encryptCipher = new AesFlushingCipher(Cipher.ENCRYPT_MODE, KEY, NONCE, START_OFFSET);
-    decryptCipher = new AesFlushingCipher(Cipher.DECRYPT_MODE, KEY, NONCE, START_OFFSET);
-  }
-
-  @After
-  public void tearDown() {
-    encryptCipher = null;
-    decryptCipher = null;
-  }
-
-  private static long getMaxUnchangedBytesAllowedPostEncryption(long length) {
-    // Assuming that not more than 10% of the resultant bytes should be identical.
-    // The value of 10% is arbitrary, ciphers standards do not name a value.
-    return length / 10;
-  }
-
-  // Count the number of bytes that do not match.
-  private static int getDifferingByteCount(byte[] data1, byte[] data2, int startOffset) {
-    int count = 0;
-    for (int i = startOffset; i < data1.length; i++) {
-      if (data1[i] != data2[i]) {
-        count++;
-      }
-    }
-    return count;
-  }
-
-  // Count the number of bytes that do not match.
-  private static int getDifferingByteCount(byte[] data1, byte[] data2) {
-    return getDifferingByteCount(data1, data2, 0);
-  }
-
-  // Test a single encrypt and decrypt call.
-  @Test
-  public void testSingle() {
-    byte[] reference = TestUtil.buildTestData(DATA_LENGTH);
-    byte[] data = reference.clone();
-
-    encryptCipher.updateInPlace(data, 0, data.length);
-    int unchangedByteCount = data.length - getDifferingByteCount(reference, data);
-    assertThat(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length))
-        .isTrue();
-
-    decryptCipher.updateInPlace(data, 0, data.length);
-    int differingByteCount = getDifferingByteCount(reference, data);
-    assertThat(differingByteCount).isEqualTo(0);
-  }
-
-  // Test several encrypt and decrypt calls, each aligned on a 16 byte block size.
-  @Test
-  public void testAligned() {
-    byte[] reference = TestUtil.buildTestData(DATA_LENGTH);
-    byte[] data = reference.clone();
-    Random random = new Random(RANDOM_SEED);
-
-    int offset = 0;
-    while (offset < data.length) {
-      int bytes = (1 + random.nextInt(50)) * 16;
-      bytes = Math.min(bytes, data.length - offset);
-      assertThat(bytes % 16).isEqualTo(0);
-      encryptCipher.updateInPlace(data, offset, bytes);
-      offset += bytes;
-    }
-
-    int unchangedByteCount = data.length - getDifferingByteCount(reference, data);
-    assertThat(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length))
-        .isTrue();
-
-    offset = 0;
-    while (offset < data.length) {
-      int bytes = (1 + random.nextInt(50)) * 16;
-      bytes = Math.min(bytes, data.length - offset);
-      assertThat(bytes % 16).isEqualTo(0);
-      decryptCipher.updateInPlace(data, offset, bytes);
-      offset += bytes;
-    }
-
-    int differingByteCount = getDifferingByteCount(reference, data);
-    assertThat(differingByteCount).isEqualTo(0);
-  }
-
-  // Test several encrypt and decrypt calls, not aligned on block boundary.
-  @Test
-  public void testUnAligned() {
-    byte[] reference = TestUtil.buildTestData(DATA_LENGTH);
-    byte[] data = reference.clone();
-    Random random = new Random(RANDOM_SEED);
-
-    // Encrypt
-    int offset = 0;
-    while (offset < data.length) {
-      int bytes = 1 + random.nextInt(4095);
-      bytes = Math.min(bytes, data.length - offset);
-      encryptCipher.updateInPlace(data, offset, bytes);
-      offset += bytes;
-    }
-
-    int unchangedByteCount = data.length - getDifferingByteCount(reference, data);
-    assertThat(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length))
-        .isTrue();
-
-    offset = 0;
-    while (offset < data.length) {
-      int bytes = 1 + random.nextInt(4095);
-      bytes = Math.min(bytes, data.length - offset);
-      decryptCipher.updateInPlace(data, offset, bytes);
-      offset += bytes;
-    }
-
-    int differingByteCount = getDifferingByteCount(reference, data);
-    assertThat(differingByteCount).isEqualTo(0);
-  }
-
-  // Test decryption starting from the middle of an encrypted block.
-  @Test
-  public void testMidJoin() {
-    byte[] reference = TestUtil.buildTestData(DATA_LENGTH);
-    byte[] data = reference.clone();
-    Random random = new Random(RANDOM_SEED);
-
-    // Encrypt
-    int offset = 0;
-    while (offset < data.length) {
-      int bytes = 1 + random.nextInt(4095);
-      bytes = Math.min(bytes, data.length - offset);
-      encryptCipher.updateInPlace(data, offset, bytes);
-      offset += bytes;
-    }
-
-    // Verify
-    int unchangedByteCount = data.length - getDifferingByteCount(reference, data);
-    assertThat(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length))
-        .isTrue();
-
-    // Setup decryption from random location
-    offset = random.nextInt(4096);
-    decryptCipher = new AesFlushingCipher(Cipher.DECRYPT_MODE, KEY, NONCE, offset + START_OFFSET);
-    int remainingLength = data.length - offset;
-    int originalOffset = offset;
-
-    // Decrypt
-    while (remainingLength > 0) {
-      int bytes = 1 + random.nextInt(4095);
-      bytes = Math.min(bytes, remainingLength);
-      decryptCipher.updateInPlace(data, offset, bytes);
-      offset += bytes;
-      remainingLength -= bytes;
-    }
-
-    // Verify
-    int differingByteCount = getDifferingByteCount(reference, data, originalOffset);
-    assertThat(differingByteCount).isEqualTo(0);
-  }
-
-}
diff --git a/testutils/aio.gradle b/testutils/aio.gradle
new file mode 100644
index 0000000000..b187e0606a
--- /dev/null
+++ b/testutils/aio.gradle
@@ -0,0 +1,13 @@
+apply plugin: 'com.android.library'
+
+android {
+}
+
+hello { task ->
+    println "$task.project.name " +  "-> okay!"
+}
+
+dependencies {
+    compile project(":exoplayer2-library-core")
+    compile 'org.mockito:mockito-core:' + mockitoVersion
+}
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java
deleted file mode 100644
index 82fff0d4fe..0000000000
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.testutil;
-
-import static junit.framework.Assert.assertEquals;
-
-import android.net.Uri;
-import android.test.MoreAsserts;
-import com.google.android.exoplayer2.testutil.FakeDataSet.FakeData;
-import com.google.android.exoplayer2.upstream.DataSourceInputStream;
-import com.google.android.exoplayer2.upstream.DataSpec;
-import com.google.android.exoplayer2.upstream.DummyDataSource;
-import com.google.android.exoplayer2.upstream.cache.Cache;
-import com.google.android.exoplayer2.upstream.cache.CacheDataSource;
-import com.google.android.exoplayer2.upstream.cache.CacheUtil;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.util.ArrayList;
-import junit.framework.Assert;
-
-/**
- * Assertion methods for {@link Cache}.
- */
-public final class CacheAsserts {
-
-  /** Asserts that the cache content is equal to the data in the {@code fakeDataSet}. */
-  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet) throws IOException {
-    ArrayList<FakeData> allData = fakeDataSet.getAllData();
-    Uri[] uris = new Uri[allData.size()];
-    for (int i = 0; i < allData.size(); i++) {
-      uris[i] = allData.get(i).uri;
-    }
-    assertCachedData(cache, fakeDataSet, uris);
-  }
-
-  /**
-   * Asserts that the cache content is equal to the given subset of data in the {@code fakeDataSet}.
-   */
-  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, String... uriStrings)
-      throws IOException {
-    Uri[] uris = new Uri[uriStrings.length];
-    for (int i = 0; i < uriStrings.length; i++) {
-      uris[i] = Uri.parse(uriStrings[i]);
-    }
-    assertCachedData(cache, fakeDataSet, uris);
-  }
-
-  /**
-   * Asserts that the cache content is equal to the given subset of data in the {@code fakeDataSet}.
-   */
-  public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, Uri... uris)
-      throws IOException {
-    int totalLength = 0;
-    for (Uri uri : uris) {
-      byte[] data = fakeDataSet.getData(uri).getData();
-      assertDataCached(cache, uri, data);
-      totalLength += data.length;
-    }
-    assertEquals(totalLength, cache.getCacheSpace());
-  }
-
-  /** Asserts that the cache contains the given subset of data in the {@code fakeDataSet}. */
-  public static void assertDataCached(Cache cache, FakeDataSet fakeDataSet, Uri... uris)
-      throws IOException {
-    for (Uri uri : uris) {
-      assertDataCached(cache, uri, fakeDataSet.getData(uri).getData());
-    }
-  }
-
-  /** Asserts that the cache contains the given data for {@code uriString}. */
-  public static void assertDataCached(Cache cache, Uri uri, byte[] expected) throws IOException {
-    CacheDataSource dataSource = new CacheDataSource(cache, DummyDataSource.INSTANCE, 0);
-    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
-    DataSourceInputStream inputStream = new DataSourceInputStream(dataSource,
-        new DataSpec(uri, DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH));
-    try {
-      inputStream.open();
-      byte[] buffer = new byte[1024];
-      int bytesRead;
-      while ((bytesRead = inputStream.read(buffer)) != -1) {
-        outputStream.write(buffer, 0, bytesRead);
-      }
-    } catch (IOException e) {
-      // Ignore
-    } finally {
-      inputStream.close();
-    }
-    MoreAsserts.assertEquals("Cached data doesn't match expected for '" + uri + "',",
-        expected, outputStream.toByteArray());
-  }
-
-  /** Asserts that there is no cache content for the given {@code uriStrings}. */
-  public static void assertDataNotCached(Cache cache, String... uriStrings) {
-    for (String uriString : uriStrings) {
-      Assert.assertNull("There is cached data for '" + uriString + "',",
-          cache.getCachedSpans(CacheUtil.generateKey(Uri.parse(uriString))));
-    }
-  }
-
-  /** Asserts that the cache is empty. */
-  public static void assertCacheEmpty(Cache cache) {
-    assertEquals(0, cache.getCacheSpace());
-  }
-
-  private CacheAsserts() {}
-
-}
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java
index 1ef1acd80b..e17ea6e4d4 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java
@@ -160,7 +160,7 @@ public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     requestWindowFeature(Window.FEATURE_NO_TITLE);
     setContentView(getResources().getIdentifier("host_activity", "layout", getPackageName()));
-    surfaceView = findViewById(
+    surfaceView = (SurfaceView) findViewById(
         getResources().getIdentifier("surface_view", "id", getPackageName()));
     surfaceView.getHolder().addCallback(this);
   }
