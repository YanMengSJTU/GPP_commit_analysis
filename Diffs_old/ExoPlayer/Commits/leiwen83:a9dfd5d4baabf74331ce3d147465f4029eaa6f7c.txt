diff --git a/library/src/androidTest/java/com/google/android/exoplayer/MediaFormatTest.java b/library/src/androidTest/java/com/google/android/exoplayer/MediaFormatTest.java
index 9339f7c6f2..a1f80bc79b 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/MediaFormatTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/MediaFormatTest.java
@@ -45,7 +45,7 @@
   public void testParcelable() {
     MediaFormat formatToParcel = new MediaFormat("id", MimeTypes.VIDEO_H264, 1024, 2048,
         C.UNKNOWN_TIME_US, 1920, 1080, 90, 2, 6, 44100, "und", MediaFormat.OFFSET_SAMPLE_RELATIVE,
-        INIT_DATA, false, 5000, 5001, 5002, 5003, 5004);
+        INIT_DATA, false, 5000, 5001, 5002, 5003, 5004, null, C.STEREO_MODE_TOP_BOTTOM);
 
     Parcel parcel = Parcel.obtain();
     formatToParcel.writeToParcel(parcel, 0);
diff --git a/library/src/main/java/com/google/android/exoplayer/C.java b/library/src/main/java/com/google/android/exoplayer/C.java
index 4f22c3f06f..2870680548 100644
--- a/library/src/main/java/com/google/android/exoplayer/C.java
+++ b/library/src/main/java/com/google/android/exoplayer/C.java
@@ -140,6 +140,21 @@
    */
   public static final int RESULT_MAX_LENGTH_EXCEEDED = -2;
 
+  /**
+   * Indicates Monoscopic stereo layout, used with 360/3D/VR videos.
+   */
+  public static final int STEREO_MODE_MONO = 0;
+
+  /**
+   * Indicates Top-Bottom stereo layout, used with 360/3D/VR videos.
+   */
+  public static final int STEREO_MODE_TOP_BOTTOM = 1;
+
+  /**
+   * Indicates Left-Right stereo layout, used with 360/3D/VR videos.
+   */
+  public static final int STEREO_MODE_LEFT_RIGHT = 2;
+
   private C() {}
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
index f6e1d0cd21..b114e374e0 100644
--- a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
@@ -329,7 +329,8 @@ private static MediaFormat createMediaFormat(android.media.MediaFormat format) {
     MediaFormat mediaFormat = new MediaFormat(null, mimeType, MediaFormat.NO_VALUE, maxInputSize,
         durationUs, width, height, rotationDegrees, MediaFormat.NO_VALUE, channelCount, sampleRate,
         language, MediaFormat.OFFSET_SAMPLE_RELATIVE, initializationData, false,
-        MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, pcmEncoding, encoderDelay, encoderPadding);
+        MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, pcmEncoding, encoderDelay, encoderPadding,
+        null, MediaFormat.NO_VALUE);
     mediaFormat.setFrameworkFormatV16(format);
     return mediaFormat;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
index 2051acf48f..15c9b58f41 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
@@ -110,6 +110,18 @@
    */
   public final float pixelWidthHeightRatio;
 
+  /**
+   * The stereo layout for 360/3D/VR video, or {@link #NO_VALUE} if not applicable. Valid stereo
+   * modes are {@link C#STEREO_MODE_MONO}, {@link C#STEREO_MODE_TOP_BOTTOM}, {@link
+   * C#STEREO_MODE_LEFT_RIGHT}.
+   */
+  public final int stereoMode;
+
+  /**
+   * The projection data for 360/VR video, or null if not applicable.
+   */
+  public final byte[] projectionData;
+
   // Audio specific.
 
   /**
@@ -157,7 +169,7 @@
   public static MediaFormat createVideoFormat(String trackId, String mimeType, int bitrate,
       int maxInputSize, long durationUs, int width, int height, List<byte[]> initializationData) {
     return createVideoFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
-        initializationData, NO_VALUE, NO_VALUE);
+        initializationData, NO_VALUE, NO_VALUE, null, NO_VALUE);
   }
 
   public static MediaFormat createVideoFormat(String trackId, String mimeType, int bitrate,
@@ -165,7 +177,18 @@ public static MediaFormat createVideoFormat(String trackId, String mimeType, int
       int rotationDegrees, float pixelWidthHeightRatio) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, NO_VALUE, NO_VALUE, null, OFFSET_SAMPLE_RELATIVE,
-        initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
+        initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null,
+        NO_VALUE);
+  }
+
+  public static MediaFormat createVideoFormat(String trackId, String mimeType, int bitrate,
+      int maxInputSize, long durationUs, int width, int height, List<byte[]> initializationData,
+      int rotationDegrees, float pixelWidthHeightRatio, byte[] projectionData,
+      int stereoMode) {
+    return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
+        rotationDegrees, pixelWidthHeightRatio, NO_VALUE, NO_VALUE, null, OFFSET_SAMPLE_RELATIVE,
+        initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
+        projectionData, stereoMode);
   }
 
   public static MediaFormat createAudioFormat(String trackId, String mimeType, int bitrate,
@@ -180,7 +203,8 @@ public static MediaFormat createAudioFormat(String trackId, String mimeType, int
       List<byte[]> initializationData, String language, int pcmEncoding) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, channelCount, sampleRate, language, OFFSET_SAMPLE_RELATIVE,
-        initializationData, false, NO_VALUE, NO_VALUE, pcmEncoding, NO_VALUE, NO_VALUE);
+        initializationData, false, NO_VALUE, NO_VALUE, pcmEncoding, NO_VALUE, NO_VALUE, null,
+        NO_VALUE);
   }
 
   public static MediaFormat createTextFormat(String trackId, String mimeType, int bitrate,
@@ -193,21 +217,22 @@ public static MediaFormat createTextFormat(String trackId, String mimeType, int
       long durationUs, String language, long subsampleOffsetUs) {
     return new MediaFormat(trackId, mimeType, bitrate, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, language, subsampleOffsetUs, null, false, NO_VALUE,
-        NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
+        NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE);
   }
 
   public static MediaFormat createImageFormat(String trackId, String mimeType, int bitrate,
       long durationUs, List<byte[]> initializationData, String language) {
     return new MediaFormat(trackId, mimeType, bitrate, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, language, OFFSET_SAMPLE_RELATIVE,
-        initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
+        initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null,
+        NO_VALUE);
   }
 
   public static MediaFormat createFormatForMimeType(String trackId, String mimeType, int bitrate,
       long durationUs) {
     return new MediaFormat(trackId, mimeType, bitrate, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, OFFSET_SAMPLE_RELATIVE, null, false, NO_VALUE,
-        NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
+        NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE);
   }
 
   public static MediaFormat createId3Format() {
@@ -237,13 +262,17 @@ public static MediaFormat createId3Format() {
     pcmEncoding = in.readInt();
     encoderDelay = in.readInt();
     encoderPadding = in.readInt();
+    boolean hasProjectionData = in.readInt() != 0;
+    projectionData = hasProjectionData ? in.createByteArray() : null;
+    stereoMode = in.readInt();
   }
 
   /* package */ MediaFormat(String trackId, String mimeType, int bitrate, int maxInputSize,
       long durationUs, int width, int height, int rotationDegrees, float pixelWidthHeightRatio,
       int channelCount, int sampleRate, String language, long subsampleOffsetUs,
       List<byte[]> initializationData, boolean adaptive, int maxWidth, int maxHeight,
-      int pcmEncoding, int encoderDelay, int encoderPadding) {
+      int pcmEncoding, int encoderDelay, int encoderPadding, byte[] projectionData,
+      int stereoMode) {
     this.trackId = trackId;
     this.mimeType = Assertions.checkNotEmpty(mimeType);
     this.bitrate = bitrate;
@@ -265,41 +294,43 @@ public static MediaFormat createId3Format() {
     this.pcmEncoding = pcmEncoding;
     this.encoderDelay = encoderDelay;
     this.encoderPadding = encoderPadding;
+    this.projectionData = projectionData;
+    this.stereoMode = stereoMode;
   }
 
   public MediaFormat copyWithMaxInputSize(int maxInputSize) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
         subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
-        encoderDelay, encoderPadding);
+        encoderDelay, encoderPadding, projectionData, stereoMode);
   }
 
   public MediaFormat copyWithMaxVideoDimensions(int maxWidth, int maxHeight) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
         subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
-        encoderDelay, encoderPadding);
+        encoderDelay, encoderPadding, projectionData, stereoMode);
   }
 
   public MediaFormat copyWithSubsampleOffsetUs(long subsampleOffsetUs) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
         subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
-        encoderDelay, encoderPadding);
+        encoderDelay, encoderPadding, projectionData, stereoMode);
   }
 
   public MediaFormat copyWithDurationUs(long durationUs) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
         subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
-        encoderDelay, encoderPadding);
+        encoderDelay, encoderPadding, projectionData, stereoMode);
   }
 
   public MediaFormat copyWithLanguage(String language) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
         subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
-        encoderDelay, encoderPadding);
+        encoderDelay, encoderPadding, projectionData, stereoMode);
   }
 
   public MediaFormat copyWithFixedTrackInfo(String trackId, int bitrate, int width, int height,
@@ -307,20 +338,20 @@ public MediaFormat copyWithFixedTrackInfo(String trackId, int bitrate, int width
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
         subsampleOffsetUs, initializationData, adaptive, NO_VALUE, NO_VALUE, pcmEncoding,
-        encoderDelay, encoderPadding);
+        encoderDelay, encoderPadding, projectionData, stereoMode);
   }
 
   public MediaFormat copyAsAdaptive(String trackId) {
     return new MediaFormat(trackId, mimeType, NO_VALUE, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, OFFSET_SAMPLE_RELATIVE, null, true, maxWidth,
-        maxHeight, NO_VALUE, NO_VALUE, NO_VALUE);
+        maxHeight, NO_VALUE, NO_VALUE, NO_VALUE, null, stereoMode);
   }
 
   public MediaFormat copyWithGaplessInfo(int encoderDelay, int encoderPadding) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
         subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
-        encoderDelay, encoderPadding);
+        encoderDelay, encoderPadding, projectionData, stereoMode);
   }
 
   /**
@@ -401,6 +432,8 @@ public int hashCode() {
       for (int i = 0; i < initializationData.size(); i++) {
         result = 31 * result + Arrays.hashCode(initializationData.get(i));
       }
+      result = 31 * result + Arrays.hashCode(projectionData);
+      result = 31 * result + stereoMode;
       hashCode = result;
     }
     return hashCode;
@@ -425,7 +458,9 @@ public boolean equals(Object obj) {
         || encoderPadding != other.encoderPadding || subsampleOffsetUs != other.subsampleOffsetUs
         || !Util.areEqual(trackId, other.trackId) || !Util.areEqual(language, other.language)
         || !Util.areEqual(mimeType, other.mimeType)
-        || initializationData.size() != other.initializationData.size()) {
+        || initializationData.size() != other.initializationData.size()
+        || !Arrays.equals(projectionData, other.projectionData)
+        || stereoMode != other.stereoMode) {
       return false;
     }
     for (int i = 0; i < initializationData.size(); i++) {
@@ -481,6 +516,11 @@ public void writeToParcel(Parcel dest, int flags) {
     dest.writeInt(pcmEncoding);
     dest.writeInt(encoderDelay);
     dest.writeInt(encoderPadding);
+    dest.writeInt(projectionData != null ? 1 : 0);
+    if (projectionData != null) {
+      dest.writeByteArray(projectionData);
+    }
+    dest.writeInt(stereoMode);
   }
 
   public static final Creator<MediaFormat> CREATOR = new Creator<MediaFormat>() {
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
index 938b1e3b86..67f6bbf516 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
@@ -126,6 +126,9 @@
   public static final int TYPE_name = Util.getIntegerCodeForString("name");
   public static final int TYPE_data = Util.getIntegerCodeForString("data");
   public static final int TYPE_emsg = Util.getIntegerCodeForString("emsg");
+  public static final int TYPE_st3d = Util.getIntegerCodeForString("st3d");
+  public static final int TYPE_sv3d = Util.getIntegerCodeForString("sv3d");
+  public static final int TYPE_proj = Util.getIntegerCodeForString("proj");
   public static final int TYPE_vp08 = Util.getIntegerCodeForString("vp08");
   public static final int TYPE_vp09 = Util.getIntegerCodeForString("vp09");
   public static final int TYPE_vpcC = Util.getIntegerCodeForString("vpcC");
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
index 4fa1132937..63564ba245 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
@@ -29,6 +29,7 @@
 import com.google.android.exoplayer.util.ParsableByteArray;
 import com.google.android.exoplayer.util.Util;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
@@ -614,6 +615,8 @@ private static void parseVideoSampleEntry(ParsableByteArray parent, int atomType
 
     List<byte[]> initializationData = null;
     String mimeType = null;
+    byte[] projectionData = null;
+    int stereoMode = MediaFormat.NO_VALUE;
     while (childPosition - position < size) {
       parent.setPosition(childPosition);
       int childStartPosition = parent.getPosition();
@@ -654,6 +657,27 @@ private static void parseVideoSampleEntry(ParsableByteArray parent, int atomType
       } else if (childAtomType == Atom.TYPE_vpcC) {
         Assertions.checkState(mimeType == null);
         mimeType = (atomType == Atom.TYPE_vp08) ? MimeTypes.VIDEO_VP8 : MimeTypes.VIDEO_VP9;
+      } else if (childAtomType == Atom.TYPE_sv3d) {
+        projectionData = parseProjFromParent(parent, childStartPosition, childAtomSize);
+      } else if (childAtomType == Atom.TYPE_st3d) {
+        int version = parent.readUnsignedByte();
+        parent.skipBytes(3); // Flags.
+        if (version == 0) {
+          int layout = parent.readUnsignedByte();
+          switch (layout) {
+            case 0:
+              stereoMode = C.STEREO_MODE_MONO;
+              break;
+            case 1:
+              stereoMode = C.STEREO_MODE_TOP_BOTTOM;
+              break;
+            case 2:
+              stereoMode = C.STEREO_MODE_LEFT_RIGHT;
+              break;
+            default:
+              break;
+          }
+        }
       }
       childPosition += childAtomSize;
     }
@@ -665,7 +689,7 @@ private static void parseVideoSampleEntry(ParsableByteArray parent, int atomType
 
     out.mediaFormat = MediaFormat.createVideoFormat(Integer.toString(trackId), mimeType,
         MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, durationUs, width, height, initializationData,
-        rotationDegrees, pixelWidthHeightRatio);
+        rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode);
   }
 
   private static AvcCData parseAvcCFromParent(ParsableByteArray parent, int position) {
@@ -1059,6 +1083,23 @@ private static TrackEncryptionBox parseSchiFromParent(ParsableByteArray parent,
     return null;
   }
 
+
+  /** Parses the proj box from sv3d box, as specified by https://github.com/google/spatial-media */
+  private static byte[] parseProjFromParent(ParsableByteArray parent, int position, int size) {
+    int childPosition = position + Atom.HEADER_SIZE;
+    while (childPosition - position < size) {
+      parent.setPosition(childPosition);
+      int childAtomSize = parent.readInt();
+      int childAtomType = parent.readInt();
+      if (childAtomType == Atom.TYPE_proj) {
+        return Arrays.copyOfRange(parent.data, childPosition, childPosition + childAtomSize);
+      }
+      childPosition += childAtomSize;
+    }
+    return null;
+  }
+
+
   /**
    * Parses the size of an expandable class, as specified by ISO 14496-1 subsection 8.3.3.
    */
