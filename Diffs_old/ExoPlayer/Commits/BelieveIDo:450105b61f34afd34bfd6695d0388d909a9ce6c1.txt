diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 25c3b2b4c2..f7a11eb0ec 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,5 +1,16 @@
 # Release notes #
 
+### Current dev branch (from r1.4.2) ###
+
+* Nothing yet.
+
+### r1.4.2 ###
+
+* Implemented automatic format detection for regular container formats.
+* Added UdpDataSource for connecting to multicast streams.
+* Improved robustness for MP4 playbacks.
+* Misc bug fixes.
+
 ### r1.4.1 ###
 
 * HLS: Fix premature playback failures that could occur in some cases.
diff --git a/build.gradle b/build.gradle
index fab548dc65..cd01d15c17 100644
--- a/build.gradle
+++ b/build.gradle
@@ -21,7 +21,7 @@ buildscript {
     }
     dependencies {
         classpath 'com.android.tools.build:gradle:1.2.3'
-        classpath 'com.novoda:bintray-release:0.2.7'
+        classpath 'com.novoda:bintray-release:0.3.2'
     }
 }
 
diff --git a/demo/src/main/AndroidManifest.xml b/demo/src/main/AndroidManifest.xml
index 18d69151b5..5212346bab 100644
--- a/demo/src/main/AndroidManifest.xml
+++ b/demo/src/main/AndroidManifest.xml
@@ -16,8 +16,8 @@
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer.demo"
-    android:versionCode="1401"
-    android:versionName="1.4.1"
+    android:versionCode="1402"
+    android:versionName="1.4.2"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java b/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
index f54dcfae58..a075f53971 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/PlayerActivity.java
@@ -26,12 +26,6 @@
 import com.google.android.exoplayer.demo.player.HlsRendererBuilder;
 import com.google.android.exoplayer.demo.player.SmoothStreamingRendererBuilder;
 import com.google.android.exoplayer.drm.UnsupportedDrmException;
-import com.google.android.exoplayer.extractor.mp3.Mp3Extractor;
-import com.google.android.exoplayer.extractor.mp4.FragmentedMp4Extractor;
-import com.google.android.exoplayer.extractor.mp4.Mp4Extractor;
-import com.google.android.exoplayer.extractor.ts.AdtsExtractor;
-import com.google.android.exoplayer.extractor.ts.TsExtractor;
-import com.google.android.exoplayer.extractor.webm.WebmExtractor;
 import com.google.android.exoplayer.metadata.GeobMetadata;
 import com.google.android.exoplayer.metadata.PrivMetadata;
 import com.google.android.exoplayer.metadata.TxxxMetadata;
@@ -84,14 +78,7 @@
   public static final int TYPE_DASH = 0;
   public static final int TYPE_SS = 1;
   public static final int TYPE_HLS = 2;
-  public static final int TYPE_MP4 = 3;
-  public static final int TYPE_MP3 = 4;
-  public static final int TYPE_FMP4 = 5;
-  public static final int TYPE_WEBM = 6;
-  public static final int TYPE_MKV = 7;
-  public static final int TYPE_TS = 8;
-  public static final int TYPE_AAC = 9;
-  public static final int TYPE_M4A = 10;
+  public static final int TYPE_OTHER = 3;
 
   public static final String CONTENT_TYPE_EXTRA = "content_type";
   public static final String CONTENT_ID_EXTRA = "content_id";
@@ -257,22 +244,8 @@ private RendererBuilder getRendererBuilder() {
             new WidevineTestMediaDrmCallback(contentId), audioCapabilities);
       case TYPE_HLS:
         return new HlsRendererBuilder(this, userAgent, contentUri.toString(), audioCapabilities);
-      case TYPE_M4A: // There are no file format differences between M4A and MP4.
-      case TYPE_MP4:
-        return new ExtractorRendererBuilder(this, userAgent, contentUri, new Mp4Extractor());
-      case TYPE_MP3:
-        return new ExtractorRendererBuilder(this, userAgent, contentUri, new Mp3Extractor());
-      case TYPE_TS:
-        return new ExtractorRendererBuilder(this, userAgent, contentUri,
-            new TsExtractor(0, audioCapabilities));
-      case TYPE_AAC:
-        return new ExtractorRendererBuilder(this, userAgent, contentUri, new AdtsExtractor());
-      case TYPE_FMP4:
-        return new ExtractorRendererBuilder(this, userAgent, contentUri,
-            new FragmentedMp4Extractor());
-      case TYPE_WEBM:
-      case TYPE_MKV:
-        return new ExtractorRendererBuilder(this, userAgent, contentUri, new WebmExtractor());
+      case TYPE_OTHER:
+        return new ExtractorRendererBuilder(this, userAgent, contentUri);
       default:
         throw new IllegalStateException("Unsupported type: " + contentType);
     }
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java b/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
index 551513161f..ef54b3ebc0 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java
@@ -128,28 +128,23 @@ public Sample(String name, String contentId, String uri, int type) {
   };
 
   public static final Sample[] MISC = new Sample[] {
-    new Sample("Dizzy", "http://html5demos.com/assets/dizzy.mp4",
-        PlayerActivity.TYPE_MP4),
+    new Sample("Dizzy", "http://html5demos.com/assets/dizzy.mp4", PlayerActivity.TYPE_OTHER),
     new Sample("Apple AAC 10s", "https://devimages.apple.com.edgekey.net/"
-        + "streaming/examples/bipbop_4x3/gear0/fileSequence0.aac",
-        PlayerActivity.TYPE_AAC),
+        + "streaming/examples/bipbop_4x3/gear0/fileSequence0.aac", PlayerActivity.TYPE_OTHER),
     new Sample("Apple TS 10s", "https://devimages.apple.com.edgekey.net/streaming/examples/"
-        + "bipbop_4x3/gear1/fileSequence0.ts",
-        PlayerActivity.TYPE_TS),
+        + "bipbop_4x3/gear1/fileSequence0.ts", PlayerActivity.TYPE_OTHER),
     new Sample("Android screens (Matroska)", "http://storage.googleapis.com/exoplayer-test-media-1/"
-        + "mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv", PlayerActivity.TYPE_MKV),
+        + "mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
+        PlayerActivity.TYPE_OTHER),
     new Sample("Big Buck Bunny (MP4 Video)",
         "http://redirector.c.youtube.com/videoplayback?id=604ed5ce52eda7ee&itag=22&source=youtube&"
         + "sparams=ip,ipbits,expire,source,id&ip=0.0.0.0&ipbits=0&expire=19000000000&signature="
         + "513F28C7FDCBEC60A66C86C9A393556C99DC47FB.04C88036EEE12565A1ED864A875A58F15D8B5300"
-        + "&key=ik0",
-        PlayerActivity.TYPE_MP4),
+        + "&key=ik0", PlayerActivity.TYPE_OTHER),
     new Sample("Google Play (MP3 Audio)",
-        "http://storage.googleapis.com/exoplayer-test-media-0/play.mp3",
-        PlayerActivity.TYPE_MP3),
+        "http://storage.googleapis.com/exoplayer-test-media-0/play.mp3", PlayerActivity.TYPE_OTHER),
     new Sample("Google Glass (WebM Video with Vorbis Audio)",
-        "http://demos.webmproject.org/exoplayer/glass_vp9_vorbis.webm",
-        PlayerActivity.TYPE_WEBM),
+        "http://demos.webmproject.org/exoplayer/glass_vp9_vorbis.webm", PlayerActivity.TYPE_OTHER),
   };
 
   private Samples() {}
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/DashRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/DashRendererBuilder.java
index 8f1d738064..a097db7745 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/DashRendererBuilder.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/DashRendererBuilder.java
@@ -41,7 +41,6 @@
 import com.google.android.exoplayer.dash.mpd.UtcTimingElementResolver;
 import com.google.android.exoplayer.dash.mpd.UtcTimingElementResolver.UtcTimingCallback;
 import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilder;
-import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilderCallback;
 import com.google.android.exoplayer.drm.MediaDrmCallback;
 import com.google.android.exoplayer.drm.StreamingDrmSessionManager;
 import com.google.android.exoplayer.drm.UnsupportedDrmException;
@@ -54,7 +53,6 @@
 import com.google.android.exoplayer.upstream.DefaultUriDataSource;
 import com.google.android.exoplayer.upstream.UriDataSource;
 import com.google.android.exoplayer.util.ManifestFetcher;
-import com.google.android.exoplayer.util.ManifestFetcher.ManifestCallback;
 import com.google.android.exoplayer.util.Util;
 
 import android.content.Context;
@@ -69,8 +67,7 @@
 /**
  * A {@link RendererBuilder} for DASH.
  */
-public class DashRendererBuilder implements RendererBuilder,
-    ManifestCallback<MediaPresentationDescription>, UtcTimingCallback {
+public class DashRendererBuilder implements RendererBuilder {
 
   private static final String TAG = "DashRendererBuilder";
 
@@ -102,13 +99,7 @@
   private final MediaDrmCallback drmCallback;
   private final AudioCapabilities audioCapabilities;
 
-  private DemoPlayer player;
-  private RendererBuilderCallback callback;
-  private ManifestFetcher<MediaPresentationDescription> manifestFetcher;
-  private UriDataSource manifestDataSource;
-
-  private MediaPresentationDescription manifest;
-  private long elapsedRealtimeOffset;
+  private AsyncRendererBuilder currentAsyncBuilder;
 
   public DashRendererBuilder(Context context, String userAgent, String url,
       MediaDrmCallback drmCallback, AudioCapabilities audioCapabilities) {
@@ -120,236 +111,294 @@ public DashRendererBuilder(Context context, String userAgent, String url,
   }
 
   @Override
-  public void buildRenderers(DemoPlayer player, RendererBuilderCallback callback) {
-    this.player = player;
-    this.callback = callback;
-    MediaPresentationDescriptionParser parser = new MediaPresentationDescriptionParser();
-    manifestDataSource = new DefaultUriDataSource(context, userAgent);
-    manifestFetcher = new ManifestFetcher<>(url, manifestDataSource, parser);
-    manifestFetcher.singleLoad(player.getMainHandler().getLooper(), this);
+  public void buildRenderers(DemoPlayer player) {
+    currentAsyncBuilder = new AsyncRendererBuilder(context, userAgent, url, drmCallback,
+        audioCapabilities, player);
+    currentAsyncBuilder.init();
   }
 
   @Override
-  public void onSingleManifest(MediaPresentationDescription manifest) {
-    this.manifest = manifest;
-    if (manifest.dynamic && manifest.utcTiming != null) {
-      UtcTimingElementResolver.resolveTimingElement(manifestDataSource, manifest.utcTiming,
-          manifestFetcher.getManifestLoadTimestamp(), this);
-    } else {
-      buildRenderers();
+  public void cancel() {
+    if (currentAsyncBuilder != null) {
+      currentAsyncBuilder.cancel();
+      currentAsyncBuilder = null;
     }
   }
 
-  @Override
-  public void onSingleManifestError(IOException e) {
-    callback.onRenderersError(e);
-  }
-
-  @Override
-  public void onTimestampResolved(UtcTimingElement utcTiming, long elapsedRealtimeOffset) {
-    this.elapsedRealtimeOffset = elapsedRealtimeOffset;
-    buildRenderers();
-  }
-
-  @Override
-  public void onTimestampError(UtcTimingElement utcTiming, IOException e) {
-    Log.e(TAG, "Failed to resolve UtcTiming element [" + utcTiming + "]", e);
-    // Be optimistic and continue in the hope that the device clock is correct.
-    buildRenderers();
-  }
-
-  private void buildRenderers() {
-    Period period = manifest.periods.get(0);
-    Handler mainHandler = player.getMainHandler();
-    LoadControl loadControl = new DefaultLoadControl(new DefaultAllocator(BUFFER_SEGMENT_SIZE));
-    DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter(mainHandler, player);
-
-    boolean hasContentProtection = false;
-    int videoAdaptationSetIndex = period.getAdaptationSetIndex(AdaptationSet.TYPE_VIDEO);
-    int audioAdaptationSetIndex = period.getAdaptationSetIndex(AdaptationSet.TYPE_AUDIO);
-    AdaptationSet videoAdaptationSet = null;
-    AdaptationSet audioAdaptationSet = null;
-    if (videoAdaptationSetIndex != -1) {
-      videoAdaptationSet = period.adaptationSets.get(videoAdaptationSetIndex);
-      hasContentProtection |= videoAdaptationSet.hasContentProtection();
+  private static final class AsyncRendererBuilder
+      implements ManifestFetcher.ManifestCallback<MediaPresentationDescription>, UtcTimingCallback {
+
+    private final Context context;
+    private final String userAgent;
+    private final MediaDrmCallback drmCallback;
+    private final AudioCapabilities audioCapabilities;
+    private final DemoPlayer player;
+    private final ManifestFetcher<MediaPresentationDescription> manifestFetcher;
+    private final UriDataSource manifestDataSource;
+
+    private boolean canceled;
+    private MediaPresentationDescription manifest;
+    private long elapsedRealtimeOffset;
+
+    public AsyncRendererBuilder(Context context, String userAgent, String url,
+        MediaDrmCallback drmCallback, AudioCapabilities audioCapabilities, DemoPlayer player) {
+      this.context = context;
+      this.userAgent = userAgent;
+      this.drmCallback = drmCallback;
+      this.audioCapabilities = audioCapabilities;
+      this.player = player;
+      MediaPresentationDescriptionParser parser = new MediaPresentationDescriptionParser();
+      manifestDataSource = new DefaultUriDataSource(context, userAgent);
+      manifestFetcher = new ManifestFetcher<>(url, manifestDataSource, parser);
     }
-    if (audioAdaptationSetIndex != -1) {
-      audioAdaptationSet = period.adaptationSets.get(audioAdaptationSetIndex);
-      hasContentProtection |= audioAdaptationSet.hasContentProtection();
+
+    public void init() {
+      manifestFetcher.singleLoad(player.getMainHandler().getLooper(), this);
     }
 
-    // Fail if we have neither video or audio.
-    if (videoAdaptationSet == null && audioAdaptationSet == null) {
-      callback.onRenderersError(new IllegalStateException("No video or audio adaptation sets"));
-      return;
+    public void cancel() {
+      canceled = true;
     }
 
-    // Check drm support if necessary.
-    boolean filterHdContent = false;
-    StreamingDrmSessionManager drmSessionManager = null;
-    if (hasContentProtection) {
-      if (Util.SDK_INT < 18) {
-        callback.onRenderersError(
-            new UnsupportedDrmException(UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME));
+    @Override
+    public void onSingleManifest(MediaPresentationDescription manifest) {
+      if (canceled) {
         return;
       }
-      try {
-        drmSessionManager = StreamingDrmSessionManager.newWidevineInstance(
-            player.getPlaybackLooper(), drmCallback, null, player.getMainHandler(), player);
-        filterHdContent = videoAdaptationSet != null && videoAdaptationSet.hasContentProtection()
-            && getWidevineSecurityLevel(drmSessionManager) != SECURITY_LEVEL_1;
-      } catch (UnsupportedDrmException e) {
-        callback.onRenderersError(e);
+
+      this.manifest = manifest;
+      if (manifest.dynamic && manifest.utcTiming != null) {
+        UtcTimingElementResolver.resolveTimingElement(manifestDataSource, manifest.utcTiming,
+            manifestFetcher.getManifestLoadCompleteTimestamp(), this);
+      } else {
+        buildRenderers();
+      }
+    }
+
+    @Override
+    public void onSingleManifestError(IOException e) {
+      if (canceled) {
         return;
       }
+
+      player.onRenderersError(e);
     }
 
-    // Determine which video representations we should use for playback.
-    int[] videoRepresentationIndices = null;
-    if (videoAdaptationSet != null) {
-      try {
-        videoRepresentationIndices = VideoFormatSelectorUtil.selectVideoFormatsForDefaultDisplay(
-            context, videoAdaptationSet.representations, null, filterHdContent);
-      } catch (DecoderQueryException e) {
-        callback.onRenderersError(e);
+    @Override
+    public void onTimestampResolved(UtcTimingElement utcTiming, long elapsedRealtimeOffset) {
+      if (canceled) {
         return;
       }
+
+      this.elapsedRealtimeOffset = elapsedRealtimeOffset;
+      buildRenderers();
     }
 
-    // Build the video renderer.
-    final MediaCodecVideoTrackRenderer videoRenderer;
-    if (videoRepresentationIndices == null || videoRepresentationIndices.length == 0) {
-      videoRenderer = null;
-    } else {
-      DataSource videoDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
-      ChunkSource videoChunkSource = new DashChunkSource(manifestFetcher,
-          videoAdaptationSetIndex, videoRepresentationIndices, videoDataSource,
-          new AdaptiveEvaluator(bandwidthMeter), LIVE_EDGE_LATENCY_MS, elapsedRealtimeOffset,
-          mainHandler, player);
-      ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,
-          VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,
-          DemoPlayer.TYPE_VIDEO);
-      videoRenderer = new MediaCodecVideoTrackRenderer(videoSampleSource, drmSessionManager, true,
-          MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000, null, mainHandler, player, 50);
+    @Override
+    public void onTimestampError(UtcTimingElement utcTiming, IOException e) {
+      if (canceled) {
+        return;
+      }
+
+      Log.e(TAG, "Failed to resolve UtcTiming element [" + utcTiming + "]", e);
+      // Be optimistic and continue in the hope that the device clock is correct.
+      buildRenderers();
     }
 
-    // Build the audio chunk sources.
-    List<ChunkSource> audioChunkSourceList = new ArrayList<>();
-    List<String> audioTrackNameList = new ArrayList<>();
-    if (audioAdaptationSet != null) {
-      DataSource audioDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
-      FormatEvaluator audioEvaluator = new FormatEvaluator.FixedEvaluator();
-      List<Representation> audioRepresentations = audioAdaptationSet.representations;
-      List<String> codecs = new ArrayList<>();
-      for (int i = 0; i < audioRepresentations.size(); i++) {
-        Format format = audioRepresentations.get(i).format;
-        audioTrackNameList.add(format.id + " (" + format.numChannels + "ch, " +
-            format.audioSamplingRate + "Hz)");
-        audioChunkSourceList.add(new DashChunkSource(manifestFetcher, audioAdaptationSetIndex,
-            new int[] {i}, audioDataSource, audioEvaluator, LIVE_EDGE_LATENCY_MS,
-            elapsedRealtimeOffset, mainHandler, player));
-        codecs.add(format.codecs);
+    private void buildRenderers() {
+      Period period = manifest.periods.get(0);
+      Handler mainHandler = player.getMainHandler();
+      LoadControl loadControl = new DefaultLoadControl(new DefaultAllocator(BUFFER_SEGMENT_SIZE));
+      DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter(mainHandler, player);
+
+      boolean hasContentProtection = false;
+      int videoAdaptationSetIndex = period.getAdaptationSetIndex(AdaptationSet.TYPE_VIDEO);
+      int audioAdaptationSetIndex = period.getAdaptationSetIndex(AdaptationSet.TYPE_AUDIO);
+      AdaptationSet videoAdaptationSet = null;
+      AdaptationSet audioAdaptationSet = null;
+      if (videoAdaptationSetIndex != -1) {
+        videoAdaptationSet = period.adaptationSets.get(videoAdaptationSetIndex);
+        hasContentProtection |= videoAdaptationSet.hasContentProtection();
+      }
+      if (audioAdaptationSetIndex != -1) {
+        audioAdaptationSet = period.adaptationSets.get(audioAdaptationSetIndex);
+        hasContentProtection |= audioAdaptationSet.hasContentProtection();
       }
 
-      if (audioCapabilities != null) {
-        // If there are any passthrough audio encodings available, select the highest priority
-        // supported format (e.g. E-AC-3) and remove other tracks.
-        for (int i = 0; i < PASSTHROUGH_CODECS_PRIORITY.length; i++) {
-          String codec = PASSTHROUGH_CODECS_PRIORITY[i];
-          int encoding = PASSTHROUGH_ENCODINGS_PRIORITY[i];
-          if (codecs.indexOf(codec) == -1 || !audioCapabilities.supportsEncoding(encoding)) {
-            continue;
-          }
+      // Fail if we have neither video or audio.
+      if (videoAdaptationSet == null && audioAdaptationSet == null) {
+        player.onRenderersError(new IllegalStateException("No video or audio adaptation sets"));
+        return;
+      }
+
+      // Check drm support if necessary.
+      boolean filterHdContent = false;
+      StreamingDrmSessionManager drmSessionManager = null;
+      if (hasContentProtection) {
+        if (Util.SDK_INT < 18) {
+          player.onRenderersError(
+              new UnsupportedDrmException(UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME));
+          return;
+        }
+        try {
+          drmSessionManager = StreamingDrmSessionManager.newWidevineInstance(
+              player.getPlaybackLooper(), drmCallback, null, player.getMainHandler(), player);
+          filterHdContent = videoAdaptationSet != null && videoAdaptationSet.hasContentProtection()
+              && getWidevineSecurityLevel(drmSessionManager) != SECURITY_LEVEL_1;
+        } catch (UnsupportedDrmException e) {
+          player.onRenderersError(e);
+          return;
+        }
+      }
+
+      // Determine which video representations we should use for playback.
+      int[] videoRepresentationIndices = null;
+      if (videoAdaptationSet != null) {
+        try {
+          videoRepresentationIndices = VideoFormatSelectorUtil.selectVideoFormatsForDefaultDisplay(
+              context, videoAdaptationSet.representations, null, filterHdContent);
+        } catch (DecoderQueryException e) {
+          player.onRenderersError(e);
+          return;
+        }
+      }
+
+      // Build the video renderer.
+      final MediaCodecVideoTrackRenderer videoRenderer;
+      if (videoRepresentationIndices == null || videoRepresentationIndices.length == 0) {
+        videoRenderer = null;
+      } else {
+        DataSource videoDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
+        ChunkSource videoChunkSource = new DashChunkSource(manifestFetcher,
+            videoAdaptationSetIndex, videoRepresentationIndices, videoDataSource,
+            new AdaptiveEvaluator(bandwidthMeter), LIVE_EDGE_LATENCY_MS, elapsedRealtimeOffset,
+            mainHandler, player);
+        ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,
+            VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, mainHandler, player,
+            DemoPlayer.TYPE_VIDEO);
+        videoRenderer = new MediaCodecVideoTrackRenderer(videoSampleSource, drmSessionManager, true,
+            MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000, null, mainHandler, player, 50);
+      }
+
+      // Build the audio chunk sources.
+      List<ChunkSource> audioChunkSourceList = new ArrayList<>();
+      List<String> audioTrackNameList = new ArrayList<>();
+      if (audioAdaptationSet != null) {
+        DataSource audioDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
+        FormatEvaluator audioEvaluator = new FormatEvaluator.FixedEvaluator();
+        List<Representation> audioRepresentations = audioAdaptationSet.representations;
+        List<String> codecs = new ArrayList<>();
+        for (int i = 0; i < audioRepresentations.size(); i++) {
+          Format format = audioRepresentations.get(i).format;
+          audioTrackNameList.add(format.id + " (" + format.numChannels + "ch, " +
+              format.audioSamplingRate + "Hz)");
+          audioChunkSourceList.add(new DashChunkSource(manifestFetcher, audioAdaptationSetIndex,
+              new int[] {i}, audioDataSource, audioEvaluator, LIVE_EDGE_LATENCY_MS,
+              elapsedRealtimeOffset, mainHandler, player));
+          codecs.add(format.codecs);
+        }
+
+        if (audioCapabilities != null) {
+          // If there are any passthrough audio encodings available, select the highest priority
+          // supported format (e.g. E-AC-3) and remove other tracks.
+          for (int i = 0; i < PASSTHROUGH_CODECS_PRIORITY.length; i++) {
+            String codec = PASSTHROUGH_CODECS_PRIORITY[i];
+            int encoding = PASSTHROUGH_ENCODINGS_PRIORITY[i];
+            if (codecs.indexOf(codec) == -1 || !audioCapabilities.supportsEncoding(encoding)) {
+              continue;
+            }
 
-          for (int j = audioRepresentations.size() - 1; j >= 0; j--) {
-            if (!audioRepresentations.get(j).format.codecs.equals(codec)) {
-              audioTrackNameList.remove(j);
-              audioChunkSourceList.remove(j);
+            for (int j = audioRepresentations.size() - 1; j >= 0; j--) {
+              if (!audioRepresentations.get(j).format.codecs.equals(codec)) {
+                audioTrackNameList.remove(j);
+                audioChunkSourceList.remove(j);
+              }
             }
+            break;
           }
-          break;
         }
       }
-    }
 
-    // Build the audio renderer.
-    final String[] audioTrackNames;
-    final MultiTrackChunkSource audioChunkSource;
-    final TrackRenderer audioRenderer;
-    if (audioChunkSourceList.isEmpty()) {
-      audioTrackNames = null;
-      audioChunkSource = null;
-      audioRenderer = null;
-    } else {
-      audioTrackNames = new String[audioTrackNameList.size()];
-      audioTrackNameList.toArray(audioTrackNames);
-      audioChunkSource = new MultiTrackChunkSource(audioChunkSourceList);
-      SampleSource audioSampleSource = new ChunkSampleSource(audioChunkSource, loadControl,
-          AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,
-          DemoPlayer.TYPE_AUDIO);
-      audioRenderer = new MediaCodecAudioTrackRenderer(audioSampleSource, drmSessionManager, true,
-          mainHandler, player);
-    }
+      // Build the audio renderer.
+      final String[] audioTrackNames;
+      final MultiTrackChunkSource audioChunkSource;
+      final TrackRenderer audioRenderer;
+      if (audioChunkSourceList.isEmpty()) {
+        audioTrackNames = null;
+        audioChunkSource = null;
+        audioRenderer = null;
+      } else {
+        audioTrackNames = new String[audioTrackNameList.size()];
+        audioTrackNameList.toArray(audioTrackNames);
+        audioChunkSource = new MultiTrackChunkSource(audioChunkSourceList);
+        SampleSource audioSampleSource = new ChunkSampleSource(audioChunkSource, loadControl,
+            AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, mainHandler, player,
+            DemoPlayer.TYPE_AUDIO);
+        audioRenderer = new MediaCodecAudioTrackRenderer(audioSampleSource, drmSessionManager, true,
+            mainHandler, player);
+      }
 
-    // Build the text chunk sources.
-    DataSource textDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
-    FormatEvaluator textEvaluator = new FormatEvaluator.FixedEvaluator();
-    List<ChunkSource> textChunkSourceList = new ArrayList<>();
-    List<String> textTrackNameList = new ArrayList<>();
-    for (int i = 0; i < period.adaptationSets.size(); i++) {
-      AdaptationSet adaptationSet = period.adaptationSets.get(i);
-      if (adaptationSet.type == AdaptationSet.TYPE_TEXT) {
-        List<Representation> representations = adaptationSet.representations;
-        for (int j = 0; j < representations.size(); j++) {
-          Representation representation = representations.get(j);
-          textTrackNameList.add(representation.format.id);
-          textChunkSourceList.add(new DashChunkSource(manifestFetcher, i, new int[] {j},
-              textDataSource, textEvaluator, LIVE_EDGE_LATENCY_MS, elapsedRealtimeOffset,
-              mainHandler, player));
+      // Build the text chunk sources.
+      DataSource textDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
+      FormatEvaluator textEvaluator = new FormatEvaluator.FixedEvaluator();
+      List<ChunkSource> textChunkSourceList = new ArrayList<>();
+      List<String> textTrackNameList = new ArrayList<>();
+      for (int i = 0; i < period.adaptationSets.size(); i++) {
+        AdaptationSet adaptationSet = period.adaptationSets.get(i);
+        if (adaptationSet.type == AdaptationSet.TYPE_TEXT) {
+          List<Representation> representations = adaptationSet.representations;
+          for (int j = 0; j < representations.size(); j++) {
+            Representation representation = representations.get(j);
+            textTrackNameList.add(representation.format.id);
+            textChunkSourceList.add(new DashChunkSource(manifestFetcher, i, new int[] {j},
+                textDataSource, textEvaluator, LIVE_EDGE_LATENCY_MS, elapsedRealtimeOffset,
+                mainHandler, player));
+          }
         }
       }
-    }
 
-    // Build the text renderers
-    final String[] textTrackNames;
-    final MultiTrackChunkSource textChunkSource;
-    final TrackRenderer textRenderer;
-    if (textChunkSourceList.isEmpty()) {
-      textTrackNames = null;
-      textChunkSource = null;
-      textRenderer = null;
-    } else {
-      textTrackNames = new String[textTrackNameList.size()];
-      textTrackNameList.toArray(textTrackNames);
-      textChunkSource = new MultiTrackChunkSource(textChunkSourceList);
-      SampleSource textSampleSource = new ChunkSampleSource(textChunkSource, loadControl,
-          TEXT_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,
-          DemoPlayer.TYPE_TEXT);
-      textRenderer = new TextTrackRenderer(textSampleSource, player, mainHandler.getLooper(),
-          new TtmlParser(), new WebvttParser());
+      // Build the text renderers
+      final String[] textTrackNames;
+      final MultiTrackChunkSource textChunkSource;
+      final TrackRenderer textRenderer;
+      if (textChunkSourceList.isEmpty()) {
+        textTrackNames = null;
+        textChunkSource = null;
+        textRenderer = null;
+      } else {
+        textTrackNames = new String[textTrackNameList.size()];
+        textTrackNameList.toArray(textTrackNames);
+        textChunkSource = new MultiTrackChunkSource(textChunkSourceList);
+        SampleSource textSampleSource = new ChunkSampleSource(textChunkSource, loadControl,
+            TEXT_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, mainHandler, player,
+            DemoPlayer.TYPE_TEXT);
+        textRenderer = new TextTrackRenderer(textSampleSource, player, mainHandler.getLooper(),
+            new TtmlParser(), new WebvttParser());
+      }
+
+      // Invoke the callback.
+      String[][] trackNames = new String[DemoPlayer.RENDERER_COUNT][];
+      trackNames[DemoPlayer.TYPE_AUDIO] = audioTrackNames;
+      trackNames[DemoPlayer.TYPE_TEXT] = textTrackNames;
+
+      MultiTrackChunkSource[] multiTrackChunkSources =
+          new MultiTrackChunkSource[DemoPlayer.RENDERER_COUNT];
+      multiTrackChunkSources[DemoPlayer.TYPE_AUDIO] = audioChunkSource;
+      multiTrackChunkSources[DemoPlayer.TYPE_TEXT] = textChunkSource;
+
+      TrackRenderer[] renderers = new TrackRenderer[DemoPlayer.RENDERER_COUNT];
+      renderers[DemoPlayer.TYPE_VIDEO] = videoRenderer;
+      renderers[DemoPlayer.TYPE_AUDIO] = audioRenderer;
+      renderers[DemoPlayer.TYPE_TEXT] = textRenderer;
+      player.onRenderers(trackNames, multiTrackChunkSources, renderers, bandwidthMeter);
     }
 
-    // Invoke the callback.
-    String[][] trackNames = new String[DemoPlayer.RENDERER_COUNT][];
-    trackNames[DemoPlayer.TYPE_AUDIO] = audioTrackNames;
-    trackNames[DemoPlayer.TYPE_TEXT] = textTrackNames;
-
-    MultiTrackChunkSource[] multiTrackChunkSources =
-        new MultiTrackChunkSource[DemoPlayer.RENDERER_COUNT];
-    multiTrackChunkSources[DemoPlayer.TYPE_AUDIO] = audioChunkSource;
-    multiTrackChunkSources[DemoPlayer.TYPE_TEXT] = textChunkSource;
-
-    TrackRenderer[] renderers = new TrackRenderer[DemoPlayer.RENDERER_COUNT];
-    renderers[DemoPlayer.TYPE_VIDEO] = videoRenderer;
-    renderers[DemoPlayer.TYPE_AUDIO] = audioRenderer;
-    renderers[DemoPlayer.TYPE_TEXT] = textRenderer;
-    callback.onRenderers(trackNames, multiTrackChunkSources, renderers, bandwidthMeter);
-  }
+    private static int getWidevineSecurityLevel(StreamingDrmSessionManager sessionManager) {
+      String securityLevelProperty = sessionManager.getPropertyString("securityLevel");
+      return securityLevelProperty.equals("L1") ? SECURITY_LEVEL_1 : securityLevelProperty
+          .equals("L3") ? SECURITY_LEVEL_3 : SECURITY_LEVEL_UNKNOWN;
+    }
 
-  private static int getWidevineSecurityLevel(StreamingDrmSessionManager sessionManager) {
-    String securityLevelProperty = sessionManager.getPropertyString("securityLevel");
-    return securityLevelProperty.equals("L1") ? SECURITY_LEVEL_1 : securityLevelProperty
-        .equals("L3") ? SECURITY_LEVEL_3 : SECURITY_LEVEL_UNKNOWN;
   }
 
 }
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
index 1dcb2f31e8..d8366f9207 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
@@ -67,39 +67,20 @@
    */
   public interface RendererBuilder {
     /**
-     * Constructs the necessary components for playback.
+     * Builds renderers for playback.
      *
-     * @param player The parent player.
-     * @param callback The callback to invoke with the constructed components.
+     * @param player The player for which renderers are being built. {@link DemoPlayer#onRenderers}
+     *     should be invoked once the renderers have been built. If building fails,
+     *     {@link DemoPlayer#onRenderersError} should be invoked.
      */
-    void buildRenderers(DemoPlayer player, RendererBuilderCallback callback);
-  }
-
-  /**
-   * A callback invoked by a {@link RendererBuilder}.
-   */
-  public interface RendererBuilderCallback {
+    void buildRenderers(DemoPlayer player);
     /**
-     * Invoked with the results from a {@link RendererBuilder}.
-     *
-     * @param trackNames The names of the available tracks, indexed by {@link DemoPlayer} TYPE_*
-     *     constants. May be null if the track names are unknown. An individual element may be null
-     *     if the track names are unknown for the corresponding type.
-     * @param multiTrackSources Sources capable of switching between multiple available tracks,
-     *     indexed by {@link DemoPlayer} TYPE_* constants. May be null if there are no types with
-     *     multiple tracks. An individual element may be null if it does not have multiple tracks.
-     * @param renderers Renderers indexed by {@link DemoPlayer} TYPE_* constants. An individual
-     *     element may be null if there do not exist tracks of the corresponding type.
-     * @param bandwidthMeter Provides an estimate of the currently available bandwidth. May be null.
+     * Cancels the current build operation, if there is one. Else does nothing.
+     * <p>
+     * A canceled build operation must not invoke {@link DemoPlayer#onRenderers} or
+     * {@link DemoPlayer#onRenderersError} on the player, which may have been released.
      */
-    void onRenderers(String[][] trackNames, MultiTrackChunkSource[] multiTrackSources,
-        TrackRenderer[] renderers, BandwidthMeter bandwidthMeter);
-    /**
-     * Invoked if a {@link RendererBuilder} encounters an error.
-     *
-     * @param e Describes the error.
-     */
-    void onRenderersError(Exception e);
+    void cancel();
   }
 
   /**
@@ -191,7 +172,6 @@ void onDecoderInitialized(String decoderName, long elapsedRealtimeMs,
   private boolean lastReportedPlayWhenReady;
 
   private Surface surface;
-  private InternalRendererBuilderCallback builderCallback;
   private TrackRenderer videoRenderer;
   private CodecCounters codecCounters;
   private Format videoFormat;
@@ -305,22 +285,31 @@ public void prepare() {
     if (rendererBuildingState == RENDERER_BUILDING_STATE_BUILT) {
       player.stop();
     }
-    if (builderCallback != null) {
-      builderCallback.cancel();
-    }
+    rendererBuilder.cancel();
     videoFormat = null;
     videoRenderer = null;
     multiTrackSources = null;
     rendererBuildingState = RENDERER_BUILDING_STATE_BUILDING;
     maybeReportPlayerState();
-    builderCallback = new InternalRendererBuilderCallback();
-    rendererBuilder.buildRenderers(this, builderCallback);
+    rendererBuilder.buildRenderers(this);
   }
 
+  /**
+   * Invoked with the results from a {@link RendererBuilder}.
+   *
+   * @param trackNames The names of the available tracks, indexed by {@link DemoPlayer} TYPE_*
+   *     constants. May be null if the track names are unknown. An individual element may be null
+   *     if the track names are unknown for the corresponding type.
+   * @param multiTrackSources Sources capable of switching between multiple available tracks,
+   *     indexed by {@link DemoPlayer} TYPE_* constants. May be null if there are no types with
+   *     multiple tracks. An individual element may be null if it does not have multiple tracks.
+   * @param renderers Renderers indexed by {@link DemoPlayer} TYPE_* constants. An individual
+   *     element may be null if there do not exist tracks of the corresponding type.
+   * @param bandwidthMeter Provides an estimate of the currently available bandwidth. May be null.
+   */
   /* package */ void onRenderers(String[][] trackNames,
       MultiTrackChunkSource[] multiTrackSources, TrackRenderer[] renderers,
       BandwidthMeter bandwidthMeter) {
-    builderCallback = null;
     // Normalize the results.
     if (trackNames == null) {
       trackNames = new String[RENDERER_COUNT][];
@@ -357,8 +346,12 @@ public void prepare() {
     rendererBuildingState = RENDERER_BUILDING_STATE_BUILT;
   }
 
+  /**
+   * Invoked if a {@link RendererBuilder} encounters an error.
+   *
+   * @param e Describes the error.
+   */
   /* package */ void onRenderersError(Exception e) {
-    builderCallback = null;
     if (internalErrorListener != null) {
       internalErrorListener.onRendererInitializationError(e);
     }
@@ -378,10 +371,7 @@ public void seekTo(long positionMs) {
   }
 
   public void release() {
-    if (builderCallback != null) {
-      builderCallback.cancel();
-      builderCallback = null;
-    }
+    rendererBuilder.cancel();
     rendererBuildingState = RENDERER_BUILDING_STATE_IDLE;
     surface = null;
     player.release();
@@ -390,14 +380,13 @@ public void release() {
 
   public int getPlaybackState() {
     if (rendererBuildingState == RENDERER_BUILDING_STATE_BUILDING) {
-      return ExoPlayer.STATE_PREPARING;
+      return STATE_PREPARING;
     }
     int playerState = player.getPlaybackState();
-    if (rendererBuildingState == RENDERER_BUILDING_STATE_BUILT
-        && rendererBuildingState == RENDERER_BUILDING_STATE_IDLE) {
+    if (rendererBuildingState == RENDERER_BUILDING_STATE_BUILT && playerState == STATE_IDLE) {
       // This is an edge case where the renderers are built, but are still being passed to the
       // player's playback thread.
-      return ExoPlayer.STATE_PREPARING;
+      return STATE_PREPARING;
     }
     return playerState;
   }
@@ -645,29 +634,4 @@ private void pushTrackSelection(int type, boolean allowRendererEnable) {
     }
   }
 
-  private class InternalRendererBuilderCallback implements RendererBuilderCallback {
-
-    private boolean canceled;
-
-    public void cancel() {
-      canceled = true;
-    }
-
-    @Override
-    public void onRenderers(String[][] trackNames, MultiTrackChunkSource[] multiTrackSources,
-        TrackRenderer[] renderers, BandwidthMeter bandwidthMeter) {
-      if (!canceled) {
-        DemoPlayer.this.onRenderers(trackNames, multiTrackSources, renderers, bandwidthMeter);
-      }
-    }
-
-    @Override
-    public void onRenderersError(Exception e) {
-      if (!canceled) {
-        DemoPlayer.this.onRenderersError(e);
-      }
-    }
-
-  }
-
 }
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/ExtractorRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/ExtractorRendererBuilder.java
index 68f0645750..2dd56fdc23 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/ExtractorRendererBuilder.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/ExtractorRendererBuilder.java
@@ -19,11 +19,9 @@
 import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilder;
-import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilderCallback;
 import com.google.android.exoplayer.extractor.Extractor;
 import com.google.android.exoplayer.extractor.ExtractorSampleSource;
 import com.google.android.exoplayer.text.TextTrackRenderer;
-import com.google.android.exoplayer.text.tx3g.Tx3gParser;
 import com.google.android.exoplayer.upstream.Allocator;
 import com.google.android.exoplayer.upstream.DataSource;
 import com.google.android.exoplayer.upstream.DefaultAllocator;
@@ -45,39 +43,42 @@
   private final Context context;
   private final String userAgent;
   private final Uri uri;
-  private final Extractor extractor;
 
-  public ExtractorRendererBuilder(Context context, String userAgent, Uri uri, Extractor extractor) {
+  public ExtractorRendererBuilder(Context context, String userAgent, Uri uri) {
     this.context = context;
     this.userAgent = userAgent;
     this.uri = uri;
-    this.extractor = extractor;
   }
 
   @Override
-  public void buildRenderers(DemoPlayer player, RendererBuilderCallback callback) {
+  public void buildRenderers(DemoPlayer player) {
     Allocator allocator = new DefaultAllocator(BUFFER_SEGMENT_SIZE);
 
     // Build the video and audio renderers.
     DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter(player.getMainHandler(),
         null);
     DataSource dataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
-    ExtractorSampleSource sampleSource = new ExtractorSampleSource(uri, dataSource, extractor,
-        allocator, BUFFER_SEGMENT_COUNT * BUFFER_SEGMENT_SIZE);
+    ExtractorSampleSource sampleSource = new ExtractorSampleSource(uri, dataSource, allocator,
+        BUFFER_SEGMENT_COUNT * BUFFER_SEGMENT_SIZE);
     MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(sampleSource,
         null, true, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000, null, player.getMainHandler(),
         player, 50);
     MediaCodecAudioTrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer(sampleSource,
         null, true, player.getMainHandler(), player);
     TrackRenderer textRenderer = new TextTrackRenderer(sampleSource, player,
-        player.getMainHandler().getLooper(), new Tx3gParser());
+        player.getMainHandler().getLooper());
 
     // Invoke the callback.
     TrackRenderer[] renderers = new TrackRenderer[DemoPlayer.RENDERER_COUNT];
     renderers[DemoPlayer.TYPE_VIDEO] = videoRenderer;
     renderers[DemoPlayer.TYPE_AUDIO] = audioRenderer;
     renderers[DemoPlayer.TYPE_TEXT] = textRenderer;
-    callback.onRenderers(null, null, renderers, bandwidthMeter);
+    player.onRenderers(null, null, renderers, bandwidthMeter);
+  }
+
+  @Override
+  public void cancel() {
+    // Do nothing.
   }
 
 }
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
index 454d4848c2..a4703e9f01 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/HlsRendererBuilder.java
@@ -24,7 +24,6 @@
 import com.google.android.exoplayer.audio.AudioCapabilities;
 import com.google.android.exoplayer.chunk.VideoFormatSelectorUtil;
 import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilder;
-import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilderCallback;
 import com.google.android.exoplayer.hls.HlsChunkSource;
 import com.google.android.exoplayer.hls.HlsMasterPlaylist;
 import com.google.android.exoplayer.hls.HlsPlaylist;
@@ -50,7 +49,7 @@
 /**
  * A {@link RendererBuilder} for HLS.
  */
-public class HlsRendererBuilder implements RendererBuilder, ManifestCallback<HlsPlaylist> {
+public class HlsRendererBuilder implements RendererBuilder {
 
   private static final int BUFFER_SEGMENT_SIZE = 256 * 1024;
   private static final int BUFFER_SEGMENTS = 64;
@@ -60,8 +59,7 @@
   private final String url;
   private final AudioCapabilities audioCapabilities;
 
-  private DemoPlayer player;
-  private RendererBuilderCallback callback;
+  private AsyncRendererBuilder currentAsyncBuilder;
 
   public HlsRendererBuilder(Context context, String userAgent, String url,
       AudioCapabilities audioCapabilities) {
@@ -72,59 +70,107 @@ public HlsRendererBuilder(Context context, String userAgent, String url,
   }
 
   @Override
-  public void buildRenderers(DemoPlayer player, RendererBuilderCallback callback) {
-    this.player = player;
-    this.callback = callback;
-    HlsPlaylistParser parser = new HlsPlaylistParser();
-    ManifestFetcher<HlsPlaylist> playlistFetcher = new ManifestFetcher<>(url,
-        new DefaultUriDataSource(context, userAgent), parser);
-    playlistFetcher.singleLoad(player.getMainHandler().getLooper(), this);
+  public void buildRenderers(DemoPlayer player) {
+    currentAsyncBuilder = new AsyncRendererBuilder(context, userAgent, url, audioCapabilities,
+        player);
+    currentAsyncBuilder.init();
   }
 
   @Override
-  public void onSingleManifestError(IOException e) {
-    callback.onRenderersError(e);
+  public void cancel() {
+    if (currentAsyncBuilder != null) {
+      currentAsyncBuilder.cancel();
+      currentAsyncBuilder = null;
+    }
   }
 
-  @Override
-  public void onSingleManifest(HlsPlaylist manifest) {
-    Handler mainHandler = player.getMainHandler();
-    LoadControl loadControl = new DefaultLoadControl(new DefaultAllocator(BUFFER_SEGMENT_SIZE));
-    DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter();
-
-    int[] variantIndices = null;
-    if (manifest instanceof HlsMasterPlaylist) {
-      HlsMasterPlaylist masterPlaylist = (HlsMasterPlaylist) manifest;
-      try {
-        variantIndices = VideoFormatSelectorUtil.selectVideoFormatsForDefaultDisplay(
-            context, masterPlaylist.variants, null, false);
-      } catch (DecoderQueryException e) {
-        callback.onRenderersError(e);
+  private static final class AsyncRendererBuilder implements ManifestCallback<HlsPlaylist> {
+
+    private final Context context;
+    private final String userAgent;
+    private final String url;
+    private final AudioCapabilities audioCapabilities;
+    private final DemoPlayer player;
+    private final ManifestFetcher<HlsPlaylist> playlistFetcher;
+
+    private boolean canceled;
+
+    public AsyncRendererBuilder(Context context, String userAgent, String url,
+        AudioCapabilities audioCapabilities, DemoPlayer player) {
+      this.context = context;
+      this.userAgent = userAgent;
+      this.url = url;
+      this.audioCapabilities = audioCapabilities;
+      this.player = player;
+      HlsPlaylistParser parser = new HlsPlaylistParser();
+      playlistFetcher = new ManifestFetcher<>(url, new DefaultUriDataSource(context, userAgent),
+          parser);
+    }
+
+    public void init() {
+      playlistFetcher.singleLoad(player.getMainHandler().getLooper(), this);
+    }
+
+    public void cancel() {
+      canceled = true;
+    }
+
+    @Override
+    public void onSingleManifestError(IOException e) {
+      if (canceled) {
         return;
       }
+
+      player.onRenderersError(e);
+    }
+
+    @Override
+    public void onSingleManifest(HlsPlaylist manifest) {
+      if (canceled) {
+        return;
+      }
+
+      Handler mainHandler = player.getMainHandler();
+      LoadControl loadControl = new DefaultLoadControl(new DefaultAllocator(BUFFER_SEGMENT_SIZE));
+      DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter();
+
+      int[] variantIndices = null;
+      if (manifest instanceof HlsMasterPlaylist) {
+        HlsMasterPlaylist masterPlaylist = (HlsMasterPlaylist) manifest;
+        try {
+          variantIndices = VideoFormatSelectorUtil.selectVideoFormatsForDefaultDisplay(
+              context, masterPlaylist.variants, null, false);
+        } catch (DecoderQueryException e) {
+          player.onRenderersError(e);
+          return;
+        }
+        if (variantIndices.length == 0) {
+          player.onRenderersError(new IllegalStateException("No variants selected."));
+          return;
+        }
+      }
+
+      DataSource dataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
+      HlsChunkSource chunkSource = new HlsChunkSource(dataSource, url, manifest, bandwidthMeter,
+          variantIndices, HlsChunkSource.ADAPTIVE_MODE_SPLICE, audioCapabilities);
+      HlsSampleSource sampleSource = new HlsSampleSource(chunkSource, loadControl,
+          BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, mainHandler, player, DemoPlayer.TYPE_VIDEO);
+      MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(sampleSource,
+          MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000, mainHandler, player, 50);
+      MediaCodecAudioTrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer(sampleSource);
+      MetadataTrackRenderer<Map<String, Object>> id3Renderer = new MetadataTrackRenderer<>(
+          sampleSource, new Id3Parser(), player, mainHandler.getLooper());
+      Eia608TrackRenderer closedCaptionRenderer = new Eia608TrackRenderer(sampleSource, player,
+          mainHandler.getLooper());
+
+      TrackRenderer[] renderers = new TrackRenderer[DemoPlayer.RENDERER_COUNT];
+      renderers[DemoPlayer.TYPE_VIDEO] = videoRenderer;
+      renderers[DemoPlayer.TYPE_AUDIO] = audioRenderer;
+      renderers[DemoPlayer.TYPE_METADATA] = id3Renderer;
+      renderers[DemoPlayer.TYPE_TEXT] = closedCaptionRenderer;
+      player.onRenderers(null, null, renderers, bandwidthMeter);
     }
 
-    DataSource dataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
-    HlsChunkSource chunkSource = new HlsChunkSource(dataSource, url, manifest, bandwidthMeter,
-        variantIndices, HlsChunkSource.ADAPTIVE_MODE_SPLICE, audioCapabilities);
-    HlsSampleSource sampleSource = new HlsSampleSource(chunkSource, loadControl,
-        BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player, DemoPlayer.TYPE_VIDEO);
-    MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(sampleSource,
-        MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000, mainHandler, player, 50);
-    MediaCodecAudioTrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer(sampleSource);
-
-    MetadataTrackRenderer<Map<String, Object>> id3Renderer =
-        new MetadataTrackRenderer<>(sampleSource, new Id3Parser(), player, mainHandler.getLooper());
-
-    Eia608TrackRenderer closedCaptionRenderer = new Eia608TrackRenderer(sampleSource, player,
-        mainHandler.getLooper());
-
-    TrackRenderer[] renderers = new TrackRenderer[DemoPlayer.RENDERER_COUNT];
-    renderers[DemoPlayer.TYPE_VIDEO] = videoRenderer;
-    renderers[DemoPlayer.TYPE_AUDIO] = audioRenderer;
-    renderers[DemoPlayer.TYPE_METADATA] = id3Renderer;
-    renderers[DemoPlayer.TYPE_TEXT] = closedCaptionRenderer;
-    callback.onRenderers(null, null, renderers, bandwidthMeter);
   }
 
 }
diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/SmoothStreamingRendererBuilder.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/SmoothStreamingRendererBuilder.java
index faea15473a..4e80aa4bfe 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/SmoothStreamingRendererBuilder.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/SmoothStreamingRendererBuilder.java
@@ -28,7 +28,6 @@
 import com.google.android.exoplayer.chunk.MultiTrackChunkSource;
 import com.google.android.exoplayer.chunk.VideoFormatSelectorUtil;
 import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilder;
-import com.google.android.exoplayer.demo.player.DemoPlayer.RendererBuilderCallback;
 import com.google.android.exoplayer.drm.DrmSessionManager;
 import com.google.android.exoplayer.drm.MediaDrmCallback;
 import com.google.android.exoplayer.drm.StreamingDrmSessionManager;
@@ -57,8 +56,7 @@
 /**
  * A {@link RendererBuilder} for SmoothStreaming.
  */
-public class SmoothStreamingRendererBuilder implements RendererBuilder,
-    ManifestFetcher.ManifestCallback<SmoothStreamingManifest> {
+public class SmoothStreamingRendererBuilder implements RendererBuilder {
 
   private static final int BUFFER_SEGMENT_SIZE = 64 * 1024;
   private static final int VIDEO_BUFFER_SEGMENTS = 200;
@@ -71,179 +69,218 @@
   private final String url;
   private final MediaDrmCallback drmCallback;
 
-  private DemoPlayer player;
-  private RendererBuilderCallback callback;
-  private ManifestFetcher<SmoothStreamingManifest> manifestFetcher;
+  private AsyncRendererBuilder currentAsyncBuilder;
 
   public SmoothStreamingRendererBuilder(Context context, String userAgent, String url,
       MediaDrmCallback drmCallback) {
     this.context = context;
     this.userAgent = userAgent;
-    this.url = url;
+    this.url = Util.toLowerInvariant(url).endsWith("/manifest") ? url : url + "/Manifest";
     this.drmCallback = drmCallback;
   }
 
   @Override
-  public void buildRenderers(DemoPlayer player, RendererBuilderCallback callback) {
-    this.player = player;
-    this.callback = callback;
-    String manifestUrl = url;
-    if (!manifestUrl.endsWith("/Manifest")) {
-      manifestUrl += "/Manifest";
-    }
-    SmoothStreamingManifestParser parser = new SmoothStreamingManifestParser();
-    manifestFetcher = new ManifestFetcher<>(manifestUrl,
-        new DefaultHttpDataSource(userAgent, null), parser);
-    manifestFetcher.singleLoad(player.getMainHandler().getLooper(), this);
+  public void buildRenderers(DemoPlayer player) {
+    currentAsyncBuilder = new AsyncRendererBuilder(context, userAgent, url, drmCallback, player);
+    currentAsyncBuilder.init();
   }
 
   @Override
-  public void onSingleManifestError(IOException exception) {
-    callback.onRenderersError(exception);
+  public void cancel() {
+    if (currentAsyncBuilder != null) {
+      currentAsyncBuilder.cancel();
+      currentAsyncBuilder = null;
+    }
   }
 
-  @Override
-  public void onSingleManifest(SmoothStreamingManifest manifest) {
-    Handler mainHandler = player.getMainHandler();
-    LoadControl loadControl = new DefaultLoadControl(new DefaultAllocator(BUFFER_SEGMENT_SIZE));
-    DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter(mainHandler, player);
-
-    // Check drm support if necessary.
-    DrmSessionManager drmSessionManager = null;
-    if (manifest.protectionElement != null) {
-      if (Util.SDK_INT < 18) {
-        callback.onRenderersError(
-            new UnsupportedDrmException(UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME));
-        return;
-      }
-      try {
-        drmSessionManager = new StreamingDrmSessionManager(manifest.protectionElement.uuid,
-            player.getPlaybackLooper(), drmCallback, null, player.getMainHandler(), player);
-      } catch (UnsupportedDrmException e) {
-        callback.onRenderersError(e);
-        return;
-      }
+  private static final class AsyncRendererBuilder
+      implements ManifestFetcher.ManifestCallback<SmoothStreamingManifest> {
+
+    private final Context context;
+    private final String userAgent;
+    private final MediaDrmCallback drmCallback;
+    private final DemoPlayer player;
+    private final ManifestFetcher<SmoothStreamingManifest> manifestFetcher;
+
+    private boolean canceled;
+
+    public AsyncRendererBuilder(Context context, String userAgent, String url,
+        MediaDrmCallback drmCallback, DemoPlayer player) {
+      this.context = context;
+      this.userAgent = userAgent;
+      this.drmCallback = drmCallback;
+      this.player = player;
+      SmoothStreamingManifestParser parser = new SmoothStreamingManifestParser();
+      manifestFetcher = new ManifestFetcher<>(url, new DefaultHttpDataSource(userAgent, null),
+          parser);
     }
 
-    // Obtain stream elements for playback.
-    int audioStreamElementCount = 0;
-    int textStreamElementCount = 0;
-    int videoStreamElementIndex = -1;
-    for (int i = 0; i < manifest.streamElements.length; i++) {
-      if (manifest.streamElements[i].type == StreamElement.TYPE_AUDIO) {
-        audioStreamElementCount++;
-      } else if (manifest.streamElements[i].type == StreamElement.TYPE_TEXT) {
-        textStreamElementCount++;
-      } else if (videoStreamElementIndex == -1
-          && manifest.streamElements[i].type == StreamElement.TYPE_VIDEO) {
-        videoStreamElementIndex = i;
-      }
+    public void init() {
+      manifestFetcher.singleLoad(player.getMainHandler().getLooper(), this);
+    }
+
+    public void cancel() {
+      canceled = true;
     }
 
-    // Determine which video tracks we should use for playback.
-    int[] videoTrackIndices = null;
-    if (videoStreamElementIndex != -1) {
-      try {
-        videoTrackIndices = VideoFormatSelectorUtil.selectVideoFormatsForDefaultDisplay(context,
-            Arrays.asList(manifest.streamElements[videoStreamElementIndex].tracks), null, false);
-      } catch (DecoderQueryException e) {
-        callback.onRenderersError(e);
+    @Override
+    public void onSingleManifestError(IOException exception) {
+      if (canceled) {
         return;
       }
-    }
 
-    // Build the video renderer.
-    final MediaCodecVideoTrackRenderer videoRenderer;
-    if (videoTrackIndices == null || videoTrackIndices.length == 0) {
-      videoRenderer = null;
-    } else {
-      DataSource videoDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
-      ChunkSource videoChunkSource = new SmoothStreamingChunkSource(manifestFetcher,
-          videoStreamElementIndex, videoTrackIndices, videoDataSource,
-          new AdaptiveEvaluator(bandwidthMeter), LIVE_EDGE_LATENCY_MS);
-      ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,
-          VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,
-          DemoPlayer.TYPE_VIDEO);
-      videoRenderer = new MediaCodecVideoTrackRenderer(videoSampleSource, drmSessionManager, true,
-          MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000, null, mainHandler, player, 50);
+      player.onRenderersError(exception);
     }
 
-    // Build the audio renderer.
-    final String[] audioTrackNames;
-    final MultiTrackChunkSource audioChunkSource;
-    final MediaCodecAudioTrackRenderer audioRenderer;
-    if (audioStreamElementCount == 0) {
-      audioTrackNames = null;
-      audioChunkSource = null;
-      audioRenderer = null;
-    } else {
-      audioTrackNames = new String[audioStreamElementCount];
-      ChunkSource[] audioChunkSources = new ChunkSource[audioStreamElementCount];
-      DataSource audioDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
-      FormatEvaluator audioFormatEvaluator = new FormatEvaluator.FixedEvaluator();
-      audioStreamElementCount = 0;
+    @Override
+    public void onSingleManifest(SmoothStreamingManifest manifest) {
+      if (canceled) {
+        return;
+      }
+
+      Handler mainHandler = player.getMainHandler();
+      LoadControl loadControl = new DefaultLoadControl(new DefaultAllocator(BUFFER_SEGMENT_SIZE));
+      DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter(mainHandler, player);
+
+      // Check drm support if necessary.
+      DrmSessionManager drmSessionManager = null;
+      if (manifest.protectionElement != null) {
+        if (Util.SDK_INT < 18) {
+          player.onRenderersError(
+              new UnsupportedDrmException(UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME));
+          return;
+        }
+        try {
+          drmSessionManager = new StreamingDrmSessionManager(manifest.protectionElement.uuid,
+              player.getPlaybackLooper(), drmCallback, null, player.getMainHandler(), player);
+        } catch (UnsupportedDrmException e) {
+          player.onRenderersError(e);
+          return;
+        }
+      }
+
+      // Obtain stream elements for playback.
+      int audioStreamElementCount = 0;
+      int textStreamElementCount = 0;
+      int videoStreamElementIndex = -1;
       for (int i = 0; i < manifest.streamElements.length; i++) {
         if (manifest.streamElements[i].type == StreamElement.TYPE_AUDIO) {
-          audioTrackNames[audioStreamElementCount] = manifest.streamElements[i].name;
-          audioChunkSources[audioStreamElementCount] = new SmoothStreamingChunkSource(
-              manifestFetcher, i, new int[] {0}, audioDataSource, audioFormatEvaluator,
-              LIVE_EDGE_LATENCY_MS);
           audioStreamElementCount++;
+        } else if (manifest.streamElements[i].type == StreamElement.TYPE_TEXT) {
+          textStreamElementCount++;
+        } else if (videoStreamElementIndex == -1
+            && manifest.streamElements[i].type == StreamElement.TYPE_VIDEO) {
+          videoStreamElementIndex = i;
         }
       }
-      audioChunkSource = new MultiTrackChunkSource(audioChunkSources);
-      ChunkSampleSource audioSampleSource = new ChunkSampleSource(audioChunkSource, loadControl,
-          AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,
-          DemoPlayer.TYPE_AUDIO);
-      audioRenderer = new MediaCodecAudioTrackRenderer(audioSampleSource, drmSessionManager, true,
-          mainHandler, player);
-    }
 
-    // Build the text renderer.
-    final String[] textTrackNames;
-    final MultiTrackChunkSource textChunkSource;
-    final TrackRenderer textRenderer;
-    if (textStreamElementCount == 0) {
-      textTrackNames = null;
-      textChunkSource = null;
-      textRenderer = null;
-    } else {
-      textTrackNames = new String[textStreamElementCount];
-      ChunkSource[] textChunkSources = new ChunkSource[textStreamElementCount];
-      DataSource ttmlDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
-      FormatEvaluator ttmlFormatEvaluator = new FormatEvaluator.FixedEvaluator();
-      textStreamElementCount = 0;
-      for (int i = 0; i < manifest.streamElements.length; i++) {
-        if (manifest.streamElements[i].type == StreamElement.TYPE_TEXT) {
-          textTrackNames[textStreamElementCount] = manifest.streamElements[i].language;
-          textChunkSources[textStreamElementCount] = new SmoothStreamingChunkSource(manifestFetcher,
-              i, new int[] {0}, ttmlDataSource, ttmlFormatEvaluator, LIVE_EDGE_LATENCY_MS);
-          textStreamElementCount++;
+      // Determine which video tracks we should use for playback.
+      int[] videoTrackIndices = null;
+      if (videoStreamElementIndex != -1) {
+        try {
+          videoTrackIndices = VideoFormatSelectorUtil.selectVideoFormatsForDefaultDisplay(context,
+              Arrays.asList(manifest.streamElements[videoStreamElementIndex].tracks), null, false);
+        } catch (DecoderQueryException e) {
+          player.onRenderersError(e);
+          return;
+        }
+      }
+
+      // Build the video renderer.
+      final MediaCodecVideoTrackRenderer videoRenderer;
+      if (videoTrackIndices == null || videoTrackIndices.length == 0) {
+        videoRenderer = null;
+      } else {
+        DataSource videoDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
+        ChunkSource videoChunkSource = new SmoothStreamingChunkSource(manifestFetcher,
+            videoStreamElementIndex, videoTrackIndices, videoDataSource,
+            new AdaptiveEvaluator(bandwidthMeter), LIVE_EDGE_LATENCY_MS);
+        ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,
+            VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, mainHandler, player,
+            DemoPlayer.TYPE_VIDEO);
+        videoRenderer = new MediaCodecVideoTrackRenderer(videoSampleSource, drmSessionManager, true,
+            MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000, null, mainHandler, player, 50);
+      }
+
+      // Build the audio renderer.
+      final String[] audioTrackNames;
+      final MultiTrackChunkSource audioChunkSource;
+      final MediaCodecAudioTrackRenderer audioRenderer;
+      if (audioStreamElementCount == 0) {
+        audioTrackNames = null;
+        audioChunkSource = null;
+        audioRenderer = null;
+      } else {
+        audioTrackNames = new String[audioStreamElementCount];
+        ChunkSource[] audioChunkSources = new ChunkSource[audioStreamElementCount];
+        DataSource audioDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
+        FormatEvaluator audioFormatEvaluator = new FormatEvaluator.FixedEvaluator();
+        audioStreamElementCount = 0;
+        for (int i = 0; i < manifest.streamElements.length; i++) {
+          if (manifest.streamElements[i].type == StreamElement.TYPE_AUDIO) {
+            audioTrackNames[audioStreamElementCount] = manifest.streamElements[i].name;
+            audioChunkSources[audioStreamElementCount] = new SmoothStreamingChunkSource(
+                manifestFetcher, i, new int[] {0}, audioDataSource, audioFormatEvaluator,
+                LIVE_EDGE_LATENCY_MS);
+            audioStreamElementCount++;
+          }
         }
+        audioChunkSource = new MultiTrackChunkSource(audioChunkSources);
+        ChunkSampleSource audioSampleSource = new ChunkSampleSource(audioChunkSource, loadControl,
+            AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, mainHandler, player,
+            DemoPlayer.TYPE_AUDIO);
+        audioRenderer = new MediaCodecAudioTrackRenderer(audioSampleSource, drmSessionManager, true,
+            mainHandler, player);
       }
-      textChunkSource = new MultiTrackChunkSource(textChunkSources);
-      ChunkSampleSource ttmlSampleSource = new ChunkSampleSource(textChunkSource, loadControl,
-          TEXT_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,
-          DemoPlayer.TYPE_TEXT);
-      textRenderer = new TextTrackRenderer(ttmlSampleSource, player, mainHandler.getLooper(),
-          new TtmlParser());
+
+      // Build the text renderer.
+      final String[] textTrackNames;
+      final MultiTrackChunkSource textChunkSource;
+      final TrackRenderer textRenderer;
+      if (textStreamElementCount == 0) {
+        textTrackNames = null;
+        textChunkSource = null;
+        textRenderer = null;
+      } else {
+        textTrackNames = new String[textStreamElementCount];
+        ChunkSource[] textChunkSources = new ChunkSource[textStreamElementCount];
+        DataSource ttmlDataSource = new DefaultUriDataSource(context, bandwidthMeter, userAgent);
+        FormatEvaluator ttmlFormatEvaluator = new FormatEvaluator.FixedEvaluator();
+        textStreamElementCount = 0;
+        for (int i = 0; i < manifest.streamElements.length; i++) {
+          if (manifest.streamElements[i].type == StreamElement.TYPE_TEXT) {
+            textTrackNames[textStreamElementCount] = manifest.streamElements[i].language;
+            textChunkSources[textStreamElementCount] = new SmoothStreamingChunkSource(
+                manifestFetcher, i, new int[] {0}, ttmlDataSource, ttmlFormatEvaluator,
+                LIVE_EDGE_LATENCY_MS);
+            textStreamElementCount++;
+          }
+        }
+        textChunkSource = new MultiTrackChunkSource(textChunkSources);
+        ChunkSampleSource ttmlSampleSource = new ChunkSampleSource(textChunkSource, loadControl,
+            TEXT_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, mainHandler, player,
+            DemoPlayer.TYPE_TEXT);
+        textRenderer = new TextTrackRenderer(ttmlSampleSource, player, mainHandler.getLooper(),
+            new TtmlParser());
+      }
+
+      // Invoke the callback.
+      String[][] trackNames = new String[DemoPlayer.RENDERER_COUNT][];
+      trackNames[DemoPlayer.TYPE_AUDIO] = audioTrackNames;
+      trackNames[DemoPlayer.TYPE_TEXT] = textTrackNames;
+
+      MultiTrackChunkSource[] multiTrackChunkSources =
+          new MultiTrackChunkSource[DemoPlayer.RENDERER_COUNT];
+      multiTrackChunkSources[DemoPlayer.TYPE_AUDIO] = audioChunkSource;
+      multiTrackChunkSources[DemoPlayer.TYPE_TEXT] = textChunkSource;
+
+      TrackRenderer[] renderers = new TrackRenderer[DemoPlayer.RENDERER_COUNT];
+      renderers[DemoPlayer.TYPE_VIDEO] = videoRenderer;
+      renderers[DemoPlayer.TYPE_AUDIO] = audioRenderer;
+      renderers[DemoPlayer.TYPE_TEXT] = textRenderer;
+      player.onRenderers(trackNames, multiTrackChunkSources, renderers, bandwidthMeter);
     }
 
-    // Invoke the callback.
-    String[][] trackNames = new String[DemoPlayer.RENDERER_COUNT][];
-    trackNames[DemoPlayer.TYPE_AUDIO] = audioTrackNames;
-    trackNames[DemoPlayer.TYPE_TEXT] = textTrackNames;
-
-    MultiTrackChunkSource[] multiTrackChunkSources =
-        new MultiTrackChunkSource[DemoPlayer.RENDERER_COUNT];
-    multiTrackChunkSources[DemoPlayer.TYPE_AUDIO] = audioChunkSource;
-    multiTrackChunkSources[DemoPlayer.TYPE_TEXT] = textChunkSource;
-
-    TrackRenderer[] renderers = new TrackRenderer[DemoPlayer.RENDERER_COUNT];
-    renderers[DemoPlayer.TYPE_VIDEO] = videoRenderer;
-    renderers[DemoPlayer.TYPE_AUDIO] = audioRenderer;
-    renderers[DemoPlayer.TYPE_TEXT] = textRenderer;
-    callback.onRenderers(trackNames, multiTrackChunkSources, renderers, bandwidthMeter);
   }
 
 }
diff --git a/demo_misc/webm_sw_decoder/src/main/AndroidManifest.xml b/demo_misc/webm_sw_decoder/src/main/AndroidManifest.xml
index 08430b8ee3..e07f7f34bc 100644
--- a/demo_misc/webm_sw_decoder/src/main/AndroidManifest.xml
+++ b/demo_misc/webm_sw_decoder/src/main/AndroidManifest.xml
@@ -17,8 +17,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer.demo.webm"
-    android:versionCode="1401"
-    android:versionName="1.4.1"
+    android:versionCode="1402"
+    android:versionName="1.4.2"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
diff --git a/demo_misc/webm_sw_decoder/src/main/java/com/google/android/exoplayer/demo/webm/DashRendererBuilder.java b/demo_misc/webm_sw_decoder/src/main/java/com/google/android/exoplayer/demo/webm/DashRendererBuilder.java
index afafc1e639..377d7611ae 100644
--- a/demo_misc/webm_sw_decoder/src/main/java/com/google/android/exoplayer/demo/webm/DashRendererBuilder.java
+++ b/demo_misc/webm_sw_decoder/src/main/java/com/google/android/exoplayer/demo/webm/DashRendererBuilder.java
@@ -114,7 +114,7 @@ public void onSingleManifest(MediaPresentationDescription manifest) {
         throw new IllegalStateException("Unexpected mime type: " + mimeType);
       }
       ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,
-          VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true);
+          VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE);
       videoRenderer = new LibvpxVideoTrackRenderer(videoSampleSource,
           true, player.getMainHandler(), player, 50);
     }
@@ -133,7 +133,7 @@ public void onSingleManifest(MediaPresentationDescription manifest) {
       }
       audioChunkSource = new MultiTrackChunkSource(audioChunkSources);
       SampleSource audioSampleSource = new ChunkSampleSource(audioChunkSource, loadControl,
-          AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true);
+          AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE);
       if (manifestUrl.contains("opus")) { // TODO: Need a better logic here.
         audioRenderer = new LibopusAudioTrackRenderer(audioSampleSource);
       } else {
diff --git a/demo_misc/webm_sw_decoder/src/main/java/com/google/android/exoplayer/demo/webm/VideoPlayer.java b/demo_misc/webm_sw_decoder/src/main/java/com/google/android/exoplayer/demo/webm/VideoPlayer.java
index 01a6a0dd5c..c855cd63ed 100644
--- a/demo_misc/webm_sw_decoder/src/main/java/com/google/android/exoplayer/demo/webm/VideoPlayer.java
+++ b/demo_misc/webm_sw_decoder/src/main/java/com/google/android/exoplayer/demo/webm/VideoPlayer.java
@@ -167,8 +167,8 @@ private void startBasicPlayback() {
     ExtractorSampleSource sampleSource = new ExtractorSampleSource(
         Uri.fromFile(new File(filename)),
         new DefaultUriDataSource(this, Util.getUserAgent(this, "ExoPlayerExtWebMDemo")),
-        new WebmExtractor(), new DefaultAllocator(BUFFER_SEGMENT_SIZE),
-        BUFFER_SEGMENT_SIZE * BUFFER_SEGMENT_COUNT);
+        new DefaultAllocator(BUFFER_SEGMENT_SIZE), BUFFER_SEGMENT_SIZE * BUFFER_SEGMENT_COUNT,
+        new WebmExtractor());
     TrackRenderer videoRenderer =
         new LibvpxVideoTrackRenderer(sampleSource, true, handler, this, 50);
     if (useOpenGL) {
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
index 96ce46f4f2..2ab807f899 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
@@ -126,24 +126,19 @@ protected MediaClock getMediaClock() {
   }
 
   @Override
-  protected int doPrepare(long positionUs) throws ExoPlaybackException {
-    try {
-      boolean sourcePrepared = source.prepare(positionUs);
-      if (!sourcePrepared) {
-        return TrackRenderer.STATE_UNPREPARED;
-      }
-    } catch (IOException e) {
-      throw new ExoPlaybackException(e);
+  protected int doPrepare(long positionUs) {
+    boolean sourcePrepared = source.prepare(positionUs);
+    if (!sourcePrepared) {
+      return TrackRenderer.STATE_UNPREPARED;
     }
-
-    for (int i = 0; i < source.getTrackCount(); i++) {
+    int trackCount = source.getTrackCount();
+    for (int i = 0; i < trackCount; i++) {
       if (source.getTrackInfo(i).mimeType.equalsIgnoreCase(MimeTypes.AUDIO_OPUS)
           || source.getTrackInfo(i).mimeType.equalsIgnoreCase(MimeTypes.AUDIO_WEBM)) {
         trackIndex = i;
         return TrackRenderer.STATE_PREPARED;
       }
     }
-
     return TrackRenderer.STATE_IGNORE;
   }
 
@@ -152,42 +147,49 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPla
     if (outputStreamEnded) {
       return;
     }
-    try {
-      sourceIsReady = source.continueBuffering(trackIndex, positionUs);
-      checkForDiscontinuity();
-      if (format == null) {
-        readFormat();
-      } else {
-        // Create the decoder.
-        if (decoder == null) {
-          // For opus, the format can contain upto 3 entries in initializationData in the following
-          // exact order:
-          // 1) Opus Header Information (required)
-          // 2) Codec Delay in nanoseconds (required if Seek Preroll is present)
-          // 3) Seek Preroll in nanoseconds (required if Codec Delay is present)
-          List<byte[]> initializationData = format.initializationData;
-          if (initializationData.size() < 1) {
-            throw new ExoPlaybackException("Missing initialization data");
-          }
-          long codecDelayNs = -1;
-          long seekPreRollNs = -1;
-          if (initializationData.size() == 3) {
-            if (initializationData.get(1).length != Long.SIZE
-                || initializationData.get(2).length != Long.SIZE) {
-              throw new ExoPlaybackException("Invalid Codec Delay or Seek Preroll");
-            }
-            codecDelayNs = ByteBuffer.wrap(initializationData.get(1)).getLong();
-            seekPreRollNs = ByteBuffer.wrap(initializationData.get(2)).getLong();
-          }
-          decoder =
-              new OpusDecoderWrapper(initializationData.get(0), codecDelayNs, seekPreRollNs);
-          decoder.start();
-        }
-        renderBuffer();
+    sourceIsReady = source.continueBuffering(trackIndex, positionUs);
+    checkForDiscontinuity();
+
+    // Try and read a format if we don't have one already.
+    if (format == null && !readFormat(positionUs)) {
+      // We can't make progress without one.
+      return;
+    }
 
-        // Queue input buffers.
-        while (feedInputBuffer()) {}
+    // If we don't have a decoder yet, we need to instantiate one.
+    if (decoder == null) {
+      // For opus, the format can contain upto 3 entries in initializationData in the following
+      // exact order:
+      // 1) Opus Header Information (required)
+      // 2) Codec Delay in nanoseconds (required if Seek Preroll is present)
+      // 3) Seek Preroll in nanoseconds (required if Codec Delay is present)
+      List<byte[]> initializationData = format.initializationData;
+      if (initializationData.size() < 1) {
+        throw new ExoPlaybackException("Missing initialization data");
+      }
+      long codecDelayNs = -1;
+      long seekPreRollNs = -1;
+      if (initializationData.size() == 3) {
+        if (initializationData.get(1).length != Long.SIZE
+            || initializationData.get(2).length != Long.SIZE) {
+          throw new ExoPlaybackException("Invalid Codec Delay or Seek Preroll");
+        }
+        codecDelayNs = ByteBuffer.wrap(initializationData.get(1)).getLong();
+        seekPreRollNs = ByteBuffer.wrap(initializationData.get(2)).getLong();
       }
+      try {
+        decoder = new OpusDecoderWrapper(initializationData.get(0), codecDelayNs, seekPreRollNs);
+      } catch (OpusDecoderException e) {
+        notifyDecoderError(e);
+        throw new ExoPlaybackException(e);
+      }
+      decoder.start();
+    }
+
+    // Rendering loop.
+    try {
+      renderBuffer();
+      while (feedInputBuffer()) {}
     } catch (AudioTrack.InitializationException e) {
       notifyAudioTrackInitializationError(e);
       throw new ExoPlaybackException(e);
@@ -197,8 +199,6 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPla
     } catch (OpusDecoderException e) {
       notifyDecoderError(e);
       throw new ExoPlaybackException(e);
-    } catch (IOException e) {
-      throw new ExoPlaybackException(e);
     }
   }
 
@@ -249,7 +249,7 @@ private void renderBuffer() throws OpusDecoderException, AudioTrack.Initializati
     }
   }
 
-  private boolean feedInputBuffer() throws IOException, OpusDecoderException {
+  private boolean feedInputBuffer() throws OpusDecoderException {
     if (inputStreamEnded) {
       return false;
     }
@@ -291,7 +291,7 @@ private boolean feedInputBuffer() throws IOException, OpusDecoderException {
     return true;
   }
 
-  private void checkForDiscontinuity() throws IOException {
+  private void checkForDiscontinuity() {
     if (decoder == null) {
       return;
     }
@@ -394,12 +394,23 @@ protected void onDisabled() {
     }
   }
 
-  private void readFormat() throws IOException {
-    int result = source.readData(trackIndex, currentPositionUs, formatHolder, null, false);
+  @Override
+  protected void maybeThrowError() throws ExoPlaybackException {
+    try {
+      source.maybeThrowError();
+    } catch (IOException e) {
+      throw new ExoPlaybackException(e);
+    }
+  }
+
+  private boolean readFormat(long positionUs) {
+    int result = source.readData(trackIndex, positionUs, formatHolder, null, false);
     if (result == SampleSource.FORMAT_READ) {
       format = formatHolder.format;
       audioTrack.reconfigure(format.getFrameworkMediaFormatV16());
+      return true;
     }
+    return false;
   }
 
   @Override
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
index b6b3cc06a1..4c8745d006 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
@@ -153,23 +153,18 @@ public LibvpxVideoTrackRenderer(SampleSource source, boolean scaleToFit,
 
   @Override
   protected int doPrepare(long positionUs) throws ExoPlaybackException {
-    try {
-      boolean sourcePrepared = source.prepare(positionUs);
-      if (!sourcePrepared) {
-        return TrackRenderer.STATE_UNPREPARED;
-      }
-    } catch (IOException e) {
-      throw new ExoPlaybackException(e);
+    boolean sourcePrepared = source.prepare(positionUs);
+    if (!sourcePrepared) {
+      return TrackRenderer.STATE_UNPREPARED;
     }
-
-    for (int i = 0; i < source.getTrackCount(); i++) {
+    int trackCount = source.getTrackCount();
+    for (int i = 0; i < trackCount; i++) {
       if (source.getTrackInfo(i).mimeType.equalsIgnoreCase(MimeTypes.VIDEO_VP9)
           || source.getTrackInfo(i).mimeType.equalsIgnoreCase(MimeTypes.VIDEO_WEBM)) {
         trackIndex = i;
         return TrackRenderer.STATE_PREPARED;
       }
     }
-
     return TrackRenderer.STATE_IGNORE;
   }
 
@@ -178,28 +173,29 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPla
     if (outputStreamEnded) {
       return;
     }
-    try {
-      sourceIsReady = source.continueBuffering(trackIndex, positionUs);
-      checkForDiscontinuity(positionUs);
-      if (format == null) {
-        readFormat(positionUs);
-      } else {
-        // TODO: Add support for dynamic switching between one type of surface to another.
-        // Create the decoder.
-        if (decoder == null) {
-          decoder = new VpxDecoderWrapper(outputRgb);
-          decoder.start();
-        }
-        processOutputBuffer(positionUs, elapsedRealtimeUs);
+    sourceIsReady = source.continueBuffering(trackIndex, positionUs);
+    checkForDiscontinuity(positionUs);
 
-        // Queue input buffers.
-        while (feedInputBuffer(positionUs)) {}
-      }
+    // Try and read a format if we don't have one already.
+    if (format == null && !readFormat(positionUs)) {
+      // We can't make progress without one.
+      return;
+    }
+
+    // If we don't have a decoder yet, we need to instantiate one.
+    // TODO: Add support for dynamic switching between one type of surface to another.
+    if (decoder == null) {
+      decoder = new VpxDecoderWrapper(outputRgb);
+      decoder.start();
+    }
+
+    // Rendering loop.
+    try {
+      processOutputBuffer(positionUs, elapsedRealtimeUs);
+      while (feedInputBuffer(positionUs)) {}
     } catch (VpxDecoderException e) {
       notifyDecoderError(e);
       throw new ExoPlaybackException(e);
-    } catch (IOException e) {
-      throw new ExoPlaybackException(e);
     }
   }
 
@@ -294,7 +290,7 @@ private void renderRgbFrame(OutputBuffer outputBuffer, boolean scale) {
     surface.unlockCanvasAndPost(canvas);
   }
 
-  private boolean feedInputBuffer(long positionUs) throws IOException, VpxDecoderException {
+  private boolean feedInputBuffer(long positionUs) throws VpxDecoderException {
     if (inputStreamEnded) {
       return false;
     }
@@ -334,7 +330,7 @@ private boolean feedInputBuffer(long positionUs) throws IOException, VpxDecoderE
     return true;
   }
 
-  private void checkForDiscontinuity(long positionUs) throws IOException {
+  private void checkForDiscontinuity(long positionUs) {
     if (decoder == null) {
       return;
     }
@@ -417,11 +413,22 @@ protected void onDisabled() {
     source.disable(trackIndex);
   }
 
-  private void readFormat(long positionUs) throws IOException {
+  @Override
+  protected void maybeThrowError() throws ExoPlaybackException {
+    try {
+      source.maybeThrowError();
+    } catch (IOException e) {
+      throw new ExoPlaybackException(e);
+    }
+  }
+
+  private boolean readFormat(long positionUs) {
     int result = source.readData(trackIndex, positionUs, formatHolder, null, false);
     if (result == SampleSource.FORMAT_READ) {
       format = formatHolder.format;
+      return true;
     }
+    return false;
   }
 
   @Override
diff --git a/library/build.gradle b/library/build.gradle
index ea115c3337..4ed58a5b5f 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -38,13 +38,6 @@ android {
     lintOptions {
         abortOnError false
     }
-
-    sourceSets {
-        androidTest {
-            assets.srcDirs = ['src/test/assets']
-            java.srcDirs = ['src/test/java']
-        }
-    }
 }
 
 dependencies {
@@ -84,7 +77,7 @@ publish {
     userOrg = 'google'
     groupId = 'com.google.android.exoplayer'
     artifactId = 'exoplayer'
-    version = 'r1.4.1'
+    version = 'r1.4.2'
     description = 'The ExoPlayer library.'
     website = 'https://github.com/google/ExoPlayer'
 }
diff --git a/library/src/test/.classpath b/library/src/androidTest/.classpath
similarity index 100%
rename from library/src/test/.classpath
rename to library/src/androidTest/.classpath
diff --git a/library/src/test/.project b/library/src/androidTest/.project
similarity index 100%
rename from library/src/test/.project
rename to library/src/androidTest/.project
diff --git a/library/src/test/.settings/org.eclipse.jdt.core.prefs b/library/src/androidTest/.settings/org.eclipse.jdt.core.prefs
similarity index 100%
rename from library/src/test/.settings/org.eclipse.jdt.core.prefs
rename to library/src/androidTest/.settings/org.eclipse.jdt.core.prefs
diff --git a/library/src/test/AndroidManifest.xml b/library/src/androidTest/AndroidManifest.xml
similarity index 92%
rename from library/src/test/AndroidManifest.xml
rename to library/src/androidTest/AndroidManifest.xml
index c9c12992a1..eb07d822e3 100644
--- a/library/src/test/AndroidManifest.xml
+++ b/library/src/androidTest/AndroidManifest.xml
@@ -28,6 +28,7 @@
 
   <instrumentation
       android:targetPackage="com.google.android.exoplayer.tests"
-      android:name="android.test.InstrumentationTestRunner"/>
+      android:name="android.test.InstrumentationTestRunner"
+      tools:replace="android:targetPackage"/>
 
 </manifest>
diff --git a/library/src/test/assets/dash/sample_mpd_1 b/library/src/androidTest/assets/dash/sample_mpd_1
similarity index 100%
rename from library/src/test/assets/dash/sample_mpd_1
rename to library/src/androidTest/assets/dash/sample_mpd_1
diff --git a/library/src/test/assets/subrip/empty b/library/src/androidTest/assets/subrip/empty
similarity index 100%
rename from library/src/test/assets/subrip/empty
rename to library/src/androidTest/assets/subrip/empty
diff --git a/library/src/test/assets/subrip/typical b/library/src/androidTest/assets/subrip/typical
similarity index 100%
rename from library/src/test/assets/subrip/typical
rename to library/src/androidTest/assets/subrip/typical
diff --git a/library/src/test/assets/webm/vorbis_codec_private b/library/src/androidTest/assets/webm/vorbis_codec_private
similarity index 100%
rename from library/src/test/assets/webm/vorbis_codec_private
rename to library/src/androidTest/assets/webm/vorbis_codec_private
diff --git a/library/src/test/assets/webvtt/empty b/library/src/androidTest/assets/webvtt/empty
similarity index 100%
rename from library/src/test/assets/webvtt/empty
rename to library/src/androidTest/assets/webvtt/empty
diff --git a/library/src/test/assets/webvtt/live_typical b/library/src/androidTest/assets/webvtt/live_typical
similarity index 100%
rename from library/src/test/assets/webvtt/live_typical
rename to library/src/androidTest/assets/webvtt/live_typical
diff --git a/library/src/test/assets/webvtt/typical b/library/src/androidTest/assets/webvtt/typical
similarity index 100%
rename from library/src/test/assets/webvtt/typical
rename to library/src/androidTest/assets/webvtt/typical
diff --git a/library/src/test/assets/webvtt/typical_with_identifiers b/library/src/androidTest/assets/webvtt/typical_with_identifiers
similarity index 100%
rename from library/src/test/assets/webvtt/typical_with_identifiers
rename to library/src/androidTest/assets/webvtt/typical_with_identifiers
diff --git a/library/src/test/assets/webvtt/typical_with_tags b/library/src/androidTest/assets/webvtt/typical_with_tags
similarity index 100%
rename from library/src/test/assets/webvtt/typical_with_tags
rename to library/src/androidTest/assets/webvtt/typical_with_tags
diff --git a/library/src/test/java/com/google/android/exoplayer/CTest.java b/library/src/androidTest/java/com/google/android/exoplayer/CTest.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/CTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/CTest.java
diff --git a/library/src/test/java/com/google/android/exoplayer/MediaFormatTest.java b/library/src/androidTest/java/com/google/android/exoplayer/MediaFormatTest.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/MediaFormatTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/MediaFormatTest.java
diff --git a/library/src/test/java/com/google/android/exoplayer/TimeRangeTest.java b/library/src/androidTest/java/com/google/android/exoplayer/TimeRangeTest.java
similarity index 99%
rename from library/src/test/java/com/google/android/exoplayer/TimeRangeTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/TimeRangeTest.java
index 5c93130de6..58df649d65 100644
--- a/library/src/test/java/com/google/android/exoplayer/TimeRangeTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/TimeRangeTest.java
@@ -25,10 +25,10 @@
   public void testEquals() {
     TimeRange timeRange1 = new TimeRange(TimeRange.TYPE_SNAPSHOT, 0, 30000000);
     assertTrue(timeRange1.equals(timeRange1));
-    
+
     TimeRange timeRange2 = new TimeRange(TimeRange.TYPE_SNAPSHOT, 0, 30000000);
     assertTrue(timeRange1.equals(timeRange2));
-    
+
     TimeRange timeRange3 = new TimeRange(TimeRange.TYPE_SNAPSHOT, 0, 60000000);
     assertFalse(timeRange1.equals(timeRange3));
   }
diff --git a/library/src/test/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java b/library/src/androidTest/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java
similarity index 99%
rename from library/src/test/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java
index 70d3b195db..db387c179a 100644
--- a/library/src/test/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/dash/DashChunkSourceTest.java
@@ -82,7 +82,6 @@
       new Format("3", "video/mp4", WIDE_WIDTH, 50, -1, -1, -1, 1000);
 
   @Mock private DataSource mockDataSource;
-  @Mock private ManifestFetcher<MediaPresentationDescription> mockManifestFetcher;
 
   @Override
   public void setUp() throws Exception {
diff --git a/library/src/test/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParserTest.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParserTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParserTest.java
diff --git a/library/src/test/java/com/google/android/exoplayer/dash/mpd/RangedUriTest.java b/library/src/androidTest/java/com/google/android/exoplayer/dash/mpd/RangedUriTest.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/dash/mpd/RangedUriTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/dash/mpd/RangedUriTest.java
diff --git a/library/src/test/java/com/google/android/exoplayer/dash/mpd/RepresentationTest.java b/library/src/androidTest/java/com/google/android/exoplayer/dash/mpd/RepresentationTest.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/dash/mpd/RepresentationTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/dash/mpd/RepresentationTest.java
diff --git a/library/src/test/java/com/google/android/exoplayer/dash/mpd/UrlTemplateTest.java b/library/src/androidTest/java/com/google/android/exoplayer/dash/mpd/UrlTemplateTest.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/dash/mpd/UrlTemplateTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/dash/mpd/UrlTemplateTest.java
diff --git a/library/src/test/java/com/google/android/exoplayer/extractor/DefaultExtractorInputTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/DefaultExtractorInputTest.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/extractor/DefaultExtractorInputTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/extractor/DefaultExtractorInputTest.java
diff --git a/library/src/test/java/com/google/android/exoplayer/extractor/ExtractorTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ExtractorTest.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/extractor/ExtractorTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/extractor/ExtractorTest.java
diff --git a/library/src/test/java/com/google/android/exoplayer/extractor/mp3/BufferingInputTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/mp3/BufferingInputTest.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/extractor/mp3/BufferingInputTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/extractor/mp3/BufferingInputTest.java
diff --git a/library/src/test/java/com/google/android/exoplayer/extractor/mp4/Mp4ExtractorTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/mp4/Mp4ExtractorTest.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/extractor/mp4/Mp4ExtractorTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/extractor/mp4/Mp4ExtractorTest.java
diff --git a/library/src/test/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReaderTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReaderTest.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReaderTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/DefaultEbmlReaderTest.java
diff --git a/library/src/test/java/com/google/android/exoplayer/extractor/webm/StreamBuilder.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/StreamBuilder.java
similarity index 89%
rename from library/src/test/java/com/google/android/exoplayer/extractor/webm/StreamBuilder.java
rename to library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/StreamBuilder.java
index 100904ed35..e644cc0624 100644
--- a/library/src/test/java/com/google/android/exoplayer/extractor/webm/StreamBuilder.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/StreamBuilder.java
@@ -80,8 +80,14 @@ public StreamBuilder setHeader(String docType) {
     return this;
   }
 
-  public StreamBuilder setInfo(int timecodeScale, long durationUs) {
-    info = createInfoElement(timecodeScale, durationUs);
+  public StreamBuilder setInfo(int timecodeScale, long durationTimecode) {
+    return setInfo(timecodeScale, durationTimecode, false, false);
+  }
+
+  public StreamBuilder setInfo(int timecodeScale, long durationTimecode,
+      boolean omitTimecodeScaleIfDefault, boolean durationFirst) {
+    info = createInfoElement(timecodeScale, durationTimecode, omitTimecodeScaleIfDefault,
+        durationFirst);
     return this;
   }
 
@@ -177,28 +183,38 @@ public StreamBuilder addBlockMedia(int trackNumber, int clusterTimecode, int blo
     Assertions.checkNotNull(info);
 
     EbmlElement tracks = element(0x1654AE6B, trackEntries.toArray(new EbmlElement[0]));
+    EbmlElement[] children;
+
+    if (cuePointCount == 0) {
+      children = new EbmlElement[2 + mediaSegments.size()];
+      System.arraycopy(mediaSegments.toArray(new EbmlElement[0]), 0, children, 2,
+          mediaSegments.size());
+      children[0] = info;
+      children[1] = tracks;
+    } else {
+      // Get the size of the initialization segment.
+      EbmlElement[] cuePointElements = new EbmlElement[cuePointCount];
+      for (int i = 0; i < cuePointCount; i++) {
+        cuePointElements[i] = createCuePointElement(10 * i, 0);
+      }
+      EbmlElement cues = element(0x1C53BB6B, cuePointElements); // Cues
+      long initializationSegmentSize = info.getSize() + tracks.getSize() + cues.getSize();
 
-    // Get the size of the initialization segment.
-    EbmlElement[] cuePointElements = new EbmlElement[cuePointCount];
-    for (int i = 0; i < cuePointCount; i++) {
-      cuePointElements[i] = createCuePointElement(10 * i, 0);
+      // Recreate the initialization segment using its size as an offset.
+      for (int i = 0; i < cuePointCount; i++) {
+        cuePointElements[i] = createCuePointElement(10 * i, (int) initializationSegmentSize);
+      }
+      cues = element(0x1C53BB6B, cuePointElements); // Cues
+
+      // Build the top-level segment element.
+      children = new EbmlElement[3 + mediaSegments.size()];
+      System.arraycopy(mediaSegments.toArray(new EbmlElement[0]), 0, children, 3,
+          mediaSegments.size());
+      children[0] = info;
+      children[1] = tracks;
+      children[2] = cues;
     }
-    EbmlElement cues = element(0x1C53BB6B, cuePointElements); // Cues
-    long initializationSegmentSize = info.getSize() + tracks.getSize() + cues.getSize();
 
-    // Recreate the initialization segment using its size as an offset.
-    for (int i = 0; i < cuePointCount; i++) {
-      cuePointElements[i] = createCuePointElement(10 * i, (int) initializationSegmentSize);
-    }
-    cues = element(0x1C53BB6B, cuePointElements); // Cues
-
-    // Build the top-level segment element.
-    EbmlElement[] children = new EbmlElement[3 + mediaSegments.size()];
-    System.arraycopy(mediaSegments.toArray(new EbmlElement[0]), 0, children, 3,
-        mediaSegments.size());
-    children[0] = info;
-    children[1] = tracks;
-    children[2] = cues;
     EbmlElement segmentElement = element(0x18538067, children); // Segment
 
     // Serialize the EBML header and the top-level segment element.
@@ -221,12 +237,19 @@ private static EbmlElement createEbmlElement(int ebmlReadVersion, String docType
         element(0x4285, (byte) (docTypeReadVersion & 0xFF))); // DocTypeReadVersion
   }
 
-  private EbmlElement createInfoElement(int timecodeScale, long durationUs) {
+  private EbmlElement createInfoElement(int timecodeScale, long durationTimecode,
+      boolean durationFirst, boolean omitDefaultTimecodeScale) {
     byte[] timecodeScaleBytes = getIntegerBytes(timecodeScale);
-    byte[] durationBytes = getLongBytes(Double.doubleToLongBits(durationUs / 1000.0));
+    byte[] durationBytes = getLongBytes(Double.doubleToLongBits(durationTimecode));
+    EbmlElement durationElement = element(0x4489, durationBytes);
+    EbmlElement timescaleElement = element(0x2AD7B1, timecodeScaleBytes);
+    if (omitDefaultTimecodeScale && timecodeScale == 1000000) {
+      return element(0x1549A966, // Info
+          durationElement);
+    }
     return element(0x1549A966, // Info
-        element(0x2AD7B1, timecodeScaleBytes), // TimecodeScale
-        element(0x4489, durationBytes)); // Duration
+        durationFirst ? durationElement : timescaleElement,
+        durationFirst ? timescaleElement : durationElement);
   }
 
   private static EbmlElement createVideoTrackEntry(String codecId, int pixelWidth, int pixelHeight,
diff --git a/library/src/test/java/com/google/android/exoplayer/extractor/webm/VarintReaderTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/VarintReaderTest.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/extractor/webm/VarintReaderTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/VarintReaderTest.java
diff --git a/library/src/test/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java
similarity index 76%
rename from library/src/test/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java
index aff52f091a..0c0e916596 100644
--- a/library/src/test/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/webm/WebmExtractorTest.java
@@ -22,11 +22,13 @@
 import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.drm.DrmInitData;
 import com.google.android.exoplayer.extractor.ChunkIndex;
+import com.google.android.exoplayer.extractor.SeekMap;
 import com.google.android.exoplayer.extractor.webm.StreamBuilder.ContentEncodingSettings;
 import com.google.android.exoplayer.testutil.FakeExtractorOutput;
 import com.google.android.exoplayer.testutil.FakeTrackOutput;
 import com.google.android.exoplayer.testutil.TestUtil;
 import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.Util;
 
 import android.test.InstrumentationTestCase;
 
@@ -41,7 +43,7 @@
 public final class WebmExtractorTest extends InstrumentationTestCase {
 
   private static final int DEFAULT_TIMECODE_SCALE = 1000000;
-  private static final long TEST_DURATION_US = 9920000L;
+  private static final long TEST_DURATION_TIMECODE = 9920L;
   private static final int TEST_WIDTH = 1280;
   private static final int TEST_HEIGHT = 720;
   private static final int TEST_CHANNEL_COUNT = 1;
@@ -82,20 +84,21 @@ public void tearDown() {
   public void testReadInitializationSegment() throws IOException, InterruptedException {
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
         .build(1);
 
     TestUtil.consumeTestData(extractor, data);
 
-    assertVp9VideoFormat();
-    assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
+    assertTracksEnded();
+    assertVp9VideoFormat(DEFAULT_TIMECODE_SCALE);
+    assertIndex(DEFAULT_TIMECODE_SCALE, 1);
   }
 
   public void testReadSegmentTwice() throws IOException, InterruptedException {
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
         .build(1);
 
@@ -103,54 +106,58 @@ public void testReadSegmentTwice() throws IOException, InterruptedException {
     extractor.seek();
     TestUtil.consumeTestData(extractor, data);
 
-    assertVp9VideoFormat();
-    assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
+    assertTracksEnded();
+    assertVp9VideoFormat(DEFAULT_TIMECODE_SCALE);
+    assertIndex(DEFAULT_TIMECODE_SCALE, 1);
   }
 
   public void testPrepareOpus() throws IOException, InterruptedException {
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addOpusTrack(TEST_CHANNEL_COUNT, TEST_SAMPLE_RATE, TEST_CODEC_DELAY,
             TEST_SEEK_PRE_ROLL, TEST_OPUS_CODEC_PRIVATE)
         .build(1);
 
     TestUtil.consumeTestData(extractor, data);
 
-    assertAudioFormat(MimeTypes.AUDIO_OPUS);
-    assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
+    assertTracksEnded();
+    assertAudioFormat(DEFAULT_TIMECODE_SCALE, MimeTypes.AUDIO_OPUS);
+    assertIndex(DEFAULT_TIMECODE_SCALE, 1);
   }
 
   public void testPrepareVorbis() throws IOException, InterruptedException {
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVorbisTrack(TEST_CHANNEL_COUNT, TEST_SAMPLE_RATE, getVorbisCodecPrivate())
         .build(1);
 
     TestUtil.consumeTestData(extractor, data);
 
-    assertAudioFormat(MimeTypes.AUDIO_VORBIS);
-    assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
+    assertTracksEnded();
+    assertAudioFormat(DEFAULT_TIMECODE_SCALE, MimeTypes.AUDIO_VORBIS);
+    assertIndex(DEFAULT_TIMECODE_SCALE, 1);
   }
 
   public void testPrepareH264() throws IOException, InterruptedException {
     byte[] data = new StreamBuilder()
         .setHeader(MATROSKA_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addH264Track(TEST_WIDTH, TEST_HEIGHT, TEST_H264_CODEC_PRIVATE)
         .build(1);
 
     TestUtil.consumeTestData(extractor, data);
 
-    assertH264VideoFormat();
-    assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
+    assertTracksEnded();
+    assertH264VideoFormat(DEFAULT_TIMECODE_SCALE);
+    assertIndex(DEFAULT_TIMECODE_SCALE, 1);
   }
 
   public void testPrepareTwoTracks() throws IOException, InterruptedException {
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
         .addOpusTrack(TEST_CHANNEL_COUNT, TEST_SAMPLE_RATE, TEST_CODEC_DELAY,
             TEST_SEEK_PRE_ROLL, TEST_OPUS_CODEC_PRIVATE)
@@ -158,16 +165,17 @@ public void testPrepareTwoTracks() throws IOException, InterruptedException {
 
     TestUtil.consumeTestData(extractor, data);
 
+    assertTracksEnded();
     assertEquals(2, extractorOutput.numberOfTracks);
-    assertVp9VideoFormat();
-    assertAudioFormat(MimeTypes.AUDIO_OPUS);
-    assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
+    assertVp9VideoFormat(DEFAULT_TIMECODE_SCALE);
+    assertAudioFormat(DEFAULT_TIMECODE_SCALE, MimeTypes.AUDIO_OPUS);
+    assertIndex(DEFAULT_TIMECODE_SCALE, 1);
   }
 
   public void testPrepareThreeTracks() throws IOException, InterruptedException {
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
         .addUnsupportedTrack()
         .addOpusTrack(TEST_CHANNEL_COUNT, TEST_SAMPLE_RATE, TEST_CODEC_DELAY,
@@ -176,17 +184,18 @@ public void testPrepareThreeTracks() throws IOException, InterruptedException {
 
     TestUtil.consumeTestData(extractor, data);
 
+    assertTracksEnded();
     // Even though the input stream has 3 tracks, only 2 of them are supported and will be reported.
     assertEquals(2, extractorOutput.numberOfTracks);
-    assertVp9VideoFormat();
-    assertAudioFormat(MimeTypes.AUDIO_OPUS);
-    assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
+    assertVp9VideoFormat(DEFAULT_TIMECODE_SCALE);
+    assertAudioFormat(DEFAULT_TIMECODE_SCALE, MimeTypes.AUDIO_OPUS);
+    assertIndex(DEFAULT_TIMECODE_SCALE, 1);
   }
 
   public void testPrepareFourTracks() throws IOException, InterruptedException {
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
         .addVorbisTrack(TEST_CHANNEL_COUNT, TEST_SAMPLE_RATE, getVorbisCodecPrivate())
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
@@ -196,26 +205,28 @@ public void testPrepareFourTracks() throws IOException, InterruptedException {
 
     TestUtil.consumeTestData(extractor, data);
 
+    assertTracksEnded();
     // Even though the input stream has 4 supported tracks, only the first video and audio track
     // will be reported.
     assertEquals(2, extractorOutput.numberOfTracks);
-    assertVp9VideoFormat();
-    assertAudioFormat(MimeTypes.AUDIO_VORBIS);
-    assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
+    assertVp9VideoFormat(DEFAULT_TIMECODE_SCALE);
+    assertAudioFormat(DEFAULT_TIMECODE_SCALE, MimeTypes.AUDIO_VORBIS);
+    assertIndex(DEFAULT_TIMECODE_SCALE, 1);
   }
 
   public void testPrepareContentEncodingEncryption() throws IOException, InterruptedException {
     ContentEncodingSettings settings = new StreamBuilder.ContentEncodingSettings(0, 1, 5, 1);
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, settings)
         .build(1);
 
     TestUtil.consumeTestData(extractor, data);
 
-    assertVp9VideoFormat();
-    assertIndex(new IndexPoint(0, 0, TEST_DURATION_US));
+    assertTracksEnded();
+    assertVp9VideoFormat(DEFAULT_TIMECODE_SCALE);
+    assertIndex(DEFAULT_TIMECODE_SCALE, 1);
     DrmInitData drmInitData = extractorOutput.drmInitData;
     assertNotNull(drmInitData);
     android.test.MoreAsserts.assertEquals(TEST_ENCRYPTION_KEY_ID, drmInitData.get(WIDEVINE_UUID));
@@ -225,75 +236,91 @@ public void testPrepareContentEncodingEncryption() throws IOException, Interrupt
   public void testPrepareThreeCuePoints() throws IOException, InterruptedException {
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
         .build(3);
 
     TestUtil.consumeTestData(extractor, data);
 
-    assertVp9VideoFormat();
-    assertIndex(
-        new IndexPoint(0, 0, 10000),
-        new IndexPoint(10000, 0, 10000),
-        new IndexPoint(20000, 0, TEST_DURATION_US - 20000));
+    assertTracksEnded();
+    assertVp9VideoFormat(DEFAULT_TIMECODE_SCALE);
+    assertIndex(DEFAULT_TIMECODE_SCALE, 3);
   }
 
-  public void testPrepareCustomTimecodeScale() throws IOException, InterruptedException {
+  public void testPrepareCustomTimecodeScaleBeforeDuration()
+      throws IOException, InterruptedException {
+    testPrepareTimecodeScale(1000, false, false);
+  }
+
+  public void testPrepareCustomTimecodeScaleAfterDuration()
+      throws IOException, InterruptedException {
+    testPrepareTimecodeScale(1000, false, true);
+  }
+
+  public void testPrepareImplicitDefaultTimecode()
+      throws IOException, InterruptedException {
+    testPrepareTimecodeScale(1000, false, true);
+  }
+
+  private void testPrepareTimecodeScale(int timecodeScale, boolean omitTimecodeScaleIfDefault,
+      boolean afterDuration) throws IOException, InterruptedException {
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(1000, TEST_DURATION_US)
+        .setInfo(timecodeScale, TEST_DURATION_TIMECODE, omitTimecodeScaleIfDefault, afterDuration)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
         .build(3);
 
     TestUtil.consumeTestData(extractor, data);
 
-    assertVp9VideoFormat();
-    assertIndex(
-        new IndexPoint(0, 0, 10),
-        new IndexPoint(10, 0, 10),
-        new IndexPoint(20, 0, (TEST_DURATION_US / 1000) - 20));
+    assertTracksEnded();
+    assertVp9VideoFormat(timecodeScale);
+    assertIndex(timecodeScale, 3);
   }
 
-  public void testPrepareNoCuePoints() throws IOException, InterruptedException {
+  public void testPrepareNoCuesElement() throws IOException, InterruptedException {
+    byte[] media = createFrameData(100);
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
+        .addSimpleBlockMedia(1 /* trackNumber */, 0 /* clusterTimecode */, 0 /* blockTimecode */,
+            true /* keyframe */, false /* invisible */, media)
         .build(0);
-    try {
-      TestUtil.consumeTestData(extractor, data);
-      fail();
-    } catch (ParserException exception) {
-      assertEquals("Invalid/missing cue points", exception.getMessage());
-    }
+
+    TestUtil.consumeTestData(extractor, data);
+
+    assertTracksEnded();
+    assertIndexUnseekable();
   }
 
   public void testAcceptsWebmDocType() throws IOException, InterruptedException {
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
         .build(1);
 
-    // No exception is thrown.
     TestUtil.consumeTestData(extractor, data);
+
+    assertTracksEnded();
   }
 
   public void testAcceptsMatroskaDocType() throws IOException, InterruptedException {
     byte[] data = new StreamBuilder()
         .setHeader(MATROSKA_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
         .build(1);
 
-    // No exception is thrown.
     TestUtil.consumeTestData(extractor, data);
+
+    assertTracksEnded();
   }
 
   public void testPrepareInvalidDocType() throws IOException, InterruptedException {
     byte[] data = new StreamBuilder()
         .setHeader("webB")
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
         .build(1);
     try {
@@ -308,7 +335,7 @@ public void testPrepareInvalidContentEncodingOrder() throws IOException, Interru
     ContentEncodingSettings settings = new ContentEncodingSettings(1, 1, 5, 1);
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, settings)
         .build(1);
     try {
@@ -323,7 +350,7 @@ public void testPrepareInvalidContentEncodingScope() throws IOException, Interru
     ContentEncodingSettings settings = new ContentEncodingSettings(0, 0, 5, 1);
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, settings)
         .build(1);
     try {
@@ -339,7 +366,7 @@ public void testPrepareInvalidContentCompAlgo()
     ContentEncodingSettings settings = new ContentEncodingSettings(0, 1, 0, new byte[0]);
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, settings)
         .build(1);
     try {
@@ -354,7 +381,7 @@ public void testPrepareInvalidContentEncAlgo() throws IOException, InterruptedEx
     ContentEncodingSettings settings = new ContentEncodingSettings(0, 1, 4, 1);
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, settings)
         .build(1);
     try {
@@ -369,7 +396,7 @@ public void testPrepareInvalidAESSettingsCipherMode() throws IOException, Interr
     ContentEncodingSettings settings = new ContentEncodingSettings(0, 1, 5, 0);
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, settings)
         .build(1);
     try {
@@ -384,7 +411,7 @@ public void testReadSampleKeyframe() throws IOException, InterruptedException {
     byte[] media = createFrameData(100);
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
         .addSimpleBlockMedia(1 /* trackNumber */, 0 /* clusterTimecode */, 0 /* blockTimecode */,
             true /* keyframe */, false /* invisible */, media)
@@ -392,7 +419,8 @@ public void testReadSampleKeyframe() throws IOException, InterruptedException {
 
     TestUtil.consumeTestData(extractor, data);
 
-    assertVp9VideoFormat();
+    assertTracksEnded();
+    assertVp9VideoFormat(DEFAULT_TIMECODE_SCALE);
     assertSample(0, media, 0, true, false, null, getVideoOutput());
   }
 
@@ -403,7 +431,7 @@ public void testReadSampleKeyframeStripped() throws IOException, InterruptedExce
     byte[] unstrippedSampleBytes = TestUtil.joinByteArrays(strippedBytes, sampleBytes);
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, settings)
         .addSimpleBlockMedia(1 /* trackNumber */, 0 /* clusterTimecode */, 0 /* blockTimecode */,
             true /* keyframe */, false /* invisible */, sampleBytes)
@@ -411,7 +439,8 @@ public void testReadSampleKeyframeStripped() throws IOException, InterruptedExce
 
     TestUtil.consumeTestData(extractor, data);
 
-    assertVp9VideoFormat();
+    assertTracksEnded();
+    assertVp9VideoFormat(DEFAULT_TIMECODE_SCALE);
     assertSample(0, unstrippedSampleBytes, 0, true, false, null, getVideoOutput());
   }
 
@@ -422,7 +451,7 @@ public void testReadSampleKeyframeManyBytesStripped() throws IOException, Interr
     byte[] unstrippedSampleBytes = TestUtil.joinByteArrays(strippedBytes, sampleBytes);
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, settings)
         .addSimpleBlockMedia(1 /* trackNumber */, 0 /* clusterTimecode */, 0 /* blockTimecode */,
             true /* keyframe */, false /* invisible */, sampleBytes)
@@ -430,7 +459,8 @@ public void testReadSampleKeyframeManyBytesStripped() throws IOException, Interr
 
     TestUtil.consumeTestData(extractor, data);
 
-    assertVp9VideoFormat();
+    assertTracksEnded();
+    assertVp9VideoFormat(DEFAULT_TIMECODE_SCALE);
     assertSample(0, unstrippedSampleBytes, 0, true, false, null, getVideoOutput());
   }
 
@@ -438,7 +468,7 @@ public void testReadTwoTrackSamples() throws IOException, InterruptedException {
     byte[] media = createFrameData(100);
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
         .addOpusTrack(TEST_CHANNEL_COUNT, TEST_SAMPLE_RATE, TEST_CODEC_DELAY,
             TEST_SEEK_PRE_ROLL, TEST_OPUS_CODEC_PRIVATE)
@@ -450,9 +480,10 @@ public void testReadTwoTrackSamples() throws IOException, InterruptedException {
 
     TestUtil.consumeTestData(extractor, data);
 
+    assertTracksEnded();
     assertEquals(2, extractorOutput.numberOfTracks);
-    assertVp9VideoFormat();
-    assertAudioFormat(MimeTypes.AUDIO_OPUS);
+    assertVp9VideoFormat(DEFAULT_TIMECODE_SCALE);
+    assertAudioFormat(DEFAULT_TIMECODE_SCALE, MimeTypes.AUDIO_OPUS);
     assertSample(0, media, 0, true, false, null, getVideoOutput());
     assertSample(0, media, 0, true, false, null, getAudioOutput());
   }
@@ -461,7 +492,7 @@ public void testReadTwoTrackSamplesWithSkippedTrack() throws IOException, Interr
     byte[] media = createFrameData(100);
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addUnsupportedTrack()
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
         .addOpusTrack(TEST_CHANNEL_COUNT, TEST_SAMPLE_RATE, TEST_CODEC_DELAY,
@@ -476,9 +507,10 @@ public void testReadTwoTrackSamplesWithSkippedTrack() throws IOException, Interr
 
     TestUtil.consumeTestData(extractor, data);
 
+    assertTracksEnded();
     assertEquals(2, extractorOutput.numberOfTracks);
-    assertVp9VideoFormat();
-    assertAudioFormat(MimeTypes.AUDIO_OPUS);
+    assertVp9VideoFormat(DEFAULT_TIMECODE_SCALE);
+    assertAudioFormat(DEFAULT_TIMECODE_SCALE, MimeTypes.AUDIO_OPUS);
     assertSample(0, media, 0, true, false, null, getVideoOutput());
     assertSample(0, media, 0, true, false, null, getAudioOutput());
   }
@@ -487,7 +519,7 @@ public void testReadBlock() throws IOException, InterruptedException {
     byte[] media = createFrameData(100);
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addOpusTrack(TEST_CHANNEL_COUNT, TEST_SAMPLE_RATE, TEST_CODEC_DELAY,
             TEST_SEEK_PRE_ROLL, TEST_OPUS_CODEC_PRIVATE)
         .addBlockMedia(2 /* trackNumber */, 0 /* clusterTimecode */, 0 /* blockTimecode */,
@@ -496,7 +528,8 @@ public void testReadBlock() throws IOException, InterruptedException {
 
     TestUtil.consumeTestData(extractor, data);
 
-    assertAudioFormat(MimeTypes.AUDIO_OPUS);
+    assertTracksEnded();
+    assertAudioFormat(DEFAULT_TIMECODE_SCALE, MimeTypes.AUDIO_OPUS);
     assertSample(0, media, 0, true, false, null, getAudioOutput());
   }
 
@@ -504,7 +537,7 @@ public void testReadBlockNonKeyframe() throws IOException, InterruptedException
     byte[] media = createFrameData(100);
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
         .addBlockMedia(1 /* trackNumber */, 0 /* clusterTimecode */, 0 /* blockTimecode */,
             false /* keyframe */, false /* invisible */, media)
@@ -512,7 +545,8 @@ public void testReadBlockNonKeyframe() throws IOException, InterruptedException
 
     TestUtil.consumeTestData(extractor, data);
 
-    assertVp9VideoFormat();
+    assertTracksEnded();
+    assertVp9VideoFormat(DEFAULT_TIMECODE_SCALE);
     assertSample(0, media, 0, false, false, null, getVideoOutput());
   }
 
@@ -521,7 +555,7 @@ public void testReadEncryptedFrame() throws IOException, InterruptedException {
     ContentEncodingSettings settings = new ContentEncodingSettings(0, 1, 5, 1);
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, settings)
         .addSimpleBlockEncryptedMedia(1 /* trackNumber */, 0 /* clusterTimecode */,
             0 /* blockTimecode */, true /* keyframe */, false /* invisible */,
@@ -530,7 +564,8 @@ public void testReadEncryptedFrame() throws IOException, InterruptedException {
 
     TestUtil.consumeTestData(extractor, data);
 
-    assertVp9VideoFormat();
+    assertTracksEnded();
+    assertVp9VideoFormat(DEFAULT_TIMECODE_SCALE);
     assertSample(0, media, 0, true, false, TEST_ENCRYPTION_KEY_ID, getVideoOutput());
   }
 
@@ -540,7 +575,7 @@ public void testReadEncryptedFrameWithInvalidSignalByte()
     ContentEncodingSettings settings = new ContentEncodingSettings(0, 1, 5, 1);
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, settings)
         .addSimpleBlockEncryptedMedia(1 /* trackNumber */, 0 /* clusterTimecode */,
             0 /* blockTimecode */, true /* keyframe */, false /* invisible */,
@@ -551,6 +586,7 @@ public void testReadEncryptedFrameWithInvalidSignalByte()
       TestUtil.consumeTestData(extractor, data);
       fail();
     } catch (ParserException exception) {
+      assertTracksEnded();
       assertEquals("Extension bit is set in signal byte", exception.getMessage());
     }
   }
@@ -559,7 +595,7 @@ public void testReadSampleInvisible() throws IOException, InterruptedException {
     byte[] media = createFrameData(100);
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
         .addSimpleBlockMedia(1 /* trackNumber */, 12 /* clusterTimecode */, 13 /* blockTimecode */,
             false /* keyframe */, true /* invisible */, media)
@@ -567,15 +603,17 @@ public void testReadSampleInvisible() throws IOException, InterruptedException {
 
     TestUtil.consumeTestData(extractor, data);
 
-    assertVp9VideoFormat();
+    assertTracksEnded();
+    assertVp9VideoFormat(DEFAULT_TIMECODE_SCALE);
     assertSample(0, media, 25000, false, true, null, getVideoOutput());
   }
 
-  public void testReadSampleCustomTimescale() throws IOException, InterruptedException {
+  public void testReadSampleCustomTimecodeScale() throws IOException, InterruptedException {
+    int timecodeScale = 1000;
     byte[] media = createFrameData(100);
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(1000, TEST_DURATION_US)
+        .setInfo(timecodeScale, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
         .addSimpleBlockMedia(1 /* trackNumber */, 12 /* clusterTimecode */, 13 /* blockTimecode */,
             false /* keyframe */, false /* invisible */, media)
@@ -583,7 +621,8 @@ public void testReadSampleCustomTimescale() throws IOException, InterruptedExcep
 
     TestUtil.consumeTestData(extractor, data);
 
-    assertVp9VideoFormat();
+    assertTracksEnded();
+    assertVp9VideoFormat(timecodeScale);
     assertSample(0, media, 25, false, false, null, getVideoOutput());
   }
 
@@ -591,7 +630,7 @@ public void testReadSampleNegativeSimpleBlockTimecode() throws IOException, Inte
     byte[] media = createFrameData(100);
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addVp9Track(TEST_WIDTH, TEST_HEIGHT, null)
         .addSimpleBlockMedia(1 /* trackNumber */, 13 /* clusterTimecode */, -12 /* blockTimecode */,
             true /* keyframe */, true /* invisible */, media)
@@ -599,7 +638,8 @@ public void testReadSampleNegativeSimpleBlockTimecode() throws IOException, Inte
 
     TestUtil.consumeTestData(extractor, data);
 
-    assertVp9VideoFormat();
+    assertTracksEnded();
+    assertVp9VideoFormat(DEFAULT_TIMECODE_SCALE);
     assertSample(0, media, 1000, true, true, null, getVideoOutput());
   }
 
@@ -607,7 +647,7 @@ public void testReadSampleWithFixedSizeLacing() throws IOException, InterruptedE
     byte[] media = createFrameData(100);
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addOpusTrack(TEST_CHANNEL_COUNT, TEST_SAMPLE_RATE, TEST_CODEC_DELAY, TEST_SEEK_PRE_ROLL,
             TEST_OPUS_CODEC_PRIVATE, TEST_DEFAULT_DURATION_NS)
         .addSimpleBlockMediaWithFixedSizeLacing(2 /* trackNumber */, 0 /* clusterTimecode */,
@@ -616,7 +656,8 @@ public void testReadSampleWithFixedSizeLacing() throws IOException, InterruptedE
 
     TestUtil.consumeTestData(extractor, data);
 
-    assertAudioFormat(MimeTypes.AUDIO_OPUS);
+    assertTracksEnded();
+    assertAudioFormat(DEFAULT_TIMECODE_SCALE, MimeTypes.AUDIO_OPUS);
     for (int i = 0; i < 20; i++) {
       long expectedTimeUs = i * TEST_DEFAULT_DURATION_NS / 1000;
       assertSample(i, Arrays.copyOfRange(media, i * 5, i * 5 + 5), expectedTimeUs, true, false,
@@ -628,7 +669,7 @@ public void testReadSampleWithXiphLacing() throws IOException, InterruptedExcept
     byte[] media = createFrameData(300);
     byte[] data = new StreamBuilder()
         .setHeader(WEBM_DOC_TYPE)
-        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_US)
+        .setInfo(DEFAULT_TIMECODE_SCALE, TEST_DURATION_TIMECODE)
         .addOpusTrack(TEST_CHANNEL_COUNT, TEST_SAMPLE_RATE, TEST_CODEC_DELAY, TEST_SEEK_PRE_ROLL,
             TEST_OPUS_CODEC_PRIVATE, TEST_DEFAULT_DURATION_NS)
         .addSimpleBlockMediaWithXiphLacing(2 /* trackNumber */, 0 /* clusterTimecode */,
@@ -637,7 +678,8 @@ public void testReadSampleWithXiphLacing() throws IOException, InterruptedExcept
 
     TestUtil.consumeTestData(extractor, data);
 
-    assertAudioFormat(MimeTypes.AUDIO_OPUS);
+    assertTracksEnded();
+    assertAudioFormat(DEFAULT_TIMECODE_SCALE, MimeTypes.AUDIO_OPUS);
     assertSample(0, Arrays.copyOfRange(media, 0, 256), 0 * TEST_DEFAULT_DURATION_NS / 1000, true,
         false, null, getAudioOutput());
     assertSample(1, Arrays.copyOfRange(media, 256, 257), 1 * TEST_DEFAULT_DURATION_NS / 1000, true,
@@ -656,22 +698,32 @@ private FakeTrackOutput getAudioOutput() {
     return extractorOutput.trackOutputs.get(2);
   }
 
-  private void assertVp9VideoFormat() {
+  private void assertTracksEnded() {
+    assertTrue(extractorOutput.tracksEnded);
+  }
+
+  private void assertVp9VideoFormat(int timecodeScale) {
     MediaFormat format = getVideoOutput().format;
+    assertEquals(Util.scaleLargeTimestamp(TEST_DURATION_TIMECODE, timecodeScale, 1000),
+        format.durationUs);
     assertEquals(TEST_WIDTH, format.width);
     assertEquals(TEST_HEIGHT, format.height);
     assertEquals(MimeTypes.VIDEO_VP9, format.mimeType);
   }
 
-  private void assertH264VideoFormat() {
+  private void assertH264VideoFormat(int timecodeScale) {
     MediaFormat format = getVideoOutput().format;
+    assertEquals(Util.scaleLargeTimestamp(TEST_DURATION_TIMECODE, timecodeScale, 1000),
+        format.durationUs);
     assertEquals(TEST_WIDTH, format.width);
     assertEquals(TEST_HEIGHT, format.height);
     assertEquals(MimeTypes.VIDEO_H264, format.mimeType);
   }
 
-  private void assertAudioFormat(String expectedMimeType) {
+  private void assertAudioFormat(int timecodeScale, String expectedMimeType) {
     MediaFormat format = getAudioOutput().format;
+    assertEquals(Util.scaleLargeTimestamp(TEST_DURATION_TIMECODE, timecodeScale, 1000),
+        format.durationUs);
     assertEquals(TEST_CHANNEL_COUNT, format.channelCount);
     assertEquals(TEST_SAMPLE_RATE, format.sampleRate);
     assertEquals(expectedMimeType, format.mimeType);
@@ -688,15 +740,25 @@ private void assertAudioFormat(String expectedMimeType) {
     }
   }
 
-  private void assertIndex(IndexPoint... indexPoints) {
+  private void assertIndex(int timecodeScale, int cuePointCount) {
     ChunkIndex index = (ChunkIndex) extractorOutput.seekMap;
-    assertEquals(indexPoints.length, index.length);
-    for (int i = 0; i < indexPoints.length; i++) {
-      IndexPoint indexPoint = indexPoints[i];
-      assertEquals(indexPoint.timeUs, index.timesUs[i]);
-      assertEquals(indexPoint.size, index.sizes[i]);
-      assertEquals(indexPoint.durationUs, index.durationsUs[i]);
+    assertEquals(cuePointCount, index.length);
+    for (int i = 0; i < cuePointCount - 1; i++) {
+      assertEquals(Util.scaleLargeTimestamp(10 * i, timecodeScale, 1000), index.timesUs[i]);
+      assertEquals(Util.scaleLargeTimestamp(10, timecodeScale, 1000), index.durationsUs[i]);
+      assertEquals(0, index.sizes[i]);
     }
+    int lastIndex = cuePointCount - 1;
+    long lastTimecode = 10 * lastIndex;
+    long lastDurationTimecode = TEST_DURATION_TIMECODE - lastTimecode;
+    assertEquals(Util.scaleLargeTimestamp(lastTimecode, timecodeScale, 1000),
+        index.timesUs[lastIndex]);
+    assertEquals(Util.scaleLargeTimestamp(lastDurationTimecode, timecodeScale, 1000),
+        index.durationsUs[lastIndex]);
+  }
+
+  private void assertIndexUnseekable() {
+    assertEquals(SeekMap.UNSEEKABLE, extractorOutput.seekMap);
   }
 
   private void assertSample(int index, byte[] expectedMedia, long timeUs, boolean keyframe,
@@ -732,19 +794,4 @@ private void assertSample(int index, byte[] expectedMedia, long timeUs, boolean
     return data;
   }
 
-  /** Used by {@link #assertIndex(IndexPoint...)} to validate index elements. */
-  private static final class IndexPoint {
-
-    private final long timeUs;
-    private final int size;
-    private final long durationUs;
-
-    private IndexPoint(long timeUs, int size, long durationUs) {
-      this.timeUs = timeUs;
-      this.size = size;
-      this.durationUs = durationUs;
-    }
-
-  }
-
 }
diff --git a/library/src/test/java/com/google/android/exoplayer/hls/HlsMasterPlaylistParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/hls/HlsMasterPlaylistParserTest.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/hls/HlsMasterPlaylistParserTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/hls/HlsMasterPlaylistParserTest.java
diff --git a/library/src/test/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java
diff --git a/library/src/test/java/com/google/android/exoplayer/metadata/Id3ParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/metadata/Id3ParserTest.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/metadata/Id3ParserTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/metadata/Id3ParserTest.java
diff --git a/library/src/test/java/com/google/android/exoplayer/testutil/FakeDataSource.java b/library/src/androidTest/java/com/google/android/exoplayer/testutil/FakeDataSource.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/testutil/FakeDataSource.java
rename to library/src/androidTest/java/com/google/android/exoplayer/testutil/FakeDataSource.java
diff --git a/library/src/test/java/com/google/android/exoplayer/testutil/FakeExtractorOutput.java b/library/src/androidTest/java/com/google/android/exoplayer/testutil/FakeExtractorOutput.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/testutil/FakeExtractorOutput.java
rename to library/src/androidTest/java/com/google/android/exoplayer/testutil/FakeExtractorOutput.java
diff --git a/library/src/test/java/com/google/android/exoplayer/testutil/FakeTrackOutput.java b/library/src/androidTest/java/com/google/android/exoplayer/testutil/FakeTrackOutput.java
similarity index 96%
rename from library/src/test/java/com/google/android/exoplayer/testutil/FakeTrackOutput.java
rename to library/src/androidTest/java/com/google/android/exoplayer/testutil/FakeTrackOutput.java
index f673c06f00..5bdeccc4d9 100644
--- a/library/src/test/java/com/google/android/exoplayer/testutil/FakeTrackOutput.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/testutil/FakeTrackOutput.java
@@ -57,8 +57,8 @@ public void format(MediaFormat format) {
   }
 
   @Override
-  public int sampleData(ExtractorInput input, int length) throws IOException,
-      InterruptedException {
+  public int sampleData(ExtractorInput input, int length, boolean allowEndOfInput)
+      throws IOException, InterruptedException {
     byte[] newData = new byte[length];
     input.readFully(newData, 0, length);
     sampleData = TestUtil.joinByteArrays(sampleData, newData);
diff --git a/library/src/test/java/com/google/android/exoplayer/testutil/TestUtil.java b/library/src/androidTest/java/com/google/android/exoplayer/testutil/TestUtil.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/testutil/TestUtil.java
rename to library/src/androidTest/java/com/google/android/exoplayer/testutil/TestUtil.java
diff --git a/library/src/test/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java
diff --git a/library/src/test/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java
diff --git a/library/src/test/java/com/google/android/exoplayer/text/webvtt/WebvttSubtitleTest.java b/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttSubtitleTest.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/text/webvtt/WebvttSubtitleTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttSubtitleTest.java
diff --git a/library/src/test/java/com/google/android/exoplayer/upstream/ByteArrayDataSourceTest.java b/library/src/androidTest/java/com/google/android/exoplayer/upstream/ByteArrayDataSourceTest.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/upstream/ByteArrayDataSourceTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/upstream/ByteArrayDataSourceTest.java
diff --git a/library/src/test/java/com/google/android/exoplayer/util/FakeClock.java b/library/src/androidTest/java/com/google/android/exoplayer/util/FakeClock.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/util/FakeClock.java
rename to library/src/androidTest/java/com/google/android/exoplayer/util/FakeClock.java
diff --git a/library/src/test/java/com/google/android/exoplayer/util/NalUnitUtilTest.java b/library/src/androidTest/java/com/google/android/exoplayer/util/NalUnitUtilTest.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/util/NalUnitUtilTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/util/NalUnitUtilTest.java
diff --git a/library/src/test/java/com/google/android/exoplayer/util/ParsableByteArrayTest.java b/library/src/androidTest/java/com/google/android/exoplayer/util/ParsableByteArrayTest.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/util/ParsableByteArrayTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/util/ParsableByteArrayTest.java
diff --git a/library/src/test/java/com/google/android/exoplayer/util/UriUtilTest.java b/library/src/androidTest/java/com/google/android/exoplayer/util/UriUtilTest.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/util/UriUtilTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/util/UriUtilTest.java
diff --git a/library/src/test/java/com/google/android/exoplayer/util/UtilTest.java b/library/src/androidTest/java/com/google/android/exoplayer/util/UtilTest.java
similarity index 100%
rename from library/src/test/java/com/google/android/exoplayer/util/UtilTest.java
rename to library/src/androidTest/java/com/google/android/exoplayer/util/UtilTest.java
diff --git a/library/src/test/libs/.README.txt b/library/src/androidTest/libs/.README.txt
similarity index 100%
rename from library/src/test/libs/.README.txt
rename to library/src/androidTest/libs/.README.txt
diff --git a/library/src/test/project.properties b/library/src/androidTest/project.properties
similarity index 100%
rename from library/src/test/project.properties
rename to library/src/androidTest/project.properties
diff --git a/library/src/test/res/.README.txt b/library/src/androidTest/res/.README.txt
similarity index 100%
rename from library/src/test/res/.README.txt
rename to library/src/androidTest/res/.README.txt
diff --git a/library/src/main/java/com/google/android/exoplayer/BehindLiveWindowException.java b/library/src/main/java/com/google/android/exoplayer/BehindLiveWindowException.java
index 074a1de01a..3fd2bfedd9 100644
--- a/library/src/main/java/com/google/android/exoplayer/BehindLiveWindowException.java
+++ b/library/src/main/java/com/google/android/exoplayer/BehindLiveWindowException.java
@@ -20,7 +20,7 @@
 /**
  * Thrown when a live playback falls behind the available media window.
  */
-public class BehindLiveWindowException extends IOException {
+public final class BehindLiveWindowException extends IOException {
 
   public BehindLiveWindowException() {
     super();
diff --git a/library/src/main/java/com/google/android/exoplayer/CryptoInfo.java b/library/src/main/java/com/google/android/exoplayer/CryptoInfo.java
index 81e55446eb..4be481259c 100644
--- a/library/src/main/java/com/google/android/exoplayer/CryptoInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer/CryptoInfo.java
@@ -23,7 +23,7 @@
 /**
  * Compatibility wrapper around {@link android.media.MediaCodec.CryptoInfo}.
  */
-public class CryptoInfo {
+public final class CryptoInfo {
 
   /**
    * @see android.media.MediaCodec.CryptoInfo#iv
diff --git a/library/src/main/java/com/google/android/exoplayer/DefaultLoadControl.java b/library/src/main/java/com/google/android/exoplayer/DefaultLoadControl.java
index b494e990fe..17d8512bf9 100644
--- a/library/src/main/java/com/google/android/exoplayer/DefaultLoadControl.java
+++ b/library/src/main/java/com/google/android/exoplayer/DefaultLoadControl.java
@@ -39,7 +39,7 @@
  * itself as a task with priority {@link NetworkLock#STREAMING_PRIORITY} during loading periods,
  * and unregistering itself during draining periods.
  */
-public class DefaultLoadControl implements LoadControl {
+public final class DefaultLoadControl implements LoadControl {
 
   /**
    * Interface definition for a callback to be notified of {@link DefaultLoadControl} events.
@@ -162,18 +162,16 @@ public Allocator getAllocator() {
 
   @Override
   public boolean update(Object loader, long playbackPositionUs, long nextLoadPositionUs,
-      boolean loading, boolean failed) {
+      boolean loading) {
     // Update the loader state.
     int loaderBufferState = getLoaderBufferState(playbackPositionUs, nextLoadPositionUs);
     LoaderState loaderState = loaderStates.get(loader);
     boolean loaderStateChanged = loaderState.bufferState != loaderBufferState
-        || loaderState.nextLoadPositionUs != nextLoadPositionUs || loaderState.loading != loading
-        || loaderState.failed != failed;
+        || loaderState.nextLoadPositionUs != nextLoadPositionUs || loaderState.loading != loading;
     if (loaderStateChanged) {
       loaderState.bufferState = loaderBufferState;
       loaderState.nextLoadPositionUs = nextLoadPositionUs;
       loaderState.loading = loading;
-      loaderState.failed = failed;
     }
 
     // Update the buffer state.
@@ -213,18 +211,16 @@ private int getBufferState(int currentBufferSize) {
 
   private void updateControlState() {
     boolean loading = false;
-    boolean failed = false;
     boolean haveNextLoadPosition = false;
     int highestState = bufferState;
     for (int i = 0; i < loaders.size(); i++) {
       LoaderState loaderState = loaderStates.get(loaders.get(i));
       loading |= loaderState.loading;
-      failed |= loaderState.failed;
       haveNextLoadPosition |= loaderState.nextLoadPositionUs != -1;
       highestState = Math.max(highestState, loaderState.bufferState);
     }
 
-    fillingBuffers = !loaders.isEmpty() && !failed && (loading || haveNextLoadPosition)
+    fillingBuffers = !loaders.isEmpty() && (loading || haveNextLoadPosition)
         && (highestState == BELOW_LOW_WATERMARK
         || (highestState == BETWEEN_WATERMARKS && fillingBuffers));
     if (fillingBuffers && !streamingPrioritySet) {
@@ -268,14 +264,12 @@ public void run() {
 
     public int bufferState;
     public boolean loading;
-    public boolean failed;
     public long nextLoadPositionUs;
 
     public LoaderState(int bufferSizeContribution) {
       this.bufferSizeContribution = bufferSizeContribution;
       bufferState = ABOVE_HIGH_WATERMARK;
       loading = false;
-      failed = false;
       nextLoadPositionUs = -1;
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/DummyTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/DummyTrackRenderer.java
index f926073740..1a1305898e 100644
--- a/library/src/main/java/com/google/android/exoplayer/DummyTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/DummyTrackRenderer.java
@@ -22,10 +22,10 @@
  * to request that it should be ignored. {@link IllegalStateException} is thrown from all methods
  * that are documented to indicate that they should not be invoked unless the renderer is prepared.
  */
-public class DummyTrackRenderer extends TrackRenderer {
+public final class DummyTrackRenderer extends TrackRenderer {
 
   @Override
-  protected int doPrepare(long positionUs) throws ExoPlaybackException {
+  protected int doPrepare(long positionUs) {
     return STATE_IGNORE;
   }
 
@@ -49,6 +49,11 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs) {
     throw new IllegalStateException();
   }
 
+  @Override
+  protected void maybeThrowError() {
+    throw new IllegalStateException();
+  }
+
   @Override
   protected long getDurationUs() {
     throw new IllegalStateException();
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java
index 17e69bf1b7..4737a36919 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerImplInternal.java
@@ -266,10 +266,12 @@ private void prepareInternal(TrackRenderer[] renderers) throws ExoPlaybackExcept
   private void incrementalPrepareInternal() throws ExoPlaybackException {
     long operationStartTimeMs = SystemClock.elapsedRealtime();
     boolean prepared = true;
-    for (int i = 0; i < renderers.length; i++) {
-      if (renderers[i].getState() == TrackRenderer.STATE_UNPREPARED) {
-        int state = renderers[i].prepare(positionUs);
+    for (int rendererIndex = 0; rendererIndex < renderers.length; rendererIndex++) {
+      TrackRenderer renderer = renderers[rendererIndex];
+      if (renderer.getState() == TrackRenderer.STATE_UNPREPARED) {
+        int state = renderer.prepare(positionUs);
         if (state == TrackRenderer.STATE_UNPREPARED) {
+          renderer.maybeThrowError();
           prepared = false;
         }
       }
@@ -414,7 +416,14 @@ private void doSomeWork() throws ExoPlaybackException {
       // invocation of this method.
       renderer.doSomeWork(positionUs, elapsedRealtimeUs);
       allRenderersEnded = allRenderersEnded && renderer.isEnded();
-      allRenderersReadyOrEnded = allRenderersReadyOrEnded && rendererReadyOrEnded(renderer);
+
+      // Determine whether the renderer is ready (or ended). If it's not, throw an error that's
+      // preventing the renderer from making progress, if such an error exists.
+      boolean rendererReadyOrEnded = rendererReadyOrEnded(renderer);
+      if (!rendererReadyOrEnded) {
+        renderer.maybeThrowError();
+      }
+      allRenderersReadyOrEnded = allRenderersReadyOrEnded && rendererReadyOrEnded;
 
       if (bufferedPositionUs == TrackRenderer.UNKNOWN_TIME_US) {
         // We've already encountered a track for which the buffered position is unknown. Hence the
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
index 1fc0cdcae4..1d3ae0c6be 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
@@ -18,15 +18,12 @@
 /**
  * Information about the ExoPlayer library.
  */
-// TODO: This file should be automatically generated by the build system.
-public class ExoPlayerLibraryInfo {
-
-  private ExoPlayerLibraryInfo() {}
+public final class ExoPlayerLibraryInfo {
 
   /**
    * The version of the library, expressed as a string.
    */
-  public static final String VERSION = "1.4.1";
+  public static final String VERSION = "1.4.2";
 
   /**
    * The version of the library, expressed as an integer.
@@ -34,7 +31,7 @@ private ExoPlayerLibraryInfo() {}
    * Three digits are used for each component of {@link #VERSION}. For example "1.2.3" has the
    * corresponding integer version 001002003.
    */
-  public static final int VERSION_INT = 001004001;
+  public static final int VERSION_INT = 001004002;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer.util.Assertions}
@@ -48,4 +45,6 @@ private ExoPlayerLibraryInfo() {}
    */
   public static final boolean TRACE_ENABLED = true;
 
+  private ExoPlayerLibraryInfo() {}
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
index 02d599aca4..a319636d52 100644
--- a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
@@ -18,7 +18,6 @@
 import com.google.android.exoplayer.SampleSource.SampleSourceReader;
 import com.google.android.exoplayer.drm.DrmInitData;
 import com.google.android.exoplayer.extractor.ExtractorSampleSource;
-import com.google.android.exoplayer.extractor.mp4.Mp4Extractor;
 import com.google.android.exoplayer.extractor.mp4.PsshAtomUtil;
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.MimeTypes;
@@ -39,19 +38,12 @@
  * <p>
  * Warning - This class is marked as deprecated because there are known device specific issues
  * associated with its use, including playbacks not starting, playbacks stuttering and other
- * miscellaneous failures. For mp4, m4a, mp3, webm, mpeg-ts and aac playbacks it is strongly
- * recommended to use {@link ExtractorSampleSource} instead, along with the corresponding extractor
- * (e.g. {@link Mp4Extractor} for mp4 playbacks). Where this is not possible this class can still be
- * used, but please be aware of the associated risks. Valid use cases of this class that are not
- * yet supported by {@link ExtractorSampleSource} include:
- * <ul>
- * <li>Playing a container format for which an ExoPlayer extractor does not yet exist (e.g. ogg).
- * </li>
- * <li>Playing media whose container format is unknown and so needs to be inferred automatically.
- * </li>
- * </ul>
+ * miscellaneous failures. For mp4, m4a, mp3, webm, mkv, mpeg-ts and aac playbacks it is strongly
+ * recommended to use {@link ExtractorSampleSource} instead. Where this is not possible this class
+ * can still be used, but please be aware of the associated risks. Playing container formats for
+ * which an ExoPlayer extractor does not yet exist (e.g. ogg) is a valid use case of this class.
  * <p>
- * Over time we hope to enhance {@link ExtractorSampleSource} to support these use cases, and hence
+ * Over time we hope to enhance {@link ExtractorSampleSource} to support more formats, and hence
  * make use of this class unnecessary.
  */
 // TODO: This implementation needs to be fixed so that its methods are non-blocking (either
@@ -76,6 +68,7 @@
   private final long fileDescriptorOffset;
   private final long fileDescriptorLength;
 
+  private IOException preparationError;
   private MediaExtractor extractor;
   private TrackInfo[] trackInfos;
   private boolean prepared;
@@ -128,13 +121,22 @@ public SampleSourceReader register() {
   }
 
   @Override
-  public boolean prepare(long positionUs) throws IOException {
+  public boolean prepare(long positionUs) {
     if (!prepared) {
+      if (preparationError != null) {
+        return false;
+      }
+
       extractor = new MediaExtractor();
-      if (context != null) {
-        extractor.setDataSource(context, uri, headers);
-      } else {
-        extractor.setDataSource(fileDescriptor, fileDescriptorOffset, fileDescriptorLength);
+      try {
+        if (context != null) {
+          extractor.setDataSource(context, uri, headers);
+        } else {
+          extractor.setDataSource(fileDescriptor, fileDescriptorOffset, fileDescriptorLength);
+        }
+      } catch (IOException e) {
+        preparationError = e;
+        return false;
       }
 
       trackStates = new int[extractor.getTrackCount()];
@@ -232,6 +234,13 @@ public void disable(int track) {
     trackStates[track] = TRACK_STATE_DISABLED;
   }
 
+  @Override
+  public void maybeThrowError() throws IOException {
+    if (preparationError != null) {
+      throw preparationError;
+    }
+  }
+
   @Override
   public void seekToUs(long positionUs) {
     Assertions.checkState(prepared);
diff --git a/library/src/main/java/com/google/android/exoplayer/LoadControl.java b/library/src/main/java/com/google/android/exoplayer/LoadControl.java
index df6130017f..d7b2091ccd 100644
--- a/library/src/main/java/com/google/android/exoplayer/LoadControl.java
+++ b/library/src/main/java/com/google/android/exoplayer/LoadControl.java
@@ -68,10 +68,8 @@
    * @param nextLoadPositionUs The loader's next load position. -1 if finished, failed, or if the
    *     next load position is not yet known.
    * @param loading Whether the loader is currently loading data.
-   * @param failed Whether the loader has failed.
    * @return True if the loader is allowed to start its next load. False otherwise.
    */
-  boolean update(Object loader, long playbackPositionUs, long nextLoadPositionUs,
-      boolean loading, boolean failed);
+  boolean update(Object loader, long playbackPositionUs, long nextLoadPositionUs, boolean loading);
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
index 7ebfd795e9..f54e8947c0 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
@@ -245,17 +245,13 @@ public MediaCodecTrackRenderer(SampleSource source, DrmSessionManager drmSession
   }
 
   @Override
-  protected int doPrepare(long positionUs) throws ExoPlaybackException {
-    try {
-      boolean sourcePrepared = source.prepare(positionUs);
-      if (!sourcePrepared) {
-        return TrackRenderer.STATE_UNPREPARED;
-      }
-    } catch (IOException e) {
-      throw new ExoPlaybackException(e);
+  protected int doPrepare(long positionUs) {
+    boolean sourcePrepared = source.prepare(positionUs);
+    if (!sourcePrepared) {
+      return TrackRenderer.STATE_UNPREPARED;
     }
-
-    for (int i = 0; i < source.getTrackCount(); i++) {
+    int trackCount = source.getTrackCount();
+    for (int i = 0; i < trackCount; i++) {
       // TODO: Right now this is getting the mime types of the container format
       // (e.g. audio/mp4 and video/mp4 for fragmented mp4). It needs to be getting the mime types
       // of the actual samples (e.g. audio/mp4a-latm and video/avc).
@@ -264,7 +260,6 @@ protected int doPrepare(long positionUs) throws ExoPlaybackException {
         return TrackRenderer.STATE_PREPARED;
       }
     }
-
     return TrackRenderer.STATE_IGNORE;
   }
 
@@ -489,39 +484,35 @@ protected void onStopped() {
 
   @Override
   protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
-    try {
-      sourceState = source.continueBuffering(trackIndex, positionUs)
-          ? (sourceState == SOURCE_STATE_NOT_READY ? SOURCE_STATE_READY : sourceState)
-          : SOURCE_STATE_NOT_READY;
-      checkForDiscontinuity(positionUs);
-      if (format == null) {
-        readFormat(positionUs);
-      }
-      if (codec == null && shouldInitCodec()) {
-        maybeInitCodec();
-      }
-      if (codec != null) {
-        TraceUtil.beginSection("drainAndFeed");
-        while (drainOutputBuffer(positionUs, elapsedRealtimeUs)) {}
-        if (feedInputBuffer(positionUs, true)) {
-          while (feedInputBuffer(positionUs, false)) {}
-        }
-        TraceUtil.endSection();
+    sourceState = source.continueBuffering(trackIndex, positionUs)
+        ? (sourceState == SOURCE_STATE_NOT_READY ? SOURCE_STATE_READY : sourceState)
+        : SOURCE_STATE_NOT_READY;
+    checkForDiscontinuity(positionUs);
+    if (format == null) {
+      readFormat(positionUs);
+    }
+    if (codec == null && shouldInitCodec()) {
+      maybeInitCodec();
+    }
+    if (codec != null) {
+      TraceUtil.beginSection("drainAndFeed");
+      while (drainOutputBuffer(positionUs, elapsedRealtimeUs)) {}
+      if (feedInputBuffer(positionUs, true)) {
+        while (feedInputBuffer(positionUs, false)) {}
       }
-      codecCounters.ensureUpdated();
-    } catch (IOException e) {
-      throw new ExoPlaybackException(e);
+      TraceUtil.endSection();
     }
+    codecCounters.ensureUpdated();
   }
 
-  private void readFormat(long positionUs) throws IOException, ExoPlaybackException {
+  private void readFormat(long positionUs) throws ExoPlaybackException {
     int result = source.readData(trackIndex, positionUs, formatHolder, sampleHolder, false);
     if (result == SampleSource.FORMAT_READ) {
       onInputFormatChanged(formatHolder);
     }
   }
 
-  private void checkForDiscontinuity(long positionUs) throws IOException, ExoPlaybackException {
+  private void checkForDiscontinuity(long positionUs) throws ExoPlaybackException {
     if (codec == null) {
       return;
     }
@@ -560,11 +551,9 @@ private void flushCodec() throws ExoPlaybackException {
    * @param firstFeed True if this is the first call to this method from the current invocation of
    *     {@link #doSomeWork(long, long)}. False otherwise.
    * @return True if it may be possible to feed more input data. False otherwise.
-   * @throws IOException If an error occurs reading data from the upstream source.
    * @throws ExoPlaybackException If an error occurs feeding the input buffer.
    */
-  private boolean feedInputBuffer(long positionUs, boolean firstFeed)
-      throws IOException, ExoPlaybackException {
+  private boolean feedInputBuffer(long positionUs, boolean firstFeed) throws ExoPlaybackException {
     if (inputStreamEnded
         || codecReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM) {
       // The input stream has ended, or we need to re-initialize the codec but are still waiting
@@ -785,6 +774,15 @@ protected boolean canReconfigureCodec(MediaCodec codec, boolean codecIsAdaptive,
     return false;
   }
 
+  @Override
+  protected void maybeThrowError() throws ExoPlaybackException {
+    try {
+      source.maybeThrowError();
+    } catch (IOException e) {
+      throw new ExoPlaybackException(e);
+    }
+  }
+
   @Override
   protected boolean isEnded() {
     return outputStreamEnded;
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
index ff3a453b16..8cffd8a852 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecUtil.java
@@ -34,7 +34,7 @@
  * A utility class for querying the available codecs.
  */
 @TargetApi(16)
-public class MediaCodecUtil {
+public final class MediaCodecUtil {
 
   /**
    * Thrown when an error occurs querying the device for its underlying media capabilities.
@@ -54,6 +54,8 @@ private DecoderQueryException(Throwable cause) {
 
   private static final HashMap<CodecKey, Pair<String, CodecCapabilities>> codecs = new HashMap<>();
 
+  private MediaCodecUtil() {}
+
   /**
    * Get information about the decoder that will be used for a given mime type.
    *
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
index 736e20fbe1..5970c7df63 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
@@ -437,7 +437,11 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
     }
 
     if (!renderedFirstFrame) {
-      renderOutputBufferImmediate(codec, bufferIndex);
+      if (Util.SDK_INT >= 21) {
+        renderOutputBufferV21(codec, bufferIndex, System.nanoTime());
+      } else {
+        renderOutputBuffer(codec, bufferIndex);
+      }
       return true;
     }
 
@@ -448,7 +452,7 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
     if (Util.SDK_INT >= 21) {
       // Let the underlying framework time the release.
       if (earlyUs < 50000) {
-        renderOutputBufferTimedV21(codec, bufferIndex, adjustedReleaseTimeNs);
+        renderOutputBufferV21(codec, bufferIndex, adjustedReleaseTimeNs);
         return true;
       }
     } else {
@@ -464,7 +468,7 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
             Thread.currentThread().interrupt();
           }
         }
-        renderOutputBufferImmediate(codec, bufferIndex);
+        renderOutputBuffer(codec, bufferIndex);
         return true;
       }
     }
@@ -491,9 +495,9 @@ protected void dropOutputBuffer(MediaCodec codec, int bufferIndex) {
     }
   }
 
-  protected void renderOutputBufferImmediate(MediaCodec codec, int bufferIndex) {
+  protected void renderOutputBuffer(MediaCodec codec, int bufferIndex) {
     maybeNotifyVideoSizeChanged();
-    TraceUtil.beginSection("renderVideoBufferImmediate");
+    TraceUtil.beginSection("releaseOutputBuffer");
     codec.releaseOutputBuffer(bufferIndex, true);
     TraceUtil.endSection();
     codecCounters.renderedOutputBufferCount++;
@@ -502,9 +506,9 @@ protected void renderOutputBufferImmediate(MediaCodec codec, int bufferIndex) {
   }
 
   @TargetApi(21)
-  protected void renderOutputBufferTimedV21(MediaCodec codec, int bufferIndex, long releaseTimeNs) {
+  protected void renderOutputBufferV21(MediaCodec codec, int bufferIndex, long releaseTimeNs) {
     maybeNotifyVideoSizeChanged();
-    TraceUtil.beginSection("releaseOutputBufferTimed");
+    TraceUtil.beginSection("releaseOutputBuffer");
     codec.releaseOutputBuffer(bufferIndex, releaseTimeNs);
     TraceUtil.endSection();
     codecCounters.renderedOutputBufferCount++;
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
index 898223969f..c1de1160c9 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
@@ -29,7 +29,7 @@
 /**
  * Defines the format of an elementary media stream.
  */
-public class MediaFormat {
+public final class MediaFormat {
 
   private static final String KEY_PIXEL_WIDTH_HEIGHT_RATIO =
       "com.google.android.videos.pixelWidthHeightRatio";
@@ -94,11 +94,19 @@ public static MediaFormat createAudioFormat(String mimeType, int maxInputSize, l
   }
 
   public static MediaFormat createTextFormat(String mimeType) {
-    return createFormatForMimeType(mimeType);
+    return createTextFormat(mimeType, C.UNKNOWN_TIME_US);
+  }
+
+  public static MediaFormat createTextFormat(String mimeType, long durationUs) {
+    return createFormatForMimeType(mimeType, durationUs);
   }
 
   public static MediaFormat createFormatForMimeType(String mimeType) {
-    return new MediaFormat(mimeType, NO_VALUE, C.UNKNOWN_TIME_US, NO_VALUE, NO_VALUE, NO_VALUE,
+    return createFormatForMimeType(mimeType, C.UNKNOWN_TIME_US);
+  }
+
+  public static MediaFormat createFormatForMimeType(String mimeType, long durationUs) {
+    return new MediaFormat(mimeType, NO_VALUE, durationUs, NO_VALUE, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, null);
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/SampleSource.java b/library/src/main/java/com/google/android/exoplayer/SampleSource.java
index 3463dc9fcf..539983d200 100644
--- a/library/src/main/java/com/google/android/exoplayer/SampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/SampleSource.java
@@ -76,9 +76,8 @@
      *
      * @param positionUs The player's current playback position.
      * @return True if the source was prepared successfully, false otherwise.
-     * @throws IOException If an error occurred preparing the source.
      */
-    public boolean prepare(long positionUs) throws IOException;
+    public boolean prepare(long positionUs);
 
     /**
      * Returns the number of tracks exposed by the source.
@@ -116,6 +115,14 @@
      */
     public void disable(int track);
 
+    /**
+     * If the source is currently having difficulty preparing or loading samples, then this method
+     * throws the underlying error. Otherwise does nothing.
+     *
+     * @throws IOException The underlying error.
+     */
+    public void maybeThrowError() throws IOException;
+
     /**
      * Indicates to the source that it should still be buffering data for the specified track.
      *
@@ -123,9 +130,8 @@
      * @param positionUs The current playback position.
      * @return True if the track has available samples, or if the end of the stream has been
      *     reached. False if more data needs to be buffered for samples to become available.
-     * @throws IOException If an error occurred reading from the source.
      */
-    public boolean continueBuffering(int track, long positionUs) throws IOException;
+    public boolean continueBuffering(int track, long positionUs);
 
     /**
      * Attempts to read either a sample, a new format or or a discontinuity from the source.
@@ -147,10 +153,9 @@
      *     {@link #DISCONTINUITY_READ} or {@link #NOTHING_READ} can be returned.
      * @return The result, which can be {@link #SAMPLE_READ}, {@link #FORMAT_READ},
      *     {@link #DISCONTINUITY_READ}, {@link #NOTHING_READ} or {@link #END_OF_STREAM}.
-     * @throws IOException If an error occurred reading from the source.
      */
     public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
-        SampleHolder sampleHolder, boolean onlyReadDiscontinuity) throws IOException;
+        SampleHolder sampleHolder, boolean onlyReadDiscontinuity);
 
     /**
      * Seeks to the specified time in microseconds.
diff --git a/library/src/main/java/com/google/android/exoplayer/SingleSampleSource.java b/library/src/main/java/com/google/android/exoplayer/SingleSampleSource.java
new file mode 100644
index 0000000000..36b44ced1c
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/SingleSampleSource.java
@@ -0,0 +1,242 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer;
+
+import com.google.android.exoplayer.SampleSource.SampleSourceReader;
+import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.upstream.DataSpec;
+import com.google.android.exoplayer.upstream.Loader;
+import com.google.android.exoplayer.upstream.Loader.Loadable;
+
+import android.net.Uri;
+import android.os.SystemClock;
+
+import java.io.IOException;
+import java.util.Arrays;
+
+/**
+ * A {@link SampleSource} that loads the data at a given {@link Uri} as a single sample.
+ */
+public final class SingleSampleSource implements SampleSource, SampleSourceReader, Loader.Callback,
+    Loadable {
+
+  /**
+   * The default minimum number of times to retry loading data prior to failing.
+   */
+  public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT = 3;
+
+  /**
+   * The initial size of the allocation used to hold the sample data.
+   */
+  private static final int INITIAL_SAMPLE_SIZE = 1;
+
+  private final Uri uri;
+  private final DataSource dataSource;
+  private final MediaFormat format;
+  private final TrackInfo trackInfo;
+  private final int minLoadableRetryCount;
+
+  private byte[] sampleData;
+  private int sampleSize;
+  private boolean pendingSample;
+
+  private boolean loadingFinished;
+  private Loader loader;
+  private IOException currentLoadableException;
+  private int currentLoadableExceptionCount;
+  private long currentLoadableExceptionTimestamp;
+
+  public SingleSampleSource(Uri uri, DataSource dataSource, MediaFormat format) {
+    this(uri, dataSource, format, DEFAULT_MIN_LOADABLE_RETRY_COUNT);
+  }
+
+  public SingleSampleSource(Uri uri, DataSource dataSource, MediaFormat format,
+      int minLoadableRetryCount) {
+    this.uri = uri;
+    this.dataSource = dataSource;
+    this.format = format;
+    this.minLoadableRetryCount = minLoadableRetryCount;
+    trackInfo = new TrackInfo(format.mimeType, format.durationUs);
+    sampleData = new byte[INITIAL_SAMPLE_SIZE];
+  }
+
+  @Override
+  public SampleSourceReader register() {
+    return this;
+  }
+
+  @Override
+  public boolean prepare(long positionUs) {
+    if (loader == null) {
+      loader = new Loader("Loader:" + format.mimeType);
+    }
+    return true;
+  }
+
+  @Override
+  public int getTrackCount() {
+    return 1;
+  }
+
+  @Override
+  public TrackInfo getTrackInfo(int track) {
+    return trackInfo;
+  }
+
+  @Override
+  public void enable(int track, long positionUs) {
+    pendingSample = true;
+    clearCurrentLoadableException();
+    maybeStartLoading();
+  }
+
+  @Override
+  public boolean continueBuffering(int track, long positionUs) {
+    maybeStartLoading();
+    return loadingFinished;
+  }
+
+  @Override
+  public void maybeThrowError() throws IOException {
+    if (currentLoadableException != null && currentLoadableExceptionCount > minLoadableRetryCount) {
+      throw currentLoadableException;
+    }
+  }
+
+  @Override
+  public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
+      SampleHolder sampleHolder, boolean onlyReadDiscontinuity) {
+    if (onlyReadDiscontinuity) {
+      return NOTHING_READ;
+    } else if (!pendingSample) {
+      return END_OF_STREAM;
+    } else if (!loadingFinished) {
+      return NOTHING_READ;
+    } else {
+      sampleHolder.timeUs = 0;
+      sampleHolder.size = sampleSize;
+      sampleHolder.flags = C.SAMPLE_FLAG_SYNC;
+      if (sampleHolder.data == null || sampleHolder.data.capacity() < sampleSize) {
+        sampleHolder.replaceBuffer(sampleHolder.size);
+      }
+      sampleHolder.data.put(sampleData, 0, sampleSize);
+      return SAMPLE_READ;
+    }
+  }
+
+  @Override
+  public void seekToUs(long positionUs) {
+    pendingSample = true;
+  }
+
+  @Override
+  public long getBufferedPositionUs() {
+    return loadingFinished ? TrackRenderer.END_OF_TRACK_US : 0;
+  }
+
+  @Override
+  public void disable(int track) {
+    pendingSample = false;
+  }
+
+  @Override
+  public void release() {
+    if (loader != null) {
+      loader.release();
+      loader = null;
+    }
+  }
+
+  // Private methods.
+
+  private void maybeStartLoading() {
+    if (loadingFinished || !pendingSample || loader.isLoading()) {
+      return;
+    }
+    if (currentLoadableException != null) {
+      long elapsedMillis = SystemClock.elapsedRealtime() - currentLoadableExceptionTimestamp;
+      if (elapsedMillis < getRetryDelayMillis(currentLoadableExceptionCount)) {
+        return;
+      }
+      currentLoadableException = null;
+    }
+    loader.startLoading(this, this);
+  }
+
+  private void clearCurrentLoadableException() {
+    currentLoadableException = null;
+    currentLoadableExceptionCount = 0;
+  }
+
+  private long getRetryDelayMillis(long errorCount) {
+    return Math.min((errorCount - 1) * 1000, 5000);
+  }
+
+  // Loader.Callback implementation.
+
+  @Override
+  public void onLoadCompleted(Loadable loadable) {
+    loadingFinished = true;
+    clearCurrentLoadableException();
+  }
+
+  @Override
+  public void onLoadCanceled(Loadable loadable) {
+    // Never happens.
+  }
+
+  @Override
+  public void onLoadError(Loadable loadable, IOException e) {
+    currentLoadableException = e;
+    currentLoadableExceptionCount++;
+    currentLoadableExceptionTimestamp = SystemClock.elapsedRealtime();
+    maybeStartLoading();
+  }
+
+  // Loadable implementation.
+
+  @Override
+  public void cancelLoad() {
+    // Never happens.
+  }
+
+  @Override
+  public boolean isLoadCanceled() {
+    return false;
+  }
+
+  @Override
+  public void load() throws IOException, InterruptedException {
+    // We always load from the beginning, so reset the sampleSize to 0.
+    sampleSize = 0;
+    try {
+      // Create and open the input.
+      dataSource.open(new DataSpec(uri));
+      // Load the sample data.
+      int result = 0;
+      while (result != C.RESULT_END_OF_INPUT) {
+        sampleSize += result;
+        if (sampleSize == sampleData.length) {
+          sampleData = Arrays.copyOf(sampleData, sampleData.length * 2);
+        }
+        result = dataSource.read(sampleData, sampleSize, sampleData.length - sampleSize);
+      }
+    } finally {
+      dataSource.close();
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/SmoothFrameReleaseTimeHelper.java b/library/src/main/java/com/google/android/exoplayer/SmoothFrameReleaseTimeHelper.java
index 1245ea6454..ce93136734 100644
--- a/library/src/main/java/com/google/android/exoplayer/SmoothFrameReleaseTimeHelper.java
+++ b/library/src/main/java/com/google/android/exoplayer/SmoothFrameReleaseTimeHelper.java
@@ -25,7 +25,7 @@
  * Makes a best effort to adjust frame release timestamps for a smoother visual result.
  */
 @TargetApi(16)
-public class SmoothFrameReleaseTimeHelper implements FrameReleaseTimeHelper, FrameCallback {
+public final class SmoothFrameReleaseTimeHelper implements FrameReleaseTimeHelper, FrameCallback {
 
   private static final long CHOREOGRAPHER_SAMPLE_DELAY_MILLIS = 500;
   private static final long MAX_ALLOWED_DRIFT_NS = 20000000;
diff --git a/library/src/main/java/com/google/android/exoplayer/StandaloneMediaClock.java b/library/src/main/java/com/google/android/exoplayer/StandaloneMediaClock.java
index f4b85b0d35..3b6871c811 100644
--- a/library/src/main/java/com/google/android/exoplayer/StandaloneMediaClock.java
+++ b/library/src/main/java/com/google/android/exoplayer/StandaloneMediaClock.java
@@ -21,7 +21,7 @@
  * A standalone {@link MediaClock}. The clock can be started, stopped and its time can be set and
  * retrieved. When started, this clock is based on {@link SystemClock#elapsedRealtime()}.
  */
-/* package */ class StandaloneMediaClock implements MediaClock {
+/* package */ final class StandaloneMediaClock implements MediaClock {
 
   private boolean started;
 
diff --git a/library/src/main/java/com/google/android/exoplayer/TrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/TrackRenderer.java
index cb4b866f15..ffc02caf4e 100644
--- a/library/src/main/java/com/google/android/exoplayer/TrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/TrackRenderer.java
@@ -107,6 +107,7 @@ protected final int getState() {
    *
    * @param positionUs The player's current playback position.
    * @return The current state (one of the STATE_* constants), for convenience.
+   * @throws ExoPlaybackException If an error occurs.
    */
   /* package */ final int prepare(long positionUs) throws ExoPlaybackException {
     Assertions.checkState(state == TrackRenderer.STATE_UNPREPARED);
@@ -139,6 +140,7 @@ protected final int getState() {
    * @param joining Whether this renderer is being enabled to join an ongoing playback. If true
    *     then {@link #start} must be called immediately after this method returns (unless a
    *     {@link ExoPlaybackException} is thrown).
+   * @throws ExoPlaybackException If an error occurs.
    */
   /* package */ final void enable(long positionUs, boolean joining) throws ExoPlaybackException {
     Assertions.checkState(state == TrackRenderer.STATE_PREPARED);
@@ -164,6 +166,8 @@ protected void onEnabled(long positionUs, boolean joining) throws ExoPlaybackExc
   /**
    * Starts the renderer, meaning that calls to {@link #doSomeWork(long, long)} will cause the
    * track to be rendered.
+   *
+   * @throws ExoPlaybackException If an error occurs.
    */
   /* package */ final void start() throws ExoPlaybackException {
     Assertions.checkState(state == TrackRenderer.STATE_ENABLED);
@@ -184,6 +188,8 @@ protected void onStarted() throws ExoPlaybackException {
 
   /**
    * Stops the renderer.
+   *
+   * @throws ExoPlaybackException If an error occurs.
    */
   /* package */ final void stop() throws ExoPlaybackException {
     Assertions.checkState(state == TrackRenderer.STATE_STARTED);
@@ -204,6 +210,8 @@ protected void onStopped() throws ExoPlaybackException {
 
   /**
    * Disable the renderer.
+   *
+   * @throws ExoPlaybackException If an error occurs.
    */
   /* package */ final void disable() throws ExoPlaybackException {
     Assertions.checkState(state == TrackRenderer.STATE_ENABLED);
@@ -224,6 +232,8 @@ protected void onDisabled() throws ExoPlaybackException {
 
   /**
    * Releases the renderer.
+   *
+   * @throws ExoPlaybackException If an error occurs.
    */
   /* package */ final void release() throws ExoPlaybackException {
     Assertions.checkState(state != TrackRenderer.STATE_ENABLED
@@ -297,6 +307,15 @@ protected void onReleased() throws ExoPlaybackException {
   protected abstract void doSomeWork(long positionUs, long elapsedRealtimeUs)
       throws ExoPlaybackException;
 
+  /**
+   * Throws an error that's preventing the renderer from making progress or buffering more data at
+   * this point in time.
+   *
+   * @throws ExoPlaybackException An error that's preventing the renderer from making progress or
+   *     buffering more data.
+   */
+  protected abstract void maybeThrowError() throws ExoPlaybackException;
+
   /**
    * Returns the duration of the media being rendered.
    * <p>
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkExtractorWrapper.java b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkExtractorWrapper.java
index 7cc0c72eeb..0c585419e7 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkExtractorWrapper.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkExtractorWrapper.java
@@ -127,8 +127,9 @@ public void format(MediaFormat format) {
   }
 
   @Override
-  public int sampleData(ExtractorInput input, int length) throws IOException, InterruptedException {
-    return output.sampleData(input, length);
+  public int sampleData(ExtractorInput input, int length, boolean allowEndOfInput)
+      throws IOException, InterruptedException {
+    return output.sampleData(input, length, allowEndOfInput);
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
index 4837f0a5d5..1e8cdaf9a6 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSampleSource.java
@@ -68,7 +68,6 @@
   private final List<BaseMediaChunk> readOnlyMediaChunks;
   private final DefaultTrackOutput sampleQueue;
   private final int bufferSizeContribution;
-  private final boolean frameAccurateSeeking;
   private final Handler eventHandler;
   private final EventListener eventListener;
   private final int minLoadableRetryCount;
@@ -91,24 +90,23 @@
   private Format downstreamFormat;
 
   public ChunkSampleSource(ChunkSource chunkSource, LoadControl loadControl,
-      int bufferSizeContribution, boolean frameAccurateSeeking) {
-    this(chunkSource, loadControl, bufferSizeContribution, frameAccurateSeeking, null, null, 0);
+      int bufferSizeContribution) {
+    this(chunkSource, loadControl, bufferSizeContribution, null, null, 0);
   }
 
   public ChunkSampleSource(ChunkSource chunkSource, LoadControl loadControl,
-      int bufferSizeContribution, boolean frameAccurateSeeking, Handler eventHandler,
-      EventListener eventListener, int eventSourceId) {
-    this(chunkSource, loadControl, bufferSizeContribution, frameAccurateSeeking, eventHandler,
-        eventListener, eventSourceId, DEFAULT_MIN_LOADABLE_RETRY_COUNT);
+      int bufferSizeContribution, Handler eventHandler, EventListener eventListener,
+      int eventSourceId) {
+    this(chunkSource, loadControl, bufferSizeContribution, eventHandler, eventListener,
+        eventSourceId, DEFAULT_MIN_LOADABLE_RETRY_COUNT);
   }
 
   public ChunkSampleSource(ChunkSource chunkSource, LoadControl loadControl,
-      int bufferSizeContribution, boolean frameAccurateSeeking, Handler eventHandler,
-      EventListener eventListener, int eventSourceId, int minLoadableRetryCount) {
+      int bufferSizeContribution, Handler eventHandler, EventListener eventListener,
+      int eventSourceId, int minLoadableRetryCount) {
     this.chunkSource = chunkSource;
     this.loadControl = loadControl;
     this.bufferSizeContribution = bufferSizeContribution;
-    this.frameAccurateSeeking = frameAccurateSeeking;
     this.eventHandler = eventHandler;
     this.eventListener = eventListener;
     this.eventSourceId = eventSourceId;
@@ -188,23 +186,18 @@ public void disable(int track) {
   }
 
   @Override
-  public boolean continueBuffering(int track, long positionUs) throws IOException {
+  public boolean continueBuffering(int track, long positionUs) {
     Assertions.checkState(state == STATE_ENABLED);
     Assertions.checkState(track == 0);
     downstreamPositionUs = positionUs;
     chunkSource.continueBuffering(positionUs);
     updateLoadControl();
-
-    boolean haveSamples = !sampleQueue.isEmpty();
-    if (!haveSamples) {
-      maybeThrowLoadableException();
-    }
-    return loadingFinished || haveSamples;
+    return loadingFinished || !sampleQueue.isEmpty();
   }
 
   @Override
   public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
-      SampleHolder sampleHolder, boolean onlyReadDiscontinuity) throws IOException {
+      SampleHolder sampleHolder, boolean onlyReadDiscontinuity) {
     Assertions.checkState(state == STATE_ENABLED);
     Assertions.checkState(track == 0);
     downstreamPositionUs = positionUs;
@@ -219,7 +212,6 @@ public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
     }
 
     if (isPendingReset()) {
-      maybeThrowLoadableException();
       return NOTHING_READ;
     }
 
@@ -252,18 +244,16 @@ public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
       if (loadingFinished) {
         return END_OF_STREAM;
       }
-      maybeThrowLoadableException();
       return NOTHING_READ;
     }
 
     if (sampleQueue.getSample(sampleHolder)) {
-      boolean decodeOnly = frameAccurateSeeking && sampleHolder.timeUs < lastSeekPositionUs;
+      boolean decodeOnly = sampleHolder.timeUs < lastSeekPositionUs;
       sampleHolder.flags |= decodeOnly ? C.SAMPLE_FLAG_DECODE_ONLY : 0;
       onSampleRead(currentChunk, sampleHolder);
       return SAMPLE_READ;
     }
 
-    maybeThrowLoadableException();
     return NOTHING_READ;
   }
 
@@ -295,15 +285,12 @@ public void seekToUs(long positionUs) {
     pendingDiscontinuity = true;
   }
 
-  private void maybeThrowLoadableException() throws IOException {
+  @Override
+  public void maybeThrowError() throws IOException {
     if (currentLoadableException != null && currentLoadableExceptionCount > minLoadableRetryCount) {
       throw currentLoadableException;
-    }
-    if (sampleQueue.isEmpty() && currentLoadableHolder.chunk == null) {
-      IOException chunkSourceException = chunkSource.getError();
-      if (chunkSourceException != null) {
-        throw chunkSourceException;
-      }
+    } else if (currentLoadableHolder.chunk == null) {
+      chunkSource.maybeThrowError();
     }
   }
 
@@ -437,7 +424,7 @@ private void updateLoadControl() {
 
     // Update the control with our current state, and determine whether we're the next loader.
     boolean nextLoader = loadControl.update(this, downstreamPositionUs, nextLoadPositionUs,
-        loadingOrBackedOff, false);
+        loadingOrBackedOff);
 
     if (isBackedOff) {
       long elapsedMillis = now - currentLoadableExceptionTimestamp;
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSource.java b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSource.java
index 88306bc8f4..1723f201d1 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/ChunkSource.java
@@ -94,13 +94,12 @@ void getChunkOperation(List<? extends MediaChunk> queue, long seekPositionUs,
       long playbackPositionUs, ChunkOperationHolder out);
 
   /**
-   * If the {@link ChunkSource} is currently unable to provide chunks through
-   * {@link ChunkSource#getChunkOperation}, then this method returns the underlying cause. Returns
-   * null otherwise.
+   * If the source is currently having difficulty providing chunks, then this method throws the
+   * underlying error. Otherwise does nothing.
    *
-   * @return An {@link IOException}, or null.
+   * @throws IOException The underlying error.
    */
-  IOException getError();
+  void maybeThrowError() throws IOException;
 
   /**
    * Invoked when the {@link ChunkSampleSource} has finished loading a chunk obtained from this
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/ContainerMediaChunk.java b/library/src/main/java/com/google/android/exoplayer/chunk/ContainerMediaChunk.java
index 031495e306..d147ce2e64 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/ContainerMediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/ContainerMediaChunk.java
@@ -27,8 +27,6 @@
 import com.google.android.exoplayer.util.ParsableByteArray;
 import com.google.android.exoplayer.util.Util;
 
-import android.util.Log;
-
 import java.io.IOException;
 
 /**
@@ -36,8 +34,6 @@
  */
 public class ContainerMediaChunk extends BaseMediaChunk implements SingleTrackOutput {
 
-  private static final String TAG = "ContainerMediaChunk";
-
   private final ChunkExtractorWrapper extractorWrapper;
   private final long sampleOffsetUs;
 
@@ -78,67 +74,69 @@ public ContainerMediaChunk(DataSource dataSource, DataSpec dataSpec, int trigger
   }
 
   @Override
-  public long bytesLoaded() {
+  public final long bytesLoaded() {
     return bytesLoaded;
   }
 
   @Override
-  public MediaFormat getMediaFormat() {
+  public final MediaFormat getMediaFormat() {
     return mediaFormat;
   }
 
   @Override
-  public DrmInitData getDrmInitData() {
+  public final DrmInitData getDrmInitData() {
     return drmInitData;
   }
 
   // SingleTrackOutput implementation.
 
   @Override
-  public void seekMap(SeekMap seekMap) {
-    Log.w(TAG, "Ignoring unexpected seekMap");
+  public final void seekMap(SeekMap seekMap) {
+    // Do nothing.
   }
 
   @Override
-  public void drmInitData(DrmInitData drmInitData) {
+  public final void drmInitData(DrmInitData drmInitData) {
     this.drmInitData = drmInitData;
   }
 
   @Override
-  public void format(MediaFormat mediaFormat) {
+  public final void format(MediaFormat mediaFormat) {
     this.mediaFormat = mediaFormat;
   }
 
   @Override
-  public int sampleData(ExtractorInput input, int length) throws IOException, InterruptedException {
-    return getOutput().sampleData(input, length);
+  public final int sampleData(ExtractorInput input, int length, boolean allowEndOfInput)
+      throws IOException, InterruptedException {
+    return getOutput().sampleData(input, length, allowEndOfInput);
   }
 
   @Override
-  public void sampleData(ParsableByteArray data, int length) {
+  public final void sampleData(ParsableByteArray data, int length) {
     getOutput().sampleData(data, length);
   }
 
   @Override
-  public void sampleMetadata(long timeUs, int flags, int size, int offset, byte[] encryptionKey) {
+  public final void sampleMetadata(long timeUs, int flags, int size, int offset,
+      byte[] encryptionKey) {
     getOutput().sampleMetadata(timeUs + sampleOffsetUs, flags, size, offset, encryptionKey);
   }
 
   // Loadable implementation.
 
   @Override
-  public void cancelLoad() {
+  public final void cancelLoad() {
     loadCanceled = true;
   }
 
   @Override
-  public boolean isLoadCanceled() {
+  public final boolean isLoadCanceled() {
     return loadCanceled;
   }
 
   @SuppressWarnings("NonAtomicVolatileUpdate")
   @Override
-  public void load() throws IOException, InterruptedException {
+  public final void load() throws IOException, InterruptedException {
     DataSpec loadDataSpec = Util.getRemainderDataSpec(dataSpec, bytesLoaded);
     try {
       // Create and open the input.
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/InitializationChunk.java b/library/src/main/java/com/google/android/exoplayer/chunk/InitializationChunk.java
index a83092ad3f..dd6c68c749 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/InitializationChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/InitializationChunk.java
@@ -138,7 +138,8 @@ public void format(MediaFormat mediaFormat) {
   }
 
   @Override
-  public int sampleData(ExtractorInput input, int length) throws IOException, InterruptedException {
+  public int sampleData(ExtractorInput input, int length, boolean allowEndOfInput)
+      throws IOException, InterruptedException {
     throw new IllegalStateException("Unexpected sample data in initialization chunk");
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/MultiTrackChunkSource.java b/library/src/main/java/com/google/android/exoplayer/chunk/MultiTrackChunkSource.java
index 84f91c5465..c612dca454 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/MultiTrackChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/MultiTrackChunkSource.java
@@ -28,7 +28,7 @@
  * A {@link ChunkSource} providing the ability to switch between multiple other {@link ChunkSource}
  * instances.
  */
-public class MultiTrackChunkSource implements ChunkSource, ExoPlayerComponent {
+public final class MultiTrackChunkSource implements ChunkSource, ExoPlayerComponent {
 
   /**
    * A message to indicate a source selection. Source selection can only be performed when the
@@ -89,8 +89,8 @@ public void getChunkOperation(List<? extends MediaChunk> queue, long seekPositio
   }
 
   @Override
-  public IOException getError() {
-    return null;
+  public void maybeThrowError() throws IOException {
+    selectedSource.maybeThrowError();
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleChunkSource.java b/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleChunkSource.java
index 8ee6c9adad..12f7689099 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleChunkSource.java
@@ -21,7 +21,6 @@
 import com.google.android.exoplayer.upstream.DataSource;
 import com.google.android.exoplayer.upstream.DataSpec;
 
-import java.io.IOException;
 import java.util.List;
 
 /**
@@ -30,7 +29,7 @@
  * An example use case for this implementation is to act as the source for loading out-of-band
  * subtitles, where subtitles for the entire video are delivered as a single file.
  */
-public class SingleSampleChunkSource implements ChunkSource {
+public final class SingleSampleChunkSource implements ChunkSource {
 
   private final DataSource dataSource;
   private final DataSpec dataSpec;
@@ -94,8 +93,8 @@ public void disable(List<? extends MediaChunk> queue) {
   }
 
   @Override
-  public IOException getError() {
-    return null;
+  public void maybeThrowError() {
+    // Do nothing.
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleMediaChunk.java b/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleMediaChunk.java
index 9e7a2a84df..de2c7067cc 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleMediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleMediaChunk.java
@@ -109,10 +109,8 @@ public void load() throws IOException, InterruptedException {
       // Load the sample data.
       int result = 0;
       while (result != C.RESULT_END_OF_INPUT) {
-        result = getOutput().sampleData(dataSource, Integer.MAX_VALUE);
-        if (result != C.RESULT_END_OF_INPUT) {
-          bytesLoaded += result;
-        }
+        bytesLoaded += result;
+        result = getOutput().sampleData(dataSource, Integer.MAX_VALUE, true);
       }
       int sampleSize = bytesLoaded;
       if (headerData != null) {
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java b/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
index 0b0da1e8f4..b4b0279052 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
@@ -386,7 +386,7 @@ public void continueBuffering(long playbackPositionUs) {
     }
 
     if (finishedCurrentManifest && (android.os.SystemClock.elapsedRealtime()
-        > manifestFetcher.getManifestLoadTimestamp() + minUpdatePeriod)) {
+        > manifestFetcher.getManifestLoadStartTimestamp() + minUpdatePeriod)) {
       manifestFetcher.requestRefresh();
     }
   }
@@ -514,9 +514,12 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long seekP
   }
 
   @Override
-  public IOException getError() {
-    return fatalError != null ? fatalError
-        : (manifestFetcher != null ? manifestFetcher.getError() : null);
+  public void maybeThrowError() throws IOException {
+    if (fatalError != null) {
+      throw fatalError;
+    } else if (manifestFetcher != null) {
+      manifestFetcher.maybeThrowError();
+    }
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/DashWrappingSegmentIndex.java b/library/src/main/java/com/google/android/exoplayer/dash/DashWrappingSegmentIndex.java
index 441cad6194..bcff061458 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/DashWrappingSegmentIndex.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/DashWrappingSegmentIndex.java
@@ -22,7 +22,7 @@
  * An implementation of {@link DashSegmentIndex} that wraps a {@link ChunkIndex} parsed from a
  * media stream.
  */
-public class DashWrappingSegmentIndex implements DashSegmentIndex {
+/* package */ final class DashWrappingSegmentIndex implements DashSegmentIndex {
 
   private final ChunkIndex chunkIndex;
   private final String uri;
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/DashSingleSegmentIndex.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/DashSingleSegmentIndex.java
similarity index 90%
rename from library/src/main/java/com/google/android/exoplayer/dash/DashSingleSegmentIndex.java
rename to library/src/main/java/com/google/android/exoplayer/dash/mpd/DashSingleSegmentIndex.java
index 46a02a3ea2..9b8f6b276c 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/DashSingleSegmentIndex.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/DashSingleSegmentIndex.java
@@ -13,14 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.dash;
+package com.google.android.exoplayer.dash.mpd;
 
-import com.google.android.exoplayer.dash.mpd.RangedUri;
+import com.google.android.exoplayer.dash.DashSegmentIndex;
 
 /**
  * A {@link DashSegmentIndex} that defines a single segment.
  */
-public class DashSingleSegmentIndex implements DashSegmentIndex {
+/* package */ final class DashSingleSegmentIndex implements DashSegmentIndex {
 
   private final long startTimeUs;
   private final long durationUs;
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/Representation.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/Representation.java
index f5eb289fd5..54c0d6913a 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/Representation.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/Representation.java
@@ -18,7 +18,6 @@
 import com.google.android.exoplayer.chunk.Format;
 import com.google.android.exoplayer.chunk.FormatWrapper;
 import com.google.android.exoplayer.dash.DashSegmentIndex;
-import com.google.android.exoplayer.dash.DashSingleSegmentIndex;
 import com.google.android.exoplayer.dash.mpd.SegmentBase.MultiSegmentBase;
 import com.google.android.exoplayer.dash.mpd.SegmentBase.SingleSegmentBase;
 
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/UtcTimingElement.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/UtcTimingElement.java
index e2f452b543..025cec3413 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/UtcTimingElement.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/UtcTimingElement.java
@@ -18,7 +18,7 @@
 /**
  * Represents a UTCTiming element.
  */
-public class UtcTimingElement {
+public final class UtcTimingElement {
 
   public final String schemeIdUri;
   public final String value;
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/UtcTimingElementResolver.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/UtcTimingElementResolver.java
index c275faebd7..19098fa8f5 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/UtcTimingElementResolver.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/UtcTimingElementResolver.java
@@ -38,7 +38,7 @@
 /**
  * Resolves a {@link UtcTimingElement}.
  */
-public class UtcTimingElementResolver implements Loader.Callback {
+public final class UtcTimingElementResolver implements Loader.Callback {
 
   /**
    * Callback for timing element resolution.
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/DefaultExtractorInput.java b/library/src/main/java/com/google/android/exoplayer/extractor/DefaultExtractorInput.java
index 0fb9008afc..a7a4ae2d9b 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/DefaultExtractorInput.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/DefaultExtractorInput.java
@@ -20,6 +20,7 @@
 
 import java.io.EOFException;
 import java.io.IOException;
+import java.util.Arrays;
 
 /**
  * An {@link ExtractorInput} that wraps a {@link DataSource}.
@@ -29,9 +30,12 @@
   private static final byte[] SCRATCH_SPACE = new byte[4096];
 
   private final DataSource dataSource;
+  private final long streamLength;
 
   private long position;
-  private long length;
+  private byte[] peekBuffer;
+  private int peekBufferPosition;
+  private int peekBufferLength;
 
   /**
    * @param dataSource The wrapped {@link DataSource}.
@@ -41,7 +45,8 @@
   public DefaultExtractorInput(DataSource dataSource, long position, long length) {
     this.dataSource = dataSource;
     this.position = position;
-    this.length = length;
+    this.streamLength = length;
+    peekBuffer = new byte[8 * 1024];
   }
 
   @Override
@@ -49,10 +54,16 @@ public int read(byte[] target, int offset, int length) throws IOException, Inter
     if (Thread.interrupted()) {
       throw new InterruptedException();
     }
-    int bytesRead = dataSource.read(target, offset, length);
+    int peekBytes = Math.min(peekBufferLength, length);
+    System.arraycopy(peekBuffer, 0, target, offset, peekBytes);
+    offset += peekBytes;
+    length -= peekBytes;
+    int bytesRead = length != 0 ? dataSource.read(target, offset, length) : 0;
     if (bytesRead == C.RESULT_END_OF_INPUT) {
       return C.RESULT_END_OF_INPUT;
     }
+    updatePeekBuffer(peekBytes);
+    bytesRead += peekBytes;
     position += bytesRead;
     return bytesRead;
   }
@@ -60,7 +71,10 @@ public int read(byte[] target, int offset, int length) throws IOException, Inter
   @Override
   public boolean readFully(byte[] target, int offset, int length, boolean allowEndOfInput)
       throws IOException, InterruptedException {
-    int remaining = length;
+    int peekBytes = Math.min(peekBufferLength, length);
+    System.arraycopy(peekBuffer, 0, target, offset, peekBytes);
+    offset += peekBytes;
+    int remaining = length - peekBytes;
     while (remaining > 0) {
       if (Thread.interrupted()) {
         throw new InterruptedException();
@@ -75,6 +89,7 @@ public boolean readFully(byte[] target, int offset, int length, boolean allowEnd
       offset += bytesRead;
       remaining -= bytesRead;
     }
+    updatePeekBuffer(peekBytes);
     position += length;
     return true;
   }
@@ -87,7 +102,8 @@ public void readFully(byte[] target, int offset, int length)
 
   @Override
   public void skipFully(int length) throws IOException, InterruptedException {
-    int remaining = length;
+    int peekBytes = Math.min(peekBufferLength, length);
+    int remaining = length - peekBytes;
     while (remaining > 0) {
       if (Thread.interrupted()) {
         throw new InterruptedException();
@@ -98,9 +114,64 @@ public void skipFully(int length) throws IOException, InterruptedException {
       }
       remaining -= bytesRead;
     }
+    updatePeekBuffer(peekBytes);
     position += length;
   }
 
+  @Override
+  public void peekFully(byte[] target, int offset, int length)
+      throws IOException, InterruptedException {
+    ensureSpaceForPeek(length);
+    int peekBytes = Math.min(peekBufferLength - peekBufferPosition, length);
+    System.arraycopy(peekBuffer, peekBufferPosition, target, offset, peekBytes);
+    offset += peekBytes;
+    int fillBytes = length - peekBytes;
+    int remaining = fillBytes;
+    int writePosition = peekBufferLength;
+    while (remaining > 0) {
+      if (Thread.interrupted()) {
+        throw new InterruptedException();
+      }
+      int bytesRead = dataSource.read(peekBuffer, writePosition, remaining);
+      if (bytesRead == C.RESULT_END_OF_INPUT) {
+        throw new EOFException();
+      }
+      System.arraycopy(peekBuffer, writePosition, target, offset, bytesRead);
+      remaining -= bytesRead;
+      writePosition += bytesRead;
+      offset += bytesRead;
+    }
+    peekBufferPosition += length;
+    peekBufferLength += fillBytes;
+  }
+
+  @Override
+  public void advancePeekPosition(int length) throws IOException, InterruptedException {
+    ensureSpaceForPeek(length);
+    int peekBytes = Math.min(peekBufferLength - peekBufferPosition, length);
+    int fillBytes = length - peekBytes;
+    int remaining = fillBytes;
+    int writePosition = peekBufferLength;
+    while (remaining > 0) {
+      if (Thread.interrupted()) {
+        throw new InterruptedException();
+      }
+      int bytesRead = dataSource.read(peekBuffer, writePosition, remaining);
+      if (bytesRead == C.RESULT_END_OF_INPUT) {
+        throw new EOFException();
+      }
+      remaining -= bytesRead;
+      writePosition += bytesRead;
+    }
+    peekBufferPosition += length;
+    peekBufferLength += fillBytes;
+  }
+
+  @Override
+  public void resetPeekPosition() {
+    peekBufferPosition = 0;
+  }
+
   @Override
   public long getPosition() {
     return position;
@@ -108,7 +179,29 @@ public long getPosition() {
 
   @Override
   public long getLength() {
-    return length;
+    return streamLength;
+  }
+
+  /**
+   * Ensures {@code peekBuffer} is large enough to store at least {@code length} bytes from the
+   * current peek position.
+   */
+  private void ensureSpaceForPeek(int length) {
+    int requiredLength = peekBufferPosition + length;
+    if (requiredLength > peekBuffer.length) {
+      peekBuffer = Arrays.copyOf(peekBuffer, Math.max(peekBuffer.length * 2, requiredLength));
+    }
+  }
+
+  /**
+   * Updates the peek buffer's length, position and contents after consuming data.
+   *
+   * @param bytesConsumed The number of bytes consumed from the peek buffer.
+   */
+  private void updatePeekBuffer(int bytesConsumed) {
+    peekBufferLength -= bytesConsumed;
+    peekBufferPosition = 0;
+    System.arraycopy(peekBuffer, bytesConsumed, peekBuffer, 0, peekBufferLength);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/DefaultTrackOutput.java b/library/src/main/java/com/google/android/exoplayer/extractor/DefaultTrackOutput.java
index 330f320d22..00689ae243 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/DefaultTrackOutput.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/DefaultTrackOutput.java
@@ -15,12 +15,14 @@
  */
 package com.google.android.exoplayer.extractor;
 
+import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.SampleHolder;
 import com.google.android.exoplayer.upstream.Allocator;
 import com.google.android.exoplayer.upstream.DataSource;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
+import java.io.EOFException;
 import java.io.IOException;
 
 /**
@@ -225,8 +227,20 @@ private boolean advanceToEligibleSample() {
 
   // Called by the loading thread.
 
-  public int sampleData(DataSource dataSource, int length) throws IOException {
-    return rollingBuffer.appendData(dataSource, length);
+  /**
+   * Invoked to write sample data to the output.
+   *
+   * @param dataSource A {@link DataSource} from which to read the sample data.
+   * @param length The maximum length to read from the input.
+   * @param allowEndOfInput True if encountering the end of the input having read no data is
+   *     allowed, and should result in {@link C#RESULT_END_OF_INPUT} being returned. False if it
+   *     should be considered an error, causing an {@link EOFException} to be thrown.
+   * @return The number of bytes appended.
+   * @throws IOException If an error occurred reading from the input.
+   */
+  public int sampleData(DataSource dataSource, int length, boolean allowEndOfInput)
+      throws IOException {
+    return rollingBuffer.appendData(dataSource, length, allowEndOfInput);
   }
 
   // TrackOutput implementation. Called by the loading thread.
@@ -237,8 +251,9 @@ public void format(MediaFormat format) {
   }
 
   @Override
-  public int sampleData(ExtractorInput input, int length) throws IOException, InterruptedException {
-    return rollingBuffer.appendData(input, length);
+  public int sampleData(ExtractorInput input, int length, boolean allowEndOfInput)
+      throws IOException, InterruptedException {
+    return rollingBuffer.appendData(input, length, allowEndOfInput);
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/Extractor.java
index 9b803a9e34..e44e67b3f4 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/Extractor.java
@@ -49,6 +49,15 @@
    */
   void init(ExtractorOutput output);
 
+  /**
+   * Returns whether this extractor can extract samples from the {@link ExtractorInput}, which must
+   * provide data from the start of the stream.
+   *
+   * @throws IOException If an error occurred reading from the input.
+   * @throws InterruptedException If the thread was interrupted.
+   */
+  boolean sniff(ExtractorInput input) throws IOException, InterruptedException;
+
   /**
    * Extracts data read from a provided {@link ExtractorInput}.
    * <p>
@@ -76,9 +85,10 @@ int read(ExtractorInput input, PositionHolder seekPosition)
    * Notifies the extractor that a seek has occurred.
    * <p>
    * Following a call to this method, the {@link ExtractorInput} passed to the next invocation of
-   * {@link #read(ExtractorInput, PositionHolder)} is required to provide data starting from any
-   * random access position in the stream. Random access positions can be obtained from a
-   * {@link SeekMap} that has been extracted and passed to the {@link ExtractorOutput}.
+   * {@link #read(ExtractorInput, PositionHolder)} is required to provide data starting from a
+   * random access position in the stream. Valid random access positions are the start of the
+   * stream and positions that can be obtained from any {@link SeekMap} passed to the
+   * {@link ExtractorOutput}.
    */
   void seek();
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorInput.java b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorInput.java
index 63c09aab3d..bf5788fc8c 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorInput.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorInput.java
@@ -93,9 +93,40 @@ boolean readFully(byte[] target, int offset, int length, boolean allowEndOfInput
   void skipFully(int length) throws IOException, InterruptedException;
 
   /**
-   * The current position (byte offset) in the stream.
+   * Peeks {@code length} bytes from the peek position, writing them into {@code target} at index
+   * {@code offset}. The current read position is left unchanged.
+   * <p>
+   * Calling {@link #resetPeekPosition()} resets the peek position to equal the current read
+   * position, so the caller can peek the same data again. Reading also resets the peek position.
+   *
+   * @param target A target array into which data should be written.
+   * @param offset The offset into the target array at which to write.
+   * @param length The number of bytes to peek from the input.
+   * @throws EOFException If the end of input was encountered.
+   * @throws IOException If an error occurs peeking from the input.
+   * @throws InterruptedException If the thread is interrupted.
+   */
+  void peekFully(byte[] target, int offset, int length) throws IOException, InterruptedException;
+
+  /**
+   * Advances the peek position by {@code length} bytes.
+   *
+   * @param length The number of bytes to peek from the input.
+   * @throws EOFException If the end of input was encountered.
+   * @throws IOException If an error occurs peeking from the input.
+   * @throws InterruptedException If the thread is interrupted.
+   */
+  void advancePeekPosition(int length) throws IOException, InterruptedException;
+
+  /**
+   * Resets the peek position to equal the current read position.
+   */
+  void resetPeekPosition();
+
+  /**
+   * The current read position (byte offset) in the stream.
    *
-   * @return The position (byte offset) in the stream.
+   * @return The read position (byte offset) in the stream.
    */
   long getPosition();
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
index 37e2ccba18..639c992b65 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
@@ -18,6 +18,7 @@
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.MediaFormatHolder;
+import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.SampleHolder;
 import com.google.android.exoplayer.SampleSource;
 import com.google.android.exoplayer.SampleSource.SampleSourceReader;
@@ -31,18 +32,55 @@
 import com.google.android.exoplayer.upstream.Loader;
 import com.google.android.exoplayer.upstream.Loader.Loadable;
 import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.Util;
 
 import android.net.Uri;
 import android.os.SystemClock;
 import android.util.SparseArray;
 
+import java.io.EOFException;
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
 
 /**
- * A {@link SampleSource} that extracts sample data using an {@link Extractor}
+ * A {@link SampleSource} that extracts sample data using an {@link Extractor}.
+ *
+ * <p>If no {@link Extractor} instances are passed to the constructor, the input stream container
+ * format will be detected automatically from the following supported formats:
+ *
+ * <ul>
+ * <li>Fragmented MP4
+ * ({@link com.google.android.exoplayer.extractor.mp4.FragmentedMp4Extractor})</li>
+ * <li>Unfragmented MP4, including M4A
+ * ({@link com.google.android.exoplayer.extractor.mp4.Mp4Extractor})</li>
+ * <li>Matroska, including WebM
+ * ({@link com.google.android.exoplayer.extractor.webm.WebmExtractor})</li>
+ * <li>MP3 ({@link com.google.android.exoplayer.extractor.mp3.Mp3Extractor})</li>
+ * <li>AAC ({@link com.google.android.exoplayer.extractor.ts.AdtsExtractor})</li>
+ * <li>MPEG TS ({@link com.google.android.exoplayer.extractor.ts.TsExtractor}</li>
+ * </ul>
+ *
+ * <p>Seeking in AAC and MPEG TS streams is not supported.
+ *
+ * <p>To override the default extractors, pass one or more {@link Extractor} instances to the
+ * constructor. When reading a new stream, the first {@link Extractor} that returns {@code true}
+ * from {@link Extractor#sniff(ExtractorInput)} will be used.
  */
-public class ExtractorSampleSource implements SampleSource, SampleSourceReader, ExtractorOutput,
-    Loader.Callback {
+public final class ExtractorSampleSource implements SampleSource, SampleSourceReader,
+    ExtractorOutput, Loader.Callback {
+
+  /**
+   * Thrown if the input format could not recognized.
+   */
+  public static final class UnrecognizedInputFormatException extends ParserException {
+
+    public UnrecognizedInputFormatException(Extractor[] extractors) {
+      super("None of the available extractors ("
+          + Util.getCommaDelimitedSimpleClassNames(extractors) + ") could read the stream.");
+    }
+
+  }
 
   /**
    * The default minimum number of times to retry loading prior to failing for on-demand streams.
@@ -57,12 +95,65 @@
   private static final int MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA = -1;
   private static final int NO_RESET_PENDING = -1;
 
-  private final Extractor extractor;
+  /**
+   * Default extractor classes in priority order. They are referred to indirectly so that it is
+   * possible to remove unused extractors.
+   */
+  private static final List<Class<? extends Extractor>> DEFAULT_EXTRACTOR_CLASSES;
+  static {
+    DEFAULT_EXTRACTOR_CLASSES = new ArrayList<>();
+    // Load extractors using reflection so that they can be deleted cleanly.
+    // Class.forName(<class name>) appears for each extractor so that automated tools like proguard
+    // can detect the use of reflection (see http://proguard.sourceforge.net/FAQ.html#forname).
+    try {
+      DEFAULT_EXTRACTOR_CLASSES.add(
+          Class.forName("com.google.android.exoplayer.extractor.webm.WebmExtractor")
+              .asSubclass(Extractor.class));
+    } catch (ClassNotFoundException e) {
+      // Extractor not found.
+    }
+    try {
+      DEFAULT_EXTRACTOR_CLASSES.add(
+          Class.forName("com.google.android.exoplayer.extractor.mp4.FragmentedMp4Extractor")
+              .asSubclass(Extractor.class));
+    } catch (ClassNotFoundException e) {
+      // Extractor not found.
+    }
+    try {
+      DEFAULT_EXTRACTOR_CLASSES.add(
+          Class.forName("com.google.android.exoplayer.extractor.mp4.Mp4Extractor")
+              .asSubclass(Extractor.class));
+    } catch (ClassNotFoundException e) {
+      // Extractor not found.
+    }
+    try {
+      DEFAULT_EXTRACTOR_CLASSES.add(
+          Class.forName("com.google.android.exoplayer.extractor.mp3.Mp3Extractor")
+              .asSubclass(Extractor.class));
+    } catch (ClassNotFoundException e) {
+      // Extractor not found.
+    }
+    try {
+      DEFAULT_EXTRACTOR_CLASSES.add(
+          Class.forName("com.google.android.exoplayer.extractor.ts.AdtsExtractor")
+              .asSubclass(Extractor.class));
+    } catch (ClassNotFoundException e) {
+      // Extractor not found.
+    }
+    try {
+      DEFAULT_EXTRACTOR_CLASSES.add(
+          Class.forName("com.google.android.exoplayer.extractor.ts.TsExtractor")
+              .asSubclass(Extractor.class));
+    } catch (ClassNotFoundException e) {
+      // Extractor not found.
+    }
+  }
+
+  private final ExtractorHolder extractorHolder;
   private final Allocator allocator;
   private final int requestedBufferSize;
   private final SparseArray<InternalTrackOutput> sampleQueues;
   private final int minLoadableRetryCount;
-  private final boolean frameAccurateSeeking;
   private final Uri uri;
   private final DataSource dataSource;
 
@@ -101,68 +192,82 @@
   /**
    * @param uri The {@link Uri} of the media stream.
    * @param dataSource A data source to read the media stream.
-   * @param extractor An {@link Extractor} to extract the media stream.
    * @param requestedBufferSize The requested total buffer size for storing sample data, in bytes.
    *     The actual allocated size may exceed the value passed in if the implementation requires it.
+   * @param extractors {@link Extractor}s to extract the media stream, in order of decreasing
+   *     priority. If omitted, the default extractors will be used.
    */
   @Deprecated
-  public ExtractorSampleSource(Uri uri, DataSource dataSource, Extractor extractor,
-      int requestedBufferSize) {
-    this(uri, dataSource, extractor, new DefaultAllocator(64 * 1024), requestedBufferSize);
+  public ExtractorSampleSource(Uri uri, DataSource dataSource, int requestedBufferSize,
+      Extractor... extractors) {
+    this(uri, dataSource, new DefaultAllocator(64 * 1024), requestedBufferSize, extractors);
   }
 
   /**
    * @param uri The {@link Uri} of the media stream.
    * @param dataSource A data source to read the media stream.
-   * @param extractor An {@link Extractor} to extract the media stream.
    * @param allocator An {@link Allocator} from which to obtain memory allocations.
    * @param requestedBufferSize The requested total buffer size for storing sample data, in bytes.
    *     The actual allocated size may exceed the value passed in if the implementation requires it.
+   * @param extractors {@link Extractor}s to extract the media stream, in order of decreasing
+   *     priority. If omitted, the default extractors will be used.
    */
-  public ExtractorSampleSource(Uri uri, DataSource dataSource, Extractor extractor,
-      Allocator allocator, int requestedBufferSize) {
-    this(uri, dataSource, extractor, allocator, requestedBufferSize,
-        MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA);
+  public ExtractorSampleSource(Uri uri, DataSource dataSource, Allocator allocator,
+      int requestedBufferSize, Extractor... extractors) {
+    this(uri, dataSource, allocator, requestedBufferSize, MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA,
+        extractors);
   }
 
   /**
    * @param uri The {@link Uri} of the media stream.
    * @param dataSource A data source to read the media stream.
-   * @param extractor An {@link Extractor} to extract the media stream.
    * @param requestedBufferSize The requested total buffer size for storing sample data, in bytes.
    *     The actual allocated size may exceed the value passed in if the implementation requires it.
    * @param minLoadableRetryCount The minimum number of times that the sample source will retry
    *     if a loading error occurs.
+   * @param extractors {@link Extractor}s to extract the media stream, in order of decreasing
+   *     priority. If omitted, the default extractors will be used.
    */
   @Deprecated
-  public ExtractorSampleSource(Uri uri, DataSource dataSource, Extractor extractor,
-      int requestedBufferSize, int minLoadableRetryCount) {
-    this(uri, dataSource, extractor, new DefaultAllocator(64 * 1024), requestedBufferSize,
-        minLoadableRetryCount);
+  public ExtractorSampleSource(Uri uri, DataSource dataSource, int requestedBufferSize,
+      int minLoadableRetryCount, Extractor... extractors) {
+    this(uri, dataSource, new DefaultAllocator(64 * 1024), requestedBufferSize,
+        minLoadableRetryCount, extractors);
   }
 
   /**
    * @param uri The {@link Uri} of the media stream.
    * @param dataSource A data source to read the media stream.
-   * @param extractor An {@link Extractor} to extract the media stream.
    * @param allocator An {@link Allocator} from which to obtain memory allocations.
    * @param requestedBufferSize The requested total buffer size for storing sample data, in bytes.
    *     The actual allocated size may exceed the value passed in if the implementation requires it.
    * @param minLoadableRetryCount The minimum number of times that the sample source will retry
    *     if a loading error occurs.
+   * @param extractors {@link Extractor}s to extract the media stream, in order of decreasing
+   *     priority. If omitted, the default extractors will be used.
    */
-  public ExtractorSampleSource(Uri uri, DataSource dataSource, Extractor extractor,
-      Allocator allocator, int requestedBufferSize, int minLoadableRetryCount) {
+  public ExtractorSampleSource(Uri uri, DataSource dataSource, Allocator allocator,
+      int requestedBufferSize, int minLoadableRetryCount, Extractor... extractors) {
     this.uri = uri;
     this.dataSource = dataSource;
-    this.extractor = extractor;
     this.allocator = allocator;
     this.requestedBufferSize = requestedBufferSize;
     this.minLoadableRetryCount = minLoadableRetryCount;
+    if (extractors == null || extractors.length == 0) {
+      extractors = new Extractor[DEFAULT_EXTRACTOR_CLASSES.size()];
+      for (int i = 0; i < extractors.length; i++) {
+        try {
+          extractors[i] = DEFAULT_EXTRACTOR_CLASSES.get(i).newInstance();
+        } catch (InstantiationException e) {
+          throw new IllegalStateException("Unexpected error creating default extractor", e);
+        } catch (IllegalAccessException e) {
+          throw new IllegalStateException("Unexpected error creating default extractor", e);
+        }
+      }
+    }
+    extractorHolder = new ExtractorHolder(extractors, this);
     sampleQueues = new SparseArray<>();
     pendingResetPositionUs = NO_RESET_PENDING;
-    frameAccurateSeeking = true;
-    extractor.init(this);
   }
 
   @Override
@@ -172,7 +277,7 @@ public SampleSourceReader register() {
   }
 
   @Override
-  public boolean prepare(long positionUs) throws IOException {
+  public boolean prepare(long positionUs) {
     if (prepared) {
       return true;
     }
@@ -198,10 +303,9 @@ public boolean prepare(long positionUs) throws IOException {
       }
       prepared = true;
       return true;
-    } else {
-      maybeThrowLoadableException();
-      return false;
     }
+
+    return false;
   }
 
   @Override
@@ -246,7 +350,7 @@ public void disable(int track) {
   }
 
   @Override
-  public boolean continueBuffering(int track, long playbackPositionUs) throws IOException {
+  public boolean continueBuffering(int track, long playbackPositionUs) {
     Assertions.checkState(prepared);
     Assertions.checkState(trackEnabledStates[track]);
     downstreamPositionUs = playbackPositionUs;
@@ -258,16 +362,12 @@ public boolean continueBuffering(int track, long playbackPositionUs) throws IOEx
     if (isPendingReset()) {
       return false;
     }
-    if (sampleQueues.valueAt(track).isEmpty()) {
-      maybeThrowLoadableException();
-      return false;
-    }
-    return true;
+    return !sampleQueues.valueAt(track).isEmpty();
   }
 
   @Override
   public int readData(int track, long playbackPositionUs, MediaFormatHolder formatHolder,
-      SampleHolder sampleHolder, boolean onlyReadDiscontinuity) throws IOException {
+      SampleHolder sampleHolder, boolean onlyReadDiscontinuity) {
     downstreamPositionUs = playbackPositionUs;
 
     if (pendingDiscontinuities[track]) {
@@ -276,7 +376,6 @@ public int readData(int track, long playbackPositionUs, MediaFormatHolder format
     }
 
     if (onlyReadDiscontinuity || isPendingReset()) {
-      maybeThrowLoadableException();
       return NOTHING_READ;
     }
 
@@ -289,7 +388,7 @@ public int readData(int track, long playbackPositionUs, MediaFormatHolder format
     }
 
     if (sampleQueue.getSample(sampleHolder)) {
-      boolean decodeOnly = frameAccurateSeeking && sampleHolder.timeUs < lastSeekPositionUs;
+      boolean decodeOnly = sampleHolder.timeUs < lastSeekPositionUs;
       sampleHolder.flags |= decodeOnly ? C.SAMPLE_FLAG_DECODE_ONLY : 0;
       if (havePendingNextSampleUs) {
         // Set the offset to make the timestamp of this sample equal to pendingNextSampleUs.
@@ -304,10 +403,30 @@ public int readData(int track, long playbackPositionUs, MediaFormatHolder format
       return END_OF_STREAM;
     }
 
-    maybeThrowLoadableException();
     return NOTHING_READ;
   }
 
+  @Override
+  public void maybeThrowError() throws IOException {
+    if (currentLoadableException == null) {
+      return;
+    }
+    if (isCurrentLoadableExceptionFatal()) {
+      throw currentLoadableException;
+    }
+    int minLoadableRetryCountForMedia;
+    if (minLoadableRetryCount != MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA) {
+      minLoadableRetryCountForMedia = minLoadableRetryCount;
+    } else {
+      minLoadableRetryCountForMedia = seekMap != null && !seekMap.isSeekable()
+          ? DEFAULT_MIN_LOADABLE_RETRY_COUNT_LIVE
+          : DEFAULT_MIN_LOADABLE_RETRY_COUNT_ON_DEMAND;
+    }
+    if (currentLoadableExceptionCount > minLoadableRetryCountForMedia) {
+      throw currentLoadableException;
+    }
+  }
+
   @Override
   public void seekToUs(long positionUs) {
     Assertions.checkState(prepared);
@@ -439,6 +558,9 @@ private void maybeStartLoading() {
     }
 
     if (currentLoadableException != null) {
+      if (isCurrentLoadableExceptionFatal()) {
+        return;
+      }
       Assertions.checkState(loadable != null);
       long elapsedMillis = SystemClock.elapsedRealtime() - currentLoadableExceptionTimestamp;
       if (elapsedMillis >= getRetryDelayMillis(currentLoadableExceptionCount)) {
@@ -496,29 +618,13 @@ private void maybeStartLoading() {
     loader.startLoading(loadable, this);
   }
 
-  private void maybeThrowLoadableException() throws IOException {
-    if (currentLoadableException == null) {
-      return;
-    }
-    int minLoadableRetryCountForMedia;
-    if (minLoadableRetryCount != MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA) {
-      minLoadableRetryCountForMedia = minLoadableRetryCount;
-    } else {
-      minLoadableRetryCountForMedia = seekMap != null && !seekMap.isSeekable()
-          ? DEFAULT_MIN_LOADABLE_RETRY_COUNT_LIVE
-          : DEFAULT_MIN_LOADABLE_RETRY_COUNT_ON_DEMAND;
-    }
-    if (currentLoadableExceptionCount > minLoadableRetryCountForMedia) {
-      throw currentLoadableException;
-    }
-  }
-
   private ExtractingLoadable createLoadableFromStart() {
-    return new ExtractingLoadable(uri, dataSource, extractor, allocator, requestedBufferSize, 0);
+    return new ExtractingLoadable(uri, dataSource, extractorHolder, allocator, requestedBufferSize,
+        0);
   }
 
   private ExtractingLoadable createLoadableFromPositionUs(long positionUs) {
-    return new ExtractingLoadable(uri, dataSource, extractor, allocator, requestedBufferSize,
+    return new ExtractingLoadable(uri, dataSource, extractorHolder, allocator, requestedBufferSize,
         seekMap.getPosition(positionUs));
   }
 
@@ -552,6 +658,10 @@ private boolean isPendingReset() {
     return pendingResetPositionUs != NO_RESET_PENDING;
   }
 
+  private boolean isCurrentLoadableExceptionFatal() {
+    return currentLoadableException instanceof UnrecognizedInputFormatException;
+  }
+
   private long getRetryDelayMillis(long errorCount) {
     return Math.min((errorCount - 1) * 1000, 5000);
   }
@@ -581,7 +691,7 @@ public void sampleMetadata(long timeUs, int flags, int size, int offset, byte[]
 
     private final Uri uri;
     private final DataSource dataSource;
-    private final Extractor extractor;
+    private final ExtractorHolder extractorHolder;
     private final Allocator allocator;
     private final int requestedBufferSize;
     private final PositionHolder positionHolder;
@@ -590,11 +700,11 @@ public void sampleMetadata(long timeUs, int flags, int size, int offset, byte[]
 
     private boolean pendingExtractorSeek;
 
-    public ExtractingLoadable(Uri uri, DataSource dataSource, Extractor extractor,
+    public ExtractingLoadable(Uri uri, DataSource dataSource, ExtractorHolder extractorHolder,
         Allocator allocator, int requestedBufferSize, long position) {
       this.uri = Assertions.checkNotNull(uri);
       this.dataSource = Assertions.checkNotNull(dataSource);
-      this.extractor = Assertions.checkNotNull(extractor);
+      this.extractorHolder = Assertions.checkNotNull(extractorHolder);
       this.allocator = Assertions.checkNotNull(allocator);
       this.requestedBufferSize = requestedBufferSize;
       positionHolder = new PositionHolder();
@@ -614,10 +724,6 @@ public boolean isLoadCanceled() {
 
     @Override
     public void load() throws IOException, InterruptedException {
-      if (pendingExtractorSeek) {
-        extractor.seek();
-        pendingExtractorSeek = false;
-      }
       int result = Extractor.RESULT_CONTINUE;
       while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
         ExtractorInput input = null;
@@ -628,6 +734,11 @@ public void load() throws IOException, InterruptedException {
             length += position;
           }
           input = new DefaultExtractorInput(dataSource, position, length);
+          Extractor extractor = extractorHolder.selectExtractor(input);
+          if (pendingExtractorSeek) {
+            extractor.seek();
+            pendingExtractorSeek = false;
+          }
           while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
             allocator.blockWhileTotalBytesAllocatedExceeds(requestedBufferSize);
             result = extractor.read(input, positionHolder);
@@ -646,4 +757,58 @@ public void load() throws IOException, InterruptedException {
 
   }
 
+  /**
+   * Stores a list of extractors and a selected extractor when the format has been detected.
+   */
+  private static final class ExtractorHolder {
+
+    private final Extractor[] extractors;
+    private final ExtractorOutput extractorOutput;
+    private Extractor extractor;
+
+    /**
+     * Creates a holder that will select an extractor and initialize it using the specified output.
+     *
+     * @param extractors One or more extractors to choose from.
+     * @param extractorOutput The output that will be used to initialize the selected extractor.
+     */
+    public ExtractorHolder(Extractor[] extractors, ExtractorOutput extractorOutput) {
+      this.extractors = extractors;
+      this.extractorOutput = extractorOutput;
+    }
+
+    /**
+     * Returns an initialized extractor for reading {@code input}, and returns the same extractor on
+     * later calls.
+     *
+     * @param input The {@link ExtractorInput} from which data should be read.
+     * @throws UnrecognizedInputFormatException Thrown if the input format could not be detected.
+     * @throws IOException Thrown if the input could not be read.
+     * @throws InterruptedException Thrown if the thread was interrupted.
+     */
+    public Extractor selectExtractor(ExtractorInput input)
+        throws UnrecognizedInputFormatException, IOException, InterruptedException {
+      if (extractor != null) {
+        return extractor;
+      }
+      for (Extractor extractor : extractors) {
+        try {
+          if (extractor.sniff(input)) {
+            this.extractor = extractor;
+            break;
+          }
+        } catch (EOFException e) {
+          // Do nothing.
+        }
+        input.resetPeekPosition();
+      }
+      if (extractor == null) {
+        throw new UnrecognizedInputFormatException(extractors);
+      }
+      extractor.init(extractorOutput);
+      return extractor;
+    }
+
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java b/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java
index 4cc229d847..c6cdb8b1c4 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java
@@ -23,6 +23,7 @@
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
+import java.io.EOFException;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.concurrent.LinkedBlockingDeque;
@@ -350,26 +351,27 @@ public long getWritePosition() {
    * Appends data to the rolling buffer.
    *
    * @param dataSource The source from which to read.
-   * @param length The maximum length of the read, or {@link C#LENGTH_UNBOUNDED} if the caller does
-   *     not wish to impose a limit.
-   * @return The number of bytes appended.
+   * @param length The maximum length of the read.
+   * @param allowEndOfInput True if encountering the end of the input having appended no data is
+   *     allowed, and should result in {@link C#RESULT_END_OF_INPUT} being returned. False if it
+   *     should be considered an error, causing an {@link EOFException} to be thrown.
+   * @return The number of bytes appended, or {@link C#RESULT_END_OF_INPUT} if the input has ended.
    * @throws IOException If an error occurs reading from the source.
    */
-  public int appendData(DataSource dataSource, int length) throws IOException {
-    ensureSpaceForWrite();
-    int remainingAllocationCapacity = allocationLength - lastAllocationOffset;
-    length = length != C.LENGTH_UNBOUNDED ? Math.min(length, remainingAllocationCapacity)
-        : remainingAllocationCapacity;
-
-    int bytesRead = dataSource.read(lastAllocation.data,
+  public int appendData(DataSource dataSource, int length, boolean allowEndOfInput)
+      throws IOException {
+    length = prepareForAppend(length);
+    int bytesAppended = dataSource.read(lastAllocation.data,
         lastAllocation.translateOffset(lastAllocationOffset), length);
-    if (bytesRead == C.RESULT_END_OF_INPUT) {
-      return C.RESULT_END_OF_INPUT;
+    if (bytesAppended == C.RESULT_END_OF_INPUT) {
+      if (allowEndOfInput) {
+        return C.RESULT_END_OF_INPUT;
+      }
+      throw new EOFException();
     }
-
-    lastAllocationOffset += bytesRead;
-    totalBytesWritten += bytesRead;
-    return bytesRead;
+    lastAllocationOffset += bytesAppended;
+    totalBytesWritten += bytesAppended;
+    return bytesAppended;
   }
 
   /**
@@ -377,17 +379,27 @@ public int appendData(DataSource dataSource, int length) throws IOException {
    *
    * @param input The source from which to read.
    * @param length The maximum length of the read.
-   * @return The number of bytes appended.
+   * @param allowEndOfInput True if encountering the end of the input having appended no data is
+   *     allowed, and should result in {@link C#RESULT_END_OF_INPUT} being returned. False if it
+   *     should be considered an error, causing an {@link EOFException} to be thrown.
+   * @return The number of bytes appended, or {@link C#RESULT_END_OF_INPUT} if the input has ended.
    * @throws IOException If an error occurs reading from the source.
+   * @throws InterruptedException If the thread has been interrupted.
    */
-  public int appendData(ExtractorInput input, int length) throws IOException, InterruptedException {
-    ensureSpaceForWrite();
-    int thisWriteLength = Math.min(length, allocationLength - lastAllocationOffset);
-    input.readFully(lastAllocation.data, lastAllocation.translateOffset(lastAllocationOffset),
-        thisWriteLength);
-    lastAllocationOffset += thisWriteLength;
-    totalBytesWritten += thisWriteLength;
-    return thisWriteLength;
+  public int appendData(ExtractorInput input, int length, boolean allowEndOfInput)
+      throws IOException, InterruptedException {
+    length = prepareForAppend(length);
+    int bytesAppended = input.read(lastAllocation.data,
+        lastAllocation.translateOffset(lastAllocationOffset), length);
+    if (bytesAppended == C.RESULT_END_OF_INPUT) {
+      if (allowEndOfInput) {
+        return C.RESULT_END_OF_INPUT;
+      }
+      throw new EOFException();
+    }
+    lastAllocationOffset += bytesAppended;
+    totalBytesWritten += bytesAppended;
+    return bytesAppended;
   }
 
   /**
@@ -397,16 +409,14 @@ public int appendData(ExtractorInput input, int length) throws IOException, Inte
    * @param length The length of the data to append.
    */
   public void appendData(ParsableByteArray buffer, int length) {
-    int remainingWriteLength = length;
-    while (remainingWriteLength > 0) {
-      ensureSpaceForWrite();
-      int thisWriteLength = Math.min(remainingWriteLength, allocationLength - lastAllocationOffset);
+    while (length > 0) {
+      int thisAppendLength = prepareForAppend(length);
       buffer.readBytes(lastAllocation.data, lastAllocation.translateOffset(lastAllocationOffset),
-          thisWriteLength);
-      lastAllocationOffset += thisWriteLength;
-      remainingWriteLength -= thisWriteLength;
+          thisAppendLength);
+      lastAllocationOffset += thisAppendLength;
+      totalBytesWritten += thisAppendLength;
+      length -= thisAppendLength;
     }
-    totalBytesWritten += length;
   }
 
   /**
@@ -424,14 +434,16 @@ public void commitSample(long sampleTimeUs, int flags, long position, int size,
   }
 
   /**
-   * Ensures at least one byte can be written, obtaining an additional allocation if necessary.
+   * Prepares the rolling sample buffer for an append of up to {@code length} bytes, returning the
+   * number of bytes that can actually be appended.
    */
-  private void ensureSpaceForWrite() {
+  private int prepareForAppend(int length) {
     if (lastAllocationOffset == allocationLength) {
       lastAllocationOffset = 0;
       lastAllocation = allocator.allocate();
       dataQueue.add(lastAllocation);
     }
+    return Math.min(length, allocationLength - lastAllocationOffset);
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/SeekMap.java b/library/src/main/java/com/google/android/exoplayer/extractor/SeekMap.java
index 20b333c4a5..701e7ccb28 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/SeekMap.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/SeekMap.java
@@ -20,6 +20,23 @@
  */
 public interface SeekMap {
 
+  /**
+   * A {@link SeekMap} that does not support seeking.
+   */
+  public static final SeekMap UNSEEKABLE = new SeekMap() {
+
+    @Override
+    public boolean isSeekable() {
+      return false;
+    }
+
+    @Override
+    public long getPosition(long timeUs) {
+      return 0;
+    }
+
+  };
+
   /**
    * Whether or not the seeking is supported.
    * <p>
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/TrackOutput.java b/library/src/main/java/com/google/android/exoplayer/extractor/TrackOutput.java
index fa639d75ba..699fddb256 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/TrackOutput.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/TrackOutput.java
@@ -15,10 +15,12 @@
  */
 package com.google.android.exoplayer.extractor;
 
+import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.SampleHolder;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
+import java.io.EOFException;
 import java.io.IOException;
 
 /**
@@ -38,11 +40,15 @@
    *
    * @param input An {@link ExtractorInput} from which to read the sample data.
    * @param length The maximum length to read from the input.
+   * @param allowEndOfInput True if encountering the end of the input having read no data is
+   *     allowed, and should result in {@link C#RESULT_END_OF_INPUT} being returned. False if it
+   *     should be considered an error, causing an {@link EOFException} to be thrown.
    * @return The number of bytes appended.
    * @throws IOException If an error occurred reading from the input.
    * @throws InterruptedException If the thread was interrupted.
    */
-  int sampleData(ExtractorInput input, int length) throws IOException, InterruptedException;
+  int sampleData(ExtractorInput input, int length, boolean allowEndOfInput)
+      throws IOException, InterruptedException;
 
   /**
    * Invoked to write sample data to the output.
@@ -56,14 +62,16 @@
    * Invoked when metadata associated with a sample has been extracted from the stream.
    * <p>
    * The corresponding sample data will have already been passed to the output via calls to
-   * {@link #sampleData(ExtractorInput, int)} or {@link #sampleData(ParsableByteArray, int)}.
+   * {@link #sampleData(ExtractorInput, int, boolean)} or
+   * {@link #sampleData(ParsableByteArray, int)}.
    *
    * @param timeUs The media timestamp associated with the sample, in microseconds.
    * @param flags Flags associated with the sample. See {@link SampleHolder#flags}.
    * @param size The size of the sample data, in bytes.
    * @param offset The number of bytes that have been passed to
-   *     {@link #sampleData(ExtractorInput, int)} or {@link #sampleData(ParsableByteArray, int)}
-   *     since the last byte belonging to the sample whose metadata is being passed.
+   *     {@link #sampleData(ExtractorInput, int, boolean)} or
+   *     {@link #sampleData(ParsableByteArray, int)} since the last byte belonging to the sample
+   *     whose metadata is being passed.
    * @param encryptionKey The encryption key associated with the sample. May be null.
    */
   void sampleMetadata(long timeUs, int flags, int size, int offset, byte[] encryptionKey);
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
index fc9ee215cb..269030ca04 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
@@ -37,7 +37,9 @@
 public final class Mp3Extractor implements Extractor {
 
   /** The maximum number of bytes to search when synchronizing, before giving up. */
-  private static final int MAX_BYTES_TO_SEARCH = 128 * 1024;
+  private static final int MAX_SYNC_BYTES = 128 * 1024;
+  /** The maximum number of bytes to read when sniffing, excluding the header, before giving up. */
+  private static final int MAX_SNIFF_BYTES = 4 * 1024;
 
   /** Mask that includes the audio header values that must match between frames. */
   private static final int HEADER_MASK = 0xFFFE0C00;
@@ -68,6 +70,61 @@ public Mp3Extractor() {
     synchronizedHeader = new MpegAudioHeader();
   }
 
+  @Override
+  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+    ParsableByteArray scratch = new ParsableByteArray(4);
+    int startPosition = 0;
+    input.peekFully(scratch.data, 0, 3);
+    if (scratch.readUnsignedInt24() == ID3_TAG) {
+      input.advancePeekPosition(3);
+      input.peekFully(scratch.data, 0, 4);
+      int headerLength = ((scratch.data[0] & 0x7F) << 21) | ((scratch.data[1] & 0x7F) << 14)
+          | ((scratch.data[2] & 0x7F) << 7) | (scratch.data[3] & 0x7F);
+      input.advancePeekPosition(headerLength);
+      startPosition = 3 + 3 + 4 + headerLength;
+    } else {
+      input.resetPeekPosition();
+    }
+
+    // Try to find four consecutive valid MPEG audio frames.
+    int headerPosition = startPosition;
+    int validFrameCount = 0;
+    int candidateSynchronizedHeaderData = 0;
+    while (true) {
+      if (headerPosition - startPosition >= MAX_SNIFF_BYTES) {
+        return false;
+      }
+
+      input.peekFully(scratch.data, 0, 4);
+      scratch.setPosition(0);
+      int headerData = scratch.readInt();
+      int frameSize;
+      if ((candidateSynchronizedHeaderData != 0
+          && (headerData & HEADER_MASK) != (candidateSynchronizedHeaderData & HEADER_MASK))
+          || (frameSize = MpegAudioHeader.getFrameSize(headerData)) == -1) {
+        validFrameCount = 0;
+        candidateSynchronizedHeaderData = 0;
+
+        // Try reading a header starting at the next byte.
+        input.resetPeekPosition();
+        input.advancePeekPosition(++headerPosition);
+        continue;
+      }
+
+      if (validFrameCount == 0) {
+        candidateSynchronizedHeaderData = headerData;
+      }
+
+      // The header was valid and matching (if appropriate). Check another or end synchronization.
+      if (++validFrameCount == 4) {
+        return true;
+      }
+
+      // Look for more headers.
+      input.advancePeekPosition(frameSize - 4);
+    }
+  }
+
   @Override
   public void init(ExtractorOutput extractorOutput) {
     this.extractorOutput = extractorOutput;
@@ -113,9 +170,12 @@ private int readSample(ExtractorInput extractorInput) throws IOException, Interr
     sampleBytesRemaining -= inputBuffer.drainToOutput(trackOutput, sampleBytesRemaining);
     if (sampleBytesRemaining > 0) {
       inputBuffer.mark();
-
+      int bytesAppended = trackOutput.sampleData(extractorInput, sampleBytesRemaining, true);
+      if (bytesAppended == C.RESULT_END_OF_INPUT) {
+        return RESULT_END_OF_INPUT;
+      }
+      sampleBytesRemaining -= bytesAppended;
       // Return if we still need more data.
-      sampleBytesRemaining -= trackOutput.sampleData(extractorInput, sampleBytesRemaining);
       if (sampleBytesRemaining > 0) {
         return RESULT_CONTINUE;
       }
@@ -164,6 +224,7 @@ private long synchronizeCatchingEndOfInput(ExtractorInput extractorInput)
   }
 
   private long synchronize(ExtractorInput extractorInput) throws IOException, InterruptedException {
+    // TODO: Use peekFully instead of a buffering input, and deduplicate with sniff().
     if (extractorInput.getPosition() == 0) {
       // Before preparation completes, retrying loads from the start, so clear any buffered data.
       inputBuffer.reset();
@@ -198,7 +259,7 @@ private long synchronize(ExtractorInput extractorInput) throws IOException, Inte
     int validFrameCount = 0;
     int candidateSynchronizedHeaderData = 0;
     while (true) {
-      if (headerPosition - startPosition >= MAX_BYTES_TO_SEARCH) {
+      if (headerPosition - startPosition >= MAX_SYNC_BYTES) {
         throw new ParserException("Searched too many bytes while resynchronizing.");
       }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/XingSeeker.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/XingSeeker.java
index fd02971a96..b6d2e9c966 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/XingSeeker.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/XingSeeker.java
@@ -69,8 +69,8 @@ public static XingSeeker create(MpegAudioHeader mpegAudioHeader, ParsableByteArr
     }
 
     // TODO: Handle encoder delay and padding in 3 bytes offset by xingBase + 213 bytes:
-    // delay = ((frame.readUnsignedByte() & 0xFF) << 4) + ((frame.readUnsignedByte() & 0xFF) >>> 4);
-    // padding = ((frame.readUnsignedByte() & 0x0F) << 8) + (frame.readUnsignedByte() & 0xFF);
+    // delay = (frame.readUnsignedByte() << 4) + (frame.readUnsignedByte() >> 4);
+    // padding = ((frame.readUnsignedByte() & 0x0F) << 8) + frame.readUnsignedByte();
     return new XingSeeker(tableOfContents, firstFramePosition, sizeBytes, durationUs, inputLength);
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
index 3a4a114a82..0ff25da170 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
@@ -24,16 +24,24 @@
 
 /* package*/ abstract class Atom {
 
-  /** Size of an atom header, in bytes. */
+  /**
+   * Size of an atom header, in bytes.
+   */
   public static final int HEADER_SIZE = 8;
 
-  /** Size of a full atom header, in bytes. */
+  /**
+   * Size of a full atom header, in bytes.
+   */
   public static final int FULL_HEADER_SIZE = 12;
 
-  /** Size of a long atom header, in bytes. */
+  /**
+   * Size of a long atom header, in bytes.
+   */
   public static final int LONG_HEADER_SIZE = 16;
 
-  /** Value for the first 32 bits of atomSize when the atom size is actually a long value. */
+  /**
+   * Value for the first 32 bits of atomSize when the atom size is actually a long value.
+   */
   public static final int LONG_SIZE_PREFIX = 1;
 
   public static final int TYPE_ftyp = Util.getIntegerCodeForString("ftyp");
@@ -41,6 +49,8 @@
   public static final int TYPE_avc3 = Util.getIntegerCodeForString("avc3");
   public static final int TYPE_hvc1 = Util.getIntegerCodeForString("hvc1");
   public static final int TYPE_hev1 = Util.getIntegerCodeForString("hev1");
+  public static final int TYPE_s263 = Util.getIntegerCodeForString("s263");
+  public static final int TYPE_d263 = Util.getIntegerCodeForString("d263");
   public static final int TYPE_mdat = Util.getIntegerCodeForString("mdat");
   public static final int TYPE_mp4a = Util.getIntegerCodeForString("mp4a");
   public static final int TYPE_ac_3 = Util.getIntegerCodeForString("ac-3");
@@ -95,7 +105,7 @@
 
   public final int type;
 
-  Atom(int type) {
+  public Atom(int type) {
     this.type = type;
   }
 
@@ -104,11 +114,20 @@ public String toString() {
     return getAtomTypeString(type);
   }
 
-  /** An MP4 atom that is a leaf. */
-  public static final class LeafAtom extends Atom {
+  /**
+   * An MP4 atom that is a leaf.
+   */
+  /* package */ static final class LeafAtom extends Atom {
 
+    /**
+     * The atom data.
+     */
     public final ParsableByteArray data;
 
+    /**
+     * @param type The type of the atom.
+     * @param data The atom data.
+     */
     public LeafAtom(int type, ParsableByteArray data) {
       super(type);
       this.data = data;
@@ -116,29 +135,53 @@ public LeafAtom(int type, ParsableByteArray data) {
 
   }
 
-  /** An MP4 atom that has child atoms. */
-  public static final class ContainerAtom extends Atom {
+  /**
+   * An MP4 atom that has child atoms.
+   */
+  /* package */ static final class ContainerAtom extends Atom {
 
-    public final long endByteOffset;
+    public final long endPosition;
     public final List<LeafAtom> leafChildren;
     public final List<ContainerAtom> containerChildren;
 
-    public ContainerAtom(int type, long endByteOffset) {
+    /**
+     * @param type The type of the atom.
+     * @param endPosition The position of the first byte after the end of the atom.
+     */
+    public ContainerAtom(int type, long endPosition) {
       super(type);
-
+      this.endPosition = endPosition;
       leafChildren = new ArrayList<>();
       containerChildren = new ArrayList<>();
-      this.endByteOffset = endByteOffset;
     }
 
+    /**
+     * Adds a child leaf to this container.
+     *
+     * @param atom The child to add.
+     */
     public void add(LeafAtom atom) {
       leafChildren.add(atom);
     }
 
+    /**
+     * Adds a child container to this container.
+     *
+     * @param atom The child to add.
+     */
     public void add(ContainerAtom atom) {
       containerChildren.add(atom);
     }
 
+    /**
+     * Gets the child leaf of the given type.
+     * <p>
+     * If no child exists with the given type then null is returned. If multiple children exist with
+     * the given type then the first one to have been added is returned.
+     *
+     * @param type The leaf type.
+     * @return The child leaf of the given type, or null if no such child exists.
+     */
     public LeafAtom getLeafAtomOfType(int type) {
       int childrenSize = leafChildren.size();
       for (int i = 0; i < childrenSize; i++) {
@@ -150,6 +193,15 @@ public LeafAtom getLeafAtomOfType(int type) {
       return null;
     }
 
+    /**
+     * Gets the child container of the given type.
+     * <p>
+     * If no child exists with the given type then null is returned. If multiple children exist with
+     * the given type then the first one to have been added is returned.
+     *
+     * @param type The container type.
+     * @return The child container of the given type, or null if no such child exists.
+     */
     public ContainerAtom getContainerAtomOfType(int type) {
       int childrenSize = containerChildren.size();
       for (int i = 0; i < childrenSize; i++) {
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
index 37ed98d3cc..06395188ac 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
@@ -45,7 +45,7 @@ public static Track parseTrak(Atom.ContainerAtom trak, Atom.LeafAtom mvhd) {
     Atom.ContainerAtom mdia = trak.getContainerAtomOfType(Atom.TYPE_mdia);
     int trackType = parseHdlr(mdia.getLeafAtomOfType(Atom.TYPE_hdlr).data);
     if (trackType != Track.TYPE_AUDIO && trackType != Track.TYPE_VIDEO
-        && trackType != Track.TYPE_TEXT && trackType != Track.TYPE_TIME_CODE) {
+        && trackType != Track.TYPE_TEXT && trackType != Track.TYPE_SUBTITLE) {
       return null;
     }
 
@@ -336,16 +336,17 @@ private static StsdDataHolder parseStsd(ParsableByteArray stsd, long durationUs)
       int childAtomType = stsd.readInt();
       if (childAtomType == Atom.TYPE_avc1 || childAtomType == Atom.TYPE_avc3
           || childAtomType == Atom.TYPE_encv || childAtomType == Atom.TYPE_mp4v
-          || childAtomType == Atom.TYPE_hvc1 || childAtomType == Atom.TYPE_hev1) {
+          || childAtomType == Atom.TYPE_hvc1 || childAtomType == Atom.TYPE_hev1
+          || childAtomType == Atom.TYPE_s263) {
         parseVideoSampleEntry(stsd, childStartPosition, childAtomSize, durationUs, holder, i);
       } else if (childAtomType == Atom.TYPE_mp4a || childAtomType == Atom.TYPE_enca
           || childAtomType == Atom.TYPE_ac_3) {
         parseAudioSampleEntry(stsd, childAtomType, childStartPosition, childAtomSize, durationUs,
             holder, i);
       } else if (childAtomType == Atom.TYPE_TTML) {
-        holder.mediaFormat = MediaFormat.createTextFormat(MimeTypes.APPLICATION_TTML);
+        holder.mediaFormat = MediaFormat.createTextFormat(MimeTypes.APPLICATION_TTML, durationUs);
       } else if (childAtomType == Atom.TYPE_tx3g) {
-        holder.mediaFormat = MediaFormat.createTextFormat(MimeTypes.APPLICATION_TX3G);
+        holder.mediaFormat = MediaFormat.createTextFormat(MimeTypes.APPLICATION_TX3G, durationUs);
       }
       stsd.setPosition(childStartPosition + childAtomSize);
     }
@@ -387,6 +388,9 @@ private static void parseVideoSampleEntry(ParsableByteArray parent, int position
         Pair<List<byte[]>, Integer> hvcCData = parseHvcCFromParent(parent, childStartPosition);
         initializationData = hvcCData.first;
         out.nalUnitLengthFieldLength = hvcCData.second;
+      } else if (childAtomType == Atom.TYPE_d263) {
+        Assertions.checkState(mimeType == null);
+        mimeType = MimeTypes.VIDEO_H263;
       } else if (childAtomType == Atom.TYPE_esds) {
         Assertions.checkState(mimeType == null);
         Pair<String, byte[]> mimeTypeAndInitializationData =
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
index 6469462394..9307f8446d 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
@@ -22,6 +22,7 @@
 import com.google.android.exoplayer.extractor.ExtractorInput;
 import com.google.android.exoplayer.extractor.ExtractorOutput;
 import com.google.android.exoplayer.extractor.PositionHolder;
+import com.google.android.exoplayer.extractor.SeekMap;
 import com.google.android.exoplayer.extractor.TrackOutput;
 import com.google.android.exoplayer.extractor.mp4.Atom.ContainerAtom;
 import com.google.android.exoplayer.extractor.mp4.Atom.LeafAtom;
@@ -76,9 +77,9 @@
   private final TrackFragment fragmentRun;
 
   private int parserState;
-  private int rootAtomBytesRead;
   private int atomType;
-  private int atomSize;
+  private long atomSize;
+  private int atomHeaderBytesRead;
   private ParsableByteArray atomData;
 
   private int sampleIndex;
@@ -94,6 +95,9 @@
   private ExtractorOutput extractorOutput;
   private TrackOutput trackOutput;
 
+  // Whether extractorOutput.seekMap has been invoked.
+  private boolean haveOutputSeekMap;
+
   public FragmentedMp4Extractor() {
     this(0);
   }
@@ -104,14 +108,19 @@ public FragmentedMp4Extractor() {
    */
   public FragmentedMp4Extractor(int workaroundFlags) {
     this.workaroundFlags = workaroundFlags;
-    atomHeader = new ParsableByteArray(Atom.HEADER_SIZE);
+    atomHeader = new ParsableByteArray(Atom.LONG_HEADER_SIZE);
     nalStartCode = new ParsableByteArray(NalUnitUtil.NAL_START_CODE);
     nalLength = new ParsableByteArray(4);
     encryptionSignalByte = new ParsableByteArray(1);
     extendedTypeScratch = new byte[16];
     containerAtoms = new Stack<>();
     fragmentRun = new TrackFragment();
-    parserState = STATE_READING_ATOM_HEADER;
+    enterReadingAtomHeaderState();
+  }
+
+  @Override
+  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+    return Sniffer.sniffFragmented(input);
   }
 
   /**
@@ -138,8 +147,7 @@ public void init(ExtractorOutput output) {
   @Override
   public void seek() {
     containerAtoms.clear();
-    rootAtomBytesRead = 0;
-    parserState = STATE_READING_ATOM_HEADER;
+    enterReadingAtomHeaderState();
   }
 
   @Override
@@ -166,17 +174,36 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     }
   }
 
+  private void enterReadingAtomHeaderState() {
+    parserState = STATE_READING_ATOM_HEADER;
+    atomHeaderBytesRead = 0;
+  }
+
   private boolean readAtomHeader(ExtractorInput input) throws IOException, InterruptedException {
-    if (!input.readFully(atomHeader.data, 0, Atom.HEADER_SIZE, true)) {
-      return false;
+    if (atomHeaderBytesRead == 0) {
+      // Read the standard length atom header.
+      if (!input.readFully(atomHeader.data, 0, Atom.HEADER_SIZE, true)) {
+        return false;
+      }
+      atomHeaderBytesRead = Atom.HEADER_SIZE;
+      atomHeader.setPosition(0);
+      atomSize = atomHeader.readUnsignedInt();
+      atomType = atomHeader.readInt();
     }
 
-    rootAtomBytesRead += Atom.HEADER_SIZE;
-    atomHeader.setPosition(0);
-    atomSize = atomHeader.readInt();
-    atomType = atomHeader.readInt();
+    if (atomSize == Atom.LONG_SIZE_PREFIX) {
+      // Read the extended atom size.
+      int headerBytesRemaining = Atom.LONG_HEADER_SIZE - Atom.HEADER_SIZE;
+      input.readFully(atomHeader.data, Atom.HEADER_SIZE, headerBytesRemaining);
+      atomHeaderBytesRead += headerBytesRemaining;
+      atomSize = atomHeader.readUnsignedLongToLong();
+    }
 
     if (atomType == Atom.TYPE_mdat) {
+      if (!haveOutputSeekMap) {
+        extractorOutput.seekMap(SeekMap.UNSEEKABLE);
+        haveOutputSeekMap = true;
+      }
       if (fragmentRun.sampleEncryptionDataNeedsFill) {
         parserState = STATE_READING_ENCRYPTION_DATA;
       } else {
@@ -187,15 +214,21 @@ private boolean readAtomHeader(ExtractorInput input) throws IOException, Interru
 
     if (shouldParseAtom(atomType)) {
       if (shouldParseContainerAtom(atomType)) {
-        parserState = STATE_READING_ATOM_HEADER;
-        containerAtoms.add(new ContainerAtom(atomType,
-            rootAtomBytesRead + atomSize - Atom.HEADER_SIZE));
+        long endPosition = input.getPosition() + atomSize - Atom.HEADER_SIZE;
+        containerAtoms.add(new ContainerAtom(atomType, endPosition));
+        enterReadingAtomHeaderState();
       } else {
-        atomData = new ParsableByteArray(atomSize);
+        // We don't support parsing of leaf atoms that define extended atom sizes, or that have
+        // lengths greater than Integer.MAX_VALUE.
+        Assertions.checkState(atomHeaderBytesRead == Atom.HEADER_SIZE);
+        Assertions.checkState(atomSize <= Integer.MAX_VALUE);
+        atomData = new ParsableByteArray((int) atomSize);
         System.arraycopy(atomHeader.data, 0, atomData.data, 0, Atom.HEADER_SIZE);
         parserState = STATE_READING_ATOM_PAYLOAD;
       }
     } else {
+      // We don't support skipping of atoms that have lengths greater than Integer.MAX_VALUE.
+      Assertions.checkState(atomSize <= Integer.MAX_VALUE);
       atomData = null;
       parserState = STATE_READING_ATOM_PAYLOAD;
     }
@@ -204,22 +237,18 @@ private boolean readAtomHeader(ExtractorInput input) throws IOException, Interru
   }
 
   private void readAtomPayload(ExtractorInput input) throws IOException, InterruptedException {
-    int payloadLength = atomSize - Atom.HEADER_SIZE;
+    int atomPayloadSize = (int) atomSize - atomHeaderBytesRead;
     if (atomData != null) {
-      input.readFully(atomData.data, Atom.HEADER_SIZE, payloadLength);
-      rootAtomBytesRead += payloadLength;
+      input.readFully(atomData.data, Atom.HEADER_SIZE, atomPayloadSize);
       onLeafAtomRead(new LeafAtom(atomType, atomData), input.getPosition());
     } else {
-      input.skipFully(payloadLength);
-      rootAtomBytesRead += payloadLength;
+      input.skipFully(atomPayloadSize);
     }
-    while (!containerAtoms.isEmpty() && containerAtoms.peek().endByteOffset == rootAtomBytesRead) {
+    long currentPosition = input.getPosition();
+    while (!containerAtoms.isEmpty() && containerAtoms.peek().endPosition == currentPosition) {
       onContainerAtomRead(containerAtoms.pop());
     }
-    if (containerAtoms.isEmpty()) {
-      rootAtomBytesRead = 0;
-    }
-    parserState = STATE_READING_ATOM_HEADER;
+    enterReadingAtomHeaderState();
   }
 
   private void onLeafAtomRead(LeafAtom leaf, long inputPosition) {
@@ -228,6 +257,7 @@ private void onLeafAtomRead(LeafAtom leaf, long inputPosition) {
     } else if (leaf.type == Atom.TYPE_sidx) {
       ChunkIndex segmentIndex = parseSidx(leaf.data, inputPosition);
       extractorOutput.seekMap(segmentIndex);
+      haveOutputSeekMap = true;
     }
   }
 
@@ -592,7 +622,7 @@ private void readEncryptionData(ExtractorInput input) throws IOException, Interr
   private boolean readSample(ExtractorInput input) throws IOException, InterruptedException {
     if (sampleIndex >= fragmentRun.length) {
       // We've run out of samples in the current mdat atom.
-      parserState = STATE_READING_ATOM_HEADER;
+      enterReadingAtomHeaderState();
       return false;
     }
 
@@ -633,14 +663,14 @@ private boolean readSample(ExtractorInput input) throws IOException, Interrupted
           sampleSize += nalUnitLengthFieldLengthDiff;
         } else {
           // Write the payload of the NAL unit.
-          int writtenBytes = trackOutput.sampleData(input, sampleCurrentNalBytesRemaining);
+          int writtenBytes = trackOutput.sampleData(input, sampleCurrentNalBytesRemaining, false);
           sampleBytesWritten += writtenBytes;
           sampleCurrentNalBytesRemaining -= writtenBytes;
         }
       }
     } else {
       while (sampleBytesWritten < sampleSize) {
-        int writtenBytes = trackOutput.sampleData(input, sampleSize - sampleBytesWritten);
+        int writtenBytes = trackOutput.sampleData(input, sampleSize - sampleBytesWritten, false);
         sampleBytesWritten += writtenBytes;
       }
     }
@@ -692,7 +722,7 @@ private static boolean shouldParseAtom(int atom) {
         || atom == Atom.TYPE_trun || atom == Atom.TYPE_mvex || atom == Atom.TYPE_mdia
         || atom == Atom.TYPE_minf || atom == Atom.TYPE_stbl || atom == Atom.TYPE_pssh
         || atom == Atom.TYPE_saiz || atom == Atom.TYPE_uuid || atom == Atom.TYPE_senc
-        || atom == Atom.TYPE_pasp;
+        || atom == Atom.TYPE_pasp || atom == Atom.TYPE_s263;
   }
 
   /** Returns whether the extractor should parse a container atom with type {@code atom}. */
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
index 9ea68fa2ec..b5db6e4cc5 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
@@ -37,15 +37,16 @@
 public final class Mp4Extractor implements Extractor, SeekMap {
 
   // Parser states.
-  private static final int STATE_READING_ATOM_HEADER = 0;
-  private static final int STATE_READING_ATOM_PAYLOAD = 1;
-  private static final int STATE_READING_SAMPLE = 2;
+  private static final int STATE_AFTER_SEEK = 0;
+  private static final int STATE_READING_ATOM_HEADER = 1;
+  private static final int STATE_READING_ATOM_PAYLOAD = 2;
+  private static final int STATE_READING_SAMPLE = 3;
 
   /**
    * When seeking within the source, if the offset is greater than or equal to this value (or the
    * offset is negative), the source will be reloaded.
    */
-  private static final int RELOAD_MINIMUM_SEEK_DISTANCE = 256 * 1024;
+  private static final long RELOAD_MINIMUM_SEEK_DISTANCE = 256 * 1024;
 
   // Temporary arrays.
   private final ParsableByteArray nalStartCode;
@@ -55,10 +56,9 @@
   private final Stack<ContainerAtom> containerAtoms;
 
   private int parserState;
-  private long rootAtomBytesRead;
   private int atomType;
   private long atomSize;
-  private int atomBytesRead;
+  private int atomHeaderBytesRead;
   private ParsableByteArray atomData;
 
   private int sampleSize;
@@ -74,7 +74,12 @@ public Mp4Extractor() {
     containerAtoms = new Stack<>();
     nalStartCode = new ParsableByteArray(NalUnitUtil.NAL_START_CODE);
     nalLength = new ParsableByteArray(4);
-    parserState = STATE_READING_ATOM_HEADER;
+    enterReadingAtomHeaderState();
+  }
+
+  @Override
+  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+    return Sniffer.sniffUnfragmented(input);
   }
 
   @Override
@@ -84,9 +89,11 @@ public void init(ExtractorOutput output) {
 
   @Override
   public void seek() {
-    rootAtomBytesRead = 0;
+    containerAtoms.clear();
+    atomHeaderBytesRead = 0;
     sampleBytesWritten = 0;
     sampleCurrentNalBytesRemaining = 0;
+    parserState = STATE_AFTER_SEEK;
   }
 
   @Override
@@ -94,6 +101,13 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
       throws IOException, InterruptedException {
     while (true) {
       switch (parserState) {
+        case STATE_AFTER_SEEK:
+          if (input.getPosition() == 0) {
+            enterReadingAtomHeaderState();
+          } else {
+            parserState = STATE_READING_SAMPLE;
+          }
+          break;
         case STATE_READING_ATOM_HEADER:
           if (!readAtomHeader(input)) {
             return RESULT_END_OF_INPUT;
@@ -138,36 +152,40 @@ public long getPosition(long timeUs) {
 
   // Private methods.
 
+  private void enterReadingAtomHeaderState() {
+    parserState = STATE_READING_ATOM_HEADER;
+    atomHeaderBytesRead = 0;
+  }
+
   private boolean readAtomHeader(ExtractorInput input) throws IOException, InterruptedException {
-    if (!input.readFully(atomHeader.data, 0, Atom.HEADER_SIZE, true)) {
-      return false;
+    if (atomHeaderBytesRead == 0) {
+      // Read the standard length atom header.
+      if (!input.readFully(atomHeader.data, 0, Atom.HEADER_SIZE, true)) {
+        return false;
+      }
+      atomHeaderBytesRead = Atom.HEADER_SIZE;
+      atomHeader.setPosition(0);
+      atomSize = atomHeader.readUnsignedInt();
+      atomType = atomHeader.readInt();
     }
 
-    atomHeader.setPosition(0);
-    atomSize = atomHeader.readUnsignedInt();
-    atomType = atomHeader.readInt();
     if (atomSize == Atom.LONG_SIZE_PREFIX) {
-      // The extended atom size is contained in the next 8 bytes, so try to read it now.
-      input.readFully(atomHeader.data, Atom.HEADER_SIZE, Atom.LONG_HEADER_SIZE - Atom.HEADER_SIZE);
-      atomSize = atomHeader.readLong();
-      rootAtomBytesRead += Atom.LONG_HEADER_SIZE;
-      atomBytesRead = Atom.LONG_HEADER_SIZE;
-    } else {
-      rootAtomBytesRead += Atom.HEADER_SIZE;
-      atomBytesRead = Atom.HEADER_SIZE;
+      // Read the extended atom size.
+      int headerBytesRemaining = Atom.LONG_HEADER_SIZE - Atom.HEADER_SIZE;
+      input.readFully(atomHeader.data, Atom.HEADER_SIZE, headerBytesRemaining);
+      atomHeaderBytesRead += headerBytesRemaining;
+      atomSize = atomHeader.readUnsignedLongToLong();
     }
 
     if (shouldParseContainerAtom(atomType)) {
-      if (atomSize == Atom.LONG_SIZE_PREFIX) {
-        containerAtoms.add(
-            new ContainerAtom(atomType, rootAtomBytesRead + atomSize - atomBytesRead));
-      } else {
-        containerAtoms.add(
-            new ContainerAtom(atomType, rootAtomBytesRead + atomSize - atomBytesRead));
-      }
-      parserState = STATE_READING_ATOM_HEADER;
+      long endPosition = input.getPosition() + atomSize - atomHeaderBytesRead;
+      containerAtoms.add(new ContainerAtom(atomType, endPosition));
+      enterReadingAtomHeaderState();
     } else if (shouldParseLeafAtom(atomType)) {
-      Assertions.checkState(atomSize < Integer.MAX_VALUE);
+      // We don't support parsing of leaf atoms that define extended atom sizes, or that have
+      // lengths greater than Integer.MAX_VALUE.
+      Assertions.checkState(atomHeaderBytesRead == Atom.HEADER_SIZE);
+      Assertions.checkState(atomSize <= Integer.MAX_VALUE);
       atomData = new ParsableByteArray((int) atomSize);
       System.arraycopy(atomHeader.data, 0, atomData.data, 0, Atom.HEADER_SIZE);
       parserState = STATE_READING_ATOM_PAYLOAD;
@@ -186,31 +204,38 @@ private boolean readAtomHeader(ExtractorInput input) throws IOException, Interru
    */
   private boolean readAtomPayload(ExtractorInput input, PositionHolder positionHolder)
       throws IOException, InterruptedException {
-    parserState = STATE_READING_ATOM_HEADER;
-    rootAtomBytesRead += atomSize - atomBytesRead;
-    long atomRemainingBytes = atomSize - atomBytesRead;
-    boolean seekRequired = atomData == null
-        && (atomSize >= RELOAD_MINIMUM_SEEK_DISTANCE || atomSize > Integer.MAX_VALUE);
-    if (seekRequired) {
-      positionHolder.position = rootAtomBytesRead;
-    } else if (atomData != null) {
-      input.readFully(atomData.data, atomBytesRead, (int) atomRemainingBytes);
+    long atomPayloadSize = atomSize - atomHeaderBytesRead;
+    long atomEndPosition = input.getPosition() + atomPayloadSize;
+    boolean seekRequired = false;
+    if (atomData != null) {
+      input.readFully(atomData.data, atomHeaderBytesRead, (int) atomPayloadSize);
       if (!containerAtoms.isEmpty()) {
         containerAtoms.peek().add(new Atom.LeafAtom(atomType, atomData));
       }
     } else {
-      input.skipFully((int) atomRemainingBytes);
+      // We don't need the data. Skip or seek, depending on how large the atom is.
+      if (atomPayloadSize < RELOAD_MINIMUM_SEEK_DISTANCE) {
+        input.skipFully((int) atomPayloadSize);
+      } else {
+        positionHolder.position = input.getPosition() + atomPayloadSize;
+        seekRequired = true;
+      }
     }
 
-    while (!containerAtoms.isEmpty() && containerAtoms.peek().endByteOffset == rootAtomBytesRead) {
+    while (!containerAtoms.isEmpty() && containerAtoms.peek().endPosition == atomEndPosition) {
       Atom.ContainerAtom containerAtom = containerAtoms.pop();
       if (containerAtom.type == Atom.TYPE_moov) {
+        // We've reached the end of the moov atom. Process it and prepare to read samples.
         processMoovAtom(containerAtom);
+        containerAtoms.clear();
+        parserState = STATE_READING_SAMPLE;
+        return false;
       } else if (!containerAtoms.isEmpty()) {
         containerAtoms.peek().add(containerAtom);
       }
     }
 
+    enterReadingAtomHeaderState();
     return seekRequired;
   }
 
@@ -225,8 +250,7 @@ private void processMoovAtom(ContainerAtom moov) {
       }
 
       Track track = AtomParsers.parseTrak(atom, moov.getLeafAtomOfType(Atom.TYPE_mvhd));
-      if (track == null || (track.type != Track.TYPE_AUDIO && track.type != Track.TYPE_VIDEO
-          && track.type != Track.TYPE_TEXT)) {
+      if (track == null) {
         continue;
       }
 
@@ -249,7 +273,6 @@ private void processMoovAtom(ContainerAtom moov) {
     this.tracks = tracks.toArray(new Mp4Track[0]);
     extractorOutput.endTracks();
     extractorOutput.seekMap(this);
-    parserState = STATE_READING_SAMPLE;
   }
 
   /**
@@ -275,6 +298,7 @@ private int readSample(ExtractorInput input, PositionHolder positionHolder)
       return RESULT_END_OF_INPUT;
     }
     Mp4Track track = tracks[trackIndex];
+    TrackOutput trackOutput = track.trackOutput;
     int sampleIndex = track.sampleIndex;
     long position = track.sampleTable.offsets[sampleIndex];
     long skipAmount = position - input.getPosition() + sampleBytesWritten;
@@ -304,24 +328,24 @@ private int readSample(ExtractorInput input, PositionHolder positionHolder)
           sampleCurrentNalBytesRemaining = nalLength.readUnsignedIntToInt();
           // Write a start code for the current NAL unit.
           nalStartCode.setPosition(0);
-          track.trackOutput.sampleData(nalStartCode, 4);
+          trackOutput.sampleData(nalStartCode, 4);
           sampleBytesWritten += 4;
           sampleSize += nalUnitLengthFieldLengthDiff;
         } else {
           // Write the payload of the NAL unit.
-          int writtenBytes = track.trackOutput.sampleData(input, sampleCurrentNalBytesRemaining);
+          int writtenBytes = trackOutput.sampleData(input, sampleCurrentNalBytesRemaining, false);
           sampleBytesWritten += writtenBytes;
           sampleCurrentNalBytesRemaining -= writtenBytes;
         }
       }
     } else {
       while (sampleBytesWritten < sampleSize) {
-        int writtenBytes = track.trackOutput.sampleData(input, sampleSize - sampleBytesWritten);
+        int writtenBytes = trackOutput.sampleData(input, sampleSize - sampleBytesWritten, false);
         sampleBytesWritten += writtenBytes;
         sampleCurrentNalBytesRemaining -= writtenBytes;
       }
     }
-    track.trackOutput.sampleMetadata(track.sampleTable.timestampsUs[sampleIndex],
+    trackOutput.sampleMetadata(track.sampleTable.timestampsUs[sampleIndex],
         track.sampleTable.flags[sampleIndex], sampleSize, 0, null);
     track.sampleIndex++;
     sampleBytesWritten = 0;
@@ -360,7 +384,8 @@ private static boolean shouldParseLeafAtom(int atom) {
         || atom == Atom.TYPE_avc1 || atom == Atom.TYPE_avcC || atom == Atom.TYPE_mp4a
         || atom == Atom.TYPE_esds || atom == Atom.TYPE_stts || atom == Atom.TYPE_stss
         || atom == Atom.TYPE_ctts || atom == Atom.TYPE_stsc || atom == Atom.TYPE_stsz
-        || atom == Atom.TYPE_stco || atom == Atom.TYPE_co64 || atom == Atom.TYPE_tkhd;
+        || atom == Atom.TYPE_stco || atom == Atom.TYPE_co64 || atom == Atom.TYPE_tkhd
+        || atom == Atom.TYPE_s263;
   }
 
   /** Returns whether the extractor should parse a container atom with type {@code atom}. */
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Sniffer.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Sniffer.java
new file mode 100644
index 0000000000..ece82e5beb
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Sniffer.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.mp4;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.util.ParsableByteArray;
+import com.google.android.exoplayer.util.Util;
+
+import java.io.IOException;
+
+/**
+ * Provides methods that peek data from an {@link ExtractorInput} and return whether the input
+ * appears to be in MP4 format.
+ */
+/* package */ final class Sniffer {
+
+  private static final int[] COMPATIBLE_BRANDS = new int[] {
+      Util.getIntegerCodeForString("isom"),
+      Util.getIntegerCodeForString("iso2"),
+      Util.getIntegerCodeForString("avc1"),
+      Util.getIntegerCodeForString("hvc1"),
+      Util.getIntegerCodeForString("hev1"),
+      Util.getIntegerCodeForString("mp41"),
+      Util.getIntegerCodeForString("mp42"),
+      Util.getIntegerCodeForString("3g2a"),
+      Util.getIntegerCodeForString("3g2b"),
+      Util.getIntegerCodeForString("3gr6"),
+      Util.getIntegerCodeForString("3gs6"),
+      Util.getIntegerCodeForString("3ge6"),
+      Util.getIntegerCodeForString("3gg6"),
+      Util.getIntegerCodeForString("M4V "),
+      Util.getIntegerCodeForString("M4A "),
+      Util.getIntegerCodeForString("f4v "),
+      Util.getIntegerCodeForString("kddi"),
+      Util.getIntegerCodeForString("M4VP"),
+      Util.getIntegerCodeForString("qt  "), // Apple QuickTime
+      Util.getIntegerCodeForString("MSNV"), // Sony PSP
+  };
+
+  /**
+   * Returns whether data peeked from the current position in {@code input} is consistent with the
+   * input being a fragmented MP4 file.
+   *
+   * @param input The extractor input from which to peek data. The peek position will be modified.
+   * @return True if the input appears to be in the fragmented MP4 format. False otherwise.
+   * @throws IOException If an error occurs reading from the input.
+   * @throws InterruptedException If the thread has been interrupted.
+   */
+  public static boolean sniffFragmented(ExtractorInput input)
+      throws IOException, InterruptedException {
+    return sniffInternal(input, 4 * 1024, true);
+  }
+
+  /**
+   * Returns whether data peeked from the current position in {@code input} is consistent with the
+   * input being an unfragmented MP4 file.
+   *
+   * @param input The extractor input from which to peek data. The peek position will be modified.
+   * @return True if the input appears to be in the unfragmented MP4 format. False otherwise.
+   * @throws IOException If an error occurs reading from the input.
+   * @throws InterruptedException If the thread has been interrupted.
+   */
+  public static boolean sniffUnfragmented(ExtractorInput input)
+      throws IOException, InterruptedException {
+    return sniffInternal(input, 128, false);
+  }
+
+  private static boolean sniffInternal(ExtractorInput input, int searchLength, boolean fragmented)
+      throws IOException, InterruptedException {
+    long inputLength = input.getLength();
+    int bytesToSearch = (int) (inputLength == C.LENGTH_UNBOUNDED || inputLength > searchLength
+        ? searchLength : inputLength);
+
+    ParsableByteArray buffer = new ParsableByteArray(64);
+    int bytesSearched = 0;
+    boolean foundGoodFileType = false;
+    boolean foundFragment = false;
+    while (bytesSearched < bytesToSearch) {
+      // Read an atom header.
+      int headerSize = Atom.HEADER_SIZE;
+      input.peekFully(buffer.data, 0, headerSize);
+      buffer.setPosition(0);
+      long atomSize = buffer.readUnsignedInt();
+      int atomType = buffer.readInt();
+      if (atomSize == Atom.LONG_SIZE_PREFIX) {
+        input.peekFully(buffer.data, headerSize, Atom.LONG_HEADER_SIZE - headerSize);
+        headerSize = Atom.LONG_HEADER_SIZE;
+        atomSize = buffer.readLong();
+      }
+      // Check the atom size is large enough to include its header.
+      if (atomSize < headerSize || atomSize > Integer.MAX_VALUE) {
+        return false;
+      }
+      // Stop searching if reading this atom would exceed the search limit.
+      if (bytesSearched + atomSize > bytesToSearch) {
+        break;
+      }
+      int atomDataSize = (int) atomSize - headerSize;
+      if (atomType == Atom.TYPE_ftyp) {
+        if (atomDataSize < 8) {
+          return false;
+        }
+        int compatibleBrandsCount = (atomDataSize - 8) / 4;
+        input.peekFully(buffer.data, 0, 4 * (compatibleBrandsCount + 2));
+        for (int i = 0; i < compatibleBrandsCount + 2; i++) {
+          if (i == 1) {
+            // This index refers to the minorVersion, not a brand, so skip it.
+            continue;
+          }
+          if (isCompatibleBrand(buffer.readInt())) {
+            foundGoodFileType = true;
+            break;
+          }
+        }
+      } else if (atomType == Atom.TYPE_moof) {
+        foundFragment = true;
+        break;
+      } else if (atomDataSize != 0) {
+        input.advancePeekPosition(atomDataSize);
+      }
+      bytesSearched += atomSize;
+    }
+    return foundGoodFileType && fragmented == foundFragment;
+  }
+
+  /**
+   * Returns whether {@code brand} is an ftyp atom brand that is compatible with the MP4 extractors.
+   */
+  private static boolean isCompatibleBrand(int brand) {
+    // Accept all brands starting '3gp'.
+    if (brand >>> 8 == Util.getIntegerCodeForString("3gp")) {
+      return true;
+    }
+    for (int compatibleBrand : COMPATIBLE_BRANDS) {
+      if (compatibleBrand == brand) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private Sniffer() {
+    // Prevent instantiation.
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Track.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Track.java
index c53a9760b2..6cdcd9568f 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Track.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Track.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.util.Util;
 
 /**
  * Encapsulates information describing an MP4 track.
@@ -26,27 +27,19 @@
   /**
    * Type of a video track.
    */
-  public static final int TYPE_VIDEO = 0x76696465;
+  public static final int TYPE_VIDEO = Util.getIntegerCodeForString("vide");
   /**
    * Type of an audio track.
    */
-  public static final int TYPE_AUDIO = 0x736F756E;
+  public static final int TYPE_AUDIO = Util.getIntegerCodeForString("soun");
   /**
    * Type of a text track.
    */
-  public static final int TYPE_TEXT = 0x74657874;
+  public static final int TYPE_TEXT = Util.getIntegerCodeForString("text");
   /**
-   * Type of a hint track.
+   * Type of a subtitle track.
    */
-  public static final int TYPE_HINT = 0x68696E74;
-  /**
-   * Type of a meta track.
-   */
-  public static final int TYPE_META = 0x6D657461;
-  /**
-   * Type of a time-code track.
-   */
-  public static final int TYPE_TIME_CODE = 0x746D6364;
+  public static final int TYPE_SUBTITLE = Util.getIntegerCodeForString("sbtl");
 
   /**
    * The track identifier.
@@ -54,8 +47,7 @@
   public final int id;
 
   /**
-   * One of {@link #TYPE_VIDEO}, {@link #TYPE_AUDIO}, {@link #TYPE_HINT}, {@link #TYPE_META} and
-   * {@link #TYPE_TIME_CODE}.
+   * One of {@link #TYPE_VIDEO}, {@link #TYPE_AUDIO}, {@link #TYPE_TEXT} and {@link #TYPE_SUBTITLE}.
    */
   public final int type;
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsExtractor.java
index 4e3a5b3c46..fd72242216 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsExtractor.java
@@ -21,6 +21,7 @@
 import com.google.android.exoplayer.extractor.PositionHolder;
 import com.google.android.exoplayer.extractor.SeekMap;
 import com.google.android.exoplayer.util.ParsableByteArray;
+import com.google.android.exoplayer.util.Util;
 
 import java.io.IOException;
 
@@ -28,7 +29,7 @@
  * Facilitates the extraction of AAC samples from elementary audio files formatted as AAC with ADTS
  * headers.
  */
-public class AdtsExtractor implements Extractor, SeekMap {
+public final class AdtsExtractor implements Extractor {
 
   private static final int MAX_PACKET_SIZE = 200;
 
@@ -49,11 +50,29 @@ public AdtsExtractor(long firstSampleTimestampUs) {
     firstPacket = true;
   }
 
+  @Override
+  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+    ParsableByteArray scratch = new ParsableByteArray(10);
+    input.peekFully(scratch.data, 0, 10);
+    int value = scratch.readUnsignedInt24();
+    if (value != Util.getIntegerCodeForString("ID3")) {
+      value = value >> 8;
+    } else {
+      int length = (scratch.data[6] & 0x7F) << 21 | ((scratch.data[7] & 0x7F) << 14)
+          | ((scratch.data[8] & 0x7F) << 7) | (scratch.data[9] & 0x7F);
+      input.advancePeekPosition(length);
+      input.peekFully(scratch.data, 0, 2);
+      scratch.setPosition(0);
+      value = scratch.readUnsignedShort();
+    }
+    return (value & 0xFFF6) == 0xFFF0;
+  }
+
   @Override
   public void init(ExtractorOutput output) {
     adtsReader = new AdtsReader(output.track(0));
     output.endTracks();
-    output.seekMap(this);
+    output.seekMap(SeekMap.UNSEEKABLE);
   }
 
   @Override
@@ -81,16 +100,4 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     return RESULT_CONTINUE;
   }
 
-  // SeekMap implementation.
-
-  @Override
-  public boolean isSeekable() {
-    return false;
-  }
-
-  @Override
-  public long getPosition(long timeUs) {
-    return 0;
-  }
-
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
index 8121c54901..5f360d4664 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
@@ -30,7 +30,7 @@
 /**
  * Parses a continuous ADTS byte stream and extracts individual frames.
  */
-/* package */ class AdtsReader extends ElementaryStreamReader {
+/* package */ final class AdtsReader extends ElementaryStreamReader {
 
   private static final int STATE_FINDING_SYNC = 0;
   private static final int STATE_READING_HEADER = 1;
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java
index 776adb5bc9..731254dbde 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java
@@ -32,7 +32,7 @@
 /**
  * Parses a continuous H264 byte stream and extracts individual frames.
  */
-/* package */ class H264Reader extends ElementaryStreamReader {
+/* package */ final class H264Reader extends ElementaryStreamReader {
 
   private static final String TAG = "H264Reader";
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java
index 1631700911..7a2dd8c454 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java
@@ -30,7 +30,7 @@
 /**
  * Parses a continuous H.265 byte stream and extracts individual frames.
  */
-/* package */ class H265Reader extends ElementaryStreamReader {
+/* package */ final class H265Reader extends ElementaryStreamReader {
 
   private static final String TAG = "H265Reader";
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java
index 28c4fe71d1..4e778820a5 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java
@@ -24,7 +24,7 @@
 /**
  * Parses ID3 data and extracts individual text information frames.
  */
-/* package */ class Id3Reader extends ElementaryStreamReader {
+/* package */ final class Id3Reader extends ElementaryStreamReader {
 
   // State that should be reset on seek.
   private boolean writingSample;
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpegAudioReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpegAudioReader.java
index b2ee4ec7a9..5ce86b7d63 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpegAudioReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpegAudioReader.java
@@ -24,7 +24,7 @@
 /**
  * Parses a continuous MPEG Audio byte stream and extracts individual frames.
  */
-/* package */ class MpegAudioReader extends ElementaryStreamReader {
+/* package */ final class MpegAudioReader extends ElementaryStreamReader {
 
   private static final int STATE_FINDING_HEADER = 0;
   private static final int STATE_READING_HEADER = 1;
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/SeiReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/SeiReader.java
index 3aa57557cc..ac1aaef4a2 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/SeiReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/SeiReader.java
@@ -28,7 +28,7 @@
  * TODO: Technically, we shouldn't allow a sample to be read from the queue until we're sure that
  * a sample with an earlier timestamp won't be added to it.
  */
-/* package */ class SeiReader extends ElementaryStreamReader {
+/* package */ final class SeiReader extends ElementaryStreamReader {
 
   public SeiReader(TrackOutput output) {
     super(output);
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
index 9d30be0f0c..2d196d5cb9 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
@@ -34,7 +34,7 @@
 /**
  * Facilitates the extraction of data from the MPEG-2 TS container format.
  */
-public final class TsExtractor implements Extractor, SeekMap {
+public final class TsExtractor implements Extractor {
 
   private static final String TAG = "TsExtractor";
 
@@ -95,10 +95,23 @@ public TsExtractor(long firstSampleTimestampUs, AudioCapabilities audioCapabilit
 
   // Extractor implementation.
 
+  @Override
+  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+    byte[] scratch = new byte[1];
+    for (int i = 0; i < 5; i++) {
+      input.peekFully(scratch, 0, 1);
+      if ((scratch[0] & 0xFF) != 0x47) {
+        return false;
+      }
+      input.advancePeekPosition(TS_PACKET_SIZE - 1);
+    }
+    return true;
+  }
+
   @Override
   public void init(ExtractorOutput output) {
     this.output = output;
-    output.seekMap(this);
+    output.seekMap(SeekMap.UNSEEKABLE);
   }
 
   @Override
@@ -153,18 +166,6 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     return RESULT_CONTINUE;
   }
 
-  // SeekMap implementation.
-
-  @Override
-  public boolean isSeekable() {
-    return false;
-  }
-
-  @Override
-  public long getPosition(long timeUs) {
-    return 0;
-  }
-
   // Internals.
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/webm/Sniffer.java b/library/src/main/java/com/google/android/exoplayer/extractor/webm/Sniffer.java
new file mode 100644
index 0000000000..b0fddff7fb
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/webm/Sniffer.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.webm;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.io.IOException;
+
+/**
+ * Utility class that peeks from the input stream in order to determine whether it appears to be
+ * compatible input for this extractor.
+ */
+/* package */ final class Sniffer {
+
+  /**
+   * The number of bytes to search for a valid header in {@link #sniff(ExtractorInput)}.
+   */
+  private static final int SEARCH_LENGTH = 1024;
+  private static final int ID_EBML = 0x1A45DFA3;
+
+  private final ParsableByteArray scratch;
+  private int peekLength;
+
+  public Sniffer() {
+    scratch = new ParsableByteArray(8);
+  }
+
+  /**
+   * @see Extractor#sniff
+   */
+  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+    long inputLength = input.getLength();
+    int bytesToSearch = (int) (inputLength == C.LENGTH_UNBOUNDED || inputLength > SEARCH_LENGTH
+        ? SEARCH_LENGTH : inputLength);
+    // Find four bytes equal to ID_EBML near the start of the input.
+    input.peekFully(scratch.data, 0, 4);
+    long tag = scratch.readUnsignedInt();
+    peekLength = 4;
+    while (tag != ID_EBML) {
+      if (++peekLength == bytesToSearch) {
+        return false;
+      }
+      input.peekFully(scratch.data, 0, 1);
+      tag = (tag << 8) & 0xFFFFFF00;
+      tag |= scratch.data[0] & 0xFF;
+    }
+
+    // Read the size of the EBML header and make sure it is within the stream.
+    long headerSize = readUint(input);
+    long headerStart = peekLength;
+    if (headerSize == Long.MIN_VALUE
+        || (inputLength != C.LENGTH_UNBOUNDED && headerStart + headerSize >= inputLength)) {
+      return false;
+    }
+
+    // Read the payload elements in the EBML header.
+    while (peekLength < headerStart + headerSize) {
+      long id = readUint(input);
+      if (id == Long.MIN_VALUE) {
+        return false;
+      }
+      long size = readUint(input);
+      if (size < 0 || size > Integer.MAX_VALUE) {
+        return false;
+      }
+      if (size != 0) {
+        input.advancePeekPosition((int) size);
+        peekLength += size;
+      }
+    }
+    return peekLength == headerStart + headerSize;
+  }
+
+  /**
+   * Peeks a variable-length unsigned EBML integer from the input.
+   */
+  private long readUint(ExtractorInput input) throws IOException, InterruptedException {
+    input.peekFully(scratch.data, 0, 1);
+    int value = scratch.data[0] & 0xFF;
+    if (value == 0) {
+      return Long.MIN_VALUE;
+    }
+    int mask = 0x80;
+    int length = 0;
+    while ((value & mask) == 0) {
+      mask >>= 1;
+      length++;
+    }
+    value &= ~mask;
+    input.peekFully(scratch.data, 1, length);
+    for (int i = 0; i < length; i++) {
+      value <<= 8;
+      value += scratch.data[i + 1] & 0xFF;
+    }
+    peekLength += length + 1;
+    return value;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/webm/VarintReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/webm/VarintReader.java
index 07973732e8..03cdb2debb 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/webm/VarintReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/webm/VarintReader.java
@@ -8,7 +8,7 @@
 /**
  * Reads EBML variable-length integers (varints) from an {@link ExtractorInput}.
  */
-/* package */ class VarintReader {
+/* package */ final class VarintReader {
 
   private static final int STATE_BEGIN_READING = 0;
   private static final int STATE_READ_CONTENTS = 1;
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
index 9623e676ea..29687aefe3 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
@@ -24,12 +24,14 @@
 import com.google.android.exoplayer.extractor.ExtractorInput;
 import com.google.android.exoplayer.extractor.ExtractorOutput;
 import com.google.android.exoplayer.extractor.PositionHolder;
+import com.google.android.exoplayer.extractor.SeekMap;
 import com.google.android.exoplayer.extractor.TrackOutput;
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.LongArray;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.NalUnitUtil;
 import com.google.android.exoplayer.util.ParsableByteArray;
+import com.google.android.exoplayer.util.Util;
 
 import android.util.Pair;
 
@@ -39,7 +41,6 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
-import java.util.concurrent.TimeUnit;
 
 /**
  * An extractor to facilitate data retrieval from the WebM container format.
@@ -64,7 +65,11 @@
   private static final String DOC_TYPE_MATROSKA = "matroska";
   private static final String CODEC_ID_VP8 = "V_VP8";
   private static final String CODEC_ID_VP9 = "V_VP9";
+  private static final String CODEC_ID_MPEG4_SP = "V_MPEG4/ISO/SP";
+  private static final String CODEC_ID_MPEG4_ASP = "V_MPEG4/ISO/ASP";
+  private static final String CODEC_ID_MPEG4_AP = "V_MPEG4/ISO/AP";
   private static final String CODEC_ID_H264 = "V_MPEG4/ISO/AVC";
+  private static final String CODEC_ID_H265 = "V_MPEGH/ISO/HEVC";
   private static final String CODEC_ID_VORBIS = "A_VORBIS";
   private static final String CODEC_ID_OPUS = "A_OPUS";
   private static final String CODEC_ID_AAC = "A_AAC";
@@ -83,6 +88,7 @@
   private static final int ID_DOC_TYPE = 0x4282;
   private static final int ID_DOC_TYPE_READ_VERSION = 0x4285;
   private static final int ID_SEGMENT = 0x18538067;
+  private static final int ID_SEGMENT_INFO = 0x1549A966;
   private static final int ID_SEEK_HEAD = 0x114D9B74;
   private static final int ID_SEEK = 0x4DBB;
   private static final int ID_SEEK_ID = 0x53AB;
@@ -147,7 +153,8 @@
 
   private long segmentContentPosition = UNKNOWN;
   private long segmentContentSize = UNKNOWN;
-  private long timecodeScale = 1000000L;
+  private long timecodeScale = C.UNKNOWN_TIME_US;
+  private long durationTimecode = C.UNKNOWN_TIME_US;
   private long durationUs = C.UNKNOWN_TIME_US;
 
   private TrackFormat trackFormat;  // Used to store the last seen track.
@@ -208,6 +215,11 @@ public WebmExtractor() {
     sampleStrippedBytes = new ParsableByteArray();
   }
 
+  @Override
+  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+    return new Sniffer().sniff(input);
+  }
+
   @Override
   public void init(ExtractorOutput output) {
     extractorOutput = output;
@@ -320,10 +332,17 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
         seenClusterPositionForCurrentCuePoint = false;
         return;
       case ID_CLUSTER:
-        // If we encounter a Cluster before building Cues, then we should try to build cues first
-        // before parsing the Cluster.
-        if (cuesState == CUES_STATE_NOT_BUILT && cuesContentPosition != UNKNOWN) {
-          seekForCues = true;
+        if (cuesState == CUES_STATE_NOT_BUILT) {
+          // We need to build cues before parsing the cluster.
+          if (cuesContentPosition != UNKNOWN) {
+            // We know where the Cues element is located. Seek to request it.
+            seekForCues = true;
+          } else {
+            // We don't know where the Cues element is located. It's most likely omitted. Allow
+            // playback, but disable seeking.
+            extractorOutput.seekMap(SeekMap.UNSEEKABLE);
+            cuesState = CUES_STATE_BUILT;
+          }
         }
         return;
       case ID_BLOCK_GROUP:
@@ -345,6 +364,15 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
 
   /* package */ void endMasterElement(int id) throws ParserException {
     switch (id) {
+      case ID_SEGMENT_INFO:
+        if (timecodeScale == C.UNKNOWN_TIME_US) {
+          // timecodeScale was omitted. Use the default value.
+          timecodeScale = 1000000;
+        }
+        if (durationTimecode != C.UNKNOWN_TIME_US) {
+          durationUs = scaleTimecodeToUs(durationTimecode);
+        }
+        return;
       case ID_SEEK:
         if (seekEntryId == UNKNOWN || seekEntryPosition == UNKNOWN) {
           throw new ParserException("Mandatory element SeekID or SeekPosition not found");
@@ -355,7 +383,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
         return;
       case ID_CUES:
         if (cuesState != CUES_STATE_BUILT) {
-          extractorOutput.seekMap(buildCues());
+          extractorOutput.seekMap(buildSeekMap());
           cuesState = CUES_STATE_BUILT;
         } else {
           // We have already built the cues. Ignore.
@@ -528,7 +556,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
   /* package */ void floatElement(int id, double value) {
     switch (id) {
       case ID_DURATION:
-        durationUs = scaleTimecodeToUs((long) value);
+        durationTimecode = (long) value;
         return;
       case ID_SAMPLING_FREQUENCY:
         trackFormat.sampleRate = (int) value;
@@ -781,7 +809,7 @@ private void writeSampleData(ExtractorInput input, TrackOutput output, TrackForm
     }
     size += sampleStrippedBytes.limit();
 
-    if (CODEC_ID_H264.equals(format.codecId)) {
+    if (CODEC_ID_H264.equals(format.codecId) || CODEC_ID_H265.equals(format.codecId)) {
       // TODO: Deduplicate with Mp4Extractor.
 
       // Zero the top three bytes of the array that we'll use to parse nal unit lengths, in case
@@ -857,7 +885,7 @@ private int readToOutput(ExtractorInput input, TrackOutput output, int length)
       bytesRead = Math.min(length, strippedBytesLeft);
       output.sampleData(sampleStrippedBytes, bytesRead);
     } else {
-      bytesRead = output.sampleData(input, length);
+      bytesRead = output.sampleData(input, length, false);
     }
     sampleBytesRead += bytesRead;
     sampleBytesWritten += bytesRead;
@@ -865,19 +893,19 @@ private int readToOutput(ExtractorInput input, TrackOutput output, int length)
   }
 
   /**
-   * Builds a {@link ChunkIndex} containing recently gathered Cues information.
+   * Builds a {@link SeekMap} from the recently gathered Cues information.
    *
-   * @return The built {@link ChunkIndex}.
-   * @throws ParserException If the index could not be built.
+   * @return The built {@link SeekMap}. May be {@link SeekMap#UNSEEKABLE} if cues information was
+   *     missing or incomplete.
    */
-  private ChunkIndex buildCues() throws ParserException {
-    if (segmentContentPosition == UNKNOWN) {
-      throw new ParserException("Segment start/end offsets unknown");
-    } else if (durationUs == C.UNKNOWN_TIME_US) {
-      throw new ParserException("Duration unknown");
-    } else if (cueTimesUs == null || cueClusterPositions == null
-        || cueTimesUs.size() == 0 || cueTimesUs.size() != cueClusterPositions.size()) {
-      throw new ParserException("Invalid/missing cue points");
+  private SeekMap buildSeekMap() {
+    if (segmentContentPosition == UNKNOWN || durationUs == C.UNKNOWN_TIME_US
+        || cueTimesUs == null || cueTimesUs.size() == 0
+        || cueClusterPositions == null || cueClusterPositions.size() != cueTimesUs.size()) {
+      // Cues information is missing or incomplete.
+      cueTimesUs = null;
+      cueClusterPositions = null;
+      return SeekMap.UNSEEKABLE;
     }
     int cuePointsSize = cueTimesUs.size();
     int[] sizes = new int[cuePointsSize];
@@ -927,14 +955,21 @@ private boolean maybeSeekForCues(PositionHolder seekPosition, long currentPositi
     return false;
   }
 
-  private long scaleTimecodeToUs(long unscaledTimecode) {
-    return TimeUnit.NANOSECONDS.toMicros(unscaledTimecode * timecodeScale);
+  private long scaleTimecodeToUs(long unscaledTimecode) throws ParserException {
+    if (timecodeScale == C.UNKNOWN_TIME_US) {
+      throw new ParserException("Can't scale timecode prior to timecodeScale being set.");
+    }
+    return Util.scaleLargeTimestamp(unscaledTimecode, timecodeScale, 1000);
   }
 
   private static boolean isCodecSupported(String codecId) {
     return CODEC_ID_VP8.equals(codecId)
         || CODEC_ID_VP9.equals(codecId)
+        || CODEC_ID_MPEG4_SP.equals(codecId)
+        || CODEC_ID_MPEG4_ASP.equals(codecId)
+        || CODEC_ID_MPEG4_AP.equals(codecId)
         || CODEC_ID_H264.equals(codecId)
+        || CODEC_ID_H265.equals(codecId)
         || CODEC_ID_OPUS.equals(codecId)
         || CODEC_ID_VORBIS.equals(codecId)
         || CODEC_ID_AAC.equals(codecId)
@@ -984,7 +1019,7 @@ public void integerElement(int id, long value) throws ParserException {
     }
 
     @Override
-    public void floatElement(int id, double value) {
+    public void floatElement(int id, double value) throws ParserException {
       WebmExtractor.this.floatElement(id, value);
     }
 
@@ -1038,13 +1073,27 @@ public MediaFormat getMediaFormat(long durationUs) throws ParserException {
         case CODEC_ID_VP9:
           mimeType = MimeTypes.VIDEO_VP9;
           break;
+        case CODEC_ID_MPEG4_SP:
+        case CODEC_ID_MPEG4_ASP:
+        case CODEC_ID_MPEG4_AP:
+          mimeType = MimeTypes.VIDEO_MP4V;
+          initializationData =
+              codecPrivate == null ? null : Collections.singletonList(codecPrivate);
+          break;
         case CODEC_ID_H264:
           mimeType = MimeTypes.VIDEO_H264;
-          Pair<List<byte[]>, Integer> h264Data = parseH264CodecPrivate(
+          Pair<List<byte[]>, Integer> h264Data = parseAvcCodecPrivate(
               new ParsableByteArray(codecPrivate));
           initializationData = h264Data.first;
           nalUnitLengthFieldLength = h264Data.second;
           break;
+        case CODEC_ID_H265:
+          mimeType = MimeTypes.VIDEO_H265;
+          Pair<List<byte[]>, Integer> hevcData = parseHevcCodecPrivate(
+              new ParsableByteArray(codecPrivate));
+          initializationData = hevcData.first;
+          nalUnitLengthFieldLength = hevcData.second;
+          break;
         case CODEC_ID_VORBIS:
           mimeType = MimeTypes.AUDIO_VORBIS;
           maxInputSize = VORBIS_MAX_INPUT_SIZE;
@@ -1085,12 +1134,12 @@ public MediaFormat getMediaFormat(long durationUs) throws ParserException {
     }
 
     /**
-     * Builds initialization data for a {@link MediaFormat} from H.264 codec private data.
+     * Builds initialization data for a {@link MediaFormat} from H.264 (AVC) codec private data.
      *
      * @return The initialization data for the {@link MediaFormat}.
      * @throws ParserException If the initialization data could not be built.
      */
-    private static Pair<List<byte[]>, Integer> parseH264CodecPrivate(ParsableByteArray buffer)
+    private static Pair<List<byte[]>, Integer> parseAvcCodecPrivate(ParsableByteArray buffer)
         throws ParserException {
       try {
         // TODO: Deduplicate with AtomParsers.parseAvcCFromParent.
@@ -1108,7 +1157,60 @@ public MediaFormat getMediaFormat(long durationUs) throws ParserException {
         }
         return Pair.create(initializationData, nalUnitLengthFieldLength);
       } catch (ArrayIndexOutOfBoundsException e) {
-        throw new ParserException("Error parsing vorbis codec private");
+        throw new ParserException("Error parsing AVC codec private");
+      }
+    }
+
+    /**
+     * Builds initialization data for a {@link MediaFormat} from H.265 (HEVC) codec private data.
+     *
+     * @return The initialization data for the {@link MediaFormat}.
+     * @throws ParserException If the initialization data could not be built.
+     */
+    private static Pair<List<byte[]>, Integer> parseHevcCodecPrivate(ParsableByteArray parent)
+        throws ParserException {
+      try {
+        // TODO: Deduplicate with AtomParsers.parseHvcCFromParent.
+        parent.setPosition(21);
+        int lengthSizeMinusOne = parent.readUnsignedByte() & 0x03;
+
+        // Calculate the combined size of all VPS/SPS/PPS bitstreams.
+        int numberOfArrays = parent.readUnsignedByte();
+        int csdLength = 0;
+        int csdStartPosition = parent.getPosition();
+        for (int i = 0; i < numberOfArrays; i++) {
+          parent.skipBytes(1); // completeness (1), nal_unit_type (7)
+          int numberOfNalUnits = parent.readUnsignedShort();
+          for (int j = 0; j < numberOfNalUnits; j++) {
+            int nalUnitLength = parent.readUnsignedShort();
+            csdLength += 4 + nalUnitLength; // Start code and NAL unit.
+            parent.skipBytes(nalUnitLength);
+          }
+        }
+
+        // Concatenate the codec-specific data into a single buffer.
+        parent.setPosition(csdStartPosition);
+        byte[] buffer = new byte[csdLength];
+        int bufferPosition = 0;
+        for (int i = 0; i < numberOfArrays; i++) {
+          parent.skipBytes(1); // completeness (1), nal_unit_type (7)
+          int numberOfNalUnits = parent.readUnsignedShort();
+          for (int j = 0; j < numberOfNalUnits; j++) {
+            int nalUnitLength = parent.readUnsignedShort();
+            System.arraycopy(NalUnitUtil.NAL_START_CODE, 0, buffer, bufferPosition,
+                NalUnitUtil.NAL_START_CODE.length);
+            bufferPosition += NalUnitUtil.NAL_START_CODE.length;
+            System.arraycopy(parent.data, parent.getPosition(), buffer, bufferPosition,
+                nalUnitLength);
+            bufferPosition += nalUnitLength;
+            parent.skipBytes(nalUnitLength);
+          }
+        }
+
+        List<byte[]> initializationData = csdLength == 0 ? null : Collections.singletonList(buffer);
+        return Pair.create(initializationData, lengthSizeMinusOne + 1);
+      } catch (ArrayIndexOutOfBoundsException e) {
+        throw new ParserException("Error parsing HEVC codec private");
       }
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/Aes128DataSource.java b/library/src/main/java/com/google/android/exoplayer/hls/Aes128DataSource.java
similarity index 81%
rename from library/src/main/java/com/google/android/exoplayer/upstream/Aes128DataSource.java
rename to library/src/main/java/com/google/android/exoplayer/hls/Aes128DataSource.java
index 2115e5b0bc..3406eba658 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/Aes128DataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/Aes128DataSource.java
@@ -13,9 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer.upstream;
+package com.google.android.exoplayer.hls;
 
 import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.upstream.DataSource;
+import com.google.android.exoplayer.upstream.DataSourceInputStream;
+import com.google.android.exoplayer.upstream.DataSpec;
 import com.google.android.exoplayer.util.Assertions;
 
 import java.io.IOException;
@@ -32,10 +35,14 @@
 import javax.crypto.spec.SecretKeySpec;
 
 /**
- * A {@link DataSource} that decrypts the data read from an upstream source, encrypted with AES-128
- * with a 128-bit key and PKCS7 padding.
+ * A {@link DataSource} that decrypts data read from an upstream source, encrypted with AES-128 with
+ * a 128-bit key and PKCS7 padding.
+ * <p>
+ * Note that this {@link DataSource} does not support being opened from arbitrary offsets. It is
+ * designed specifically for reading whole files as defined in an HLS media playlist. For this
+ * reason the implementation is private to the HLS package.
  */
-public class Aes128DataSource implements DataSource {
+/* package */ final class Aes128DataSource implements DataSource {
 
   private final DataSource upstream;
   private final byte[] encryptionKey;
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java
index 78b9d06648..789217bbcc 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java
@@ -74,7 +74,7 @@
   private static final Pattern RESOLUTION_ATTR_REGEX =
       Pattern.compile(RESOLUTION_ATTR + "=(\\d+x\\d+)");
   private static final Pattern MEDIA_DURATION_REGEX =
-      Pattern.compile(MEDIA_DURATION_TAG + ":([\\d.]+),");
+      Pattern.compile(MEDIA_DURATION_TAG + ":([\\d.]+)\\b");
   private static final Pattern MEDIA_SEQUENCE_REGEX =
       Pattern.compile(MEDIA_SEQUENCE_TAG + ":(\\d+)\\b");
   private static final Pattern TARGET_DURATION_REGEX =
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java b/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
index b3a2dbdc34..30eb9bb0a1 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/HlsSampleSource.java
@@ -40,7 +40,7 @@
 /**
  * A {@link SampleSource} for HLS streams.
  */
-public class HlsSampleSource implements SampleSource, SampleSourceReader, Loader.Callback {
+public final class HlsSampleSource implements SampleSource, SampleSourceReader, Loader.Callback {
 
   /**
    * Interface definition for a callback to be notified of {@link HlsSampleSource} events.
@@ -56,7 +56,6 @@
 
   private final HlsChunkSource chunkSource;
   private final LinkedList<HlsExtractorWrapper> extractors;
-  private final boolean frameAccurateSeeking;
   private final int minLoadableRetryCount;
   private final int bufferSizeContribution;
 
@@ -92,24 +91,23 @@
   private long currentLoadStartTimeMs;
 
   public HlsSampleSource(HlsChunkSource chunkSource, LoadControl loadControl,
-      int bufferSizeContribution, boolean frameAccurateSeeking) {
-    this(chunkSource, loadControl, bufferSizeContribution, frameAccurateSeeking, null, null, 0);
+      int bufferSizeContribution) {
+    this(chunkSource, loadControl, bufferSizeContribution, null, null, 0);
   }
 
   public HlsSampleSource(HlsChunkSource chunkSource, LoadControl loadControl,
-      int bufferSizeContribution, boolean frameAccurateSeeking, Handler eventHandler,
-      EventListener eventListener, int eventSourceId) {
-    this(chunkSource, loadControl, bufferSizeContribution, frameAccurateSeeking, eventHandler,
-        eventListener, eventSourceId, DEFAULT_MIN_LOADABLE_RETRY_COUNT);
+      int bufferSizeContribution, Handler eventHandler, EventListener eventListener,
+      int eventSourceId) {
+    this(chunkSource, loadControl, bufferSizeContribution, eventHandler, eventListener,
+        eventSourceId, DEFAULT_MIN_LOADABLE_RETRY_COUNT);
   }
 
   public HlsSampleSource(HlsChunkSource chunkSource, LoadControl loadControl,
-      int bufferSizeContribution, boolean frameAccurateSeeking, Handler eventHandler,
-      EventListener eventListener, int eventSourceId, int minLoadableRetryCount) {
+      int bufferSizeContribution, Handler eventHandler, EventListener eventListener,
+      int eventSourceId, int minLoadableRetryCount) {
     this.chunkSource = chunkSource;
     this.loadControl = loadControl;
     this.bufferSizeContribution = bufferSizeContribution;
-    this.frameAccurateSeeking = frameAccurateSeeking;
     this.minLoadableRetryCount = minLoadableRetryCount;
     this.eventHandler = eventHandler;
     this.eventListener = eventListener;
@@ -125,7 +123,7 @@ public SampleSourceReader register() {
   }
 
   @Override
-  public boolean prepare(long positionUs) throws IOException {
+  public boolean prepare(long positionUs) {
     if (prepared) {
       return true;
     }
@@ -162,7 +160,6 @@ public boolean prepare(long positionUs) throws IOException {
       downstreamPositionUs = positionUs;
     }
     maybeStartLoading();
-    maybeThrowLoadableException();
     return false;
   }
 
@@ -218,7 +215,7 @@ public void disable(int track) {
   }
 
   @Override
-  public boolean continueBuffering(int track, long playbackPositionUs) throws IOException {
+  public boolean continueBuffering(int track, long playbackPositionUs) {
     Assertions.checkState(prepared);
     Assertions.checkState(trackEnabledStates[track]);
     downstreamPositionUs = playbackPositionUs;
@@ -232,7 +229,6 @@ public boolean continueBuffering(int track, long playbackPositionUs) throws IOEx
     if (isPendingReset() || extractors.isEmpty()) {
       return false;
     }
-
     for (int extractorIndex = 0; extractorIndex < extractors.size(); extractorIndex++) {
       HlsExtractorWrapper extractor = extractors.get(extractorIndex);
       if (!extractor.isPrepared()) {
@@ -242,13 +238,12 @@ public boolean continueBuffering(int track, long playbackPositionUs) throws IOEx
         return true;
       }
     }
-    maybeThrowLoadableException();
     return false;
   }
 
   @Override
   public int readData(int track, long playbackPositionUs, MediaFormatHolder formatHolder,
-      SampleHolder sampleHolder, boolean onlyReadDiscontinuity) throws IOException {
+      SampleHolder sampleHolder, boolean onlyReadDiscontinuity) {
     Assertions.checkState(prepared);
     downstreamPositionUs = playbackPositionUs;
 
@@ -262,13 +257,11 @@ public int readData(int track, long playbackPositionUs, MediaFormatHolder format
     }
 
     if (isPendingReset()) {
-      maybeThrowLoadableException();
       return NOTHING_READ;
     }
 
     HlsExtractorWrapper extractor = getCurrentExtractor();
     if (!extractor.isPrepared()) {
-      maybeThrowLoadableException();
       return NOTHING_READ;
     }
 
@@ -290,7 +283,6 @@ public int readData(int track, long playbackPositionUs, MediaFormatHolder format
       // next one for the current read.
       extractor = extractors.get(++extractorIndex);
       if (!extractor.isPrepared()) {
-        maybeThrowLoadableException();
         return NOTHING_READ;
       }
     }
@@ -304,7 +296,7 @@ public int readData(int track, long playbackPositionUs, MediaFormatHolder format
     }
 
     if (extractor.getSample(track, sampleHolder)) {
-      boolean decodeOnly = frameAccurateSeeking && sampleHolder.timeUs < lastSeekPositionUs;
+      boolean decodeOnly = sampleHolder.timeUs < lastSeekPositionUs;
       sampleHolder.flags |= decodeOnly ? C.SAMPLE_FLAG_DECODE_ONLY : 0;
       return SAMPLE_READ;
     }
@@ -313,10 +305,16 @@ public int readData(int track, long playbackPositionUs, MediaFormatHolder format
       return END_OF_STREAM;
     }
 
-    maybeThrowLoadableException();
     return NOTHING_READ;
   }
 
+  @Override
+  public void maybeThrowError() throws IOException {
+    if (currentLoadableException != null && currentLoadableExceptionCount > minLoadableRetryCount) {
+      throw currentLoadableException;
+    }
+  }
+
   @Override
   public void seekToUs(long positionUs) {
     Assertions.checkState(prepared);
@@ -361,6 +359,8 @@ public void release() {
     }
   }
 
+  // Loader.Callback implementation.
+
   @Override
   public void onLoadCompleted(Loadable loadable) {
     Assertions.checkState(loadable == currentLoadable);
@@ -412,6 +412,8 @@ public void onLoadError(Loadable loadable, IOException e) {
     maybeStartLoading();
   }
 
+  // Internal stuff.
+
   /**
    * Gets the current extractor from which samples should be read.
    * <p>
@@ -455,12 +457,6 @@ private boolean haveSamplesForEnabledTracks(HlsExtractorWrapper extractor) {
     return false;
   }
 
-  private void maybeThrowLoadableException() throws IOException {
-    if (currentLoadableException != null && currentLoadableExceptionCount > minLoadableRetryCount) {
-      throw currentLoadableException;
-    }
-  }
-
   private void restartFrom(long positionUs) {
     pendingResetPositionUs = positionUs;
     loadingFinished = false;
@@ -496,7 +492,7 @@ private void maybeStartLoading() {
 
     // Update the control with our current state, and determine whether we're the next loader.
     boolean nextLoader = loadControl.update(this, downstreamPositionUs, nextLoadPositionUs,
-        loadingOrBackedOff, false);
+        loadingOrBackedOff);
 
     if (isBackedOff) {
       long elapsedMillis = now - currentLoadableExceptionTimestamp;
@@ -565,7 +561,7 @@ private long getRetryDelayMillis(long errorCount) {
     return Math.min((errorCount - 1) * 1000, 5000);
   }
 
-  protected final int usToMs(long timeUs) {
+  /* package */ int usToMs(long timeUs) {
     return (int) (timeUs / 1000);
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/hls/TsChunk.java b/library/src/main/java/com/google/android/exoplayer/hls/TsChunk.java
index f46f094097..56968c5fe7 100644
--- a/library/src/main/java/com/google/android/exoplayer/hls/TsChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer/hls/TsChunk.java
@@ -20,7 +20,6 @@
 import com.google.android.exoplayer.extractor.DefaultExtractorInput;
 import com.google.android.exoplayer.extractor.Extractor;
 import com.google.android.exoplayer.extractor.ExtractorInput;
-import com.google.android.exoplayer.upstream.Aes128DataSource;
 import com.google.android.exoplayer.upstream.DataSource;
 import com.google.android.exoplayer.upstream.DataSpec;
 import com.google.android.exoplayer.util.Util;
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/GeobMetadata.java b/library/src/main/java/com/google/android/exoplayer/metadata/GeobMetadata.java
index 1d4fcb4dee..6cc61dd468 100644
--- a/library/src/main/java/com/google/android/exoplayer/metadata/GeobMetadata.java
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/GeobMetadata.java
@@ -19,7 +19,7 @@
  * A metadata that contains parsed ID3 GEOB (General Encapsulated Object) frame data associated
  * with time indices.
  */
-public class GeobMetadata {
+public final class GeobMetadata {
 
   public static final String TYPE = "GEOB";
 
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/Id3Parser.java b/library/src/main/java/com/google/android/exoplayer/metadata/Id3Parser.java
index f306c5d6e8..6b52cb5371 100644
--- a/library/src/main/java/com/google/android/exoplayer/metadata/Id3Parser.java
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/Id3Parser.java
@@ -28,7 +28,7 @@
 /**
  * Extracts individual TXXX text frames from raw ID3 data.
  */
-public class Id3Parser implements MetadataParser<Map<String, Object>> {
+public final class Id3Parser implements MetadataParser<Map<String, Object>> {
 
   private static final int ID3_TEXT_ENCODING_ISO_8859_1 = 0;
   private static final int ID3_TEXT_ENCODING_UTF_16 = 1;
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/MetadataTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/metadata/MetadataTrackRenderer.java
index 6376f88a61..767214482f 100644
--- a/library/src/main/java/com/google/android/exoplayer/metadata/MetadataTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/MetadataTrackRenderer.java
@@ -35,7 +35,7 @@
  *
  * @param <T> The type of the metadata.
  */
-public class MetadataTrackRenderer<T> extends TrackRenderer implements Callback {
+public final class MetadataTrackRenderer<T> extends TrackRenderer implements Callback {
 
   /**
    * An interface for components that process metadata.
@@ -90,16 +90,13 @@ public MetadataTrackRenderer(SampleSource source, MetadataParser<T> metadataPars
   }
 
   @Override
-  protected int doPrepare(long positionUs) throws ExoPlaybackException {
-    try {
-      boolean sourcePrepared = source.prepare(positionUs);
-      if (!sourcePrepared) {
-        return TrackRenderer.STATE_UNPREPARED;
-      }
-    } catch (IOException e) {
-      throw new ExoPlaybackException(e);
+  protected int doPrepare(long positionUs) {
+    boolean sourcePrepared = source.prepare(positionUs);
+    if (!sourcePrepared) {
+      return TrackRenderer.STATE_UNPREPARED;
     }
-    for (int i = 0; i < source.getTrackCount(); i++) {
+    int trackCount = source.getTrackCount();
+    for (int i = 0; i < trackCount; i++) {
       if (metadataParser.canParse(source.getTrackInfo(i).mimeType)) {
         trackIndex = i;
         return TrackRenderer.STATE_PREPARED;
@@ -128,29 +125,21 @@ private void seekToInternal() {
   @Override
   protected void doSomeWork(long positionUs, long elapsedRealtimeUs)
       throws ExoPlaybackException {
-    try {
-      source.continueBuffering(trackIndex, positionUs);
-    } catch (IOException e) {
-      // TODO: This should be propagated, but in the current design propagation may occur too
-      // early. See [Internal b/22291244].
-      // throw new ExoPlaybackException(e);
-    }
+    source.continueBuffering(trackIndex, positionUs);
 
     if (!inputStreamEnded && pendingMetadata == null) {
-      try {
         int result = source.readData(trackIndex, positionUs, formatHolder, sampleHolder, false);
         if (result == SampleSource.SAMPLE_READ) {
           pendingMetadataTimestamp = sampleHolder.timeUs;
-          pendingMetadata = metadataParser.parse(sampleHolder.data.array(), sampleHolder.size);
+          try {
+            pendingMetadata = metadataParser.parse(sampleHolder.data.array(), sampleHolder.size);
+          } catch (IOException e) {
+            throw new ExoPlaybackException(e);
+          }
           sampleHolder.data.clear();
         } else if (result == SampleSource.END_OF_STREAM) {
           inputStreamEnded = true;
         }
-      } catch (IOException e) {
-        // TODO: This should be propagated, but in the current design propagation may occur too
-        // early. See [Internal b/22291244].
-        // throw new ExoPlaybackException(e);
-      }
     }
 
     if (pendingMetadata != null && pendingMetadataTimestamp <= positionUs) {
@@ -159,6 +148,15 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs)
     }
   }
 
+  @Override
+  protected void maybeThrowError() throws ExoPlaybackException {
+    try {
+      source.maybeThrowError();
+    } catch (IOException e) {
+      throw new ExoPlaybackException(e);
+    }
+  }
+
   @Override
   protected void onDisabled() {
     pendingMetadata = null;
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/PrivMetadata.java b/library/src/main/java/com/google/android/exoplayer/metadata/PrivMetadata.java
index 8573b25906..94ba6e52cc 100644
--- a/library/src/main/java/com/google/android/exoplayer/metadata/PrivMetadata.java
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/PrivMetadata.java
@@ -19,7 +19,7 @@
  * A metadata that contains parsed ID3 PRIV (Private) frame data associated
  * with time indices.
  */
-public class PrivMetadata {
+public final class PrivMetadata {
 
   public static final String TYPE = "PRIV";
 
diff --git a/library/src/main/java/com/google/android/exoplayer/metadata/TxxxMetadata.java b/library/src/main/java/com/google/android/exoplayer/metadata/TxxxMetadata.java
index c455bb825d..c0f1d2c5b3 100644
--- a/library/src/main/java/com/google/android/exoplayer/metadata/TxxxMetadata.java
+++ b/library/src/main/java/com/google/android/exoplayer/metadata/TxxxMetadata.java
@@ -19,7 +19,7 @@
  * A metadata that contains parsed ID3 TXXX (User defined text information) frame data associated
  * with time indices.
  */
-public class TxxxMetadata {
+public final class TxxxMetadata {
 
   public static final String TYPE = "TXXX";
 
diff --git a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingChunkSource.java b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingChunkSource.java
index 91121c59fd..9849b3d323 100644
--- a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingChunkSource.java
@@ -239,7 +239,7 @@ public void continueBuffering(long playbackPositionUs) {
     }
 
     if (finishedCurrentManifest && (SystemClock.elapsedRealtime()
-        > manifestFetcher.getManifestLoadTimestamp() + MINIMUM_MANIFEST_REFRESH_PERIOD_MS)) {
+        > manifestFetcher.getManifestLoadStartTimestamp() + MINIMUM_MANIFEST_REFRESH_PERIOD_MS)) {
       manifestFetcher.requestRefresh();
     }
   }
@@ -324,9 +324,12 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long seekP
   }
 
   @Override
-  public IOException getError() {
-    return fatalError != null ? fatalError
-        : (manifestFetcher != null ? manifestFetcher.getError() : null);
+  public void maybeThrowError() throws IOException {
+    if (fatalError != null) {
+      throw fatalError;
+    } else {
+      manifestFetcher.maybeThrowError();
+    }
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/text/CuePainter.java b/library/src/main/java/com/google/android/exoplayer/text/CuePainter.java
index b88711f333..bbeee94f51 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/CuePainter.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/CuePainter.java
@@ -136,7 +136,7 @@ public CuePainter(Context context) {
   public void draw(Cue cue, CaptionStyleCompat style, float fontScale, Canvas canvas,
       int cueBoxLeft, int cueBoxTop, int cueBoxRight, int cueBoxBottom) {
     if (TextUtils.isEmpty(cue.text)) {
-      // Nothing to draw;
+      // Nothing to draw.
       return;
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/text/SubtitleParserHelper.java b/library/src/main/java/com/google/android/exoplayer/text/SubtitleParserHelper.java
index 69872bf385..835f66aa51 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/SubtitleParserHelper.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/SubtitleParserHelper.java
@@ -31,7 +31,7 @@
  * Wraps a {@link SubtitleParser}, exposing an interface similar to {@link MediaCodec} for
  * asynchronous parsing of subtitles.
  */
-public class SubtitleParserHelper implements Handler.Callback {
+public final class SubtitleParserHelper implements Handler.Callback {
 
   private final SubtitleParser parser;
 
diff --git a/library/src/main/java/com/google/android/exoplayer/text/TextTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/text/TextTrackRenderer.java
index ef0195d6e3..dd9b7bd28f 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/TextTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/TextTrackRenderer.java
@@ -31,18 +31,77 @@
 import android.os.Message;
 
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
 /**
- * A {@link TrackRenderer} for textual subtitles. The actual rendering of each line of text to a
- * suitable output (e.g. the display) is delegated to a {@link TextRenderer}.
+ * A {@link TrackRenderer} for subtitles. Text is parsed from sample data using a
+ * {@link SubtitleParser}. The actual rendering of each line of text is delegated to a
+ * {@link TextRenderer}.
+ * <p>
+ * If no {@link SubtitleParser} instances are passed to the constructor, the subtitle type will be
+ * detected automatically for the following supported formats:
+ *
+ * <ul>
+ * <li>WebVTT ({@link com.google.android.exoplayer.text.webvtt.WebvttParser})</li>
+ * <li>TTML
+ * ({@link com.google.android.exoplayer.text.ttml.TtmlParser})</li>
+ * <li>SubRip
+ * ({@link com.google.android.exoplayer.text.subrip.SubripParser})</li>
+ * <li>TX3G
+ * ({@link com.google.android.exoplayer.text.tx3g.Tx3gParser})</li>
+ * </ul>
+ *
+ * <p>To override the default parsers, pass one or more {@link SubtitleParser} instances to the
+ * constructor. The first {@link SubtitleParser} that returns {@code true} from
+ * {@link SubtitleParser#canParse(String)} will be used.
  */
 @TargetApi(16)
-public class TextTrackRenderer extends TrackRenderer implements Callback {
+public final class TextTrackRenderer extends TrackRenderer implements Callback {
 
   private static final int MSG_UPDATE_OVERLAY = 0;
 
+  /**
+   * Default parser classes in priority order. They are referred to indirectly so that it is
+   * possible to remove unused parsers.
+   */
+  private static final List<Class<? extends SubtitleParser>> DEFAULT_PARSER_CLASSES;
+  static {
+    DEFAULT_PARSER_CLASSES = new ArrayList<>();
+    // Load parsers using reflection so that they can be deleted cleanly.
+    // Class.forName(<class name>) appears for each parser so that automated tools like proguard
+    // can detect the use of reflection (see http://proguard.sourceforge.net/FAQ.html#forname).
+    try {
+      DEFAULT_PARSER_CLASSES.add(
+          Class.forName("com.google.android.exoplayer.text.webvtt.WebvttParser")
+              .asSubclass(SubtitleParser.class));
+    } catch (ClassNotFoundException e) {
+      // Parser not found.
+    }
+    try {
+      DEFAULT_PARSER_CLASSES.add(
+          Class.forName("com.google.android.exoplayer.text.ttml.TtmlParser")
+              .asSubclass(SubtitleParser.class));
+    } catch (ClassNotFoundException e) {
+      // Parser not found.
+    }
+    try {
+      DEFAULT_PARSER_CLASSES.add(
+          Class.forName("com.google.android.exoplayer.text.subrip.SubripParser")
+              .asSubclass(SubtitleParser.class));
+    } catch (ClassNotFoundException e) {
+      // Parser not found.
+    }
+    try {
+      DEFAULT_PARSER_CLASSES.add(
+          Class.forName("com.google.android.exoplayer.text.tx3g.Tx3gParser")
+              .asSubclass(SubtitleParser.class));
+    } catch (ClassNotFoundException e) {
+      // Parser not found.
+    }
+  }
+
   private final Handler textRendererHandler;
   private final TextRenderer textRenderer;
   private final SampleSourceReader source;
@@ -68,8 +127,8 @@
    *     normally be the looper associated with the applications' main thread, which can be
    *     obtained using {@link android.app.Activity#getMainLooper()}. Null may be passed if the
    *     renderer should be invoked directly on the player's internal rendering thread.
-   * @param subtitleParsers An array of available subtitle parsers. Where multiple parsers are able
-   *     to render a subtitle, the one with the lowest index will be preferred.
+   * @param subtitleParsers {@link SubtitleParser}s to parse text samples, in order of decreasing
+   *     priority. If omitted, the default parsers will be used.
    */
   public TextTrackRenderer(SampleSource source, TextRenderer textRenderer,
       Looper textRendererLooper, SubtitleParser... subtitleParsers) {
@@ -77,22 +136,31 @@ public TextTrackRenderer(SampleSource source, TextRenderer textRenderer,
     this.textRenderer = Assertions.checkNotNull(textRenderer);
     this.textRendererHandler = textRendererLooper == null ? null
         : new Handler(textRendererLooper, this);
-    this.subtitleParsers = Assertions.checkNotNull(subtitleParsers);
+    if (subtitleParsers == null || subtitleParsers.length == 0) {
+      subtitleParsers = new SubtitleParser[DEFAULT_PARSER_CLASSES.size()];
+      for (int i = 0; i < subtitleParsers.length; i++) {
+        try {
+          subtitleParsers[i] = DEFAULT_PARSER_CLASSES.get(i).newInstance();
+        } catch (InstantiationException e) {
+          throw new IllegalStateException("Unexpected error creating default parser", e);
+        } catch (IllegalAccessException e) {
+          throw new IllegalStateException("Unexpected error creating default parser", e);
+        }
+      }
+    }
+    this.subtitleParsers = subtitleParsers;
     formatHolder = new MediaFormatHolder();
   }
 
   @Override
-  protected int doPrepare(long positionUs) throws ExoPlaybackException {
-    try {
-      boolean sourcePrepared = source.prepare(positionUs);
-      if (!sourcePrepared) {
-        return TrackRenderer.STATE_UNPREPARED;
-      }
-    } catch (IOException e) {
-      throw new ExoPlaybackException(e);
+  protected int doPrepare(long positionUs) {
+    boolean sourcePrepared = source.prepare(positionUs);
+    if (!sourcePrepared) {
+      return TrackRenderer.STATE_UNPREPARED;
     }
+    int trackCount = source.getTrackCount();
     for (int i = 0; i < subtitleParsers.length; i++) {
-      for (int j = 0; j < source.getTrackCount(); j++) {
+      for (int j = 0; j < trackCount; j++) {
         if (subtitleParsers[i].canParse(source.getTrackInfo(j).mimeType)) {
           parserIndex = i;
           trackIndex = j;
@@ -128,11 +196,7 @@ private void seekToInternal() {
 
   @Override
   protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
-    try {
-      source.continueBuffering(trackIndex, positionUs);
-    } catch (IOException e) {
-      throw new ExoPlaybackException(e);
-    }
+    source.continueBuffering(trackIndex, positionUs);
 
     if (nextSubtitle == null) {
       try {
@@ -142,6 +206,10 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPla
       }
     }
 
+    if (getState() != TrackRenderer.STATE_STARTED) {
+      return;
+    }
+
     boolean textRendererNeedsUpdate = false;
     long subtitleNextEventTimeUs = Long.MAX_VALUE;
     if (subtitle != null) {
@@ -164,24 +232,20 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPla
       textRendererNeedsUpdate = true;
     }
 
-    if (textRendererNeedsUpdate && getState() == TrackRenderer.STATE_STARTED) {
+    if (textRendererNeedsUpdate) {
       // textRendererNeedsUpdate is set and we're playing. Update the renderer.
       updateTextRenderer(subtitle.getCues(positionUs));
     }
 
     if (!inputStreamEnded && nextSubtitle == null && !parserHelper.isParsing()) {
       // Try and read the next subtitle from the source.
-      try {
-        SampleHolder sampleHolder = parserHelper.getSampleHolder();
-        sampleHolder.clearData();
-        int result = source.readData(trackIndex, positionUs, formatHolder, sampleHolder, false);
-        if (result == SampleSource.SAMPLE_READ) {
-          parserHelper.startParseOperation();
-        } else if (result == SampleSource.END_OF_STREAM) {
-          inputStreamEnded = true;
-        }
-      } catch (IOException e) {
-        throw new ExoPlaybackException(e);
+      SampleHolder sampleHolder = parserHelper.getSampleHolder();
+      sampleHolder.clearData();
+      int result = source.readData(trackIndex, positionUs, formatHolder, sampleHolder, false);
+      if (result == SampleSource.SAMPLE_READ) {
+        parserHelper.startParseOperation();
+      } else if (result == SampleSource.END_OF_STREAM) {
+        inputStreamEnded = true;
       }
     }
   }
@@ -202,6 +266,15 @@ protected void onReleased() {
     source.release();
   }
 
+  @Override
+  protected void maybeThrowError() throws ExoPlaybackException {
+    try {
+      source.maybeThrowError();
+    } catch (IOException e) {
+      throw new ExoPlaybackException(e);
+    }
+  }
+
   @Override
   protected long getDurationUs() {
     return source.getTrackInfo(trackIndex).durationUs;
diff --git a/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608Parser.java b/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608Parser.java
index 9fdf41ba08..e47d1dc29f 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608Parser.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608Parser.java
@@ -26,7 +26,7 @@
  * Facilitates the extraction and parsing of EIA-608 (a.k.a. "line 21 captions" and "CEA-608")
  * Closed Captions from the SEI data block from H.264.
  */
-public class Eia608Parser {
+public final class Eia608Parser {
 
   private static final int PAYLOAD_TYPE_CC = 4;
   private static final int COUNTRY_CODE = 0xB5;
diff --git a/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608TrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608TrackRenderer.java
index 45bf83694c..ffb9faddbb 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608TrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/eia608/Eia608TrackRenderer.java
@@ -39,7 +39,7 @@
 /**
  * A {@link TrackRenderer} for EIA-608 closed captions in a media stream.
  */
-public class Eia608TrackRenderer extends TrackRenderer implements Callback {
+public final class Eia608TrackRenderer extends TrackRenderer implements Callback {
 
   private static final int MSG_INVOKE_RENDERER = 0;
 
@@ -92,16 +92,13 @@ public Eia608TrackRenderer(SampleSource source, TextRenderer textRenderer,
   }
 
   @Override
-  protected int doPrepare(long positionUs) throws ExoPlaybackException {
-    try {
-      boolean sourcePrepared = source.prepare(positionUs);
-      if (!sourcePrepared) {
-        return TrackRenderer.STATE_UNPREPARED;
-      }
-    } catch (IOException e) {
-      throw new ExoPlaybackException(e);
+  protected int doPrepare(long positionUs) {
+    boolean sourcePrepared = source.prepare(positionUs);
+    if (!sourcePrepared) {
+      return TrackRenderer.STATE_UNPREPARED;
     }
-    for (int i = 0; i < source.getTrackCount(); i++) {
+    int trackCount = source.getTrackCount();
+    for (int i = 0; i < trackCount; i++) {
       if (eia608Parser.canParse(source.getTrackInfo(i).mimeType)) {
         trackIndex = i;
         return TrackRenderer.STATE_PREPARED;
@@ -133,13 +130,7 @@ private void seekToInternal() {
 
   @Override
   protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
-    try {
-      source.continueBuffering(trackIndex, positionUs);
-    } catch (IOException e) {
-      // TODO: This should be propagated, but in the current design propagation may occur too
-      // early. See [Internal b/22291244].
-      // throw new ExoPlaybackException(e);
-    }
+    source.continueBuffering(trackIndex, positionUs);
 
     if (isSamplePending()) {
       maybeParsePendingSample(positionUs);
@@ -147,17 +138,11 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs) throws ExoPla
 
     int result = inputStreamEnded ? SampleSource.END_OF_STREAM : SampleSource.SAMPLE_READ;
     while (!isSamplePending() && result == SampleSource.SAMPLE_READ) {
-      try {
-        result = source.readData(trackIndex, positionUs, formatHolder, sampleHolder, false);
-        if (result == SampleSource.SAMPLE_READ) {
-          maybeParsePendingSample(positionUs);
-        } else if (result == SampleSource.END_OF_STREAM) {
-          inputStreamEnded = true;
-        }
-      } catch (IOException e) {
-        // TODO: This should be propagated, but in the current design propagation may occur too
-        // early. See [Internal b/22291244].
-        // throw new ExoPlaybackException(e);
+      result = source.readData(trackIndex, positionUs, formatHolder, sampleHolder, false);
+      if (result == SampleSource.SAMPLE_READ) {
+        maybeParsePendingSample(positionUs);
+      } else if (result == SampleSource.END_OF_STREAM) {
+        inputStreamEnded = true;
       }
     }
 
@@ -181,6 +166,15 @@ protected void onDisabled() {
     source.disable(trackIndex);
   }
 
+  @Override
+  protected void maybeThrowError() throws ExoPlaybackException {
+    try {
+      source.maybeThrowError();
+    } catch (IOException e) {
+      throw new ExoPlaybackException(e);
+    }
+  }
+
   @Override
   protected long getDurationUs() {
     return source.getTrackInfo(trackIndex).durationUs;
diff --git a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java
index d93f99fea0..22bc7e1975 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlParser.java
@@ -54,7 +54,7 @@
  * </p>
  * @see <a href="http://www.w3.org/TR/ttaf1-dfxp/">TTML specification</a>
  */
-public class TtmlParser implements SubtitleParser {
+public final class TtmlParser implements SubtitleParser {
 
   private static final String TAG = "TtmlParser";
 
diff --git a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParser.java b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParser.java
index 0503eb2299..bebf643e82 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParser.java
@@ -91,7 +91,7 @@ public WebvttParser(boolean strictParsing) {
   }
 
   @Override
-  public WebvttSubtitle parse(InputStream inputStream, String inputEncoding, long startTimeUs)
+  public final WebvttSubtitle parse(InputStream inputStream, String inputEncoding, long startTimeUs)
       throws IOException {
     ArrayList<WebvttCue> subtitles = new ArrayList<>();
     long mediaTimestampUs = startTimeUs;
@@ -253,7 +253,7 @@ public WebvttSubtitle parse(InputStream inputStream, String inputEncoding, long
   }
 
   @Override
-  public boolean canParse(String mimeType) {
+  public final boolean canParse(String mimeType) {
     return MimeTypes.TEXT_VTT.equals(mimeType);
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttSubtitle.java b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttSubtitle.java
index 3ca64cdc21..3cc7ba6362 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttSubtitle.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttSubtitle.java
@@ -30,7 +30,7 @@
 /**
  * A representation of a WebVTT subtitle.
  */
-public class WebvttSubtitle implements Subtitle {
+public final class WebvttSubtitle implements Subtitle {
 
   private final List<WebvttCue> cues;
   private final int numCues;
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/AssetDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/AssetDataSource.java
index 84642df5a0..254a7574eb 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/AssetDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/AssetDataSource.java
@@ -16,7 +16,6 @@
 package com.google.android.exoplayer.upstream;
 
 import com.google.android.exoplayer.C;
-import com.google.android.exoplayer.util.Assertions;
 
 import android.content.Context;
 import android.content.res.AssetManager;
@@ -79,12 +78,22 @@ public long open(DataSpec dataSpec) throws AssetDataSourceException {
       uriString = dataSpec.uri.toString();
       inputStream = assetManager.open(path, AssetManager.ACCESS_RANDOM);
       long skipped = inputStream.skip(dataSpec.position);
-      Assertions.checkState(skipped == dataSpec.position);
-      bytesRemaining = dataSpec.length == C.LENGTH_UNBOUNDED ? inputStream.available()
-          : dataSpec.length;
-      if (bytesRemaining < 0) {
+      if (skipped < dataSpec.position) {
+        // assetManager.open() returns an AssetInputStream, whose skip() implementation only skips
+        // fewer bytes than requested if the skip is beyond the end of the asset's data.
         throw new EOFException();
       }
+      if (dataSpec.length != C.LENGTH_UNBOUNDED) {
+        bytesRemaining = dataSpec.length;
+      } else {
+        bytesRemaining = inputStream.available();
+        if (bytesRemaining == Integer.MAX_VALUE) {
+          // assetManager.open() returns an AssetInputStream, whose available() implementation
+          // returns Integer.MAX_VALUE if the remaining length is greater than (or equal to)
+          // Integer.MAX_VALUE. We don't know the true length in this case, so treat as unbounded.
+          bytesRemaining = C.LENGTH_UNBOUNDED;
+        }
+      }
     } catch (IOException e) {
       throw new AssetDataSourceException(e);
     }
@@ -103,13 +112,17 @@ public int read(byte[] buffer, int offset, int readLength) throws AssetDataSourc
     } else {
       int bytesRead = 0;
       try {
-        bytesRead = inputStream.read(buffer, offset, (int) Math.min(bytesRemaining, readLength));
+        int bytesToRead = bytesRemaining == C.LENGTH_UNBOUNDED ? readLength
+            : (int) Math.min(bytesRemaining, readLength);
+        bytesRead = inputStream.read(buffer, offset, bytesToRead);
       } catch (IOException e) {
         throw new AssetDataSourceException(e);
       }
 
       if (bytesRead > 0) {
-        bytesRemaining -= bytesRead;
+        if (bytesRemaining != C.LENGTH_UNBOUNDED) {
+          bytesRemaining -= bytesRead;
+        }
         if (listener != null) {
           listener.onBytesTransferred(bytesRead);
         }
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/ByteArrayDataSink.java b/library/src/main/java/com/google/android/exoplayer/upstream/ByteArrayDataSink.java
index d672dd95d7..aaa8a1c186 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/ByteArrayDataSink.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/ByteArrayDataSink.java
@@ -24,7 +24,7 @@
 /**
  * A {@link DataSink} for writing to a byte array.
  */
-public class ByteArrayDataSink implements DataSink {
+public final class ByteArrayDataSink implements DataSink {
 
   private ByteArrayOutputStream stream;
 
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/ByteArrayDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/ByteArrayDataSource.java
index 0438f87371..e16b3a7ccc 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/ByteArrayDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/ByteArrayDataSource.java
@@ -23,7 +23,7 @@
 /**
  * A {@link DataSource} for reading from a byte array.
  */
-public class ByteArrayDataSource implements DataSource {
+public final class ByteArrayDataSource implements DataSource {
 
   private final byte[] data;
   private int readPosition;
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/ContentDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/ContentDataSource.java
index 6102bc2b2c..8158312f24 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/ContentDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/ContentDataSource.java
@@ -16,7 +16,6 @@
 package com.google.android.exoplayer.upstream;
 
 import com.google.android.exoplayer.C;
-import com.google.android.exoplayer.util.Assertions;
 
 import android.content.ContentResolver;
 import android.content.Context;
@@ -75,12 +74,22 @@ public long open(DataSpec dataSpec) throws ContentDataSourceException {
       AssetFileDescriptor assetFd = resolver.openAssetFileDescriptor(dataSpec.uri, "r");
       inputStream = new FileInputStream(assetFd.getFileDescriptor());
       long skipped = inputStream.skip(dataSpec.position);
-      Assertions.checkState(skipped == dataSpec.position);
-      bytesRemaining = dataSpec.length == C.LENGTH_UNBOUNDED ? inputStream.available()
-          : dataSpec.length;
-      if (bytesRemaining < 0) {
+      if (skipped < dataSpec.position) {
+        // We expect the skip to be satisfied in full. If it isn't then we're probably trying to
+        // skip beyond the end of the data.
         throw new EOFException();
       }
+      if (dataSpec.length != C.LENGTH_UNBOUNDED) {
+        bytesRemaining = dataSpec.length;
+      } else {
+        bytesRemaining = inputStream.available();
+        if (bytesRemaining == 0) {
+          // FileInputStream.available() returns 0 if the remaining length cannot be determined, or
+          // if it's greater than Integer.MAX_VALUE. We don't know the true length in either case,
+          // so treat as unbounded.
+          bytesRemaining = C.LENGTH_UNBOUNDED;
+        }
+      }
     } catch (IOException e) {
       throw new ContentDataSourceException(e);
     }
@@ -100,13 +109,17 @@ public int read(byte[] buffer, int offset, int readLength) throws ContentDataSou
     } else {
       int bytesRead = 0;
       try {
-        bytesRead = inputStream.read(buffer, offset, (int) Math.min(bytesRemaining, readLength));
+        int bytesToRead = bytesRemaining == C.LENGTH_UNBOUNDED ? readLength
+            : (int) Math.min(bytesRemaining, readLength);
+        bytesRead = inputStream.read(buffer, offset, bytesToRead);
       } catch (IOException e) {
         throw new ContentDataSourceException(e);
       }
 
       if (bytesRead > 0) {
-        bytesRemaining -= bytesRead;
+        if (bytesRemaining != C.LENGTH_UNBOUNDED) {
+          bytesRemaining -= bytesRead;
+        }
         if (listener != null) {
           listener.onBytesTransferred(bytesRead);
         }
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/DataSourceInputStream.java b/library/src/main/java/com/google/android/exoplayer/upstream/DataSourceInputStream.java
index 75bcf72b88..ff3d0b7b8e 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/DataSourceInputStream.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/DataSourceInputStream.java
@@ -24,7 +24,7 @@
  * Allows data corresponding to a given {@link DataSpec} to be read from a {@link DataSource} and
  * consumed as an {@link InputStream}.
  */
-public class DataSourceInputStream extends InputStream {
+public final class DataSourceInputStream extends InputStream {
 
   private final DataSource dataSource;
   private final DataSpec dataSpec;
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/DataSpec.java b/library/src/main/java/com/google/android/exoplayer/upstream/DataSpec.java
index 072ba82294..618605c2c8 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/DataSpec.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/DataSpec.java
@@ -20,6 +20,8 @@
 
 import android.net.Uri;
 
+import java.util.Arrays;
+
 /**
  * Defines a region of media data.
  */
@@ -42,6 +44,10 @@
    * Identifies the source from which data should be read.
    */
   public final Uri uri;
+  /**
+   * Body for a POST request, null otherwise.
+   */
+  public final byte[] postBody;
   /**
    * The absolute position of the data in the full stream.
    */
@@ -124,10 +130,28 @@ public DataSpec(Uri uri, long absoluteStreamPosition, long length, String key, i
    */
   public DataSpec(Uri uri, long absoluteStreamPosition, long position, long length, String key,
       int flags) {
+    this(uri, null, absoluteStreamPosition, position, length, key, flags);
+  }
+
+  /**
+   * Construct a {@link DataSpec} where {@link #position} may differ from
+   * {@link #absoluteStreamPosition}.
+   *
+   * @param uri {@link #uri}.
+   * @param postBody {@link #postBody}.
+   * @param absoluteStreamPosition {@link #absoluteStreamPosition}.
+   * @param position {@link #position}.
+   * @param length {@link #length}.
+   * @param key {@link #key}.
+   * @param flags {@link #flags}.
+   */
+  public DataSpec(Uri uri, byte[] postBody, long absoluteStreamPosition, long position, long length,
+      String key, int flags) {
     Assertions.checkArgument(absoluteStreamPosition >= 0);
     Assertions.checkArgument(position >= 0);
     Assertions.checkArgument(length > 0 || length == C.LENGTH_UNBOUNDED);
     this.uri = uri;
+    this.postBody = postBody;
     this.absoluteStreamPosition = absoluteStreamPosition;
     this.position = position;
     this.length = length;
@@ -137,8 +161,8 @@ public DataSpec(Uri uri, long absoluteStreamPosition, long position, long length
 
   @Override
   public String toString() {
-    return "DataSpec[" + uri + ", " + absoluteStreamPosition + ", " + position + ", " + length
-        + ", " + key + ", " + flags + "]";
+    return "DataSpec[" + uri + ", " + Arrays.toString(postBody) + ", " + absoluteStreamPosition
+        + ", "  + position + ", " + length + ", " + key + ", " + flags + "]";
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultBandwidthMeter.java b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultBandwidthMeter.java
index 8af7bf9250..ba2297341b 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultBandwidthMeter.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultBandwidthMeter.java
@@ -26,7 +26,7 @@
  * Counts transferred bytes while transfers are open and creates a bandwidth sample and updated
  * bandwidth estimate each time a transfer ends.
  */
-public class DefaultBandwidthMeter implements BandwidthMeter {
+public final class DefaultBandwidthMeter implements BandwidthMeter {
 
   public static final int DEFAULT_MAX_WEIGHT = 2000;
 
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultHttpDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultHttpDataSource.java
index f06e280288..2c70748e28 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultHttpDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultHttpDataSource.java
@@ -27,6 +27,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InterruptedIOException;
+import java.io.OutputStream;
 import java.net.HttpURLConnection;
 import java.net.NoRouteToHostException;
 import java.net.ProtocolException;
@@ -270,15 +271,15 @@ public void close() throws HttpDataSourceException {
         } catch (IOException e) {
           throw new HttpDataSourceException(e, dataSpec);
         }
-        inputStream = null;
       }
     } finally {
+      inputStream = null;
+      closeConnection();
       if (opened) {
         opened = false;
         if (listener != null) {
           listener.onTransferEnd();
         }
-        closeConnection();
       }
     }
   }
@@ -329,6 +330,7 @@ protected final long bytesRemaining() {
    */
   private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
     URL url = new URL(dataSpec.uri.toString());
+    byte[] postBody = dataSpec.postBody;
     long position = dataSpec.position;
     long length = dataSpec.length;
     boolean allowGzip = (dataSpec.flags & DataSpec.FLAG_ALLOW_GZIP) != 0;
@@ -336,24 +338,27 @@ private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
     if (!allowCrossProtocolRedirects) {
       // HttpURLConnection disallows cross-protocol redirects, but otherwise performs redirection
       // automatically. This is the behavior we want, so use it.
-      HttpURLConnection connection = configureConnection(url, position, length, allowGzip);
-      connection.connect();
+      HttpURLConnection connection = makeConnection(
+          url, postBody, position, length, allowGzip, true /* followRedirects */);
       return connection;
     }
 
     // We need to handle redirects ourselves to allow cross-protocol redirects.
     int redirectCount = 0;
     while (redirectCount++ <= MAX_REDIRECTS) {
-      HttpURLConnection connection = configureConnection(url, position, length, allowGzip);
-      connection.setInstanceFollowRedirects(false);
-      connection.connect();
+      HttpURLConnection connection = makeConnection(
+          url, postBody, position, length, allowGzip, false /* followRedirects */);
       int responseCode = connection.getResponseCode();
       if (responseCode == HttpURLConnection.HTTP_MULT_CHOICE
           || responseCode == HttpURLConnection.HTTP_MOVED_PERM
           || responseCode == HttpURLConnection.HTTP_MOVED_TEMP
           || responseCode == HttpURLConnection.HTTP_SEE_OTHER
-          || responseCode == 307 /* HTTP_TEMP_REDIRECT */
-          || responseCode == 308 /* HTTP_PERM_REDIRECT */) {
+          || (postBody == null
+              && (responseCode == 307 /* HTTP_TEMP_REDIRECT */
+                  || responseCode == 308 /* HTTP_PERM_REDIRECT */))) {
+        // For 300, 301, 302, and 303 POST requests follow the redirect and are transformed into
+        // GET requests. For 307 and 308 POST requests are not redirected.
+        postBody = null;
         String location = connection.getHeaderField("Location");
         connection.disconnect();
         url = handleRedirect(url, location);
@@ -367,19 +372,20 @@ private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
   }
 
   /**
-   * Configures a connection, but does not open it.
+   * Configures a connection and opens it.
    *
    * @param url The url to connect to.
+   * @param postBody The body data for a POST request.
    * @param position The byte offset of the requested data.
    * @param length The length of the requested data, or {@link C#LENGTH_UNBOUNDED}.
    * @param allowGzip Whether to allow the use of gzip.
+   * @param followRedirects Whether to follow redirects.
    */
-  private HttpURLConnection configureConnection(URL url, long position, long length,
-      boolean allowGzip) throws IOException {
+  private HttpURLConnection makeConnection(URL url, byte[] postBody, long position,
+      long length, boolean allowGzip, boolean followRedirects) throws IOException {
     HttpURLConnection connection = (HttpURLConnection) url.openConnection();
     connection.setConnectTimeout(connectTimeoutMillis);
     connection.setReadTimeout(readTimeoutMillis);
-    connection.setDoOutput(false);
     synchronized (requestProperties) {
       for (Map.Entry<String, String> property : requestProperties.entrySet()) {
         connection.setRequestProperty(property.getKey(), property.getValue());
@@ -396,6 +402,17 @@ private HttpURLConnection configureConnection(URL url, long position, long lengt
     if (!allowGzip) {
       connection.setRequestProperty("Accept-Encoding", "identity");
     }
+    connection.setInstanceFollowRedirects(followRedirects);
+    connection.setDoOutput(postBody != null);
+    if (postBody != null) {
+      connection.setFixedLengthStreamingMode(postBody.length);
+      connection.connect();
+      OutputStream os = connection.getOutputStream();
+      os.write(postBody);
+      os.close();
+    } else {
+      connection.connect();
+    }
     return connection;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/PriorityDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/PriorityDataSource.java
index 34ed14794c..19a2b224de 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/PriorityDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/PriorityDataSource.java
@@ -24,7 +24,7 @@
  * priority is the highest priority of any task. {@link NetworkLock.PriorityTooLowException} is
  * thrown when this condition does not hold.
  */
-public class PriorityDataSource implements DataSource {
+public final class PriorityDataSource implements DataSource {
 
   private final DataSource upstream;
   private final int priority;
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/UdpDataSource.java b/library/src/main/java/com/google/android/exoplayer/upstream/UdpDataSource.java
new file mode 100644
index 0000000000..c9a41e3aa3
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/UdpDataSource.java
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.upstream;
+
+import com.google.android.exoplayer.C;
+
+import java.io.IOException;
+import java.net.DatagramPacket;
+import java.net.DatagramSocket;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.MulticastSocket;
+
+/**
+ * A UDP {@link DataSource}.
+ */
+public final class UdpDataSource implements UriDataSource {
+
+  /**
+   * Thrown when an error is encountered when trying to read from a {@link UdpDataSource}.
+   */
+  public static final class UdpDataSourceException extends IOException {
+
+    public UdpDataSourceException(String message) {
+      super(message);
+    }
+
+    public UdpDataSourceException(IOException cause) {
+      super(cause);
+    }
+
+  }
+
+  /**
+   * The default maximum datagram packet size, in bytes.
+   */
+  public static final int DEFAULT_MAX_PACKET_SIZE = 2000;
+
+  private final TransferListener listener;
+  private final DatagramPacket packet;
+
+  private DataSpec dataSpec;
+  private DatagramSocket socket;
+  private MulticastSocket multicastSocket;
+  private InetAddress address;
+  private InetSocketAddress socketAddress;
+  private boolean opened;
+
+  private byte[] packetBuffer;
+  private int packetRemaining;
+
+  /**
+   * @param listener An optional listener.
+   */
+  public UdpDataSource(TransferListener listener) {
+    this(listener, DEFAULT_MAX_PACKET_SIZE);
+  }
+
+  /**
+   * @param listener An optional listener.
+   * @param maxPacketSize The maximum datagram packet size, in bytes.
+   */
+  public UdpDataSource(TransferListener listener, int maxPacketSize) {
+    this.listener = listener;
+    packetBuffer = new byte[maxPacketSize];
+    packet = new DatagramPacket(packetBuffer, 0, maxPacketSize);
+  }
+
+  @Override
+  public long open(DataSpec dataSpec) throws UdpDataSourceException {
+    this.dataSpec = dataSpec;
+    String uri = dataSpec.uri.toString();
+    String host = uri.substring(0, uri.indexOf(':'));
+    int port = Integer.parseInt(uri.substring(uri.indexOf(':') + 1));
+
+    try {
+      address = InetAddress.getByName(host);
+      socketAddress = new InetSocketAddress(address, port);
+      if (address.isMulticastAddress()) {
+        multicastSocket = new MulticastSocket(socketAddress);
+        multicastSocket.joinGroup(address);
+        socket = multicastSocket;
+      } else {
+        socket = new DatagramSocket(socketAddress);
+      }
+    } catch (IOException e) {
+      throw new UdpDataSourceException(e);
+    }
+
+    opened = true;
+    if (listener != null) {
+      listener.onTransferStart();
+    }
+    return C.LENGTH_UNBOUNDED;
+  }
+
+  @Override
+  public int read(byte[] buffer, int offset, int readLength) throws UdpDataSourceException {
+    if (packetRemaining == 0) {
+      // We've read all of the data from the current packet. Get another.
+      try {
+        socket.receive(packet);
+      } catch (IOException e) {
+        throw new UdpDataSourceException(e);
+      }
+
+      packetRemaining = packet.getLength();
+      if (listener != null) {
+        listener.onBytesTransferred(packetRemaining);
+      }
+    }
+
+    int packetOffset = packet.getLength() - packetRemaining;
+    int bytesToRead = Math.min(packetRemaining, readLength);
+    System.arraycopy(packetBuffer, packetOffset, buffer, offset, bytesToRead);
+    packetRemaining -= bytesToRead;
+    return bytesToRead;
+  }
+
+  @Override
+  public void close() {
+    if (multicastSocket != null) {
+      try {
+        multicastSocket.leaveGroup(address);
+      } catch (IOException e) {
+        // Do nothing.
+      }
+      multicastSocket = null;
+    }
+    if (socket != null) {
+      socket.close();
+      socket = null;
+    }
+    address = null;
+    socketAddress = null;
+    packetRemaining = 0;
+    if (opened) {
+      opened = false;
+      if (listener != null) {
+        listener.onTransferEnd();
+      }
+    }
+  }
+
+  @Override
+  public String getUri() {
+    return dataSpec == null ? null : dataSpec.uri.toString();
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSink.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSink.java
index 01e06b5158..5ed4efcf2e 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSink.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CacheDataSink.java
@@ -29,7 +29,7 @@
 /**
  * Writes data into a cache.
  */
-public class CacheDataSink implements DataSink {
+public final class CacheDataSink implements DataSink {
 
   private final Cache cache;
   private final long maxCacheFileSize;
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/LeastRecentlyUsedCacheEvictor.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/LeastRecentlyUsedCacheEvictor.java
index 577d7b3bbf..4998f09fc2 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/LeastRecentlyUsedCacheEvictor.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/LeastRecentlyUsedCacheEvictor.java
@@ -21,7 +21,7 @@
 /**
  * Evicts least recently used cache files first.
  */
-public class LeastRecentlyUsedCacheEvictor implements CacheEvictor, Comparator<CacheSpan> {
+public final class LeastRecentlyUsedCacheEvictor implements CacheEvictor, Comparator<CacheSpan> {
 
   private final long maxBytes;
   private final TreeSet<CacheSpan> leastRecentlyUsed;
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/NoOpCacheEvictor.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/NoOpCacheEvictor.java
index ea050c28dd..56e4e33400 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/NoOpCacheEvictor.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/NoOpCacheEvictor.java
@@ -22,7 +22,7 @@
  * Warning: Using this evictor might have unforeseeable consequences if cache
  * size is not managed elsewhere.
  */
-public class NoOpCacheEvictor implements CacheEvictor {
+public final class NoOpCacheEvictor implements CacheEvictor {
 
   @Override
   public void onStartFile(Cache cache, String key, long position, long length) {
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCache.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCache.java
index ed2001b371..649e555dc3 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCache.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/SimpleCache.java
@@ -32,7 +32,7 @@
 /**
  * A {@link Cache} implementation that maintains an in-memory representation.
  */
-public class SimpleCache implements Cache {
+public final class SimpleCache implements Cache {
 
   private final File cacheDir;
   private final CacheEvictor evictor;
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ManifestFetcher.java b/library/src/main/java/com/google/android/exoplayer/util/ManifestFetcher.java
index 267d8ff6ae..d50b5be27f 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/ManifestFetcher.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/ManifestFetcher.java
@@ -108,13 +108,15 @@
   private int enabledCount;
   private Loader loader;
   private UriLoadable<T> currentLoadable;
+  private long currentLoadStartTimestamp;
 
   private int loadExceptionCount;
   private long loadExceptionTimestamp;
   private IOException loadException;
 
   private volatile T manifest;
-  private volatile long manifestLoadTimestamp;
+  private volatile long manifestLoadStartTimestamp;
+  private volatile long manifestLoadCompleteTimestamp;
 
   /**
    * @param manifestUri The manifest location.
@@ -176,27 +178,37 @@ public T getManifest() {
     return manifest;
   }
 
+  /**
+   * Gets the value of {@link SystemClock#elapsedRealtime()} when the last completed load started.
+   *
+   * @return The value of {@link SystemClock#elapsedRealtime()} when the last completed load
+   *     started.
+   */
+  public long getManifestLoadStartTimestamp() {
+    return manifestLoadStartTimestamp;
+  }
+
   /**
    * Gets the value of {@link SystemClock#elapsedRealtime()} when the last load completed.
    *
    * @return The value of {@link SystemClock#elapsedRealtime()} when the last load completed.
    */
-  public long getManifestLoadTimestamp() {
-    return manifestLoadTimestamp;
+  public long getManifestLoadCompleteTimestamp() {
+    return manifestLoadCompleteTimestamp;
   }
 
   /**
-   * Gets the error that affected the most recent attempt to load the manifest, or null if the
-   * most recent attempt was successful.
+   * Throws the error that affected the most recent attempt to load the manifest. Does nothing if
+   * the most recent attempt was successful.
    *
-   * @return The error, or null if the most recent attempt was successful.
+   * @throws IOException The error that affected the most recent attempt to load the manifest.
    */
-  public IOException getError() {
-    if (loadExceptionCount <= 1) {
-      // Don't report an exception until at least 1 retry attempt has been made.
-      return null;
+  public void maybeThrowError() throws IOException {
+    // Don't throw an exception until at least 1 retry attempt has been made.
+    if (loadException == null || loadExceptionCount <= 1) {
+      return;
     }
-    return loadException;
+    throw loadException;
   }
 
   /**
@@ -235,6 +247,7 @@ public void requestRefresh() {
     }
     if (!loader.isLoading()) {
       currentLoadable = new UriLoadable<>(manifestUri, uriDataSource, parser);
+      currentLoadStartTimestamp = SystemClock.elapsedRealtime();
       loader.startLoading(currentLoadable, this);
       notifyManifestRefreshStarted();
     }
@@ -248,7 +261,8 @@ public void onLoadCompleted(Loadable loadable) {
     }
 
     manifest = currentLoadable.getResult();
-    manifestLoadTimestamp = SystemClock.elapsedRealtime();
+    manifestLoadStartTimestamp = currentLoadStartTimestamp;
+    manifestLoadCompleteTimestamp = SystemClock.elapsedRealtime();
     loadExceptionCount = 0;
     loadException = null;
 
@@ -282,9 +296,10 @@ public void onLoadError(Loadable loadable, IOException exception) {
     notifyManifestError(loadException);
   }
 
-  /* package */ void onSingleFetchCompleted(T result) {
+  /* package */ void onSingleFetchCompleted(T result, long loadStartTimestamp) {
     manifest = result;
-    manifestLoadTimestamp = SystemClock.elapsedRealtime();
+    manifestLoadStartTimestamp = loadStartTimestamp;
+    manifestLoadCompleteTimestamp = SystemClock.elapsedRealtime();
   }
 
   private long getRetryDelayMillis(long errorCount) {
@@ -331,6 +346,8 @@ public void run() {
     private final ManifestCallback<T> wrappedCallback;
     private final Loader singleUseLoader;
 
+    private long loadStartTimestamp;
+
     public SingleFetchHelper(UriLoadable<T> singleUseLoadable, Looper callbackLooper,
         ManifestCallback<T> wrappedCallback) {
       this.singleUseLoadable = singleUseLoadable;
@@ -340,6 +357,7 @@ public SingleFetchHelper(UriLoadable<T> singleUseLoadable, Looper callbackLooper
     }
 
     public void startLoading() {
+      loadStartTimestamp = SystemClock.elapsedRealtime();
       singleUseLoader.startLoading(callbackLooper, singleUseLoadable, this);
     }
 
@@ -347,7 +365,7 @@ public void startLoading() {
     public void onLoadCompleted(Loadable loadable) {
       try {
         T result = singleUseLoadable.getResult();
-        onSingleFetchCompleted(result);
+        onSingleFetchCompleted(result, loadStartTimestamp);
         wrappedCallback.onSingleManifest(result);
       } finally {
         releaseLoader();
diff --git a/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java b/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
index 66e44b905a..7b0d9d0d4c 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
@@ -23,7 +23,7 @@
 /**
  * Defines common MIME types and helper methods.
  */
-public class MimeTypes {
+public final class MimeTypes {
 
   public static final String BASE_TYPE_VIDEO = "video";
   public static final String BASE_TYPE_AUDIO = "audio";
@@ -32,6 +32,7 @@
 
   public static final String VIDEO_MP4 = BASE_TYPE_VIDEO + "/mp4";
   public static final String VIDEO_WEBM = BASE_TYPE_VIDEO + "/webm";
+  public static final String VIDEO_H263 = BASE_TYPE_VIDEO + "/3gpp";
   public static final String VIDEO_H264 = BASE_TYPE_VIDEO + "/avc";
   public static final String VIDEO_H265 = BASE_TYPE_VIDEO + "/hevc";
   public static final String VIDEO_VP8 = BASE_TYPE_VIDEO + "/x-vnd.on2.vp8";
diff --git a/library/src/main/java/com/google/android/exoplayer/util/PriorityHandlerThread.java b/library/src/main/java/com/google/android/exoplayer/util/PriorityHandlerThread.java
index 86f77ffa3b..d10b3055c3 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/PriorityHandlerThread.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/PriorityHandlerThread.java
@@ -21,7 +21,7 @@
 /**
  * A {@link HandlerThread} with a specified process priority.
  */
-public class PriorityHandlerThread extends HandlerThread {
+public final class PriorityHandlerThread extends HandlerThread {
 
   private final int priority;
 
diff --git a/library/src/main/java/com/google/android/exoplayer/util/SlidingPercentile.java b/library/src/main/java/com/google/android/exoplayer/util/SlidingPercentile.java
index 77294f4562..36a15101ae 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/SlidingPercentile.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/SlidingPercentile.java
@@ -31,7 +31,7 @@
  * @see <a href="http://en.wikipedia.org/wiki/Moving_average">Wiki: Moving average</a>
  * @see <a href="http://en.wikipedia.org/wiki/Selection_algorithm">Wiki: Selection algorithm</a>
  */
-public class SlidingPercentile {
+public final class SlidingPercentile {
 
   // Orderings.
   private static final Comparator<Sample> INDEX_COMPARATOR = new Comparator<Sample>() {
diff --git a/library/src/main/java/com/google/android/exoplayer/util/TraceUtil.java b/library/src/main/java/com/google/android/exoplayer/util/TraceUtil.java
index d581305c8c..3cd305bfe7 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/TraceUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/TraceUtil.java
@@ -22,7 +22,9 @@
 /**
  * Calls through to {@link android.os.Trace} methods on supported API levels.
  */
-public class TraceUtil {
+public final class TraceUtil {
+
+  private TraceUtil() {}
 
   /**
    * Writes a trace message to indicate that a given section of code has begun.
diff --git a/library/src/main/java/com/google/android/exoplayer/util/Util.java b/library/src/main/java/com/google/android/exoplayer/util/Util.java
index 2e90c4abba..c3b449034d 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/Util.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/Util.java
@@ -577,11 +577,28 @@ public static int getIntegerCodeForString(String string) {
    * @return A string containing the hex representation of the data provided.
    */
   public static String getHexStringFromBytes(byte[] data, int beginIndex, int endIndex) {
-    StringBuffer dataStringBuffer = new StringBuffer(endIndex - beginIndex);
+    StringBuilder dataStringBuilder = new StringBuilder(endIndex - beginIndex);
     for (int i = beginIndex; i < endIndex; i++) {
-      dataStringBuffer.append(String.format(Locale.US, "%02X", data[i]));
+      dataStringBuilder.append(String.format(Locale.US, "%02X", data[i]));
     }
-    return dataStringBuffer.toString();
+    return dataStringBuilder.toString();
+  }
+
+  /**
+   * Returns a string with comma delimited simple names of each object's class.
+   *
+   * @param objects The objects whose simple class names should be comma delimited and returned.
+   * @return A string with comma delimited simple names of each object's class.
+   */
+  public static <T> String getCommaDelimitedSimpleClassNames(T[] objects) {
+    StringBuilder stringBuilder = new StringBuilder();
+    for (int i = 0; i < objects.length; i++) {
+      stringBuilder.append(objects[i].getClass().getSimpleName());
+      if (i < objects.length - 1) {
+        stringBuilder.append(", ");
+      }
+    }
+    return stringBuilder.toString();
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/util/VerboseLogUtil.java b/library/src/main/java/com/google/android/exoplayer/util/VerboseLogUtil.java
index 590c1b51c0..4fe40cde5f 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/VerboseLogUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/VerboseLogUtil.java
@@ -18,14 +18,12 @@
 /**
  * Utility class for managing a set of tags for which verbose logging should be enabled.
  */
-public class VerboseLogUtil {
+public final class VerboseLogUtil {
 
   private static volatile String[] enabledTags;
   private static volatile boolean enableAllTags;
 
-  private VerboseLogUtil() {
-    // Private constructor to prevent instantiation.
-  }
+  private VerboseLogUtil() {}
 
   /**
    * Sets the tags for which verbose logging should be enabled.
