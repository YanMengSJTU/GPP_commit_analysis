diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
index a39c40eb3d..03c18c4281 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.extractor.GaplessInfo;
 import com.google.android.exoplayer.util.Ac3Util;
 import com.google.android.exoplayer.util.Assertions;
@@ -82,8 +83,10 @@ public static Track parseTrak(Atom.ContainerAtom trak, Atom.LeafAtom mvhd, boole
    * @param track Track to which this sample table corresponds.
    * @param stblAtom stbl (sample table) atom to parse.
    * @return Sample table described by the stbl atom.
+   * @throws ParserException If the resulting sample sequence does not contain a sync sample.
    */
-  public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAtom) {
+  public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAtom)
+      throws ParserException {
     // Array of sample sizes.
     ParsableByteArray stsz = stblAtom.getLeafAtomOfType(Atom.TYPE_stsz).data;
 
@@ -327,6 +330,15 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
       }
       pts += duration;
     }
+
+    boolean hasSyncSample = false;
+    for (int i = 0; i < editedFlags.length && !hasSyncSample; i++) {
+      hasSyncSample |= (editedFlags[i] & C.SAMPLE_FLAG_SYNC) != 0;
+    }
+    if (!hasSyncSample) {
+      throw new ParserException("The edited sample sequence does not contain a sync sample.");
+    }
+
     return new TrackSampleTable(editedOffsets, editedSizes, editedMaximumSize, editedTimestamps,
         editedFlags);
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
index 5710e6b0ae..379b0ec940 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer.extractor.mp4;
 
 import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.extractor.Extractor;
 import com.google.android.exoplayer.extractor.ExtractorInput;
 import com.google.android.exoplayer.extractor.ExtractorOutput;
@@ -240,7 +241,7 @@ private boolean readAtomPayload(ExtractorInput input, PositionHolder positionHol
     return seekRequired && parserState != STATE_READING_SAMPLE;
   }
 
-  private void processAtomEnded(long atomEndPosition) {
+  private void processAtomEnded(long atomEndPosition) throws ParserException {
     while (!containerAtoms.isEmpty() && containerAtoms.peek().endPosition == atomEndPosition) {
       Atom.ContainerAtom containerAtom = containerAtoms.pop();
       if (containerAtom.type == Atom.TYPE_moov) {
@@ -281,7 +282,7 @@ private static boolean processFtypAtom(ParsableByteArray atomData) {
   /**
    * Updates the stored track metadata to reflect the contents of the specified moov atom.
    */
-  private void processMoovAtom(ContainerAtom moov) {
+  private void processMoovAtom(ContainerAtom moov) throws ParserException {
     List<Mp4Track> tracks = new ArrayList<>();
     long earliestSampleOffset = Long.MAX_VALUE;
     GaplessInfo gaplessInfo = null;
