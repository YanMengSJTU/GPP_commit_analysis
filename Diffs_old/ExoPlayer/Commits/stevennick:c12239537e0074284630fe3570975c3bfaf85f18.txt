diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
index bf5b3f6482..2f21b586c5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
@@ -465,7 +465,7 @@ private void doSomeWork() throws ExoPlaybackException, IOException {
       return;
     }
 
-    TraceUtil.beginSection("doSomeWork");
+    TraceUtil.beginSection("ExoPlayerImplInternal.doSomeWork");
 
     updatePlaybackPositions();
     playingPeriodHolder.mediaPeriod.discardBuffer(playbackInfo.positionUs);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
index 48c7462b03..7cfa2dd6bb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
@@ -21,6 +21,8 @@
 import android.media.MediaFormat;
 import android.media.audiofx.Virtualizer;
 import android.os.Handler;
+import android.util.Log;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
@@ -361,6 +363,8 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
       boolean shouldSkip) throws ExoPlaybackException {
     if (passthroughEnabled && (bufferFlags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {
       // Discard output buffers from the passthrough (raw) decoder containing codec specific data.
+      String logMessage = "Release audio output buffer with bufferIndex @" + bufferIndex;
+      Log.d("MediaCodecAudioRenderer", logMessage);
       codec.releaseOutputBuffer(bufferIndex, false);
       return true;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
index ddb870f6ff..354429e610 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
@@ -211,7 +211,7 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
     if (decoder != null) {
       try {
         // Rendering loop.
-        TraceUtil.beginSection("drainAndFeed");
+        TraceUtil.beginSection("SimpleDecoderAudioRenderer.drainAndFeed");
         while (drainOutputBuffer()) {}
         while (feedInputBuffer()) {}
         TraceUtil.endSection();
@@ -528,7 +528,7 @@ private void maybeInitDecoder() throws ExoPlaybackException {
 
     try {
       long codecInitializingTimestamp = SystemClock.elapsedRealtime();
-      TraceUtil.beginSection("createAudioDecoder");
+      TraceUtil.beginSection("SimpleDecoderAudioRenderer.createAudioDecoder");
       decoder = createDecoder(inputFormat, mediaCrypto);
       TraceUtil.endSection();
       long codecInitializedTimestamp = SystemClock.elapsedRealtime();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
index dfc2b3822a..3b0c73e979 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
@@ -15,7 +15,9 @@
  */
 package com.google.android.exoplayer2.extractor;
 
+import android.app.Application;
 import android.os.Trace;
+import android.util.Log;
 
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
@@ -31,6 +33,8 @@
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.Arrays;
+import java.util.Iterator;
+import java.util.Map;
 import java.util.concurrent.LinkedBlockingDeque;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -82,6 +86,7 @@
   private int lastAllocationOffset;
   private boolean pendingSplice;
   private UpstreamFormatChangedListener upstreamFormatChangeListener;
+  private final String TAG = "DefaultTrackOutput";
 
   /**
    * @param allocator An {@link Allocator} from which allocations for sample data can be obtained.
@@ -294,9 +299,7 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer, boolea
           }
           // Write the sample data into the holder.
           buffer.ensureSpaceForWrite(extrasHolder.size);
-//          TraceUtil.beginSection("DefaultTrackOutput.readData(Move Allocation to DecodeInputBuffer):" + buffer.data.hashCode());
           readData(extrasHolder.offset, buffer.data, extrasHolder.size);
-//          TraceUtil.endSection();
           // Advance the read head.
           dropDownstreamTo(extrasHolder.nextOffset);
         }
@@ -390,15 +393,24 @@ private void readEncryptionData(DecoderInputBuffer buffer, BufferExtrasHolder ex
    */
   private void readData(long absolutePosition, ByteBuffer target, int length) {
     int remaining = length;
+    String logMessage = "";
+    logMessage = "readData(allocation -> DecodeInputBuffer.ByteBuffer)[absPos=" + absolutePosition +", len=" + length + ", rem=" + remaining + "]";
+    Log.d(TAG, logMessage);
+    TraceUtil.beginSection(logMessage);
     while (remaining > 0) {
       dropDownstreamTo(absolutePosition);
       int positionInAllocation = (int) (absolutePosition - totalBytesDropped);
       int toCopy = Math.min(remaining, allocationLength - positionInAllocation);
       Allocation allocation = dataQueue.peek();
+      logMessage = "readData(from allocation #" +allocation.id + ")[absPos=" + absolutePosition +", len=" + length + ", rem=" + remaining + "]";
+      Log.d(TAG, logMessage);
       target.put(allocation.data, allocation.translateOffset(positionInAllocation), toCopy);
       absolutePosition += toCopy;
       remaining -= toCopy;
     }
+    logMessage = "readData(allocation -> DecodeInputBuffer.ByteBuffer)[FIN, absPos=" + absolutePosition +", len=" + length + ", rem=" + remaining + "]";
+    Log.d(TAG, logMessage);
+    TraceUtil.endSection();
   }
 
   /**
@@ -415,10 +427,8 @@ private void readData(long absolutePosition, byte[] target, int length) {
       int positionInAllocation = (int) (absolutePosition - totalBytesDropped);
       int toCopy = Math.min(length - bytesRead, allocationLength - positionInAllocation);
       Allocation allocation = dataQueue.peek();
-      TraceUtil.beginSection("DefaultTrackOutput.readData(dataQueue deque): " + String.valueOf(Arrays.hashCode(allocation.data)));
       System.arraycopy(allocation.data, allocation.translateOffset(positionInAllocation), target,
           bytesRead, toCopy);
-      TraceUtil.endSection();
       absolutePosition += toCopy;
       bytesRead += toCopy;
     }
@@ -431,12 +441,18 @@ private void readData(long absolutePosition, byte[] target, int length) {
    * @param absolutePosition The absolute position up to which allocations can be discarded.
    */
   private void dropDownstreamTo(long absolutePosition) {
+    String logMessage = "DefaultTrackOutput.dropDownstreamTo(" + absolutePosition + ")";
+    Log.d(TAG, logMessage);
+    TraceUtil.beginSection(logMessage);
     int relativePosition = (int) (absolutePosition - totalBytesDropped);
     int allocationIndex = relativePosition / allocationLength;
     for (int i = 0; i < allocationIndex; i++) {
-      allocator.release(dataQueue.remove());
+      Allocation remove = dataQueue.remove();
+      Log.d(TAG, "Remove allocation #"+ remove.id + " from dataQueue[relativePosition=" + relativePosition + ", allocationIndex=" + allocationIndex +"]");
+      allocator.release(remove);
       totalBytesDropped += allocationLength;
     }
+    TraceUtil.endSection();
   }
 
   // Called by the loading thread.
@@ -489,10 +505,14 @@ public int sampleData(ExtractorInput input, int length, boolean allowEndOfInput)
     }
     try {
       length = prepareForAppend(length);
-      TraceUtil.beginSection("DefaultTrackOutput.sampleData(Fetch data from upstream): " + String.valueOf(Arrays.hashCode(lastAllocation.data)));
+//      String logMessage = "sampleData<ExtractorInput>(Fetch data from upstream to #" + lastAllocation.id + ")";
+//      Log.d(TAG, logMessage);
+//      TraceUtil.beginSection(logMessage);
       int bytesAppended = input.read(lastAllocation.data,
           lastAllocation.translateOffset(lastAllocationOffset), length);
-      TraceUtil.endSection();
+//      TraceUtil.endSection();
+//      String logMessage = "sampleData<ExtractorInput>(New data ID for allocation #" + lastAllocation.id + "): " + String.valueOf(Arrays.hashCode(lastAllocation.data));
+//      Log.d(TAG, logMessage);
       if (bytesAppended == C.RESULT_END_OF_INPUT) {
         if (allowEndOfInput) {
           return C.RESULT_END_OF_INPUT;
@@ -513,6 +533,9 @@ public void sampleData(ParsableByteArray buffer, int length) {
       buffer.skipBytes(length);
       return;
     }
+    String logMessage = "sampleData<ParsableByteArray>(upstream -> allocation)[len=" + length + "]";
+//    Log.d(TAG, logMessage);
+    TraceUtil.beginSection(logMessage);
     while (length > 0) {
       int thisAppendLength = prepareForAppend(length);
       buffer.readBytes(lastAllocation.data, lastAllocation.translateOffset(lastAllocationOffset),
@@ -521,6 +544,9 @@ public void sampleData(ParsableByteArray buffer, int length) {
       totalBytesWritten += thisAppendLength;
       length -= thisAppendLength;
     }
+    TraceUtil.endSection();
+    logMessage = "sampleData<ParsableByteArray>(upstream -> allocation)[FIN, lastId=#" + lastAllocation.id + "]";
+//    Log.d(TAG, logMessage);
     endWriteOperation();
   }
 
@@ -580,9 +606,11 @@ private int prepareForAppend(int length) {
     if (lastAllocationOffset == allocationLength) {
       lastAllocationOffset = 0;
       lastAllocation = allocator.allocate();
-      TraceUtil.beginSection("DefaultTrackOutput.prepareForAppend(dataQueue enque): " + String.valueOf(Arrays.hashCode(lastAllocation.data)));
+      String logMessage = "prepareForAppend(dataQueue enque for #" + lastAllocation.id + "): " + String.valueOf(Arrays.hashCode(lastAllocation.data));
+//      Log.d(TAG, logMessage);
+//      TraceUtil.beginSection(logMessage);
       dataQueue.add(lastAllocation);
-      TraceUtil.endSection();
+//      TraceUtil.endSection();
     }
     return Math.min(length, allocationLength - lastAllocationOffset);
   }
@@ -632,6 +660,7 @@ private static Format getAdjustedSampleFormat(Format format, long sampleOffsetUs
     private boolean upstreamFormatRequired;
     private Format upstreamFormat;
     private int upstreamSourceId;
+    private final String TAG = "TrackOutput.InfoQueue";
 
     public InfoQueue() {
       capacity = SAMPLE_CAPACITY_INCREMENT;
@@ -805,7 +834,8 @@ public synchronized int readData(FormatHolder formatHolder, DecoderInputBuffer b
       extrasHolder.size = sizes[relativeReadIndex];
       extrasHolder.offset = offsets[relativeReadIndex];
       extrasHolder.encryptionKeyId = encryptionKeys[relativeReadIndex];
-
+      String logMessage = "BufferExtractsHolder[size=" +extrasHolder.size+ ", offset="+extrasHolder.offset+"], relaIndex= " +relativeReadIndex+ ", timeUs=" + buffer.timeUs +", largeDeqTimestampUs=" + largestDequeuedTimestampUs;
+      Log.d(TAG, logMessage);
       largestDequeuedTimestampUs = Math.max(largestDequeuedTimestampUs, buffer.timeUs);
       queueSize--;
       relativeReadIndex++;
@@ -922,6 +952,7 @@ public synchronized void commitSample(long timeUs, @C.BufferFlags int sampleFlag
       sourceIds[relativeWriteIndex] = upstreamSourceId;
       // Increment the write index.
       queueSize++;
+      Log.d(TAG, "commitSample[timeUs="+timeUs+", relativeWriteIndex="+relativeWriteIndex+ ", sampleFlags="+sampleFlags+", offset="+offset+", size="+size+", queueSize="+ queueSize + "]");
       if (queueSize == capacity) {
         // Increase the capacity.
         int newCapacity = capacity + SAMPLE_CAPACITY_INCREMENT;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
index 25a5aa4dd3..222031d505 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
@@ -114,6 +114,8 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
 
   private static final String TAG = "MediaCodecRenderer";
 
+  private long loopCount;
+
   /**
    * If the {@link MediaCodec} is hotswapped (i.e. replaced during playback), this is the period of
    * time during which {@link #isReady()} will report true regardless of whether the new codec has
@@ -234,6 +236,7 @@ public MediaCodecRenderer(int trackType, MediaCodecSelector mediaCodecSelector,
     outputBufferInfo = new MediaCodec.BufferInfo();
     codecReconfigurationState = RECONFIGURATION_STATE_NONE;
     codecReinitializationState = REINITIALIZATION_STATE_NONE;
+    loopCount = 0;
   }
 
   @Override
@@ -349,13 +352,13 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
     codecNeedsMonoChannelCountWorkaround = codecNeedsMonoChannelCountWorkaround(codecName, format);
     try {
       long codecInitializingTimestamp = SystemClock.elapsedRealtime();
-      TraceUtil.beginSection("createCodec:" + codecName);
+      TraceUtil.beginSection("MediaCodecRenderer.createCodec:" + codecName);
       codec = MediaCodec.createByCodecName(codecName);
       TraceUtil.endSection();
-      TraceUtil.beginSection("configureCodec");
+      TraceUtil.beginSection("MediaCodecRenderer.configureCodec");
       configureCodec(decoderInfo, codec, format, mediaCrypto);
       TraceUtil.endSection();
-      TraceUtil.beginSection("startCodec");
+      TraceUtil.beginSection("MediaCodecRenderer.startCodec");
       codec.start();
       TraceUtil.endSection();
       long codecInitializedTimestamp = SystemClock.elapsedRealtime();
@@ -506,10 +509,11 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
     // We have a format.
     maybeInitCodec();
     if (codec != null) {
-      TraceUtil.beginSection("drainAndFeed");
+      TraceUtil.beginSection("drainAndFeed - loop " + loopCount + ", rendered:" + decoderCounters.renderedOutputBufferCount + ", skip:"+ decoderCounters.skippedOutputBufferCount + ", drop:" + decoderCounters.droppedOutputBufferCount);
       while (drainOutputBuffer(positionUs, elapsedRealtimeUs)) {}
       while (feedInputBuffer()) {}
       TraceUtil.endSection();
+      loopCount++;
     } else {
       skipSource(positionUs);
       // We need to read any format changes despite not having a codec so that drmSession can be
@@ -564,15 +568,20 @@ protected void flushCodec() throws ExoPlaybackException {
    * @throws ExoPlaybackException If an error occurs feeding the input buffer.
    */
   private boolean feedInputBuffer() throws ExoPlaybackException {
+    String logMessage = "readSource from allocation to decodeInputBuffer.";
+//    Log.d(TAG, logMessage);
+    TraceUtil.beginSection(logMessage);
     if (codec == null || codecReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM
         || inputStreamEnded) {
       // We need to reinitialize the codec or the input stream has ended.
+      TraceUtil.endSection();
       return false;
     }
 
     if (inputIndex < 0) {
       inputIndex = codec.dequeueInputBuffer(0);
       if (inputIndex < 0) {
+        TraceUtil.endSection();
         return false;
       }
       buffer.data = inputBuffers[inputIndex];
@@ -590,6 +599,7 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
         inputIndex = C.INDEX_UNSET;
       }
       codecReinitializationState = REINITIALIZATION_STATE_WAIT_END_OF_STREAM;
+      TraceUtil.endSection();
       return false;
     }
 
@@ -599,6 +609,7 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
       codec.queueInputBuffer(inputIndex, 0, ADAPTATION_WORKAROUND_BUFFER.length, 0, 0);
       inputIndex = C.INDEX_UNSET;
       codecReceivedBuffers = true;
+      TraceUtil.endSection();
       return true;
     }
 
@@ -622,6 +633,7 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
     }
 
     if (result == C.RESULT_NOTHING_READ) {
+      TraceUtil.endSection();
       return false;
     }
     if (result == C.RESULT_FORMAT_READ) {
@@ -632,6 +644,7 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
         codecReconfigurationState = RECONFIGURATION_STATE_WRITE_PENDING;
       }
       onInputFormatChanged(formatHolder.format);
+      TraceUtil.endSection();
       return true;
     }
 
@@ -647,6 +660,7 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
       inputStreamEnded = true;
       if (!codecReceivedBuffers) {
         processEndOfStream();
+        TraceUtil.endSection();
         return false;
       }
       try {
@@ -658,8 +672,10 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
           inputIndex = C.INDEX_UNSET;
         }
       } catch (CryptoException e) {
+        TraceUtil.endSection();
         throw ExoPlaybackException.createForRenderer(e, getIndex());
       }
+      TraceUtil.endSection();
       return false;
     }
     if (waitingForFirstSyncFrame && !buffer.isKeyFrame()) {
@@ -669,17 +685,20 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
         // data into a subsequent buffer (if there is one).
         codecReconfigurationState = RECONFIGURATION_STATE_WRITE_PENDING;
       }
+      TraceUtil.endSection();
       return true;
     }
     waitingForFirstSyncFrame = false;
     boolean bufferEncrypted = buffer.isEncrypted();
     waitingForKeys = shouldWaitForKeys(bufferEncrypted);
     if (waitingForKeys) {
+      TraceUtil.endSection();
       return false;
     }
     if (codecNeedsDiscardToSpsWorkaround && !bufferEncrypted) {
       NalUnitUtil.discardToSps(buffer.data);
       if (buffer.data.position() == 0) {
+        TraceUtil.endSection();
         return true;
       }
       codecNeedsDiscardToSpsWorkaround = false;
@@ -689,8 +708,10 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
       if (buffer.isDecodeOnly()) {
         decodeOnlyPresentationTimestamps.add(presentationTimeUs);
       }
-
+//      Log.d(TAG, "Queue input bufferIndex @" + inputIndex + " with ByteBuffer: " + buffer.data.hashCode());
       buffer.flip();
+//      Log.d(TAG, "New ByteBuffer bufferIndex @" + inputIndex + " hash: " + buffer.data.hashCode());
+      Log.d(TAG, "ByteBuffer bufferIndex @" + inputIndex + " queued.");
       onQueueInputBuffer(buffer);
 
       if (bufferEncrypted) {
@@ -705,8 +726,10 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
       codecReconfigurationState = RECONFIGURATION_STATE_NONE;
       decoderCounters.inputBufferCount++;
     } catch (CryptoException e) {
+      TraceUtil.endSection();
       throw ExoPlaybackException.createForRenderer(e, getIndex());
     }
+    TraceUtil.endSection();
     return true;
   }
 
@@ -714,6 +737,7 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
       int adaptiveReconfigurationBytes) {
     MediaCodec.CryptoInfo cryptoInfo = buffer.cryptoInfo.getFrameworkCryptoInfoV16();
     if (adaptiveReconfigurationBytes == 0) {
+
       return cryptoInfo;
     }
     // There must be at least one sub-sample, although numBytesOfClearData is permitted to be
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
index f247d4dd37..67cf190bfa 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
@@ -17,6 +17,7 @@
 
 import android.net.Uri;
 import android.os.Handler;
+import android.util.Log;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
@@ -40,6 +41,7 @@
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ConditionVariable;
 import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.TraceUtil;
 import com.google.android.exoplayer2.util.Util;
 import java.io.EOFException;
 import java.io.IOException;
@@ -93,6 +95,7 @@
   private int extractedSamplesCountAtStartOfLoad;
   private boolean loadingFinished;
   private boolean released;
+  private final String TAG = "ExtractorMediaPeriod";
 
   /**
    * @param uri The {@link Uri} of the media stream.
@@ -633,6 +636,7 @@ public boolean isLoadCanceled() {
     @Override
     public void load() throws IOException, InterruptedException {
       int result = Extractor.RESULT_CONTINUE;
+      String logMessage ;
       while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
         ExtractorInput input = null;
         try {
@@ -641,12 +645,21 @@ public void load() throws IOException, InterruptedException {
           if (length != C.LENGTH_UNSET) {
             length += position;
           }
+          logMessage= "new DefaultExtractorInput & SelectExtractor[initPos=" + position +", length=" + length + "](-1 mean UNKNOWN_LENGTH)";
+          Log.d(TAG, logMessage);
+          TraceUtil.beginSection(logMessage);
           input = new DefaultExtractorInput(dataSource, position, length);
           Extractor extractor = extractorHolder.selectExtractor(input, dataSource.getUri());
+          TraceUtil.endSection();
           if (pendingExtractorSeek) {
+            logMessage= "ExtractorSeek[initPos=" + position +", seekTimeUs=" + seekTimeUs + "]";
+            Log.d(TAG, logMessage);
             extractor.seek(position, seekTimeUs);
             pendingExtractorSeek = false;
           }
+          logMessage= "extractor.read[inputPos=" + input.getPosition() +", initPos=" + position + "]";
+          Log.d(TAG, logMessage);
+          TraceUtil.beginSection(logMessage);
           while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
             loadCondition.block();
             result = extractor.read(input, positionHolder);
@@ -656,6 +669,9 @@ public void load() throws IOException, InterruptedException {
               handler.post(onContinueLoadingRequestedRunnable);
             }
           }
+          TraceUtil.endSection();
+          logMessage= "extractor.read[inputPos=" + input.getPosition() +", initPos=" + position + "]";
+          Log.d(TAG, logMessage);
         } finally {
           if (result == Extractor.RESULT_SEEK) {
             result = Extractor.RESULT_CONTINUE;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/Allocation.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/Allocation.java
index 3f91b70c47..f608567ac7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/Allocation.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/Allocation.java
@@ -45,7 +45,7 @@ public Allocation(byte[] data, int offset) {
     this.data = data;
     this.offset = offset;
     this.id = this.hashCode();
-    Log.i(TAG, "New id #hash :"+ this.id);
+//    Log.i(TAG, "New id #hash :"+ this.id);
   }
 
   /**
@@ -57,7 +57,7 @@ public Allocation(byte[] data, int offset, int id) {
     this.data = data;
     this.offset = offset;
     this.id = id;
-    Log.d(TAG, "New id #id :" + this.id);
+//    Log.d(TAG, "New id #id :" + this.id);
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index dd0c5356ea..a1abfe5dbc 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -496,14 +496,14 @@ protected boolean shouldDropOutputBuffer(long earlyUs, long elapsedRealtimeUs) {
   }
 
   private void skipOutputBuffer(MediaCodec codec, int bufferIndex) {
-    TraceUtil.beginSection("skipVideoBuffer");
+    TraceUtil.beginSection("MediaCodecVideoRenderer.skipVideoBuffer");
     codec.releaseOutputBuffer(bufferIndex, false);
     TraceUtil.endSection();
     decoderCounters.skippedOutputBufferCount++;
   }
 
   private void dropOutputBuffer(MediaCodec codec, int bufferIndex) {
-    TraceUtil.beginSection("dropVideoBuffer");
+    TraceUtil.beginSection("MediaCodecVideoRenderer.dropVideoBuffer");
     codec.releaseOutputBuffer(bufferIndex, false);
     TraceUtil.endSection();
     decoderCounters.droppedOutputBufferCount++;
@@ -518,7 +518,7 @@ private void dropOutputBuffer(MediaCodec codec, int bufferIndex) {
 
   private void renderOutputBuffer(MediaCodec codec, int bufferIndex) {
     maybeNotifyVideoSizeChanged();
-    TraceUtil.beginSection("releaseOutputBuffer");
+    TraceUtil.beginSection("MediaCodecVideoRenderer.releaseOutputBuffer");
     codec.releaseOutputBuffer(bufferIndex, true);
     TraceUtil.endSection();
     decoderCounters.renderedOutputBufferCount++;
@@ -529,7 +529,9 @@ private void renderOutputBuffer(MediaCodec codec, int bufferIndex) {
   @TargetApi(21)
   private void renderOutputBufferV21(MediaCodec codec, int bufferIndex, long releaseTimeNs) {
     maybeNotifyVideoSizeChanged();
-    TraceUtil.beginSection("releaseOutputBuffer");
+    String logMessage = "release video output buffer with bufferIndex @" + bufferIndex;
+    Log.d(TAG, logMessage);
+    TraceUtil.beginSection(logMessage);
     codec.releaseOutputBuffer(bufferIndex, releaseTimeNs);
     TraceUtil.endSection();
     decoderCounters.renderedOutputBufferCount++;
