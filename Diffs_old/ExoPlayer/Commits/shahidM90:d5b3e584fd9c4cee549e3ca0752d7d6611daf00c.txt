diff --git a/demo_ext/src/main/java/com/google/android/exoplayer/demo/ext/PlayerActivity.java b/demo_ext/src/main/java/com/google/android/exoplayer/demo/ext/PlayerActivity.java
index 21350acddb..2f361c3cd4 100644
--- a/demo_ext/src/main/java/com/google/android/exoplayer/demo/ext/PlayerActivity.java
+++ b/demo_ext/src/main/java/com/google/android/exoplayer/demo/ext/PlayerActivity.java
@@ -18,7 +18,10 @@
 import com.google.android.exoplayer.AspectRatioFrameLayout;
 import com.google.android.exoplayer.ExoPlaybackException;
 import com.google.android.exoplayer.ExoPlayer;
+import com.google.android.exoplayer.MediaCodecAudioTrackRenderer;
+import com.google.android.exoplayer.MediaCodecSelector;
 import com.google.android.exoplayer.TrackRenderer;
+import com.google.android.exoplayer.ext.flac.FlacExtractor;
 import com.google.android.exoplayer.ext.flac.LibflacAudioTrackRenderer;
 import com.google.android.exoplayer.ext.opus.LibopusAudioTrackRenderer;
 import com.google.android.exoplayer.ext.vp9.LibvpxVideoTrackRenderer;
@@ -130,7 +133,7 @@ public void onPause() {
   }
 
   private void startBasicPlayback() {
-    player = ExoPlayer.Factory.newInstance(3);
+    player = ExoPlayer.Factory.newInstance(4);
     player.addListener(this);
     mediaController.setMediaPlayer(new PlayerControl(player));
     mediaController.setEnabled(true);
@@ -138,7 +141,7 @@ private void startBasicPlayback() {
         contentUri,
         new DefaultUriDataSource(this, Util.getUserAgent(this, "ExoPlayerExtWebMDemo")),
         new DefaultAllocator(BUFFER_SEGMENT_SIZE), BUFFER_SEGMENT_SIZE * BUFFER_SEGMENT_COUNT,
-        new WebmExtractor());
+        new WebmExtractor(), new FlacExtractor());
     TrackRenderer videoRenderer =
         new LibvpxVideoTrackRenderer(sampleSource, true, handler, this, 50);
     if (useOpenGL) {
@@ -153,8 +156,11 @@ private void startBasicPlayback() {
     }
     TrackRenderer opusAudioTrackRenderer = new LibopusAudioTrackRenderer(sampleSource);
     TrackRenderer flacAudioTrackRenderer = new LibflacAudioTrackRenderer(sampleSource);
+    TrackRenderer mediaCodecAudioTrackRenderer = new MediaCodecAudioTrackRenderer(sampleSource,
+        MediaCodecSelector.DEFAULT);
 
-    player.prepare(videoRenderer, opusAudioTrackRenderer, flacAudioTrackRenderer);
+    player.prepare(videoRenderer, opusAudioTrackRenderer, flacAudioTrackRenderer,
+        mediaCodecAudioTrackRenderer);
     player.setPlayWhenReady(true);
   }
 
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java
index b34f468615..f053d4d869 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java
@@ -23,29 +23,13 @@
 import java.util.List;
 
 /**
- * JNI wrapper for the libflac Flac decoder.
+ * Flac decoder.
  */
 /* package */ final class FlacDecoder extends
     SimpleDecoder<InputBuffer, FlacOutputBuffer, FlacDecoderException> {
 
-  /**
-   * Whether the underlying libflac library is available.
-   */
-  public static final boolean IS_AVAILABLE;
-  static {
-    boolean isAvailable;
-    try {
-      System.loadLibrary("flacJNI");
-      isAvailable = true;
-    } catch (UnsatisfiedLinkError exception) {
-      isAvailable = false;
-    }
-    IS_AVAILABLE = isAvailable;
-  }
-
   private final int maxOutputBufferSize;
-  private final long nativeDecoderContext;
-
+  private final NativeFlacDecoder decoder;
   /**
    * Creates a Flac decoder.
    *
@@ -61,19 +45,17 @@ public FlacDecoder(int numInputBuffers, int numOutputBuffers, List<byte[]> initi
       throw new FlacDecoderException("Wrong number of initialization data");
     }
 
-    nativeDecoderContext = flacInit();
-    if (nativeDecoderContext == 0) {
-      throw new FlacDecoderException("Failed to initialize decoder");
-    }
+    decoder = new NativeFlacDecoder();
 
-    byte[] data = initializationData.get(0);
-    boolean decoded = flacDecodeMetadata(nativeDecoderContext, data);
-    if (!decoded) {
+    ByteBuffer metadata = ByteBuffer.wrap(initializationData.get(0));
+    decoder.setData(metadata);
+    FlacStreamInfo streamInfo = decoder.decodeMetadata();
+    if (streamInfo == null) {
       throw new FlacDecoderException("Metadata decoding failed");
     }
 
-    setInitialInputBufferSize(flacGetMaxFrameSize(nativeDecoderContext));
-    maxOutputBufferSize = flacGetMaxOutputBufferSize(nativeDecoderContext);
+    setInitialInputBufferSize(streamInfo.maxFrameSize);
+    maxOutputBufferSize = streamInfo.maxDecodedFrameSize();
   }
 
   @Override
@@ -95,10 +77,11 @@ protected void releaseOutputBuffer(FlacOutputBuffer buffer) {
   public FlacDecoderException decode(InputBuffer inputBuffer, FlacOutputBuffer outputBuffer) {
     SampleHolder sampleHolder = inputBuffer.sampleHolder;
     outputBuffer.timestampUs = sampleHolder.timeUs;
+    sampleHolder.data.limit(sampleHolder.data.position());
     sampleHolder.data.position(sampleHolder.data.position() - sampleHolder.size);
     outputBuffer.init(maxOutputBufferSize);
-    int result = flacDecode(nativeDecoderContext, sampleHolder.data, sampleHolder.size,
-        outputBuffer.data, outputBuffer.data.capacity());
+    decoder.setData(sampleHolder.data);
+    int result = decoder.decodeSample(outputBuffer.data);
     if (result < 0) {
       return new FlacDecoderException("Frame decoding failed");
     }
@@ -110,20 +93,8 @@ public FlacDecoderException decode(InputBuffer inputBuffer, FlacOutputBuffer out
   @Override
   public void release() {
     super.release();
-    flacClose(nativeDecoderContext);
+    decoder.release();
   }
 
-  private native long flacInit();
-
-  private native boolean flacDecodeMetadata(long context, byte[] input);
-
-  private native int flacDecode(long context, ByteBuffer inputBuffer, int inputSize,
-      ByteBuffer outputBuffer, int outputSize);
-
-  private native void flacClose(long context);
-
-  private native int flacGetMaxOutputBufferSize(long context);
-
-  private native int flacGetMaxFrameSize(long context);
 }
 
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacExtractor.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacExtractor.java
new file mode 100644
index 0000000000..e47d91f48b
--- /dev/null
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacExtractor.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.flac;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.ExtractorOutput;
+import com.google.android.exoplayer.extractor.PositionHolder;
+import com.google.android.exoplayer.extractor.SeekMap;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.ParsableByteArray;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+/**
+ * Facilitates the extraction of data from the FLAC container format.
+ */
+public final class FlacExtractor implements Extractor {
+  /**
+   * FLAC signature: first 4 is the signature word, second 4 is the sizeof STREAMINFO. 0x22 is the
+   * mandatory STREAMINFO.
+   */
+  private static final byte[] FLAC_SIGNATURE = {'f', 'L', 'a', 'C', 0, 0, 0, 0x22};
+
+  private TrackOutput output;
+
+  private NativeFlacDecoder decoder;
+
+  private boolean metadataNotParsed;
+
+  private ParsableByteArray outputBuffer;
+  private ByteBuffer outputByteBuffer;
+
+  public FlacExtractor() {
+    metadataNotParsed = true;
+  }
+
+  @Override
+  public void init(ExtractorOutput output) {
+    this.output = output.track(0);
+    output.endTracks();
+    //TODO implement seekable
+    output.seekMap(SeekMap.UNSEEKABLE);
+
+    try {
+      decoder = new NativeFlacDecoder();
+    } catch (FlacDecoderException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @Override
+  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+    byte[] header = new byte[FLAC_SIGNATURE.length];
+    input.peekFully(header, 0, FLAC_SIGNATURE.length);
+    return Arrays.equals(header, FLAC_SIGNATURE);
+  }
+
+  @Override
+  public int read(final ExtractorInput input, PositionHolder seekPosition)
+      throws IOException, InterruptedException {
+    decoder.setData(input);
+
+    if (metadataNotParsed) {
+      FlacStreamInfo streamInfo = decoder.decodeMetadata();
+      if (streamInfo == null) {
+        throw new IOException("Metadata decoding failed");
+      }
+      metadataNotParsed = false;
+
+      MediaFormat mediaFormat = MediaFormat.createAudioFormat(null, MimeTypes.AUDIO_RAW,
+              MediaFormat.NO_VALUE, streamInfo.bitRate(), streamInfo.durationUs(),
+              streamInfo.channels, streamInfo.sampleRate, null, null);
+      output.format(mediaFormat);
+
+      outputBuffer = new ParsableByteArray(streamInfo.maxDecodedFrameSize());
+      outputByteBuffer = ByteBuffer.wrap(outputBuffer.data);
+    }
+
+    outputBuffer.reset();
+    int size = decoder.decodeSample(outputByteBuffer);
+    if (size <= 0) {
+      return RESULT_END_OF_INPUT;
+    }
+    output.sampleData(outputBuffer, size);
+
+    output.sampleMetadata(decoder.getLastSampleTimestamp(), C.SAMPLE_FLAG_SYNC, size, 0, null);
+
+    return decoder.isEndOfData() ? RESULT_END_OF_INPUT : RESULT_CONTINUE;
+  }
+
+  @Override
+  public void seek() {
+    if (!metadataNotParsed) {
+      decoder.release();
+      try {
+        decoder = new NativeFlacDecoder();
+      } catch (FlacDecoderException e) {
+        throw new RuntimeException(e);
+      }
+      metadataNotParsed = true;
+    }
+  }
+
+  @Override
+  public void release() {
+    decoder.release();
+    decoder = null;
+  }
+
+}
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacStreamInfo.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacStreamInfo.java
new file mode 100644
index 0000000000..8de58f7993
--- /dev/null
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacStreamInfo.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.flac;
+
+/**
+ * Holder for flac stream info.
+ */
+/* package */ final class FlacStreamInfo {
+  public final int minBlockSize;
+  public final int maxBlockSize;
+  public final int minFrameSize;
+  public final int maxFrameSize;
+  public final int sampleRate;
+  public final int channels;
+  public final int bitsPerSample;
+  public final long totalSamples;
+
+  public FlacStreamInfo(int minBlockSize, int maxBlockSize, int minFrameSize, int maxFrameSize,
+      int sampleRate, int channels, int bitsPerSample, long totalSamples) {
+    this.minBlockSize = minBlockSize;
+    this.maxBlockSize = maxBlockSize;
+    this.minFrameSize = minFrameSize;
+    this.maxFrameSize = maxFrameSize;
+    this.sampleRate = sampleRate;
+    this.channels = channels;
+    this.bitsPerSample = bitsPerSample;
+    this.totalSamples = totalSamples;
+  }
+
+  public int maxDecodedFrameSize() {
+    return maxBlockSize * channels * 2;
+  }
+
+  public int bitRate() {
+    return bitsPerSample * sampleRate;
+  }
+
+  public long durationUs() {
+    return (totalSamples * 1000000L) / sampleRate;
+  }
+}
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
index ad3ea4268e..662f8ba2b7 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
@@ -123,7 +123,7 @@ public LibflacAudioTrackRenderer(SampleSource source, Handler eventHandler,
    * Returns whether the underlying libflac library is available.
    */
   public static boolean isLibflacAvailable() {
-    return FlacDecoder.IS_AVAILABLE;
+    return NativeFlacDecoder.IS_AVAILABLE;
   }
 
   @Override
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/NativeFlacDecoder.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/NativeFlacDecoder.java
new file mode 100644
index 0000000000..6ec97714a6
--- /dev/null
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/NativeFlacDecoder.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.flac;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+/**
+ * JNI wrapper for the libflac Flac decoder.
+ */
+/* package */ final class NativeFlacDecoder {
+
+  /**
+   * Whether the underlying libflac library is available.
+   */
+  public static final boolean IS_AVAILABLE;
+  static {
+    boolean isAvailable;
+    try {
+      System.loadLibrary("flacJNI");
+      isAvailable = true;
+    } catch (UnsatisfiedLinkError exception) {
+      isAvailable = false;
+    }
+    IS_AVAILABLE = isAvailable;
+  }
+
+  private static final int TEMP_BUFFER_SIZE = 8192;
+
+  private final long nativeDecoderContext;
+
+  private ByteBuffer byteBufferData;
+
+  private ExtractorInput extractorInput;
+  private boolean endOfExtractorInput;
+  private byte[] tempBuffer;
+
+  public NativeFlacDecoder() throws FlacDecoderException {
+    nativeDecoderContext = flacInit();
+    if (nativeDecoderContext == 0) {
+      throw new FlacDecoderException("Failed to initialize decoder");
+    }
+  }
+
+  /**
+   * Sets data to be parsed by libflac.
+   * @param byteBufferData Source {@link ByteBuffer}
+   */
+  public void setData(ByteBuffer byteBufferData) {
+    this.byteBufferData = byteBufferData;
+    this.extractorInput = null;
+    this.tempBuffer = null;
+  }
+
+  /**
+   * Sets data to be parsed by libflac.
+   * @param extractorInput Source {@link ExtractorInput}
+   */
+  public void setData(ExtractorInput extractorInput) {
+    this.byteBufferData = null;
+    this.extractorInput = extractorInput;
+    if (tempBuffer == null) {
+      this.tempBuffer = new byte[TEMP_BUFFER_SIZE];
+    }
+    endOfExtractorInput = false;
+  }
+
+  public boolean isEndOfData() {
+    if (byteBufferData != null) {
+      return byteBufferData.remaining() == 0;
+    } else if (extractorInput != null) {
+      return endOfExtractorInput;
+    }
+    return true;
+  }
+
+  /**
+   * Reads up to {@code length} bytes from the data source.
+   * <p>
+   * This method blocks until at least one byte of data can be read, the end of the input is
+   * detected or an exception is thrown.
+   *
+   * @param target A target {@link ByteBuffer} into which data should be written.
+   * @return Returns the number of bytes read, or -1 on failure. It's not an error if this returns
+   * zero; it just means all the data read from the source.
+   */
+  public int read(ByteBuffer target) throws IOException, InterruptedException {
+    int byteCount = target.remaining();
+    if (byteBufferData != null) {
+      byteCount = Math.min(byteCount, byteBufferData.remaining());
+      int originalLimit = byteBufferData.limit();
+      byteBufferData.limit(byteBufferData.position() + byteCount);
+
+      target.put(byteBufferData);
+
+      byteBufferData.limit(originalLimit);
+    } else if (extractorInput != null) {
+      byteCount = Math.min(byteCount, TEMP_BUFFER_SIZE);
+      byteCount = extractorInput.read(tempBuffer, 0, byteCount);
+      if (byteCount == C.RESULT_END_OF_INPUT) {
+        endOfExtractorInput = true;
+        return 0;
+      }
+      target.put(tempBuffer, 0, byteCount);
+    } else {
+      return -1;
+    }
+    return byteCount;
+  }
+
+  public FlacStreamInfo decodeMetadata() {
+    return flacDecodeMetadata(nativeDecoderContext);
+  }
+
+  public int decodeSample(ByteBuffer output) {
+    return output.isDirect()
+        ? flacDecodeToBuffer(nativeDecoderContext, output)
+        : flacDecodeToArray(nativeDecoderContext, output.array());
+  }
+
+  public long getLastSampleTimestamp() {
+    return flacGetLastTimestamp(nativeDecoderContext);
+  }
+
+  public void release() {
+    flacRelease(nativeDecoderContext);
+  }
+
+  private native long flacInit();
+
+  private native FlacStreamInfo flacDecodeMetadata(long context);
+
+  private native int flacDecodeToBuffer(long context, ByteBuffer outputBuffer);
+
+  private native int flacDecodeToArray(long context, byte[] outputArray);
+
+  private native long flacGetLastTimestamp(long context);
+
+  private native void flacRelease(long context);
+
+}
diff --git a/extensions/flac/src/main/jni/data_source.cc b/extensions/flac/src/main/jni/data_source.cc
deleted file mode 100644
index 9701df0789..0000000000
--- a/extensions/flac/src/main/jni/data_source.cc
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "include/data_source.h"
-#include <android/log.h>
-#include <string.h>
-
-#define LOG_TAG "DataSource"
-#define ALOGE(...) \
-  ((void)__android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__))
-
-void DataSource::setBuffer(const void *data, const size_t size) {
-  this->data = data;
-  this->size = size;
-}
-
-ssize_t DataSource::readAt(off64_t /*offset*/, void *const data, size_t size) {
-  if (size > this->size) {
-    size = this->size;
-  }
-  memcpy(data, this->data, size);
-  this->data = reinterpret_cast<const char *>(this->data) + size;
-  this->size -= size;
-  return size;
-}
diff --git a/extensions/flac/src/main/jni/flac_jni.cc b/extensions/flac/src/main/jni/flac_jni.cc
index be21d9f057..4ee18dde62 100644
--- a/extensions/flac/src/main/jni/flac_jni.cc
+++ b/extensions/flac/src/main/jni/flac_jni.cc
@@ -22,58 +22,110 @@
 
 #include "include/flac_parser.h"
 
-#define LOG_TAG "libflac_native"
+#define LOG_TAG "NativeFlacDecoderJNI"
 #define ALOGE(...) \
   ((void)__android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__))
 #define ALOGV(...) \
   ((void)__android_log_print(ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__))
 
-#define FUNC(RETURN_TYPE, NAME, ...)                                 \
-  extern "C" {                                                       \
-  JNIEXPORT RETURN_TYPE                                              \
-      Java_com_google_android_exoplayer_ext_flac_FlacDecoder_##NAME( \
-          JNIEnv *env, jobject thiz, ##__VA_ARGS__);                 \
-  }                                                                  \
-  JNIEXPORT RETURN_TYPE                                              \
-      Java_com_google_android_exoplayer_ext_flac_FlacDecoder_##NAME( \
+#define FUNC(RETURN_TYPE, NAME, ...)                                       \
+  extern "C" {                                                             \
+  JNIEXPORT RETURN_TYPE                                                    \
+      Java_com_google_android_exoplayer_ext_flac_NativeFlacDecoder_##NAME( \
+          JNIEnv *env, jobject thiz, ##__VA_ARGS__);                       \
+  }                                                                        \
+  JNIEXPORT RETURN_TYPE                                                    \
+      Java_com_google_android_exoplayer_ext_flac_NativeFlacDecoder_##NAME( \
           JNIEnv *env, jobject thiz, ##__VA_ARGS__)
 
+class JavaDataSource : public DataSource {
+ public:
+  void setNativeFlacDecoder(JNIEnv *env, jobject nativeFlacDecoder) {
+    this->env = env;
+    this->nativeFlacDecoder = nativeFlacDecoder;
+    if (mid == NULL) {
+      jclass cls = env->GetObjectClass(nativeFlacDecoder);
+      mid = env->GetMethodID(cls, "read", "(Ljava/nio/ByteBuffer;)I");
+      env->DeleteLocalRef(cls);
+    }
+  }
+
+  ssize_t readAt(off64_t offset, void *const data, size_t size) {
+    jobject byteBuffer = env->NewDirectByteBuffer(data, size);
+    int result = env->CallIntMethod(nativeFlacDecoder, mid, byteBuffer);
+    if (env->ExceptionOccurred()) {
+      result = -1;
+    }
+    env->DeleteLocalRef(byteBuffer);
+    return result;
+  }
+
+ private:
+  JNIEnv *env;
+  jobject nativeFlacDecoder;
+  jmethodID mid;
+};
+
+struct Context {
+  JavaDataSource *source;
+  FLACParser *parser;
+};
+
 FUNC(jlong, flacInit) {
-  FLACParser *parser = new FLACParser();
-  ALOGV("flacInit parser %p", parser);
-  return reinterpret_cast<intptr_t>(parser);
+  Context *context = new Context;
+  context->source = new JavaDataSource();
+  context->parser = new FLACParser(context->source);
+  return reinterpret_cast<intptr_t>(context);
 }
 
-FUNC(jboolean, flacDecodeMetadata, jlong jContext, jbyteArray jInput) {
-  FLACParser *parser = reinterpret_cast<FLACParser *>(jContext);
-  jbyte *data = env->GetByteArrayElements(jInput, NULL);
-  jint inputSize = env->GetArrayLength(jInput);
-  ALOGV("flacDecodeMetadata byte array: %p size: %d", data, inputSize);
-  jboolean result = parser->init(data, inputSize);
-  env->ReleaseByteArrayElements(jInput, data, JNI_ABORT);
-  return result;
+FUNC(jobject, flacDecodeMetadata, jlong jContext) {
+  Context *context = reinterpret_cast<Context *>(jContext);
+  context->source->setNativeFlacDecoder(env, thiz);
+  if (!context->parser->init()) {
+    return NULL;
+  }
+
+  const FLAC__StreamMetadata_StreamInfo &streamInfo =
+      context->parser->getStreamInfo();
+
+  jclass cls = env->FindClass(
+      "com/google/android/exoplayer/ext/flac/"
+      "FlacStreamInfo");
+  jmethodID constructor = env->GetMethodID(cls, "<init>", "(IIIIIIIJ)V");
+
+  return env->NewObject(cls, constructor, streamInfo.min_blocksize,
+                        streamInfo.max_blocksize, streamInfo.min_framesize,
+                        streamInfo.max_framesize, streamInfo.sample_rate,
+                        streamInfo.channels, streamInfo.bits_per_sample,
+                        streamInfo.total_samples);
 }
 
-FUNC(jint, flacDecode, jlong jContext, jobject jInputBuffer, jint inputSize,
-     jobject jOutputBuffer, jint outputSize) {
-  FLACParser *parser = reinterpret_cast<FLACParser *>(jContext);
-  const uint8_t *inputBuffer = reinterpret_cast<const uint8_t *>(
-      env->GetDirectBufferAddress(jInputBuffer));
-  int16_t *outputBuffer =
-      reinterpret_cast<int16_t *>(env->GetDirectBufferAddress(jOutputBuffer));
-  return parser->readBuffer(inputBuffer, inputSize, outputBuffer, outputSize);
+FUNC(jint, flacDecodeToBuffer, jlong jContext, jobject jOutputBuffer) {
+  Context *context = reinterpret_cast<Context *>(jContext);
+  context->source->setNativeFlacDecoder(env, thiz);
+  void *outputBuffer = env->GetDirectBufferAddress(jOutputBuffer);
+  jint outputSize = env->GetDirectBufferCapacity(jOutputBuffer);
+  return context->parser->readBuffer(outputBuffer, outputSize);
 }
 
-FUNC(void, flacClose, jlong jContext) {
-  delete reinterpret_cast<FLACParser *>(jContext);
+FUNC(jint, flacDecodeToArray, jlong jContext, jbyteArray jOutputArray) {
+  Context *context = reinterpret_cast<Context *>(jContext);
+  context->source->setNativeFlacDecoder(env, thiz);
+  jbyte *outputBuffer = env->GetByteArrayElements(jOutputArray, NULL);
+  jint outputSize = env->GetArrayLength(jOutputArray);
+  int count = context->parser->readBuffer(outputBuffer, outputSize);
+  env->ReleaseByteArrayElements(jOutputArray, outputBuffer, 0);
+  return count;
 }
 
-FUNC(jint, flacGetMaxOutputBufferSize, jlong jContext) {
-  FLACParser *parser = reinterpret_cast<FLACParser *>(jContext);
-  return parser->getMaxOutputBufferSize();
+FUNC(jlong, flacGetLastTimestamp, jlong jContext) {
+  Context *context = reinterpret_cast<Context *>(jContext);
+  return context->parser->getLastTimestamp();
 }
 
-FUNC(jint, flacGetMaxFrameSize, jlong jContext) {
-  FLACParser *parser = reinterpret_cast<FLACParser *>(jContext);
-  return parser->getMaxFrameSize();
+FUNC(void, flacRelease, jlong jContext) {
+  Context *context = reinterpret_cast<Context *>(jContext);
+  delete context->parser;
+  delete context->source;
+  delete context;
 }
diff --git a/extensions/flac/src/main/jni/flac_parser.cc b/extensions/flac/src/main/jni/flac_parser.cc
index 19bc53c7e3..49128be0c5 100644
--- a/extensions/flac/src/main/jni/flac_parser.cc
+++ b/extensions/flac/src/main/jni/flac_parser.cc
@@ -266,8 +266,8 @@ static void copyTrespass(int16_t * /* dst */, const int *const * /* src */,
 
 // FLACParser
 
-FLACParser::FLACParser()
-    : mDataSource(new DataSource),
+FLACParser::FLACParser(DataSource *source)
+    : mDataSource(source),
       mCopy(copyTrespass),
       mDecoder(NULL),
       mCurrentPos(0LL),
@@ -288,12 +288,9 @@ FLACParser::~FLACParser() {
     FLAC__stream_decoder_delete(mDecoder);
     mDecoder = NULL;
   }
-  delete mDataSource;
 }
 
-bool FLACParser::init(const void *buffer, size_t size) {
-  mDataSource->setBuffer(buffer, size);
-
+bool FLACParser::init() {
   // setup libFLAC parser
   mDecoder = FLAC__stream_decoder_new();
   if (mDecoder == NULL) {
@@ -386,11 +383,9 @@ bool FLACParser::init(const void *buffer, size_t size) {
   return true;
 }
 
-size_t FLACParser::readBuffer(const void *buffer, size_t size, int16_t *output,
-                              size_t output_size) {
+size_t FLACParser::readBuffer(void *output, size_t output_size) {
   mWriteRequested = true;
   mWriteCompleted = false;
-  mDataSource->setBuffer(buffer, size);
 
   if (!FLAC__stream_decoder_process_single(mDecoder)) {
     ALOGE("FLACParser::readBuffer process_single failed");
@@ -429,7 +424,8 @@ size_t FLACParser::readBuffer(const void *buffer, size_t size, int16_t *output,
   }
 
   // copy PCM from FLAC write buffer to our media buffer, with interleaving.
-  (*mCopy)(output, mWriteBuffer, blocksize, getChannels());
+  (*mCopy)(reinterpret_cast<int16_t *>(output), mWriteBuffer, blocksize,
+           getChannels());
 
   // fill in buffer metadata
   CHECK(mWriteHeader.number_type == FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER);
diff --git a/extensions/flac/src/main/jni/flac_sources.mk b/extensions/flac/src/main/jni/flac_sources.mk
index a42c152129..ade9daa359 100644
--- a/extensions/flac/src/main/jni/flac_sources.mk
+++ b/extensions/flac/src/main/jni/flac_sources.mk
@@ -15,7 +15,6 @@
 #
 
 FLAC_SOURCES = \
-  data_source.cc                                 \
   flac_jni.cc                                    \
   flac_parser.cc                                 \
   flac/src/libFLAC/bitmath.c                     \
diff --git a/extensions/flac/src/main/jni/include/data_source.h b/extensions/flac/src/main/jni/include/data_source.h
index 930f35577e..175431dd7a 100644
--- a/extensions/flac/src/main/jni/include/data_source.h
+++ b/extensions/flac/src/main/jni/include/data_source.h
@@ -17,20 +17,15 @@
 #ifndef INCLUDE_DATA_SOURCE_H_
 #define INCLUDE_DATA_SOURCE_H_
 
+#include <jni.h>
 #include <sys/types.h>
 
 class DataSource {
  public:
-  void setBuffer(const void *data, const size_t size);
-
   // Returns the number of bytes read, or -1 on failure. It's not an error if
   // this returns zero; it just means the given offset is equal to, or
   // beyond, the end of the source.
-  ssize_t readAt(off64_t /*offset*/, void *const data, size_t size);
-
- private:
-  const void *data;
-  size_t size;
+  virtual ssize_t readAt(off64_t offset, void* const data, size_t size) = 0;
 };
 
 #endif  // INCLUDE_DATA_SOURCE_H_
diff --git a/extensions/flac/src/main/jni/include/flac_parser.h b/extensions/flac/src/main/jni/include/flac_parser.h
index 19905c1ed7..7739815c49 100644
--- a/extensions/flac/src/main/jni/include/flac_parser.h
+++ b/extensions/flac/src/main/jni/include/flac_parser.h
@@ -28,10 +28,10 @@ typedef int status_t;
 
 class FLACParser {
  public:
-  FLACParser();
+  FLACParser(DataSource *source);
   ~FLACParser();
 
-  bool init(const void *buffer, size_t size);
+  bool init();
 
   // stream properties
   unsigned getMaxBlockSize() const { return mStreamInfo.max_blocksize; }
@@ -39,13 +39,15 @@ class FLACParser {
   unsigned getChannels() const { return mStreamInfo.channels; }
   unsigned getBitsPerSample() const { return mStreamInfo.bits_per_sample; }
   FLAC__uint64 getTotalSamples() const { return mStreamInfo.total_samples; }
-  unsigned getMaxOutputBufferSize() const {
-    return getMaxBlockSize() * getChannels() * sizeof(int16_t);
+  const FLAC__StreamMetadata_StreamInfo &getStreamInfo() const {
+    return mStreamInfo;
   }
-  unsigned getMaxFrameSize() const { return mStreamInfo.max_framesize; }
 
-  size_t readBuffer(const void *buffer, size_t size, int16_t *output,
-                    size_t output_size);
+  int64_t getLastTimestamp() const {
+    return (1000000LL * mWriteHeader.number.sample_number) / getSampleRate();
+  }
+
+  size_t readBuffer(void *output, size_t output_size);
 
  private:
   DataSource *mDataSource;
diff --git a/extensions/flac/src/main/proguard.cfg b/extensions/flac/src/main/proguard.cfg
index 190e32d539..971663d76e 100644
--- a/extensions/flac/src/main/proguard.cfg
+++ b/extensions/flac/src/main/proguard.cfg
@@ -4,3 +4,8 @@
 -keepclasseswithmembernames class * {
     native <methods>;
 }
+
+# Some members of this class are being accessed from native methods. Keep them unobfuscated.
+-keep class com.google.android.exoplayer.ext.flac.NativeFlacDecoder {
+    *;
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
index 528e762cb9..0075ff55b8 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
@@ -59,6 +59,8 @@
  * <li>MPEG PS ({@link com.google.android.exoplayer.extractor.ts.PsExtractor})</li>
  * <li>FLV ({@link com.google.android.exoplayer.extractor.flv.FlvExtractor})</li>
  * <li>WAV ({@link com.google.android.exoplayer.extractor.wav.WavExtractor})</li>
+ * <li>FLAC ({@link com.google.android.exoplayer.ext.flac.FlacExtractor}) (only available if the
+ * flac extension is built and included)</li>
  * </ul>
  *
  * <p>Seeking in AAC, MPEG TS and FLV streams is not supported.
@@ -190,6 +192,13 @@ public UnrecognizedInputFormatException(Extractor[] extractors) {
     } catch (ClassNotFoundException e) {
       // Extractor not found.
     }
+    try {
+      DEFAULT_EXTRACTOR_CLASSES.add(
+          Class.forName("com.google.android.exoplayer.ext.flac.FlacExtractor")
+              .asSubclass(Extractor.class));
+    } catch (ClassNotFoundException e) {
+      // Extractor not found.
+    }
   }
 
   private final ExtractorHolder extractorHolder;
